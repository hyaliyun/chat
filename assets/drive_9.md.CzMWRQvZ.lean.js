import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-bb62529d"]]),S=JSON.parse('[{"question":"# Coding Assessment Question Scenario As part of a data validation system, you need to implement a function that verifies if a given string is a valid identifier. A valid identifier must start with a letter (either uppercase or lowercase) or an underscore (`_`), and the remaining characters may be letters, digits (`0-9`), or underscores. Identifiers can\'t be empty, and they must be no longer than 100 characters. Task Implement a function `is_valid_identifier` that checks if the given input string `s` is a valid identifier according to the rules specified. Input - A single string `s` (length between 0 and 100). Output - A boolean `True` if the string `s` is a valid identifier and `False` otherwise. Constraints - The input string can contain uppercase letters (`A-Z`), lowercase letters (`a-z`), digits (`0-9`), and underscores (`_`). Examples ```python >>> is_valid_identifier(\\"variable1\\") True >>> is_valid_identifier(\\"_value\\") True >>> is_valid_identifier(\\"1stValue\\") False >>> is_valid_identifier(\\"Var_123\\") True >>> is_valid_identifier(\\"invalid-char!\\") False >>> is_valid_identifier(\\"\\") False ``` Implementation ```python def is_valid_identifier(s: str) -> bool: Check if the given string is a valid identifier. if not s or len(s) > 100: return False if not (s[0].isalpha() or s[0] == \'_\'): return False for char in s[1:]: if not (char.isalnum() or char == \'_\'): return False return True # Sample test cases to validate your function assert is_valid_identifier(\\"variable1\\") == True assert is_valid_identifier(\\"_value\\") == True assert is_valid_identifier(\\"1stValue\\") == False assert is_valid_identifier(\\"Var_123\\") == True assert is_valid_identifier(\\"invalid-char!\\") == False assert is_valid_identifier(\\"\\") == False print(\\"All tests passed!\\") ```","solution":"def is_valid_identifier(s: str) -> bool: Check if the given string is a valid identifier. if not s or len(s) > 100: return False if not (s[0].isalpha() or s[0] == \'_\'): return False for char in s[1:]: if not (char.isalnum() or char == \'_\'): return False return True"},{"question":"# Keyword Count in Paragraph You are provided with a text file `paragraph.txt`, containing a single paragraph of text. Your task is to find the frequency of a pre-defined set of keywords within this paragraph. # Instructions 1. Read `paragraph.txt` and extract the text. 2. Normalize the text by converting it to lowercase and removing any punctuation. 3. Define a set of keywords to search for within the paragraph. 4. Count the occurrence of each keyword in the paragraph. # Example Consider the following content in `paragraph.txt`: ``` \\"Python is a widely used high-level programming language for general-purpose programming. Created by Guido van Rossum and first released in 1991, Python has a design philosophy that emphasizes code readability.\\" ``` If the set of keywords is `{\\"python\\", \\"programming\\", \\"design\\", \\"readability\\"}`: - \\"python\\" occurs 2 times - \\"programming\\" occurs 2 times - \\"design\\" occurs 1 time - \\"readability\\" occurs 1 time # Objective Write a Python function `count_keywords_in_paragraph` that takes the file path and a set of keywords as input, processes the paragraph, and returns a dictionary with the count of each keyword. ```python def count_keywords_in_paragraph(file_path: str, keywords: set) -> dict: Counts the occurrences of each keyword in the given file. :param file_path: Path to the text file containing the paragraph. :param keywords: A set of keywords to count. :return: A dictionary with keywords as keys and their counts as values. # Your implementation goes here. pass # Example usage: # result = count_keywords_in_paragraph(\\"path_to_your_paragraph.txt\\", {\\"python\\", \\"programming\\", \\"design\\", \\"readability\\"}) # print(result) # Expected output: {\'python\': 2, \'programming\': 2, \'design\': 1, \'readability\': 1} ``` # Constraints 1. The function should handle textual input efficiently. 2. Assume the file contains a single text paragraph. 3. The text only consists of English alphabet letters, spaces, and standard punctuation. 4. Keyword matching should be case-insensitive.","solution":"import string def count_keywords_in_paragraph(file_path: str, keywords: set) -> dict: Counts the occurrences of each keyword in the given file. :param file_path: Path to the text file containing the paragraph. :param keywords: A set of keywords to count. :return: A dictionary with keywords as keys and their counts as values. # Initialize a dictionary to keep count of each keyword keyword_counts = {keyword: 0 for keyword in keywords} # Read and process the paragraph text with open(file_path, \'r\') as file: paragraph = file.read().strip().lower() # Remove punctuation from the text translator = str.maketrans(\'\', \'\', string.punctuation) normalized_text = paragraph.translate(translator) # Split the text into words words = normalized_text.split() # Count occurrences of each keyword for word in words: if word in keyword_counts: keyword_counts[word] += 1 return keyword_counts"},{"question":"# Coding Assessment Question **Title**: Longest Harmonious Subsequence **Context**: You are developing a feature for a data analysis tool that helps identify patterns within numerical datasets. One of the features requires finding the longest harmonious subsequence in a list of integers. A harmonious subsequence is defined as a subsequence where the difference between its maximum and minimum values is exactly 1. **Task**: Write a function `findLHS` that takes a list of integers and returns the length of the longest harmonious subsequence. **Input**: - `nums`: a list of integers. **Output**: - An integer representing the length of the longest harmonious subsequence. **Constraints**: - All integers in the list are within the range of [-10^9, 10^9]. - The length of the list is at most 10^4. **Example**: ```python nums = [1,3,2,2,5,2,3,7] print(findLHS(nums)) ``` **Expected Output**: ``` 5 ``` **Explanation**: The longest harmonious subsequence is [3, 2, 2, 2, 3]. **Notes**: - A subsequence is derived from the list by deleting some or no elements without changing the order of the remaining elements. - Consider edge cases, such as when the list is empty or has only one element. **Hint**: - You may find it helpful to use a frequency counter or dictionary to track occurrences of each number, and then look for pairs of consecutive numbers to determine the length of the potential harmonious subsequences.","solution":"def findLHS(nums): Returns the length of the longest harmonious subsequence in the list of integers. if not nums: return 0 num_count = {} for num in nums: num_count[num] = num_count.get(num, 0) + 1 max_length = 0 for num in num_count: if num + 1 in num_count: current_length = num_count[num] + num_count[num + 1] max_length = max(max_length, current_length) return max_length"},{"question":"# Task Implement a function `flatten_and_filter(lst: list, threshold: int) -> list` that flattens a nested list of integers and filters out any integers that are less than or equal to a given threshold. # Input - `lst`: A list of integers, which might also contain other lists of integers nested to an arbitrary depth. - `threshold`: An integer to filter out numbers less than or equal to it. # Output - Return a flat list of integers that are greater than the threshold. # Constraints - The function should handle lists nested to arbitrary depths. - Aim for O(n) time complexity where n is the number of elements in the list. - Ensure the approach utilizes O(n) additional space, where n is the total number of elements, given that they need to be stored in the output list. # Example ```python >>> flatten_and_filter([1, [2, [3, 4], 5], 6, [7, 8]], 4) [5, 6, 7, 8] >>> flatten_and_filter([[-1, 2, [3]], 0, 4], 0) [2, 3, 4] >>> flatten_and_filter([[10, 20, [30]], [5]], 25) [30] >>> flatten_and_filter([], 3) [] ``` # Notes - Your solution should effectively traverse the nested list structure and apply the threshold filter simultaneously. - Consider edge cases such as deeply nested empty lists or lists containing only elements below the threshold.","solution":"def flatten_and_filter(lst, threshold): def flatten(lst): for item in lst: if isinstance(item, list): yield from flatten(item) else: yield item return [item for item in flatten(lst) if item > threshold]"},{"question":"# Coding Assessment Question Context: Linked lists are a fundamental data structure, allowing efficient insertion and deletion operations. They are widely used in various applications, including memory management and implementation of complex data structures like stacks and queues. Understanding how to manipulate linked lists is essential for solving advanced coding problems. Task: Implement a function `remove_duplicates_from_sorted_linked_list(head: ListNode) -> ListNode` that removes duplicates from a sorted singly linked list and returns the head of the modified list. Function Signature: ```python def remove_duplicates_from_sorted_linked_list(head: ListNode) -> ListNode: pass ``` Input: - `head` (ListNode): The head node of a singly linked list, where each node contains an integer value and a reference to the next node. Output: - The function should return the head of the modified list after removing all duplicate values. Constraints: - The linked list is sorted in non-decreasing order. - The linked list may contain up to 10^4 nodes. - Each node\'s value is an integer within the range of -10^4 to 10^4. Examples: ```python # Example 1 # Input: 1 -> 1 -> 2 # Output: 1 -> 2 head1 = ListNode(1, ListNode(1, ListNode(2))) head1 = remove_duplicates_from_sorted_linked_list(head1) # Expected output: # head1: 1 -> 2 # Example 2 # Input: 1 -> 1 -> 2 -> 3 -> 3 # Output: 1 -> 2 -> 3 head2 = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3))))) head2 = remove_duplicates_from_sorted_linked_list(head2) # Expected output: # head2: 1 -> 2 -> 3 # Example 3 # Input: 4 -> 4 -> 4 -> 4 # Output: 4 head3 = ListNode(4, ListNode(4, ListNode(4, ListNode(4)))) head3 = remove_duplicates_from_sorted_linked_list(head3) # Expected output: # head3: 4 ``` Helper Class Definition: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Notes: - The input list is guaranteed to be sorted. - The function should not create any new nodes; it should mutate the existing nodes to remove duplicates. Hint: * Use a two-pointer approach to compare and skip nodes containing duplicate values.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_from_sorted_linked_list(head: ListNode) -> ListNode: current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"# Array Reversal In-Place You need to create a function that reverses an array of integers in place. In place means that you should not use any extra space for another array to copy the elements. Design a function named `reverse_array(arr: List[int]) -> None`. Requirements: 1. The function should accept a list of integers and reverse the elements within the same list. 2. The algorithm must have O(n) time complexity where n is the number of elements in the list. 3. You should modify the input list directly without using extra space for another array or list. Constraints: - The array\'s length can range from `0` to `10^6`. - The elements of the array are integers in the range `-10^9 to 10^9`. Expected Input and Output: ```python >>> arr = [1, 2, 3, 4] >>> reverse_array(arr) >>> arr [4, 3, 2, 1] >>> arr = [1] >>> reverse_array(arr) >>> arr [1] >>> arr = [] >>> reverse_array(arr) >>> arr [] >>> arr = [7, -3, 22, 0, 5] >>> reverse_array(arr) >>> arr [5, 0, 22, -3, 7] >>> arr = [12, 75, -58, 100, 92] >>> reverse_array(arr) >>> arr [92, 100, -58, 75, 12] ```","solution":"from typing import List def reverse_array(arr: List[int]) -> None: Reverses the elements of the input list in place. Args: arr: A list of integers. Returns: None left, right = 0, len(arr) - 1 while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1"},{"question":"# Problem Statement: You are working on a performance tracking system for athletes, and one of the requirements is to calculate the top average scores among multiple athletes over several events. You need to implement a function that processes the scores and determines which athletes have the top average scores, in descending order. # Requirements: 1. **Input Format**: Your function should accept a list of dictionaries, where each dictionary contains: - Athlete\'s name (as a string). - A list of scores (as floats) from different events. 2. **Return Value**: The function should return a list of athlete names sorted by their average scores in descending order. In case of a tie in average scores, maintain the names in their original input order. 3. **Error Handling**: If any dictionary does not contain the required keys or has invalid data types, your function should raise a `ValueError` with a meaningful message indicating the issue. # Constraints: * The input list can have up to 10^4 dictionaries. * Each list of scores will contain between 1 and 50 scores. # Function Signature: ```python def top_athletes(athletes: list[dict[str, list[float]]]) -> list[str]: pass ``` # Example: ```python athletes_list = [ {\\"name\\": \\"Alice\\", \\"scores\\": [9.5, 8.0, 8.5]}, {\\"name\\": \\"Bob\\", \\"scores\\": [6.0, 7.5, 8.0]}, {\\"name\\": \\"Charlie\\", \\"scores\\": [9.0, 9.0, 9.0]}, {\\"name\\": \\"Denise\\", \\"scores\\": [9.5, 9.5]}, ] # The function call should return: # [\\"Denise\\", \\"Charlie\\", \\"Alice\\", \\"Bob\\"] ``` # Task: Implement the `top_athletes` function which takes a list of athlete dictionaries and returns a list of names sorted by their average scores in descending order. # Hint: Use Python\'s built-in functions to calculate averages and sort the list of athletes accordingly. Avoid redundant calculations by storing intermediate results as needed during processing.","solution":"def top_athletes(athletes): Returns a list of athlete names sorted by their average scores in descending order. if not isinstance(athletes, list): raise ValueError(\\"Input should be a list of dictionaries.\\") for athlete in athletes: if not isinstance(athlete, dict): raise ValueError(\\"Each athlete entry should be a dictionary.\\") if \'name\' not in athlete or \'scores\' not in athlete: raise ValueError(\\"Each athlete dictionary must contain \'name\' and \'scores\' keys.\\") if not isinstance(athlete[\'name\'], str): raise ValueError(\\"Athlete name should be a string.\\") if not isinstance(athlete[\'scores\'], list) or not all(isinstance(score, (int, float)) for score in athlete[\'scores\']): raise ValueError(\\"Scores should be a list of floats or ints.\\") if len(athlete[\'scores\']) == 0: raise ValueError(\\"Scores list should not be empty.\\") athlete_avg_scores = [(athlete[\'name\'], sum(athlete[\'scores\']) / len(athlete[\'scores\'])) for athlete in athletes] sorted_athletes = sorted(athlete_avg_scores, key=lambda x: x[1], reverse=True) return [athlete[0] for athlete in sorted_athletes]"},{"question":"# Scenario: You are developing a feature for an image processing software that helps users quickly determine the amount of \\"whitespace\\" in an image. For simplicity, we define \\"whitespace\\" as any pixel with a grayscale value above a certain threshold. Write a function that calculates the percentage of white pixels in a given image represented as a 2D list of integers. Each integer represents the grayscale value of a pixel (ranging from 0 to 255). You will also be given the threshold value that determines whether a pixel is considered \\"white\\". # Function Specification **Function name**: `calculate_whitespace_percentage` **Input**: - `image` (List[List[int]]): A 2D list of integers representing the grayscale values of the image pixels. - `threshold` (int): An integer value between 0 and 255. **Output**: - (float): The percentage of white pixels in the image (as a float). **Constraints**: - The image will have at least one pixel and at most 1,000,000 pixels. - Each pixel\'s grayscale value will be between 0 and 255. - The threshold will be between 0 and 255. **Examples**: ```python >>> calculate_whitespace_percentage([[255, 200], [150, 100]], 150) 50.0 >>> calculate_whitespace_percentage([[255, 255], [255, 255]], 200) 100.0 >>> calculate_whitespace_percentage([[0, 50], [100, 150]], 100) 25.0 ``` # Task: Complete the implementation of the `calculate_whitespace_percentage` function to accurately compute the required percentage based on the given image and threshold.","solution":"def calculate_whitespace_percentage(image, threshold): Calculates the percentage of white pixels in the image given a threshold. Args: image (list of list of int): 2D list representing the grayscale values of image pixels. threshold (int): The grayscale value threshold above which pixels are considered white. Returns: float: The percentage of white pixels in the image. total_pixels = sum([len(row) for row in image]) white_pixels = sum([1 for row in image for pixel in row if pixel > threshold]) return (white_pixels / total_pixels) * 100"},{"question":"# Task: Implement a LRU (Least Recently Used) Cache for a Web Application # Problem Statement You are tasked with implementing a Least Recently Used (LRU) cache to optimize the performance of a web application by caching frequent resource requests. The cache should have a fixed capacity and should efficiently handle the operations of adding a new resource, retrieving an existing resource, and evicting the least recently used resource when the cache reaches its capacity. Requirements 1. **LRU Cache Class**: - Initialize the cache with a fixed capacity. - Use an appropriate data structure to keep track of the usage order of cached items. 2. **LRU Cache Operations**: - **Insert**: - Insert a resource with a given key and value. - If the cache is at capacity, evict the least recently used resource before inserting the new resource. - Mark the newly inserted resource as the most recently used. - **Retrieve**: - Retrieve a resource by its key. - If the resource is found, mark it as the most recently used. - Return `None` if the resource is not found. - **Eviction**: - Evict the least recently used resource when the cache reaches its capacity. 3. **Edge Cases**: - Handle retrieval of a resource that is not present in the cache. - Ensure that the cache can successfully insert and retrieve resources up to its capacity. - Maintain performance for frequent insertions and retrievals. Implementation Details - Implement the `LRUCache` class with the following methods: - `__init__(capacity: int)`: Initialize the LRU cache with the given capacity. - `put(key: str, value: str) -> None`: Insert a resource into the cache. - `get(key: str) -> str | None`: Retrieve a resource by its key. Return `None` if the resource is not found. Example Usage ```python cache = LRUCache(2) # Insert cache.put(\\"page_1\\", \\"Content of Page 1\\") cache.put(\\"page_2\\", \\"Content of Page 2\\") # Retrieve assert cache.get(\\"page_1\\") == \\"Content of Page 1\\" assert cache.get(\\"page_3\\") is None # Insert causing eviction cache.put(\\"page_3\\", \\"Content of Page 3\\") # Retrieve after eviction assert cache.get(\\"page_1\\") is None # page_1 should be evicted assert cache.get(\\"page_2\\") == \\"Content of Page 2\\" assert cache.get(\\"page_3\\") == \\"Content of Page 3\\" ``` Ensure that your implementation adheres to the given requirements and efficiently manages the LRU cache operations of insertion, retrieval, and eviction.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: str) -> str | None: if key not in self.cache: return None self.cache.move_to_end(key) # Mark as most recently used return self.cache[key] def put(self, key: str, value: str) -> None: if key in self.cache: self.cache.move_to_end(key) # Mark as most recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Evict least recently used item"},{"question":"# Problem Statement You are tasked with implementing a function `count_valid_triangles(arr: List[int]) -> int` that counts the number of valid triangles formed by the elements of the array. A triangle is considered valid if the sum of any two sides is greater than the third side. # Input Format - A list of integers `arr` of length `n`: - `arr` (1 <= n <= 10^4) - Each element `arr[i]` (1 <= arr[i] <= 10^6) # Output Format - An integer representing the number of valid triangles. # Constraints - The number of triangles possible is determined by checking every combination of triplets `(i, j, k)` where `0 <= i < j < k < n`. - Optimize your solution to handle the upper limits of the constraints. # Detailed Explanation - You are given an array `arr`. The task is to determine how many valid triangles can be formed using three different elements of the array as sides. - A triangle is valid if and only if for three sides `a`, `b`, and `c`, the following conditions hold: - a + b > c - a + c > b - b + c > a - You need to count all such valid triangles among the given elements. # Performance Requirements - The solution should run efficiently for values up to the upper limits specified in the constraints. # Example ```python from typing import List def count_valid_triangles(arr: List[int]) -> int: # Your code goes here pass # Test cases print(count_valid_triangles([4, 6, 3, 7])) # Expected output: 3 print(count_valid_triangles([10, 21, 22, 100])) # Expected output: 1 print(count_valid_triangles([1, 1, 1, 1])) # Expected output: 4 print(count_valid_triangles([2, 2, 2, 2])) # Expected output: 4 ``` # Notes - Make use of sorting and two-pointer technique to optimize the determination of valid triangles. - Ensure to include tests covering edge cases such as: - Arrays with fewer than three elements. - Arrays where all elements are the same. - Arrays with large differences between the smallest and largest elements.","solution":"from typing import List def count_valid_triangles(arr: List[int]) -> int: arr.sort() n = len(arr) count = 0 for i in range(n-2): k = i + 2 for j in range(i + 1, n-1): while k < n and arr[i] + arr[j] > arr[k]: k += 1 count += k - j - 1 return count"},{"question":"# Coding Question: Data Structure Manipulation with Segment Trees In competitive programming and advanced algorithmic challenges, Segment Trees are invaluable for efficiently solving range queries and updates. Your task is to implement a Segment Tree that supports both point updates and range minimum queries (RMQ). # Requirements: - Implement the class `SegmentTree`. - Implement the method `__init__(self, data: List[int])`, which constructs the segment tree from the given list `data`. - Implement the method `update(self, index: int, value: int)`, which updates the element at `index` with `value`. - Implement the method `range_min_query(self, left: int, right: int) -> int`, which returns the minimum value in the range `[left, right]` (inclusive). # Input: - `data`: A list of integers representing initial array values. - `index`, `value`: An integer position in the array and the new value to update it with. - `left`, `right`: The range [left, right] for which the minimum is queried. # Output: - A class with method implementations to handle range minimum queries and point updates efficiently. # Constraints: - The input list `data` will have a length between 1 and (10^5). - The values within `data`, `value`, and elements of `range_min_query` will be integers within the range of ([-10^9, 10^9]). - The number of `update` and `range_min_query` operations will not exceed (10^5). # Example: ```python class SegmentTree: def __init__(self, data: List[int]): # Your initialization implementation here. pass def update(self, index: int, value: int): # Your update implementation here. pass def range_min_query(self, left: int, right: int) -> int: # Your range minimum query implementation here. pass # Example Usage: data = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(data) print(segment_tree.range_min_query(1, 4)) # Example Output: 3 segment_tree.update(3, 2) print(segment_tree.range_min_query(1, 4)) # Example Output: 2 segment_tree.update(5, 0) print(segment_tree.range_min_query(0, 5)) # Example Output: 0 segment_tree.update(0, -5) print(segment_tree.range_min_query(0, 3)) # Example Output: -5 ``` # Additional Context: In this problem, your solution must demonstrate efficient construction, update, and query mechanisms for Segment Trees. The primary goal is to ensure the operations `update` and `range_min_query` are optimized logarithmically relative to the size of the input data. This question tests your ability to manipulate and implement fundamental data structures, specifically Segment Trees, to manage dynamic array queries efficiently.","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves of the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update element at index to value pos = self.n + index self.tree[pos] = value # Update the tree upwards while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_min_query(self, left, right): # Perform RMQ between indices left and right inclusive left += self.n right += self.n + 1 min_value = float(\'inf\') while left < right: if left % 2: min_value = min(min_value, self.tree[left]) left += 1 if right % 2: right -= 1 min_value = min(min_value, self.tree[right]) left //= 2 right //= 2 return min_value"},{"question":"# Problem Description You have been given a list of students with their grades in multiple subjects. You need to write a function that calculates the average grade for each student, determines the class topper, and returns a tuple containing the name of the topper along with their average grade. # Function Signature ```python def find_class_topper(students: list[dict[str, [str, list[float]]]]) -> tuple[str, float]: ``` # Parameters - **students** (list): A list of dictionaries, where each dictionary represents a student. Each dictionary contains two keys: - `\'name\'` (str): The name of the student. - `\'grades\'` (list): A list of floats representing the student\'s grades in various subjects. # Returns - Returns a tuple with the name of the student who has the highest average grade, and their average grade as a float. # Constraints - All names are unique. - Each student has at least one grade. - The grade lists will contain only non-negative floating point numbers. # Examples ```python >>> find_class_topper([ {\'name\': \'Alice\', \'grades\': [88.5, 92.0, 79.0]}, {\'name\': \'Bob\', \'grades\': [80.0, 82.5, 91.0]}, {\'name\': \'Charlie\', \'grades\': [85.0, 88.5, 91.5]} ]) (\'Charlie\', 88.33) >>> find_class_topper([ {\'name\': \'Emma\', \'grades\': [70.0, 85.0]}, {\'name\': \'Liam\', \'grades\': [90.0, 91.5]}, {\'name\': \'Olivia\', \'grades\': [95.0, 85.0]} ]) (\'Liam\', 90.75) ``` # Additional Notes - Consider edge cases such as a single student, very high or very low grades, etc. - Ensure that the average grade is rounded to two decimal places before determining the topper.","solution":"def find_class_topper(students): Returns the name and average grade of the class topper. Args: students (list): List of dictionaries containing student names and their grades. Returns: tuple: A tuple containing the name of the student with the highest average grade and their average grade. topper = None highest_avg = float(\'-inf\') for student in students: average_grade = sum(student[\'grades\']) / len(student[\'grades\']) if average_grade > highest_avg: highest_avg = average_grade topper = student[\'name\'] return (topper, round(highest_avg, 2))"},{"question":"**Context**: You\'re working on a project that requires implementing a recommendation system using collaborative filtering. The goal is to predict the ratings that a user might give to various items (movies, products, etc.) based on their past interactions as well as the interactions of other users. **Task**: Your task is to implement the key functions to load the dataset, preprocess it, build a collaborative filtering model using Singular Value Decomposition (SVD), and predict the ratings. 1. Write a function `load_and_prepare_data` to load the dataset, split it into a user-item interaction matrix, and preprocess it for the SVD model. 2. Implement a `train_svd` function to train an SVD model using the interaction matrix. 3. Write a function called `predict_ratings` to predict the ratings for a given user. **Function Specifications**: 1. `load_and_prepare_data(file_path: str) -> tuple` - Loads the dataset from a CSV file with columns [\'user_id\', \'item_id\', \'rating\']. - Converts the dataset into a user-item interaction matrix. - Normalizes the matrix by filling in missing values (e.g., with zeros or user/item averages). - Returns the user-item interaction matrix. 2. `train_svd(interaction_matrix: np.ndarray, n_factors: int) -> tuple` - Trains an SVD model with the specified number of factors (latent features). - Returns the decomposed matrices ( U ), ( Sigma ), and ( V^T ) from the SVD. 3. `predict_ratings(user_id: int, U: np.ndarray, Sigma: np.ndarray, Vt: np.ndarray) -> np.ndarray` - Predicts ratings for all items for the given user based on the SVD decomposed matrices. - Returns an array with the predicted ratings for the user. **Constraints**: - Use `numpy` for matrix operations. **Example**: ```python import numpy as np import pandas as pd from scipy.sparse.linalg import svds def load_and_prepare_data(file_path: str) -> np.ndarray: df = pd.read_csv(file_path) interaction_matrix = df.pivot(index=\'user_id\', columns=\'item_id\', values=\'rating\').fillna(0) return interaction_matrix.values def train_svd(interaction_matrix: np.ndarray, n_factors: int) -> tuple: U, Sigma, Vt = svds(interaction_matrix, k=n_factors) return U, Sigma, Vt def predict_ratings(user_id: int, U: np.ndarray, Sigma: np.ndarray, Vt: np.ndarray) -> np.ndarray: user_ratings = np.dot(np.dot(U[user_id, :], np.diag(Sigma)), Vt) return user_ratings def main(): interaction_matrix = load_and_prepare_data(\'ratings.csv\') U, Sigma, Vt = train_svd(interaction_matrix, n_factors=50) user_id = 0 # Example user ID predicted_ratings = predict_ratings(user_id, U, Sigma, Vt) print(predicted_ratings) if __name__ == \\"__main__\\": main() ``` This question will test your ability to handle matrix operations, data preprocessing, and understanding of collaborative filtering using SVD.","solution":"import numpy as np import pandas as pd from scipy.sparse.linalg import svds def load_and_prepare_data(file_path: str) -> np.ndarray: df = pd.read_csv(file_path) interaction_matrix = df.pivot(index=\'user_id\', columns=\'item_id\', values=\'rating\').fillna(0).values return interaction_matrix def train_svd(interaction_matrix: np.ndarray, n_factors: int) -> tuple: U, Sigma, Vt = svds(interaction_matrix, k=n_factors) return U, Sigma, Vt def predict_ratings(user_id: int, U: np.ndarray, Sigma: np.ndarray, Vt: np.ndarray) -> np.ndarray: user_ratings = np.dot(np.dot(U[user_id, :], np.diag(Sigma)), Vt) return user_ratings"},{"question":"# Problem Statement You are provided with an implementation of a queue. A queue is a data structure that follows the First In, First Out (FIFO) principle, allowing you to add (`enqueue`) elements at the back and remove (`dequeue`) elements from the front. The current implementation includes basic queue operations such as `enqueue`, `dequeue`, `peek`, `is_empty`, `is_full`, and `size`. # Task Your task is to implement an additional method called `clone_queue` in the `Queue` class. This method should return a new queue containing the same elements as the original queue in the same order. You should not modify the original queue during this operation. # Method Signature ```python def clone_queue(self) -> \'Queue\': Create a clone of the current queue with the same elements in the same order. >>> Q = Queue() >>> Q.enqueue(1) >>> Q.enqueue(2) >>> Q.enqueue(3) >>> new_queue = Q.clone_queue() >>> print(list(new_queue)) [1, 2, 3] ``` # Constraints * The queue may contain up to `limit` elements. * The available methods of the `Queue` class (i.e., `enqueue`, `dequeue`, `peek`, `is_empty`, `size`, etc.) are the only allowed interactions with the queue. * You must not use any other data structures (such as lists, stacks, or another queue) for this task. # Expectations * The `clone_queue` method should work for an empty queue and return an empty queue. * The order of elements in the cloned queue should match the original queue. * Ensure that you do not lose or duplicate any elements in the process. * The efficiency of the cloning should be reasonable given the constraints. # Example ```python Q = Queue() Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) new_queue = Q.clone_queue() assert list(new_queue) == [1, 2, 3] ``` Implement the `clone_queue` method below: ```python def clone_queue(self) -> \'Queue\': # Your code goes here ```","solution":"class Queue: def __init__(self, limit=10): self.front = 0 self.rear = 0 self.size = 0 self.queue = [None] * limit self.limit = limit def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.limit def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = item self.rear = (self.rear + 1) % self.limit self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.limit self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def get_size(self): return self.size def clone_queue(self): new_queue = Queue(self.limit) for i in range(self.size): item = self.queue[(self.front + i) % self.limit] new_queue.enqueue(item) return new_queue def __iter__(self): idx = self.front count = 0 while count < self.size: yield self.queue[idx] idx = (idx + 1) % self.limit count += 1"},{"question":"# Problem Statement You are given a list of strings and a pattern string. Your task is to write a function that finds all strings in the list that match the given pattern. A string matches the pattern if there exists a bijection between the characters of the pattern and the characters of the string. **Function Signature**: ```python def find_matching_strings(strings: List[str], pattern: str) -> List[str]: ``` # Input: * `strings` (List[str]): A list of strings to be evaluated. * `pattern` (str): The pattern string to be matched against. # Output: * Returns a list of strings from the input list that match the given pattern. # Example: ```python strings = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" print(find_matching_strings(strings, pattern)) # Output: [\'mee\', \'aqq\'] ``` # Constraints: * All strings and the pattern are of lowercase English letters. * The length of the pattern and each string in the list will be between 1 and 20. * The input list will not exceed 1000 strings. # Notes: - The bijection means a one-to-one correspondence between characters of the pattern and characters of the string, i.e., no two characters in the pattern should map to the same character in the string and vice versa. - Be mindful to handle edge cases like strings of different lengths or where the mapping would break bijection constraints. # Hints: - Consider using a dictionary to map characters from the pattern to characters in the current string and another to map characters from the string to characters in the pattern. - Ensure the pattern and the string conform to the bijection across their entire length. --- This task should test the candidate\'s understanding of string manipulation, dictionary usage, and pattern matching concepts, aligning well with the conceptual depth and scope of the referenced question.","solution":"def find_matching_strings(strings, pattern): def matches_pattern(s, pattern): if len(s) != len(pattern): return False char_map_s_to_p = {} char_map_p_to_s = {} for sc, pc in zip(s, pattern): if sc not in char_map_s_to_p: char_map_s_to_p[sc] = pc if pc not in char_map_p_to_s: char_map_p_to_s[pc] = sc if char_map_s_to_p[sc] != pc or char_map_p_to_s[pc] != sc: return False return True result = [] for s in strings: if matches_pattern(s, pattern): result.append(s) return result"},{"question":"# Scenario You\'re developing a software to assist a library in managing their book inventory. One feature involves categorizing books based on the publication year into decade ranges. A decade range is defined as the ten-year period starting from a year that is a multiple of 10 (e.g., 1980-1989, 1990-1999). # Problem Write a function `categorize_by_decade(years: list[int]) -> dict` that takes a list of publication years and returns a dictionary where the keys are the starting year of the decade, and the values are lists of years that fall within that decade. # Input * `years` (list of int): A list of publication years. Each year will be an integer greater than 0. # Output * `dict`: A dictionary categorizing the years into their respective decades. The keys are the starting year of the decade (as integers) and the values are lists of years sorted in ascending order that fall within that decade. # Constraints 1. All years in the `years` list will be positive integers. 2. The input list `years` can be empty, in which case the returned dictionary should also be empty. # Examples 1. `categorize_by_decade([1980, 1985, 1990, 1992, 2001, 2003])` should return `{1980: [1980, 1985], 1990: [1990, 1992], 2000: [2001, 2003]}`. 2. `categorize_by_decade([1978, 1981, 1999, 2000, 2010])` should return `{1970: [1978], 1980: [1981], 1990: [1999], 2000: [2000], 2010: [2010]}`. 3. `categorize_by_decade([])` should return `{}`. # Implementation Implement your solution based on the analysis above: ```python def categorize_by_decade(years: list[int]) -> dict: :param years: list of publication years :type years: list[int] :return: Dictionary categorizing years into decades Tests: >>> categorize_by_decade([1980, 1985, 1990, 1992, 2001, 2003]) {1980: [1980, 1985], 1990: [1990, 1992], 2000: [2001, 2003]} >>> categorize_by_decade([1978, 1981, 1999, 2000, 2010]) {1970: [1978], 1980: [1981], 1990: [1999], 2000: [2000], 2010: [2010]} >>> categorize_by_decade([]) {} # Initialize an empty dictionary to store the categorized decades decade_dict = {} for year in years: # Determine the start of the decade decade_start = (year // 10) * 10 # Append the year to the corresponding decade list in the dictionary if decade_start not in decade_dict: decade_dict[decade_start] = [] decade_dict[decade_start].append(year) # Sort the years within each decade for key in decade_dict: decade_dict[key].sort() return decade_dict if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def categorize_by_decade(years: list[int]) -> dict: Categorize years into their respective decades. :param years: A list of publication years. :type years: list[int] :return: A dictionary where the keys are the starting year of the decade, and the values are lists of years that fall within that decade. :rtype: dict Examples: >>> categorize_by_decade([1980, 1985, 1990, 1992, 2001, 2003]) {1980: [1980, 1985], 1990: [1990, 1992], 2000: [2001, 2003]} >>> categorize_by_decade([1978, 1981, 1999, 2000, 2010]) {1970: [1978], 1980: [1981], 1990: [1999], 2000: [2000], 2010: [2010]} >>> categorize_by_decade([]) {} decade_dict = {} for year in years: decade_start = (year // 10) * 10 if decade_start not in decade_dict: decade_dict[decade_start] = [] decade_dict[decade_start].append(year) for key in decade_dict: decade_dict[key].sort() return decade_dict"},{"question":"# Coding Assessment Question: Rotate Array You are provided with an array of integers and a number, `k`. Your task is to rotate the array to the right by `k` steps. Rotating an array means moving the elements from the end of the array to the beginning in a circular manner. Write a Python function `rotate_array` to achieve this rotation. Function Signature ```python def rotate_array(nums: List[int], k: int) -> List[int]: ``` Input - `nums`: A list of integers (0 <= len(nums) <= 10^4, -10^9 <= nums[i] <= 10^9) - `k`: An integer representing the number of steps to rotate the array (0 <= k) Output - Returns a list with elements rotated `k` steps to the right. Example ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array([1, 2], 3) == [2, 1] ``` Constraints 1. An empty array should return empty. 2. If `k` is greater than the length of the array, the rotation should wrap around (i.e., `k` becomes `k % len(nums)`). Scenario Consider an application in streaming data processing where new data points get continuously added to the array. Rotating the array helps in keeping a fixed-size window of the most recent data points updated in real-time.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. if not nums: return [] n = len(nums) k = k % n # In case k is larger than the length of the array return nums[-k:] + nums[:-k]"},{"question":"# Context: In the study of algorithms, sorting is a fundamental concept and various sorting algorithms have different performance benefits based on the nature of the input data. Merge Sort is a classic example of a divide-and-conquer algorithm and is especially efficient for sorting large datasets due to its stable sorting behavior and O(n log n) time complexity. # Task: Write a function `merge_sort` that takes a list of integers and returns a new list containing the same integers sorted in ascending order using the Merge Sort algorithm. # Function Signature: ```python def merge_sort(arr: list) -> list: pass ``` # Input: * `arr` (list): A list of integers to be sorted. # Output: * Returns a new list of integers sorted in ascending order. # Example: ```python assert merge_sort([34, 7, 23, 32, 5, 62]) == [5, 7, 23, 32, 34, 62] assert merge_sort([6, 5, 3, 1, 8, 7, 2, 4]) == [1, 2, 3, 4, 5, 6, 7, 8] ``` # Constraints: * The input list can be empty or contain up to 100,000 elements. * The integers in the list will be in the range [-1,000,000, 1,000,000]. # Notes: * You should not use Python\'s built-in sort functions. * Make sure your implementation is optimized for performance. # Guidelines: * Implement the merge sort algorithm according to the divide-and-conquer approach. * Ensure that your solution handles all edge cases, including empty lists and lists with one element. ```python def merge_sort(arr: list) -> list: Sorts a list in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left: list, right: list) -> list: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) ```","solution":"def merge_sort(arr: list) -> list: Sorts a list in ascending order using the Merge Sort algorithm. if len(arr) <= 1: return arr def merge(left: list, right: list) -> list: Merges two sorted lists into one sorted list. sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Problem Context You are developing software for autonomous drone navigation, where the drone needs to calculate the shortest path between various waypoints. To optimize the drone\'s path, a variant of the famous Dijkstra\'s algorithm is used, which not only finds the shortest path but also takes into account the battery levels at each waypoint. # Task Implement the class `DronePathPlanner` to evaluate the shortest path while considering battery consumption at each waypoint. # Function Signature ```python class DronePathPlanner: def __init__(self, waypoints: list[tuple[int, int]], battery_levels: list[int], edges: list[tuple[int, int, int]]): ... def calculate_shortest_path(self, start_index: int, end_index: int) -> tuple[list[int], int]: ... def display_path(self, path: list[int], total_battery_consumed: int): ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Accepts a list of waypoints (coordinates), battery levels, and edges between waypoints. - Waypoints are given as tuples representing `(x, y)` coordinates. - Battery levels represent the battery consumed when visiting each waypoint. - Edges are given as tuples representing connections `(from, to, distance)`. 2. **Shortest Path Calculation (`calculate_shortest_path` method)**: - Accepts two indices, `start_index` and `end_index`, representing the starting and destination waypoints. - Implements a variant of Dijkstra\'s algorithm considering both distances and battery levels. - Returns a tuple containing the list of indices representing the shortest path and the total battery consumed. 3. **Path Display (`display_path` method)**: - Accepts the list of indices representing the shortest path and the total battery consumed. - Prints the path with an indication of battery levels at each waypoint and the total battery consumed. # Input and Output Format * **Input**: List of waypoints, battery levels, edges, and indices for start and end. ```plaintext waypoints = [(0, 0), (1, 1), (2, 2), (3, 3)] battery_levels = [1, 2, 1, 3] edges = [(0, 1, 1), (1, 2, 1), (2, 3, 1), (0, 2, 2), (1, 3, 2)] start_index = 0 end_index = 3 ``` * **Output**: - Implement method signatures. - Use `display_path` to visualize the result. # Constraints 1. Minimum waypoints: 2. 2. All waypoints and their connections are valid. 3. Battery levels are non-negative integers. 4. `start_index` and `end_index` are valid indices within the waypoints list. # Example Usage ```python if __name__ == \\"__main__\\": waypoints = [(0, 0), (1, 1), (2, 2), (3, 3)] battery_levels = [1, 2, 1, 3] edges = [(0, 1, 1), (1, 2, 1), (2, 3, 1), (0, 2, 2), (1, 3, 2)] planner = DronePathPlanner(waypoints, battery_levels, edges) path, battery_consumed = planner.calculate_shortest_path(0, 3) planner.display_path(path, battery_consumed) ``` Visualize the calculated path and corresponding battery consumption. # Additional Guidelines 1. **Edge Cases**: - Handle the case where there\'s no path from start to end. - Validate inputs properly to ensure indices and battery levels are within given constraints. 2. **Performance**: - Optimize path calculation for a large number of waypoints and edges. - Ensure efficient battery level consideration during path computation.","solution":"import heapq from typing import List, Tuple class DronePathPlanner: def __init__(self, waypoints: List[Tuple[int, int]], battery_levels: List[int], edges: List[Tuple[int, int, int]]): self.waypoints = waypoints self.battery_levels = battery_levels self.edges = edges self.graph = self.build_graph(edges) def build_graph(self, edges): graph = {} for u, v, dist in edges: if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append((v, dist)) graph[v].append((u, dist)) return graph def calculate_shortest_path(self, start_index: int, end_index: int) -> Tuple[List[int], int]: queue = [(0, start_index, 0, [])] # (distance, current index, battery used, path) visited = set() while queue: dist, current, battery_used, path = heapq.heappop(queue) if current in visited: continue visited.add(current) path = path + [current] if current == end_index: return (path, battery_used) for neighbor, distance in self.graph.get(current, []): if neighbor not in visited: total_distance = dist + distance total_battery_used = battery_used + self.battery_levels[neighbor] heapq.heappush(queue, (total_distance, neighbor, total_battery_used, path)) return ([], float(\'inf\')) # return empty and inf if there is no path def display_path(self, path: List[int], total_battery_consumed: int): output = \\" -> \\".join(f\\"{i}(Battery: {self.battery_levels[i]})\\" for i in path) print(f\\"Path: {output}\\") print(f\\"Total Battery Consumed: {total_battery_consumed}\\")"},{"question":"# Scenario: You are tasked with processing log data to identify and count the number of unique users visiting a website. The log data is stored in a text file, where each line represents a log entry. Each log entry consists of a timestamp, a user identifier, and a webpage URL, all separated by a space. # Task: 1. **Load Log Data**: Implement functionality to load the log data from the text file into a suitable data structure. 2. **Count Unique Users**: For each webpage URL, count the number of unique users who visited that page. 3. **Save Results**: Save the results to an output file where each line contains a URL and the corresponding unique visitor count. # Constraints: * The log data file path and the output file path should be specified as input parameters. * The log entries are guaranteed to be well-formatted. # Function Specifications: ```python def load_log_data(file_path: str) -> list[str]: - file_path <type: str>: Path to the log data file Returns <type: list>: List of log entries read from the file def count_unique_visitors(log_entries: list[str]) -> dict[str, int]: - log_entries <type: list>: List of log entries Returns <type: dict>: Dictionary with URLs as keys and the number of unique visitors as values def save_results(unique_visitors: dict[str, int], output_path: str) -> None: - unique_visitors <type: dict>: Dictionary with URLs and their corresponding unique visitor count - output_path <type: str>: Path to save the results def main() -> None: - Load the log data - Count unique visitors per webpage - Save the results if __name__ == \\"__main__\\": main() ``` # Input Format: * Path to the log data file. * Path to the output results file. # Output Format: * The output file contains lines with URLs and their respective unique visitor counts. Each line follows the format: `<URL> <uniq_user_count>`. For example: ``` /homepage.html 123 /about.html 45 /contact.html 67 ``` # Example: Given a log data file with the following contents: ``` 2023-10-01T10:00:00 user1 /homepage.html 2023-10-01T10:00:05 user2 /homepage.html 2023-10-01T10:01:00 user1 /about.html 2023-10-01T10:01:05 user2 /contact.html 2023-10-01T10:02:00 user1 /homepage.html 2023-10-01T10:02:05 user3 /contact.html ``` The output results file should contain: ``` /homepage.html 2 /about.html 1 /contact.html 2 ```","solution":"def load_log_data(file_path: str) -> list[str]: - file_path <type: str>: Path to the log data file Returns <type: list>: List of log entries read from the file with open(file_path, \'r\') as file: log_entries = file.readlines() return [entry.strip() for entry in log_entries] def count_unique_visitors(log_entries: list[str]) -> dict[str, int]: - log_entries <type: list>: List of log entries Returns <type: dict>: Dictionary with URLs as keys and the number of unique visitors as values visitor_counts = {} for entry in log_entries: _, user, url = entry.split() if url not in visitor_counts: visitor_counts[url] = set() visitor_counts[url].add(user) unique_visitors = {url: len(users) for url, users in visitor_counts.items()} return unique_visitors def save_results(unique_visitors: dict[str, int], output_path: str) -> None: - unique_visitors <type: dict>: Dictionary with URLs and their corresponding unique visitor count - output_path <type: str>: Path to save the results with open(output_path, \'w\') as file: for url, count in unique_visitors.items(): file.write(f\\"{url} {count}n\\") def main() -> None: - Load the log data - Count unique visitors per webpage - Save the results input_file_path = \'log.txt\' # Example input file path output_file_path = \'output.txt\' # Example output file path # Load log data log_entries = load_log_data(input_file_path) # Count unique visitors unique_visitors = count_unique_visitors(log_entries) # Save results save_results(unique_visitors, output_file_path) if __name__ == \\"__main__\\": main()"},{"question":"# Problem Description Write a function `is_rotated_version` that determines if one given string is a rotated version of another string. Two strings are considered rotated versions of each other if one string can be obtained by rotating the other string by some number of places. # Input * `s1` (str): The first input string. * `s2` (str): The second input string. # Output * The function should return a boolean value: `True` if `s2` is a rotated version of `s1`, otherwise `False`. # Constraints * The input strings `s1` and `s2` consist of lowercase and/or uppercase letters. * The length of `s1` and `s2` should be between 1 and 1000, inclusive. # Requirements * Implement the function `is_rotated_version` to determine if one string is a rotated version of another. * Aim for an efficient solution in terms of both time and space complexity. # Example ```python >>> is_rotated_version(\\"hello\\", \\"lohel\\") True >>> is_rotated_version(\\"hello\\", \\"olelh\\") False >>> is_rotated_version(\\"rotation\\", \\"tationro\\") True >>> is_rotated_version(\\"rotation\\", \\"noitatiro\\") False ``` # Description The function `is_rotated_version` should compare the given strings and evaluate if one string can be derived from another through rotation. You might want to take advantage of string concatenation and the `in` keyword to check if rotations match.","solution":"def is_rotated_version(s1, s2): Determines if the second string is a rotated version of the first string. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: bool: True if the s2 is a rotated version of s1, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Context In cryptography, the Caesar cipher is one of the simplest and most widely known encryption techniques. It involves shifting the letters of a plaintext by a fixed number of positions down the alphabet. For example, with a shift of 1, \'A\' would be replaced by \'B\', \'B\' would become \'C\', and so on, wrapping around to the start of the alphabet after \'Z\'. # Task You need to implement the Caesar cipher in Python. Specifically, you\'ll write two functions: 1. `caesar_cipher_slow(text: str, shift: int) -> str`: The slower implementation using basic string operations. 2. `caesar_cipher(text: str, shift: int) -> str`: The optimized implementation using a precomputed table or dictionary. # Input/Output Format * **Input**: A single string `text` consisting of alphabetic characters (both uppercase and lowercase) and non-alphabetic characters, and an integer `shift` which represents the number of positions by which each letter should be shifted. * **Output**: A string where each alphabetic character has been substituted with its Caesar cipher equivalent. Non-alphabetic characters should remain unchanged. # Constraints 1. The `shift` can be any integer (positive, negative, or zero). 2. The input string `text` will not exceed 10,000 characters. 3. Only standard ASCII characters will be present in the input string. # Requirements 1. `caesar_cipher_slow`: Implement a direct character-wise substitution. 2. `caesar_cipher`: Implement an optimized version using precomputed mappings for better performance. # Examples ```python >>> caesar_cipher_slow(\\"ABC\\", 1) \'BCD\' >>> caesar_cipher_slow(\\"aB;!z\\", 2) \'cD;!b\' >>> caesar_cipher(\\"ABC\\", 1) \'BCD\' >>> caesar_cipher(\\"aB;!z\\", 2) \'cD;!b\' ``` # Performance Expectations The optimized version should demonstrate significantly better performance than the slow version for long strings. Use the `timeit` module to benchmark the two functions.","solution":"def caesar_cipher_slow(text, shift): Shifts each alphabetic character in the text by the given shift. Non-alphabetic characters are unchanged. shifted_text = [] for char in text: if char.isalpha(): base = ord(\'A\') if char.isupper() else ord(\'a\') shifted_char = chr((ord(char) - base + shift) % 26 + base) shifted_text.append(shifted_char) else: shifted_text.append(char) return \'\'.join(shifted_text) def caesar_cipher(text, shift): Shifts each alphabetic character in the text by the given shift using precomputed mappings. Non-alphabetic characters are unchanged. def create_shift_map(shift): shift_map = {} for i in range(26): shift_map[chr(ord(\'A\') + i)] = chr((i + shift) % 26 + ord(\'A\')) shift_map[chr(ord(\'a\') + i)] = chr((i + shift) % 26 + ord(\'a\')) return shift_map shift_map = create_shift_map(shift) shifted_text = \'\'.join(shift_map.get(char, char) for char in text) return shifted_text"},{"question":"# Coding Assessment Question: Calculate Factorial of a Large Number **Background**: Factorials are a fundamental concept in mathematics, often used in permutations, combinations, and other areas of combinatorics. However, calculating the factorial of large numbers can be challenging due to potential integer overflow in some programming languages. Your task is to implement a function that can handle large integers and return the factorial of a supplied number. **Function Description**: Write a function `compute_factorial(n: int) -> str` that calculates and returns the factorial of a non-negative integer `n`. Since the factorial values can be very large, the result should be returned as a string. Input: * `n`: an integer representing the number to calculate the factorial for (0 ≤ n ≤ 500). Output: * A string representing the factorial of the given number. Constraints: * Ensure that the function handles incorrect input appropriately by raising a `ValueError` if `n` is negative. * The function should be optimized to run within a reasonable time frame even for the largest inputs under given constraints. Example: ```python assert compute_factorial(5) == \\"120\\" assert compute_factorial(10) == \\"3628800\\" assert compute_factorial(0) == \\"1\\" assert compute_factorial(20) == \\"2432902008176640000\\" assert compute_factorial(100) == \\"93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\\" ``` Additional Context: 1. Factorials grow very quickly with larger numbers. For instance, the factorial of 1000 is a 2568-digit number. 2. Factorial calculation can be efficiently performed using iterative or recursive methods, and modern programming languages often handle large integers natively. Use Python\'s inherent capabilities to manage large integers. Feel free to use this question format and constraints as part of your coding assessment.","solution":"def compute_factorial(n: int) -> str: Calculates the factorial of a non-negative integer n and returns it as a string. Args: - n (int): A non-negative integer whose factorial is to be computed. Returns: - str: The factorial of input n as a string. Raises: - ValueError: If the input n is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") factorial = 1 for i in range(2, n + 1): factorial *= i return str(factorial)"},{"question":"# Coding Assessment Question Context You are given a dataset representing sales figures for various products over several years. Your task is to implement a simple linear regression model to predict future sales. The dataset consists of pairs of values representing the year and the corresponding total sales for that year. Task Your task is to build a linear regression model from scratch, train it using the provided dataset, and evaluate it. Specifically, you need to: 1. **Preprocess the Data**: Handle missing values and normalize the data. 2. **Implement Linear Regression**: Write a function to train the linear regression model using gradient descent. 3. **Evaluate the Model**: Calculate the mean squared error (MSE) on a test set. Function Signature ```python def run_sales_prediction(train_data: List[Tuple[int, float]], test_data: List[Tuple[int, float]]): Sales prediction using linear regression. Parameters: train_data (List[Tuple[int, float]]): Training dataset with (year, total_sales) pairs. test_data (List[Tuple[int, float]]): Test dataset with (year, total_sales) pairs. The function should implement data preprocessing, training using linear regression, and evaluation on the test set. ``` Input * **train_data (List[Tuple[int, float]])**: List of tuples where each tuple contains a year (int) and corresponding total sales (float) for the training set. * **test_data (List[Tuple[int, float]])**: List of tuples where each tuple contains a year (int) and corresponding total sales (float) for the test set. Output * The function should print the coefficients of the linear regression model and the mean squared error (MSE) on the test set. Constraints * Handle missing values by using the mean of the available data. * Normalize the year and total sales values before training. * Use a learning rate and number of iterations that ensure the model converges. Example ```python # Example training and test data train_data = [(2010, 1000.0), (2011, 1500.0), (2012, 2000.0), (2013, 2500.0), (2014, 3000.0)] test_data = [(2015, 3500.0), (2016, 4000.0)] # Call the function with the training and test data run_sales_prediction(train_data, test_data) ``` **Expected Outcome**: The function should print the learned coefficients of the linear regression model and the mean squared error (MSE) on the test set, ensuring that the data is preprocessed appropriately. Good luck!","solution":"import numpy as np from typing import List, Tuple def preprocess_data(data: List[Tuple[int, float]]) -> Tuple[np.ndarray, np.ndarray]: # Handle missing values by replacing them with the mean of the dataset years = np.array([entry[0] for entry in data]) sales = np.array([entry[1] if entry[1] is not None else np.nan for entry in data]) if np.isnan(sales).any(): mean_sales = np.nanmean(sales) sales = np.where(np.isnan(sales), mean_sales, sales) # Normalize the data years_mean, years_std = np.mean(years), np.std(years) sales_mean, sales_std = np.mean(sales), np.std(sales) years = (years - years_mean) / years_std sales = (sales - sales_mean) / sales_std return years, sales def train_linear_regression(years: np.ndarray, sales: np.ndarray, learning_rate: float = 0.01, iterations: int = 1000) -> Tuple[float, float]: m, b = 0.0, 0.0 # Initialize slope and intercept N = float(len(years)) for _ in range(iterations): # Make predictions predictions = m * years + b # Calculate errors error = predictions - sales # Update weights using gradient descent m -= (learning_rate * (2 / N) * np.dot(error, years)) b -= (learning_rate * (2 / N) * np.sum(error)) return m, b def mean_squared_error(predictions: np.ndarray, actual: np.ndarray) -> float: return np.mean((predictions - actual) ** 2) def run_sales_prediction(train_data: List[Tuple[int, float]], test_data: List[Tuple[int, float]]): # Preprocess training and test data train_years, train_sales = preprocess_data(train_data) test_years, test_sales = preprocess_data(test_data) # Train the linear regression model m, b = train_linear_regression(train_years, train_sales) # Make predictions on the test set test_predictions = m * test_years + b # Un-normalize the predictions and test sales test_sales_mean, test_sales_std = np.mean([entry[1] for entry in test_data]), np.std([entry[1] for entry in test_data]) unnormalized_predictions = test_predictions * test_sales_std + test_sales_mean unnormalized_test_sales = test_sales * test_sales_std + test_sales_mean # Calculate mean squared error on the test set mse = mean_squared_error(unnormalized_predictions, unnormalized_test_sales) # Print the coefficients and the MSE print(f\\"Coefficients: Slope (m) = {m}, Intercept (b) = {b}\\") print(f\\"Mean Squared Error (MSE) on the test set: {mse}\\")"},{"question":"# Scenario: You are managing a network of interconnected systems, and you need to ensure data packets are routed in the most efficient way possible. The network is represented as an undirected graph where nodes are systems and edges are direct communication paths with associated latencies. Your task is to find the shortest path between two systems in this network. # Task: Implement a function `shortest_path(graph: dict, start_node: str, end_node: str) -> int` that uses Dijkstra\'s algorithm to calculate the shortest path latency between two specified nodes in the graph. # Function Signature: ```python def shortest_path(graph: dict, start_node: str, end_node: str) -> int: pass ``` # Input: * `graph`: A dictionary where keys are node labels (strings) and values are dictionaries. The inner dictionaries map adjacent node labels to their respective edge latencies. * `start_node`: A string representing the starting node for the path calculation. * `end_node`: A string representing the end node for the path calculation. # Output: * Return an integer representing the minimum total latency from the start node to the end node. # Example: ```python >>> graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } >>> shortest_path(graph, \'A\', \'D\') 4 >>> shortest_path(graph, \'A\', \'C\') 3 >>> shortest_path(graph, \'C\', \'D\') 1 ``` # Constraints: * The graph contains between 2 and 1000 nodes. * Each node label is a unique, non-empty string of up to 10 characters. * Edge latencies are positive integers up to 1000. # Notes: * You may assume there is always a path between the start node and the end node. * Ensure the function handles various graph structures efficiently.","solution":"import heapq def shortest_path(graph, start_node, end_node): Implements Dijkstra\'s algorithm to find the shortest path in terms of latency from start_node to end_node. # Priority queue for the Dijkstra\'s algorithm, initialized with the start_node and a distance of 0. priority_queue = [(0, start_node)] # Dictionary to keep track of the shortest path to each node. shortest_paths = {start_node: 0} while priority_queue: current_latency, current_node = heapq.heappop(priority_queue) # If we have reached the end_node, we can return the latency. if current_node == end_node: return current_latency # Explore neighbors for neighbor, latency in graph[current_node].items(): distance = current_latency + latency # If the calculated distance is shorter, update the shortest_paths and add to queue. if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # If there\'s no path found, return an infinite latency which is indicative that the nodes are not connected return float(\'inf\')"},{"question":"# Binary Tree Depth Calculation **Context**: Understanding the depth of a binary tree is a fundamental concept in computer science. The depth (or height) of a binary tree is the number of edges on the longest path from the root to a leaf node. Implementing this helps in various tree operations like balancing, searching, and more. **Problem Statement**: You are given a binary tree and need to implement a function that calculates its depth. The depth of an empty tree is 0, and the depth of a tree with one node is 1. **Function Signature**: ```python def calculate_tree_depth(root: TreeNode) -> int: ``` **Input**: * `root` (TreeNode): The root node of the binary tree. A `TreeNode` has attributes `val`, `left`, and `right`, which point to the node\'s value and its left and right children, respectively. **Output**: * `int`: An integer representing the depth of the binary tree. **Constraints**: * Each `TreeNode` will have value as an integer. * The binary tree can have at most 10^5 nodes. **Performance Requirements**: * Optimize for time complexity. The solution should ideally traverse each node exactly once. **Example**: Consider the following tree: ``` 1 / 2 3 / 4 5 ``` ```python assert calculate_tree_depth(root) == 3 ``` In this example, the depth is 3, with the longest path being 1 → 3 → 4 or 1 → 3 → 5. **Edge Cases**: * Test with an empty tree. * Test with a single-node tree. * Test with a tree where each node only has one child (linear tree). **Notes**: * Ensure correct handling of edge cases like an empty tree or a single-node tree. * Use recursion or an iterative approach with a queue to calculate the tree depth. Happy coding!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_tree_depth(root: TreeNode) -> int: if not root: return 0 else: left_depth = calculate_tree_depth(root.left) right_depth = calculate_tree_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Go through the list of given questions and carefully analyze their format, complexity, topic, and style. Below is a synthetic question that aligns with the provided example: # K-Means Clustering Implementation and Application **Background**: An e-commerce company intends to segment customers based on their purchasing behavior to offer personalized recommendations. You are required to implement the K-Means clustering algorithm to achieve this goal. **Objective**: Using the provided data structure and code snippets, complete the implementation of the K-Means clustering algorithm. Then, use it to identify clusters in a given dataset of customer purchase records. **Task**: 1. Complete the methods `initialize_centroids`, `assign_clusters`, and `update_centroids` to ensure the K-Means algorithm can correctly perform clustering on the dataset. 2. Write a function `k_means_clustering(data_set: list[list[float]], k: int, max_iterations: int) -> tuple[list[int], list[list[float]]]` that: - Accepts a dataset and the number of clusters `k`. - Accepts a maximum number of iterations `max_iterations`. - Returns a tuple containing a list of cluster assignments and a list of centroids. **Function Signature**: ```python def k_means_clustering(data_set: list[list[float]], k: int, max_iterations: int) -> tuple[list[int], list[list[float]]]: ``` **Input**: - `data_set`: A list of data points, where each data point is a list of feature values. Example: `[[12.0, 24.1], [10.8, 22.5], ...]` - `k`: An integer representing the number of clusters. - `max_iterations`: An integer representing the maximum number of iterations to run the algorithm. **Output**: - A tuple where the first element is a list of integers representing the cluster assignments for each data point, and the second element is a list of lists representing the final centroids. **Constraints**: - The number of data points `n` is such that `1 <= n <= 1000`. - The number of features `f` in each data point does not exceed 50. - It is guaranteed that the `k` value provided is such that `1 <= k <= n`. **Example**: ```python data_set = [ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0] ] k = 3 max_iterations = 100 cluster_assignments, centroids = k_means_clustering(data_set, k, max_iterations) print(cluster_assignments) # Output could be: [0, 0, 1, 2, 0, 2, 1, 1, 1] print(centroids) # Output could be: [[1.16, 1.466], [8.0, 3.75], [8.5, 9.5]] ``` You can use provided code snippets to aid in the development of the K-Means clustering algorithm. This includes initialization of centroids, assignment to clusters based on Euclidean distance, and updating centroids.","solution":"import random import math def euclidean_distance(point1, point2): Calculates the Euclidean distance between two points. return math.sqrt(sum((p1 - p2) ** 2 for p1, p2 in zip(point1, point2))) def initialize_centroids(data_set, k): Randomly initializes and returns k centroids from the data_set. return random.sample(data_set, k) def assign_clusters(data_set, centroids): Assigns each point in the data_set to the nearest centroid. Returns a list of cluster assignments. assignments = [] for point in data_set: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) assignments.append(closest_centroid_index) return assignments def update_centroids(data_set, assignments, k): Updates and returns centroids based on the current assignments of points to clusters. clusters = [[] for _ in range(k)] for point, assignment in zip(data_set, assignments): clusters[assignment].append(point) centroids = [] for cluster in clusters: if cluster: new_centroid = [sum(dimension) / len(cluster) for dimension in zip(*cluster)] centroids.append(new_centroid) else: centroids.append(random.choice(data_set)) # Handle empty clusters by randomly choosing a point return centroids def k_means_clustering(data_set: list[list[float]], k: int, max_iterations: int) -> tuple[list[int], list[list[float]]]: Applies the K-Means clustering algorithm. Parameters: data_set: A list of data points, where each data point is a list of feature values. k: An integer representing the number of clusters. max_iterations: An integer representing the maximum number of iterations to run the algorithm. Returns: A tuple containing a list of cluster assignments and a list of centroids. centroids = initialize_centroids(data_set, k) for _ in range(max_iterations): assignments = assign_clusters(data_set, centroids) new_centroids = update_centroids(data_set, assignments, k) if new_centroids == centroids: break centroids = new_centroids return assignments, centroids"},{"question":"# Scenario You are working on a project that involves significant string manipulations. One of the tasks requires checking if a given string can be rearranged to form a palindrome. This function needs to be efficient and capable of processing the request in real time. # Problem Statement Write a function `can_form_palindrome(s: str) -> bool` that determines whether any permutation of the input string `s` can form a palindrome. # Input Format * `s` is a string of length `n` containing only lowercase alphabets. # Output Format * Return a boolean value, `True` if any permutation of the string can form a palindrome, otherwise `False`. # Constraints * 1 ≤ n ≤ 10^5 # Performance Requirements * The solution should operate within O(n) time complexity. # Example ```python >>> can_form_palindrome(\\"carrace\\") True >>> can_form_palindrome(\\"daily\\") False >>> can_form_palindrome(\\"abcba\\") True ``` # Notes * A string can be rearranged to form a palindrome if at most one character occurs an odd number of times. * Ensure that your solution is efficient for large input sizes.","solution":"def can_form_palindrome(s: str) -> bool: Determines whether any permutation of the input string can form a palindrome. from collections import Counter char_count = Counter(s) odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1"},{"question":"# System Uptime Calculator You are given the list of start and end times of several service events within a monitoring system. Each event represents a time period during which the service was reported as active. The goal is to calculate the total uptime of the service within a specific analysis window, taking into account any overlapping event times. The events are provided as pairs of strings in the format `\'YYYY-MM-DD HH:MM:SS\'`. The analysis window is also defined with start and end times in the same format. You need to write a function `calculate_uptime` that computes the total number of seconds the service was active within the specified analysis window. Function Signature ```python def calculate_uptime( events: List[Tuple[str, str]], window_start: str, window_end: str ) -> int: ... ``` Input - `events` (List[Tuple[str, str]]): A list of tuples where each tuple consists of two strings representing the start and end times of an event. - `window_start` (str): The start time of the analysis window. - `window_end` (str): The end time of the analysis window. Output - `int`: The total uptime in seconds within the analysis window. Constraints - The `window_start` time is always earlier than the `window_end` time. - Event times are guaranteed to be within or overlap with the analysis window. Example ```python >>> events = [ (\\"2023-10-01 12:00:00\\", \\"2023-10-01 14:00:00\\"), (\\"2023-10-01 13:30:00\\", \\"2023-10-01 15:30:00\\"), (\\"2023-10-01 16:00:00\\", \\"2023-10-01 17:00:00\\"), ] >>> window_start = \\"2023-10-01 12:00:00\\" >>> window_end = \\"2023-10-01 16:00:00\\" >>> calculate_uptime(events, window_start, window_end) 14400 >>> window_start = \\"2023-10-01 13:00:00\\" >>> window_end = \\"2023-10-01 17:00:00\\" >>> calculate_uptime(events, window_start, window_end) 14400 ``` Error Handling The function should not raise any errors for valid inputs. If the inputs are invalid, the function is allowed to behave unexpectedly.","solution":"from typing import List, Tuple from datetime import datetime def calculate_uptime( events: List[Tuple[str, str]], window_start: str, window_end: str ) -> int: Calculate the total uptime of the service within the specified analysis window, taking into account any overlapping event times. window_start_dt = datetime.strptime(window_start, \\"%Y-%m-%d %H:%M:%S\\") window_end_dt = datetime.strptime(window_end, \\"%Y-%m-%d %H:%M:%S\\") total_uptime = 0 for start, end in events: start_dt = datetime.strptime(start, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end, \\"%Y-%m-%d %H:%M:%S\\") # Calculate the effective start and end time within the analysis window effective_start_dt = max(window_start_dt, start_dt) effective_end_dt = min(window_end_dt, end_dt) if effective_start_dt < effective_end_dt: total_uptime += (effective_end_dt - effective_start_dt).total_seconds() return int(total_uptime)"},{"question":"# Maze Solving: DFS vs. BFS Objective You are provided with base implementations of both Depth-First Search (DFS) and Breadth-First Search (BFS) algorithms used for solving a maze. The current implementations only handle simple mazes with open paths and obstacles. However, some mazes have weighted paths where certain paths are more costly to traverse. Task Modify the existing DFS and BFS implementations to account for weighted paths in the maze. You need to adapt the algorithms to properly consider these weights while navigating through the maze. Input 1. **Maze grid**: A 2D list of integers where each element represents the movement cost of traversing that cell. Lower values represent easier paths, and higher values represent more difficult paths. ```python maze = [ [1, 1, 1, 1, 1], [1, 5, 1, 5, 1], [1, 1, 1, 1, 1], [1, 5, 5, 5, 1], [1, 1, 1, 1, 1], ] ``` 2. **Start Position**: A tuple representing the starting coordinates (row, column). 3. **End Position**: A tuple representing the goal coordinates (row, column). Output A list of tuples, where each tuple represents the coordinates of the path from the start to the end position, inclusive. Constraints 1. Movement is allowed in four directions: up, down, left, and right. 2. Minimize the total movement cost from start to end. Performance Requirements * Ensure the modified algorithms remain efficient in terms of time complexity—DFS should explore nodes deeper first, while BFS should explore nodes layer-by-layer. * Space complexity should be managed to handle large mazes without excessive memory usage. Scenario The maze represents paths with varying difficulty. For example, some cells might be easily traversable (low cost) while others require more effort (high cost). Example ```python maze = [ [1, 1, 1, 1, 1], [1, 5, 1, 5, 1], [1, 1, 1, 1, 1], [1, 5, 5, 5, 1], [1, 1, 1, 1, 1], ] start = (0, 0) end = (4, 4) # Expected output: List of tuples representing the path. ``` Implement the modified algorithms in classes `WeightedDFS` and `WeightedBFS`.","solution":"import heapq def dijkstra(maze, start, end): Dijkstra\'s algorithm to find the shortest path in a weighted maze. row_count, col_count = len(maze), len(maze[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] pq = [(0, start)] visited = set() costs = {start: 0} parents = {start: None} while pq: current_cost, current = heapq.heappop(pq) if current in visited: continue visited.add(current) if current == end: # reconstruct the path path = [] while current is not None: path.append(current) current = parents[current] return path[::-1] for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < row_count and 0 <= neighbor[1] < col_count: new_cost = current_cost + maze[neighbor[0]][neighbor[1]] if neighbor not in costs or new_cost < costs[neighbor]: costs[neighbor] = new_cost parents[neighbor] = current heapq.heappush(pq, (new_cost, neighbor)) return [] class WeightedDFS: @staticmethod def search(maze, start, end): Performs a weighted DFS using Dijkstra\'s algorithm. return dijkstra(maze, start, end) class WeightedBFS: @staticmethod def search(maze, start, end): Performs a weighted BFS using Dijkstra\'s algorithm. return dijkstra(maze, start, end)"},{"question":"# Implementing and Testing a Balanced Binary Search Tree (BST) Scenario You are required to improve an existing database system by implementing a Balanced Binary Search Tree (BST) to efficiently manage and query data. The current unbalanced tree structure has performance issues with data insertion and lookups, especially with large datasets. Your task is to implement an AVL Tree, which is a self-balancing BST. Objective * **Implement**: Implement an AVL Tree class that maintains balance after insertion and allows for efficient lookups. * **Test**: Write test cases to ensure your implementation is correct. # Requirements `AVLTree` Class 1. **Init method**: Initialize the class. ```python def __init__(self): pass ``` 2. **Insert method**: Implement a method to insert a value into the AVL tree. ```python def insert(self, value: int): pass ``` 3. **Find method**: Implement a method to find a value in the AVL tree. ```python def find(self, value: int) -> bool: pass ``` # Example Usage ```python # Initialize the AVL tree avl_tree = AVLTree() # Insert values avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(6) avl_tree.insert(15) # Search for values assert avl_tree.find(10) == True assert avl_tree.find(15) == True assert avl_tree.find(25) == False assert avl_tree.find(5) == True assert avl_tree.find(7) == False ``` # Constraints * Values to be inserted are integers. * Inserted values are unique. # Performance Requirements Your solution must: * Maintain the balanced property of the AVL tree after each insertion. * Ensure that both insert and find operations are performed in O(log n) time. # Instructions 1. Implement the class and its methods as described. 2. Create a suite of test cases to verify the correctness of your implementation. 3. Ensure your implementation is efficient and can handle edge cases. ```python class AVLNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) # Example usage tests if __name__ == \\"__main__\\": avl_tree = AVLTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(6) avl_tree.insert(15) assert avl_tree.find(10) == True assert avl_tree.find(15) == True assert avl_tree.find(25) == False assert avl_tree.find(5) == True assert avl_tree.find(7) == False ```","solution":"class AVLNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key)"},{"question":"Pascal\'s Triangle with Recursive Approach Given the task to generate Pascal\'s Triangle up to a given number of rows using a recursive approach, complete the following function. # Problem Description **Objective**: Write a function `generate_pascals_triangle` to generate the first `n` rows of Pascal\'s Triangle using recursion. # Function Signature: ```python def generate_pascals_triangle(n: int) -> list[list[int]]: ``` # Input - `n` (int): The number of rows of Pascal\'s Triangle to generate, `0 ≤ n ≤ 50`. # Output - Returns a list of lists of integers, where each sublist represents a row of Pascal\'s Triangle. # Constraints 1. `n` is a non-negative integer (0 ≤ n ≤ 50). 2. Efficient computation - try to utilize memoization for your recursive solution to avoid excessive recomputation. # Examples 1. **Example 1** ```python assert generate_pascals_triangle(0) == [] ``` 2. **Example 2** ```python assert generate_pascals_triangle(1) == [[1]] ``` 3. **Example 3** ```python assert generate_pascals_triangle(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] ``` # Note - Pascal\'s Triangle starts with the top row as the 0th row, containing a single 1. - Each subsequent row is constructed using the sum of the two numbers directly above it in the previous row. # Hints - You can define a helper function that recursively finds the value at a specific position in Pascal\'s Triangle. - Use memoization to store already computed values to optimize your recursive approach.","solution":"def generate_pascals_triangle(n: int) -> list[list[int]]: Generate the first \'n\' rows of Pascal\'s Triangle using recursion with memoization. memo = {} def get_value(row, col): if col == 0 or col == row: return 1 if (row, col) in memo: return memo[(row, col)] memo[(row, col)] = get_value(row - 1, col - 1) + get_value(row - 1, col) return memo[(row, col)] result = [] for i in range(n): row = [] for j in range(i + 1): row.append(get_value(i, j)) result.append(row) return result"},{"question":"# Traveling Salesperson Genetic Algorithm Context The Traveling Salesperson Problem (TSP) is a classic optimization problem that seeks the shortest possible route for a salesperson to visit a list of cities and return to the origin city. Given the problem\'s complexity, heuristic methods like genetic algorithms can be employed to find near-optimal solutions efficiently. In this task, you will implement a genetic algorithm to approximate the solution to the TSP. The genetic algorithm should evolve a population of possible routes over a series of generations, using selection, crossover, and mutation to iteratively improve the solutions. Task Implement a genetic algorithm to solve the Traveling Salesperson Problem. Your implementation should include mechanisms for selection, crossover, and mutation, and should work with a specified number of generations. Requirements 1. **Function Name**: `genetic_tsp` 2. **Inputs**: - `distances`: 2D numpy.ndarray where `distances[i][j]` represents the distance between city `i` and city `j`. - `num_generations`: Integer specifying the number of generations to run the genetic algorithm. - `population_size`: Integer specifying the size of the population. - `mutation_rate`: Float representing the probability of mutation for each individual. 3. **Output**: - A list of integers representing the best route found that starts and ends at the same city. Constraints - The distance matrix will be symmetric and contain non-negative values. - `num_generations` is at most 500. - `population_size` is at most 100. - `mutation_rate` is between 0 and 1. Performance Requirements - Your solution should efficiently handle distance matrices of up to 20 cities. - The algorithm should complete within an acceptable range of a few seconds for the upper constraint limits. Example ```python import numpy as np distances = np.array([ [0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0] ]) num_generations = 100 population_size = 20 mutation_rate = 0.01 best_route = genetic_tsp(distances, num_generations, population_size, mutation_rate) print(best_route) # Expected Output: A list representing the near-optimal route, e.g. [0, 1, 3, 2, 0] ``` Notes - Ensure that your implementation includes a way to initialize the population randomly. - Use appropriate crossover and mutation techniques to generate new routes. - Implement a fitness function to evaluate and rank the individuals in the population. - The selection process should favor shorter routes.","solution":"import numpy as np import random def genetic_tsp(distances, num_generations, population_size, mutation_rate): def create_route(): return random.sample(range(num_cities), num_cities) def initial_population(pop_size): return [create_route() for _ in range(pop_size)] def route_distance(route): total_distance = sum(distances[route[i]][route[i+1]] for i in range(len(route)-1)) total_distance += distances[route[-1]][route[0]] return total_distance def rank_routes(population): return sorted(population, key=lambda route: route_distance(route)) def selection(pop_ranked): selected = [] for i in range(population_size // 2): selected.append(pop_ranked[i]) return selected def crossover(parent1, parent2): gene_a = int(random.random() * len(parent1)) gene_b = int(random.random() * len(parent1)) start_gene = min(gene_a, gene_b) end_gene = max(gene_a, gene_b) child_p1 = [] for i in range(start_gene, end_gene): child_p1.append(parent1[i]) child_p2 = [item for item in parent2 if item not in child_p1] return child_p1 + child_p2 def mutate(route): for swapped in range(len(route)): if random.random() < mutation_rate: swap_with = int(random.random() * len(route)) city1 = route[swapped] city2 = route[swap_with] route[swapped] = city2 route[swap_with] = city1 def mutate_population(population): for i in range(len(population)): mutate(population[i]) def next_generation(current_gen): pop_ranked = rank_routes(current_gen) selected = selection(pop_ranked) next_gen = selected[:] for i in range(len(pop_ranked) // 2): parent1 = random.choice(selected) parent2 = random.choice(selected) child = crossover(parent1, parent2) next_gen.append(child) mutate_population(next_gen) return next_gen num_cities = len(distances) population = initial_population(population_size) for _ in range(num_generations): population = next_generation(population) best_route = rank_routes(population)[0] return best_route + [best_route[0]]"},{"question":"# Sorting a List of Dictionaries by Multiple Keys Context: You are given a list of dictionaries, where each dictionary represents an item with various attributes. Your task is to sort the list based on multiple keys provided as input. This operation is common in data transformation and manipulation tasks. Function Signature: ```python def sort_dicts_by_keys(items: list[dict], keys: list[tuple[str, bool]]) -> list[dict]: pass ``` Input: - `items`: A list of dictionaries, where each dictionary has string keys and values of various types (int, float, str). - `keys`: A list of tuples, where each tuple contains a string (the key by which to sort) and a boolean (the sorting order). The boolean `True` indicates ascending order and `False` indicates descending order. The keys in the list represent the priority of sorting (first key is the highest priority). Output: - A sorted list of dictionaries based on the specified keys and sorting order. Constraints: - The `items` list can be empty. - Each dictionary in `items` is guaranteed to have all the keys specified in the `keys` list. - The data type of the value for a given key is consistent across all dictionaries in the list. - Values for the sorting keys will be comparable (e.g., all numeric or all strings). Example: ```python items = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"score\\": 88.0} ] keys = [(\\"age\\", True), (\\"score\\", False)] print(sort_dicts_by_keys(items, keys)) # Output: [ # {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90.0}, # {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"score\\": 88.0}, # {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85.5} # ] ``` Description: In the example provided: - The `items` list contains three dictionaries, each representing a person with attributes \\"name\\", \\"age\\", and \\"score\\". - The `keys` list specifies that sorting should be done first by \\"age\\" in ascending order and then by \\"score\\" in descending order. - The result is the sorted list of dictionaries based on the specified sorting criteria. Requirements: - Implement the function `sort_dicts_by_keys`. - Ensure the implementation is efficient and handles edge cases such as an empty `items` list gracefully. - Do not use any print statements in your function. - The solution should use stable sorting mechanisms to maintain relative order when keys are equal.","solution":"def sort_dicts_by_keys(items, keys): Sorts a list of dictionaries based on multiple keys. Args: items (list of dict): The list of dictionaries to sort. keys (list of tuples): The list of key and order pairs to sort the dictionaries by. Returns: list of dict: The sorted list of dictionaries. for key, ascending in reversed(keys): items.sort(key=lambda item: item[key], reverse=not ascending) return items"},{"question":"# The Knapsack Problem Problem Statement You are given `n` items, where each item `i` has a weight `w[i]` and a value `v[i]`. You need to determine the maximum value that can be obtained by selecting items such that their total weight does not exceed a given limit `W`. Write a function `knapsack_max_value` that takes three arguments: 1. `weights`: A list of integers representing weights of the items. 2. `values`: A list of integers representing values of the items. 3. `W`: An integer representing the maximum weight capacity of the knapsack. The function should return the maximum value that can be obtained using the given items. Input * `weights`: List of integers (1 ≤ len(weights) ≤ 100, 1 ≤ weights[i] ≤ 1000) * `values`: List of integers (1 ≤ len(values) ≤ 100, 1 ≤ values[i] ≤ 1000) * `W`: Integer (0 ≤ W ≤ 10000) Output * An integer representing the maximum value that can be obtained. Examples ```python >>> knapsack_max_value([1, 2, 3], [10, 15, 40], 6) 65 >>> knapsack_max_value([1, 3, 4, 5], [1, 4, 5, 7], 7) 9 >>> knapsack_max_value([2, 3, 4, 5], [1, 2, 5, 6], 8) 8 >>> knapsack_max_value([3, 1, 2], [5, 1, 3], 5) 8 >>> knapsack_max_value([10, 20, 30], [60, 100, 120], 50) 220 ``` Constraints * The number of items (len(weights) == len(values)). * Use dynamic programming to achieve an efficient solution. * Consider edge cases when `W` is 0 or very large (e.g., when `W` exceeds the sum of all weights). Implement the function as specified to solve the Knapsack Problem using dynamic programming.","solution":"def knapsack_max_value(weights, values, W): n = len(weights) # Initialize DP table dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for w in range(1, W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], values[i - 1] + dp[i - 1][w - weights[i - 1]]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"# Assignment: Implement a Queue Using Two Stacks In this assignment, you will create a queue using two stacks. This is a classic computer science problem that requires understanding of how stacks and queues function and how to simulate one using another. # Task: 1. Create a class `QueueUsingStacks` that includes the following methods: * `__init__(self)`: Initializes two empty stacks. * `enqueue(self, x)`: Adds an element `x` to the end of the queue. * `dequeue(self)`: Removes and returns the element from the front of the queue. If the queue is empty, return `None`. * `peek(self)`: Returns the element at the front of the queue without removing it. If the queue is empty, return `None`. * `is_empty(self)`: Returns `True` if the queue is empty, `False` otherwise. 2. Your implementation should ensure that each operation takes amortized constant time. # Constraints: * You can only use the standard stack operations (`push` and `pop`) for manipulating the stacks. * No direct use of arrays or list slicing for queue operations is allowed. # Example: ```python q = QueueUsingStacks() q.enqueue(1) q.enqueue(2) assert q.dequeue() == 1 assert q.peek() == 2 assert q.is_empty() == False q.dequeue() assert q.is_empty() == True ``` # Notes: * You should take care to handle edge cases such as calling `dequeue` or `peek` on an empty queue. * Your solution should use two stacks and provide the correct queue behavior with appropriate time complexity.","solution":"class QueueUsingStacks: def __init__(self): self.stack_in = [] self.stack_out = [] def enqueue(self, x): self.stack_in.append(x) def dequeue(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() if self.stack_out else None def peek(self): if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out[-1] if self.stack_out else None def is_empty(self): return not self.stack_in and not self.stack_out"},{"question":"# Coding Assessment Question Problem Statement: Implement a Python function `most_frequent_substring(s: str, k: int) -> Tuple[str, int]` that finds the most frequent substring of length `k` in the given string and returns the substring along with its frequency. Requirements: * **Input Format**: * `s` (`str`): A string consisting of lowercase English letters. * `k` (`int`): An integer representing the length of the substring. * **Output Format**: * A tuple `(substring, frequency)` where `substring` is the most frequent substring of length `k` and `frequency` is its number of occurrences in the string. * **Constraints**: * `1 <= len(s) <= 10^5` * `1 <= k <= len(s)` * **Performance**: * Your solution should run in O(n) time complexity where n is the length of the string. Example: ```python >>> most_frequent_substring(\\"abbabcaab\\", 2) (\'ab\', 3) >>> most_frequent_substring(\\"aaaaa\\", 1) (\'a\', 5) >>> most_frequent_substring(\\"abcdef\\", 1) (\'a\', 1) >>> most_frequent_substring(\\"abababab\\", 3) (\'aba\', 3) ``` Hints: 1. Use a sliding window approach to maintain the substrings of length `k`. 2. Use a dictionary to keep track of the frequency of each substring. 3. If there are multiple substrings with the same highest frequency, return any one of them. Edge Cases: 1. If the string has only one character and `k` is 1, return the character with its frequency. 2. If all characters in the string are unique and `k` is 1, return the first character with a frequency of 1. Implement your function below: ```python def most_frequent_substring(s: str, k: int) -> Tuple[str, int]: if k > len(s) or k <= 0: return \\"\\", 0 substring_counts = {} max_frequency = 0 max_substring = \'\' for i in range(len(s) - k + 1): substring = s[i:i + k] if substring in substring_counts: substring_counts[substring] += 1 else: substring_counts[substring] = 1 if substring_counts[substring] > max_frequency: max_frequency = substring_counts[substring] max_substring = substring return max_substring, max_frequency ``` Please ensure your function works efficiently for large string lengths and various values of `k`.","solution":"def most_frequent_substring(s: str, k: int): from collections import defaultdict if k > len(s) or k <= 0: return (\\"\\", 0) substring_counts = defaultdict(int) for i in range(len(s) - k + 1): substring = s[i:i + k] substring_counts[substring] += 1 max_frequency = max(substring_counts.values()) max_substrings = [key for key, value in substring_counts.items() if value == max_frequency] # Return any one of the max frequency substrings (here we take the first) return (max_substrings[0], max_frequency)"},{"question":"Implement a Function to Rotate a Linked List Given a singly linked list, implement a function called `rotate_list` that rotates the list to the right by `k` places. The rotation means that the last `k` elements of the list will appear at the beginning, and the rest will follow in their original order. # Function Signature ```python def rotate_list(head: Node, k: int) -> Node: ``` # Parameters and Constraints - `head` is the head node of the singly linked list. The linked list node is defined as: ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next ``` - `k` is an integer representing the number of positions to rotate the list to the right. - `k` can be positive, zero, or greater than the length of the linked list. - The function should return the new head of the rotated linked list. - The solution should aim to perform the rotation in O(n) time complexity. # Example ```python # Example 1 # Given linked list: 1 -> 2 -> 3 -> 4 -> 5 # Rotate by k=2 # Expected output: 4 -> 5 -> 1 -> 2 -> 3 # Example 2 # Given linked list: 0 -> 1 -> 2 # Rotate by k=4 # Expected output: 2 -> 0 -> 1 ``` # Additional Notes - You need to handle the cases where `k` is larger than the length of the linked list by using `k % length` to get the effective number of rotations. - Consider edge cases such as an empty linked list, a linked list with a single node, and `k` equal to zero. # Function Implementation To implement the function, you can follow the steps: 1. Traverse the linked list to find its length. 2. Find the effective rotations needed using `k % length`. 3. Identify the new head and tail of the rotated list. 4. Re-link the list to achieve the rotation. Example implementation: ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_list(head: Node, k: int) -> Node: if not head or k == 0: return head # Step 1: Traverse the list to find its length current = head length = 1 while current.next: current = current.next length += 1 # Step 2: Calculate effective rotations k = k % length if k == 0: return head # Step 3: Find new head and tail current.next = head # make the list circular steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Step 4: Break the circle new_tail.next = None return new_head ``` # Example Usage ```python # Creating the linked list 1 -> 2 -> 3 -> 4 -> 5 node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node5 = Node(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 # Rotating the linked list by 2 places new_head = rotate_list(node1, 2) # Creating the list 4 -> 5 -> 1 -> 2 -> 3 to verify the rotation while new_head: print(new_head.value, end=\\" -> \\" if new_head.next else \\"n\\") new_head = new_head.next ```","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def rotate_list(head: Node, k: int) -> Node: if not head or k == 0: return head # Step 1: Traverse the list to find its length current = head length = 1 while current.next: current = current.next length += 1 # Step 2: Calculate effective rotations k = k % length if k == 0: return head # Step 3: Find new head and tail current.next = head # make the list circular steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next # Step 4: Break the circle new_tail.next = None return new_head"},{"question":"**Objective**: Design a function to efficiently find the longest consecutive sequence of integers in an unsorted list using hash sets. **Scenario**: Given a list of unsorted integers, you need to determine the length of the longest consecutive sequence of numbers. This sequence should be formed from the integers present in the list without any gaps. **Function Signature**: ```python def longest_consecutive_sequence(nums: list[int]) -> int: Return the length of the longest consecutive sequence in the given list. Parameters: nums (list[int]): A list of integers that may contain duplicates. Returns: int: The length of the longest consecutive sequence. Raises: ValueError: If the list is empty. pass ``` **Constraints**: 1. The list `nums` may contain positive and negative integers. 2. The input list may be empty, in which case the function should return 0. 3. Your algorithm should have an average time complexity of O(n). **Requirements**: 1. Handle edge cases such as lists with duplicate elements. 2. Ensure the implementation is efficient, leveraging a hash set to quickly check for the presence of consecutive elements. **Examples**: ```python # Example 1 nums = [100, 4, 200, 1, 3, 2] assert longest_consecutive_sequence(nums) == 4 # The longest consecutive sequence is [1, 2, 3, 4] # Example 2 nums = [0, -1, 1, 2] assert longest_consecutive_sequence(nums) == 4 # The longest consecutive sequence is [-1, 0, 1, 2] # Example 3 nums = [10, 5, 12, 3, 55, 30, 11, 13] assert longest_consecutive_sequence(nums) == 4 # The longest consecutive sequence is [10, 11, 12, 13] # Example 4 nums = [8, 7, 6, 2, 3, 5, 4, 1] assert longest_consecutive_sequence(nums) == 8 # The longest consecutive sequence is [1, 2, 3, 4, 5, 6, 7, 8] # Example 5 nums = [] assert longest_consecutive_sequence(nums) == 0 # No elements in the list ``` **Hint**: Consider using a hash set to store the numbers and then check for the start of a sequence by confirming that the number smaller than the current number does not exist in the set. This will ensure each sequence is only counted once.","solution":"def longest_consecutive_sequence(nums: list[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Only check for the beginning of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Assessment Question Scenario You are tasked with implementing a function to perform the Caesar Cipher encryption and decryption for a given string. The Caesar Cipher is a type of substitution cipher where each letter in the plaintext is shifted a certain number of places down or up the alphabet. Task Implement a function `caesar_cipher` that takes a string and an integer key, and returns the encrypted or decrypted string based on the specified mode. Function Signature ```python def caesar_cipher(text: str, key: int, mode: str = \\"encrypt\\") -> str: Caesar Cipher implementation for encryption and decryption. :param text: The input string to be encrypted or decrypted. :param key: The integer key to shift the characters. :param mode: Mode of operation, either \\"encrypt\\" or \\"decrypt\\". Defaults to \\"encrypt\\". :return: The encrypted or decrypted string. ``` Input * `text`: A string of printable ASCII characters (includes letters, digits, punctuation, and whitespace). Length of the string is between 0 and 10^3. * `key`: An integer indicating the number of positions each character in the `text` is shifted. * `mode`: A string indicating the mode of operation, either \\"encrypt\\" or \\"decrypt\\". Defaults to \\"encrypt\\". Output * A string that represents the encrypted or decrypted version of the input text based on the specified mode and key. Constraints * The input string can be empty or contain up to 1000 characters. * The function should handle wrap-around for both uppercase and lowercase letters (e.g., with a key of 1, \'z\' should become \'a\'). * Non-alphabetic characters should remain unchanged. Examples ```python assert caesar_cipher(\\"hello world\\", 3) == \\"khoor zruog\\" assert caesar_cipher(\\"khoor zruog\\", 3, \\"decrypt\\") == \\"hello world\\" assert caesar_cipher(\\"12345\\", 5) == \\"12345\\" assert caesar_cipher(\\"ABC XYZ\\", 2) == \\"CDE ZAB\\" assert caesar_cipher(\\"CDE ZAB\\", 2, \\"decrypt\\") == \\"ABC XYZ\\" ``` Notes * Ensure that your implementation handles edge cases, such as empty strings and strings without any letters. * Consider the performance of your implementation, making sure it operates efficiently within the given constraints. * Pay special attention to the correct handling of both uppercase and lowercase letters while ensuring non-alphabetic characters are not altered.","solution":"def caesar_cipher(text: str, key: int, mode: str = \\"encrypt\\") -> str: Caesar Cipher implementation for encryption and decryption. :param text: The input string to be encrypted or decrypted. :param key: The integer key to shift the characters. :param mode: Mode of operation, either \\"encrypt\\" or \\"decrypt\\". Defaults to \\"encrypt\\". :return: The encrypted or decrypted string. if mode == \\"decrypt\\": key = -key result = [] for char in text: if char.isalpha(): offset = 65 if char.isupper() else 97 shifted = (ord(char) - offset + key) % 26 + offset result.append(chr(shifted)) else: result.append(char) return \\"\\".join(result)"},{"question":"# Problem Statement You are given an array of integers `arr` and an integer `x`. Your task is to implement a function that finds the smallest subarray with a sum greater than `x`. If no such subarray exists, return `0`. # Function Signature ```python def smallest_subarray_with_sum_greater_than_x(arr: list[int], x: int) -> int: ``` # Input - `arr`: A list of integers with a length (1 leq n leq 10,000). - `x`: An integer. # Output - An integer representing the length of the smallest subarray with a sum greater than `x`. If no such subarray exists, return `0`. # Constraints - All integers in `arr` are between 1 and 1,000 inclusive. - The function should handle edge cases efficiently. # Examples 1. Input: `arr = [1, 4, 45, 6, 0, 19]`, `x = 51` - Output: `3` 2. Input: `arr = [1, 10, 5, 2, 7]`, `x = 9` - Output: `1` 3. Input: `arr = [1, 11, 100, 1, 0, 200, 3, 2, 1, 250]`, `x = 280` - Output: `4` 4. Input: `arr = [1, 2, 4]`, `x = 8` - Output: `0` # Guidelines 1. Ensure your solution efficiently handles larger arrays. 2. Strive for a solution with a time complexity better than O(n^2). 3. Follow good coding practices, ensuring your solution is readable, efficient, and handles edge cases appropriately.","solution":"def smallest_subarray_with_sum_greater_than_x(arr, x): Finds the smallest subarray with a sum greater than x. Parameters: arr (list of int): List of integers. x (int): The target sum. Returns: int: The length of the smallest subarray with a sum greater than x. Returns 0 if no such subarray exists. n = len(arr) min_length = n + 1 # Start with max possible length + 1 start = 0 current_sum = 0 for end in range(n): # Add the current element to the current sum current_sum += arr[end] # While the current sum is greater than x, update the min length # and reduce the sum by removing elements from the start while current_sum > x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 # If min_length was never updated, return 0 return min_length if min_length <= n else 0"},{"question":"# Problem Statement Context: You are working on an image processing library. A new feature requires implementing a function to rotate a square matrix (representing an image) by 90 degrees clockwise. Instructions: 1. **Implement the `rotate_matrix` function**: - The function should accept a square matrix (a list of lists with equal lengths) and return a new matrix that is rotated 90 degrees clockwise. - Input validation is required to ensure the matrix is non-empty and square, otherwise, raise a `ValueError` exception. 2. **Implement the `is_square_matrix` function**: - This helper function should check if the provided matrix is a non-empty, square matrix. - Input: A list of lists. - Output: A boolean indicating whether the matrix is square and non-empty. Specifications: - **Function Signatures**: ```python def rotate_matrix(matrix: list) -> list: ... def is_square_matrix(matrix: list) -> bool: ... ``` - **Input/Output Examples**: ```python >>> is_square_matrix([[1, 2], [3, 4]]) True >>> is_square_matrix([[1, 2, 3], [4, 5, 6]]) False >>> is_square_matrix([]) False >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([[1], [2]]) Traceback (most recent call last): ... ValueError: Invalid input: matrix must be non-empty and square. ``` - **Constraints**: - The input matrix must be non-empty and square. - Matrix elements will be integers. - Function should handle incorrect matrix structures by raising appropriate exceptions. - **Performance Requirements**: - Ensure the rotation implementation is done efficiently with minimal time complexity overhead. Aim for O(n^2) time complexity, where n is the dimension of the square matrix.","solution":"def is_square_matrix(matrix: list) -> bool: Checks if the given matrix is a non-empty square matrix. Args: matrix (list): The matrix to check. Returns: bool: True if the matrix is non-empty and square, False otherwise. if not matrix or not all(isinstance(row, list) for row in matrix): return False n = len(matrix) return all(len(row) == n for row in matrix) def rotate_matrix(matrix: list) -> list: Rotates a square matrix 90 degrees clockwise. Args: matrix (list): The square matrix to rotate. Returns: list: A new matrix that is rotated 90 degrees clockwise. Raises: ValueError: If the matrix is not non-empty and square. if not is_square_matrix(matrix): raise ValueError(\\"Invalid input: matrix must be non-empty and square.\\") n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Rectangle Area Calculation Problem You are given the lengths of two sides of a rectangle, and you need to calculate its area. Implement the function `calculate_rectangle_area` according to the provided specifications. Function Signature ```python def calculate_rectangle_area(length: float, width: float) -> float: ``` Input - `length` (float): The length of the rectangle. (0 ≤ length) - `width` (float): The width of the rectangle. (0 ≤ width) Output - Returns a float that represents the area of the rectangle. Constraints - If `length` is negative, raise a `ValueError` with the message \\"Length must be non-negative\\". - If `width` is negative, raise a `ValueError` with the message \\"Width must be non-negative\\". Examples ```python # Example 1 assert round(calculate_rectangle_area(5.0, 10.0), 2) == 50.0 # Example 2 assert round(calculate_rectangle_area(7.5, 3.2), 2) == 24.0 # Example 3 assert round(calculate_rectangle_area(0, 9.8), 2) == 0.0 # Example 4 try: calculate_rectangle_area(-5, 7) except ValueError as e: assert str(e) == \\"Length must be non-negative\\" try: calculate_rectangle_area(6, -3) except ValueError as e: assert str(e) == \\"Width must be non-negative\\" try: calculate_rectangle_area(-4, -2) except ValueError as e: assert str(e) == \\"Length must be non-negative\\" ``` Detailed Explanation 1. **Validation**: - Check whether `length` is non-negative. - Ensure `width` is non-negative. 2. **Calculation**: - Compute the area of the rectangle using the formula ( text{Area} = text{length} times text{width} ). 3. **Return**: - Return the computed area value. Provide a robust implementation of the function `calculate_rectangle_area` following these guidelines and ensuring that all edge cases are handled correctly.","solution":"def calculate_rectangle_area(length: float, width: float) -> float: Calculate the area of a rectangle given its length and width. Parameters: length (float): The length of the rectangle. Must be non-negative. width (float): The width of the rectangle. Must be non-negative. Returns: float: The area of the rectangle. Raises: ValueError: If length or width is negative. if length < 0: raise ValueError(\\"Length must be non-negative\\") if width < 0: raise ValueError(\\"Width must be non-negative\\") return length * width"},{"question":"# Coding Assessment Question Context You are provided with a task to create a function that performs a certain transformation on a list of integers. The objective is to enforce strict input types for the list elements and handle common edge cases to ensure robustness. Task Write a Python function `increment_evens_and_concatenate(odd_marker: str, numbers: list[int]) -> str` that increments all even numbers by 1 and replaces all odd numbers with the specified odd_marker. The function should return a single string which is the result of concatenating all transformed elements. If any element in the list is not an integer, raise a `TypeError`. Function Signature ```python def increment_evens_and_concatenate(odd_marker: str, numbers: list[int]) -> str: pass ``` Inputs - `odd_marker` (str): The string to replace each odd number in the list. - `numbers` (list of int): A list containing integers that need to be processed. Output - Returns a single string which is the concatenated result of the transformed list. Constraints - All elements in `numbers` are of type `int`. - The function should raise a `TypeError` if any element in `numbers` is not an integer. Examples ```python >>> increment_evens_and_concatenate(\\"#\\", [2, 3, 4, 5]) \'3#5#\' >>> increment_evens_and_concatenate(\\"X\\", [1, 2, 3, 4]) \'X3X5\' >>> increment_evens_and_concatenate(\\"-\\", [2, 4, 6]) \'357\' >>> increment_evens_and_concatenate(\\"*\\", [1, 3, 5, 7]) \'****\' >>> increment_evens_and_concatenate(\\"!\\", [10, 15, 20]) \'11!21\' >>> increment_evens_and_concatenate(\\"!\\", [2, \\"3\\", 4]) Traceback (most recent call last): ... TypeError: increment_evens_and_concatenate() accepts only integers >>> increment_evens_and_concatenate(\\"@\\", []) \'\' ``` Notes - Think about the edge cases like empty lists or all elements being odd numbers. - Ensure the function correctly processes each element and produces the expected result. - Test the function with various inputs to confirm its robustness.","solution":"def increment_evens_and_concatenate(odd_marker: str, numbers: list[int]) -> str: result = [] for num in numbers: if not isinstance(num, int): raise TypeError(\\"increment_evens_and_concatenate() accepts only integers\\") if num % 2 == 0: result.append(str(num + 1)) else: result.append(odd_marker) return \\"\\".join(result)"},{"question":"# Coding Assessment Question **Scenario**: As part of a campaign to improve educational outreach, you are tasked with developing a simplified scheduling system for a university\'s online course management platform. This system allows students to enroll in courses, drop courses, and query available courses based on various criteria. Efficient data management and query handling are essential to ensure a smooth user experience as the number of students and courses grows. **Task**: Implement a system to manage course enrollments with the ability to handle queries about student-course enrollments using a Trie (prefix tree) for efficient lookups based on course or student prefixes. **Requirements**: 1. **Course and Student Trie Structures**: - Provide a `CourseEnrollmentSystem` class that uses a Trie for efficient prefix-based queries. - Implement methods to add a student to a course, drop a student from a course, and query enrollments. 2. **Add and Drop Operations**: - Implement an `add` method to enroll a student in a course. - Implement a `drop` method to remove a student from a course. 3. **Query Operations**: - Implement a `query_courses_with_prefix` method to return a list of courses starting with a given prefix. - Implement a `query_students_with_prefix` method to return a list of students enrolled in courses starting with a given course prefix. # Function Details - **Class**: `CourseEnrollmentSystem` - **Constructor**: - `__init__(self) -> None` - Initializes the `CourseEnrollmentSystem` with empty Tries for courses and students. - **Methods**: - `add(self, student: str, course: str) -> None` - Enrolls the specified student in the specified course. - `drop(self, student: str, course: str) -> None` - Removes the specified student from the specified course. - `query_courses_with_prefix(self, prefix: str) -> List[str]` - Returns a list of courses that start with the given prefix. - `query_students_with_prefix(self, prefix: str) -> List[str]` - Returns a list of students enrolled in courses that start with the given course prefix. **Constraints**: - Number of students `S` and courses `C` where `1 <= S, C <= 10^5`. - Length of student names and course names does not exceed 100 characters. - All names are composed of lowercase English letters. # Input Format: - Multiple add, drop, and query operations. - Example operations: - `add(\\"alice\\", \\"math101\\")` should enroll Alice in \\"math101\\". - `drop(\\"alice\\", \\"math101\\")` should drop Alice from \\"math101\\". - `query_courses_with_prefix(\\"ma\\")` should return courses starting with \\"ma\\". - `query_students_with_prefix(\\"phy\\")` should return students enrolled in courses starting with \\"phy\\". # Output Format: - For each query operation, output the result of the query. # Example: ```python ces = CourseEnrollmentSystem() ces.add(\\"alice\\", \\"math101\\") ces.add(\\"bob\\", \\"math201\\") ces.add(\\"charlie\\", \\"physics101\\") print(ces.query_courses_with_prefix(\\"ma\\")) # Output: [\\"math101\\", \\"math201\\"] print(ces.query_students_with_prefix(\\"phy\\")) # Output: [\\"charlie\\"] ces.drop(\\"alice\\", \\"math101\\") print(ces.query_courses_with_prefix(\\"ma\\")) # Output: [\\"math201\\"] ``` --- This new question is designed to test the understanding of data structures, specifically Tries, and how they can be utilized to efficiently manage and query large amounts of enrollment data while maintaining the style, complexity, and scope of the provided sample question.","solution":"from collections import defaultdict from typing import List, Dict, Set class TrieNode: def __init__(self): self.children = dict() self.is_end_of_word = False self.enrollments = set() class CourseEnrollmentSystem: def __init__(self): self.course_trie = TrieNode() self.student_trie = TrieNode() self.enrollments = defaultdict(set) def add(self, student: str, course: str) -> None: # enroll the student in the course if student not in self.enrollments[course]: self.enrollments[course].add(student) self._insert(self.course_trie, course, student) self._insert(self.student_trie, student, course) def drop(self, student: str, course: str) -> None: # remove the student from the course if student in self.enrollments[course]: self.enrollments[course].remove(student) self._remove(self.course_trie, course, student) self._remove(self.student_trie, student, course) def _insert(self, root: TrieNode, word: str, data: str): node = root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.enrollments.add(data) node.is_end_of_word = True def _remove(self, root: TrieNode, word: str, data: str): node = root for char in word: if char in node.children: node = node.children[char] if data in node.enrollments: node.enrollments.remove(data) def _collect_all_words(self, node: TrieNode, prefix: str) -> List[str]: results = [] if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): results += self._collect_all_words(child_node, prefix + char) return results def query_courses_with_prefix(self, prefix: str) -> List[str]: # query courses starting with a prefix node = self.course_trie for char in prefix: if char in node.children: node = node.children[char] else: return [] return self._collect_all_words(node, prefix) def query_students_with_prefix(self, prefix: str) -> List[str]: # query students enrolled in courses starting with a prefix results = set() node = self.course_trie for char in prefix: if char in node.children: node = node.children[char] else: return [] results = node.enrollments return list(results)"},{"question":"# Minimum Edit Distance Given two strings, compute the minimum number of operations required to convert the first string into the second. Operations allowed are insertion, deletion, or substitution of a single character. Input - Two strings `a` and `b`. Output - The function should return an integer, representing the minimum edit distance. Constraints - Both input strings `a` and `b` can have a maximum length of 1000. Performance Requirements - The implementation should have a time complexity of O(m * n) and a space complexity of O(m * n), where m and n are the lengths of `a` and `b` respectively. Example ```python def minimum_edit_distance(a: str, b: str) -> int: pass # Example Test Cases assert minimum_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # substitute \'k\' with \'s\', replace \'e\' with \'i\', append \'g\' assert minimum_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # substituting \'f\' with \'l\', and appending \'n\' assert minimum_edit_distance(\\"intention\\", \\"execution\\") == 5 # multiple operations required assert minimum_edit_distance(\\"\\", \\"abc\\") == 3 # adding \'a\', \'b\', \'c\' assert minimum_edit_distance(\\"abc\\", \\"\\") == 3 # deleting \'a\', \'b\', \'c\' ``` Implementation Notes: 1. Define a 2D array `dp` of size (m+1) x (n+1), where `dp[i][j]` represents the minimum edit distance between the first `i` characters of `a` and the first `j` characters of `b`. 2. Initialize `dp[0][j] = j` for all `j` (converting empty string to first `j` characters of `b`). 3. Initialize `dp[i][0] = i` for all `i` (converting first `i` characters of `a` to empty string). 4. Fill the `dp` array using the following relations: - If `a[i-1] == b[j-1]`, then `dp[i][j] = dp[i-1][j-1]` (no operation required). - Otherwise, `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])` (either insert, delete, or substitute). 5. The final value `dp[m][n]` will be the minimum edit distance between strings `a` and `b`.","solution":"def minimum_edit_distance(a: str, b: str) -> int: Compute the minimum number of operations required to convert string a to string b. Allowed operations are insertion, deletion, or substitution of a single character. m, n = len(a), len(b) # Initialize DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill DP table for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min( dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Substitution ) return dp[m][n]"},{"question":"# Context Two strings are said to be isomorphic if the characters in one string can be replaced to get the second string, without changing the order of characters. For example, \\"egg\\" and \\"add\\" are isomorphic because the \'e\' is replaced with \'a\' and \'g\' is replaced with \'d\'. However, \\"foo\\" and \\"bar\\" are not isomorphic since we cannot find a mapping that replaces characters to match the second string while preserving the order. # Task Implement a function `is_isomorphic(s1: str, s2: str) -> bool` that returns True if the given two strings `s1` and `s2` are isomorphic, and False otherwise. Examples ```python def is_isomorphic(s1: str, s2: str) -> bool: Check if two strings `s1` and `s2` are isomorphic. :param s1: The first string :type s1: str :param s2: The second string :type s2: str :return: True if `s1` and `s2` are isomorphic, False otherwise :rtype: bool Examples: >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False pass ``` Constraints - (1 leq text{{len}}(s1), text{{len}}(s2) leq 10^4) - `s1` and `s2` consists of only lowercase English letters.","solution":"def is_isomorphic(s1: str, s2: str) -> bool: Check if two strings `s1` and `s2` are isomorphic. :param s1: The first string :type s1: str :param s2: The second string :type s2: str :return: True if `s1` and `s2` are isomorphic, False otherwise :rtype: bool Examples: >>> is_isomorphic(\\"egg\\", \\"add\\") True >>> is_isomorphic(\\"foo\\", \\"bar\\") False >>> is_isomorphic(\\"paper\\", \\"title\\") True >>> is_isomorphic(\\"ab\\", \\"aa\\") False if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for c1, c2 in zip(s1, s2): if (c1 in mapping_s1_to_s2 and mapping_s1_to_s2[c1] != c2) or (c2 in mapping_s2_to_s1 and mapping_s2_to_s1[c2] != c1): return False mapping_s1_to_s2[c1] = c2 mapping_s2_to_s1[c2] = c1 return True"},{"question":"# Question: Maze Solver with Heuristic Pathfinding Context You are tasked with designing a maze solver that uses a heuristic algorithm to find the shortest path from a starting point to an endpoint in a given maze. This exercise will test your understanding of graph traversal techniques, representation of the maze, and the implementation of heuristic-based search algorithms. Requirements 1. **Maze Representation**: - Represent the maze as a 2D list where 0s represent passable paths and 1s represent impassable walls. 2. **Solver Class (`MazeSolver`)**: - Implement a class `MazeSolver` which takes the 2D maze, start, and end positions as initial parameters. 3. **Heuristic Pathfinding Algorithm**: - Implement the A* algorithm to find the shortest path from the start to the end. - Include a heuristic function, such as the Manhattan distance, to guide the search. 4. **Path Retrieval Function**: - Implement a function `find_path` that returns the list of coordinates forming the shortest path, or an empty list if no path exists. Implementation Details - **Input Format**: - `maze`: a 2D list of integers (0s and 1s) - `start`: a tuple of integers representing the starting coordinate (row, column) - `end`: a tuple of integers representing the destination coordinate (row, column) - **Output Format**: - A list of tuples representing the coordinates of the shortest path from start to end, or an empty list if no path exists. - **Constraints**: - The maze contains at most 100x100 cells. - The start and end points are guaranteed to be passable (i.e., they will always be \'0\'). Function Signature ```python from typing import List, Tuple class MazeSolver: def __init__(self, maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]): pass # Initialize with maze, start, and end positions def find_path(self) -> List[Tuple[int, int]]: pass # Implement the A* algorithm to find the shortest path # Example Usage: # maze = [ # [0, 1, 0, 0, 0], # [0, 1, 0, 1, 0], # [0, 0, 0, 1, 0], # [0, 1, 1, 1, 0], # [0, 0, 0, 0, 0] # ] # start = (0, 0) # end = (4, 4) # solver = MazeSolver(maze, start, end) # path = solver.find_path() ``` Performance Requirements - Ensure the implementation of the A* algorithm is optimized to handle the constraints. - The heuristic function should guide the search effectively to ensure timely pathfinding.","solution":"from typing import List, Tuple import heapq class MazeSolver: def __init__(self, maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]): self.maze = maze self.start = start self.end = end self.rows = len(maze) self.cols = len(maze[0]) self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance heuristic between two points. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_path(self) -> List[Tuple[int, int]]: Find the shortest path from start to end using the A* algorithm. start, end = self.start, self.end open_set = [(0 + self.heuristic(start, end), 0, start)] # (priority, cost, node) came_from = {} cost_so_far = {start: 0} while open_set: _, cost, current = heapq.heappop(open_set) if current == end: return self.reconstruct_path(came_from, current) for direction in self.directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < self.rows and 0 <= neighbor[1] < self.cols: if self.maze[neighbor[0]][neighbor[1]] == 0: new_cost = cost + 1 if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]: cost_so_far[neighbor] = new_cost priority = new_cost + self.heuristic(neighbor, end) heapq.heappush(open_set, (priority, new_cost, neighbor)) came_from[neighbor] = current return [] def reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]: Reconstruct the path from the end to the start by backtracking using the came_from dictionary. path = [] while current in came_from: path.append(current) current = came_from[current] path.append(self.start) path.reverse() return path"},{"question":"# Question: Order Processing System You have been assigned to develop a function that processes a batch of orders for an e-commerce platform. Each order has to be assigned to a delivery agent based on their proximity to the delivery location. Your task is to enhance the efficiency and scalability of this function. **Task** 1. Modify the `assign_orders` function to distribute orders among delivery agents using an optimal strategy. 2. Ensure that the function can handle a large number of orders and agents efficiently. 3. Implement a retry mechanism for any failures in order processing. 4. Log all error events for monitoring and troubleshooting. # Requirements **Function Signature** ```python import asyncio # You may use this library for asynchronous processing import logging # You may use this library for logging async def assign_orders(orders: list[dict], agents: list[dict]) -> dict: pass # Your implementation here ``` **Input** - `orders` (list of dict): A list of orders, where each order is represented by a dictionary containing `order_id`, `location`, and `details`. - `agents` (list of dict): A list of delivery agents, where each agent is represented by a dictionary containing `agent_id`, `current_location`, and `availability`. **Output** - Returns a dictionary where the keys are agent IDs and the values are lists of order IDs assigned to each agent. **Constraints** - Implement an optimal strategy for assigning orders to agents based on the proximity of agents to the delivery locations. - Ensure that the function handles order processing failures with a retry mechanism. - Log all errors efficiently for monitoring purposes. # Performance - Optimized for a large number of concurrent orders and agents. # Example ```python import asyncio # Assuming your function implementation is complete async def main(): orders = [ {\'order_id\': 1, \'location\': \'51.5074,-0.1278\', \'details\': \'Order Details 1\'}, {\'order_id\': 2, \'location\': \'48.8566,2.3522\', \'details\': \'Order Details 2\'} ] agents = [ {\'agent_id\': \'A1\', \'current_location\': \'51.5074,-0.1278\', \'availability\': True}, {\'agent_id\': \'A2\', \'current_location\': \'48.8566,2.3522\', \'availability\': True} ] try: assignments = await assign_orders(orders, agents) print(assignments) except Exception as e: print(f\\"Error: {e}\\") asyncio.run(main()) ``` # Note - Use asynchronous programming to efficiently handle the order processing tasks. - Ensure proper logging of all errors for debugging and traceability.","solution":"import asyncio import logging from typing import List, Dict import random # For simulating random failures # Setting up logging logging.basicConfig(level=logging.ERROR, format=\'%(asctime)s - %(levelname)s - %(message)s\') MAX_RETRIES = 3 def calculate_distance(loc1: str, loc2: str) -> float: # Dummy function to calculate distance between two locations given as \\"lat,lon\\" lat1, lon1 = map(float, loc1.split(\',\')) lat2, lon2 = map(float, loc2.split(\',\')) return ((lat1 - lat2) ** 2 + (lon1 - lon2) ** 2) ** 0.5 async def assign_order_to_agent(order, agents): retries = 0 while retries < MAX_RETRIES: try: # Simulating potential failure if random.random() < 0.2: raise Exception(\\"Simulated failure in order processing\\") # Find the closest available agent closest_agent = None min_distance = float(\'inf\') for agent in agents: if agent[\'availability\']: distance = calculate_distance(order[\'location\'], agent[\'current_location\']) if distance < min_distance: min_distance = distance closest_agent = agent # If no agents are available, log and return None if closest_agent is None: logging.error(f\\"No available agents for order {order[\'order_id\']}\\") return None # Mark agent as unavailable closest_agent[\'availability\'] = False return closest_agent[\'agent_id\'], order[\'order_id\'] except Exception as e: retries += 1 logging.error(f\\"Error processing order {order[\'order_id\']}: {e}. Retrying {retries}/{MAX_RETRIES}\\") logging.error(f\\"Failed to process order {order[\'order_id\']} after {MAX_RETRIES} retries\\") return None async def assign_orders(orders: List[Dict], agents: List[Dict]) -> Dict[str, List[int]]: assignments = {agent[\'agent_id\']: [] for agent in agents} # Create a list of tasks to process orders tasks = [assign_order_to_agent(order, agents) for order in orders] results = await asyncio.gather(*tasks) for result in results: if result: agent_id, order_id = result assignments[agent_id].append(order_id) return assignments"},{"question":"# Longest Substring with K Distinct Characters You\'re working on a text mining software that needs to handle large streams of textual data efficiently. One of the functionalities required is to identify the longest substring containing exactly ( k ) distinct characters. This feature will be crucial for analyzing text patterns and identifying sections of interest within the data. Function Signature ```python def longest_substring_k_distinct(s: str, k: int) -> str: pass ``` Input * A string ( s ) of lowercase English letters (1 (leq) (|s|) (leq) (10^6)). * An integer ( k ) ((1 leq k leq 26)). Output * Returns the longest substring of ( s ) that contains exactly ( k ) distinct characters. If there are multiple results with the same length, return any of them. Example ```python assert longest_substring_k_distinct(\\"eceba\\", 2) == \\"ece\\" assert longest_substring_k_distinct(\\"aa\\", 1) == \\"aa\\" assert longest_substring_k_distinct(\\"abcadcacacaca\\", 3) == \\"cadcacacaca\\" ``` # Constraints * ( k ) will always be a valid number within the provided string length. * The function should be optimized to handle large strings efficiently. # Notes 1. Use sliding window or two-pointer technique to maintain a window of substrings while ensuring the condition of exactly ( k ) distinct characters. 2. Properly handle edge cases such as when ( k ) is greater than the number of distinct characters in ( s ) or when ( k ) is equal to 1. 3. Performance will be evaluated on extremely large inputs to ensure the solution\'s efficiency in both time and space complexity.","solution":"def longest_substring_k_distinct(s: str, k: int) -> str: Returns the longest substring containing exactly k distinct characters. from collections import defaultdict # Edge case when k is 0 or more than number of unique characters if k == 0 or k > len(set(s)): return \\"\\" # Initialize pointers and data structures left = 0 right = 0 n = len(s) char_count = defaultdict(int) max_len = 0 max_substr = \\"\\" # Iterate over the string with the right pointer while right < n: char_count[s[right]] += 1 # While we have more than k distinct characters, shrink the window while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 # Check and update the maximum length substring if len(char_count) == k: current_len = right - left + 1 if current_len > max_len: max_len = current_len max_substr = s[left:right + 1] # Move the right pointer to the next character right += 1 return max_substr"},{"question":"# Coding Assessment Question You need to implement a function `kth_largest_element` that finds the k-th largest element in an unsorted array using the Quickselect algorithm. # Function Signature ```python def kth_largest_element(arr: List[int], k: int) -> int: pass ``` # Input * `arr` (List[int]): A list of integers. * `k` (int): The k-th largest position to find (1-based index). # Output * Returns the k-th largest element as an integer. # Constraints * `1 <= len(arr) <= 10^5` * `1 <= k <= len(arr)` * `-10^9 <= element in arr <= 10^9` # Performance Requirements * The implementation should be efficient for large arrays. * Expected average time complexity is O(n), leveraging the Quickselect algorithm. # Example ```python arr = [3, 2, 1, 5, 6, 4] k = 2 result = kth_largest_element(arr, k) print(result) # Expected output: 5 arr = [7, 10, 4, 3, 20, 15] k = 3 result = kth_largest_element(arr, k) print(result) # Expected output: 10 ``` # Note * Ensure to handle edge cases such as `k` being 1 (largest element) and `k` being equal to the length of the array (smallest element). * Provide error handling for invalid inputs, such as `k` being out of the valid range.","solution":"from typing import List import random def kth_largest_element(arr: List[int], k: int) -> int: Finds the k-th largest element in an unsorted array using the Quickselect algorithm. if not (1 <= k <= len(arr)): raise ValueError(\\"k is out of the valid range\\") def quickselect(low, high, index): pivot_index = random_partition(low, high) if pivot_index == index: return arr[pivot_index] elif pivot_index < index: return quickselect(pivot_index + 1, high, index) else: return quickselect(low, pivot_index - 1, index) def random_partition(low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] return partition(low, high) def partition(low, high): pivot = arr[high] i = low for j in range(low, high): if arr[j] > pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# File Management and Data Processing Coding Challenge **Context**: You are tasked with analyzing a large log file from a web server to identify potential security issues. Each line in the log file contains a request made to the server, including the IP address of the client making the request, the date and time of the request, and the requested resource. # Function Implementation Implement a function named `find_suspicious_ip_addresses` that accepts the following parameter: 1. `file_path` (str): The path to the log file. The function should perform the following: 1. Validate the input to ensure it is a non-empty string. 2. Read and parse the log file to extract IP addresses. 3. Count the number of requests made by each IP address. 4. Identify IP addresses that made more than 100 requests as suspicious. 5. Return a list of those suspicious IP addresses. **Specifications**: - If `file_path` is `None` or an empty string, return `None`. - If the file cannot be read (due to errors like file not found), return `None`. - Return a sorted list of suspicious IP addresses in ascending order. - Each log entry is in the format: `[IP_ADDRESS] - - [DATE/TIME] \\"REQUEST_METHOD RESOURCE HTTP_VERSION\\" STATUS_CODE RESPONSE_SIZE` **Constraints**: - Assume well-formed entries in the log file. - The log file can be very large, so ensure your solution is efficient in both time and space. # Example Consider a log file `server.log` with the following entries: ``` 192.168.1.1 - - [01/Jan/2023:00:00:01 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 192.168.1.2 - - [01/Jan/2023:00:00:02 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 192.168.1.1 - - [01/Jan/2023:00:00:03 +0000] \\"GET /index.html HTTP/1.1\\" 200 1024 ... ``` Calling the function as follows: ```python suspicious_ips = find_suspicious_ip_addresses(\'server.log\') ``` Should return something like: ```python [\'192.168.1.1\', \'192.168.1.5\', \'192.168.1.10\'] ``` **Test Cases**: 1. `find_suspicious_ip_addresses(None)` should return `None`. 2. `find_suspicious_ip_addresses(\'\')` should return `None`. 3. `find_suspicious_ip_addresses(\'non_existent_file.log\')` should return `None`. 4. `find_suspicious_ip_addresses(\'normal_server.log\')` should return a list of suspicious IP addresses that made more than 100 requests. **Notes**: - Ensure your function handles exceptions and edge cases as specified. - You may assume that the necessary imports (`os`, `collections`, etc.) are available for parsing the file and counting the occurrences. **Example Implementation**: ```python import os from collections import defaultdict def find_suspicious_ip_addresses(file_path: str) -> list | None: if not file_path or not isinstance(file_path, str): return None if not os.path.isfile(file_path): return None ip_count = defaultdict(int) try: with open(file_path, \'r\') as file: for line in file: parts = line.split(\' \') if len(parts) < 1: continue ip_address = parts[0] ip_count[ip_address] += 1 except OSError: return None suspicious_ips = [ip for ip, count in ip_count.items() if count > 100] return sorted(suspicious_ips) ```","solution":"import os from collections import defaultdict def find_suspicious_ip_addresses(file_path: str) -> list | None: if not file_path or not isinstance(file_path, str): return None if not os.path.isfile(file_path): return None ip_count = defaultdict(int) try: with open(file_path, \'r\') as file: for line in file: parts = line.split(\' \') if len(parts) < 1: continue ip_address = parts[0] ip_count[ip_address] += 1 except OSError: return None suspicious_ips = [ip for ip, count in ip_count.items() if count > 100] return sorted(suspicious_ips)"},{"question":"# Context You are developing an image processing application, and one of the tasks requires you to handle matrix operations efficiently. To improve the application, you need to implement a function to perform matrix multiplication. Matrix multiplication is a fundamental operation in various applications such as graphics, machine learning, and scientific computing. # Task Implement the function `matrix_multiply` that multiplies two matrices A and B. Function Signature ```python def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input - `A` (List[List[int]]): a matrix with dimensions m x n, where 1 ≤ m, n ≤ 100. - `B` (List[List[int]]): a matrix with dimensions n x p, where 1 ≤ p ≤ 100. Output - Returns the matrix product of A and B, which is a matrix with dimensions m x p. # Constraints - The elements of matrices A and B are integer values between -1000 and 1000. # Performance Requirements - The solution must handle the multiplication of matrices within reasonable time limits given the constraint dimensions. # Example ```python # Example 1 A = [ [1, 2], [4, 5] ] B = [ [1, 2], [4, 5] ] print(matrix_multiply(A, B)) # Output: [[9, 12], [24, 33]] # Example 2 A = [ [2, 3], [0, 1] ] B = [ [1, 4], [2, 5] ] print(matrix_multiply(A, B)) # Output: [[8, 23], [2, 5]] ``` # Hints - Matrix multiplication follows the rule: (AB)_ij = Σ_k A_ik * B_kj, where the sum is over all valid k. - Ensure the dimensions match: The number of columns in matrix A must equal the number of rows in matrix B.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices A and B. A has dimensions m x n B has dimensions n x p Returns the matrix product which has dimensions m x p # Number of rows in A and columns in B m, n, p = len(A), len(A[0]), len(B[0]) # Initialize result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Validate JSON Object Against Schema You are asked to create a Python class that validates whether a given JSON object adheres to a specified schema. The schema and the JSON object will both be provided as dictionaries. The validation must check for required keys, the correct data type of values, and nested structures. Function Signature: ```python class JSONSchemaValidator: def __init__(self, schema: dict) -> None: pass def validate(self, json_object: dict) -> bool: pass ``` Requirements: 1. **Initialization**: - The constructor should accept a schema represented as a dictionary and store it. 2. **Validation Method**: - The `validate` method should take a JSON object (also represented as a dictionary) and check if it matches the schema. - The schema will specify the required keys and their data types. 3. **Type Checking**: - Ensure each key in the JSON object matches the data type defined in the schema. - Support the following data types: `int`, `float`, `str`, `bool`, `list`, `dict`. 4. **Nested Structure**: - The schema may define nested dictionaries. The validator should correctly validate these nested structures. 5. **Error Handling**: - If the JSON object does not match the schema, the validator should return `False`. Example: ```python # Example Schema schema = { \\"name\\": str, \\"age\\": int, \\"email\\": str, \\"address\\": { \\"street\\": str, \\"city\\": str, \\"zipcode\\": int } } # Example JSON Object json_object = { \\"name\\": \\"John Doe\\", \\"age\\": 30, \\"email\\": \\"john.doe@example.com\\", \\"address\\": { \\"street\\": \\"123 Main St\\", \\"city\\": \\"Springfield\\", \\"zipcode\\": 12345 } } # Create an instance of the JSONSchemaValidator validator = JSONSchemaValidator(schema=schema) # Validate the JSON object print(validator.validate(json_object)) # Expected output: True ``` **Note**: Handle all edge cases, such as missing required keys, incorrect data types, and nested structure validations.","solution":"class JSONSchemaValidator: def __init__(self, schema: dict) -> None: self.schema = schema def validate(self, json_object: dict) -> bool: return self._validate(self.schema, json_object) def _validate(self, schema: dict, json_object: dict) -> bool: for key, value_type in schema.items(): if key not in json_object: return False if isinstance(value_type, dict): if not self._validate(value_type, json_object[key]): return False elif not isinstance(json_object[key], value_type): return False return True"},{"question":"# Binary Tree to Doubly Linked List Conversion You are asked to convert a given binary tree into a doubly linked list in place. The doubly linked list should follow the in-order traversal of the binary tree, meaning the leftmost node will be the head of the list, followed by its in-order successor, and so on. # Problem Statement Write a function `convert_to_doubly_linked_list(root: TreeNode) -> Optional[TreeNode]` that takes the root of a binary tree and converts it to a doubly linked list in place, following in-order traversal. The function should return the head of the doubly linked list. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_doubly_linked_list(root: TreeNode) -> Optional[TreeNode]: pass ``` # Input * `root` (`TreeNode`): The root node of the binary tree. # Output * `Optional[TreeNode]`: The head node of the resulting doubly linked list, or `None` if the tree is empty. # Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-1000 <= TreeNode.val <= 1000` # Example ```python # Example 1 root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5) ) dll_head = convert_to_doubly_linked_list(root) # Output should be nodes in order: 1 <-> 2 <-> 3 <-> 4 <-> 5 # Verify the result by traversing the linked list from head to end current = dll_head result = [] while current: result.append(current.val) current = current.right print(result) # Expected output: [1, 2, 3, 4, 5] # Example 2 root = None dll_head = convert_to_doubly_linked_list(root) print(dll_head) # Expected output: None ``` # Additional Notes * The left pointer in the binary tree should be utilized as the prev pointer in the doubly linked list. * The right pointer in the binary tree should be utilized as the next pointer in the doubly linked list. * Handle edge cases such as an empty tree, single-node tree, and highly unbalanced trees efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convert_to_doubly_linked_list(root: TreeNode): Converts a binary tree to a doubly linked list in place and returns the head of the list. if not root: return None # Dummy node to help with the conversion dummy = TreeNode(0) prev = dummy def inorder(node): nonlocal prev if not node: return # In-order traversal: visit left subtree inorder(node.left) # Node processing prev.right = node node.left = prev prev = node # In-order traversal: visit right subtree inorder(node.right) # Perform in-order traversal and node rearrangement inorder(root) # Head of the doubly linked list is right of the dummy node head = dummy.right # Set left pointer of head to None if head: head.left = None return head"},{"question":"**Scenario**: You are working on the payment processing system of an online store. The system needs to process sales transactions and apply various discounts as described in the pricing rules. Implement a system to calculate the final amount after applying the discounts and taking into account multiple transactions. **Requirements**: 1. Implement the class `TransactionProcessor` that can handle multiple transactions and apply discounts. 2. Implement the class `Transaction` to represent a single transaction. 3. Discounts to be applied include: - A percentage discount if the transaction amount exceeds a certain threshold. - A fixed discount if a specific item is purchased. 4. The `TransactionProcessor` should maintain a list of all transactions and be able to calculate the total amount after discounts. **Function Specifications**: - **Transaction(description, amount):** - Input: `description` (string) - the item description, and `amount` (float) - the transaction amount. - Output: Initializes a `Transaction` object. - **TransactionProcessor():** - Input: None. - Output: Initializes a `TransactionProcessor` object with an empty transaction list. - **add_transaction(transaction):** - Input: A `Transaction` object. - Output: Adds the transaction to the list of transactions. - **apply_percentage_discount(threshold, percent_discount):** - Input: `threshold` (float) - the amount above which the discount applies, and `percent_discount` (float) - the discount percentage to apply. - Output: Applies the percentage discount to all qualifying transactions. - **apply_fixed_discount(item_description, fixed_discount):** - Input: `item_description` (string) - the item description that qualifies for the discount, and `fixed_discount` (float) - the fixed amount to subtract. - Output: Applies the fixed discount to all qualifying transactions. - **calculate_total():** - Input: None. - Output: The total amount after applying all discounts. **Example**: ```python class Transaction: def __init__(self, description, amount): self.description = description self.amount = amount class TransactionProcessor: def __init__(self): self.transactions = [] def add_transaction(self, transaction): self.transactions.append(transaction) def apply_percentage_discount(self, threshold, percent_discount): for transaction in self.transactions: if transaction.amount > threshold: transaction.amount -= transaction.amount * (percent_discount / 100) def apply_fixed_discount(self, item_description, fixed_discount): for transaction in self.transactions: if transaction.description == item_description: transaction.amount -= fixed_discount def calculate_total(self): total_amount = sum(transaction.amount for transaction in self.transactions) return total_amount # Example usage tp = TransactionProcessor() t1 = Transaction(\\"Laptop\\", 1000) t2 = Transaction(\\"Mouse\\", 50) tp.add_transaction(t1) tp.add_transaction(t2) tp.apply_percentage_discount(500, 10) # Apply 10% discount on items costing more than 500 tp.apply_fixed_discount(\\"Mouse\\", 5) # Apply 5 discount on Mouse print(tp.calculate_total()) # Output: 945.0 ```","solution":"class Transaction: def __init__(self, description, amount): self.description = description self.amount = amount class TransactionProcessor: def __init__(self): self.transactions = [] def add_transaction(self, transaction): self.transactions.append(transaction) def apply_percentage_discount(self, threshold, percent_discount): for transaction in self.transactions: if transaction.amount > threshold: transaction.amount -= transaction.amount * (percent_discount / 100) def apply_fixed_discount(self, item_description, fixed_discount): for transaction in self.transactions: if transaction.description == item_description: transaction.amount -= fixed_discount def calculate_total(self): total_amount = sum(transaction.amount for transaction in self.transactions) return total_amount"},{"question":"Dyck Paths Counting Given a two-dimensional grid of cells, count the number of Dyck paths from the bottom-left corner to the top-right corner. A Dyck path is a path that proceeds by a sequence of steps either \\"up\\" or \\"right\\" such that no point on the path is ever above the main diagonal of the grid. The main diagonal is defined as the line from the bottom-left to the top-right of the grid. # Input - An integer `n`, the size of the grid. The grid is `n x n`. # Output - An integer representing the number of possible Dyck paths. # Constraints - (0 leq n leq 15) # Example ```python >>> dyck_paths_count(2) 2 >>> dyck_paths_count(3) 5 >>> dyck_paths_count(4) 14 ``` # Task Implement the following Python function: ```python def dyck_paths_count(n: int) -> int: # your code here ```","solution":"def dyck_paths_count(n: int) -> int: Return the number of Dyck paths in an n x n grid. if n == 0: return 1 # There\'s exactly 1 Dyck path in a 0x0 grid, the empty path. # Using dynamic programming to count the number of paths. dp = [[0] * (n + 1) for _ in range(n + 1)] dp[0][0] = 1 for i in range(n + 1): for j in range(n + 1): if i < j: # Ensure we are not above the main diagonal continue if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[n][n]"},{"question":"# Minimum Stack Implementation You need to implement a custom stack data structure called `MinStack` that supports the standard stack operations (push, pop, top) and includes an additional operation to retrieve the minimum element in the stack efficiently. Class Definition ```python class MinStack: def __init__(self) -> None: Initialize your data structure here. pass def push(self, val: int) -> None: Push element val onto stack. pass def pop(self) -> None: Removes the element on the top of the stack. pass def top(self) -> int: Get the top element. pass def getMin(self) -> int: Retrieve the minimum element in the stack. pass ``` Requirements 1. **Initialization**: The `__init__` method initializes all necessary structures to manage the stack and its minimum values. 2. **push**: Add an element to the stack, updating any supporting structure to keep track of the minimum value. 3. **pop**: Removes the top element from the stack, ensuring the minimum value tracking remains accurate. 4. **top**: Return the top element without removing it from the stack. 5. **getMin**: Return the current minimum value in the stack. Constraints * The stack can handle up to 10^5 operations efficiently. * All operations are expected to be performed in constant time, O(1). Example Usage: ```python minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) print(minStack.getMin()) # Output: -3 minStack.pop() print(minStack.top()) # Output: 0 print(minStack.getMin()) # Output: -2 ``` # Notes * Ensure robust handling of edge cases, like operations on an empty stack. * Your implementation should optimize for both time and space efficiency. # Analysis This question tests the candidate\'s ability to design and implement data structures that utilize efficient algorithms and maintain additional state information (like the current minimum value) without compromising performance.","solution":"class MinStack: def __init__(self) -> None: Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Push element val onto stack, and update the min stack. self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack, and update the min stack. if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] raise IndexError(\\"top from empty stack\\") def getMin(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] raise IndexError(\\"getMin from empty stack\\")"},{"question":"You are assigned to develop a data-tracking system for a simplified version of a warehouse inventory. The warehouse inventory must keep track of items and their respective quantities, and it should include the ability to add new items, remove items, and query the quantity of a specific item. # Objectives: 1. Create a class `InventorySystem` to manage inventory items. 2. Implement the `add_item` method to add an item to the inventory or update the quantity if the item already exists. 3. Implement the `remove_item` method to remove a given quantity of an item from the inventory. 4. Implement the `query_item` method to return the current quantity of a specific item. 5. Implement the `total_items` method to return the total number of unique items in the inventory. # Class and Function Definitions: - `class InventorySystem` - `def add_item(item: str, quantity: int) -> None` - **Input**: - item: The name of the item to add. - quantity: A positive integer representing the quantity of the item to add. - **Output**: None - `def remove_item(item: str, quantity: int) -> bool` - **Input**: - item: The name of the item to remove. - quantity: A positive integer representing the quantity of the item to remove. - **Output**: Boolean value indicating success (`True`) if the quantity could be removed, or failure (`False`) if the item does not exist or insufficient quantity to remove. - `def query_item(item: str) -> int` - **Output**: An integer representing the current quantity of the specified item. If the item does not exist, return 0. - `def total_items() -> int` - **Output**: An integer representing the total number of unique items in the inventory. # Constraints: - The item name (`item`) will be a non-empty string. - The quantity for both `add_item` and `remove_item` will be a positive integer. # Example Usage: ```python # Creating an instance of InventorySystem warehouse = InventorySystem() # Adding items to the inventory warehouse.add_item(\\"apple\\", 10) warehouse.add_item(\\"banana\\", 5) # Removing items from the inventory success = warehouse.remove_item(\\"apple\\", 3) print(success) # Output: True # Querying the quantity of an item quantity = warehouse.query_item(\\"apple\\") print(quantity) # Output: 7 # Querying the quantity of a non-existing item quantity = warehouse.query_item(\\"pear\\") print(quantity) # Output: 0 # Getting the total number of unique items total = warehouse.total_items() print(total) # Output: 2 ``` Implement the `InventorySystem` class in Python following provided specifications and constraints. Ensure the class accurately tracks item quantities and handles edge cases like removing items that do not exist or asking for quantities of non-existing items.","solution":"class InventorySystem: def __init__(self): self.inventory = {} def add_item(self, item: str, quantity: int) -> None: if item in self.inventory: self.inventory[item] += quantity else: self.inventory[item] = quantity def remove_item(self, item: str, quantity: int) -> bool: if item in self.inventory and self.inventory[item] >= quantity: self.inventory[item] -= quantity if self.inventory[item] == 0: del self.inventory[item] return True return False def query_item(self, item: str) -> int: return self.inventory.get(item, 0) def total_items(self) -> int: return len(self.inventory)"},{"question":"# Palindrome Sequence Check Background: A palindrome sequence is one that reads the same backward as forward. This can apply to a sequence of numbers in the same way it does to strings. Given a sequence of integers, your task is to determine whether the sequence is a palindrome. Task: You need to implement a function `is_palindrome_sequence` that checks if a given list of integers forms a palindrome. Requirements: - Write a function `is_palindrome_sequence(sequence: List[int]) -> bool` that determines if the provided list of integers is a palindrome. Function Signature: ```python def is_palindrome_sequence(sequence: List[int]) -> bool: # Your code here ``` Input: - `sequence`: A list of integers. Output: - Returns `True` if the list of integers is a palindrome. - Returns `False` otherwise. Example: ```python # Example 1 sequence = [1, 2, 3, 2, 1] print(is_palindrome_sequence(sequence)) # Returns True # Example 2 sequence = [1, 2, 3, 4, 5] print(is_palindrome_sequence(sequence)) # Returns False # Example 3 sequence = [7, 7, 7, 7] print(is_palindrome_sequence(sequence)) # Returns True ``` Constraints: - The function must handle sequences of up to 1,000,000 elements efficiently. - Elements of the sequence will be non-negative integers. Notes: - Consider edge cases such as an empty list or a list with one element. - Consider utilizing both iterative and recursive approaches to check for palindromic properties.","solution":"from typing import List def is_palindrome_sequence(sequence: List[int]) -> bool: Determine if the provided list of integers is a palindrome. Args: sequence (List[int]): A list of integers. Returns: bool: True if the list is a palindrome, False otherwise. return sequence == sequence[::-1]"},{"question":"# Scenario: A logistics company uses a tracking system to monitor its fleet of delivery trucks. The system logs the truck\'s speed at regular intervals, and the company wants to calculate the average speed over a period of time. Your task is to implement a function that calculates this average speed from a given list of speed measurements. # Problem Statement: Write a function `average_speed` that takes in a list of speed measurements and returns the average speed over the period of time. # Input: * `speeds` (List[float]): A list of speed measurements in kilometers per hour (km/h). All values in the list will be non-negative floats. # Output: * `average` (float): The computed average speed in kilometers per hour. # Constraints: * The `speeds` list will always contain at least one element. * If the list is empty, the function should return `0.0`. * The average should be calculated using simple arithmetic mean. * Ensure the function handles any edge cases properly. # Performance Requirements: * The function must perform the operation in O(n) time complexity, where n is the number of speed measurements. * Ensure to handle any exception or edge cases gracefully. # Function Signature: ```python def average_speed(speeds: List[float]) -> float: pass ``` # Examples: ```python average_speed([60.0, 70.0, 80.0]) # Expected Output: 70.0 average_speed([50.0, 50.0, 50.0, 50.0]) # Expected Output: 50.0 average_speed([0.0, 100.0]) # Expected Output: 50.0 average_speed([]) # Expected Output: 0.0 ``` # Notes: * Consider edge cases where the list might contain zero values. * Do not use any external libraries for the calculations. * The function should correctly compute the arithmetic mean and handle edge cases effectively.","solution":"from typing import List def average_speed(speeds: List[float]) -> float: if not speeds: return 0.0 total_speed = sum(speeds) num_measurements = len(speeds) return total_speed / num_measurements"},{"question":"# Problem Statement Your task is to implement a basic file comparison tool that can detect and report the differences between two text files. The comparison should identify and output the lines that are present in one file but not in the other, and vice versa. # Requirements Implement a function `compare_files(file1_path: str, file2_path: str) -> tuple[list[str], list[str]]` that performs the following steps: 1. **Read the content** of the two files specified by `file1_path` and `file2_path`. 2. **Compare the lines** from both files and determine: - Lines that are present in `file1` but not in `file2`. - Lines that are present in `file2` but not in `file1`. 3. **Return two lists**: - The first list containing the lines exclusive to `file1`. - The second list containing the lines exclusive to `file2`. # Components - **File Reading**: Implement efficient methods to read and process the lines of the files. - **Line Comparison**: Perform an optimized line-by-line comparison between the contents of the two files. # Input Constraints: - `file1_path` and `file2_path`: Both should be valid file paths pointing to text files with no restriction on file size. # Expected Output: The function should return a tuple: - **List of lines in File1 but not in File2**: A list of strings. - **List of lines in File2 but not in File1**: A list of strings. # Example: Assume `file1.txt` contains: ``` apple banana cherry date ``` And `file2.txt` contains: ``` banana cherry elderberry fig ``` ```python # Example usage unique_file1_lines, unique_file2_lines = compare_files(\'file1.txt\', \'file2.txt\') print(\\"Lines in file1.txt but not in file2.txt:\\", unique_file1_lines) print(\\"Lines in file2.txt but not in file1.txt:\\", unique_file2_lines) ``` Expected Output: ``` Lines in file1.txt but not in file2.txt: [\\"apple\\", \\"date\\"] Lines in file2.txt but not in file1.txt: [\\"elderberry\\", \\"fig\\"] ``` # Notes: 1. Implement appropriate error handling for scenarios such as file not found, permission issues, etc. 2. Ensure that the solution is optimized for performance, particularly when dealing with large files. 3. Consider edge cases such as empty files or files with a single line.","solution":"def compare_files(file1_path: str, file2_path: str) -> tuple[list[str], list[str]]: Compare two files and return lines that are exclusive to each file as lists. :param file1_path: Path to the first text file. :param file2_path: Path to the second text file. :return: A tuple containing: - A list of lines present in file1 but not in file2 - A list of lines present in file2 but not in file1 try: with open(file1_path, \'r\') as f1, open(file2_path, \'r\') as f2: lines_file1 = set(f1.read().splitlines()) lines_file2 = set(f2.read().splitlines()) unique_to_file1 = list(lines_file1 - lines_file2) unique_to_file2 = list(lines_file2 - lines_file1) return unique_to_file1, unique_to_file2 except FileNotFoundError: raise FileNotFoundError(\\"One or both of the file paths provided do not exist.\\") except Exception as e: raise e"},{"question":"# Question: Validate and Correct IP Addresses Context: Writing network applications often involves working with IP addresses. Occasionally, these IP addresses may be incorrectly formatted due to user error or data corruption. A valid IPv4 address is in the format \\"x.x.x.x\\", where x is a value between 0 and 255. Your task is to validate whether a string is a correctly formatted IPv4 address. Additionally, you should correct common user errors related to missing leading zeros or extra leading zeros on octets. Task: Implement the `IPAddressHelper` class with the following functionalities: 1. `is_valid_ip(ip: str) -> bool`: Method to check if the given string is a valid IPv4 address. 2. `correct_ip(ip: str) -> str`: Method to correct an IPv4 address by removing leading zeros in each octet. 3. Utility methods to assist with validation and correction as needed. Requirements: * **Input Formats**: - `is_valid_ip`: Takes a single string IP address. - `correct_ip`: Takes a single string IP address. * **Output Formats**: - `is_valid_ip`: Returns a boolean indicating whether the IP address is valid. - `correct_ip`: Returns a corrected string IP address or the original string if no correction is needed. * **Constraints**: - A valid IP address must contain exactly four octets separated by periods. - Each octet must be a numeric value between 0 and 255. - Common errors to handle may include extra leading zeros. - The implementation should not return address octets with leading zeros (e.g., \\"192.168.001.001\\" should become \\"192.168.1.1\\"). Example: ```python ip_helper = IPAddressHelper() valid_ip = \\"192.168.0.1\\" invalid_ip = \\"256.100.50.25\\" ip_with_extra_zeros = \\"172.016.254.001\\" print(ip_helper.is_valid_ip(valid_ip)) # Output: True print(ip_helper.is_valid_ip(invalid_ip)) # Output: False print(ip_helper.correct_ip(ip_with_extra_zeros)) # Output: \\"172.16.254.1\\" ``` **Note**: You must follow the structure for the `IPAddressHelper` class provided below. ```python class IPAddressHelper: def is_valid_ip(self, ip: str) -> bool: # Implementation here def correct_ip(self, ip: str) -> str: # Implementation here ``` Testing: Ensure your implementation passes the following doctests: ```python >>> ip_helper = IPAddressHelper() >>> valid_ip = \\"192.168.0.1\\" >>> invalid_ip = \\"256.100.50.25\\" >>> ip_with_extra_zeros = \\"172.016.254.001\\" >>> ip_helper.is_valid_ip(valid_ip) True >>> ip_helper.is_valid_ip(invalid_ip) False >>> ip_helper.correct_ip(ip_with_extra_zeros) \'172.16.254.1\' >>> ip_helper.correct_ip(invalid_ip) \'256.100.50.25\' ```","solution":"class IPAddressHelper: def is_valid_ip(self, ip: str) -> bool: # Split the IP into its components parts = ip.split(\\".\\") # Check if it has exactly four parts if len(parts) != 4: return False for part in parts: # Check if each part can be converted into an integer if not part.isdigit(): return False num = int(part) # Check if the integer is in the range 0 to 255 if num < 0 or num > 255: return False # Check if the part has leading zeros if part != str(num): return False # If all checks pass, then the IP is valid return True def correct_ip(self, ip: str) -> str: # Split the IP into its components parts = ip.split(\\".\\") # Correct each part by stripping leading zeros corrected_parts = [str(int(part)) for part in parts] # Join the corrected parts back into the IP string corrected_ip = \\".\\".join(corrected_parts) return corrected_ip"},{"question":"# Matrix Manipulation and Path Finding Implement a Matrix class that supports operations related to matrix manipulation and path finding. The goal is to provide efficient solutions to common matrix operations and to solve a specific path finding problem using the A* algorithm. # Problem Statement 1. **Implementation**: - Implement a method to rotate the matrix by 90 degrees clockwise or counter-clockwise. - Implement a method to transpose the matrix. - Implement the A* algorithm to find the shortest path from the top-left to the bottom-right corner of a binary matrix where `1` represents a walkable cell and `0` represents an obstacle. 2. **Function Signature**: ```python class Matrix: ... def rotate(self, direction: str = \\"clockwise\\") -> Matrix: Rotates the matrix 90 degrees in the given direction (\'clockwise\' or \'counter-clockwise\'). pass def transpose(self) -> Matrix: Transposes the matrix. pass def a_star_path(self) -> list[tuple[int, int]]: Finds the shortest path from the top-left to the bottom-right corner using the A* algorithm. pass ``` # Input and Output - `rotate`: - **Input**: A string direction which can be either \\"clockwise\\" or \\"counter-clockwise\\". - **Output**: A new Matrix object which is rotated by 90 degrees in the specified direction. - `transpose`: - **Input**: None. - **Output**: A new Matrix object which is the transpose of the original matrix. - `a_star_path`: - **Input**: None. - **Output**: A list of tuples representing the coordinates of the cells in the shortest path from the top-left to the bottom-right corner. # Constraints - The matrix is a 2D list of integers between 0 and 1. - The matrix dimensions are up to 100x100. - A valid path only exists if there are walkable cells from the start to the end. - Ensure that `rotate` and `transpose` functions are optimized for efficiency. - A* algorithm should be implemented optimally considering time and space complexity. # Example ```python # Matrix Rotation (Clockwise) m = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) rotated_matrix = m.rotate(\\"clockwise\\") print(rotated_matrix) # Expected: Matrix([[7, 4, 1], # [8, 5, 2], # [9, 6, 3]]) # Matrix Transposition m = Matrix([[1, 2, 3], [4, 5, 6]]) transposed_matrix = m.transpose() print(transposed_matrix) # Expected: Matrix([[1, 4], # [2, 5], # [3, 6]]) # A* Path Finding m = Matrix([[1, 0, 0, 0], [1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 1, 1]]) path = m.a_star_path() print(path) # Example Expected Output: [(0, 0), (1, 0), (2, 1), (3, 2), (3, 3)] ``` # Note Ensure that the rotation and transposition operations are correctly implemented and that the A* algorithm finds the optimal path efficiently, handling edge cases such as no available path.","solution":"import heapq class Matrix: def __init__(self, grid): self.grid = grid self.n = len(grid) self.m = len(grid[0]) if grid else 0 def rotate(self, direction: str = \\"clockwise\\") -> \'Matrix\': if direction == \\"clockwise\\": return Matrix([[self.grid[self.n - j - 1][i] for j in range(self.n)] for i in range(self.m)]) elif direction == \\"counter-clockwise\\": return Matrix([[self.grid[j][self.m - i - 1] for j in range(self.n)] for i in range(self.m)]) else: raise ValueError(\\"Invalid direction, must be \'clockwise\' or \'counter-clockwise\'\\") def transpose(self) -> \'Matrix\': return Matrix([[self.grid[j][i] for j in range(self.n)] for i in range(self.m)]) def a_star_path(self) -> list[tuple[int, int]]: def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) start = (0, 0) goal = (self.n - 1, self.m - 1) open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: neighbor = (current[0] + dx, current[1] + dy) if 0 <= neighbor[0] < self.n and 0 <= neighbor[1] < self.m and self.grid[neighbor[0]][neighbor[1]]: tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] # Return empty list if no path found"},{"question":"Coding Assessment Question # Context You are designing a file system simulation that supports creation of files and directories and allows efficient queries to list files or directories under a given directory path. # Task Implement a basic file system with the ability to create files and directories, as well as list the contents of a given directory. # Function Specifications **Class 1: FileSystem** - **Methods**: - **`mkdir`**: Creates a directory. - **Input**: - **`path: str`**: A string representing the absolute path of the directory to be created. - **Output**: None. - **`create_file`**: Creates a file. - **Input**: - **`path: str`**: A string representing the absolute path of the file to be created. - **`content: str`**: A string representing the content to be stored in the file. - **Output**: None. - **`ls`**: Lists the contents of a directory. - **Input**: - **`path: str`**: A string representing the absolute path of the directory whose contents are to be listed. - **Output**: A list of strings containing the names of files and directories under the given path. # Constraints - All paths are represented as UNIX-style paths (e.g., `/a/b/c`). - Directory names and file names consist of lowercase English letters and digits. - An empty string or a string with only `/` as input path for `ls` should list the contents of the root directory. - The root directory always exists. - You can assume non-existing paths should return an empty list or raise an error appropriately during access. # Example Usage ```python fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.create_file(\\"/c.txt\\", \\"Hello, World!\\") fs.create_file(\\"/a/b/d.txt\\", \\"Another file\\") print(fs.ls(\\"/\\")) # Output: [\\"a\\", \\"c.txt\\"] print(fs.ls(\\"/a\\")) # Output: [\\"b\\"] print(fs.ls(\\"/a/b\\")) # Output: [\\"d.txt\\"] print(fs.ls(\\"/a/b/d.txt\\")) # Should raise an error or return empty (invalid path for directory query) ``` # Notes - Be mindful of edge cases where paths may have redundant slashes or multiple path separators. - Ensure that the `ls` method responds in a way that correctly represents the current state of the file system.","solution":"class FileSystem: def __init__(self): self.fs = {\\"\\": {}} def mkdir(self, path: str): parts = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for part in parts: if part not in current: current[part] = {} current = current[part] def create_file(self, path: str, content: str): parts = path.strip(\\"/\\").split(\\"/\\") file_name = parts.pop() current = self.fs[\\"\\"] for part in parts: if part not in current: current[part] = {} current = current[part] current[file_name] = content def ls(self, path: str): if path == \\"/\\": current = self.fs[\\"\\"] else: parts = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"\\"] for part in parts: if part in current: current = current[part] else: return [] if isinstance(current, dict): return sorted(current.keys()) return []"},{"question":"# Scenario In competitive programming, it is often required to find the smallest or largest values in a data set. One common operation is to find the k-th smallest or k-th largest value in a list of integers. # Problem Create a function: 1. `find_kth_number(arr: List[int], k: int, order: str) -> int`: This function should find the k-th smallest or k-th largest number in the provided list of integers. # Requirements - Implement this function to correctly identify the k-th smallest or k-th largest number based on the order specified. - Raise a `ValueError` with an appropriate message if `k` is not within the valid range (i.e., 1 to length of list). - Raise a `ValueError` if the `order` parameter is not \'smallest\' or \'largest\'. # Function Signature ```python from typing import List def find_kth_number(arr: List[int], k: int, order: str) -> int: ... ``` # Input and Output - **Input**: - A list of integers `arr`. - An integer `k` representing the 1-based index of the element to find. - A string `order` which can be either \'smallest\' or \'largest\'. - **Output**: An integer representing the k-th smallest or k-th largest number in the list. # Constraints - The elements in the list `arr` will be in the range -10^6 to 10^6. - The length of the list `arr` will be at least 1 and at most 10^5. - The value of `k` will be in the range 1 to len(arr). - Only \'smallest\' or \'largest\' are valid values for `order`. # Examples - `find_kth_number([3, 1, 2, 1, 4, 6], 2, \'smallest\')` should return `1`. - `find_kth_number([3, 1, 2, 1, 4, 6], 2, \'largest\')` should return `4`. - `find_kth_number([7, 5, 3, 2, 8, 6], 3, \'smallest\')` should return `5`. - `find_kth_number([7, 5, 3, 2, 8, 6], 3, \'largest\')` should return `6`. # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the function.","solution":"from typing import List def find_kth_number(arr: List[int], k: int, order: str) -> int: if k < 1 or k > len(arr): raise ValueError(\\"k is out of the valid range\\") if order not in [\\"smallest\\", \\"largest\\"]: raise ValueError(\\"order must be either \'smallest\' or \'largest\'\\") arr_sorted = sorted(arr) if order == \\"smallest\\": return arr_sorted[k-1] elif order == \\"largest\\": return arr_sorted[-k]"},{"question":"Problem Overview You are given a matrix of characters and a target word. Your task is to determine if the target word exists in the matrix. The word can be constructed from adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. This problem tests your ability to implement a classic depth-first search (DFS) algorithm to solve a pathfinding problem in a 2D grid. Detailed Description # Function Specification You need to implement the following function: ```python def exist(board: list[list[str]], word: str) -> bool: Determines if the given word exists in the matrix by navigating through adjacent cells. Parameters: board (list[list[str]]): A 2D list of characters representing the board. word (str): A string representing the target word to be found. Returns: bool: True if the word exists in the board, False otherwise. pass ``` # Input - A 2D list of characters `board`, with dimensions m x n, where 0 ≤ m, n ≤ 200 and each character is a lowercase English letter. - A string `word` with a length of 1 ≤ len(word) ≤ 10^3, consisting of lowercase English letters. # Output - Boolean `True` if the word exists in the board; `False` otherwise. # Constraints - You must use a depth-first search (DFS) approach to navigate through the board. - Ensure efficient backtracking to handle revisits of the same cell. - Handle edge cases like empty boards and words gracefully. # Example: ```python >>> exist([[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], \\"ABCCED\\") True >>> exist([[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], \\"SEE\\") True >>> exist([[\'A\',\'B\',\'C\',\'E\'], [\'S\',\'F\',\'C\',\'S\'], [\'A\',\'D\',\'E\',\'E\']], \\"ABCB\\") False >>> exist([[]], \\"\\") False >>> exist([[\'A\']], \\"A\\") True ``` # Implementation Notes - Utilize a recursive DFS strategy to explore all potential paths in the grid. - Use a visited set or modify the grid in-place to avoid revisiting cells within the same path. - Ensure your solution is efficient enough to handle the upper bounds of the input size constraints.","solution":"def exist(board: list[list[str]], word: str) -> bool: def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False # temporarily mark the cell as visited temp = board[i][j] board[i][j] = \'#\' # explore all possible directions found = (dfs(board, word, i+1, j, word_index+1) or dfs(board, word, i-1, j, word_index+1) or dfs(board, word, i, j+1, word_index+1) or dfs(board, word, i, j-1, word_index+1)) # unmark the cell board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == word[0] and dfs(board, word, i, j, 0): return True return False"},{"question":"Context In many programming scenarios, we often need to manipulate strings and perform operations such as reversing words, counting characters, and modifying the format. One common problem is to reverse the characters in each word of a string while keeping the words’ order intact. Task Implement a function `reverse_words` that reverses the characters in each word in a given string while maintaining the order of the words. **Function Signature:** ```python def reverse_words(s: str) -> str: Reverses the characters in each word of a string while maintaining the word order. Args: s (str): A string containing words separated by spaces. Returns: str: A string where the characters in each word are reversed, but the words\' order is preserved. Examples: >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"python programming\\") \\"nohtyp gnimmargorp\\" >>> reverse_words(\\"a b c d\\") \\"a b c d\\" >>> reverse_words(\\"reverse the characters\\") \\"esrever eht sretcarahc\\" >>> reverse_words(\\" leading and trailing spaces \\") \\"gnidael dna gniliart secaps\\" ``` **Constraints:** 1. The input string can contain up to (10^5) characters. 2. The input string consists of printable ASCII characters and spaces. 3. Words are separated by single spaces. Any leading or trailing spaces should be trimmed in the final output. **Performance Requirements:** - The time complexity should be (O(n)), where (n) is the length of the string. - The space complexity should be (O(n)).","solution":"def reverse_words(s: str) -> str: Reverses the characters in each word of a string while maintaining the word order. Args: s (str): A string containing words separated by spaces. Returns: str: A string where the characters in each word are reversed, but the words\' order is preserved. return \' \'.join(word[::-1] for word in s.split())"},{"question":"# Question: String Pattern Expansion Given a string that contains segments in the format `{n|pattern}`, where `n` is an integer indicating how many times the `pattern` should be repeated, expand the string by repeating the patterns accordingly. Requirements: 1. Write a function `expand_pattern` that accepts a single parameter `input_string` (a string containing patterns formatted as `{n|pattern}`) and returns the expanded string. 2. The segments can be nested, and your function should handle such cases appropriately. 3. Handle edge cases such as empty input strings, malformed segments, and large values of `n`. Function Signature: ```python def expand_pattern(input_string: str) -> str: pass ``` Input: * `input_string` – A string consisting of segments in the format `{n|pattern}`, where `n` is an integer and `pattern` is any string, possibly containing nested segments. Output: * A single string where all the segments have been expanded. Constraints: * `1 <= len(input_string) <= 10^5` * `1 <= n <= 100` Example Usage: ```python >>> print(expand_pattern(\\"Hello{3|ab}world\\")) Helloabababworld >>> print(expand_pattern(\\"{2|a{3|bc}}\\")) abcbcbcabcbcbc >>> print(expand_pattern(\\"No patterns here\\")) No patterns here ``` # Explanation * In the first example, the string `Hello{3|ab}world` expands to `Helloabababworld` as `{3|ab}` is replaced by `ab` repeated 3 times. * In the second example, the string `{2|a{3|bc}}` expands to `abcbcbcabcbcbc` as `{3|bc}` is first expanded to `bcbcbc` and then `{2|a{3|bc}}` is replaced by `a` followed by `bcbcbc` repeated 2 times. * In the third example, there are no segments to expand, so the string remains unchanged. Ensure your solution efficiently handles nesting and large input sizes.","solution":"def expand_pattern(input_string): import re def expand_segment(match): n, pattern = int(match.group(1)), match.group(2) return pattern * n while True: # This regex matches the most nested segments first input_string, count = re.subn(r\'{(d+)|([^{}]*)}\', expand_segment, input_string) if count == 0: break return input_string"},{"question":"# Problem Statement A prime ring is a circular arrangement of the numbers 1 through n such that every adjacent pair of numbers sum to a prime number. The first and last numbers in the ring are also considered adjacent. The task is to implement a function that computes all possible prime rings for a given integer `n`. # Function Signature ```python def prime_rings(n: int) -> List[List[int]]: ``` # Input * `n` (int): An integer where `1 ≤ n ≤ 20`. # Output * A list of lists, where each list represents a prime ring for the given integer `n`. Each prime ring should be a permutation of the numbers from `1` to `n` and the numbers should be arranged in ascending order starting from 1 when presenting the ring. # Constraints - `1 ≤ n ≤ 20` # Example ```python assert prime_rings(6) == [ [1, 4, 3, 2, 5, 6], [1, 6, 5, 2, 3, 4] ] assert prime_rings(4) == [ [1, 2, 3, 4], [1, 4, 3, 2] ] ``` # Hints 1. Generate all permutations of the numbers from `1` to `n` and check each to see if it forms a prime ring. 2. Use a helper function to check if the sum of any two adjacent numbers in the permutation is a prime number. 3. Keep in mind that in a prime ring, the first and last numbers are also considered adjacent.","solution":"from typing import List from itertools import permutations def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def check_prime_ring(ring): n = len(ring) for i in range(n): if not is_prime(ring[i] + ring[(i+1) % n]): return False return True def prime_rings(n: int) -> List[List[int]]: if n == 1: return [[1]] numbers = list(range(1, n + 1)) prime_ring_permutations = [] for perm in permutations(numbers[1:]): ring = [1] + list(perm) if check_prime_ring(ring): prime_ring_permutations.append(ring) return prime_ring_permutations"},{"question":"# Scenario You are developing a system for managing a playlist of songs. The system needs to support the functionality of shuffling songs into a random order while ensuring that no song is played twice before all have been played once. # Task You are required to write a function called `shuffle_playlist` that takes in a list of song titles and returns a new list with the songs in a random order. Each shuffle operation should produce a different permutation of the list from previous ones. # Requirements * **Input**: - A list of strings `songs` (0 <= len(songs) <= 10^4), e.g., `[\\"Song A\\", \\"Song B\\", \\"Song C\\"]` * **Output**: - A list of strings in a random order, e.g., `[\\"Song C\\", \\"Song A\\", \\"Song B\\"]` * **Constraints**: - Ensure the output list is a valid permutation of the input list. - Avoiding using Python built-in shuffle functions. - Ensure the function runs efficiently, even for large lists. Here\'s the function signature: ```python import random def shuffle_playlist(songs): pass ``` # Example ```python >>> shuffle_playlist([\\"Song A\\", \\"Song B\\", \\"Song C\\"]) [\\"Song B\\", \\"Song C\\", \\"Song A\\"] >>> shuffle_playlist([]) [] ``` # Notes 1. Consider using an efficient algorithm to generate the random permutation, such as the Fisher-Yates shuffle. 2. Ensure that the original list remains unmodified. 3. Provide inline documentation to explain your logic and approach.","solution":"import random def shuffle_playlist(songs): Shuffles the input list of songs into a random order using the Fisher-Yates shuffle algorithm. Args: songs (list of str): List of song titles to be shuffled. Returns: list of str: List of song titles in a random order. # Copy the input list to avoid modifying the original list shuffled_songs = songs[:] # Get the length of the list n = len(shuffled_songs) # Fisher-Yates Shuffle Algorithm for i in range(n - 1, 0, -1): # Pick a random index from 0 to i (inclusive) j = random.randint(0, i) # Swap shuffled_songs[i] with the element at random index shuffled_songs[i], shuffled_songs[j] = shuffled_songs[j], shuffled_songs[i] return shuffled_songs"},{"question":"# Problem Statement: You are tasked with implementing a binary search algorithm to find the position of a target value within a sorted array of integers. If the target value is found, return its index. If the target value is not found in the array, return -1. # Input: 1. **Array**: A list of integers that is already sorted in ascending order. 2. **Target**: An integer representing the value you need to find in the array. # Output: 1. An integer representing the index of the target value in the sorted array, or -1 if the target value is not present in the array. # Requirements: 1. Your solution must implement the binary search algorithm. 2. Do not use built-in search functions or methods. 3. Handle edge cases where the array is empty or the target value is not present. # Constraints: - The array must be a sorted list of integers. - The target must be an integer. - The array length (n) can range from 0 to 10,000. # Example: Input: ```python arr = [1, 3, 5, 7, 9, 11] target = 5 ``` Output: ```python 2 ``` # Solution Template: You may use the structure provided below as a starting point: ```python def binary_search(arr, target): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 mid_val = arr[mid] if mid_val == target: return mid elif mid_val < target: low = mid + 1 else: high = mid - 1 return -1 if __name__ == \\"__main__\\": arr = list(map(int, input(\\"Enter a sorted array of integers: \\").split())) target = int(input(\\"Enter the target value: \\")) result = binary_search(arr, target) print(result) ``` # Note: Ensure to test your function thoroughly, especially for edge cases like an empty array, single-element array, and the target value being at the first or last position in the array.","solution":"def binary_search(arr, target): Perform binary search on a sorted list to find the target value. Args: arr (list): A sorted list of integers. target (int): The target integer to find in the array. Returns: int: The index of the target integer in the array, or -1 if the target is not found. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 mid_val = arr[mid] if mid_val == target: return mid elif mid_val < target: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Coding Question **Objective**: Write a function to generate a sequence of prime numbers up to a given limit. # Problem Statement You need to write a function `generate_primes(limit: int) -> List[int]` that takes an integer limit as input and returns a list of all prime numbers less than or equal to that limit. # Input Format - A single integer `limit` (2 ≤ limit ≤ 10^6). # Output Format - A list of integers where each integer is a prime number less than or equal to the input limit. # Constraints - The input integer will always be greater than or equal to 2. # Example ```python assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(1) == [] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] ``` # Requirements - You should use an efficient algorithm such as the Sieve of Eratosthenes to ensure that your solution can handle input sizes up to 1,000,000 efficiently. - Ensure that your implementation correctly handles edge cases, such as when the limit is a prime number itself. # Function Signature ```python def generate_primes(limit: int) -> List[int]: pass ``` # Example Usage ```python # Example Usage print(generate_primes(10)) # Output: [2, 3, 5, 7] print(generate_primes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] print(generate_primes(2)) # Output: [2] ```","solution":"def generate_primes(limit: int) -> list[int]: Returns a list of all prime numbers less than or equal to the given limit. if limit < 2: return [] sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(limit ** 0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"# Problem Statement Create a function that calculates the power set of a given list of unique integers. The power set is a set of all subsets, including the empty set and the given set itself. # Function Signature ```python def power_set(nums: List[int]) -> List[List[int]]: pass ``` # Input * `nums`: A list of `n` unique integers, where (0 leq n leq 10). # Output * A list of lists, where each sublist is a subset of the input list `nums`. # Constraints * The function should correctly handle edge cases where the list is empty or contains a single element. * The function should not use any libraries for generating subsets. * The function should be efficient in terms of both time and space within the bounds of the input size. # Example ```python >>> power_set([]) [[]] >>> power_set([1]) [[], [1]] >>> power_set([1, 2]) [[], [1], [2], [1, 2]] >>> power_set([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` # Additional Information Ensure the power set generation leverages a method that explores all possible combinations of the elements and includes each subset exactly once. The function should be mindful of performance within the provided constraints.","solution":"from typing import List def power_set(nums: List[int]) -> List[List[int]]: Returns the power set of the given list of unique integers. res = [[]] for num in nums: res += [curr + [num] for curr in res] return res"},{"question":"# Elevator System Simulation Elevator systems are complex but critical components of modern buildings. Your task is to simulate a basic elevator system that can handle requests and move between floors efficiently. # Problem Statement Create a class `ElevatorSystem` that represents an elevator in a building with multiple floors. The system should handle requests to move to different floors and keep track of the current position of the elevator. # Class Definition ```python class ElevatorSystem: def __init__(self, num_floors: int): self.num_floors = num_floors self.current_floor = 1 def request_floor(self, floor: int) -> str: pass ``` # Detailed Requirements 1. **Initialization**: * **Input**: An integer `num_floors` (2 ≤ num_floors ≤ 1000) representing the number of floors in the building. The elevator starts at floor 1. 2. **request_floor Method**: * **Input**: An integer `floor` (1 ≤ floor ≤ num_floors) representing the floor the user wants to go to. * **Output**: Return a string indicating the action taken by the elevator, for example: - \\"Moving up to floor X\\" if the requested floor is higher than the current floor. - \\"Moving down to floor X\\" if the requested floor is lower than the current floor. - \\"Already on floor X\\" if the requested floor is the same as the current floor. # Constraints * Ensure the `request_floor` method does not allow invalid floor requests that are out of the building\'s range. * Handle edge cases such as requests to the same floor or requests for the lowest and highest floors. # Example ```python elevator = ElevatorSystem(10) print(elevator.request_floor(5)) # Expected Output: \\"Moving up to floor 5\\" print(elevator.request_floor(2)) # Expected Output: \\"Moving down to floor 2\\" print(elevator.request_floor(2)) # Expected Output: \\"Already on floor 2\\" print(elevator.request_floor(8)) # Expected Output: \\"Moving up to floor 8\\" ``` # Performance Requirements The solution should efficiently handle requests, with a time complexity of O(1) for each request since it involves only simple comparison and update operations. This question requires you to implement a simple simulation of an elevator system, testing your ability to manage state and handle edge cases in a practical scenario.","solution":"class ElevatorSystem: def __init__(self, num_floors: int): self.num_floors = num_floors self.current_floor = 1 def request_floor(self, floor: int) -> str: if floor < 1 or floor > self.num_floors: return \\"Invalid floor request\\" if floor > self.current_floor: result = f\\"Moving up to floor {floor}\\" self.current_floor = floor elif floor < self.current_floor: result = f\\"Moving down to floor {floor}\\" self.current_floor = floor else: result = f\\"Already on floor {floor}\\" return result"},{"question":"# Coding Assessment Question Scenario Sorting algorithms are fundamental to computer science and are widely used across various domains, from data analysis to machine learning preprocessing. One such algorithm is the Quick Sort, known for its efficiency and simplicity. Task Implement the Quick Sort algorithm in Python. Your implementation should be able to sort both numerical and string lists. Additionally, implement an optimization that selects the pivot element using the \\"median-of-three\\" approach to improve average-case performance. Requirements 1. Implement a function `quick_sort` that: - Takes a list of comparable elements (either all integers or all strings). - Sorts the list in-place using the Quick Sort algorithm. 2. Use the \\"median-of-three\\" rule to select the pivot: - Choose the median value of the first, middle, and last elements of the list or sublist. 3. Demonstrate your implementation with the following cases: - Sort the list `[3, 6, 8, 10, 1, 2, 1]`. - Sort the list `[\\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\"]`. Function Signature ```python def quick_sort(arr: List[Union[int, str]]) -> None: # Implement the quick sort algorithm with median-of-three pivot selection # Example usage numbers = [3, 6, 8, 10, 1, 2, 1] quick_sort(numbers) print(numbers) # Expected sorted list [1, 1, 2, 3, 6, 8, 10] strings = [\\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\"] quick_sort(strings) print(strings) # Expected sorted list [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"orange\\"] ``` Input Format - A list of integers or a list of strings. Output Format - The function directly modifies the input list to produce a sorted order. Constraints - The list contains elements of a single type (all integers or all strings). - The list length is at most `10^5`. Performance Requirements - Implement the Quick Sort to have an average-case time complexity of O(n log n). # Notes for the Candidate - Ensure that your implementation handles edge cases such as an empty list or a list with a single element. - Use auxiliary functions if necessary to maintain code readability and modularity.","solution":"from typing import List, Union def quick_sort(arr: List[Union[int, str]]) -> None: def median_of_three(a, b, c): if (a <= b <= c) or (c <= b <= a): return b elif (b <= a <= c) or (c <= a <= b): return a else: return c def partition(low, high): mid = (low + high) // 2 pivot_val = median_of_three(arr[low], arr[mid], arr[high]) arr[low], arr[high] = arr[high], arr[low] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort_recursive(low, high): if low < high: pi = partition(low, high) quicksort_recursive(low, pi - 1) quicksort_recursive(pi + 1, high) if len(arr) > 1: quicksort_recursive(0, len(arr) - 1) # Example usage numbers = [3, 6, 8, 10, 1, 2, 1] quick_sort(numbers) print(numbers) # Expected sorted list [1, 1, 2, 3, 6, 8, 10] strings = [\\"apple\\", \\"orange\\", \\"banana\\", \\"kiwi\\"] quick_sort(strings) print(strings) # Expected sorted list [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"orange\\"]"},{"question":"```markdown # Coding Assessment Question Scenario: You\'re working on analyzing a series of transactions for potential fraud. Each transaction is recorded with a unique ID, a timestamp, and an amount. Your task is to identify if any transactions are repeated within a specified time window to flag them for potential fraud. Problem Statement: Implement a function that processes a list of transaction records and identifies all transactions that occur more than once within a given time window. The function should return a list of flagged transaction IDs. Function Signature: ```python def flag_fraudulent_transactions( transactions: list[tuple[str, int]], window: int ) -> list[str]: ... ``` Input: 1. **`transactions` (list[tuple[str, int]]):** A list of tuples where each tuple contains a transaction ID (str) and a timestamp (int) representing the time the transaction occurred. 2. **`window` (int):** An integer representing the time window (in seconds) within which duplicate transactions are considered fraudulent. Output: 1. **`flagged_ids` (list[str]):** A list of transaction IDs that are flagged as fraudulent due to repetition within the specified time window. Constraints: * Transaction IDs are unique for each occurrence but can appear multiple times with different timestamps. * The timestamps are given in ascending order. * A transaction is considered fraudulent if it appears more than once within the time window across different entries. * The function should efficiently handle large lists of transactions. Example Usage: ```python transactions = [ (\\"txn1\\", 1), (\\"txn2\\", 2), (\\"txn1\\", 100), (\\"txn3\\", 102), (\\"txn2\\", 103), (\\"txn1\\", 105), ] window = 100 flagged_ids = flag_fraudulent_transactions(transactions, window) # Expected Output: # flagged_ids = [\\"txn1\\"] ``` ```","solution":"def flag_fraudulent_transactions(transactions, window): Identifies transactions appearing more than once within a specified time window. Parameters: transactions (list[tuple[str, int]]): List of transaction tuples containing transaction ID and timestamp. window (int): Time window in seconds to check for duplicate transactions. Returns: list[str]: List of flagged transaction IDs. from collections import defaultdict transaction_times = defaultdict(list) flagged_ids = set() for txn_id, timestamp in transactions: # Check if the current transaction falls within the window of any previous occurrence for t in transaction_times[txn_id]: if timestamp - t <= window: flagged_ids.add(txn_id) break # Add the current transaction to the list of times for the id transaction_times[txn_id].append(timestamp) return list(flagged_ids)"},{"question":"# Background You are implementing a file system simulator that tracks file operations and can determine the size of a directory or file, including nested directories. Each file and directory have a unique name and a size (for directories, the size is the sum of all contained files and directories). # Task Implement a class `FileSystem` that manages files and directories. Your implementation should adhere to the following specifications: Class Signature ```python class FileSystem: def __init__(self): pass def create_file(self, path: str, size: int) -> None: pass def create_directory(self, path: str) -> None: pass def delete(self, path: str) -> None: pass def get_size(self, path: str) -> int: pass ``` Methods 1. `create_file(path: str, size: int) -> None`: * `path`: A string representing the full path of the file to be created. * `size`: An integer indicating the size of the file in bytes. * Creates a file at the specified path with the given size. * Raises an error if the path is invalid or if a file or directory already exists at the specified path. 2. `create_directory(path: str) -> None`: * `path`: A string representing the full path of the directory to be created. * Creates a directory at the specified path. * Raises an error if the path is invalid or if a file or directory already exists at the specified path. 3. `delete(path: str) -> None`: * `path`: A string representing the full path of the file or directory to be deleted. * Deletes the file or directory at the specified path. * If a directory is deleted, all contents within the directory are also deleted. * Raises an error if the path is invalid or if no file or directory exists at the specified path. 4. `get_size(path: str) -> int`: * `path`: A string representing the full path of the file or directory. * Returns the size of the file or directory. * For a directory, this is the sum of the sizes of all files and directories within it, recursively. * Raises an error if the path is invalid or if no file or directory exists at the specified path. Constraints * The path strings will be in Unix-like format, e.g., \\"/dir1/dir2/file.txt\\". * The path will not contain trailing slashes. * All path operations are case-sensitive. * Disk size constraints: 0 < size ≤ 10^6 bytes. * File names and directory names are all alphanumeric and length ≤ 255 characters. * The maximum depth of the file system hierarchy: 100 Examples ```python fs = FileSystem() # Create files and directories fs.create_directory(\'/dir1\') fs.create_directory(\'/dir1/dir2\') fs.create_file(\'/dir1/dir2/file1.txt\', 100) fs.create_file(\'/dir1/dir2/file2.txt\', 200) # Query sizes print(fs.get_size(\'/dir1/dir2/file1.txt\')) # Output: 100 print(fs.get_size(\'/dir1/dir2\')) # Output: 300 print(fs.get_size(\'/dir1\')) # Output: 300 # Delete operations fs.delete(\'/dir1/dir2/file1.txt\') print(fs.get_size(\'/dir1/dir2\')) # Output: 200 print(fs.get_size(\'/dir1\')) # Output: 200 fs.create_directory(\'/dir3\') fs.create_file(\'/dir3/file3.txt\', 400) print(fs.get_size(\'/dir3\')) # Output: 400 ``` Ensure your implementation conforms to the constraints and matches the provided examples.","solution":"class FileSystem: def __init__(self): self.fs = {} def create_file(self, path: str, size: int) -> None: parts = path.strip(\'/\').split(\'/\') dir_path, file_name = \'/\'.join(parts[:-1]), parts[-1] dir_node = self._navigate(dir_path) if file_name in dir_node: raise ValueError(\\"File or directory already exists at the specified path\\") dir_node[file_name] = size def create_directory(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') dir_node = self._navigate(\'/\'.join(parts[:-1])) if parts[-1] in dir_node: raise ValueError(\\"File or directory already exists at the specified path\\") dir_node[parts[-1]] = {} def delete(self, path: str) -> None: parts = path.strip(\'/\').split(\'/\') dir_path, name_to_delete = \'/\'.join(parts[:-1]), parts[-1] dir_node = self._navigate(dir_path) if name_to_delete not in dir_node: raise ValueError(\\"No file or directory exists at the specified path\\") del dir_node[name_to_delete] def get_size(self, path: str) -> int: node = self._navigate(path.strip(\'/\')) if isinstance(node, int): return node else: return self._calculate_directory_size(node) def _navigate(self, path): if not path: return self.fs parts = path.split(\'/\') node = self.fs for part in parts: if part not in node: raise ValueError(\\"Path is invalid\\") node = node[part] return node def _calculate_directory_size(self, directory): total_size = 0 for name, item in directory.items(): if isinstance(item, int): total_size += item else: total_size += self._calculate_directory_size(item) return total_size"},{"question":"# Problem Statement You are tasked with implementing utility functions that analyze and manage parking lot allocations. A parking lot can be represented as a list of slots, where each slot can be either occupied or free. You are required to write two functions: `allocate_parking` and `deallocate_parking`. # Function Definitions 1. **allocate_parking** ```python def allocate_parking(parking_lot: list, car_id: int) -> list | ValueError: Input Parameters: ----------------- parking_lot: A list of integers where a value of 0 represents an empty slot and any other value represents an occupied slot with a car. car_id: An integer representing the identifier of the car to be parked. Returns: -------- The updated parking lot as a list of integers with the new car parked in the first available empty slot. Raises a ValueError if there are no empty slots available or if car_id is less than or equal to zero. ``` 2. **deallocate_parking** ```python def deallocate_parking(parking_lot: list, car_id: int) -> list | ValueError: Input Parameters: ----------------- parking_lot: A list of integers where a value of 0 represents an empty slot and any other value represents an occupied slot with a car. car_id: An integer representing the identifier of the car to be removed. Returns: -------- The updated parking lot as a list of integers with the specified car removed, making its slot available. Raises a ValueError if the car_id is not found in the parking lot or if car_id is less than or equal to zero. ``` # Constraints * Car identifiers (car_id) are positive integers. * A parking slot is either represented by zero (for free) or a positive integer (car_id) for occupied. * Empty slots will always be represented by zero in the parking lot list. # Example Scenarios: **Example 1**: ```python # Allocate a parking slot allocate_parking([0, 0, 2, 0, 4], 3) # Expected: [3, 0, 2, 0, 4] # Deallocate a parking slot deallocate_parking([3, 0, 2, 0, 4], 3) # Expected: [0, 0, 2, 0, 4] ``` **Example 2**: ```python # Invalid allocation due to no empty slot allocate_parking([1, 2, 3, 4, 5], 6) # Expected: ValueError(\'No empty slot available or car_id must be greater than 0.\') # Invalid deallocation due to non-existent car_id deallocate_parking([1, 0, 2, 0, 4], 3) # Expected: ValueError(\'Car_id not found or car_id must be greater than 0.\') ```","solution":"def allocate_parking(parking_lot: list, car_id: int) -> list | ValueError: if car_id <= 0: raise ValueError(\\"car_id must be greater than 0.\\") for i in range(len(parking_lot)): if parking_lot[i] == 0: parking_lot[i] = car_id return parking_lot raise ValueError(\\"No empty slot available.\\") def deallocate_parking(parking_lot: list, car_id: int) -> list | ValueError: if car_id <= 0: raise ValueError(\\"car_id must be greater than 0.\\") for i in range(len(parking_lot)): if parking_lot[i] == car_id: parking_lot[i] = 0 return parking_lot raise ValueError(\\"Car_id not found.\\")"},{"question":"# Coding Assessment Question Scenario You\'re working on a string manipulation library. Your objective is to create a function that checks if a string can be rearranged to form a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Task Implement the following function: ```python def can_form_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. Parameters: - s: A string of lowercase alphabetic characters (1 <= len(s) <= 1000). Returns: - A boolean indicating whether the string can be rearranged to form a palindrome. ``` Requirements 1. **`can_form_palindrome` Implementation**: Utilize efficient algorithms to determine if the string can be rearranged to a palindrome. 2. **Input Constraints**: (1 leq text{len}(s) leq 1000) 3. **Output**: A boolean indicating whether the string can be rearranged to form a palindrome. Example ```python assert can_form_palindrome(\\"civic\\") == True # \\"civic\\" is already a palindrome assert can_form_palindrome(\\"ivicc\\") == True # \\"ivicc\\" can be rearranged to \\"civic\\" assert can_form_palindrome(\\"hello\\") == False # \\"hello\\" cannot be rearranged to form a palindrome assert can_form_palindrome(\\"aabbcc\\") == True # \\"aabbcc\\" can be rearranged to \\"abccba\\" ``` Additional Notes - Assume the input string consists only of lowercase alphabetic characters. - Consider performance implications and optimize the function accordingly.","solution":"def can_form_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. Parameters: - s: A string of lowercase alphabetic characters (1 <= len(s) <= 1000). Returns: - A boolean indicating whether the string can be rearranged to form a palindrome. from collections import Counter # Count frequency of each character char_counts = Counter(s) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # At most one character can have an odd frequency to form a palindrome return odd_count <= 1"},{"question":"# Coding Challenge: Implement Trie and Prefix Search Function **Scenario**: You are a software engineer working on a predictive text engine for a mobile application. Your task is to implement a Trie data structure to efficiently support prefix-based searches. **Objective**: Implement the `Trie` class with the ability to insert words and check if any word in the trie starts with a given prefix. **Requirements**: 1. Implement the `Trie` class. 2. Implement the `insert` method to add words to the trie. 3. Implement the `startsWith` method to check if any words in the trie begin with the specified prefix. **Function Signature**: ```python class Trie: def __init__(self): ... def insert(self, word: str): ... def startsWith(self, prefix: str) -> bool: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes the trie. - `insert(self, word: str)`: Inserts a word into the trie. - `startsWith(self, prefix: str) -> bool`: Returns `True` if there are any words in the trie that start with the given prefix, `False` otherwise. **Constraints**: - The words and prefixes will consist of lowercase alphabets only. - The number of operations (insert and startsWith) combined will be in the range [1, 5000]. - The length of each word and prefix will be in the range [1, 100]. **Performance Requirements**: - The insert operation should be (O(n)), where (n) is the length of the word. - The startsWith operation should be (O(m)), where (m) is the length of the prefix. **Testing**: Your implementation should be verified by the following tests: 1. Inserting and searching for words with different prefixes. 2. Checking prefixes that do not exist in the trie. 3. Inserting the same word multiple times and checking the prefix. 4. Checking an empty prefix (should always return False as prefix is never empty by constraint). Implement the `Trie` class and the methods based on the provided function signatures, and ensure your solution passes the described tests.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Coding Assessment Question: Implement a Function to Simulate a Tic-Tac-Toe Game Move Validation You are tasked to implement a function to validate whether a move in a Tic-Tac-Toe game is valid, given the current state of the board and the move position. **Context**: In the game of Tic-Tac-Toe, two players take turns marking a 3x3 grid with \'X\' or \'O\'. A move is valid if the chosen cell is empty and it is the current player\'s turn. **Instructions**: 1. Implement the function `is_valid_move`. # Function Definition: `is_valid_move(board: List[List[str]], player: str, row: int, col: int) -> bool`: * **Input**: * `board`: A 2D list representing the current state of the Tic-Tac-Toe board. - The board will always be a 3x3 list of lists containing \'X\', \'O\', or an empty string \'\'. * `player`: A string representing the current player (\'X\' or \'O\'). * `row`: An integer representing the row (0-indexed) where the player wants to make a move. * `col`: An integer representing the column (0-indexed) where the player wants to make a move. * **Output**: * Returns `True` if the move is valid, otherwise `False`. # Specifications: * A move is considered valid if: * The cell at the given `row` and `col` is empty. * It is currently the `player`\'s turn. # Assumptions and Constraints: * The board will always be a valid 3x3 grid. * `player` will always be either \'X\' or \'O\'. * `row` and `col` will always be integers in the range 0 to 2. # Example 1: ```python board = [[\'X\', \'\', \'O\'], [\'O\', \'X\', \'\'], [\'\', \'\', \'\']] player = \'O\' row = 1 col = 2 # Call the is_valid_move function print(is_valid_move(board, player, row, col)) # Expected Output: True ``` # Example 2: ```python board = [[\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'X\', \'O\', \'\']] player = \'O\' row = 0 col = 0 # Call the is_valid_move function print(is_valid_move(board, player, row, col)) # Expected Output: False ``` Good luck and demonstrate your ability to validate game rules in a structured manner!","solution":"def is_valid_move(board, player, row, col): Returns True if the move is valid, otherwise False. A move is valid if: - The cell at the given row and col is empty. - It is currently the player\'s turn. if board[row][col] == \'\': # Further checks for turn validity can involve game-specific logic return True # Simplified assuming it\'s always player\'s turn when called return False"},{"question":"# Problem Statement You are given an integer `n` which represents the number of elements in an array. Your task is to write a function `find_k_smallest_elements` that finds the `k` smallest elements from the array and returns them in a sorted order. # Function Signature ```python def find_k_smallest_elements(arr: List[int], k: int) -> List[int]: pass ``` # Input - `arr`: A list of `n` integers (1 <= n <= 10^5), where each element `arr[i]` can range from `-10^6` to `10^6`. - `k`: An integer `k` (1 <= k <= n), representing the number of smallest elements to find. # Output - A list of `k` integers representing the `k` smallest elements from `arr` sorted in ascending order. # Examples ```python assert find_k_smallest_elements([5, 3, 1, 2, 4], 3) == [1, 2, 3] assert find_k_smallest_elements([7, 10, 4, 3, 20, 15], 4) == [3, 4, 7, 10] assert find_k_smallest_elements([-1, -2, -3, -4, -5], 2) == [-5, -4] assert find_k_smallest_elements([1], 1) == [1] assert find_k_smallest_elements([9, 8, 7, 6, 5], 5) == [5, 6, 7, 8, 9] ``` # Constraints - Ensure your solution handles large inputs efficiently, both in terms of time and space complexity. - You can assume that the array elements can be any integer within the given range, including negative numbers. # Notes - Think about optimal algorithms for finding the k smallest elements and ensure sorting is performed efficiently. - Avoid unnecessary space and time usage to handle large values of `n` and `k`. - Utilize built-in Python data structures and algorithms appropriately for an optimal solution.","solution":"from typing import List import heapq def find_k_smallest_elements(arr: List[int], k: int) -> List[int]: Finds the k smallest elements from the array and returns them in sorted order. if k == 0: return [] # Use a max-heap (inverted min-heap) to keep track of k smallest elements # Heapq by default is a min-heap, so we insert negative values to simulate a max-heap max_heap = [] for num in arr: if len(max_heap) < k: heapq.heappush(max_heap, -num) else: heapq.heappushpop(max_heap, -num) # Convert back to positive, sort, and return the result return sorted(-x for x in max_heap)"},{"question":"# Description: Suppose you need to simulate a basic vending machine that dispenses items based on coins inserted. The vending machine can dispense multiple items if the amount of money inserted is sufficient for all selected items. It will also return any remaining change after the transaction. # Task: Implement a function `vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]` that: 1. Takes a list of items, a corresponding list of prices, and the total amount of money inserted. 2. Dispenses as many items as the inserted coins can buy (in order of the items list). 3. Returns a list of dispensed items and the remaining change. # Constraints: - If `inserted_coins` is less than the price of any single item, no items should be dispensed, and all the money should be returned. - Items and prices lists are of the same length, and items have distinct prices. - All prices are positive floats. - If multiple items can be bought with the exact amount of money, the function should return all those items and 0 remaining coins. # Inputs: - `items` (List of strings): The names of the items in the vending machine. - `prices` (List of floats): The corresponding prices of the items. - `inserted_coins` (Float): The amount of money inserted into the vending machine. # Output: - Returns a tuple containing: 1. List of items that can be dispensed (in order of selection). 2. The remaining change after dispensing the items. # Example Usage: ```python >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 3.00) ([\\"Soda\\", \\"Candy\\"], 0.75) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 1.00) ([], 1.00) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 5.00) ([\\"Soda\\", \\"Chips\\", \\"Candy\\"], 0.75) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 0.50) ([], 0.50) ``` # Note: - Ensure your implementation efficiently handles the process of selecting items and calculating remaining change. - Consider edge cases where no items can be dispensed or all money is spent exactly. ```python def vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]: dispensed_items = [] remaining_coins = inserted_coins for item, price in zip(items, prices): if price <= remaining_coins: dispensed_items.append(item) remaining_coins -= price return dispensed_items, remaining_coins ```","solution":"def vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]: dispensed_items = [] remaining_coins = inserted_coins for item, price in zip(items, prices): if price <= remaining_coins: dispensed_items.append(item) remaining_coins -= price return dispensed_items, remaining_coins"},{"question":"# Sudoku Solver You are tasked with creating a class that can solve a Sudoku puzzle. Your job is to implement the `SudokuSolver` class to fill the empty cells of a given 9x9 Sudoku board. # Requirements: 1. **Input and Output Formats**: * The input is a 9x9 grid of integers where zeros represent empty cells. * The output should be the completed grid where all zeros are replaced with valid numbers. 2. **Constraints**: * Each row, column, and 3x3 sub-grid must contain all digits from 1 to 9 without repetition. * There is always exactly one solution to the puzzle. 3. **Performance**: * The algorithm should efficiently solve the problem using backtracking. # Example ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solver = SudokuSolver(board) solver.solve() # Output should be the solved board: # [ # [5, 3, 4, 6, 7, 8, 9, 1, 2], # [6, 7, 2, 1, 9, 5, 3, 4, 8], # [1, 9, 8, 3, 4, 2, 5, 6, 7], # [8, 5, 9, 7, 6, 1, 4, 2, 3], # [4, 2, 6, 8, 5, 3, 7, 9, 1], # [7, 1, 3, 9, 2, 4, 8, 5, 6], # [9, 6, 1, 5, 3, 7, 2, 8, 4], # [2, 8, 7, 4, 1, 9, 6, 3, 5], # [3, 4, 5, 2, 8, 6, 1, 7, 9] # ] ``` # Function Signature ```python class SudokuSolver: def __init__(self, board: List[List[int]]) -> None: pass def solve(self) -> None: pass ``` This new question maintains the required style, length, difficulty level, and topic alignment with the previous question, focusing on backtracking algorithms crucial for coding assessments.","solution":"class SudokuSolver: def __init__(self, board): self.board = board def solve(self): self._solve_helper() def _solve_helper(self): empty_pos = self._find_empty() if not empty_pos: return True row, col = empty_pos for num in range(1, 10): if self._is_valid(num, row, col): self.board[row][col] = num if self._solve_helper(): return True self.board[row][col] = 0 return False def _find_empty(self): for i in range(9): for j in range(9): if self.board[i][j] == 0: return (i, j) return None def _is_valid(self, num, row, col): # Check row for j in range(9): if self.board[row][j] == num: return False # Check column for i in range(9): if self.board[i][col] == num: return False # Check 3x3 sub-grid start_row = row - row % 3 start_col = col - col % 3 for i in range(3): for j in range(3): if self.board[start_row + i][start_col + j] == num: return False return True"},{"question":"# Coding Assessment Question: Sorting an Almost Sorted Array You are given an array where each element is at most `k` positions away from its correct sorted position. Your task is to implement a function that sorts this \\"almost sorted\\" array efficiently. **Objective**: Create a function `sort_almost_sorted_array` that sorts an array where each element is at most `k` positions away from its correct sorted position. # Function Signature ```python def sort_almost_sorted_array(arr: list[int], k: int) -> list[int]: pass ``` # Input - `arr` (list of int): The almost sorted array. - `k` (int): The maximum number of positions away each element is from its correct sorted position. # Output - Returns a list of integers representing the sorted array. # Constraints - `1 <= len(arr) <= 10^5` - `1 <= k < len(arr)` - Each element in `arr` is a distinct integer. # Requirements - Implement the `sort_almost_sorted_array` function. - The function should run in O(n log k) time complexity. # Example ```python # Sample almost sorted array and k value arr = [2, 6, 3, 12, 56, 8] k = 3 # Sorting the almost sorted array result = sort_almost_sorted_array(arr, k) print(result) # Expected Output: [2, 3, 6, 8, 12, 56] ``` # Hints - Consider using a min-heap to keep track of the k elements and efficiently find the minimum element. - Gradually build the sorted array by extracting the smallest elements from the heap.","solution":"import heapq def sort_almost_sorted_array(arr: list[int], k: int) -> list[int]: Sorts an almost sorted array where each element is at most k positions away from its correct sorted position. # Initialize a min-heap with the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) sorted_array = [] n = len(arr) # Iterate over the rest of the array and maintain the heap for i in range(k+1, n): smallest = heapq.heappop(min_heap) sorted_array.append(smallest) heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap while min_heap: smallest = heapq.heappop(min_heap) sorted_array.append(smallest) return sorted_array"},{"question":"# Coding Challenge: Implementing Dijkstra\'s Algorithm for Shortest Path Scenario: You are developing a navigation system for a city where intersections are represented as nodes and streets as edges with weights representing travel time. To provide optimal route suggestions, you need to find the shortest path from a starting intersection to all other intersections using Dijkstra\'s algorithm. Task: Implement an optimized version of Dijkstra\'s algorithm using the provided min-heap operations. Your implementation should find the shortest path from a starting node to all other nodes in a graph represented as an adjacency list. Input: * An integer `n` representing the number of nodes (intersections). * An integer `start` representing the starting node. * A list of tuples `edges`, where each tuple `(u, v, w)` represents an edge between nodes `u` and `v` with weight `w`. Output: A list of integers where the `i-th` element represents the minimum distance from the start node to node `i`. If there\'s no path to a node, the distance should be represented as `sys.maxsize`. Constraints: * The graph is connected and undirected. * Each edge has a positive weight. * (1 leq n leq 1000) * (0 leq w leq 10^5) Example: Input: ``` n = 5 start = 0 edges = [(0, 1, 10), (0, 3, 5), (1, 2, 1), (2, 3, 9), (1, 4, 20), (3, 4, 2)] ``` Output: ``` [0, 10, 11, 5, 7] ``` Implementation Details: - Define a function `dijkstra_shortest_path(n: int, start: int, edges: List[Tuple[int, int, int]]) -> List[int]` to perform the task. - Ensure your function adheres to the provided input and output formats. - Use appropriate data structures and algorithms to ensure efficiency. ```python from collections import defaultdict from typing import List, Tuple import heapq import sys def dijkstra_shortest_path(n: int, start: int, edges: List[Tuple[int, int, int]]) -> List[int]: adjacency_list = defaultdict(list) for u, v, w in edges: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) distances = [sys.maxsize] * n distances[start] = 0 min_heap = [(0, start)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > distances[u]: continue for v, weight in adjacency_list[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances # Example usage: if __name__ == \\"__main__\\": n = 5 start = 0 edges = [(0, 1, 10), (0, 3, 5), (1, 2, 1), (2, 3, 9), (1, 4, 20), (3, 4, 2)] print(dijkstra_shortest_path(n, start, edges)) ```","solution":"from collections import defaultdict from typing import List, Tuple import heapq import sys def dijkstra_shortest_path(n: int, start: int, edges: List[Tuple[int, int, int]]) -> List[int]: Finds the shortest path from the start node to all other nodes in a graph represented as an adjacency list using Dijkstra\'s algorithm. :param n: Number of nodes in the graph. :param start: Starting node for the Dijkstra\'s algorithm. :param edges: List of edges where each edge is represented as a tuple (u, v, w) indicating an edge between nodes u and v with weight w. :return: List of minimum distances from the start node to each other node. # Create the adjacency list adjacency_list = defaultdict(list) for u, v, w in edges: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) # Initialize distances with maxsize distances = [sys.maxsize] * n distances[start] = 0 # Initialize the min-heap with the starting node min_heap = [(0, start)] while min_heap: current_distance, u = heapq.heappop(min_heap) # If we have found a shorter way to u, continue if current_distance > distances[u]: continue # Explore neighbors for v, weight in adjacency_list[u]: distance = current_distance + weight # If a shorter path to v is found if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances"},{"question":"# Problem Statement You are implementing a feature to identify anomalies in a sequence of numerical data using the Z-Score method. The Z-Score measures how many standard deviations a data point is from the mean, helping identify outliers in the data. # Description A Z-Score is calculated as: [ text{Z-Score} = frac{X - mu}{sigma} ] Where: - (X) is the value in the data set. - (mu) is the mean of the data set. - (sigma) is the standard deviation of the data set. # Objective Write a function `detect_anomalies` that identifies and returns the indices of anomalies in the given data based on a specified Z-Score threshold. # Function Signature ```python def detect_anomalies(data: List[float], threshold: float) -> List[int]: pass ``` # Input - **data** (List[float]): A list of numerical values representing the data set. - **threshold** (float): The Z-Score threshold for determining anomalies. A data point is considered an anomaly if its absolute Z-Score is greater than this threshold. # Output - Return a list containing the indices of anomalies in the data set. # Constraints - The `data` list contains at least two numerical values. - It is guaranteed that the `threshold` is a positive float. - Avoid raising exceptions directly from this function. # Examples **Example 1:** ```python data = [10.0, 12.0, 15.0, 18.0, 9.0, 50.0, 11.0] threshold = 2.0 print(detect_anomalies(data, threshold)) # Expected output: [5] ``` **Example 2:** ```python data = [5.0, 6.0, 7.0, 8.0, 10.0, 50.0, 7.5] threshold = 1.5 print(detect_anomalies(data, threshold)) # Expected output: [5] ``` **Example 3:** ```python data = [1.0, 2.0, 2.5, 3.0, 2.0, 100.0, 2.0, 2.1] threshold = 3.0 print(detect_anomalies(data, threshold)) # Expected output: [5] ``` # Constraints 1. The function should handle cases where `data` contains less than 2 numerical values by raising a `ValueError`. # Hints 1. Use numpy for efficient computation of mean and standard deviation. 2. Ensure to handle numerical stability when working with floating-point arithmetic.","solution":"from typing import List import numpy as np def detect_anomalies(data: List[float], threshold: float) -> List[int]: Identifies and returns the indices of anomalies in the data based on the specified Z-Score threshold. Parameters: - data (List[float]): The data set. - threshold (float): The Z-Score threshold for determining anomalies. Returns: - List[int]: The list of indices of anomalies. if len(data) < 2: raise ValueError(\\"Data should contain at least two numerical values.\\") mean = np.mean(data) std_dev = np.std(data) anomalies = [] for index, value in enumerate(data): z_score = (value - mean) / std_dev if std_dev else 0 if abs(z_score) > threshold: anomalies.append(index) return anomalies"},{"question":"# Markdown File Conversion Utility You are tasked with creating a markdown file conversion utility that can read a markdown file, extract and count the headings (levels 1-6), and convert the headings into uppercase. The utility should support bulk conversion of multiple markdown files. **Objectives**: 1. **Develop the Conversion Utility**: - Implement functionality to read and process markdown files. - Count and convert all headings (levels 1-6) to uppercase. - Provide support for bulk processing of multiple markdown files. 2. **Function Definitions**: - **`convert_headings_single(filename: str) -> dict`**: Read and process a single markdown file. - **`convert_headings_bulk(filenames: list[str]) -> dict`**: Process multiple markdown files and return the aggregated results. **Input/Output Specifications**: - **`convert_headings_single`**: - **Input**: - `filename` (str): Path to the markdown file to be processed. - **Output**: - (dict): A dictionary with heading levels as keys and their respective counts as values. - (None): If the file is not found or is empty. - **Side Effects**: - Convert all headings in the file to uppercase. - **`convert_headings_bulk`**: - **Input**: - `filenames` (list[str]): List of paths to markdown files to be processed. - **Output**: - (dict): A dictionary with heading levels as keys and their aggregate counts across all files as values. - (None): If none of the files are found or all files are empty. - **Side Effects**: - Convert all headings in each file to uppercase. **Example**: Given the following files: - `file1.md`: ```markdown # Heading 1 Heading 2 # Heading 3 ``` - `file2.md`: ```markdown # Another Heading 1 Another Heading 2 ``` For `convert_headings_single`: ```python convert_headings_single(\'file1.md\') ``` Output: ```python { \'H1\': 1, \'H2\': 1, \'H3\': 1 } ``` For `convert_headings_bulk`: ```python convert_headings_bulk([\'file1.md\', \'file2.md\']) ``` Output: ```python { \'H1\': 2, \'H2\': 2, \'H3\': 1 } ``` **Constraints**: - Ensure all file I/O operations are appropriately managed. - Handle edge cases such as non-existing files and empty files gracefully. - Preserve and enhance the provided docstrings and test cases. Implement the markup file conversion utility in Python.","solution":"import os import re from collections import defaultdict def convert_headings_single(filename: str) -> dict: Reads and processes a single markdown file. Parameters: filename (str): Path to the markdown file to be processed. Returns: dict: A dictionary with heading levels as keys and their respective counts as values. if not os.path.isfile(filename): return None heading_counts = defaultdict(int) heading_pattern = re.compile(r\'^(#{1,6})s*(.+)\', re.MULTILINE) converted_lines = [] with open(filename, \'r\', encoding=\'utf-8\') as file: content = file.readlines() if not content: return None for line in content: match = heading_pattern.match(line) if match: heading_level = f\'H{len(match.group(1))}\' heading_counts[heading_level] += 1 converted_line = f\\"{match.group(1)} {match.group(2).upper()}n\\" converted_lines.append(converted_line) else: converted_lines.append(line) with open(filename, \'w\', encoding=\'utf-8\') as file: file.writelines(converted_lines) return dict(heading_counts) def convert_headings_bulk(filenames: list) -> dict: Processes multiple markdown files and returns the aggregated results. Parameters: filenames (list): List of paths to markdown files to be processed. Returns: dict: A dictionary with heading levels as keys and their aggregate counts across all files as values. total_heading_counts = defaultdict(int) for filename in filenames: if os.path.isfile(filename): file_heading_counts = convert_headings_single(filename) if file_heading_counts: for level, count in file_heading_counts.items(): total_heading_counts[level] += count return dict(total_heading_counts) if total_heading_counts else None"},{"question":"# Graph Cycle Detection Problem Statement: You are given an undirected graph represented using an adjacency list. Your task is to determine if the graph contains any cycles. Task: 1. Implement a function to detect cycles in the given graph. 2. Use Depth-First Search (DFS) as part of your solution to detect cycles. 3. The function should return `True` if the graph contains a cycle, and `False` otherwise. Expected Function Signature: ```python def has_cycle(self) -> bool ``` Example: ```python g = Graph() g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(2, 3) g.add_edge(3, 4) print(g.has_cycle()) # Output should be True g2 = Graph() g2.add_edge(0, 1) g2.add_edge(1, 2) g2.add_edge(2, 3) print(g2.has_cycle()) # Output should be False ``` Constraints: 1. The graph can have up to 10^3 vertices. 2. There will be no negative vertex labels. 3. The graph may contain self-loops and/or multiple edges. Hint: To detect a cycle in an undirected graph using DFS, keep track of the parent node to avoid falsely detecting a cycle.","solution":"class Graph: def __init__(self): self.adj_list = {} def add_edge(self, u, v): if u not in self.adj_list: self.adj_list[u] = [] if v not in self.adj_list: self.adj_list[v] = [] self.adj_list[u].append(v) self.adj_list[v].append(u) def has_cycle_util(self, v, visited, parent): visited[v] = True # Recur for all the vertices adjacent to this vertex for i in self.adj_list[v]: # If the adjacent node is not visited, then recurse on it if not visited[i]: if self.has_cycle_util(i, visited, v): return True # If an adjacent vertex is visited and is not parent of the current vertex, # then there is a cycle elif parent != i: return True return False def has_cycle(self): visited = {i: False for i in self.adj_list} for i in self.adj_list: if not visited[i]: # Don\'t recur for already visited vertices if self.has_cycle_util(i, visited, -1): return True return False"},{"question":"# Array Rotation Challenge In this problem, you need to determine the rotated version of an input array. Given an integer array and a number `d`, rotate the array to the right by `d` positions. Requirements * Implement the function `rotate_array(arr: List[int], d: int) -> List[int]` that returns the array after rotating it to the right by `d` positions. * Handle constraints in terms of large values of `d` to avoid unnecessary computations by using modulus operation. Function Signature ```python def rotate_array(arr: List[int], d: int) -> List[int]: pass ``` # Input * `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5), representing the elements of the array. * `d`: An integer (0 ≤ d ≤ 10^9), representing the number of positions to rotate the array. # Output * Returns a list of integers which is the rotated version of the input array. # Example ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] ``` # Constraints * If `d` is greater than the length of the array, use `d % len(arr)` to determine effective rotations. * Consider edge cases such as when `d` is `0` or when `len(arr)` is `1`. # Notes * The function must be optimized to handle large values of `d` and long arrays efficiently. * Ensure your solution avoids unnecessary array copies to enhance performance.","solution":"from typing import List def rotate_array(arr: List[int], d: int) -> List[int]: Rotates the array arr to the right by d positions. n = len(arr) if n == 0 or d == 0 or d % n == 0: return arr d = d % n return arr[-d:] + arr[:-d]"},{"question":"# Coding Challenge: Rotate List **Objective**: Write a function that rotates a list to the right by a given number of steps. The rotation operation shifts each element in the list to the right by one position, and the last element is moved to the first position. This process is repeated for the specified number of steps. Function Signature ```python def rotate_list(input_list: List[Any], steps: int) -> List[Any]: pass ``` Input - `input_list` (list): The list of elements to be rotated. - `steps` (int): The number of steps to rotate the list. This value is guaranteed to be a non-negative integer. Output - `List[Any]`: The rotated list. Constraints - The list can contain elements of different types (integers, strings, etc.). - The total number of elements in the list does not exceed 1000. - The number of rotation steps will not exceed 10,000. Examples ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], 3) == [\'C\', \'D\', \'E\', \'A\', \'B\'] assert rotate_list([1, 2, 3], 0) == [1, 2, 3] assert rotate_list([], 4) == [] assert rotate_list([1], 10) == [1] ``` # Implementation Notes 1. Determine the effective number of rotation steps needed by taking `steps % len(input_list)`. If `input_list` is empty, return it as-is. 2. Use list slicing to rearrange the elements. Specifically, the rotated list can be formed by combining two slices. 3. Return the result list after constructing it with the rotated order. Good luck!","solution":"from typing import List, Any def rotate_list(input_list: List[Any], steps: int) -> List[Any]: if not input_list: # If the list is empty, return as is return input_list n = len(input_list) steps = steps % n # Effective rotation steps # Slice and concatenate the list return input_list[-steps:] + input_list[:-steps]"},{"question":"**Title**: Longest Path in a Tree **Context**: You are given an unrooted tree represented as an undirected graph with `N` vertices and `N-1` edges. The goal is to find the longest path in this tree, which is also known as the diameter of the tree. **Problem Statement**: Implement the function `tree_diameter(edges: List[Tuple[int, int]]) -> int` that reads a list of edges representing an unrooted tree and returns the length of the longest path (diameter) in the tree. **Input Format**: - `edges`: A list of tuples, where each tuple `(u, v)` represents an undirected edge between vertex `u` and vertex `v`. **Output Format**: - Returns an integer, the length of the longest path in the tree. **Constraints**: 1. `2 <= N <= 1000` (Number of vertices) 2. `0 <= u, v < N` **Example**: ```python edges = [ (0, 1), (0, 2), (1, 3), (1, 4), (4, 5) ] assert tree_diameter(edges) == 4 ``` **Note**: You can assume that the input graph is always a tree.","solution":"from typing import List, Tuple from collections import deque def bfs_farthest_node(start_node: int, adjacency_list: List[List[int]]) -> Tuple[int, int]: Perform BFS to find the farthest node from the start_node. Returns a tuple of the farthest node and the distance to it. visited = [False] * len(adjacency_list) queue = deque([(start_node, 0)]) visited[start_node] = True farthest_node = start_node max_distance = 0 while queue: current_node, current_distance = queue.popleft() if current_distance > max_distance: farthest_node = current_node max_distance = current_distance for neighbor in adjacency_list[current_node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, current_distance + 1)) return farthest_node, max_distance def tree_diameter(edges: List[Tuple[int, int]]) -> int: Given a list of edges representing an unrooted tree, returns the diameter of the tree. # First build the adjacency list from the edges n = len(edges) + 1 adjacency_list = [[] for _ in range(n)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Step 1: Perform BFS from an arbitrary node (node 0) to find the farthest node farthest_from_start, _ = bfs_farthest_node(0, adjacency_list) # Step 2: Perform BFS from the farthest_from_start to find the tree diameter _, diameter = bfs_farthest_node(farthest_from_start, adjacency_list) return diameter"},{"question":"# Coding Question: Image Pixelation Filter Given an image represented as a 2D array (list of lists in Python) of integers where each integer represents a pixel\'s grayscale value, write a function to apply a simple pixelation filter. The function should take two parameters: the original image and the size of the block for pixelation and return a new image where each block of the specified size has been replaced by the average grayscale value of the pixels in that block. Implement the `apply_pixelation_filter` function. Function Signature ```python def apply_pixelation_filter(image: List[List[int]], block_size: int) -> List[List[int]]: pass ``` Inputs - `image (List[List[int]])`: A 2D array representing the grayscale values of the image pixels. Each grayscale value is between 0 and 255. - `block_size (int)`: The size of the block (a positive integer) for pixelation. Outputs - Returns a new 2D array representing the image after applying the pixelation filter. Constraints - The number of rows and columns in `image` is divisible by `block_size`. - The grayscale values in `image` are between 0 and 255 inclusive. Implementation Details 1. Iterate through the image in blocks of size `block_size x block_size`. 2. For each block, calculate the average grayscale value. 3. Replace each pixel in the block with the calculated average value. Example ```python def apply_pixelation_filter(image: List[List[int]], block_size: int) -> List[List[int]]: # Implement the pixelation filter pass # Example Test Case image = [ [100, 100, 50, 50], [100, 100, 50, 50], [200, 200, 150, 150], [200, 200, 150, 150] ] block_size = 2 print(apply_pixelation_filter(image, block_size)) # Output: [ # [100, 100, 50, 50], # [100, 100, 50, 50], # [200, 200, 150, 150], # [200, 200, 150, 150] # ] ``` Hints 1. Initialize necessary variables to calculate the sum of grayscale values and average for each block. 2. Use nested loops to process each block and update the original image with the average value. 3. Ensure the function handles different block sizes correctly and efficiently.","solution":"from typing import List def apply_pixelation_filter(image: List[List[int]], block_size: int) -> List[List[int]]: height = len(image) width = len(image[0]) new_image = [row[:] for row in image] # Making a copy of the image for i in range(0, height, block_size): for j in range(0, width, block_size): # Calculate the average value for the current block block_sum = 0 for x in range(block_size): for y in range(block_size): block_sum += image[i + x][j + y] block_average = block_sum // (block_size * block_size) # Set the average value for the current block for x in range(block_size): for y in range(block_size): new_image[i + x][j + y] = block_average return new_image"},{"question":"# Context A restaurant reviews app allows users to submit reviews and ratings for various restaurants. Reviews include a rating from 1 to 5, along with a text comment. To better understand user sentiment, you are tasked with implementing a feature that identifies positive reviews. A review is considered positive if its rating is 4 or 5. Given a list of reviews, your goal is to filter out only the positive reviews. # Task You are to implement the function `filter_positive_reviews(reviews)` that takes: 1. `reviews`: A list of tuples, where each tuple contains a rating (an integer between 1 and 5) and the review text (a string). The function should return a list of strings containing only the review texts that have a rating of 4 or 5. # Input Format - `reviews` is a list where each element is a tuple `(rating, comment)`. - `rating` is an integer between 1 and 5 representing the star rating given to the restaurant. - `comment` is a string representing the review text. # Output Format - A list of review texts that have a rating of 4 or 5. # Constraints - ( 1 leq text{len(reviews)} leq 1000 ) - The review text length does not exceed 500 characters. - Each rating is an integer between 1 and 5. # Example Input: ```python reviews = [ (5, \\"Fantastic food and great service!\\"), (3, \\"Average experience, nothing special.\\"), (4, \\"Good place, will visit again.\\"), (2, \\"Not worth the money.\\"), (5, \\"Absolutely loved it! Highly recommend.\\") ] ``` Output: ```python [\\"Fantastic food and great service!\\", \\"Good place, will visit again.\\", \\"Absolutely loved it! Highly recommend.\\"] ``` # Function Signature ```python def filter_positive_reviews(reviews: list[tuple[int, str]]) -> list[str]: pass ```","solution":"def filter_positive_reviews(reviews): Filters out positive reviews from the list of reviews. A review is considered positive if its rating is 4 or 5. Args: reviews (list): A list of tuples, where each tuple contains a rating (integer) and a review text (string). Returns: list: A list of review texts that have a rating of 4 or 5. return [comment for rating, comment in reviews if rating == 4 or rating == 5]"},{"question":"# Question Scenario: You have been tasked with developing a utility function for a social media app that detects abusive or spam content. A key part of this function is to identify and count the number of profane words from a predefined list within a given text. Task: Implement the function `count_profanities` that takes a single string input and a list of profane words, and returns the count of those profane words in the input string. The function should be case-insensitive and ignore punctuation. Implementation: 1. Define the function `count_profanities(text: str, profane_words: List[str]) -> int`. 2. Ensure the function handles the following: * Case insensitivity. * Ignoring punctuation. * Recognizing whole words only (i.e., \'bad\' should not match \'badger\'). * Input validation to ensure the input is a string and the list contains only strings. 3. Optimize for performance (O(n) time complexity for the text parsing). Input: * A single string `text`. * A list of strings `profane_words`. Output: * An integer representing the number of profane words in the input text. Constraints: * The input text length does not exceed 10^6 characters. * The list of profane words does not exceed 10^3 words. * Each word in the list does not exceed 50 characters. Examples: ```python >>> count_profanities(\\"This is a very bad and nasty example!\\", [\\"bad\\", \\"nasty\\", \\"evil\\"]) 2 >>> count_profanities(\\"Nicer words here, nothing bad!\\", [\\"bad\\", \\"ugly\\"]) 1 >>> count_profanities(\\"\\", [\\"bad\\", \\"ugly\\"]) 0 >>> count_profanities(\\"All words are good and kind.\\", [\\"bad\\", \\"ugly\\"]) 0 >>> count_profanities(\\"BAD nasty Bad BAD\\", [\\"bad\\", \\"nasty\\"]) 4 ``` Performance Requirements: The function should run efficiently with a linear time complexity in relation to the length of the input text, ensuring it can handle large inputs up to 10^6 characters. Some preprocessing of the list of profane words is allowed to optimize checking against the text.","solution":"import re from typing import List def count_profanities(text: str, profane_words: List[str]) -> int: Counts the number of profane words in the given text. Args: text (str): The input text. profane_words (List[str]): A list of profane words to look for. Returns: int: The count of profane words in the text. if not isinstance(text, str): raise ValueError(\\"The input text must be a string.\\") if not all(isinstance(word, str) for word in profane_words): raise ValueError(\\"All profane words must be strings.\\") # Normalize the text to lowercase and remove punctuation cleaned_text = re.sub(r\'[^ws]\', \'\', text.lower()) # Split the text into words words = cleaned_text.split() # Convert the list of profane words to lowercase for case insensitivity profane_set = set(word.lower() for word in profane_words) # Count the profane words profane_count = sum(1 for word in words if word in profane_set) return profane_count"},{"question":"# Context An online book store wants to enhance its search functionality. You are assigned the task of implementing a search class that allows searching for books by title, author, and ISBN using different criteria. # Task 1. Implement the `BookSearch` class that should provide efficient search functionalities. 2. Store information about books using an appropriate data structure. 3. Offer search methods that can retrieve books by title substring, author name substring, or exact ISBN match. # Expected Input and Output * **add_book(title: str, author: str, isbn: str) -> None**: Adds a new book with the given title, author, and ISBN to the search system. * **search_by_title(title_substring: str) -> List[str]**: Finds and returns a list of book titles that contain the given title substring. The search should be case-insensitive. * **search_by_author(author_substring: str) -> List[str]**: Finds and returns a list of book titles whose authors contain the given author substring. The search should be case-insensitive. * **search_by_isbn(isbn: str) -> str**: Finds and returns the title of the book with the exact ISBN match. If no book is found, return an empty string. # Constraints * Assume all book titles and author names are unique. * The ISBN is a unique number consisting of 13 digits. * Ensure your implementation can handle a large number of books efficiently. # Example ```python bs = BookSearch() bs.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"9780141182636\\") bs.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"9780061120084\\") bs.add_book(\\"1984\\", \\"George Orwell\\", \\"9780451524935\\") print(bs.search_by_title(\\"great\\")) # Output: [\\"The Great Gatsby\\"] print(bs.search_by_author(\\"Lee\\")) # Output: [\\"To Kill a Mockingbird\\"] print(bs.search_by_isbn(\\"9780451524935\\")) # Output: \\"1984\\" print(bs.search_by_isbn(\\"1234567890123\\")) # Output: \\"\\" ``` # Performance Requirements * All search methods (`search_by_title`, `search_by_author`, and `search_by_isbn`) should be optimized for quick retrieval, ensuring the system can handle searches efficiently even with a large dataset.","solution":"class BookSearch: def __init__(self): self.books = {} def add_book(self, title: str, author: str, isbn: str) -> None: self.books[isbn] = {\'title\': title, \'author\': author} def search_by_title(self, title_substring: str) -> list: title_substring = title_substring.lower() return [book[\'title\'] for book in self.books.values() if title_substring in book[\'title\'].lower()] def search_by_author(self, author_substring: str) -> list: author_substring = author_substring.lower() return [book[\'title\'] for book in self.books.values() if author_substring in book[\'author\'].lower()] def search_by_isbn(self, isbn: str) -> str: return self.books[isbn][\'title\'] if isbn in self.books else \\"\\""},{"question":"# Coding Question Context File systems have operations like `cd` (change directory), which allow you to navigate between directories. Given a current directory path and a command to change directory, your task is to implement a function that determines the resulting path. Tasks 1. Implement a function `change_directory` which computes the resulting directory path given the current directory and the command path. # Function Signature ```python def change_directory(current_path: str, command_path: str) -> str: # your code here ``` # Requirements - The paths are given in Unix-style with \'/\' as the directory separator. - You must handle special directory names: - `.` refers to the current directory. - `..` refers to the parent directory. - If the final path would attempt to go above the root directory \'/\', return \'/\'. # Constraints - The current path and command path are non-empty strings. - Both paths may or may not start with a \'/\'. - Directory names consist of alphanumeric characters. # Example Usage ```python # Test cases for changing directory change_directory(\'/home/user/docs\', \'../photos\') # should return \'/home/user/photos\' change_directory(\'/home/user/docs\', \'..\') # should return \'/home/user\' change_directory(\'/home/user/docs\', \'../../..\') # should return \'/\' change_directory(\'/\', \'home/user\') # should return \'/home/user\' change_directory(\'/home/user/docs\', \'./photos/2021\') # should return \'/home/user/docs/photos/2021\' ```","solution":"def change_directory(current_path: str, command_path: str) -> str: Computes the resulting directory path given the current directory and the command path. # Split the current path into a list of directories if current_path.startswith(\'/\'): current_path = current_path[1:] current_dirs = current_path.split(\'/\') if current_path else [] # Split the command path into a list of instructions command_dirs = command_path.split(\'/\') # Process each instruction in command_dirs for dir in command_dirs: if dir == \'\' or dir == \'.\': continue # Skip empty parts and current directory references elif dir == \'..\': if current_dirs: current_dirs.pop() # Move to parent directory else: current_dirs.append(dir) # Move into the specified directory # Construct the resulting path result_path = \'/\' + \'/\'.join(current_dirs) return result_path"},{"question":"# Question: Detect a Cycle in a Directed Graph Using DFS In a directed graph, a cycle is a path that starts and ends at the same vertex, following the direction of the edges. Write a function `has_cycle(graph: dict[int, list[int]]) -> bool` that determines if a given directed graph contains a cycle. Use the Depth-First Search (DFS) technique to perform this check. **Function Signature**: ```python def has_cycle(graph: dict[int, list[int]]) -> bool: ``` **Input**: * `graph`: A dictionary representing the adjacency list of the directed graph. The keys are integer nodes and the values are lists of integers representing the nodes to which there are directed edges. **Output**: * Returns `True` if the graph contains a cycle, `False` otherwise. **Constraints**: * Node values and edge values are non-negative integers. **Performance Requirements**: * Time Complexity: (O(V + E)) * Space Complexity: (O(V)) **Examples**: ```python assert has_cycle({0: [1, 2], 1: [3], 2: [4], 3: [4], 4: [0]}) == True assert has_cycle({0: [1, 2], 1: [2], 2: [3], 3: []}) == False assert has_cycle({0: [1], 1: [2], 2: [0]}) == True assert has_cycle({0: [1], 1: [2], 2: [], 3: [4], 4: []}) == False ``` **Note**: Ensure that the function handles the following edge cases: * A graph with isolated vertices or multiple disconnected components. * An empty graph. * Graphs with varied connectivity structures.","solution":"def has_cycle(graph: dict[int, list[int]]) -> bool: Detects if a directed graph contains a cycle using DFS. :param graph: A dictionary representing the graph with vertices as keys and lists of connected vertices as values. :return: True if the graph contains a cycle, False otherwise. def dfs(v): if visited[v] == 2: return False if visited[v] == 1: return True visited[v] = 1 for neighbor in graph[v]: if dfs(neighbor): return True visited[v] = 2 return False visited = {node: 0 for node in graph} for node in graph: if visited[node] == 0: if dfs(node): return True return False"},{"question":"# Question: Circuit Resistance Calculation As an electrical engineer, you are tasked with designing a function to calculate the equivalent resistance of a circuit. Given a list of resistances and their configuration (series or parallel), your goal is to implement a function that returns the total resistance. Your task is to implement the following function: 1. **total_resistance(resistances, configuration)**: - **Input**: A list of floats `resistances` and a string `configuration` which can either be `\\"series\\"` or `\\"parallel\\"`. - **Output**: The total resistance as a float. - **Constraints**: - `resistances` should only contain positive floats. - `configuration` should be either `\\"series\\"` or `\\"parallel\\"`. - **Examples**: ```python >>> total_resistance([10.0, 20.0, 30.0], \\"series\\") 60.0 >>> total_resistance([10.0, 20.0, 30.0], \\"parallel\\") 5.454545454545454 ``` # Implementation Requirements - **The function should raise a `ValueError` if `configuration` is neither `\\"series\\"` nor `\\"parallel\\"`**. - **The function should raise a `ValueError` if any resistance in the `resistances` list is non-positive**. - Ensure to handle edge cases, such as an empty list of resistances. - Optimize for efficient computation. # Test Cases You should test your function with the following cases: ```python # Series configuration assert total_resistance([10.0, 20.0, 30.0], \\"series\\") == 60.0 assert total_resistance([5.0, 10.0], \\"series\\") == 15.0 assert total_resistance([1.0], \\"series\\") == 1.0 assert total_resistance([], \\"series\\") == 0.0 # Parallel configuration assert total_resistance([10.0, 20.0, 30.0], \\"parallel\\") == 5.454545454545454 assert total_resistance([5.0, 10.0], \\"parallel\\") == 3.3333333333333335 assert total_resistance([1.0], \\"parallel\\") == 1.0 assert total_resistance([], \\"parallel\\") == 0.0 # Test for invalid configuration value try: total_resistance([10.0, 20.0, 30.0], \\"invalid\\") except ValueError: print(\\"ValueError raised as expected\\") # Test for non-positive resistance value try: total_resistance([-10.0, 20.0, 30.0], \\"series\\") except ValueError: print(\\"ValueError raised as expected\\") try: total_resistance([10.0, 0, 30.0], \\"parallel\\") except ValueError: print(\\"ValueError raised as expected\\") ``` # Notes - In a **series** configuration, the total resistance is the sum of all resistances. - In a **parallel** configuration, the total resistance is given by the inverse of the sum of the inverses of each resistance. The function you implement should correctly calculate these values and handle the specified edge cases appropriately.","solution":"def total_resistance(resistances, configuration): Calculate the total resistance of a circuit based on the given configuration. Parameters: resistances (list of float): List of resistances in ohms. configuration (str): Configuration of the resistances. Can be \\"series\\" or \\"parallel\\". Returns: float: The total resistance of the circuit. Raises: ValueError: If configuration is not \\"series\\" or \\"parallel\\" or if any resistance is non-positive. if configuration not in [\\"series\\", \\"parallel\\"]: raise ValueError(\\"Invalid configuration. Must be \'series\' or \'parallel\'.\\") if any(r <= 0 for r in resistances): raise ValueError(\\"All resistances must be positive.\\") if configuration == \\"series\\": return sum(resistances) if configuration == \\"parallel\\": if not resistances: return 0.0 # Handle case of empty list for parallel total_inverse_resistance = sum(1.0 / r for r in resistances) if total_inverse_resistance == 0: return float(\'inf\') # This handles case where all resistances are infinite (which is admittedly theoretical) return 1.0 / total_inverse_resistance"},{"question":"# Coding Exercise: Building a Cache to Optimize Fibonacci Sequence Calculation Context The Fibonacci sequence is a classic example in algorithms and can be recursively defined as F(n) = F(n-1) + F(n-2) with base cases F(0) = 0 and F(1) = 1. However, the naive recursive algorithm for calculating Fibonacci numbers has an exponential time complexity due to repeated recalculations. One way to improve performance is by using memoization, a technique where we store the results of expensive function calls and reuse the cached result when the same inputs occur again. Task Write a Python function `memoized_fibonacci` that calculates the nth Fibonacci number using memoization to improve performance. Requirements 1. **Function Name**: `memoized_fibonacci` 2. **Expected Input and Output**: - Input: An integer `n` (0 ≤ n ≤ 1000). - Output: An integer representing the nth Fibonacci number. 3. **Constraints**: - Use a dictionary or similar structure to cache intermediate Fibonacci values. - Ensure the function handles large values of `n` efficiently. 4. **Performance Requirements**: The function should run in linear time complexity, O(n). Example Scenarios ```python >>> memoized_fibonacci(0) 0 >>> memoized_fibonacci(1) 1 >>> memoized_fibonacci(10) 55 >>> memoized_fibonacci(50) 12586269025 ``` Instructions - Refrain from using any external libraries; focus solely on Python\'s built-in features for cache implementation. - Test your implementation with various values, especially edge cases like the smallest (0) and largest (1000) inputs. --- Here\'s the new question that aligns with the provided example in terms of style, complexity, and scope.","solution":"def memoized_fibonacci(n, cache={0: 0, 1: 1}): Returns the nth Fibonacci number using memoization. Parameters: n (int): The position in the Fibonacci sequence (0 ≤ n ≤ 1000) Returns: int: The nth Fibonacci number. if n in cache: return cache[n] cache[n] = memoized_fibonacci(n - 1, cache) + memoized_fibonacci(n - 2, cache) return cache[n]"},{"question":"# Problem Statement Given an integer `n`, write a function `n_th_ugly_number(n: int) -> int` that returns the nth ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, and 5. # Function Signature ```python def n_th_ugly_number(n: int) -> int: ``` # Input * `n` (int): An integer representing the position of the ugly number to find. # Output * (int): The nth ugly number. # Constraints * 1 <= n <= 1000 # Examples ```python >>> n_th_ugly_number(10) 12 >>> n_th_ugly_number(1) 1 >>> n_th_ugly_number(15) 24 ``` # Implementation Requirements * The solution should adhere to an O(n log n) time complexity. * You must use a space-efficient approach to generate and store the sequence of ugly numbers. * Consider using a min-heap to maintain the order of ugly numbers efficiently. * Optimize the use of multiple pointers to handle the next multiple for 2, 3, and 5.","solution":"import heapq def n_th_ugly_number(n: int) -> int: # Min-heap to keep track of the next smallest ugly number heap = [1] # A set to check for duplicates before inserting in the heap seen = {1} # Factors for ugly numbers factors = [2, 3, 5] # Generate ugly numbers until we reach the nth one for _ in range(n): # Extract the smallest number from the heap current_ugly = heapq.heappop(heap) # Generate new ugly numbers and add them to the heap if they are not seen before for factor in factors: new_ugly = current_ugly * factor if new_ugly not in seen: heapq.heappush(heap, new_ugly) seen.add(new_ugly) return current_ugly"},{"question":"Coding Assessment Question Background & Context You are working on an e-commerce platform that recommends products to users based on their browsing history. The platform uses a weighted graph to represent the relationship between different products, with edge weights indicating the strength of the relationship. Task Write a function `find_most_related` that takes in the current product ID and a dictionary representing the graph. Return the product ID of the most related product based on the highest cumulative weight of direct connections. Function Signature ```python def find_most_related(product_id: int, graph: Dict[int, Dict[int, int]]) -> int: Find the product ID of the most related product based on the highest cumulative weight. :param product_id: int, ID of the current product :param graph: Dict[int, Dict[int, int]], graph representing the relationships between products, where graph[a][b] is the weight of the edge from product a to product b :return: int, product ID of the most related product ``` Input and Output Format * **Input**: - `product_id` (int): ID of the current product. - `graph` (Dict[int, Dict[int, int]]): Dictionary representing the relationship graph. * **Output**: - Return the product ID of the most related product. Constraints * Each product ID is a positive integer. * The graph is not necessarily complete; some products may have no direct connections to others. * The weights are positive integers. * If multiple products have the same cumulative weight, return the product ID with the smallest numeric value. Example ```python graph = { 1: {2: 10, 3: 2}, 2: {1: 10, 3: 5}, 3: {1: 2, 2: 5, 4: 1}, 4: {3:1} } # Example usage: result = find_most_related(1, graph) print(result) # Output should be 2 ``` Notes * The function should efficiently calculate the cumulative weight of the direct connections for the given product ID. * Consider edge cases, such as a product with no related products or disconnected subgraphs. * Ensure that your implementation can handle large graphs within a reasonable time.","solution":"from typing import Dict def find_most_related(product_id: int, graph: Dict[int, Dict[int, int]]) -> int: Find the product ID of the most related product based on the highest cumulative weight. :param product_id: int, ID of the current product :param graph: Dict[int, Dict[int, int]], graph representing the relationships between products, where graph[a][b] is the weight of the edge from product a to product b :return: int, product ID of the most related product if product_id not in graph or not graph[product_id]: return -1 # Return -1 or another appropriate default value if there are no related products related_products = graph[product_id] # Find the product with the highest cumulative weight. most_related_product = max(related_products, key=related_products.get) return most_related_product"},{"question":"# Question: Validating Palindromic Subsequences You are given a string `s` of lowercase English letters. Your task is to implement a function `is_k_palindrome` that determines if the given string can be transformed into a palindrome by at most `k` deletions. Function Signature ```python def is_k_palindrome(s: str, k: int) -> bool: ``` Parameters - `s`: str - A string consisting of lowercase English letters. - `k`: int - The maximum number of deletions allowed to transform the string into a palindrome. Returns - `bool`: True if the string can be transformed into a palindrome by at most `k` deletions, otherwise False. Constraints 1. The length of `s` will be between 1 and 1000. 2. `k` will be a non-negative integer. Examples ```python # Example 1 s = \\"abcdeca\\" k = 2 # Call the function result = is_k_palindrome(s, k) # Expected Output print(result) # Output: True # Example 2 s = \\"abcdef\\" k = 1 # Call the function result = is_k_palindrome(s, k) # Expected Output print(result) # Output: False ``` # Notes: * A palindrome is a string that reads the same forward and backward. * You are allowed to delete characters from the string but not rearrange them. * The function should be optimized to handle the upper limits of the input constraints efficiently. Consider dynamic programming for an optimal solution.","solution":"def is_k_palindrome(s: str, k: int) -> bool: def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] n = len(s) lps_length = longest_palindromic_subsequence(s) min_deletions_needed = n - lps_length return min_deletions_needed <= k"},{"question":"**Scenario**: You are developing a text editor that includes a feature to find and clean up extra spaces between words. When given a string, the function should remove all extra spaces so that words are separated by only one space, and there should be no leading or trailing spaces. # Task Write a function `clean_spaces(text: str) -> str` that takes a string `text` and returns the cleaned-up version of the string with exactly one space between words and no leading or trailing spaces. # Input * A string `text` consisting of ASCII characters, where 0 <= `len(text)` <= 10^6. # Output * A string with no leading or trailing spaces and exactly one space separating the words. # Constraints * You are not allowed to use built-in functions that perform the entire cleaning task (e.g., `strip`, `split`, `join` all in conjunction). * Aim for O(n) time complexity and O(1) additional space complexity. # Examples ```python >>> clean_spaces(\\" Hello world! \\") \\"Hello world!\\" >>> clean_spaces(\\"Python is great \\") \\"Python is great\\" >>> clean_spaces(\\" Multiple spaces should be reduced.\\") \\"Multiple spaces should be reduced.\\" >>> clean_spaces(\\"SingleWord\\") \\"SingleWord\\" >>> clean_spaces(\\"\\") \\"\\" ``` # Note * In the first example, the input string has leading and trailing spaces and multiple spaces between the words \\"Hello\\" and \\"world!\\". The output string removes the extra spaces so that each word is separated by a single space, and there are no leading or trailing spaces. * In the second example, extra spaces are reduced to a single space separating words. * Consider edge cases like a single word, an empty string, or strings with spaces only. **Function Signature** ```python def clean_spaces(text: str) -> str: ```","solution":"def clean_spaces(text: str) -> str: result = [] n = len(text) i = 0 while i < n: # Skip leading spaces while i < n and text[i] == \' \': i += 1 # Collect the word word_start = i while i < n and text[i] != \' \': i += 1 if word_start < i: result.append(text[word_start:i]) # Skip spaces between words while i < n and text[i] == \' \': i += 1 return \' \'.join(result)"},{"question":"# Coding Assessment Question: You are given a list of integers, and your task is to implement a function `remove_duplicates` that returns a new list with all duplicate elements removed. The order of elements in the returned list should be the same as their first occurrence in the original list. # Function Signature: ```python def remove_duplicates(nums: list) -> list: pass ``` # Input: * A list of integers `nums`. * Constraints: The length of the list `nums` is 0 <= len(nums) <= 10^6. # Output: * Returns a new list of integers with duplicates removed, preserving the order of first appearance. # Examples: ```python >>> remove_duplicates([1, 2, 3, 2, 1]) [1, 2, 3] >>> remove_duplicates([4, 5, 4, 4, 6, 7, 5]) [4, 5, 6, 7] >>> remove_duplicates([10]) [10] >>> remove_duplicates([]) [] ``` # Performance Requirements: * The solution must have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input list.","solution":"def remove_duplicates(nums: list) -> list: Returns a new list with all duplicate elements removed, maintaining the order of their first occurrences in the input list. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"Scenario You are developing a file system that stores files in a compressed format to save space. Each file can be individually compressed or decompressed, and the system should support gzip compression. You need to implement functions that handle file compression and decompression, ensuring that the operations handle edge cases such as empty files or invalid gzip data gracefully. Challenge Implement the following functions: `compress_file` and `decompress_file`. Your implementations should follow these rules: 1. `compress_file(data: bytes) -> bytes`: Compresses the input bytes using gzip compression and returns the compressed data. 2. `decompress_file(data: bytes) -> bytes`: Decompresses the gzip-compressed input bytes and returns the original data. Both functions should handle edge cases such as empty input and invalid gzip data. For `decompress_file`, ensure that it checks for invalid gzip format and raises a meaningful error if encountered. # Function Signatures ```python import gzip def compress_file(data: bytes) -> bytes: pass def decompress_file(data: bytes) -> bytes: pass ``` # Example Usage ```python # Compression examples original_data = b\\"Hello World!\\" compressed_data = compress_file(original_data) # The actual compressed data will depend on the implementation details, but it should decompress correctly assert decompress_file(compressed_data) == original_data original_data = b\\"123456\\" compressed_data = compress_file(original_data) assert decompress_file(compressed_data) == original_data original_data = b\\"some long complex string\\" compressed_data = compress_file(original_data) assert decompress_file(compressed_data) == original_data # Decompression examples # Example pre-compressed data, normally you would use `compress_file` to generate this compressed_data = gzip.compress(b\'Hello World!\') assert decompress_file(compressed_data) == b\'Hello World!\' compressed_data = gzip.compress(b\'123456\') assert decompress_file(compressed_data) == b\'123456\' compressed_data = gzip.compress(b\'some long complex string\') assert decompress_file(compressed_data) == b\'some long complex string\' # Invalid data try: decompress_file(b\'invalid compressed data\') except gzip.BadGzipFile: pass # Expected error ``` # Constraints and Performance Requirements * Ensure that gzip compression produces output with minimal delay (linear to the length of input data). * Gzip decompression should validate input and handle errors without crashing. * Input data for both functions will not exceed 1MB. # Notes * Your implementation should efficiently use memory and handle edge cases smoothly. * Consider all potential pitfalls of incorrect or malformed input and design error handling appropriately.","solution":"import gzip from io import BytesIO def compress_file(data: bytes) -> bytes: Compresses the input bytes using gzip compression and returns the compressed data. :param data: Bytes to compress :return: Compressed bytes if not data: return b\'\' out = BytesIO() with gzip.GzipFile(fileobj=out, mode=\\"wb\\") as f: f.write(data) return out.getvalue() def decompress_file(data: bytes) -> bytes: Decompresses the gzip-compressed input bytes and returns the original data. :param data: Gzip-compressed bytes to decompress :return: Decompressed original bytes :raises: gzip.BadGzipFile if the data is not valid gzip data if not data: return b\'\' try: in_ = BytesIO(data) with gzip.GzipFile(fileobj=in_, mode=\\"rb\\") as f: return f.read() except gzip.BadGzipFile as e: raise gzip.BadGzipFile(\\"Invalid gzip data\\") from e"},{"question":"# Question: Implement a function `rotate_string(s: str, n: int) -> str` that takes a string `s` and an integer `n`, and returns the string rotated to the right by `n` positions. The rotation should be cyclic, meaning that characters shifted out of the right end appear from the left. # Input: - `s` (type `str`): The input string. - `n` (type `int`): The number of positions to rotate to the right. # Output: - A string (type `str`): The resulting string after the rotation. # Constraints: - 1 <= len(s) <= 1000 - 0 <= n <= 10^5 # Examples: 1. Input: `s = \\"abcdefgh\\"`, `n = 2` Output: `\\"ghabcdef\\"` Explanation: By rotating the string `\\"abcdefgh\\"` to the right by 2 positions, we get `\\"ghabcdef\\"`. 2. Input: `s = \\"rotation\\"`, `n = 4` Output: `\\"tionrota\\"` Explanation: By rotating the string `\\"rotation\\"` to the right by 4 positions, we get `\\"tionrota\\"`. 3. Input: `s = \\"simple\\"``, `n = 8` Output: `\\"plesim\\"` Explanation: By rotating the string `\\"simple\\"` to the right by 8 positions (which is effectively 2 positions due to the string’s length), we get `\\"plesim\\"`. # Notes: - The function should handle the rotation efficiently even for large values of `n`. - If `n` exceeds the length of the string, treat `n % len(s)` as the number of positions to rotate.","solution":"def rotate_string(s: str, n: int) -> str: Rotates the string `s` to the right by `n` positions. Parameters: s (str): The input string. n (int): The number of positions to rotate. Returns: str: The string rotated to the right by `n` positions. length = len(s) if length == 0: return s n = n % length # to handle cases where n > length of the string return s[-n:] + s[:-n]"},{"question":"# Huffman Encoding and Decoding Problem Description: You are tasked with implementing a function to create a Huffman tree from a given string and another function to encode that string using the Huffman tree. Additionally, implement a function that can decode a given Huffman encoded string using the corresponding Huffman tree. Function Signatures: ```python def build_huffman_tree(data: str) -> dict: Builds a Huffman tree and returns the corresponding encoding map. Args: - data (str): The input string to build the Huffman tree from. Returns: - dict: A dictionary with characters as keys and their corresponding Huffman codes as values. pass def huffman_encode(data: str, huffman_map: dict) -> str: Encodes the given string using the Huffman encoding map. Args: - data (str): The input string to be encoded. - huffman_map (dict): The Huffman encoding map generated from the input string. Returns: - str: The Huffman encoded string. pass def huffman_decode(encoded_data: str, huffman_map: dict) -> str: Decodes the given Huffman encoded string using the Huffman encoding map. Args: - encoded_data (str): The Huffman encoded string. - huffman_map (dict): The Huffman encoding map used to encode the string. Returns: - str: The decoded string. pass ``` Input: - For `build_huffman_tree`: - `data`: A string representing the input text to build the Huffman tree from. - For `huffman_encode`: - `data`: A string representing the plaintext message to be encoded. - `huffman_map`: A dictionary with characters as keys and their corresponding Huffman codes as values. - For `huffman_decode`: - `encoded_data`: A string representing the Huffman encoded message. - `huffman_map`: A dictionary with characters as keys and their corresponding Huffman codes as values. Output: - For `build_huffman_tree`: A dictionary with characters as keys and their corresponding Huffman codes as values. - For `huffman_encode`: A string representing the Huffman encoded message. - For `huffman_decode`: A string representing the decoded plaintext message. Constraints: - The input string for building the Huffman tree should have a length between 1 and 1000 characters inclusive. - All characters in the string are ASCII characters. - The function `huffman_encode` should handle strings efficiently and produce the correct Huffman encoded output. - The function `huffman_decode` should correctly reconstruct the original string from the encoded message and the encoding map. Performance Requirements: - The functions should build the Huffman tree and encode/decode the string efficiently. - Careful with handling edge cases such as single unique character strings and ensuring the Huffman tree is constructed correctly. Example: ```python # Example usage of the functions. input_string = \\"this is an example for huffman encoding\\" huffman_map = build_huffman_tree(input_string) encoded_string = huffman_encode(input_string, huffman_map) print(\\"Encoded String:\\", encoded_string) # Decode the encoded string decoded_string = huffman_decode(encoded_string, huffman_map) print(\\"Decoded String:\\", decoded_string) ```","solution":"import heapq from collections import Counter, namedtuple class Node(namedtuple(\\"Node\\", [\\"left\\", \\"right\\"])): def walk(self, code, acc): self.left.walk(code, acc + \\"0\\") self.right.walk(code, acc + \\"1\\") class Leaf(namedtuple(\\"Leaf\\", [\\"char\\"])): def walk(self, code, acc): code[self.char] = acc or \\"0\\" def build_huffman_tree(data: str) -> dict: Build the Huffman tree for the input string \'data\' and return the encoding map. huffman_map = {} if len(data) == 0: return huffman_map frequency = Counter(data) heap = [] for ch, freq in frequency.items(): heap.append((freq, len(heap), Leaf(ch))) heapq.heapify(heap) count = len(heap) while len(heap) > 1: freq1, _count1, left = heapq.heappop(heap) freq2, _count2, right = heapq.heappop(heap) heapq.heappush(heap, (freq1 + freq2, count, Node(left, right))) count += 1 if heap: [(_, _count, root)] = heap root.walk(huffman_map, \\"\\") return huffman_map def huffman_encode(data: str, huffman_map: dict) -> str: Encode the input string \'data\' using the given Huffman encoding map. return \'\'.join(huffman_map[ch] for ch in data) def huffman_decode(encoded_data: str, huffman_map: dict) -> str: Decode the Huffman encoded string \'encoded_data\' using the given Huffman encoding map. reverse_huffman_map = {v: k for k, v in huffman_map.items()} current_code = \\"\\" decoded_output = [] for bit in encoded_data: current_code += bit if current_code in reverse_huffman_map: character = reverse_huffman_map[current_code] decoded_output.append(character) current_code = \\"\\" return \'\'.join(decoded_output)"},{"question":"# Binary Tree: Duplicate Subtree Detection Background: You need to detect whether a binary tree contains any duplicate subtrees. A subtree is considered a duplicate if another subtree with the same structure and node values exists elsewhere in the tree. Task: Write a function to check for the presence of duplicate subtrees in a given binary tree. Requirements: 1. **Tree Traversal**: - Implement a function to traverse the binary tree efficiently. - Use a serialization method to represent subtrees uniquely. 2. **Duplicate Detection**: - Store the serialized versions of visited subtrees. - Check for duplicates efficiently using a dictionary to track occurrences. 3. **Edge Case Handling**: - Ensure correct behavior for trees with no nodes (empty tree). - Correctly identify and handle trees with all unique subtrees and trees where all nodes are identical. Function Implementation: Your function definition should be as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def has_duplicate_subtree(root: TreeNode) -> bool: # Implement your function here ``` Input and Output: - **Input**: The input is the root of a binary tree. - **Output**: The function should return `True` if a duplicate subtree exists, otherwise `False`. **Example**: ```python # Example 1 # Input: root = [1, 2, 3, 4, None, 2, 4, None, None, 4] # Output: True # # Explanation: The tree has a duplicate subtree with the following structure: # 2 # / # 4 # Example 2 # Input: root = [1, 2, 3, 4, None, None, 4] # Output: False # # Explanation: No duplicate subtrees exist in the tree. # Helper function to build the tree from a list def build_tree(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) i = 1 while queue: node = queue.popleft() if i < len(values) and values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root # Demonstration import collections test_tree_1 = build_tree([1, 2, 3, 4, None, 2, 4, None, None, 4]) test_tree_2 = build_tree([1, 2, 3, 4, None, None, 4]) assert has_duplicate_subtree(test_tree_1) == True assert has_duplicate_subtree(test_tree_2) == False ``` **Constraints**: - The number of nodes in the tree is in the range [1, 10000]. - The value of each node is an integer in the range [-10000, 10000]. **Performance Requirements**: - The function should run in O(n) time complexity, where n is the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize_and_check(root, subtree_map): if not root: return \\"#\\" left_serial = serialize_and_check(root.left, subtree_map) right_serial = serialize_and_check(root.right, subtree_map) subtree_serial = f\\"{root.val},{left_serial},{right_serial}\\" if subtree_serial in subtree_map: subtree_map[subtree_serial] += 1 else: subtree_map[subtree_serial] = 1 return subtree_serial def has_duplicate_subtree(root: TreeNode) -> bool: if not root: return False subtree_map = {} serialize_and_check(root, subtree_map) for count in subtree_map.values(): if count > 1: return True return False # Helper function to build the tree from a list def build_tree(values): if not values: return None root = TreeNode(values[0]) queue = [root] i = 1 while queue: node = queue.pop(0) if i < len(values) and values[i] is not None: node.left = TreeNode(values[i]) queue.append(node.left) i += 1 if i < len(values) and values[i] is not None: node.right = TreeNode(values[i]) queue.append(node.right) i += 1 return root"},{"question":"# Question: Implement the ReLU Activation Function In this task, you will implement the Rectified Linear Unit (ReLU) activation function. ReLU is commonly used in neural networks due to its simplicity and effectiveness in practice. Mathematically, the ReLU function `g` for a given input `x` is defined as: ``` g(x) = x, if x > 0 g(x) = 0, if x <= 0 ``` Your task is to write a function that takes an array of real numbers and applies the ReLU function to each element of this array. Function Signature ```python def custom_rectified_linear_unit(vector: List[float]) -> List[float]: pass ``` Input - `vector` (List[float]): A list of K real numbers. Output - A list of K real numbers after applying the ReLU function. Constraints - The length of the vector can be between 1 and (10^6). - The value of each element in the vector is a real number that fits in the standard floating-point precision. Examples ```python >>> custom_rectified_linear_unit([2.3, 0.6, -2, -3.8]) [2.3, 0.6, 0, 0] >>> custom_rectified_linear_unit([-9.2, -0.3, 0.45, -4.56]) [0, 0, 0.45, 0] ``` Notes - Ensure your solution is optimized for large `vector` sizes up to (10^6) entries. - Handle edge cases such as very large/small values correctly. - Be aware of numerical precision and operations, but since ReLU is simpler than exponential functions, fewer numerical precision issues should arise.","solution":"from typing import List def custom_rectified_linear_unit(vector: List[float]) -> List[float]: Applies the ReLU function to each element in the input vector. Arguments: vector -- List of real numbers. Returns: A list of real numbers where the ReLU function has been applied to each element. return [max(0, x) for x in vector]"},{"question":"# Merge k Sorted Lists: Efficient Merge Context: Merging multiple sorted lists into a single sorted list is a common problem in various applications, such as data analysis and processing. An efficient solution is necessary to handle large datasets. Problem Statement: You are given `k` sorted linked lists, each linked list containing `n` elements. Your task is to merge all these linked lists into one sorted linked list in an efficient manner. Input: - The first line contains two integers `k` and `n` (`1 <= k <= 1000`, `0 <= n <= 500`), representing the number of sorted linked lists and the number of elements in each list. - The next `k` lines each contain `n` integers in non-decreasing order, representing the elements of each sorted linked list. Output: - Output should be a single line containing all the elements of the merged linked list in non-decreasing order. Constraints: - The total number of elements across all lists will not exceed `500000`. - All list elements are integers. Example: **Input:** ``` 3 3 1 4 5 1 3 4 2 6 8 ``` **Output:** ``` 1 1 2 3 4 4 5 6 8 ``` # Implementation Requirements: - Implement the main method `merge_k_sorted_lists` that accepts a list of `k` sorted lists and returns a single merged linked list. - Use efficient data structures to optimize the merging process, such as a min heap (priority queue). - Handle all edge cases, e.g., lists with no elements, lists with varying lengths, and duplicate elements. Good luck!","solution":"import heapq def merge_k_sorted_lists(lists): Merges k sorted linked lists into one sorted linked list. Args: lists (list of list of int): A list containing k sorted lists. Returns: list of int: A merged sorted list. min_heap = [] merged_list = [] # Insert the first element of each list into the heap for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i][0], i, 0)) # Extract the minimum element and add the next element from the same list to the heap while min_heap: val, list_idx, element_idx = heapq.heappop(min_heap) merged_list.append(val) if element_idx + 1 < len(lists[list_idx]): next_element = lists[list_idx][element_idx + 1] heapq.heappush(min_heap, (next_element, list_idx, element_idx + 1)) return merged_list"},{"question":"**Problem Statement**: Given a list of integers, implement an algorithm to find the length of the longest contiguous subarray with an equal number of 0s and 1s. This problem tests your understanding of array manipulation, hashing, and efficient algorithm design. **Function Signature**: ```python def find_max_length(nums: list[int]) -> int: pass ``` **Input**: - `nums` (list of int): A list of integers where each element is either 0 or 1. The length of the list can be up to 10^5. **Output**: - Returns an integer representing the length of the longest contiguous subarray where the number of 0s and 1s are the same. **Constraints**: - The length of `nums` is between 1 and 10^5. - The elements in `nums` are either 0 or 1. **Requirements**: - You should raise a `ValueError` with an appropriate message if the input list is empty. - The function should handle large inputs efficiently, leveraging optimal time complexity solutions such as O(n). **Examples**: ```python >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 1, 0, 0, 1, 1, 0]) 6 >>> find_max_length([0, 0, 1, 1, 0]) 4 >>> find_max_length([1, 1, 1, 1]) 0 >>> find_max_length([]) Traceback (most recent call last): ... ValueError: Input list cannot be empty ``` **Additional Context**: This problem requires you to consider cumulative sums and the use of a hash map for tracking indices efficiently. Upon encountering any position where the cumulative sum has been seen earlier, it implies that the subarray between the previous index and current index has an equal number of 0s and 1s. The task tests your ability to think in terms of prefix sums and space-time trade-offs involved in optimized solutions.","solution":"def find_max_length(nums: list[int]) -> int: if not nums: raise ValueError(\\"Input list cannot be empty\\") # Convert all 0s to -1s to make the problem similar to finding a subarray with sum zero nums = [-1 if num == 0 else 1 for num in nums] max_length = 0 cumulative_sum = 0 sum_indices = {0: -1} # Cumulative sum has been seen at index -1 as initial condition for index, num in enumerate(nums): cumulative_sum += num if cumulative_sum in sum_indices: max_length = max(max_length, index - sum_indices[cumulative_sum]) else: sum_indices[cumulative_sum] = index return max_length"},{"question":"# Question Design a function that can rotate a square matrix 90 degrees clockwise. Your task is to complete this function using an in-place algorithm without using additional matrix for intermediate steps. Input - `matrix`: a list of lists representing a square matrix of integers (`n x n`). Output - An updated `matrix` which is rotated 90 degrees clockwise. Constraints - `1 <= n <= 100` - `-1000 <= matrix[i][j] <= 1000` # Example ```python def rotate_matrix(matrix): pass # Example 1 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) print(matrix1) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] # Example 2 matrix2 = [ [10, 20, 30, 40], [50, 60, 70, 80], [90, 100, 110, 120], [130, 140, 150, 160] ] rotate_matrix(matrix2) print(matrix2) # Output: [[130, 90, 50, 10], [140, 100, 60, 20], [150, 110, 70, 30], [160, 120, 80, 40]] ``` Explanation - For the first example, the original matrix is rotated 90 degrees clockwise, resulting in the transformed matrix. - For the second example, the transformation is performed in-place for the larger 4x4 matrix.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in place. Args: matrix (List[List[int]]): 2D list representing square matrix. Returns: None: The input matrix is modified in place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): # Note: starting from i to avoid duplicating swaps matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for row in matrix: row.reverse()"},{"question":"# Array Transformation Based on Parity Develop a function that processes an input list of integers based on the parity of their positions (index). If the index of the element is even, the element should be squared; if the index is odd, the element should be cubed. # Function Signature ```python def transform_based_on_index(array: List[int]) -> List[int]: pass ``` # Input - `array` (List[int]): A list of integers to be transformed based on their index position. # Output - List of integers where each element is transformed according to its index parity. # Constraints - Performance: The function should handle lists of up to 10^6 elements efficiently. - Index handling: Ensure correct transformations for both even and odd indices within the array. - Invalid inputs: Raise a `ValueError` if any element in the array is not an integer. - Edge cases: Handle empty lists by returning an empty list. # Example ```python >>> transform_based_on_index([2, 3, 4, 5]) [4, 27, 16, 125] >>> transform_based_on_index([1, -1, 2, -2, 3, -3]) [1, -1, 4, -8, 9, -27] >>> transform_based_on_index([0] * 5) [0, 0, 0, 0, 0] >>> transform_based_on_index([]) [] >>> transform_based_on_index([1, \'test\', 3]) Traceback (most recent call last): ... ValueError: All elements in array must be integers. ``` # Notes - Ensure the function adheres to the described transformation rules strictly based on index parity. - Validate that all elements in the input list are integers and handle any discrepancies appropriately.","solution":"from typing import List def transform_based_on_index(array: List[int]) -> List[int]: Processes an input list, squaring elements at even indices and cubing elements at odd indices. if not all(isinstance(i, int) for i in array): raise ValueError(\\"All elements in array must be integers.\\") return [x**2 if i % 2 == 0 else x**3 for i, x in enumerate(array)]"},{"question":"# New Question: **Objective**: Develop a function to determine if a binary tree is a balanced binary tree. A binary tree is considered balanced if the height of its two subtrees of any node never differ by more than one. # Input/Output Specifications * **Input**: The root node of the binary tree. * **Output**: Return `True` if the tree is balanced, otherwise return `False`. # Requirements 1. Implement the function `is_balanced`. 2. The function should: * Calculate the height of the left and right subtrees of each node. * Ensure the height difference between the left and right subtrees of any node is no more than one. * Use recursion to check balance from the leaf nodes up to the root. # Context In many applications, it is important to ensure the data structure maintains efficiency in operations such as search, insertion, and deletion. Verifying that a binary tree is balanced ensures that these operations remain efficient. # Constraints * Assume the binary tree can have up to 1000 nodes. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Define the tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.left.left = TreeNode(8) # Calling the function to check if the tree is balanced print(is_balanced(root)) # Output should be False ``` # Implementation Complete the following function outside the TreeNode class: ```python def is_balanced(root): Determines if the binary tree is balanced. :param root: TreeNode, the root of the binary tree. :return: True if the tree is balanced, otherwise False. def height(node): if not node: return 0 left_height = height(node.left) right_height = height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return height(root) != -1 ``` # Performance Requirements * Ensure that the solution has a time complexity of O(n), where n is the number of nodes in the tree. * Minimize the extra space used, preferably achieving O(h) additional space, where h is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if the binary tree is balanced. :param root: TreeNode, the root of the binary tree. :return: True if the tree is balanced, otherwise False. def height(node): if not node: return 0 left_height = height(node.left) right_height = height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return height(root) != -1"},{"question":"# Coding Assessment Question Context: You are developing an e-commerce application and need to implement a feature that suggests product bundles to users. One approach is to identify consecutive sequences of days where the user was active on the platform. This will help you understand user engagement patterns and suggest appropriate bundles based on their active days. Task: Write a function `find_consecutive_active_days` that takes a list of integers `active_days` and returns a list of tuples where each tuple represents the start and end of a consecutive sequence of days. Function Signature: ```python def find_consecutive_active_days(active_days: list[int]) -> list[tuple[int, int]]: ``` Input: * `active_days`: A list of integers where each integer represents a day the user was active. The days are not necessarily sorted and might contain duplicates. Output: * A list of tuples where each tuple contains two integers representing the start and end days of a consecutive sequence of days that the user was active. The resulting list should not contain any overlapping or duplicate sequences and should be sorted by the start day of each sequence. Constraints: * The days in `active_days` are integers ranging from 1 to 365. * The input list should have at least one element. Examples: ```python find_consecutive_active_days([1, 2, 2, 3, 5, 8, 9, 10]) => [(1, 3), (5, 5), (8, 10)] find_consecutive_active_days([7, 5, 6, 6, 4]) => [(4, 7)] find_consecutive_active_days([34, 33, 32, 31]) => [(31, 34)] find_consecutive_active_days([1, 3, 5, 7]) => [(1, 1), (3, 3), (5, 5), (7, 7)] find_consecutive_active_days([100]) => [(100, 100)] ``` Scenario: You utilize the function to analyze user activity trends on your platform. By identifying periods of consecutive activity, you can create more personalized and effective product recommendations or marketing strategies.","solution":"def find_consecutive_active_days(active_days: list[int]) -> list[tuple[int, int]]: Returns a list of tuples where each tuple represents the start and end days of a consecutive sequence of active days. # First, we remove duplicates and sort the days active_days = sorted(set(active_days)) if not active_days: return [] result = [] start = active_days[0] end = active_days[0] for i in range(1, len(active_days)): if active_days[i] == end + 1: end = active_days[i] else: result.append((start, end)) start = active_days[i] end = active_days[i] result.append((start, end)) return result"},{"question":"# Next Permutation Implement a function that rearranges numbers into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it should return the lowest possible order (i.e., the sorted order). The replacement must be in-place and use only constant extra memory. # Requirements: 1. Implement a function, `next_permutation(nums: List[int]) -> None`. 2. The function should modify the list `nums` in-place. 3. Aim for an efficient solution with O(n) complexity. # Constraints: - The `nums` list will contain elements in the range `[1, 1000]`. - Length of `nums` lies within `[1, 1000]`. # Example: ```python # Example 1 nums = [1, 2, 3] next_permutation(nums) # The function should modify nums to [1, 3, 2] # Example 2 nums = [3, 2, 1] next_permutation(nums) # The function should modify nums to [1, 2, 3] # Example 3 nums = [1, 1, 5] next_permutation(nums) # The function should modify nums to [1, 5, 1] # Example 4 nums = [1] next_permutation(nums) # The function should modify nums to [1] # Example 5 nums = [1, 5, 4, 3, 2] next_permutation(nums) # The function should modify nums to [2, 1, 3, 4, 5] ``` # Edge Cases: - The list `nums` may contain only one element. - The list may be sorted in descending order. # Implementation Details: 1. Traverse the list from the end to find the first pair of two successive numbers `nums[i]` and `nums[i+1]` where `nums[i] < nums[i+1]`. 2. If no such pair is found, reverse the entire list to return the smallest permutation. 3. Otherwise, find the smallest element in the list from `i` to the end that is larger than `nums[i]` and swap them. 4. Finally, reverse the order of the elements from `i+1` to the end of the list to achieve the next permutation. # Function Signature: ```python def next_permutation(nums: List[int]) -> None: pass ``` # Implementation Note: - Ensure the function modifies the original `nums` list without returning anything.","solution":"def next_permutation(nums): Modifies nums in-place to the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it modifies nums to the lowest possible order (i.e., sorted in ascending order). def reverse(nums, start): Reverses the elements of nums starting from index start to the end of the list. i, j = start, len(nums) - 1 while i < j: nums[i], nums[j] = nums[j], nums[i] i, j = i + 1, j - 1 # Find the first index i such that nums[i] < nums[i + 1] from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If no such index is found, reverse the entire list to obtain the smallest permutation if i == -1: reverse(nums, 0) return # Find the first index j greater than i such that nums[j] > nums[i] from the end j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Reverse the part of the list from i+1 to the end reverse(nums, i + 1)"},{"question":"# Context Graph traversal is a fundamental technique in computer science, used in various applications such as pathfinding, testing connectivity, and cycle detection. One common way to represent graphs is through an adjacency list. # Problem Statement You are provided with a graph represented as an adjacency list. Implement a function to determine if there is a path between two given nodes. # Task Create a function `is_path_exist(graph: Dict[int, List[int]], src: int, dest: int) -> bool` that checks if there exists a path from `src` to `dest` in the given directed graph. # Function Signature ```python def is_path_exist(graph: Dict[int, List[int]], src: int, dest: int) -> bool: pass ``` # Input * `graph`: A dictionary where each key is a node, and the corresponding value is a list of nodes it has directed edges to. * `src`: An integer representing the starting node. * `dest`: An integer representing the destination node. # Output * A boolean value, `True` if there is a path from `src` to `dest`, `False` otherwise. # Example Usage ```python # Example Usage graph = { 1: [2], 2: [3, 4], 3: [5], 4: [5], 5: [] } print(is_path_exist(graph, 1, 5)) # Should output True print(is_path_exist(graph, 1, 6)) # Should output False ``` # Constraints 1. The total number of nodes will be less than or equal to 1000. 2. The graph does not contain any self-loops. 3. The graph can be cyclic. 4. The `src` and `dest` are guaranteed to be nodes in the graph. # Notes - You can utilize any graph traversal technique such as Depth-First Search (DFS) or Breadth-First Search (BFS) to implement the solution. - Ensure the function handles large graphs efficiently.","solution":"def is_path_exist(graph, src, dest): Determines if there is a path from src to dest in the given directed graph. :param graph: A dictionary where each key is a node and the value is a list of nodes it has edges to. :param src: The starting node. :param dest: The destination node. :return: True if there is a path from src to dest, False otherwise. visited = set() def dfs(node): if node == dest: return True visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(src)"},{"question":"# Context A company providing smart home solutions wants to automate lighting control based on sunrise and sunset timings. To do this, they need to calculate the next occurrence of either sunrise or sunset after a given timestamp. You have been asked to create a function that determines this. # Task Implement a function called `next_event(timestamp, events)` which calculates the next event (either sunrise or sunset) based on the given `timestamp` and a list of event times. Each event time is a string in the format \\"HH:MM\\" representing the time of day in 24-hour format. The function should return a string representing the next event time in the same \\"HH:MM\\" format. If the `timestamp` is past all event times for the current day, return the earliest event time for the next day. # Specifications * **Input Format**: - An integer `timestamp` representing the time in minutes past midnight (e.g., \\"00:00\\" is 0, \\"12:00\\" is 720, \\"23:59\\" is 1439). - A list of strings `events` representing event times in \\"HH:MM\\" format. * **Constraints**: - The `timestamp` will always be between 0 and 1439 inclusive. - The `events` list will have at least one time and all times will be unique and sorted in ascending order. * **Output Format**: - A string representing the next event time in \\"HH:MM\\" format. # Example ```python >>> events = [\\"06:00\\", \\"18:00\\"] >>> next_event(450, events) # 450 minutes is \\"07:30\\" \'18:00\' >>> events = [\\"06:00\\", \\"18:00\\"] >>> next_event(36, events) # 36 minutes is \\"00:36\\" \'06:00\' >>> events = [\\"06:00\\", \\"18:00\\"] >>> next_event(1080, events) # 1080 minutes is \\"18:00\\" \'06:00\' >>> events = [\\"06:00\\", \\"18:00\\"] >>> next_event(20, events) # 20 minutes is \\"00:20\\" \'06:00\' >>> events = [\\"00:00\\", \\"12:00\\", \\"23:59\\"] >>> next_event(720, events) # 720 minutes is \\"12:00\\" \'23:59\' ``` # Notes * Ensure the function handles all possible edge cases, including exactly matching a given event time, and times wrapping to the next day. * You may assume the input times are in the correct format and are logically valid. * The function implementation should not use any external libraries for handling date or time computations.","solution":"def next_event(timestamp, events): Returns the next event (either sunrise or sunset) after the given timestamp. Parameters: timestamp (int): The time in minutes past midnight (0 to 1439). events (list): A list of event times in \\"HH:MM\\" format, sorted in ascending order. Returns: str: The next event time in \\"HH:MM\\" format. for event in events: event_minutes = int(event[:2]) * 60 + int(event[3:]) if timestamp < event_minutes: return event # If no event is found for the current day, return the first event for the next day return events[0]"},{"question":"# Problem Description You are tasked with implementing a simple in-memory caching system with time-based invalidation. This cache should store key-value pairs and automatically invalidate entries based on a specified time-to-live (TTL) value. Your tasks are: 1. Implement a method to add or update a key-value pair in the cache with a specific TTL. 2. Implement a method to get a value from the cache by its key, which should return `None` if the key is not found or if it has expired. 3. Implement a method to delete a key-value pair from the cache. 4. Implement a method to clear all entries in the cache. 5. Implement a method to count the current number of valid entries in the cache. # Function Specifications 1. **put(key: str, value: Any, ttl: int)**: Add or update a key-value pair with TTL. - **Input**: A string `key`, a value `value`, and an integer `ttl` representing time-to-live in seconds. - **Output**: None - **Behavior**: Store the key-value pair in the cache, and set the TTL for how long this entry should remain valid. Each call to `put` for an existing key should reset its TTL. 2. **get(key: str) -> Any**: Retrieve a value by key. - **Input**: A string `key` - **Output**: The value associated with the key or `None` if the key is not found or has expired. - **Behavior**: Return the value if the key exists and its TTL has not expired; otherwise, return `None`. 3. **delete(key: str)**: Delete a key-value pair. - **Input**: A string `key` - **Output**: None - **Behavior**: Remove the key-value pair from the cache if it exists. 4. **clear()**: Clear all entries in the cache. - **Input**: None - **Output**: None - **Behavior**: Remove all key-value pairs from the cache. 5. **count_entries() -> int**: Count valid entries in the cache. - **Input**: None - **Output**: An integer representing the number of valid entries currently in the cache. - **Behavior**: Return the number of key-value pairs that have not expired. # Constraints - TTL values will always be positive integers. - The cache should handle both string and integer keys. - The cache must be thread-safe, ensuring correctness in concurrent environments. # Example ```python cache = Cache() # Add or update key-value pairs cache.put(\\"user_1\\", \\"Alice\\", 5) cache.put(\\"user_2\\", \\"Bob\\", 10) # Retrieve values print(cache.get(\\"user_1\\")) # Expected: \\"Alice\\" (if within TTL) print(cache.get(\\"user_2\\")) # Expected: \\"Bob\\" (if within TTL) # Delete a key cache.delete(\\"user_1\\") print(cache.get(\\"user_1\\")) # Expected: None (since deleted) # Count valid entries print(cache.count_entries()) # Expected: 1 (only \\"user_2\\" remains) # Clear all entries cache.clear() print(cache.count_entries()) # Expected: 0 ``` # Requirements - Ensure the cache performs efficiently even with a large number of entries. - Implement proper thread safety mechanisms to handle concurrent access to the cache. - Consider edge cases such as attempts to access expired or non-existent keys.","solution":"import time from threading import Lock class Cache: def __init__(self): self.cache = {} self.lock = Lock() def put(self, key: str, value: any, ttl: int): with self.lock: expiry_time = time.time() + ttl self.cache[key] = (value, expiry_time) def get(self, key: str): with self.lock: if key not in self.cache: return None value, expiry_time = self.cache.get(key, (None, 0)) if time.time() > expiry_time: del self.cache[key] return None return value def delete(self, key: str): with self.lock: if key in self.cache: del self.cache[key] def clear(self): with self.lock: self.cache.clear() def count_entries(self) -> int: with self.lock: current_time = time.time() valid_entries = {k: v for k, v in self.cache.items() if v[1] > current_time} return len(valid_entries)"},{"question":"# Problem Statement: You are tasked with developing a system to manage a library of books. The system needs to keep track of the books and their respective details and allow for basic querying of the database. Implement a Python class `Library` which supports the following functionality: 1. Adding a new book to the library. 2. Removing a book from the library by its ISBN. 3. Getting details of a book by its ISBN. 4. Finding all books by a specific author. 5. Finding all books in a specific genre. Each book is represented as a dictionary with the following keys: - `title`: The title of the book (string) - `author`: The author of the book (string) - `isbn`: The ISBN of the book (string) - `genre`: The genre of the book (string) The `Library` class should provide the following methods: - `add_book(book: dict) -> None`: Adds the given book to the library. - `remove_book(isbn: str) -> None`: Removes the book with the given ISBN from the library. - `get_book(isbn: str) -> dict`: Returns the details of the book with the given ISBN. If the book is not found, return `None`. - `find_books_by_author(author: str) -> list`: Returns a list of all books by the given author. - `find_books_by_genre(genre: str) -> list`: Returns a list of all books in the given genre. You can assume that all ISBNs are unique and well-formed strings. Constraints * The library can store up to 10,000 books. * Each book added has a unique ISBN. * The methods should be efficient in terms of time complexity. Inputs and Outputs * **Input**: Methods called with their respective parameters. * **Output**: Methods return their respective outputs as specified. Example: ```python library = Library() library.add_book({\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"isbn\\": \\"9780060935467\\", \\"genre\\": \\"Fiction\\"}) library.add_book({\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"isbn\\": \\"9780451524935\\", \\"genre\\": \\"Dystopian\\"}) assert library.get_book(\\"9780060935467\\") == {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"isbn\\": \\"9780060935467\\", \\"genre\\": \\"Fiction\\"} assert library.find_books_by_author(\\"George Orwell\\") == [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"isbn\\": \\"9780451524935\\", \\"genre\\": \\"Dystopian\\"}] assert library.find_books_by_genre(\\"Dystopian\\") == [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"isbn\\": \\"9780451524935\\", \\"genre\\": \\"Dystopian\\"}] library.remove_book(\\"9780060935467\\") assert library.get_book(\\"9780060935467\\") is None ```","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book: dict) -> None: self.books[book[\'isbn\']] = book def remove_book(self, isbn: str) -> None: if isbn in self.books: del self.books[isbn] def get_book(self, isbn: str) -> dict: return self.books.get(isbn) def find_books_by_author(self, author: str) -> list: return [book for book in self.books.values() if book[\'author\'] == author] def find_books_by_genre(self, genre: str) -> list: return [book for book in self.books.values() if book[\'genre\'] == genre]"},{"question":"# Question You are required to design a self-checkout system for a grocery store. The system should support adding items to a cart, removing them, and computing the total cost including a discount if applicable. Each item has a name, price, and quantity. The discount is applied based on predefined conditions. Implement a `Cart` class with the following methods: Method 1: `add_item` * **Input**: `name` (str), `price` (float), `quantity` (int) * **Output**: Add the item to the cart. If the item already exists, update its quantity. * **Constraints**: - The price should be a non-negative value. - The quantity should be a positive integer. Method 2: `remove_item` * **Input**: `name` (str) * **Output**: Remove the item from the cart. If the item does not exist, do nothing. * **Constraints**: - The name should be a non-empty string. Method 3: `total_cost` * **Input**: `discount` (float, optional, default=0) * **Output**: Return the total cost of all items in the cart, applying the discount if provided. * **Constraints**: - The discount should be between 0 and 100 inclusive and represents a percentage. Here’s an example of how the `Cart` class should behave: ```python class Cart: def __init__(self): self.items = {} def add_item(self, name, price, quantity): if price < 0 or quantity <= 0: raise ValueError(\\"Price must be non-negative and quantity positive\\") if name in self.items: self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name): if name in self.items: del self.items[name] def total_cost(self, discount=0): if not 0 <= discount <= 100: raise ValueError(\\"Discount must be between 0 and 100\\") total = sum(details[\'price\'] * details[\'quantity\'] for details in self.items.values()) return total * ((100 - discount) / 100) # Example Usage: cart = Cart() cart.add_item(\\"apple\\", 0.5, 10) cart.add_item(\\"banana\\", 0.2, 5) cart.add_item(\\"banana\\", 0.2, 5) # Update quantity cart.remove_item(\\"apple\\") print(cart.total_cost()) # Output: 2.0 print(cart.total_cost(10)) # Output: 1.8 ``` # Objective - Implement the `Cart` class with the specified methods. - Demonstrate the functionality of your class with example usage, as shown above.","solution":"class Cart: def __init__(self): self.items = {} def add_item(self, name, price, quantity): if price < 0 or quantity <= 0: raise ValueError(\\"Price must be non-negative and quantity positive\\") if name in self.items: self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name): if name in self.items: del self.items[name] def total_cost(self, discount=0): if not 0 <= discount <= 100: raise ValueError(\\"Discount must be between 0 and 100\\") total = sum(details[\'price\'] * details[\'quantity\'] for details in self.items.values()) return total * ((100 - discount) / 100)"},{"question":"# Coding Assessment Question A sparse matrix is a matrix in which most of the elements are zero. Efficient storage and computation with sparse matrices often involve techniques like compressed sparse row (CSR) format. **Objective**: Implement a CSR sparse matrix class and demonstrate its capability by performing matrix-vector multiplication. Requirements: 1. **CSR Matrix Implementation**: * Create a class `CSRMatrix` that initializes with a given 2D list (matrix). * Implement methods to convert the given matrix to CSR format, storing only the non-zero elements along with their row and column indices. 2. **Matrix-Vector Multiplication**: * Extend the `CSRMatrix` class to include a method for multiplying the CSR matrix with a dense vector. * Ensure the method performs the multiplication efficiently by only considering the non-zero elements. Function Signature ```python class CSRMatrix: def __init__(self, matrix: list[list[int]]): # Initialize the CSR matrix from the given 2D list pass def to_csr(self) -> None: # Convert the matrix to CSR format pass def multiply(self, vector: list[int]) -> list[int]: # Multiply the CSR matrix by a dense vector pass ``` Example Usage: ```python matrix = [ [0, 0, 3, 0], [22, 0, 0, 0], [0, 15, 0, 0], [0, 0, 0, 4] ] vector = [1, 2, 3, 4] csr_matrix = CSRMatrix(matrix) csr_matrix.to_csr() result = csr_matrix.multiply(vector) print(result) # Expected output: [9, 22, 30, 16] ``` Constraints: 1. The input matrix should have at least one row and one column. 2. The vector should have the same length as the number of columns in the matrix. 3. Assume the matrix and vector contain integers. Context: Sparse matrices are prevalent in various scientific and engineering applications, including systems of linear equations, machine learning algorithms, and graph representations. By implementing the CSR format and matrix-vector multiplication, you demonstrate your ability to handle efficient data storage and computational techniques.","solution":"class CSRMatrix: def __init__(self, matrix: list[list[int]]): self.matrix = matrix self.values = [] self.col_indices = [] self.row_pointers = [] def to_csr(self) -> None: self.values = [] self.col_indices = [] self.row_pointers = [0] for row in self.matrix: for col_idx, value in enumerate(row): if value != 0: self.values.append(value) self.col_indices.append(col_idx) self.row_pointers.append(len(self.values)) def multiply(self, vector: list[int]) -> list[int]: result = [0] * len(self.matrix) for row_idx, row_start in enumerate(self.row_pointers[:-1]): row_end = self.row_pointers[row_idx + 1] for idx in range(row_start, row_end): result[row_idx] += self.values[idx] * vector[self.col_indices[idx]] return result"},{"question":"# Question: Scheduling Tasks with Dependencies Context: You are tasked with implementing a scheduling system for a project management tool. The tool needs to handle tasks with dependencies, ensuring that dependent tasks are only executed after their prerequisites are completed. This requires a topological sort of the tasks. Task: Implement the `TaskScheduler` class with the following functionalities: 1. `add_task(task: str)`: Method to add a task to the scheduler. 2. `add_dependency(task: str, dependency: str)`: Method to add a dependency for a task. 3. `get_order() -> list`: Method that returns a topological order of tasks if possible. If there is a cycle, return an empty list. Additionally, you should implement the `schedule_tasks(tasks: list, dependencies: list) -> list` function that: - Accepts a list of tasks. - Accepts a list of task dependencies where each dependency is a tuple of `(task, dependency)`. - Returns a list of tasks in topological order, or an empty list if a cycle exists. Requirements: * **Input Formats**: - `add_task` and `add_dependency` methods accept strings for task and dependency. - `schedule_tasks` function accepts a list of strings for tasks and a list of tuples for dependencies. * **Output Formats**: - `get_order` and `schedule_tasks` return a list of strings. * **Constraints**: - Tasks and dependencies will consist only of lowercase English letters. - The number of tasks is up to 100. - The number of dependencies is up to 500. Example: ```python tasks = [\\"design\\", \\"develop\\", \\"test\\", \\"deploy\\"] dependencies = [(\\"develop\\", \\"design\\"), (\\"test\\", \\"develop\\"), (\\"deploy\\", \\"test\\")] order = schedule_tasks(tasks, dependencies) print(order) # Output: [\\"design\\", \\"develop\\", \\"test\\", \\"deploy\\"] ``` **Note**: You must follow the structure for the `TaskScheduler` class and `schedule_tasks` function provided below. ```python from collections import defaultdict, deque class TaskScheduler: def __init__(self) -> None: self.graph = defaultdict(list) self.in_degree = defaultdict(int) self.tasks = set() def add_task(self, task: str) -> None: # Implementation here def add_dependency(self, task: str, dependency: str) -> None: # Implementation here def get_order(self) -> list: # Implementation here def schedule_tasks(tasks: list, dependencies: list) -> list: # Implementation here ``` Testing: Ensure your implementation passes the following doctests: ```python >>> tasks = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> dependencies = [(\\"b\\", \\"a\\"), (\\"c\\", \\"b\\"), (\\"d\\", \\"c\\")] >>> order = schedule_tasks(tasks, dependencies) >>> order [\'a\', \'b\', \'c\', \'d\'] >>> tasks = [\\"a\\", \\"b\\", \\"c\\"] >>> dependencies = [(\\"b\\", \\"a\\"), (\\"c\\", \\"b\\"), (\\"a\\", \\"c\\")] # Introducing a cycle >>> order = schedule_tasks(tasks, dependencies) >>> order [] ```","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self) -> None: self.graph = defaultdict(list) self.in_degree = defaultdict(int) self.tasks = set() def add_task(self, task: str) -> None: if task not in self.tasks: self.tasks.add(task) self.in_degree[task] = 0 def add_dependency(self, task: str, dependency: str) -> None: self.graph[dependency].append(task) self.in_degree[task] += 1 def get_order(self) -> list: order = [] zero_in_degree_queue = deque([task for task in self.tasks if self.in_degree[task] == 0]) while zero_in_degree_queue: current_task = zero_in_degree_queue.popleft() order.append(current_task) for dependent_task in self.graph[current_task]: self.in_degree[dependent_task] -= 1 if self.in_degree[dependent_task] == 0: zero_in_degree_queue.append(dependent_task) if len(order) == len(self.tasks): return order else: return [] def schedule_tasks(tasks: list, dependencies: list) -> list: scheduler = TaskScheduler() for task in tasks: scheduler.add_task(task) for task, dependency in dependencies: scheduler.add_dependency(task, dependency) return scheduler.get_order()"},{"question":"# Coding Question: Implement the following two functions for the `LinkedList` class provided: 1. **Function to reverse the linked list**: Implement a method `reverse` to reverse the linked list in place. ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, head=None): self.head = head def reverse(self) -> None: Reverse the linked list in place. >>> lst = LinkedList(ListNode(1, ListNode(2, ListNode(3)))) >>> lst.reverse() >>> lst.to_list() [3, 2, 1] >>> lst2 = LinkedList(ListNode(1)) >>> lst2.reverse() >>> lst2.to_list() [1] >>> lst3 = LinkedList() >>> lst3.reverse() >>> lst3.to_list() [] # Your implementation here ``` 2. **Function to convert the linked list to a list**: Implement a method `to_list` to convert the linked list to a Python list of values. ```python class LinkedList: # existing methods... def to_list(self) -> list[int]: Convert the linked list to a Python list of values. Returns: A list of node values in the linked list. >>> LinkedList(ListNode(1, ListNode(2, ListNode(3)))).to_list() [1, 2, 3] >>> LinkedList(ListNode(1)).to_list() [1] >>> LinkedList().to_list() [] # Your implementation here ``` # Constraints: * The linked list node values are integers. * The linked list can be empty. * The maximum number of nodes in the linked list is not greater than 1000. # Examples: ```python # Example 1 lst = LinkedList(ListNode(1, ListNode(2, ListNode(3, ListNode(4))))) print(lst.to_list()) # Output: [1, 2, 3, 4] lst.reverse() print(lst.to_list()) # Output: [4, 3, 2, 1] # Example 2 lst2 = LinkedList(ListNode(1)) print(lst2.to_list()) # Output: [1] lst2.reverse() print(lst2.to_list()) # Output: [1] # Example 3 lst3 = LinkedList() print(lst3.to_list()) # Output: [] lst3.reverse() print(lst3.to_list()) # Output: [] ``` # Additional Notes: * Ensure the methods correctly handle lists with only one node and empty linked lists. * The implementation should be efficient in both time and space complexity for large linked lists.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, head=None): self.head = head def reverse(self) -> None: Reverse the linked list in place. prev = None current = self.head while current is not None: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self) -> list: Convert the linked list to a Python list of values. result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result"},{"question":"# Coding Assessment Question: Rainwater Trapping Problem Given `n` non-negative integers representing the height of a series of bars where the width of each bar is 1, compute how much water it is able to trap after raining. Your task is to implement the function `trap_water` that calculates the total amount of trapped water given the following constraints. Function Signature ```python def trap_water(height: List[int]) -> int: pass ``` # Input * `height`: A list of integers `height` where `height[i]` represents the height of the ith bar (0 ≤ |height| ≤ 10^5). # Output * Returns an integer representing the amount of water trapped after raining. # Example ```python height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] # Output: 6 height = [4, 2, 0, 3, 2, 5] # Output: 9 ``` # Constraints * Your algorithm should run with a time complexity of O(n). * Use two-pointer technique or dynamic programming to achieve this efficiently. # Requirements 1. Ensure the function is efficient and handles large inputs gracefully. 2. Consider edge cases such as a list of all zeros or a list with no trapping capacity. 3. No external libraries are allowed for additional helper functions. Given this information, implement the function `trap_water`.","solution":"from typing import List def trap_water(height: List[int]) -> int: if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: if height[left] > left_max: left_max = height[left] else: water_trapped += left_max - height[left] left += 1 else: if height[right] > right_max: right_max = height[right] else: water_trapped += right_max - height[right] right -= 1 return water_trapped"},{"question":"# Depth-First Search and Optimized Pathfinding in a Weighted Maze Objective You have been provided with a base implementation of Depth-First Search (DFS) for pathfinding in a 2D binary grid (where cells are either passable or obstacles). Your task is to modify and optimize the DFS algorithm to account for weighted grids, where each cell can have a different movement cost. Task Modify the provided DFS algorithm to find the path with the minimum movement cost in a weighted grid. Ensure that your implementation prioritizes cells with lower weights, leading to an optimized traversal and path selection. Input 1. **Grid of weights**: A 2D list where each element is a positive integer representing the weight (movement cost) of a cell. ```python grid_weighted = [ [1, 2, 2, 3, 1], [1, 3, 3, 3, 1], [1, 1, 1, 3, 1], [3, 3, 1, 1, 1], [1, 1, 1, 1, 1], ] ``` 2. **Initial Position**: A tuple representing the starting coordinates (row, column). 3. **Goal Position**: A tuple representing the goal coordinates (row, column). Output A list of tuples where each tuple represents the coordinates of the path from the initial to the goal position inclusive, optimized for the minimum movement cost. Constraints 1. Movement is allowed in four directions: up, down, left, and right. 2. Obstacle cells must be represented with a weight of -1. 3. Ensure the algorithm handles grids of varying sizes efficiently. Performance Requirements * The solution should be optimized to consider the movement cost, resulting in the minimum cost path. * The implemented algorithm should avoid revisiting nodes excessively, thereby optimizing time and space complexity, though explicit complexity constraints are not enumerated. Scenario The weighted maze represents different terrain costs. You need to implement an optimized DFS that minimizes the cost of the path through the terrain, actively using weights. Example ```python grid_weighted = [ [1, 2, 2, 3, 1], [1, 3, 3, 3, 1], [1, 1, 1, 3, 1], [3, 3, 1, 1, 1], [1, 1, 1, 1, 1], ] start = (0, 0) goal = (4, 4) # Expected output: List of tuples representing the path. ``` Implement the modified algorithm within a class `OptimizedDFS`.","solution":"import heapq def optimized_dfs(grid, start, goal): Returns the path from start to goal with the minimum movement cost. def get_neighbors(position): row, col = position for drow, dcol in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_row, new_col = row + drow, col + dcol if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]) and grid[new_row][new_col] != -1: yield (new_row, new_col) rows, cols = len(grid), len(grid[0]) heap = [(0, start)] # (cost, current_position) visited = set() cost_so_far = {start: 0} came_from = {start: None} while heap: current_cost, current = heapq.heappop(heap) if current in visited: continue if current == goal: break visited.add(current) for neighbor in get_neighbors(current): new_cost = current_cost + grid[neighbor[0]][neighbor[1]] if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]: cost_so_far[neighbor] = new_cost priority = new_cost heapq.heappush(heap, (priority, neighbor)) came_from[neighbor] = current # Reconstruct the path if goal not in came_from: return [] # No path found path = [] current = goal while current is not None: path.append(current) current = came_from[current] return path[::-1] # Example Usage grid_weighted = [ [1, 2, 2, 3, 1], [1, 3, 3, 3, 1], [1, 1, 1, 3, 1], [3, 3, 1, 1, 1], [1, 1, 1, 1, 1], ] start = (0, 0) goal = (4, 4) print(optimized_dfs(grid_weighted, start, goal))"},{"question":"# Problem Statement: You are given a list of integers representing the heights of buildings arranged in a straight line. Each building has a width of 1 unit. The task is to find the maximum rectangular area that can be formed using consecutive buildings. # Instructions: 1. Implement a function `max_rect_area(heights: list[int]) -> int` that returns the maximum area of a rectangle that can be formed by using consecutive buildings. 2. Each element in the `heights` list is an integer indicating the height of a building. # Constraints: * Height `h` can be any non-negative integer. * The input list can have any length from 0 to 10^5. # Input and Output Formats: * **Input**: A list of integers representing the heights of buildings. * **Output**: An integer representing the maximum area of the rectangle. # Examples: ```python >>> max_rect_area([2,1,5,6,2,3]) 10 >>> max_rect_area([2,4]) 4 >>> max_rect_area([1,2,3,4,5]) 9 >>> max_rect_area([]) 0 ``` **Explanation**: - In the first example, the maximum rectangle has an area of 10 (from buildings with heights [5,6]). - In the second example, the maximum rectangle has an area of 4 (one building with height 4). - In the third example, the maximum rectangle is formed by the last three buildings (heights [3,4,5]) forming an area of 9. *Edge Cases*: 1. If there are no buildings, the function should return 0. 2. If the list of heights contains all zeroes, the function should return 0.","solution":"def max_rect_area(heights): Returns the maximum rectangular area that can be formed with consecutive buildings. Args: heights (list): A list of integers representing the heights of buildings. Returns: int: The maximum area of a rectangle. # Function to find the largest rectangle in histogram stack, max_area = [], 0 for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"Task Write a function to implement a k-nearest neighbors (k-NN) classifier from scratch. Your function should take a dataset, a set of labels, and a new data point, and it should return the predicted label for the new data point based on the majority vote of the k nearest data points. # Details **Function Signature**: ```python def knn_classifier( data: np.ndarray, labels: np.ndarray, new_point: np.ndarray, k: int ) -> int: ... ``` # Parameters - `data`: A 2-dimensional numpy array where each row represents a data point and each column represents a feature. - `labels`: A 1-dimensional numpy array where each element represents the label corresponding to a data point in `data`. - `new_point`: A 1-dimensional numpy array representing the new data point to classify. - `k`: An integer representing the number of nearest neighbors to consider. # Output - An integer representing the predicted label for `new_point`. # Constraints - The `data` array is always non-empty and contains valid float values. - The `labels` array is non-empty, with the same number of elements as the number of rows in `data`. - `k` is less than or equal to the number of rows in `data`. # Example ```python import numpy as np data = np.array([ [2.0, 3.0], [1.0, 1.0], [3.0, 4.0], [6.0, 5.0], [7.0, 7.0], [9.0, 9.0] ]) labels = np.array([0, 0, 0, 1, 1, 1]) new_point = np.array([5.0, 5.0]) k = 3 predicted_label = knn_classifier(data, labels, new_point, k) print(predicted_label) # Expected output: 1 ``` # Guidelines - Ensure your function is efficient, considering both time and space complexity. - Implement the distance calculation using Euclidean distance. - Handle ties by returning the smallest label numerically if there is an equal number of votes.","solution":"import numpy as np def knn_classifier(data, labels, new_point, k): Implements the k-nearest neighbors algorithm. Parameters: data (np.ndarray): 2-dimensional array where each row is a data point. labels (np.ndarray): 1-dimensional array where each element is the label corresponding to a data point. new_point (np.ndarray): 1-dimensional array representing the new data point to classify. k (int): The number of nearest neighbors to consider. Returns: int: The predicted label for the new_point. # Calculate the Euclidean distances from the new point to all points in the dataset distances = np.linalg.norm(data - new_point, axis=1) # Find the indices of the k smallest distances nearest_indices = np.argsort(distances)[:k] # Get the labels of the k nearest neighbors nearest_labels = labels[nearest_indices] # Find the most common label among the nearest neighbors labels, counts = np.unique(nearest_labels, return_counts=True) predicted_label = labels[np.argmax(counts)] return predicted_label"},{"question":"# Context In software development, sorting algorithms are essential tools for organizing data. Python provides a built-in sorting method that can be customized with a specific key for sorting complex data structures. In this task, you are required to sort a list of dictionaries based on a specified key. # Objective Write a Python function `sort_dicts_by_key` that takes a list of dictionaries and a key, and returns a new list of dictionaries sorted by the specified key. # Requirements 1. The function should accept exactly two parameters: `dicts_list` and `sort_key`. 2. The function should operate on a list of dictionaries where each dictionary contains the key `sort_key`. 3. The function should return a new list of dictionaries, sorted in ascending order based on the values corresponding to `sort_key`. # Input Validation - If `dicts_list` is not a list, raise a `TypeError`. - If any element in `dicts_list` is not a dictionary, raise a `TypeError`. - If `sort_key` is not a string, raise a `TypeError`. - If any dictionary in `dicts_list` does not contain the `sort_key`, raise a `KeyError`. # Implementation Details - Use Python\'s built-in `sorted()` function with an appropriate sorting key. - Ensure that the original list of dictionaries is not modified (i.e., return a new list). - Perform input validation as specified. # Input Format - `dicts_list` (list): A list containing dictionaries. - `sort_key` (str): The key used to sort the dictionaries. # Output Format - A new list of dictionaries sorted by the specified key. # Examples 1. `sort_dicts_by_key([{\'id\': 3, \'name\': \'Alice\'}, {\'id\': 1, \'name\': \'Bob\'}, {\'id\': 2, \'name\': \'Charlie\'}], \'id\')` returns ` [{\'id\': 1, \'name\': \'Bob\'}, {\'id\': 2, \'name\': \'Charlie\'}, {\'id\': 3, \'name\': \'Alice\'}]` 2. `sort_dicts_by_key([{\'age\': 25, \'score\': 88}, {\'age\': 30, \'score\': 95}, {\'age\': 22, \'score\': 78}], \'age\')` returns ` [{\'age\': 22, \'score\': 78}, {\'age\': 25, \'score\': 88}, {\'age\': 30, \'score\': 95}]` 3. `sort_dicts_by_key([{\'title\': \'Book A\', \'price\': 20}, {\'title\': \'Book B\', \'price\': 15}, {\'title\': \'Book C\', \'price\': 25}], \'price\')` returns ` [{\'title\': \'Book B\', \'price\': 15}, {\'title\': \'Book A\', \'price\': 20}, {\'title\': \'Book C\', \'price\': 25}]` 4. `sort_dicts_by_key(\\"not a list\\", \'id\')` raises `TypeError: The first argument must be a list of dictionaries` 5. `sort_dicts_by_key([{\'id\': 1, \'name\': \'Alice\'}, \'not a dict\'], \'id\')` raises `TypeError: All elements in the list must be dictionaries` 6. `sort_dicts_by_key([{\'id\': 1, \'name\': \'Alice\'}, {\'id\': 2, \'name\': \'Bob\'}], 3)` raises `TypeError: The sort_key must be a string` 7. `sort_dicts_by_key([{\'id\': 1, \'name\': \'Alice\'}, {\'id\': 2, \'name\': \'Bob\'}], \'surname\')` raises `KeyError: All dictionaries must contain the key \'surname\'` # Constraints - Ensure the function executes efficiently for typical use cases. - Assume the input list contains at least one dictionary and the dictionaries have the specified sort key.","solution":"def sort_dicts_by_key(dicts_list, sort_key): Sorts a list of dictionaries by a specified key. Parameters: dicts_list (list): A list of dictionaries. sort_key (str): The key to sort the dictionaries by. Returns: list: A new list of dictionaries sorted by the specified key. Raises: TypeError: If dicts_list is not a list or any element is not a dictionary, or sort_key is not a string. KeyError: If any dictionary does not contain the sort_key. if not isinstance(dicts_list, list): raise TypeError(\\"The first argument must be a list of dictionaries\\") if not all(isinstance(d, dict) for d in dicts_list): raise TypeError(\\"All elements in the list must be dictionaries\\") if not isinstance(sort_key, str): raise TypeError(\\"The sort_key must be a string\\") for d in dicts_list: if sort_key not in d: raise KeyError(f\\"All dictionaries must contain the key \'{sort_key}\'\\") return sorted(dicts_list, key=lambda x: x[sort_key])"},{"question":"# Coding Assessment Question You are developing an autonomous car software and need to implement a function to calculate the most efficient route between two points in a city represented as a grid. The grid contains roads (0) and buildings (1), and you can only move on roads. The car can move up, down, left, or right, but not diagonally nor through buildings. Your task is to implement a function `find_shortest_path` that takes a 2D list `city_grid`, the starting coordinates `(start_x, start_y)`, and the destination coordinates `(dest_x, dest_y)`. The function should return the minimum number of moves required to get from the starting point to the destination. If it is not possible to reach the destination, return -1. Function Signature ```python def find_shortest_path(city_grid: list[list[int]], start: tuple[int, int], destination: tuple[int, int]) -> int: pass ``` Input Format - `city_grid`: A 2D list of integers where `city_grid[i][j]` is `0` for a road and `1` for a building. - `start`: A tuple `(start_x, start_y)` representing the starting coordinates. - `destination`: A tuple `(dest_x, dest_y)` representing the destination coordinates. Output Format An integer representing the minimum number of moves required to reach the destination from the start, or `-1` if the destination cannot be reached. Constraints - The dimensions of the `city_grid` will be at least 1x1 and at most 100x100. - The starting point `(start_x, start_y)` and the destination `(dest_x, dest_y)` are always guaranteed to be valid indices within the grid. - `city_grid[start_x][start_y] == 0` and `city_grid[dest_x][dest_y] == 0`. Example ```python city_grid = [ [0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0] ] start = (0, 0) destination = (3, 3) print(find_shortest_path(city_grid, start, destination)) # Output: 7 ``` Performance Requirements - Your solution should have a time complexity of O(n^2) where n is the size of the grid. - The space complexity should be O(n^2) to accommodate the grid and auxiliary data structures. Good luck!","solution":"from collections import deque def find_shortest_path(city_grid, start, destination): rows, cols = len(city_grid), len(city_grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if start and destination are the same if start == destination: return 0 queue = deque([(start[0], start[1], 0)]) # (row, col, steps) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and city_grid[nx][ny] == 0: if (nx, ny) == destination: return steps + 1 queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"Scenario: You have been asked to develop a software module for a social media platform that recommends new friends to users based on mutual friends. The goal is to suggest to each user the top N friends they might know. The social network is modeled as an undirected graph where each user is a node and each friendship is an edge between nodes. # Question: Implement an algorithm that, for each user, finds the top N recommended friends based on the number of mutual friends. If two potential friends have the same number of mutual friends, they should be recommended based on their user ID in ascending order. # Function Signature: * **function name**: `recommend_friends` * **inputs**: - `graph` (Dict[int, List[int]]): A dictionary representing the social network, where the keys are user IDs and the values are lists of IDs representing their friends. - `N` (int): The number of top recommended friends to return for each user. * **outputs**: - `recommendations` (Dict[int, List[int]]): A dictionary where each key is a user ID and the corresponding value is a list of recommended friend IDs based on mutual friends. # Constraints: 1. There will be at least 2 users and at most 100 users. 2. Each user will have at most 50 friends. 3. `N` will be a positive integer no greater than the largest number of possible recommendations for any user. # Example: ```python # Example usage: graph = { 1: [2, 3], 2: [1, 3, 4], 3: [1, 2, 5], 4: [2], 5: [3] } N = 2 recommendations = recommend_friends(graph, N) for user in sorted(recommendations.keys()): print(f\\"User {user}: {recommendations[user]}\\") # Expected Output: # User 1: [4, 5] # User 2: [5] # User 3: [4] # User 4: [1, 3] # User 5: [1, 2] ``` # Additional Notes: - Ensure mutual friends are counted accurately without counting self-friends. - Prioritize recommendation lists by descending number of mutual friends and subsequently by ascending user ID when necessary. - Handle edge cases where users have fewer than N recommended friends available gracefully, filling their recommendation list with the maximum available suggestions.","solution":"from collections import defaultdict def recommend_friends(graph, N): recommendations = {} for user in graph: mutuals = defaultdict(int) # Count mutual friends for friend in graph[user]: for mutual in graph[friend]: if mutual != user and mutual not in graph[user]: mutuals[mutual] += 1 # Sort based on number of mutuals and user ID sorted_mutuals = sorted(mutuals.items(), key=lambda x: (-x[1], x[0])) # Select top N recommendations recommendations[user] = [friend for friend, _ in sorted_mutuals[:N]] return recommendations"},{"question":"Matrix Rotation Coding Question Context You have been given the task of rotating an `n x n` matrix in-place by 90 degrees clockwise. This is a common problem in image processing where you might need to rotate an image. Your Task Write a function that takes a square matrix (a list of lists with equal rows and columns) and rotates it by 90 degrees clockwise. Function Signature ```python def rotate_matrix(matrix: list) -> None: # your code here ``` Input - `matrix` (list of lists): An `n x n` list (matrix), where each inner list represents a row. Output - The function should modify the matrix in place. It does not return any value. Constraints - `n` is the number of rows and columns of the matrix and is in the range `[1, 100]`. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] output = [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> rotate_matrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] ``` Edge Cases to Consider - A `1 x 1` matrix, which should remain the same after rotation. - An even number of rows and columns versus an odd number. - A matrix where all elements are the same.","solution":"def rotate_matrix(matrix: list) -> None: Rotates an n x n matrix in place by 90 degrees clockwise. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement Develop a function that identifies and corrects common formatting errors in decimal numbers stored as strings. Decimal number strings may have errant commas, spaces, and non-numeric characters (other than a single dot to denote the decimal point). Your function should: 1. Strip any leading and trailing whitespace. 2. Remove any non-numeric characters except for a single decimal point. If there are multiple decimal points, only the first one should be retained. 3. Ensure that there are no commas separating the digits. 4. Retain the sign of the number if it is negative. # Function Signature ```python def correct_decimal_format(decimal_str: str) -> float: Corrects the decimal format of a given string and returns the value as a float. :param decimal_str: Input decimal number as a string with potential errors :return: Corrected decimal number as a float ``` # Input * `decimal_str` (string): A string that represents a decimal number with potential formatting errors. # Output * A float value that is the corrected decimal number. # Examples ```python >>> correct_decimal_format(\\" 34,500.28 \\") 34500.28 >>> correct_decimal_format(\\"123.4.56\\") 123.456 >>> correct_decimal_format(\\"+65,200.01\\") 65200.01 >>> correct_decimal_format(\\"-10,000.78\\") -10000.78 >>> correct_decimal_format(\\"4506asd7.89sa87\\") 45067.8987 ``` # Constraints - The input decimal string will be a non-empty string. - You may assume the decimal string will represent a valid number once non-numeric characters (except for the decimal point) are removed. - Ensure the solution is efficient with respect to time and space complexity. # Additional Notes - Ensure that the solution handles various edge cases such as multiple decimal points and errant characters. - Pay attention to details like retaining the negative sign and correctly parsing the decimal part of the number.","solution":"def correct_decimal_format(decimal_str: str) -> float: Corrects the decimal format of a given string and returns the value as a float. :param decimal_str: Input decimal number as a string with potential errors :return: Corrected decimal number as a float # Strip leading and trailing whitespace decimal_str = decimal_str.strip() # Initiate a corrected string container corrected_str = \\"\\" # Track if we have encountered a decimal point yet decimal_point_encountered = False # Loop over each character in the input string for char in decimal_str: # If the character is a digit, add it to the corrected string if char.isdigit(): corrected_str += char # If the character is a dot (.) and we haven\'t encountered one yet elif char == \'.\' and not decimal_point_encountered: corrected_str += char decimal_point_encountered = True # If the character is a minus sign and it\'s the first character elif char == \'-\' and len(corrected_str) == 0: corrected_str += char # Convert the corrected string to a float and return return float(corrected_str)"},{"question":"# Problem Statement Alice and Bob are playing a game of summing sequences. In this game, Alice selects a sequence of integers from `1` to `n`, inclusive. Bob’s task is to compute the exact sum of all unique subsequences (including the empty sequence) formed by the integers in Alice\'s sequence. A subsequence is defined as any sequence derived by deleting some or no elements without changing the order of the remaining elements. For example, if Alice selects the sequence `[1, 2]`, the unique subsequences are as follows: - `[]` (empty sequence) - `[1]` - `[2]` - `[1, 2]` The sum of their sums is `0 (for []) + 1 (for [1]) + 2 (for [2]) + 3 (for [1, 2]) = 6`. Your task is to help Bob by writing a program that returns the sum of sums of all unique subsequences for a given `n`. # Function Signature ```python def sum_of_subsequences(n: int) -> int: Returns the sum of the sums of all unique subsequences for a sequence from 1 to n. ``` # Input and Output - **Input**: An integer `n` (1 ≤ n ≤ 20) - **Output**: An integer representing the sum of the sums of all unique subsequences. # Constraints - The given number `n` will be between 1 and 20 inclusive. # Examples 1. If the input is `n = 2`, the expected output is `6`. 2. If the input is `n = 3`, the expected output is `24`. # Performance Requirements - The function should efficiently compute the result, considering the exponential growth of the number of subsequences with increasing `n`. # Explanation - For `n = 2`: - Subsequences: `[]`, `[1]`, `[2]`, `[1, 2]` - Sum of sums: `0 + 1 + 2 + 3 = 6` - For `n = 3`: - Subsequences: `[]`, `[1]`, `[2]`, `[3]`, `[1, 2]`, `[1, 3]`, `[2, 3]`, `[1, 2, 3]` - Sum of sums: `0 + 1 + 2 + 3 + 3 + 4 + 5 + 6 = 24` Your task is to implement the function `sum_of_subsequences` to compute this sum.","solution":"def sum_of_subsequences(n: int) -> int: Returns the sum of the sums of all unique subsequences for a sequence from 1 to n. return (1 << (n-1)) * n * (n + 1) // 2"},{"question":"Problem Statement You are required to design a system to manage a university\'s course registration process. Your implementation should include the ability to add new courses, register students for courses, and retrieve a list of all students enrolled in a particular course. Each course has a unique course code, and each student has a unique student ID. # Function Signatures ```python class University: def __init__(self): pass def add_course(self, course_code: str) -> None: pass def register_student(self, student_id: str, course_code: str) -> None: pass def get_students(self, course_code: str) -> list: pass ``` # Method Descriptions 1. `add_course(course_code: str) -> None`: Adds a course with the provided course code to the university\'s list of courses. 2. `register_student(student_id: str, course_code: str) -> None`: Registers a student with the provided student ID to the course defined by the course code. 3. `get_students(course_code: str) -> list`: Returns a list of student IDs of students registered in the course identified by course code. The list should be in ascending order. # Input - `course_code` (string): The unique code identifying the course. - `student_id` (string): The unique ID identifying the student. # Output - `add_course`: Does not return any value. - `register_student`: Does not return any value. - `get_students`: Returns a list of strings representing student IDs. # Constraints 1. Each course code is unique. 2. Each student can be registered for multiple courses. 3. If a student attempts to register for a course that does not exist, an exception should be raised. 4. If an attempt is made to retrieve a list of students for a course that does not exist, an exception should be raised. 5. Student IDs and course codes will be alphanumeric. # Example Usage ```python # Example 1 university = University() university.add_course(\\"CS101\\") university.add_course(\\"MATH123\\") university.register_student(\\"S001\\", \\"CS101\\") university.register_student(\\"S002\\", \\"CS101\\") university.register_student(\\"S003\\", \\"MATH123\\") print(university.get_students(\\"CS101\\")) # Output: [\\"S001\\", \\"S002\\"] print(university.get_students(\\"MATH123\\")) # Output: [\\"S003\\"] ``` # Note - You may assume that all inputs are valid except as specified in the constraints. - Raise appropriate exceptions for invalid operations.","solution":"class CourseNotFoundException(Exception): pass class University: def __init__(self): self.courses = {} def add_course(self, course_code: str) -> None: if course_code not in self.courses: self.courses[course_code] = set() def register_student(self, student_id: str, course_code: str) -> None: if course_code not in self.courses: raise CourseNotFoundException(f\\"Course code {course_code} does not exist\\") self.courses[course_code].add(student_id) def get_students(self, course_code: str) -> list: if course_code not in self.courses: raise CourseNotFoundException(f\\"Course code {course_code} does not exist\\") return sorted(self.courses[course_code])"},{"question":"# Coding Assessment Question: Encode and Decode String Context You are developing a text-processing application that needs to compress and decompress strings efficiently. To achieve this, you want to implement a simple encoding scheme where the string is encoded into a sequence of tuples containing each character and the number of consecutive occurrences of that character. Your task is to create functions to encode and decode strings using this scheme. Task Write two functions: 1. A function `encode_string(s: str) -> list[tuple[str, int]]` that takes a string and returns a list of tuples where each tuple contains a character and the number of its consecutive appearances in the string. 2. A function `decode_string(encoded: list[tuple[str, int]]) -> str` that takes a list of tuples and returns the original string. Specifications * `encode_string(s: str) -> list[tuple[str, int]]` * **Input**: * `s`: A string containing lowercase or uppercase letters. * **Output**: * A list of tuples `(char, count)`, where `char` is a character in the string and `count` is the number of consecutive appearances of that character. * `decode_string(encoded: list[tuple[str, int]]) -> str` * **Input**: * `encoded`: A list of tuples `(char, count)`. * **Output**: * The original string represented by the list of tuples. Constraints * The input string and encoded list will not be empty. * Each character in the output should be repeated exactly as specified by the count in the tuple. Examples * Example 1: ```python input_string = \\"aaabbbccaa\\" encoded = encode_string(input_string) assert encoded == [(\\"a\\", 3), (\\"b\\", 3), (\\"c\\", 2), (\\"a\\", 2)] decoded = decode_string(encoded) assert decoded == \\"aaabbbccaa\\" ``` * Example 2: ```python input_string = \\"abcd\\" encoded = encode_string(input_string) assert encoded == [(\\"a\\", 1), (\\"b\\", 1), (\\"c\\", 1), (\\"d\\", 1)] decoded = decode_string(encoded) assert decoded == \\"abcd\\" ``` Notes * Ensure that your encoding and decoding functions can handle strings with varying character sequences, including cases with no repeating characters. * Think about edge cases such as strings with a single character or strings with all identical characters.","solution":"def encode_string(s): Encode the string s to a list of tuples containing each character and the number of its consecutive appearances. if not s: return [] result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append((current_char, count)) current_char = char count = 1 result.append((current_char, count)) return result def decode_string(encoded): Decode a list of tuples to the original string. result = [] for char, count in encoded: result.append(char * count) return \'\'.join(result)"},{"question":"# Problem Statement # Balanced Bracket Sequences Given an integer `n`, write a function `generate_balanced_bracket_sequences(n: int) -> List[str]` that generates all possible balanced sequences of `n` pairs of parentheses. # Input * `n` - An integer (1 ≤ n ≤ 10) # Output A list of strings, each string representing a unique balanced sequence of `n` pairs of parentheses. # Constraints * The order of the output sequences does not matter. * Ensure the solution is efficient, taking into account the constraints provided. # Example ```python def test_generate_balanced_bracket_sequences(): assert set(generate_balanced_bracket_sequences(1)) == {\\"()\\"} assert set(generate_balanced_bracket_sequences(2)) == {\\"(())\\", \\"()()\\"} assert set(generate_balanced_bracket_sequences(3)) == {\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"} assert set(generate_balanced_bracket_sequences(0)) == {\\"\\"} print(\\"All test cases pass\\") test_generate_balanced_bracket_sequences() ``` # Note You can test your implementation with the provided examples to ensure correctness.","solution":"from typing import List def generate_balanced_bracket_sequences(n: int) -> List[str]: Generate all combinations of n pairs of balanced parentheses. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) result = [] backtrack() return result"},{"question":"# Problem Statement You are responsible for building a function `track_order_status` for an eCommerce platform. This function will help track the status of an order based on the provided updates. # Input - **order_id**: A string representing the unique identifier of the order. - **status_logs**: A list of tuples, each containing a timestamp (string in \\"YYYY-MM-DD HH:MM:SS\\" format) and a status (string). The status can be one of the following: \\"Ordered\\", \\"Packed\\", \\"Shipped\\", \\"Delivered\\", or \\"Cancelled\\". # Output - A string representing the final status of the order. # Constraints - If the order is \\"Cancelled\\" at any point, subsequent statuses are ignored, and the function should return \\"Cancelled\\". - If there is no \\"Delivered\\" status and no \\"Cancelled\\" status, the function should return the latest status in the list. - The timestamps in `status_logs` are in ascending order. - The status_logs list will contain at least one status update. # Examples ```python >>> status_logs = [ ... (\\"2023-01-01 10:00:00\\", \\"Ordered\\"), ... (\\"2023-01-02 12:00:00\\", \\"Packed\\"), ... (\\"2023-01-03 08:00:00\\", \\"Shipped\\"), ... (\\"2023-01-04 15:00:00\\", \\"Delivered\\") ... ] >>> track_order_status(\\"ORD12345\\", status_logs) \\"Delivered\\" >>> status_logs = [ ... (\\"2023-01-01 10:00:00\\", \\"Ordered\\"), ... (\\"2023-01-02 12:00:00\\", \\"Packed\\"), ... (\\"2023-01-03 08:00:00\\", \\"Cancelled\\"), ... (\\"2023-01-04 15:00:00\\", \\"Shipped\\") ... ] >>> track_order_status(\\"ORD12345\\", status_logs) \\"Cancelled\\" >>> status_logs = [ ... (\\"2023-01-01 10:00:00\\", \\"Ordered\\"), ... (\\"2023-01-02 12:00:00\\", \\"Packed\\"), ... (\\"2023-01-03 08:00:00\\", \\"Shipped\\") ... ] >>> track_order_status(\\"ORD12345\\", status_logs) \\"Shipped\\" ``` # Function Signature ```python def track_order_status(order_id: str, status_logs: list[tuple[str, str]]) -> str: pass ``` # Context You are a developer at an eCommerce company tasked with improving the order tracking system. This function will help customers and support agents quickly ascertain the current status of any order based on its history, thereby improving transparency and customer satisfaction.","solution":"def track_order_status(order_id: str, status_logs: list[tuple[str, str]]) -> str: Returns the final status of an order based on the provided status logs. final_status = \\"\\" for timestamp, status in status_logs: if status == \\"Cancelled\\": return \\"Cancelled\\" # If status is Cancelled, subsequent statuses are ignored final_status = status return final_status"},{"question":"# Cities Connection Checker Problem Description Write a function `can_travel(matrix: List[List[int]], start: int, end: int) -> bool` that determines if there is a path from the `start` city to the `end` city. You are given an `n x n` adjacency matrix representing a network of cities, where `matrix[i][j]` is 1 if there\'s a direct road from city `i` to city `j`, and 0 otherwise. Multiple roads between two cities are possible but represented only once in the matrix. The traversal between cities is bidirectional. Input - A 2D list of integers `matrix` representing an adjacency matrix where `matrix[i][j] = 1` means a road exists between city `i` and city `j`, and `matrix[i][j] = 0` otherwise. - (1 leq n leq 1000) - `matrix[i][i]` is always 0 for all cities (i). - Two integers `start` and `end` representing the indices of the start and end cities. - (0 leq start, end < n) Output - A boolean indicating whether there is a path from the `start` city to the `end` city. Example ```python matrix1 = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 0], ] assert can_travel(matrix1, 0, 3) == True assert can_travel(matrix1, 0, 2) == True assert can_travel(matrix1, 2, 3) == True assert can_travel(matrix1, 0, 0) == True matrix2 = [ [0, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], ] assert can_travel(matrix2, 0, 3) == False assert can_travel(matrix2, 2, 4) == True assert can_travel(matrix2, 1, 4) == False assert can_travel(matrix2, 3, 2) == True ``` Constraints - The function should handle both direct and indirect connections efficiently. - Consider optimizations for large matrices. - Ensure to handle cases where `start` and `end` are the same, which should trivially return True.","solution":"from collections import deque from typing import List def can_travel(matrix: List[List[int]], start: int, end: int) -> bool: Determines if there is a path from the start city to the end city. if start == end: return True n = len(matrix) visited = [False] * n queue = deque([start]) visited[start] = True while queue: city = queue.popleft() for neighbor in range(n): if matrix[city][neighbor] == 1 and not visited[neighbor]: if neighbor == end: return True queue.append(neighbor) visited[neighbor] = True return False"},{"question":"# Anomaly Detection Using k-Nearest Neighbors Algorithm In this task, you need to implement an Anomaly Detector using the k-Nearest Neighbors (k-NN) algorithm based on the provided incomplete class and function definitions. Task 1. **Complete the `fit` method**: This method should receive a set of observations (data points) and store them in a way that they can be referred to during prediction. 2. **Complete the `predict` method**: This method takes a new observation and determines whether it is an anomaly or not based on the distance to its k nearest neighbors. 3. **Calculate a threshold** for identifying anomalies: During the `fit` method, calculate the average distance to the k nearest neighbors for each point and use it to determine a threshold. Observations with an average distance above this threshold will be considered anomalies. 4. **Enhance Error Handling**: Ensure the `fit` and `predict` methods handle misuse scenarios and unexpected input robustly. # Input and Output Input * `fit` method: - `observations`: List of numpy arrays representing observations. - `k`: Integer representing the number of nearest neighbors to consider. * `predict` method: - `observation`: NumPy array representing a single observation. Output * `fit` method: None. This method stores necessary data and computes the threshold for anomaly detection. * `predict` method: Boolean indicating whether the observation is an anomaly (True) or not (False). # Constraints 1. Ensure the `fit` method computes the average distance to the k nearest neighbors for each point accurately. 2. The `predict` method should handle predictions efficiently for up to 1000 observations. 3. Use Euclidean distance for measuring the distances between points. 4. Ensure robust error checking and handling in the methods. # Example Here\'s an example usage of the completed class and methods: ```python import numpy as np class KNNAnomalyDetector: def __init__(self): self.observations = None self.k = None self.threshold = None def fit(self, observations: list, k: int): Fit the model using the provided observations and k value. Args: observations (list): List of NumPy arrays representing observations. k (int): Number of nearest neighbors to consider. self.observations = observations self.k = k # Ensure enough observations are provided. if len(observations) < k: raise ValueError(\\"Number of observations must be greater than or equal to k.\\") average_distances = [] for i in range(len(observations)): distances = [] for j in range(len(observations)): if i != j: distance = np.linalg.norm(observations[i] - observations[j]) distances.append(distance) distances.sort() average_distance = np.mean(distances[:k]) average_distances.append(average_distance) self.threshold = np.mean(average_distances) def predict(self, observation: np.ndarray) -> bool: Predict if the provided observation is an anomaly. Args: observation (np.ndarray): The observation to test. Returns: bool: True if the observation is an anomaly, False otherwise. distances = [np.linalg.norm(observation - obs) for obs in self.observations] distances.sort() average_distance = np.mean(distances[:self.k]) return average_distance > self.threshold # Sample data for testing observations = [np.array([1, 2]), np.array([2, 3]), np.array([3, 4]), np.array([4, 5])] k = 2 # KNN Anomaly Detector initialization and training anomaly_detector = KNNAnomalyDetector() anomaly_detector.fit(observations, k) # Predicting new observation is_anomaly = anomaly_detector.predict(np.array([10, 10])) print(is_anomaly) # Expected output: True ``` Ensure your `KNNAnomalyDetector` class is robust, thoroughly tested, and capable of efficiently handling the prescribed scenario.","solution":"import numpy as np class KNNAnomalyDetector: def __init__(self): self.observations = None self.k = None self.threshold = None def fit(self, observations: list, k: int): Fit the model using the provided observations and k value. Args: observations (list): List of NumPy arrays representing observations. k (int): Number of nearest neighbors to consider. self.observations = observations self.k = k # Validate inputs if not isinstance(observations, list) or any(not isinstance(obs, np.ndarray) for obs in observations): raise ValueError(\\"Observations must be a list of NumPy arrays.\\") if not isinstance(k, int) or k <= 0: raise ValueError(\\"k must be a positive integer.\\") if len(observations) < k: raise ValueError(\\"Number of observations must be greater than or equal to k.\\") average_distances = [] for i in range(len(observations)): distances = [] for j in range(len(observations)): if i != j: distance = np.linalg.norm(observations[i] - observations[j]) distances.append(distance) distances.sort() average_distance = np.mean(distances[:k]) average_distances.append(average_distance) self.threshold = np.mean(average_distances) def predict(self, observation: np.ndarray) -> bool: Predict if the provided observation is an anomaly. Args: observation (np.ndarray): The observation to test. Returns: bool: True if the observation is an anomaly, False otherwise. if self.observations is None or self.k is None or self.threshold is None: raise ValueError(\\"The model has not been fit yet.\\") if not isinstance(observation, np.ndarray): raise ValueError(\\"Observation must be a NumPy array.\\") distances = [np.linalg.norm(observation - obs) for obs in self.observations] distances.sort() average_distance = np.mean(distances[:self.k]) return average_distance > self.threshold"},{"question":"# Context: As a member of a game development team, you have been assigned to work on the logic for a dynamic scoring system. This scoring system needs to evaluate players\' performances by applying a series of score adjustments specified in a configuration file. # Problem Statement: Write a Python function `calculate_final_scores(raw_scores: list, score_config: dict) -> list` that calculates the final scores for a list of players based on given configurations. * Each element in `raw_scores` is a tuple consisting of a player\'s name and their initial score. * Each key in `score_config` corresponds to an adjustment rule (e.g., \\"bonus\\" or \\"penalty\\") and maps to a list of tuples. - Each tuple in the configuration contains a player\'s name and the value to be added (positive) or subtracted (negative) from their score. For each player: - Start with their initial score from `raw_scores`. - Apply any adjustments from `score_config`. # Inputs: - `raw_scores (list)`: List of tuples containing player names and their initial scores. - `score_config (dict)`: Dictionary where keys are adjustment types and values are lists of tuples specifying player names and adjustment amounts. # Outputs: - A list of tuples containing each player\'s name and their final score after all adjustments. # Constraints: - Each player name in `raw_scores` will be unique. - Player names in `score_config` are guaranteed to exist in `raw_scores`. - The length of `raw_scores` will not exceed 100. - The number of adjustments in `score_config` will not exceed 100 per adjustment type. # Example: ```python def calculate_final_scores(raw_scores: list, score_config: dict) -> list: pass # An example of the function in use: raw_scores = [(\\"Alice\\", 100), (\\"Bob\\", 50), (\\"Charlie\\", 75)] score_config = { \\"bonus\\": [(\\"Alice\\", 10), (\\"Bob\\", 5)], \\"penalty\\": [(\\"Charlie\\", -20)], } print(calculate_final_scores(raw_scores, score_config)) # Output: [(\\"Alice\\", 110), (\\"Bob\\", 55), (\\"Charlie\\", 55)] ``` # Notes: - Ensure that all adjustments are applied in the order they appear in the configuration. - Handle potential edge cases such as missing adjustments for some players or conflicting adjustments.","solution":"def calculate_final_scores(raw_scores, score_config): Computes the final scores for a list of players based on given configurations. Parameters: raw_scores (list): List of tuples containing player names and their initial scores. score_config (dict): Dictionary where keys are adjustment types and values are lists of tuples specifying player names and adjustment amounts. Returns: list: A list of tuples containing each player\'s name and their final score after all adjustments. # Convert the raw_scores list to a dictionary for easier score manipulation scores = {player: score for player, score in raw_scores} # Iterate through the config to adjust the scores for adjustment_type, adjustments in score_config.items(): for player, adjustment in adjustments: scores[player] += adjustment # Convert the scores dictionary back to a list of tuples final_scores = [(player, score) for player, score in scores.items()] return final_scores"},{"question":"# Question: A company\'s security system logs unsuccessful login attempts with timestamps. The logs are stored as a list of strings, where each string represents a timestamp in the format `yyyy-mm-ddThh:mm:ss`. You need to find the timestamp of the first failed attempt and the timestamp of the last failed attempt. Assume the log entries are sorted in ascending order by timestamp. # Objective: Implement the function `find_login_attempts(logs: List[str]) -> Tuple[str, str]` that takes a list of timestamps and returns a tuple containing the first and last timestamps from the list. # Function Signature: ```python def find_login_attempts(logs: List[str]) -> Tuple[str, str]: ``` # Input: - `logs`: A list of strings representing the timestamps of failed login attempts. (1 <= len(logs) <= 1000) # Output: - A tuple containing two strings: the first and the last timestamps from the list. # Example: ```python logs = [ \'2023-01-01T00:00:01\', \'2023-01-01T01:00:00\', \'2023-01-01T02:00:01\', \'2023-01-01T03:00:05\', \'2023-01-01T04:00:10\' ] output = find_login_attempts(logs) # Expected output: # (\'2023-01-01T00:00:01\', \'2023-01-01T04:00:10\') ``` # Constraints: - The input list `logs` will have at least one timestamp. - Each timestamp is in the format `yyyy-mm-ddThh:mm:ss`. - The timestamps are sorted in ascending order.","solution":"from typing import List, Tuple def find_login_attempts(logs: List[str]) -> Tuple[str, str]: Returns the timestamp of the first and the last failed login attempts from the provided list of logs. Args: logs (List[str]): List of timestamps sorted in ascending order. Returns: Tuple[str, str]: The first and the last timestamps from the list. if not logs: raise ValueError(\\"The logs list should not be empty\\") return (logs[0], logs[-1])"},{"question":"# Unicorn Horn Potion Brewing Context: In a magical realm, unicorn horn potions are created by combining various ingredients according to specific recipes. Each recipe requires certain ingredients in particular proportions. A potion is successful only if all ingredients are present and in the required amounts. Task: Write a function `brew_potion` to determine if a potion can be successfully brewed given the available ingredients and their quantities. Function Signature: ```python def brew_potion(recipe: dict, ingredients: dict) -> bool: ``` Input: * `recipe (dict)`: A dictionary where keys are ingredient names and values are the required quantities for the potion. * `ingredients (dict)`: A dictionary where keys are ingredient names and values are the available quantities. Output: * Returns `True` if the potion can be brewed with the available ingredients, `False` otherwise. Constraints: * All quantities are positive integers. * Both dictionaries will have non-empty strings as keys and positive integers as values. Examples: ```python >>> brew_potion({\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}) True >>> brew_potion({\\"unicorn_horn\\": 4, \\"fairy_dust\\": 5}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}) False >>> brew_potion({\\"unicorn_horn\\": 2, \\"fairy_dust\\": 3, \\"phoenix_feather\\": 1}, {\\"unicorn_horn\\": 2, \\"fairy_dust\\": 3, \\"phoenix_feather\\": 1}) True >>> brew_potion({\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"troll_eye\\": 2}, {\\"unicorn_horn\\": 3, \\"fairy_dust\\": 5, \\"phoenix_feather\\": 1}) False >>> brew_potion({\\"unicorn_horn\\": 1}, {\\"unicorn_horn\\": 1}) True ``` Notes: * The function should inspect the availability of each required ingredient and verify its quantity. * Ingredients not listed in the recipe but present in the `ingredients` dictionary should be ignored. * If any of the required ingredients is missing or insufficient, the function should return `False`.","solution":"def brew_potion(recipe, ingredients): Determines if a potion can be successfully brewed given the available ingredients and their quantities. :param recipe: Dictionary where keys are ingredient names and values are the required quantities. :param ingredients: Dictionary where keys are ingredient names and values are the available quantities. :return: True if the potion can be brewed with the available ingredients, False otherwise. for ingredient, required_quantity in recipe.items(): if ingredient not in ingredients or ingredients[ingredient] < required_quantity: return False return True"},{"question":"Problem Statement You are required to implement a function that determines if a given string can be transformed into another string using a set of transformation rules. Each rule allows replacing a specific character in the input string with another specific character. # Function Signature ```python def can_transform(start_string: str, end_string: str, transformations: list[(str, str)]) -> bool: ``` # Input * `start_string` (str): The initial string (1 ≤ len(start_string) ≤ 100). * `end_string` (str): The desired resulting string (1 ≤ len(end_string) ≤ 100). * `transformations` (list of tuples): A list of tuples where each tuple `(\'a\', \'b\')` means character \'a\' can be transformed into character \'b\' (1 ≤ len(transformations) ≤ 1000). # Output * Returns `True` if `start_string` can be transformed into `end_string` using the given rules, otherwise `False`. # Example ```python can_transform(\\"abc\\", \\"bbc\\", [(\'a\', \'b\'), (\'b\', \'c\')]) # Returns: True can_transform(\\"abc\\", \\"def\\", [(\'a\', \'d\'), (\'b\', \'e\'), (\'c\', \'f\')]) # Returns: True can_transform(\\"abc\\", \\"def\\", [(\'a\', \'z\'), (\'b\', \'y\'), (\'c\', \'x\')]) # Returns: False ``` # Detailed Description Write the function `can_transform` which will determine if you can convert `start_string` to `end_string` by applying the given character transformations in any order. Each transformation rule applies only once for each character in `start_string`. # Hints * Consider using a breadth-first search (BFS) or depth-first search (DFS) approach to explore all possible transformations. * Use a set to keep track of visited transformations to avoid cycles or redundant work. # Constraints * Both `start_string` and `end_string` are of the same length. * Transformation rules may contain characters that do not appear in the `start_string`. # Edge Cases * Transformations may include rules that are not directly useful for the transformation (such as rules that transform characters not present in the string). * Check if transformations allow a character to transform into itself, which means no action is needed for that particular character.","solution":"def can_transform(start_string: str, end_string: str, transformations: list) -> bool: Determines if start_string can be transformed into end_string using a given set of transformations. Args: - start_string (str): The initial string. - end_string (str): The desired resulting string. - transformations (list of tuples): Each tuple contains two characters, the first can be transformed into the second. Returns: - bool: True if the transformation is possible, otherwise False. if len(start_string) != len(end_string): return False from collections import deque, defaultdict # Create a graph representation for the transformations transform_map = defaultdict(set) for src, dest in transformations: transform_map[src].add(dest) # Use a queue for BFS queue = deque([(start_string, 0)]) visited = set([start_string]) while queue: current_string, index = queue.popleft() if current_string == end_string: return True if index < len(current_string): next_char = end_string[index] current_char = current_string[index] if current_char != next_char and next_char in transform_map[current_char]: new_string = current_string[:index] + next_char + current_string[index+1:] if new_string not in visited: visited.add(new_string) queue.append((new_string, index + 1)) else: # Increment the index to move to the next character queue.append((current_string, index + 1)) return False"},{"question":"**Graph Coloring Problem** Your task is to solve the Graph Coloring problem using a backtracking algorithm. The goal is to assign colors to the vertices of a graph such that no two adjacent vertices share the same color, using at most M colors. # Requirements - Implement a function `graph_coloring(graph: List[List[int]], m: int) -> Optional[List[int]]` that returns a valid coloring configuration of the vertices. If no valid coloring exists, return `None`. - `graph` is represented as an adjacency matrix, where `graph[i][j]` is `1` if there is an edge between vertices `i` and `j`, and `0` otherwise. - Ensure the function handles edge cases gracefully and returns an optimal solution if one exists. # Inputs - List of lists `graph`: representing the adjacency matrix of the graph (1 ≤ len(graph) ≤ 10). - Integer `m`: Maximum number of colors that can be used. # Outputs - A list of integers where the i-th element represents the color assigned to the i-th vertex (0 indexed), or `None` if no such coloring is possible. # Constraints - Colors are represented by integers starting from 0 up to `m-1`. - The algorithm should avoid unnecessary computations and terminate early if it determines that no valid coloring is possible. # Example ```python def graph_coloring(graph: List[List[int]], m: int) -> Optional[List[int]]: # Your code here # Example usage: graph = [ [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 0] ] m = 3 solution = graph_coloring(graph, m) print(solution) # Example output: # [0, 1, 2, 1] ``` **Prompt** Using the described algorithm and principles above: 1. Implement the `graph_coloring` function. 2. Optimize the function for good performance practices. 3. Provide meaningful comments and documentation within the code.","solution":"from typing import List, Optional def graph_coloring(graph: List[List[int]], m: int) -> Optional[List[int]]: n = len(graph) colors = [-1] * n def is_safe_to_color(node, color): for neighbor in range(n): if graph[node][neighbor] == 1 and colors[neighbor] == color: return False return True def solve(node): if node == n: return True for color in range(m): if is_safe_to_color(node, color): colors[node] = color if solve(node + 1): return True colors[node] = -1 return False if solve(0): return colors return None"},{"question":"# Context String manipulation and pattern recognition are vital skills in computer science, with applications ranging from text processing to data analysis. Efficiently identifying patterns within strings and manipulating them are core competencies in various domains, including software development, machine learning, and natural language processing. # Problem Statement You are required to extend the provided `StringManipulator` class with the following capabilities: 1. **Longest Palindromic Substring**: Implement a method `longest_palindromic_substring` to identify the longest palindromic substring within a given string. 2. **Anagram Groups**: Implement a method `group_anagrams` to group a list of strings into anagrams. # Function Specifications: Longest Palindromic Substring: **Input**: - No input parameters, but use a class attribute `self.string`. **Output**: - Returns the longest palindromic substring as a string. # Group Anagrams: **Input**: - A list of strings as a parameter. **Output**: - Returns a list of lists where each sublist contains strings that are anagrams of each other. # Example: ```python s = StringManipulator(\\"babad\\") # Should print the longest palindromic substring \\"bab\\" or \\"aba\\" print(s.longest_palindromic_substring()) # Output: \\"bab\\" or \\"aba\\" words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] sm = StringManipulator(\\"\\") # Should print grouped anagrams print(sm.group_anagrams(words)) # Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] ``` # Constraints: - For `longest_palindromic_substring`, the string length will be at most 1000. - For `group_anagrams`, the list length will be at most 10,000, and each string\'s length will be at most 100. # Additional Notes: - Ensure that the `longest_palindromic_substring` method is optimized for performance. - The `group_anagrams` method should handle case sensitivities and special characters. - Include edge cases in your implementation such as empty strings and single-character strings. # Class Definition: ```python class StringManipulator: def __init__(self, string): self.string = string def longest_palindromic_substring(self): # Implement the logic to find the longest palindromic substring pass def group_anagrams(self, words): # Implement the logic to group anagrams pass ```","solution":"class StringManipulator: def __init__(self, string): self.string = string def longest_palindromic_substring(self): n = len(self.string) if n == 0: return \\"\\" # Table to store the palindromic substring status dp = [[False] * n for _ in range(n)] longest_palindrome_start = 0 max_length = 1 # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for a two-character palindrome for i in range(n - 1): if self.string[i] == self.string[i + 1]: dp[i][i + 1] = True longest_palindrome_start = i max_length = 2 # Dynamic programming table processing for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if self.string[i] == self.string[j] and dp[i + 1][j - 1]: dp[i][j] = True longest_palindrome_start = i max_length = length return self.string[longest_palindrome_start:longest_palindrome_start + max_length] def group_anagrams(self, words): from collections import defaultdict anagrams = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) # Examples s = StringManipulator(\\"babad\\") print(s.longest_palindromic_substring()) # Output: \\"bab\\" or \\"aba\\" words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] sm = StringManipulator(\\"\\") print(sm.group_anagrams(words)) # Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]]"},{"question":"# Problem Description You are required to implement a function to evaluate simple mathematical expressions given as strings. The expressions will consist of non-negative integers and the basic arithmetic operators: addition (+), subtraction (-), multiplication (*), and division (/). Integer division should truncate towards zero. # Function Specification Implement a function `evaluate_expression` that parses and evaluates a given string expression: Input - A string `expression` consisting of non-negative integers and the operators \'+\', \'-\', \'*\', \'/\'. Output - An integer representing the evaluated result of the expression. # Constraints - The input string will only contain valid characters: digits (0-9), \'+\', \'-\', \'*\', \'/\', and spaces. - The length of the input string will not exceed 1000 characters. - Division by zero will not occur. - The string will represent a valid arithmetic expression. # Example Usage ```python >>> evaluate_expression(\'3+5/2\') 5 >>> evaluate_expression(\'2*3-4/2\') 4 >>> evaluate_expression(\'100 + 4 - 50 / 2\') 77 >>> evaluate_expression(\'45 * 3 / 9 + 2 - 5\') 12 ``` # Requirements - Implement the function with efficient parsing and evaluation. - Ensure that the function handles spaces appropriately and has O(n) complexity. - The arithmetic operations should respect the precedence rules (multiplication and division before addition and subtraction). - Consider edge cases such as empty strings, and single operand inputs.","solution":"def evaluate_expression(expression): Evaluates a simple mathematical expression given as a string. The expression contains non-negative integers and the operators: +, -, *, and /. def operate(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': return int(first / second) # Integer division tokens = [] num = 0 prev_op = \'+\' i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if prev_op == \'+\': tokens.append(num) elif prev_op == \'-\': tokens.append(-num) elif prev_op in \'*/\': prev_num = tokens.pop() tokens.append(operate(prev_op, num, prev_num)) prev_op = char num = 0 i += 1 # Sum up all tokens return sum(tokens)"},{"question":"# Problem Statement You are given an input list of integers where each element is in the range from 1 to n (inclusive) and each number appears exactly once except one number which appears twice. Your task is to write a function `find_duplicate_number` that finds and returns the duplicate number. # Function Signature ```python def find_duplicate_number(numbers: List[int]) -> int: pass ``` # Input - `numbers`: A list of integers `numbers` where (1 <= len(numbers) <= 10^5). # Output - An integer representing the duplicate number in the list. # Examples ```python assert find_duplicate_number([1, 3, 4, 2, 2]) == 2 assert find_duplicate_number([3, 1, 3, 4, 2]) == 3 assert find_duplicate_number([1, 1]) == 1 assert find_duplicate_number([1, 2, 3, 4, 5, 6, 6, 7]) == 6 ``` # Constraints - Ensure your solution handles large inputs efficiently. - Each number in the list except one will appear exactly once, and one number will appear exactly twice. - You cannot modify the input list. # Notes - Think about different approaches to solve this problem, such as using extra space (hash table) or without using extra space. - The solution should be optimized for both time and space complexity. - Avoid using external libraries to demonstrate fundamental understanding of algorithm design.","solution":"from typing import List def find_duplicate_number(numbers: List[int]) -> int: Finds and returns the duplicate number in the list of integers. # Using Floyd\'s Tortoise and Hare (Cycle Detection) algorithm slow = numbers[0] fast = numbers[0] # Phase 1: Finding the intersection point in the cycle while True: slow = numbers[slow] fast = numbers[numbers[fast]] if slow == fast: break # Phase 2: Finding the entrance of the cycle (duplicate element) slow = numbers[0] while slow != fast: slow = numbers[slow] fast = numbers[fast] return slow"},{"question":"# Scenario You are tasked with creating a tool to generate reports of word frequencies from a list of sentences. Given a list of sentences, implement a function that counts the occurrence of each word and returns the words sorted by their frequencies in descending order. Words with the same frequency should be sorted alphabetically. # Requirements 1. Implement a function `word_frequencies` that takes in a single argument: - `sentences: List[str]` - List of sentences (strings). 2. The function should count the frequency of each word across all sentences and then return a list of tuples, each containing a word and its corresponding frequency, sorted primarily by frequency in descending order and secondarily by word alphabetically in ascending order. # Input - `sentences: List[str]` - List of sentences. # Output - `List[Tuple[str, int]]` - List of tuples where each tuple contains a word and its frequency, sorted primarily by frequency in descending order and secondarily by words in ascending order in case of ties. # Constraints - `0 <= len(sentences) <= 1000` - Each sentence contains only alphabetical characters and spaces. - Words are case-insensitive (e.g. \\"Word\\" and \\"word\\" should be considered the same). # Function Signature ```python def word_frequencies(sentences: List[str]) -> List[Tuple[str, int]]: pass ``` # Example ```python sentences = [\\"The quick brown fox\\", \\"jumped over the lazy dog\\", \\"The Fox\\"] # \'The\' and \'the\' are considered the same assert word_frequencies(sentences) == [(\'the\', 3), (\'fox\', 2), (\'brown\', 1), (\'dog\', 1), (\'jumped\', 1), (\'lazy\', 1), (\'over\', 1), (\'quick\', 1)] ```","solution":"from collections import defaultdict from typing import List, Tuple def word_frequencies(sentences: List[str]) -> List[Tuple[str, int]]: Counts the frequency of each word across all sentences and returns the words sorted by their frequencies in descending order. Words with the same frequency should be sorted alphabetically. :param sentences: List of sentences (strings) :return: List of tuples where each tuple contains a word and its frequency word_count = defaultdict(int) for sentence in sentences: for word in sentence.lower().split(): word_count[word] += 1 # Sorting first by frequency in descending order, then by word lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) return sorted_words"},{"question":"Question: Implement a Simple Interpreter # Context In this problem, you will create a simple interpreter for a subset of a hypothetical programming language. The interpreter will need to parse and execute a specified set of instructions. # Task Write a Python function `simple_interpreter(instructions: str) -> int` that takes a string of instructions as input and returns the final value of a variable called `result` after executing all instructions. # Expected Function Signature ```python def simple_interpreter(instructions: str) -> int: # Your implementation here ``` # Input - `instructions` (str): A newline-separated string where each line is an instruction in one of the following formats: - `result = <value>`: Sets the variable `result` to the given integer value. - `result += <value>`: Adds the given integer value to `result`. - `result -= <value>`: Subtracts the given integer value from `result`. # Output - The function returns the final value of `result` after executing all the given instructions in sequence. # Constraints - Assume `result` is initially set to 0. - Each `<value>` will be a valid integer in the range `[-1000, 1000]`. - The input string will contain a maximum of 1000 instructions. - The input instructions will always be valid and follow the specified format. # Example ```python instructions = result = 10 result += 5 result -= 3 # Expected Output: 12 assert simple_interpreter(instructions) == 12 ``` # Requirements - Design your solution to handle the instructions in the given order, ensuring correct parsing and execution. - Ensure that your implementation is efficient and can handle the upper limits of input constraints.","solution":"def simple_interpreter(instructions: str) -> int: Executes a series of instructions to modify the variable \'result\'. Args: instructions (str): A newline-separated string where each line is an instruction. Returns: int: The final value of \'result\' after executing all instructions. result = 0 # Split the instructions into individual commands commands = instructions.strip().split(\'n\') for command in commands: if command.startswith(\\"result = \\"): result = int(command[len(\\"result = \\"):]) elif command.startswith(\\"result += \\"): result += int(command[len(\\"result += \\"):]) elif command.startswith(\\"result -= \\"): result -= int(command[len(\\"result -= \\"):]) return result"},{"question":"**Question: Kth Smallest Element in an Array** Given a list of integers and an integer `k`, find the k-th smallest element in the array. Note that it is the k-th smallest element in the sorted order, not the k-th distinct element. **Function Signature:** ```python def kth_smallest_element(arr: List[int], k: int) -> int: pass ``` **Input:** - `arr` : a list of integers where ( 1 leq len(arr) leq 10^5 ) and (-10^9 leq arr[i] leq 10^9 ) - `k` : an integer where ( 1 leq k leq len(arr) ) **Output:** - Return the k-th smallest element in the given array. **Example:** ```plaintext Input: [7, 10, 4, 3, 20, 15], 3 Output: 7 Input: [7, 10, 4, 3, 20, 15], 4 Output: 10 ``` **Constraints:** - You may assume `k` is always valid, 1 ≤ k ≤ len(arr). - Ensure the solution handles large arrays efficiently without TLE (Time Limit Exceeded). **Performance Requirements:** - The function should aim for an average time complexity better than ( O(n log n) ), such as ( O(n) ) using Quickselect. **Edge Cases:** - Consider arrays with duplicate values. - Explore cases where the array is already sorted or in reverse order. - Handle large range values efficiently.","solution":"def kth_smallest_element(arr, k): Function to find the k-th smallest element in an array. Args: arr : List[int] - The list of integers. k : int - The k-th position (1-based index) to find the smallest element. Returns: int - The k-th smallest element in the array. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return i+1 def quickselect(low, high, k): if low == high: return arr[low] pivot_index = partition(low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(low, pivot_index - 1, k) else: return quickselect(pivot_index + 1, high, k) return quickselect(0, len(arr) - 1, k - 1)"},{"question":"# Array Rotation Challenge You are given an array of integers and a number, `k`. Your task is to rotate the array to the right by `k` steps. If `k` is negative or larger than the length of the array, handle these edge cases gracefully by rotating the array an appropriate number of times within its bounds. Input - A list of integers, `arr`. - An integer, `k`, which denotes the number of steps to rotate the array. Output - The rotated list of integers. Constraints - The input list must contain at least one element (1 ≤ len(arr) ≤ 10^5). - Each element in the list (|arr[i]| ≤ 10^5). - The integer `k` can be positive, negative, or zero. # Example ```python def rotate_array(arr: list, k: int) -> list: Rotate the given array to the right by \'k\' steps. Args: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the array. Returns: list: Rotated list of integers. # Your code here # Example 1 arr = [1, 2, 3, 4, 5, 6, 7] k = 3 # Output: [5, 6, 7, 1, 2, 3, 4] # Example 2 arr = [-1, -100, 3, 99] k = 2 # Output: [3, 99, -1, -100] ``` **Note**: - Ensure that your solution is efficient, even for large arrays. - Handle edge cases suitably, such as negative values and `k` greater than the length of the array.","solution":"def rotate_array(arr: list, k: int) -> list: Rotate the given array to the right by \'k\' steps. Args: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the array. Returns: list: Rotated list of integers. n = len(arr) # Handle edge case if k is negative or larger than n k = k % n # Rotate the list return arr[-k:] + arr[:-k]"},{"question":"# Binary Search Tree Operations You are required to implement certain operations of a Binary Search Tree (BST). A BST is a type of binary tree in which nodes are arranged in a specific order: for every node, keys in the left subtree are smaller and keys in the right subtree are larger. This task will test your ability to handle basic BST operations such as insertion, searching, deletion, and in-order traversal. **Objective**: Implement the following operations for a binary search tree: 1. **Insertion**: Insert a new value into the tree. 2. **Search**: Search for a value in the tree. 3. **Delete**: Delete a node with a specific value from the tree. 4. **In-order Traversal**: Return the in-order traversal of the tree. **Detailed Instructions**: 1. **Insert Operation** - Implement the method `insert(self, val)` in the `BST` class. - This method should insert the value `val` into the appropriate position in the tree. - Ensure the BST properties are maintained after insertion. 2. **Search Operation** - Implement the method `search(self, val)` in the `BST` class. - This method should return `True` if the value `val` is found in the tree, otherwise, return `False`. 3. **Delete Operation** - Implement the method `delete(self, val)` in the `BST` class. - This method should remove the node with the value `val` from the tree. - Ensure the BST properties are maintained after deletion. 4. **In-order Traversal Operation** - Implement the method `in_order_traversal(self)` in the `BST` class. - This method should return a list of values representing the in-order traversal of the tree. Here is the structure of the `BST` class and `TreeNode` class (already provided): ```python class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): # Insert logic pass def search(self, val): # Search logic pass def delete(self, val): # Delete logic pass def in_order_traversal(self): # In-order traversal logic pass def is_empty(self): return self.root is None ``` **Constraints**: 1. Perform the operations while maintaining the BST properties. 2. The operations should be efficient as per the standard BST complexities. **Examples**: ```python # Insert and Search Operations bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) assert bst.search(40) == True assert bst.search(25) == False # Deletion Operation bst.delete(20) assert bst.search(20) == False bst.delete(30) assert bst.search(30) == False # In-order Traversal Operation assert bst.in_order_traversal() == [40, 50, 60, 70, 80] ```","solution":"class TreeNode: def __init__(self, val): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val): self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"},{"question":"**Context**: Bit manipulation is a critical skill in computer science, with applications spanning from optimizing storage to implementing efficient algorithms. Reversing the bits of an integer is a common task that can be used in encryption algorithms, data compression, and various other domains. Given an integer `n`, the goal is to reverse its binary representation and return the resulting integer. **Problem Statement**: You are given an integer `n`. Your task is to implement the function `reverse_bits(n: int) -> int` which takes the integer `n` and returns the integer obtained by reversing the binary representation of `n`. # Function Signature: ```python def reverse_bits(n: int) -> int: pass ``` # Input: - an integer `n` (1 ≤ n ≤ 1,000,000) # Output: - an integer, which is the result of reversing the binary representation of `n`. # Constraints: - You can assume `n` will always be within the given range. - Consider leading zeros in the binary representation (e.g., the binary representation of 13 is `1101`, and its reversed representation is `1011`, which corresponds to 11 in decimal format). # Example: ```python assert reverse_bits(13) == 11 # binary 1101 reversed is 1011 assert reverse_bits(6) == 3 # binary 110 reversed is 011 assert reverse_bits(5) == 5 # binary 101 reversed is 101 assert reverse_bits(1) == 1 # binary 1 reversed is 1 assert reverse_bits(1024) == 1 # binary 10000000000 reversed is 00000000001 ``` # Note: - Consider using bitwise operations to reverse the bits efficiently. - Ensure proper handling and validation of edge cases, including very small and very large integers within the provided constraints.","solution":"def reverse_bits(n: int) -> int: This function takes an integer n and returns the integer obtained by reversing its binary representation. bin_str = format(n, \'b\') # Convert to binary string without \'0b\' prefix reversed_bin_str = bin_str[::-1] # Reverse the string return int(reversed_bin_str, 2) # Convert back to integer"},{"question":"# Merge Two Sorted Lists Context: As part of a data processing task, you are given two sorted lists that need to be merged into a single sorted list. The merged list should maintain the sorted order of the elements. Objective: Implement a function that takes two sorted lists and returns a new list containing all the elements from both input lists, sorted in non-decreasing order. Function Signature: ```python def merge_sorted_lists(list1: list, list2: list) -> list: pass ``` Input: 1. **list1** (list of int): The first sorted list. 2. **list2** (list of int): The second sorted list. Output: - **list of int**: The merged and sorted list containing all elements from `list1` and `list2`. Constraints: - The lengths of `list1` and `list2` will both be between 0 and 10^5. - Each integer in `list1` and `list2` will be between -10^9 and 10^9. Example: ```python assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([], [2, 4, 6]) == [2, 4, 6] assert merge_sorted_lists([1, 3, 5], []) == [1, 3, 5] assert merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([], []) == [] ``` Note: - The function should efficiently handle merging large lists. - You can assume that input to this function will always be valid and adhere to the constraints.","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: i, j = 0, 0 merged_list = [] # Merge the lists by comparing the elements one by one while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append any remaining elements from list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # Append any remaining elements from list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a feature for a cinema booking system. The system contains a seating chart for each theater that must be managed effectively to optimize seating arrangements when booking tickets. Your goal is to find and reserve the best available seats for a group of customers in a single row. The best available seats are the ones with the smallest average distance to the center of the row. Objectives Your task is to implement a function that finds and reserves the best available seats in a specified row of the theater for a given number of consecutive seats required by a group. Function Signature ```python def reserve_best_seats(seating_chart: list[list[str]], row: int, seats: int) -> bool: pass ``` Input * A 2D list of strings `seating_chart` representing the seating arrangement, where each string is \\"E\\" (empty) or \\"R\\" (reserved). - For example, [ [\\"E\\", \\"E\\", \\"R\\", \\"E\\"], [ \\"R\\", \\"R\\", \\"E\\", \\"E\\"], ... ] * An integer `row` representing the index of the row (0-indexed) for which seats need to be found. * An integer `seats` representing the number of consecutive seats required. Output * A boolean value indicating whether the reservation was successful (True) or not (False). Constraints * The number of rows in the seating chart will be between 1 and 1000. * The number of seats per row will be between 1 and 1000. * `row` will be a valid index within the seating chart. * `seats` will be a positive integer, and there will always be at least one seat available in the row at the start of the reservation process. Example ```python >>> seating_chart = [ ... [\\"E\\", \\"E\\", \\"R\\", \\"E\\", \\"E\\"], ... [\\"R\\", \\"R\\", \\"E\\", \\"E\\", \\"E\\"], ... [\\"E\\", \\"E\\", \\"E\\", \\"R\\", \\"E\\"] ... ] >>> reserve_best_seats(seating_chart, 0, 2) True # The seating chart after the reservation: # [ [\\"R\\", \\"R\\", \\"R\\", \\"E\\", \\"E\\"], [\\"R\\", \\"R\\", \\"E\\", \\"E\\", \\"E\\"], [\\"E\\", \\"E\\", \\"E\\", \\"R\\", \\"E\\"] ] >>> reserve_best_seats(seating_chart, 1, 4) False # No four consecutive seats are available in row 1. ``` Instructions 1. Find the best available consecutive seats based on the smallest average distance to the center of the row. 2. If such seats are available, reserve them by updating the chart with \\"R\\" for those seats and return True. 3. If no suitable seats are available, return False. 4. Ensure you efficiently handle the search and update process to maintain performance with larger inputs.","solution":"def reserve_best_seats(seating_chart: list[list[str]], row: int, seats: int) -> bool: Finds and reserves the best available seats in a specified row of the theater. Parameters: seating_chart (list[list[str]]): The 2D list of strings representing the seating arrangement. row (int): The index of the row in which to find and reserve seats. seats (int): The number of consecutive seats required. Returns: bool: True if the reservation was successful, False otherwise. if row < 0 or row >= len(seating_chart) or seats <= 0: return False current_row = seating_chart[row] row_length = len(current_row) seats_found = False best_avg_distance = float(\'inf\') best_start_pos = -1 center = (row_length - 1) / 2 for start in range(row_length - seats + 1): if all(current_row[start + i] == \'E\' for i in range(seats)): avg_distance = sum(abs(center - (start + i)) for i in range(seats)) / seats if avg_distance < best_avg_distance: best_avg_distance = avg_distance best_start_pos = start seats_found = True if seats_found: for i in range(seats): seating_chart[row][best_start_pos + i] = \'R\' return True return False"},{"question":"# Task Implement the A* algorithm to solve the Pac-Man shortest path problem on a grid with passable and impassable cells. Pac-Man starts at a given start cell and needs to reach an end cell, navigating through passable cells while avoiding impassable cells. # Function Signature ```python def a_star_pacman(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: pass ``` # Input - `maze`: A 2D list where `maze[i][j]` is 0 for passable cells and 1 for impassable cells. - `start`: A tuple `(x, y)` representing Pac-Man\'s starting position. - `end`: A tuple `(x, y)` representing Pac-Man\'s destination. # Output - A list of tuples, representing the sequence of cells from start to end, inclusive. - If no valid path exists, return an empty list. # Constraints 1. The maze will be a non-empty rectangle with dimensions at most 100x100. 2. The start and end positions will always be valid indices within the maze. 3. There will always be a valid path from start to end. 4. Pac-Man can move up, down, left, or right but not diagonally. # Example ```python maze = [ [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [1, 0, 1, 0] ] start = (0, 0) end = (3, 3) print(a_star_pacman(maze, start, end)) # Expected Output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (2, 3), (3, 3)] ```","solution":"import heapq def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(point, maze): x, y = point neighbors = [] for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]: if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: neighbors.append((nx, ny)) return neighbors def a_star_pacman(maze, start, end): open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} while open_set: current = heapq.heappop(open_set)[1] if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) path.reverse() return path for neighbor in get_neighbors(current, maze): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Scenario You are building a library for basic matrix operations in Python, focusing on common tasks such as matrix addition, subtraction, multiplication, and transposition. For this task, you need to implement matrix addition. # Objective Write a Python function named `matrix_addition` that accepts two matrices (lists of lists of integers) and returns their sum. The matrices should be of the same shape. The function should handle input validation and provide meaningful error messages for invalid inputs. # Function Signature ```python def matrix_addition(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: pass ``` # Input 1. `matrix1` (list): A matrix represented as a list of lists of integers. 2. `matrix2` (list): A matrix represented as a list of lists of integers. # Output * Returns a matrix (list of lists of integers) representing the element-wise sum of the input matrices. # Constraints * Both matrices must be of the same dimensions, i.e., same number of rows and columns. * All elements in the matrices should be integers. # Requirements 1. The function should raise a ValueError if the matrices are of different dimensions. 2. The function should raise a TypeError if either of the inputs is not a list of lists of integers. # Examples ```python >>> matrix_addition([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[6, 8], [10, 12]] >>> matrix_addition([[10, 20], [30, 40]], [[1, 2], [3, 4]]) [[11, 22], [33, 44]] >>> matrix_addition([[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]) [[8, 10, 12], [14, 16, 18]] >>> matrix_addition([[1]], [[2]]) [[3]] >>> matrix_addition([[1, 2], [3, 4]], [[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: Matrices must have the same dimensions >>> matrix_addition([[1, 2], [3, \\"4\\"]], [[5, 6], [7, 8]]) Traceback (most recent call last): ... TypeError: Matrix elements must be integers >>> matrix_addition([[1, 2], [3, 4]], [1, 2, 3, 4]) Traceback (most recent call last): ... TypeError: Inputs must be matrices (lists of lists of integers) ``` # Notes * The solution should efficiently handle small and moderately-sized matrices. * Input edge cases should be addressed (e.g., empty matrices, single-element matrices). Provide well-documented code and include any assumptions made in your solution.","solution":"def matrix_addition(matrix1: list[list[int]], matrix2: list[list[int]]) -> list[list[int]]: Adds two matrices element-wise. Parameters: matrix1 (list[list[int]]): The first matrix. matrix2 (list[list[int]]): The second matrix. Returns: list[list[int]]: The matrix which is the element-wise sum of the input matrices. Raises: ValueError: If the matrices have different dimensions. TypeError: If the input is not a list of lists of integers. # Validate inputs if not all(isinstance(row, list) for row in matrix1) or not all(isinstance(row, list) for row in matrix2): raise TypeError(\\"Inputs must be matrices (lists of lists of integers)\\") if not all(isinstance(element, int) for row in matrix1 for element in row) or not all(isinstance(element, int) for row in matrix2 for element in row): raise TypeError(\\"Matrix elements must be integers\\") if len(matrix1) != len(matrix2) or any(len(row1) != len(row2) for row1, row2 in zip(matrix1, matrix2)): raise ValueError(\\"Matrices must have the same dimensions\\") # Adding matrices element-wise return [[matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[i]))] for i in range(len(matrix1))]"},{"question":"# Problem Statement Implement a function `remove_duplicates_and_sort` that takes a list of integers, removes any duplicate elements, and returns a new list containing the sorted unique integers. # Requirements 1. **Function Signature**: ```python def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: ``` 2. **Inputs**: * `numbers` (List[int]): A list of integers that may contain duplicates. 3. **Outputs**: * Returns a new list with all duplicates removed and remaining integers sorted in ascending order. 4. **Constraints**: * The input list can be empty or contain up to 10^6 elements. * Each integer in the input list will be within the range of -10^6 to 10^6. # Example Usage ```python >>> remove_duplicates_and_sort([4, 5, 2, 2, 3, 1, 4]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([10, 10, 10, -1, -1, 0]) [-1, 0, 10] >>> remove_duplicates_and_sort([]) [] ``` # Additional Notes - Ensure that your solution handles input lists with both positive and negative integers. - Consider edge cases, such as already sorted lists or lists with all identical elements. - Aim for an efficient solution, particularly with respect to time complexity.","solution":"from typing import List def remove_duplicates_and_sort(numbers: List[int]) -> List[int]: Takes a list of integers, removes any duplicate elements, and returns a new list containing the sorted unique integers. return sorted(set(numbers))"},{"question":"Problem Statement: You are given an integer `n` representing the total number of nodes, and an array `edges` where each element is a pair of integers `[u, v]` representing an undirected edge connecting nodes `u` and `v`. Your task is to write a function `valid_tree(n: int, edges: List[List[int]]) -> bool` that determines if these edges form a valid tree. # Requirements: 1. Check if the graph formed by the edges is connected and acyclic. 2. Utilize Union-Find (Disjoint Set Union) algorithm to achieve an efficient solution. # Constraints: - The number of nodes `n` is between 1 and 2000. - Each pair in the `edges` represents an undirected edge. - The number of edges is between 0 and 1999. - Each node is an integer between 0 and `n-1`. # Input: - `n`: An integer representing the number of nodes. - `edges`: A list of lists where each sublist contains 2 integers representing an undirected edge. # Output: - A boolean value (`True` or `False`). # Example: **Input**: ```python n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] ``` **Output**: ```python True ``` **Input**: ```python n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] ``` **Output**: ```python False ``` **Input**: ```python n = 3 edges = [[0, 1], [1, 2], [2, 0]] ``` **Output**: ```python False ``` # Notes: - A valid tree must be connected, meaning there is a path between any pair of nodes. - A valid tree cannot have any cycles. - Use the Union-Find algorithm to detect cycles and ensure all nodes are connected.","solution":"from typing import List def valid_tree(n: int, edges: List[List[int]]) -> bool: if n - 1 != len(edges): return False parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False for u, v in edges: if not union(u, v): return False return True"},{"question":"# Coding Assessment Question Implement a function to simulate a basic version of a relational database join operation. You will perform an inner join on two tables (lists of dictionaries), ensuring that each resulting dictionary contains all the fields from both original dictionaries, excluding duplicate keys. Function Signature ```python def inner_join(table1: list, table2: list, key: str) -> list: ``` Input Specifications: - **table1** (*list* of *dict*): First table containing a list of dictionaries where each dictionary represents a row. - **table2** (*list* of *dict*): Second table containing a list of dictionaries where each dictionary represents a row. - **key** (*str*): The key on which to join the two tables. Output Specifications: - **output** (*list* of *dict*): A list of dictionaries representing the result of the inner join operation. Each dictionary should contain fields from both input tables, with no duplicate keys except for the join key. Example Usage: ```python table1 = [ {\'id\': 1, \'name\': \'Alice\', \'age\': 30}, {\'id\': 2, \'name\': \'Bob\', \'age\': 25}, {\'id\': 3, \'name\': \'Charlie\', \'age\': 35} ] table2 = [ {\'id\': 1, \'country\': \'USA\', \'occupation\': \'Engineer\'}, {\'id\': 2, \'country\': \'Canada\', \'occupation\': \'Doctor\'}, {\'id\': 4, \'country\': \'UK\', \'occupation\': \'Artist\'} ] key = \'id\' result = inner_join(table1, table2, key) # expected result [ {\'id\': 1, \'name\': \'Alice\', \'age\': 30, \'country\': \'USA\', \'occupation\': \'Engineer\'}, {\'id\': 2, \'name\': \'Bob\', \'age\': 25, \'country\': \'Canada\', \'occupation\': \'Doctor\'} ] ``` Constraints: - The function should handle cases where the join key may not be present in every dictionary of both tables. - Duplicate \'key\' values in the result should be avoided. - The function should operate in O(n * m) where n and m are the lengths of table1 and table2, respectively. Optimal use of data structures to accomplish the task efficiently is encouraged. - Write your implementation without using any third-party libraries, focusing on core Python functionalities.","solution":"def inner_join(table1: list, table2: list, key: str) -> list: Perform an inner join on two tables (lists of dictionaries) using the specified key. Args: table1 (list of dict): The first table. table2 (list of dict): The second table. key (str): The join key. Returns: list of dict: The result of the inner join operation. # Create a mapping from the key values to the rows in table2 table2_map = {} for row in table2: if key in row: table2_map[row[key]] = row # Perform the inner join result = [] for row1 in table1: if key in row1 and row1[key] in table2_map: # Combine the rows from table1 and table2 combined_row = {**row1, **table2_map[row1[key]]} result.append(combined_row) return result"},{"question":"# Sorting a List of Dictionaries by a Key Value Background In many programming tasks, you might have a list of dictionaries, and you need to sort this list based on the values associated with a specific key in each dictionary. This type of sorting can be crucial for organizing data in a meaningful way. Task Write a function `sort_dicts_by_key(dicts_list: List[Dict[str, int]], key: str) -> List[Dict[str, int]]` that takes a list of dictionaries and a string representing the key, and returns a new list of dictionaries sorted by the values associated with the specified key in ascending order. Input - `dicts_list`: A list of dictionaries containing string keys and integer values. - `key`: A string indicating the key by which the list should be sorted. Output - Returns a new list of dictionaries sorted by the values associated with the specified key. Constraints - Each dictionary in `dicts_list` will have the specified `key`. - Each dictionary will have string keys and integer values. - The list may be empty, in which case, return an empty list. Example ```python >>> dicts_list = [ {\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\', \'age\': 25}, {\'name\': \'Charlie\', \'age\': 35} ] >>> key = \'age\' >>> sort_dicts_by_key(dicts_list, key) [ {\'name\': \'Bob\', \'age\': 25}, {\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Charlie\', \'age\': 35} ] ``` Additional Notes - Consider using Python\'s built-in sorting functions to achieve an efficient solution. - Ensure the function is generic enough to handle any list of dictionaries with integer values, not just the `age` key. Your task is to implement this `sort_dicts_by_key` function correctly and efficiently.","solution":"from typing import List, Dict def sort_dicts_by_key(dicts_list: List[Dict[str, int]], key: str) -> List[Dict[str, int]]: Sorts a list of dictionaries by the values associated with the specified key. Parameters: dicts_list (List[Dict[str, int]]): List of dictionaries to be sorted. key (str): The key by which the list should be sorted. Returns: List[Dict[str, int]]: A new list of dictionaries sorted by the specified key in ascending order. return sorted(dicts_list, key=lambda d: d[key])"},{"question":"# Matrix Transposition Problem Context: Matrix transposition is a fundamental operation in linear algebra where the rows of a matrix are swapped with its columns. This operation is crucial in various computations, including solving linear equations, computer graphics, and machine learning. You need to implement a function that takes an `n x m` matrix and returns its transpose. Task: - Implement a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list `matrix` as input and returns its transpose. Input: - The function will receive a single argument `matrix`, which is a list of `n` lists, each containing `m` integers. Output: - A 2D list representing the transposed matrix, where the original matrix\'s rows have become the columns and vice versa. Constraints: - The matrix can have dimensions up to 100x100. - The matrix will always have at least one element. Example: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Implement the matrix transposition here # Example Usage: matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output: [[1, 4], [2, 5], [3, 6]] ``` Your task is to provide an implementation for the function `transpose_matrix`, which should take a 2D list and return its transpose accurately.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given 2D matrix. Args: matrix (List[List[int]]): The 2D list representing the matrix to be transposed Returns: List[List[int]]: The transposed matrix # To transpose, we\'ll swap rows with columns return [list(row) for row in zip(*matrix)]"},{"question":"# Problem Statement: You are tasked with implementing an algorithm to detect cycles within a directed graph. A cycle is a path in which the first and last vertices are the same. You need to write a function that accepts an adjacency list representing the graph and determines if a cycle exists. # Function Requirements: 1. **`has_cycle(graph: dict) -> bool`**: - **Input**: - `graph` (dictionary): A dictionary where keys are nodes and values are lists of nodes directly accessible from the key node. - **Output**: - Return `True` if there is a cycle in the graph, and `False` otherwise. # Constraints: - The graph will have at least one node and will be represented as a dictionary. - Each node in the graph will be a string consisting of alphabetic characters. - Your implementation should efficiently handle the detection of cycles in both small and large graphs. # Example: ```python # Example 1 graph1 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } assert has_cycle(graph1) == True # Example 2 graph2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } assert has_cycle(graph2) == False # Example 3 graph3 = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [], \\"C\\": [\\"D\\"], \\"D\\": [\\"A\\"] } assert has_cycle(graph3) == True # Example 4 graph4 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } assert has_cycle(graph4) == False ``` # Additional Requirements: - Aim for a time complexity close to O(V + E), where V is the number of vertices (nodes) and E is the number of edges. - Ensure that the function is well-commented and provides clear logic flow. - Handle edge cases such as a graph with no edges or a node pointing to itself. This problem tests your understanding of graph traversal techniques and cycle detection algorithms, essential skills for solving complex graph-related problems.","solution":"def has_cycle(graph): Determines if a cycle exists in the directed graph represented by the adjacency list. :param graph: Dictionary representing the adjacency list of the graph :return: True if a cycle exists, False otherwise def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[node] = False return False visited = {node: False for node in graph} rec_stack = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Context: In database management systems, a common requirement is to aggregate data based on certain conditions. For example, analyzing sales data to determine monthly revenue, average revenue per customer, or finding the most popular product sold within a specific period. Such tasks often involve filtering, sorting, and summarizing data efficiently using predefined conditions. # Problem Statement: You need to implement a function that summarizes monthly sales data by calculating the total revenue, average revenue per sale, and the most popular product (the one with the highest number of sales) for each month. Write a function `summarize_sales` that processes a list of sales records. Each sale record is represented as a dictionary containing \'date\' (a string in \'YYYY-MM-DD\' format), \'product\' (a string representing the product name), and \'revenue\' (a float representing the revenue from the sale). # Function Signature: ```python def summarize_sales(sales: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: ``` # Input: - `sales`: a list of dictionaries, where each dictionary has the following structure: - \'date\': a string representing the sale date in \'YYYY-MM-DD\' format. - \'product\': a string representing the product name. - \'revenue\': a float representing the revenue from the sale. # Output: - Returns a list of dictionaries where each dictionary summarizes sales for a specific month with the following structure: - \'month\': a string representing the month in \'YYYY-MM\' format. - \'total_revenue\': a float representing the total revenue for the month. - \'avg_revenue_per_sale\': a float representing the average revenue per sale for the month. - \'most_popular_product\': a string representing the product with the highest number of sales for the month. # Constraints: - Ensure that the filtering and summarizing operations are performed efficiently. - Handle edge cases where no sales are recorded for a specific month or products have identical sales numbers. # Example: ```python >>> sales_data = [ {\'date\': \'2023-01-15\', \'product\': \'Product A\', \'revenue\': 120.50}, {\'date\': \'2023-01-20\', \'product\': \'Product B\', \'revenue\': 80.00}, {\'date\': \'2023-01-25\', \'product\': \'Product A\', \'revenue\': 150.75}, {\'date\': \'2023-02-05\', \'product\': \'Product C\', \'revenue\': 200.00}, {\'date\': \'2023-02-15\', \'product\': \'Product A\', \'revenue\': 170.50}, {\'date\': \'2023-02-20\', \'product\': \'Product C\', \'revenue\': 100.00} ] >>> summarize_sales(sales_data) [ { \'month\': \'2023-01\', \'total_revenue\': 351.25, \'avg_revenue_per_sale\': 117.08, \'most_popular_product\': \'Product A\' }, { \'month\': \'2023-02\', \'total_revenue\': 470.50, \'avg_revenue_per_sale\': 156.83, \'most_popular_product\': \'Product C\' } ] ``` # Additional Information: Use the following helper function to parse the dates into a more manageable form: ```python from datetime import datetime def parse_date(date_str: str) -> str: date = datetime.strptime(date_str, \'%Y-%m-%d\') return date.strftime(\'%Y-%m\') ```","solution":"from typing import List, Dict, Union from collections import defaultdict, Counter from datetime import datetime import math def parse_date(date_str: str) -> str: Helper function to parse the date into \'YYYY-MM\' format. date = datetime.strptime(date_str, \'%Y-%m-%d\') return date.strftime(\'%Y-%m\') def summarize_sales(sales: List[Dict[str, Union[str, float]]]) -> List[Dict[str, Union[str, float]]]: monthly_sales = defaultdict(list) # Aggregate sales data by month for sale in sales: month = parse_date(sale[\'date\']) monthly_sales[month].append(sale) summaries = [] # Process each month\'s sales data for month, sales_list in monthly_sales.items(): total_revenue = sum(sale[\'revenue\'] for sale in sales_list) avg_revenue_per_sale = total_revenue / len(sales_list) product_counter = Counter(sale[\'product\'] for sale in sales_list) most_popular_product = product_counter.most_common(1)[0][0] summary = { \'month\': month, \'total_revenue\': total_revenue, \'avg_revenue_per_sale\': round(avg_revenue_per_sale, 2), \'most_popular_product\': most_popular_product } summaries.append(summary) return summaries"},{"question":"# Create a To-Do List Application Your task is to design a basic To-Do list application. You must implement functionalities to add, remove, mark as complete, and view tasks. The goal is to demonstrate efficient handling of operations on a list of tasks while maintaining simplicity and clarity in your code. # Requirements: 1. **Input**: The program should be able to process multiple commands to manipulate the tasks. 2. **Output**: Based on the command, return the current state of the task list or a confirmation message. 3. **Function Implementation**: Write a class `ToDoList` with the following methods: - `add_task(task: str) -> str` - `remove_task(task_number: int) -> str` - `mark_task_complete(task_number: int) -> str` - `view_tasks() -> list[str]` # Constraints: 1. Task identification is managed by their order in the list (1-based indexing). 2. Handle attempts to remove or mark a task that doesn\'t exist gracefully. 3. Commands: - `\\"add\\":` Add a task to the list. - `\\"remove\\":` Remove a task from the list by its task number. - `\\"complete\\":` Mark a task as complete by its task number. - `\\"view\\":` View the current list of tasks, with each task on a new line. 4. Ensure tasks are stored in the order they are added. 5. When viewing tasks, denote completed tasks clearly. # Example: ```python class ToDoList: def __init__(self): self.tasks = [] def add_task(self, task: str) -> str: # Your implementation def remove_task(self, task_number: int) -> str: # Your implementation def mark_task_complete(self, task_number: int) -> str: # Your implementation def view_tasks(self) -> list[str]: # Your implementation # Usage example todo = ToDoList() print(todo.add_task(\\"Buy groceries\\")) print(todo.add_task(\\"Walk the dog\\")) print(todo.view_tasks()) print(todo.mark_task_complete(1)) print(todo.view_tasks()) print(todo.remove_task(2)) print(todo.view_tasks()) ``` # Scenario: Imagine you are managing your daily tasks and need an application to add new tasks, remove completed or unnecessary ones, and mark tasks that you have completed. This application should be able to help prioritize and handle your to-do list efficiently without losing track of your tasks. # Notes: - Implement error handling to manage invalid task numbers (out of range). - Clearly distinguish between the states of tasks (e.g., completed vs pending) when viewing them. - Maintain task integrity and order for easy tracking and prioritization. - Ensure that your code is modular and easy to follow for future enhancements or fixes.","solution":"class ToDoList: def __init__(self): self.tasks = [] def add_task(self, task: str) -> str: Add a new task to the list. self.tasks.append({\'task\': task, \'completed\': False}) return f\'Task \\"{task}\\" added.\' def remove_task(self, task_number: int) -> str: Remove a task from the list by its number. if 1 <= task_number <= len(self.tasks): task = self.tasks.pop(task_number - 1) return f\'Task \\"{task[\\"task\\"]}\\" removed.\' else: return \\"Invalid task number.\\" def mark_task_complete(self, task_number: int) -> str: Mark a task as complete by its number. if 1 <= task_number <= len(self.tasks): self.tasks[task_number - 1][\'completed\'] = True return f\'Task \\"{self.tasks[task_number - 1][\\"task\\"]}\\" marked as complete.\' else: return \\"Invalid task number.\\" def view_tasks(self) -> list[str]: Return the current list of tasks. tasks_display = [] for idx, task in enumerate(self.tasks): status = \'done\' if task[\'completed\'] else \'pending\' tasks_display.append(f\\"{idx + 1}. [{status}] {task[\'task\']}\\") return tasks_display"},{"question":"# Question Objective Implement a function `merge_sort` to perform the merge sort algorithm on a given list of integers. Merge sort is a divide-and-conquer algorithm that splits the list into smaller sublists, sorts each sublist, and then merges them back together to form the sorted list. Algorithm Explanation Merge sort consists of the following steps: 1. Divide the unsorted list into n sublists, each containing one element (a list of one element is naturally sorted). 2. Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list. Input and Output * **Input**: A list of integers `nums`. * **Output**: A new list of integers, sorted in non-decreasing order. Constraints * You should not use Python\'s built-in `sort` or `sorted` methods. * Aim for a time complexity of O(n log n) and a space complexity of O(n). * The function signature should be: `def merge_sort(nums: list) -> list`. Scenario Consider the array of student grades in a database that need to be sorted in non-decreasing order for ease of processing. Example ```python >>> nums = [5, 3, 8, 4, 2] >>> merge_sort(nums) [2, 3, 4, 5, 8] >>> nums = [1, 2, 3, 4, 5] >>> merge_sort(nums) [1, 2, 3, 4, 5] >>> nums = [] >>> merge_sort(nums) [] >>> nums = [10, 3] >>> merge_sort(nums) [3, 10] ``` Develop the `merge_sort` function to correctly sort the given sequences as per the outlined principles.","solution":"def merge_sort(nums): Performs merge sort on a list of integers. Parameters: nums (list of int): The list of integers to be sorted. Returns: list of int: The sorted list. if len(nums) <= 1: return nums mid = len(nums) // 2 left_half = merge_sort(nums[:mid]) right_half = merge_sort(nums[mid:]) return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list of int): The first sorted list. right (list of int): The second sorted list. Returns: list of int: The merged and sorted list. sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"# Problem Statement You are required to enhance an existing function that transforms a list of words into a word cloud. A word cloud is a visual representation where the size of each word indicates its frequency or importance. # Objective Implement a function `generate_word_cloud` that: 1. Processes a list of words into a format suitable for creating a word cloud. 2. Ensures that the word cloud removes common stop words (like \\"the\\", \\"is\\", \\"at\\", etc.). 3. Counts the frequency of each word and returns a dictionary where keys are words and values are their respective frequencies. # Requirements - **Input**: - `words_list`: A list of strings, where each string is a word or a phrase. (1 ≤ length of words_list ≤ 1000) - **Output**: A dictionary with each word as the key and its frequency count as the value. # Constraints - Words are case insensitive. The words \\"Example\\" and \\"example\\" should be considered the same. - Remove common English stop words (https://gist.github.com/sebleier/554280) from the count. - Return the words in lowercase. # Example Case ```python def generate_word_cloud(words_list: list[str]) -> dict[str, int]: # Your implementation here # Example usage words = [\\"hello\\", \\"world\\", \\"Hello\\", \\"WORLD\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"example\\"] word_cloud = generate_word_cloud(words) print(word_cloud) ``` **Expected Output**: ```python {\'hello\': 2, \'world\': 2, \'test\': 1, \'example\': 2} ``` # Note - You may use any libraries for processing text. - Document any assumptions you make and handle unusual scenarios within reason. # Instructions - Consider edge cases such as empty input or a list with only stop words. - Focus on code efficiency to handle the maximum input sizes effectively.","solution":"def generate_word_cloud(words_list): Transforms a list of words into a dictionary suitable for creating a word cloud. Args: words_list (list of str): List of words and phrases. Returns: dict: A dictionary with words as keys and their respective frequencies as values. import re from collections import Counter # List of common English stop words stop_words = set([ \\"a\\", \\"about\\", \\"above\\", \\"after\\", \\"again\\", \\"against\\", \\"all\\", \\"am\\", \\"an\\", \\"and\\", \\"any\\", \\"are\\", \\"aren\'t\\", \\"as\\", \\"at\\", \\"be\\", \\"because\\", \\"been\\", \\"before\\", \\"being\\", \\"below\\", \\"between\\", \\"both\\", \\"but\\", \\"by\\", \\"can\'t\\", \\"cannot\\", \\"could\\", \\"couldn\'t\\", \\"did\\", \\"didn\'t\\", \\"do\\", \\"does\\", \\"doesn\'t\\", \\"doing\\", \\"don\'t\\", \\"down\\", \\"during\\", \\"each\\", \\"few\\", \\"for\\", \\"from\\", \\"further\\", \\"had\\", \\"hadn\'t\\", \\"has\\", \\"hasn\'t\\", \\"have\\", \\"haven\'t\\", \\"having\\", \\"he\\", \\"he\'d\\", \\"he\'ll\\", \\"he\'s\\", \\"her\\", \\"here\\", \\"here\'s\\", \\"hers\\", \\"herself\\", \\"him\\", \\"himself\\", \\"his\\", \\"how\\", \\"how\'s\\", \\"i\\", \\"i\'d\\", \\"i\'ll\\", \\"i\'m\\", \\"i\'ve\\", \\"if\\", \\"in\\", \\"into\\", \\"is\\", \\"isn\'t\\", \\"it\\", \\"it\'s\\", \\"its\\", \\"itself\\", \\"let\'s\\", \\"me\\", \\"more\\", \\"most\\", \\"mustn\'t\\", \\"my\\", \\"myself\\", \\"no\\", \\"nor\\", \\"not\\", \\"of\\", \\"off\\", \\"on\\", \\"once\\", \\"only\\", \\"or\\", \\"other\\", \\"ought\\", \\"our\\", \\"ours\\", \\"ourselves\\", \\"out\\", \\"over\\", \\"own\\", \\"same\\", \\"shan\'t\\", \\"she\\", \\"she\'d\\", \\"she\'ll\\", \\"she\'s\\", \\"should\\", \\"shouldn\'t\\", \\"so\\", \\"some\\", \\"such\\", \\"than\\", \\"that\\", \\"that\'s\\", \\"the\\", \\"their\\", \\"theirs\\", \\"them\\", \\"themselves\\", \\"then\\", \\"there\\", \\"there\'s\\", \\"these\\", \\"they\\", \\"they\'d\\", \\"they\'ll\\", \\"they\'re\\", \\"they\'ve\\", \\"this\\", \\"those\\", \\"through\\", \\"to\\", \\"too\\", \\"under\\", \\"until\\", \\"up\\", \\"very\\", \\"was\\", \\"wasn\'t\\", \\"we\\", \\"we\'d\\", \\"we\'ll\\", \\"we\'re\\", \\"we\'ve\\", \\"were\\", \\"weren\'t\\", \\"what\\", \\"what\'s\\", \\"when\\", \\"when\'s\\", \\"where\\", \\"where\'s\\", \\"which\\", \\"while\\", \\"who\\", \\"who\'s\\", \\"whom\\", \\"why\\", \\"why\'s\\", \\"with\\", \\"won\'t\\", \\"would\\", \\"wouldn\'t\\", \\"you\\", \\"you\'d\\", \\"you\'ll\\", \\"you\'re\\", \\"you\'ve\\", \\"your\\", \\"yours\\", \\"yourself\\", \\"yourselves\\" ]) # Convert all words to lowercase and filter out stop words filtered_words = [ word.lower() for word in words_list if word.lower() not in stop_words ] # Count the frequency of each word word_count = Counter(filtered_words) return dict(word_count) # Example usage words = [\\"hello\\", \\"world\\", \\"Hello\\", \\"WORLD\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"example\\", \\"example\\"] word_cloud = generate_word_cloud(words) print(word_cloud)"},{"question":"# Problem Statement You are tasked with creating a system that can compress a sequence of integers using a very simple run-length encoding (RLE) scheme. Your job is to implement two functions: one to compress the sequence and one to decompress the sequence back to its original form. # Function Signatures ```python def compress_sequence(sequence: list[int]) -> list[tuple[int, int]]: Compresses a sequence of integers using run-length encoding. :param sequence: List of integers to compress. :return: A list of tuples where each tuple contains a number and its consecutive count. ``` ```python def decompress_sequence(compressed_sequence: list[tuple[int, int]]) -> list[int]: Decompresses a run-length encoded sequence of integers. :param compressed_sequence: List of tuples containing the number and its consecutive count. :return: The original list of integers before compression. ``` # Input * For `compress_sequence`: `sequence` is a list of integers where each integer can be negative or positive. * For `decompress_sequence`: `compressed_sequence` is a list of tuples, where each tuple contains a number and its count. # Output * For `compress_sequence`: A list of tuples, where each tuple contains a number from the sequence and its count of consecutive occurrences. * For `decompress_sequence`: A list of integers, restored to their original order from the compressed sequence. # Constraints * The input sequence for compression contains between 1 and 1000 elements. * The input sequence for decompression contains between 1 and 1000 tuples. * Each tuple in the `compressed_sequence` will have a positive integer count. # Example ```python sequence = [1, 1, 2, 3, 3, 3, 4] # Output should be a compressed sequence of tuples expected_compressed_output = [(1, 2), (2, 1), (3, 3), (4, 1)] assert compress_sequence(sequence) == expected_compressed_output compressed_sequence = [(1, 2), (2, 1), (3, 3), (4, 1)] # Output should be the original sequence expected_sequence_output = [1, 1, 2, 3, 3, 3, 4] assert decompress_sequence(compressed_sequence) == expected_sequence_output ``` # Note - The `compress_sequence` function should iterate through the input list and count consecutive occurrences of the same integer, storing them as tuples. - The `decompress_sequence` function should iterate through the list of tuples and reconstruct the original sequence using the number and its count from each tuple.","solution":"def compress_sequence(sequence: list[int]) -> list[tuple[int, int]]: Compresses a sequence of integers using run-length encoding. :param sequence: List of integers to compress. :return: A list of tuples where each tuple contains a number and its consecutive count. if not sequence: return [] compressed = [] current_number = sequence[0] count = 1 for num in sequence[1:]: if num == current_number: count += 1 else: compressed.append((current_number, count)) current_number = num count = 1 compressed.append((current_number, count)) # Append the last group return compressed def decompress_sequence(compressed_sequence: list[tuple[int, int]]) -> list[int]: Decompresses a run-length encoded sequence of integers. :param compressed_sequence: List of tuples containing the number and its consecutive count. :return: The original list of integers before compression. decompressed = [] for num, count in compressed_sequence: decompressed.extend([num] * count) return decompressed"},{"question":"# Problem: Maximum Sum of Non-Adjacent Elements Given an array of integers, write a function `max_sum_non_adjacent(arr: list) -> int` that returns the maximum sum of non-adjacent elements. You are not allowed to take two adjacent elements from the array. If the array is empty, the function should return 0. **Function Signature**: `def max_sum_non_adjacent(arr: list) -> int:` **Input**: - `arr` (list): A list of integers. (-10^4 ≤ arr[i] ≤ 10^4, 0 ≤ len(arr) ≤ 1000) **Output**: - An integer representing the maximum sum of non-adjacent elements from the given list. **Examples**: ```python print(max_sum_non_adjacent([3, 2, 5, 10, 7])) # Output: 15 print(max_sum_non_adjacent([3, 2, 7, 10])) # Output: 13 print(max_sum_non_adjacent([5, 5, 10, 100, 10, 5])) # Output: 110 print(max_sum_non_adjacent([0, 0, 0])) # Output: 0 print(max_sum_non_adjacent([])) # Output: 0 ``` **Detailed Explanation**: 1. Use dynamic programming to keep track of the maximum sum up to each index while ensuring non-adjacency is maintained. 2. Create two variables, `include` and `exclude`: - `include`: Maximum sum including the current element. - `exclude`: Maximum sum excluding the current element. 3. Traverse through each element in the array and update `include` and `exclude` accordingly. 4. The final result will be the maximum of `include` and `exclude`. **Requirements**: - Ensure your solution handles edge cases such as an empty array or arrays with only one element.","solution":"def max_sum_non_adjacent(arr): if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) include = 0 exclude = 0 for num in arr: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Question You are given a list of integers `arr` and an integer value `X`. Your task is to find the largest number in the list that is smaller than X. If no such number exists, return -1. **Function Signature:** ```python def largest_number_smaller_than_x(arr: List[int], X: int) -> int: Args: arr: List[int]: a list of integers. X: int: the target value. Returns: int: The largest number in the list less than `X` or -1 if no such number exists. ``` # Input * `arr` (0 <= len(arr) <= 10^5): A list of integers. * `X` (1 <= X <= 10^9): The target value. # Output The function should return an integer which is the largest number in `arr` that is smaller than `X`, or -1 if no such number exists in the list. # Constraints * The elements of `arr` can be negative or positive. * Ensure your solution is efficient enough to handle large lists up to 100,000 elements. # Performance Requirements Your solution should prioritize efficient search and comparison techniques to handle large input sizes. # Example: ```python >>> largest_number_smaller_than_x([3, 8, 1, 4, 7], 5) 4 >>> largest_number_smaller_than_x([-1, -3, 2, 6, 10], 0) -1 >>> largest_number_smaller_than_x([12, 15, 14, 18, 17], 16) 15 >>> largest_number_smaller_than_x([20, 30, 40, 50], 10) -1 ```","solution":"from typing import List def largest_number_smaller_than_x(arr: List[int], X: int) -> int: Returns the largest number in arr that is smaller than X. Args: arr: List[int]: a list of integers. X: int: the target value. Returns: int: The largest number in the list less than `X` or -1 if no such number exists. max_num = -1 for num in arr: if num < X: max_num = max(max_num, num) return max_num"},{"question":"# Problem Statement You are given a positive integer `n` representing the number of stairs. You need to write a function `ways_to_climb_stairs(n: int) -> int:` that computes the number of distinct ways to climb to the top. You can either climb 1 or 2 steps at a time. # Inputs - A single integer `n` representing the number of stairs where ( 1 leq n leq 50 ). # Outputs - Returns an integer representing the number of distinct ways to reach the top. # Constraints & Performance - ( 1 leq n leq 50 ) - Time Complexity: Ideally O(n) - Space Complexity: O(1) for storing intermediate results. # Scenario for Context You are training for a marathon and have a staircase with a certain number of steps `n`. Each time you practice, you can choose to take either one step or two steps at a time. Calculate the number of distinct ways you can reach the top of the stairs, which will help you plan your training schedule. # Sample Tests **Input**: ```python assert ways_to_climb_stairs(1) == 1 assert ways_to_climb_stairs(2) == 2 assert ways_to_climb_stairs(3) == 3 assert ways_to_climb_stairs(4) == 5 ``` **Explanation**: - For 1 stair, there is only 1 way: [1] - For 2 stairs, there are 2 ways: [1+1], [2] - For 3 stairs, there are 3 ways: [1+1+1], [1+2], [2+1] - For 4 stairs, there are 5 ways: [1+1+1+1], [1+1+2], [1+2+1], [2+1+1], [2+2]","solution":"def ways_to_climb_stairs(n: int) -> int: Returns the number of distinct ways to climb to the top of a staircase with `n` steps, given that at each step, you can either climb 1 or 2 steps. if n == 1: return 1 if n == 2: return 2 first = 1 # represents the number of ways to reach the first step second = 2 # represents the number of ways to reach the second step for i in range(3, n + 1): current = first + second first = second second = current return second"},{"question":"# Scenario You are developing a utility for managing a collection of books in a digital library. One useful feature is to generate statistics about the collection, such as counting how many distinct authors are present. # Task Implement a function that takes a list of strings, representing book titles and their respective authors in the format `\\"Title by Author\\"`, and returns the number of distinct authors in the collection. # Function Signature ```python def count_distinct_authors(books: List[str]) -> int: pass ``` # Input * `books` (list of strings): A list where each string is in the format `\\"Title by Author\\"`. # Output * An integer representing the number of distinct authors. # Constraints * The list can contain up to 1000 book entries. * Each string in the list will be in the format `\\"Title by Author\\"`, where \\"Title\\" can contain any characters except \\" by \\" (note the spaces), and \\"Author\\" can contain any characters except for newline characters. * The function should treat authors with the same name as distinct if their names appear differently in the list (even due to differences in capitalization, spaces, or punctuation). # Examples ```python assert count_distinct_authors([\\"The Great Gatsby by F. Scott Fitzgerald\\", \\"To Kill a Mockingbird by Harper Lee\\", \\"1984 by George Orwell\\", \\"Go Set a Watchman by Harper Lee\\"]) == 3 assert count_distinct_authors([\\"In Search of Lost Time by Marcel Proust\\", \\"Ulysses by James Joyce\\", \\"Don Quixote by Miguel de Cervantes\\", \\"One Hundred Years of Solitude by Gabriel Garcia Marquez\\"]) == 4 assert count_distinct_authors([]) == 0 assert count_distinct_authors([\\"Sample Book by Sample Author\\", \\"Another Book by Sample Author\\"]) == 1 ``` Implement this function in the function `count_distinct_authors`.","solution":"from typing import List def count_distinct_authors(books: List[str]) -> int: Returns the number of distinct authors in a list of books. Each book is in the format \\"Title by Author\\". authors = set() for book in books: title, author = book.rsplit(\\" by \\", 1) authors.add(author) return len(authors)"},{"question":"# Problem Description You are given a basic implementation of a `Trie` in Python. Your task is to enhance the existing code to support an additional feature: **Longest Prefix Matching**. The longest prefix matching should find the longest prefix of a given word that is present in the trie. This feature is particularly useful in applications like IP routing or text processing. # Objective Implement a method in the `Trie` class called `longest_prefix_match` that takes a string `word` and returns the longest prefix of that word present in the trie. # Input * A `Trie` instance representing the root of the trie. * A string `word`. # Output * A string representing the longest prefix of the input `word` present in the trie. # Constraints * The `word` will consist of lowercase English letters only. * The words stored in the trie will consist of lowercase English letters only. * The trie might contain up to 1000 words. # Example Given the trie built with the words [\\"inter\\", \\"internet\\", \\"internal\\", \\"intern\\", \\"into\\", \\"int\\", \\"in\\"]: ```python trie = Trie() trie.insert_many([\\"inter\\", \\"internet\\", \\"internal\\", \\"intern\\", \\"into\\", \\"int\\", \\"in\\"]) ``` Calling `trie.longest_prefix_match(\\"internetting\\")` should return: ``` \\"internet\\" ``` Calling `trie.longest_prefix_match(\\"internship\\")` should return: ``` \\"intern\\" ``` # Implementation Notes 1. Traverse the trie, following the nodes that match the given word character by character. 2. Keep track of the last position where the word matched exactly a prefix in the trie. # Code Template ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def insert_many(self, words: list[str]): for word in words: self.insert(word) def longest_prefix_match(self, word: str) -> str: Find the longest prefix of the given word that is present in the trie. Args: word (str): the word to search with. Returns: str: the longest prefix found in the trie. current = self.root prefix = \\"\\" longest_prefix = \\"\\" for char in word: if char in current.children: prefix += char current = current.children[char] if current.is_end_of_word: longest_prefix = prefix else: break return longest_prefix # Example usage trie = Trie() trie.insert_many([\\"inter\\", \\"internet\\", \\"internal\\", \\"intern\\", \\"into\\", \\"int\\", \\"in\\"]) print(trie.longest_prefix_match(\\"internetting\\")) # Output should be \\"internet\\" print(trie.longest_prefix_match(\\"internship\\")) # Output should be \\"intern\\" ``` # Requirements * Ensure the function operates efficiently with the given constraints. * Handle edge cases appropriately, such as no prefix matching the word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def insert_many(self, words): for word in words: self.insert(word) def longest_prefix_match(self, word: str) -> str: Find the longest prefix of the given word that is present in the trie. Args: word (str): the word to search with. Returns: str: the longest prefix found in the trie. current = self.root prefix = \\"\\" longest_prefix = \\"\\" for char in word: if char in current.children: prefix += char current = current.children[char] if current.is_end_of_word: longest_prefix = prefix else: break return longest_prefix # Example usage trie = Trie() trie.insert_many([\\"inter\\", \\"internet\\", \\"internal\\", \\"intern\\", \\"into\\", \\"int\\", \\"in\\"]) print(trie.longest_prefix_match(\\"internetting\\")) # Output should be \\"internet\\" print(trie.longest_prefix_match(\\"internship\\")) # Output should be \\"intern\\""},{"question":"# Scenario: You are developing a tool for an online bookstore that needs to manage and track the inventory of books in the store. The inventory consists of various books, each identified by a unique ISBN number. The objective is to maintain an efficient inventory system that allows adding, removing, and searching for books. # Task: Write a class `BookInventory` that supports the following operations: 1. `add_book(isbn: str, title: str, author: str, quantity: int) -> None`: Adds a new book to the inventory or increases the quantity if the book already exists. 2. `remove_book(isbn: str) -> None`: Removes a book from the inventory based on the ISBN. If the book does not exist, print an appropriate error message. 3. `search_book(isbn: str) -> str`: Searches for a book by ISBN and returns its details as a formatted string. If the book is not found, return \\"Book not found\\". # Requirements: 1. The inventory should be stored as a dictionary where the key is the ISBN and the value is a dictionary containing the title, author, and quantity of the book. 2. Error handling should be incorporated to manage invalid operations, such as removing a non-existent book. 3. The search function should return a string that includes the title, author, and quantity of the book. # Example: ```python class BookInventory: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str, quantity: int) -> None: pass # Implement the function here def remove_book(self, isbn: str) -> None: pass # Implement the function here def search_book(self, isbn: str) -> str: pass # Implement the function here # Example usage: inventory = BookInventory() inventory.add_book(\\"978-3-16-148410-0\\", \\"The Example Book\\", \\"John Doe\\", 5) print(inventory.search_book(\\"978-3-16-148410-0\\")) # Should return book details inventory.remove_book(\\"978-3-16-148410-0\\") print(inventory.search_book(\\"978-3-16-148410-0\\")) # Should return \\"Book not found\\" ``` Input: - `isbn`: A string representing the unique ISBN number of the book. - `title`: A string representing the title of the book. - `author`: A string representing the author of the book. - `quantity`: An integer representing the quantity of the book. Output: - The `add_book` and `remove_book` methods do not return anything. - The `search_book` method returns a string with the book\'s details or an error message. Constraints: - The ISBN numbers are unique and valid. - Quantities are non-negative integers. - The maximum number of books in the inventory is 1,000.","solution":"class BookInventory: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str, quantity: int) -> None: if isbn in self.inventory: self.inventory[isbn][\'quantity\'] += quantity else: self.inventory[isbn] = {\'title\': title, \'author\': author, \'quantity\': quantity} def remove_book(self, isbn: str) -> None: if isbn in self.inventory: del self.inventory[isbn] else: print(\\"Error: Book not found\\") def search_book(self, isbn: str) -> str: if isbn in self.inventory: book = self.inventory[isbn] return f\\"Title: {book[\'title\']}, Author: {book[\'author\']}, Quantity: {book[\'quantity\']}\\" else: return \\"Book not found\\""},{"question":"# Salary Bracket Calculator You have been tasked with implementing a function to calculate the salary bracket for employees based on their annual salary. These brackets help categorize employee salaries for various analysis purposes. **Task**: Implement a function `salary_bracket` within the `Employee` class that returns the salary bracket for an employee. Here is the salary bracket list: - \'Low\' for salaries less than 30,000 - \'Medium\' for salaries ranging from 30,000 to 70,000 - \'High\' for salaries ranging from 70,001 to 150,000 - \'Very High\' for salaries above 150,000 **Objective**: You need to define this method so that it accurately classifies the employee\'s salary into one of the above brackets. **Input/Output**: * **Input**: The method will use an existing attribute `self.salary`. * **Output**: A string representing the salary bracket. **Constraints**: * `self.salary` is an integer representing an annual salary in dollars. * Assume salaries provided are all non-negative integers. **Scenario**: You are assisting the HR department in classifying employee salaries to generate a report on salary distribution across different brackets. Example: ```python class Employee: def __init__(self, name, salary): self.name = name self.salary = salary def salary_bracket(self): Determines the salary bracket for the employee. :return: A string representing the salary bracket. if self.salary < 30000: return \'Low\' elif 30000 <= self.salary <= 70000: return \'Medium\' elif 70001 <= self.salary <= 150000: return \'High\' else: return \'Very High\' # Example Usage employee1 = Employee(\'Alice\', 25000) employee2 = Employee(\'Bob\', 50000) employee3 = Employee(\'Charlie\', 125000) employee4 = Employee(\'Diana\', 200000) print(employee1.salary_bracket()) # Output: \'Low\' print(employee2.salary_bracket()) # Output: \'Medium\' print(employee3.salary_bracket()) # Output: \'High\' print(employee4.salary_bracket()) # Output: \'Very High\' ``` Add your method definition to the `Employee` class and verify its correctness based on the provided examples.","solution":"class Employee: def __init__(self, name, salary): self.name = name self.salary = salary def salary_bracket(self): Determines the salary bracket for the employee based on the given brackets. :return: A string representing the salary bracket. if self.salary < 30000: return \'Low\' elif 30000 <= self.salary <= 70000: return \'Medium\' elif 70001 <= self.salary <= 150000: return \'High\' else: return \'Very High\' # Example Usage employee1 = Employee(\'Alice\', 25000) employee2 = Employee(\'Bob\', 50000) employee3 = Employee(\'Charlie\', 125000) employee4 = Employee(\'Diana\', 200000) print(employee1.salary_bracket()) # Output: \'Low\' print(employee2.salary_bracket()) # Output: \'Medium\' print(employee3.salary_bracket()) # Output: \'High\' print(employee4.salary_bracket()) # Output: \'Very High\'"},{"question":"# Context You are developing a file system utility that archives files based on their size. To make your tool efficient, you need to implement a function that sorts the filenames by their sizes using the Quick Sort algorithm. This will enable the tool to effectively group and compress files of similar sizes together. # Objective Implement the Quick Sort algorithm to sort a list of files by their sizes. Your function should be capable of handling files of varying sizes and ensure stable sorting. # Function Signature ```python def quick_sort_files(files: list[tuple[str, int]]) -> list[tuple[str, int]]: Sorts a list of files by their sizes using the Quick Sort algorithm. :param files: List of tuples, where each tuple contains the filename as a string and the file size as an integer :return: List of tuples sorted by file sizes in ascending order Example: >>> files = [(\'file1.txt\', 1200), (\'file2.txt\', 500), (\'file3.txt\', 1500)] >>> quick_sort_files(files) [(\'file2.txt\', 500), (\'file1.txt\', 1200), (\'file3.txt\', 1500)] >>> files = [(\'img1.jpg\', 204800), (\'audio1.mp3\', 5120), (\'video1.mp4\', 1048576)] >>> quick_sort_files(files) [(\'audio1.mp3\', 5120), (\'img1.jpg\', 204800), (\'video1.mp4\', 1048576)] ``` # Constraints and Requirements 1. The input list `files` contains non-empty tuples where the first element is a filename (string) and the second element is its size (positive integer). 2. The sorting should be done based on the file sizes in ascending order. 3. The function should handle empty input gracefully by returning an empty list. 4. The implementation of Quick Sort should ensure a worst-case time complexity of (O(n^2)) with typical expected time complexity of (O(n log n)). # Performance 1. Ensure the function is efficient and avoids unnecessary memory usage. 2. Maintain stable sorting wherever possible (i.e., files with the same size should retain their relative ordering). # Examples - Input: `[(\'file1.txt\', 1200), (\'file2.txt\', 500), (\'file3.txt\', 1500)]` Output: `[(\'file2.txt\', 500), (\'file1.txt\', 1200), (\'file3.txt\', 1500)]` - Input: `[(\'doc1.docx\', 1024), (\'doc2.docx\', 1024), (\'doc3.pdf\', 2560)]` Output: `[(\'doc1.docx\', 1024), (\'doc2.docx\', 1024), (\'doc3.pdf\', 2560)]` - Input: `[]` Output: `[]` # Notes - Implement the Quick Sort algorithm with the ability to handle various sizes effectively. - The filenames should not be altered or split during the sorting process; only their order should change. - Verify your implementation with diverse test cases, ensuring consistent performance and correctness across different file size distributions.","solution":"def quick_sort_files(files): Sorts a list of files by their sizes using the Quick Sort algorithm. :param files: List of tuples, where each tuple contains the filename as a string and the file size as an integer :return: List of tuples sorted by file sizes in ascending order if len(files) <= 1: return files pivot = files[0] left = [file for file in files[1:] if file[1] < pivot[1]] right = [file for file in files[1:] if file[1] >= pivot[1]] return quick_sort_files(left) + [pivot] + quick_sort_files(right)"},{"question":"# Problem Statement: You are given a set of points on a 2D plane, and your task is to determine whether there is a straight line that passes through at least three of these points. If such a line exists, return any one of the points on this line as a tuple. Otherwise, return `None`. # Function Signature: ```python def find_collinear_points(points: List[Tuple[int, int]]) -> Optional[Tuple[int, int]]: pass ``` # Input: * `points`: A list of tuples, where each tuple represents the coordinates of a point on the 2D plane. The length of the list `points` can range from 3 to 1000. Each coordinate is an integer (`-10^4 <= x, y <= 10^4`). # Output: * Return a tuple representing one of the points on a line that passes through at least three of the given points. If no such line exists, return `None`. # Constraints: * Efficiently check for collinear points considering the constraints. * Handle edge cases with overlapping points and different point distributions. # Example: ```python assert find_collinear_points([(0, 0), (1, 1), (2, 2), (3, 5)]) == (0, 0) or (1, 1) or (2, 2) assert find_collinear_points([(0, 0), (1, 1), (1, 0), (2, 2), (3, 3)]) == (0, 0) or (1, 1) or (2, 2) or (3, 3) assert find_collinear_points([(0, 0), (0, 1), (1, 1), (1, 0)]) == None assert find_collinear_points([(0, 0), (-3, -3), (-1, -1), (2, 2)]) == (0, 0) or (-3, -3) or (-1, -1) or (2, 2) ``` # Note: - You should implement a solution that checks collinearity using the properties of slopes or cross multiplication. - Ensure the solution can handle up to 1000 points efficiently, considering all combinations that might be required to check for collinearity. # Helper Function: To assist with the development, you may find it helpful to implement a helper function to check whether three points are collinear: ```python def is_collinear(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool: # Calculate whether the three points are collinear using the area formula or slope comparison pass ``` This helper function can then be used within the main function to find three collinear points. This setup offers a comprehensive assessment of understanding and implementing geometric algorithms while ensuring solutions are efficient and handle various edge cases.","solution":"from typing import List, Tuple, Optional def is_collinear(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool: # Use cross product to check area of triangle formed by p1, p2, p3. If zero, they are collinear. (x1, y1), (x2, y2), (x3, y3) = p1, p2, p3 return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def find_collinear_points(points: List[Tuple[int, int]]) -> Optional[Tuple[int, int]]: n = len(points) for i in range(n): for j in range(i + 1, n): count = 0 third_point = None for k in range(n): if i != k and j != k and is_collinear(points[i], points[j], points[k]): count += 1 third_point = points[k] if count >= 1: # checking for at least one more third point return points[i] return None"},{"question":"# Coding Assessment Question You are given a list of integers that represent the heights of a series of buildings with windows facing the west. Write a function `number_of_windows_with_views(buildings: List[int]) -> int` that calculates the number of windows that have an unobstructed view of the sunset. A window has an unobstructed view if all buildings to its right are shorter than the building in question. The function should use an efficient approach to solve this problem. Implement and compare your function\'s performance with a less efficient approach to ensure correctness and efficiency. Measure their execution time and provide comparisons for demonstration. # Input - A list of integers `buildings` where each element represents the height of a building. # Output - An integer representing the number of windows with unobstructed views of the sunset. # Constraints - The length of the list can be up to 10^5. - The heights of the buildings will be between 1 and 10^6. Here is the skeleton of the function you need to implement: ```python from typing import List def number_of_windows_with_views(buildings: List[int]) -> int: # Your implementation here pass def test_number_of_windows_with_views(): # Your test cases here pass if __name__ == \\"__main__\\": test_number_of_windows_with_views() ``` # Example ```python buildings1 = [3, 7, 8, 3, 6, 1] print(number_of_windows_with_views(buildings1)) # Output: 3 buildings2 = [1, 4, 5, 8] print(number_of_windows_with_views(buildings2)) # Output: 1 buildings3 = [8, 7, 6, 5, 4, 3, 2, 1] print(number_of_windows_with_views(buildings3)) # Output: 8 large_buildings = generate_large_buildings_list() # List length will be 10^5 print(number_of_windows_with_views(large_buildings)) # Output should be tested for large input performance ``` # Performance Comparison Measure the execution time of your efficient function and compare it against a naive method like the one provided in the reference code snippet. Discuss the performance results in your comments.","solution":"from typing import List def number_of_windows_with_views(buildings: List[int]) -> int: Calculate the number of windows with unobstructed views of the sunset. Args: buildings (List[int]): List of building heights. Returns: int: Number of windows with unobstructed views. count = 0 max_height = 0 # Iterate from right to left for height in reversed(buildings): if height > max_height: count += 1 max_height = height return count # Less efficient approach for comparison def number_of_windows_with_views_naive(buildings: List[int]) -> int: count = 0 n = len(buildings) for i in range(n): unobstructed = True for j in range(i+1, n): if buildings[j] >= buildings[i]: unobstructed = False break if unobstructed: count += 1 return count"},{"question":"# Question: Validate and Repair a List of Strings In this task, you need to write a Python function that takes a list of strings and validates if each string meets certain criteria. If a string is valid, it remains unchanged; if it is invalid, it should be repaired according to specific rules and added to the list of results. Function Signature ```python def validate_and_repair_strings(strings: List[str]) -> List[str]: pass ``` Input * `strings` (List[str]): A list of strings to be validated and potentially repaired. Each string will have a length between 1 and 1000 characters. Output * A list of strings where each string is either an original string (if valid) or a repaired string (if invalid). Validation and Repair Rules 1. A valid string: * Contains only alphanumeric characters (a-z, A-Z, 0-9). 2. Invalid characters (non-alphanumeric) must be replaced by the underscore character (\'_\'). Constraints * 1 <= len(strings) <= 10^4 * 1 <= len(strings[i]) <= 1000 Example ```python # Test Case 1 assert validate_and_repair_strings([\\"hello\\", \\"world!\\", \\"python3\\"]) == [\\"hello\\", \\"world_\\", \\"python3\\"] # Test Case 2 assert validate_and_repair_strings([\\"valid_string\\", \\"not@valid@\\", \\"spaces are invalid\\"]) == [\\"valid_string\\", \\"not_valid_\\", \\"spaces_are_invalid\\"] # Test Case 3 assert validate_and_repair_strings([\\"\\", \\"1234567890\\", \\"A-Z\\"]) == [\\"\\", \\"1234567890\\", \\"A_Z\\"] ``` Implementation Requirements * The resulting list must maintain the original order of the input strings. * Ensure proper handling of cases where strings are empty or contain no invalid characters. # Note Do not use any pre-existing Python library functions that automatically repair or validate strings. Tips * Utilize Python string methods and properties. * The function should perform efficiently even with large input sizes.","solution":"from typing import List def validate_and_repair_strings(strings: List[str]) -> List[str]: result = [] for string in strings: repaired_string = \'\'.join(char if char.isalnum() else \'_\' for char in string) result.append(repaired_string) return result"},{"question":"# Problem Statement You are given an integer array `nums` and an integer `k`. Your task is to write a function `max_subarray_len(nums: List[int], k: int) -> int` that finds the maximum length of a subarray that sums to `k`. If there isn\'t one, return 0 instead. # Expected Input and Output * **Input**: * `nums` (List[int]): A list of integers. * `k` (int): An integer representing the sum you are checking for. * **Output**: * Return the maximum length of a subarray that sums to `k`. If no such subarray exists, return 0. # Constraints * The length of the `nums` array will be in the range [1, 10^5]. * Each element in the `nums` array will be an integer in the range [-10^4, 10^4]. * The integer `k` will be in the range [-10^9, 10^9]. # Example Input & Output *Example 1*: ```python nums = [1, -1, 5, -2, 3] k = 3 max_subarray_len(nums, k) ``` *Output*: ```python 4 ``` *Example 2*: ```python nums = [-2, -1, 2, 1] k = 1 max_subarray_len(nums, k) ``` *Output*: ```python 2 ``` *Example 3*: ```python nums = [1, 2, 3] k = 6 max_subarray_len(nums, k) ``` *Output*: ```python 3 ``` # Performance Requirements * The solution should aim for a time complexity of O(n) to handle the largest inputs within reasonable time limits. # Scenario for Consideration Imagine you are working on data analysis software that needs to identify time periods where a certain metric stays within specific target values. For example, identifying periods of time where temperature fluctuations stay within a target range is crucial in climate study. Using the above function, find the longest duration in which the sum of daily temperature changes hits a given target consistently.","solution":"def max_subarray_len(nums, k): Finds the maximum length of a subarray that sums to k. Parameters: nums (List[int]): A list of integers. k (int): The target sum. Returns: int: The maximum length of a subarray that sums to k. If no such subarray exists, return 0. prefix_sum = 0 hash_map = {0: -1} max_len = 0 for i in range(len(nums)): prefix_sum += nums[i] if prefix_sum - k in hash_map: max_len = max(max_len, i - hash_map[prefix_sum - k]) if prefix_sum not in hash_map: hash_map[prefix_sum] = i return max_len"},{"question":"Create a function that simulates an elevator operating in a building. Your function should manage the state of the elevator (current floor, direction, and pending requests) and process incoming requests for floor stops in an efficient manner. # Function to Implement Implement a class `Elevator` with the following methods: 1. `__init__(self, num_floors: int) -> None`: Initializes the elevator for a building with the given number of floors `num_floors`. 2. `request(self, floor: int) -> None`: Adds a new floor request to the elevator\'s queue. Ensure that the request is valid, i.e., within the range of floors. 3. `step(self) -> None`: Moves the elevator one step in its current direction: * If moving up, it should move to the next higher floor, if possible. * If moving down, it should move to the next lower floor, if possible. * If there are no higher floors or lower floors to move to, or no pending requests, the elevator should stop and wait. 4. `state(self) -> dict`: Returns a dictionary containing the current state of the elevator with the following fields: - \\"current floor\\" - \\"direction\\" (one of \\"up\\", \\"down\\", or \\"idle\\") - \\"pending requests\\" (a sorted list of pending floor requests) # Constraints * There must be a minimum of 2 and a maximum of 100 floors. * Floor requests should be processed in the order they were added, with the elevator prioritizing its current direction of travel. * If the elevator is idle and receives a new request, it should start moving towards that request. # Expected Input and Output * **Initialization**: `Elevator(10)` initializes an elevator in a building with 10 floors. * **Floor Request**: `request(5)` adds a request to move to the 5th floor. * **Move Step**: `step()` moves the elevator one step according to the pending requests and current direction. * **Elevator State**: `state()` returns the current state of the elevator. # Example ```python elevator = Elevator(5) elevator.request(3) elevator.step() print(elevator.state()) ``` Expected output: ```python { \\"current floor\\": 2, \\"direction\\": \\"up\\", \\"pending requests\\": [3] } ``` If the elevator is at the 1st floor and it receives a request to the 3rd floor: ```python elevator = Elevator(5) elevator.request(3) for _ in range(3): elevator.step() print(elevator.state()) ``` Expected output: ```python { \\"current floor\\": 3, \\"direction\\": \\"idle\\", \\"pending requests\\": [] } ``` The elevator should handle multiple requests and should resume from an idle state upon receiving new requests. It should also deal with edge cases like receiving requests for the current floor or out-of-bound floor requests.","solution":"class Elevator: def __init__(self, num_floors: int) -> None: if num_floors < 2 or num_floors > 100: raise ValueError(\\"Number of floors must be between 2 and 100.\\") self.num_floors = num_floors self.current_floor = 1 self.direction = \\"idle\\" self.pending_requests = set() def request(self, floor: int) -> None: if floor < 1 or floor > self.num_floors: raise ValueError(\\"Requested floor is out of bounds.\\") if floor != self.current_floor: self.pending_requests.add(floor) if self.direction == \\"idle\\": self._update_direction() def step(self) -> None: if not self.pending_requests: self.direction = \\"idle\\" return if self.direction == \\"up\\": self.current_floor += 1 elif self.direction == \\"down\\": self.current_floor -= 1 if self.current_floor in self.pending_requests: self.pending_requests.remove(self.current_floor) self._update_direction() def _update_direction(self) -> None: if not self.pending_requests: self.direction = \\"idle\\" return if self.direction in [\\"idle\\", \\"up\\"] and any(floor > self.current_floor for floor in self.pending_requests): self.direction = \\"up\\" elif self.direction in [\\"idle\\", \\"down\\"] and any(floor < self.current_floor for floor in self.pending_requests): self.direction = \\"down\\" else: self.direction = \\"idle\\" def state(self) -> dict: return { \\"current floor\\": self.current_floor, \\"direction\\": self.direction, \\"pending requests\\": sorted(self.pending_requests), }"},{"question":"# Coding Assessment Question **Context**: You are working on a software application for data analysis that requires efficient manipulation of large datasets. Specifically, you need to perform operations on sequences of numerical data represented as lists. One commonly required operation is to smoothen the data by applying a moving average filter. # Task Your task is to implement a function that applies a moving average filter of a given window size to a sequence of numbers, with the added twist of handling edge cases where the window extends beyond the boundaries of the list. **Specifications**: 1. Implement the function `moving_average_filter(data, window_size)` that computes the moving average of a list of numbers. - Parameters: * `data`: List of numerical values. * `window_size`: An integer representing the number of elements to include in the moving average. - Returns: A list of numerical values representing the smoothed data. **Steps**: 1. Replace each element in the list with the average of the elements within the window centered at that element. 2. If the window extends beyond the edges of the list, include only the elements that exist within the range. **Constraints**: - `data` is a list of `n` integers or floats (`1 <= n <= 10^5`). - `window_size` is an odd integer (`1 <= window_size <= n`). **Example**: ```python data = [1, 2, 3, 4, 5, 6, 7, 8, 9] window_size = 3 # Expected output: [1.5, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 8.5] moving_average_filter(data, window_size) ``` **Note**: - The moving average at the first element would be computed as the average of the first two elements since there is no element before the first element. - Similarly, the moving average at the last element would be the average of the last two elements only. - Ensure the handling of edge cases where the window might partially extend beyond the boundaries of the list.","solution":"def moving_average_filter(data, window_size): Applies a moving average filter to the given data with the specified window size. Parameters: - data: List of numerical values. - window_size: An integer representing the number of elements to include in the moving average. Returns: A list of numerical values representing the smoothed data. n = len(data) half_window = window_size // 2 smoothed_data = [] for i in range(n): start_index = max(i - half_window, 0) end_index = min(i + half_window + 1, n) window_elements = data[start_index:end_index] average = sum(window_elements) / len(window_elements) smoothed_data.append(average) return smoothed_data"},{"question":"# Scenario You have been hired as a software developer to optimize a customer support system. A part of your task involves analyzing chat transcripts to identify frequent patterns in customer queries. Specifically, you need to identify the most frequently occurring words (excluding common stop words) in a given chat transcript. # Problem Statement Write a Python function `common_queries(transcript: str, stop_words: List[str]) -> List[str]` to determine the most frequently occurring words in a given chat transcript, excluding a provided list of stop words. Additionally, implement a function `top_n_common_queries(transcript: str, stop_words: List[str], n: int) -> List[str]` that returns the top `n` most frequent non-stop words. # Requirements 1. **Input/Output Specifications**: * `common_queries(transcript: str, stop_words: List[str]) -> List[str]`: Returns a list of the most frequent non-stop words in the transcript. * `top_n_common_queries(transcript: str, stop_words: List[str], n: int) -> List[str]`: Returns a list of the top `n` most frequent non-stop words in the transcript. 2. **Constraints**: * You may assume all words are separated by spaces and are case insensitive. * Remove punctuation (.,!?) before processing the words. * Consider words with a length of at least 2 characters for frequency counting. * Assume `1 <= len(transcript) <= 1000000` and `0 <= len(stop_words) <= 1000`. 3. **Performance Requirements**: * The implementation should be optimized to handle large transcripts efficiently. # Example ```python from typing import List def common_queries(transcript: str, stop_words: List[str]) -> List[str]: # Your implementation here def top_n_common_queries(transcript: str, stop_words: List[str], n: int) -> List[str]: # Your implementation here # Example usage: transcript = \\"Hello! How can I help you today? Please wait a moment... Thank you for waiting. How can I assist you?\\" stop_words = [\\"how\\", \\"can\\", \\"i\\", \\"you\\", \\"for\\"] print(common_queries(transcript, stop_words)) # Output: [\'help\', \'today\', \'please\', \'wait\', \'moment\', \'thank\', \'waiting\', \'assist\'] print(top_n_common_queries(transcript, stop_words, 3)) # Output: [\'help\', \'today\', \'please\'] ``` # Notes 1. You may use helper functions if necessary. 2. Normalize all words to lowercase before processing. 3. Ensure your solution is efficiently implemented to handle large transcripts.","solution":"from typing import List from collections import Counter import re def preprocess_transcript(transcript: str, stop_words: List[str]) -> List[str]: # Convert transcript to lowercase transcript = transcript.lower() # Remove punctuation transcript = re.sub(r\'[^ws]\', \'\', transcript) # Split into words words = transcript.split() # Filter out stop words and single character words words = [word for word in words if word not in stop_words and len(word) > 1] return words def common_queries(transcript: str, stop_words: List[str]) -> List[str]: words = preprocess_transcript(transcript, stop_words) word_counts = Counter(words) if not word_counts: return [] max_count = max(word_counts.values()) most_common_words = [word for word, count in word_counts.items() if count == max_count] return most_common_words def top_n_common_queries(transcript: str, stop_words: List[str], n: int) -> List[str]: words = preprocess_transcript(transcript, stop_words) word_counts = Counter(words) return [word for word, _count in word_counts.most_common(n)]"},{"question":"Task Implement a Function to Determine the Bead Representation of a Number # Objective You need to design a function that converts an integer into its representation using the \\"Abacus Bead\\" format. The abacus representation follows a specific pattern which you need to carefully emulate. # Problem Statement Write a function `abacus_bead_representation(number: int) -> str` that takes any non-negative integer and converts it into a string representation showing how it would look on a traditional abacus, using `|` for the rod, `O` for the beads, and `-` for the frame support. # Implementation Details 1. **Input**: A non-negative integer. 2. **Output**: A string that represents the given number in abacus bead form. # Function Signature ```python def abacus_bead_representation(number: int) -> str: pass ``` # Constraints 1. The input number will be from 0 up to 9999999 (inclusive). 2. Each level of the abacus contains a single rod that can count up to 9 beads. # Example ```python number = 1234567 expected_output = ( \'O--------|n\' \'O-------------|n\' \'O----------------|n\' \'O-------------------|n\' \'O----------------------|n\' \'O-------------------------|n\' \'O----------------------------|n\' ) assert abacus_bead_representation(number) == expected_output ``` # Description 1. **Design**: Each abacus rod represents a single digit of the given number. 2. **Output Format**: - Each rod is displayed in a new line. - Beads (\'O\') are positioned left to the rod (\'|\'), and remaining positions to the right are filled with hyphens (\'-\'). **Example**: For the number `123`, the abacus representation would look as follows: ``` \'|O-------------------------n\' \'|OOO----------------------n\' \'|OOOOOOOO-----------------n\' ``` **Steps**: 1. Convert the number to its string form to process each digit. 2. For each digit, create a row of the abacus using the proper number of beads and filling hyphens. 3. Join all rows to form the final output string. Your function should efficiently handle the formatting and ensure the abacus representation is precise according to the example provided. # Notes - Handle leading zeroes in the number properly by ensuring the corresponding abacus rod shows no beads if the digit is `0`. - Ensure the output string has each rod on a new line, following the abacus pattern strictly. Verify your implementation with several test cases, ranging from edge cases like `0` and `9999999` to random intermediate values, to ensure accuracy and robustness.","solution":"def abacus_bead_representation(number: int) -> str: Returns the abacus bead representation of a non-negative integer. number_str = str(number).zfill(7) abacus_representation = [] for digit in number_str: beads = int(digit) line = \'O\' * beads + \'-\' * (9 - beads) + \'|\' abacus_representation.append(line) return \'n\'.join(abacus_representation)"},{"question":"# Word Frequency Counter You are provided with a class `WordFrequencyCounter` that will read a text file and count the occurrences of each word in the file. Enhance the functionality of the `WordFrequencyCounter` class by implementing the following methods: 1. **most_common(n)**: Returns the `n` most common words in the text along with their counts. 2. **least_common(n)**: Returns the `n` least common words in the text along with their counts. 3. **total_unique_words()**: Returns the total number of unique words in the text. 4. **frequency(word)**: Returns the frequency of the specified `word` in the text. # Specification Method Signature ```python def most_common(self, n: int) -> list[tuple[str, int]] def least_common(self, n: int) -> list[tuple[str, int]] def total_unique_words(self) -> int def frequency(self, word: str) -> int ``` Input * For `most_common(n)` and `least_common(n)`, `n` is an integer indicating the number of words to return. * For `frequency(word)`, `word` is a string representing the word whose frequency needs to be determined. * The class should read from a text file for initializing word counts. Output * `most_common(n)` returns a list of tuples where each tuple contains a word and its frequency, sorted by the highest frequency. * `least_common(n)` returns a list of tuples where each tuple contains a word and its frequency, sorted by the lowest frequency. * `total_unique_words()` returns an integer representing the number of unique words in the text. * `frequency(word)` returns an integer representing the frequency of the specified word in the text. # Constraints * Words are case-insensitive and punctuation should be ignored (e.g., \\"Word\\", \\"word,\\", and \\"word.\\" should all be considered the same). * The number of words in the file can be large, so your implementation should handle large texts efficiently. # Example: ```python # Assume \'text.txt\' contains the following text: # \\"This is a test. This test is only a test.\\" wfc = WordFrequencyCounter(\'text.txt\') assert wfc.total_unique_words() == 5 # 5 unique words: \\"This\\", \\"is\\", \\"a\\", \\"test\\", \\"only\\" assert wfc.frequency(\'test\') == 3 # \\"test\\" appears 3 times common_words = wfc.most_common(2) assert common_words == [(\'test\', 3), (\'is\', 2)] # Most common 2 words least_words = wfc.least_common(2) assert least_words == [(\'this\', 2), (\'only\', 1)] # Least common 2 words ``` Use this structure to implement the required methods for the `WordFrequencyCounter` class.","solution":"from collections import Counter import re class WordFrequencyCounter: def __init__(self, filepath): self.filepath = filepath self.word_counts = self._count_words() def _count_words(self): with open(self.filepath, \'r\') as file: text = file.read().lower() words = re.findall(r\'bw+b\', text) return Counter(words) def most_common(self, n): return self.word_counts.most_common(n) def least_common(self, n): return self.word_counts.most_common()[:-n-1:-1] def total_unique_words(self): return len(self.word_counts) def frequency(self, word): return self.word_counts.get(word.lower(), 0)"},{"question":"# Context You have been tasked with implementing a function to generate a sequence of numbers based on specific rules. This sequence will be used in various calculations within a larger application. # Task Write a function `generate_sequence(n: int) -> list[int]` that generates the first `n` numbers of a specific sequence where each number is the square of its 1-based index. # Function Signature ```python def generate_sequence(n: int) -> list[int]: Generates the first \'n\' numbers of a specific sequence where each number is the square of its 1-based index. :param n: The number of elements to generate in the sequence. :return: A list of the first \'n\' numbers in the sequence. ``` # Input * `n`: An integer representing the number of elements to generate. For example: `5` # Output * A list of integers representing the sequence, where each element is the square of its 1-based index. # Constraints * 0 ≤ n ≤ 10^3 # Examples 1. Input: `5` Output: `[1, 4, 9, 16, 25]` 2. Input: `3` Output: `[1, 4, 9]` 3. Input: `0` Output: `[]` # Notes - Ensure that the function handles edge cases such as `n = 0` appropriately. - The sequence starts at index 1, meaning the calculation for the first element is 1^2, the second is 2^2, and so on.","solution":"def generate_sequence(n: int) -> list[int]: Generates the first \'n\' numbers of a specific sequence where each number is the square of its 1-based index. :param n: The number of elements to generate in the sequence. :return: A list of the first \'n\' numbers in the sequence. return [i * i for i in range(1, n + 1)]"},{"question":"# Coding Assessment Question Scenario: You are responsible for managing a parking lot system where each parking slot is identified by a unique number. This parking lot allows compact cars, sedans, and trucks to be parked. To efficiently manage the space and revenue, you need to calculate the total amount to be charged based on the type of vehicle and the number of hours it has been parked. Task: Write a Python function `calculate_parking_fee(parking_slot: int, vehicle_type: str, hours_parked: int) -> float` that: * Takes three inputs: - `parking_slot` (an integer representing the unique parking slot number), - `vehicle_type` (a string representing the type of vehicle, which could be \\"compact\\", \\"sedan\\", or \\"truck\\"), - `hours_parked` (an integer representing the number of hours the vehicle has been parked). * Calculates and returns the total parking fee based on the type of vehicle and hours parked. # Specifications: * The parking fee rates are: - \\"compact\\" cars: 5 per hour - \\"sedan\\" cars: 7 per hour - \\"truck\\": 10 per hour * **Input**: - `parking_slot` (an integer, 0 ≤ parking_slot ≤ 10^4) - `vehicle_type` (a string: \\"compact\\", \\"sedan\\", \\"truck\\") - `hours_parked` (an integer, 1 ≤ hours_parked ≤ 24) * **Output**: - A floating-point number representing the total parking fee. # Constraints: * If the `vehicle_type` is not one of \\"compact\\", \\"sedan\\", or \\"truck\\", your function should raise a `ValueError` with an appropriate error message. * If the input `parking_slot` is not an integer, your function should raise a `TypeError` with an appropriate error message. * If the input `hours_parked` is not an integer, your function should raise a `TypeError` with an appropriate error message. * If the `hours_parked` is not within the range 1 to 24 inclusive, your function should raise a `ValueError` with an appropriate error message. # Example Inputs and Outputs: 1. `calculate_parking_fee(101, \\"compact\\", 3)` should return `15.0` 2. `calculate_parking_fee(202, \\"sedan\\", 4)` should return `28.0` 3. `calculate_parking_fee(303, \\"truck\\", 5)` should return `50.0` 4. `calculate_parking_fee(404, \\"compact\\", 24)` should return `120.0` # Edge Cases and Error Handling: 1. `calculate_parking_fee(101, \\"motorcycle\\", 3)` should raise a `ValueError` with the message \\"Invalid vehicle type\\". 2. `calculate_parking_fee(101, \\"sedan\\", 0)` should raise a `ValueError` with the message \\"Invalid number of hours\\". 3. `calculate_parking_fee(\\"101\\", \\"sedan\\", 3)` should raise a `TypeError` with the message \\"Parking slot must be an integer\\". 4. `calculate_parking_fee(101, \\"sedan\\", 3.5)` should raise a `TypeError` with the message \\"Hours parked must be an integer\\". # Note: Ensure that your function can handle all edge cases as specified and that the output is accurate based on the given parking fee rates.","solution":"def calculate_parking_fee(parking_slot: int, vehicle_type: str, hours_parked: int) -> float: Calculate the total parking fee based on the type of vehicle and the number of hours parked. Parameters: - parking_slot: int, unique identifying number for the parking slot. - vehicle_type: str, type of vehicle (\\"compact\\", \\"sedan\\", \\"truck\\"). - hours_parked: int, number of hours the vehicle has been parked (1 ≤ hours_parked ≤ 24). Returns: - float, total parking fee. Raises: - ValueError: if vehicle_type is not one of \\"compact\\", \\"sedan\\", or \\"truck\\" or if hours_parked is not within the range 1 to 24 inclusive. - TypeError: if parking_slot or hours_parked is not of type int. # Validate input types if not isinstance(parking_slot, int): raise TypeError(\\"Parking slot must be an integer\\") if not isinstance(hours_parked, int): raise TypeError(\\"Hours parked must be an integer\\") # Validate vehicle_type if vehicle_type not in [\\"compact\\", \\"sedan\\", \\"truck\\"]: raise ValueError(\\"Invalid vehicle type\\") # Validate hours_parked if hours_parked < 1 or hours_parked > 24: raise ValueError(\\"Invalid number of hours\\") # Define parking fees per vehicle type rates = { \\"compact\\": 5.0, \\"sedan\\": 7.0, \\"truck\\": 10.0 } # Calculate and return the total parking fee return rates[vehicle_type] * hours_parked"},{"question":"# Question: Fibonacci Sequence Checker You are given an integer `num` and need to determine whether it belongs to the Fibonacci sequence. The Fibonacci sequence starts with 0 and 1, and the next number in the sequence is derived by adding the two previous numbers. Your task is to implement a function `is_fibonacci_number(num: int) -> bool` which checks if the given number is a Fibonacci number. Function Signature ```python def is_fibonacci_number(num: int) -> bool: pass ``` Input * A single integer `num` where `0 <= num <= 10^18`. Output * Returns `True` if the number is in the Fibonacci sequence, otherwise returns `False`. Constraints * The input `num` will always be a non-negative integer within the specified range. * The function should raise a `TypeError` if the input is not an integer. Example ```python >>> is_fibonacci_number(8) True >>> is_fibonacci_number(14) False >>> is_fibonacci_number(144) True >>> is_fibonacci_number(0) True >>> is_fibonacci_number(4.5) Traceback (most recent call last): ... TypeError: Input must be an integer >>> is_fibonacci_number(\'a\') Traceback (most recent call last): ... TypeError: Input must be an integer ``` # Scenario Imagine you are working on a software tool for mathematics education that allows students to explore various numerical sequences, including the Fibonacci sequence. By inputting a number, the tool will indicate whether the number is part of the Fibonacci sequence. Implement the function to determine this accurately, taking into account the constraints, edge cases, and requirements provided.","solution":"def is_fibonacci_number(num: int) -> bool: if not isinstance(num, int): raise TypeError(\\"Input must be an integer\\") if num < 0: return False # A number is a Fibonacci number if and only if one or both of # (5*num^2 + 4) or (5*num^2 - 4) is a perfect square def is_perfect_square(x: int) -> bool: s = int(x**0.5) return s * s == x test1 = 5 * num * num + 4 test2 = 5 * num * num - 4 return is_perfect_square(test1) or is_perfect_square(test2)"},{"question":"# Coding Assessment Question Context A group of software developers is working on a new sorting algorithm. As part of their research, they need a utility that helps validate if a permutation of an array can create a strictly increasing sequence by grouping and summing adjacent elements. Objective Write a function `can_form_increasing_sequence(arr: list[int]) -> bool` that determines if it\'s possible to rearrange the elements of the given array and form a strictly increasing sequence by repeatedly grouping and summing adjacent elements. Input and Output - **Input**: A list of integers `arr` which may contain positive, negative integers and zeroes. - **Output**: A boolean value indicating whether it is possible to rearrange the array and form a strictly increasing sequence. Constraints - The length of `arr` will be between 1 and 1000 inclusive. - Elements of `arr` can range from -100,000 to 100,000 inclusive. Performance Requirements - The solution should efficiently handle typical edge cases such as arrays with negative numbers, arrays with zeroes, and arrays with both positive and negative numbers. - Aim to design an algorithm that makes an optimal number of comparisons and checks. Example ```python def can_form_increasing_sequence(arr: list[int]) -> bool: Check if the array can be rearranged to form a strictly increasing sequence by summing adjacent elements. Args: - arr (list[int]): List of integers. Returns: - bool: True if possible, False otherwise. pass # Your implementation goes here # Example Usage arr = [1, 2, 10, 4] print(can_form_increasing_sequence(arr)) # Output: True arr = [3, 2, 6, 1] print(can_form_increasing_sequence(arr)) # Output: False ``` Notes - Ensure your implementation is robust and handles edge cases appropriately. - Focus on achieving a balance between clarity and performance in your solution.","solution":"def can_form_increasing_sequence(arr: list[int]) -> bool: Check if the array can be rearranged to form a strictly increasing sequence by summing adjacent elements. Args: - arr (list[int]): List of integers. Returns: - bool: True if possible, False otherwise. if len(arr) == 1: return True arr.sort() for i in range(len(arr) - 1): if arr[i] >= arr[i + 1]: return False return True"},{"question":"# Question: You need to implement a function `move_zeroes_to_end` that moves all the zeroes in a given list of integers to the end of the list while maintaining the relative order of the non-zero elements. The function should modify the given list in-place and should not return anything. Function Signature: ```python def move_zeroes_to_end(nums: list[int]) -> None: Move all zeroes in the list to the end while maintaining the relative order of non-zero elements. Args: nums (list[int]): A list of integers. Returns: None: The function should modify the list in-place. Raises: ValueError: If nums is not of type list or contains non-integer elements. ``` Sample Input/Output: ```python nums = [0, 1, 0, 3, 12] move_zeroes_to_end(nums) assert nums == [1, 3, 12, 0, 0] nums = [4, 2, 4, 0, 0, 3, 0, 5, 1, 0] move_zeroes_to_end(nums) assert nums == [4, 2, 4, 3, 5, 1, 0, 0, 0, 0] nums = [0, 0, 1] move_zeroes_to_end(nums) assert nums == [1, 0, 0] ``` Constraints: * The input `nums` will be a list of integers. * The list can contain positive, negative, and zero integers. * The list should be modified in-place without returning anything. * The input list will be non-empty and can contain at least one zero. Notes: * Invalid inputs must raise a `ValueError` with appropriate messages as described in the function signature. * Avoid creating any additional lists; use the given list for all modifications. * Your implementation should be efficient and handle any edge cases (e.g., lists with no zeroes, lists with all zeroes).","solution":"def move_zeroes_to_end(nums: list[int]) -> None: Move all zeroes in the list to the end while maintaining the relative order of non-zero elements. Args: nums (list[int]): A list of integers. Returns: None: The function should modify the list in-place. Raises: ValueError: If nums is not of type list or contains non-integer elements. # Validate input if not isinstance(nums, list): raise ValueError(\\"Input must be a list.\\") for num in nums: if not isinstance(num, int): raise ValueError(\\"List elements must be integers.\\") non_zero_index = 0 # Position to place the next non-zero element # Move non-zero elements to the start of the list for i in range(len(nums)): if nums[i] != 0: nums[non_zero_index] = nums[i] non_zero_index += 1 # Fill the remainder of the list with zeros for i in range(non_zero_index, len(nums)): nums[i] = 0"},{"question":"# Domino Tiling Problem You are given a grid of size `2 x N` (2 rows and N columns), and an infinite supply of 1x2 dominos, which can cover two adjacent cells either horizontally or vertically. Your task is to determine the total number of ways to completely fill the grid with these dominos. # Function Specification **Function Name**: `domino_tiling` **Parameters**: - `n` (int): the number of columns in the grid, where 1 ≤ `n` ≤ 100. **Returns**: - `int`: the number of distinct ways to tile the grid completely with 1x2 dominos. **Expected Input/Output**: ```python def domino_tiling(n: int) -> int: ``` **Example**: ```python >>> domino_tiling(2) 2 >>> domino_tiling(3) 3 >>> domino_tiling(4) 5 ``` # Explanation - For `n = 2`: There are two ways to tile the grid (two horizontal dominos or two vertical dominos stacked on top of each other). - For `n = 3`: There are three ways to tile the grid: three horizontal dominos, or two dominos stacked vertically and one horizontally either at the start or the end. # Constraints - `n` will always be a positive integer within the limits: 1 ≤ `n` ≤ 100. # Guidelines 1. Consider using dynamic programming to solve this problem efficiently. 2. Recognize the recurrence relation in the domino tiling pattern. 3. Precompute results for potential values of `n` to quickly return the final answer. **Performance Requirements**: - Ensure that your implementation can handle the maximum input efficiently. - Aim to use O(n) space complexity for storing precomputed results.","solution":"def domino_tiling(n: int) -> int: Calculate the number of distinct ways to tile a 2 x N grid with 1x2 dominos. This problem can be solved using dynamic programming. Let dp[i] be the number of ways to tile a 2 x i grid. - If we place a vertical domino in the first column, then we are left with a 2 x (i - 1) grid, which can be tiled in dp[i - 1] ways. - If we place two horizontal dominos in the first two rows of the first two columns, then we are left with a 2 x (i - 2) grid, which can be tiled in dp[i - 2] ways. Thus, the recurrence relation is: dp[i] = dp[i - 1] + dp[i - 2] Base cases: dp[0] = 1 (1 way to fill a 2 x 0 grid, do nothing) dp[1] = 1 (1 way to fill a 2 x 1 grid, one vertical domino) :param n: Number of columns in the grid :return: Number of ways to tile the grid if n == 1: return 1 if n == 2: return 2 # Initialize dynamic programming table dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n]"},{"question":"# Unique IDs Generation Problem Statement You need to implement a function that takes an integer `n` and generates a list of `n` unique identifiers. Each identifier should be a string containing 8 randomly chosen alphanumeric characters (both uppercase and lowercase letters, and digits). The function should ensure the uniqueness of each identifier. Function Signature ```python import random import string def generate_unique_ids(n: int) -> list: ``` Input - `n` (int) : the number of unique identifiers to generate, where 1 <= n <= 10^3 Output - A list of `n` unique identifiers, each consisting of 8 randomly chosen alphanumeric characters. Constraints - If `n` is not an integer or if `n` is out of the specified range, raise a `ValueError` with the message \\"n must be an integer between 1 and 1000 inclusive\\". Examples ```python >>> generate_unique_ids(5) [\'a1B2c3D4\', \'e5F6g7H8\', \'i9J0k1L2\', \'m3N4o5P6\', \'q7R8s9T0\'] >>> generate_unique_ids(1) [\'x1Y2z3A4\'] >>> generate_unique_ids(\'two\') Traceback (most recent call last): ... ValueError: n must be an integer between 1 and 1000 inclusive >>> generate_unique_ids(0) Traceback (most recent call last): ... ValueError: n must be an integer between 1 and 1000 inclusive ``` Additional Notes - You may use Python\'s `random` and `string` modules to facilitate the random generation of characters. - Ensure that the generated identifiers are unique within the list. # Example Implementation: ```python import random import string def generate_unique_ids(n: int) -> list: if not isinstance(n, int) or not (1 <= n <= 1000): raise ValueError(\\"n must be an integer between 1 and 1000 inclusive\\") unique_ids = set() while len(unique_ids) < n: new_id = \'\'.join(random.choices(string.ascii_letters + string.digits, k=8)) unique_ids.add(new_id) return list(unique_ids) ```","solution":"import random import string def generate_unique_ids(n: int) -> list: if not isinstance(n, int) or not (1 <= n <= 1000): raise ValueError(\\"n must be an integer between 1 and 1000 inclusive\\") unique_ids = set() while len(unique_ids) < n: new_id = \'\'.join(random.choices(string.ascii_letters + string.digits, k=8)) unique_ids.add(new_id) return list(unique_ids)"},{"question":"**Context**: You are designing a file storage and retrieval system that requires efficient text search capabilities. To facilitate this, you decided to implement a Suffix Array based substring search algorithm. **Problem**: Write a function `substring_search` that constructs a suffix array for a given text and then efficiently searches for a given pattern within that text using the suffix array. **Function Signature**: ```python def substring_search(text: str, pattern: str) -> list: ``` **Input**: * A string `text` which is the main text in which the pattern needs to be searched. * A string `pattern` which is the substring that needs to be searched within the text. **Output**: * Return a list of starting indices where the pattern is found in the text. If the pattern is not found, return an empty list. **Constraints**: * `text` can have up to 100,000 characters. * `pattern` can have up to 1,000 characters. * Both `text` and `pattern` consist only of lowercase English letters. **Performance Requirements**: * Construct the suffix array in O(n log n) time complexity. * Pattern search should be done in O(m log n) time complexity, where n is the length of `text` and m is the length of `pattern`. **Example**: ```python text = \\"banana\\" pattern = \\"ana\\" output = substring_search(text, pattern) print(output) # Expected: [1, 3] text = \\"aabaaaab\\" pattern = \\"aa\\" output = substring_search(text, pattern) print(output) # Expected: [0, 3, 4, 5] ```","solution":"def build_suffix_array(text): Build a suffix array for the given text. Returns a list where each value is the starting index of a suffix in sorted order. suffixes = sorted([(text[i:], i) for i in range(len(text))]) suffix_array = [index for (suffix, index) in suffixes] return suffix_array def suffix_array_search(text, pattern, suffix_array): Use binary search on the suffix array to find all occurrences of the pattern in the text. Returns a list of starting indices. def find_occurrences(text, pattern, suffix_array, left, right): occurrences = [] while left <= right: mid = (left + right) // 2 suffix = text[suffix_array[mid]:] if suffix.startswith(pattern): occurrences.append(suffix_array[mid]) # Search adjacent suffixes for more occurrences lower = mid - 1 while lower >= left and text[suffix_array[lower]:].startswith(pattern): occurrences.append(suffix_array[lower]) lower -= 1 upper = mid + 1 while upper <= right and text[suffix_array[upper]:].startswith(pattern): occurrences.append(suffix_array[upper]) upper += 1 break elif suffix > pattern: right = mid - 1 else: left = mid + 1 return occurrences left, right = 0, len(suffix_array) - 1 return find_occurrences(text, pattern, suffix_array, left, right) def substring_search(text, pattern): Search for all occurrences of pattern in text using the suffix array. if not text or not pattern: return [] suffix_array = build_suffix_array(text) pattern_occurrences = suffix_array_search(text, pattern, suffix_array) return sorted(pattern_occurrences)"},{"question":"# Context You are tasked with creating a Python class that models a simple inventory system for a bookstore. The class should allow adding new books, removing books, and querying the inventory for the number of copies of a specific book. Additionally, you should implement unit tests to verify the correct functionality of the class methods. # Task Write a Python class `BookstoreInventory` with the following methods: 1. `add_book(title: str, count: int) -> None`: Adds a given number of copies of a book to the inventory. 2. `remove_book(title: str, count: int) -> None`: Removes a given number of copies of a book from the inventory. 3. `get_inventory(title: str) -> int`: Returns the number of copies of a specific book in the inventory. Additionally, write unit tests using the `unittest` framework to verify the correctness of the class methods. Your tests should cover: 1. Adding books to the inventory. 2. Removing books from the inventory. 3. Querying the inventory for a specific book. 4. Handling edge cases such as attempting to remove more books than are available. # Class Signature ```python class BookstoreInventory: def __init__(self): Initialize an empty inventory. pass def add_book(self, title: str, count: int) -> None: Add a specified number of copies of a book to the inventory. Args: title (str): The title of the book. count (int): The number of copies to add. Returns: None pass def remove_book(self, title: str, count: int) -> None: Remove a specified number of copies of a book from the inventory. Args: title (str): The title of the book. count (int): The number of copies to remove. Returns: None pass def get_inventory(self, title: str) -> int: Get the number of copies of a specific book in the inventory. Args: title (str): The title of the book. Returns: int: The number of copies of the book in the inventory. pass ``` # Input and Output Formats * **Input**: Method arguments such as book titles and the number of copies as specified in the method signatures. * **Output**: Return values as specified in the method signatures. # Constraints * The `title` string is non-empty. * The `count` is a non-negative integer. * If an attempt is made to remove more books than available, an exception should be raised. # Example Assume the following sequence of method calls: ```python inventory = BookstoreInventory() inventory.add_book(\\"Book A\\", 10) inventory.add_book(\\"Book B\\", 5) inventory.remove_book(\\"Book A\\", 3) print(inventory.get_inventory(\\"Book A\\")) # Output: 7 print(inventory.get_inventory(\\"Book B\\")) # Output: 5 ``` # Requirements 1. Implement the `BookstoreInventory` class with the specified methods. 2. Write unit tests using the `unittest` framework to cover different scenarios and edge cases. ```python import unittest class BookstoreInventory: def __init__(self): self.books = {} def add_book(self, title: str, count: int) -> None: if title in self.books: self.books[title] += count else: self.books[title] = count def remove_book(self, title: str, count: int) -> None: if title not in self.books or self.books[title] < count: raise ValueError(\\"Not enough copies to remove\\") self.books[title] -= count if self.books[title] == 0: del self.books[title] def get_inventory(self, title: str) -> int: return self.books.get(title, 0) class TestBookstoreInventory(unittest.TestCase): def test_add_book(self): inventory = BookstoreInventory() inventory.add_book(\\"Book A\\", 10) self.assertEqual(inventory.get_inventory(\\"Book A\\"), 10) def test_remove_book(self): inventory = BookstoreInventory() inventory.add_book(\\"Book A\\", 10) inventory.remove_book(\\"Book A\\", 3) self.assertEqual(inventory.get_inventory(\\"Book A\\"), 7) def test_get_inventory(self): inventory = BookstoreInventory() inventory.add_book(\\"Book A\\", 10) self.assertEqual(inventory.get_inventory(\\"Book B\\"), 0) def test_remove_more_than_available(self): inventory = BookstoreInventory() inventory.add_book(\\"Book A\\", 10) with self.assertRaises(ValueError): inventory.remove_book(\\"Book A\\", 15) if __name__ == \'__main__\': unittest.main() ```","solution":"class BookstoreInventory: def __init__(self): self.books = {} def add_book(self, title: str, count: int) -> None: if title in self.books: self.books[title] += count else: self.books[title] = count def remove_book(self, title: str, count: int) -> None: if title not in self.books or self.books[title] < count: raise ValueError(\\"Not enough copies to remove\\") self.books[title] -= count if self.books[title] == 0: del self.books[title] def get_inventory(self, title: str) -> int: return self.books.get(title, 0)"},{"question":"# Problem Statement You are tasked with creating a mini calculator that can handle basic arithmetic operations with error handling features for division by zero and invalid inputs. The calculator should support addition, subtraction, multiplication, and division. # Requirements 1. Implement a class named `MiniCalculator` with the following methods: - `add(a: float, b: float) -> float`: returns the sum of `a` and `b`. - `subtract(a: float, b: float) -> float`: returns the result of `a` minus `b`. - `multiply(a: float, b: float) -> float`: returns the product of `a` and `b`. - `divide(a: float, b: float) -> float`: returns the result of `a` divided by `b` if `b` is not 0, otherwise raises a `ValueError` with the message \\"Cannot divide by zero\\". 2. Design a method `calculate(expression: str) -> float` that evaluates a given arithmetic expression containing the basic operations (`+`, `-`, `*`, `/`). 3. The `calculate` method should: - Parse the expression and perform the operations in the correct order. - Handle potential errors such as division by zero, invalid operators, and invalid expressions. # Input Format ```python class MiniCalculator: def add(a: float, b: float) -> float def subtract(a: float, b: float) -> float def multiply(a: float, b: float) -> float def divide(a: float, b: float) -> float def calculate(expression: str) -> float ``` # Output Format * The methods return the result of their respective operations as a float. * The `calculate` method parses and evaluates the input expression and returns the computed result as a float. # Constraints * Inputs `a` and `b` for arithmetic methods are floating-point numbers. * The input expression for the `calculate` method is a valid arithmetic expression containing floating-point numbers and the operators `+`, `-`, `*`, `/`. * Division by zero should raise a `ValueError`. # Example ```python calculator = MiniCalculator() # Using basic arithmetic methods sum_result = calculator.add(1.5, 2.3) print(f\\"Sum: {sum_result}\\") subtraction_result = calculator.subtract(5.5, 3.1) print(f\\"Subtraction: {subtraction_result}\\") multiplication_result = calculator.multiply(4.2, 3.1) print(f\\"Multiplication: {multiplication_result}\\") division_result = calculator.divide(10.0, 2.0) print(f\\"Division: {division_result}\\") # Evaluating an expression expression_result = calculator.calculate(\\"2 + 3 * 4 - 5 / 2.5\\") print(f\\"Expression Result: {expression_result}\\") ``` *Expected Output*: ``` Sum: 3.8 Subtraction: 2.4 Multiplication: 13.02 Division: 5.0 Expression Result: 12.0 ``` # Notes * Implement proper error handling for invalid expressions and operations. * Ensure that the `calculate` method respects the order of operations (PEMDAS/BODMAS).","solution":"import re class MiniCalculator: def add(self, a: float, b: float) -> float: return a + b def subtract(self, a: float, b: float) -> float: return a - b def multiply(self, a: float, b: float) -> float: return a * b def divide(self, a: float, b: float) -> float: if b == 0: raise ValueError(\\"Cannot divide by zero\\") return a / b def calculate(self, expression: str) -> float: # Define the precedence of operators precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} def parse_expression(expression): tokens = re.findall(r\'d+.?d*|[+*/()-]\', expression) return tokens def perform_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(self.add(left, right)) elif operator == \'-\': values.append(self.subtract(left, right)) elif operator == \'*\': values.append(self.multiply(left, right)) elif operator == \'/\': values.append(self.divide(left, right)) def evaluate_expression(tokens): values = [] operators = [] i = 0 while i < len(tokens): token = tokens[i] if token.isnumeric() or re.match(r\'d+.?d*\', token): values.append(float(token)) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': perform_operation(operators, values) operators.pop() # pop \'(\' else: # operator while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[token]): perform_operation(operators, values) operators.append(token) i += 1 while operators: perform_operation(operators, values) return values[0] tokens = parse_expression(expression) return evaluate_expression(tokens)"},{"question":"# Calculate Grade Distribution Background In educational institutions, grading students\' scores and then categorizing them into grade distributions is a common requirement. You are tasked with writing software that can count the number of students falling into each grade category based on specific scoring ranges. Task Write a Python function `grade_distribution(scores: list) -> dict` that takes a list of student scores and returns a dictionary representing the grade distribution. The grades and their corresponding ranges are as follows: - \'A\': 90 to 100 - \'B\': 80 to 89 - \'C\': 70 to 79 - \'D\': 60 to 69 - \'F\': Below 60 Input * One parameter: * `scores` (list): A list of integer scores, where each score ranges from 0 to 100. Output * A dictionary with the grade categories as keys and the number of students in each category as values. Examples ```python >>> grade_distribution([95, 85, 76, 65, 54]) {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} >>> grade_distribution([99, 89, 79, 69, 59]) {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} >>> grade_distribution([100, 90, 80, 70, 60, 55]) {\'A\': 2, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} >>> grade_distribution([92, 85, 75]) {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 0, \'F\': 0} ```","solution":"def grade_distribution(scores): Returns the grade distribution based on a list of scores. Parameters: scores (list): A list of integer scores. Returns: dict: A dictionary with grades as keys and counts as values. # Initializing the grade distribution dictionary distribution = { \'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0 } # Categorizing each score into their respective grade for score in scores: if 90 <= score <= 100: distribution[\'A\'] += 1 elif 80 <= score <= 89: distribution[\'B\'] += 1 elif 70 <= score <= 79: distribution[\'C\'] += 1 elif 60 <= score <= 69: distribution[\'D\'] += 1 elif score < 60: distribution[\'F\'] += 1 return distribution"},{"question":"# Problem Statement Given a list of integers, you are asked to find and return the first contiguous subarray (starting from the beginning of the original list) that, when its elements are summed, is greater than or equal to a given integer `S`. If no such subarray exists, return an empty list. # Input * A list of integers `nums` where `0 <= len(nums) <= 10^5` * An integer `S` where `0 <= S <= 10^9` # Output * Return the first contiguous subarray from the start of `nums` whose sum is greater than or equal to `S`. If no such subarray exists, return an empty list. # Implementation Implement the following function: ```python def find_subarray(nums: list[int], S: int) -> list[int]: Find the first subarray from the beginning whose sum is greater than or equal to S. :param nums: List of integers :param S: Target sum :return: The required subarray or an empty list >>> find_subarray([1, 2, 3, 4, 5], 9) [1, 2, 3, 4] >>> find_subarray([2, 1, 2, 1, 1, 1], 5) [2, 1, 2] >>> find_subarray([1, 2, 3], 7) [] >>> find_subarray([], 1) [] >>> find_subarray([1, 2, 3, 4, 5], 1) [1] pass ``` # Constraints * The list can be empty. * Each integer in the list is within the range of -10^9 to 10^9. # Edge Cases * If the list is empty, the function should return an empty list. * If `S` is zero, any subarray starting from the beginning that contains at least one element satisfies the condition. * Negative integers should be handled appropriately. # Example ```python print(find_subarray([1, 2, 3, 4, 5], 9)) # Output: [1, 2, 3, 4] print(find_subarray([2, 1, 2, 1, 1, 1], 5)) # Output: [2, 1, 2] print(find_subarray([1, 2, 3], 7)) # Output: [] print(find_subarray([], 1)) # Output: [] print(find_subarray([1, 2, 3, 4, 5], 1)) # Output: [1] ```","solution":"def find_subarray(nums: list[int], S: int) -> list[int]: Find the first subarray from the beginning whose sum is greater than or equal to S. :param nums: List of integers :param S: Target sum :return: The required subarray or an empty list current_sum = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum >= S: return nums[:i+1] return []"},{"question":"# Binary Indexed Tree (Fenwick Tree) Range Queries and Updates Objective You are to implement a Binary Indexed Tree (Fenwick Tree) data structure that will support efficient prefix sum queries and element updates on an array. The Binary Indexed Tree should be able to handle different types of prefix queries including sum, minimum, and maximum using a commutative combiner function. Requirements 1. **Initialization**: Initialize the Binary Indexed Tree with an array and a combiner function. 2. **Range Query**: Implement a method to query the combined result from the start of the array up to any given index. 3. **Update**: Implement a method to update an element in the array and adjust the Binary Indexed Tree accordingly. Specifications 1. The array will be of integers with a length **N** (1 ≤ N ≤ 10^4). 2. The combiner function will be a commutative and associative function such as summation, minimum, or maximum. 3. The constructor should take an array and a combiner function. 4. The `query(index: int) -> int` method should return the combined result of the range `[0, index]`. 5. The `update(index: int, value: int) -> None` method should update the element at the specified index and modify the Binary Indexed Tree. Input & Output * **Initialization**: ```python bit = BinaryIndexedTree(arr: List[int], fn: Callable[[int, int], int]) ``` * `arr` is the array to be processed * `fn` is the commutative combiner function * **Range Query**: ```python result = bit.query(index: int) ``` * `index` is the end index of the range `[0, index]` * **Update**: ```python bit.update(index: int, value: int) ``` * `index` is the position in the array to be updated * `value` is the new value at that position Example ```python # Initialize BinaryIndexedTree arr = [1, 3, 5, 7, 9, 11] combiner_function = sum bit = BinaryIndexedTree(arr, combiner_function) # Perform queries print(bit.query(3)) # Output: 16 (1 + 3 + 5 + 7) print(bit.query(2)) # Output: 9 (1 + 3 + 5) # Update elements bit.update(2, 6) print(bit.query(3)) # Output: 17 (1 + 3 + 6 + 7) ``` Implement the Binary Indexed Tree class so that it can efficiently handle the above requirements and provide accurate prefix query results and support element updates.","solution":"class BinaryIndexedTree: def __init__(self, arr, fn): Initializes the Binary Indexed Tree with the given array and combiner function. :param arr: List[int], array to be processed :param fn: Callable[[int, int], int], commutative combiner function self.n = len(arr) self.fn = fn self.tree = [0] * (self.n + 1) self.data = arr[:] for i in range(self.n): self._add(i + 1, self.data[i]) def _add(self, index, value): Adds value to the index-th position in the tree. :param index: int, position in the tree (1-based index) :param value: int, value to add while index <= self.n: self.tree[index] = self.fn(self.tree[index], value) index += index & -index def query(self, index): Returns the combined result of the range [0, index]. :param index: int, end index of the range (0-based index) :return: int, combined result of the range result = 0 idx = index + 1 while idx > 0: result = self.fn(result, self.tree[idx]) idx -= idx & -idx return result def update(self, index, value): Updates the element at the specified index and adjusts the Binary Indexed Tree. :param index: int, position in the array (0-based index) :param value: int, new value at that position current_value = self.data[index] difference = value - current_value self.data[index] = value self._add(index + 1, difference)"},{"question":"# Data Processing and Aggregation Task Scenario You are working with a dataset that contains sales records for different products sold across various regions. Your task is to write a function that processes this data and provides a summary report that includes the total sales for each product as well as the overall total sales. Requirements Implement a function `process_sales_data()` that performs the following: 1. **Data Parsing**: * Parse the input data to extract product names, regions, and sales amounts. * The input data will be provided as a list of dictionaries where each dictionary represents a sales record. 2. **Sales Aggregation**: * Compute the total sales for each product. * Compute the overall total sales across all products and regions. Function Signature ```python def process_sales_data(sales_records: list) -> dict: pass ``` Input * `sales_records` (list): A list of dictionaries containing sales data. Each dictionary has the following format: ```python { \\"product\\": str, # name of the product \\"region\\": str, # region where product was sold \\"sales\\": float # sales amount } ``` Output * Returns a dictionary with the total sales for each product and the overall total sales. The format of the output dictionary should be as follows: ```python { \\"total_sales\\": float, # overall total sales \\"products\\": { \\"product_name_1\\": float, # total sales for product_name_1 \\"product_name_2\\": float, # total sales for product_name_2 ... } } ``` Example Input: ```python sales_records = [ {\\"product\\": \\"ProductA\\", \\"region\\": \\"North\\", \\"sales\\": 100.0}, {\\"product\\": \\"ProductB\\", \\"region\\": \\"South\\", \\"sales\\": 150.0}, {\\"product\\": \\"ProductA\\", \\"region\\": \\"East\\", \\"sales\\": 200.0}, {\\"product\\": \\"ProductC\\", \\"region\\": \\"West\\", \\"sales\\": 250.0}, {\\"product\\": \\"ProductB\\", \\"region\\": \\"North\\", \\"sales\\": 50.0}, {\\"product\\": \\"ProductA\\", \\"region\\": \\"South\\", \\"sales\\": 300.0}, ] ``` Expected Output: ```python { \\"total_sales\\": 1050.0, \\"products\\": { \\"ProductA\\": 600.0, \\"ProductB\\": 200.0, \\"ProductC\\": 250.0 } } ``` --- This new question aligns with the existing set by focusing on data processing and aggregation, essential concepts in programming and data analysis. The complexity level is matched by requiring parsing, aggregation, and comprehensive output structuring while allowing for clean and efficient code. This question extends the skill assessment into data handling and summary creation in a different yet related context.","solution":"def process_sales_data(sales_records: list) -> dict: Processes sales data to compute total sales for each product and overall total sales. Args: sales_records (list): List of dictionaries containing sales records. Returns: dict: Dictionary containing total sales per product and overall total sales. total_sales = 0.0 product_sales = {} for record in sales_records: product = record[\\"product\\"] sales = record[\\"sales\\"] total_sales += sales if product in product_sales: product_sales[product] += sales else: product_sales[product] = sales return { \\"total_sales\\": total_sales, \\"products\\": product_sales }"},{"question":"# Sorting and Swapping Adjacent Elements Objective You are required to implement a function that sorts an input list of integers in non-decreasing order using a custom sorting algorithm. The algorithm only allows adjacent elements to be swapped if they are out of order. Problem Statement Implement the function `custom_sort(arr: List[int]) -> List[int]` that sorts a list of integers by only swapping adjacent elements if they are out of order. Input and Output * **Input**: * `arr`: A list of integers. * **Output**: * Returns a new list sorted in non-decreasing order. Constraints * The input list can have up to (10^4) elements. * Elements are integers, and they can be negative. Performance Requirement The algorithm should ideally minimize the number of swaps, aiming to perform efficiently with (O(n^2)) in worst-case scenarios. Example ```python >>> custom_sort([3, 2, 1]) [1, 2, 3] >>> custom_sort([4, 5, 1, 2, 3]) [1, 2, 3, 4, 5] >>> custom_sort([10, -1, 2, 5, -3]) [-3, -1, 2, 5, 10] >>> custom_sort([1]) [1] ``` Note * You must handle edge cases like an empty list or a list with one element. * Your implementation should ensure that the list is only sorted using adjacent swaps. Function Signature ```python from typing import List def custom_sort(arr: List[int]) -> List[int]: # Your implementation here ``` Additional Information * `custom_sort([3, 2, 1])` requires multiple adjacent swaps: `3<->2`, then `3<->1`, followed by `2<->1`. * Emphasize the efficiency and correctness of sorting using adjacent swaps while following constraints diligently. Implement the function `custom_sort` to accomplish the task as described above.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sort an array of integers using only adjacent swaps. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"# Problem Statement You need to implement a data structure that allows you to efficiently track the k-th largest element in a dynamically changing list. This data structure should support two main functionalities: 1. Add an element to the data structure. 2. Retrieve the k-th largest element from the data structure quickly. # Requirements 1. **Initialization:** - Initialize the structure with the number `k`, which specifies the k-th largest element to track. 2. **Operations:** - **Add an element (add(x))**: Insert a new element `x` into the data structure. - **Get k-th largest (kth_largest())**: Return the k-th largest element from the data structure. # Input Format - An integer `k` (an integer `k > 0`). - A sequence of operations and their values. # Output Format - For an `add` operation, return `None`. - For a `kth_largest` operation, return the k-th largest element. # Constraints - The value of `k` will always be smaller than or equal to the current number of elements in the data structure. - Elements added to the data structure will be integers. - Operations are provided in the form of a list of tuples, where each tuple contains the operation name and necessary parameters. # Example ```python # Initial value of k is 3 # Sequence of operations operations = [ (\\"add\\", 4), (\\"add\\", 5), (\\"add\\", 8), (\\"add\\", 2), (\\"kth_largest\\",), # Output: 4 (\\"add\\", 9), (\\"kth_largest\\",), # Output: 5 (\\"add\\", 3), (\\"kth_largest\\",), # Output: 5 ] tracker = KthLargestElementTracker(3) for operation in operations: if operation[0] == \\"add\\": tracker.add(operation[1]) elif operation[0] == \\"kth_largest\\": print(tracker.kth_largest()) ``` # Boilerplate Code: Implement the required methods in the provided class: ```python import heapq class KthLargestElementTracker: def __init__(self, k: int) -> None: # Initialize the tracker with the k value and an empty min-heap self.k = k self.min_heap = [] def add(self, val: int): # Add a new element into the data structure if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) def kth_largest(self) -> int: # Return the k-th largest element return self.min_heap[0] ``` This additional question maintains a consistent style, complexity, and scope with the provided sample question 1. It involves initializing a data structure, handling dynamic updates, and performing efficient queries, which are common themes in coding assessments related to data structures and algorithms.","solution":"import heapq class KthLargestElementTracker: def __init__(self, k: int) -> None: Initialize the tracker with the k value and an empty min-heap. self.k = k self.min_heap = [] def add(self, val: int): Add a new element into the data structure. if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, val) elif val > self.min_heap[0]: heapq.heapreplace(self.min_heap, val) def kth_largest(self) -> int: Return the k-th largest element. return self.min_heap[0]"},{"question":"# Problem Description: You are to implement a matrix diagonal traversal. In this problem, you\'ll write a function that returns an array containing the elements of a given matrix in diagonal order. # Function Signature: ```python def find_diagonal_order(mat: List[List[int]]) -> List[int]: ``` # Input: - `mat`: A 2D list of integers representing the matrix. # Output: - A list of integers representing the elements of the matrix in diagonal order. # Constraints: 1. The number of rows in `mat` will be between 1 and 100. 2. The number of columns in `mat` will be between 1 and 100. 3. Each element of the matrix (`mat[i][j]`) will be an integer in the range of -10^5 to 10^5. # Example: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [1, 2, 4, 7, 5, 3, 6, 8, 9] assert find_diagonal_order(mat) == expected_output ``` # Notes: - Start the traversal from the top-left corner of the matrix. - Continue diagonally up-right, then down-left alternatively. - When reaching the boundary of the matrix, the direction should reverse appropriately (e.g., when reaching the top row, switch to down-left direction). - Ensure to handle edge cases such as single-row or single-column matrices.","solution":"from typing import List def find_diagonal_order(mat: List[List[int]]) -> List[int]: if not mat or not mat[0]: return [] rows, cols = len(mat), len(mat[0]) result = [] intermediate = [] for diag in range(rows + cols - 1): row = 0 if diag < cols else diag - cols + 1 col = diag if diag < cols else cols - 1 while row < rows and col > -1: intermediate.append(mat[row][col]) row += 1 col -= 1 if diag % 2 == 0: result.extend(intermediate[::-1]) else: result.extend(intermediate) intermediate = [] return result"},{"question":"# Shortest Path using Dijkstra\'s Algorithm Problem Statement You are given a directed graph represented by an adjacency list where each node is connected to one or more other nodes with given edge weights. Your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source node to all other nodes in the graph using a Min-Heap to efficiently track the minimum distance. Function Signature ```python def dijkstra_shortest_path(adjacency_list: dict, source: int) -> dict: Compute the shortest path from a given source node to all other nodes using Dijkstra\'s algorithm. Args: adjacency_list (dict): A dictionary representing adjacency list of the graph where keys are node numbers and values are lists of tuples (neighbour, weight). source (int): The starting node for shortest path calculation. Returns: dict: A dictionary where keys are node numbers and values are the minimum distance from the source node. Example: adjacency_list = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [(4, 3)], 4: [] } source = 0 dijkstra_shortest_path(adjacency_list, source) -> {0: 0, 1: 3, 2: 1, 3: 4, 4: 7} ``` Constraints * The graph\'s nodes are labeled with integers starting from 0. * The edge weights are non-negative integers. * The graph may not be fully connected, but the source node will have at least one edge. * The graph contains at least one node. Implementation Details * Implement and use a Min-Heap to track and extract the minimum distance estimate. * Your implementation should handle the edge cases of empty graphs and graphs with varying edge densities. * Ensure your solution efficiently handles graphs with up to 1000 vertices and 20000 edges. Example Input ```python adjacency_list = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [(4, 3)], 4: [] } source = 0 ``` Expected Output ```python {0: 0, 1: 3, 2: 1, 3: 4, 4: 7} ```","solution":"import heapq def dijkstra_shortest_path(adjacency_list, source): Compute the shortest path from a given source node to all other nodes using Dijkstra\'s algorithm. Args: adjacency_list (dict): A dictionary representing adjacency list of the graph where keys are node numbers and values are lists of tuples (neighbour, weight). source (int): The starting node for shortest path calculation. Returns: dict: A dictionary where keys are node numbers and values are the minimum distance from the source node. # Initialize the distances dictionary with infinity distances = {node: float(\'inf\') for node in adjacency_list} distances[source] = 0 # Create a priority queue and push the source node with distance 0 priority_queue = [(0, source)] while priority_queue: # Extract the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) # Check if the popped node\'s distance is already greater, skip processing it if current_distance > distances[current_node]: continue # Process each neighbour of the current node for neighbor, weight in adjacency_list[current_node]: distance = current_distance + weight # Only consider if the new distance is shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Scenario You are working on a machine learning data preprocessing pipeline where you need to implement a k-th smallest element selection feature for various statistical operations. This will help in efficiently performing tasks such as finding the median, quartiles, or other quantile-based statistics. # Problem Statement Write a function `find_kth_smallest(nums: list, k: int) -> int` that finds the k-th smallest element in an unsorted list of integers using the QuickSelect algorithm. This is particularly useful in large datasets where sorting the entire list is infeasible due to time complexity constraints. # Input Format * `nums` is a list of integers, where the integers can be both positive and negative. * `k` is an integer representing the position (1-based index) of the k-th smallest element to retrieve. # Output Format * Return a single integer which is the k-th smallest element in the list. # Constraints * 1 ≤ len(nums) ≤ 10^5 * -10^6 ≤ nums[i] ≤ 10^6 * 1 ≤ k ≤ len(nums) # Performance Requirements * The solution should operate within O(n) expected time complexity. # Example ```python >>> find_kth_smallest([3, 2, 1, 5, 4], 2) 2 >>> find_kth_smallest([7, -2, 3, 4, 1, 12], 5) 7 >>> find_kth_smallest([-5, -10, 0, 5], 1) -10 ``` # Notes * Your implementation should correctly handle edge cases, such as when the list contains duplicate values. * Ensure the function is robust to handling an empty list or a value of k outside the valid range with appropriate error messages or exceptions. * QuickSelect is an efficient algorithm for this problem and should be the preferred approach over simpler but less efficient methods like sorting the entire list and selecting the k-th element.","solution":"def find_kth_smallest(nums, k): Finds the k-th smallest element in an unsorted list of integers using the QuickSelect algorithm. :param nums: List of integers :param k: 1-based index of the k-th smallest element to find :return: The k-th smallest element in the list if k < 1 or k > len(nums): raise ValueError(\\"k is out of the valid range\\") def quick_select(left, right, k_smallest): if left == right: return nums[left] pivot_index = partition(left, right) if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quick_select(left, pivot_index - 1, k_smallest) else: return quick_select(pivot_index + 1, right, k_smallest) def partition(left, right): pivot = nums[right] store_index = left for i in range(left, right): if nums[i] < pivot: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 nums[right], nums[store_index] = nums[store_index], nums[right] return store_index return quick_select(0, len(nums) - 1, k - 1)"},{"question":"Problem Statement You are tasked with finding the length of the longest subsequence in an array such that all elements of the subsequence are sorted in increasing order. Implement the function `longest_increasing_subsequence` which returns the length of this subsequence. # Function Signature ```python def longest_increasing_subsequence(arr: List[int]) -> int: pass ``` # Input * `arr` (List[int]): The list of integers. * 1 <= len(arr) <= 10^4 * -10^6 <= arr[i] <= 10^6 # Output * The function should return a single integer, representing the length of the longest increasing subsequence. # Example Input ```python arr = [10, 9, 2, 5, 3, 7, 101, 18] ``` Output ```python 4 ``` # Explanation The longest increasing subsequence is [2, 3, 7, 101], and its length is 4. # Scenario Tom is analyzing a series of stock prices over time. He wishes to determine the longest period during which the stock prices continually increase—which will help him make smarter investment decisions. # Constraints * Consider edge cases, such as when the array is already sorted in decreasing order or contains duplicates. * Aim for an efficient solution to handle larger input sizes within acceptable runtime. # Example Test Cases ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 assert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3 ```","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. if not arr: # Edge case: empty array return 0 # Stores the largest possible value for the minimum ending value # of an increasing subsequence of length i at tails[i - 1] tails = [] for num in arr: # Binary search for the smallest number in tails such that tails[i] >= num left, right = 0, len(tails) while left < right: mid = (left + right) // 2 if tails[mid] < num: left = mid + 1 else: right = mid # If left points to the end of tails, it means num is greater than # any element in tails, so we append it to extend the subsequence. if left == len(tails): tails.append(num) else: tails[left] = num return len(tails)"},{"question":"# Array Rotation Objective Write a Python function that performs a left rotation on an array of integers and returns the rotated array. Problem Statement Given an array of integers `arr` and a number `d`, implement a function `rotate_array(arr: List[int], d: int) -> List[int]` that rotates the elements of `arr` to the left by `d` positions. Ensure that your solution works efficiently for large arrays. Input and Output Format * **Input**: * `arr`: A list of integers (1 <= len(arr) <= 10^5, 1 <= arr[i] <= 10^9) * `d`: An integer representing the number of positions to rotate the array left by (0 <= d <= len(arr)). * **Output**: A list of integers representing the array after it has been rotated left by `d` positions. Constraints * The input list can be of significant length, so your solution should aim for optimal performance. * d can be zero, in which case the array should remain unchanged. Performance Requirements * Time Complexity: O(n), where n is the length of `arr`. * Space Complexity: O(1) if rotations are performed in place or O(n) if a new list is returned. Example 1 * **Input**: `arr = [1, 2, 3, 4, 5]`, `d = 2` * **Output**: `[3, 4, 5, 1, 2]` Example 2 * **Input**: `arr = [10, 20, 30, 40, 50, 60, 70]`, `d = 4` * **Output**: `[50, 60, 70, 10, 20, 30, 40]` Example 3 * **Input**: `arr = [15, 25, 35]`, `d = 0` * **Output**: `[15, 25, 35]` Tasks 1. Implement the function `rotate_array(arr: List[int], d: int) -> List[int]`. 2. Write a suite of test cases to ensure your implementation is correct, covering edge cases such as `d = 0` and `d` equal to the length of the array. Notes * Be aware of cases where `d` is larger than the length of the array; rotating by `d` should be equivalent to rotating by `d % len(arr)`. * Ensure your solution maintains the integrity of the array and performs rotations efficiently.","solution":"from typing import List def rotate_array(arr: List[int], d: int) -> List[int]: Rotates an array of integers to the left by \'d\' positions. n = len(arr) if n == 0 or d % n == 0: return arr d = d % n return arr[d:] + arr[:d]"},{"question":"# Problem Statement Create a function that simulates the performance of stock prices over a specified period based on geometric Brownian motion. You are to generate daily closing prices for a stock based on historical volatility and a given drift rate. # Task Implement a function `simulate_stock_prices` that generates a list of simulated stock prices for a given number of days. Each price is calculated using the geometric Brownian motion formula. Function Signature ```python def simulate_stock_prices( start_price: float, drift: float, volatility: float, days: int ) -> list: ``` Input * `start_price` (float): The initial stock price. * `drift` (float): The expected return rate of the stock (as a fraction, e.g., 5% as 0.05). * `volatility` (float): The standard deviation of the stock\'s returns (as a fraction, e.g., 20% as 0.20). * `days` (int): The number of days to simulate. Output * (list): A list of floats representing the simulated daily closing prices for the stock over the given number of days. Constraints * `start_price`, `drift`, and `volatility` must be positive. * `days` must be a positive integer. # Example ```python prices = simulate_stock_prices(100.0, 0.01, 0.05, 10) print(prices) # Output could be something like [100.0, 101.2, 102.4, ..., 110.5] depending on random variation. ``` # Notes 1. The geometric Brownian motion formula to use is ``` S_t = S_{t-1} * exp((drift - 0.5 * volatility^2) * dt + volatility * sqrt(dt) * Z_t) ``` where `S_t` is the stock price at day t, `dt` is the time increment (which should be 1 day), and `Z_t` is a random variable from a standard normal distribution. 2. Use Python\'s `random` module to generate the random variables. 3. Ensure to validate inputs and handle any potential edge cases. 4. Document your assumptions or any additional considerations in your solution.","solution":"import math import random def simulate_stock_prices(start_price: float, drift: float, volatility: float, days: int) -> list: Simulates the performance of stock prices over a specified period based on geometric Brownian motion. Parameters: start_price (float): The initial stock price. drift (float): The expected return rate of the stock (as a fraction, e.g., 5% as 0.05). volatility (float): The standard deviation of the stock\'s returns (as a fraction, e.g., 20% as 0.20). days (int): The number of days to simulate. Returns: list: A list of floats representing the simulated daily closing prices for the stock over the given number of days. # Input validation if start_price <= 0 or drift <= 0 or volatility <= 0 or days <= 0: raise ValueError(\\"All input values must be positive.\\") prices = [start_price] dt = 1 # one day for _ in range(days - 1): Z = random.gauss(0, 1) price = prices[-1] * math.exp((drift - 0.5 * volatility**2) * dt + volatility * math.sqrt(dt) * Z) prices.append(price) return prices"},{"question":"# Question: Fibonacci Number Finder with Memoization Context: Calculating Fibonacci numbers using the naive recursive approach can be highly inefficient due to repeated calculations of the same subproblems. To improve the efficiency, you can implement memoization, which stores the results of expensive function calls and returns the cached result when the same inputs occur again. Objective: Implement a Fibonacci number finder that utilizes memoization to optimize the recursive calculation of the nth Fibonacci number. Requirements: 1. Implement a function `fibonacci_memo(n: int, memo: dict[int, int] = {}) -> int` that returns the nth Fibonacci number. 2. Use a dictionary for memoization to store and reuse computed Fibonacci numbers. 3. The function should handle input values from 0 up to 30 inclusively, and for values outside this range, the function should raise a `ValueError`. Input: - `n`: An integer representing the position in the Fibonacci sequence. Output: - An integer representing the nth Fibonacci number. Constraints: - 0 ≤ n ≤ 30 Example: ```python # Example usage print(fibonacci_memo(0)) # Output: 0 print(fibonacci_memo(1)) # Output: 1 print(fibonacci_memo(10)) # Output: 55 print(fibonacci_memo(20)) # Output: 6765 # Example of error handling try: print(fibonacci_memo(31)) except ValueError as e: print(e) # Output: Input out of valid range (0-30) ``` ```python # Function definition skeleton def fibonacci_memo(n: int, memo: dict[int, int] = {}) -> int: if n < 0 or n > 30: raise ValueError(\\"Input out of valid range (0-30)\\") # Write your implementation here pass # You can create your tests using the examples provided ```","solution":"def fibonacci_memo(n: int, memo: dict[int, int] = {}) -> int: if n < 0 or n > 30: raise ValueError(\\"Input out of valid range (0-30)\\") if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo) return memo[n]"},{"question":"# Common Elements in Ordered Lists - Programming Question You are given two sorted lists of integers. Your task is to write a function to find the common elements between the two lists. The result should also be a sorted list of integers. **Function Signature**: ```python def common_elements(list_a: list, list_b: list) -> list: :param list_a: Sorted list of integers :param list_b: Sorted list of integers :return: Sorted list of integers that are common in both list_a and list_b >>> common_elements([1, 2, 3], [2, 3, 4]) [2, 3] >>> common_elements([5, 6, 7], [7, 8, 9]) [7] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 2, 3], []) [] pass ``` # Constraints: 1. Both inputs must be of list type containing integers. 2. The input lists are sorted in non-decreasing order. 3. The resultant list should be sorted in non-decreasing order. 4. If input is not of list type, the function should raise an assertion error with a specific message. # Edge Cases to Consider: - One or both input lists are empty. - Large lists with considerable number of elements. - Lists containing negative integers. - Input lists of different lengths. # Inputs: - `list_a` and `list_b`: Two sorted lists of integers. # Outputs: - A sorted list containing all common elements between `list_a` and `list_b`. Implement the function `common_elements` to compute the result based on the provided template and constraints.","solution":"def common_elements(list_a: list, list_b: list) -> list: Returns a sorted list of integers that are common in both list_a and list_b. if not isinstance(list_a, list) or not all(isinstance(x, int) for x in list_a): raise AssertionError(\\"Input list_a must be a list of integers\\") if not isinstance(list_b, list) or not all(isinstance(x, int) for x in list_b): raise AssertionError(\\"Input list_b must be a list of integers\\") # Pointers for both lists i, j = 0, 0 common = [] # Use two-pointer technique since lists are already sorted while i < len(list_a) and j < len(list_b): if list_a[i] < list_b[j]: i += 1 elif list_a[i] > list_b[j]: j += 1 else: # Both elements are same common.append(list_a[i]) i += 1 j += 1 return common"},{"question":"# K-means Clustering for Customer Segmentation You have been provided with a dataset containing customer data, including various features such as age, income, and spending score. Your task is to implement a K-means clustering algorithm to segment the customers into distinct groups based on their features. **Function Signature**: ```python def k_means_clustering( data: np.ndarray, num_clusters: int, max_iterations: int = 300, tolerance: float = 1e-4 ) -> Tuple[np.ndarray, np.ndarray, List[float]]: ``` **Input**: - `data`: A 2D numpy array of shape `(n_samples, n_features)`, where `n_samples` is the number of customers and `n_features` is the number of features. - `num_clusters`: An integer representing the number of clusters to form. - `max_iterations`: An optional integer representing the maximum number of iterations to run the algorithm (defaults to 300). - `tolerance`: An optional float representing the tolerance for convergence (defaults to 1e-4). **Output**: - A tuple containing: 1. `centroids`: A 2D numpy array of shape `(num_clusters, n_features)` containing the coordinates of the cluster centroids. 2. `labels`: A 1D numpy array of shape `(n_samples,)` containing the cluster labels for each sample. 3. `inertia`: A list of floats representing the sum of squared distances of samples to their closest cluster center for each iteration. **Constraints**: - Ensure `num_clusters` is a positive integer less than or equal to `n_samples`. - All inputs must be provided in the correct formats and will always contain valid data. - The algorithm should terminate either upon reaching the `max_iterations` or when the change in centroids is less than the specified `tolerance`. Your implementation should include the following steps: 1. Initialize the cluster centroids randomly from the data points. 2. Assign each sample to the nearest centroid. 3. Update centroids as the mean of the assigned samples. 4. Repeat steps 2 and 3 until convergence or until the maximum number of iterations is reached. # Example ```python import numpy as np data = np.array([ [25, 40000], [34, 60000], [22, 55000], [27, 65000], [35, 70000], [40, 75000] ]) num_clusters = 2 centroids, labels, inertia = k_means_clustering(data, num_clusters) print(\\"Centroids:n\\", centroids) print(\\"Labels:n\\", labels) print(\\"Inertia:n\\", inertia) ``` Write your implementation for the `k_means_clustering` function below, ensuring adherence to the above specifications and requirements.","solution":"import numpy as np from typing import Tuple, List def k_means_clustering( data: np.ndarray, num_clusters: int, max_iterations: int = 300, tolerance: float = 1e-4 ) -> Tuple[np.ndarray, np.ndarray, List[float]]: # Step 1: Randomly initialize the cluster centroids np.random.seed(42) # For reproducibility indices = np.random.choice(data.shape[0], num_clusters, replace=False) centroids = data[indices] inertia_history = [] for _ in range(max_iterations): # Step 2: Assign each sample to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) labels = np.argmin(distances, axis=1) # Step 3: Calculate the new centroids new_centroids = np.array([data[labels == k].mean(axis=0) for k in range(num_clusters)]) # Calculate inertia inertia = np.sum(np.min(distances, axis=1) ** 2) inertia_history.append(inertia) # Check for convergence centroid_shifts = np.linalg.norm(centroids - new_centroids, axis=1) if np.max(centroid_shifts) < tolerance: break centroids = new_centroids return centroids, labels, inertia_history"},{"question":"# Problem Statement In this task, you will be working with a string manipulation and computation problem that involves frequency analysis. Implement a function that accepts a string and computes the frequency of each character in the string. Additionally, enhance this function to find and return the character with the highest frequency. If there are multiple characters with the same highest frequency, return the one that appears first in the string. # Implementation Details 1. **Character Frequency Count**: - Implement a function `char_frequency` that takes a string as input and returns a dictionary with characters as keys and their respective frequencies as values. 2. **Highest Frequency Character**: - Implement a function `highest_frequency_char` that takes the same string input and returns the character with the highest frequency. - In the case of a tie where two or more characters have the same highest frequency, the function should return the character that appears first in the string. # Expected Input and Output 1. **Character Frequency Count**: - **Input**: A single string `s` - **Output**: A dictionary containing character frequencies - **Example**: ```python print(char_frequency(\\"mississippi\\")) # Output: {\'m\': 1, \'i\': 4, \'s\': 4, \'p\': 2} ``` 2. **Highest Frequency Character**: - **Input**: A single string `s` - **Output**: A single character `c` - **Example**: ```python print(highest_frequency_char(\\"mississippi\\")) # Output: \'i\' ``` # Constraints * The input string may contain any printable characters including spaces, punctuation, and alphanumeric. * The input string will have a length of at least 1 and at most 10^5 characters. Implement the `char_frequency` and `highest_frequency_char` functions based on the given input and output specifications.","solution":"def char_frequency(s): Returns a dictionary with character frequencies in the input string. :param s: Input string :return: Dictionary with characters as keys and their frequencies as values frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def highest_frequency_char(s): Returns the character with the highest frequency in the input string. In case of a tie, returns the character that appears first in the string. :param s: Input string :return: Character with the highest frequency frequency = char_frequency(s) max_freq = 0 max_char = None for char in s: if frequency[char] > max_freq: max_freq = frequency[char] max_char = char return max_char"},{"question":"# Coding Assessment Question Scenario You are working on an image processing application which includes an operation to calculate the brightness of a grayscale image. Brightness is defined as the average pixel value of the image. Implement a function to compute the brightness for a given grayscale image represented as a 2D list of integers. Task Implement the function `calculate_brightness` which takes a 2D list of integers representing the pixel values of a grayscale image and returns the overall brightness of the image. The pixel values range from 0 to 255 inclusive. Requirements - Define the function `calculate_brightness(image: list[list[int]]) -> float`. - The function should handle an empty image (return a brightness of 0 in such cases). - Ensure correct handling of images with varied dimensions. - Provide sufficient test cases to validate your implementation. Constraints - Each value in the 2D list (image) is an integer between 0 and 255 inclusive. - The dimensions of the image: 0 ≤ width, height ≤ 10^3. - Ensure the function completes within a reasonable time frame (1 second) for the maximum input size. Performance Requirements - Time Complexity: O(m * n), where m is the number of rows and n is the number of columns in the image. - Space Complexity: O(1), fixed space usage regardless of input size. Example ```python >>> calculate_brightness([[0, 0, 0], [255, 255, 255], [127, 127, 127]]) 127.0 >>> calculate_brightness([]) 0.0 >>> calculate_brightness([[34, 56, 78], [123, 145, 167]]) 100.5 ```","solution":"def calculate_brightness(image): Calculates the brightness of a given grayscale image represented as a 2D list of integers. Brightness is defined as the average pixel value of the image. :param image: 2D list of integers representing the pixel values of a grayscale image :return: Brightness of the image as a float # If the image is empty, return a brightness of 0.0 if not image or not image[0]: return 0.0 total_pixels = 0 sum_brightness = 0 for row in image: for pixel in row: sum_brightness += pixel total_pixels += 1 return sum_brightness / total_pixels"},{"question":"# Coding Assessment Question Problem Statement You are given a string that represents a mathematical expression containing non-negative integers and the operators `+`, `-`, `*`, and `/` (integer division). Write a function to evaluate the value of this expression. The function should adhere to the standard operator precedence and use integer division for the `/` operator, meaning the division result should be rounded towards zero. Function Signature ```python def evaluate_expression(expression: str) -> int: ``` Input - `expression`: A string representing a mathematical expression containing non-negative integers and the operators `+`, `-`, `*`, and `/`. Constraints: - The length of the string is between 1 and 1000. - Each operator and operand is non-negative, and the expression is guaranteed to be valid. Output - The function should return a single integer which is the result of evaluating the mathematical expression. Examples ```python >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 >>> evaluate_expression(\\"10+0*5\\") 10 ``` Constraints & Considerations - Handle edge cases such as spaces within the expression and ensure that the division by zero is not encountered. - The function should raise a `ValueError` if the expression is invalid or if a division by zero occurs, with an appropriate message (\\"Invalid Expression\\" or \\"Division by zero\\"). - Consider the possibility of invalid characters in the expression and handle them accordingly. - Aim for a solution with linear time complexity. Detailed Explanation 1. **Tokenize the Expression**: - Separate numbers and operators while ignoring spaces. 2. **Operator Precedence and Evaluation**: - Use a stack to handle the operator precedence. - Scan the expression and push numbers onto the stack. - For `*` and `/` operators, immediately evaluate the expression using the top value on the stack. - For `+` and `-` operators, push them onto the stack for later evaluation. 3. **Final Calculation**: - After processing all tokens, perform the final addition and subtraction operations to obtain the result.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators +, -, *, and / with correct operator precedence. Args: expression (str): The input mathematical expression as a string. Returns: int: The result of evaluating the expression. Raises: ValueError: If the expression is invalid or contains division by zero. import re if not expression: raise ValueError(\\"Invalid Expression\\") # Regular expression to check for invalid characters in the expression if re.search(r\'[^0-9+-*/ ]\', expression): raise ValueError(\\"Invalid Expression\\") # Initialize variables stack = [] current_num = 0 operation = \\"+\\" expression = expression.replace(\\" \\", \\"\\") length = len(expression) for i in range(length): char = expression[i] if char.isdigit(): current_num = current_num * 10 + int(char) if char in \\"+-*/\\" or i == length - 1: if operation == \'+\': stack.append(current_num) elif operation == \'-\': stack.append(-current_num) elif operation == \'*\': stack.append(stack.pop() * current_num) elif operation == \'/\': top = stack.pop() if current_num == 0: raise ValueError(\\"Division by zero\\") stack.append(int(top / current_num)) operation = char current_num = 0 return sum(stack)"},{"question":"# Problem Description Given a string `s` that consists of both alphabets and digits, split the string into substrings such that each substring contains either only alphabets or only digits. Return a list of the substrings in the order they appear in the input string. # Function Definition Define a function `split_string(s: str) -> List[str]` that takes a string `s` and returns a list of substrings each containing only alphabets or only digits. # Input * **s** (str): A string containing mixed alphabets and digits (1 <= len(s) <= 100). # Output * **List[str]**: A list of substrings containing only alphabets or only digits. # Examples Example 1: **Input**: ```python s = \\"abc123def456\\" ``` **Output**: ```python [\\"abc\\", \\"123\\", \\"def\\", \\"456\\"] ``` **Explanation**: The input string is split into substrings containing only alphabets or only digits. Example 2: **Input**: ```python s = \\"a1b2c3\\" ``` **Output**: ```python [\\"a\\", \\"1\\", \\"b\\", \\"2\\", \\"c\\", \\"3\\"] ``` **Explanation**: Each character alternates between alphabet and digit, resulting in single-character substrings. Example 3: **Input**: ```python s = \\"123abc456def\\" ``` **Output**: ```python [\\"123\\", \\"abc\\", \\"456\\", \\"def\\"] ``` **Explanation**: The numeric and alphabetic substrings are combined as they appear consecutively in the input string. # Constraints * The input string `s` only contains alphabets (`a-z`, `A-Z`) and digits (`0-9`). # Notes - Handle cases where the input string starts or ends with either digits or alphabets. - Ensure multiple consecutive characters of the same type are grouped into a single substring. **Please provide your implementation below:**","solution":"from typing import List def split_string(s: str) -> List[str]: Splits the input string into substrings each containing only alphabets or only digits. if not s: return [] result = [] current_substring = s[0] for char in s[1:]: if char.isdigit() == current_substring[-1].isdigit(): current_substring += char else: result.append(current_substring) current_substring = char result.append(current_substring) return result"},{"question":"# Problem Statement: Matrix Spiral Sum Write a function to calculate the sum of matrix elements in a spiral order, starting from the top-left element and moving clockwise. You need to ensure that the function handles both square and rectangular matrices. # Requirements 1. **Function Implementation**: Implement the function `spiral_matrix_sum(matrix: list[list[int]]) -> int` 2. **Input**: * `matrix` - A list of lists of integers representing the matrix. 3. **Output**: * Returns the sum of the matrix elements visited in spiral order. # Constraints 1. The matrix will have at least one element. 2. The matrix dimensions can range from 1x1 to 100x100. 3. All elements in the matrix are integers. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = spiral_matrix_sum(matrix) print(result) # Expected Output: 45 (because the spiral order visit is: 1, 2, 3, 6, 9, 8, 7, 4, 5) matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] result = spiral_matrix_sum(matrix) print(result) # Expected Output: 78 (because the spiral order visit is: 1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7) ``` # Requirements 1. Ensure that the function efficiently sums the elements in spiral order without re-visiting any element. 2. Optimize for clarity and efficiency, avoiding redundant calculations where possible.","solution":"def spiral_matrix_sum(matrix): Returns the sum of matrix elements in spiral order, starting from the top-left element. if not matrix: return 0 sum_spiral = 0 while matrix: # add the first row sum_spiral += sum(matrix.pop(0)) # add the last element of each remaining row if matrix and matrix[0]: for row in matrix: sum_spiral += row.pop() # add the last row in reverse order if matrix: sum_spiral += sum(matrix.pop()[::-1]) # add the first element of each remaining row (in reverse order) if matrix and matrix[0]: for row in matrix[::-1]: sum_spiral += row.pop(0) return sum_spiral"},{"question":"# Coding Assessment Question Context As part of your role in a data analytics company, you need to develop custom data processing utilities. One of the tools required is a function to generate moving averages over a sliding window. A moving average provides a smoothed version of the input values by averaging values inside the window. Problem Statement **Task**: Implement a `moving_average` function in Python that calculates the moving average with a specified window size over a given list of integers. Additionally, implement a `generate_moving_average_report` function to create a readable report of the moving averages. * **Function Specifications**: - **Function 1**: `moving_average` - **Input**: A list of integers (`data`) and an integer (`window_size`). - **Output**: A list of floating-point numbers representing the moving averages. - **Function 2**: `generate_moving_average_report` - **Input**: A list of integers (`data`) and an integer (`window_size`). - **Output**: A formatted string report of window positions and their corresponding moving averages. * **Constraints**: - Elements in `data` are integers between `-1000` and `1000`. - `window_size` must be a positive integer and not greater than the length of `data`. - If `window_size` is greater than the length of `data`, raise a `ValueError`. - The moving average should cover all possible windows in the data if `window_size` is valid. * **Performance Requirements**: - The solution should have O(n) complexity for calculating the moving averages, where `n` is the length of `data`. - The report generation should iterate over the resulting moving averages efficiently. Example Usage ```python def moving_average(data: list[int], window_size: int) -> list[float]: Calculate the moving averages over a sliding window. >>> moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0] >>> moving_average([10, 20, 30, 40, 50], 2) [15.0, 25.0, 35.0, 45.0] >>> moving_average([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: window_size must be less than or equal to the length of data def generate_moving_average_report(data: list[int], window_size: int) -> str: Generate a report of moving averages. >>> print(generate_moving_average_report([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)) Moving Average Report: Window (0 to 2): 2.0 Window (1 to 3): 3.0 Window (2 to 4): 4.0 Window (3 to 5): 5.0 Window (4 to 6): 6.0 Window (5 to 7): 7.0 Window (6 to 8): 8.0 Window (7 to 9): 9.0 >>> print(generate_moving_average_report([10, 20, 30, 40, 50], 2)) Moving Average Report: Window (0 to 1): 15.0 Window (1 to 2): 25.0 Window (2 to 3): 35.0 Window (3 to 4): 45.0 if __name__ == \\"__main__\\": import doctest doctest.testmod() print(generate_moving_average_report([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)) ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"def moving_average(data, window_size): if window_size > len(data): raise ValueError(\\"window_size must be less than or equal to the length of data\\") averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] averages.append(sum(window) / window_size) return averages def generate_moving_average_report(data, window_size): averages = moving_average(data, window_size) report_lines = [\\"Moving Average Report:\\"] for i in range(len(averages)): report_lines.append(f\\"Window ({i} to {i + window_size - 1}): {averages[i]}\\") return \\"n\\".join(report_lines)"},{"question":"Problem Statement You are given the task of implementing a simplified relational database system that supports basic Insert, Delete, and Select operations. Your database system should maintain records in a table, where each record consists of a fixed number of fields: `id` (an integer serving as the primary key), `name` (a string), and `age` (an integer). Your task is to implement the following functions: 1. `insert_record(records: List[Dict], id: int, name: str, age: int) -> List[Dict]` 2. `delete_record(records: List[Dict], id: int) -> List[Dict]` 3. `select_records(records: List[Dict], min_age: int, max_age: int) -> List[Dict]` # Input - The `insert_record` function takes a list of current records, an `id`, a `name`, and an `age` as parameters. - The `delete_record` function takes a list of current records and an `id` to delete the corresponding record. - The `select_records` function takes a list of current records and two integers, `min_age` and `max_age`, representing an age range. # Output - The `insert_record` function returns the updated list of records with the new record added. - The `delete_record` function returns the updated list of records with the specified record removed. - The `select_records` function returns a list of records where the `age` is within the provided age range (inclusive). # Constraints - The `id` field of each record is unique. - The `name` field is a string containing only alphabetical characters and has at most 100 characters. - The `age` field is an integer between 0 and 150. - There will be at most 1000 records in the table. # Example ```python # Initial records records = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 24} ] # Insert a new record records = insert_record(records, 3, \\"Charlie\\", 19) # records will now be: # [ # {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, # {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 24}, # {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 19} # ] # Delete a record records = delete_record(records, 2) # records will now be: # [ # {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, # {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 19} # ] # Select records within an age range selected_records = select_records(records, 18, 30) # selected_records will be: # [ # {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30}, # {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 19} # ] ``` # Guidance - Ensure that `insert_record` checks for an existing `id` and raises an exception if the `id` already exists. - Ensure that `delete_record` only deletes the record if it exists; otherwise, it should return the list unchanged. - Ensure that `select_records` returns only the records within the specified age range. # Sample Function Definitions ```python def insert_record(records: List[Dict], id: int, name: str, age: int) -> List[Dict]: # Your code here def delete_record(records: List[Dict], id: int) -> List[Dict]: # Your code here def select_records(records: List[Dict], min_age: int, max_age: int) -> List[Dict]: # Your code here ```","solution":"from typing import List, Dict def insert_record(records: List[Dict], id: int, name: str, age: int) -> List[Dict]: Inserts a new record into the list of records if the id is unique. if any(record[\'id\'] == id for record in records): raise ValueError(f\\"Record with id {id} already exists.\\") records.append({\\"id\\": id, \\"name\\": name, \\"age\\": age}) return records def delete_record(records: List[Dict], id: int) -> List[Dict]: Deletes the record with the specified id from the list of records. records = [record for record in records if record[\'id\'] != id] return records def select_records(records: List[Dict], min_age: int, max_age: int) -> List[Dict]: Returns the list of records where the age is within the specified range [min_age, max_age]. return [record for record in records if min_age <= record[\'age\'] <= max_age]"},{"question":"# Problem Statement You are required to implement a function that determines if a given positive integer is a power of three using only bitwise operations. Your task is to complete the function `is_power_of_three` which takes a positive integer as input and returns a boolean indicating whether the number is a power of three. # Function Signature ```python def is_power_of_three(number: int) -> bool: Determines if a given positive integer is a power of three using bitwise operations. Parameters: number (int): A positive integer Returns: bool: True if the number is a power of three, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is not a positive integer. Examples: >>> is_power_of_three(1) True >>> is_power_of_three(3) True >>> is_power_of_three(9) True >>> is_power_of_three(15) False >>> is_power_of_three(27) True >>> is_power_of_three(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(-3) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(\\"3\\") Traceback (most recent call last): ... TypeError: The input must be an integer! pass ``` # Requirements * Your implementation should handle all edge cases, including non-integer or negative inputs, raising appropriate exceptions: `TypeError` and `ValueError`. * Your function must use bitwise operations as part of the solution. # Constraints * Inputs will be positive integers within the range of typical mathematical limits for powers of three. * Performance is crucial: your solution should handle the full range of input values efficiently, including edge cases. # Testing Your solution will be tested with varying input sizes, including edge cases and performance benchmarks. Make sure to test with inputs at the boundary of constraints to ensure robustness.","solution":"def is_power_of_three(number): Determines if a given positive integer is a power of three using bitwise operations. Parameters: number (int): A positive integer Returns: bool: True if the number is a power of three, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is not a positive integer. Examples: >>> is_power_of_three(1) True >>> is_power_of_three(3) True >>> is_power_of_three(9) True >>> is_power_of_three(15) False >>> is_power_of_three(27) True >>> is_power_of_three(0) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(-3) Traceback (most recent call last): ... ValueError: The input must be a positive integer!! >>> is_power_of_three(\\"3\\") Traceback (most recent call last): ... TypeError: The input must be an integer! if not isinstance(number, int): raise TypeError(\\"The input must be an integer!\\") if number <= 0: raise ValueError(\\"The input must be a positive integer!!\\") # The largest power of three that fits in a 32-bit integer max_power_of_three = 1162261467 # 3^19, since 3^20 is beyond 32-bit int range # number is a power of three if max_power_of_three % number == 0 return max_power_of_three % number == 0"},{"question":"**Context:** You are tasked with implementing a data structure to keep track of the median of a dynamically changing list of numbers. This data structure is frequently needed in scenarios such as real-time data analysis, where maintaining quick access to the median is crucial. # Task: Implement a class that supports adding numbers to a list of elements and finding the median of the list. The class should support the following operations: - `add_num(num)`: Adds `num` to the list. - `find_median()`: Returns the median of the list. # Specifications: 1. Implement the class such that: - `add_num` operation has O(log n) time complexity. - `find_median` operation has O(1) time complexity. 2. Median of a list is defined as: - The middle element if the list length is odd. - The average of the two middle elements if the list length is even. 3. Handle edge cases appropriately (e.g., finding the median of an empty list should raise an error). # Input and Output: Your methods must match the following signatures: - `add_num(num: int) -> None` - `find_median() -> float` # Constraints: - Assume all numbers are integers. - Maximum number of elements tracked: 10^5. - Each `find_median` operation should either return a float or raise a ValueError if the list is empty. **Example:** ```python class MedianTracker: # Your implementation here tracker = MedianTracker() tracker.add_num(1) tracker.add_num(3) assert tracker.find_median() == 2.0 # (1 + 3) / 2 tracker.add_num(2) assert tracker.find_median() == 2.0 # 2 is the middle element try: empty_tracker = MedianTracker() empty_tracker.find_median() except ValueError: assert True # Expected behavior ```","solution":"import heapq class MedianTracker: def __init__(self): self.min_heap = [] # to store the larger half self.max_heap = [] # to store the smaller half def add_num(self, num: int) -> None: heapq.heappush(self.max_heap, -num) # max_heap is a max-heap by pushing negative numbers heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Balance the heaps if the min_heap gets more elements if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if not self.min_heap and not self.max_heap: raise ValueError(\\"The list is empty\\") if len(self.min_heap) == len(self.max_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return -self.max_heap[0]"},{"question":"# Coding Challenge **Scenario**: You are given an array of integers. Your task is to re-arrange the integers such that all the even numbers come before all the odd numbers while maintaining the relative order of the even and odd numbers. **Function Signature**: ```python def rearrange_even_odd(nums: list[int]) -> list[int]: pass ``` # Input * `nums` (list[int]): A list of integers ( (1 leq text{len}(nums) leq 10^3) ). # Output * (list[int]): A list of integers where all even numbers appear before all odd numbers, maintaining the relative order. # Constraints * Each element in the `nums` list is a non-negative integer. # Examples **Example 1** * Input: ```python nums = [1, 2, 3, 4, 5, 6] ``` * Output: ```python [2, 4, 6, 1, 3, 5] ``` **Example 2** * Input: ```python nums = [3, 1, 2] ``` * Output: ```python [2, 3, 1] ``` # Guidelines: * The solution should maintain the relative order of even and odd numbers as they appeared in the original list. * Consider edge cases such as a list with all even numbers or all odd numbers, and lists with a single element. * Optimize the solution\'s time complexity to be linear (O(n)) where (n) is the length of the input list. * Ensure robustness in handling the largest constraint.","solution":"def rearrange_even_odd(nums: list[int]) -> list[int]: Re-arrange the integers such that all the even numbers come before all the odd numbers while maintaining the relative order. even_nums = [num for num in nums if num % 2 == 0] odd_nums = [num for num in nums if num % 2 != 0] return even_nums + odd_nums"},{"question":"# Sum of All Unique Elements You need to write a function that calculates the sum of all unique elements in a list of integers. This problem will test your ability to use data structures to track and process elements efficiently. Function Signature ```python def sum_of_unique_elements(nums: list) -> int: ``` Input and Output Formats * **Input**: * `nums`: A list of integers. * **Constraints**: * The list can contain negative integers. * The list can be of any length, including zero. * **Output**: * An integer representing the sum of all unique elements. Example ```python # Example 1 assert sum_of_unique_elements([1, 2, 3, 2]) == 4 # 1 and 3 are unique # Example 2 assert sum_of_unique_elements([4, 4, 4, 4]) == 0 # no unique elements # Example 3 assert sum_of_unique_elements([]) == 0 # empty list # Example 4 assert sum_of_unique_elements([-1, 1, -1, 1, 0]) == 0 # 0 is the only unique element # Example 5 assert sum_of_unique_elements([10, 20, 30, 40, 50]) == 150 # all are unique ``` Explanation 1. For the input `[1, 2, 3, 2]`, only `1` and `3` are unique, so their sum is `4`. 2. For the input `[4, 4, 4, 4]`, there are no unique elements, so the sum is `0`. 3. An empty list should trivially return `0` since there are no elements to sum. 4. For `[-1, 1, -1, 1, 0]`, `0` is the only unique element, so the sum is `0`. 5. In `[10, 20, 30, 40, 50]`, all elements are unique, so their sum is `150`. Instructions 1. Implement the function according to the provided signature. 2. Use a data structure to keep track of the frequency of each element. 3. Identify unique elements (those with a frequency of 1). 4. Calculate and return the sum of these unique elements.","solution":"def sum_of_unique_elements(nums: list) -> int: Calculate the sum of all unique elements in a list of integers. Args: nums (list): A list of integers. Returns: int: The sum of unique elements. from collections import Counter # Count the frequency of each element in the list element_count = Counter(nums) # Identify and sum the unique elements unique_sum = sum(num for num, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Task You are given a collection of tasks with varying durations and deadlines, and you need to determine the optimal scheduling order to maximize the total number of tasks completed on or before their deadlines. # Problem Statement Given a list of tasks where each task has a duration and a deadline, determine the maximum number of tasks that can be completed without exceeding their individual deadlines. Input * An integer `t` representing the number of tasks. * An array of tuples, where each tuple `(d, l)` represents a task with duration `d` and deadline `l`. Output * An integer representing the maximum number of tasks that can be completed on or before their deadlines. Constraints * `1 <= t <= 10^5` * `1 <= d, l <= 10^4` Example ```plaintext Input: 5 3 5 2 7 4 6 1 3 2 2 Output: 3 ``` # Explanation The tasks are as follows: 1. Task with duration 3 and deadline 5 2. Task with duration 2 and deadline 7 3. Task with duration 4 and deadline 6 4. Task with duration 1 and deadline 3 5. Task with duration 2 and deadline 2 An optimal schedule would be: * Complete the task with duration 2 and deadline 2 * Complete the task with duration 1 and deadline 3 * Complete the task with duration 2 and deadline 7 This allows for the completion of a maximum of 3 tasks. # Instructions * Implement the function `max_completed_tasks(t: int, tasks: list[tuple[int, int]]) -> int`. * Ensure the implementation efficiently handles the constraints. * Use a greedy algorithm to determine the optimal scheduling order. # Notes * Consider sorting tasks by their deadlines to maximize the number of tasks completed. * Prioritize tasks with shorter durations when deciding how to fill the remaining available time. * You may use a priority queue to manage and schedule tasks efficiently.","solution":"import heapq def max_completed_tasks(t, tasks): This function takes in a number of tasks and a list of tuples where each tuple represents (duration, deadline) of a task. The function returns the maximum number of tasks that can be completed on or before their deadlines. # Sort tasks by their deadline tasks.sort(key=lambda x: x[1]) current_time = 0 max_heap = [] for duration, deadline in tasks: if current_time + duration <= deadline: heapq.heappush(max_heap, -duration) current_time += duration elif max_heap and -max_heap[0] > duration: longest_duration = -heapq.heappop(max_heap) current_time -= longest_duration current_time += duration heapq.heappush(max_heap, -duration) return len(max_heap)"},{"question":"# Coding Question You are tasked to design a Python function that processes an input text file and produces an output with specific formatting and content tailoring. The function should read lines from the file, filter and transform the data according to certain rules, and then write the formatted result into another file. Function Requirements: - **Function Name**: `process_file_data` - **Inputs**: - `input_file` (str): The path to the input text file. - `output_file` (str): The path to the output text file. - `filter_word` (str): A word to filter out lines from the input file (default = None). - `transform_case` (str): Case transformation on each word (\\"upper\\", \\"lower\\", \\"title\\", None) (default = None). - **Outputs**: - None. All results should be written to the specified output file. - **Constraints**: - If the input file does not exist, raise a `FileNotFoundError` with the message \\"Input file not found: {input_file}\\". - If an invalid case transformation is provided, raise a `ValueError` with the message \\"Invalid case transformation: {transform_case}\\". - Words should be separated by a single space in the output file. - **Performance**: Ensure that the function can handle reasonably large files efficiently. Aim for minimal memory usage by processing lines one-by-one. - **Edge Cases**: - Empty input file. - Empty or None filter word. - None or unsupported case transformation. # Example Input File Format ```plaintext hello world this is a test filter this sentence another line here ``` # Example Usage ```python try: process_file_data( input_file=\\"input.txt\\", output_file=\\"output.txt\\", filter_word=\\"filter\\", transform_case=\\"upper\\" ) except FileNotFoundError as fnfe: print(fnfe) except ValueError as ve: print(ve) ``` # Example Output File Format (For the above example usage, if the input was as provided) ```plaintext HELLO WORLD THIS IS A TEST ANOTHER LINE HERE ``` # Example Solution Signature ```python def process_file_data( input_file: str, output_file: str, filter_word: str | None = None, transform_case: str | None = None ) -> None: # Your code here pass ```","solution":"def process_file_data(input_file, output_file, filter_word=None, transform_case=None): Processes an input text file by filtering and transforming lines, then writes the result to an output file. :param input_file: Path to the input text file. :param output_file: Path to the output text file. :param filter_word: Word to filter out lines containing it (default None). :param transform_case: Case transformation (\\"upper\\", \\"lower\\", \\"title\\", None) (default None). :raise FileNotFoundError: If the input file does not exist. :raise ValueError: If an invalid case transformation is provided. if transform_case not in (None, \\"upper\\", \\"lower\\", \\"title\\"): raise ValueError(f\\"Invalid case transformation: {transform_case}\\") try: with open(input_file, \'r\') as infile: lines = infile.readlines() except FileNotFoundError: raise FileNotFoundError(f\\"Input file not found: {input_file}\\") with open(output_file, \'w\') as outfile: for line in lines: if filter_word and filter_word in line: continue if transform_case == \\"upper\\": line = line.upper() elif transform_case == \\"lower\\": line = line.lower() elif transform_case == \\"title\\": line = line.title() outfile.write(line)"},{"question":"# Problem Statement: Maximal Square of 1\'s in Binary Matrix You are given a binary matrix `m` of size `r x c` (where each element is either 0 or 1). Your task is to find the side length of the largest square containing only `1`s in the matrix. # Detailed Requirements: - You are given an `r x c` binary matrix `m`, where `m[i][j]` is a binary integer (0 or 1). - Your task is to determine the side length of the largest square that can be formed entirely of `1`s within the matrix. **Input**: - An integer `r`, the number of rows in the matrix (1 <= r <= 300). - An integer `c`, the number of columns in the matrix (1 <= c <= 300). - A 2D list `m` of size `r x c` containing the binary elements. **Output**: - A single integer representing the side length of the largest square of 1\'s in the matrix. # Constraints: - Matrix dimensions are at most 300 x 300 which requires efficient memory and time handling. # Example: ```python def maximal_square(matrix: list[list[int]]) -> int: # Implement this function pass # Example Use Cases assert maximal_square( [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ] ) == 2 assert maximal_square( [ [0, 1], [1, 0] ] ) == 1 assert maximal_square( [ [0] ] ) == 0 assert maximal_square( [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] ) == 4 ``` # Guidelines: - **Edge Cases**: Handle cases where the matrix dimensions are at their minimum or filled mostly (or entirely) with 0\'s. - **Performance**: Aim for a time complexity of around O(r * c) by leveraging dynamic programming techniques. - **Memory Optimization**: Optimize space usage by using a single additional array rather than creating a new 2D DP array if possible.","solution":"def maximal_square(matrix: list[list[int]]) -> int: if not matrix or not matrix[0]: return 0 r = len(matrix) c = len(matrix[0]) max_side = 0 # Create a DP array to store the side length of the largest square ending at (i, j) dp = [[0] * c for _ in range(r)] for i in range(r): for j in range(c): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"# Task Implement a function `optimize_prime_factors` that extends the basic prime factorization to include memoization for improved performance, especially for repeated queries of the same number. # Scenarios Your function will be used in number theory analysis to quickly retrieve the prime factors of various numbers, leveraging memoization to handle large inputs efficiently. # Input - An integer `n_input` for which the prime factors need to be computed. The value of `n_input` will be a positive integer greater than 1. # Output - A list of integers representing the prime factors of the input number. # Constraints 1. The input integer will be greater than 1. 2. If the function receives a non-integer input, it should raise a `ValueError`. # Requirements - The function should use memoization to store previously computed prime factors to enhance performance for repeated queries. - Handle edge cases where the input number might be very large efficiently. # Hints - Utilize a dictionary or similar data structure for memoizing results of previous computations. - Implement an efficient algorithm for prime factorization (e.g., trial division or Pollard\'s rho algorithm). # Example ```python def optimize_prime_factors(n_input: int) -> list[int]: # Your implementation here pass # Example Test Cases: print(optimize_prime_factors(60)) # Expected output: [2, 2, 3, 5] print(optimize_prime_factors(97)) # Expected output: [97] since 97 is a prime number print(optimize_prime_factors(1)) # Expected output: ValueError since the input must be greater than 1 print(optimize_prime_factors(1024)) # Expected output: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2] because 1024 = 2^10 print(optimize_prime_factors(56)) # Expected output: [2, 2, 2, 7] # Test the memoization with repeated queries print(optimize_prime_factors(56)) # Expected to quickly return: [2, 2, 2, 7] print(optimize_prime_factors(60)) # Expected to quickly return: [2, 2, 3, 5] ```","solution":"def optimize_prime_factors(n_input: int) -> list[int]: Returns the prime factors of the input number using memoization to handle repeated queries efficiently. Args: n_input (int): The number for which prime factors are to be computed. Must be > 1. Returns: list[int]: A list of integers representing the prime factors. Raises: ValueError: If the input is not an integer or if it is <= 1. if not isinstance(n_input, int) or n_input <= 1: raise ValueError(\\"Input must be an integer greater than 1.\\") # Memoization dictionary if not hasattr(optimize_prime_factors, \'memo\'): optimize_prime_factors.memo = {} # Return memoized result if available if n_input in optimize_prime_factors.memo: return optimize_prime_factors.memo[n_input] # Prime factorization using trial division factors = [] divisor = 2 while n_input > 1: while n_input % divisor == 0: factors.append(divisor) n_input //= divisor divisor += 1 if divisor * divisor > n_input: if n_input > 1: factors.append(n_input) break # Memoize result optimize_prime_factors.memo[n_input] = factors return factors"},{"question":"# Question: Implement a Balanced Split Tree You have been tasked with implementing a data structure which supports efficient range sum queries and element insertion. The goal is to use a balanced binary search tree to maintain the structure, ensuring logarithmic time complexity for insertion and linearithmic time complexity for range queries. Task: Implement the class `BalancedSplitTree` which supports the following methods: - `insert(value: int) -> None`: Insert a value into the tree. - `range_sum(start: int, end: int) -> int`: Return the sum of all values in the tree between the start and end (inclusive). # Constraints: - The values inserted into the tree will be integers. - The start and end values for the range sum query will be within the valid bounds of inserted values. # Requirements: 1. **Class Declaration** 2. **Method Signatures**: - `def insert(self, value: int) -> None:` - `def range_sum(self, start: int, end: int) -> int:` 3. **Input/Output**: - **Input**: For `insert`, an integer value to insert. For `range_sum`, two integers representing the start and end of the range. - **Output**: For `range_sum`, the sum of all values within the specified range. 4. The implementation should aim for logarithmic efficiency for insertions and range sum calculations. # Example: ```python tree = BalancedSplitTree() tree.insert(10) tree.insert(5) tree.insert(15) tree.insert(7) assert tree.range_sum(5, 10) == 22 assert tree.range_sum(10, 15) == 25 tree.insert(12) assert tree.range_sum(10, 15) == 37 ``` **Note**: If the problem cannot be solved due to invalid input constraints, you may raise an appropriate exception.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.sum = key # Maintains the sum of all nodes in the subtree rooted by this node class BalancedSplitTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = Node(value) else: self.root = self._insert(self.root, value) def _insert(self, node, value): if not node: return Node(value) if value < node.key: node.left = self._insert(node.left, value) else: node.right = self._insert(node.right, value) # Update the sum for this node node.sum = node.key + (node.left.sum if node.left else 0) + (node.right.sum if node.right else 0) return node def range_sum(self, start: int, end: int) -> int: return self._range_sum(self.root, start, end) def _range_sum(self, node, start, end): if not node: return 0 if node.key < start: return self._range_sum(node.right, start, end) elif node.key > end: return self._range_sum(node.left, start, end) else: return node.key + self._range_sum(node.left, start, end) + self._range_sum(node.right, start, end)"},{"question":"# Coding Assessment Question Context You are developing a feature for an online store that displays related products to customers based on their browsing history. The goal is to suggest products that are frequently bought together with the product the customer is currently viewing. You need to implement a recommendation system using an appropriate graph traversal technique. Objective Write a function to find the top N recommended products related to a given product based on the number of purchases. Use the Breadth-First Search (BFS) algorithm to explore the product connections. Function Signature ```python def top_n_recommended_products(transactions: dict, product: str, n: int) -> list: Identifies the top N recommended products related to the given product based on transaction data using Breadth-First Search (BFS). Args: transactions (dict): Dictionary representation of product transactions where each key is a product, and its value is a list of products frequently bought together. { \\"productA\\": [\\"productB\\", \\"productC\\", ...], ... } product (str): The product for which recommendations are being sought. n (int): The number of top recommended products to return. Returns: list: A list of top N recommended products, sorted by the number of transactions. If there are fewer than N products related, return all related products. pass ``` Input & Output * **Input**: The function takes a dictionary representing product transactions, a string representing the target product, and an integer representing the number of recommendations. * `transactions`: A dictionary where each key is a product, and the value is a list of products frequently bought together with that product. * `product`: A string indicating the target product. * `n`: An integer indicating the number of top recommended products to return. * **Output**: The function should return a list of strings representing the top N recommended products. The recommended products should be sorted in descending order based on the frequency of transactions. If there are fewer than N related products, return all related products. Constraints * You may assume that all products have non-negative transaction counts. * The transaction data does not include self-loops (i.e., a product is not listed as related to itself). Example ```python transactions = { \\"laptop\\": [\\"mouse\\", \\"keyboard\\", \\"monitor\\"], \\"mouse\\": [\\"mousepad\\", \\"keyboard\\"], \\"keyboard\\": [\\"mousepad\\", \\"monitor\\"], \\"monitor\\": [\\"hdmi_cable\\"], \\"mousepad\\": [], \\"hdmi_cable\\": [] } product = \\"laptop\\" n = 3 assert top_n_recommended_products(transactions, product, n) == [\\"mouse\\", \\"keyboard\\", \\"monitor\\"] ``` Performance Requirements * The implementation should efficiently handle transaction graphs with up to 5,000 products and 20,000 connections.","solution":"from collections import deque, defaultdict def top_n_recommended_products(transactions, product, n): Identifies the top N recommended products related to the given product based on transaction data using Breadth-First Search (BFS). Args: transactions (dict): Dictionary representation of product transactions where each key is a product, and its value is a list of products frequently bought together. { \\"productA\\": [\\"productB\\", \\"productC\\", ...], ... } product (str): The product for which recommendations are being sought. n (int): The number of top recommended products to return. Returns: list: A list of top N recommended products, sorted by the number of transactions. If there are fewer than N products related, return all related products. if product not in transactions: return [] visited = set() queue = deque([product]) recommendations = defaultdict(int) while queue: current = queue.popleft() for neighbor in transactions[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) recommendations[neighbor] += 1 sorted_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True) return [product for product, _ in sorted_recommendations[:n]]"},{"question":"# Coding Challenge: Unique Elements in a List You are tasked with writing a function to determine the unique elements in a given list of integers using set operations. This exercise will test your understanding of data structures and basic algorithms. Problem Description Implement a function named `find_unique_elements` that takes a list of integers as input and returns a list of integers that appear exactly once in the input list. Function Signature: ```python def find_unique_elements(elements: list) -> list: ``` Input: * `elements`: A list of integers. The list can be empty or contain duplicated integers. Output: * A list of integers that appear exactly once in the input list, maintaining the original order of their first appearance. Example: ```python assert find_unique_elements([4, 5, 4, 6, 7, 8, 5]) == [6, 7, 8] assert find_unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] assert find_unique_elements([10, 20, 30, 10, 30, 40]) == [20, 40] assert find_unique_elements([]) == [] assert find_unique_elements([5, 5, 5, 5]) == [] ``` Constraints: * Aim for an efficient solution in terms of time complexity and avoid unnecessary iterations. * The output list should maintain the original order of the first occurrence of each unique element. * You may use set operations for this task, but avoid using built-in functions that directly solve the problem. Additional Considerations: Ensure to handle different types of edge cases effectively, such as an empty list or list with no unique elements.","solution":"def find_unique_elements(elements: list) -> list: Returns a list of integers that appear exactly once in the input list, maintaining the original order of their first appearance. from collections import Counter # Count occurrences of each element element_counts = Counter(elements) # Filter and maintain the order of the first appearance of unique elements unique_elements = [element for element in elements if element_counts[element] == 1] return unique_elements"},{"question":"# Coding Question Problem Statement You are given a list of `n` strings. Each string consists of lowercase alphabets. You have to implement a function `findLongestAnagramGroup(strings: List[str]) -> List[str]` that finds the largest group of anagrams in the list. If there are multiple groups of the same maximum size, return any one of them. The function should return the list of anagrams in that group. # Input and Output Formats * **Input Format**: * `strings`: A list of strings where the number of strings (`n`) may vary. * **Output Format**: * Return a list of strings that form the largest group of anagrams. # Constraints * `1 ≤ n ≤ 10000` * `1 ≤ len(strings[i]) ≤ 100` for all valid `i` # Example Input ```python strings = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] ``` Output ```python [\\"eat\\", \\"tea\\", \\"ate\\"] ``` # Hints * Consider using a dictionary to group anagrams by sorted strings or a similar invariant. Here\'s the function signature: ```python from typing import List def findLongestAnagramGroup(strings: List[str]) -> List[str]: pass ```","solution":"from typing import List from collections import defaultdict def findLongestAnagramGroup(strings: List[str]) -> List[str]: anagram_groups = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagram_groups[sorted_string].append(string) largest_group = [] for group in anagram_groups.values(): if len(group) > len(largest_group): largest_group = group return largest_group"},{"question":"# Spiral Matrix You need to write a function that takes a matrix of integers and returns all items in a spiral order. The function should start at the top-left corner and proceed in a clockwise direction. # Function Signature ```python def spiral_order(matrix: list[list[int]]) -> list[int]: pass ``` # Input - A matrix represented as a list of lists of integers. # Output - A list of integers representing the elements of the matrix in spiral order. # Constraints - The matrix can have varying dimensions, including non-square shapes (e.g., 3x2 or 4x4). # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = spiral_order(matrix1) print(result) # Output: # [1, 2, 3, 6, 9, 8, 7, 4, 5] matrix2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] result = spiral_order(matrix2) print(result) # Output: # [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] matrix3 = [ [1], [2], [3], [4] ] result = spiral_order(matrix3) print(result) # Output: # [1, 2, 3, 4] ``` # Notes - Ensure that the function works with various dimensions, from single row/column matrices to square and rectangular matrices. - Handle edge cases such as single element matrices or empty matrices. - Optimize for both time and space complexity to ensure efficient performance on large matrices. Implement the function using a comprehensive yet efficient approach to ensure correct traversal of matrix elements in a spiral manner.","solution":"def spiral_order(matrix: list[list[int]]) -> list[int]: Returns the elements of the given matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right across the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left across the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"# Scenario You work for a robotics company developing autonomous vehicles. One of your tasks is to program the vehicles to navigate through a grid-based warehouse. The warehouse comprises a series of shelves (obstacles) and open paths. You need to develop an algorithm that allows the vehicle to find the shortest path from its starting position to a designated target position within the grid. # Task Implement a function `shortest_path` which takes in 4 parameters: - A 2D list `grid` of size `n x m` representing the warehouse layout, where `1` denotes an obstacle and `0` denotes an open path. - Two tuples `start` and `target`, representing the starting and target positions in the grid, respectively. The function then computes and returns the shortest path length from the start position to the target position. If no path exists, return `-1`. # Input - A 2D list `grid` of dimensions `n x m`, where each element is either `0` or `1`. - A tuple `start` containing two integers `(x1, y1)` representing the starting position. - A tuple `target` containing two integers `(x2, y2)` representing the target position. # Output - A single integer representing the shortest path length. # Constraints - `1 <= n, m <= 200` - The values in the grid are binary: `0` for open path and `1` for obstacles. - Assume the start and target positions are valid and contain a `0`. - Movement is allowed in four directions: up, down, left, and right. # Performance Requirements - Optimize for the shortest path efficiently, considering the potential size of the grid. # Example Given the grid: ``` [[0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]] ``` Start position: `(0, 0)` Target position: `(4, 3)` The function should return: `7` # Note Ensure your implementation correctly handles edge cases, such as when the start and target positions are the same or when no path exists. ```python from collections import deque def shortest_path(grid, start, target): Computes the shortest path in a grid from start to target position. Args: grid: 2D list representing the warehouse layout. start: Tuple (x1, y1) representing the starting position. target: Tuple (x2, y2) representing the target position. Returns: int: The length of the shortest path from start to target. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 directions = [(0, 1), (0, -1), (1, 0), ( -1, 0)] queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (x, y), dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return -1 # Example usage grid = [[0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]] start = (0, 0) target = (4, 3) print(shortest_path(grid, start, target)) # Output: 7 ```","solution":"from collections import deque def shortest_path(grid, start, target): Computes the shortest path in a grid from start to target position. Args: grid: 2D list representing the warehouse layout. start: Tuple (x1, y1) representing the starting position. target: Tuple (x2, y2) representing the target position. Returns: int: The length of the shortest path from start to target. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (x, y), dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) return -1"},{"question":"# Coding Assessment Question Scenario You are tasked with developing an algorithm to analyze a sequence of integers and identify the longest contiguous subarray where the difference between the maximum and minimum elements within the subarray does not exceed a specified limit. Task Write a function `longest_subarray_within_limit` to determine the length of the longest contiguous subarray that satisfies the above condition. Requirements - You may assume the input list has at least one element. - Your solution should be efficient and manage large datasets within reasonable time limits. Function Signature ```python def longest_subarray_within_limit(nums: List[int], limit: int) -> int: pass ``` Inputs - `nums` (List[int]): A list of integers representing the sequence. - `limit` (int): An integer representing the allowed difference between the maximum and minimum elements within any valid subarray. Output - (int): The length of the longest contiguous subarray where the difference between the maximum and minimum elements does not exceed the given limit. Example ```python >>> longest_subarray_within_limit([8, 2, 4, 7], limit=4) 2 ``` - Explanation: The longest subarray where the difference between the maximum and minimum elements is within 4 is `[2, 4]`. ```python >>> longest_subarray_within_limit([10, 1, 2, 4, 7, 2], limit=5) 4 ``` - Explanation: The longest subarray where the difference between the maximum and minimum elements is within 5 is `[2, 4, 7, 2]`. ```python >>> longest_subarray_within_limit([4, 2, 2, 2, 4, 4, 2, 2], limit=0) 3 ``` - Explanation: The longest subarrays where all elements are the same (and thus their max minus min is 0) are `[2, 2, 2]`. Constraints - The length of the input list `nums` can vary between (1) and (10^5). - Each element in `nums` can vary from (-10^9) to (10^9). - The `limit` value will be a non-negative integer within the range (0) to (10^9). Implement this function to effectively handle all specified constraints and edge cases.","solution":"from collections import deque from typing import List def longest_subarray_within_limit(nums: List[int], limit: int) -> int: Returns the length of the longest contiguous subarray where the difference between the max and min elements within the subarray does not exceed the specified limit. max_deque = deque() min_deque = deque() left = 0 result = 0 for right in range(len(nums)): while max_deque and nums[max_deque[-1]] <= nums[right]: max_deque.pop() while min_deque and nums[min_deque[-1]] >= nums[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while nums[max_deque[0]] - nums[min_deque[0]] > limit: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() result = max(result, right - left + 1) return result"},{"question":"# Task: Implement Min Stack Implement a Python class `MinStack` that supports the following operations: 1. `push(x)`: Pushes the element `x` onto the stack. 2. `pop()`: Removes the element on the top of the stack. 3. `top()`: Retrieves the element on the top of the stack without removing it. 4. `getMin()`: Retrieves the minimum element in the stack in constant time. # Class Interface ```python class MinStack: def __init__(self) -> None: Initializes the stack object. pass def push(self, x: int) -> None: Pushes the element x onto the stack. pass def pop(self) -> None: Removes the element on the top of the stack. pass def top(self) -> int: Retrives the element on the top of the stack. pass def getMin(self) -> int: Retrieves the minimum element in the stack. pass ``` # Constraints * `-2^31 <= x <= 2^31 - 1` * Methods `pop`, `top`, and `getMin` operations will always be called on non-empty stacks. * The solution should maintain O(1) complexity for each of the methods. # Example ```python # Testing MinStack min_stack = MinStack() # Pushing values min_stack.push(-2) min_stack.push(0) min_stack.push(-3) # Getting minimum value assert min_stack.getMin() == -3 # Returns -3 # Popping the top value min_stack.pop() # Getting the top value assert min_stack.top() == 0 # Returns 0 # Getting minimum value again assert min_stack.getMin() == -2 # Returns -2 ```","solution":"class MinStack: def __init__(self) -> None: Initializes the stack object. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Pushes the element x onto the stack. self.stack.append(x) # If the min stack is empty or the current element is smaller than or equal to the current min, push it to the min stack if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on the top of the stack. if self.stack: top_element = self.stack.pop() # If the popped element is the minimum element, pop it from the min stack as well if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Retrives the element on the top of the stack. if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieves the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"**Array Rotation Challenge** # Scenario You are required to implement an efficient algorithm for rotating the elements of an array. This functionality is crucial in scenarios such as text processing, data manipulation, or even gaming mechanics where cyclic rotations are common. # Task Write a function to rotate an array `arr` of size `n` by `k` positions to the right. The rotation should handle both positive and negative values of `k`. # Function Signature ```python def rotate_array(arr: list[int], k: int) -> list[int]: pass ``` # Input * A list of integers, `arr` with length `n` (0 <= n <= 10^6). * An integer `k` representing the number of positions to rotate the array (can be both positive or negative). # Output * A list of integers representing the rotated array. # Constraints * The solution should be optimized to handle large arrays efficiently. * Consider edge cases such as: * Empty list. * Large positive or negative values of `k`. * `k` values larger than `n`. * `k` zero, which means the array should remain unchanged. # Example ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([1, 2, 3, 4, 5, 6, 7], -2) == [3, 4, 5, 6, 7, 1, 2] assert rotate_array([], 3) == [] assert rotate_array([1], 4) == [1] assert rotate_array([1, 2, 3], 0) == [1, 2, 3] assert rotate_array([1, 2, 3, 4, 5], -5) == [1, 2, 3, 4, 5] assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] ``` # Performance - Ensure the function runs in O(n) time complexity. - Minimize additional memory usage. --- This new question, \\"Array Rotation Challenge,\\" aligns with the original set in terms of style, complexity, and scope. It introduces a novel problem related to array manipulation that requires efficient algorithm design and handling of edge cases.","solution":"def rotate_array(arr: list[int], k: int) -> list[int]: Rotates the given array arr by k positions to the right. Handles both positive and negative k values. n = len(arr) if n == 0: return arr # Reduce k to fall within the range of 0 to n-1 k = k % n # Rotate the array by slicing return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question Scenario: You are working as a developer for a software company that has been approached by a bookstore chain to develop an inventory management system. One of the core functionalities required is efficiently tracking and updating book quantities. You have been tasked with implementing a function to handle inventory updates based on a series of transactions. Task: Write a Python function `update_inventory(inventory, transactions)` that updates the given inventory based on a list of transactions. **Function Signature**: ```python def update_inventory(inventory: dict, transactions: list) -> dict: ``` **Input**: - `inventory`: A dictionary where the keys are the book titles (strings) and the values are the quantities (integers). - `transactions`: A list of tuples where each tuple represents a transaction in the form `(book_title, quantity_change)`. - `book_title` is a string representing the title of the book. - `quantity_change` is an integer representing the change in quantity (positive for addition, negative for removal). **Output**: - A dictionary representing the updated inventory after applying all the transactions. **Constraints**: - Inventory quantities should never be negative; if a transaction would result in a negative quantity, set the quantity to zero instead. - All book titles in inventory and transactions are non-empty strings. - Quantities in the inventory and quantity changes in transactions are non-negative integers. **Edge Cases to Handle**: - If the inventory is empty, return an empty dictionary. - If a transaction\'s `quantity_change` is such that it would reduce the book\'s quantity below zero, set that book\'s quantity to zero in the updated inventory. - If a book title in a transaction does not exist in the inventory, add it with the given `quantity_change` (if positive). **Examples**: ```python print(update_inventory({\\"Book A\\": 5, \\"Book B\\": 3}, [(\\"Book A\\", 2), (\\"Book B\\", -4), (\\"Book C\\", 1)])) # Expected Output: {\\"Book A\\": 7, \\"Book B\\": 0, \\"Book C\\": 1} print(update_inventory({\\"Book A\\": 0}, [(\\"Book A\\", -1), (\\"Book B\\", 10)])) # Expected Output: {\\"Book A\\": 0, \\"Book B\\": 10} print(update_inventory({}, [(\\"Book A\\", 5)])) # Expected Output: {\\"Book A\\": 5} ```","solution":"def update_inventory(inventory: dict, transactions: list) -> dict: for book_title, quantity_change in transactions: if book_title in inventory: inventory[book_title] += quantity_change if inventory[book_title] < 0: inventory[book_title] = 0 else: if quantity_change > 0: inventory[book_title] = quantity_change else: inventory[book_title] = 0 return inventory"},{"question":"# Array Rotation You are tasked with writing a function to perform a rotation on a given list of integers. The rotation must be performed in-place, meaning you should not use any additional list or array to accomplish this. Objective: Implement the function `rotate_array` which rotates the elements of an integer array to the right by a given number of steps. # Specifications: - **Function Name**: `rotate_array` - **Input**: - `arr`: a list of integers. - `k`: an integer representing the number of steps to rotate the list. - **Output**: The function should return a list of integers that have been rotated in-place. # Constraints: - The array can have zero or more integer elements. - ( k ) can be zero or positive; if ( k ) is larger than the length of the list, normalize it by taking ( k % text{len(arr)} ). - You are not allowed to use additional lists or arrays; the rotation must modify the original list itself. - Ensure to handle edge cases where the list is empty or contains only one element. # Example: ```python arr = [1, 2, 3, 4, 5] rotate_array(arr, 2) # Expected: [4, 5, 1, 2, 3] arr = [0, 1, 2] rotate_array(arr, 4) # Expected: [2, 0, 1] ``` # Steps: 1. Normalize ( k ) using ( k %= text{len(arr)} ) to handle cases where ( k ) is larger than the array length. 2. Reverse the entire array. 3. Reverse the first ( k ) elements of the reversed array. 4. Reverse the elements from ( k ) to the end. # Edge Cases to Consider: - List contains only one or zero elements. - ( k ) is zero (no rotation should occur). - ( k ) is equal to or greater than the length of the array.","solution":"def rotate_array(arr, k): Rotates the elements of arr in place to the right by k steps. Parameters: arr (list of int): The array to rotate. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. if not arr or k == 0: return arr n = len(arr) k %= n # Normalize k to be within the bounds of the list length # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = arr[:k][::-1] # Reverse the remaining elements arr[k:] = arr[k:][::-1] return arr"},{"question":"# Coding Assessment Question Context You are working on a data visualization tool that requires rendering paginated data from a large dataset of user activity logs. To efficiently fetch and display the paginated data, you need to implement a lazy loading mechanism that fetches data on demand as the user navigates through the pages. Task Write a function `get_paginated_data` that takes in a list of user activity logs and returns the data for a specified page. The function should: 1. Use zero-based indexing for pages. 2. Handle cases where the requested page number is out of range by returning an empty list. 3. Implement both iterative and recursive methods for fetching paginated data. Constraints - The user activity logs list will have a length between 0 and (10^6). - Each log entry is represented as a dictionary with fields \\"user_id\\", \\"activity\\", and \\"timestamp\\". - The page size (the number of logs per page) is a fixed integer between 1 and 100. Function Signature ```python def get_paginated_data(logs: list[dict], page_number: int, page_size: int) -> list[dict]: pass ``` Expected Input and Output ```python logs = [ {\\"user_id\\": 1, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:01Z\\"}, {\\"user_id\\": 2, \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2023-01-01T00:00:02Z\\"}, {\\"user_id\\": 3, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:03Z\\"}, {\\"user_id\\": 4, \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2023-01-01T00:00:04Z\\"}, {\\"user_id\\": 5, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:05Z\\"} ] >>> get_paginated_data(logs, 0, 2) [ {\\"user_id\\": 1, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:01Z\\"}, {\\"user_id\\": 2, \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2023-01-01T00:00:02Z\\"} ] >>> get_paginated_data(logs, 1, 2) [ {\\"user_id\\": 3, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:03Z\\"}, {\\"user_id\\": 4, \\"activity\\": \\"logout\\", \\"timestamp\\": \\"2023-01-01T00:00:04Z\\"} ] >>> get_paginated_data(logs, 3, 2) [ {\\"user_id\\": 5, \\"activity\\": \\"login\\", \\"timestamp\\": \\"2023-01-01T00:00:05Z\\"} ] >>> get_paginated_data(logs, 2, 2) [] >>> get_paginated_data([], 0, 2) [] ``` Performance Requirements - Your implementation should efficiently handle large input sizes. - Aim for O(n) time complexity per page request. - Ensure to handle edge cases mentioned above effectively.","solution":"def get_paginated_data(logs, page_number, page_size): Returns a list of paginated user activity logs for the specified page number. Arguments: logs -- list of dictionaries representing user activity logs page_number -- the zero-based page number for which the data should be returned page_size -- the number of logs per page Returns a list of dictionaries representing the user activity logs for the specified page. If the page number is out of range, returns an empty list. # Calculate start and end index for the specified page number start_index = page_number * page_size end_index = start_index + page_size # Return the sliced list; handles out of range with automatic empty list return return logs[start_index:end_index]"},{"question":"# Question You are tasked with developing a `Matrix` class that supports and optimizes common matrix operations. The current objective is to enhance the performance of matrix multiplication by caching computed results and implement additional matrix functionalities as outlined below: Your task is to develop a `Matrix` class which includes: 1. **Matrix Initialization**: Initialize a matrix with the given 2D list. 2. **Matrix Multiplication with Caching**: Implement matrix multiplication such that previously computed results are cached to avoid redundant calculations. 3. **Transpose**: Implement a method to return the transpose of the matrix. 4. **Determinant Calculation**: Implement a method to compute the determinant for square matrices. # Function Specifications: Matrix Class - **Method**: `__init__(self, data: list[list[int]]) -> None` - **Description**: Initializes the matrix with the given 2D list of integers. - **Input**: 2D list of integers representing matrix elements. - **Output**: None - **Method**: `multiply(self, other: Matrix) -> Matrix` - **Description**: Multiplies the current matrix with another matrix and caches the result. - **Input**: An instance of `Matrix` to multiply with. - **Output**: A new `Matrix` instance representing the product. - **Method**: `transpose(self) -> Matrix` - **Description**: Returns the transpose of the current matrix. - **Input**: None - **Output**: A new `Matrix` instance representing the transpose. - **Method**: `determinant(self) -> int` - **Description**: Computes the determinant of the current matrix. - **Input**: None - **Output**: An integer representing the determinant of the matrix. # Example Usage: ```python class Matrix: def __init__(self, data: list[list[int]]) -> None: self.data = data self.cache = {} def multiply(self, other: Matrix) -> Matrix: if (id(self), id(other)) in self.cache: return self.cache[(id(self), id(other))] if len(self.data[0]) != len(other.data): raise ValueError(\\"Matrices cannot be multiplied\\") result = [[0] * len(other.data[0]) for _ in range(len(self.data))] for i in range(len(self.data)): for j in range(len(other.data[0])): for k in range(len(self.data[0])): result[i][j] += self.data[i][k] * other.data[k][j] result_matrix = Matrix(result) self.cache[(id(self), id(other))] = result_matrix return result_matrix def transpose(self) -> Matrix: transposed_data = [[self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0]))] return Matrix(transposed_data) def determinant(self) -> int: if len(self.data) != len(self.data[0]): raise ValueError(\\"Determinant can only be calculated for square matrices\\") n = len(self.data) if n == 1: return self.data[0][0] if n == 2: return self.data[0][0] * self.data[1][1] - self.data[0][1] * self.data[1][0] det = 0 for c in range(n): submatrix = [row[:c] + row[c+1:] for row in (self.data[:0] + self.data[1:])] det += ((-1)**c) * self.data[0][c] * Matrix(submatrix).determinant() return det # Example usage matrix1 = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) matrix2 = Matrix([[9, 8, 7], [6, 5, 4], [3, 2, 1]]) product = matrix1.multiply(matrix2) transpose_matrix = matrix1.transpose() determinant = matrix1.determinant() print(\\"Matrix 1:\\") for row in matrix1.data: print(row) print(\\"Matrix 2:\\") for row in matrix2.data: print(row) print(\\"Product of matrix1 and matrix2:\\") for row in product.data: print(row) print(\\"Transpose of matrix1:\\") for row in transpose_matrix.data: print(row) print(\\"Determinant of matrix1:\\", determinant) ``` Ensure your implementation meets the following criteria: 1. Matrix multiplication with caching to improve performance. 2. Correct handling of matrix dimensions and constraints for operations. 3. Exception handling for invalid operations (e.g., non-square matrices for determinant calculation). Write unit tests for the following scenarios: 1. Multiplication of two matrices with caching effect. 2. Transpose of a matrix. 3. Determinant computation of square matrices, including edge cases for 1x1 and 2x2 matrices.","solution":"class Matrix: def __init__(self, data: list[list[int]]) -> None: self.data = data self.cache = {} def multiply(self, other: \'Matrix\') -> \'Matrix\': if (id(self), id(other)) in self.cache: return self.cache[(id(self), id(other))] if len(self.data[0]) != len(other.data): raise ValueError(\\"Matrices cannot be multiplied\\") result = [[0] * len(other.data[0]) for _ in range(len(self.data))] for i in range(len(self.data)): for j in range(len(other.data[0])): for k in range(len(self.data[0])): result[i][j] += self.data[i][k] * other.data[k][j] result_matrix = Matrix(result) self.cache[(id(self), id(other))] = result_matrix return result_matrix def transpose(self) -> \'Matrix\': transposed_data = [[self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0]))] return Matrix(transposed_data) def determinant(self) -> int: if len(self.data) != len(self.data[0]): raise ValueError(\\"Determinant can only be calculated for square matrices\\") n = len(self.data) if n == 1: return self.data[0][0] if n == 2: return self.data[0][0] * self.data[1][1] - self.data[0][1] * self.data[1][0] det = 0 for c in range(n): submatrix = [row[:c] + row[c+1:] for row in (self.data[1:])] det += ((-1)**c) * self.data[0][c] * Matrix(submatrix).determinant() return det"},{"question":"# Unique Path Counter Problem Statement: You are given a `m x n` grid representing a map where the top-left corner is the starting point and the bottom-right corner is the destination. You can only move either down or right at any point in time. Your task is to count how many unique paths exist from the top-left corner to the bottom-right corner of the grid. Write a function `unique_paths(m: int, n: int) -> int` that receives the integers `m` and `n` representing the number of rows and columns of the grid, respectively, and returns the number of unique paths from the top-left corner to the bottom-right corner. # Input: * Two integers `m` and `n` where `1 <= m, n <= 100`. # Output: * Returns an integer representing the number of unique paths from the top-left corner to the bottom-right corner. # Constraints: * You may only move either down or right at any point in time. * The grid size will always be positive. # Example: 1. `unique_paths(3, 7)` should return `28` 2. `unique_paths(3, 2)` should return `3` 3. `unique_paths(7, 3)` should return `28` 4. `unique_paths(3, 3)` should return `6` 5. `unique_paths(1, 1)` should return `1` Additional Notes: * Consider using dynamic programming to optimize your solution for larger grids. * The problem can also be solved using combinatorics, leveraging the binomial coefficient.","solution":"def unique_paths(m: int, n: int) -> int: Return the number of unique paths from the top-left corner to the bottom-right corner of the grid. # Create a 2D array `dp` initialized to 1s for the first row and column dp = [[1] * n for _ in range(m)] # Iterate over the cells starting from (1, 1), as (0, 0) is the starting point and has only one path for i in range(1, m): for j in range(1, n): # The number of ways to get to (i, j) is the sum of ways to get to the cell directly above (i-1, j) # and the cell directly to the left (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner of the grid has the final count of unique paths return dp[m-1][n-1]"},{"question":"# Problem Statement Write a function that takes a list of integers and returns a list of all possible subsets, excluding the empty subset. The subsets should be returned without any duplication and the order of integers within each subset does not matter. # Task Description Implement the following function: 1. **Function: `generate_subsets(nums: List[int]) -> List[List[int]]`** - Takes a list of integers as input and returns a list of lists, where each inner list is a subset of the original list excluding the empty subset. - Each subset should not be repeated in the final output list. - The order of subsets in the final output list does not matter, but each subset should be unique. # Input - A list of integers `nums` of length `n` (0 <= n <= 15), where integers can be negative, zero, or positive. - The list may contain duplicate integers. # Output - A list of lists, where each inner list is a subset of the original list, excluding the empty subset and without duplications. # Example ```python assert generate_subsets([1, 2, 2]) == [ [1], [2], [1, 2], [2, 2], [1, 2, 2] ] assert generate_subsets([]) == [] assert generate_subsets([3, -1, 2]) == [ [-1], [2], [3], [-1, 2], [-1, 3], [2, 3], [-1, 2, 3] ] ``` # Constraints - The length of the input list `nums` does not exceed 15. # Exception Handling - There are no specific exception handling requirements for this problem, assume the input will always be valid.","solution":"from itertools import combinations from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generate all unique subsets of the input list, excluding the empty subset. unique_subsets = set() n = len(nums) for i in range(1, n + 1): for comb in combinations(nums, i): unique_subsets.add(tuple(sorted(comb))) # use sorted tuple to ensure uniqueness return [list(subset) for subset in unique_subsets]"},{"question":"# Data Structures Question: Rebuilding a Binary Tree from Traversals Given the inorder and postorder traversal of a binary tree, rebuild the tree and return its root. The binary tree has unique values for each node. **Function Signature**: `def build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:` # Input: - A list of integers `inorder` representing the inorder traversal of the tree. - A list of integers `postorder` representing the postorder traversal of the tree. # Output: - The `TreeNode` object representing the root of the rebuilt binary tree. # Example: ```python >>> class TreeNode: ... def __init__(self, val=0, left=None, right=None): ... self.val = val ... self.left = left ... self.right = right >>> inorder = [9, 3, 15, 20, 7] >>> postorder = [9, 15, 7, 20, 3] >>> tree = build_tree(inorder, postorder) >>> tree.val 3 >>> tree.left.val 9 >>> tree.right.val 20 >>> tree.right.left.val 15 >>> tree.right.right.val 7 ``` # Constraints: - The lengths of `inorder` and `postorder` will be equal and range from 1 to 2000. - Each value in the tree is unique. # Approach: 1. Identify the root node from the last element in the `postorder` list. 2. Split the `inorder` list into left and right subtrees based on the root node\'s value. 3. Recursively build left and right subtrees using the corresponding parts of the `inorder` and `postorder` lists. 4. Efficiently manage index lookups for optimal time complexity.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(inorder: List[int], postorder: List[int]) -> Optional[TreeNode]: if not inorder or not postorder: return None # The root is the last element of postorder root_val = postorder.pop() root = TreeNode(root_val) # Find the index of the root in inorder traversal inorder_index = inorder.index(root_val) # Recursively build right and left subtrees # Note that we build right subtree first since we are popping from end of postorder root.right = build_tree(inorder[inorder_index+1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root"},{"question":"# Sum of Subsets Context: You are required to find the number of ways to select a subset of a given array such that the sum of its elements equals a given target. Each element in the array is distinct and you may not use the same element more than once. Problem Statement: Given: - A list of distinct integers `nums`. - An integer `target` representing the target sum. Write a function `count_subsets(nums: List[int], target: int) -> int` that returns the total number of ways to select subsets of `nums` such that the sum of elements in each subset equals the `target`. Function Signature: ```python def count_subsets(nums: List[int], target: int) -> int: ``` Input: - `nums`: A list of distinct integers. - `target`: An integer. Output: - An integer representing the total number of ways to select subsets summing to the target. Constraints: - 1 ≤ len(nums) ≤ 20 - 1 ≤ nums[i] ≤ 100 - 1 ≤ target ≤ sum(nums) Example: Input: ```python nums = [1, 2, 3, 4, 5] target = 5 ``` Output: ```python 3 ``` Explanation: For the given example, there are 3 unique subsets whose sum equals the target: - [5] - [2, 3] - [1, 4] Ensure your solution is efficient and handles all edge cases appropriately. Consider using a backtracking approach or any other method you find suitable to solve the problem optimally.","solution":"from typing import List def count_subsets(nums: List[int], target: int) -> int: def backtrack(index, current_sum): if current_sum == target: return 1 if index >= len(nums) or current_sum > target: return 0 # Choose the current number count = backtrack(index + 1, current_sum + nums[index]) # Don\'t choose the current number count += backtrack(index + 1, current_sum) return count return backtrack(0, 0)"},{"question":"# Question: Implement Binary Tree Traversal Methods Context You are developing a tool to visualize binary tree structures, highlighting various traversal methods used in binary trees. Your task is to implement the functions that return a list of node values in specific traversal orders. Requirements 1. **Function 1: In-order Traversal** ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_traversal(root: TreeNode) -> list: Take in a binary tree root node. \'root\' is the root node of the binary tree. Return a list of node values in in-order traversal (left, root, right). Example: >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] ``` 2. **Function 2: Pre-order Traversal** ```python def preorder_traversal(root: TreeNode) -> list: Take in a binary tree root node. \'root\' is the root node of the binary tree. Return a list of node values in pre-order traversal (root, left, right). Example: >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> preorder_traversal(root) [1, 2, 3] ``` 3. **Function 3: Post-order Traversal** ```python def postorder_traversal(root: TreeNode) -> list: Take in a binary tree root node. \'root\' is the root node of the binary tree. Return a list of node values in post-order traversal (left, right, root). Example: >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> postorder_traversal(root) [3, 2, 1] ``` Constraints - The binary tree nodes can contain any integer values. - The number of nodes in the tree is at most `1000`. - Nodes may have zero, one, or two children. - The tree can be empty (i.e., the root node can be `None`). Performance Requirements - Aim for efficient implementations with linear time complexity relative to the number of nodes in the tree. Edge Cases - Handle cases where the tree is empty. - Ensure the functions return an empty list when the tree is empty. Write code that performs these operations, verifying through provided examples.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_traversal(root: TreeNode) -> list: Return a list of node values in in-order traversal (left, root, right). result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def preorder_traversal(root: TreeNode) -> list: Return a list of node values in pre-order traversal (root, left, right). result = [] def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result def postorder_traversal(root: TreeNode) -> list: Return a list of node values in post-order traversal (left, right, root). result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Problem Statement The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones. Starting with 0 and 1, the sequence goes 0, 1, 1, 2, 3, 5, 8, etc. Write a Python function `find_fibonacci_term_with_digits(digit_count)` that takes an integer `digit_count` and returns the index of the first term in the Fibonacci sequence to contain `digit_count` digits. # Requirements * **Input**: An integer `digit_count` (1 <= digit_count <= 1000). * **Output**: An integer representing the index of the first term in the Fibonacci sequence with at least `digit_count` digits. # Example ```python print(find_fibonacci_term_with_digits(3)) # prints 12 since the 12th Fibonacci term (144) has 3 digits ``` # Constraints 1. The function should handle large Fibonacci terms efficiently. 2. Your approach should be optimized to handle the increasing size of Fibonacci numbers as `digit_count` increases. # Function Signature ```python def find_fibonacci_term_with_digits(digit_count: int) -> int: pass ```","solution":"def find_fibonacci_term_with_digits(digit_count): Returns the index of the first term in the Fibonacci sequence to contain \'digit_count\' digits. if digit_count == 1: return 1 # The first Fibonacci term with 1 digit is F1 = 1 a, b = 1, 1 index = 2 # Start from the second term while True: next_term = a + b index += 1 if len(str(next_term)) >= digit_count: return index a, b = b, next_term"},{"question":"# Coding Question: Custom Permutation Sort Your task is to implement a custom version of a permutation sort algorithm that can handle sorting an array of integers. You will write the function `custom_permutation_sort(arr: List[int]) -> List[int]` that will sort the given array using a permutation sorting technique. Permutation sort checks for every possible permutation of the array and returns the first one that is sorted. Input: * The function will take a list of integers `arr` to be sorted. Output: * The function should return the sorted list of integers. Constraints: * The length of the array should be between 1 and 6. * The elements of the array can be any integer, including negative numbers and zeros. # Example: ```python def custom_permutation_sort(arr: List[int]) -> List[int]: >>> custom_permutation_sort([3, 1, 2]) [1, 2, 3] >>> custom_permutation_sort([5, 3, 4, 2, 1]) [1, 2, 3, 4, 5] >>> custom_permutation_sort([-1, -3, -2, 0, -4]) [-4, -3, -2, -1, 0] ``` # Notes: * You can use the `itertools.permutations` library to generate permutations. * Ensure that the function correctly sorts small arrays of integers, including edge cases with negative numbers and zeros. * Given the constraints, prioritize clarity and correctness over optimization.","solution":"from itertools import permutations from typing import List def custom_permutation_sort(arr: List[int]) -> List[int]: This function sorts a list of integers by checking every possible permutation of the array and returning the first one that is sorted. for perm in permutations(arr): if list(perm) == sorted(arr): return list(perm)"},{"question":"# Question: Find All Possible Sums in a List Given a list of integers, find all possible unique sums that can be obtained by selecting one or more elements from the list. Function Signature ```python def find_possible_sums(numbers: list[int]) -> set[int]: pass ``` Input * `numbers (list[int])`: A list of integers. The list can be empty. Output * A set of integers representing all unique possible sums that can be formed. Constraints * The length of `numbers` is in the range `[0, 100]`. * Each integer in `numbers` can be in the range `[-100, 100]`. Example **Example - 1:** ```python numbers = [1, 2, 3] assert find_possible_sums(numbers) == {1, 2, 3, 3, 4, 5, 6} ``` **Example - 2:** ```python numbers = [-1, 2] assert find_possible_sums(numbers) == {-1, 1, 2} ``` Notes * If the `numbers` list is empty, the function should return an empty set. * The function should compute all possible sums by using each number at most once per sum. * Consider using bit manipulation or dynamic programming for an efficient solution. * The result set should remove any duplicate sums and include all unique sums you can form from one or more elements in the list.","solution":"def find_possible_sums(numbers: list[int]) -> set[int]: Finds all possible unique sums that can be obtained by selecting one or more elements from the list. all_sums = set() # Base case: if the list is empty, return empty set if not numbers: return all_sums # Use a set to store sums sums_set = set() for number in numbers: new_sums = set() for sum_value in sums_set: new_sums.add(sum_value + number) new_sums.add(number) sums_set.update(new_sums) return sums_set"},{"question":"Scenario You are tasked with developing a simple text editor with several functions including the ability to undo and redo text changes. Users will perform operations such as inserting text, deleting text, and undoing or redoing those actions. Your task is to write a function that simulates the sequence of operations and returns the final state of the text. Problem Statement Write a function `text_editor` that, given a list of operations, returns the final text after all operations are performed. # Function Signature ```python def text_editor(operations: List[Tuple[str, Union[str, None]]]) -> str: ``` # Input * A list of tuples `operations` where each tuple represents an operation: * If the first element is `\\"insert\\"`, the second element is the string to insert at the end of the current text. * If the first element is `\\"delete\\"`, the second element is the number of characters to delete from the end of the current text. * If the first element is `\\"undo\\"`, the second element is `None`, indicating an undo action. * If the first element is `\\"redo\\"`, the second element is `None`, indicating a redo action. # Output * The function should return a string representing the final state of the text after all operations. # Constraints * 1 <= number of operations <= 1000 * 1 <= length of text to insert <= 100 * 1 <= number of characters to delete <= length of current text # Example ```python operations = [(\\"insert\\", \\"hello \\"), (\\"insert\\", \\"world\\"), (\\"delete\\", 5), (\\"undo\\", None), (\\"redo\\", None)] result = text_editor(operations) # This should return the final text # \\"hello \\" ``` # Additional Information * Undo and redo operations should revert and reapply the most recent operation that has been performed and undone respectively. * Each insert and delete operation should be considered a state change that can be undone and redone. * Multiple undo and redo operations should function correctly in sequence, maintaining the integrity of the text.","solution":"def text_editor(operations): Simulates a text editor with undo and redo functionalities. Args: operations (List[Tuple[str, Union[str, None]]]): List of operations to be performed on the text. Returns: str: Final state of the text after all operations. # Initializations text = \\"\\" history = [] undone_history = [] for operation in operations: if operation[0] == \\"insert\\": # Save current state before action history.append(text) undone_history.clear() # Clear redo history after a new action text += operation[1] elif operation[0] == \\"delete\\": # Save current state before action history.append(text) undone_history.clear() # Clear redo history after a new action text = text[:-operation[1]] elif operation[0] == \\"undo\\": if history: undone_history.append(text) text = history.pop() elif operation[0] == \\"redo\\": if undone_history: history.append(text) text = undone_history.pop() return text"},{"question":"# Coding Assessment Question: Evaluate Reverse Polish Notation Scenario: You are given an array of strings that represents an arithmetic expression in Reverse Polish Notation (RPN). Reverse Polish Notation is a postfix notation wherein every operator follows all of its operands. Each of the operators operates on the two most recent values in the stack. Problem: Write a function `evaluateRPN(expression: List[str]) -> int` which evaluates the RPN expression and returns the result as an integer. Input and Output Formats: * **Input**: A list of strings, `expression`, where each string is an operand (integer represented as a string) or one of the operators `\'+\', \'-\', \'*\', \'/\'`. * **Output**: An integer result of evaluating the RPN expression. Constraints: * You can assume the given expression is always valid. * Division should truncate towards zero. * The number of integers and operators in `expression` is at most 10,000. Example Usage: ```python assert evaluateRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 # Explanation: ((2 + 1) * 3) = 9 assert evaluateRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 # Explanation: (4 + (13 / 5)) = 6 assert evaluateRPN([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22 # Explanation: 10 * (6 / ((9 + 3) * -11)) + 17 + 5 ``` Implementation: Implement the function with appropriate handling to evaluate the RPN expression. ```python from typing import List def evaluateRPN(expression: List[str]) -> int: stack = [] for token in expression: if token in \\"+-*/\\": b, a = stack.pop(), stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Ensure truncation towards zero else: stack.append(int(token)) return stack[0] # Example cases if __name__ == \\"__main__\\": print(evaluateRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"])) # Output: 9 print(evaluateRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"])) # Output: 6 print(evaluateRPN([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"])) # Output: 22 ```","solution":"from typing import List def evaluateRPN(expression: List[str]) -> int: Evaluate the value of an arithmetic expression in Reverse Polish Notation. Args: expression (List[str]): A list of strings representing the RPN expression. Returns: int: The result of evaluating the RPN expression. stack = [] for token in expression: if token in \\"+-*/\\": b, a = stack.pop(), stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # Ensure truncation towards zero else: stack.append(int(token)) return stack[0]"},{"question":"# Coding Assessment Question Scenario: A robotics research company is developing an algorithm to navigate a robot through a grid-based environment. The environment contains obstacles, and the robot\'s goal is to find the shortest path from a starting position to a target position. Task: Write a function named `find_shortest_path` to implement the A* search algorithm to find the shortest path from the start position to the target position on the grid. Function Signature: ```python def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Find the shortest path in a grid using the A* search algorithm. Parameters: grid (List[List[int]]): A 2D list representing the grid, where 0 indicates an empty cell and 1 indicates an obstacle. start (Tuple[int, int]): The starting coordinate (row, column). goal (Tuple[int, int]): The target coordinate (row, column). Returns: List[Tuple[int, int]]: A list of coordinates representing the shortest path from start to goal. If no path is found, return an empty list. ``` Constraints: * All grid cells are either 0 (empty) or 1 (obstacle). * `start` and `goal` are always within grid bounds and on empty cells. * At least one valid path exists from `start` to `goal`. Example Usage: 1. Given a grid and a start and goal position: ```python grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) ``` 2. Find the shortest path from start to goal: ```python path = find_shortest_path(grid, start, goal) print(path) ``` This should return the coordinates of the shortest path, such as: ```python [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4), (2, 4), (3, 4), (4, 4)] ``` Testing: - Ensure that the function correctly finds the shortest path in a simple grid without obstacles. - Validate handling of larger grids with multiple obstacles. - Confirm the algorithm\'s correctness by comparing the output path length with the expected shortest distance.","solution":"from heapq import heappop, heappush from typing import List, Tuple def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: Calculate the Manhattan distance heuristic between two points a and b. return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(position: Tuple[int, int], grid: List[List[int]]) -> List[Tuple[int, int]]: Get valid neighboring cells for a given position in the grid. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] neighbors = [] for direction in directions: neighbor = (position[0] + direction[0], position[1] + direction[1]) if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0: neighbors.append(neighbor) return neighbors def reconstruct_path(came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]: Reconstruct the path from start to goal by following the came_from map. path = [current] while current in came_from: current = came_from[current] path.append(current) path.reverse() return path def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]: Find the shortest path in a grid using the A* search algorithm. open_set = [] heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, goal)} while open_set: _, current = heappop(open_set) if current == goal: return reconstruct_path(came_from, current) for neighbor in get_neighbors(current, grid): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Question: Graph Cycle Detection You are tasked with implementing a function to detect cycles in an undirected graph. A cycle in an undirected graph is a sequence of nodes starting and ending at the same node, such that the sequence contains at least one edge and does not repeat any edge. Function Specification ```python def has_cycle(graph: dict[int, list[int]]) -> bool: Determines if the given undirected graph contains a cycle. Parameters: graph (dict of int to list of int): An adjacency list representation of the graph. Returns: bool: True if the graph contains a cycle, False otherwise. Examples: >>> has_cycle({ 1: [2], 2: [1, 3], 3: [2, 4], 4: [3, 5], 5: [4] }) False >>> has_cycle({ 1: [2, 3], 2: [1, 3], 3: [1, 2, 4], 4: [3] }) True >>> has_cycle({ 1: [2], 2: [1, 3], 3: [2, 4, 5], 4: [3, 5], 5: [3, 4] }) True ``` Requirements 1. **Input Constraints**: * The graph is represented as an adjacency list, where keys are node identifiers (integers) and values are lists of adjacent nodes (also integers). * Nodes and edges are undirected. 2. **Output**: * The function should return `True` if the graph contains a cycle, otherwise it should return `False`. 3. **Edge Cases**: * Handle graphs with disconnected components. * Handle graphs where a node points to itself to form a cycle. 4. **Performance Considerations**: * The solution should efficiently handle large graphs by leveraging depth-first search (DFS) or breadth-first search (BFS) for cycle detection. Example Testing Test the function with various scenarios including graphs with multiple nodes, graphs with different structures, and graphs with various cycles to ensure correctness and performance.","solution":"def has_cycle(graph: dict[int, list[int]]) -> bool: Determines if the given undirected graph contains a cycle. :param graph: An adjacency list representation of the graph. :return: True if the graph contains a cycle, False otherwise. def dfs(node, parent, visited): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = {node: False for node in graph} for node in graph: if not visited[node]: if dfs(node, -1, visited): return True return False"},{"question":"# Coding Challenge: Design a File System Class **Scenario**: As a software architect, you are tasked with designing a simplistic in-memory file system. This file system should support basic file and directory operations, such as creation, deletion, and navigation throughout the file hierarchy. **Objective**: Implement the `FileSystem` class that allows for creation of directories and files, storing file contents, and retrieval of directory listings. **Requirements**: 1. Implement the `FileSystem` class. 2. Implement methods to create directories, create files with content, and list the content of a directory. 3. Support navigation through the file hierarchy using paths. **Function Signature**: ```python class FileSystem: def __init__(self): ... def mkdir(self, path: str) -> None: ... def createFile(self, path: str, content: str) -> None: ... def ls(self, path: str) -> List[str]: ... ``` **Expected Input and Output**: - `__init__(self)`: Initializes the file system with an empty root. - `mkdir(self, path: str) -> None`: Creates a directory at the specified path. Intermediate directories should be created if they do not exist. - `createFile(self, path: str, content: str) -> None`: Creates a file at the specified path with the given content. Intermediate directories should be created if they do not exist. If the file already exists, overwrite its content. - `ls(self, path: str) -> List[str]`: Lists the contents of the directory specified by the path. The contents of a directory are shown as a list of names and must be returned in lexicographically sorted order. If the path is a file, returns the list containing only the file name. **Constraints**: - The path string will be a valid absolute path starting with `/`. - The content string of the file may contain any characters. - Directory and file names will consist of lowercase alphabets only. - The depth and length of paths will be in the range [1, 1000]. **Performance Requirements**: - Directory and file creation should be efficient. - Directory listing should also be efficient, particularly for shallow structures. **Testing**: Your implementation should be verified by the following tests: 1. Creating and listing directories. 2. Creating and listing directories with intermediate directory creation. 3. Creating files and listing the containing directory. 4. Overwriting file content. 5. Listing a file path should return the file name. Implement the `FileSystem` class and its methods based on the initial provided code and ensure your solution passes the described tests.","solution":"from typing import List class FileSystem: def __init__(self): self.fs = {\'/\': {}} def mkdir(self, path: str) -> None: dirs = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] def createFile(self, path: str, content: str) -> None: dirs = path.strip(\'/\').split(\'/\') *folders, file_name = dirs current = self.fs[\'/\'] for directory in folders: if directory not in current: current[directory] = {} current = current[directory] current[file_name] = content def ls(self, path: str) -> List[str]: dirs = path.strip(\'/\').split(\'/\') current = self.fs[\'/\'] for directory in dirs: if directory: current = current[directory] if isinstance(current, str): return [dirs[-1]] return sorted(current.keys())"},{"question":"# Question You are required to implement a `WordDictionary` that supports adding words and searching for words with special capabilities. The current functionality needs to be extended to include: 1. **Wildcard character search**: Support for searching words with a `.` character that can match any single letter. 2. **Case-insensitive functionality**: All searches should be case-insensitive. 3. **Deletion of words**: Provide functionality to delete words from the dictionary. Your task is to implement a modified version of the `WordDictionary` class which includes: 1. **Case-insensitive add, search, and delete**: Ignore case when performing operations. 2. **Wildcard search**: Implement a method to search words containing a `.` that can match any letter. 3. **Deletion of words**: Ability to remove words from the dictionary. Additionally, write tests for the following scenarios: 1. Wildcard search with various patterns. 2. Case-insensitive add and search. 3. Deletion of words and subsequent searches. # Function Specifications: WordDictionary Class - **Method**: `add_word(self, word: str) -> None` - **Description**: Adds the given word to the dictionary. - **Input**: `word` (a string containing the word to add, case-insensitive) - **Output**: None - **Method**: `search(self, word: str) -> bool` - **Description**: Searches the dictionary for exactly matching words, including support for the wildcard character `.`. - **Input**: `word` (a string to search, case-insensitive, can include `.` as any letter) - **Output**: `True` if the word is found, `False` otherwise - **Method**: `delete_word(self, word: str) -> None` - **Description**: Deletes the given word from the dictionary. - **Input**: `word` (a string containing the word to delete, case-insensitive) - **Output**: None ```python class WordDictionary: def __init__(self): self.words = set() def add_word(self, word: str) -> None: Adds the given word to the dictionary, in a case-insensitive manner. self.words.add(word.lower()) def search(self, word: str) -> bool: Searches the dictionary for exactly matching words, including support for the wildcard character `.`. word = word.lower() return any(self._match(w, word) for w in self.words) def _match(self, candidate: str, pattern: str) -> bool: if len(candidate) != len(pattern): return False for c, p in zip(candidate, pattern): if p != \'.\' and c != p: return False return True def delete_word(self, word: str) -> None: Deletes the given word from the dictionary, in a case-insensitive manner. self.words.discard(word.lower()) def main(): wd = WordDictionary() wd.add_word(\\"Dog\\") wd.add_word(\\"duck\\") wd.add_word(\\"Deer\\") assert wd.search(\\"doG\\") == True assert wd.search(\\"DoGgy\\") == False assert wd.search(\\"d...\\") == True # Matches \\"dog\\", \\"duck\\", \\"deer\\" assert wd.search(\\"d.ck\\") == True # Matches \\"duck\\" wd.delete_word(\\"duck\\") assert wd.search(\\"d.ck\\") == False if __name__ == \\"__main__\\": main() ``` This question tests the ability to handle various operations related to a dynamic data structure while considering case sensitivity and wildcard characters. The user will implement methods to add, search, and delete words, ensuring all operations are case-insensitive and capable of recognizing wildcard characters during a search.","solution":"import re class WordDictionary: def __init__(self): self.words = set() def add_word(self, word: str) -> None: Adds the given word to the dictionary, in a case-insensitive manner. self.words.add(word.lower()) def search(self, word: str) -> bool: Searches the dictionary for exactly matching words, including support for the wildcard character `.`. word = word.lower() pattern = re.compile(f\\"^{word}\\") return any(pattern.match(w) for w in self.words) def delete_word(self, word: str) -> None: Deletes the given word from the dictionary, in a case-insensitive manner. self.words.discard(word.lower())"},{"question":"# Coding Assessment Question Scenario A company needs to track and manage user activities within their application. They require a system that can efficiently log activities, retrieve the most recent activities, and identify the most frequent activities over a given period. You are tasked with implementing a class that provides these functionalities. Task Implement a class `ActivityTracker` that logs user activities and provides methods to retrieve recent activities and the most frequent activities within a given timeframe. # Class Signature ```python class ActivityTracker: def __init__(self): pass def log_activity(self, timestamp: int, activity: str) -> None: pass def get_recent_activities(self, n: int) -> list[str]: pass def get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]: pass ``` # Methods 1. `log_activity(timestamp: int, activity: str) -> None`: Logs an activity with a given timestamp. - `timestamp`: An integer representing the time at which the activity occurred. - `activity`: A string representing the activity performed by the user. 2. `get_recent_activities(n: int) -> list[str]`: Retrieves the most recent `n` activities, in reverse chronological order. - `n`: An integer specifying the number of recent activities to retrieve. 3. `get_most_frequent_activities(start_time: int, end_time: int) -> list[str]`: Retrieves the most frequent activities performed within a specified timeframe. - `start_time`: An integer representing the start of the time window. - `end_time`: An integer representing the end of the time window. # Example ```python tracker = ActivityTracker() tracker.log_activity(1, \\"login\\") tracker.log_activity(2, \\"view_page\\") tracker.log_activity(3, \\"logout\\") tracker.log_activity(4, \\"login\\") tracker.log_activity(5, \\"purchase\\") assert tracker.get_recent_activities(3) == [\\"purchase\\", \\"login\\", \\"logout\\"] assert tracker.get_most_frequent_activities(1, 5) == [\\"login\\"] ``` # Constraints * `log_activity` may be called up to 10^5 times. * `timestamp` is a non-negative integer and is strictly increasing. * `activity` is a non-empty string with a maximum length of 100 characters. * `n` is a non-negative integer, and it will be less than or equal to the number of logged activities. * `start_time <= end_time`. * `get_most_frequent_activities` will return activities sorted lexicographically in case of ties. # Notes * You may use additional data structures to ensure that the methods `get_recent_activities` and `get_most_frequent_activities` are efficient. * The implementation should aim for optimal time complexity for both retrieving recent and frequent activities. * Clear and efficient code with appropriate comments is expected.","solution":"from collections import defaultdict, deque from heapq import nlargest class ActivityTracker: def __init__(self): self.activities = deque() self.activity_log = defaultdict(list) def log_activity(self, timestamp: int, activity: str) -> None: self.activities.append((timestamp, activity)) self.activity_log[activity].append(timestamp) def get_recent_activities(self, n: int) -> list[str]: return [activity for _, activity in list(self.activities)[-n:]][::-1] def get_most_frequent_activities(self, start_time: int, end_time: int) -> list[str]: count = defaultdict(int) for activity, timestamps in self.activity_log.items(): for timestamp in timestamps: if start_time <= timestamp <= end_time: count[activity] += 1 max_freq = max(count.values(), default=0) most_frequent = [activity for activity, freq in count.items() if freq == max_freq] return sorted(most_frequent)"},{"question":"# Coding Question Scenario Geography students are often tasked with analyzing data related to distances between cities to understand various concepts in geography better. You are given a list of pairs of cities and the distances between them. Your task is to find the shortest path a student needs to travel to visit all the cities starting from a specified city using the Traveling Salesman Problem (TSP) heuristic approach. Task Implement the function `shortest_travel_path` to compute the shortest path to visit all cities from a starting city using a given distance matrix and a simple heuristic such as the Nearest Neighbor algorithm. # Function Signature ```python def shortest_travel_path(distance_matrix: list[list[float]], start_city: int) -> list[int]: ``` # Input * `distance_matrix`: A 2D list of floats where `distance_matrix[i][j]` represents the distance between city `i` and city `j`. * `start_city`: An integer representing the starting city\'s index. # Output * A list of integers representing the order in which the cities should be visited to achieve the shortest travel path starting from `start_city`. # Constraints * The number of cities (length of `distance_matrix`) will be between 2 and 20. * Each element in `distance_matrix` will be between 0 and 10,000. * `start_city` will be between 0 and the number of cities minus 1. # Requirements 1. The algorithm should return to the starting city at the end of the tour. 2. Each city must be visited exactly once. # Example ```python # Input distance_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] start_city = 0 # Output [0, 1, 3, 2, 0] ``` **Notes:** - The output list provides the order of cities including returning back to the start_city. - Implement the Nearest Neighbor (NN) heuristic which is not guaranteed to find the optimal solution but provides a reasonably efficient path. - Ensure your implementation handles the edge cases like matrix filled with zeros or very large distances between certain pairs. **Edge cases to consider:** - When `distance_matrix` has cities that have no direct path (distance `0` indicates no direct connection and must be handled as infinite or inapplicable for pathfinding). - Handling multiple cities with the same shortest distance from the current city.","solution":"def shortest_travel_path(distance_matrix, start_city): Returns the order of cities to visit to achieve the shortest travel path starting from `start_city` using the Nearest Neighbor heuristic. :param distance_matrix: 2D list of floats where distance_matrix[i][j] represents distance between city i and city j :param start_city: an integer representing the starting city\'s index :return: list of integers representing the order to visit the cities n = len(distance_matrix) visited = [False] * n path = [start_city] current_city = start_city visited[current_city] = True while len(path) < n: next_city = None shortest_distance = float(\'inf\') for city in range(n): if not visited[city] and 0 < distance_matrix[current_city][city] < shortest_distance: shortest_distance = distance_matrix[current_city][city] next_city = city path.append(next_city) visited[next_city] = True current_city = next_city path.append(start_city) # return to the starting city return path"},{"question":"# Problem Statement You are developing a program to simulate the movement of a robot on a 2D grid. The robot can move in four directions: up, down, left, and right. Each movement is represented by a character: \'U\' for up, \'D\' for down, \'L\' for left, and \'R\' for right. The robot starts at the origin point (0, 0). Your task is to determine the robot\'s final position after executing a sequence of movements. Write a function `finalPosition(movements: str) -> Tuple[int, int]` that returns the final coordinates of the robot after performing all the movements in the given sequence. # Input Format - A single string `movements` (1 ≤ len(movements) ≤ 10^5) representing the sequence of movements. # Output Format - A tuple of two integers representing the final x and y coordinates of the robot. # Example ```python >>> finalPosition(\\"UUUDDD\\") (0, 0) >>> finalPosition(\\"LLRR\\") (0, 0) >>> finalPosition(\\"UUDDLR\\") (0, 0) >>> finalPosition(\\"UUDLRR\\") (1, 1) ``` # Constraints - The string `movements` will only contain the characters \'U\', \'D\', \'L\', and \'R\'. - Ensure that the function performs efficiently even for the maximum length of the input string. # Guidelines - Initialize the position of the robot at (0, 0). - Parse each character in the `movements` string and update the coordinates accordingly. - After processing all movements, return the final coordinates as a tuple.","solution":"def finalPosition(movements: str): Returns the final coordinates of the robot after performing all the movements. x, y = 0, 0 for move in movements: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return (x, y)"},{"question":"# Coding Assessment Question: Implement a Min-Stack Scenario: You are tasked with implementing a stack data structure that, in addition to standard stack operations, can retrieve the minimum element in constant time. Problem: Write a class called `MinStack` that implements the following methods: 1. `push(item: int)`: Adds an item to the stack. 2. `pop() -> int`: Removes and returns the item from the top of the stack. 3. `top() -> int | None`: Returns the item at the top of the stack without removing it. Returns `None` if the stack is empty. 4. `get_min() -> int | None`: Returns the minimum item in the stack without removing it. Returns `None` if the stack is empty. Input and Output Formats: * **push(item: int)**: Adds `item` to the stack. Does not return anything. * **pop() -> int**: Removes and returns the top item from the stack. If the stack is empty, it should raise an `IndexError`. * **top() -> int | None**: Returns the top item without removing it. If the stack is empty, it should return `None`. * **get_min() -> int | None**: Returns the minimum item in the stack without removing it. If the stack is empty, it should return `None`. Constraints: * All methods should maintain an overall average time complexity of O(1). * You may only use built-in stack operations (`append`, `pop`). Example Usage: ```python min_stack = MinStack() min_stack.push(5) min_stack.push(3) min_stack.push(7) assert min_stack.get_min() == 3 min_stack.push(2) assert min_stack.get_min() == 2 assert min_stack.pop() == 2 assert min_stack.get_min() == 3 assert min_stack.top() == 7 min_stack.pop() min_stack.pop() assert min_stack.get_min() == 5 try: while True: min_stack.pop() except IndexError: print(\\"Caught expected IndexError for pop from empty stack\\") assert min_stack.get_min() is None assert min_stack.top() is None ``` Implementation: Implement the class with appropriate methods to satisfy the above requirements.","solution":"class MinStack: def __init__(self): self.stack = [] # Normal stack to store all elements self.min_stack = [] # Auxiliary stack to store minimum elements def push(self, item: int): self.stack.append(item) if not self.min_stack or item <= self.min_stack[-1]: self.min_stack.append(item) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") item = self.stack.pop() if item == self.min_stack[-1]: self.min_stack.pop() return item def top(self) -> int | None: if not self.stack: return None return self.stack[-1] def get_min(self) -> int | None: if not self.min_stack: return None return self.min_stack[-1]"},{"question":"**Question 2:** You are required to implement a data structure that provides constant time complexity for the operations `insert`, `delete`, and `get_random_element`. This data structure will be tested on its performance and integrity under various operations to ensure its efficiency and correctness. # Function Signatures ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def delete(self, val: int) -> bool: pass def get_random_element(self) -> int: pass ``` # Class Methods 1. **`__init__()`**: - Initializes the data structure. 2. **`insert(val: int) -> bool`**: - Inserts an integer `val` into the data structure. - Returns `True` if the element was not already present, `False` otherwise. 3. **`delete(val: int) -> bool`**: - Deletes an integer `val` from the data structure. - Returns `True` if the element was present and deleted, `False` otherwise. 4. **`get_random_element() -> int`**: - Returns a random element from the current elements in the data structure. - All elements should have an equal probability of being returned. # Constraints - The values inserted will be within the range of a 32-bit signed integer. - You may assume that `get_random_element` will only be called when the data structure is not empty. # Example ```python # Initialize a new RandomizedSet random_set = RandomizedSet() # Insert 1. Should return True. print(random_set.insert(1)) # Insert 1 again. Should return False. print(random_set.insert(1)) # Insert 2. Should return True. print(random_set.insert(2)) # get_random_element should return either 1 or 2. # Each result should have equal probability. print(random_set.get_random_element()) # Delete 1. Should return True. print(random_set.delete(1)) # get_random_element should return 2. print(random_set.get_random_element()) ``` **Note**: Ensure to consider edge cases where operations are performed on an empty set or with elements that do not exist in the set. Aim to maintain an average constant time (`O(1)`) complexity for all methods.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def delete(self, val: int) -> bool: if val not in self.dict: return False # Move the last element to the place of the element to delete last_element = self.list[-1] index_to_remove = self.dict[val] self.list[index_to_remove] = last_element self.dict[last_element] = index_to_remove # Remove the last element self.list.pop() del self.dict[val] return True def get_random_element(self) -> int: return random.choice(self.list)"},{"question":"# Binary Search Tree Implementation with Rotations Problem Statement: You are tasked with implementing a self-balancing binary search tree (BST) using AVL (Adelson-Velsky and Landis) rotation techniques. The tree should support insertion, deletion, and search operations while maintaining balance to ensure efficient performance. Requirements: 1. **Function Signature**: ```python class AVLTreeNode: def __init__(self, key: int, value: Any = None) -> None: class AVLTree: def __init__(self) -> None: def insert(self, key: int, value: Any = None) -> None: def delete(self, key: int) -> None: def find(self, key: int) -> Optional[Any]: def in_order_traversal(self) -> List[int]: ``` 2. **Input and Output Format**: - `insert(self, key: int, value: Any = None)`: Inserts a new node with the given key and optional value, maintaining AVL balance. - `delete(self, key: int)`: Removes the node with the given key, maintaining AVL balance. - `find(self, key: int)`: Searches for the node with the given key and returns its value if found, otherwise returns `None`. - `in_order_traversal(self)`: Returns a list of all keys in the tree in in-order traversal. 3. **Constraints**: - Keys are unique integers. - Balance factors must be maintained within the allowed range [-1, 0, 1] after each insertion or deletion. - Implement the necessary AVL rotations (left, right, left-right, right-left) to maintain balance. 4. **Performance Requirements**: - Ensure that the tree remains balanced, with average case operations for insertion, deletion, and search being logarithmic time (O(log n)). Example Usage: ```python # Initializing AVL Tree avl = AVLTree() # Inserting elements avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) avl.insert(25) # In-order traversal print(avl.in_order_traversal()) # Output: [10, 20, 25, 30, 40, 50] # Searching for an element print(avl.find(25)) # Output: None (if no value assigned), or the given value if assigned # Deleting an element avl.delete(40) # In-order traversal after deletion print(avl.in_order_traversal()) # Output: [10, 20, 25, 30, 50] ``` Implement the `AVLTree` and `AVLTreeNode` classes to fulfill the above specifications.","solution":"class AVLTreeNode: def __init__(self, key: int, value: any = None) -> None: self.key = key self.value = value self.height = 1 self.left = None self.right = None class AVLTree: def __init__(self) -> None: self.root = None def insert(self, key: int, value: any = None) -> None: self.root = self._insert(self.root, key, value) def _insert(self, node, key, value): if not node: return AVLTreeNode(key, value) if key < node.key: node.left = self._insert(node.left, key, value) else: node.right = self._insert(node.right, key, value) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1: if key < node.left.key: return self._right_rotate(node) else: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if key > node.right.key: return self._left_rotate(node) else: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key: int) -> None: self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) >= 0: return self._right_rotate(node) else: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if self._get_balance(node.right) <= 0: return self._left_rotate(node) else: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def find(self, key: int) -> any: return self._find(self.root, key) def _find(self, node, key): if not node: return None if key < node.key: return self._find(node.left, key) elif key > node.key: return self._find(node.right, key) else: return node.value def in_order_traversal(self) -> list: res = [] self._in_order_traversal(self.root, res) return res def _in_order_traversal(self, node, res): if not node: return self._in_order_traversal(node.left, res) res.append(node.key) self._in_order_traversal(node.right, res) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"# Inventory Cycle Count You are managing an inventory system for a warehouse and need to report on the stock cycle counts. Each cycle count operation on an item provides the current count of that item. The system records each operation as a tuple of two elements: the item ID and the count. Your task is to determine the total number of each item present in the inventory based on the recorded operations. # Function Signature ```python def calculate_inventory(operations: list[tuple[str, int]]) -> dict: Returns a dictionary with the total count of each item in the inventory. ``` # Input * A list of tuples `operations`, where each tuple contains: * a string `item_id` representing the unique ID of an item, * an integer `count` representing the count of the item. # Output * A dictionary where: * keys are the unique item IDs (strings), * values are the total counts (integers) of each item. # Constraints * An item\'s count can be positive (addition) or negative (removal). * An item ID consists of alphanumeric characters and is case-sensitive. * The length of the input list `operations` will not exceed 1000 operations. # Example ```python >>> calculate_inventory([(\\"A123\\", 10), (\\"B456\\", 5), (\\"A123\\", -3), (\\"C789\\", 7), (\\"B456\\", 2), (\\"C789\\", -4), (\\"A123\\", 6)]) {\'A123\': 13, \'B456\': 7, \'C789\': 3} >>> calculate_inventory([(\\"ItemX\\", 100), (\\"ItemY\\", 150), (\\"ItemX\\", -50), (\\"ItemZ\\", 75), (\\"ItemY\\", -25), (\\"ItemZ\\", 10)]) {\'ItemX\': 50, \'ItemY\': 125, \'ItemZ\': 85} ``` # Scenario In your warehouse, the system logs every inventory adjustment as cycle count operations. To keep track of the inventory accurately, you need to sum up all operations for each item to determine the correct stock levels. This new inventory count will help in generating accurate reports and making informed decisions on restocking and order fulfillment. # Performance Requirements Your solution should efficiently handle up to 1000 operations while ensuring the proper aggregation of inventory counts for each unique item ID.","solution":"def calculate_inventory(operations): Returns a dictionary with the total count of each item in the inventory. inventory = {} for item_id, count in operations: if item_id not in inventory: inventory[item_id] = 0 inventory[item_id] += count return inventory"},{"question":"# Problem Statement: You are a software developer tasked with writing a function that finds the first non-repeated character in a given string. This is a common task in text processing, often used in various applications like data compression algorithms and search engines. # Task: Write a function `find_first_non_repeated_char()` that takes a single argument: - `input_string` (str): The string in which you need to find the first non-repeated character. The function should return the first character that does not repeat anywhere in the string. If all characters are repeated, return `None`. Constraints: - The input string will only contain lowercase alphabetic characters (`a-z`). - The length of the input string will not exceed 10,000 characters. Example: ```python def find_first_non_repeated_char(input_string: str) -> str: pass # Your implementation here # Example Test Cases: print(find_first_non_repeated_char(\\"alphabet\\")) # \'l\' print(find_first_non_repeated_char(\\"swiss\\")) # \'w\' print(find_first_non_repeated_char(\\"aabbcc\\")) # None ``` # Requirements: - Optimize for time and space complexity. - Consider edge cases, including empty strings and strings where all characters are repeated. Hint: You might want to use a dictionary to count the occurrences of each character and then iterate through the string again to find the first non-repeated character.","solution":"def find_first_non_repeated_char(input_string: str) -> str: Finds the first non-repeated character in the input string. Returns the first non-repeated character or None if all characters repeat. # Dictionary to count occurrences of each character. char_count = {} # Count each character in the input_string. for char in input_string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character with count 1. for char in input_string: if char_count[char] == 1: return char return None"},{"question":"# Coding Question: Number of Unique Binary Trees Context Given an integer `n`, a unique binary tree is defined as a binary tree structure (without considering the values of nodes themselves) such that no two trees in the collection can be made identical by renaming nodes. These structures are known as unique binary search trees (BST). Objective You are tasked to write a function that computes the number of unique BSTs that can be built with `n` unique nodes. Function Signature ```python def num_unique_bst(n: int) -> int: pass ``` Input - `n` (int): The number of unique nodes (1 ≤ n ≤ 19). Output - Returns an integer representing the number of unique BSTs that can be constructed with `n` unique nodes. Constraints - Utilize combinatorial mathematics, particularly the Catalan number, to derive the number of unique BSTs. - Optimize for readability and efficiency given the constraints. Example - `num_unique_bst(3)` should return `5`, corresponding to the unique trees that can be formed. - `num_unique_bst(5)` should return `42`, indicating the number of different binary structures achievable. Additional Notes - The sequence of Catalan numbers can be generated using the relation `C(n) = (2n)! / ((n + 1)! n!)`. - Thoroughly test with the provided boundary values for accuracy.","solution":"def num_unique_bst(n: int) -> int: Returns the number of unique BSTs that can be constructed with `n` unique nodes. This is computed using the nth Catalan number. if n == 0 or n == 1: return 1 # Initialize a list to store results of subproblems catalan = [0] * (n + 1) # Base cases catalan[0] = 1 catalan[1] = 1 # Fill the table according to the recursive Catalan Number equation for i in range(2, n + 1): catalan[i] = sum(catalan[j] * catalan[i - 1 - j] for j in range(i)) return catalan[n]"},{"question":"# Question: Implement a Consecutive Prime Sum Checker Context In number theory, there is a special interest in summing consecutive prime numbers. For example, the sum of the first 3 primes (2, 3, 5) is 10. This is beneficial for understanding prime distribution and properties of numbers formed by sums of primes. Task Write a function `is_consecutive_prime_sum(n: int) -> bool` that takes an integer `n` and returns `True` if `n` can be expressed as the sum of two or more consecutive prime numbers; otherwise, return `False`. Function Signature ```python def is_consecutive_prime_sum(n: int) -> bool: ``` Inputs - `n`: A positive integer. Outputs - A boolean value indicating whether `n` can be expressed as the sum of two or more consecutive prime numbers. Constraints 1. The input `n` is a positive integer. 2. The function should validate the input value and raise appropriate exceptions: * `ValueError` if the input is not positive. * `TypeError` if the input is not an integer. Performance Requirements - The function should efficiently handle values of `n` up to `10^6`. Examples ```python >>> is_consecutive_prime_sum(10) True # Explanation: 2 + 3 + 5 = 10 >>> is_consecutive_prime_sum(41) True # Explanation: 2 + 3 + 5 + 7 + 11 + 13 = 41 >>> is_consecutive_prime_sum(20) False # Explanation: There is no combination of consecutive primes summing to 20. >>> is_consecutive_prime_sum(23) True # Explanation: 5 + 7 + 11 = 23 >>> is_consecutive_prime_sum(30) True # Explanation: 7 + 11 + 13 = 30 ``` Error Handling Examples ```python >>> is_consecutive_prime_sum(-10) Traceback (most recent call last): ... ValueError: the value of input must be positive >>> is_consecutive_prime_sum(1.5) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> is_consecutive_prime_sum(\\"50\\") Traceback (most recent call last): ... TypeError: \'<\' not supported between instances of \'str\' and \'int\' ```","solution":"def is_consecutive_prime_sum(n: int) -> bool: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") def generate_primes(limit): sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False for start in range(2, int(limit**0.5) + 1): if sieve[start]: for multiple in range(start*start, limit + 1, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] primes = generate_primes(n) for i in range(len(primes)): total = 0 for j in range(i, len(primes)): total += primes[j] if total == n: return True if total > n: break return False"},{"question":"# Inheritance Hierarchy for Shapes You are tasked with defining a set of classes to represent a hierarchy of shapes and calculating their areas. Implement the following classes in Python. Rules: 1. Define an abstract base class `Shape` with an abstract method `area()`. 2. Define three concrete classes `Rectangle`, `Circle`, and `Triangle` that inherit from `Shape`. 3. Each shape class should have its own constructor and implement the `area()` method to calculate its area: - Rectangle: `length` and `width` - Circle: `radius` - Triangle: `base` and `height` Your task is to implement these classes and ensure that they follow the correct inheritance hierarchy and provide accurate area calculations. # Input: - No direct input; you will create instances of the classes and call their methods. # Output: - The function `calculate_area(shape: Shape) -> float` should return the area of the given shape instance. - Ensure the output is a floating-point number accurate to two decimal places. # Example: ```python # Define the Shape hierarchy from abc import ABC, abstractmethod import math class Shape(ABC): @abstractmethod def area(self) -> float: pass class Rectangle(Shape): def __init__(self, length: float, width: float): self.length = length self.width = width def area(self) -> float: return self.length * self.width class Circle(Shape): def __init__(self, radius: float): self.radius = radius def area(self) -> float: return math.pi * self.radius ** 2 class Triangle(Shape): def __init__(self, base: float, height: float): self.base = base self.height = height def area(self) -> float: return 0.5 * self.base * self.height def calculate_area(shape: Shape) -> float: return round(shape.area(), 2) # Usage shapes = [ Rectangle(5, 3), Circle(4), Triangle(6, 7) ] for shape in shapes: print(calculate_area(shape)) ``` Output: ``` 15.0 50.27 21.0 ``` # Note: - You need to create a class hierarchy that adheres to the principles of inheritance and polymorphism. - Use the `abc` module to define the abstract base class and its abstract method. - Ensure that floating-point results are rounded to two decimal places. Implement your solution by defining the class hierarchy and the `calculate_area` function.","solution":"from abc import ABC, abstractmethod import math class Shape(ABC): @abstractmethod def area(self) -> float: pass class Rectangle(Shape): def __init__(self, length: float, width: float): self.length = length self.width = width def area(self) -> float: return self.length * self.width class Circle(Shape): def __init__(self, radius: float): self.radius = radius def area(self) -> float: return math.pi * self.radius ** 2 class Triangle(Shape): def __init__(self, base: float, height: float): self.base = base self.height = height def area(self) -> float: return 0.5 * self.base * self.height def calculate_area(shape: Shape) -> float: return round(shape.area(), 2)"},{"question":"# Problem Statement As part of a data processing pipeline, you need to implement functions to handle two critical operations involving matrices. These operations are commonly required in computational data analysis, machine learning, and image processing tasks. # Your Task 1. **Rotate a Matrix**: Implement a function to rotate a matrix by 90 degrees clockwise. The rotation should be done in-place for optimal performance. 2. **Matrix Transposition**: Implement a function to compute the transpose of a matrix without modifying the original matrix. # Instructions 1. **rotate_matrix**: * **Input**: `matrix` (List[List[int]]) - a square 2D list where each element is an integer. * **Output**: None. * **Constraints**: The matrix will have dimensions `n x n` where ( 1 leq n leq 100 ). 2. **transpose_matrix**: * **Input**: `matrix` (List[List[int]]) - a 2D list where each element is an integer. * **Output**: List[List[int]] - the transposed matrix. * **Constraints**: The matrix can have any valid dimensions where ( 1 leq rows, cols leq 100 ). # Example Example 1: Rotate Matrix ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Example 2: Transpose Matrix ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> result = transpose_matrix(matrix) >>> print(result) [ [1, 4], [2, 5], [3, 6] ] ``` # Requirements - The `rotate_matrix` function should modify the input matrix in-place without using additional arrays for holding elements during transformation. - The `transpose_matrix` function should return a new matrix and leave the original matrix unaltered. - Ensure to handle edge cases such as empty matrices or matrices with non-standard shapes. - Performance should be optimal for the given constraints.","solution":"def rotate_matrix(matrix): Rotates the input n x n matrix by 90 degrees clockwise in-place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Coordinates of the four corners in the current square top_left = matrix[i][j] bottom_left = matrix[n - j - 1][i] bottom_right = matrix[n - i - 1][n - j - 1] top_right = matrix[j][n - i - 1] # Rotating elements in 90 degree clockwise manner matrix[i][j], matrix[j][n - i - 1], matrix[n - i - 1][n - j - 1], matrix[n - j - 1][i] = bottom_left, top_left, top_right, bottom_right def transpose_matrix(matrix): Returns the transpose of the input 2D matrix. rows = len(matrix) if rows == 0: return [] cols = len(matrix[0]) transposed = [[matrix[j][i] for j in range(rows)] for i in range(cols)] return transposed"},{"question":"# Coding Assessment Question: Problem Context In software development, especially in gaming and graphical applications, manipulating strings of a defined length is a common task. String validation ensures that the username or player name meets specific criteria for a better user experience. Task Implement a function `is_valid_username(username: str) -> bool` that verifies whether a given username adheres to specific criteria: 1. The username must be between 5 and 15 characters long (inclusive). 2. It must start with an alphabets (either uppercase or lowercase). 3. The only allowed characters in the username are alphabets (both uppercase and lowercase), digits, and the underscore \'_\'. Function Signature ```python def is_valid_username(username: str) -> bool: ``` Input * A single string `username`. Output * A boolean value `True` if the username meets all the criteria, `False` otherwise. Constraints 1. The input string `username` will not exceed 100 characters in length. Examples * `is_valid_username(\\"Player_1\\")` should return `True`. * `is_valid_username(\\"123player\\")` should return `False` (does not start with an alphabet). * `is_valid_username(\\"PlayerName!\\")` should return `False` (contains an invalid character \'!\'). * `is_valid_username(\\"TooShort\\")` should return `False` (length less than 5 characters). * `is_valid_username(\\"_underscore\\")` should return `False` (does not start with an alphabet). Notes 1. Ensure your implementation is case-insensitive for the valid starting alphabet condition. 2. It\'s recommended to use regular expressions for pattern matching to simplify validation logic. 3. Consider edge cases such as empty strings and strings with only valid initial characters followed by invalid characters. Additional Implementation Details 1. Validate the length of the string first to ensure it falls within the required range. 2. Use appropriate error handling to manage non-string inputs, raising a `TypeError` if necessary. 3. Perform unit testing to ensure all test cases and edge cases are covered. ---","solution":"import re def is_valid_username(username: str) -> bool: Checks if the given username meets the specified criteria: 1. Length between 5 and 15 characters (inclusive). 2. Starts with an alphabet (uppercase or lowercase). 3. Contains only allowed characters: alphabets, digits, and underscore \'_\'. Args: username (str): The username to check. Returns: bool: True if the username is valid, False otherwise. if not isinstance(username, str): raise TypeError(\\"Username must be a string\\") if len(username) < 5 or len(username) > 15: return False # Regular expression to match the criteria pattern = r\'^[A-Za-z][A-Za-z0-9_]*\' if re.match(pattern, username): return True return False"},{"question":"# Problem Statement You are given a list of integers representing the height of buildings in a city skyline. The sun rises from the left (i.e., from the direction of the first element in the list), and a building receives sunlight if all the previous buildings to the left of it are shorter than it. Your task is to determine the number of buildings that will receive sunlight. # Function Signature ```python def count_buildings_with_sunlight(buildings: List[int]) -> int: pass ``` # Input * A list of integers `buildings` where ( 1 leq text{len(buildings)} leq 10^5 ) and each height ( 1 leq text{buildings[i]} leq 10^4 ). # Output * Return an integer representing the count of buildings that receive sunlight. # Examples ```python >>> count_buildings_with_sunlight([3, 1, 4, 7, 5, 8, 2]) 4 >>> count_buildings_with_sunlight([1, 2, 3, 4]) 4 >>> count_buildings_with_sunlight([4, 3, 2, 1]) 1 >>> count_buildings_with_sunlight([1, 1, 1, 1]) 1 ``` # Explanation In the first example, the buildings with height `3, 4, 7,` and `8` receive sunlight as they are taller than all the buildings to their left. Similarly, in the second example, each building is taller than the one before it, so all receive sunlight. In the third example, only the first building receives sunlight since all subsequent buildings are shorter. In the last example, only the first building receives sunlight as all buildings have the same height and thus block the sunlight for the buildings on their right. # Constraints * Ensure your solution works efficiently for the upper limit of the input size.","solution":"def count_buildings_with_sunlight(buildings): if not buildings: return 0 count = 1 # The first building always receives sunlight max_height = buildings[0] for height in buildings[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"# Scenario: Consider a file system that allows storage and retrieval of multiple file types and supports extensive search operations based on file properties. Efficient data organization and query support are crucial for the system\'s performance, especially with a large volume of files of varying sizes and types. # Task: Given a set of files, each characterized by its size (in KB) and type (such as \'txt\', \'jpg\', \'pdf\', etc.), design a data structure (Trie or Prefix Tree) to support the following operations efficiently: 1. **Insert File**: Add a new file with its size and type to the system. 2. **Search by Type**: Retrieve a list of files of a given type. 3. **Search by Size Range**: Retrieve a list of files whose sizes fall within a specified range. 4. **Delete File**: Remove a specific file identified by its type and size. # Implementation Requirements: 1. **Class Definitions**: - `FileStorage()`: Initializes the file storage system. - `insert(file_type: str, file_size: int) -> None`: Adds a new file with its type and size. - `search_by_type(file_type: str) -> list[tuple[str, int]]`: Returns a list of files of the specified type. - `search_by_size_range(min_size: int, max_size: int) -> list[tuple[str, int]]`: Returns a list of files whose sizes are within the specified range `[min_size, max_size]`. - `delete(file_type: str, file_size: int) -> bool`: Deletes a file with the specified type and size and returns `True` if the file was successfully deleted, `False` otherwise. 2. **Input**: - File type (string) and file size (integer) for insertion. - Parameters for the functions include file types, size ranges, and specific query terms. 3. **Output**: - Return values based on specified function requirements, with lists of files or success/failure indicators for deletions. 4. **Constraints**: - File sizes are non-negative integers. - File types are non-empty alphanumeric strings. - All operations assume valid inputs within the system\'s constraints. # Example: ```python storage = FileStorage() # Inserting files storage.insert(\'txt\', 1024) storage.insert(\'jpg\', 2048) storage.insert(\'pdf\', 512) storage.insert(\'txt\', 256) storage.insert(\'jpg\', 1024) # Search by file type print(storage.search_by_type(\'txt\')) # Output: [(\'txt\', 1024), (\'txt\', 256)] # Search by size range print(storage.search_by_size_range(500, 1500)) # Output: [(\'txt\', 1024), (\'pdf\', 512), (\'jpg\', 1024)] # Deleting a file print(storage.delete(\'txt\', 256)) # Output: True print(storage.search_by_type(\'txt\')) # Output: [(\'txt\', 1024)] ``` Implement the above functions carefully, considering edge cases and performance constraints.","solution":"class FileStorage: def __init__(self): self.files = [] def insert(self, file_type: str, file_size: int) -> None: Adds a new file with its type and size to the storage. self.files.append((file_type, file_size)) def search_by_type(self, file_type: str) -> list[tuple[str, int]]: Returns a list of files of the specified type. return [(ftype, fsize) for ftype, fsize in self.files if ftype == file_type] def search_by_size_range(self, min_size: int, max_size: int) -> list[tuple[str, int]]: Returns a list of files whose sizes fall within the specified range [min_size, max_size]. return [(ftype, fsize) for ftype, fsize in self.files if min_size <= fsize <= max_size] def delete(self, file_type: str, file_size: int) -> bool: Deletes a file with the specified type and size and returns True if the file was successfully deleted, or False if the file was not found. if (file_type, file_size) in self.files: self.files.remove((file_type, file_size)) return True return False"},{"question":"# Problem Statement You are given a string representing a mathematical expression containing non-negative integers and the operators `+`, `-`, `*`, and `/`. The expression is fully parenthesized, meaning every pair of operations is grouped by parentheses. Your task is to write a function `evaluate_expression` that evaluates the expression and returns the result as an integer. Input - A string containing a fully parenthesized mathematical expression. Output - An integer representing the result of evaluating the expression. Constraints - The integers are non-negative and fit within the range of a standard 32-bit integer. - The string length will not exceed 1000 characters. - Only the `+`, `-`, `*`, and `/` operations are used, and the `/` operator indicates integer division, which truncates towards zero. - The parenthesized expression will always be valid. Function Signature ```python def evaluate_expression(expression: str) -> int: ``` Example Suppose the input string is: ```text \\"((2+3)*(4-1))\\" ``` Step by step evaluation: 1. Evaluate the innermost expressions: - (2 + 3) -> 5 - (4 - 1) -> 3 2. Evaluate the remaining expression: - (5 * 3) -> 15 Thus, the result is 15. Another example: ```text \\"((15/3)-(2*3))\\" ``` Step by step evaluation: 1. Evaluate the innermost expressions: - (15 / 3) -> 5 - (2 * 3) -> 6 2. Evaluate the remaining expression: - (5 - 6) -> -1 Thus, the result is -1. Requirements - Implement the function in Python. - Ensure the function can correctly parse and evaluate the fully parenthesized mathematical expression. - Handle all edge cases such as division by zero (though not expected in valid inputs). --- This problem tests the ability to parse and evaluate nested expressions, handling arithmetic operations and respecting mathematical precedence due to the full parenthesization. The function should correctly handle input parsing, expression evaluation, and demonstrate robustness in dealing with intricate mathematical logic.","solution":"def evaluate_expression(expression: str) -> int: def helper(s, i): stack = [] num = 0 sign = \'+\' while i < len(s): c = s[i] if c.isdigit(): num = num * 10 + int(c) if c == \'(\': num, i = helper(s, i + 1) if not c.isdigit() and not c.isspace() or i == len(s) - 1: if sign == \'+\': stack.append(num) elif sign == \'-\': stack.append(-num) elif sign == \'*\': stack.append(stack.pop() * num) elif sign == \'/\': stack.append(int(stack.pop() / num)) sign = c num = 0 if c == \')\': break i += 1 return sum(stack), i return helper(expression, 0)[0]"},{"question":"# Determine the Missing Number **Problem Statement**: Implement a function `find_missing_number` that finds the missing number from a given list `nums` containing `n` distinct numbers ranging from `0` to `n`. The list is expected to have exactly one number missing. **Input**: * A list `nums` containing `n` distinct integers in the range `[0, n]`. **Output**: * An integer representing the missing number. **Constraints**: * The length of the input list ( |nums| ) is in the range `[1, 10^6]`. * All elements in `nums` are distinct. * The elements of `nums` are integers in the inclusive range `[0, n]`. **Examples**: ```python >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9, 6, 4, 2, 3, 5, 7, 0, 1]) 8 >>> find_missing_number([0]) 1 ``` **Implementation Note**: * Students can choose from various algorithms to determine the missing number, such as using the arithmetic sum formula, utilizing a set for efficient look-ups, or leveraging bitwise operations.","solution":"def find_missing_number(nums): Finds the missing number in the list of distinct numbers ranging from 0 to n. Args: nums (list): A list of distinct integers from 0 to n, with one number missing. Returns: int: The missing number. n = len(nums) total_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(total_sum - actual_sum)"},{"question":"# Devising an Efficient Warehouse Management Inventory You are tasked with creating a function that manages the inventory of a warehouse. The warehouse stores varying quantities of multiple products. You will be given a list of actions to perform, such as adding new products, updating quantities, and deleting products. The function should process these actions and return the current state of the inventory. # Instructions 1. **Function Signature**: ```python def manage_inventory(actions: List[Dict[str, Any]]) -> Dict[str, int]: ``` 2. **Inputs**: ```python [ {\\"action\\": \\"add\\", \\"product\\": \\"apple\\", \\"quantity\\": 100}, {\\"action\\": \\"update\\", \\"product\\": \\"apple\\", \\"quantity\\": 50}, {\\"action\\": \\"delete\\", \\"product\\": \\"banana\\"}, ... ] ``` * `action`: A string indicating the type of action (e.g., \\"add\\", \\"update\\", \\"delete\\"). * `product`: A string identifying the product. * `quantity`: An integer indicating the quantity of the product (used only with \\"add\\" and \\"update\\" actions). 3. **Output**: * A dictionary representing the current inventory, where keys are product names and values are their quantities. 4. **Constraints**: * The quantity will always be a non-negative integer. * \\"update\\" action assumes the product already exists in the inventory. * \\"delete\\" action removes the product from the inventory if it exists; otherwise, it does nothing. * If the actions list is empty, the output should be an empty dictionary. 5. **Example**: ```python actions = [ {\\"action\\": \\"add\\", \\"product\\": \\"apple\\", \\"quantity\\": 100}, {\\"action\\": \\"update\\", \\"product\\": \\"apple\\", \\"quantity\\": 50}, {\\"action\\": \\"delete\\", \\"product\\": \\"banana\\"} ] result = manage_inventory(actions) print(result) # {\\"apple\\": 50} ``` 6. **Hint**: Utilize dictionary operations to manage adding, updating, and deleting products efficiently. Implement the function `manage_inventory` such that it accurately processes the actions and returns the current state of the inventory.","solution":"from typing import List, Dict, Any def manage_inventory(actions: List[Dict[str, Any]]) -> Dict[str, int]: Processes a list of inventory management actions and returns the current state of the warehouse inventory. Parameters: - actions (List[Dict[str, Any]]): List of actions to perform on the inventory. Returns: - Dict[str, int]: The current state of the inventory. inventory = {} for action in actions: if action[\\"action\\"] == \\"add\\": if action[\\"product\\"] not in inventory: inventory[action[\\"product\\"]] = action[\\"quantity\\"] else: inventory[action[\\"product\\"]] += action[\\"quantity\\"] elif action[\\"action\\"] == \\"update\\": if action[\\"product\\"] in inventory: inventory[action[\\"product\\"]] = action[\\"quantity\\"] elif action[\\"action\\"] == \\"delete\\": if action[\\"product\\"] in inventory: del inventory[action[\\"product\\"]] return inventory"},{"question":"# Question: Common Prefix in a List of Words Problem Statement You are given a list of words, and your task is to find the longest common prefix shared among all words in the list. If there is no common prefix, return an empty string. Input: * A list of strings `words` ((0 leq text{len(words)} leq 10^5)), where each string has a length of at most (100). Output: * A string representing the longest common prefix among all the words in the list. Constraints: * All words consist of lowercase English letters only. * The input list `words` can be empty, in which case return an empty string. Examples: ```python def longest_common_prefix(words: List[str]) -> str: pass # Test Cases print(longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"])) # Output: \\"fl\\" print(longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"])) # Output: \\"\\" print(longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"])) # Output: \\"inters\\" print(longest_common_prefix([])) # Output: \\"\\" ``` Explanation: 1. For the first example, the longest common prefix among \\"flower\\", \\"flow\\", \\"flight\\" is \\"fl\\". 2. For the second example, there is no common prefix among \\"dog\\", \\"racecar\\", and \\"car\\". 3. For the third example, \\"interspecies\\", \\"interstellar\\", and \\"interstate\\" share the longest common prefix \\"inters\\". # Implementation Hints: * Consider comparing characters of each word one by one. * Alternatively, you might want to leverage the common prefix between two strings at a time to build the solution iteratively.","solution":"from typing import List def longest_common_prefix(words: List[str]) -> str: if not words: return \\"\\" # Find the shortest word in the list min_len = min(len(word) for word in words) # Use the shortest word as a reference to find the common prefix common_prefix = \\"\\" for i in range(min_len): # Get the current character from the first word current_char = words[0][i] # Check if this character is present at the same position in all words if all(word[i] == current_char for word in words): common_prefix += current_char else: break return common_prefix"},{"question":"# Coding Challenge # Problem Statement You are given a string `melody` consisting of lowercase alphabets and a list of `n` favorite substrings `favorites` where each substring is also composed of lowercase alphabets. Your task is to write a Python function `favorite_substring_count` that counts the number of times each favorite substring appears in the melody. # Input * A string `melody` consisting of lowercase alphabets with a length between 1 and 10^5. * A list of favorite substrings `favorites`, where each substring is composed of lowercase alphabets and the length of each favorite substring is between 1 and 10. # Output * A list of integers, where each integer corresponds to the number of times a favorite substring appears in the `melody`. # Constraints * The length of the string `melody` will be between 1 and 10^5. * The list `favorites` will contain between 1 and 10^3 favorite substrings. # Example ```python def favorite_substring_count(melody: str, favorites: List[str]) -> List[int]: pass # Example usage: assert favorite_substring_count(\\"abracadabra\\", [\\"abra\\", \\"cad\\", \\"br\\"]) == [2, 1, 1] assert favorite_substring_count(\\"abababab\\", [\\"ab\\", \\"ba\\", \\"abab\\", \\"baba\\"]) == [4, 3, 3, 2] ``` # Instructions * Implement the `favorite_substring_count` function. * Ensure that the solution handles large inputs efficiently. * Consider edge cases such as overlapping substrings and single-character substrings. # Performance considerations * The solution should process the input quickly even for the largest possible inputs. * Efficient search algorithms like the Knuth-Morris-Pratt (KMP) algorithm or Rabin-Karp algorithm can be used, but simpler approaches can also be accepted if they fit the problem constraints. # Note * Ensure your solution aligns with the standard Python coding practices and performs efficiently for large inputs. * Helper functions can be defined but keep the main function concise and focused on the problem statement.","solution":"def favorite_substring_count(melody, favorites): Counts the number of times each favorite substring appears in the melody. Parameters: melody (str): The string in which to search for favorite substrings. favorites (List[str]): The list of favorite substrings to count in the melody. Returns: List[int]: A list of integers where each integer is the count of appearances of the corresponding favorite substring. result = [] for favorite in favorites: count = 0 pos = melody.find(favorite) while pos != -1: count += 1 pos = melody.find(favorite, pos + 1) result.append(count) return result"},{"question":"# Context You are part of a software development team responsible for creating an optimized file management system. The system must support dynamic file allocation and efficient access for a variety of operations. Your current task is to implement a segment of this system focused on managing file segments using a merge and split strategy. # Problem Statement Create a class `SegmentManager` which supports the following operations: 1. `add_segment(start:int, end:int)`: Adds a new segment `[start, end]`. 2. `get_segments()`: Returns the current list of merged segments. When adding a segment, the function should merge any overlapping or contiguous segments to ensure no redundant segments exist. # Input - `add_segment(start, end)`: - `start`: integer (0 ≤ start ≤ 1000) indicating the start of the segment. - `end`: integer (0 ≤ end ≤ 1000) indicating the end of the segment. # Output - `get_segments()`: Returns a list of tuples, where each tuple represents a merged segment `(s, e)`. # Constraints Ensure the class handles edge cases efficiently, including: - Merging overlapping segments. - Adding non-overlapping segments. - Handling segments that are contiguous. # Example ```python segments = SegmentManager() segments.add_segment(1, 5) segments.add_segment(10, 15) segments.add_segment(3, 10) segments.get_segments() # Expected Output: [(1, 15)] ``` # Notes - Each segment is defined as `[start, end]` where `start` <= `end`. - Ensure your solution merges and organizes segments upon every addition, maintaining O(n log n) performance via efficient data structures. - Thoroughly test the implementation against various scenarios to confirm its accuracy and efficiency. # Proposed Class Structure ```python class SegmentManager: def __init__(self): self.segments = [] def add_segment(self, start: int, end: int): pass # Implement the logic to add and merge segments def get_segments(self): pass # Implement the logic to return the current merged segments ```","solution":"class SegmentManager: def __init__(self): self.segments = [] def add_segment(self, start: int, end: int): new_segment = (start, end) self.segments.append(new_segment) self._merge_segments() def _merge_segments(self): self.segments.sort() merged_segments = [] current_start, current_end = self.segments[0] for start, end in self.segments[1:]: if start <= current_end + 1: current_end = max(current_end, end) else: merged_segments.append((current_start, current_end)) current_start, current_end = start, end merged_segments.append((current_start, current_end)) self.segments = merged_segments def get_segments(self): return self.segments"},{"question":"# Question: Circular Shift Pattern Match Scenario You are given two strings consisting of lowercase English letters. Your task is to determine if one string can become the other using any number of circular shifts. # Task Write a function: ```python def is_circular_shift(s1: str, s2: str) -> bool: Check if one string can become the other string through any number of circular shifts. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string can become the other through circular shifts, otherwise False. ``` # Input - `s1`: A string of length n consisting of lowercase English letters. - `s2`: A string of length n consisting of lowercase English letters. # Output - The function should return `True` if `s1` can become `s2` through any number of circular shifts, otherwise `False`. # Constraints - Both strings `s1` and `s2` are non-empty and contain the same length (1 ≤ n ≤ 1000). # Performance Requirements - Ensure the solution can handle the maximum length efficiently. - Aim for a solution that checks circular shifts within linear time complexity. # Examples - `>>> is_circular_shift(\\"abcde\\", \\"cdeab\\")` - Output: True (after 3 right shifts of \\"abcde\\", it becomes \\"cdeab\\") - `>>> is_circular_shift(\\"abcde\\", \\"abced\\")` - Output: False (no circular shift can transform \\"abcde\\" into \\"abced\\") # Notes - Circular shift implies you take the last character and move it to the front, or take the first character and move it to the end, repetitively. - Consider edge cases with very short strings and identical strings. # Hints - Concatenate one of the strings with itself and check if the other string is a substring of this concatenated string. - This method allows you to handle shifts in linear time and efficiently compare substrings.","solution":"def is_circular_shift(s1: str, s2: str) -> bool: Check if one string can become the other string through any number of circular shifts. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if one string can become the other through circular shifts, otherwise False. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Matrix Diagonal Sum Calculation with Offset **Objective**: Implement a function that extends the capabilities of a standard matrix diagonal sum calculation to include diagonals determined by a given offset. **Task**: 1. **Core Functionality**: Implement a function `diagonal_sum` that calculates the sum of elements along a diagonal of a provided 2D matrix, considering an offset from the main diagonal. 2. **Offset Handling**: The offset can be positive, zero, or negative: - `offset = 0`: Main diagonal - `offset > 0`: Diagonals above the main diagonal - `offset < 0`: Diagonals below the main diagonal 3. **Validation and Constraints**: Ensure the function handles edge cases such as non-square matrices and invalid offsets gracefully. **Input and Output Formats**: * **Input**: * `matrix` (List[List[int]]): A 2D matrix of integers. * `offset` (int): An integer representing the offset from the main diagonal. * **Output**: An integer representing the sum of the elements along the specified diagonal. **Constraints**: * The matrix dimensions will be at least 1x1 and can vary in size, but the minimum size is guaranteed to be 1x1. * The `offset` should be a valid integer and within the bounds of the matrix dimensions to specify a valid diagonal. **Function Signature**: ```python def diagonal_sum(matrix: List[List[int]], offset: int) -> int: pass ``` **Examples**: 1. `diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0)` should return `15` (sum of main diagonal: 1 + 5 + 9). 2. `diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1)` should return `8` (sum of elements one diagonal above the main diagonal: 2 + 6). 3. `diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], -1)` should return `12` (sum of elements one diagonal below the main diagonal: 4 + 8). **Notes**: 1. If the offset specifies a diagonal that is outside the bounds of the matrix, return `0`. 2. Ensure robust error handling to manage matrices of different shapes and edge cases effectively.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]], offset: int) -> int: num_rows = len(matrix) num_cols = len(matrix[0]) sum_diag = 0 if offset >= 0: i, j = 0, offset else: i, j = -offset, 0 while i < num_rows and j < num_cols: sum_diag += matrix[i][j] i += 1 j += 1 return sum_diag"},{"question":"# Coding Question: Directed Graph Cycle Detection Problem Statement You are given a directed graph data structure implemented using an adjacency list. Your task is to extend this implementation to include methods for detecting cycles in the graph. Requirements 1. **Check Cycle**: - Implement the `has_cycle` method which checks if there is a cycle in the graph using Depth-First Search (DFS). - If the graph contains a cycle, the method should return `True`; otherwise, it should return `False`. Method Signatures - `def has_cycle(self) -> bool:` Input and Output Formats - **Has Cycle Method**: - **Input**: No additional input. - **Output**: A boolean indicating whether there is a cycle in the graph. Constraints - The graph can have up to 10,000 vertices and 50,000 edges. - The input vertices will always be valid integers if they exist in the graph. Example Assume we initialize the graph with the following vertices and edges: ```python vertices = [1, 2, 3, 4, 5] edges = [[1, 2], [2, 3], [3, 4], [4, 2], [4, 5]] graph = DirectedGraphAdjacencyList(vertices, edges) ``` - For `graph.has_cycle()`, the output would be `True` because there is a cycle (2 -> 3 -> 4 -> 2). Assume we initialize the graph with the following vertices and edges: ```python vertices = [1, 2, 3, 4, 5] edges = [[1, 2], [2, 3], [3, 4], [4, 5]] graph = DirectedGraphAdjacencyList(vertices, edges) ``` - For `graph.has_cycle()`, the output would be `False` because there are no cycles. Implementation ```python class DirectedGraphAdjacencyList(Generic[T]): def __init__(self, vertices: list[T], edges: list[list[T]]): self.adj_list = {vertex: [] for vertex in vertices} for edge in edges: self.adj_list[edge[0]].append(edge[1]) def has_cycle(self) -> bool: def visit(vertex, visited, stack): visited[vertex] = True stack[vertex] = True for neighbor in self.adj_list[vertex]: if not visited[neighbor]: if visit(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[vertex] = False return False visited = {vertex: False for vertex in self.adj_list} stack = {vertex: False for vertex in self.adj_list} for vertex in self.adj_list: if not visited[vertex]: if visit(vertex, visited, stack): return True return False # Example of how to use: vertices = [1, 2, 3, 4, 5] edges = [[1, 2], [2, 3], [3, 4], [4, 2], [4, 5]] graph = DirectedGraphAdjacencyList(vertices, edges) print(graph.has_cycle()) # True vertices = [1, 2, 3, 4, 5] edges = [[1, 2], [2, 3], [3, 4], [4, 5]] graph = DirectedGraphAdjacencyList(vertices, edges) print(graph.has_cycle()) # False ```","solution":"class DirectedGraphAdjacencyList: def __init__(self, vertices, edges): self.adj_list = {vertex: [] for vertex in vertices} for edge in edges: self.adj_list[edge[0]].append(edge[1]) def has_cycle(self): def visit(vertex, visited, stack): visited[vertex] = True stack[vertex] = True for neighbor in self.adj_list[vertex]: if not visited[neighbor]: if visit(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[vertex] = False return False visited = {vertex: False for vertex in self.adj_list} stack = {vertex: False for vertex in self.adj_list} for vertex in self.adj_list: if not visited[vertex]: if visit(vertex, visited, stack): return True return False"},{"question":"# Task: Implement a simplified LRU Cache Context: A tech company wants to implement an in-memory cache that allows efficient retrieval and storage of data. They chose to use an LRU (Least Recently Used) strategy to manage cache evictions when the cache reaches its capacity. An LRU Cache evicts the least recently accessed item when new items are added beyond its capacity. Problem: Create an `LRUCache` class with methods to add, retrieve, and maintain the LRU property for the cache elements. Implement the cache using a dictionary to store values and a doubly linked list to keep track of recently used elements. Requirements: - **Key Functionality**: - Implement the `LRUCache` class with specified methods and ensure the least recently accessed item is evicted first when the cache exceeds its capacity. - Retrieve items in constant time and update access history efficiently. - Handle cache inserts, updates, and evictions. - **Input/Output**: ```python class LRUCache: def __init__(self, capacity: int) -> None def get(self, key: int) -> int # retrieves the value for the given key, -1 if key is not found def put(self, key: int, value: int) -> None # inserts or updates the value for the given key ``` - **Constraints**: - Max capacity (`capacity`) is defined at cache initialization. - Handle both typical and edge case scenarios gracefully. - **Performance Expectations**: - Average-case time complexity O(1) for both insertions (`put`) and lookups (`get`). Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Output: -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Output: -1 (not found) print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ``` Implement the `LRUCache` class with methods `get` and `put` to maintain and manage the cache using the LRU (Least Recently Used) strategy.","solution":"class Node: def __init__(self, key: int, value: int) -> None: self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node) -> None: temp = self.head.next self.head.next = node node.prev = self.head node.next = temp temp.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) new_node = Node(key, value) self._add(new_node) self.cache[key] = new_node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key]"},{"question":"# Bi-Directional Dictionary In many programming scenarios, there\'s a need to maintain relationships between two sets of data that can be easily reversed, such as maintaining mappings between countries and their capital cities. In this task, you will create a Bi-Directional Dictionary class that allows for bi-directional lookups: given a key you can find its corresponding value, and given a value you can find its corresponding key. # Requirements 1. **Class Definition**: Define a `BiDict` class capable of managing bi-directional lookups. 2. **Add Pairs**: Implement a method to add a new key-value pair to the dictionary. 3. **Remove Pairs**: Implement a method to remove a key-value pair from the dictionary. 4. **Lookup Methods**: Implement two methods for lookup: - `get_by_key(key)`: Returns the value associated with the key. - `get_by_value(value)`: Returns the key associated with the value. 5. **String Representation**: Implement a `__str__` method for printing the current state of the dictionary. # Constraints - Keys and values are assumed to be unique and immutable (strings, for simplicity). - Raise an appropriate error if a non-existent key or value is requested. - Ensure consistency in the bi-directional mapping upon additions and deletions. # Example ```python class BiDict: def __init__(self): self.key_to_value = {} self.value_to_key = {} def add_pair(self, key, value): if key in self.key_to_value or value in self.value_to_key: raise ValueError(\\"Duplicate key or value detected\\") self.key_to_value[key] = value self.value_to_key[value] = key def remove_pair(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") value = self.key_to_value.pop(key) del self.value_to_key[value] def get_by_key(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") return self.key_to_value[key] def get_by_value(self, value): if value not in self.value_to_key: raise KeyError(\\"Value does not exist\\") return self.value_to_key[value] def __str__(self): return str(self.key_to_value) # Example Usage bi_dict = BiDict() bi_dict.add_pair(\\"USA\\", \\"Washington\\") bi_dict.add_pair(\\"Canada\\", \\"Ottawa\\") print(bi_dict) # Output: {\\"USA\\": \\"Washington\\", \\"Canada\\": \\"Ottawa\\"} print(bi_dict.get_by_key(\\"USA\\")) # Output: Washington print(bi_dict.get_by_value(\\"Ottawa\\")) # Output: Canada bi_dict.remove_pair(\\"USA\\") print(bi_dict) # Output: {\\"Canada\\": \\"Ottawa\\"} ``` # Notes - Handle errors gracefully and provide meaningful error messages. - Ensure that the internal data structures remain consistent after each operation. - Consider edge cases such as attempting to add duplicates or removing non-existent keys/values.","solution":"class BiDict: def __init__(self): self.key_to_value = {} self.value_to_key = {} def add_pair(self, key, value): if key in self.key_to_value or value in self.value_to_key: raise ValueError(\\"Duplicate key or value detected\\") self.key_to_value[key] = value self.value_to_key[value] = key def remove_pair(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") value = self.key_to_value.pop(key) del self.value_to_key[value] def get_by_key(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") return self.key_to_value[key] def get_by_value(self, value): if value not in self.value_to_key: raise KeyError(\\"Value does not exist\\") return self.value_to_key[value] def __str__(self): return str(self.key_to_value)"},{"question":"# Analyze Digits to Determine Sequences You are given a function to determine if all digits in a given number follow a specific incremental pattern. The function should check whether each digit in the number is exactly one more than the previous digit. # Problem Description Write a function, `check_incremental_pattern`, that verifies if each digit in the input number is exactly one greater than the previous one. # Requirements 1. The function should return `True` if each digit is exactly one greater than the preceding digit. 2. The function should return `False` otherwise. 3. Strings with a single digit are always considered to follow the pattern. # Function Signature ```python def check_incremental_pattern(number: int) -> bool: ``` # Input * `number` (int): A non-negative integer. # Output * Returns a boolean: `True` if the digits follow the incremental pattern, `False` otherwise. # Constraints 1. The number parameter should always be non-negative. 2. If the number is zero, the function should return `True`. # Example ```python def check_incremental_pattern(number: int) -> bool: >>> check_incremental_pattern(12345) True >>> check_incremental_pattern(1357) False >>> check_incremental_pattern(56) True >>> check_incremental_pattern(32) False >>> check_incremental_pattern(0) True >>> check_incremental_pattern(7) True number_str = str(number) for i in range(1, len(number_str)): if int(number_str[i]) != int(number_str[i - 1]) + 1: return False return True ```","solution":"def check_incremental_pattern(number: int) -> bool: Determines if the digits in a number follow an incremental pattern where each digit is exactly one more than the preceding digit. Parameters: number (int): A non-negative integer. Returns: bool: True if the digits follow the incremental pattern, False otherwise. number_str = str(number) for i in range(1, len(number_str)): if int(number_str[i]) != int(number_str[i - 1]) + 1: return False return True"},{"question":"# Duplicate Finder in a List Context In software development, it\'s vital to identify and handle duplicate data within data structures to ensure data integrity and reduce redundancies. Identifying duplicates can help in optimizing storage and enhancing the performance of applications. Problem Statement You need to write a function that takes a list of integers and returns a list of duplicates found in the input list. If no duplicates are found, the function should return an empty list. # Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: Returns a list of duplicates from the input list of integers. - nums: A list of integers. ``` # Expected Inputs and Outputs * Input: A list of integers. * Output: A list of integers containing the duplicates in the order they first appear. # Constraints - The input list can contain up to 10^6 integers. - Integers can be both positive and negative. - Duplicates in the input list should appear in the output list only once, in the order they first occur in the input list. # Examples ```python assert find_duplicates([1, 2, 3, 4, 5, 3, 2, 1]) == [3, 2, 1] assert find_duplicates([1, 2, 3, 4, 5]) == [] assert find_duplicates([6, 6, 6, 6]) == [6] assert find_duplicates([-1, -2, -3, -1, -2, -3]) == [-1, -2, -3] assert find_duplicates([]) == [] ``` # Additional Information - You may use Python\'s built-in data structures like sets and dictionaries to optimize the performance of your solution. - Ensure that the function performs efficiently even for large input sizes.","solution":"def find_duplicates(nums: list[int]) -> list[int]: Returns a list of duplicates from the input list of integers. - nums: A list of integers. seen = set() duplicates = set() result = [] for num in nums: if num in seen: if num not in duplicates: duplicates.add(num) result.append(num) else: seen.add(num) return result"},{"question":"# **Coding Assessment Question** **String Manipulation and Patterns** In this task, you will implement and test additional functionalities for the `StringPattern` class. The objective is to demonstrate your understanding of string manipulation, pattern recognition, and regular expressions by completing the methods as specified below. **Task** 1. **Longest Prefix**: Implement a method `longest_prefix` to return the longest common prefix among an array of strings. ```python def longest_prefix(self, strings: List[str]) -> str: Return the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \\"\\". >>> StringPattern().longest_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \'fl\' >>> StringPattern().longest_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \'\' >>> StringPattern().longest_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \'inters\' # Implement the method here ``` 2. **Anagrams Check**: Implement a method `are_anagrams` to check if two strings are anagrams of each other. ```python def are_anagrams(self, str1: str, str2: str) -> bool: Determine if the two strings are anagrams of each other. >>> StringPattern().are_anagrams(\\"listen\\", \\"silent\\") True >>> StringPattern().are_anagrams(\\"hello\\", \\"world\\") False >>> StringPattern().are_anagrams(\\"evil\\", \\"vile\\") True # Implement the method here ``` 3. **Word Pattern Matching**: Implement a method `word_pattern` to check if a word follows a given pattern. ```python def word_pattern(self, pattern: str, s: str) -> bool: Determine if the given word follows the specified pattern. >>> StringPattern().word_pattern(\\"abba\\", \\"dog cat cat dog\\") True >>> StringPattern().word_pattern(\\"abba\\", \\"dog cat cat fish\\") False >>> StringPattern().word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") True >>> StringPattern().word_pattern(\\"abba\\", \\"dog dog dog dog\\") False # Implement the method here ``` **Function Signature** ```python class StringPattern: def longest_prefix(self, strings: List[str]) -> str: # Implement here pass def are_anagrams(self, str1: str, str2: str) -> bool: # Implement here pass def word_pattern(self, pattern: str, s: str) -> bool: # Implement here pass ``` **Input and Output Formats** * The `longest_prefix` method should return a string which is the longest common prefix among the input strings. * The `are_anagrams` method should return a boolean indicating whether the two input strings are anagrams of each other. * The `word_pattern` method should return a boolean indicating whether the input string follows the specified pattern. **Constraints/Limitations** * All input strings consist of lowercase English letters. * The number of strings for `longest_prefix` is at most 200. * The length of each string for `longest_prefix` and the two strings for `are_anagrams` is at most 100. * The pattern and the word in `word_pattern` method are non-empty and consist of lowercase English letters and spaces respectively.","solution":"from typing import List class StringPattern: def longest_prefix(self, strings: List[str]) -> str: if not strings: return \\"\\" min_length = min(len(s) for s in strings) low, high = 1, min_length def is_common_prefix(length): prefix = strings[0][:length] return all(s.startswith(prefix) for s in strings) while low <= high: mid = (low + high) // 2 if is_common_prefix(mid): low = mid + 1 else: high = mid - 1 return strings[0][:(low + high) // 2] def are_anagrams(self, str1: str, str2: str) -> bool: return sorted(str1) == sorted(str2) def word_pattern(self, pattern: str, s: str) -> bool: words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Generate Spiral Matrix Scenario A robotics company is developing a path-following algorithm for their robots to navigate a grid-based environment. The robot must be able to generate a path that spirals inward from the top-left corner and covers all cells of a given matrix. Task You need to implement a function `generate_spiral_matrix(n: int) -> List[List[int]]` that returns an `n x n` matrix filled with numbers from 1 to `n^2` in a spiral order starting from the top-left corner. Implementation Details * Start with an empty `n x n` matrix. * Fill the matrix in a spiral order, moving right initially, then down, left, and up, repeating this process as needed until the matrix is completely filled. * Ensure that you handle boundaries and already-filled cells properly to guide the direction changes. Constraints * `1 <= n <= 20`, where `n` is the size of the matrix. Example ```python >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] ``` Notes * The numbers in the matrix should increment sequentially from 1 up to `n^2`. * Ensure that all rows and columns conform to the spiral pattern specified in the example.","solution":"def generate_spiral_matrix(n): Generate an n x n matrix filled with numbers from 1 to n^2 in a spiral order. if n <= 0: return [] # Initialize the matrix with zeros matrix = [[0] * n for _ in range(n)] # Directions vectors for right, down, left, and up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] row, col = 0, 0 # Start from the top-left corner current_dir = 0 # Start with moving right num = 1 # Starting number for _ in range(n * n): matrix[row][col] = num num += 1 # Calculate the next position next_row = row + directions[current_dir][0] next_col = col + directions[current_dir][1] # Check boundaries and already filled cells if next_row < 0 or next_row >= n or next_col < 0 or next_col >= n or matrix[next_row][next_col] != 0: # Change direction current_dir = (current_dir + 1) % 4 next_row = row + directions[current_dir][0] next_col = col + directions[current_dir][1] row, col = next_row, next_col return matrix"},{"question":"# Question: Building and Analyzing an Adjustable IIR Filter Context You have previously worked on implementing and visualizing an FIR filter. Now, your task is to construct a custom Infinite Impulse Response (IIR) filter and analyze its frequency and phase response using existing visualization functions. Task 1. Implement a custom IIR filter class that adheres to a given interface. The class must have: - An `__init__` method to initialize feedforward (`b`) and feedback (`a`) coefficients. - A `process()` method that takes a single sample as input and returns a filtered sample. 2. Visualize the frequency and phase response using the provided `show_frequency_response()` and `show_phase_response()` functions. Requirements * **Filter Specification**: You will implement a second-order low-pass IIR filter with specified coefficients. * **Input/Output**: - The IIR filter class will take lists of feedforward and feedback coefficients as input. - The `process()` method will output the filtered value for each sample. * **Constraints**: - Sample rate for visualization: 48000 Hz. - Length of input signal for visualization: 512 samples. * **Performance**: - The implementation must handle signals efficiently. - The plot should be clear and cover the frequency range effectively. # Example ```python class IIRFilter: def __init__(self, b: list[float], a: list[float]) -> None: self.b = b self.a = a self.buffer_x = [0] * len(b) self.buffer_y = [0] * len(a) def process(self, sample: float) -> float: self.buffer_x.pop(0) self.buffer_x.append(sample) output = sum(c * s for c, s in zip(self.b, self.buffer_x)) - sum(c * s for c, s in zip(self.a[1:], self.buffer_y[1:])) self.buffer_y.pop(0) self.buffer_y.append(output) return output # Coefficients for a simple second-order low-pass IIR filter b = [0.2929, 0.5858, 0.2929] # Feedforward coefficients a = [1.0, -0.0, 0.1716] # Feedback coefficients filt = IIRFilter(b, a) show_frequency_response(filt, 48000) show_phase_response(filt, 48000) ``` Ensure your implementation of the IIR filter efficiently processes the signals and generates clear frequency and phase response plots as required.","solution":"import numpy as np from scipy.signal import freqz import matplotlib.pyplot as plt class IIRFilter: def __init__(self, b, a): Initializes the IIR filter with feedforward (b) and feedback (a) coefficients. self.b = b self.a = a self.x_buffer = [0] * len(b) self.y_buffer = [0] * len(a) def process(self, sample): Processes a single sample through the IIR filter and returns the filtered output. # Update buffers self.x_buffer.pop(0) self.x_buffer.append(sample) # Calculate the output sample output = sum(c * s for c, s in zip(self.b, self.x_buffer)) - sum(c * s for c, s in zip(self.a[1:], self.y_buffer[1:])) # Update output buffer self.y_buffer.pop(0) self.y_buffer.append(output) return output def show_frequency_response(filter_obj, fs): Plots the frequency response of the IIR filter. # Calculate frequency response b, a = filter_obj.b, filter_obj.a w, h = freqz(b, a, fs=fs) # Plot magnitude response plt.figure(figsize=(10, 6)) plt.subplot(2, 1, 1) plt.plot(w, 20 * np.log10(abs(h))) plt.title(\'Frequency response\') plt.xlabel(\'Frequency (Hz)\') plt.ylabel(\'Magnitude (dB)\') plt.grid(True) # Plot phase response plt.subplot(2, 1, 2) plt.plot(w, np.angle(h)) plt.title(\'Phase response\') plt.xlabel(\'Frequency (Hz)\') plt.ylabel(\'Phase (radians)\') plt.grid(True) plt.show() # Coefficients for a simple second-order low-pass IIR filter b = [0.2929, 0.5858, 0.2929] # Feedforward coefficients a = [1.0, -0.0, 0.1716] # Feedback coefficients filt = IIRFilter(b, a) show_frequency_response(filt, 48000)"},{"question":"# Meal Distribution for Homeless Shelter You are tasked with developing a function to manage a volunteer program for distributing meals at a homeless shelter. The shelter receives a varying number of food packages weekly and needs to distribute them equally among the volunteers. If the number of packages does not divide evenly among the volunteers, the remainder of packages should be distributed such that each of the first few volunteers gets one extra package until there are no more remainders left. The Task Given the number of food packages and the number of volunteers, write a function that distributes the packages and returns the number of packages each volunteer receives. **Function Signature:** ```python def distribute_meals(packages: int, volunteers: int) -> List[int]: pass ``` **Input:** - `packages` (*int*): A non-negative integer representing the number of food packages. - `volunteers` (*int*): A positive integer representing the number of volunteers. **Output:** - (*List[int]*): A list of integers where each element represents the number of packages assigned to each volunteer. **Constraints:** - Ensure the solution efficiently handles a large number of packages. - The solution must work even if the number of packages is zero. **Performance Requirements:** - The solution should run efficiently for `packages` up to 100000. # Example Usages: ```python print(distribute_meals(10, 3)) # Expected output: [4, 3, 3] print(distribute_meals(12, 5)) # Expected output: [3, 3, 2, 2, 2] print(distribute_meals(0, 4)) # Expected output: [0, 0, 0, 0] print(distribute_meals(8, 2)) # Expected output: [4, 4] ``` **Scenario:** You are managing resources in a homeless shelter, and it\'s imperative that food packages are distributed equitably among the volunteers to ensure smooth operations and fair distribution.","solution":"def distribute_meals(packages: int, volunteers: int): Distributes packages among volunteers. Extra packages are distributed to the first few volunteers. Args: packages (int): Number of packages. volunteers (int): Number of volunteers. Returns: List[int]: List containing number of packages each volunteer receives. # Convert volunteers to integer to handle case if not provided in expected type volunteers = int(volunteers) # Calculate the base number of packages each volunteer should get and the remainder base = packages // volunteers remainder = packages % volunteers # Distribute the packages distribution = [base + 1 if i < remainder else base for i in range(volunteers)] return distribution"},{"question":"# Matrix Diagonal Sum Calculation Scenario: You are given a problem where you need to calculate the sum of the primary diagonal elements of a square matrix. The primary diagonal of a square matrix runs from the top left corner to the bottom right corner. Task: Write a function `diagonal_sum` that computes the sum of the primary diagonal elements of a given square matrix. The function should validate that the input is a square matrix and handle any errors appropriately. Function Signature: ```python def diagonal_sum(matrix: list[list[int]]) -> int: pass ``` Input: - `matrix` (list[list[int]]): A two-dimensional list representing a square matrix of integers where each element is an int. Output: - Returns the sum (int) of the primary diagonal elements of the matrix. Constraints: - The matrix is guaranteed to be non-empty and to have equal number of rows and columns. Performance Requirements: - The function should operate efficiently with a time complexity of O(n), where n is the number of rows (or columns) in the matrix. Examples: ```python >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> diagonal_sum([[5, 1], [3, 4]]) 9 >>> diagonal_sum([[7]]) 7 >>> diagonal_sum([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: The provided matrix is not a square matrix. >>> diagonal_sum([[2, 4, 6], [8, 10, 12], 14]) Traceback (most recent call last): ... TypeError: The matrix must be a list of lists of integers. ``` Ensure your function validates the input and handles errors appropriately. The function should efficiently compute the diagonal sum with the performance constraint in mind.","solution":"def diagonal_sum(matrix): Computes the sum of the primary diagonal elements of a given square matrix. :param matrix: A two-dimensional list representing a square matrix of integers. :return: The sum of the primary diagonal elements. :raises ValueError: If the matrix is not square. :raises TypeError: If the matrix is not a list of lists of integers. if not all(isinstance(row, list) for row in matrix): raise TypeError(\\"The matrix must be a list of lists of integers.\\") n = len(matrix) if not all(len(row) == n for row in matrix): raise ValueError(\\"The provided matrix is not a square matrix.\\") if not all(isinstance(item, int) for row in matrix for item in row): raise TypeError(\\"The matrix must be a list of lists of integers.\\") return sum(matrix[i][i] for i in range(n))"},{"question":"# Problem Statement You are tasked with implementing a function that takes two strings and finds the first non-repeated character in each string. If a string doesn\'t have any non-repeated characters, the function should return `None` for that string. The function should return a tuple containing the first non-repeated characters of each input string. Function Signature ```python def find_first_non_repeated_chars(s1: str, s2: str) -> (str, str): pass ``` Parameters - `s1`: A string representing the first input string. - `s2`: A string representing the second input string. Returns - A tuple of two elements: 1. A string representing the first non-repeated character in `s1`, or `None` if there isn\'t one. 2. A string representing the first non-repeated character in `s2`, or `None` if there isn\'t one. Constraints - The length of strings `s1` and `s2` will not exceed 100. Example ```python >>> find_first_non_repeated_chars(\\"swiss\\", \\"programming\\") (\'w\', \'p\') >>> find_first_non_repeated_chars(\\"aabbcc\\", \\"xxyyzz\\") (None, None) >>> find_first_non_repeated_chars(\\"hello\\", \\"world\\") (\'h\', \'w\') ``` # Additional Context Identifying non-repeated characters in strings is a common problem in text processing, particularly in areas such as language parsing, coding theorems, and character frequency analysis. Your implementation should be efficient, preferably with a linear time complexity O(n) where n is the length of the longer string. Consider edge cases such as strings with all repeated characters or very short strings. Ensure your function handles these scenarios gracefully.","solution":"def find_first_non_repeated_chars(s1: str, s2: str) -> (str, str): Returns a tuple containing the first non-repeated character in each input string, or None if there isn\'t one. def first_non_repeated_char(s: str) -> str: char_count = {} # Count occurrence of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeated character for char in s: if char_count[char] == 1: return char return None return (first_non_repeated_char(s1), first_non_repeated_char(s2))"},{"question":"# Sorting and Searching in a 2D Matrix In this task, you are required to implement functions to search and sort within a 2D matrix. Part 1: Searching in a Sorted 2D Matrix Implement a function `search_sorted_matrix` that searches for a given element in a matrix that is sorted such that each row is sorted in ascending order from left to right, and the first integer of each row is greater than the last integer of the previous row. The function should return a boolean indicating whether the element is found. Part 2: Sorting a 2D Matrix Implement a function `sort_2d_matrix` that takes an unsorted 2D matrix and returns a matrix where each row and each column is sorted in ascending order. Function Signatures ```python def search_sorted_matrix(matrix: List[List[int]], target: int) -> bool: Searches for a target element in a 2D matrix sorted in ascending order. Parameters: matrix (List[List[int]]): The sorted 2D matrix. target (int): The element to search for. Returns: bool: True if the element is found, False otherwise. pass def sort_2d_matrix(matrix: List[List[int]]) -> List[List[int]]: Sorts a given 2D matrix such that each row and each column is sorted in ascending order. Parameters: matrix (List[List[int]]): The 2D matrix to sort. Returns: List[List[int]]: The sorted 2D matrix. pass ``` # Constraints * The matrix is guaranteed to be non-empty. * Elements in the matrix are integers. * The input matrix for `sort_2d_matrix` can be of any shape. # Example ```python matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] print(search_sorted_matrix(matrix, 9)) # Output: True print(search_sorted_matrix(matrix, 4)) # Output: False unsorted_matrix = [ [3, 1, 4], [9, 2, 8], [7, 6, 5] ] print(sort_2d_matrix(unsorted_matrix)) # Output: [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] ``` # Requirements 1. Ensure the `search_sorted_matrix` function has an average time complexity better than O(n*m) where n is the number of rows and m is the number of columns in the matrix. 2. The `sort_2d_matrix` function should return a new matrix, not modify the input matrix. 3. Include error handling for invalid inputs such as non-integer elements in the matrix.","solution":"def search_sorted_matrix(matrix, target): Searches for a target element in a 2D matrix sorted in ascending order. Parameters: matrix (List[List[int]]): The sorted 2D matrix. target (int): The element to search for. Returns: bool: True if the element is found, False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) left, right = 0, rows * cols - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // cols][mid % cols] if mid_value == target: return True elif mid_value < target: left = mid + 1 else: right = mid - 1 return False def sort_2d_matrix(matrix): Sorts a given 2D matrix such that each row and each column is sorted in ascending order. Parameters: matrix (List[List[int]]): The 2D matrix to sort. Returns: List[List[int]]: The sorted 2D matrix. if not matrix or not matrix[0]: return [] flat_list = [item for sublist in matrix for item in sublist] flat_list.sort() rows, cols = len(matrix), len(matrix[0]) sorted_matrix = [] for r in range(rows): row = [flat_list[r * cols + c] for c in range(cols)] sorted_matrix.append(row) return sorted_matrix"},{"question":"# Coding Assessment Question Scenario: You are tasked with developing a function to determine the optimal order in which a set of tasks should be performed. Each task has dependencies on other tasks and must be completed in a sequence that respects these dependencies. This is a classic example of topological sorting in a directed acyclic graph (DAG). Task: Write a function named `find_task_order` that takes a list of tasks and their dependencies and returns a list representing the optimal order in which the tasks should be executed. Function Signature: ```python def find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Determine the optimal order of tasks based on their dependencies using topological sorting. Parameters: tasks (List[str]): A list of all tasks. dependencies (List[Tuple[str, str]]): A list of dependencies where each tuple (A, B) indicates that task A must be completed before task B can start. Returns: List[str]: A list of tasks in the order they should be executed. ``` Constraints: - Each task is represented as a unique string. - Dependencies are represented as tuples of two strings. - There are no cyclic dependencies (the graph is a DAG). Example Usage: 1. Define a set of tasks and their dependencies: ```python tasks = [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] dependencies = [(\'a\', \'d\'), (\'f\', \'b\'), (\'b\', \'d\'), (\'f\', \'a\'), (\'d\', \'c\')] ``` 2. Determine the order in which the tasks should be executed: ```python order = find_task_order(tasks, dependencies) print(order) # Output could be [\'f\', \'e\', \'a\', \'b\', \'d\', \'c\'] ``` This output indicates that task \'f\' should be performed first, followed by \'e\', and so on, ensuring all dependencies are respected. Testing: - Ensure that the function handles empty task lists and dependency lists. - Validate the handling of complex dependencies with multiple tasks depending on a single task. - Test the function with different valid DAGs to ensure correct topological sorting. - Raise appropriate errors or return an empty list if no valid task order exists due to invalid input (e.g., cyclic dependencies).","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_task_order(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: Determine the optimal order of tasks based on their dependencies using topological sorting. Parameters: tasks (List[str]): A list of all tasks. dependencies (List[Tuple[str, str]]): A list of dependencies where each tuple (A, B) indicates that task A must be completed before task B can start. Returns: List[str]: A list of tasks in the order they should be executed. # Initialize graph and in-degree dictionary graph = defaultdict(list) in_degree = {task: 0 for task in tasks} # Build graph and fill in-degrees for pre, post in dependencies: graph[pre].append(post) in_degree[post] += 1 # Queue for tasks with no incoming edges (in-degree 0) queue = deque([task for task in tasks if in_degree[task] == 0]) order = [] # Process the queue while queue: current_task = queue.popleft() order.append(current_task) # Decrement in-degree of neighbors for neighbor in graph[current_task]: in_degree[neighbor] -= 1 # If in-degree becomes 0, add to queue if in_degree[neighbor] == 0: queue.append(neighbor) # Check if topological sort is possible (no cycle) if len(order) == len(tasks): return order else: raise ValueError(\\"No valid task order exists due to cyclic dependencies.\\")"},{"question":"# Problem Description You are required to enhance your knowledge and skills by implementing a simple event scheduling system. Your task is to create a basic event scheduler using a priority queue data structure, where each event is scheduled based on its priority and time of occurrence. # Objectives 1. Implement an `add_event` method to add events to the scheduler with a given priority and time. 2. Implement a `get_next_event` method to get the event with the highest priority and the earliest time if priorities are the same. 3. Ensure the scheduler efficiently handles removal of past events after being checked or retrieved. # Requirements Part 1: `add_event` * **Function Signature**: `def add_event(self, event_name: str, priority: int, timestamp: int) -> None:` * **Inputs**: - A string `event_name` representing the name of the event. - An integer `priority` representing the priority of the event (higher numbers indicate higher priority). - An integer `timestamp` representing the time of occurrence of the event in UNIX format. * **Outputs**: None * **Constraints**: - The event name will be a non-empty string. - Priority and timestamp will be integers. Part 2: `get_next_event` * **Function Signature**: `def get_next_event(self) -> str:` * **Inputs**: None * **Outputs**: - The name of the next event based on the highest priority and earliest timestamp. - If no events are scheduled, return a string \\"No events scheduled\\". Part 3: Event Removal - When `get_next_event` is called, the retrieved event should be removed from the scheduler. - Ensure that past events (events with a timestamp earlier than the current time) are ignored or removed when retrieving the next event. # Input and Output Format ```python # Example for Part 1 scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 3, 1700000000) scheduler.add_event(\\"Lunch\\", 2, 1700003600) # Example for Part 2 scheduler.add_event(\\"Code Review\\", 5, 1700007200) print(scheduler.get_next_event()) # Output should be \\"Code Review\\" # Example for Part 3 scheduler.add_event(\\"Breakfast\\", 1, 1699996400) print(scheduler.get_next_event()) # Output should be \\"Meeting\\" (assuming current time > 1699996400 and other events are in future) ``` Performance and Constraints - Ensure that the operations with the scheduler are efficient, optimizing for priority queue manipulations. - Handle edge cases such as multiple events having the same priority and timestamp. # Function Details 1. `add_event(self, event_name: str, priority: int, timestamp: int) -> None` 2. `get_next_event(self) -> str` 3. Other necessary functions to ensure event removal of past events and maintaining priority order. # Scenario Imagine you are building a meeting scheduler system for a team where meetings need to be efficiently scheduled and prioritized based on their importance. By implementing a priority queue to manage these meetings, the scheduler will ensure high-priority meetings are attended to first, and redundant or past meetings are removed from the schedule to keep the team focused and on track. ---","solution":"import heapq import time class EventScheduler: def __init__(self): self.events = [] def add_event(self, event_name, priority, timestamp): # Using negative priority because heapq is a min-heap, but we need max-heap functionality heapq.heappush(self.events, (-priority, timestamp, event_name)) def get_next_event(self): current_time = int(time.time()) while self.events: priority, timestamp, event_name = heapq.heappop(self.events) if timestamp >= current_time: return event_name return \\"No events scheduled\\""},{"question":"# Coding Assessment Question Matrix Chain Multiplication Optimization You need to optimize the implementation of the Matrix Chain Multiplication algorithm. The goal is to find the most efficient way to multiply a given chain of matrices. Task 1. Implement a method `matrix_chain_order` that calculates the minimum number of scalar multiplications needed to multiply the entire chain. 2. Modify the `parenthesization` function to return the optimal order of matrix multiplications. Additional Guidelines - **Dynamic Programming Approach**: - Use dynamic programming to store the results of subproblems to avoid redundant calculations. - Store the minimum cost and the position of the split point in separate tables. Function Signatures and Expected Behavioral Outline ```python class MatrixChainMultiplication: def matrix_chain_order(self, dims): # Implement the matrix chain order calculation with dynamic programming pass def parenthesization(self): # Implement the function to return the optimal parenthesization of matrix multiplications pass ``` Input Examples and Output Expectations ```python # Dimensions of the matrices dims = [30, 35, 15, 5, 10, 20, 25] # Initialize and compute the matrix chain order mcm = MatrixChainMultiplication() min_cost = mcm.matrix_chain_order(dims) # Get the optimal order of multiplications optimal_order = mcm.parenthesization() print(\\"Minimum number of multiplications is\\", min_cost) print(\\"Optimal order of matrix multiplications is\\", optimal_order) ``` - **Constraints**: - The size of the `dims` list should be between 2 and 100. - All values in `dims` should be positive integers. - **Performance Requirements**: - Ensure the algorithm efficiently computes the minimum cost without redundant computations. - The solution should scale well with an increasing number of matrices. # Example Given dimensions `dims = [30, 35, 15, 5, 10, 20, 25]`, the expected output is: ``` Minimum number of multiplications is 15125 Optimal order of matrix multiplications is (((A1 x A2) x (A3 x A4)) x (A5 x A6)) ``` Where `A1` is a 30x35 matrix, `A2` is a 35x15 matrix, and so on. Evaluate the efficiency and correctness of your implementation by comparing the manually calculated results to those produced by the algorithm.","solution":"class MatrixChainMultiplication: def __init__(self): self.dp = None self.split = None def matrix_chain_order(self, dims): Computes the minimum multiplication cost for the matrix chain. :param dims: List of dimensions where the i-th matrix has dimensions dims[i-1] x dims[i] :return: Minimum number of scalar multiplications needed n = len(dims) - 1 self.dp = [[0 for _ in range(n)] for _ in range(n)] self.split = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 self.dp[i][j] = float(\'inf\') for k in range(i, j): q = self.dp[i][k] + self.dp[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1] if q < self.dp[i][j]: self.dp[i][j] = q self.split[i][j] = k return self.dp[0][n - 1] def parenthesization(self): Returns the optimal order of matrix multiplications. :return: Optimal order as a string return self._construct_optimal_order(0, len(self.dp) - 1) def _construct_optimal_order(self, i, j): if i == j: return f\\"A{i+1}\\" else: k = self.split[i][j] left = self._construct_optimal_order(i, k) right = self._construct_optimal_order(k + 1, j) return f\\"({left} x {right})\\""},{"question":"# Code Assessment Question Context Data structures play a crucial role in software engineering and computer science. Recognizing specific patterns and implementing efficient algorithms to manipulate these structures are essential skills. This problem explores the concept of linked lists, a fundamental data structure. Problem Statement You are tasked with implementing a function to reverse a singly linked list in groups of `k` nodes. This problem assesses your understanding of linked list manipulation and recursive algorithms. Implement a function `reverse_k_group` that reverses a singly linked list in groups of `k` nodes. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: pass ``` Input - `head` (`ListNode`): The head node of a singly linked list. - `k` (`int`): The size of the groups to reverse. If `k` is 1, the list should remain unchanged. Output - Return the head node of the modified list after reversing the nodes in groups of `k`. Constraints - The number of nodes in the list is in the range `[0, 5000]`. - `0 <= Node.val <= 1000` - `1 <= k <= 5000` Examples ```python # Example 1: # Linked List: 1 -> 2 -> 3 -> 4 -> 5 # k = 2 # Output: 2 -> 1 -> 4 -> 3 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 2 result_head = reverse_k_group(head, k) # Expected linked list after function call: 2 -> 1 -> 4 -> 3 -> 5 # Example 2: # Linked List: 1 -> 2 -> 3 -> 4 -> 5 # k = 3 # Output: 3 -> 2 -> 1 -> 4 -> 5 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) k = 3 result_head = reverse_k_group(head, k) # Expected linked list after function call: 3 -> 2 -> 1 -> 4 -> 5 ``` Note - The nodes that do not form a complete group should remain as they are. - Ensure that your implementation efficiently handles both small and large linked lists. By addressing this problem, you will demonstrate a solid understanding of linked list operations, including traversal, inversion, and recursive processing.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head: ListNode, k: int) -> ListNode: # Function to reverse a part of the linked list def reverse_linked_list(head, k): prev, curr = None, head while k > 0: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev # Check if we have k nodes available count = 0 node = head while count < k and node: node = node.next count += 1 # If we have k nodes, we reverse them if count == k: reversed_head = reverse_linked_list(head, k) # head is now the end of the reversed section # and we need to connect it to the next section head.next = reverse_k_group(node, k) return reversed_head return head"},{"question":"# Scenario In a large-scale software system, managing and processing logs are critical for monitoring and debugging. A common task involves parsing log records and extracting summary statistics for analysis. You are tasked to implement a log processing function to compute the average response time for each unique endpoint. # Problem Statement Write a function `compute_avg_response_time(logs: list) -> dict` that parses a list of log records and computes the average response time for each unique endpoint. # Input Format * `logs` is a list of strings where each string represents a log record in the format: `\\"endpoint,status,response_time\\"`. * `endpoint` is a string representing the endpoint URL. * `status` is a string which can be `\\"success\\"` or `\\"failure\\"`. * `response_time` is a float representing the time taken to get a response in milliseconds. # Output Format * Return a dictionary where the keys are the unique endpoints and the values are the average response time (float) for successful requests to that endpoint. # Constraints * 1 ≤ len(logs) ≤ 1000 * `status` will only be `\\"success\\"` or `\\"failure\\"`. * `response_time` is a non-negative float. # Performance Requirements * The solution should operate within O(n) time complexity, where n is the length of the logs list. # Example ```python >>> logs = [ ... \\"/api/data,success,120.5\\", ... \\"/api/data,success,135.0\\", ... \\"/api/data,failure,0\\", ... \\"/api/user,success,55.2\\", ... \\"/api/user,failure,0\\", ... \\"/api/data,success,100.8\\" ... ] >>> compute_avg_response_time(logs) {\'/api/data\': 118.76666666666667, \'/api/user\': 55.2} >>> logs = [ ... \\"/api/data,success,200.0\\", ... \\"/api/data,success,150.0\\", ... \\"/api/user,success,100.0\\" ... ] >>> compute_avg_response_time(logs) {\'/api/data\': 175.0, \'/api/user\': 100.0} >>> logs = [ ... \\"/api/test,success,90.0\\", ... \\"/api/test,failure,0\\", ... \\"/api/test,success,120.0\\", ... \\"/api/test,failure,0\\" ... ] >>> compute_avg_response_time(logs) {\'/api/test\': 105.0} ``` # Notes * Ensure that only successful requests contribute to the average response time calculation. * Your implementation should handle cases where there are no logs for the given endpoints or when there are no successful responses. * Make sure to validate the input format and handle any errors appropriately while parsing the log records.","solution":"def compute_avg_response_time(logs): Computes the average response time per endpoint for successful requests. endpoint_stats = {} for log in logs: try: endpoint, status, response_time = log.split(\',\') response_time = float(response_time) if status == \\"success\\": if endpoint not in endpoint_stats: endpoint_stats[endpoint] = {\\"total_time\\": 0, \\"count\\": 0} endpoint_stats[endpoint][\\"total_time\\"] += response_time endpoint_stats[endpoint][\\"count\\"] += 1 except ValueError: # Skip any malformed logs continue avg_response_times = {} for endpoint, stats in endpoint_stats.items(): if stats[\\"count\\"] > 0: avg_response_times[endpoint] = stats[\\"total_time\\"] / stats[\\"count\\"] return avg_response_times"},{"question":"# Question You have been tasked with implementing a Symbol Table using a Hash Table with Quadratic Probing for collision resolution. Your goal is to create a class, `SymbolTable`, that supports insertion, searching, and deletion of symbols (unique strings). Class Definition ```python class SymbolTable: def __init__(self, size: int): pass def hash_function(self, key: str) -> int: pass def insert(self, key: str) -> bool: pass def search(self, key: str) -> bool: pass def remove(self, key: str) -> bool: pass ``` Methods * `__init__(self, size: int)`: Initializes the symbol table with a given size. * `hash_function(self, key: str) -> int`: Computes the hash value for the given key (string). * `insert(self, key: str) -> bool`: Inserts the key into the symbol table. Returns `True` if the insertion is successful, `False` if the table is full or the key already exists. * `search(self, key: str) -> bool`: Searches for the key in the symbol table. Returns `True` if found, otherwise `False`. * `remove(self, key: str) -> bool`: Removes the key from the symbol table. Returns `True` if the removal is successful, `False` if the key does not exist. Description 1. Use a hash function to map symbols to key indexes. 2. Handle collisions using quadratic probing, i.e., if index `i` is occupied, try `(i + 1^2) % size`, then `(i + 2^2) % size`, etc. 3. Ensure insertions handle the table being full and detecting duplicate keys. 4. The search method should efficiently find the key, using the same probing sequence as insertion. 5. The remove method should clear the key from the table without disrupting the probing sequence for other keys. Example ```python st = SymbolTable(11) # Initialize symbol table with size 11 print(st.insert(\\"apple\\")) # True print(st.insert(\\"banana\\")) # True print(st.search(\\"apple\\")) # True print(st.remove(\\"apple\\")) # True print(st.search(\\"apple\\")) # False print(st.insert(\\"banana\\")) # False, as \\"banana\\" already exists print(st.remove(\\"grape\\")) # False, as \\"grape\\" does not exist ``` This example initializes a `SymbolTable` with size 11, inserts \\"apple\\" and \\"banana\\", searches for \\"apple\\", removes \\"apple\\", and checks that \\"apple\\" is no longer present. Inserting \\"banana\\" again returns `False` as it already exists, and removing \\"grape\\" returns `False` as it does not exist.","solution":"class SymbolTable: def __init__(self, size: int): self.size = size self.table = [None] * size self.deleted = object() # Special marker for deleted items def hash_function(self, key: str) -> int: Computes the hash value for the given key using a simple additive hash function. return sum(ord(c) for c in key) % self.size def insert(self, key: str) -> bool: Inserts the key into the symbol table. Returns True if the insertion is successful, otherwise returns False if the table is full or the key already exists. index = self.hash_function(key) for i in range(self.size): probe_index = (index + i * i) % self.size if self.table[probe_index] is None or self.table[probe_index] is self.deleted: self.table[probe_index] = key return True elif self.table[probe_index] == key: return False return False def search(self, key: str) -> bool: Searches for the key in the symbol table. Returns True if found, otherwise False. index = self.hash_function(key) for i in range(self.size): probe_index = (index + i * i) % self.size if self.table[probe_index] is None: return False elif self.table[probe_index] == key: return True return False def remove(self, key: str) -> bool: Removes the key from the symbol table. Returns True if the removal is successful, otherwise False if the key does not exist. index = self.hash_function(key) for i in range(self.size): probe_index = (index + i * i) % self.size if self.table[probe_index] is None: return False elif self.table[probe_index] == key: self.table[probe_index] = self.deleted return True return False"},{"question":"# Question: Meeting Room Scheduler You are tasked with implementing a `MeetingRoomScheduler` class that manages the scheduling of meeting rooms. Each room can only accommodate one meeting at a time, and you need to check if a new meeting can fit into the schedule without overlapping any existing meetings. # Class Specification Implement the class `MeetingRoomScheduler` with the following methods: 1. **`__init__(self)`** - **Description**: Initializes the `MeetingRoomScheduler` object with no meetings scheduled. - **Input**: None - **Output**: None 2. **`book(self, start: int, end: int) -> bool`** - **Description**: Tries to book a meeting room for a new meeting starting at `start` and ending at `end`. - **Input**: - `start` (int) – The start time of the meeting. - `end` (int) – The end time of the meeting. - **Output**: Returns `True` if the meeting can be booked without overlapping any existing meetings, otherwise returns `False`. # Constraints - Meetings are defined by a start time and an end time (inclusive). - Start and end times are integers within the range [0, 10^4]. - A meeting [start, end] is valid only if `start < end`. - The `book` method will be called at least once. # Example Usage ```python scheduler = MeetingRoomScheduler() print(scheduler.book(10, 20)) # Output: True print(scheduler.book(15, 25)) # Output: False print(scheduler.book(20, 30)) # Output: True ``` # Notes - Ensure your solution efficiently checks for overlapping meetings. - Consider edge cases such as when there are no meetings scheduled initially. - Optimize for both time and space complexity.","solution":"class MeetingRoomScheduler: def __init__(self): self.schedule = [] def book(self, start: int, end: int) -> bool: if start >= end: return False for s, e in self.schedule: if not (end <= s or start >= e): return False self.schedule.append((start, end)) return True"},{"question":"# Matrix Column Sum Finder Many applications in data processing and analytics involve operations on matrices. One common operation is summing the elements of a particular column in a matrix. **Task**: Your task is to write a function that computes the sum of all the elements in a specified column of a given matrix. You should implement the following function: ```python def column_sum(matrix: List[List[int]], column_index: int) -> int: ``` **Input**: - `matrix`: A list of lists of integers representing the matrix. Each inner list is a row of the matrix. - `column_index`: An integer index representing the column for which the sum needs to be calculated. **Output**: - Return the sum of the elements in the specified column. **Constraints**: - The matrix will have between 1 and 10^3 rows. - Each row will have between 1 and 10^3 columns. - The `column_index` will be valid, i.e., 0 ≤ column_index < number of columns in the matrix. - The matrix elements are integers between -10^3 and 10^3. **Example**: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> column_sum(matrix, 1) 15 >>> column_sum([[1], [2], [3]], 0) 6 >>> column_sum([[0, 1], [1, 2], [2, 3]], 0) 3 ``` # Performance Requirements: - Your implementation should efficiently handle the largest allowable input sizes.","solution":"from typing import List def column_sum(matrix: List[List[int]], column_index: int) -> int: Computes the sum of all the elements in a specified column of a given matrix. Args: matrix (List[List[int]]): The matrix as a list of lists of integers. column_index (int): The column index for which the sum needs to be calculated. Returns: int: The sum of the elements in the specified column. return sum(row[column_index] for row in matrix)"},{"question":"# Problem Statement Given an integer `n`, implement the function `find_petals(n: int) -> int` that determines the number of petals on the last flower according to the rule that the number of petals on each flower grows exponentially with each step. The petal count for the flowers follows this pattern: 1. Flower 1: 1 petal 2. Flower 2: 2 petals 3. Flower 3: 4 petals 4. Flower 4: 8 petals 5. Flower 5: 16 petals ...and so on. Input * `n` (int): the position of the flower in the sequence. ( n ) ranges from ( 1 ) to ( 50 ). Output * The function should return an integer representing the number of petals on the n-th flower. Example ```python >>> find_petals(1) 1 >>> find_petals(4) 8 >>> find_petals(10) 512 >>> find_petals(20) 524288 ``` # Constraints * ( 1 leq n leq 50 ) * The result may be a large number but will fit within Python\'s integer type. # Requirements * The function should execute in constant time, i.e., O(1). * Avoid the use of loops or recursion in your solution. * Use efficient mathematical operations to calculate the result.","solution":"def find_petals(n: int) -> int: Returns the number of petals on the n-th flower. Petal count grows exponentially: 1, 2, 4, 8, 16, etc. The formula for the petals on the n-th flower is 2^(n-1). return 2**(n-1)"},{"question":"# Task: Weather Data Fetcher Scenario As a software developer, you are working on a travel application that provides users with weather updates for their destinations. Your task is to create a function that retrieves the current temperature for a given city using OpenWeatherMap\'s API. Construct a function `current_temperature(city: str) -> str` which, given a city name, returns the current temperature as a string. If the city name is invalid or the temperature cannot be retrieved, the function should return a message indicating the failure. Input - `city` (str): A valid city name (e.g., \\"London\\", \\"New York\\"). Output - Returns a string representing the current temperature in Celsius (e.g., \\"20°C\\"). - Returns an error message string if the city name is invalid or if the temperature cannot be found (e.g., \\"Invalid city name\\" or \\"Temperature not found\\"). Constraints - The function should complete within a reasonable time (consider a network timeout of 10 seconds). - Assume the `requests` library is available and you have an API key for OpenWeatherMap. Performance Requirements - The function should handle up to 100 temperature queries per minute without significant performance degradation. # Implementation Implement the function following these requirements and consider the described edge cases, performance bottlenecks, and potential error scenarios. Example ```python print(current_temperature(\\"London\\")) # Returns the current temperature as a string, e.g., \\"20°C\\" print(current_temperature(\\"INVALID\\")) # Returns an error message, e.g., \\"Invalid city name\\" ```","solution":"import requests API_KEY = \'your_api_key_here\' # Replace with your actual OpenWeatherMap API key def current_temperature(city: str) -> str: Returns the current temperature for a given city using OpenWeatherMap\'s API. Args: city (str): The name of the city. Returns: str: The current temperature in Celsius or an error message. url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={API_KEY}&units=metric\\" try: response = requests.get(url, timeout=10) data = response.json() if response.status_code != 200 or \'main\' not in data: return \\"Invalid city name or temperature not found\\" temperature = data[\'main\'][\'temp\'] return f\\"{temperature}°C\\" except requests.exceptions.RequestException: return \\"Error retrieving data\\""},{"question":"# Problem Statement You have been provided with a simple calculator class `SimpleCalculator` that can add, subtract, multiply, and divide two numbers. Your task is to extend this class by adding a new method that calculates the power of a number to another number. # Function Signature ```python class SimpleCalculator: ... def power(self, base: float, exponent: float) -> float: This method should return the base raised to the power of the exponent. ``` # Input & Output - **Input**: - The method receives two floating-point numbers, `base` and `exponent`. - **Output**: - The method should return a floating-point number which is the base raised to the power of the exponent. # Examples 1. **Example 1**: ```python sc = SimpleCalculator() print(sc.power(2, 3)) ``` **Output**: ``` 8.0 ``` 2. **Example 2**: ```python sc = SimpleCalculator() print(sc.power(5, -2)) ``` **Output**: ``` 0.04 ``` 3. **Example 3**: ```python sc = SimpleCalculator() print(sc.power(10, 0)) ``` **Output**: ``` 1.0 ``` 4. **Example 4**: ```python sc = SimpleCalculator() print(sc.power(3, 1)) ``` **Output**: ``` 3.0 ``` # Constraints - The base and exponent will be floating-point numbers such that -100 ≤ base ≤ 100 and -10 ≤ exponent ≤ 10. - The output of the power calculation should be accurate to within an error of 10^-6. # Notes - Make sure to handle cases where the exponent is zero, which should return 1. - Take into account negative exponents, which should return a fractional result. Implement the `power` method in the `SimpleCalculator` class.","solution":"class SimpleCalculator: # The power method is defined to calculate base raised to the power of exponent def power(self, base: float, exponent: float) -> float: return base ** exponent"},{"question":"# Coding Assessment Question Context You are working on a project that involves analyzing sequences of integers. One common operation is to determine the longest subsequence within a list where the difference between every two adjacent elements is constant. This functionality is crucial for identifying linear patterns in data sequences. Objective Write a function `longest_arithmetic_subsequence(numbers: list[int]) -> int` that finds the length of the longest arithmetic subsequence within the given list of integers. An arithmetic subsequence is a sequence where the difference between consecutive elements is the same. Input and Output - **Input**: A list of integers `numbers`. - **Output**: An integer representing the length of the longest arithmetic subsequence. Constraints - The length of `numbers` will be between 0 and 1000 inclusive. - The elements of `numbers` can range from -10,000 to 10,000 inclusive. Performance Requirements - Aim for an efficient solution with a time complexity of O(n^2). - Ensure your solution handles edge cases such as empty arrays and arrays with all elements being the same. Example ```python def longest_arithmetic_subsequence(numbers: list[int]) -> int: Find the length of the longest arithmetic subsequence. Args: - numbers (list[int]): List of integers. Returns: - int: Length of the longest arithmetic subsequence. pass # Your implementation goes here # Example Usage numbers = [3, 6, 9, 12] print(longest_arithmetic_subsequence(numbers)) # Output: 4 numbers = [1, 3, 5, 7, 9, 11, 13] print(longest_arithmetic_subsequence(numbers)) # Output: 7 numbers = [10, 5, 2, 1, -3, -6, -8] print(longest_arithmetic_subsequence(numbers)) # Output: 3 ``` Notes - Ensure your implementation is robust and optimally handles different edge cases. - Consider using dynamic programming techniques for constructing the solution efficiently.","solution":"def longest_arithmetic_subsequence(numbers: list[int]) -> int: Find the length of the longest arithmetic subsequence. Args: - numbers (list[int]): List of integers. Returns: - int: Length of the longest arithmetic subsequence. if not numbers: return 0 n = len(numbers) subseq_lengths = [{} for _ in range(n)] max_length = 1 for i in range(n): for j in range(i): diff = numbers[i] - numbers[j] if diff in subseq_lengths[j]: subseq_lengths[i][diff] = subseq_lengths[j][diff] + 1 else: subseq_lengths[i][diff] = 2 max_length = max(max_length, subseq_lengths[i][diff]) return max_length"},{"question":"# Problem Statement You are tasked with implementing a function that generates and returns all possible letter combinations that a given digit string could represent on a classic T9 keypad of old mobile phones. Each digit (excluding 0 and 1) maps to a set of letters. # Requirements: 1. The function should accept a digit string and return a list of all possible letter combinations. 2. The function should handle digits from 2 to 9 inclusively, as they map to the corresponding letters: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" 3. The function should return an empty list if the input string is empty. 4. The order of the combinations in the resulting list does not matter. # Implementation Details: * **Input Format**: A string representing the digit sequence, with each character being a digit from \'2\' to \'9\'. * **Output Format**: A list of strings, each representing a possible letter combination for the input digits. # Constraints: - The input digit string will have a maximum length of 4 characters. # Examples: ```python def letter_combinations(digits: str) -> List[str]: Generates all possible letter combinations from a given digit string according to T9 keypad mappings. Args: digits: str - Input digit string Returns: List[str] - List of all possible letter combinations Examples: >>> letter_combinations(\'23\') [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] >>> letter_combinations(\'\') [] >>> letter_combinations(\'9\') [\'w\', \'x\', \'y\', \'z\'] >>> letter_combinations(\'835\') [\'tdj\', \'tdk\', \'tdl\', \'tej\', \'tek\', \'tel\', \'tfj\', \'tfk\', \'tfl\', \'udj\', \'udk\', \'udl\', \'uej\', \'uek\', \'uel\', \'ufj\', \'ufk\', \'ufl\', \'vdj\', \'vdk\', \'vdl\', \'vej\', \'vek\', \'vel\', \'vfj\', \'vfk\', \'vfl\'] # Your code here # Example usage input_digits = \'23\' print(letter_combinations(input_digits)) # Should return [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] ``` Write the `letter_combinations` function according to the outlined requirements and ensure it passes all provided examples and edge cases.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Generates all possible letter combinations from a given digit string according to T9 keypad mappings. Args: digits: str - Input digit string Returns: List[str] - List of all possible letter combinations if not digits: return [] # Mapping of digits to their corresponding letters on a T9 keypad digit_to_letters = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } # Helper function for backtracking through the combinations def backtrack(index: int, path: str): if index == len(digits): combinations.append(path) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \'\') return combinations"},{"question":"# In-Place Bucket Sort Implementation Task **Objective:** You are required to implement the Bucket Sorting algorithm to sort an array of floating-point numbers. The function should handle the cases where numbers span across various ranges and ensure the list is sorted correctly without using extra space beyond what is necessary for the buckets themselves. **Function Signature:** ```python def bucket_sort(arr: List[float]) -> None: ``` The function should sort the list `arr` in place. **Input:** - `arr`: A list of floating-point numbers `arr` of size `n` where (1 leq n leq 10^6). **Output:** - The list `arr` should be sorted in ascending order, modifying the list in place. **Example:** ```python arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] bucket_sort(arr) print(arr) # Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` **Constraints:** - The elements in `arr` are floating-point numbers between 0 and 1 (inclusive). **Performance Requirements:** - The function should run efficiently for arrays up to size `10^6`. **Notes:** - You may assume all elements in the array are floating-point numbers within the specified range. - Ensure that the algorithm uses minimal extra space and is appropriately optimized for the input range. **Additional Guidance:** - Consider how to efficiently assign elements to buckets based on their value. - Document any edge cases and thoroughly test your function against them, such as when some buckets remain empty or when elements are already sorted.","solution":"from typing import List def bucket_sort(arr: List[float]) -> None: Perform bucket sort on a list of floats [0, 1) in place. if not arr: return bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Put array elements into different buckets for num in arr: index = int(num * bucket_count) buckets[index].append(num) # Sort individual buckets and concatenate arr.clear() for bucket in buckets: arr.extend(sorted(bucket))"},{"question":"# Coding Assessment Question: Path Sum with Obstacles Background: You are given a grid with (m) rows and (n) columns. Each cell in the grid can contain a value 0, indicating it is an empty cell, or 1, indicating it is an obstacle. You start at the top-left corner of the grid (cell (0,0)) and you want to move to the bottom-right corner of the grid (cell (m-1, n-1)). You can only move either down or right at any point in time. Your task is to determine the number of unique paths from the top-left corner to the bottom-right corner. # Function Signature ```python def unique_paths_with_obstacles(grid: List[List[int]]) -> int: pass ``` # Input - `grid` (List[List[int]]): A 2D list of integers representing the grid. # Output - An integer representing the number of unique paths from the top-left to the bottom-right corner of the grid. # Constraints - (m, n leq 100) - The grid will always have at least one element (i.e., (1 leq m leq 100) and (1 leq n leq 100)). - The top-left corner (cell (0,0)) and the bottom-right corner (cell (m-1, n-1)) will never be obstacles. # Example ```python def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles([[0,0,0],[0,1,0],[0,0,0]]) == 2, \\"Test case 1 failed\\" assert unique_paths_with_obstacles([[0,1],[0,0]]) == 1, \\"Test case 2 failed\\" assert unique_paths_with_obstacles([[0,0],[1,0]]) == 1, \\"Test case 3 failed\\" assert unique_paths_with_obstacles([[0,1],[1,0]]) == 0, \\"Test case 4 failed\\" print(\\"All test cases pass\\") ``` # Notes - Use dynamic programming to keep track of the number of paths to each cell. - If a cell has value 1 (obstacle), the number of paths to that cell is 0. - Initialize the first row and the first column of the grid considering the obstacles. - Iterate through the grid and update the number of paths for each cell based on the number of paths to the cells directly above and to the left of it. The new question addresses grid traversal, dynamic programming, and path counting, aligning closely with the complexity and domain of the given examples.","solution":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Initialize DP table dp = [[0 for _ in range(n)] for _ in range(m)] # Start position dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] if grid[i][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] if grid[0][j] == 0 else 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1]"},{"question":"# Problem: Matrix Transposition You are working with two-dimensional matrices and need to implement a function to transpose a given matrix. Transposition is a process of swapping the rows and columns of a matrix. Implement the following function to perform the transposition of a given matrix: Function: `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` Transposes the given two-dimensional matrix. **Parameters**: * `matrix`: A list of lists where each sub-list represents a row in the matrix and contains integers. **Returns**: * A list of lists representing the transposed matrix. Constraints: * The input matrix will be non-empty. * The matrix can have any number of rows and columns. * Elements in the matrix are integers. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6] ] transposed_matrix = transpose_matrix(matrix) print(transposed_matrix) # Expected Output: # [ # [1, 4], # [2, 5], # [3, 6] # ] ``` Consider edge cases, such as: * Matrix with only one row * Matrix with only one column * Square matrix * Large matrix with various dimensions # Performance Requirements: * Implement the function to run in O(m * n) time, where m is the number of rows and n is the number of columns in the matrix. # Notes: - The function should not modify the input matrix. - Use appropriate list comprehension or nested loops to achieve the required transposition. # Implementation: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] ```","solution":"def transpose_matrix(matrix): Transposes the given two-dimensional matrix. Parameters: matrix (list of list of int): The input 2D matrix. Returns: list of list of int: The transposed matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Question: Finding the Minimum Number of Platforms Required You are given the arrival and departure times of trains at a railway station. Your task is to write a function to calculate the minimum number of platforms required such that no train waits. Each train is represented by its arrival and departure times. **Function Signature:** ```python def min_platforms(arr: list[str], dep: list[str]) -> int: pass ``` **Input:** * `arr`: A list of strings representing the arrival times of trains in \\"HH:MM\\" format. * `dep`: A list of strings representing the departure times of trains in \\"HH:MM\\" format. The length of `dep` is equal to the length of `arr`. **Output:** * Return an integer which is the minimum number of platforms required. **Constraints:** * The input lists `arr` and `dep` can have up to (10^4) elements. * The time format is a 24-hour format (e.g., \\"13:45\\" for 1:45 PM). * All times are in the same day. **Examples:** ```python assert min_platforms([\\"09:00\\", \\"09:40\\", \\"09:50\\", \\"11:00\\"], [\\"09:10\\", \\"12:00\\", \\"11:20\\", \\"11:30\\"]) == 3 assert min_platforms([\\"09:00\\", \\"09:20\\"], [\\"09:19\\", \\"09:21\\"]) == 1 assert min_platforms([\\"10:00\\", \\"10:05\\"], [\\"10:10\\", \\"10:15\\"]) == 2 assert min_platforms([], []) == 0 ``` **Explanation:** - In Example 1, at 09:50, the third train arrives but the first two trains are still at the platform, so we need a total of 3 platforms at that time. - In Example 2, there is never more than one train at the station simultaneously. - In Example 3, at 10:15, the second train arrives before the first one left, so we need 2 platforms during their overlap. - An empty input means no trains, so no platforms are needed. Note: Consider using an efficient algorithm to handle up to 10,000 trains in a reasonable time.","solution":"def min_platforms(arr: list[str], dep: list[str]) -> int: Calculate the minimum number of platforms required at a station such that no train waits. Parameters: arr (list of str): A list of strings representing the arrival times of trains in \\"HH:MM\\" format. dep (list of str): A list of strings representing the departure times of trains in \\"HH:MM\\" format. Returns: int: The minimum number of platforms required. if not arr or not dep or len(arr) != len(dep): return 0 # Convert times to minutes from midnight for easy comparison arr = [int(a[:2])*60 + int(a[3:]) for a in arr] dep = [int(d[:2])*60 + int(d[3:]) for d in dep] # Sort arrival and departure times arr.sort() dep.sort() # Initialize platform need and result platform_needed = 0 max_platforms = 0 # Pointers to track arrivals and departures i, j = 0, 0 n = len(arr) # Similar to merge process of merge sort while i < n and j < n: if arr[i] < dep[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"# Longest Increasing Subsequence - Stock Price Analysis You are working as a financial analyst and need to analyze the stock prices over a series of days. Your task is to determine the length of the longest increasing subsequence of stock prices. This will help to understand the maximum period during which the stock prices continuously increased. A subsequence is derived from the sequence by deleting some or none of the elements without changing the order of the remaining elements. Implement the function to find the length of the longest increasing subsequence in the input list of stock prices. Function Signature ```python def longest_increasing_subsequence(prices: List[int]) -> int: ``` Input - **prices**: A list of integers where each integer represents the stock price on a particular day. Output - Returns an integer representing the length of the longest increasing subsequence. Constraints - The length of the list (N) is between 1 and 1000. - The stock prices are non-negative integers not exceeding 10000. Example ```python prices = [3, 10, 2, 1, 20] assert longest_increasing_subsequence(prices) == 3 # The longest increasing subsequence is [3, 10, 20] prices = [3, 2, 10, 1, 20, 30] assert longest_increasing_subsequence(prices) == 4 # The longest increasing subsequence is [2, 10, 20, 30] prices = [6, 5, 4, 3, 2, 1] assert longest_increasing_subsequence(prices) == 1 # The longest increasing subsequence is [6] or any single element ``` Notes - Use dynamic programming to solve the problem efficiently. - Ensure that the solution handles edge cases where no increasing subsequence exists beyond individual elements. - Optimize your approach to ensure it runs in a reasonable time for the given constraints. Write the function `longest_increasing_subsequence` to implement the above functionality.","solution":"from typing import List def longest_increasing_subsequence(prices: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list of stock prices. if not prices: return 0 n = len(prices) dp = [1] * n for i in range(1, n): for j in range(i): if prices[i] > prices[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Coding Assessment Question Problem Statement Given a string `s` containing only digits, implement a function `restore_ip_addresses(s)` that returns all possible valid IP address combinations that can be formed from the given string. An IP address consists of four integers (each between 0 and 255) separated by points (\'.\'). The digits must be used in their original order, and each integer must not start with a 0 unless it is exactly \'0\'. Function Signature ```python def restore_ip_addresses(s: str) -> list: pass ``` Input - `s`: A string consisting only of digits. E.g., \'25525511135\' Output - A list of all possible valid IP address combinations formed from the string. E.g., [\'255.255.11.135\', \'255.255.111.35\'] Constraints - The length of the string: (1 leq text{len}(s) leq 20) Example ```python s = \\"25525511135\\" print(restore_ip_addresses(s)) # Output: [\\"255.255.11.135\\", \\"255.255.111.35\\"] s = \\"0000\\" print(restore_ip_addresses(s)) # Output: [\\"0.0.0.0\\"] s = \\"101023\\" print(restore_ip_addresses(s)) # Output: [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] ``` Notes - Consider using backtracking to explore all possible segmentations of the string into four parts. - An IP address is considered valid if each of the four integers ranges from 0 to 255, inclusive, and there are no leading zeros unless the integer itself is exactly \'0\'. - If a segment contains more than one digit, it should not start with \'0\'.","solution":"def restore_ip_addresses(s: str) -> list: def is_valid(segment): Check if the segment is a valid part of an IP address. # Segment must be between 0 and 255 and must not have leading zeros return segment == \\"0\\" or (segment[0] != \\"0\\" and 0 < int(segment) <= 255) def backtrack(start=0, parts=[]): Use backtracking to find all valid IP address splits. # If we have 4 parts and are at the end of the string, it\'s a valid IP address if len(parts) == 4 and start == len(s): result.append(\'.\'.join(parts)) return # If we have 4 parts but are not at the end of the string, it\'s invalid if len(parts) == 4: return # Try to split the remaining string into parts for end in range(start + 1, min(start + 4, len(s) + 1)): segment = s[start:end] if is_valid(segment): backtrack(end, parts + [segment]) result = [] backtrack() return result"},{"question":"# Coding Assessment Question **Context**: You are working on a program that needs to filter out strings based on specific patterns. You have a list of strings and a list of patterns defined by regular expressions. Your task is to implement a function that filters out the strings that do not match any of the provided patterns. Write a Python function `filter_strings_by_patterns(strings: List[str], patterns: List[str]) -> List[str]` that takes a list of strings and a list of patterns and returns a new list of strings that match at least one of the patterns. **Function Signature**: ```python def filter_strings_by_patterns(strings: List[str], patterns: List[str]) -> List[str]: ``` **Input**: 1. `strings`: List of strings, the list of strings to filter. 2. `patterns`: List of strings, the list of regular expression patterns to match the strings against. **Output**: - Return a list of strings that match at least one of the provided patterns. **Constraints**: - The list `strings` may contain up to 1000 strings. - Each string can be up to 100 characters long. - The list `patterns` will contain between 1 and 50 regular expression patterns. - Each pattern is a valid regular expression. **Example**: Given the inputs: ```python strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\", \\"fig\\", \\"grape\\"] patterns = [\\"^a.*e\\", \\"b.*a\\", \\"c.*y\\"] ``` Example usage: ```python result = filter_strings_by_patterns(strings, patterns) print(result) # Should return [\\"apple\\", \\"banana\\", \\"cherry\\"] ``` In the example, the function filters the input list of strings based on the patterns, resulting in the list `[\\"apple\\", \\"banana\\", \\"cherry\\"]` because only these strings match at least one of the given patterns. **Additional Instructions**: 1. Ensure that the function performs efficiently even with the upper limits of input sizes. 2. Handle potential errors with invalid regular expressions gracefully. 3. Consider edge cases where the input lists may be empty and handle them appropriately.","solution":"import re from typing import List def filter_strings_by_patterns(strings: List[str], patterns: List[str]) -> List[str]: Returns a list of strings that match at least one of the provided regular expression patterns. :param strings: List of strings to be filtered. :param patterns: List of regular expression patterns to match the strings against. :return: List of strings that match at least one of the provided patterns. compiled_patterns = [re.compile(pattern) for pattern in patterns] def matches_any_pattern(s: str) -> bool: return any(pattern.search(s) for pattern in compiled_patterns) return [s for s in strings if matches_any_pattern(s)]"},{"question":"# Problem Statement You are tasked with implementing a simple text-based game simulation where different actions lead to changes in the player\'s attributes. The game consists of a character who can perform various actions, and each action affects the character\'s health and energy levels. You are to simulate the sequence of actions and track the final state of the player. # Requirements 1. **Function Implementation**: Implement the function `simulate_game_actions(starting_health: int, starting_energy: int, actions: list[tuple[str, int, int]], num_actions: int) -> tuple[int, int]` to simulate the game. - **Parameters**: - `starting_health`: An `int` representing the initial health of the character. - `starting_energy`: An `int` representing the initial energy level of the character. - `actions`: A `list` of `tuple`s where each tuple consists of a `str` (action name), an `int` (health change), and an `int` (energy change). - `num_actions`: An `int` representing the number of actions to simulate. - **Return**: A `tuple` of two `int` values representing the final health and energy levels of the character after the simulation. 2. **Constraints**: - The health and energy levels cannot fall below 0. - Actions are chosen randomly from the provided `actions` list. - Ensure that meaningful game actions lead to diverse outcomes. 3. **Example**: ```python actions = [ (\'rest\', 10, 20), (\'work\', -5, -20), (\'exercise\', -10, -30), (\'eat\', 20, 5) ] result = simulate_game_actions(100, 100, actions, 50) print(result) # Output might look like (150, 50) ``` 4. **Edge Cases**: - Consider scenarios where the player only performs actions that decrease health or energy. - Actions with maximum health or energy boosts. # Hints - Use random selection to pick actions from the provided list. - Implement checks to ensure health and energy levels do not drop below zero. - Keep track of the current state after each action and apply changes accordingly.","solution":"import random def simulate_game_actions(starting_health, starting_energy, actions, num_actions): Simulates a sequence of actions on a game character and returns the final health and energy levels. Parameters: - starting_health (int): Initial health level. - starting_energy (int): Initial energy level. - actions (list of tuple): List of actions where each action is a tuple (name, health_change, energy_change). - num_actions (int): Number of actions to simulate. Returns: - tuple: Final health and energy levels as a tuple (final_health, final_energy). current_health = starting_health current_energy = starting_energy for _ in range(num_actions): action_name, health_change, energy_change = random.choice(actions) current_health = max(0, current_health + health_change) current_energy = max(0, current_energy + energy_change) return current_health, current_energy"},{"question":"# Question: Recursive Fibonacci Sequence Generation You need to write a Python function to generate the nth Fibonacci number using a recursive approach. The Fibonacci sequence is determined by the following recurrence relation: - `F(0) = 0` - `F(1) = 1` - And for `n >= 2, F(n) = F(n-1) + F(n-2)` Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input: - `n` (int): The position in the Fibonacci sequence. (0 ≤ n ≤ 30) Output: - An integer representing the nth Fibonacci number. Constraints: - The function must be implemented using recursion. - `n` is guaranteed to be a non-negative integer. Sample Execution: ```python print(fibonacci(0)) # Expected output: 0 print(fibonacci(1)) # Expected output: 1 print(fibonacci(5)) # Expected output: 5 print(fibonacci(10)) # Expected output: 55 print(fibonacci(20)) # Expected output: 6765 ``` Background: This exercise is designed to test your understanding of: - Recursion and the base and recursive cases. - Mathematical series and their implementation in programming. - Handling edge cases with recursion (e.g., very small values of `n`). Implementing the Fibonacci sequence recursively helps emphasize fundamental recursive concepts and their applications to classic algorithmic problems.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using a recursive approach. if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2)"},{"question":"**Database and SQL Task** # Problem Statement You have been provided with a database containing two tables: `Employees` and `Departments`. The `Employees` table contains various details about employees, including their ID, name, and department ID. The `Departments` table contains department IDs and the corresponding department names. Write an SQL query to retrieve the name of each employee, their corresponding department name, and their hire date, sorted by hire date in ascending order. If an employee does not belong to a department, include them in the results with a `NULL` value for the department name. # Tables - **Employees**: - `id` (INT): Primary key, unique identifier for each employee. - `name` (VARCHAR): The name of the employee. - `department_id` (INT): The ID of the department the employee belongs to. - `hire_date` (DATE): The date the employee was hired. - **Departments**: - `id` (INT): Primary key, unique identifier for each department. - `name` (VARCHAR): The name of the department. # Requirements 1. **Table Schema**: Assume the tables have the following schema definitions: ```sql CREATE TABLE Departments ( id INT PRIMARY KEY, name VARCHAR(100) NOT NULL ); CREATE TABLE Employees ( id INT PRIMARY KEY, name VARCHAR(100) NOT NULL, department_id INT, hire_date DATE, FOREIGN KEY (department_id) REFERENCES Departments(id) ); ``` 2. **SQL Query**: Write an SQL query to fetch the employee name, department name, and hire date. 3. **Output**: The query should return the result sorted by `hire_date` in ascending order. # Example Given the following data in the tables: **Employees** | id | name | department_id | hire_date | |----|--------|----------------|-----------| | 1 | Alice | 2 | 2021-01-15| | 2 | Bob | NULL | 2020-03-22| | 3 | Charlie| 1 | 2019-07-30| **Departments** | id | name | |----|---------------| | 1 | HR | | 2 | Engineering | The query would produce the following result: | name | department_name | hire_date | |---------|-----------------|-------------| | Charlie | HR | 2019-07-30 | | Bob | NULL | 2020-03-22 | | Alice | Engineering | 2021-01-15 | # SQL Query Template ```sql SELECT e.name, d.name AS department_name, e.hire_date FROM Employees e LEFT JOIN Departments d ON e.department_id = d.id ORDER BY e.hire_date; ``` # Notes - Ensure the query handles cases where the `department_id` may be `NULL`. - The result should always be sorted by `hire_date` in ascending order. - The solution should be optimized for performance, especially on large datasets. - Alias the department name column as `department_name` in the result set.","solution":"def get_employees_with_departments(): SQL query to return the name of each employee, their corresponding department name, and their hire date, sorted by hire date in ascending order. query = SELECT e.name, d.name AS department_name, e.hire_date FROM Employees e LEFT JOIN Departments d ON e.department_id = d.id ORDER BY e.hire_date; return query"},{"question":"**[Question 2]:** Given an integer ( n ), write a function `count_digit_divisors(n: int) -> int` that returns the count of digits in ( n ) that divide ( n ). # Input: * A single integer ( n ) with ( 1 leq n leq 10^9 ). # Output: * Single integer representing the count of digits in ( n ) that divide ( n ) without leaving a remainder. # Function Signature: ```python def count_digit_divisors(n: int) -> int: pass ``` # Example: ```python >>> count_digit_divisors(1012) 3 >>> count_digit_divisors(123) 2 >>> count_digit_divisors(111) 3 ``` # Note: * For ( n = 1012 ): - The digits are ( 1, 0, 1, 2 ). - Digits (1, 1,) and (2) divide ( 1012 ) without a remainder. However, (0) does not count as it cannot be a divisor. - Hence, the output is ( 3 ). * For ( n = 123 ): - The digits are (1, 2, 3). - Digits (1) and (3) divide ( 123 ) without a remainder. - Hence, the output is ( 2 ). * For ( n = 111 ): - The digits are (1, 1, 1). - Digits (1, 1,) and (1) divide (111) without a remainder. - Hence, the output is ( 3 ).","solution":"def count_digit_divisors(n: int) -> int: digit_str = str(n) count = 0 for digit_char in digit_str: digit = int(digit_char) if digit != 0 and n % digit == 0: count += 1 return count"},{"question":"# Context As part of a space exploration project, you have been assigned the task of developing software that calculates the escape velocity needed for a spacecraft to break free from a planet\'s gravitational pull. The escape velocity depends on the mass and the radius of the planet. # Task Implement a Python function called `compute_escape_velocity` that calculates the escape velocity of a spacecraft from a given planet. Your function should adhere to the following requirements: # Requirements * Define the function as `compute_escape_velocity(mass: float, radius: float) -> float`. * The function should return the escape velocity computed using the formula ( v_e = sqrt{frac{2GM}{R}} ), where ( G ) is the gravitational constant with a value of ( 6.67430 times 10^{-11} , text{m}^3 text{kg}^{-1} text{s}^{-2} ). * Your function should raise a `ValueError` if the `mass` or `radius` is less than or equal to zero, with an appropriate error message. * Assume that inputs will be of type `float`. # Example Usage ```python >>> compute_escape_velocity(5.97e24, 6.371e6) 11186.137055896647 >>> compute_escape_velocity(0, 6.371e6) Traceback (most recent call last): ... ValueError: Mass cannot be 0 or negative >>> compute_escape_velocity(5.97e24, 0) Traceback (most recent call last): ... ValueError: Radius cannot be 0 or negative ``` # Constraints * Mass and radius will be floating-point numbers. * Focus on the accuracy of the escape velocity calculation and correct error handling. * Optimize for clear and maintainable code. # Performance Requirements * The function must run in constant time, O(1), given the simplicity of operations involved. * Error messages should be descriptive and user-friendly, aiding in debugging and correctness validation.","solution":"import math def compute_escape_velocity(mass: float, radius: float) -> float: Calculate the escape velocity of a spacecraft from a given planet. Parameters: - mass: float, the mass of the planet in kilograms - radius: float, the radius of the planet in meters Returns: - float, the escape velocity in meters per second Raises: - ValueError: if mass <= 0 or radius <= 0 if mass <= 0: raise ValueError(\\"Mass cannot be 0 or negative\\") if radius <= 0: raise ValueError(\\"Radius cannot be 0 or negative\\") G = 6.67430e-11 # gravitational constant in m^3 kg^(-1) s^(-2) escape_velocity = math.sqrt((2 * G * mass) / radius) return escape_velocity"},{"question":"# Coding Assessment Question Scenario: You are developing a function for a social media platform to display a comment thread. Each comment can be a reply to another comment in the thread, thus forming a tree structure. You need to write a function that prints this tree in a readable, indented format where each level of replies is indented more than the previous level. Task: Implement a function `print_comment_thread(comments)` that prints a nested comment thread. The input `comments` is a list of dictionaries where each dictionary has the keys: `id`, `content`, and `replies`. The `id` is a unique identifier for the comment, `content` is the text of the comment, and `replies` is a list of dictionaries representing the replies to this comment, each with the same structure. Function Signature: ```python def print_comment_thread(comments: List[Dict[str, Union[int, str, List]]]) -> None: ``` Input: - `comments`: A list of dictionaries representing the comments and their replies. Output: - Prints the comments and their replies in a readable format. Constraints: - The `comments` list length can range from 1 to 50. - Each comment `id` is an integer and unique. - Each `content` is a non-empty string with a maximum length of 200 characters. - The nesting of replies can be up to 5 levels deep. Example: ```python comments = [ {\\"id\\": 1, \\"content\\": \\"First comment\\", \\"replies\\": [ {\\"id\\": 2, \\"content\\": \\"Reply to first comment\\", \\"replies\\": []}, {\\"id\\": 3, \\"content\\": \\"Another reply to first comment\\", \\"replies\\": [ {\\"id\\": 4, \\"content\\": \\"Nested reply\\", \\"replies\\": []} ]} ]}, {\\"id\\": 5, \\"content\\": \\"Second comment\\", \\"replies\\": []} ] print_comment_thread(comments) ``` # Expected Output: ``` 1: First comment 2: Reply to first comment 3: Another reply to first comment 4: Nested reply 5: Second comment ``` Notes: - Indent each level of replies with two spaces. - Do not return anything from the function, just print the output in the specified format. - Ensure your implementation handles edge cases, such as deeply nested replies.","solution":"from typing import List, Dict, Union def print_comment_thread(comments: List[Dict[str, Union[int, str, List]]], level: int = 0) -> None: Prints a nested comment thread in a readable, indented format where each level of replies is indented more than the previous level. Args: comments (List[Dict[str, Union[int, str, List]]]): List of comments to print. level (int): Current level of nesting, used for indentation (default is 0). for comment in comments: print(\\" \\" * level + f\\"{comment[\'id\']}: {comment[\'content\']}\\") if comment[\'replies\']: print_comment_thread(comment[\'replies\'], level + 1)"},{"question":"**Scenario**: You are given a string representing a sequence of characters. The goal is to determine the minimum number of changes needed to make the string a palindrome. A palindrome is a word that reads the same forwards and backwards. # Task Write a function `min_changes_to_palindrome(s: str) -> int` that takes a string `s` and returns the minimum number of character changes required to make `s` a palindrome. # Input * A string `s` where 1 <= `len(s)` <= 10^5 and `s` consists of lowercase English letters only. # Output * An integer representing the minimum number of character changes needed to make the string a palindrome. # Examples ```python >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"race\\") 2 >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"abcdef\\") 3 >>> min_changes_to_palindrome(\\"abba\\") 0 ``` # Note * In the first example, changing the character \'c\' to \'b\' will make the string \\"abba\\", which is a palindrome. * In the second example, changing \'r\' to \'e\' and \'c\' to \'a\' will make the string \\"eae\\", which is a palindrome. * A single character string is already a palindrome with 0 changes. * Consider edge cases such as already palindromic strings or strings that require multiple changes. **Function Signature** ```python def min_changes_to_palindrome(s: str) -> int: ```","solution":"def min_changes_to_palindrome(s: str) -> int: Given a string s, returns the minimum number of character changes required to make it a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"**Objective**: To implement a solver class for popular puzzle games and demonstrate its efficiency in solving one of them using standard algorithms. **Puzzle Solver Challenge**: Implement a Python class `SudokuSolver` that provides methods for solving standard Sudoku puzzles. Your implementation should handle file I/O to read the puzzle from a file and write the solution to a file. # Tasks 1. **solve**: Write a method `solve` which takes in a single parameter, `board` (a 2D list representing a 9x9 Sudoku board). This method should solve the Sudoku puzzle using backtracking or another efficient algorithm, and return the solved board. If the puzzle is unsolvable, return `None`. 2. **read_board_from_file**: Write a method `read_board_from_file` which takes in one parameter, `file_path` (a string representing the path to the input file containing the Sudoku puzzle). This should read from the file and return the `board` as a 2D list. Each cell in the board is an integer from 0-9, where 0 represents an empty cell. 3. **write_board_to_file**: Write a method `write_board_to_file` which takes two parameters, `board` (a 2D list representing the solved Sudoku board) and `file_path` (a string representing the path to the file where the solved board will be written). This method should write the solved board to the file in a structured format. 4. **solve_from_file**: Write a method `solve_from_file` which takes two parameters, `input_file_path` (a string representing the path to the file containing the original Sudoku puzzle) and `output_file_path` (a string representing the path where the solved puzzle will be written). This method should read the board from the input file, solve the puzzle, and write the solved board to the output file. Return `True` if the solution was successful, otherwise `False`. # Specifications - The input file will contain 9 lines, each with 9 integers separated by whitespace. - Ensure that you handle unexpected errors gracefully and return appropriate boolean flags for file operations. - Develop a simple `__main__` method to demonstrate the usage of your class and methods. # Example ```python # Example usage solver = SudokuSolver() board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solved_board = solver.solve(board) print(solver.write_board_to_file(solved_board, \\"solved.txt\\")) solver.solve_from_file(\\"sudoku_input.txt\\", \\"sudoku_output.txt\\") ``` # Constraints: - Each number in the Sudoku board must be an integer between 0 and 9. - The file path should be a valid path relative or absolute. - The Sudoku puzzle given will always have at least one solution. **Note**: Focus on edge cases, such as reading empty or malformed files, and ensure efficient solving for puzzles with minimal starting clues.","solution":"class SudokuSolver: def __init__(self): pass def solve(self, board): def is_valid(board, row, col, num): # Check if num is not in the current row, column and 3x3 sub-box for i in range(9): if board[row][i] == num or board[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve_recursively(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_recursively(board): return True board[row][col] = 0 return False return True if solve_recursively(board): return board else: return None def read_board_from_file(self, file_path): with open(file_path, \'r\') as file: board = [] for line in file: board.append([int(num) for num in line.split()]) return board def write_board_to_file(self, board, file_path): with open(file_path, \'w\') as file: for row in board: file.write(\' \'.join(map(str, row)) + \'n\') def solve_from_file(self, input_file_path, output_file_path): try: board = self.read_board_from_file(input_file_path) solved_board = self.solve(board) if solved_board is not None: self.write_board_to_file(solved_board, output_file_path) return True else: return False except: return False"},{"question":"# Context A local bookstore owner wants to keep track of the inventory of their books, sorted by titles. The owner has requested a program that can organize the inventory. # Task Write a function `sort_books(inventory: list[tuple[int, str]]) -> list[tuple[int, str]]` that sorts the bookstore inventory using the Bubble Sort algorithm. # Function Signature ```python def sort_books(inventory: list[tuple[int, str]]) -> list[tuple[int, str]]: Sorts a list of book inventory records in ascending order based on book titles using the bubble sort algorithm. :param inventory: A list of tuples, each containing an integer representing qty and a string with the book title. :return: The sorted list based on book titles. ``` # Input * `inventory`: A list of tuples, where each tuple consists of an integer (the quantity of the book) and a string (the book title). For example: `[(3, \\"Harry Potter\\"), (6, \\"Percy Jackson\\"), (2, \\"Catching Fire\\")]` # Output * A sorted list of tuples based on the string value (book title) in ascending order. # Constraints * 0 ≤ len(inventory) ≤ 10^3 * Each tuple will have a non-negative integer and a non-empty string. * Book titles are unique. # Examples 1. Input: `[(3, \\"Harry Potter\\"), (6, \\"Percy Jackson\\"), (2, \\"Catching Fire\\")]` Output: `[(2, \\"Catching Fire\\"), (3, \\"Harry Potter\\"), (6, \\"Percy Jackson\\")]` 2. Input: `[(5, \\"A Tale of Two Cities\\"), (1, \\"1984\\"), (7, \\"Jane Eyre\\")]` Output: `[(1, \\"1984\\"), (5, \\"A Tale of Two Cities\\"), (7, \\"Jane Eyre\\")]` # Notes Consider potential edge cases like an empty list or a list with one element, and ensure that your function handles these appropriately.","solution":"def sort_books(inventory: list[tuple[int, str]]) -> list[tuple[int, str]]: Sorts a list of book inventory records in ascending order based on book titles using the bubble sort algorithm. :param inventory: A list of tuples, each containing an integer representing qty and a string with the book title. :return: The sorted list based on book titles. n = len(inventory) for i in range(n): for j in range(0, n-i-1): if inventory[j][1] > inventory[j+1][1]: inventory[j], inventory[j+1] = inventory[j+1], inventory[j] return inventory"},{"question":"# Task You are given a string containing words and separators. Separators include spaces, commas, and periods. Write a Python function `reverse_words(s: str) -> str` that reverses the order of words while keeping the separators in their original positions. # Function Signature ```python def reverse_words(s: str) -> str: pass ``` # Input * **s**: A string containing words delimited by spaces, commas, or periods. The string length is between 1 and 10,000 characters. # Output * Returns a string where the words are reversed in order, but the separators remain in their original positions. # Constraints * Each word consists only of alphabetic characters. * The function should be able to handle large input strings efficiently. # Example Consider the string: `s = \\"hello, world. today\\"` * The words are \\"hello\\", \\"world\\", and \\"today\\". * The separators are \\", \\", and \\". \\". * Reversing the words in their original order, the string should become \\"today, world. hello\\". ```python >>> reverse_words(\\"hello, world. today\\") \\"today, world. hello\\" ``` # Note Ensure that spaces, commas, and periods that are part of the separators are correctly retained in their original locations within the string.","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the string while keeping the separators (spaces, commas, and periods) at their original positions. import re # Find all the words in the string using a regex words = re.findall(r\'b[a-zA-Z]+b\', s) # Reverse the list of words words_reversed = words[::-1] # Iterator for the reversed words words_iter = iter(words_reversed) # Reconstruct the string with words in reversed order result = [] i = 0 while i < len(s): if s[i].isalpha(): # Find the complete word starting from this position j = i while j < len(s) and s[j].isalpha(): j += 1 # Replace with the next word in the reversed list result.append(next(words_iter)) i = j else: # If it\'s a separator, just add it to the result result.append(s[i]) i += 1 return \'\'.join(result)"},{"question":"# Question An e-commerce website keeps track of user ratings for various products. Each product can be rated on a scale of 1 to 5. Given a list of lists where each sublist contains the ratings received by a product, identify the product with the highest average rating. If there is a tie, return the product that appears first in the input list. Implement the function `highest_average_rating(ratings: list[list[int]]) -> int` that takes a list of `n` sublists representing ratings for `n` products and returns the index of the product with the highest average rating. Function Signature ```python def highest_average_rating(ratings: list[list[int]]) -> int: pass ``` # Input * `ratings`: A list of `n` sublists where each sublist contains integers from 1 to 5 representing the ratings for a product. Each sublist has at least one rating. # Output * An integer representing the index of the product with the highest average rating. If there is a tie, return the index of the product that appears first in the list. # Examples ```python assert highest_average_rating([[4, 5, 3], [5, 5, 4, 5], [3, 3, 4, 4]]) == 1 assert highest_average_rating([[1, 2, 2], [3, 3, 3], [2, 2, 2, 5]]) == 1 assert highest_average_rating([[1, 1, 1], [2], [3, 3, 3, 3]]) == 2 ``` # Constraints * Each sublist contains at least one rating. * Ratings are given as integers in the range 1 to 5. * There will be at least one product in the input list. # Notes * You may assume that the input list contains valid ratings. * The solution should handle cases where there are ties in the average ratings effectively.","solution":"def highest_average_rating(ratings): max_average = 0 # Initialize the maximum average rating max_index = 0 # Initialize the index of the product with the maximum average rating for i, rating in enumerate(ratings): average_rating = sum(rating) / len(rating) # Calculate the average rating for the product # Update the max average and its corresponding index if the current product has a higher average if average_rating > max_average: max_average = average_rating max_index = i return max_index"},{"question":"# Problem Statement A company is managing a set of servers, each having a finite processing capacity. Each server can process a certain number of tasks simultaneously. You are tasked with distributing a list of tasks across these servers such that the maximum load (the number of tasks assigned to the most loaded server) is minimized. Write a function: ```python def minimize_max_load(tasks: List[int], server_capacity: int) -> int: Distributes the tasks among servers to minimize the maximum load on any server. Parameters: - tasks (List[int]): A list of integers where each integer represents a task\'s required processing capacity. - server_capacity (int): The capacity of each individual server. Returns: - int: The minimum possible maximum load that can be achieved on any server. pass ``` # Constraints 1. (1 leq text{len(tasks)} leq 10^5) 2. (1 leq text{tasks[i]} leq 1000) 3. (1 leq text{server_capacity} leq 1000) # Example ```python print(minimize_max_load([7, 2, 5, 10, 8], 15)) # Output: 10 print(minimize_max_load([1, 2, 3, 4, 5], 6)) # Output: 6 print(minimize_max_load([10, 20, 30], 50)) # Output: 30 ``` # Considerations 1. The function should be designed to handle a large number of tasks optimally. 2. The distribution should be done in such a way that the load difference between the most loaded and least loaded servers is minimized. 3. Consider edge cases where all tasks require maximum capacity or when tasks are relatively evenly distributed.","solution":"from typing import List def minimize_max_load(tasks: List[int], server_capacity: int) -> int: def can_distribute(mid): current_load = 0 servers_needed = 1 for task in tasks: if task > mid: return False if current_load + task > mid: servers_needed += 1 current_load = task if servers_needed > server_capacity: return False else: current_load += task return True left, right = max(tasks), sum(tasks) result = right while left <= right: mid = (left + right) // 2 if can_distribute(mid): result = mid right = mid - 1 else: left = mid + 1 return result # Example usage print(minimize_max_load([7, 2, 5, 10, 8], 3)) # Output: 14 print(minimize_max_load([1, 2, 3, 4, 5], 2)) # Output: 9 print(minimize_max_load([10, 20, 30], 1)) # Output: 60"},{"question":"# Coding Assessment: String Interleaving Check **Objective**: Implement a function to determine if a given string `s3` is an interleaving of two other strings `s1` and `s2`. # Problem An interleaving of two strings `s1` and `s2` is a string made up of all the characters of `s1` and `s2` in a way that maintains the left-to-right ordering of the characters from each string. Given three strings `s1`, `s2`, and `s3`, write a function `is_interleave` that returns `True` if `s3` is an interleaving of `s1` and `s2`, and `False` otherwise. # Function Signature ```python def is_interleave(s1: str, s2: str, s3: str) -> bool: Determine if s3 is an interleaving of s1 and s2. Args: s1 (str): The first string. s2 (str): The second string. s3 (str): The target interleaved string. Returns: bool: True if s3 is an interleaving of s1 and s2, False otherwise. pass ``` # Input * `s1`: A string containing lowercase letters. * `s2`: A string containing lowercase letters. * `s3`: A string containing lowercase letters. # Output * A boolean value: `True` if `s3` is an interleaving of `s1` and `s2`, `False` otherwise. # Constraints * 0 ≤ len(s1), len(s2) ≤ 100 * 0 ≤ len(s3) ≤ 200 # Example ```python s1 = \\"abc\\" s2 = \\"def\\" s3 = \\"adbcef\\" result = is_interleave(s1, s2, s3) print(result) # Expected output: True ``` # Explanation In the example above, the string `s3 = \\"adbcef\\"` is formed by interleaving `s1 = \\"abc\\"` and `s2 = \\"def\\"` as follows: * Take \'a\' from `s1`, then \'d\' from `s2`, then \'b\' from `s1`, then \'c\' from `s1`, then \'e\' from `s2`, then \'f\' from `s2`. # Instructions 1. Implement the function `is_interleave` using dynamic programming or recursion. 2. Ensure that your function handles edge cases, such as empty strings. 3. Optimize the function for time and space complexity where possible. 4. Test your function with different input cases to validate correctness. # Notes * An interleaved string meets the following criteria: * It contains all characters from `s1` and `s2`. * It maintains the relative order of characters from `s1` and `s2`. Use these guidelines to develop an efficient and accurate function.","solution":"def is_interleave(s1: str, s2: str, s3: str) -> bool: Determine if s3 is an interleaving of s1 and s2. Args: s1 (str): The first string. s2 (str): The second string. s3 (str): The target interleaved string. Returns: bool: True if s3 is an interleaving of s1 and s2, False otherwise. # If the lengths don\'t match, s3 can\'t be an interleaving of s1 and s2 if len(s3) != len(s1) + len(s2): return False # Create a 2D DP array with dimensions (len(s1) + 1) x (len(s2) + 1) dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] # Initialize the DP array dp[0][0] = True # Fill the DP array for i in range(len(s1) + 1): for j in range(len(s2) + 1): if i > 0 and dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]: dp[i][j] = True if j > 0 and dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]: dp[i][j] = True return dp[len(s1)][len(s2)]"},{"question":"# Scenario: You are building an event scheduling feature for a calendar application. The events are represented as intervals with start and end times. The goal is to identify if there are any conflicts between given events. If no conflicts exist, the events can be scheduled as is; otherwise, you need to merge overlapping events. # Implement the Function: **Function Signature**: ```python def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: pass ``` **Input**: * A list of intervals, where each interval is represented as a list of two integers [start, end]: `intervals` (List[List[int]]). **Output**: * A list of merged intervals sorted by start time. **Constraints**: * The intervals may not be sorted. * The start time of each interval is less than the end time. # Example: **Input**: ```python intervals = [[1, 3], [2, 6], [8, 10], [15, 18]] ``` **Output**: ```python [[1, 6], [8, 10], [15, 18]] ``` **Explanation**: The intervals [1, 3] and [2, 6] overlap, so they are merged into [1, 6]. The intervals [8, 10] and [15, 18] do not overlap with any other intervals. # Example: **Input**: ```python intervals = [[1, 4], [4, 5]] ``` **Output**: ```python [[1, 5]] ``` **Explanation**: The intervals [1, 4] and [4, 5] overlap, so they are merged into [1, 5]. # Tips: * Consider sorting the intervals based on their start time before processing them. * Iterate through the sorted intervals and merge overlapping intervals as you go. * Maintain an output list and add non-overlapping intervals directly to it.","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] # Check if there is an overlap if current[0] <= last_merged[1]: # Merge the intervals last_merged[1] = max(last_merged[1], current[1]) else: merged.append(current) return merged"},{"question":"# Prime Number Gap Problem Statement: Write a function `find_prime_gap` that computes the smallest gap between any two consecutive prime numbers in a given range `[m, n]`. A prime number is only divisible by 1 and itself. The gap between two consecutive prime numbers `p1` and `p2` (where (p1 < p2)) is defined as (p2 - p1). The program should identify all prime numbers between `m` and `n` (inclusive) and calculate the smallest gap between any two consecutive primes. If there are fewer than two prime numbers in the given range, return `-1`. Input: - Two integers `m` and `n` (1 ≤ m ≤ n ≤ 10,000), representing the range within which to find prime numbers. Output: - An integer representing the smallest gap between any two consecutive prime numbers within the range `[m, n]`, or `-1` if there are fewer than two primes. Constraints: - The input values `m` and `n` must be positive integers, with `m` less than or equal to `n`. - The solution should be efficient and able to handle the upper limits of the input size. Example: **Input:** ```python 10, 30 ``` **Output:** ```python 2 ``` **Explanation:** - The prime numbers between 10 and 30 are: [11, 13, 17, 19, 23, 29] - The gaps between consecutive primes in this range are: [2, 4, 2, 4, 6] - The smallest gap is 2. Notes: - Ensure to handle edge cases such as no primes found in the given range. - Multiple methods can be employed to find prime numbers such as the Sieve of Eratosthenes for efficiency in larger ranges.","solution":"def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def find_prime_gap(m, n): primes = [num for num in range(m, n+1) if is_prime(num)] if len(primes) < 2: return -1 min_gap = float(\'inf\') for i in range(1, len(primes)): min_gap = min(min_gap, primes[i] - primes[i-1]) return min_gap"},{"question":"# Scenario You are developing a simple blog platform where multiple authors can submit posts. To streamline the development process, you need to implement a content management system (CMS) backend for managing posts and author information. # Task 1. **Function Requirement: `add_author`** - **Purpose**: Create a function to add a new author to the system. - **Input**: - `name: str`: The full name of the author. - `email: str`: The email address of the author. - **Output**: - Returns a dictionary containing the author\'s ID, name, and email. 2. **Function Requirement: `create_post`** - **Purpose**: Create a function to add a new blog post. - **Input**: - `author_id: int`: The ID of the author writing the post. - `title: str`: The title of the blog post. - `content: str`: The main content of the blog post. - `tags: List[str]`: A list of tags related to the post. - **Output**: - Returns a dictionary containing the post\'s ID, author ID, title, content, tags, and the creation timestamp. # Constraints: - Ensure error handling for invalid inputs and cases where the author does not exist. - The ID for authors and posts should be unique and auto-incrementing. - Careful management of attributes like email addresses to prevent duplicates or errors. - Functions should raise custom exceptions with meaningful messages for errors like invalid author ID or missing required fields. # Examples ```python # Example Usage # 1. Add a new author author_data = add_author(\\"Alice Johnson\\", \\"alice@example.com\\") print(author_data) # Expected output: {\'id\': 1, \'name\': \'Alice Johnson\', \'email\': \'alice@example.com\'} # 2. Create a new blog post post_data = create_post(author_id=1, title=\\"My First Blog Post\\", content=\\"This is the content of the blog post.\\", tags=[\\"introduction\\", \\"personal\\"]) print(post_data) # Expected output: # { # \'id\': 1, # \'author_id\': 1, # \'title\': \'My First Blog Post\', # \'content\': \'This is the content of the blog post.\', # \'tags\': [\'introduction\', \'personal\'], # \'timestamp\': \'2023-10-15T18:45:00Z\' # } ```","solution":"import datetime from typing import List, Dict # Global counters author_counter = 1 post_counter = 1 # Global storage authors = {} posts = {} class AuthorExistsError(Exception): pass class AuthorNotFoundError(Exception): pass class InvalidInputError(Exception): pass def add_author(name: str, email: str) -> Dict: global author_counter if not name or not email: raise InvalidInputError(\\"Name and email are required fields.\\") # Check if the email is already present for author in authors.values(): if author[\'email\'] == email: raise AuthorExistsError(f\\"Author with email {email} already exists.\\") author_id = author_counter authors[author_id] = { \'id\': author_id, \'name\': name, \'email\': email } author_counter += 1 return authors[author_id] def create_post(author_id: int, title: str, content: str, tags: List[str]) -> Dict: global post_counter if not author_id or not title or not content or tags is None: raise InvalidInputError(\\"Author ID, title, content, and tags are required fields.\\") # Check if the author exists if author_id not in authors: raise AuthorNotFoundError(f\\"Author with ID {author_id} does not exist.\\") post_id = post_counter timestamp = datetime.datetime.utcnow().isoformat() + \\"Z\\" posts[post_id] = { \'id\': post_id, \'author_id\': author_id, \'title\': title, \'content\': content, \'tags\': tags, \'timestamp\': timestamp } post_counter += 1 return posts[post_id]"},{"question":"# Scenario: You are required to design and implement a simple in-memory key-value store that supports basic CRUD operations. The store should allow setting a value for a given key, retrieving the value of a key, updating the value of a key, and deleting a key-value pair. # Requirements: 1. **Set operation** should allow setting a value for a given key. 2. **Get operation** should retrieve the value associated with a given key. 3. **Update operation** should modify the value of an existing key. 4. **Delete operation** should remove the key-value pair from the store. # Function Specification: 1. **Set Function**: ```python def set(self, key: str, value: Any) -> None: Sets the value for a given key in the key-value store. Parameters: key (str): The key for the value. value (Any): The value to be associated with the key. # Your implementation here ``` 2. **Get Function**: ```python def get(self, key: str) -> Any: Retrieves the value associated with the given key. Parameters: key (str): The key whose value is to be retrieved. Returns: Any: The value associated with the key, or None if the key does not exist. # Your implementation here ``` 3. **Update Function**: ```python def update(self, key: str, value: Any) -> None: Updates the value for an existing key in the key-value store. Parameters: key (str): The key for which the value is to be updated. value (Any): The new value to be associated with the key. Raises: KeyError: If the key does not exist in the store. # Your implementation here ``` 4. **Delete Function**: ```python def delete(self, key: str) -> None: Deletes the key-value pair corresponding to the given key from the store. Parameters: key (str): The key to be deleted from the store. Raises: KeyError: If the key does not exist in the store. # Your implementation here ``` # Constraints: - **Store Size**: 1 <= number of keys <= 10^5 - **Key Length**: Each key is a string with length up to 100 characters. - **Value Types**: Values can be of any data type, including integers, strings, lists, or dictionaries. # Performance Requirements: - All operations should have average constant time complexity, O(1). # Example Usage: ```python # Initialize the key-value store store = KeyValueStore() # Set key-value pairs store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", 30) # Get the value of a key name = store.get(\\"name\\") # Should return \\"Alice\\" # Update the value of a key store.update(\\"age\\", 31) # Verify the updated value age = store.get(\\"age\\") # Should return 31 # Delete a key-value pair store.delete(\\"name\\") # Try to get the value of a deleted key deleted_value = store.get(\\"name\\") # Should return None ``` Ensure that the operations set, get, update, and delete follow the constraints and perform efficiently.","solution":"class KeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: any) -> None: self.store[key] = value def get(self, key: str) -> any: return self.store.get(key) def update(self, key: str, value: any) -> None: if key in self.store: self.store[key] = value else: raise KeyError(f\\"Key \'{key}\' not found in the store\\") def delete(self, key: str) -> None: if key in self.store: del self.store[key] else: raise KeyError(f\\"Key \'{key}\' not found in the store\\")"},{"question":"# Scenario: You are developing a text editor and need to incorporate a feature that allows users to search for the closest occurrence of a target word within a document. The document is represented as a list of strings, where each string is a line of text. # Task: Create a function that finds the closest occurrence of a target word within the document. The function should return the line number and the index of the word within that line. # Requirements: 1. **Function Definition**: Define the function `find_closest_word(document, target_word)`. 2. **Implementation**: * The `document` parameter is a list of non-empty strings, each representing a line of text. * The `target_word` parameter is a single word (string) to search for in the document. * If the target_word appears multiple times in the same line, return the first occurrence. * If the target_word is not found, return (-1, -1). 3. **Constraints**: * The search should be case-insensitive. * The function should return a tuple containing the line number (0-based index) and the word index (0-based index within the line). # Input Format: - `document`: A list of non-empty strings. - `target_word`: A string representing the word to search for. # Output Format: - A tuple containing the line number and the index of the word within that line. If not found, return (-1, -1). # Example: ```python document = [ \\"The quick brown fox jumps over the lazy dog\\", \\"The quick brown fox\\", \\"jumps over\\", \\"the lazy fox\\" ] target_word = \\"fox\\" print(find_closest_word(document, target_word)) # Expected output: (0, 16) target_word = \\"wolf\\" print(find_closest_word(document, target_word)) # Expected output: (-1, -1) ``` Implement the `find_closest_word` function in Python with the specified behavior. ```python def find_closest_word(document, target_word): target_word = target_word.lower() for line_number, line in enumerate(document): words = line.lower().split() if target_word in words: return (line_number, line.lower().index(target_word)) return (-1, -1) # Example usage document = [ \\"The quick brown fox jumps over the lazy dog\\", \\"The quick brown fox\\", \\"jumps over\\", \\"the lazy fox\\" ] target_word = \\"fox\\" print(find_closest_word(document, target_word)) # Expected output: (0, 16) target_word = \\"wolf\\" print(find_closest_word(document, target_word)) # Expected output: (-1, -1) ```","solution":"def find_closest_word(document, target_word): target_word_lower = target_word.lower() for line_number, line in enumerate(document): words = line.lower().split() if target_word_lower in words: word_index = line.lower().index(target_word_lower) return (line_number, word_index) return (-1, -1) # Example usage document = [ \\"The quick brown fox jumps over the lazy dog\\", \\"The quick brown fox\\", \\"jumps over\\", \\"the lazy fox\\" ] print(find_closest_word(document, \\"fox\\")) # Expected output: (0, 16) print(find_closest_word(document, \\"wolf\\")) # Expected output: (-1, -1)"},{"question":"# Scenario: In a rectangular grid consisting of `m` rows and `n` columns, each cell is either filled with water (\'W\') or land (\'L\'). Our objective is to determine the number of disconnected land masses present in the grid. A land mass is defined as a collection of horizontally and/or vertically adjacent \'L\' cells. No diagonal adjacency is considered. # Task: Write a Python function that takes a 2D list of characters representing the grid, and returns the number of disconnected land masses. # Function Signature: ```python def count_land_masses(grid: List[List[str]]) -> int: pass ``` # Input: - `grid` (List[List[str]]): A 2D list of characters where each character is either \'W\' (representing water) or \'L\' (representing land). # Output: - An integer representing the number of disconnected land masses in the grid. # Constraints: - The grid can be empty or of various sizes, up to a maximum of 1000x1000. - Land cells (\'L\') that are connected both horizontally and vertically should be treated as a single land mass. - Ensure efficient traversal to handle large grids within reasonable time limits. # Example: ```python >>> count_land_masses([[\'L\', \'W\', \'W\', \'L\'], [\'L\', \'L\', \'W\', \'W\'], [\'W\', \'L\', \'L\', \'W\'], [\'W\', \'W\', \'W\', \'L\']]) 4 ``` # Requirements: - Implement your solution using depth-first search (DFS) or breadth-first search (BFS) algorithms to explore and count land masses. - Handle edge cases such as empty grids or grids with no land. # Approach: - Iterate through each cell in the grid. - Start a DFS/BFS whenever an unvisited \'L\' cell is encountered, marking all reachable cells of the connected component. - Continue the process until all cells are visited and count the total number of disconnected land masses.","solution":"from typing import List def count_land_masses(grid: List[List[str]]) -> int: if not grid: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] != \'L\': return grid[x][y] = \'W\' # Mark as visited by converting \'L\' to \'W\' directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) m, n = len(grid), len(grid[0]) land_masses = 0 for i in range(m): for j in range(n): if grid[i][j] == \'L\': land_masses += 1 dfs(i, j) return land_masses"},{"question":"# Objective Implement a function to find the next lexicographical permutation of a given list of integers. # Problem Statement You are given a list of integers `lst`. Your task is to implement the `next_permutation` function that modifies the list in-place to produce the next lexicographical permutation of the integers in `lst`. Specifications - **Function Signature**: ```python def next_permutation(lst: List[int]) -> None: ``` - **Parameters**: - `lst` (List[int]): A list of integers. - **Returns**: - None: The function should modify the given list in-place to be its next lexicographical permutation. If the operation is not possible (the list is in descending order), it should rearrange the list to the lowest possible order (i.e., sorted in ascending order). Constraints - The length of the list will be between 1 and 1000. - Elements of the list are all integers between -10^9 and 10^9. Examples ```python >>> lst = [1, 2, 3] >>> next_permutation(lst) >>> lst [1, 3, 2] >>> lst = [3, 2, 1] >>> next_permutation(lst) >>> lst [1, 2, 3] >>> lst = [1, 1, 5] >>> next_permutation(lst) >>> lst [1, 5, 1] ``` Notes - The list must be modified in-place. - The function should not return any value.","solution":"def next_permutation(lst): Modifies the list lst in-place to produce the next lexicographical permutation. If no such permutation exists, it rearranges to the lowest possible order. n = len(lst) if n <= 1: return # Step 1: Find the largest index k such that lst[k] < lst[k + 1]. If no such index exists, # the permutation is the last permutation. k = n - 2 while k >= 0 and lst[k] >= lst[k + 1]: k -= 1 if k == -1: # lst is sorted in descending order, rearrange to the lowest possible order lst.reverse() return # Step 2: Find the largest index l greater than k such that lst[k] < lst[l] l = n - 1 while l > k and lst[l] <= lst[k]: l -= 1 # Step 3: Swap the value of lst[k] with that of lst[l] lst[k], lst[l] = lst[l], lst[k] # Step 4: Reverse the sequence from lst[k + 1] to the end lst[k + 1:] = reversed(lst[k + 1:])"},{"question":"# Problem Statement You are required to implement a function that performs an in-order traversal on a given binary search tree (BST). The function should return the list of node values in ascending order of the traversal. # Input * A binary search tree node structure where each node has attributes `value`, `left`, and `right`. * The root node of the BST. # Output * A list of integers representing the node values in ascending order as obtained from the in-order traversal. # Constraints * The number of nodes in the tree is between 1 and 1000. * Node values are integers and unique. * Node values are within the range of -10^5 to 10^5. # Performance Requirements * The function should have a time complexity of O(N), where N is the number of nodes. * The function should have a space complexity of O(H), where H is the height of the tree. # Scenario: Consider the following binary search tree: ``` 4 / 2 6 / / 1 3 5 7 ``` The in-order traversal should return `[1, 2, 3, 4, 5, 6, 7]`. # Function Signature ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root: TreeNode) -> list[int]: pass ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root: TreeNode) -> list[int]: def inorder(node, result): if node is not None: inorder(node.left, result) result.append(node.value) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"# Coding Assessment Question Scenario: You need to design an itinerary system for a travel planning service. The system is supposed to determine the order in which a series of flights should be taken based on given direct flight connections. Each flight\'s identifier, source, and destination form a flight itinerary graph that may contain cycles. Create a function to find a valid itinerary that visits all destinations once, using Depth First Search (DFS). Task: Write a function `find_itinerary(flights: List[Tuple[str, str]]) -> List[str]` that finds a valid itinerary from the given list of flights. Each flight is represented as a tuple of its source and destination. Input: 1. `flights`: A list of tuples where each tuple contains two strings representing the source and destination of a flight. Output: - A list of strings representing the flight identifiers in the order they should be taken. Constraints: - Every destination must be visited exactly once. - There may be multiple valid itineraries. - It is guaranteed that a solution exists. - Flight identifiers (source and destination) are unique. Example: ```python flights = [(\\"JFK\\", \\"SFO\\"), (\\"JFK\\", \\"ATL\\"), (\\"SFO\\", \\"ATL\\"), (\\"ATL\\", \\"JFK\\"), (\\"ATL\\", \\"SFO\\")] print(find_itinerary(flights)) # Output could be [\'JFK\', \'ATL\', \'JFK\', \'SFO\', \'ATL\', \'SFO\'] ``` # Performance Requirements: - The time complexity should be O(E + V). - The algorithm should efficiently handle up to 10,000 flights. Note: - Ensure to test scenarios where there are multiple flight connections for a single source. - Ensure that the graph handling accounts for cycles and properly visits each destination exactly once.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_itinerary(flights: List[Tuple[str, str]]) -> List[str]: # Constructing graph from flights graph = defaultdict(list) for src, dst in flights: graph[src].append(dst) # Sorting destinations for each source node to handle multiple valid itineraries for src in graph: graph[src].sort(reverse=True) # DFS function to reconstruct the itinerary def dfs(node): while graph[node]: next_node = graph[node].pop() dfs(next_node) itinerary.append(node) # Define the itinerary list itinerary = [] start = flights[0][0] # Guaranteed that a solution exists; we assume start from the source of the first flight dfs(start) # Reverse the itinerary as we construct it in reverse order during DFS return itinerary[::-1]"},{"question":"**Find the First Non-Repeating Character** # Background You are tasked with analyzing strings for unique characters in order to identify the first character that does not repeat itself within the string. This is a common problem in text processing, and it will help you develop efficient solutions for analyzing and manipulating strings. # Problem Write a function `first_non_repeating_character` that takes a string and returns the first character that does not repeat itself in the string. If all characters are repeating, the function should return an underscore (\'_\'). # Requirements: - You need to consider the case sensitivity of the characters. (\'a\' and \'A\' are considered different characters) - The string may contain a combination of upper case, lower case, digits, and special characters. # Function Signature ```python def first_non_repeating_character(s: str) -> str: pass ``` # Input - `s` (str): A string of length `n` containing upper case letters, lower case letters, digits, and special characters. # Output - (str): The first non-repeating character in the input string, or an underscore (\'_\') if all characters repeat. # Examples 1. `first_non_repeating_character(\\"aabcc\\")` should return `\'b\'` 2. `first_non_repeating_character(\\"aabbccddeeff\\")` should return `\'_\'` 3. `first_non_repeating_character(\\"azzzbbccc\\")` should return `\'a\'` 4. `first_non_repeating_character(\\"aA\\")` should return `\'a\'` 5. `first_non_repeating_character(\\"!@#!!@#\\")` should return `\'_\'` 6. `first_non_repeating_character(\\"leetCode\\")` should return `\'l\'` 7. `first_non_repeating_character(\\"123451234\\")` should return `\'5\'` # Constraints - The length of the string `n` will be between 1 and 10^5. - The string may contain non-alphanumeric characters. - You are expected to write an efficient solution with optimal performance given the constraints.","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating, returns \'_\'. char_count = {} # First pass to count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first non-repeating character for char in s: if char_count[char] == 1: return char return \'_\'"},{"question":"# Question Given a list of non-negative integers, write two functions to: 1. Determine if the list can be classified as an arithmetic series. 2. Calculate the median of the values in the list. Requirements - Implement the function `is_arithmetic_series(series: list) -> bool`: * This function should return `True` if the given list forms an arithmetic series, else return `False`. * An empty list should raise a `ValueError`. * If the input is not a list, raise a `ValueError`. - Implement the function `median(series: list) -> float`: * This function should return the median of the numbers in the list. * If the list is empty, raise a `ValueError`. * If the input is not a list, raise a `ValueError`. Input Format * `series`: A list of non-negative integers. Output Format * `is_arithmetic_series`: Return a boolean value. * `median`: Return a float value that is the median of the list. # Examples ```python >>> is_arithmetic_series([2, 5, 8, 11, 14]) True >>> is_arithmetic_series([1, 2, 4, 7, 11]) False >>> is_arithmetic_series([3, 6, 9, 12, 15]) True >>> is_arithmetic_series([0, 1, 2, 3, 4]) True >>> is_arithmetic_series([1, 2, 4, 5, 9]) False >>> median([1, 3, 3, 6, 7, 8, 9]) 6 >>> median([1, 2, 3, 4, 5, 6, 8, 9, 9]) 5 >>> median([1, 1, 1, 1, 1]) 1 >>> median([1, 4, 2, 3]) 2.5 >>> median([4]) 4 ``` Constraints * The input list must only contain non-negative integers. * The functions must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. Additional Information An arithmetic series is a sequence of numbers in which the difference of any two successive members is a constant. The median is a measure of central tendency that splits the distribution into two equal halves.","solution":"def is_arithmetic_series(series): Determines if the given series is an arithmetic series. Parameters: series (list): A list of non-negative integers. Returns: bool: True if the series is arithmetic, else False. Raises: ValueError: If the series is empty or not a list. if not isinstance(series, list): raise ValueError(\\"Input must be a list\\") if len(series) == 0: raise ValueError(\\"List cannot be empty\\") if len(series) == 1: return True difference = series[1] - series[0] for i in range(2, len(series)): if series[i] - series[i - 1] != difference: return False return True def median(series): Calculates the median of the given series. Parameters: series (list): A list of non-negative integers. Returns: float: The median of the series. Raises: ValueError: If the series is empty or not a list. if not isinstance(series, list): raise ValueError(\\"Input must be a list\\") if len(series) == 0: raise ValueError(\\"List cannot be empty\\") series.sort() n = len(series) mid = n // 2 if n % 2 == 0: return (series[mid - 1] + series[mid]) / 2.0 else: return float(series[mid])"},{"question":"# Coding Assessment Question Context You are working on an advanced data manipulation project where you often need to manage dynamically changing data sets. One common task involves performing range queries on a mutable array efficiently, such as finding the sum of elements within a certain range and updating elements in the array. Segment trees are a suitable data structure for these requirements. Problem Statement You need to implement a segment tree to handle the following operations efficiently: 1. **Building the Segment Tree**: * Construct a segment tree from a given array for range sum queries. 2. **Range Sum Query**: * Implement a function to query the sum of elements in a given range. 3. **Update Element**: * Implement a function to update an element at a specified index in the array. Function Signatures ```python class SegmentTree: def __init__(self, data: list[int]): Initializes the segment tree with the given data array. pass def range_sum(self, left: int, right: int) -> int: Returns the sum of elements in the range [left, right]. pass def update(self, index: int, value: int): Updates the element at the given index in the array to the new value. pass ``` Example ```python data = [1, 3, 5, 7, 9, 11] segment_tree = SegmentTree(data) print(segment_tree.range_sum(1, 3)) # Output: 15 (sum of elements from index 1 to 3: 3 + 5 + 7) segment_tree.update(1, 10) print(segment_tree.range_sum(1, 3)) # Output: 22 (after updating index 1 to 10: 10 + 5 + 7) print(segment_tree.range_sum(2, 5)) # Output: 32 (sum of elements from index 2 to 5: 5 + 7 + 9 + 11) ``` Constraints * Number of elements in the array (`n`): 1 ≤ n ≤ 10^5 * Element values: -10^9 ≤ value ≤ 10^9 * Number of queries (`q`): 1 ≤ q ≤ 10^5 Your solution will be evaluated on correctness, efficiency (both time and space), and proper handling of edge cases.","solution":"class SegmentTree: def __init__(self, data: list[int]): Initializes the segment tree with the given data array. self.n = len(data) self.tree = [0] * (2 * self.n) # Build the tree self.build(data) def build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def range_sum(self, left: int, right: int) -> int: Returns the sum of elements in the range [left, right]. # Shift the indexes to leaf nodes left += self.n right += self.n + 1 sum_val = 0 while left < right: if left % 2 == 1: sum_val += self.tree[left] left += 1 if right % 2 == 1: right -= 1 sum_val += self.tree[right] left //= 2 right //= 2 return sum_val def update(self, index: int, value: int): Updates the element at the given index in the array to the new value. # Update the value at the leaf node pos = self.n + index self.tree[pos] = value # Then update its ancestors while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]"},{"question":"# Question You are working on a genetic analysis project where you need to compute a similarity score between two DNA sequences. The similarity score is defined as the number of positions at which the corresponding nucleotides are the same divided by the total number of positions. Implement a function `similarity_score` to calculate this score. Function Signature ```python def similarity_score(dna_seq1: str, dna_seq2: str) -> float: ``` Input - `dna_seq1 (str)`: The first DNA sequence. - `dna_seq2 (str)`: The second DNA sequence. Output - Return a float value representing the similarity score between the two DNA sequences. Constraints - Both DNA sequences must be non-empty and of equal length. - DNA sequences can contain only the characters \'A\', \'C\', \'G\', and \'T\'. Example ```python >>> similarity_score(\'ACGTT\', \'ACGTT\') 1.0 >>> similarity_score(\'ACGTT\', \'ACGTA\') 0.8 ``` Errors ```python >>> similarity_score(\'ACGTT\', \'ACGT\') Traceback (most recent call last): ... ValueError: DNA sequences must be of the same length >>> similarity_score(\'ACGTT\', \'AXGTT\') Traceback (most recent call last): ... ValueError: DNA sequences can only contain the characters \'A\', \'C\', \'G\', and \'T\' ```","solution":"def similarity_score(dna_seq1: str, dna_seq2: str) -> float: Calculate the similarity score between two DNA sequences. The similarity score is defined as the number of positions at which the corresponding nucleotides are the same divided by the total number of positions. Both DNA sequences must be non-empty and of equal length, and can contain only the characters \'A\', \'C\', \'G\', and \'T\'. :param dna_seq1: The first DNA sequence. :param dna_seq2: The second DNA sequence. :return: The similarity score as a float. :raises ValueError: If the sequences are not of the same length or contain invalid characters. if len(dna_seq1) != len(dna_seq2): raise ValueError(\\"DNA sequences must be of the same length\\") valid_chars = {\'A\', \'C\', \'G\', \'T\'} if not set(dna_seq1).issubset(valid_chars) or not set(dna_seq2).issubset(valid_chars): raise ValueError(\\"DNA sequences can only contain the characters \'A\', \'C\', \'G\', and \'T\'\\") matches = sum(1 for a, b in zip(dna_seq1, dna_seq2) if a == b) return matches / len(dna_seq1)"},{"question":"Average of Levels in Binary Tree Problem Statement: Given a non-empty binary tree, write a function `average_of_levels(root: TreeNode) -> List[float]` to return the average value of the nodes on each level in the form of a list. A binary tree is a data structure in which each node has at most two children, referred to as the left child and the right child. Example: Consider the following binary tree: ``` 3 / 9 20 / 15 7 ``` Input: The root node of the binary tree representing the above structure. Output: `[3.0, 14.5, 11.0]` Explanation: - The first level has one node: 3, hence the average is 3. - The second level has two nodes: 9 and 20, with an average of (9+20)/2 = 14.5. - The third level has two nodes: 15 and 7, with an average of (15+7)/2 = 11.0. Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def average_of_levels(root: TreeNode) -> list: ``` Constraints: - The number of nodes in the tree is in the range `[1, 10^4]`. - `TreeNode.val` is an integer that can be positive or negative. - The function should handle large trees efficiently. - Use breadth-first traversal to calculate the average. Performance Requirement: Your solution should be efficient with respect to both time and space complexity. An O(n) solution in terms of time complexity is expected, where n is the number of nodes in the binary tree. Testing: The function will be tested with the following test cases and potentially more: 1. A complete binary tree. 2. A binary tree with only left children. 3. A binary tree with only right children. 4. A binary tree with varying levels of depth. 5. A binary tree with all node values being the same. Example Code: The following are some inputs and expected outputs for testing: ```python print(average_of_levels(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))))) # Expected: [3.0, 14.5, 11.0] print(average_of_levels(TreeNode(1))) # Expected: [1.0] print(average_of_levels(TreeNode(1, TreeNode(2, TreeNode(3))))) # Expected: [1.0, 2.0, 3.0] ``` Your task is to implement the `average_of_levels` function.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def average_of_levels(root: Optional[TreeNode]) -> List[float]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"# Problem Statement You are writing a software for a vending machine that dispenses products based on user input. The vending machine contains multiple items, each assigned a unique code and price. Write a program that: 1. Takes three parameters: `items` (dictionary), `code` (string), and `amount` (float). 2. Determines if the `code` exists in the `items` dictionary and checks if the `amount` is sufficient to purchase the item. 3. Calculates and returns the change if the purchase is successful. 4. Raises appropriate errors for invalid inputs (e.g., non-existent code or insufficient funds). # Input Format * A dictionary `items` where keys are strings representing item codes, and values are floats representing the price of the items. * A string `code` representing the code of the item to be purchased. * A float `amount` representing the amount of money provided by the user. # Output Format * Print one of the following: 1. The change after the purchase. 2. An error message if the code is invalid or funds are insufficient. # Constraints * `items` dictionary can have up to 100 items. * Item codes are non-empty strings and can have a length up to 10 characters. * Prices and amount should be positive floats. # Example Input 1 ```python items = { \\"A1\\": 1.25, \\"B2\\": 0.75, \\"C3\\": 2.00 } code = \\"A1\\" amount = 2.00 ``` Output 1 ``` Change: 0.75 ``` Input 2 ```python items = { \\"A1\\": 1.25, \\"B2\\": 0.75, \\"C3\\": 2.00 } code = \\"B5\\" amount = 1.00 ``` Output 2 ``` Error: Invalid item code ``` Input 3 ```python items = { \\"A1\\": 1.25, \\"B2\\": 0.75, \\"C3\\": 2.00 } code = \\"B2\\" amount = 0.50 ``` Output 3 ``` Error: Insufficient funds ``` # Function Signature The implementation should include one main function: ```python def vending_machine(items: dict, code: str, amount: float) -> float: pass ``` # Requirements 1. Ensure the function handles invalid inputs gracefully by raising a `ValueError` with appropriate messages: \\"Invalid item code\\" for non-existent codes and \\"Insufficient funds\\" for insufficient amounts. 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that you have clearly written and optimized code for performance.","solution":"def vending_machine(items: dict, code: str, amount: float) -> float: Determine if the code exists in the items dictionary and checks if the amount is sufficient to purchase the item. Calculate and return the change if the purchase is successful. Raise appropriate errors for invalid inputs. Parameters: items (dict): Dictionary with item codes as keys and prices as values. code (str): The code of the item to be purchased. amount (float): The amount of money provided by the user. Returns: float: The change after the purchase. Raises: ValueError: If the code is invalid or the amount is insufficient. if code not in items: raise ValueError(\\"Invalid item code\\") item_price = items[code] if amount < item_price: raise ValueError(\\"Insufficient funds\\") return amount - item_price"},{"question":"# **Stock Price Prediction** # Problem Statement: You are required to create a simple stock price prediction model using linear regression. Given a list of historical stock prices for a specific company, the program should predict the stock price for the next day. # Function Definitions: Function 1: `prepare_data(prices: List[float]) -> Tuple[List[float], List[float]]` - **Input**: A list of historical stock prices (floats). - **Output**: A tuple containing two lists: * The first list represents the input feature (x) values, which are the stock prices excluding the last entry. * The second list represents the target (y) values, which are the stock prices excluding the first entry. - **Constraints**: * If the length of the `prices` list is less than 2, raise a `ValueError(\\"Not enough data to prepare features\\")`. Function 2: `predict_next_price(x: List[float], y: List[float]) -> float` - **Input**: Two lists representing the input feature (x) values and the target (y) values. - **Output**: A float representing the predicted stock price for the next day. - **Constraints**: * Use linear regression to build a model and make the prediction. * If unable to fit the model (e.g. due to invalid or insufficient data), raise a `RuntimeError(\\"Model fitting error\\")`. # Task Instructions: 1. Implement the `prepare_data` function. 2. Implement the `predict_next_price` function. 3. Write a main block to take a list of historical stock prices, prepare the data, build a linear regression model, and print the predicted price for the next day. # Example: Given the following historical stock prices: ```python prices = [100.0, 101.5, 102.8, 105.0, 107.2] ``` Expected functions and output: 1. `prepare_data(prices)` would generate: ```python x = [100.0, 101.5, 102.8, 105.0] y = [101.5, 102.8, 105.0, 107.2] ``` 2. `predict_next_price(x, y)` would create a linear regression model and predict the next stock price, say `108.5`. The main block would print: ``` Predicted stock price for the next day: 108.5 ``` # Constraints: * Handle exceptions gracefully, especially regarding insufficient or invalid data for model training. * Assume the historical stock price data is relatively clean and preprocessed.","solution":"from typing import List, Tuple from sklearn.linear_model import LinearRegression def prepare_data(prices: List[float]) -> Tuple[List[float], List[float]]: Prepares the data for linear regression by creating input features (x) and target values (y). Args: prices (List[float]): A list of historical stock prices. Returns: Tuple[List[float], List[float]]: A tuple containing the input features and target values. Raises: ValueError: If the length of prices is less than 2. if len(prices) < 2: raise ValueError(\\"Not enough data to prepare features\\") x = prices[:-1] y = prices[1:] return x, y def predict_next_price(x: List[float], y: List[float]) -> float: Predicts the next stock price using a linear regression model. Args: x (List[float]): The input feature values. y (List[float]): The target values. Returns: float: The predicted stock price for the next day. Raises: RuntimeError: If the model fitting process fails. try: # Reshape the data to fit the model x = [[value] for value in x] y = [[value] for value in y] # Create and fit the model model = LinearRegression() model.fit(x, y) # Predict the next value next_x = [[x[-1][0] + (x[-1][0] - x[-2][0])]] # Predict next trend next_price = model.predict(next_x) return next_price[0][0] except Exception as e: raise RuntimeError(f\\"Model fitting error: {e}\\")"},{"question":"# Coding Question: Find and Replace Username in Email Addresses Context: As a software developer, you are working on a user management system for an online platform. In one of the tasks, you need to find and replace the username part of the email addresses within a given list. The username part of an email address is defined as the substring before the \\"@\\" symbol. Your task is to write a function that updates the username part while keeping the domain part unchanged. Objective: - Write a function `find_and_replace_username(emails: list, old_username: str, new_username: str) -> list` that: - Searches for email addresses containing the `old_username` as the username part. - Replaces the `old_username` with the `new_username`. - Returns the updated list of email addresses. Input and Output: - **Input**: - `emails`: A list of strings representing email addresses (e.g., `[\\"alice@example.com\\", \\"bob@example.com\\"]`). - `old_username`: A string representing the username to be replaced (e.g., `\\"alice\\"`). - `new_username`: A string representing the new username (e.g., `\\"charlie\\"`). - **Output**: - A list of strings representing the updated email addresses. Constraints and Limitations: - Each email address will be a valid email format containing exactly one \\"@\\" symbol. - The `old_username` will only appear as the username part and not as part of the domain. - `old_username` and `new_username` are guaranteed to be non-empty strings. - The list `emails` will contain at most 100 email addresses. Examples: ```python >>> find_and_replace_username([\\"alice@example.com\\", \\"bob@domain.com\\"], \\"alice\\", \\"charlie\\") [\'charlie@example.com\', \'bob@domain.com\'] >>> find_and_replace_username([\\"john.doe@gmail.com\\", \\"jane.doe@outlook.com\\"], \\"john.doe\\", \\"john.smith\\") [\'john.smith@gmail.com\', \'jane.doe@outlook.com\'] >>> find_and_replace_username([\\"foo@bar.com\\"], \\"foo\\", \\"baz\\") [\'baz@bar.com\'] >>> find_and_replace_username([\\"admin@company.com\\", \\"user@service.com\\"], \\"admin\\", \\"sysadmin\\") [\'sysadmin@company.com\', \'user@service.com\'] ``` Function Signature: ```python def find_and_replace_username(emails: list, old_username: str, new_username: str) -> list: pass ```","solution":"def find_and_replace_username(emails: list, old_username: str, new_username: str) -> list: updated_emails = [] for email in emails: username, domain = email.split(\'@\') if username == old_username: updated_emails.append(new_username + \'@\' + domain) else: updated_emails.append(email) return updated_emails"},{"question":"# List Operations Lab: Implement a Dynamic Queue Using a Circular Buffer In this task, you will implement a dynamic queue using a circular buffer to manage a stream of integer data efficiently. Scenario: You are working on a real-time data processing system that requires a fast and memory-efficient way to handle a continuous stream of integers. Using a dynamic queue implemented with a circular buffer can meet these requirements. Objective: Implement a class `DynamicQueue` that uses a circular buffer to manage the queue operations. Your class should support the basic queue operations: `enqueue`, `dequeue`, `is_empty`, and `size`. Additionally, the buffer should be dynamically resized when it becomes full. # Specifications: 1. Class: * `DynamicQueue` - This class should encapsulate the circular buffer and provide the following methods: * `__init__(self)`: Initializes an empty queue with a small initial buffer size. * `enqueue(self, value: int)`: Inserts the given integer value at the end of the queue. The buffer should resize dynamically if it becomes full. * `dequeue(self)`: Removes and returns the integer value at the front of the queue. If the queue is empty, raise an appropriate exception. * `is_empty(self) -> bool`: Returns `True` if the queue is empty, and `False` otherwise. * `size(self) -> int`: Returns the number of elements currently in the queue. # Detailed Descriptions: * **Circular Buffer**: Use an internal list of fixed size to implement the buffer. Maintain two pointers, `front` and `rear`, to manage the insertion and removal of elements. When `rear` reaches the end of the buffer, wrap it around to the beginning (and similarly for `front`). * **Dynamic Resizing**: When the buffer is full (i.e., inserting a new element would overwrite an existing element), create a new buffer of double the current size, and copy the elements from the old buffer to the new one in the correct order. Methods: ```python class DynamicQueue: def __init__(self): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def is_empty(self) -> bool: pass def size(self) -> int: pass ``` Example Usage: ```python q = DynamicQueue() q.enqueue(10) q.enqueue(20) q.enqueue(30) assert q.dequeue() == 10 assert q.size() == 2 assert q.is_empty() == False q.enqueue(40) q.enqueue(50) assert q.dequeue() == 20 assert q.size() == 3 assert q.dequeue() == 30 assert q.dequeue() == 40 assert q.dequeue() == 50 try: q.dequeue() except Exception as e: print(e) # Expect an exception since the queue is now empty ``` Constraints: * The initial buffer size should be small (e.g., 4). * Methods should handle a large number of elements efficiently, dynamically resizing the buffer as needed. * Inserting or removing elements should have an average time complexity of O(1). In this question, candidates are required to implement a queue using the circular buffer approach which dynamically resizes. This involves understanding data structures, pointers, and dynamic memory management efficiently.","solution":"class DynamicQueue: def __init__(self, initial_capacity=4): self.capacity = initial_capacity self.queue = [None] * self.capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, value: int) -> None: if self.size() == self.capacity: self._resize() self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise Exception(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None # Clear the slot self.front = (self.front + 1) % self.capacity self.count -= 1 return value def is_empty(self) -> bool: return self.count == 0 def size(self) -> int: return self.count def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.count): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.queue = new_queue self.front = 0 self.rear = self.count self.capacity = new_capacity"},{"question":"# Background Sorting algorithms are fundamental to computer science. One common sorting algorithm is Quick Sort, which uses a divide-and-conquer strategy. Understanding Quick Sort helps in optimizing not just algorithmic efficiency but also in learning pivot-based partitioning. # Problem Statement You are tasked with implementing a recursive quicksort function to sort an array of integers in ascending order. The function should apply the quicksort algorithm using a non-random pivot selection strategy (you can use the last element as the pivot). # Function Signature ```python def quicksort(arr: List[int], low: int, high: int) -> None: pass ``` # Input Format - `arr`: A list of integers to be sorted. - `low`: The starting index of the array to be sorted (initially, this will be 0). - `high`: The ending index of the array to be sorted (initially, this will be len(arr) - 1). # Output Format - The function should sort the array in place and does not need to return any value. # Constraints - The input array will have a length in the range [0, 10^4]. - Elements of the array can be in the range [-10^6, 10^6]. - You should aim for an average-case time complexity of O(n log n). # Performance Requirements - Handle input arrays with up to 10,000 elements efficiently. - Ensure the function implements the quicksort algorithm correctly without using built-in sorting functions. # Example ```python arr = [3, 6, 8, 10, 1, 2, 1] quicksort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 1, 2, 3, 6, 8, 10] ``` # Notes - Ensure the function modifies the array in place, as this is crucial for the problem constraints. - Make sure to handle edge cases such as empty arrays or arrays with one element.","solution":"from typing import List def quicksort(arr: List[int], low: int, high: int) -> None: Sorts the given list of integers in place using the QuickSort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. low (int): The starting index of the portion of the list to be sorted. high (int): The ending index of the portion of the list to be sorted. if low < high: # Partitioning index pi = partition(arr, low, high) # Recursively sort elements before and after partition quicksort(arr, low, pi - 1) quicksort(arr, pi + 1, high) def partition(arr: List[int], low: int, high: int) -> int: Partitions the array around the pivot (last element) and returns the index of the pivot element. Parameters: arr (List[int]): The list of integers to be partitioned. low (int): The starting index for the partition. high (int): The ending index for the partition (pivot). Returns: int: The index of the pivot element after partitioning. pivot = arr[high] i = low - 1 # index of the smaller element for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1"},{"question":"# Coding Assessment Question: Matrix Flipping **Scenario**: In image processing, certain transformations like flipping can be applied to enhance data augmentation. Your task is to implement a matrix flipping function which flips the matrix horizontally or vertically based on the specified direction. **Objective**: Write a function called `flip_matrix` that accepts a 2-dimensional NumPy array and a string specifying the direction (\'horizontal\' or \'vertical\'). The function should return a new matrix that is flipped in the specified direction. **Function Signature**: ```python def flip_matrix(matrix: np.ndarray, direction: str) -> np.ndarray: pass ``` **Input**: - `matrix` (ndarray): A 2-dimensional NumPy array of integers. - `direction` (str): A string specifying the direction of flip, either \'horizontal\' or \'vertical\'. **Output**: - `ndarray`: A new 2-dimensional array where the elements have been flipped according to the specified direction. **Constraints**: - You must use NumPy for matrix operations. - Assume that the matrix will have at least one element and no dimension will exceed (10^3). - The `direction` input will always be either \'horizontal\' or \'vertical\'. **Performance Requirements**: - The implementation should be efficient, making suitable use of NumPy\'s capabilities. **Example**: ```python import numpy as np matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(flip_matrix(matrix, \'horizontal\')) # Expected output: # array([[3, 2, 1], # [6, 5, 4], # [9, 8, 7]]) matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) print(flip_matrix(matrix, \'vertical\')) # Expected output: # array([[7, 8, 9], # [4, 5, 6], # [1, 2, 3]]) ``` Additionally, ensure your implementation passes the following test: ```python import numpy as np matrix = np.array([[1, 2], [3, 4], [5, 6]]) expected_output_horizontal = np.array([[2, 1], [4, 3], [6, 5]]) expected_output_vertical = np.array([[5, 6], [3, 4], [1, 2]]) np.testing.assert_array_equal(flip_matrix(matrix, \'horizontal\'), expected_output_horizontal) np.testing.assert_array_equal(flip_matrix(matrix, \'vertical\'), expected_output_vertical) ```","solution":"import numpy as np def flip_matrix(matrix: np.ndarray, direction: str) -> np.ndarray: Flips the given matrix in the specified direction. Parameters: matrix (ndarray): A 2-dimensional NumPy array of integers. direction (str): A string specifying the direction of flip, either \'horizontal\' or \'vertical\'. Returns: ndarray: A new 2-dimensional array where the elements have been flipped according to the specified direction. if direction == \'horizontal\': return np.fliplr(matrix) elif direction == \'vertical\': return np.flipud(matrix) else: raise ValueError(\\"Invalid direction. Use \'horizontal\' or \'vertical\'.\\")"},{"question":"# Coding Assessment Question Scenario A certain online grocery store has daily price updates on various items. Each item is associated with a unique product code, and you are given a list of updates representing the item code, date, and new price. Your task is to track the latest price for each product code. The price updates follow the format `[(product_code_1, date_1, new_price_1), (product_code_2, date_2, new_price_2), ..., (product_code_n, date_n, new_price_n)]`, where dates are provided in the \'YYYY-MM-DD\' format and the updates are guaranteed to be in non-decreasing order of the dates. Problem Statement Implement a function `latest_prices(updates: List[Tuple[int, str, int]]) -> Dict[int, int]` that takes a list of updates and returns a dictionary with the product codes as keys and their latest price as the values. Constraints * `1 <= len(updates) <= 10^5` * Each product code will appear at least once in the updates. * Dates are in non-decreasing order within the updates list (i.e., they are sorted). * `0 <= new_price <= 10^5` Input * A list of tuples `updates`, where each tuple contains: - An integer representing the product code (`0 <= product_code <= 10^5`). - A string representing the date in \'YYYY-MM-DD\' format. - An integer representing the new price. Output * A dictionary where the keys are product codes and the values are the latest prices. Example ```python from typing import List, Tuple, Dict def latest_prices(updates: List[Tuple[int, str, int]]) -> Dict[int, int]: # Your implementation here # Example Usages: print(latest_prices([(101, \'2023-01-01\', 100), (102, \'2023-01-03\', 200), (101, \'2023-01-05\', 150)])) # Output: {101: 150, 102: 200} print(latest_prices([(201, \'2023-06-01\', 300), (202, \'2023-06-02\', 400), (201, \'2023-06-04\', 350), (202, \'2023-06-04\', 420)])) # Output: {201: 350, 202: 420} ``` Requirements Ensure that your solution runs efficiently for large lists of updates and use appropriate data structures to handle this.","solution":"from typing import List, Tuple, Dict def latest_prices(updates: List[Tuple[int, str, int]]) -> Dict[int, int]: latest_prices_dict = {} for product_code, date, new_price in updates: latest_prices_dict[product_code] = new_price return latest_prices_dict"},{"question":"# Depth-First Search to Find Cycle in a Graph You are given an undirected graph represented by an adjacency list. Your task is to implement a function that detects if there is any cycle in the graph using Depth-First Search (DFS). If a cycle is found, the function should return `True`, otherwise `False`. # Function Signature ```python def detect_cycle(graph: Dict[int, List[int]]) -> bool: ``` # Input - `graph`: A dictionary where the keys are the nodes, and the values are the lists of connected nodes (adjacency list). # Output - A boolean indicating if there is a cycle in the graph. # Constraints - The graph is non-empty. - Nodes are labeled with integers. - The graph can be disconnected. - The graph can contain any number of nodes and edges. # Example ```python graph1 = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4, 6], 6: [5] } graph2 = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4, 6, 7], 6: [5, 7], 7: [5, 6] } print(detect_cycle(graph1)) # Output: False print(detect_cycle(graph2)) # Output: True ``` # Notes - Use Depth-First Search (DFS) to traverse the graph. - Keep track of visited nodes and the parent node to avoid falsely detecting a cycle. - A cycle is detected if a visited node is encountered that is not the direct parent of the current node.","solution":"def detect_cycle(graph): def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1): return True return False"},{"question":"Question: Calculate and Append Cumulative Sum in a List Write a Python function that takes a list of integers and returns a new list with the cumulative sum of the original list values. # Requirements 1. **Function**: Implement the function `cumulative_sum(data: list[int]) -> list[int]`. 2. **Calculation**: The cumulative sum at each index is the sum of all previous values up to and including the current index. 3. **Edge Cases**: - If the input list is empty, the function should return an empty list. - Ensure the function handles negative integers appropriately. # Input - `data`: A list of integers. # Output - A new list containing the cumulative sum of the input list. # Example Input: ```python data = [1, 2, 3, 4] ``` Output: ```python [1, 3, 6, 10] ``` Input: ```python data = [10, -2, 3, -1, 5] ``` Output: ```python [10, 8, 11, 10, 15] ``` # Additional Notes: - The function should efficiently handle large lists and maintain a time complexity of O(n). # Testing: Include tests to validate the function\'s correctness and efficiency. Ensure to test with both positive and negative integers, as well as edge cases of empty and small-sized lists. ```python def test_cumulative_sum(): assert cumulative_sum([]) == [] assert cumulative_sum([1, 2, 3]) == [1, 3, 6] assert cumulative_sum([10, -2, 3, -1, 5]) == [10, 8, 11, 10, 15] assert cumulative_sum([5]) == [5] ```","solution":"def cumulative_sum(data: list[int]) -> list[int]: Returns a new list containing the cumulative sum of the input list. if not data: return [] cumulative_sums = [data[0]] for i in range(1, len(data)): cumulative_sums.append(cumulative_sums[-1] + data[i]) return cumulative_sums"},{"question":"Coding Assessment Question # Context You are developing a backend for a food delivery service, and you need to manage and update the status of multiple orders efficiently. Each order has a unique ID and a status associated with it. # Task Implement a class to manage and update the orders with efficient lookup and update functionalities. # Class Specifications **Class Name**: `OrderManager` **Attributes and Methods**: 1. **Attribute**: `orders` - **Type**: Dictionary (`Dict[int, str]`) - **Description**: This dictionary will map order IDs to their respective statuses. 2. **Method 1**: `add_order` - **Signature**: `def add_order(self, order_id: int, status: str) -> None` - **Input**: - `order_id` (int): The unique ID of the order. - `status` (str): The initial status of the order. - **Output**: None - **Description**: Adds a new order with the given ID and status to the `orders` dictionary. If the order ID already exists, raises a `ValueError`. 3. **Method 2**: `update_status` - **Signature**: `def update_status(self, order_id: int, new_status: str) -> None` - **Input**: - `order_id` (int): The unique ID of the order to be updated. - `new_status` (str): The new status of the order. - **Output**: None - **Description**: Updates the status of the order identified by `order_id` to `new_status`. If the order ID does not exist, raises a `ValueError`. 4. **Method 3**: `get_status` - **Signature**: `def get_status(self, order_id: int) -> str` - **Input**: - `order_id` (int): The unique ID of the order. - **Output**: - Status (str): The current status of the order. - **Description**: Returns the current status of the order identified by `order_id`. If the order ID does not exist, raises a `ValueError`. # Example Usage ```python # Creating an OrderManager instance manager = OrderManager() # Adding orders manager.add_order(1001, \\"Pending\\") manager.add_order(1002, \\"Preparing\\") # Updating order status manager.update_status(1002, \\"Delivered\\") # Retrieving order status print(manager.get_status(1001)) # Output: \\"Pending\\" print(manager.get_status(1002)) # Output: \\"Delivered\\" ``` # Notes - Assume the order status is always a non-empty string. - Handle edge cases like order ID not existing for updates or retrievals appropriately by raising `ValueError`. - Ensure that operations are performed in constant time where reasonable (`O(1)` for lookups and updates).","solution":"class OrderManager: def __init__(self): self.orders = {} def add_order(self, order_id: int, status: str) -> None: if order_id in self.orders: raise ValueError(\\"Order ID already exists\\") self.orders[order_id] = status def update_status(self, order_id: int, new_status: str) -> None: if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") self.orders[order_id] = new_status def get_status(self, order_id: int) -> str: if order_id not in self.orders: raise ValueError(\\"Order ID does not exist\\") return self.orders[order_id]"},{"question":"# Problem Statement Create a function `replace_words` that takes a list of `strings` and a `phrase`. The function should replace each word in the `phrase` that matches any word in the list of `strings` with asterisks (*), with the number of asterisks equal to the length of the word being replaced. The comparison should be case-insensitive, but the replacement should preserve the original casing. # Requirements 1. **Function to Implement**: `replace_words(strings: List[str], phrase: str) -> str` 2. **Inputs**: - `strings`: A list of words (strings) to be replaced in the phrase. - `phrase`: A string where the replacements should occur. 3. **Outputs**: A string with the appropriate words replaced by asterisks. 4. **Constraints**: - The `strings` and `phrase` will only contain alphabetic characters and spaces. - The function should handle words that are case-insensitive. - The length of each word in `strings` is at most 100. - The length of the `phrase` is at most 10^4. # Example ```python strings = [\\"apple\\", \\"banana\\", \\"Orange\\"] phrase = \\"An Apple a day keeps the doctor away, but not an orange or BANANA.\\" print(replace_words(strings, phrase)) # Output: \\"An ***** a day keeps the doctor away, but not an ****** or ******.\\" ``` # Notes - The case-insensitive comparison means that both \\"Apple\\" and \\"apple\\" match, and so do \\"Banana\\" and \\"banana\\". - The replacement must exactly match the length of the word being replaced with asterisks. - The function should preserve the character casing (upper/lower) of the original words in the phrase when replacing with asterisks.","solution":"from typing import List def replace_words(strings: List[str], phrase: str) -> str: Replace words in the phrase that match any word in the list of strings with asterisks. Args: strings (List[str]): List of words to be replaced in the phrase. phrase (str): The phrase where replacements should occur. Returns: str: The phrase with appropriate words replaced by asterisks. words_to_replace = {word.lower(): word for word in strings} phrase_words = phrase.split(\' \') result = [] for word in phrase_words: clean_word = \'\'.join(filter(str.isalpha, word)) # Remove punctuation lower_case_word = clean_word.lower() if lower_case_word in words_to_replace: asterisks = \'*\' * len(clean_word) replaced_word = word.replace(clean_word, asterisks, 1) result.append(replaced_word) else: result.append(word) return \' \'.join(result)"},{"question":"# Coding Challenge In a data processing system, you often need to perform robust string comparisons, which include ignoring case sensitivity and trimming extra spaces. This is particularly useful when comparing user-generated data, such as form inputs or search queries, to ensure consistency and accuracy in results. Objective Write a function to compare two strings in a case-insensitive manner after removing any leading or trailing whitespace. The function should return `True` if the strings are equivalent and `False` otherwise. Requirements - Implement the function `compare_strings` that takes two strings as input and returns a boolean indicating whether they are equivalent after being normalized (trimmed and converted to lower case). Function Signature ```python def compare_strings(str1: str, str2: str) -> bool: pass ``` Input - `str1`: A string containing any combination of characters. - Example: \\" Hello, World! \\" - `str2`: A string containing any combination of characters. - Example: \\"hello, WORLD!\\" Output - A boolean indicating whether the two strings are equivalent after normalization. Constraints - Both input strings will contain only printable ASCII characters. - The length of each string will not exceed 1000 characters. Example Here is an example of how your function should work: ```python >>> compare_strings(\\" Hello, World! \\", \\"hello, WORLD!\\") True >>> compare_strings(\\"Python \\", \\"python\\") True >>> compare_strings(\\"Python3.8\\", \\"Python3.7\\") False ``` Code Template Use the following template to start your implementation: ```python def compare_strings(str1: str, str2: str) -> bool: normalized_str1 = str1.strip().lower() normalized_str2 = str2.strip().lower() return normalized_str1 == normalized_str2 if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def compare_strings(str1: str, str2: str) -> bool: Compares two strings in a case-insensitive manner after trimming leading and trailing whitespace. Args: str1, str2 (str): Input strings to be compared. Returns: bool: True if the strings are equivalent after normalization, False otherwise. normalized_str1 = str1.strip().lower() normalized_str2 = str2.strip().lower() return normalized_str1 == normalized_str2"},{"question":"# Coding Assessment Question **Scenario**: As a data scientist, you often deal with datasets that require transformation for analysis. One common transformation is compressing strings of characters to their run-length encoding format. **Problem Statement**: Implement a function `run_length_encoding()` that compresses a string using run-length encoding. Run-length encoding is a simple form of data compression where consecutive occurrences of the same character are replaced by one occurrence of that character followed by the number of occurrences. Function Signature ```python def run_length_encoding(s: str) -> str: # Implementation here ``` Input & Output Formats - **Input**: A string `s` where (0 leq text{len}(s) leq 10^5) consisting of only uppercase and lowercase English letters. - **Output**: A compressed string using run-length encoding. Constraints - You must handle both uppercase and lowercase letters. - If a character appears only once consecutively, it should appear in the output without a following number. Examples ```python >>> run_length_encoding(\\"aaabbc\\") \'a3b2c\' >>> run_length_encoding(\\"a\\") \'a\' >>> run_length_encoding(\\"abbccccccde\\") \'a1b2c6d1e1\' # The 1s are optional; \'ab2c6de\' is also acceptable. >>> run_length_encoding(\\"\\") \'\' >>> run_length_encoding(\\"XYZ\\") \'X1Y1Z1\' # The 1s are optional; \'XYZ\' is also acceptable. ``` Notes - Handle edge cases like an empty string and strings with a single character. - Ensure that the result is a string efficiently compressed as per the run-length encoding rules but maintains readability.","solution":"def run_length_encoding(s: str) -> str: if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{current_char}{count if count > 1 else \'\'}\\") current_char = char count = 1 encoded_str.append(f\\"{current_char}{count if count > 1 else \'\'}\\") return \'\'.join(encoded_str)"},{"question":"# Coding Question **Rearrange Array Alternately** Given a sorted array of positive integers, rearrange the elements in such a way that the first element is the maximum value, the second element is the minimum value, the third element is the second maximum value, and so on. Write a function that performs this rearrangement in place. **Function Signature**: ```python def rearrange_alternately(arr: List[int]) -> List[int]: Rearrange a sorted array alternately such that the pattern is: - max, min, 2nd max, 2nd min, and so on. Parameters: - arr (List[int]): A sorted list of positive integers. Returns: - List[int]: The rearranged list of integers. Example: >>> rearrange_alternately([1, 2, 3, 4, 5, 6, 7, 8, 9]) [9, 1, 8, 2, 7, 3, 6, 4, 5] ``` # Constraints * The input list will have at least one element and at most `10^6` elements. * All elements in the array are positive integers. * The array is initially sorted in non-decreasing order. # Input and Output * **Input**: A list of integers in non-decreasing order. * **Output**: A list of integers rearranged as specified. # Evaluation Criteria * Correctness: The function must accurately rearrange the elements as specified. * Efficiency: The solution should be optimized for large lists. * Readability: The code should be well-structured and easy to read. # Example ```python assert rearrange_alternately([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [9, 1, 8, 2, 7, 3, 6, 4, 5] assert rearrange_alternately([10, 20, 30, 40, 50]) == [50, 10, 40, 20, 30] ```","solution":"def rearrange_alternately(arr): Rearrange a sorted array alternately such that the pattern is: - max, min, 2nd max, 2nd min, and so on. Parameters: - arr (List[int]): A sorted list of positive integers. Returns: - List[int]: The rearranged list of integers. n = len(arr) result = [0] * n # Pointers for max and min elements max_idx = n - 1 min_idx = 0 # Use flag to switch between max and min flag = True for i in range(n): if flag: result[i] = arr[max_idx] max_idx -= 1 else: result[i] = arr[min_idx] min_idx += 1 flag = not flag return result"},{"question":"# Coding Question **Scenario:** In a customer loyalty program, customers earn points based on their purchases. For a given customer, you need to analyze their transaction history to determine the frequency of their purchases and categorize them accordingly into loyalty tiers. The tiers are defined as follows: - \\"Bronze\\" for customers with 1-10 transactions. - \\"Silver\\" for customers with 11-20 transactions. - \\"Gold\\" for customers with 21-50 transactions. - \\"Platinum\\" for customers with more than 50 transactions. # Problem Statement: You are provided with a list of transaction records, where each record is a unique customer identifier. Write a function `loyalty_tier(customers: list[int]) -> dict[int, str]` that categorizes each customer into one of the loyalty tiers based on the number of their transactions. # Input: - A list of integers `customers` where each integer represents a customer identifier (1 <= len(customers) <= 10^6). # Output: - A dictionary where keys are customer identifiers and values are loyalty tiers (\\"Bronze\\", \\"Silver\\", \\"Gold\\", \\"Platinum\\"). # Constraints: - Each input element is a valid integer representing a customer identifier. - The list can contain up to 10^6 transactions but will fit into memory. # Example: ```python >>> loyalty_tier([1, 1, 2, 3, 1, 2, 3, 3]) {1: \'Bronze\', 2: \'Bronze\', 3: \'Bronze\'} >>> loyalty_tier([4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) {4: \'Bronze\', 2: \'Silver\'} >>> loyalty_tier([5, 6, 6, 6, 6, 6, 6, 6, 6, 1]) {5: \'Bronze\', 6: \'Bronze\', 1: \'Bronze\'} >>> loyalty_tier([7]*51) {7: \'Platinum\'} >>> loyalty_tier([]) {} ``` # Detailed Steps: 1. Use the `Counter` from the `collections` module to count the number of transactions for each customer. 2. Create a dictionary to map each customer to their loyalty tier based on their transaction count. 3. Return the dictionary with customers categorized into the appropriate tiers. # Notes: - Ensure the code efficiently handles large transaction lists. - Ensure correct categorization even if there are customers with no transactions.","solution":"from collections import Counter def loyalty_tier(customers): Categorizes customers into loyalty tiers based on their transaction frequency. Parameters: customers (list[int]): A list of customer identifiers. Returns: dict[int, str]: A dictionary mapping customer identifiers to their loyalty tiers. customer_counts = Counter(customers) tiers = {} for customer, count in customer_counts.items(): if count <= 10: tiers[customer] = \\"Bronze\\" elif count <= 20: tiers[customer] = \\"Silver\\" elif count <= 50: tiers[customer] = \\"Gold\\" else: tiers[customer] = \\"Platinum\\" return tiers"},{"question":"# Coding Assessment: Binary Search Tree (BST) Level Order Traversal Problem Statement: You are tasked to implement a level-order traversal for a Binary Search Tree (BST). The level-order traversal traverses each level of the BST from top to bottom and from left to right within each level. Your implementation should: * Construct the BST from a given list of integers. * Perform the level-order traversal and return a list of lists, where each inner list represents the nodes at a particular level. Function Signature Implement the function `bst_level_order_traversal(values: List[int]) -> List[List[int]]` where: * `values`: A list of integers representing node values to be inserted into the BST in the given order. The function should return a list of lists: * Each list represents the node values at a particular level. Constraints: * The number of elements in `values` can be up to 1000. * The values can include duplicate integers. * Node values are within the range -1000 to 1000. Example ```python # Example Input values = [10, 5, 15, 3, 7, 12, 18] # Example Output result = bst_level_order_traversal(values) # Output result => [[10], [5, 15], [3, 7, 12, 18]] ``` Instructions: 1. Implement the `Node` class with attributes `value`, `left`, and `right`. 2. Implement the `BST` class with methods to insert nodes and perform level-order traversal. 3. Return the required results in the specific format.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, current_node: Node, value: int): if value <= current_node.value: if current_node.left is None: current_node.left = Node(value) else: self._insert(current_node.left, value) else: if current_node.right is None: current_node.right = Node(value) else: self._insert(current_node.right, value) def level_order_traversal(self) -> List[List[int]]: if self.root is None: return [] result = [] queue = deque([self.root]) while queue: level_size = len(queue) current_level = [] for i in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result def bst_level_order_traversal(values: List[int]) -> List[List[int]]: bst = BST() for value in values: bst.insert(value) return bst.level_order_traversal()"},{"question":"You are given a list of integers representing the heights of buildings in a city from left to right. Your task is to implement an algorithm to find the maximum area of a rectangle that can be formed between the buildings assuming each building can only be reduced in height to the height of the shortest building in the chosen range. # Function Signature ```python def maxRectangleArea(heights: list[int]) -> int: pass ``` # Input - `heights`: A list of integers (1 ≤ len(heights) ≤ 10^5; 0 ≤ heights[i] ≤ 10^9 for all integers in `heights`). # Output - Return an integer representing the maximum area of a rectangle that fits between the buildings. # Constraints 1. Your implementation should strive to achieve an optimal time complexity suitable for large datasets. 2. Ensure you efficiently handle scenarios where all buildings have the same height, and where buildings have significantly varying heights. 3. Minimize use of additional space wherever possible. # Examples ```python assert maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10 # Maximum rectangle area between buildings is 2x5 or 1x6: 10 assert maxRectangleArea([2, 4]) == 4 # Only one rectangle of area 2x2 or 4x1 assert maxRectangleArea([6, 2, 5, 4, 5, 1, 6]) == 12 # Maximum rectangle area between buildings is 3x4: 12 assert maxRectangleArea([1, 2, 3, 4, 5]) == 9 # Maximum rectangle area between buildings is 3x3 or 5x1: 9 assert maxRectangleArea([5, 5, 5, 5]) == 20 # Only one rectangle of area 5x4: 20 ``` # Additional Notes 1. In the example [2, 1, 5, 6, 2, 3], the rectangle of height 2 spanning indices [2, 0, 1, 5, 4, 3] forms the area 2x5 = 10. 2. In the example [6, 2, 5, 4, 5, 1, 6], the rectangle of height 4 spanning indices [2, 4, 3, 6] forms the area 4x3 = 12. 3. Consider how you might implement a stack-based or other optimized approach to solve this problem efficiently for large inputs.","solution":"def maxRectangleArea(heights: list[int]) -> int: Returns the maximum area of a rectangle made from the histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Matrix Operations with Special Conditions In this exercise, you will implement a class `SpecialMatrix` to manage and perform operations on matrices with special conditions. A matrix is represented by its number of rows and columns, as well as a list of lists containing the matrix elements. Task Implement the following methods for the `SpecialMatrix` class: 1. **Initialization (`__init__`)**: - Initializes a matrix with given rows, columns, and elements. Raise a `ValueError` if the number of elements does not match the number of rows * columns. 2. **Addition (`__add__`)**: - Adds two matrices of the same dimension. Raise a `ValueError` if the dimensions do not match. 3. **Subtraction (`__sub__`)**: - Subtracts one matrix from another of the same dimension. Raise a `ValueError` if the dimensions do not match. 4. **Transpose (`transpose`)**: - Transposes the matrix and returns the new matrix. 5. **Multiplication (`__mul__`)**: - Multiplies two matrices if compatible dimensions (i.e., columns of the first matrix should match rows of the second matrix), else raise a `ValueError`. 6. **Determinant (`determinant`)**: - Calculates and returns the determinant of a square matrix. Raise a `ValueError` if the matrix is not square. 7. **Scaling (`scale`)**: - Scales the matrix by a given constant and returns the new matrix. 8. **Identity (`identity`)**: - Returns an identity matrix of a given size n (n x n). 9. **Equality (`__eq__`)**: - Compares two matrices for equality. 10. **Inequality (`__ne__`)**: - Compares two matrices for inequality. Input and Output Formats - **Input**: - Initialization: `SpecialMatrix(rows: int, columns: int, elements: List[List[float]])` - Operations: As per operator overloading for `+`, `-`, `*`; and methods for `transpose`, `determinant`, `scale`, `identity`, `__eq__`, and `__ne__`. - **Output**: - Returns new `SpecialMatrix` instances or results as specified by the operations. Example ```python # Initialization m1 = SpecialMatrix(2, 2, [[1, 2], [3, 4]]) m2 = SpecialMatrix(2, 2, [[5, 6], [7, 8]]) # Addition print(m1 + m2) # Should output: [[6, 8], [10, 12]] # Subtraction print(m1 - m2) # Should output: [[-4, -4], [-4, -4]] # Transpose print(m1.transpose()) # Should output: [[1, 3], [2, 4]] # Multiplication print(m1 * m2) # Should output: [[19, 22], [43, 50]] # Determinant print(m1.determinant()) # Should output: -2 # Scaling print(m1.scale(2)) # Should output: [[2, 4], [6, 8]] # Identity print(SpecialMatrix.identity(3)) # Should output: [[1, 0, 0], [0, 1, 0], [0, 0, 1]] # Equality and Inequality print(m1 == SpecialMatrix(2, 2, [[1, 2], [3, 4]])) # Should output: True print(m1 != SpecialMatrix(2, 2, [[1, 2], [3, 4]])) # Should output: False ```","solution":"class SpecialMatrix: def __init__(self, rows, columns, elements): if len(elements) != rows or any(len(row) != columns for row in elements): raise ValueError(\\"Number of elements does not match given dimensions.\\") self.rows = rows self.columns = columns self.elements = elements def __add__(self, other): if self.rows != other.rows or self.columns != other.columns: raise ValueError(\\"Matrix dimensions do not match for addition.\\") result = [[self.elements[i][j] + other.elements[i][j] for j in range(self.columns)] for i in range(self.rows)] return SpecialMatrix(self.rows, self.columns, result) def __sub__(self, other): if self.rows != other.rows or self.columns != other.columns: raise ValueError(\\"Matrix dimensions do not match for subtraction.\\") result = [[self.elements[i][j] - other.elements[i][j] for j in range(self.columns)] for i in range(self.rows)] return SpecialMatrix(self.rows, self.columns, result) def transpose(self): result = [[self.elements[j][i] for j in range(self.rows)] for i in range(self.columns)] return SpecialMatrix(self.columns, self.rows, result) def __mul__(self, other): if self.columns != other.rows: raise ValueError(\\"Matrix dimensions do not match for multiplication.\\") result = [] for i in range(self.rows): row = [] for j in range(other.columns): sum_product = sum(self.elements[i][k] * other.elements[k][j] for k in range(self.columns)) row.append(sum_product) result.append(row) return SpecialMatrix(self.rows, other.columns, result) def determinant(self): if self.rows != self.columns: raise ValueError(\\"Determinant can only be calculated for square matrices.\\") if self.rows == 1: return self.elements[0][0] if self.rows == 2: return self.elements[0][0] * self.elements[1][1] - self.elements[0][1] * self.elements[1][0] def get_minor(matrix, row, col): minor = [r[:col] + r[col + 1:] for r in (matrix[:row] + matrix[row + 1:])] return minor determinant = 0 for c in range(len(self.elements)): determinant += ((-1) ** c) * self.elements[0][c] * SpecialMatrix(self.rows - 1, self.columns - 1, get_minor(self.elements, 0, c)).determinant() return determinant def scale(self, constant): result = [[element * constant for element in row] for row in self.elements] return SpecialMatrix(self.rows, self.columns, result) @staticmethod def identity(n): result = [[1 if i == j else 0 for j in range(n)] for i in range(n)] return SpecialMatrix(n, n, result) def __eq__(self, other): return self.elements == other.elements def __ne__(self, other): return not self == other def __repr__(self): return f\\"SpecialMatrix({self.rows}, {self.columns}, {self.elements})\\""},{"question":"# Problem Statement You are tasked with writing a function `merge_sorted_lists` that accepts two sorted lists and merges them into a single sorted list. The function should return the merged sorted list without using any built-in sorting functions. # Input and Output Formats Input: * `list_a` (list): A list of integers sorted in ascending order. * `list_b` (list): Another list of integers sorted in ascending order. Output: * A list that contains all elements from `list_a` and `list_b`, sorted in ascending order. # Constraints: * Both `list_a` and `list_b` contain only integers (positive, negative, and zero). * The maximum size of each list is (10^3). # Performance Requirements: * Your implementation should efficiently merge the lists with a time complexity of O(n + m), where n and m are the lengths of `list_a` and `list_b`, respectively. # Examples: ```python >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([-1, 0, 1], [-2, 2]) [-2, -1, 0, 1, 2] ``` # Additional Test Case: ```python >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5, 6], []) [4, 5, 6] ``` # Edge Cases: 1. Both lists are empty: ```python >>> merge_sorted_lists([], []) [] ``` # Implementation Requirements: * Ensure that both inputs are lists, otherwise raise an `AssertionError`. * Merge the lists without using any built-in sort functionality. # Specifications: 1. If either or both input lists are empty, the function should return the non-empty list (or an empty list if both are empty). 2. The function should maintain the order of elements, respecting the initial sort order of the inputs.","solution":"def merge_sorted_lists(list_a, list_b): Merges two sorted lists into a single sorted list. Parameters: list_a (list): A list of integers sorted in ascending order. list_b (list): Another list of integers sorted in ascending order. Returns: list: A merged list sorted in ascending order. # Ensure inputs are list assert isinstance(list_a, list), \\"Expected list, got {}\\".format(type(list_a)) assert isinstance(list_b, list), \\"Expected list, got {}\\".format(type(list_b)) i, j = 0, 0 result = [] # Merge the two lists while i < len(list_a) and j < len(list_b): if list_a[i] < list_b[j]: result.append(list_a[i]) i += 1 else: result.append(list_b[j]) j += 1 # Add any remaining elements from list_a while i < len(list_a): result.append(list_a[i]) i += 1 # Add any remaining elements from list_b while j < len(list_b): result.append(list_b[j]) j += 1 return result"},{"question":"# Coding Assessment Question **Scenario**: You are developing a feature for a web application\'s backend service that logs user activities. The feature should analyze the log to provide meaningful insights into user engagement and usage patterns. **Problem Description**: Write a function `summarize_user_log` that processes a log of user activities and returns a summary of the activities. The summary should include the total number of activities, the unique users that performed those activities, and a count of each type of activity performed. # Function Signature ```python def summarize_user_log(log: List[Tuple[str, str]]) -> Dict[str, Any]: pass ``` # Input - **log** (List[Tuple[str, str]]): A list of tuples where each tuple contains two strings. The first string is a user identifier (e.g., \\"user1\\"), and the second string is an activity (e.g., \\"login\\"). # Output - **Dict[str, Any]**: A dictionary with the following structure: - `\\"total_activities\\"` (int): The total number of activities in the log. - `\\"unique_users\\"` (List[str]): A list of unique users who performed the activities. - `\\"activity_counts\\"` (Dict[str, int]): A dictionary where the keys are activity types and the values are the counts of those activities. # Constraints - The length of the log will not exceed 10^4 entries. - Each user identifier and activity string will be at most 20 characters long. - The log will be non-empty. # Example Given the log: ```python log = [ (\\"user1\\", \\"login\\"), (\\"user2\\", \\"view\\"), (\\"user1\\", \\"view\\"), (\\"user1\\", \\"logout\\"), (\\"user3\\", \\"login\\"), (\\"user2\\", \\"logout\\") ] ``` Calling `summarize_user_log(log)` should return: ```python { \\"total_activities\\": 6, \\"unique_users\\": [\\"user1\\", \\"user2\\", \\"user3\\"], \\"activity_counts\\": { \\"login\\": 2, \\"view\\": 2, \\"logout\\": 2 } } ``` # Specific Requirements 1. **Function Implementation**: Only the function definition and logic should be implemented. 2. **Performance**: The function should operate efficiently given the constraints. 3. **Edge Case Handling**: Ensure to handle cases like empty logs or logs with repetitive activities gracefully.","solution":"from typing import List, Tuple, Dict, Any def summarize_user_log(log: List[Tuple[str, str]]) -> Dict[str, Any]: Process a log of user activities and return a summary. Args: log (List[Tuple[str, str]]): A list of tuples where each tuple contains a user identifier and an activity type. Returns: Dict[str, Any]: A dictionary containing the total number of activities, a list of unique users, and a dictionary with activity counts. total_activities = len(log) unique_users = set() activity_counts = {} for user, activity in log: unique_users.add(user) if activity in activity_counts: activity_counts[activity] += 1 else: activity_counts[activity] = 1 return { \\"total_activities\\": total_activities, \\"unique_users\\": list(unique_users), \\"activity_counts\\": activity_counts }"},{"question":"# Binary Tree Traversals You are required to implement methods for different types of tree traversals on a binary tree. Specifically, you need to implement methods for in-order traversal, pre-order traversal, and post-order traversal. **Function Signatures**: 1. `in_order_traversal(root: TreeNode) -> List[int]` 2. `pre_order_traversal(root: TreeNode) -> List[int]` 3. `post_order_traversal(root: TreeNode) -> List[int]` **Implementation Details**: 1. **in_order_traversal(root)**: * This function should take the root node of a binary tree. * It should return a list of integers representing the in-order traversal of the tree. 2. **pre_order_traversal(root)**: * This function should take the root node of a binary tree. * It should return a list of integers representing the pre-order traversal of the tree. 3. **post_order_traversal(root)**: * This function should take the root node of a binary tree. * It should return a list of integers representing the post-order traversal of the tree. **Constraints**: * The tree\'s nodes contain integer values. * The functions should correctly handle an empty tree (i.e., when the root is `None`). **Example**: ```python # Assuming TreeNode class and associated methods are already defined as below. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example binary tree # 1 # / # 2 3 # / # 4 5 # Create the tree nodes root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Test in_order_traversal function in_order = in_order_traversal(root) print(in_order) # Should print [4, 2, 5, 1, 3] # Test pre_order_traversal function pre_order = pre_order_traversal(root) print(pre_order) # Should print [1, 2, 4, 5, 3] # Test post_order_traversal function post_order = post_order_traversal(root) print(post_order) # Should print [4, 5, 2, 3, 1] ``` # Edge Cases: * Ensure each traversal method handles the case where the binary tree is empty (i.e., the root is `None`). * Check that the methods correctly traverse trees with varying structures, such as perfectly balanced trees, completely skewed trees, etc. Implement these tree traversal methods to enhance your understanding of binary trees and their traversal techniques.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(root: TreeNode) -> list: result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result def pre_order_traversal(root: TreeNode) -> list: result = [] def traverse(node): if node: result.append(node.val) traverse(node.left) traverse(node.right) traverse(root) return result def post_order_traversal(root: TreeNode) -> list: result = [] def traverse(node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Question: Implement a Function to Find the Intersection of Two Sorted Arrays You are given two sorted lists of integers. Your task is to implement a function that finds the intersection of these two lists and returns a new list containing the common elements in sorted order. **Input**: 1. A sorted list of integers, `list1`. 2. A sorted list of integers, `list2`. **Output**: - A list of integers representing the intersection of `list1` and `list2`. **Function Signature**: ```python def find_intersection(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Constraints: 1. Each input list will contain at most 10^6 elements. 2. All elements of both lists are distinct integers. # Example: ```python >>> find_intersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7]) [3, 4, 5] >>> find_intersection([0, 1, 2, 8, 13], [2, 13, 42]) [2, 13] >>> find_intersection([], [1, 2, 3]) [] >>> find_intersection([5], [5]) [5] >>> find_intersection([-10, -3, 0, 7, 23, 45], [-3, 7, 23]) [-3, 7, 23] ``` # Explanation: - The first example returns `[3, 4, 5]` because these elements are common to both lists. - The second example returns `[2, 13]` because these elements are common to both lists. - The third example returns `[]` because the first list is empty. - The fourth example returns `[5]` because that is the only element in both lists. - The fifth example returns `[-3, 7, 23]` because these elements are common to both lists. Your implementation should be optimized for time complexity and should handle the constraints efficiently. Ensure to test your function with various edge cases to validate its correctness.","solution":"def find_intersection(list1: list[int], list2: list[int]) -> list[int]: Returns a sorted list of the intersection elements of list1 and list2. i, j = 0, 0 intersection = [] while i < len(list1) and j < len(list2): if list1[i] == list2[j]: intersection.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return intersection"},{"question":"# Problem Statement: You are provided with a simple calculator tool that should perform operations on a sequence of numbers based on a string input. The calculator supports basic arithmetic operations: addition, subtraction, multiplication, and division. However, there are certain edge cases and performance issues that need to be addressed. # Requirements: 1. **Refactor the given functions** to handle the following edge cases and optimize their performance: - Strings with invalid characters or whitespace. - Division by zero. - Long operations involving a large number of numbers. 2. **Optimize the `calculate_expression` function** to efficiently parse and compute the result for large expressions. # Function Signature: ```python def calculate_expression(expression: str) -> float: ``` # Input: - **Expression**: A string containing a sequence of numbers and operators separated by spaces. The supported operators are `+`, `-`, `*`, and `/`. # Output: - Returns the computed result as a float. # Constraints: - The input string length will not exceed 10,000 characters. - Numbers in the expression are integers or floats. - The result should be rounded to two decimal places. # Examples: ```python assert calculate_expression(\\"3 + 5\\") == 8.0 assert calculate_expression(\\"10 + 2 * 6\\") == 22.0 assert calculate_expression(\\"100 * 2 + 12\\") == 212.0 assert calculate_expression(\\"100 * ( 2 + 12 )\\") == 1400.0 assert calculate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100.0 ``` # Notes: - Ensure your solution correctly handles edge cases, such as invalid input formats and division by zero. - Use efficient parsing and computation techniques for large expressions. - Avoid altering the function signature. - You may add helper functions if needed but ensure they follow the required logic and constraints.","solution":"import re def calculate_expression(expression: str) -> float: Evaluates a mathematical expression string and returns the result as a float. Parameters: expression (str): The string containing the mathematical expression. Returns: float: The result of the evaluated expression. # Remove unnecessary whitespace expression = expression.strip() # Check for invalid characters using regular expression # Valid characters are digits, operators (+, -, *, /), parentheses, spaces and periods for decimal numbers. if not re.match(r\'^[0-9+-*/(). ]+\', expression): raise ValueError(\\"Invalid characters in expression\\") try: result = eval(expression) return round(float(result), 2) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero occurred in the expression\\") except Exception as e: raise ValueError(f\\"Invalid expression: {e}\\")"},{"question":"# Problem Statement You are given a list of integers representing prices of items in a store and an integer `k`, where `k` is the maximum number of items you can choose from the list. You need to find the maximum profit you can make by selecting `k` items whose prices sum up to the maximum possible value without exceeding `k`. Implement a function `max_profit(prices: List[int], k: int) -> int` that returns the maximum profit you can make. Input * A list of integers `prices` (1 ≤ len(prices) ≤ 10^5, 1 ≤ prices[i] ≤ 10^4) representing the prices of items in the store. * An integer `k` (1 ≤ k ≤ len(prices)) representing the maximum items you can choose. Output * An integer representing the maximum profit. Constraints * Consider that you cannot exceed choosing more than `k` items. * The function should be efficient in terms of time complexity. # Example ```python def max_profit(prices: List[int], k: int) -> int: # Your implementation here # Example prices = [34, 56, 23, 87, 72, 76, 45] k = 3 result = max_profit(prices, k) print(result) # Output should be 235 (87 + 72 + 76) ``` # Notes - The function you design should handle large lists of prices efficiently. - Ensure to check edge cases like `k` equal to 1 or equal to the length of the prices list. - You need to select `k` items such that their prices do not exceed the limit of `k`.","solution":"from typing import List def max_profit(prices: List[int], k: int) -> int: Returns the maximum profit by selecting k items with maximum possible prices. # Sort prices in descending order prices.sort(reverse=True) # Sum the top k prices return sum(prices[:k])"},{"question":"# Text Data Preprocessing for Sentiment Analysis You are tasked with implementing a pipeline that handles text data pre-processing, model training, and evaluation for sentiment analysis. Using the given IMDB movie reviews dataset, your job is to clean the text data, transform it into a suitable format for machine learning, train a logistic regression model, and evaluate its performance. Function Specifications 1. **clean_text(text: str) -> str**: - **Input**: A string containing a movie review. - **Output**: A cleaned version of the input string with lowercasing, removal of punctuation, and any other necessary text normalization. 2. **vectorize_text(reviews: List[str]) -> Tuple[csr_matrix, CountVectorizer]**: - **Input**: A list of cleaned movie review strings. - **Output**: A tuple containing the transformed review features as a sparse matrix and the fitted `CountVectorizer` object. 3. **train_model(features: csr_matrix, labels: np.ndarray) -> LogisticRegression**: - **Input**: - `features`: sparse matrix of shape `(n_samples, n_features)` representing the vectorized text data. - `labels`: numpy array of shape `(n_samples,)` containing binary sentiment labels (0 for negative and 1 for positive). - **Output**: Trained `LogisticRegression` model. 4. **evaluate_model(model: LogisticRegression, features: csr_matrix, labels: np.ndarray) -> dict**: - **Input**: - `model`: Trained LogisticRegression model. - `features`: sparse matrix of shape `(n_samples, n_features)`. - `labels`: numpy array of shape `(n_samples,)`. - **Output**: Dictionary containing model performance metrics such as accuracy, precision, recall, and F1-score. Additional Requirements - Ensure `clean_text` adequately handles typical issues in text data such as case sensitivity, punctuation, and stop words. - The `vectorize_text` function should utilize `CountVectorizer` from the scikit-learn library. - Use appropriate metrics to evaluate the model\'s performance and ensure robustness through cross-validation. - Your final performance evaluation should include a confusion matrix. # Example ```python # Expected usage example: # Sample reviews and their corresponding sentiment labels reviews = [\\"I loved this movie, it was fantastic!\\", \\"The film was boring and I hated it.\\", ...] labels = np.array([1, 0, ...]) # Clean the text data cleaned_reviews = [clean_text(review) for review in reviews] # Vectorize the cleaned text data features, vectorizer = vectorize_text(cleaned_reviews) # Split data into training and test sets x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.25, random_state=42) # Train the model model = train_model(x_train, y_train) # Evaluate model performance on the test set metrics = evaluate_model(model, x_test, y_test) print(f\\"Model Performance: {metrics}\\") ``` # Constraints - Assume the dataset is correctly formatted for processing. - Your solution should be efficient and capable of handling large text datasets. - Adhere to clean coding practices and provide appropriate documentation and comments. # Dataset The IMDB dataset can be obtained via `from sklearn.datasets import load_files`: ```python from sklearn.datasets import load_files imdb_data = load_files(\'aclImdb\', categories=[\'pos\', \'neg\'], shuffle=True) reviews = imdb_data.data labels = imdb_data.target ```","solution":"import re from typing import List, Tuple, Any from sklearn.feature_extraction.text import CountVectorizer from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix from scipy.sparse import csr_matrix import numpy as np def clean_text(text: str) -> str: Cleans the input text by lowercasing, removing punctuation and non-alphabetic characters. Args: - text (str): Input string containing a movie review. Returns: - str: Cleaned version of the input string. text = text.lower() text = re.sub(r\'<.*?>\', \'\', text) text = re.sub(r\'[^ws]\', \'\', text) text = re.sub(r\'d+\', \'\', text) return text.strip() def vectorize_text(reviews: List[str]) -> Tuple[csr_matrix, CountVectorizer]: Vectorizes the list of cleaned movie review strings using CountVectorizer. Args: - reviews (List[str]): List of cleaned movie review strings. Returns: - Tuple[csr_matrix, CountVectorizer]: A tuple containing the transformed review features as a sparse matrix and the fitted CountVectorizer object. vectorizer = CountVectorizer(stop_words=\'english\') features = vectorizer.fit_transform(reviews) return features, vectorizer def train_model(features: csr_matrix, labels: np.ndarray) -> LogisticRegression: Trains a Logistic Regression model using the given features and labels. Args: - features (csr_matrix): Sparse matrix of shape (n_samples, n_features) containing the vectorized text data. - labels (np.ndarray): Numpy array of shape (n_samples,) containing binary sentiment labels (0 for negative, 1 for positive). Returns: - LogisticRegression: Trained LogisticRegression model. model = LogisticRegression() model.fit(features, labels) return model def evaluate_model(model: LogisticRegression, features: csr_matrix, labels: np.ndarray) -> dict: Evaluates the trained Logistic Regression model Args: - model (LogisticRegression): Trained Logistic Regression model. - features (csr_matrix): Sparse matrix of shape (n_samples, n_features). - labels (np.ndarray): Numpy array of shape (n_samples,) containing binary sentiment labels (0 for negative, 1 for positive). Returns: - dict: Dictionary containing model performance metrics such as accuracy, precision, recall, and F1-score. predictions = model.predict(features) accuracy = accuracy_score(labels, predictions) precision = precision_score(labels, predictions) recall = recall_score(labels, predictions) f1 = f1_score(labels, predictions) conf_matrix = confusion_matrix(labels, predictions) return { \'accuracy\': accuracy, \'precision\': precision, \'recall\': recall, \'f1_score\': f1, \'confusion_matrix\': conf_matrix }"},{"question":"# String Compression Create a function that takes a string as an input and returns a compressed version of the string using run-length encoding. If the compressed string is not shorter than the original string, the function should return the original string. Run-length encoding is a basic form of data compression in which consecutive repeated characters are replaced with the character followed by the number of repetitions. Function Signature ```python def compress_string(s: str) -> str: Compresses the given string using run-length encoding. If the compressed string is not shorter than the original string, returns the original string. Args: s: The string to compress. Returns: The compressed string or the original string if compression does not reduce the size. Example: >>> compress_string(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> compress_string(\\"abcdef\\") \'abcdef\' >>> compress_string(\\"aa\\") \'a2\' # Your code goes here ``` Input and Output * **Input**: - `s` (str): The string to compress. * **Output**: - Return the compressed string using run-length encoding or the original string if the compressed version is not shorter. Constraints * All characters in the input string `s` are lowercase English letters (a-z). * The length of the input string will not exceed 1000 characters. Performance Requirements * The function should process the input string in linear time relative to its length.","solution":"def compress_string(s: str) -> str: Compresses the given string using run-length encoding. If the compressed string is not shorter than the original string, returns the original string. Args: s: The string to compress. Returns: The compressed string or the original string if compression does not reduce the size. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Finding Missing Number in an Arithmetic Progression Context: You are working on some mathematical problems related to sequences. One common sequence you encounter is an arithmetic progression (AP). An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant. However, in your problem set, one term is always missing from the sequence, and you need to find it. Task: Write a function `find_missing_ap(sequence: list[int]) -> int` that finds the missing number from a given arithmetic progression. The input is a list of integers representing the AP with one term missing, and the function should return the missing term. Input: * A list of integers `sequence` where the length of the list is `n` (n >= 3). Output: * An integer representing the missing term in the AP. Example: ```python def find_missing_ap(sequence: list[int]) -> int: Example usage: >>> find_missing_ap([1, 4, 7, 10, 13, 19]) 16 >>> find_missing_ap([3, 6, 12, 15]) 9 ``` Constraints: * The length of the input list `sequence` will be at least 3. * The missing number is guaranteed to be such that the sequence remains a valid AP if the missing number were inserted. * The first and last numbers of the list are always present and correct. **Edge Cases to Consider**: * Ensure the function handles a variety of AP sequences, including both positive and negative differences. * The function should correctly identify the missing term even if it is near the start or end of the sequence. Requirements: * Make sure your function correctly handles all valid and edge case inputs. * Ensure the output is the actual missing term that would make the sequence a valid AP if inserted.","solution":"def find_missing_ap(sequence: list[int]) -> int: Finds the missing number from a given arithmetic progression. Args: sequence (list[int]): The arithmetic progression with one term missing. Returns: int: The missing term in the progression. # Calculate the common difference using the first and last terms n = len(sequence) total_sum = (n + 1) * (sequence[0] + sequence[-1]) // 2 return total_sum - sum(sequence)"},{"question":"Problem Statement You have been given a task to implement a `CircularBuffer` class that represents a cyclic buffer or ring buffer. A circular buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. When the buffer is full, subsequent writes wrap around to the beginning of the buffer and overwrite the old data. # Requirements: 1. **enqueue(self, value: int) -> None**: - This method should add an item to the buffer. If the buffer is full, it should overwrite the oldest item. 2. **dequeue(self) -> int**: - This method should remove and return the oldest item from the buffer. If the buffer is empty, it should raise an `IndexError` with the message \\"Buffer is empty\\". 3. **peek(self) -> int**: - This method should return the oldest item from the buffer without removing it. If the buffer is empty, it should raise an `IndexError` with the message \\"Buffer is empty\\". 4. **is_empty(self) -> bool**: - This method should return `True` if the buffer is empty, otherwise `False`. 5. **is_full(self) -> bool**: - This method should return `True` if the buffer is full, otherwise `False`. # Constraints 1. `CircularBuffer` should be initialized with a positive integer to define the buffer\'s capacity. 2. Implement the circular buffer operations using a list and integer indices to manage the start and end of the buffer. Do not use any pre-built data structures like `deque`. # Expected Input and Output Format * The `enqueue` method takes an integer `value` as an input. * The `dequeue` and `peek` methods have no inputs other than `self`. * The `is_empty` and `is_full` methods have no inputs other than `self`. * The `enqueue` method returns `None`. * The `dequeue` and `peek` methods return the integer value as the output or raise an `IndexError`. * The `is_empty` and `is_full` methods return boolean values. # Example ```python >>> buffer = CircularBuffer(3) >>> buffer.is_empty() True >>> buffer.enqueue(1) >>> buffer.enqueue(2) >>> buffer.enqueue(3) >>> buffer.is_full() True >>> buffer.peek() 1 >>> buffer.dequeue() 1 >>> buffer.is_empty() False >>> buffer.enqueue(4) >>> buffer.peek() 2 >>> buffer.dequeue() 2 >>> buffer.dequeue() 3 >>> buffer.peek() 4 >>> buffer.dequeue() 4 >>> buffer.is_empty() True >>> buffer.dequeue() Traceback (most recent call last): ... IndexError: Buffer is empty ``` # Additional Instructions * Ensure your implementation efficiently handles the wrap-around logic of the circular buffer. * Test your methods thoroughly to account for edge cases and proper functionality under various scenarios.","solution":"class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def enqueue(self, value: int) -> None: if self.is_full(): self.start = (self.start + 1) % self.size else: self.count += 1 self.buffer[self.end] = value self.end = (self.end + 1) % self.size def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.start] self.start = (self.start + 1) % self.size self.count -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.start] def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size"},{"question":"# Coding Assessment Question Scenario You are tasked with writing a function that takes a list of integers and a target value, and determines if there is a subset of the list that sums up to the target value. This is a classic problem known as the \\"Subset Sum Problem\\", which is a fundamental challenge in computer science relating to combinatorial optimization and decision problems. Function Specification Write a function `is_subset_sum` that performs the following: - **Parameters**: - `numbers` (List[int]): A list of integers. - `target` (int): The target sum we want to check for. - **Returns**: - A boolean indicating whether there exists a subset of the list that sums up to the target value. Examples ```python def is_subset_sum(numbers: List[int], target: int) -> bool: pass # Example test cases print(is_subset_sum([3, 34, 4, 12, 5, 2], 9)) # Expected output: True (subset [4, 5] or [3, 2, 4]) print(is_subset_sum([1, 2, 3, 7, 8, 10], 11)) # Expected output: True (subset [1, 10] or [3, 8]) print(is_subset_sum([1, 2, 5, 9, 10], 22)) # Expected output: True (subset [2, 10, 10]) print(is_subset_sum([1, 2, 5, 9, 10], 55)) # Expected output: False ``` Constraints - The function should handle lists up to a length of 200 and target values up to 10,000 efficiently. - Optimize for both time and space complexity to ensure the solution is feasible within reasonable computational limits. - Consider edge cases such as an empty list or a target of 0. Requirements Focus on dynamic programming or recursive backtracking strategies to ensure an efficient solution. Aim for a time complexity of O(n * target) where n is the length of the list.","solution":"def is_subset_sum(numbers, target): Returns True if there is a subset of the numbers that sums to the target. n = len(numbers) dp = [[False] * (target + 1) for _ in range(n + 1)] # If sum is 0, empty subset always has a sum of 0 for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j < numbers[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-numbers[i-1]] return dp[n][target]"},{"question":"# **Number String Encoding** Scenario: You are developing a tool to encode and decode numerical strings. The encoding process transforms a string of digits by replacing each digit with another digit according to a given mapping. Decoding reverses the process to recover the original string. Task: Implement two methods, `encode` and `decode`, in a class `NumberCodec`. The `encode` method should convert a numerical string into an encoded string based on a provided dictionary mapping of digit substitutions. The `decode` method should convert an encoded string back to the original numerical string using the inverse of the original mapping. Method Specifications: 1. **encode(number_string: str, mapping: dict[str, str]) -> str** - **Input**: A numerical string `number_string` to be encoded and a dictionary `mapping` where each key is a digit (in string format) and each value is the digit it should be mapped to. - **Output**: An encoded string where each digit in `number_string` has been replaced by its corresponding value in `mapping`. 2. **decode(encoded_string: str, mapping: dict[str, str]) -> str** - **Input**: An encoded string `encoded_string` and the original dictionary `mapping`. - **Output**: The decoded string which is the original numerical string before encoding. Constraints: - Assume the `number_string` contains only decimal digits (\'0\' to \'9\'). - All digits in `number_string` will have a corresponding entry in `mapping`. - The `decode` method should throw an error if any digit in `encoded_string` does not map back to the original string using the inverse mapping. Example: ```python from numbercodec import NumberCodec # assume the code is in a file named \'numbercodec.py\' mapping = {\'0\': \'4\', \'1\': \'3\', \'2\': \'7\', \'3\': \'8\', \'4\': \'0\', \'5\': \'2\', \'6\': \'1\', \'7\': \'9\', \'8\': \'6\', \'9\': \'5\'} # Encoding the number string encoded = NumberCodec.encode(\\"1234567890\\", mapping) # Decoding the encoded string decoded = NumberCodec.decode(encoded_string, mapping) # Check the equality assert decoded == \\"1234567890\\" ``` Your task is to implement these methods with the given specifications.","solution":"class NumberCodec: @staticmethod def encode(number_string: str, mapping: dict[str, str]) -> str: Encodes a numerical string according to the provided mapping. Args: number_string (str): The numerical string to be encoded. mapping (dict[str, str]): The mapping dictionary for digit substitutions. Returns: str: The encoded string. return \'\'.join(mapping[digit] for digit in number_string) @staticmethod def decode(encoded_string: str, mapping: dict[str, str]) -> str: Decodes an encoded string back to the original numerical string using the inverse of the provided mapping. Args: encoded_string (str): The encoded string to be decoded. mapping (dict[str, str]): The original mapping dictionary for digit substitutions. Returns: str: The decoded original numerical string. Raises: ValueError: If any digit in the encoded string does not map back correctly. inverse_mapping = {v: k for k, v in mapping.items()} return \'\'.join(inverse_mapping[digit] for digit in encoded_string)"},{"question":"# Scenario: You are tasked with developing a feature for a project management tool that involves calculating the completion percentage of tasks assigned to multiple team members. Each team member is assigned a certain number of tasks, and each task can either be complete or incomplete. # Task: Implement a function `calculate_completion_percentage` to perform the following: 1. Compute the completion percentage for each team member. 2. Print each team member\'s completion percentage in a specified format. # Specifications: 1. `calculate_completion_percentage(team_members: list[str], tasks: list[list[bool]]) -> None` - **Parameters**: - `team_members (list[str])`: A list of team member names. - `tasks (list[list[bool]])`: A list of lists where each sublist represents the completion status of tasks for a corresponding team member (`True` for complete, `False` for incomplete). - **Returns**: None 2. The function should validate and ensure: - The number of team members matches the number of task lists. - Each task list is non-empty. 3. **Output**: - Print the results in the format: \\"Team Member\\", \\"Completion Percentage\\". - Calculate and print the overall completion percentage for the entire team. # Example: ```python team_members = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] tasks = [[True, False, True], [True, True, True], [False, False, True]] calculate_completion_percentage(team_members, tasks) ``` **Expected Output**: ``` Team Member Completion Percentage Alice 66.67% Bob 100.00% Charlie 33.33% Overall completion percentage = 66.67% ``` # Constraints: - Assume there is at least one team member and each member has at least one task. - Focus on accuracy, readability, and efficient computation of percentages.","solution":"def calculate_completion_percentage(team_members, tasks): Calculate and print the completion percentage for each team member and the overall completion percentage. Parameters: team_members (list[str]): A list of team member names. tasks (list[list[bool]]): A list of lists where each sublist represents the completion status of tasks for a corresponding team member (`True` for complete, `False` for incomplete). if len(team_members) != len(tasks): raise ValueError(\\"Number of team members must match the number of task lists.\\") print(\\"Team Member Completion Percentage\\") total_completed_tasks = 0 total_tasks = 0 for team_member, task_list in zip(team_members, tasks): if not task_list: raise ValueError(f\\"Task list for {team_member} is empty.\\") completed_tasks = sum(task_list) total_tasks_for_member = len(task_list) percentage = (completed_tasks / total_tasks_for_member) * 100 total_completed_tasks += completed_tasks total_tasks += total_tasks_for_member print(f\\"{team_member:<17} {percentage:.2f}%\\") overall_completion_percentage = (total_completed_tasks / total_tasks) * 100 print(f\\"Overall completion percentage = {overall_completion_percentage:.2f}%\\")"},{"question":"# Problem Statement You are given a 2D grid representing a city map where each cell contains either a building (`1`) or an empty space (`0`). Your task is to determine the shortest distance from any building to the nearest empty space by implementing both a breadth-first search (BFS) and a depth-first search (DFS) approach. # Function Signature ```python def shortest_distance_bfs(grid: list[list[int]]) -> int: pass def shortest_distance_dfs(grid: list[list[int]]) -> int: pass ``` **Input Format**: - `grid` (list[list[int]]): A 2D list of integers where `1` denotes a building and `0` denotes an empty space. **Output Format**: - `shortest_distance_bfs` should return an integer representing the shortest distance from any building to the nearest empty space. - `shortest_distance_dfs` should return an integer representing the shortest distance from any building to the nearest empty space. **Constraints**: - The size of the grid is up to 100x100. - There is at least one building and at least one empty space. # Example Usage ```python grid = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] distance_bfs = shortest_distance_bfs(grid) print(distance_bfs) distance_dfs = shortest_distance_dfs(grid) print(distance_dfs) ``` **Expected Output**: ``` 1 1 ``` # Evaluation Criteria 1. Correctness: The solution should correctly compute the shortest distance from any building to the nearest empty space for various grid inputs. 2. Efficiency: The solution should perform within acceptable time limits given the constraints. 3. Edge Handling: Solutions should adequately handle edge cases, including grids with minimal buildings and empty spaces, and grids fully occupied with buildings or empty spaces. 4. Code Quality: The implementation should be clean, well-documented, and easy to understand.","solution":"from collections import deque def shortest_distance_bfs(grid: list[list[int]]) -> int: rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def bfs(): visited = set() queue = deque() # First, add all buildings to the queue and mark them as visited for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c, 0)) visited.add((r, c)) min_distance = float(\'inf\') while queue: r, c, dist = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: if grid[nr][nc] == 0: min_distance = min(min_distance, dist + 1) visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return min_distance if min_distance != float(\'inf\') else -1 return bfs() def shortest_distance_dfs(grid: list[list[int]]) -> int: rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] min_distance = float(\'inf\') def dfs(r, c, visited, dist): nonlocal min_distance if grid[r][c] == 0: min_distance = min(min_distance, dist) return for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited: visited.add((nr, nc)) dfs(nr, nc, visited, dist + 1) visited.remove((nr, nc)) for r in range(rows): for c in range(cols): if grid[r][c] == 1: visited = set() visited.add((r, c)) dfs(r, c, visited, 0) return min_distance if min_distance != float(\'inf\') else -1"},{"question":"# Problem Statement You are given a list of strings representing a sequence of operations applied on a stack. Your task is to implement a function `evaluate_stack_operations` that simulates the stack operations and returns the final state of the stack. The operations include: - `\\"PUSH x\\"`: Push an integer `x` onto the stack. - `\\"POP\\"`: Remove the top element from the stack. Ignore this operation if the stack is empty. - `\\"PEEK\\"`: Return the top element of the stack without removing it. Ignore this operation if the stack is empty. Implement the function `evaluate_stack_operations` which takes a list of strings as input and returns the state of the stack after performing all the given operations. # Function Signature ```python def evaluate_stack_operations(operations: list[str]) -> list[int]: pass ``` # Input - `operations`: A list of strings where each string represents an operation on the stack. # Output - A list of integers representing the final state of the stack. # Constraints - Each string in the `operations` list will be either `\\"PUSH x\\"` (where `x` is an integer), `\\"POP\\"`, or `\\"PEEK\\"`. - Length of `operations` list will be between 1 and 1000. - The integer `x` in the `\\"PUSH x\\"` operation will be between -1000 and 1000. # Example ```python >>> evaluate_stack_operations([\\"PUSH 5\\", \\"PUSH 3\\", \\"PEEK\\", \\"POP\\", \\"PEEK\\", \\"POP\\", \\"POP\\"]) [5] >>> evaluate_stack_operations([\\"PUSH 10\\", \\"PUSH 20\\", \\"PUSH 30\\", \\"POP\\", \\"PUSH 40\\", \\"PEEK\\"]) [10, 20, 40] >>> evaluate_stack_operations([\\"POP\\", \\"PEEK\\"]) [] >>> evaluate_stack_operations([\\"PUSH -1\\", \\"PUSH -2\\", \\"PUSH -3\\", \\"POP\\", \\"PUSH 4\\", \\"PEEK\\", \\"POP\\", \\"POP\\"]) [-1, -2] ``` # Hints - Initialize an empty stack and iterate through the list of operations to update the stack accordingly. - Handle edge cases where the stack might be empty and a `\\"POP\\"` or `\\"PEEK\\"` operation is requested.","solution":"def evaluate_stack_operations(operations: list[str]) -> list[int]: stack = [] for op in operations: if op.startswith(\\"PUSH\\"): _, value = op.split() stack.append(int(value)) elif op == \\"POP\\": if stack: stack.pop() elif op == \\"PEEK\\": if stack: pass # PEEK does not modify the stack return stack"},{"question":"# Problem Statement You are developing a system for monitoring environmental conditions in a smart greenhouse. One of the requirements is to adjust the lighting based on the current time of day. Write a program that: 1. Takes three parameters: `hour`, `minute`, and `second` representing the current time. 2. Determines whether the current time falls within the ideal lighting period, which is defined as any time between 6:00:00 (inclusive) and 18:00:00 (exclusive). 3. Ensures all provided parameters are valid, raising an appropriate error for invalid inputs. 4. Returns `True` if the time is within the lighting period, and `False` otherwise. # Input Format * Three integers representing `hour`, `minute`, and `second`. # Output Format * Print `True` or `False` indicating whether the current time falls within the defined lighting period. # Constraints * `hour` must be between 0 and 23. * `minute` and `second` must be between 0 and 59. # Example Input ``` 7 30 15 ``` Output ``` True ``` Input ``` 19 0 0 ``` Output ``` False ``` # Function Signature The implementation should include the following function: ```python def is_lighting_period(hour: int, minute: int, second: int) -> bool: pass ``` # Requirements 1. Make sure that your function handles invalid inputs gracefully by raising a `ValueError` with the message \\"Invalid time parameters\\". 2. Use the provided input format and constraints to ensure correctness. 3. Ensure that you have clearly written and error-free code.","solution":"def is_lighting_period(hour: int, minute: int, second: int) -> bool: Determines if the given time falls within the lighting period (6:00:00 to 18:00:00). Args: - hour (int): The hour of the time (0-23). - minute (int): The minute of the time (0-59). - second (int): The second of the time (0-59). Returns: - bool: True if the time is within the lighting period, False otherwise. Raises: - ValueError: If the input time parameters are invalid. # Validate inputs if not (0 <= hour <= 23): raise ValueError(\\"Invalid time parameters\\") if not (0 <= minute <= 59): raise ValueError(\\"Invalid time parameters\\") if not (0 <= second <= 59): raise ValueError(\\"Invalid time parameters\\") # Check if the time falls within the lighting period start_time = 6 * 3600 # 6:00:00 in seconds end_time = 18 * 3600 # 18:00:00 in seconds current_time = hour * 3600 + minute * 60 + second return start_time <= current_time < end_time"},{"question":"# Cylindrical Volume Calculation Problem Description You are tasked with computing the volume of a cylinder given two of its characteristics: radius, height, or volume. The relationship between these properties is governed by the formula (V = pi r^2 h), where: - (V) (volume) is measured in cubic units - (r) (radius) is measured in linear units - (h) (height) is measured in linear units Task Requirements Implement the function `cylinder_volume(radius: float, height: float, volume: float) -> dict[str, float]` that takes: - `radius` in units (can be zero) - `height` in units (can be zero) - `volume` in cubic units (can be zero) Exactly one of these parameters is zero, and the function must compute and return the value for the zero parameter as a dictionary with the parameter\'s name as the key. Input and Output - **Input**: Three float values for radius, height, and volume respectively, where one and only one value is zero. - **Output**: A dictionary with the zero-parameter name as the key and the calculated value as the corresponding value. Constraints - Radius, height, and volume values must not be negative. If a negative value is given, raise a `ValueError` with the corresponding message: - `\\"Radius cannot be negative\\"` - `\\"Height cannot be negative\\"` - `\\"Volume cannot be negative\\"` - Exactly one of the inputs must be zero. Otherwise, raise a `ValueError` with the message: `\\"One and only one argument must be 0\\"` Example ```python >>> cylinder_volume(0, 10, 314.1592653589793) {\'radius\': 3.1622776601683795} >>> cylinder_volume(3, 0, 84.82300164692441) {\'height\': 3.0} >>> cylinder_volume(3, 5, 0) {\'volume\': 141.3716694115407} ```","solution":"import math def cylinder_volume(radius: float, height: float, volume: float) -> dict[str, float]: if radius < 0: raise ValueError(\\"Radius cannot be negative\\") if height < 0: raise ValueError(\\"Height cannot be negative\\") if volume < 0: raise ValueError(\\"Volume cannot be negative\\") if sum(x == 0 for x in (radius, height, volume)) != 1: raise ValueError(\\"One and only one argument must be 0\\") if radius == 0: # Calculate radius given height and volume radius_result = math.sqrt(volume / (math.pi * height)) return {\\"radius\\": radius_result} elif height == 0: # Calculate height given radius and volume height_result = volume / (math.pi * radius ** 2) return {\\"height\\": height_result} else: # Calculate volume given radius and height volume_result = math.pi * radius ** 2 * height return {\\"volume\\": volume_result}"},{"question":"# Task Description Write a Python function that reads a CSV file containing student records and performs various data processing and validation tasks on the data. The CSV file has the following columns: `ID`, `Name`, `Age`, `Grade`, `Email`. Your task is to implement the function `process_student_records` that includes the following functionalities: # Function to Implement `process_student_records(filename: str)` * **Input**: - `filename` (str): Path to the CSV file containing student data. * **Output**: - Returns a tuple with three elements: 1. A dictionary with student IDs as keys and corresponding student names as values. 2. A list of student records where the students are older than 20. 3. The average grade of all students (rounded to 2 decimal places). # Constraints * The CSV file is guaranteed to follow the format: ``` ID,Name,Age,Grade,Email 1,John Doe,21,85,john.doe@example.com 2,Jane Smith,19,90,jane.smith@example.com ``` * The `Age` is an integer, and the `Grade` is an integer between 0 and 100. * Assume `1 <= number_of_students <= 1000`. # Requirements 1. Implement the `process_student_records` function that: - Reads the CSV file and parses the data. - Creates and returns a dictionary where the keys are student IDs and the values are student names. - Creates and returns a list of records (each as a dictionary) for students older than 20. - Calculates and returns the average grade of all students. 2. Handle potential edge cases such as empty files or invalid data formats gracefully. 3. Ensure the implementation adheres to the constraints and is efficient. # Example ```python # Example usage of the process_student_records function records_dict, students_above_20, avg_grade = process_student_records(\\"students.csv\\") print(records_dict) # {1: \'John Doe\', 2: \'Jane Smith\'} print(students_above_20) # [{\'ID\': 1, \'Name\': \'John Doe\', \'Age\': 21, \'Grade\': 85, \'Email\': \'john.doe@example.com\'}] print(avg_grade) # 87.5 ``` # Notes * You may use Python\'s built-in modules such as `csv` and `statistics`. * Ensure your implementation considers edge cases and validates the input data as needed.","solution":"import csv from statistics import mean def process_student_records(filename: str): Processes student records from a CSV file. Args: filename (str): Path to the CSV file containing student data. Returns: tuple: A tuple containing a dictionary of student IDs and names, a list of students older than 20, and the average grade of all students. student_dict = {} students_above_20 = [] grades = [] try: with open(filename, mode=\'r\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: try: student_id = int(row[\'ID\']) name = row[\'Name\'] age = int(row[\'Age\']) grade = int(row[\'Grade\']) email = row[\'Email\'] student_dict[student_id] = name grades.append(grade) if age > 20: students_above_20.append({ \'ID\': student_id, \'Name\': name, \'Age\': age, \'Grade\': grade, \'Email\': email }) except ValueError: pass # Handle possible conversion errors gracefully except FileNotFoundError: return {}, [], 0 # In case the file is not found avg_grade = round(mean(grades), 2) if grades else 0 return student_dict, students_above_20, avg_grade"},{"question":"# Problem Statement **Objective**: Write a function that takes two binary trees and determines whether the two trees are mirrors of each other. # Function Signature ```python def are_mirrors(root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool: pass ``` # Input - **root1** (Optional[TreeNode]): The root node of the first binary tree. - **root2** (Optional[TreeNode]): The root node of the second binary tree. # Output - Returns a boolean value indicating whether the two binary trees are mirrors of each other. # Constraints - Each binary tree node contains an integer value. - The number of nodes in each tree is in the range [0, 10^4]. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root2 = TreeNode(1) root2.left = TreeNode(3) root2.right = TreeNode(2) # Expected Output: True # Example 2 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root2 = TreeNode(1) root2.left = TreeNode(3) root2.right = TreeNode(4) # Expected Output: False ``` # Notes - The function should be able to handle edge cases, such as when one or both of the trees are empty. - Consider recursive and iterative approaches for checking whether two trees are mirrors. - Ensure the function runs efficiently within the provided constraints. # Additional Requirement - Include detailed docstrings with examples and explanations for your function, as well as for any helper functions or classes used.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_mirrors(root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool: Determines whether two binary trees are mirrors of each other. Args: root1 (Optional[TreeNode]): The root node of the first binary tree. root2 (Optional[TreeNode]): The root node of the second binary tree. Returns: bool: True if the two trees are mirrors of each other, False otherwise. def are_mirrors_helper(node1: Optional[TreeNode], node2: Optional[TreeNode]) -> bool: if node1 is None and node2 is None: return True if node1 is None or node2 is None: return False return (node1.val == node2.val and are_mirrors_helper(node1.left, node2.right) and are_mirrors_helper(node1.right, node2.left)) return are_mirrors_helper(root1, root2)"},{"question":"# Word Ladder Transformation Challenge You are given two words, `begin_word` and `end_word`, and a list of `word_list` containing different words of the same length. You must transform the `begin_word` into the `end_word` by changing only one letter at a time, and each intermediate word must exist in the `word_list`. Return the number of transformations required to achieve this transformation. If it is not possible to transform `begin_word` into `end_word`, return `-1`. Task: Write a function `word_ladder(begin_word: str, end_word: str, word_list: list[str]) -> int` that: - Accepts two string words, `begin_word` and `end_word`, and a list of strings `word_list`. - Returns the minimum number of single-letter transformations from `begin_word` to `end_word`. If the transformation is not possible, return `-1`. Inputs: - `begin_word`: A string representing the initial word. - `end_word`: A string representing the target word. - `word_list`: A list of strings representing the allowed intermediate words. - Each word in the list has the same length as `begin_word` and `end_word`. - `1 <= len(begin_word), len(end_word), length of each word in word_list <= 100`: The length of words. - `1 <= len(word_list) <= 1000`: The size of the word list. Output: - Return an integer representing the minimum number of transformations needed to convert `begin_word` to `end_word`. Return `-1` if the transformation is not possible. Example Scenario: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] # Transformations: # hit -> hot -> dot -> dog -> cog # There are 4 transformations needed. word_ladder(begin_word, end_word, word_list) # should return 5 ``` **Note:** - If `end_word` is not in the `word_list`, transformation is not possible. - All words consist of lowercase English letters only, and no word appears more than once in the `word_list`. Ensure to handle edge cases and test your implementation for correctness and efficiency.","solution":"from collections import deque def word_ladder(begin_word: str, end_word: str, word_list: list[str]) -> int: Returns the minimum number of transformations from begin_word to end_word. Transformation rules: - Only one letter can be changed at a time. - Each transformed word must exist in the word_list. if end_word not in word_list: return -1 word_set = set(word_list) queue = deque([(begin_word, 1)]) # (current_word, current_step) while queue: current_word, steps = queue.popleft() if current_word == end_word: return steps for i in range(len(current_word)): for char in \\"abcdefghijklmnopqrstuvwxyz\\": next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_set: queue.append((next_word, steps + 1)) word_set.remove(next_word) return -1"},{"question":"# Scenario Analysis and Time Management You are participating in a hackathon and your coding team needs to determine the productivity of individual team members. You have a list of coding sessions for each team member, where each session is represented by a start and end time. Your task is to calculate the total time spent coding by each member without overlapping times being counted multiple times. Write a function `calculate_productive_time(sessions: List[Tuple[int, int]]) -> int` that takes a list of tuples representing the coding sessions of a team member and returns the total productive time. Each tuple contains two integers, the start and end time of a session. # Input: - `sessions` (List[Tuple[int, int]]): A list of tuples where each tuple represents a coding session with start and end times in the format (start, end). (1 <= len(sessions) <= 100, 0 <= start < end <= 1000) # Output: - (int): The total time spent coding, accounting for overlapping sessions. # Example: ```python # Example Case # Input: sessions = [(1, 5), (3, 7), (9, 12)] # Output: 8 # Example Case # Input: sessions = [(1, 2), (2, 3), (3, 4)] # Output: 3 ``` # Constraints: - Each coding session is represented by a valid interval with a start and end time. - Sessions may overlap, and the overlapping times should only be counted once. # Performance Requirement: Ensure your algorithm efficiently handles the given constraints. # Hints: 1. Consider sorting the sessions by their start times. 2. Merge overlapping intervals to aggregate productive time correctly. Write your function implementation below: ```python from typing import List, Tuple def calculate_productive_time(sessions: List[Tuple[int, int]]) -> int: if not sessions: return 0 # Sort the sessions by their start time sessions.sort() total_time = 0 current_start, current_end = sessions[0] for start, end in sessions[1:]: if start <= current_end: # Extend the current interval current_end = max(current_end, end) else: # Add the current interval length to total time total_time += current_end - current_start # Move to the next interval current_start, current_end = start, end # Add the last interval length to total time total_time += current_end - current_start return total_time # Testing the function print(calculate_productive_time([(1, 5), (3, 7), (9, 12)])) # Output: 8 print(calculate_productive_time([(1, 2), (2, 3), (3, 4)])) # Output: 3 ```","solution":"from typing import List, Tuple def calculate_productive_time(sessions: List[Tuple[int, int]]) -> int: if not sessions: return 0 # Sort the sessions by their start time sessions.sort() total_time = 0 current_start, current_end = sessions[0] for start, end in sessions[1:]: if start <= current_end: # Extend the current interval current_end = max(current_end, end) else: # Add the current interval length to total time total_time += current_end - current_start # Move to the next interval current_start, current_end = start, end # Add the last interval length to total time total_time += current_end - current_start return total_time"},{"question":"# Question: Implement String Rotation Checker You are developing a system that needs to check if one string is a rotation of another string. Your task is to implement a function that determines if one string is a rotation of another string by using only one call to a substring-checking function (i.e., `in` operation). Function Signature ```python def is_rotation(s1: str, s2: str) -> bool: ``` Requirements * The function should return `True` if `s1` is a rotation of `s2`, and `False` otherwise. * A string is considered a rotation of another string if it can be obtained by taking some number of characters from the beginning of one string and moving them to the end. * The function should not use repetitive loops or multiple substring-checking calls to check for the rotation. Input * `s1`: A string to check. * `s2`: A string to compare against. Output * Returns `True` if `s1` is a rotation of `s2`. * Returns `False` otherwise. Constraints * The strings can contain any characters, including numeric and special characters. * Handle both strings regardless of their lengths (including empty strings). Examples ```python assert is_rotation(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotation(\\"hello\\", \\"llohe\\") == True assert is_rotation(\\"python\\", \\"onpyth\\") == True assert is_rotation(\\"abcd\\", \\"bcda\\") == True assert is_rotation(\\"abcd\\", \\"dabc\\") == True assert is_rotation(\\"abcd\\", \\"abcd\\") == True assert is_rotation(\\"abcd\\", \\"abdc\\") == False assert is_rotation(\\"abcd\\", \\"abcdabcd\\") == False assert is_rotation(\\"\\", \\"\\") == True assert is_rotation(\\"a\\", \\"\\") == False assert is_rotation(\\"\\", \\"a\\") == False assert is_rotation(\\"a\\", \\"a\\") == True ``` Constraints & Limitations * The solution must make use of only one substring-checking function call (`in` operation) to determine if one string is a rotation of another. * Ensure that your implementation handles edge cases correctly. * Solutions should consider both empty strings and strings with different lengths.","solution":"def is_rotation(s1: str, s2: str) -> bool: Check if s2 is a rotation of s1. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Challenge: Rotate Array Elements to the Right **Context**: You are working on enhancing the efficiency of a data processing pipeline. One of the tasks is to implement a function that rotates the elements of an array to the right by a given number of steps. **Problem**: Given an array of integers and a non-negative integer `k`, implement a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates the array elements to the right by `k` steps. Rotation means that elements at the end of the array wrap around to the beginning. For example, if the array is `[1, 2, 3, 4, 5]` and `k` is `2`, the rotated array should be `[4, 5, 1, 2, 3]`. **Constraints**: 1. The length of the array will be between `1` and `10^5`. 2. `k` will be a non-negative integer. **Input**: - A list `arr` of length `n` containing integers. - An integer `k` representing the number of steps to rotate the array. **Output**: - A list of integers representing the rotated array. **Performance Requirements**: - The function should achieve the desired rotation in linear time, O(n). **Example**: ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2], 3) [2, 1] ```","solution":"def rotate_array(arr, k): Rotates the elements of the array to the right by k steps. n = len(arr) k = k % n # handle cases where k is greater than length of arr return arr[-k:] + arr[:-k]"},{"question":"# Flight Reservation System Using AVL Trees Context You are tasked with implementing a flight reservation system using AVL trees to manage reservations. Each reservation is associated with a unique reservation ID and a flight date. You can add new reservations, remove existing ones, and retrieve the reservation details efficiently by reservation ID. Requirements Write a class `FlightReservationSystem` with the following methods: 1. **`__init__(self)`**: Initialize the AVL tree to store reservations. 2. **`add_reservation(self, reservation_id: int, flight_date: str)`**: Add a new reservation with a given reservation ID and flight date. 3. **`remove_reservation(self, reservation_id: int)`**: Remove an existing reservation by reservation ID. 4. **`get_reservation(self, reservation_id: int) -> str`**: Retrieve the flight date for a given reservation ID. If the reservation ID does not exist, return \\"Reservation not found.\\" Input and Output * **Input**: * `add_reservation` method should accept an integer `reservation_id` and a string `flight_date` in the format \\"YYYY-MM-DD\\". * `remove_reservation` method should accept an integer `reservation_id`. * `get_reservation` method should accept an integer `reservation_id` and return the corresponding flight date as a string. * **Output**: * `get_reservation` method should return the flight date string corresponding to the reservation ID or \\"Reservation not found\\" if the reservation ID does not exist. * **Constraints**: * Reservation IDs will be positive integers. * Flight dates will be valid strings in the format \\"YYYY-MM-DD\\". * The system can hold up to (10^5) reservations. Example ```python system = FlightReservationSystem() system.add_reservation(1, \\"2023-12-25\\") system.add_reservation(2, \\"2023-11-15\\") system.add_reservation(3, \\"2024-01-01\\") assert system.get_reservation(2) == \\"2023-11-15\\" system.remove_reservation(2) assert system.get_reservation(2) == \\"Reservation not found\\" ```","solution":"class AVLTreeNode: def __init__(self, key, value): self.key = key self.value = value self.height = 1 # Height of this node for balancing self.left = None self.right = None class FlightReservationSystem: def __init__(self): self.root = None def height(self, node): if not node: return 0 return node.height def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(self.height(z.left), self.height(z.right)) + 1 y.height = max(self.height(y.left), self.height(y.right)) + 1 return y def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(self.height(z.left), self.height(z.right)) + 1 y.height = max(self.height(y.left), self.height(y.right)) + 1 return y def get_balance(self, node): if not node: return 0 return self.height(node.left) - self.height(node.right) def insert(self, node, key, value): if not node: return AVLTreeNode(key, value) if key < node.key: node.left = self.insert(node.left, key, value) elif key > node.key: node.right = self.insert(node.right, key, value) else: node.value = value return node node.height = max(self.height(node.left), self.height(node.right)) + 1 balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.right_rotate(node) if balance < -1 and key > node.right.key: return self.left_rotate(node) if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def min_value_node(self, node): if node is None or node.left is None: return node return self.min_value_node(node.left) def delete(self, node, key): if not node: return node if key < node.key: node.left = self.delete(node.left, key) elif key > node.key: node.right = self.delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.min_value_node(node.right) node.key = temp.key node.value = temp.value node.right = self.delete(node.right, temp.key) if not node: return node node.height = max(self.height(node.left), self.height(node.right)) + 1 balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.right_rotate(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.left_rotate(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def search(self, node, key): if not node or node.key == key: return node if key < node.key: return self.search(node.left, key) return self.search(node.right, key) def add_reservation(self, reservation_id, flight_date): self.root = self.insert(self.root, reservation_id, flight_date) def remove_reservation(self, reservation_id): self.root = self.delete(self.root, reservation_id) def get_reservation(self, reservation_id): result = self.search(self.root, reservation_id) if result: return result.value else: return \\"Reservation not found\\""},{"question":"# Coding Challenge: Peak Element Finder You are given an array of integers that represents the elevation profile of a landscape. Your task is to identify the \'peak\' elements in this landscape. An element is considered a peak if it is greater than or equal to its immediate neighbors. If an element has no neighbors (i.e., it is at the boundary of the array), it should still be considered a peak if it meets the aforementioned condition. Write a function that: 1. Takes an array of integers as input. 2. Identifies all peak elements. 3. Returns a list containing the values of these peak elements. Function Signature ```python def find_peaks(elevations: list[int]) -> list[int]: pass ``` Parameters - `elevations`: A list of integers representing the elevation levels. Constraints - The length of the array will be at least 1 and at most 1000. - The integers in the array can be positive or negative, and may have duplicates. Output - A list of integers, where each integer is a peak element as defined. # Example ```python elevations = [2, 4, 1, 7, 6, 8, 3] peak_elements = find_peaks(elevations) print(peak_elements) ``` **Output:** ```python [4, 7, 8] ``` Please write the function `find_peaks` to solve the problem.","solution":"def find_peaks(elevations: list[int]) -> list[int]: Identifies all peak elements in the elevation profile. Args: elevations (list[int]): List of integers representing the elevation levels. Returns: list[int]: List of peak elements. n = len(elevations) if n == 1: return [elevations[0]] peaks = [] for i in range(n): if i == 0: if elevations[i] >= elevations[i + 1]: peaks.append(elevations[i]) elif i == n - 1: if elevations[i] >= elevations[i - 1]: peaks.append(elevations[i]) else: if elevations[i] >= elevations[i - 1] and elevations[i] >= elevations[i + 1]: peaks.append(elevations[i]) return peaks"},{"question":"# Coding Assessment Question: User Preference Management with Auto-Suggestion Objective Your task is to create a user preference management system where users can submit their preferences for a particular category. Based on the preferences submitted by all users, the system should provide the top 5 most common preferences as suggestions. Requirements 1. **Preference Submission**: Implement a mechanism allowing users to submit their preferences. 2. **Auto-Suggestion**: Implement functionality to return the top 5 most popular preferences for a category. 3. **Data Handling**: Store and retrieve user preferences efficiently. Assume necessary database configurations. 4. **Edge Cases**: Handle scenarios where there are less than 5 unique preferences. Input/Output Formats - **Input**: - An HTTP request containing a user ID, category, and preference. - **Output**: - A list of the top 5 preferences for the specified category. Performance Requirements - Efficiently handle multiple simultaneous submissions and queries. - Consider scalability in terms of both user numbers and preference data. Implementation Steps 1. Create a model to store user preferences linked to user IDs and categories. 2. Implement a view to handle submission of user preferences. 3. Implement a view to query and return the top 5 preferences for a given category. Scenario Consider a movie recommendation website where users can submit their favorite genres. The system will suggest the top 5 genres based on all user submissions to new users when they sign up. ```python from django.db import models from django.shortcuts import render from django.http import JsonResponse from collections import Counter # Model to store user preferences class UserPreference(models.Model): user_id = models.IntegerField() category = models.CharField(max_length=200) preference = models.CharField(max_length=200) # View to submit user preferences def submit_preference(request): if request.method == \'POST\': user_id = request.POST.get(\'user_id\') category = request.POST.get(\'category\') preference = request.POST.get(\'preference\') UserPreference.objects.create(user_id=user_id, category=category, preference=preference) return JsonResponse({\\"status\\": \\"Preference submitted successfully.\\"}) return render(request, \\"submit_preference.html\\") # View to get top 5 preferences for a category def get_top_preferences(request, category): preferences = UserPreference.objects.filter(category=category).values_list(\'preference\', flat=True) # Counting preferences and getting the top 5 top_preferences = [item[0] for item in Counter(preferences).most_common(5)] return JsonResponse({\\"top_preferences\\": top_preferences}) # Note: Additional setup in urls.py to map to these views is assumed. ``` **Note**: Remember to handle appropriate data validation, error handling, and securing of entries in a production environment. Additionally, set up views and templates in a way that fits your project structure.","solution":"from collections import Counter class UserPreferenceManager: def __init__(self): self.preferences = [] def submit_preference(self, user_id, category, preference): Submit a user\'s preference for a specific category. self.preferences.append((user_id, category, preference)) def get_top_preferences(self, category): Get the top 5 most common preferences for the specified category. category_preferences = [pref[2] for pref in self.preferences if pref[1] == category] top_preferences = [item[0] for item in Counter(category_preferences).most_common(5)] return top_preferences"},{"question":"# String Compression and Expansion String compression is a technique where we replace repeated sequences of characters with a marker indicating the number of times each sequence occurs. Conversely, string expansion reverses this process. Your task is to implement both compression and expansion functions. Part 1: String Compression Implement the function `compress_string(text: str) -> str` that takes a string `text` and returns a compressed version of the string where each sequence of repeated characters is replaced by a single character followed by the number of times it appears consecutively. If a character appears only once consecutively, it should not be followed by a number. # Input * `text` (str): A string of characters. # Output * A compressed string. # Example ```python >>> compress_string(\\"aaabbcddd\\") \'a3b2cd3\' ``` Part 2: String Expansion Implement the function `expand_string(compressed: str) -> str` that takes a compressed string `compressed` and returns the original string by expanding the sequences. # Input * `compressed` (str): A compressed string where each character may be followed by a number indicating how many times it appears consecutively. # Output * The original expanded string. # Example ```python >>> expand_string(\\"a3b2cd3\\") \'aaabbcddd\' ``` Constraints * The input strings can consist of lowercase English letters (a-z). * The count in the compressed string will always be a positive integer greater than 1. * If no number follows a character, it should be considered as appearing once. * Handle edge cases such as empty strings to avoid errors. Performance Requirements * Aim for linear time complexity for both compression and expansion in terms of the length of the input. ```python def compress_string(text: str) -> str: # Your code here def expand_string(compressed: str) -> str: # Your code here ```","solution":"def compress_string(text: str) -> str: Compresses the given string by replacing sequences of repeated characters with a single character followed by the number of times it appears consecutively. if not text: return \\"\\" compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i-1]: count += 1 else: compressed.append(text[i-1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(text[-1]) if count > 1: compressed.append(str(count)) return \\"\\".join(compressed) def expand_string(compressed: str) -> str: Expands the given compressed string by replacing each character followed by a number with that character repeated that many times. if not compressed: return \\"\\" expanded = [] i = 0 while i < len(compressed): char = compressed[i] i += 1 if i < len(compressed) and compressed[i].isdigit(): num = 0 while i < len(compressed) and compressed[i].isdigit(): num = num * 10 + int(compressed[i]) i += 1 expanded.append(char * num) else: expanded.append(char) return \\"\\".join(expanded)"},{"question":"# Problem Statement: Given a list of integers, determine the number of distinct contiguous subarrays that sum to a target value `S`. Write a function `count_subarrays_with_sum(arr: List[int], S: int) -> int` that computes this value. # Input Format: - `arr` (List[int]): A list of positive and negative integers (-10^4 ≤ arr[i] ≤ 10^4, 1 ≤ len(arr) ≤ 10000). - `S` (integer): The target sum (-10^9 ≤ S ≤ 10^9). # Output Format: - Return an integer representing the number of distinct contiguous subarrays that sum up to exactly `S`. # Example: ```python >>> count_subarrays_with_sum([1, 2, 3, 4, 5], 9) 2 >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([3, -1, 4, -2, 1], 2) 3 ``` # Explanation: - In the first example, the subarrays [2, 3, 4] and [4, 5] both sum to 9. - In the second example, the subarrays [1, 1] and [1, 1] both sum to 2. - In the third example, the subarrays [3, -1] and [4, -2] and [2] all sum to 2. # Constraints: - Ensure the solution works efficiently for large arrays and large target sums. - Implement a balanced approach that avoids excessive usage of space or time. - Pay attention to edge cases where the array contains minimal or maximal values. # Implementation Details: Use sliding window or prefix-sum techniques combined with a hash map/dictionary for faster look-up of previously seen sums. Be mindful of potential integer overflow and handle various combinations efficiently.","solution":"def count_subarrays_with_sum(arr, S): Counts the number of distinct contiguous subarrays that sum to the target value S. Parameters: arr (list): List of integers. S (int): Target sum value. Returns: int: Number of contiguous subarrays that sum to S. count = 0 cumulative_sum = 0 sum_freq = {0: 1} # initialize with zero sum for num in arr: cumulative_sum += num if cumulative_sum - S in sum_freq: count += sum_freq[cumulative_sum - S] if cumulative_sum in sum_freq: sum_freq[cumulative_sum] += 1 else: sum_freq[cumulative_sum] = 1 return count"},{"question":"# Question You are tasked with developing a function that identifies all the starting indices where a given pattern string appears in another given text string using a sliding window approach. # Function Signature ```python def find_pattern_indices(text: str, pattern: str) -> List[int]: Returns a list of all starting indices where the pattern is found in the text. Parameters: text (str): The text string to search within. pattern (str): The pattern string to search for. Returns: List[int]: A list of starting indices (0-based) where the pattern occurs in the text. ``` # Input - A string `text` such that its length (1 leq text{len(text)} leq 100000). - A string `pattern` such that its length (1 leq text{len(pattern)} leq 1000). # Output - A list of integers representing the starting indices where `pattern` is found in `text`. # Examples 1. `find_pattern_indices(\\"abracadabra\\", \\"abra\\")` should return `[0, 7]`. 2. `find_pattern_indices(\\"banana\\", \\"ana\\")` should return `[1, 3]`. 3. `find_pattern_indices(\\"hello world\\", \\"world\\")` should return `[6]`. 4. `find_pattern_indices(\\"aaaaaa\\", \\"aaa\\")` should return `[0, 1, 2, 3]`. # Additional Constraints - Your solution should be efficient, aiming for (O(n + m)) time complexity where (n) is the length of the text and (m) is the length of the pattern. - Ensure your code handles cases where the pattern length is greater than the text length. # Hints - Consider preprocessing the pattern string to create a prefix table (also known as the Partial Match Table or KMP table) to optimize the search. - Utilize the Knuth-Morris-Pratt (KMP) algorithm or a similar string matching algorithm to achieve the desired efficiency. - Be mindful of edge cases, such as an empty pattern or the pattern being longer than the text.","solution":"from typing import List def compute_prefix_function(pattern: str) -> List[int]: Preprocesses the pattern string and returns the prefix table used in the KMP algorithm. m = len(pattern) prefix_table = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j else: prefix_table[i] = 0 return prefix_table def find_pattern_indices(text: str, pattern: str) -> List[int]: Returns a list of all starting indices where the pattern is found in the text. n = len(text) m = len(pattern) if m == 0: # If the pattern is empty, we return an empty list. return [] prefix_table = compute_prefix_function(pattern) indices = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = prefix_table[j - 1] if text[i] == pattern[j]: j += 1 if j == m: indices.append(i - m + 1) j = prefix_table[j - 1] return indices"},{"question":"# Traffic Light Simulation You are tasked with creating a simulation of a traffic light system for a T-junction. The T-junction involves three traffic lights: one for the main road (north-south), one for the side road (east-west), and one for pedestrian crossing. Each light has three states: green, orange, and red. Create a function to simulate the traffic light system with the following sequence: 1. The main road light turns green for 15 seconds, and the side road and pedestrian lights stay red. 2. The main road light turns orange for 3 seconds, the side road and pedestrian lights stay red. 3. The main road light turns red, and the side road light turns green for 10 seconds, pedestrian light stays red. 4. The side road light turns orange for 3 seconds, and the main road and pedestrian lights stay red. 5. The side road light turns red, and the pedestrian light turns green for 5 seconds, the main road light stays red. 6. The pedestrian light turns red, and the cycle restarts. Implement the function `simulate_traffic_light` that takes the number of cycles to simulate and outputs the state of each light at each second. ```python def simulate_traffic_light(cycles: int) -> List[Dict[str, str]]: Simulate the traffic light system at a T-junction. :param cycles: number of cycles to simulate :return: a list of dictionaries representing the state of each light every second Each dictionary contains: - \\"time\\": current time in seconds from the start - \\"main_road\\": state of the main road light (\\"red\\", \\"orange\\", \\"green\\") - \\"side_road\\": state of the side road light (\\"red\\", \\"orange\\", \\"green\\") - \\"pedestrian\\": state of the pedestrian light (\\"red\\", \\"green\\") pass ``` Requirements: * The function should take into account the duration of each light phase accurately. * The function should handle multiple cycles correctly, ensuring the sequence restarts after each cycle. * Optimize for readability and maintainability of the code. * Each state change and simulation step should be properly documented in the output. Additional Considerations: Consider potential edge cases where the cycle might not be a perfect multiple of any particular phase duration. A strong solution will display each second of the simulation clearly and concisely, ensuring the transitions between states are smooth and predictable. Provide a brief explanation of your approach, including how you ensured the timing accuracy for each light and how you tested the function for correctness.","solution":"from typing import List, Dict def simulate_traffic_light(cycles: int) -> List[Dict[str, str]]: Simulate the traffic light system at a T-junction. :param cycles: number of cycles to simulate :return: a list of dictionaries representing the state of each light every second Each dictionary contains: - \\"time\\": current time in seconds from the start - \\"main_road\\": state of the main road light (\\"red\\", \\"orange\\", \\"green\\") - \\"side_road\\": state of the side road light (\\"red\\", \\"orange\\", \\"green\\") - \\"pedestrian\\": state of the pedestrian light (\\"red\\", \\"green\\") sequence = [ (\\"main_road\\", \\"green\\", 15), (\\"main_road\\", \\"orange\\", 3), (\\"main_road\\", \\"red\\", \\"side_road\\", \\"green\\", 10), (\\"side_road\\", \\"orange\\", 3), (\\"side_road\\", \\"red\\", \\"pedestrian\\", \\"green\\", 5), (\\"pedestrian\\", \\"red\\", 0) # This is just a placeholder to restart the cycle ] state = { \\"main_road\\": \\"red\\", \\"side_road\\": \\"red\\", \\"pedestrian\\": \\"red\\" } events = [] current_time = 0 for _ in range(cycles): for s in sequence: if (len(s) == 3): state[s[0]] = s[1] duration = s[2] for t in range(duration): events.append({ \\"time\\": current_time + t, \\"main_road\\": state[\\"main_road\\"], \\"side_road\\": state[\\"side_road\\"], \\"pedestrian\\": state[\\"pedestrian\\"] }) if current_time + duration < cycles*36: current_time += duration elif(len(s) == 5): state[s[0]] = s[1] state[s[2]] = s[3] duration = s[4] for t in range(duration): events.append({ \\"time\\": current_time + t, \\"main_road\\": state[\\"main_road\\"], \\"side_road\\": state[\\"side_road\\"], \\"pedestrian\\": state[\\"pedestrian\\"] }) if current_time + duration < cycles*36: current_time += duration return events"},{"question":"# Question You are to implement a function that checks if a given integer is a power of three. Your function should determine this without using loops or recursion. Function Signature ```python def is_power_of_three(n: int) -> bool: pass ``` Input * `n` (int): A non-negative integer. Output * (bool): `True` if `n` is a power of three, `False` otherwise. Constraints * (0 leq n leq 10^9) * The input is guaranteed to be an integer. Performance Requirements * Your function should run in constant time O(1). Example ```python >>> is_power_of_three(27) True >>> is_power_of_three(9) True >>> is_power_of_three(15) False >>> is_power_of_three(1) True >>> is_power_of_three(0) False ``` Additional Notes The solution should employ mathematical properties of powers of three to determine if the given number is a power of three. For example, since (3^{19}) (1162261467) is the largest power of three that fits in a 32-bit signed integer, you can use this to determine if `n` is a power of three.","solution":"def is_power_of_three(n: int) -> bool: Checks if a given integer is a power of three. Parameters: n (int): A non-negative integer Returns: bool: True if n is a power of three, False otherwise if n <= 0: return False # 3^19 is 1162261467, which is the largest power of three under 10^9 largest_power_of_three = 1162261467 return largest_power_of_three % n == 0"},{"question":"# Problem Statement Given an array of integers where every element appears twice except for one, you need to find that single one. Implement an efficient function to identify and return the single non-duplicate element. This problem is an application of bitwise operations and requires linear time complexity. # Details 1. **Function Name**: `find_single_number` 2. **Input**: A list, `nums` with n elements where each element appears exactly twice except for one element which appears only once. 3. **Output**: The single element that appears only once. 4. **Constraints**: - The input list length is odd and greater than or equal to 1. - All numbers in the list are integers. # Expectations: * **Correctness**: The two duplicate elements should cancel out each other using bitwise XOR operation, thereby isolating the single element. * **Performance**: The solution should run in O(n) time and use O(1) space. * **Edge Cases**: Consider lists with only one element and lists where the single element is at the beginning, middle, or end. # Example ```python def find_single_number(nums: list) -> int: # Your implementation here assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([2]) == 2 assert find_single_number([3, 3, 7, 9, 9, 5, 5]) == 7 assert find_single_number([0, 0, 1]) == 1 ``` # Code Constraints * The use of collections, sets, or any other data collection to check duplicates is not allowed. * You must utilize the XOR operation to achieve the solution. * Your solution should cater to the performance requirements specified under the given constraints.","solution":"def find_single_number(nums: list) -> int: Returns the element that appears only once in the list where every element appears twice except for one. single = 0 for num in nums: single ^= num return single"},{"question":"# String Permutation Checker Problem Statement You are required to implement a function `are_permutations(str1, str2)` that checks whether two given strings `str1` and `str2` are permutations of each other. Two strings are permutations if they contain the same characters in the same frequency, but possibly in a different order. Input - Two strings `str1` and `str2`, each containing at most 10^5 characters. The strings will consist of only lowercase English letters. Output - Return `True` if `str1` and `str2` are permutations of each other; otherwise, return `False`. Constraints - The solution should have a time complexity of O(n) and space complexity of O(1), where `n` is the length of the longer string. - Handle edge cases such as empty strings and strings of different lengths appropriately. Example ```python are_permutations(\\"abc\\", \\"cba\\") # should return True are_permutations(\\"hello\\", \\"bello\\") # should return False are_permutations(\\"racecar\\", \\"carrace\\") # should return True are_permutations(\\"a\\", \\"\\") # should return False ``` Requirements 1. Implement the function `are_permutations(str1, str2)` with the expected input and output formats. 2. The function should be optimized for performance and handle edge cases correctly. 3. Write additional unit tests to validate your implementation against different scenarios including edge cases. Implementation Tips - Consider using a character count to efficiently compare the frequencies of each character in both strings. - Ensure that your function handles cases where the strings have different lengths, as these cannot be permutations of each other.","solution":"from collections import Counter def are_permutations(str1, str2): Returns True if str1 and str2 are permutations of each other. if len(str1) != len(str2): return False return Counter(str1) == Counter(str2)"},{"question":"# Problem Statement You are working on a data analysis project that requires implementing a function to create and manipulate a sparse matrix. Given a list of tuples representing non-zero elements in the matrix and the size of the matrix, your task is to create the sparse matrix and then count the number of non-zero elements in specified sub-regions. Implement the following function: # Function Specification **Function Name**: `sparse_matrix_query` **Input**: - `elements`: A list of tuples where each tuple contains three integers (row, column, value). Each tuple represents a non-zero element in the sparse matrix. - `rows`: An integer representing the number of rows in the matrix. - `cols`: An integer representing the number of columns in the matrix. - `queries`: A list of tuples where each tuple contains four integers (row_start, col_start, row_end, col_end). Each tuple represents a sub-region in the matrix (inclusive). **Output**: - A list of integers representing the count of non-zero elements in each specified sub-region. # Constraints: - The matrix can have up to 1000 rows and 1000 columns. - There can be up to 2000 non-zero elements and up to 500 queries. - The elements of the matrix and the queries are all valid within the given dimensions. # Example 1. Example 1: ```python elements = [(0, 1, 2), (2, 3, 5), (4, 0, 3)] rows = 5 cols = 5 queries = [(0, 0, 2, 2), (2, 2, 4, 4), (0, 0, 4, 4)] sparse_matrix_query(elements, rows, cols, queries) ``` Output: ```python [1, 1, 3] ``` 2. Example 2: ```python elements = [(1, 1, 4), (2, 2, 5), (3, 3, 6)] rows = 4 cols = 4 queries = [(0, 0, 1, 1), (1, 1, 3, 3), (0, 0, 3, 3)] sparse_matrix_query(elements, rows, cols, queries) ``` Output: ```python [1, 3, 3] ``` 3. Example 3: ```python elements = [(0, 2, 1), (3, 1, 2), (5, 5, 3)] rows = 6 cols = 6 queries = [(0, 0, 5, 5), (1, 1, 4, 4), (3, 3, 5, 5)] sparse_matrix_query(elements, rows, cols, queries) ``` Output: ```python [3, 1, 1] ``` *Note*: The matrix and queries are zero-indexed. The function should efficiently handle large matrices and multiple queries by leveraging the sparse nature of the input.","solution":"def sparse_matrix_query(elements, rows, cols, queries): Generates a sparse matrix from the given elements and counts the number of non-zero elements in the specified sub-regions defined by the queries. Parameters: - elements: List[Tuple[int, int, int]]: List of (row, column, value) indicating non-zero elements. - rows: int: Number of rows in the matrix. - cols: int: Number of columns in the matrix. - queries: List[Tuple[int, int, int, int]]: List of (row_start, col_start, row_end, col_end) indicating sub-regions. Returns: - List[int]: List containing counts of non-zero elements for each sub-region. from collections import defaultdict # Create a sparse representation of the matrix using a dictionary sparse_matrix = defaultdict(int) # Populate the sparse matrix with non-zero elements for row, col, value in elements: if value != 0: sparse_matrix[(row, col)] = value results = [] # Process each query for row_start, col_start, row_end, col_end in queries: count = 0 for (row, col), value in sparse_matrix.items(): if row_start <= row <= row_end and col_start <= col <= col_end: count += 1 results.append(count) return results"},{"question":"# Question Problem Statement You are developing a scheduling system for a conference where multiple speakers will present their talks. Each talk has a start time, an end time, and an importance value. The goal is to create a schedule that maximizes the importance of the talks that can be attended without any overlapping in their times. You need to write a function to select the optimal combination of talks using a greedy algorithm. Function Signature ```python def schedule_talks(talks: list) -> list: # Your code here ``` Definitions - `talks`: A list of dictionaries, where each dictionary represents a talk with the keys `start`, `end`, and `value`. - `start`: An integer representing the start time of the talk. - `end`: An integer representing the end time of the talk. - `value`: An integer representing the importance of the talk. Output The function should return a list of dictionaries representing the selected talks that maximize the total importance without any time overlaps. Constraints - Talks cannot overlap in time. - The selection should maximize the total importance of the included talks. - You must use a greedy algorithm for the selection process. Example Usage ```python talks = [ {\\"start\\": 1, \\"end\\": 3, \\"value\\": 50}, {\\"start\\": 2, \\"end\\": 4, \\"value\\": 30}, {\\"start\\": 3, \\"end\\": 5, \\"value\\": 40}, {\\"start\\": 0, \\"end\\": 6, \\"value\\": 60}, {\\"start\\": 5, \\"end\\": 7, \\"value\\": 20}, {\\"start\\": 8, \\"end\\": 9, \\"value\\": 10} ] print(schedule_talks(talks)) # Output should be a list of talks that can be attended without overlap, maximizing the total importance. ``` Notes - Ensure that your function handles edge cases such as talks that are entirely overlapping. - Consider the efficiency of your algorithm, especially the sorting and selection steps. - Think about how to handle multiple talks with the same start or end times but different importance values. - Make sure your function returns talks based on their non-overlapping, highest importance criteria.","solution":"def schedule_talks(talks: list) -> list: Function to schedule talks in a way that maximizes the total importance of the talks without any overlapping in their times. Parameters: talks (list): A list of dictionaries, each representing a talk with \'start\', \'end\', and \'value\' keys. Returns: list: A list of dictionaries representing the scheduled talks. # Step 1: Sort the talks by their ending time talks.sort(key=lambda x: x[\'end\']) # Step 2: Initialize the list of selected talks selected_talks = [] current_end_time = 0 # Step 3: Iterate through sorted talks and select talks that don\'t overlap for talk in talks: if talk[\'start\'] >= current_end_time: selected_talks.append(talk) current_end_time = talk[\'end\'] return selected_talks"},{"question":"# Question: You are tasked with implementing a function `reverse_in_groups(arr: list, k: int) -> list` that reverses the elements of the array in groups of size (k). If the number of elements in the last group is less than (k), reverse all the elements in that group as well. To solve this, follow these instructions: 1. Define a function `reverse_in_groups(arr: list, k: int) -> list` that takes an array `arr` and an integer `k`. 2. Traverse the array from the beginning, reversing every (k) elements. 3. Return the resultant array after processing all the groups. **Function Signature**: ```python def reverse_in_groups(arr: list, k: int) -> list: pass ``` **Input**: - `arr` (list): The list of integers to reverse in groups. - `k` (int): The size of the groups to reverse ((1 leq k leq len(arr))). **Output**: - list: A list of integers where the elements have been reversed in groups of size (k). **Constraints**: - The function should handle the case where (k) is larger than (len(arr)). - The function should return an empty list if `arr` is empty. - The function should raise `ValueError` if `k` is less than 1. **Examples**: ```python reverse_in_groups([1, 2, 3, 4, 5], 2) # Output: [2, 1, 4, 3, 5] reverse_in_groups([1, 2, 3, 4, 5], 3) # Output: [3, 2, 1, 5, 4] reverse_in_groups([1, 2, 3, 4, 5, 6, 7], 4) # Output: [4, 3, 2, 1, 7, 6, 5] reverse_in_groups([1, 2, 3, 4, 5], 1) # Output: [1, 2, 3, 4, 5] ``` Implement the `reverse_in_groups` function in Python. Ensure to handle negative and non-integer inputs for `k` correctly by raising appropriate exceptions.","solution":"def reverse_in_groups(arr: list, k: int) -> list: Reverses elements of the array in groups of size k. If the remaining elements are less than k, reverse all of them. Parameters: arr (list): The list of integers to reverse in groups. k (int): The size of the groups to reverse. Returns: list: A list of integers where elements have been reversed in groups of size k. Raises: ValueError: If k is less than 1. TypeError: If k is not an integer. if not isinstance(k, int): raise TypeError(\\"k must be an integer\\") if k < 1: raise ValueError(\\"k must be greater than 0\\") result = [] for i in range(0, len(arr), k): result.extend(arr[i:i+k][::-1]) return result"},{"question":"# Problem Statement Implement a function that generates a \\"word cloud\\" from a given text. This word cloud should ignore common English stopwords and represent the frequency of each word proportionally. # Function Signature ```python def generate_word_cloud(text: str, stopwords: List[str]) -> Dict[str, int]: Generates a word cloud from the input text, ignoring specified stopwords. Parameters: text (str): The input text to process. stopwords (List[str]): A list of common English stopwords to be ignored. Returns: Dict[str, int]: A dictionary representing the word cloud, where keys are words and values are their corresponding frequencies. ``` # Input * `text` (str): A string containing the input text for which the word cloud is to be generated. * `stopwords` (List[str]): A list of words to exclude from the word cloud. # Output * The function should return a dictionary where keys are words from the text (excluding stopwords) and values are their respective frequencies. # Constraints * Words should be treated case-insensitively, e.g., \\"Python\\" and \\"python\\" should be considered the same. * Punctuation marks should be ignored or removed. * The input text has a maximum length of 10,000 characters. # Example ```python text = \\"Python is great and python programming is fun. Learning python is essential in the current tech world.\\" stopwords = [\\"is\\", \\"and\\", \\"the\\", \\"in\\"] # Expected output: {\'python\': 3, \'great\': 1, \'programming\': 1, \'fun\': 1, \'learning\': 1, \'essential\': 1, \'current\': 1, \'tech\': 1, \'world\': 1} generate_word_cloud(text, stopwords) ``` # Notes * Make sure to normalize the text to a consistent case (e.g., all lowercase) before processing. * You can use regular expressions to remove punctuation and split words. * Be efficient with memory and processing to handle the maximum input size effectively. # Hints * Utilize Python\'s `re` module for regex operations. * Use a Python `Counter` or a dictionary to track word frequencies.","solution":"import re from collections import defaultdict from typing import List, Dict def generate_word_cloud(text: str, stopwords: List[str]) -> Dict[str, int]: # Normalize to lowercase text = text.lower() # Remove punctuation text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() # Use a set for fast lookup of stopwords stopwords_set = set(stopwords) # Calculate the frequency of each word, ignoring stopwords word_frequency = defaultdict(int) for word in words: if word not in stopwords_set: word_frequency[word] += 1 return dict(word_frequency)"},{"question":"# Coding Question: Hydrogen Atom Energy Level Calculation Given the formula for the energy levels of a hydrogen atom, you are required to write a function that computes the energy level of the electron within the atom or the energy released/absorbed when transitioning between two levels. Formula The energy level of an electron in a hydrogen atom can be found using the Rydberg formula: [ E_n = -frac{13.6text{eV}}{n^2} ] where ( E_n ) is the energy of the electron at level ( n ), and ( n ) is the principal quantum number. The energy change (( Delta E )) when transitioning from level ( n_i ) to ( n_f ) is: [ Delta E = E_{n_f} - E_{n_i} ] Function Signature ```python def hydrogen_atom_energy(n_initial: int, n_final: int) -> dict[str, float]: pass ``` Input Parameters * `n_initial` (int): The initial energy level (must be a positive integer). If zero, it indicates a calculation for the energy of the final level. * `n_final` (int): The final energy level (must be a positive integer). If zero, it indicates a calculation for the energy of the initial level. Output * A dictionary with the name of the calculated energy level or energy change, including: * The calculated energy level (`\'E_n_initial\'`, `\'E_n_final\'`). * The energy change between levels (`\'energy_change\'`). Constraints * At least one of the input parameters `n_initial` or `n_final` must be zero. * The function should raise a `ValueError` if: * Both `n_initial` and `n_final` are zero. * Any value other than zero is not a positive integer. Doctests ```python >>> hydrogen_atom_energy(n_initial=3, n_final=0) {\'E_n_final\': -3.4} >>> hydrogen_atom_energy(n_initial=0, n_final=2) {\'E_n_initial\': -13.6} >>> hydrogen_atom_energy(n_initial=2, n_final=1) {\'energy_change\': -10.2} >>> hydrogen_atom_energy(n_initial=0, n_final=0) Traceback (most recent call last): ... ValueError: Either n_initial or n_final must be a positive integer. >>> hydrogen_atom_energy(n_initial=3, n_final=-1) Traceback (most recent call last): ... ValueError: Both levels must be positive integers or zero. ``` Ensure your implementation complies with the provided formula and guidelines for error handling.","solution":"def hydrogen_atom_energy(n_initial: int, n_final: int) -> dict[str, float]: Calculate the energy levels or energy change for a hydrogen atom electron. Args: n_initial (int): The initial energy level. n_final (int): The final energy level. Returns: dict[str, float]: A dictionary with the calculated energy levels or energy change. Raises: ValueError: If both n_initial and n_final are zero, or either is not a positive integer. if (n_initial <= 0 and n_initial != 0) or (n_final <= 0 and n_final != 0): raise ValueError(\\"Both levels must be positive integers or zero.\\") if n_initial == 0 and n_final == 0: raise ValueError(\\"Either n_initial or n_final must be a positive integer.\\") def energy_level(n: int) -> float: return -13.6 / (n ** 2) result = {} if n_initial != 0 and n_final == 0: # Calculate final energy level for given initial level result[\\"E_n_final\\"] = energy_level(n_initial) elif n_initial == 0 and n_final != 0: # Calculate initial energy level for given final level result[\\"E_n_initial\\"] = energy_level(n_final) else: # Calculate energy transition E_initial = energy_level(n_initial) E_final = energy_level(n_final) result[\\"energy_change\\"] = E_final - E_initial return result"},{"question":"# Problem Statement You are tasked with implementing a function that finds the k-th smallest element in a list of integers. The function should be optimized for large lists using an appropriate selection algorithm. # Input Format - `arr`: A list of integers, where the length of the list is between 1 and 10^6. - `k`: An integer (1 ≤ k ≤ length of the list) which specifies the position (1-based index) of the smallest element to find. # Output Format - Return the k-th smallest integer from the input list. # Constraints - The list may contain duplicate values. - The function should be efficient and handle lists with up to 10^6 elements. # Function Signature ```python def kth_smallest(arr: List[int], k: int) -> int: pass ``` # Example Input ```python arr = [3, 2, 1, 5, 4] k = 3 ``` Output ```python 3 ``` # Notes - Consider using the Quickselect algorithm or other efficient selection algorithms to ensure the solution can handle the upper limit of input size. - Ensure your solution can handle edge cases, such as when the list contains all identical elements, or when `k` is 1 or the length of the list.","solution":"from typing import List import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low <= high: pi = partition(arr, low, high) if pi == k: return arr[pi] elif pi < k: return quickselect(arr, pi + 1, high, k) else: return quickselect(arr, low, pi - 1, k) def kth_smallest(arr: List[int], k: int) -> int: return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"**[Question 2]: Dynamic Programming: Longest Common Subsequence** Two archaeologists are analyzing two charred ancient manuscripts. They suspect that the texts share a common origin, and they are interested in finding the longest sequence of characters that appears in the same relative order in both texts (though not necessarily consecutively). This common sequence could provide insights into the shared content of the manuscripts. # Problem Statement You are given two strings, `text1` and `text2`. Your task is to find the length of the longest common subsequence (LCS) that can be derived from these two strings. # Task Implement the function `longest_common_subsequence(text1, text2)` that returns the length of the longest common subsequence shared by the two input strings. # Expected Input and Output Formats ```python def longest_common_subsequence(text1: str, text2: str) -> int: pass ``` - `text1`: A string representing the first manuscript. - `text2`: A string representing the second manuscript. **Output**: An integer representing the length of the longest subsequence common to both strings. # Constraints 1. `1 <= len(text1), len(text2) <= 1000` 2. `text1` and `text2` consist only of lowercase English letters. # Performance Requirements Your solution should efficiently handle the upper limits of the input sizes using dynamic programming techniques. # Scenario Consider you are working with partially preserved ancient manuscripts. The task is critical in understanding the overlapping content between two related texts, which help in piecing together historical information. # Example ```python text1 = \\"abcde\\" text2 = \\"ace\\" print(longest_common_subsequence(text1, text2)) # Output: 3 ``` In this example, the longest common subsequence between `text1` and `text2` is \\"ace\\", which has a length of 3. # Explanation The function calculates the length of the longest sequence of characters that appear in both text1 and text2 in the same order. Here, \'ace\' is the longest sequence that appears in both. Compose an efficient algorithm to find the LCS length to help the archaeologists with their manuscripts analysis. This solution can be implemented using a 2D dynamic programming table to keep track of the LCS lengths for all subproblems formed by prefixes of the input strings.","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) # Create a 2D DP array with (m+1) * (n+1) dimension dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Student Grades Analyzer You are tasked with developing a Python function to analyze and summarize students\' grades from a CSV file. Each row in the file includes a student\'s name and their grades for multiple subjects. Requirements 1. **Function Implementation**: - Implement a function `analyze_grades(file_path: str) -> dict`, which takes the file path of a CSV as input and returns a dictionary containing various statistical insights. 2. **Input and Output Formats**: - **Input**: * `file_path` (string): The path to the CSV file containing the students\' grades. - **Output**: * A dictionary with the following keys and their corresponding values: * `\\"highest_average\\"`: The name of the student with the highest average grade. * `\\"lowest_average\\"`: The name of the student with the lowest average grade. * `\\"subject_averages\\"`: A dictionary where keys are subject names and values are the average grades for those subjects. 3. **Constraints**: - Assume the CSV file has the following structure: ``` Name,Math,Science,English,History Alice,90,85,88,92 Bob,78,82,80,76 Charlie,95,95,98,90 ``` - Handle missing or malformed data gracefully by skipping invalid rows and logging a warning. - Ensure that the function can handle large files efficiently. 4. **Performance Requirements**: - Efficiently read and process the CSV file. - Ensure that the solution is optimized for time and space complexity. Example CSV Content ``` Name,Math,Science,English,History Alice,90,85,88,92 Bob,78,82,80,76 Charlie,95,95,98,90 Denise,invalid,87,84,82 ``` Expected Output For the example CSV provided above, the output should be: ```python { \\"highest_average\\": \\"Charlie\\", \\"lowest_average\\": \\"Bob\\", \\"subject_averages\\": { \\"Math\\": 87.67, \\"Science\\": 87.25, \\"English\\": 87.5, \\"History\\": 85.0 } } ``` # Implementation Note - Ensure the function correctly handles edge cases such as invalid grade entries by skipping those entries and logging a warning. - You may use the `csv` module in Python to handle CSV file reading. ```python import csv from statistics import mean def analyze_grades(file_path: str) -> dict: Anaylze students\' grades from a CSV file and return statistical insights. students = {} subject_totals = {} subject_counts = {} with open(file_path, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: name = row[\'Name\'] grades = [] for subject, grade in row.items(): if subject == \'Name\' or grade == \'invalid\': continue try: grade = float(grade) except ValueError: continue grades.append(grade) if subject not in subject_totals: subject_totals[subject] = 0 subject_counts[subject] = 0 subject_totals[subject] += grade subject_counts[subject] += 1 if grades: students[name] = mean(grades) if not students: return {} highest_average = max(students, key=students.get) lowest_average = min(students, key=students.get) subject_averages = {sub: tot / cnt for sub, tot, cnt in zip(subject_totals.keys(), subject_totals.values(), subject_counts.values())} return { \'highest_average\': highest_average, \'lowest_average\': lowest_average, \'subject_averages\': subject_averages } if __name__ == \\"__main__\\": file_path = \'path_to_your_csv_file.csv\' print(analyze_grades(file_path)) ```","solution":"import csv from statistics import mean def analyze_grades(file_path: str) -> dict: Analyze students\' grades from a CSV file and return statistical insights. students = {} subject_totals = {} subject_counts = {} with open(file_path, newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: name = row[\'Name\'] grades = [] for subject, grade in row.items(): if subject == \'Name\' or grade == \'invalid\': continue try: grade = float(grade) except ValueError: continue grades.append(grade) if subject not in subject_totals: subject_totals[subject] = 0 subject_counts[subject] = 0 subject_totals[subject] += grade subject_counts[subject] += 1 if grades: students[name] = mean(grades) if not students: return {} highest_average = max(students, key=students.get) lowest_average = min(students, key=students.get) subject_averages = {sub: round(tot / cnt, 2) for sub, tot, cnt in zip(subject_totals.keys(), subject_totals.values(), subject_counts.values())} return { \'highest_average\': highest_average, \'lowest_average\': lowest_average, \'subject_averages\': subject_averages }"},{"question":"# Coding Assessment Question Background & Context You are developing a report generation system for a retail company. One of its features generates detailed daily sales reports using the CSV files that contain transaction data. Each row in the CSV file represents a transaction with columns for `date`, `store_id`, `item_id`, `quantity`, and `total_price`. Task Write a function `generate_daily_report` that takes the path to a CSV file of transactions and a specific date as input and generates a daily sales report for that date. The report should include the total sales and quantities sold for each item and the overall total sales. Function Signature ```python def generate_daily_report(csv_path: str, date: str) -> dict: Generates a daily sales report for the specified date. :param csv_path: str, path of the CSV file containing transaction data :param date: str, the date for which the report should be generated in \\"YYYY-MM-DD\\" format :return: dict, a dictionary containing the report with item-wise and overall totals ``` Input and Output Format * **Input**: - `csv_path` (str): Path to the CSV file containing transaction data. - `date` (str): The date for which the report should be generated, in \\"YYYY-MM-DD\\" format. * **Output**: - A dictionary with a breakdown of total quantities and sales for each item and the overall totals. Constraints * The `csv_path` file exists and follows the expected format. * The `date` is valid and matches the \\"YYYY-MM-DD\\" format. * Efficiently process the CSV file even if it contains a large number of transactions. Example Suppose the CSV file at `csv_path` contains the following data: ``` date,store_id,item_id,quantity,total_price 2023-02-25,1,A123,10,100.0 2023-02-25,1,B456,5,50.0 2023-02-24,1,A123,3,30.0 2023-02-25,2,A123,7,70.0 2023-02-25,2,B456,2,20.0 ``` And the `date` provided is \\"2023-02-25\\". Your `generate_daily_report` function should return: ```python { \\"items\\": { \\"A123\\": {\\"total_quantity\\": 17, \\"total_sales\\": 170.0}, \\"B456\\": {\\"total_quantity\\": 7, \\"total_sales\\": 70.0}, }, \\"overall\\": { \\"total_quantity\\": 24, \\"total_sales\\": 240.0, } } ``` Notes * Use the `csv` module to handle reading the CSV file. * Ensure that all transactions for the specified date are accurately aggregated. * Focus on handling large files efficiently and managing memory usage appropriately.","solution":"import csv from collections import defaultdict def generate_daily_report(csv_path: str, date: str) -> dict: Generates a daily sales report for the specified date. :param csv_path: str, path of the CSV file containing transaction data :param date: str, the date for which the report should be generated in \\"YYYY-MM-DD\\" format :return: dict, a dictionary containing the report with item-wise and overall totals items = defaultdict(lambda: {\\"total_quantity\\": 0, \\"total_sales\\": 0.0}) overall_total_quantity = 0 overall_total_sales = 0.0 with open(csv_path, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: if row[\'date\'] == date: item_id = row[\'item_id\'] quantity = int(row[\'quantity\']) total_price = float(row[\'total_price\']) items[item_id][\'total_quantity\'] += quantity items[item_id][\'total_sales\'] += total_price overall_total_quantity += quantity overall_total_sales += total_price return { \\"items\\": dict(items), \\"overall\\": { \\"total_quantity\\": overall_total_quantity, \\"total_sales\\": overall_total_sales, } }"},{"question":"# Array Permutation Matcher Objective Create a function to check if one array is a permutation of another array. The function should handle arrays of integers and return a boolean indicating if the arrays are permutations of each other. Problem Scenario In data manipulation and analysis, verifying the structure and content of data collections is crucial. One common task is checking whether one array is a re-arrangement (permutation) of another. Implement a method to verify this efficiently. Task Write a function `is_permutation(arr1, arr2)` that determines if the array `arr1` is a permutation of the array `arr2`. Function Signature ```python def is_permutation(arr1: List[int], arr2: List[int]) -> bool: pass ``` Input * `arr1`: a list of integers. * `arr2`: a list of integers. Output * Returns `True` if `arr1` is a permutation of `arr2`, otherwise returns `False`. Constraints * Each list will have a length of at least 1 and at most 100,000 elements. * Each element in `arr1` and `arr2` will be an integer within the range of -1,000,000 to 1,000,000. * The function should handle arrays of different lengths gracefully. Examples ```python print(is_permutation([1, 2, 3], [3, 2, 1])) # Should print: True print(is_permutation([1, 2, 2], [2, 1, 1])) # Should print: False print(is_permutation([4, 5, 6], [6, 4, 5])) # Should print: True print(is_permutation([7, 8], [8, 7, 8])) # Should print: False print(is_permutation([], [])) # Should print: True ``` Constraints & Edge Cases * Handle empty arrays properly (two empty arrays are permutations of each other). * Handle cases with repeated elements appropriately. * Consider arrays where the order of elements is different but they contain the same elements in different frequencies. Good luck!","solution":"from typing import List def is_permutation(arr1: List[int], arr2: List[int]) -> bool: Determines if arr1 is a permutation of arr2. if len(arr1) != len(arr2): return False return sorted(arr1) == sorted(arr2)"},{"question":"# Context: As a software developer, you are tasked with implementing efficient processes for querying and updating large datasets. One such operation frequently needed is finding the nth largest element in an unsorted list, which is a common problem in data analysis and manipulation. # Problem: You need to create a function that determines the nth largest number in a given list. If the list contains duplicates, these should be treated as distinct values for the purpose of ranking. # Function Signature: ```python def nth_largest(lst: List[int], n: int) -> int | None: Finds the nth largest distinct element in the given list. :param lst: A list of integers. :param n: An integer representing the rank to find. :return: The nth largest element or `None` if the input parameters are not feasible. ``` # Input: - `lst`: A list of integers. `[List[int]]` - `n`: An integer indicating the desired ranking. `[int]` # Output: - The nth largest integer in the list if it exists; otherwise `None`. # Constraints: 1. The list `lst` must not be empty. 2. The value of `n` must be a positive integer such that 1 ≤ n ≤ len(lst). # Examples: ```python >>> lst = [3, 2, 1, 5, 6, 4] >>> nth_largest(lst, 2) 5 >>> lst = [3, 2, 1, 5, 6, 4] >>> nth_largest(lst, 4) 3 >>> lst = [3, 2, 2, 1, 5, 6, 4] >>> nth_largest(lst, 3) 4 >>> lst = [1, 2] >>> nth_largest(lst, 3) None ``` # Notes: - Ensure to handle cases where `n` is out of the bounds of the list length. - The list should be processed efficiently to handle large datasets within reasonable time limits. - Consider edge cases such as lists with all duplicate elements or requests for rankings exceeding the list size.","solution":"from typing import List, Optional def nth_largest(lst: List[int], n: int) -> Optional[int]: Finds the nth largest distinct element in the given list. :param lst: A list of integers. :param n: An integer representing the rank to find. :return: The nth largest element or `None` if the input parameters are not feasible. if not lst or n <= 0 or n > len(lst): return None # Get the unique values and sort them in descending order unique_sorted_list = sorted(set(lst), reverse=True) # Check if n is within the unique list size if n > len(unique_sorted_list): return None return unique_sorted_list[n - 1]"},{"question":"# Problem Statement **Balanced Brackets with String Reversal** Given a string containing the characters `{`, `}`, `[`, `]`, `(`, and `)`, determine if the string has balanced brackets. Additionally, if the string is not balanced, determine if reversing any single contiguous substring of the original string can make the brackets balanced. Write a function called `is_balanced_or_can_be_reversed(s: str) -> str` that handles the logic. # Input - `s`: A string consisting of `{`, `}`, `[`, `]`, `(`, and `)`. # Output - Returns `\'Balanced\'` if the input string is initially balanced. - Returns `\'Can be balanced by reversing\'` if the string is not balanced but can be made balanced by reversing any single contiguous substring. - Returns `\'Not balanced\'` if neither of the above conditions is met. # Constraints - The length of `s` will not exceed `10^5`. # Example ```python >>> is_balanced_or_can_be_reversed(\\"([])\\") \'Balanced\' >>> is_balanced_or_can_be_reversed(\\"([)]\\") \'Can be balanced by reversing\' >>> is_balanced_or_can_be_reversed(\\"([{})\\") \'Not balanced\' ``` # Notes - A string is considered balanced if for every opening bracket there is a corresponding closing bracket in the correct order. - Efficiently check if any single substring reversal can balance the string using optimal algorithms for large input sizes. - Consider edge cases where the string has the correct set of brackets in the wrong order.","solution":"def is_balanced(s): Helper function to check if a string has balanced brackets. stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == [] def reverse_and_check_balanced(s, i, j): Helper function to check if reversing a substring can lead to a balanced string. modified_s = s[:i] + s[i:j+1][::-1] + s[j+1:] return is_balanced(modified_s) def is_balanced_or_can_be_reversed(s: str) -> str: if is_balanced(s): return \'Balanced\' n = len(s) for i in range(n): for j in range(i + 1, n): if reverse_and_check_balanced(s, i, j): return \'Can be balanced by reversing\' return \'Not balanced\'"},{"question":"# Question: Remove K Digits to Form Smallest Number Given a non-negative integer represented as a string `num` and an integer `k`, remove `k` digits from the number so that the new number is the smallest possible. **Function Signature**: ```python def remove_k_digits(num: str, k: int) -> str: ... ``` # Input - `num`: A string consisting of digits representing a non-negative integer. (1 ≤ len(num) ≤ 10^5) - `k`: A non-negative integer. (0 ≤ k ≤ len(num)) # Output - Return the smallest possible number as a string after removing `k` digits from `num`. # Constraints * The result should not contain any leading zeros. * The output should be \\"0\\" if the resulting number is empty. # Examples ```python # Example 1 assert remove_k_digits(\\"1432219\\", 3) == \\"1219\\" # Example 2 assert remove_k_digits(\\"10200\\", 1) == \\"200\\" # Example 3 assert remove_k_digits(\\"10\\", 2) == \\"0\\" # Example 4 assert remove_k_digits(\\"1234567890\\", 9) == \\"0\\" ``` # Description - Your task is to implement the function `remove_k_digits(num: str, k: int) -> str` which returns the smallest possible number after removing `k` digits from the input string `num`. - **Remove K Digits**: * The goal is to remove digits such that the resulting number is as small as possible. * If the number becomes 0 after removing the digits, return \\"0\\". * Follow the constraint that the result should not have leading zeros unless it is zero itself. # Notes * Consider edge cases like when `k` is zero (no digits should be removed) or when `k` equals the length of `num` (the result should be \\"0\\"). * Aim for an optimal solution that manages large input sizes efficiently.","solution":"def remove_k_digits(num: str, k: int) -> str: Removes k digits from the num string to form the smallest possible number. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are any remaining digits to remove, remove them from the end while k > 0: stack.pop() k -= 1 # Convert the stack to a string and remove leading zeros result = \\"\\".join(stack).lstrip(\'0\') # If the result is empty, return \'0\' return result if result else \\"0\\""},{"question":"# Problem Statement You are given a list of integers. Your task is to write a function `longest_increasing_subarray(lst: List[int]) -> int` that returns the length of the longest increasing contiguous subarray in the list. # Input Format - A list of integers `lst` (0 ≤ `len(lst)` ≤ 100,000). # Output Format - A single integer representing the length of the longest increasing contiguous subarray. # Constraints - The list can be of any size from empty to 100,000 elements. - Consider edge cases where the list is empty or has one element. # Performance Requirements - Your solution should run in linear time relative to the size of the list. # Example ```python >>> longest_increasing_subarray([1, 3, 5, 4, 7]) 3 >>> longest_increasing_subarray([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subarray([]) 0 >>> longest_increasing_subarray([10, 20, 30, 40, 50]) 5 ``` # Analysis To solve this problem, iterate through the list while maintaining a count of the current increasing subarray length. Whenever an element is not greater than the previous element, reset the count. Keep track of the maximum length encountered during the iteration. # Constraints & Edge Cases 1. Handle cases where the list is empty. 2. Ensure the algorithm efficiently identifies and counts increasing subarrays without excessive recomputation. Implement the function `longest_increasing_subarray` below: ```python from typing import List def longest_increasing_subarray(lst: List[int]) -> int: if not lst: return 0 max_len = 1 current_len = 1 for i in range(1, len(lst)): if lst[i] > lst[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len # You may write your own test cases to validate your solution if __name__ == \\"__main__\\": print(longest_increasing_subarray([1, 3, 5, 4, 7])) # Should output 3 print(longest_increasing_subarray([2, 2, 2, 2, 2])) # Should output 1 print(longest_increasing_subarray([])) # Should output 0 print(longest_increasing_subarray([10, 20, 30, 40, 50])) # Should output 5 ```","solution":"from typing import List def longest_increasing_subarray(lst: List[int]) -> int: if not lst: return 0 max_len = 1 current_len = 1 for i in range(1, len(lst)): if lst[i] > lst[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"# Graph Depth Calculation You are provided with an adjacency list representing an undirected graph. Your task is to write a function that computes the maximum depth (or height) of the graph starting from a given node, using Depth First Search (DFS). The depth is defined as the number of vertices from the starting node (inclusive) to the farthest vertex reachable within the connected component containing the starting node. Task 1. **Function Name**: `max_depth_of_graph` 2. **Input**: An adjacency list represented as a dictionary where the keys are node identifiers (integers or strings), and the values are lists of adjacent nodes. A starting node identifier. 3. **Output**: An integer representing the maximum depth of the graph starting from the given node. 4. **Constraints**: - The graph contains no cycles. - The graph can have up to 10^4 nodes and 2 * 10^4 edges. - Node identifiers are unique and can be any hashable type (i.e., integer, string). Requirements - Handle edge cases effectively, such as graphs with no edges or a single node. - Optimize for performance, ensuring the function efficiently handles deep and wide graphs. - Ensure the function correctly returns depth, even if the graph is disconnected. Example ```python def max_depth_of_graph(graph: dict, start_node) -> int: visited = set() def dfs(node, depth): if node in visited: return depth - 1 visited.add(node) max_depth = depth for neighbor in graph.get(node, []): max_depth = max(max_depth, dfs(neighbor, depth + 1)) return max_depth return dfs(start_node, 1) #Example cases graph1 = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2] } print(max_depth_of_graph(graph1, 1)) # Expected output: 3 graph2 = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"] } print(max_depth_of_graph(graph2, \\"A\\")) # Expected output: 3 graph3 = { 1: [2], 2: [1], 3: [4], 4: [3] } print(max_depth_of_graph(graph3, 1)) # Expected output: 2 print(max_depth_of_graph(graph3, 3)) # Expected output: 2 print(max_depth_of_graph({}, \'start\')) # Expected output: 0 graph4 = { 1: [] } print(max_depth_of_graph(graph4, 1)) # Expected output: 1 ``` You can include unit tests to verify the correctness of your function, especially for edge cases, disconnected graphs, and performance on larger datasets.","solution":"def max_depth_of_graph(graph: dict, start_node) -> int: visited = set() def dfs(node, depth): if node in visited: return depth - 1 visited.add(node) max_depth = depth for neighbor in graph.get(node, []): max_depth = max(max_depth, dfs(neighbor, depth + 1)) return max_depth if start_node not in graph: return 0 return dfs(start_node, 1)"},{"question":"Matrix Zigzag Traversal # Objective Implement a Python function to traverse a given matrix in a zigzag order. The order of traversal should be a diagonal traversal where elements are accessed in a top-down and bottom-up sequence alternatively. # Description Given a matrix, you need to implement a function that returns the elements of the matrix in a zigzag order. The zigzag order is defined as the sequence of elements when traversing the matrix diagonally. Start from the top-left element and traverse diagonally to the bottom-right element, switching the direction of traversal on alternating diagonals. # Requirements 1. Implement the `zigzag_traversal` function that takes a 2D list (matrix) of integers and returns a list of integers representing the matrix elements in the zigzag order. # Input - `matrix` (list of list of int): A 2D list of integers representing the matrix to be traversed. # Output - List of integers representing the matrix elements in zigzag order. # Constraints 1. `1 <= len(matrix) <= 100` 2. `1 <= len(matrix[0]) <= 100` # Example ```python def zigzag_traversal(matrix: list[list[int]]) -> list[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] for line in range(rows + cols - 1): if line % 2 == 0: row = line if line < rows else rows - 1 col = 0 if line < rows else line - (rows - 1) while row >= 0 and col < cols: result.append(matrix[row][col]) row -= 1 col += 1 else: row = 0 if line < cols else line - (cols - 1) col = line if line < cols else cols - 1 while col >= 0 and row < rows: result.append(matrix[row][col]) row += 1 col -= 1 return result # Example usage: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(zigzag_traversal(matrix)) # Output: [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` * Ensure the function handles both square and rectangular matrices. * Optimize for performance considering the constraints. # Notes - The input matrix can have different numbers of rows and columns. - The zigzag traversal should switch direction at each diagonal boundary. This question tests your understanding of matrix traversal and diagonal access patterns, requiring the implementation of logical conditions and loop control for correct traversal.","solution":"def zigzag_traversal(matrix: list[list[int]]) -> list[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) result = [] for line in range(rows + cols - 1): if line % 2 == 0: row = line if line < rows else rows - 1 col = 0 if line < rows else line - (rows - 1) while row >= 0 and col < cols: result.append(matrix[row][col]) row -= 1 col += 1 else: row = 0 if line < cols else line - (cols - 1) col = line if line < cols else cols - 1 while col >= 0 and row < rows: result.append(matrix[row][col]) row += 1 col -= 1 return result"},{"question":"Problem Statement You are tasked to implement a function `find_middle_value` that finds the median value within a list of integers with an odd number of elements. The median of a list is the middle element when the list is sorted in ascending order. Assume the given list always contains an odd number of elements. # Function Signature ```python def find_middle_value(nums: list[int]) -> int: pass ``` # Input - `nums`: A list of integers. The length of the list is always odd. # Output - Returns an integer that is the median value of the list. # Constraints - `1 <= len(nums) <= 10^5` - `-10^9 <= nums[i] <= 10^9` # Requirements - Your implementation should sort the list and then find the middle element. - Ensure an efficient approach that handles large lists within time limits. # Example Example 1: ```python nums = [1, 3, 2] find_middle_value(nums) ``` **Output**: `2` Example 2: ```python nums = [7, 5, 2, 1, 9] find_middle_value(nums) ``` **Output**: `5` Example 3: ```python nums = [-5, -2, -3, -1, -4] find_middle_value(nums) ``` **Output**: `-3` # Additional Requirements - Optimize your solution to run efficiently for large lists. - Consider using efficient sorting algorithms available in Python\'s standard library. # Hints - Utilize Python\'s built-in sorting functions or libraries for optimal performance.","solution":"def find_middle_value(nums: list[int]) -> int: Returns the median value from a list of integers with an odd number of elements. # Sort the list sorted_nums = sorted(nums) # Find the middle index middle_index = len(sorted_nums) // 2 # Return the middle element return sorted_nums[middle_index]"},{"question":"# Coding Assessment Question Scenario You are developing a utility to analyze sequences of integers for certain properties. One common task is to determine whether a sequence is a palindrome. A sequence of integers is considered a palindrome if it reads the same backward as forward. Task Write a function `is_palindrome` that takes a list of integers and returns whether it is a palindrome. Function Signature ```python def is_palindrome(sequence: List[int]) -> bool: ``` Input * `sequence`: A list of integers. Output * A boolean value, `True` if the sequence is a palindrome, `False` otherwise. Examples ```python >>> is_palindrome([1, 2, 3, 2, 1]) True >>> is_palindrome([1, 2, 3, 4, 5]) False >>> is_palindrome([1, 1, 1, 1]) True >>> is_palindrome([1, 2, 2, 1]) True >>> is_palindrome([1, 2, 3, 4, 1]) False ``` Explanation of Examples * In the first example, `[1, 2, 3, 2, 1]` is the same forward and backward, hence it is a palindrome. * In the second example, `[1, 2, 3, 4, 5]` is not the same backward, hence it is not a palindrome. * In the third example, `[1, 1, 1, 1]` is the same forward and backward, hence it is a palindrome. * In the fourth example, `[1, 2, 2, 1]` is the same forward and backward, hence it is a palindrome. * In the fifth example, `[1, 2, 3, 4, 1]` is not the same backward, hence it is not a palindrome. Performance Requirements * The function should execute in linear time O(n), where n is the length of the sequence.","solution":"def is_palindrome(sequence): Returns True if the given sequence of integers is a palindrome, False otherwise. return sequence == sequence[::-1]"},{"question":"# String Compression Algorithm **Scenario**: You are required to implement a basic string compression algorithm. The algorithm should compress a string such that \'aaabb\' becomes \'a3b2\'. If the compressed string is not smaller than the original string, the function should return the original string. **Objective**: Write a function `compress_string(input_string: str) -> str` that compresses the given string using the described rules. **Input**: - `input_string` (str): A non-empty string consisting of only lowercase alphabetical characters. **Output**: - A compressed version of the string if it is shorter than the original, otherwise, the original string. **Constraints**: - 1 <= len(input_string) <= 5000 **Performance Requirements**: - Your implementation should handle the upper constraint limits efficiently. **Example**: ```python # Example 1 input_string_1 = \\"aabcccccaaa\\" result_1 = compress_string(input_string_1) # Expected output: \\"a2b1c5a3\\" # Example 2 input_string_2 = \\"abcdef\\" result_2 = compress_string(input_string_2) # Expected output: \\"abcdef\\" because compressed string is not smaller ``` Implement the function `compress_string` following the specified guidelines and ensure to handle performance, edge cases, and efficiency effectively.","solution":"def compress_string(input_string: str) -> str: compressed = [] count = 1 length = len(input_string) for i in range(1, length): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1] + str(count)) count = 1 # Append the last character and its count compressed.append(input_string[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < length else input_string"},{"question":"# Coding Assessment Question Context: You are building a budgeting tool for personal finance tracking. The tool should help users categorize their transactions based on specified rules. Categories are defined by keywords that might appear in transaction descriptions. Your task is to develop a function that categorizes transactions accurately and efficiently. Task: Implement the function `categorize_transactions` to classify a list of transactions based on given category rules. Each category rule consists of a category name and a list of keywords. Transactions should be categorized according to the keywords they contain in their descriptions. Requirements: 1. **Function Signature**: ```python def categorize_transactions(transactions: list, category_rules: dict) -> dict: ``` 2. **Input**: * `transactions` (list): A list of dictionaries where each dictionary represents a transaction with a description and an amount. Example format: ```python [ {\\"description\\": \\"Grocery shopping at Walmart\\", \\"amount\\": 50.25}, {\\"description\\": \\"Monthly subscription to Netflix\\", \\"amount\\": 12.99}, ... ] ``` * `category_rules` (dict): A dictionary where each key is a category name and each value is a list of keywords. Example format: ```python { \\"Groceries\\": [\\"grocery\\", \\"walmart\\", \\"supermarket\\"], \\"Entertainment\\": [\\"netflix\\", \\"cinema\\", \\"theater\\"], ... } ``` 3. **Output**: * `dict`: A dictionary where each key is a category name and each value is a list of transaction amounts that fall under that category. 4. **Constraints**: * Each transaction can belong to only one category based on the first matching keyword found. * If a transaction description matches keywords from multiple categories, categorize it under the category whose keyword appears first in the description. * If a transaction description does not match any keyword, categorize it under \\"Uncategorized\\". 5. **Performance Requirements**: * The function should efficiently categorize transactions even for a large number of transactions and categories. Example Usage: ```python transactions = [ {\\"description\\": \\"Grocery shopping at Walmart\\", \\"amount\\": 50.25}, {\\"description\\": \\"Monthly subscription to Netflix\\", \\"amount\\": 12.99}, {\\"description\\": \\"Dinner at local restaurant\\", \\"amount\\": 30.00}, {\\"description\\": \\"Gas for car\\", \\"amount\\": 40.00} ] category_rules = { \\"Groceries\\": [\\"grocery\\", \\"walmart\\", \\"supermarket\\"], \\"Entertainment\\": [\\"netflix\\", \\"cinema\\", \\"theater\\"], \\"Dining\\": [\\"restaurant\\", \\"dinner\\", \\"lunch\\"], \\"Transportation\\": [\\"gas\\", \\"uber\\", \\"train\\"] } result = categorize_transactions(transactions, category_rules) # Expected Output # { # \\"Groceries\\": [50.25], # \\"Entertainment\\": [12.99], # \\"Dining\\": [30.00], # \\"Transportation\\": [40.00], # \\"Uncategorized\\": [] # } ``` Hints: * Use efficient string searching techniques to match keywords in the transaction descriptions. * Consider edge cases where descriptions contain multiple keywords or no keywords from any category. Good luck!","solution":"def categorize_transactions(transactions, category_rules): categorized_transactions = {category: [] for category in category_rules} categorized_transactions[\\"Uncategorized\\"] = [] for transaction in transactions: description = transaction[\\"description\\"].lower() amount = transaction[\\"amount\\"] categorized = False for category, keywords in category_rules.items(): for keyword in keywords: if keyword in description: categorized_transactions[category].append(amount) categorized = True break if categorized: break if not categorized: categorized_transactions[\\"Uncategorized\\"].append(amount) return categorized_transactions"},{"question":"# Coding Question: Finding Bridges in an Undirected Graph Problem Statement Given an undirected graph represented as an adjacency list, write a function `find_bridges` that identifies all bridges in the graph. A bridge (or cut-edge) is an edge which, when removed, increases the number of connected components in the graph. Function Signature ```python def find_bridges(graph: Dict[int, List[int]]) -> List[Tuple[int, int]]: ``` Input - `graph`: A dictionary representing the undirected graph. The keys are node identifiers (integers) and the values are lists of adjacent node identifiers. Output - A list of tuples representing the bridges of the graph. Each tuple contains two integers representing the nodes connected by the bridge. Constraints - The graph will be connected and may contain up to `10^4` nodes. Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 5], 3: [2, 4], 4: [3], 5: [2, 6, 8], 6: [5, 7], 7: [6, 8], 8: [5, 7], } find_bridges(graph) # Output: [(2, 3), (2, 5), (3, 4)] ``` Ensure your solution is optimized for graphs with up to `10^4` nodes and adheres to the time complexity of O(V + E). Consider edge cases such as single-edge graphs, graphs with no bridges, and graphs with multiple bridges.","solution":"from typing import List, Dict, Tuple def find_bridges(graph: Dict[int, List[int]]) -> List[Tuple[int, int]]: def dfs(u, parent): nonlocal timer vis[u] = True tin[u] = low[u] = timer timer += 1 for v in graph[u]: if v == parent: continue if vis[v]: # Back edge low[u] = min(low[u], tin[v]) else: # Tree edge dfs(v, u) low[u] = min(low[u], low[v]) if low[v] > tin[u]: bridges.append((u, v)) n = len(graph) timer = 0 tin = [-1] * n low = [-1] * n vis = [False] * n bridges = [] for i in graph: if not vis[i]: dfs(i, -1) return bridges"},{"question":"# Fibonacci Sequence Generator with Conditional Caching As a systems engineer, you are tasked with enhancing the performance of a Fibonacci sequence generator by implementing a conditional caching mechanism. This mechanism will cache the Fibonacci numbers only if they are even. Your goal is to strike a balance between space efficiency and time efficiency. Requirements: 1. Implement a function that generates the Fibonacci sequence up to a given `n` terms. 2. Cache the calculated Fibonacci numbers selectively – only even numbers should be cached. 3. Ensure the function checks the cache before performing any recalculations. # Function Specification Implement a function `fibonacci_with_cache(n: int) -> List[int]` that generates the first `n` Fibonacci numbers, caching only the even numbers for subsequent calls. Inputs: - `n`: An integer specifying the number of terms in the Fibonacci sequence to generate. Outputs: - A list of integers representing the first `n` Fibonacci numbers. Constraints: - `n` will be a non-negative integer. - The cache should be implemented using a dictionary where keys are indices and values are the even Fibonacci numbers at those indices. Performance Requirements: - Your solution should maintain O(1) access time for cached elements, leveraging the efficiency of the dictionary. Example Usage: ```python fib_sequence = fibonacci_with_cache(10) print(fib_sequence) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Even Fibonacci numbers cached: {2: 2, 6: 8, 9: 34} ```","solution":"def fibonacci_with_cache(n): Generates the first n Fibonacci numbers and caches the even numbers. if n <= 0: return [] fib_cache = {} fib_sequence = [] def fib(k): if k in fib_cache: return fib_cache[k] if k == 0: result = 0 elif k == 1: result = 1 else: result = fib(k-1) + fib(k-2) if result % 2 == 0: fib_cache[k] = result return result for i in range(n): fib_sequence.append(fib(i)) return fib_sequence"},{"question":"# Problem Statement You are tasked with creating a function to efficiently determine the unique words in a list of sentences. The function should normalize the words by converting them to lowercase and strip any punctuation. # Problem Description Given a list of sentences, identify all unique words in the provided text. Normalize the words by converting them to lowercase and removing any punctuation marks (i.e., .,!?). # Requirements * Implement the function `unique_words(sentences: List[str]) -> List[str]`. * Combine all sentences into a single string. * Convert the text to lowercase and remove all punctuation from the words. * Split the normalized text into individual words and identify the unique words. * Return the list of unique words sorted in alphabetical order. # Input * `sentences` - A list of strings, each representing a sentence. ```python sentences = [\\"Hello world!\\", \\"This is a Test.\\", \\"Is this a test?\\"] ``` # Output * Return a list of unique words sorted in alphabetical order. ```python [\\"a\\", \\"hello\\", \\"is\\", \\"test\\", \\"this\\", \\"world\\"] ``` # Constraints * The total length of all sentences combined should not exceed (10^5) characters. * Each individual sentence should not exceed 1000 characters in length. * Words and sentences are case-insensitive. # Function Signature ```python from typing import List def unique_words(sentences: List[str]) -> List[str]: pass ``` # Example Input ```python sentences = [\\"Python is great!\\", \\"It\'s great to learn Python.\\", \\"hello hello, great world!\\"] ``` Output ```python [\\"great\\", \\"hello\\", \\"is\\", \\"its\\", \\"learn\\", \\"python\\", \\"to\\", \\"world\\"] ``` Note: In the above example, punctuation is removed and all words are converted to lowercase before identifying unique words and sorting them alphabetically.","solution":"from typing import List import re def unique_words(sentences: List[str]) -> List[str]: Identifies unique words from a list of sentences and returns them sorted in alphabetical order. The function normalizes words by converting them to lowercase and removing punctuation. # Combine all sentences into a single string combined_text = \\" \\".join(sentences) # Convert the text to lowercase combined_text = combined_text.lower() # Remove punctuation using regex combined_text = re.sub(r\'[^ws]\', \'\', combined_text) # Split the text into words words = combined_text.split() # Identify unique words unique_words = sorted(set(words)) return unique_words"},{"question":"# Analyzing Sales Data You are to create a function `top_selling_products(sales_data: List[dict], top_n: int) -> List[str]` that processes sales data to determine the top `N` selling products. Each sale is recorded as a dictionary with the following structure: - `product_id`: A unique identifier for the product (string) - `revenue`: The revenue generated from the sale (float) Your function should return a list of product IDs of the top `N` selling products based on total revenue, sorted in descending order of total revenue. If two products have the same total revenue, they should be sorted lexicographically by their product ID. Input: - `sales_data` (List[dict]): A list of dictionaries representing sales records. - `top_n` (int): The number of top selling products to return. Output: - A list of strings representing the product IDs of the top `N` selling products. # Example ```python sales_data = [ {\\"product_id\\": \\"A123\\", \\"revenue\\": 500.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"A123\\", \\"revenue\\": 700.0}, {\\"product_id\\": \\"C789\\", \\"revenue\\": 300.0}, {\\"product_id\\": \\"B456\\", \\"revenue\\": 200.0} ] top_selling_products(sales_data, 2) # Output # [\\"A123\\", \\"B456\\"] ``` # Constraints 1. Each `product_id` in the `sales_data` list will be a string consisting of alphanumeric characters. 2. Each `revenue` value will be a non-negative float. 3. The length of `sales_data` will not exceed 10^4. 4. The value of `top_n` will be a positive integer not greater than the number of unique products in the `sales_data` list.","solution":"from typing import List, Dict def top_selling_products(sales_data: List[Dict[str, float]], top_n: int) -> List[str]: Returns the top N selling products by total revenue. Parameters: sales_data (List[Dict[str, float]]): A list of dictionaries each containing a product ID and revenue. top_n (int): The number of top selling products to return. Returns: List[str]: A list of product IDs of the top N selling products based on total revenue. from collections import defaultdict # Dictionary to store total revenue for each product ID total_revenue = defaultdict(float) for sale in sales_data: product_id = sale[\'product_id\'] revenue = sale[\'revenue\'] total_revenue[product_id] += revenue # Sort products based on total revenue (descending) and product_id (lexicographically) sorted_products = sorted( total_revenue.items(), key=lambda x: (-x[1], x[0]) ) # Extract the top N product IDs top_products = [product_id for product_id, _ in sorted_products[:top_n]] return top_products"},{"question":"# Implement a Modified Queue Using Two Stacks You are required to implement a queue that supports the operations of inserting an element at the rear, removing the front element, and peeking at the front element using two stacks. A queue is a data structure that follows the First In-First Out (FIFO) principle. Implement a class `QueueWithStacks` that emulates the queue operations (`enqueue`, `dequeue`, `peek`) using two stacks. Requirements: 1. **enqueue(item: int) -> None**: Inserts an integer `item` at the rear of the queue. 2. **dequeue() -> int**: Removes and returns the front element from the queue. If the queue is empty, raise an `IndexError`. 3. **peek() -> int | None**: Returns the front element of the queue without removing it. If the queue is empty, return `None`. Constraint: - The implementation should only use the following stack operations: * `push(item)` - to insert an element on top of the stack. * `pop()` - to remove the top element of the stack. * `peek()` - to get the top element of the stack without removing it. * `len(stack)` - to get the number of elements in the stack. Example: ```python queue = QueueWithStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.peek()) # Output: 2 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: 3 print(queue.peek()) # Output: None ``` **Note**: Do not use a list or any other data structure to simulate the queue behavior. Stick strictly to using two stacks.","solution":"class QueueWithStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, item: int) -> None: self.stack1.append(item) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"dequeue from an empty queue\\") return self.stack2.pop() def peek(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return None return self.stack2[-1]"},{"question":"# Coding Assessment Question Context: You have been tasked with designing a simple heap-based priority queue. The priority queue should support insertion of elements with associated priorities and extraction of the element with the highest priority. Task: Implement the class `PriorityQueue` to handle the functionalities of a max-priority queue using a binary heap. The class should have methods to insert an element, extract the maximum, and check if the queue is empty. Specifically, you need to: 1. Implement a method `insert` to add an element with a specific priority. 2. Implement a method `extract_max` to remove and return the element with the highest priority. 3. Implement a method `is_empty` to check if the priority queue is empty. Class Definition ```python class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.heap = [] def insert(self, element: str, priority: int) -> None: Inserts an element with the specified priority into the priority queue. Args: element (str): The element to be inserted. priority (int): The priority of the element. pass def extract_max(self) -> tuple[str, int] | None: Removes and returns the element with the highest priority. Returns: tuple: A tuple containing the element and its priority, or None if the queue is empty. pass def is_empty(self) -> bool: Checks if the priority queue is empty. Returns: bool: True if the priority queue is empty, False otherwise. pass ``` Expected Inputs and Outputs - `insert` method inserts elements with specified priorities into the priority queue. - `extract_max` method removes and returns the element with the highest priority, or `None` if the queue is empty. - `is_empty` method returns `True` if the priority queue is empty, `False` otherwise. Example ```python pq = PriorityQueue() pq.insert(\\"task1\\", 1) pq.insert(\\"task2\\", 5) pq.insert(\\"task3\\", 3) assert pq.extract_max() == (\\"task2\\", 5) assert pq.extract_max() == (\\"task3\\", 3) assert pq.is_empty() == False assert pq.extract_max() == (\\"task1\\", 1) assert pq.is_empty() == True assert pq.extract_max() == None ``` Notes - You may use any helper functions if necessary. - Ensure your heap operations are efficient, typically O(log n) for insertion and extraction. - Handle edge cases like extracting from an empty priority queue appropriately. - Test your implementation with several insertions and extractions to validate correctness and performance.","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.heap = [] def insert(self, element: str, priority: int) -> None: Inserts an element with the specified priority into the priority queue. Args: element (str): The element to be inserted. priority (int): The priority of the element. heapq.heappush(self.heap, (-priority, element)) def extract_max(self) -> tuple[str, int] | None: Removes and returns the element with the highest priority. Returns: tuple: A tuple containing the element and its priority, or None if the queue is empty. if self.is_empty(): return None priority, element = heapq.heappop(self.heap) return (element, -priority) def is_empty(self) -> bool: Checks if the priority queue is empty. Returns: bool: True if the priority queue is empty, False otherwise. return len(self.heap) == 0"},{"question":"# Question: You are developing a system to analyze text data, and you need to write two functions to tokenize and compute the frequency of each word in a given sentence. Task: 1. **Function 1: `tokenize_sentence(sentence: str) -> list`** - Input: - `sentence`: A string representing a sentence with words separated by spaces. - Output: - A list of words (tokens) extracted from the sentence. - Implementation details: - Ensure that punctuation marks are removed. - Convert all words to lowercase. - Handle any potential extra spaces gracefully. 2. **Function 2: `word_frequency(tokens: list) -> dict`** - Input: - `tokens`: A list of words (tokens). - Output: - A dictionary where keys are words and values are their corresponding frequencies. - Implementation details: - Compute the frequency of each word in the provided list. - Ensure that the output dictionary is case-insensitive (i.e., \'Word\' and \'word\' should be counted as the same word). Examples: - Tokenize Sentence: ```python tokenize_sentence(\\"Hello, world! Welcome to the new world.\\") # Output: [\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"new\\", \\"world\\"] tokenize_sentence(\\"This is a test. This test is only a test.\\") # Output: [\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"this\\", \\"test\\", \\"is\\", \\"only\\", \\"a\\", \\"test\\"] ``` - Word Frequency: ```python word_frequency([\\"hello\\", \\"world\\", \\"welcome\\", \\"to\\", \\"the\\", \\"new\\", \\"world\\"]) # Output: {\'hello\': 1, \'world\': 2, \'welcome\': 1, \'to\': 1, \'the\': 1, \'new\': 1} word_frequency([\\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"this\\", \\"test\\", \\"is\\", \\"only\\", \\"a\\", \\"test\\"]) # Output: {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} ``` Ensure your solution correctly handles edge cases such as empty input, punctuation, varying capitalization, and potential extra spaces, and delivers the expected output format.","solution":"import re from collections import Counter def tokenize_sentence(sentence: str) -> list: Tokenizes a sentence into a list of words, removing punctuation, converting to lowercase, and handling extra spaces. Args: sentence (str): The input sentence. Returns: list: List of words (tokens). # Remove punctuation and convert to lowercase sentence = re.sub(r\'[^ws]\', \'\', sentence).lower() # Split into tokens and filter out empty strings tokens = [word for word in sentence.split() if word.strip()] return tokens def word_frequency(tokens: list) -> dict: Computes the frequency of each word in the provided list. Args: tokens (list): The list of words (tokens). Returns: dict: Dictionary where keys are words and values are their frequencies. frequency_dict = Counter(tokens) return dict(frequency_dict)"},{"question":"# Coding Assessment Question You are working on an e-commerce platform where you need to enhance the security of user passwords by implementing a strong password validation system. The system must enforce a set of rules that determine whether a given string qualifies as a strong password. # Task Details Implement a function: 1. `is_strong_password(password: str) -> bool`: Determines if the given password is strong based on the criteria outlined below. - **Input**: A string representing the password to be validated. - **Output**: A boolean, `True` if the password is strong, `False` otherwise. - **Constraints**: - The password must be at least 8 characters long. - It must contain at least one uppercase letter. - It must contain at least one lowercase letter. - It must contain at least one digit. - It must contain at least one special character from the set: `!@#%^&*()-+`. - Any password not meeting these criteria should be considered not strong. # Example Usage ```python >>> is_strong_password(\\"Password123!\\") True >>> is_strong_password(\\"WeakPass\\") False >>> is_strong_password(\\"StrongPass1\\") False >>> is_strong_password(\\"!Str0ng!\\") True >>> is_strong_password(\\"12345678\\") False ``` # Additional Requirements - Ensure your implementation includes adequate comments and error handling. - Use efficient string operations to maximize performance. - Provide at least five unit tests that cover a variety of edge cases. Deliver the Python code that passes the above example usages and the additional unit tests provided.","solution":"def is_strong_password(password: str) -> bool: Determines if the given password is strong based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from `!@#%^&*()-+` :param password: The password to be validated. :return: True if the password is strong, False otherwise. if len(password) < 8: return False has_upper = False has_lower = False has_digit = False has_special = False special_characters = \\"!@#%^&*()-+\\" for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"# Inventory Tracking System As a software engineer at a retail company, your task is to develop an inventory tracking system. This system should be able to record inventory transactions and provide insights about stock levels and potential shortages. You need to implement a solution that tracks stock levels for different products and predicts when a product might be out of stock. Task 1. **Implement a function `record_transaction` to update the stock levels based on transactions (sales or restocks).** 2. **Implement a function `predict_stock_level` using a linear regression model to predict the stock level for a specified future date.** 3. **Implement a function `check_for_shortages` to check if the predicted stock level is below a specified threshold.** Requirements 1. Implement the following functions: - `record_transaction(transactions: List[Tuple[str, float, float]]) -> Dict[str, float]`: This function should return a dictionary representing the updated stock levels for each product. Each transaction is a tuple containing the product ID, the quantity (positive for restocks, negative for sales), and the date (as a float). If a product ID is encountered for the first time, its initial stock level is assumed to be 0. - `predict_stock_level(product_id: str, dates: List[float], stock_levels: List[float], future_date: float) -> float`: This function should return the predicted stock level for the specified product on the future date using a linear regression model trained on the provided historical dates and stock levels. - `check_for_shortages(product_id: str, predicted_stock_level: float, threshold: float) -> bool`: This function should return a boolean indicating whether the predicted stock level for the specified product is below the threshold. 2. **Constraints**: - The length of `dates` and `stock_levels` lists will be the same, representing historical data for a specific product. - Each transaction will have a valid product ID with at most 1000 transactions. - All the quantities and stock levels will be non-negative floats. 3. **Performance Requirements**: - Efficient memory usage and computation speed for typical historical data sizes up to 1000 records. - Correct handling of date and quantity values with appropriate floating-point precision. Input - `transactions` (List[Tuple[str, float, float]]): List of transactions, each tuple containing product ID, quantity (positive for restocks, negative for sales), and date. - `product_id` (str): Product ID for which stock level prediction and shortage check are to be performed. - `dates` (List[float]): List of historical dates for stock levels. - `stock_levels` (List[float]): List of historical stock levels for the product. - `future_date` (float): The date for which to predict the stock level. - `threshold` (float): The stock level threshold for potential shortage. Output - `record_transaction` returns a dictionary representing the updated stock levels for each product. - `predict_stock_level` returns a float representing the predicted stock level for the specified product on the future date. - `check_for_shortages` returns a bool indicating whether the predicted stock level is below the threshold. Example ```python transactions = [ (\\"P1\\", 100, 1.0), # Restock of 100 units on day 1.0 (\\"P1\\", -30, 2.0), # Sale of 30 units on day 2.0 (\\"P2\\", 50, 1.0) # Restock of 50 units on day 1.0 ] product_id = \\"P1\\" historical_dates = [1.0, 2.0, 3.0] historical_stock_levels = [100, 70, 40] future_date = 4.0 threshold = 20.0 stock_levels = record_transaction(transactions) # Expected: {\\"P1\\": 70, \\"P2\\": 50} predicted_level = predict_stock_level(product_id, historical_dates, historical_stock_levels, future_date) # Expected: Predicted stock level on day 4.0 using linear regression shortage_status = check_for_shortages(product_id, predicted_level, threshold) # Expected: True if predicted stock level is below 20.0, False otherwise ```","solution":"from typing import List, Tuple, Dict from sklearn.linear_model import LinearRegression import numpy as np def record_transaction(transactions: List[Tuple[str, float, float]]) -> Dict[str, float]: stock_levels = {} for product_id, quantity, _ in transactions: if product_id not in stock_levels: stock_levels[product_id] = 0 stock_levels[product_id] += quantity return stock_levels def predict_stock_level(product_id: str, dates: List[float], stock_levels: List[float], future_date: float) -> float: dates_np = np.array(dates).reshape(-1, 1) stock_levels_np = np.array(stock_levels) model = LinearRegression() model.fit(dates_np, stock_levels_np) future_date_np = np.array([[future_date]]) predicted_stock_level = model.predict(future_date_np)[0] return predicted_stock_level def check_for_shortages(product_id: str, predicted_stock_level: float, threshold: float) -> bool: return predicted_stock_level < threshold"},{"question":"# Question Create a function that parses a string containing space-separated integers, filters out the even numbers, and returns the remaining odd numbers in ascending order. If no valid integers are found, the function should return an empty list. Requirements: 1. Your function should be named `filter_and_sort_odds`. 2. The function should take a single argument: - `num_str`: a `str` containing space-separated integers. 3. The function should return a `list` of `int` representing the odd integers in ascending order. Constraints: 1. The input string may contain leading or trailing whitespace, which should be ignored. 2. Any non-numeric strings or invalid integers should be ignored. 3. If the input string is empty or contains no valid odd numbers, the function should return an empty list. Examples: ```python >>> filter_and_sort_odds(\\"10 15 20 25 30\\") [15, 25] >>> filter_and_sort_odds(\\" 1 2 3 4 5 \\") [1, 3, 5] >>> filter_and_sort_odds(\\"2 4 6 8 10\\") [] >>> filter_and_sort_odds(\\"\\") [] >>> filter_and_sort_odds(\\"abc def ghi\\") [] >>> filter_and_sort_odds(\\"99 -101 303 202\\") [-101, 99, 303] ``` Performance Requirements: 1. The implementation should be efficient with a time complexity of O(n log n), where n is the number of tokens in the input string. 2. Space complexity should be O(k), where k is the number of valid odd numbers in the input string. Implement the function `filter_and_sort_odds` in Python.","solution":"def filter_and_sort_odds(num_str): Parses a string containing space-separated integers, filters out the even numbers, and returns the remaining odd numbers in ascending order. :param num_str: str : A string containing space-separated integers. :return: list of int : The odd integers in ascending order. # Split the string into potential integer substrings potential_integers = num_str.strip().split() # Filter and keep only the odd integers odd_numbers = [] for item in potential_integers: try: num = int(item) if num % 2 != 0: odd_numbers.append(num) except ValueError: continue # Return the sorted list of odd numbers return sorted(odd_numbers)"},{"question":"# Task In this task, you need to implement the `find_largest_island_area` function to detect the largest island in a given 2D grid. The grid consists of 0s and 1s, where 0 represents water and 1 represents land. An island is formed by connecting adjacent lands horizontally or vertically. You will also provide a `test_find_largest_island_area` function to test the behavior of your solution on different grid scenarios. # Requirements: * Implement `find_largest_island_area` to: - Traverse the grid and identify all distinct islands. - Compute the area of each island and return the size of the largest island. * Implement `test_find_largest_island_area` to: - Print the actual grid and the largest island area. # Input Format: - `grid`: A 2D list representing the grid where each cell contains either a 0 or a 1. # Output Format: - Return an integer representing the largest island area in `find_largest_island_area`. - In `test_find_largest_island_area`, print the given grid and the computed largest island area. # Constraints: - The grid dimensions will range between 1x1 to 100x100. - All cells contain either a 0 or a 1. # Example Usage: Given: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 1] ] ``` After running `find_largest_island_area(grid)` function, the output might be: ```python 6 ``` After running `test_find_largest_island_area(grid)` function, the output might be: ```python Given grid: [1, 1, 0, 0, 0] [1, 1, 0, 1, 1] [0, 0, 1, 0, 0] [0, 1, 0, 0, 0] [1, 0, 0, 1, 1] Largest Island Area: 6 ``` Implement the functions `find_largest_island_area` and `test_find_largest_island_area` to check if your solution works correctly.","solution":"def find_largest_island_area(grid): Finds the largest island area in a given 2D grid of 0s and 1s where 0 represents water and 1 represents land. An island is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]]: 2D list representing the grid :return: int: size of the largest island if not grid: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[i][j] = 0 area = 1 # Explore the four adjacent directions area += dfs(i + 1, j) area += dfs(i - 1, j) area += dfs(i, j + 1) area += dfs(i, j - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: current_area = dfs(i, j) max_area = max(max_area, current_area) return max_area"},{"question":"# Problem Statement You are given a list of strings representing words, and a target string. Your task is to implement a function that performs a `Case-Insensitive Substring Search` to return a list of indices of all words that contain the target string as a substring, ignoring case. The search should be efficient, leveraging Python\'s built-in string methods as needed. # Function Signature ```python def case_insensitive_substring_search(words: list[str], target: str) -> list[int]: :param words: List of strings to search within. :param target: String target to search for as a substring. :return: List of indices of words containing the target string (case-insensitive). ``` # Input - `words`: A list of strings of length `n` where `0 <= n <= 10^5`. - `target`: A string which is the substring you are searching for within the list of words. # Output - A list of integers representing the indices of the words in the input list that contain the target substring, in a case-insensitive manner. If no such words are found, return an empty list. # Examples ```python >>> case_insensitive_substring_search([\\"hello\\", \\"world\\", \\"HELLOworld\\", \\"HelloAgain\\"], \\"hello\\") [0, 2, 3] >>> case_insensitive_substring_search([\\"apple\\", \\"banana\\", \\"Cherry\\", \\"Date\\", \\"applePie\\"], \\"APPLE\\") [0, 4] >>> case_insensitive_substring_search([\\"Dog\\", \\"Dogfish\\", \\"cat\\", \\"caterpillar\\"], \\"DOG\\") [0, 1] >>> case_insensitive_substring_search([], \\"test\\") [] >>> case_insensitive_substring_search([\\"test\\", \\"testing\\", \\"TEST\\"], \\"none\\") [] ``` # Constraints - You must complete the search operation with a time complexity of O(n * m), where `n` is the number of words, and `m` is the average length of the words. - Consider edge cases such as empty lists and cases where no words contain the target substring. - Ensure your solution handles case insensitivity correctly. # Additional Notes - It is acceptable to use Python\'s in-built string methods such as `str.lower()` or `str.upper()` to handle case insensitivity. - Ensure efficiency by avoiding unnecessary computations within your search loop.","solution":"def case_insensitive_substring_search(words: list[str], target: str) -> list[int]: Returns the list of indices where the words contain the target substring, case-insensitively. target_lower = target.lower() result = [] for idx, word in enumerate(words): if target_lower in word.lower(): result.append(idx) return result"},{"question":"# String Pattern Matcher You are required to write a function that checks if a given pattern occurs as a substring in a given text. The function should return the starting index of the first occurrence of the pattern. If the pattern does not exist within the text, return -1. Implement the function `find_pattern(text: str, pattern: str) -> int` with the following requirements: 1. **Inputs**: - `text` (str): A string in which to search for the pattern. - `pattern` (str): A non-empty string that represents the pattern to search for. 2. **Output**: - An integer representing the starting index of the first occurrence of the pattern in the text, or -1 if the pattern is not found. 3. **Constraints**: - Both `text` and `pattern` consist of ASCII characters. - The length of `text` is between 1 and 10^5. - The length of `pattern` is between 1 and the length of `text`. 4. **Exceptions**: - Raise a `ValueError` if the `pattern` is an empty string (although the constraints already ensure that pattern is non-empty). # Function Signature ```python def find_pattern(text: str, pattern: str) -> int: pass ``` # Examples ```python >>> find_pattern(\\"hello world\\", \\"world\\") 6 >>> find_pattern(\\"abcdef\\", \\"def\\") 3 >>> find_pattern(\\"aaaaaa\\", \\"aaa\\") 0 >>> find_pattern(\\"abcdef\\", \\"gh\\") -1 >>> find_pattern(\\"abcabcabc\\", \\"cab\\") 2 >>> find_pattern(\\"abcabcabc\\", \\"\\") Traceback (most recent call last): ... ValueError: Pattern must be a non-empty string ``` **Note**: Ensure that your function efficiently finds the pattern, especially given the constraints on the length of the text and pattern.","solution":"def find_pattern(text: str, pattern: str) -> int: Returns the starting index of the first occurrence of the pattern within the text. If the pattern is not found, returns -1. if not pattern: raise ValueError(\\"Pattern must be a non-empty string\\") n, m = len(text), len(pattern) # Simple implementation using Python\'s built-in string method for i in range(n - m + 1): if text[i:i + m] == pattern: return i return -1"},{"question":"# Coding Assessment Question You are creating a report generation tool for a product shipment system. The tool needs to summarize the weights of products in a shipment and classify them into different weight categories: 1. **Light**: Products weighing less than 1 kg. 2. **Medium**: Products weighing 1 kg to less than 10 kg. 3. **Heavy**: Products weighing 10 kg to 25 kg. 4. **Very Heavy**: Products weighing more than 25 kg. Your task is to implement a function `classify_weights(weights: List[float]) -> Dict[str, int]` that takes a list of product weights and returns a dictionary where the keys are the weight categories (\'Light\', \'Medium\', \'Heavy\', \'Very Heavy\') and the values are the counts of products in each category. **Function Signature**: ```python from typing import List, Dict def classify_weights(weights: List[float]) -> Dict[str, int]: ... ``` Input Constraints: - `1 <= len(weights) <= 10^4` - `0 <= weights[i] <= 1000` - Weights can be fractional values (e.g., 0.75 kg, 8.6 kg, etc.) Expected Output: - Returns a dictionary with the classification of products based on their weights. Example: ```python assert classify_weights([0.5, 1.0, 9.9, 10.0, 24.5, 30.0]) == { \'Light\': 1, \'Medium\': 2, \'Heavy\': 2, \'Very Heavy\': 1 } assert classify_weights([15.0, 25.0, 25.5, 0.5, 10.0, 5.5, 35.0]) == { \'Light\': 1, \'Medium\': 2, \'Heavy\': 2, \'Very Heavy\': 2 } ``` **Note**: Make sure the function handles all edge cases and executes within reasonable time limits for the given input constraints.","solution":"from typing import List, Dict def classify_weights(weights: List[float]) -> Dict[str, int]: Classifies the given weights into \'Light\', \'Medium\', \'Heavy\', and \'Very Heavy\' categories. categories = { \'Light\': 0, \'Medium\': 0, \'Heavy\': 0, \'Very Heavy\': 0 } for weight in weights: if weight < 1: categories[\'Light\'] += 1 elif 1 <= weight < 10: categories[\'Medium\'] += 1 elif 10 <= weight < 25: categories[\'Heavy\'] += 1 else: categories[\'Very Heavy\'] += 1 return categories"},{"question":"# Create a Text-Based Adventure Game Background A text-based adventure game is a genre of interactive fiction where the player makes choices from a list of options provided for each scenario. The game progresses based on the player\'s decisions, leading to different outcomes. In this task, you will implement a simple text-based adventure game that includes a player exploring different rooms in a house, with each room containing multiple choices for the player. Task You need to implement two methods in a class `AdventureGame` and one method in the `Player` class: 1. `describe_current_room`: This method outputs a description of the player\'s current location and the available choices. 2. `choose_next_room`: This method updates the player\'s current location based on their choice. 3. `move_to`: This method in the `Player` class updates the player\'s current room. You also need to create a main function to demonstrate the gameplay. Implementation 1. **Player**: - Contains an attribute `current_room` which represents the player\'s current location. - **move_to**: - **Input**: A string representing the next room. - **Output**: None (updates `current_room`). - **Example**: ```python player = Player(\\"Living Room\\") player.move_to(\\"Kitchen\\") print(player.current_room) # Output: \\"Kitchen\\" ``` 2. **describe_current_room**: - **Input**: A dictionary `rooms` where keys are the names of rooms and values are lists of choices (strings), and a `Player` object. - **Output**: None (prints a description and available choices). - **Example**: ```python game = AdventureGame() rooms = {\\"Living Room\\": [\\"Go to Kitchen\\", \\"Go to Bedroom\\"], \\"Kitchen\\": [\\"Go to Living Room\\"]} player = Player(\\"Living Room\\") game.describe_current_room(rooms, player) # Expected Output: # \\"You are in Living Room.\\" # \\"You can: \\" # \\"1. Go to Kitchen\\" # \\"2. Go to Bedroom\\" ``` 3. **choose_next_room**: - **Input**: A dictionary `rooms`, a `Player` object, and an integer `choice` representing the player\'s decision. - **Output**: None (updates the Player\'s room and describes the new current room). - **Example**: ```python game = AdventureGame() rooms = {\\"Living Room\\": [\\"Go to Kitchen\\", \\"Go to Bedroom\\"], \\"Kitchen\\": [\\"Go to Living Room\\"]} player = Player(\\"Living Room\\") game.choose_next_room(rooms, player, 1) # Expected Output: # \\"You are in Kitchen.\\" # \\"You can: \\" # \\"1. Go to Living Room\\" ``` 4. **main**: - Initialize the game\'s rooms and player. - Implement a loop to simulate the game flow where the player makes choices until they decide to quit. - Handle invalid choices gracefully. Constraints - Only rooms listed in the `rooms` dictionary are valid. - Assume the player always starts in the \\"Living Room\\". - The player can quit the game at any time by typing \\"q\\". Performance - Ensure the function efficiently handles input/output operations. - Optimize code readability and user experience. Example Implement the following: ```python class Player: def __init__(self, starting_room): self.current_room = starting_room def move_to(self, next_room): self.current_room = next_room class AdventureGame: def describe_current_room(self, rooms, player): current = player.current_room print(f\\"You are in {current}.\\") print(\\"You can: \\") for i, choice in enumerate(rooms[current]): print(f\\"{i + 1}. {choice}\\") def choose_next_room(self, rooms, player, choice): current = player.current_room next_room = rooms[current][choice - 1].split(\\" \\")[-1] player.move_to(next_room) self.describe_current_room(rooms, player) def main(): rooms = { \\"Living Room\\": [\\"Go to Kitchen\\", \\"Go to Bedroom\\"], \\"Kitchen\\": [\\"Go to Living Room\\"], \\"Bedroom\\": [\\"Go to Living Room\\"] } player = Player(\\"Living Room\\") game = AdventureGame() while True: game.describe_current_room(rooms, player) choice = input(\\"Choose an option (or \'q\' to quit): \\") if choice == \'q\': print(\\"Thanks for playing!\\") break if choice.isdigit() and 1 <= int(choice) <= len(rooms[player.current_room]): game.choose_next_room(rooms, player, int(choice)) else: print(\\"Invalid choice, try again.\\") if __name__ == \\"__main__\\": main() ```","solution":"class Player: def __init__(self, starting_room): self.current_room = starting_room def move_to(self, next_room): self.current_room = next_room class AdventureGame: def describe_current_room(self, rooms, player): current = player.current_room print(f\\"You are in {current}.\\") print(\\"You can: \\") for i, choice in enumerate(rooms[current]): print(f\\"{i + 1}. {choice}\\") def choose_next_room(self, rooms, player, choice): current = player.current_room next_room = rooms[current][choice - 1].split(\\" \\")[-1] player.move_to(next_room) self.describe_current_room(rooms, player) def main(): rooms = { \\"Living Room\\": [\\"Go to Kitchen\\", \\"Go to Bedroom\\"], \\"Kitchen\\": [\\"Go to Living Room\\"], \\"Bedroom\\": [\\"Go to Living Room\\"] } player = Player(\\"Living Room\\") game = AdventureGame() while True: game.describe_current_room(rooms, player) choice = input(\\"Choose an option (or \'q\' to quit): \\") if choice == \'q\': print(\\"Thanks for playing!\\") break if choice.isdigit() and 1 <= int(choice) <= len(rooms[player.current_room]): game.choose_next_room(rooms, player, int(choice)) else: print(\\"Invalid choice, try again.\\") if __name__ == \\"__main__\\": main()"},{"question":"# Coding Assessment Question As a software engineer, you are responsible for building a utility tool that will parse and extract information from log files generated by a server. Each log entry follows a standardized format. The tool should summarize error counts and messages for easier debugging. A log entry has the following format: ``` [Timestamp] [LogLevel] [Source]: Message ``` - `Timestamp`: The date and time the log entry was created, in the format `YYYY-MM-DD HH:MM:SS`. - `LogLevel`: The severity level of the log message, e.g., ERROR, WARNING, INFO, DEBUG. - `Source`: The component that generated the log message. - `Message`: The actual log message. Task Write a Python function `summarize_errors` that parses a given list of log entries, extracts all entries with the log level `ERROR`, and returns a dictionary summarizing these errors. The dictionary should have error messages as keys and their counts as values. Example ```python def summarize_errors(log_entries): # Implement log parsing and summarization here pass # Example usage: log_entries = [ \\"[2023-06-14 12:34:56] ERROR [Auth]: Invalid user credentials\\", \\"[2023-06-14 12:35:00] INFO [Server]: Connection established\\", \\"[2023-06-14 12:36:00] ERROR [Database]: Connection failed\\", \\"[2023-06-14 12:37:00] ERROR [Auth]: Invalid user credentials\\" ] error_summary = summarize_errors(log_entries) print(error_summary) # Expected: {\'Invalid user credentials\': 2, \'Connection failed\': 1} ``` Constraints - The input list can contain up to 10^5 log entries. - Each log entry is a string as described in the format above. - Log entries are guaranteed to follow the specified format. Performance Requirement - The function should handle error summarization efficiently, aiming for linear time complexity relative to the number of log entries.","solution":"def summarize_errors(log_entries): Parses log entries and extracts error messages, summarizing them with their counts. Args: log_entries (list of str): The list of log entries in the standardized format. Returns: dict: A dictionary with error messages as keys and their counts as values. error_summary = {} for entry in log_entries: parts = entry.split(\\"] \\") log_level_part = parts[1] if log_level_part.startswith(\\"ERROR\\"): message = entry.split(\\": \\", 1)[1] if message in error_summary: error_summary[message] += 1 else: error_summary[message] = 1 return error_summary"},{"question":"# Knight\'s Shortest Path Challenge Context You are tasked with writing a function for a game development project to determine the shortest path for a knight on a chessboard to reach a specific target cell from a given starting cell. The knight moves in an L-shape: two cells in one direction and one cell perpendicular. Objective Write a function `knight_shortest_path(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int` that computes the minimum number of moves required for a knight to reach the target cell from the start cell on an `n x n` chessboard. Input * `n`: An integer representing the size of the chessboard (n x n). * `start`: A tuple `(x, y)` representing the starting position of the knight. * `target`: A tuple `(x, y)` representing the target position of the knight. Output * Returns an integer representing the minimum number of moves for the knight to reach the target cell. If the target cannot be reached, return -1. Constraints * 1 <= n <= 1000 * 0 <= start[0], start[1], target[0], target[1] < n. Example ```python def knight_shortest_path(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int: # Your code here # Example usage: n = 8 start = (0, 0) target = (7, 7) print(knight_shortest_path(n, start, target)) # Output: 6 ``` Explanation For the given example, the knight starts at position (0, 0) and can reach position (7, 7) in 6 moves. Various intermediate moves like (2, 1), (4, 2), (5, 4), etc., lead to the minimum move count. The function should use the BFS algorithm to find the shortest path efficiently.","solution":"from collections import deque from typing import List, Tuple def knight_shortest_path(n: int, start: Tuple[int, int], target: Tuple[int, int]) -> int: # All possible movements for a knight in chess moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] # Initialize BFS queue queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Problem Statement: You are tasked with creating a program that generates a summary report of product sales. Given a list of sales records, where each record is a tuple containing the product name, the quantity sold, and the price per unit, develop a function `sales_summary` that takes this list as input and produces a summary dictionary. The summary should contain the total quantity sold and the total revenue for each product. Example Sales Records: * `(\\"Widget\\", 5, 19.99)` * `(\\"Gadget\\", 10, 2.50)` * `(\\"Widget\\", 2, 19.99)` **Function Signature**: ```python def sales_summary(sales_records: List[Tuple[str, int, float]]) -> Dict[str, Dict[str, float]]: pass ``` # Requirements: * Implement the `sales_summary` function. * Validate that the input is a list of tuples with the appropriate types (string, integer, float). * Summarize the total quantity sold and total revenue for each product. * Handle cases where the input list may be empty. * Ensure the function performs summarization correctly, considering multiple sales of the same product. # Example Usage: ```python >>> sales_summary([(\\"Widget\\", 5, 19.99), (\\"Gadget\\", 10, 2.50), (\\"Widget\\", 2, 19.99)]) { \\"Widget\\": {\\"total_quantity\\": 7, \\"total_revenue\\": 139.93}, \\"Gadget\\": {\\"total_quantity\\": 10, \\"total_revenue\\": 25.00} } >>> sales_summary([(\\"ProductA\\", 1, 100.0), (\\"ProductB\\", 2, 50.0), (\\"ProductA\\", 3, 100.0)]) { \\"ProductA\\": {\\"total_quantity\\": 4, \\"total_revenue\\": 400.0}, \\"ProductB\\": {\\"total_quantity\\": 2, \\"total_revenue\\": 100.0} } >>> sales_summary([]) {} ``` # Constraints: * You can assume valid sales records are provided in the input list. * Focus on computational efficiency and robustness of the solution. * Handle invalid input types by raising a TypeError with an appropriate message. * Accumulate quantities and revenues considering potential floating-point imprecision.","solution":"from typing import List, Tuple, Dict def sales_summary(sales_records: List[Tuple[str, int, float]]) -> Dict[str, Dict[str, float]]: summary = {} for record in sales_records: if not (isinstance(record, tuple) and len(record) == 3 and isinstance(record[0], str) and isinstance(record[1], int) and isinstance(record[2], float)): raise TypeError(\\"Each sales record must be a tuple of the form (str, int, float)\\") product, quantity, price_per_unit = record if product in summary: summary[product][\'total_quantity\'] += quantity summary[product][\'total_revenue\'] += quantity * price_per_unit else: summary[product] = { \'total_quantity\': quantity, \'total_revenue\': quantity * price_per_unit } # To address potential floating-point precision issues summary[product][\'total_revenue\'] = round(summary[product][\'total_revenue\'], 2) return summary"},{"question":"# Problem Statement You are given an `n x n` matrix filled with integers, and your task is to rotate the matrix 90 degrees clockwise. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given `n x n` matrix by 90 degrees clockwise. Parameters: matrix (List[List[int]]): The input `n x n` matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Raises: ValueError: If the input matrix is not `n x n`. ``` # Requirements - The function should handle square matrices (same number of rows and columns, denoted as `n` x `n`). - Ensure your solution only modifies the matrix in-place if possible. Minimize the use of additional memory. # Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(rotate_matrix(matrix1)) # Expected output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] matrix2 = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] print(rotate_matrix(matrix2)) # Expected output: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ``` # Constraints - The matrix dimensions `n x n` will satisfy 1 <= n <= 1000. - Ensure the function handles both small and large matrices efficiently. # Hints - Think about transforming the matrix in layers, rotating from the outermost elements to the innermost. - Consider the properties of indices when they are rotated; this could simplify your implementation. This newly crafted question fits into the broader theme of matrix manipulation and algorithm efficiency, which complements the domains covered in the provided sample set.","solution":"def rotate_matrix(matrix): Rotates the given `n x n` matrix by 90 degrees clockwise. Parameters: matrix (List[List[int]]): The input `n x n` matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Raises: ValueError: If the input matrix is not `n x n`. if not matrix or not matrix[0] or len(matrix) != len(matrix[0]): raise ValueError(\\"The input matrix is not an n x n matrix.\\") n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] # Move left to top matrix[first][i] = matrix[last - offset][first] # Move bottom to left matrix[last - offset][first] = matrix[last][last - offset] # Move right to bottom matrix[last][last - offset] = matrix[i][last] # Move top to right matrix[i][last] = top return matrix"},{"question":"# Temperature Monitoring System with Sensor Aggregation You are tasked with developing a system to monitor and aggregate temperature readings from multiple sensors distributed across a building. Your solution should compute the average temperature and identify the maximum and minimum temperatures recorded. **Objective**: Write a Python function named `process_temperatures` that reads temperature data from multiple sensors, computes the average temperature, and finds the highest and lowest temperatures. **Function Signature**: ```python def process_temperatures(sensor_data: List[List[int]]) -> Tuple[float, int, int]: pass ``` **Input**: - `sensor_data` (List[List[int]]): A list of lists, where each inner list contains integer temperature readings from a single sensor. **Output**: - A tuple containing three values: - `average_temperature` (float): The rounded average of all the temperature readings. - `max_temperature` (int): The maximum temperature recorded. - `min_temperature` (int): The minimum temperature recorded. **Constraints**: - The number of sensors (length of outer list) will be between 1 and 1000. - Each sensor can record between 1 and 1000 temperature readings. - Temperatures range between -100 and 100 degrees. **Performance**: - Aim for a time complexity of O(N), where N is the total number of temperature readings. - Space complexity should be O(1) extra space, making use of in-place calculations where feasible. **Example**: ```python sensor_data = [ [22, 24, 21, 23], [19, 18, 20, 22], [25, 27, 26, 28] ] process_temperatures(sensor_data) # Output: (23.33, 28, 18) ``` **Python Libraries**: - Only basic functionalities of Python standard libraries are required (e.g., sum, min, max). # Context: Monitoring and aggregating temperature data from multiple sensors is critical for maintaining optimal environmental conditions in various settings such as industrial complexes, office buildings, and data centers. This ensures efficient operation of HVAC systems and helps in anomaly detection for maintenance purposes.","solution":"from typing import List, Tuple def process_temperatures(sensor_data: List[List[int]]) -> Tuple[float, int, int]: Processes temperature data from multiple sensors to compute the average, maximum, and minimum temperatures. Parameters: sensor_data (List[List[int]]): A list of lists where each inner list contains temperature readings from a single sensor. Returns: Tuple[float, int, int]: A tuple containing the average temperature (rounded to 2 decimals), the maximum temperature, and the minimum temperature. if not sensor_data or all(not readings for readings in sensor_data): return 0.0, None, None # Return early if no data is provided total_sum = 0 count = 0 max_temp = float(\'-inf\') min_temp = float(\'inf\') for readings in sensor_data: for temp in readings: total_sum += temp count += 1 if temp > max_temp: max_temp = temp if temp < min_temp: min_temp = temp average_temp = round(total_sum / count, 2) if count != 0 else 0.0 return average_temp, max_temp, min_temp"},{"question":"# Coding Question: Optimized Matrix Rotation **Context**: Matrix rotation is a common operation in various applications, from image processing to mathematical computations. However, rotating a large matrix efficiently requires careful handling of the matrix elements to avoid excessive computation and memory usage. Your task is to implement an optimized rotation function that rotates a given NxN matrix 90 degrees clockwise. **Function Signature**: ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` **Inputs**: 1. `matrix` (list of list of int): A square matrix of size NxN where N is between 1 and 300, inclusive. **Output**: A list of lists representing the matrix rotated 90 degrees clockwise. **Constraints**: * 1 <= N <= 300 * The elements of the matrix are integers and can be positive, negative, or zero. **Example**: ```python >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_matrix([[1]]) [[1]] ``` **Requirements**: 1. Implement the rotation in place if possible to minimize memory usage. 2. Ensure the algorithm is efficient and can handle the upper constraint (N = 300) within a reasonable time limit. 3. Handle edge cases such as a 1x1 matrix.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store rotated values rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-i-1] = matrix[i][j] return rotated_matrix"},{"question":"# Question: Encode and Decode a Message In this challenge, you are required to implement a pair of functions to encode and decode a message based on simple shifting of characters. **Problem Statement**: Write two Python functions: one to encode a message by shifting each character by a given number of positions in the alphabet, and another to decode an encoded message by reversing that shift. **Function Signatures**: ```python def encode_message(message: str, shift: int) -> str: pass def decode_message(encoded_message: str, shift: int) -> str: pass ``` **Parameters**: - `message` (str): The original message to be encoded, containing only lowercase alphabetical characters and spaces. - `shift` (int): The number of positions to shift each character in the message for encoding and decoding. A positive \'shift\' indicates a forward shift and a negative \'shift\' indicates a backward shift. **Returns**: - `encode_message` returns a string which is the encoded message. - `decode_message` returns a string which is the original message after decoding the encoded message. **Examples**: ```python >>> encode_message(\\"hello world\\", 3) \'khoor zruog\' >>> decode_message(\\"khoor zruog\\", 3) \'hello world\' >>> encode_message(\\"abc xyz\\", 2) \'cde zab\' >>> decode_message(\\"cde zab\\", 2) \'abc xyz\' >>> encode_message(\\"message\\", -1) \'ldrtrfd\' >>> decode_message(\\"ldrtrfd\\", -1) \'message\' ``` **Constraints**: - Only lowercase alphabetical characters and spaces are allowed in the message. - The function should handle positive and negative `shift` values correctly. - Spaces in the original message should be preserved in the encoded message. The task requires you to write these two functions efficiently, considering the rotation of the alphabet and maintaining the spaces in their original positions.","solution":"def encode_message(message: str, shift: int) -> str: encoded = [] for char in message: if char == \' \': encoded.append(char) else: new_pos = (ord(char) - ord(\'a\') + shift) % 26 encoded.append(chr(ord(\'a\') + new_pos)) return \'\'.join(encoded) def decode_message(encoded_message: str, shift: int) -> str: decoded = [] for char in encoded_message: if char == \' \': decoded.append(char) else: new_pos = (ord(char) - ord(\'a\') - shift) % 26 decoded.append(chr(ord(\'a\') + new_pos)) return \'\'.join(decoded)"},{"question":"# Problem Context In computer graphics, we often need to manipulate and transform matrices. One common transformation is the rotation of a matrix by 90 degrees. Given a square matrix (2D list) of integers, write a Python function to rotate the matrix by 90 degrees in a clockwise direction. You need to perform the rotation in-place. # Task Write a function `rotate_matrix(matrix: List[List[int]]) -> None` that modifies the input matrix to rotate it 90 degrees clockwise. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` # Input - A single parameter `matrix`, which is a list of n lists, each containing n integers representing an n x n matrix. You may assume that 1 ≤ n ≤ 15. # Output - The function does not return anything. Modify the input matrix in-place to achieve the rotation. # Constraints - The function should rotate the given matrix in-place. - Use only O(1) additional space for variables other than the input matrix. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Hints - Consider the layers of the matrix, and rotate each layer one by one. - Swap elements in the four corners of the matrix incrementally to achieve the rotation.","solution":"def rotate_matrix(matrix): Rotates the given n x n matrix by 90 degrees clockwise in-place. Args: matrix (List[List[int]]): A 2D list representing the n x n matrix. Returns: None n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): # offset is the index shift within the current layer offset = i - first # save the top element top = matrix[first][i] # left to top matrix[first][i] = matrix[last - offset][first] # bottom to left matrix[last - offset][first] = matrix[last][last - offset] # right to bottom matrix[last][last - offset] = matrix[i][last] # top to right matrix[i][last] = top"},{"question":"# Question You are asked to implement a function that takes a string representing a mathematical expression and evaluates it. The expression will include real numbers, parentheses, and the operators `+`, `-`, `*`, and `/`. Your task is to correctly compute the value of this expression using the appropriate order of operations (PEMDAS/BODMAS rules). Function Signature ```python def evaluate_expression(expression: str) -> float: pass ``` Input - `expression`: A string representing a mathematical expression which can include: - Real numbers (e.g., `2`, `3.14`, `5.67`) - Operators: `+`, `-`, `*`, `/` - Parentheses: `(` and `)` Output - A floating-point result representing the evaluated value of the expression. Constraints - The input string will always be a valid mathematical expression. - The expression can include spaces which should be ignored during processing. Examples - `evaluate_expression(\\"3 + 5 / 2\\")` should return `5.5` - `evaluate_expression(\\"(2 + 3) * 4\\")` should return `20.0` - `evaluate_expression(\\"2 + (3 * 4) - 5 / (2 + 3)\\")` should return `13.0` Additional Notes - Consider utilizing a stack-based approach or the Shunting Yard algorithm for parsing the expression. - Be careful with floating-point division and ensure precision is maintained. Performance Requirements - Your solution should parse and evaluate the expression in linear time with respect to the length of the input string.","solution":"def evaluate_expression(expression: str) -> float: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(left / right) def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def evaluate(expression): i = 0 operators = [] values = [] while i < len(expression): if expression[i] == \' \': i += 1 continue elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit() or expression[i] == \'.\': val = 0 # There could be real numbers with decimal part while (i < len(expression) and (expression[i].isdigit() or expression[i] == \'.\')): val = val * 10 + float(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # Remove the \'(\' else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1] return evaluate(expression)"},{"question":"# Coding Assessment: Trie Data Structure for Autocomplete System Problem Statement: You are tasked with implementing an autocomplete system using a Trie data structure. The Trie should efficiently store and retrieve words for the autocomplete feature, allowing users to quickly find suggestions based on the prefix they have typed. Your implementation should: * Insert a list of words into the Trie. * Search and suggest words that start with a given prefix. * Return the suggestions sorted lexicographically. Function Signature Implement the class `AutocompleteSystem` with the following methods: * `__init__(self)`: Initializes an empty Trie. * `insert(self, words: List[str]) -> None`: Inserts a list of words into the Trie. * `suggest(self, prefix: str) -> List[str]`: Returns a list of all words that start with the given prefix, sorted lexicographically. Constraints: * All words consist of lowercase English letters. * The number of words to insert can be up to 10,000. * The length of each word and the prefix can be up to 100 characters. * The total number of characters across all input words does not exceed 1,000,000. Example ```python # Example Usage autocomplete_system = AutocompleteSystem() words = [\\"dog\\", \\"deer\\", \\"deal\\", \\"cat\\", \\"can\\", \\"cape\\", \\"cake\\"] autocomplete_system.insert(words) # Example Outputs assert autocomplete_system.suggest(\\"de\\") == [\\"deal\\", \\"deer\\"] assert autocomplete_system.suggest(\\"ca\\") == [\\"cake\\", \\"can\\", \\"cape\\", \\"cat\\"] assert autocomplete_system.suggest(\\"do\\") == [\\"dog\\"] assert autocomplete_system.suggest(\\"d\\") == [\\"deal\\", \\"deer\\", \\"dog\\"] assert autocomplete_system.suggest(\\"z\\") == [] ``` Instructions: 1. Implement the class `TrieNode` with methods to initialize and manage Trie nodes. 2. Implement the class `AutocompleteSystem` with methods to insert words and suggest autocomplete results based on a prefix. 3. Return the required results in the specific format.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class AutocompleteSystem: def __init__(self): self.root = TrieNode() def insert(self, words): for word in words: self._insert_word(word) def _insert_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def suggest(self, prefix): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] suggestions = [] self._collect_words(node, prefix, suggestions) suggestions.sort() return suggestions def _collect_words(self, node, prefix, suggestions): if node.end_of_word: suggestions.append(prefix) for char, child_node in node.children.items(): self._collect_words(child_node, prefix + char, suggestions)"},{"question":"# Scenario You are tasked with implementing a tic-tac-toe game board evaluation system that determines the game\'s current status. Add functionality to check if either player has won, or if the game is still ongoing or ended in a draw. Implement the `check_board` function to handle these requirements. # Requirements **Function Signature**: ```python def check_board(board: List[List[str]]) -> str: pass ``` # Input & Output Formats * **Input**: A 3x3 matrix `board` representing the tic-tac-toe board, filled with \'X\', \'O\', or an empty string \'\'. * **Output**: * Return \'X\' if player \'X\' has won, * Return \'O\' if player \'O\' has won, * Return \'Draw\' if the board is full and no player has won, * Return \'Ongoing\' if there are still empty spots and no player has won. # Constraints * The board will always be of size 3x3. * Assume valid board configurations. # Performance Requirements * Time Complexity: O(1) — since the board size is fixed. * Space Complexity: O(1) — use constant space. # Example ```python >>> board1 = [ [\'X\', \'O\', \'X\'], [\'O\', \'X\', \'O\'], [\'O\', \'X\', \'X\'] ] >>> check_board(board1) \'X\' >>> board2 = [ [\'X\', \'O\', \'\'], [\'O\', \'O\', \'X\'], [\'X\', \'X\', \'O\'] ] >>> check_board(board2) \'Ongoing\' ```","solution":"from typing import List def check_board(board: List[List[str]]) -> str: Evaluates the current state of the tic-tac-toe board. Parameters: board (List[List[str]]): A 3x3 matrix representing the tic-tac-toe board. Returns: str: \'X\' if X wins, \'O\' if O wins, \'Draw\' if it\'s a draw, \'Ongoing\' if the game is still ongoing. def check_winner(player): # Check rows and columns for i in range(3): if all(board[i][j] == player for j in range(3)) or all(board[j][i] == player for j in range(3)): return True # Check diagonals if (board[0][0] == player and board[1][1] == player and board[2][2] == player) or (board[0][2] == player and board[1][1] == player and board[2][0] == player): return True return False if check_winner(\'X\'): return \'X\' if check_winner(\'O\'): return \'O\' if all(all(cell != \'\' for cell in row) for row in board): return \'Draw\' return \'Ongoing\'"},{"question":"# Coding Question **Context:** String manipulation is a common task in programming that can test both algorithmic thinking and familiarity with language-specific functions. One of the frequent operations is replacing substrings within a string, which can be useful in various applications such as text processing, data cleaning, and content generation. **Task:** You are required to implement a function `replace_substring(s: str, old: str, new: str) -> str` that takes a string `s`, and replaces all occurrences of the substring `old` with the substring `new`. The function should return the modified string. **Function Signature:** ```python def replace_substring(s: str, old: str, new: str) -> str: ``` **Input:** * `s` (str): The input string. * `old` (str): The substring to be replaced. * `new` (str): The substring to replace `old` with. **Output:** * A string where all occurrences of `old` in `s` are replaced with `new`. **Constraints:** * `s` must be a valid string. * `old` and `new` must be valid strings and `old` must not be an empty string. **Examples:** ```python >>> replace_substring(\\"hello world\\", \\"world\\", \\"there\\") \'hello there\' >>> replace_substring(\\"abc abc abc\\", \\"abc\\", \\"xyz\\") \'xyz xyz xyz\' >>> replace_substring(\\"the quick brown fox\\", \\"quick\\", \\"slow\\") \'the slow brown fox\' >>> replace_substring(\\"aaa bbb ccc\\", \\"bbb\\", \\"ddd\\") \'aaa ddd ccc\' >>> replace_substring(\\"replace me in this string\\", \\"me\\", \\"us\\") \'replace us in this string\' ``` **Edge Cases:** * `replace_substring(\\"nothing to replace here\\", \\"non-existent\\", \\"absent\\")` should return the original string since `old` is not found. * `replace_substring(\\"hi\\", \\"\\", \\"hello\\")` should raise a ValueError since `old` is an empty string. **Testing:** Use the following template to test your function: ```python if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` Matched the existing question set in terms of style, complexity, and length. This question includes string manipulation operations, a fundamental concept in programming, similar to how bitwise operations are fundamental but in a different domain. The complexity and context are aligned with the original question, ensuring consistency and seamless integration.","solution":"def replace_substring(s: str, old: str, new: str) -> str: Replaces all occurrences of the substring \'old\' in the string \'s\' with the substring \'new\'. Args: s (str): The input string. old (str): The substring to be replaced. new (str): The substring to replace \'old\' with. Returns: str: The modified string with \'old\' replaced by \'new\'. Raises: ValueError: If \'old\' is an empty string. if old == \\"\\": raise ValueError(\\"The \'old\' substring must not be empty.\\") return s.replace(old, new)"},{"question":"# Random String Manipulation Challenge You are a software engineer working on a text processing application. You need to create a function that performs a specific manipulation on a given string and returns the manipulated result. The manipulation involves retaining only every nth character from the original string, where n is a provided integer. Task: Create the following function: `retain_nth_characters(content: str, n: int) -> str` This function should: - **Parameters**: - `content` (str): The input string from which characters will be retained. - `n` (int): The integer step that determines which characters to retain. - **Return**: A new string that consists of every nth character from the input string, starting with the first character. Constraints: - Assume the input string will not be empty. - The parameter `n` will be a positive integer (1 ≤ n ≤ length of the input string). - Handle cases where `n` is equal to 1 (return the entire string). **Example**: ```python print(retain_nth_characters(\\"abcdefghij\\", 2)) # prints \\"acegi\\" print(retain_nth_characters(\\"hello world\\", 3)) # prints \\"hlwl\\" # edge case where n = 1 print(retain_nth_characters(\\"example\\", 1)) # prints \\"example\\" ``` Performance Requirements: - Aim for O(n) time complexity, where n is the length of the input string. - Use O(n) space complexity for storing the result.","solution":"def retain_nth_characters(content: str, n: int) -> str: Retain every nth character in the given string content. Args: content (str): The original string from which characters will be retained. n (int): The step value to determine which characters to retain. Returns: str: A new string with every nth character from content. return content[::n]"},{"question":"# Coding Assessment Question You are developing a task scheduler for a simplified operating system that prioritizes tasks based on their importance and the time they have been in the queue. Each task has a unique identifier, a priority value, and a timestamp indicating when it was added to the queue. To ensure optimal task management, you need to implement functionalities that enable adding, removing, and retrieving the highest priority task from the queue. # Task Details Implement the following methods for a `TaskScheduler` class: 1. `add_task(task_id: int, priority: int, timestamp: int) -> None`: Adds a new task to the queue. - **Input**: - `task_id` - An integer representing the unique identifier of the task. - `priority` - An integer representing the priority of the task (higher values indicate higher priority). - `timestamp` - An integer representing the time (in seconds since the epoch) when the task was added. - **Output**: None - **Constraints**: - Task IDs are unique. Adding a task with a duplicate ID should raise a `ValueError` with a clear message. - Priorities can be any integer. - Timestamps are integers and assumed to be accurate. 2. `remove_task(task_id: int) -> None`: Removes the task with the given ID from the queue. - **Input**: `task_id` - An integer representing the unique identifier of the task to be removed. - **Output**: None - **Constraints**: - If the task ID does not exist in the queue, raise a `ValueError` with a clear message. 3. `get_highest_priority_task() -> int`: Retrieves the ID of the task with the highest priority from the queue. If multiple tasks have the same priority, return the one that has been in the queue the longest. - **Output**: An integer representing the unique identifier of the highest priority task. - **Constraints**: - If the queue is empty, raise a `ValueError` with a clear message. # Example Usage ```python >>> scheduler = TaskScheduler() >>> scheduler.add_task(1, 5, 100) >>> scheduler.add_task(2, 10, 200) >>> scheduler.add_task(3, 10, 150) >>> scheduler.get_highest_priority_task() 2 >>> scheduler.remove_task(2) >>> scheduler.get_highest_priority_task() 3 >>> scheduler.add_task(4, 8, 220) >>> scheduler.get_highest_priority_task() 3 >>> scheduler.remove_task(5) Traceback (most recent call last): ... ValueError: Task ID 5 does not exist in the queue >>> scheduler.get_highest_priority_task() 3 ``` # Additional Requirements - Ensure your implementation includes adequate comments and error handling. - Use efficient data structures to ensure optimal performance for each operation. - Provide at least five unit tests that cover various scenarios, including edge cases. Deliver the Python code that implements the `TaskScheduler` class and passes the above example usages and unit tests provided.","solution":"import heapq class TaskScheduler: def __init__(self): self.task_dict = {} self.task_heap = [] self.counter = 0 def add_task(self, task_id: int, priority: int, timestamp: int) -> None: if task_id in self.task_dict: raise ValueError(f\\"Task ID {task_id} already exists in the queue.\\") entry = (-priority, timestamp, self.counter, task_id) self.counter += 1 heapq.heappush(self.task_heap, entry) self.task_dict[task_id] = entry def remove_task(self, task_id: int) -> None: if task_id not in self.task_dict: raise ValueError(f\\"Task ID {task_id} does not exist in the queue.\\") entry = self.task_dict.pop(task_id) self.task_heap.remove(entry) heapq.heapify(self.task_heap) def get_highest_priority_task(self) -> int: if not self.task_heap: raise ValueError(\\"The task queue is empty.\\") while self.task_heap: priority, timestamp, counter, task_id = self.task_heap[0] if task_id in self.task_dict and self.task_dict[task_id] == self.task_heap[0]: return task_id heapq.heappop(self.task_heap) raise ValueError(\\"The task queue is empty.\\")"},{"question":"# Problem Description You are given a matrix of integers where each row represents a number of continuous ranges of 0s and 1s. Your task is to implement a function that determines the largest rectangular area (sub-matrix) with all 1s. # Requirements 1. **Input**: A 2D list (matrix) of integers containing only 0s and 1s. 2. **Output**: An integer representing the area of the largest rectangle containing only 1s. # Implementation Implement the given function `maximal_rectangle(matrix: List[List[int]]) -> int`. # Example ```python def maximal_rectangle(matrix: List[List[int]]) -> int: # Your code here pass # Example Test Case print(maximal_rectangle([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ])) # Expected Output: 6 ``` # Notes * Leverage techniques like dynamic programming or stack to solve the problem efficiently. * Consider edge cases such as an empty matrix or matrix with one row or one column. * Ensure the solution handles large matrices computationally well.","solution":"from typing import List def maximal_rectangle(matrix: List[List[int]]) -> int: if not matrix: return 0 max_area = 0 n_cols = len(matrix[0]) height = [0] * (n_cols + 1) for row in matrix: for i in range(n_cols): if row[i] == 1: height[i] += 1 else: height[i] = 0 stack = [-1] for i in range(n_cols + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"# Scenario You have been hired to develop a simulation of a simplified memory allocation system for a computer science class. The system must allocate contiguous blocks of memory for various processes and deallocate them when processes complete. Your task is to design and implement the memory allocation simulator with a first-fit allocation strategy. # Task Write a class `MemoryAllocator` that manages memory allocation and deallocation for processes. The system should support the following operations: initializing the memory size, allocating memory for a process, deallocating memory, and displaying the current memory layout. # Class Definition ```python class MemoryAllocator: def __init__(self, size: int): Initialize the memory allocator with a given memory size. Parameters: - size (int): The total memory size. def allocate(self, process_id: str, block_size: int) -> bool: Allocate a block of memory for a process using first-fit strategy. Parameters: - process_id (str): The unique identifier for the process. - block_size (int): The size of the memory block to allocate. Returns: - bool: True if allocation is successful, False otherwise. def deallocate(self, process_id: str) -> bool: Deallocate the memory block for the given process. Parameters: - process_id (str): The unique identifier for the process. Returns: - bool: True if deallocation is successful, False otherwise. def display_memory(self) -> List[str]: Display the current memory layout. Returns: - List[str]: The memory layout with each block represented by the process_id or \'Free\'. ``` # Input - The `size` parameter of the constructor is an integer representing the total memory size. - The `allocate` method takes a `process_id` (str) and a `block_size` (int) representing the size of the memory block to allocate. - The `deallocate` method takes a `process_id` (str) representing the process identifier to deallocate memory for. # Output - The `allocate` method returns a boolean indicating if the memory allocation was successful. - The `deallocate` method returns a boolean indicating if the memory deallocation was successful. - The `display_memory` method returns a list of strings representing the current memory layout. # Constraints - Memory size (`size`) is between 1 and 1000. - Process identifiers (`process_id`) are unique strings. - Block sizes (`block_size`) are positive integers and do not exceed the total memory size. - The first-fit strategy should be used for memory allocation. # Examples ```python # Example 1 allocator = MemoryAllocator(10) print(allocator.allocate(\\"P1\\", 4)) # True print(allocator.allocate(\\"P2\\", 2)) # True print(allocator.display_memory()) # [\'P1\', \'P1\', \'P1\', \'P1\', \'P2\', \'P2\', \'Free\', \'Free\', \'Free\', \'Free\'] print(allocator.deallocate(\\"P1\\")) # True print(allocator.display_memory()) # [\'Free\', \'Free\', \'Free\', \'Free\', \'P2\', \'P2\', \'Free\', \'Free\', \'Free\', \'Free\'] print(allocator.allocate(\\"P3\\", 3)) # True print(allocator.display_memory()) # [\'P3\', \'P3\', \'P3\', \'Free\', \'P2\', \'P2\', \'Free\', \'Free\', \'Free\', \'Free\'] # Example 2 allocator = MemoryAllocator(15) print(allocator.allocate(\\"P1\\", 5)) # True print(allocator.allocate(\\"P2\\", 7)) # True print(allocator.allocate(\\"P3\\", 4)) # False print(allocator.deallocate(\\"P1\\")) # True print(allocator.allocate(\\"P3\\", 4)) # True print(allocator.display_memory()) # [\'P3\', \'P3\', \'P3\', \'P3\', \'Free\', \'P2\', \'P2\', \'P2\', \'P2\', \'P2\', \'P2\', \'P2\', \'Free\', \'Free\', \'Free\'] ```","solution":"from typing import List class MemoryAllocator: def __init__(self, size: int): self.size = size self.memory = [\'Free\'] * size def allocate(self, process_id: str, block_size: int) -> bool: start_index = -1 consecutive_free_count = 0 for i in range(self.size): if self.memory[i] == \'Free\': if start_index == -1: start_index = i consecutive_free_count += 1 if consecutive_free_count >= block_size: for j in range(start_index, start_index + block_size): self.memory[j] = process_id return True else: start_index = -1 consecutive_free_count = 0 return False def deallocate(self, process_id: str) -> bool: deallocated = False for i in range(self.size): if self.memory[i] == process_id: self.memory[i] = \'Free\' deallocated = True return deallocated def display_memory(self) -> List[str]: return self.memory"},{"question":"# Unique Paths Coding Challenge # Problem Statement Write a function `unique_paths` that receives two integers representing the number of rows (m) and columns (n) in a grid, and returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. You can only move to the right or down at any point in time. # Detailed Requirements - **Function Signature**: `def unique_paths(m: int, n: int) -> int:` - The inputs `m` and `n` will be positive integers. - If either `m` or `n` is not a positive integer, raise a `ValueError` with a meaningful error message. - If either `m` or `n` is `1`, there is only one unique path possible. # Example Test Cases ```python def test_unique_paths(): assert unique_paths(3, 7) == 28, \\"Test case 1 failed\\" assert unique_paths(3, 2) == 3, \\"Test case 2 failed\\" assert unique_paths(7, 3) == 28, \\"Test case 3 failed\\" assert unique_paths(3, 3) == 6, \\"Test case 4 failed\\" assert unique_paths(1, 7) == 1, \\"Test case 5 failed\\" assert unique_paths(7, 1) == 1, \\"Test case 6 failed\\" try: unique_paths(0, 2) except ValueError as e: assert str(e) == \\"m and n must be positive integers\\", \\"Test case 7 failed\\" try: unique_paths(-1, 3) except ValueError as e: assert str(e) == \\"m and n must be positive integers\\", \\"Test case 8 failed\\" try: unique_paths(3, \'a\') except ValueError as e: assert str(e) == \\"m and n must be positive integers\\", \\"Test case 9 failed\\" print(\\"All test cases pass\\") ``` # Constraints * You must not use any built-in combinatorial functions or libraries to trivialize the task. * Your solution should handle different grid sizes efficiently, with consideration for large values of `m` and `n`. # Guidelines * Ensure your code handles edge cases such as invalid inputs before processing. * Use dynamic programming to optimize the solution, aiming for O(m*n) time complexity and O(m*n) space complexity.","solution":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from top-left corner to bottom-right corner of a grid. if not isinstance(m, int) or not isinstance(n, int) or m <= 0 or n <= 0: raise ValueError(\\"m and n must be positive integers\\") if m == 1 or n == 1: return 1 # Initialize a 2D dp array with 1\'s in the first row and first column dp = [[1] * n for _ in range(m)] # Populate the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Coding Assessment Question: Implementing a Genetic Algorithm for TSP Context You are working on a combinatorial optimization project that requires solving the Traveling Salesman Problem (TSP). To achieve this, you decide to use a Genetic Algorithm (GA). Implementing GA will help find an approximate solution efficiently by evolving a population of possible routes over generations. Task Write a function that runs a Genetic Algorithm to optimize a TSP route and returns the best route found after a defined number of generations. Function Signature ```python def genetic_algorithm_tsp(cities: list[list[float]], population_size: int, generations: int, mutation_rate: float) -> list[int]: ``` Input Format * `cities`: A 2D list of floats where each inner list represents the coordinates of a city in 2D space. * `population_size`: An integer representing the number of routes in the population. * `generations`: An integer representing the number of generations to evolve. * `mutation_rate`: A float representing the probability of mutating a route per generation. Output Format * The function should return a list of integers representing the index order of cities in the best route found by the algorithm. Constraints * The number of cities can be between 2 and 20. * The population size (`population_size`) will be a positive integer. * The number of generations (`generations`) will be a positive integer. * The mutation rate (`mutation_rate`) will be a small positive float (typically between 0.01 and 0.1). Example ```python cities = [[0, 0], [1, 1], [4, 4], [6, 1]] population_size = 10 generations = 100 mutation_rate = 0.05 best_route = genetic_algorithm_tsp(cities, population_size, generations, mutation_rate) print(f\\"Best Route: {best_route}\\") ``` **Note:** Ensure your implementation handles initialization, selection, crossover, mutation, and fitness evaluation for route optimization. Handle edge cases, such as very small or large mutation rates, and maintain diversity in the population to avoid premature convergence.","solution":"import random import math from typing import List def calculate_distance(cities: List[List[float]], route: List[int]) -> float: distance = 0.0 for i in range(len(route)): city1 = cities[route[i]] city2 = cities[route[(i + 1) % len(route)]] distance += math.sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) return distance def create_initial_population(cities: List[List[float]], population_size: int) -> List[List[int]]: population = [] for _ in range(population_size): route = list(range(len(cities))) random.shuffle(route) population.append(route) return population def select_parents(population: List[List[int]], fitness_scores: List[float]) -> List[List[int]]: parents = random.choices(population, weights=fitness_scores, k=len(population)) return parents def crossover(parent1: List[int], parent2: List[int]) -> List[int]: child = [-1] * len(parent1) start, end = sorted(random.sample(range(len(parent1)), 2)) for i in range(start, end + 1): child[i] = parent1[i] current_pos = end + 1 for city in parent2: if city not in child: if current_pos == len(child): current_pos = 0 child[current_pos] = city current_pos += 1 return child def mutate(route: List[int], mutation_rate: float) -> None: for i in range(len(route)): if random.random() < mutation_rate: j = random.randint(0, len(route) - 1) route[i], route[j] = route[j], route[i] def genetic_algorithm_tsp(cities: List[List[float]], population_size: int, generations: int, mutation_rate: float) -> List[int]: population = create_initial_population(cities, population_size) for generation in range(generations): fitness_scores = [1 / calculate_distance(cities, route) for route in population] parents = select_parents(population, fitness_scores) next_generation = [] for i in range(0, len(parents), 2): parent1 = parents[i] parent2 = parents[(i + 1) % len(parents)] child1 = crossover(parent1, parent2) child2 = crossover(parent2, parent1) mutate(child1, mutation_rate) mutate(child2, mutation_rate) next_generation.append(child1) next_generation.append(child2) population = next_generation best_route = min(population, key=lambda route: calculate_distance(cities, route)) return best_route"},{"question":"# Problem Statement You need to design a function that reads a file containing a list of URLs, fetches the content of each URL, and outputs the length of the content fetched for each URL. The given code framework provides a basic structure but requires enhancement for performance and error handling. # Requirements 1. **File Reading**: Implement a function `read_urls_from_file` that reads URLs from a file, ensuring each URL is valid. 2. **Concurrent Fetching**: Improve the `fetch_all_url_contents` function to retrieve URL contents concurrently using asynchronous programming. 3. **Error Handling**: Implement robust error handling to manage network failures, invalid URLs, and timeouts gracefully. # Constraints - You can use the `aiohttp` library for asynchronous HTTP requests and `asyncio` for managing concurrency. - Assume the URLs file contains a maximum of 100 URLs, each on a new line. # Function Signature ```python import aiohttp import asyncio def read_urls_from_file(file_path: str) -> list[str]: # Implement this function pass async def fetch_url_content(session: aiohttp.ClientSession, url: str) -> dict: # Implement this function pass async def fetch_all_url_contents(urls: list[str]) -> list[dict]: # Implement this function pass if __name__ == \\"__main__\\": import sys file_path = sys.argv[1] urls = read_urls_from_file(file_path) results = asyncio.run(fetch_all_url_contents(urls)) for result in results: print(f\\"URL: {result[\'url\']} - Content Length: {result[\'content_length\']}\\") ``` # Expected Behavior 1. **Input**: File path to a text file containing URLs, one per line. 2. **Output**: Print each URL followed by the content length fetched. # Example Given `urls.txt`: ``` http://example.com http://example.org ``` Command: ```shell python fetch_content.py urls.txt ``` Example output: ``` URL: http://example.com - Content Length: 12785 URL: http://example.org - Content Length: 10452 ``` # Additional Notes - Ensure async functionality is correctly utilized to maximize performance. - Handle common errors such as invalid URLs or connection timeouts, returning appropriate messages.","solution":"import aiohttp import asyncio import re def read_urls_from_file(file_path: str) -> list[str]: Reads URLs from a file and validates them. :param file_path: Path to the file containing URLs :return: List of valid URLs with open(file_path, \\"r\\") as file: urls = file.read().splitlines() # Simple regex to validate URLs url_pattern = re.compile(r\'^(http|https)://[^s/.?#].[^s]*\') valid_urls = [url for url in urls if url_pattern.match(url)] return valid_urls async def fetch_url_content(session: aiohttp.ClientSession, url: str) -> dict: Fetches the content of a given URL. :param session: aiohttp ClientSession to use :param url: URL to fetch :return: Dictionary with URL and its content length try: async with session.get(url) as response: content = await response.read() return {\\"url\\": url, \\"content_length\\": len(content)} except aiohttp.ClientError as e: return {\\"url\\": url, \\"content_length\\": -1, \\"error\\": str(e)} async def fetch_all_url_contents(urls: list[str]) -> list[dict]: Fetches the content of all URLs concurrently. :param urls: List of URLs :return: List of dictionaries with URL and its content length async with aiohttp.ClientSession() as session: tasks = [fetch_url_content(session, url) for url in urls] return await asyncio.gather(*tasks) if __name__ == \\"__main__\\": import sys file_path = sys.argv[1] urls = read_urls_from_file(file_path) results = asyncio.run(fetch_all_url_contents(urls)) for result in results: if \\"error\\" in result: print(f\\"URL: {result[\'url\']} - Error: {result[\'error\']}\\") else: print(f\\"URL: {result[\'url\']} - Content Length: {result[\'content_length\']}\\")"},{"question":"# Fruit Harvest Optimization **Context**: A farmer has a series of fruit trees planted in a row. Each tree bears a different number of fruits. The farmer has a basket that can hold a maximum capacity of fruits, and he wishes to maximize the total number of fruits he harvests without exceeding the basket\'s capacity. **Task**: Write a function `max_fruits(tree_fruits: list[int], basket_capacity: int) -> int` that returns the maximum number of fruits that can be harvested without exceeding the basket\'s capacity. **Function Signature**: ```python def max_fruits(tree_fruits: list[int], basket_capacity: int) -> int: ``` **Input**: - `tree_fruits`: A list of integers where each element represents the number of fruits on each tree. - `basket_capacity`: An integer representing the maximum number of fruits the basket can hold. **Output**: - An integer representing the maximum number of fruits that can be harvested without exceeding the basket\'s capacity. **Constraints**: 1. `1 <= len(tree_fruits) <= 1000` 2. `1 <= tree_fruits[i] <= 1000` 3. `1 <= basket_capacity <= 10000` **Performance Requirements**: - The implementation should utilize a sliding window technique which runs in O(n) time complexity. **Example**: ```python tree_fruits = [2, 3, 2, 4, 3, 1, 5] basket_capacity = 10 print(max_fruits(tree_fruits, basket_capacity)) # Output: 10 ``` **Notes**: - The farmer can only harvest fruits from consecutive trees. - Ensure that the total number of fruits harvested does not exceed the basket\'s capacity.","solution":"def max_fruits(tree_fruits, basket_capacity): Returns the maximum number of fruits that can be harvested without exceeding the basket\'s capacity. Uses a sliding window technique to find the optimal solution. max_fruits = 0 current_sum = 0 left = 0 for right in range(len(tree_fruits)): current_sum += tree_fruits[right] while current_sum > basket_capacity: current_sum -= tree_fruits[left] left += 1 max_fruits = max(max_fruits, current_sum) return max_fruits # Example tree_fruits = [2, 3, 2, 4, 3, 1, 5] basket_capacity = 10 print(max_fruits(tree_fruits, basket_capacity)) # Output: 10"},{"question":"# Scenario: You are tasked with building an advanced calculator application. One feature of this calculator is to determine if a given integer is a prime number. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. Write a function that evaluates whether a given integer is a prime number. # Function Specification **Function name**: `is_prime` **Input**: - `n` (int): The integer to be evaluated. **Output**: - (bool): Returns `True` if the integer is a prime number, otherwise `False`. **Constraints**: - `n` will be a non-negative integer. - The function should be optimized for efficiency. **Examples**: ```python >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(1) False >>> is_prime(0) False ``` # Task: Complete the implementation of the `is_prime` function to correctly determine if the given integer is a prime number.","solution":"def is_prime(n): Returns True if the integer n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem Statement Create a function `unique_chars_count(s: str) -> Dict[str, int]` that counts the frequency of each unique character in a given string and returns the results as a dictionary. Function Signature ```python from typing import Dict def unique_chars_count(s: str) -> Dict[str, int]: ``` # Input - `s`: A string containing only lowercase alphabetical characters (1 ≤ len(s) ≤ 10^5). # Output - A dictionary where each key is a unique character from the input string and the value is the count of that character in the string. # Constraints - The function should raise a `ValueError` if `s` contains any non-alphabetical characters or if the length is not within the specified bounds. # Example ```python >>> unique_chars_count(\\"hello\\") {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} >>> unique_chars_count(\\"programming\\") {\'p\': 1, \'r\': 2, \'o\': 1, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1, \'n\': 1} >>> unique_chars_count(\\"aabbcc\\") {\'a\': 2, \'b\': 2, \'c\': 2} >>> unique_chars_count(\\"abcd\\") {\'a\': 1, \'b\': 1, \'c\': 1, \'d\': 1} ``` # Explanation 1. For `s = \\"hello\\"`, each unique character and their counts are \'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1. 2. For `s = \\"programming\\"`, each unique character and their counts are \'p\': 1, \'r\': 2, \'o\': 1, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1, \'n\': 1. 3. For `s = \\"aabbcc\\"`, each unique character and their counts are \'a\': 2, \'b\': 2, \'c\': 2. # Notes - Your solution should be efficient to handle the upper limit of input size. - Ensure handling of edge cases like minimum length strings and repeated characters. - Raise meaningful errors for invalid inputs as specified in the constraints. # Testing Ensure your implementation is tested against various scenarios: 1. Strings with all unique characters. 2. Strings with repeated characters. 3. Edge cases like single character strings. 4. Invalid input scenarios, such as strings containing digits or symbols or being outside the length constraints.","solution":"from typing import Dict def unique_chars_count(s: str) -> Dict[str, int]: if not (1 <= len(s) <= 10**5): raise ValueError(\\"The length of the string must be between 1 and 100,000 characters\\") if not s.isalpha() or not s.islower(): raise ValueError(\\"The string must contain only lowercase alphabetical characters\\") char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"# Context You are part of a development team that is working on a new data-stream processing pipeline. One of the critical components is a data rate limiter, which ensures that events do not exceed a certain rate per time interval. This rate limiting should be implemented using a token bucket algorithm. Your implementation will help the team manage the flow of data in real-time efficiently. # Objective Build a rate limiter using the token bucket algorithm. Your implementation must support adding tokens at regular intervals, consuming tokens when events occur, and resetting the bucket to a specified state. # Function Definitions 1. `initialize(rate: int, capacity: int)`: - Initializes the token bucket with a specified rate of token addition and a maximum capacity. 2. `consume(tokens: int) -> bool`: - Tries to consume the specified number of tokens from the bucket. Returns `True` if tokens were successfully consumed, else `False`. 3. `add_tokens()`: - Adds tokens to the bucket at the specified rate, up to the maximum capacity. 4. `reset(rate: int, capacity: int)`: - Resets the bucket to a new rate and capacity. # Input and Output Formats - **initialize(rate: int, capacity: int)** * `rate`: Integer, rate at which tokens are added to the bucket per second. * `capacity`: Integer, maximum number of tokens the bucket can hold. - **consume(tokens: int) -> bool** * `tokens`: Integer, number of tokens to consume. * Returns: Boolean, `True` if tokens were consumed successfully, `False` otherwise. - **add_tokens()** * No parameters, adds tokens to bucket based on the rate. - **reset(rate: int, capacity: int)** * `rate`: Integer, new rate at which tokens are added to the bucket per second. * `capacity`: Integer, new maximum number of tokens the bucket can hold. # Constraints - `1 <= rate <= 1000` - `1 <= capacity <= 10000` - `1 <= tokens <= 1000` # Example Usage ```python # Initialization initialize(rate=5, capacity=20) # Add tokens (assuming this function is called periodically by a scheduler) add_tokens() # Consume tokens print(consume(4)) # Example output: True print(consume(17)) # Example output: False # Reset bucket reset(rate=10, capacity=30) ``` # Task Implement the functions `initialize`, `consume`, `add_tokens`, and `reset` following the detailed guidelines and constraints.","solution":"import time class TokenBucket: def __init__(self): self.rate = 0 self.capacity = 0 self.tokens = 0 self.last_time = time.time() def initialize(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() def consume(self, tokens: int) -> bool: self.add_tokens() if self.tokens >= tokens: self.tokens -= tokens return True return False def add_tokens(self): current_time = time.time() elapsed = current_time - self.last_time tokens_to_add = int(elapsed * self.rate) self.tokens = min(self.capacity, self.tokens + tokens_to_add) self.last_time = current_time def reset(self, rate: int, capacity: int): self.rate = rate self.capacity = capacity self.tokens = capacity self.last_time = time.time() # Instance to use for the functions token_bucket = TokenBucket() def initialize(rate: int, capacity: int): token_bucket.initialize(rate, capacity) def consume(tokens: int) -> bool: return token_bucket.consume(tokens) def add_tokens(): token_bucket.add_tokens() def reset(rate: int, capacity: int): token_bucket.reset(rate, capacity)"},{"question":"# Coding Assessment Question Scenario You are tasked with developing a logging system that captures event logs and provides efficient retrieval of event counts that occurred within a specified time range. To accomplish this, implement a Fenwick Tree (Binary Indexed Tree) to support cumulative frequency queries. Task Implement the `build_fenwick_tree` and `query` functions to construct a Fenwick Tree from a list of event occurrences and efficiently retrieve event counts for specified time ranges. Function Definitions 1. **build_fenwick_tree**: * **Input**: A list of integers where each integer represents the number of events that occurred at a specific time. * **Output**: A list representing the constructed Fenwick Tree. * **Constraints**: - The input list may be empty. - The values are non-negative integers. 2. **query**: * **Input**: - A Fenwick Tree generated from `build_fenwick_tree`. - Two integers (`left_time`, `right_time`) representing the time range for the query. * **Output**: An integer representing the total number of events in the range `[left_time, right_time]`. * **Constraints**: - Ensure the time bounds are within the valid range. - Handle cases where the time bounds are invalid. Sample Usage ```python fenwick_tree = build_fenwick_tree([3, 2, 0, 5, 1, 2, 6]) assert query(fenwick_tree, 0, 3) == 10 assert query(fenwick_tree, 2, 6) == 14 fenwick_tree = build_fenwick_tree([1, 1, 1, 1, 1]) assert query(fenwick_tree, 0, 4) == 5 assert query(fenwick_tree, 1, 2) == 2 ``` # Requirements * Implement the core algorithm using the Fenwick Tree data structure. * Validate inputs to ensure error handling for edge cases such as empty lists and invalid time bounds. * Use efficient methods to achieve optimal performance for both construction and query operations. Constraints * Maximum length of the list ( n leq 10^5 ). * Ensure your implementation handles both small and large inputs effectively.","solution":"def build_fenwick_tree(events): Build a Fenwick Tree from a list of event counts. :param events: List of integers where each integer represents the number of events at a specific time. :return: List representing the constructed Fenwick Tree. n = len(events) fenwick_tree = [0] * (n + 1) for i in range(n): update(fenwick_tree, i, events[i]) return fenwick_tree def update(fenwick_tree, index, value): Update the Fenwick Tree with a new value. :param fenwick_tree: List representing the Fenwick Tree. :param index: Index at which to update the value. :param value: Value to add to the Fenwick Tree. index += 1 # Fenwick Tree is 1-indexed while index < len(fenwick_tree): fenwick_tree[index] += value index += index & -index def prefix_sum(fenwick_tree, index): Calculate the prefix sum up to a given index in the Fenwick Tree. :param fenwick_tree: List representing the Fenwick Tree. :param index: Index up to which to calculate the prefix sum. :return: Prefix sum of events up to the given index. index += 1 # Fenwick Tree is 1-indexed total = 0 while index > 0: total += fenwick_tree[index] index -= index & -index return total def query(fenwick_tree, left_time, right_time): Query the total number of events within the specified time range. :param fenwick_tree: Fenwick Tree generated from build_fenwick_tree. :param left_time: Starting time of the query range (inclusive). :param right_time: Ending time of the query range (inclusive). :return: Integer representing the total number of events in the range [left_time, right_time]. if left_time > right_time or left_time < 0 or right_time >= len(fenwick_tree) - 1: return 0 return prefix_sum(fenwick_tree, right_time) - prefix_sum(fenwick_tree, left_time - 1)"},{"question":"# Question: Determine the Shortest Path Length in a Weighted Graph Given a graph represented as an adjacency matrix, write a Python function to find the shortest path length between two specified nodes using Dijkstra\'s algorithm. The graph is represented as a two-dimensional list where each element `graph[i][j]` denotes the weight of the edge from node `i` to node `j`. If there is no edge between nodes `i` and `j`, the value will be `float(\'inf\')`. # Function Signature: ```python def shortest_path_length(graph: list[list[float]], start_node: int, end_node: int) -> float: pass ``` # Input: - `graph` (list[list[float]]): A 2D list where `graph[i][j]` is the weight of the edge from node `i` to node `j`. The number of nodes in the graph will be between 2 and 100. - `start_node` (int): The starting node index, must be a valid index within the graph. - `end_node` (int): The ending node index, must be a valid index within the graph. # Output: - The shortest path length (float) from the `start_node` to the `end_node`. If no path exists, return `float(\'inf\')`. # Constraints: - The adjacency matrix graph will have `float(\'inf\')` for non-existing edges and positive weights for existing edges. - The `start_node` and `end_node` will be valid indices within the bounds of the graph. # Example: ```python >>> graph = [ ... [0, 3, float(\'inf\'), 7], ... [8, 0, 2, float(\'inf\')], ... [5, float(\'inf\'), 0, 1], ... [2, float(\'inf\'), float(\'inf\'), 0] ... ] >>> shortest_path_length(graph, 0, 2) 5.0 >>> shortest_path_length(graph, 0, 3) 6.0 ``` # Notes: - Implement Dijkstra\'s algorithm to solve the problem. - Ensure to handle edge cases where no path exists between the start and end nodes by returning `float(\'inf\')`. - Consider the efficiency of the algorithm, particularly the handling of the priority queue.","solution":"import heapq def shortest_path_length(graph, start_node, end_node): Finds the shortest path length between start_node and end_node using Dijkstra\'s algorithm. Parameters: graph (list[list[float]]): A 2D list representing the weighted adjacency matrix of the graph. start_node (int): The starting node index. end_node (int): The ending node index. Returns: float: The shortest path length from start_node to end_node. If no path exists, return float(\'inf\'). n = len(graph) distances = [float(\'inf\')] * n distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight != float(\'inf\'): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end_node]"},{"question":"# Fibonacci Sequence Detection The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Given an integer, determine whether it belongs to the Fibonacci sequence. Task Implement a function `is_fibonacci_number` that checks if the provided integer is a Fibonacci number. Function Signature ```python def is_fibonacci_number(number: int) -> bool: pass ``` Input * `number` (int): A non-negative integer to be checked. Output * Returns `True` if the number belongs to the Fibonacci sequence, otherwise `False`. Constraints * `0 <= number <= 10^18` Examples * Example 1: - Input: `0` - Output: `True` * Example 2: - Input: `1` - Output: `True` * Example 3: - Input: `4` - Output: `False` * Example 4: - Input: `21` - Output: `True` * Example 5: - Input: `145` - Output: `False` Requirements * Account for the possibility of very large integers up to 10^18. * Ensure the algorithm efficiently handles the full input range, particularly for large numbers.","solution":"def is_fibonacci_number(number: int) -> bool: Check if a given number is a Fibonacci number. if number < 0: return False if number == 0 or number == 1: return True a, b = 0, 1 while b < number: a, b = b, a + b return b == number"},{"question":"# Zoo Animal Classification Context In a zoo, animals are categorized based on their species and other attributes like habitat and diet. As part of a new classification system, the zoo wants to automate the process of categorizing animals. Each animal can belong to one or more categories. Task Write a function `classify_animal` that takes the details of an animal and returns its categories based on predefined classification criteria. Function Signature ```python def classify_animal(species: str, habitat: str, diet: str) -> list: pass ``` Input * `species` (str): The species of the animal. * `habitat` (str): The habitat where the animal is commonly found. * `diet` (str): The diet of the animal. Output * A list of categories (list of str) that the animal belongs to. Classification Criteria * If the species is \\"elephant\\" and the habitat is \\"savannah\\", the animal belongs to the category \\"Mammal\\". * If the species is \\"lion\\" and the diet is \\"carnivore\\", the animal belongs to the categories \\"Mammal\\" and \\"Predator\\". * If the species is \\"crocodile\\" and the habitat is \\"river\\", the animal belongs to the categories \\"Reptile\\" and \\"Predator\\". * If the species is \\"parrot\\" and the diet is \\"herbivore\\", the animal belongs to the categories \\"Bird\\" and \\"Herbivore\\". * If the habitat is \\"tropical rainforest\\", the animal additionally belongs to the category \\"Tropical\\". * If the diet is \\"omnivore\\", the animal additionally belongs to the category \\"Omnivore\\". Constraints * The input strings will always be valid and have a length of 1 to 100 characters. Example ```python # Example usage print(classify_animal(\\"elephant\\", \\"savannah\\", \\"herbivore\\")) # Output: [\\"Mammal\\"] print(classify_animal(\\"lion\\", \\"savannah\\", \\"carnivore\\")) # Output: [\\"Mammal\\", \\"Predator\\"] print(classify_animal(\\"crocodile\\", \\"river\\", \\"carnivore\\")) # Output: [\\"Reptile\\", \\"Predator\\"] print(classify_animal(\\"parrot\\", \\"tropical rainforest\\", \\"herbivore\\")) # Output: [\\"Bird\\", \\"Herbivore\\", \\"Tropical\\"] ``` NOTE: Ensure that your function is efficient and correct, handling the classification based on the given criteria.","solution":"def classify_animal(species: str, habitat: str, diet: str) -> list: categories = [] if species == \\"elephant\\" and habitat == \\"savannah\\": categories.append(\\"Mammal\\") if species == \\"lion\\" and diet == \\"carnivore\\": categories.extend([\\"Mammal\\", \\"Predator\\"]) if species == \\"crocodile\\" and habitat == \\"river\\": categories.extend([\\"Reptile\\", \\"Predator\\"]) if species == \\"parrot\\" and diet == \\"herbivore\\": categories.extend([\\"Bird\\", \\"Herbivore\\"]) if habitat == \\"tropical rainforest\\": categories.append(\\"Tropical\\") if diet == \\"omnivore\\": categories.append(\\"Omnivore\\") return categories"},{"question":"# Coding Assessment Question: Implement a Simple Graph with Breadth-First Search (BFS) Context: As a software engineer, you are often required to manage and analyze network structures and their properties. One common task is to explore and traverse these structures efficiently. You are assigned to implement an undirected, unweighted graph and provide traversal capabilities using the Breadth-First Search (BFS) algorithm. Task: Implement a Graph class with the following methods: 1. `add_edge(node1: int, node2: int) -> None`: Add an undirected edge between two nodes. 2. `bfs(start: int) -> List[int]`: Perform BFS starting from a given node and return the nodes in the order they were visited. 3. `get_adj_list() -> Dict[int, List[int]]`: Return the adjacency list representation of the graph. Expected Behavior: - Adding an edge between two nodes should reflect in the adjacency list of both nodes. - Performing BFS should explore the nodes layer by layer starting from the given node. - `get_adj_list` should return the graph\'s adjacency list. Input and Output Formats: * `add_edge(node1: int, node2: int)`: * **Input**: Two integer values representing the nodes to be connected. * **Output**: None. * `bfs(start: int)`: * **Input**: An integer value representing the starting node for BFS. * **Output**: A list of integers representing nodes in BFS traversal order. * `get_adj_list()`: * **Input**: None. * **Output**: A dictionary representing the adjacency list of the graph. Constraints: 1. Node values will be non-negative integers. 2. Adding an edge between two nodes already connected should not create duplicate edges. 3. Performing BFS on an empty graph should return an empty list. 4. The graph will have no more than 10^4 nodes and 10^5 edges. 5. All operations should target average-case time complexity, considering Python’s list and dictionary operations. Performance Requirements: - The `add_edge` and `bfs` operations must be designed to handle large graphs efficiently. Complete the method definitions in the class `Graph`: ```python from collections import deque, defaultdict from typing import List, Dict class Graph: def __init__(self): self.adj_list = defaultdict(list) def add_edge(self, node1: int, node2: int) -> None: Add an undirected edge between node1 and node2 if node2 not in self.adj_list[node1]: self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs(self, start: int) -> List[int]: Perform Breadth-First Search starting from the given node visited = set() queue = deque([start]) result = [] visited.add(start) while queue: node = queue.popleft() result.append(node) for neighbor in self.adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result def get_adj_list(self) -> Dict[int, List[int]]: Return the adjacency list of the graph return dict(self.adj_list) # Example: # graph = Graph() # graph.add_edge(1, 2) # graph.add_edge(1, 3) # graph.add_edge(2, 4) # graph.add_edge(3, 4) # print(graph.get_adj_list()) # {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]} # print(graph.bfs(1)) # [1, 2, 3, 4] or [1, 3, 2, 4] ``` This question integrates into the existing set by maintaining a similar style, complexity, and scope. It requires knowledge of graph theory and traversal algorithms, aligning with the skills tested in the sample questions.","solution":"from collections import deque, defaultdict from typing import List, Dict class Graph: def __init__(self): self.adj_list = defaultdict(list) def add_edge(self, node1: int, node2: int) -> None: Add an undirected edge between node1 and node2 if node2 not in self.adj_list[node1]: self.adj_list[node1].append(node2) self.adj_list[node2].append(node1) def bfs(self, start: int) -> List[int]: Perform Breadth-First Search starting from the given node if start not in self.adj_list: return [] visited = set() queue = deque([start]) result = [] visited.add(start) while queue: node = queue.popleft() result.append(node) for neighbor in self.adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result def get_adj_list(self) -> Dict[int, List[int]]: Return the adjacency list of the graph return dict(self.adj_list)"},{"question":"# Product Sales Tracker You are given a list of sales records for various products. Each sale record is a tuple containing the product ID, quantity sold, and the price per unit. Your task is to analyze these records and return the total sales amount for each product ID. # Task Write a function `total_sales(records)` that takes a list of sales records, calculates the total sales for each product ID, and returns a dictionary with the product ID as keys and their corresponding total sales amount as values. # Input * `records`: A list of tuples where each tuple is of the form `(product_id, quantity_sold, price_per_unit)`. # Output * Return a dictionary where the keys are product IDs and the values are the total sales amount for each product ID. # Constraints 1. `product_id` is an integer. 2. `quantity_sold` and `price_per_unit` are positive integers. 3. The number of sales records will not exceed `10^5`. # Example Assume the following sales records: ```python records = [ (101, 2, 100), (102, 1, 200), (101, 5, 100), (103, 1, 300), (102, 4, 200) ] ``` Explanation: * Product 101: Total sales = (2 * 100) + (5 * 100) = 700 * Product 102: Total sales = (1 * 200) + (4 * 200) = 1000 * Product 103: Total sales = (1 * 300) = 300 The function should return: ```python { 101: 700, 102: 1000, 103: 300 } ``` **Function signature:** ```python def total_sales(records: list) -> dict: pass ```","solution":"def total_sales(records): Calculate the total sales amount for each product ID. Args: records (list of tuples): A list of sales records. Each tuple contains: (product_id, quantity_sold, price_per_unit). Returns: dict: A dictionary with product IDs as keys and their corresponding total sales amount as values. sales_dict = {} for product_id, quantity_sold, price_per_unit in records: if product_id in sales_dict: sales_dict[product_id] += quantity_sold * price_per_unit else: sales_dict[product_id] = quantity_sold * price_per_unit return sales_dict"},{"question":"# Context A mobile gaming application features a leaderboard tracking the high scores of its users. The leaderboard allows users to maintain their highest scores in various game levels, and administrators to query both individual scores and rankings. Your task is to build a class to manage this leaderboard efficiently. # Task Implement the following functions in a class named `Leaderboard`: 1. `add_score(self, user_id: int, score: int) -> None`: Adds or updates the user\'s highest score for a game level. If the user already has a higher score recorded, do not update it. 2. `remove_user(self, user_id: int) -> None`: Removes the user and their score from the leaderboard. 3. `get_score(self, user_id: int) -> int`: Returns the user\'s highest score. Raise a `ValueError` if the user is not on the leaderboard. 4. `get_top_users(self, k: int) -> list[int]`: Returns a list of the user IDs of the top `k` users sorted by their scores in descending order. If `k` is greater than the number of users, return all user IDs. 5. `get_rank(self, user_id: int) -> int`: Returns the rank of the user based on their score (1-based index). Raise a `ValueError` if the user is not on the leaderboard. # Constraints * User IDs are integers in the range [1, 10^6]. * Scores are integers in the range [0, 10^9]. * There will be at most 10^5 users on the leaderboard. # Performance Requirements Ensure efficient time complexity for all functions, particularly focusing on keeping insertions, deletions, and queries performant. # Class signature ```python class Leaderboard: def __init__(self) -> None: pass def add_score(self, user_id: int, score: int) -> None: pass def remove_user(self, user_id: int) -> None: pass def get_score(self, user_id: int) -> int: pass def get_top_users(self, k: int) -> list[int]: pass def get_rank(self, user_id: int) -> int: pass ``` # Example Usage ```python lb = Leaderboard() lb.add_score(1, 150) lb.add_score(2, 300) lb.add_score(3, 200) print(lb.get_score(2)) # 300 print(lb.get_top_users(2)) # [2, 3] lb.remove_user(3) print(lb.get_top_users(2)) # [2, 1] print(lb.get_rank(1)) # 2 lb.add_score(4, 350) print(lb.get_rank(4)) # 1 ```","solution":"class Leaderboard: def __init__(self) -> None: self.scores = {} def add_score(self, user_id: int, score: int) -> None: if user_id not in self.scores or score > self.scores[user_id]: self.scores[user_id] = score def remove_user(self, user_id: int) -> None: if user_id in self.scores: del self.scores[user_id] def get_score(self, user_id: int) -> int: if user_id not in self.scores: raise ValueError(f\\"User ID {user_id} is not on the leaderboard\\") return self.scores[user_id] def get_top_users(self, k: int) -> list[int]: sorted_users = sorted(self.scores.keys(), key=lambda user: self.scores[user], reverse=True) return sorted_users[:k] def get_rank(self, user_id: int) -> int: if user_id not in self.scores: raise ValueError(f\\"User ID {user_id} is not on the leaderboard\\") sorted_scores = sorted(self.scores.values(), reverse=True) user_score = self.scores[user_id] return sorted_scores.index(user_score) + 1"},{"question":"# Problem Statement: You need to perform several text processing operations on a list of sentences. Your task is to implement the following functions: 1. **`unique_words_count`**: Calculate the number of unique words across all sentences. 2. **`word_frequencies`**: Compute the frequency of each word in the list of sentences. 3. **`sentence_lengths`**: Calculate the length of each sentence in terms of the number of words. 4. **`average_sentence_length`**: Compute the average length of the sentences. 5. **`unique_words_in_sentence`**: Identify the unique words in each sentence. # Function Signatures: 1. **`def unique_words_count(sentences: list[str]) -> int:`** 2. **`def word_frequencies(sentences: list[str]) -> dict:`** 3. **`def sentence_lengths(sentences: list[str]) -> list[int]:`** 4. **`def average_sentence_length(sentence_lengths: list[int]) -> float:`** 5. **`def unique_words_in_sentence(sentence: str) -> set:`** # Input: - `sentences`: List of strings, where each string is a sentence consisting of multiple words separated by spaces. # Output: - The functions should return the required textual data as described in the function signatures. # Constraints: - The list of sentences has at least one sentence. - Each sentence consists of at least one word. - Words are separated by spaces and contain only alphabetic characters. # Example: ```python # Example usage of the functions: sentences = [\\"This is a sample sentence\\", \\"Another sample sentence is here\\", \\"Sample text is different\\"] # Unique Words Count unique_count = unique_words_count(sentences) print(unique_count) # Output: 8 # Word Frequencies frequencies = word_frequencies(sentences) print(frequencies) # Output: {\'This\': 1, \'is\': 3, \'a\': 1, \'sample\': 2, \'sentence\': 2, \'Another\': 1, \'here\': 1, \'text\': 1, \'different\': 1} # Sentence Lengths lengths = sentence_lengths(sentences) print(lengths) # Output: [5, 5, 4] # Average Sentence Length average_length = average_sentence_length(lengths) print(average_length) # Output: 4.666666666666667 # Unique Words in Sentence unique_words_set = unique_words_in_sentence(\\"This is a sample sentence\\") print(unique_words_set) # Output: {\'This\', \'is\', \'a\', \'sample\', \'sentence\'} ```","solution":"def unique_words_count(sentences): Calculate the number of unique words across all sentences. words_set = set() for sentence in sentences: words = sentence.split() for word in words: words_set.add(word) return len(words_set) def word_frequencies(sentences): Compute the frequency of each word in the list of sentences. frequency_dict = {} for sentence in sentences: words = sentence.split() for word in words: if word in frequency_dict: frequency_dict[word] += 1 else: frequency_dict[word] = 1 return frequency_dict def sentence_lengths(sentences): Calculate the length of each sentence in terms of the number of words. lengths = [] for sentence in sentences: length = len(sentence.split()) lengths.append(length) return lengths def average_sentence_length(sentence_lengths): Compute the average length of the sentences. return sum(sentence_lengths) / len(sentence_lengths) def unique_words_in_sentence(sentence): Identify the unique words in each sentence. return set(sentence.split())"},{"question":"# Matrix Transposition with Constraints You are required to implement a function that accepts an ( m times n ) matrix and returns its transpose. However, there is a constraint to ensure that the element in the i-th row and j-th column of the new transposed matrix does not fall into any disallowed row or column provided as input. Function Signature ```python def transpose_matrix_with_constraints(matrix: List[List[int]], disallowed_rows: List[int], disallowed_columns: List[int]) -> List[List[int]]: pass ``` Input: - `matrix` (List[List[int]]): An ( m times n ) matrix of integers. - `disallowed_rows` (List[int]): A list of row indices that are disallowed in the result transpose. - `disallowed_columns` (List[int]): A list of column indices that are disallowed in the result transpose. Output: - Returns a List of Lists of integers, representing the transposed matrix without the specified disallowed rows and columns. Constraints: - 1 ≤ m, n ≤ 100 - The indices in disallowed_rows and disallowed_columns will always be valid and within range. - Elements in matrix are integers. Requirements: - The function should efficiently handle the matrix transposition with the given constraints. - Ensure the output matrix does not include any disallowed rows or columns. Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] disallowed_rows = [1] disallowed_columns = [2] result = transpose_matrix_with_constraints(matrix, disallowed_rows, disallowed_columns) print(result) # Expected output: [[1, 4], [7, 10]] ``` Scenario: Consider you have an application that processes grid data and needs to transpose matrices while avoiding specific disallowed rows and columns due to privacy or other constraints. Implement a solution that transposes the given matrix and removes any specified rows and columns from the result. For example, if you have a 3x3 matrix and want to transpose it while excluding the second row and last column, the function should provide the desired output with these constraints applied.","solution":"from typing import List def transpose_matrix_with_constraints(matrix: List[List[int]], disallowed_rows: List[int], disallowed_columns: List[int]) -> List[List[int]]: m = len(matrix) n = len(matrix[0]) if matrix else 0 # Initialize the transposed matrix with empty list transposed_matrix = [] # Iterate over columns of the original matrix for j in range(n): if j in disallowed_columns: continue new_row = [] # Iterate over rows of the original matrix for i in range(m): if i in disallowed_rows: continue new_row.append(matrix[i][j]) transposed_matrix.append(new_row) return transposed_matrix"},{"question":"String Compression Algorithm You are developing a file compression utility and need to implement a fundamental string compression algorithm. This algorithm replaces sequences of repeated characters with a single character followed by the count of repetitions. Task: Write a function `compress_string` to perform basic string compression using the counts of repeated characters. ```python def compress_string(input_string: str) -> str: # implement the function pass ``` Parameters: * **input_string** (str): A string consisting of ASCII characters. Returns: * **str**: The compressed version of the input string. If the compressed string is not smaller than the original, return the original string. Details: * The compression rule is: - Each sequence of repeated characters is replaced by the single character followed by the number of times it appears consecutively. - If the compressed string is longer than the original, return the original. Examples: ```python >>> compress_string(\\"aabbcc\\") \'aabbcc\' >>> compress_string(\\"aaabccddd\\") \'a3bc2d3\' ``` Constraints: * The input string must not be empty. * The input string must contain only printable ASCII characters. Notes: * You can assume the input string will have a length of at most 10,000 characters. * Ensure the function operates efficiently even with the maximum input size.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for current_char in input_string[1:]: if current_char == prev_char: count += 1 else: compressed.append(prev_char) if count > 1: compressed.append(str(count)) prev_char = current_char count = 1 # Append the final group compressed.append(prev_char) if count > 1: compressed.append(str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Problem Statement You are tasked with implementing a function to parse a mathematical expression represented as a string and calculate its result. The expression will only contain the operators `+` and `-`, and positive integers. The expression will not have any whitespace between the numbers and the operators. Your task is to compute the result of the expression considering the order of operations (left to right). # Implementation Details **Function**: `calculate_expression(expression: str) -> int` - **Input**: * `expression`: A string representing a mathematical expression containing positive integers and the operators `+` and `-`. - **Output**: * Returns an integer representing the result of the expression. - **Constraints**: * The length of the expression string will not exceed 10^5. * Each number in the expression will be a positive integer not exceeding 1000. * The expression string will be valid and will not contain any whitespace. # Examples 1. **Example 1**: * Input: `\\"10+20-5+3-2\\"` * Output: `26` * Explanation: - 10 + 20 = 30 - 30 - 5 = 25 - 25 + 3 = 28 - 28 - 2 = 26 2. **Example 2**: * Input: `\\"100-50+25-10\\"` * Output: `65` * Explanation: - 100 - 50 = 50 - 50 + 25 = 75 - 75 - 10 = 65 # Implementation You should implement the following function in Python: ```python def calculate_expression(expression: str) -> int: # Your implementation here pass ```","solution":"def calculate_expression(expression: str) -> int: Calculates the result of the mathematical expression containing + and -. total = 0 current_number = 0 sign = 1 # Start with a positive sign for char in expression: if char.isdigit(): current_number = current_number * 10 + int(char) else: # Apply the current number to total based on the sign total += sign * current_number # Reset current number for the next number current_number = 0 # Update the sign based on current character if char == \'+\': sign = 1 elif char == \'-\': sign = -1 # Don\'t forget to add the last number if there is any total += sign * current_number return total"},{"question":"# Matrix Diagonal Sum Calculation **Background**: You are given a 2D square matrix (a list of lists) where each element is an integer. Your task is to calculate the sum of the matrix\'s primary and secondary diagonals. **Objective**: Implement the functionality to: 1. Calculate the sum of the primary diagonal elements. 2. Calculate the sum of the secondary diagonal elements. 3. Return the sum of both diagonals. # Requirements 1. **primary_diagonal_sum(matrix)**: This function should return the sum of the primary diagonal elements. 2. **secondary_diagonal_sum(matrix)**: This function should return the sum of the secondary diagonal elements. 3. **diagonal_sum(matrix)**: This function should return the combined sum of the primary and secondary diagonals. **Function Signatures**: ```python def primary_diagonal_sum(matrix): pass def secondary_diagonal_sum(matrix): pass def diagonal_sum(matrix): pass ``` # Input and Output **Primary Diagonal Sum** * **Input**: A 2D list `matrix` of integers. * **Output**: An integer representing the sum of the primary diagonal elements. **Secondary Diagonal Sum** * **Input**: A 2D list `matrix` of integers. * **Output**: An integer representing the sum of the secondary diagonal elements. **Diagonal Sum** * **Input**: A 2D list `matrix` of integers. * **Output**: An integer representing the sum of both diagonals. # Example ```python >>> m = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Primary Diagonal: 1 + 5 + 9 = 15 # Secondary Diagonal: 3 + 5 + 7 = 15 >>> primary_diagonal_sum(m) 15 >>> secondary_diagonal_sum(m) 15 >>> diagonal_sum(m) 30 ``` Complete the implementation of the three functions to meet these requirements.","solution":"def primary_diagonal_sum(matrix): Returns the sum of the primary diagonal elements of the matrix. return sum(matrix[i][i] for i in range(len(matrix))) def secondary_diagonal_sum(matrix): Returns the sum of the secondary diagonal elements of the matrix. n = len(matrix) return sum(matrix[i][n-i-1] for i in range(n)) def diagonal_sum(matrix): Returns the combined sum of the primary and secondary diagonals. return primary_diagonal_sum(matrix) + secondary_diagonal_sum(matrix)"},{"question":"# Prime Factors: Highest Power Problem Statement You are tasked with finding the highest power of a prime number that divides a given integer `n`. Specifically, given a number `n` and a prime number `p`, the objective is to determine the largest integer `k` such that `p^k` divides `n`. Objective Implement a function `highest_power_of_prime` that: - Takes two integer inputs, `n` (the number to be factored) and `p` (the prime number). - Returns the largest integer `k` such that `p^k` divides `n`. Functional Requirements - The function should validate and handle incorrect inputs: - Raise a `TypeError` if `n` or `p` is not an integer or cannot be cast to an integer. - Raise a `ValueError` if `n` is less than 1. - Raise a `ValueError` if `p` is not a prime number. - You must use an efficient algorithm to determine the highest power of the prime `p` that divides `n`. Constraints * 1 ≤ `n` ≤ 10^12. * 2 ≤ `p` ≤ 10^6. Input Format - Two integers `n` and `p`, where `n` is the number to be factored and `p` is the prime number. Output Format - An integer representing the highest power `k` such that `p^k` divides `n`. Example ```python >>> highest_power_of_prime(100, 2) 2 >>> highest_power_of_prime(81, 3) 4 >>> highest_power_of_prime(50, 5) 2 >>> highest_power_of_prime(50, 2) 1 >>> highest_power_of_prime(50, 3) 0 ``` Function Signature ```python def highest_power_of_prime(n: int, p: int) -> int: # Your code here ``` Scenario You are building a mathematical analysis tool that requires the ability to determine the highest power of a given prime factor within a number. This functionality is essential for various number theory computations and optimizations in cryptography and digital security algorithms. The user inputs the integer `n` and the prime number `p`, and your function should efficiently compute and return the necessary power.","solution":"def highest_power_of_prime(n: int, p: int) -> int: if not isinstance(n, int) or not isinstance(p, int): raise TypeError(\\"n and p must be integers\\") if n < 1: raise ValueError(\\"n must be a positive integer\\") # Basic prime validation for small p if p < 2 or any(p % d == 0 for d in range(2, int(p**0.5) + 1)): raise ValueError(\\"p must be a prime number\\") k = 0 while n % p == 0: n //= p k += 1 return k"},{"question":"# Context As part of a content management system (CMS), you need to implement a feature that helps track and manage user activities within the system. The focus is on monitoring when users log in and log out, and calculating the total amount of time a user has been active. # Task Implement a class `UserActivityTracker` that tracks user sessions and calculates total active time. The system should support the following operations: 1. **Log in**: Mark the time a user logs in. If the user is already logged in, this operation should not affect the current session. 2. **Log out**: Mark the time a user logs out. If the user is not logged in, this operation should have no effect. 3. **Get total active time**: Retrieve the total amount of time (in minutes) that a user has been active (i.e., logged in) within the system. User sessions are represented by timestamps in the form `YYYY-MM-DD HH:MM`. Implement methods with the following signatures: ```python class UserActivityTracker: def login(self, user: str, timestamp: str) -> None: pass def logout(self, user: str, timestamp: str) -> None: pass def get_total_active_time(self, user: str) -> int: pass ``` # Requirements 1. Timestamps are passed as strings in the `YYYY-MM-DD HH:MM` format. 2. You may assume all timestamps are valid and in chronological order. 3. Handle edge cases such as logging out without logging in, logging in while already logged in, and retrieving active time for users without any activity gracefully. 4. Calculate active time in minutes and ignore time zones and daylight saving changes. # Constraints * Usernames are strings with a maximum length of 50 characters. * Timestamps fall within the range `2000-01-01 00:00` to `2099-12-31 23:59`. # Example ```python tracker = UserActivityTracker() tracker.login(\\"Alice\\", \\"2023-10-15 08:00\\") tracker.logout(\\"Alice\\", \\"2023-10-15 10:00\\") print(tracker.get_total_active_time(\\"Alice\\")) # Output: 120 tracker.login(\\"Alice\\", \\"2023-10-15 11:00\\") tracker.logout(\\"Alice\\", \\"2023-10-15 12:30\\") print(tracker.get_total_active_time(\\"Alice\\")) # Output: 210 tracker.login(\\"Bob\\", \\"2023-10-15 09:00\\") tracker.logout(\\"Bob\\", \\"2023-10-15 09:30\\") print(tracker.get_total_active_time(\\"Bob\\")) # Output: 30 ``` Submission Submit a class `UserActivityTracker` implemented in Python, with the specified methods handling user activity tracking and calculating active time accurately as described.","solution":"from datetime import datetime class UserActivityTracker: def __init__(self): self.user_sessions = {} self.logged_in_users = {} def login(self, user: str, timestamp: str) -> None: if user in self.logged_in_users: return # User is already logged in, do nothing self.logged_in_users[user] = timestamp def logout(self, user: str, timestamp: str) -> None: if user not in self.logged_in_users: return # User is not logged in, do nothing login_time = datetime.strptime(self.logged_in_users[user], \\"%Y-%m-%d %H:%M\\") logout_time = datetime.strptime(timestamp, \\"%Y-%m-%d %H:%M\\") active_time = int((logout_time - login_time).total_seconds() / 60) if user in self.user_sessions: self.user_sessions[user] += active_time else: self.user_sessions[user] = active_time del self.logged_in_users[user] def get_total_active_time(self, user: str) -> int: if user in self.user_sessions: return self.user_sessions[user] return 0"},{"question":"# Coding Question You are tasked to design a Python function that interacts with the OpenWeatherMap API to fetch, analyze, and return weather data for specific cities. The function should process multiple cities in parallel to enhance performance and handle errors gracefully. Function Requirements: - **Function Name**: `fetch_weather_data` - **Inputs**: - `city_names` (list): A list of city names to query. - `fields` (list): List of weather data fields to retrieve for each city (default = None). - **Outputs**: - A dictionary where keys are city names and values are dictionaries of requested weather data fields. - **Constraints**: - If invalid field names are provided, raise a `ValueError` with the message \\"Invalid field(s): {invalid_fields}\\". - If a city name is not found, handle the error and continue processing other cities. - Use asynchronous requests to fetch data and ensure minimal performance impact. - Use `timeout=10` for API requests. - **Performance**: Optimize handling of multiple cities by using asynchronous programming and ensure efficient data processing. - **Edge Cases**: - Invalid city names. - API rate limiting and timeouts. - Empty responses. # Example Usage ```python try: result = fetch_weather_data( city_names=[\\"London\\", \\"New York\\", \\"Tokyo\\"], fields=[\\"temperature\\", \\"humidity\\", \\"pressure\\"] ) for city, weather_data in result.items(): print(f\\"Weather data for {city}:\\") for field, value in weather_data.items(): print(f\\" {field}: {value}\\") except ValueError as ve: print(ve) except requests.HTTPError: print(\\"Rate limit or other HTTP error, please try again later.\\") ``` # Notes - The `valid_fields` set is pre-defined with a list of acceptable weather data fields. - Focus on ensuring your solution filters data correctly and handles exceptions as specified. - Consider using libraries like `aiohttp` for asynchronous API requests and `asyncio` for managing the event loop. # Example Solution Signature ```python import aiohttp import asyncio async def fetch_weather_data( city_names: list, fields: list | None = None ) -> dict: # Your code here pass ```","solution":"import aiohttp import asyncio valid_fields = {\\"temperature\\", \\"humidity\\", \\"pressure\\", \\"weather\\", \\"wind_speed\\"} async def fetch_city_weather(session, city, fields): url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid=your_api_key\\" async with session.get(url, timeout=10) as response: data = await response.json() if response.status != 200: return city, None filtered_data = {field: data[\'main\'][field] for field in fields if field in data[\'main\']} filtered_data.update({field: data[\'weather\'][0][field] for field in fields if field in data[\'weather\'][0]}) return city, filtered_data async def fetch_weather_data(city_names, fields=None): if fields is None: fields = valid_fields else: invalid_fields = set(fields) - valid_fields if invalid_fields: raise ValueError(f\\"Invalid field(s): {invalid_fields}\\") async with aiohttp.ClientSession() as session: tasks = [fetch_city_weather(session, city, fields) for city in city_names] weather_data = await asyncio.gather(*tasks) return {city: data for city, data in weather_data if data is not None} # Example usage: # try: # result = asyncio.run(fetch_weather_data( # city_names=[\\"London\\", \\"New York\\", \\"Tokyo\\"], # fields=[\\"temperature\\", \\"humidity\\", \\"pressure\\"] # )) # for city, weather_data in result.items(): # print(f\\"Weather data for {city}:\\") # for field, value in weather_data.items(): # print(f\\" {field}: {value}\\") # except ValueError as ve: # print(ve) # except aiohttp.ClientError as e: # print(\\"HTTP error, please try again later.\\")"},{"question":"# Binary Search Tree (BST) - Median Finder You are provided with a Binary Search Tree (BST) implementation for storing and querying integer values. Your task is to extend this implementation to handle a new feature: **Finding the Median**. # Problem Context BSTs are commonly used for efficient sorting and searching. In addition to these operations, BSTs can be leveraged to quickly find statistical measures such as the median. In this problem, we focus on extending the BST functionality to include finding the median of all stored values. # Task Implement a `find_median` function that takes the root of a BST and returns the median value of all the integers stored in the BST. # Function Signature ```python def find_median(root: TreeNode) -> float: ``` # Parameters - `root`: The root node of a Binary Search Tree. # Returns - A float representing the median value of all integers in the BST. # Constraints - Assume the BST will contain at least one node. - The number of nodes in the BST will not exceed 10^6. # Example ```python # Example Usage bst = TreeNode(10) bst.left = TreeNode(5) bst.right = TreeNode(15) bst.left.left = TreeNode(2) bst.left.right = TreeNode(7) bst.right.left = TreeNode(12) bst.right.right = TreeNode(18) median = find_median(bst) print(\\"Median value of BST:\\", median) ``` In the example, `find_median` finds the median value of the BST. The sorted order of the BST values would be `[2, 5, 7, 10, 12, 15, 18]`, and the median value is `10`. # Considerations - Ensure the implementation handles both odd and even numbers of nodes. - For an even number of nodes, the median is the average of the two middle values. # Approach - Perform an in-order traversal to collect all the elements in sorted order. - Calculate the median based on the collected list of values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_traversal(root): Helper function to perform in-order traversal of the BST and return a sorted list of values. if root is None: return [] return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right) def find_median(root: TreeNode) -> float: Function to find the median of values stored in the BST. values = in_order_traversal(root) n = len(values) if n % 2 == 1: return values[n // 2] else: mid1 = n // 2 mid2 = mid1 - 1 return (values[mid1] + values[mid2]) / 2"},{"question":"# Coding Assessment Question Problem: You are working on a simulation of a robotic vacuum cleaner that can clean a rectangular grid room represented by a 2D matrix. The robot can move in four possible directions: up, down, left, and right. However, the robot cannot move into a cell that is an obstacle. Your task is to determine if there is a path for the robot to get from the starting position to the target position. Function Signature: ```python def can_reach_target(room: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: Determine if the robot can reach the target position from the start position. Input Parameters: ----------------- room: A 2D matrix (list of lists) representing the room, where 0 indicates an empty cell and 1 indicates an obstacle. start: A tuple (x, y) representing the starting coordinates of the robot. target: A tuple (x, y) representing the target coordinates. Returns: -------- A boolean indicating whether the robot can reach the target position. pass ``` Input: - `room` is a list of lists of integers, where each integer is either 0 or 1 (0 indicates an empty cell and 1 indicates an obstacle). - `start` is a tuple of two integers representing the starting coordinates in the grid. - `target` is a tuple of two integers representing the target coordinates in the grid. Output: - Return a boolean `True` if the robot can reach the target position from the start position, otherwise return `False`. Constraints: * All coordinates and elements in the room matrix will be non-negative integers. * The room matrix contains at least one row and one column. * The starting and target coordinates are guaranteed to be within the bounds of the grid and in cells that are not obstacles. * The robot can only move up, down, left, or right by one cell at a time. Example: ```python room = [ [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) can_reach_target(room, start, target) # Output: True room = [ [0, 0, 0, 1], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) can_reach_target(room, start, target) # Output: False ``` You should utilize an efficient search algorithm (like BFS or DFS) to explore the grid and determine the reachability from the start position to the target position. Ensure you handle edge cases such as when the start and target are the same cell.","solution":"from typing import List, Tuple from collections import deque def can_reach_target(room: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> bool: Determine if the robot can reach the target position from the start position. Input Parameters: ----------------- room: A 2D matrix (list of lists) representing the room, where 0 indicates an empty cell and 1 indicates an obstacle. start: A tuple (x, y) representing the starting coordinates of the robot. target: A tuple (x, y) representing the target coordinates. Returns: -------- A boolean indicating whether the robot can reach the target position. rows = len(room) cols = len(room[0]) if start == target: return True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and room[nx][ny] == 0: if (nx, ny) == target: return True queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Question: Interval Scheduling Maximization You are provided with a class `Scheduler` that manages a list of tasks, where each task is defined by a start time and an end time. The class includes a method `max_non_overlapping_tasks` for finding the maximum number of non-overlapping tasks using a greedy algorithm. Currently, the implementation assumes all tasks are provided at once and does not support dynamic task management. # Task 1. Extend the `Scheduler` class to not only manage and maximize non-overlapping tasks but also handle the following scenarios: - Ensure the scheduler can be updated dynamically, i.e., support adding and removing tasks. - Validate if the maximum set of non-overlapping tasks is updated correctly after each task modification. # Requirements 1. **Implement** the following additional methods in the `Scheduler` class: - `add_task`: to add a new task defined by its start time and end time. - `remove_task`: to remove an existing task defined by its start time and end time. 2. **Modify** the existing `max_non_overlapping_tasks` method such that it recalculates the maximum number of non-overlapping tasks efficiently after any task modification. # Input: - A list of tasks defined by their start time and end time. - Series of task additions or deletions. # Output: - Updated maximum number of non-overlapping tasks after each modification. # Constraints: - Ensure no overlap between the end time of one task and the start time of another. # Example: ```python scheduler = Scheduler() scheduler.tasks = [ (1, 3), (2, 5), (4, 6), (6, 8) ] print(scheduler.max_non_overlapping_tasks()) # Output should give the maximum number of non-overlapping tasks. # Adding a task and recalculating scheduler.add_task(3, 4) print(scheduler.max_non_overlapping_tasks()) # Output should reflect the updated maximum number of non-overlapping tasks. # Removing a task and recalculating scheduler.remove_task(2, 5) print(scheduler.max_non_overlapping_tasks()) # Output should reflect the updated maximum number of non-overlapping tasks. ``` # Function Signatures: 1. `def add_task(self, start: int, end: int) -> None:` 2. `def remove_task(self, start: int, end: int) -> None:` 3. Ensure `max_non_overlapping_tasks` method dynamically updates the maximum number of non-overlapping tasks upon task changes.","solution":"class Scheduler: def __init__(self): self.tasks = [] def add_task(self, start, end): Adds a task to the scheduler. if (start, end) not in self.tasks: self.tasks.append((start, end)) def remove_task(self, start, end): Removes a task from the scheduler. if (start, end) in self.tasks: self.tasks.remove((start, end)) def max_non_overlapping_tasks(self): Returns the maximum number of non-overlapping tasks. if not self.tasks: return 0 # Sort tasks by their end time sorted_tasks = sorted(self.tasks, key=lambda x: x[1]) count = 0 last_end_time = float(\'-inf\') for task in sorted_tasks: if task[0] >= last_end_time: count += 1 last_end_time = task[1] return count"},{"question":"**Context**: There is a need for a feature in an e-commerce platform that verifies whether the items in a cart meet certain requirements based on a dynamic pricing rule. An item can have multiple attributes like category, brand, price, etc. The system should be able to verify if the total price of items from a specific category is within a specified range. **Task**: Implement the function `is_category_price_within_range(cart: List[Dict[str, Any]], category: str, min_price: float, max_price: float) -> bool` that checks whether the total price of items belonging to a specific category in the shopping cart falls within the given price range. **Function Signature**: ```python from typing import List, Dict, Any def is_category_price_within_range(cart: List[Dict[str, Any]], category: str, min_price: float, max_price: float) -> bool: pass ``` **Input**: * `cart` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents an item. Each dictionary has the following structure: * `\\"name\\"` (str): The name of the item. * `\\"category\\"` (str): The category of the item. * `\\"price\\"` (float): The price of the item. * `category` (str): The specific category to check the total price for. * `min_price` (float): The minimum allowed price for the total price of the items in the specified category. * `max_price` (float): The maximum allowed price for the total price of the items in the specified category. **Output**: * (bool): `True` if the total price of items in the specified category is within the given price range, `False` otherwise. **Constraints**: * The cart list can contain up to 10^5 items. * Each item\'s price is a non-negative float that does not exceed 10^6. * The length of item names and categories does not exceed 100 characters. **Requirements**: * Achieve linear time complexity O(n) for the function. **Examples**: ```python cart = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1500.00}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 800.00}, {\\"name\\": \\"Headphones\\", \\"category\\": \\"Accessories\\", \\"price\\": 100.00}, {\\"name\\": \\"Shoes\\", \\"category\\": \\"Fashion\\", \\"price\\": 120.00} ] assert is_category_price_within_range(cart, \\"Electronics\\", 2000.00, 3000.00) == True assert is_category_price_within_range(cart, \\"Electronics\\", 2500.00, 3000.00) == False assert is_category_price_within_range(cart, \\"Fashion\\", 100.00, 150.00) == True assert is_category_price_within_range(cart, \\"Accessories\\", 50.00, 150.00) == True assert is_category_price_within_range(cart, \\"Accessories\\", 200.00, 300.00) == False ```","solution":"from typing import List, Dict, Any def is_category_price_within_range(cart: List[Dict[str, Any]], category: str, min_price: float, max_price: float) -> bool: Checks whether the total price of items in the specified category falls within the given price range. total_price = sum(item[\'price\'] for item in cart if item[\'category\'] == category) return min_price <= total_price <= max_price"},{"question":"# Rectangle Overlap Detection - Geometric Analysis You are working on a graphics rendering system where you need to detect if two rectangles overlap. Each rectangle is aligned with the axes of the plane, meaning their sides are parallel to the x and y axes. Each rectangle is represented by its bottom-left and top-right corners. Implement a function to determine whether two given rectangles overlap. Function Signature ```python def do_rectangles_overlap(rect1: Tuple[Tuple[int, int], Tuple[int, int]], rect2: Tuple[Tuple[int, int], Tuple[int, int]]) -> bool: ``` Input - **rect1**: A tuple containing two tuples, where the first tuple is the bottom-left corner, and the second tuple is the top-right corner of the first rectangle. Each corner is represented as a tuple of two integers (x, y). - **rect2**: A tuple containing two tuples, where the first tuple is the bottom-left corner, and the second tuple is the top-right corner of the second rectangle. Each corner is represented as a tuple of two integers (x, y). Output - Returns `True` if the rectangles overlap, and `False` otherwise. Constraints - The coordinates of the corners are integers within the range [-10^4, 10^4]. Example ```python rect1 = ((0, 0), (2, 2)) rect2 = ((1, 1), (3, 3)) assert do_rectangles_overlap(rect1, rect2) == True rect1 = ((0, 0), (1, 1)) rect2 = ((1, 1), (2, 2)) assert do_rectangles_overlap(rect1, rect2) == False ``` Notes - Rectangles that only touch at the edges or corners should not be considered overlapping. - Use efficient geometric principles to determine overlap, considering the positions of all corners of both rectangles.","solution":"from typing import Tuple def do_rectangles_overlap(rect1: Tuple[Tuple[int, int], Tuple[int, int]], rect2: Tuple[Tuple[int, int], Tuple[int, int]]) -> bool: Determines if two rectangles overlap. Each rectangle is given by two corners: the bottom-left and the top-right corners. # Unpack the corners of the rectangles (x1_bl, y1_bl), (x1_tr, y1_tr) = rect1 (x2_bl, y2_bl), (x2_tr, y2_tr) = rect2 # Check if one rectangle is to the left of the other if x1_tr <= x2_bl or x2_tr <= x1_bl: return False # Check if one rectangle is above the other if y1_tr <= y2_bl or y2_tr <= y1_bl: return False return True"},{"question":"# Context Basic knowledge of matrix operations and array manipulation will help you solve this puzzle. The task requires you to implement a function that rotates a 2D matrix 90 degrees in the clockwise direction. Understanding of nested loops, matrix indexing, and in-place modifications is essential. # Problem Statement Define a function `rotate_matrix_90_clockwise` that takes a square matrix and rotates it by 90 degrees in the clockwise direction. # Function Signature ```python def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: ``` # Input * A 2D list of integers `matrix`, where each inner list represents a row of the matrix. # Output * The function should modify the matrix in place to perform the rotation. No explicit return value is needed. # Constraints * You may assume that the matrix is a square matrix (i.e., the number of rows is equal to the number of columns). * The matrix can contain integer values of any range, including negative, positive, and zero. * The matrix dimension `n` (number of rows and columns) will be between 1 and 100. # Example ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix_90_clockwise(matrix) print(matrix) # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [5, 1], [2, 3] ] rotate_matrix_90_clockwise(matrix) print(matrix) # Output: [ # [2, 5], # [3, 1] # ] # Example 3 matrix = [[1]] rotate_matrix_90_clockwise(matrix) print(matrix) # Output: [[1]] ``` # Hints * Consider breaking the problem into two main steps: transposing the matrix and then reversing each row. * Ensure you handle in-place modifications correctly to avoid additional memory usage.","solution":"def rotate_matrix_90_clockwise(matrix: list[list[int]]) -> None: Rotates the given square matrix 90 degrees in the clockwise direction in place. :param matrix: 2D list of integers representing the square matrix. n = len(matrix) # First, transpose the matrix (convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, reverse each row to get the 90 degrees clockwise rotation for i in range(n): matrix[i].reverse()"},{"question":"# Question: Optimal Meeting Point Given an array representing the positions of houses on a street (each house is represented by its integer coordinate), implement a function `optimal_meeting_point(houses: List[int]) -> int` that finds the optimal meeting point minimizing the total travel distance for all the houses. The optimal meeting point is the coordinate such that the sum of the absolute differences between each house\'s position and this point is minimized. # Input Format * `houses`: A list of integers ( -10^9 leq house , text{coordinate} leq 10^9 ) with length ( 0 leq |houses| leq 10^5 ). # Output Format * A single integer representing the optimal meeting point. # Constraints * You must achieve a time complexity of at most (O(n log n)). * The array may contain duplicate elements, but they should be handled appropriately in finding the optimal meeting point. # Example ```python >>> optimal_meeting_point([1, 2, 3, 4]) 2 >>> optimal_meeting_point([7, 10, 3, 4]) 4 >>> optimal_meeting_point([10, 20, 30]) 20 >>> optimal_meeting_point([1]) 1 >>> optimal_meeting_point([]) 0 ``` # Additional Notes 1. Explain how your algorithm leverages the properties of the median to find the optimal meeting point efficiently. 2. Consider edge cases such as an empty list or a list with a single house.","solution":"from typing import List def optimal_meeting_point(houses: List[int]) -> int: Returns the optimal meeting point minimizing the total travel distance for all houses. if not houses: return 0 # Sort the list to find the median houses.sort() # Median minimizes the total distance in a one-dimensional list n = len(houses) median = houses[n // 2] if n % 2 != 0 else houses[n // 2 - 1] return median"},{"question":"Implement a simplified version of the LRU (Least Recently Used) cache. This cache system will store a fixed number of items and, when full, will remove the least recently used item to make space for new ones. You need to implement the following functionalities: cache initialization, retrieving an item from the cache, adding an item to the cache, and getting the current state of the cache. # Objectives: 1. Write a class `LRUCache` to represent the LRU cache. 2. Implement an `__init__` method to initialize the cache with a given capacity. 3. Implement a `get` method to retrieve the value of a key if it exists in the cache, otherwise return `-1`. 4. Implement a `put` method to add a key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before adding a new item. 5. Implement a `current_state` method to return the current state of the cache as an ordered list of key-value pairs. # Class Definitions: - `class LRUCache` - **Method**: - `__init__(capacity: int) -> None` - **Input**: - capacity: Integer representing the maximum number of items the cache can hold. - **Output**: None - `get(key: int) -> int` - **Input**: - key: Integer key whose value needs to be retrieved. - **Output**: Integer value associated with the key if it exists, else `-1`. - `put(key: int, value: int) -> None` - **Input**: - key: Integer key to be added or updated. - value: Integer value associated with the key. - **Output**: None - `current_state() -> List[Tuple[int, int]]` - **Output**: List of key-value pairs representing the current state of the cache in order of usage (most recently used to least recently used). # Constraints: - Capacity of the cache will be between 1 and 1000 inclusive. - Key and value for `get` and `put` methods will be integers. # Example Usage: ```python # Initializing LRUCache with capacity 3 cache = LRUCache(3) # Adding items to the cache cache.put(1, 10) cache.put(2, 20) cache.put(3, 30) # Current state of the cache print(cache.current_state()) # Output: [(1, 10), (2, 20), (3, 30)] # Retrieving value of key 2 print(cache.get(2)) # Output: 20 # Current state of the cache print(cache.current_state()) # Output: [(1, 10), (3, 30), (2, 20)] # Adding a new item when cache is full cache.put(4, 40) # Current state of the cache print(cache.current_state()) # Output: [(3, 30), (2, 20), (4, 40)] # Retrieving value of key 1 (should be -1 as it was removed) print(cache.get(1)) # Output: -1 ``` Implement these functionalities in Python following provided specifications and constraints. Ensure your implementation correctly handles the LRU eviction policy.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int) -> None: self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) def current_state(self) -> list: return list(self.cache.items())"},{"question":"Binary Search on a Matrix Binary search can be efficiently applied to a sorted 2D matrix to find the position of a specified element. Using this approach can help achieve an optimal search performance in a matrix setting. # Problem Statement You are required to implement a binary search algorithm to find the position of a specified element in a sorted 2D matrix. The matrix is sorted such that each row and each column are in ascending order. # Input * A sorted 2D matrix `mat` of `m x n` integers. * An integer `val` which is the value to be searched within the matrix. # Output * Return a tuple `(i, j)` representing the row and column indices of the `val` in the matrix. * Return `(-1, -1)` if the value is not found in the matrix. # Constraints * The elements of the matrix can be any type that supports comparison operators. * The matrix `mat` can be of size `0 <= m, n <= 10^3`. * Be prepared to handle both positive and negative integers. # Example: ```python >>> binary_search_2d([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5) (1, 1) >>> binary_search_2d([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) (-1, -1) >>> binary_search_2d([], 1) (-1, -1) >>> binary_search_2d([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 15) (2, 1) ``` # Task Implement the `binary_search_2d` function as described.","solution":"def binary_search_2d(mat, val): if not mat or not mat[0]: return (-1, -1) m, n = len(mat), len(mat[0]) left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_val = mat[mid // n][mid % n] if mid_val == val: return (mid // n, mid % n) elif mid_val < val: left = mid + 1 else: right = mid - 1 return (-1, -1)"},{"question":"# Scenario As part of an automation project, you need to write a Python function that extracts and processes financial data from a CSV file. The CSV file contains daily stock prices for several companies, including the columns: `Date`, `Company`, `Open`, `High`, `Low`, `Close`, and `Volume`. # Task Write a Python function `calculate_moving_average(company: str, window_size: int) -> List[Tuple[str, float]]` that accepts a company\'s name and a window size as parameters. The function should read a CSV file named `stock_prices.csv`, filter the rows corresponding to the selected company, and then calculate the moving average of the `Close` prices over the specified window size. The function should return a list of tuples, where each tuple contains a date (as a string) and the associated moving average (as a float). # Requirements - Use the `csv` library to read the CSV file. - Handle edge cases such as when the data for the specified company is insufficient to calculate the moving average for the given window size. - Ensure the function returns the moving averages only for the dates where they can be calculated (i.e., avoid returning moving averages for the first few rows where the window is incomplete). - Raise a ValueError if the company does not exist in the dataset or if the window size is not positive. # Input and Output - **Input**: - `company` (str): The name of the company. - `window_size` (int): The moving average window size. - **Output**: A list of tuples, each containing a date (str) and the moving average (float). # Code Template ```python import csv from typing import List, Tuple def calculate_moving_average(company: str, window_size: int) -> List[Tuple[str, float]]: if window_size <= 0: raise ValueError(\\"Window size must be a positive integer.\\") moving_averages = [] prices = [] with open(\'stock_prices.csv\', newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if row[\'Company\'] == company: prices.append((row[\'Date\'], float(row[\'Close\']))) if not prices: raise ValueError(f\\"No data found for company {company}.\\") for i in range(len(prices)): if i >= window_size - 1: window = prices[i-window_size+1:i+1] average_close = sum(price[1] for price in window) / window_size moving_averages.append((prices[i][0], average_close)) return moving_averages # Example usage (do not include in submission): # print(calculate_moving_average(\\"Apple\\", 3)) ``` **Constraints**: - Assume the CSV file named `stock_prices.csv` is available in the same directory as the script. - Date format in the CSV file is assumed to be `YYYY-MM-DD`.","solution":"import csv from typing import List, Tuple def calculate_moving_average(company: str, window_size: int) -> List[Tuple[str, float]]: if window_size <= 0: raise ValueError(\\"Window size must be a positive integer.\\") moving_averages = [] prices = [] with open(\'stock_prices.csv\', newline=\'\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: if row[\'Company\'] == company: prices.append((row[\'Date\'], float(row[\'Close\']))) if not prices: raise ValueError(f\\"No data found for company {company}.\\") for i in range(len(prices)): if i >= window_size - 1: window = prices[i-window_size+1:i+1] average_close = sum(price[1] for price in window) / window_size moving_averages.append((prices[i][0], average_close)) return moving_averages"},{"question":"# Question You are provided with a string manipulation problem that focuses on finding the longest substring without repeating characters. Your task is to design an efficient function to identify the longest such substring in a given input string. **Core Concepts**: A substring is a contiguous sequence of characters within a string. The goal is to identify the maximum length of substrings where no character repeats. # Input - A single string `s` containing only ASCII characters. # Output - An integer representing the length of the longest substring without repeating characters. # Constraints - 0 ≤ len(s) ≤ 10000 # Example ```python s = \\"abcabcbb\\" print(longest_unique_substr(s)) ``` Output: ```python 3 ``` ```python s = \\"bbbbb\\" print(longest_unique_substr(s)) ``` Output: ```python 1 ``` # Implementation Function signature: ```python def longest_unique_substr(s: str) -> int: pass # Implementation to be added ``` # Steps to Solve 1. Use the sliding window technique to keep track of the current substring and ensure all characters are unique. 2. Utilize a hash map or set to store the characters in the current window. 3. Expand the window by adding characters until a repeat is found, then contract from the left to remove the repeat character. 4. Update the maximum length of the substring found at each step. **Additional Information**: Your implementation should handle strings efficiently without repeating characters, leveraging optimal sliding window strategies. Consider edge cases such as an empty string or a string with all unique characters.","solution":"def longest_unique_substr(s: str) -> int: Finds the length of the longest substring without repeating characters. :param s: Input string :return: Length of the longest substring with unique characters # Dictionary to store the last positions of the characters last_seen = {} start = 0 longest_length = 0 for i, char in enumerate(s): # If the character is already in the dictionary and it\'s within the bounds of the current window if char in last_seen and last_seen[char] >= start: # Move the start to the next position after the last occurrence of the current character start = last_seen[char] + 1 # Update the last occurrence of the character last_seen[char] = i # Calculate the length of the current window and update max length if needed window_length = i - start + 1 longest_length = max(longest_length, window_length) return longest_length"},{"question":"**Question: Efficient Palindrome Checking** **Context:** Bob is developing a text processing tool that needs to efficiently identify palindromes within strings. A palindrome is a string that reads the same forward and backward. Given the need to handle large strings and numerous queries, Bob wants to implement a function that checks if a given string is a palindrome efficiently. **Task:** Your task is to implement a function that checks if a given string is a palindrome. The function should be case-insensitive and ignore non-alphanumeric characters to handle phrases and sentences correctly. **Function Signature:** ```python def is_palindrome(s: str) -> bool: pass ``` **Input:** - `s` (string): A string that may contain uppercase and lowercase letters, digits, spaces, and punctuation marks. **Output:** - A boolean value: `True` if the string is a palindrome after ignoring case and non-alphanumeric characters; otherwise, `False`. **Constraints:** - The string length may be up to (10^5) characters. **Examples:** 1. `is_palindrome(\\"A man, a plan, a canal, Panama!\\")` should return `True`. 2. `is_palindrome(\\"racecar\\")` should return `True`. 3. `is_palindrome(\\"hello\\")` should return `False`. 4. `is_palindrome(\\"No lemon, no melon\\")` should return `True`. **Additional Notes:** 1. Convert all characters to lowercase and remove non-alphanumeric characters before checking for palindrome. 2. Ensure the function performs efficiently even for the maximum string length.","solution":"def is_palindrome(s: str) -> bool: Check if the given string is a palindrome, ignoring case and non-alphanumeric characters. # Convert string to lowercase and filter out non-alphanumeric characters filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"# Coding Challenge: Subarray Sum Calculation You are required to write a function to calculate the sum of all subarrays of a given array of integers. A subarray is a contiguous part of the array. Function Signature ```python def subarray_sums(arr: List[int]) -> List[int]: # Your implementation here ``` Input 1. `arr` (List[int]): A list of integers. Output - Returns a list of integers where each element is the sum of a contiguous subarray of the input array. The sums should be listed in the order of the starting index of the subarrays and then by the length of the subarrays. Constraints - The length of `arr` will be between 1 and 100, inclusive. - Each element in `arr` will be between -1000 and 1000, inclusive. Examples 1. `subarray_sums([1, 2, 3])` should return `[1, 3, 6, 2, 5, 3]` because the subarrays are [1], [1,2], [1,2,3], [2], [2,3], and [3]. 2. `subarray_sums([-1, 2, -3])` should return `[-1, 1, -2, 2, -1, -3]` because the subarrays are [-1], [-1,2], [-1,2,-3], [2], [2,-3], and [-3]. 3. `subarray_sums([4, -2, 5])` should return `[4, 2, 7, -2, 3, 5]` because the subarrays are [4], [4,-2], [4,-2,5], [-2], [-2,5], and [5]. Example Usage ```python print(subarray_sums([1, 3, 2])) # Should output: [1, 4, 6, 3, 5, 2] print(subarray_sums([-1, 2, 1])) # Should output: [-1, 1, 2, 2, 3, 1] print(subarray_sums([1])) # Should output: [1] ``` Implement the `subarray_sums` function according to the given requirements.","solution":"from typing import List def subarray_sums(arr: List[int]) -> List[int]: Calculate sum of all subarrays of the given array. Args: arr (List[int]): A list of integers. Returns: List[int]: A list containing the sums of all subarrays. result = [] n = len(arr) for i in range(n): current_sum = 0 for j in range(i, n): current_sum += arr[j] result.append(current_sum) return result"},{"question":"# Identifying Prime Fibonacci Numbers You are tasked with implementing a function that generates the first `n` Fibonacci numbers and identifies which of those numbers are prime. Function Signature ```python def prime_fibonacci_numbers(n: int) -> list: ``` Input - **n**: A positive integer representing the number of Fibonacci numbers to generate. Output - Returns a list of tuples where each tuple contains a Fibonacci number and a boolean indicating whether it is prime. For instance, [(0, False), (1, False), (1, False), (2, True)] indicating the number is prime or not. Constraints - The input `n` will be between 1 and 50. - Optimize for time and space considering the constraints. Example ```python >>> prime_fibonacci_numbers(10) [(0, False), (1, False), (1, False), (2, True), (3, True), (5, True), (8, False), (13, True), (21, False), (34, False)] ``` Notes - Make sure to handle edge cases such as non-integer inputs and non-positive integers appropriately by raising appropriate exceptions. - You can use any prime-checking algorithm or library available to determine the primality of a number. Hints - Recall that the Fibonacci sequence is generated by summing the two preceding numbers, starting from 0 and 1. - Pay attention to efficient prime-checking techniques, such as the Sieve of Eratosthenes, to avoid performance bottlenecks.","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def prime_fibonacci_numbers(n: int) -> list: Generate the first `n` Fibonacci numbers and identify which of those numbers are prime. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") fib_sequence = [] a, b = 0, 1 for _ in range(n): fib_sequence.append(a) a, b = b, a + b result = [(num, is_prime(num)) for num in fib_sequence] return result"},{"question":"# Problem Statement: You need to implement a searching function that finds the smallest missing positive integer from an unsorted list of integers. This should be done in O(n) time complexity and constant space complexity. # Input: * A list of integers `nums` with length `n` (1 ≤ `n` ≤ 10^6). The list may contain positive, negative, and zero values. # Output: * An integer which is the smallest missing positive integer. # Constraints: * Your implementation should be efficient, adhering to O(n) time complexity. * You are not allowed to use extra space other than a few variables (i.e., O(1) space complexity). # Example: ```python assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 ``` # Hint: * Modify the input list in-place to mark the presence of elements. * Utilize the properties of indices to efficiently determine the missing positive integer. # Implementation: Implement the function `find_smallest_missing_positive(nums: List[int]) -> int` based on the above analysis.","solution":"def find_smallest_missing_positive(nums): Finds the smallest missing positive integer from an unsorted list of integers. The function modifies the list in-place and operates in O(n) time with O(1) extra space. n = len(nums) # Step 1: Replace negative numbers, zeros, and numbers larger than n with n + 1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark the presence of numbers within the range [1, n] for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first positive number\'s index (which represents the missing positive) for i in range(n): if nums[i] > 0: return i + 1 # If all numbers from 1 to n are present, the missing number is n + 1 return n + 1"},{"question":"# Binary Search Tree (BST) Traversal and Validation Context Binary Search Trees (BSTs) are a type of data structure that maintains sorted order, allowing efficient insertion, deletion, and lookup operations. It is crucial to be able to traverse and validate BSTs, ensuring they preserve the binary search tree properties. Task You are required to write a function that checks if a binary tree is a valid Binary Search Tree (BST) and returns the in-order traversal of the tree if it is valid. Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def validate_bst_and_traverse(root: TreeNode) -> list[int]: pass ``` # Input 1. **root**: The root node of a binary tree. - Each `TreeNode` has an integer value. - Tree node values are within the range of `-1000` to `1000`. - The number of nodes in the tree is between `1` and `10,000`. # Output If the tree is a valid BST, return a list of integers representing the in-order traversal of the tree. If the tree is not a valid BST, return an empty list. # Constraints - A valid BST follows these rules: - The left subtree of a node contains only nodes with values less than the node’s value. - The right subtree of a node contains only nodes with values greater than or equal to the node’s value. - Both the left and right subtrees must also be BSTs. Example ```python # Example 1 root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) print(validate_bst_and_traverse(root)) # Output: [1, 2, 3] # Example 2 root = TreeNode(5) root.left = TreeNode(1) root.right = TreeNode(4) root.right.left = TreeNode(3) root.right.right = TreeNode(6) print(validate_bst_and_traverse(root)) # Output: [] # Example 3 root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.right.left = TreeNode(11) root.right.right = TreeNode(20) print(validate_bst_and_traverse(root)) # Output: [5, 10, 11, 15, 20] ``` Notes - You may use a recursive or iterative approach to implement both the validation and the in-order traversal. - Ensure to handle edge cases such as an empty tree or a tree with only one node. - Consider utilizing helper functions to keep your code organized and modular.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def validate_bst_and_traverse(root: TreeNode) -> list[int]: def inorder_traversal(node: TreeNode): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) def is_valid_bst(node: TreeNode, left_limit=float(\'-inf\'), right_limit=float(\'inf\')) -> bool: if not node: return True if not (left_limit < node.val < right_limit): return False return (is_valid_bst(node.left, left_limit, node.val) and is_valid_bst(node.right, node.val, right_limit)) if is_valid_bst(root): return inorder_traversal(root) else: return []"},{"question":"# Problem Description You are given a string `s` and a non-negative integer `k`. Your task is to write a function `rotate_string_k` that returns a new string where the original string has been rotated to the right by `k` positions. If `k` is greater than the length of the string, the rotation should continue from the beginning. # Input * `s` (string): The input string. * `k` (int): The number of positions to rotate the string to the right. # Output * The function should return a string that is the result of the rotation. # Constraints * The string `s` can be empty. * `0 <= k <= 10^5` # Example ```python >>> rotate_string_k(\\"hello\\", 2) \\"lohel\\" >>> rotate_string_k(\\"world\\", 0) \\"world\\" >>> rotate_string_k(\\"python\\", 10) \\"thonpy\\" >>> rotate_string_k(\\"\\", 3) \\"\\" ``` # Requirements * Implement the function `rotate_string_k` that meets the specifications. * Ensure the code efficiently handles the constraints.","solution":"def rotate_string_k(s, k): Rotates the string s to the right by k positions. If k is greater than the length of the string, the rotation continues from the beginning. Parameters: s (str): The input string. k (int): The number of positions to rotate the string to the right. Returns: str: The rotated string. if not s: return s n = len(s) k = k % n # Get the effective rotations needed if k is greater than n return s[-k:] + s[:-k]"},{"question":"# Racing Horses in Python In this assessment, you will implement a function to determine the outcome of a horse race given the time each horse requires to complete the race. The function should return the rankings of the horses based on their times, with the fastest horse ranked first. # Requirements: 1. Implement the function `rank_horses()` with the following signature: ```python def rank_horses(horse_times: List[float]) -> List[int]: ``` 2. The function should take a list of positive floats representing the time (in seconds) each horse took to complete the race. The return value should be a list of integers representing the ranks of the corresponding horses. 3. Ensure the function handles invalid inputs by raising appropriate exceptions: - `ValueError` if any time value is non-positive. - For clarity, the descriptive message should be: - \\"All times must be positive numbers.\\" 4. The ranking should start from 1 for the fastest horse and increase sequentially. If two horses have the same time, they should receive the same rank, and the subsequent horses should skip as many rankings as necessary to maintain a sequence. 5. Constraints: - The list will contain at least 2 and at most 1000 elements. - Each time will be less than or equal to 10,000 and greater than 0. # Function Signature ```python from typing import List def rank_horses(horse_times: List[float]) -> List[int]: ``` # Examples ```python # Example 1 print(rank_horses([120.5, 121.0, 119.8, 122.5])) # Output: [2, 3, 1, 4] # Example 2: Horses with the same times print(rank_horses([118.5, 117.0, 117.0, 120.0])) # Output: [2, 1, 1, 3] # Example 3: Non-positive time should raise an exception try: print(rank_horses([120.5, -121.0, 119.8, 122.5])) except ValueError as e: print(e) # Output: All times must be positive numbers. ``` Implement the function and ensure it handles the constraints, edge cases, and performs the required calculations accurately.","solution":"from typing import List def rank_horses(horse_times: List[float]) -> List[int]: Ranks horses based on their race completion times. The fastest horse gets rank 1, the second fastest gets rank 2, and so on. Horses with the same time share the same rank. Args: - horse_times: List[float] representing the time (in seconds) each horse took to complete the race. Returns: - List[int] representing the ranks of each horse. Raises: - ValueError: If any time value is non-positive. if any(time <= 0 for time in horse_times): raise ValueError(\\"All times must be positive numbers.\\") sorted_times = sorted(set(horse_times)) # Get unique sorted times for ranking rank_dict = {time: rank + 1 for rank, time in enumerate(sorted_times)} return [rank_dict[time] for time in horse_times]"},{"question":"```markdown # Coding Question: Moving Sum Query You are required to implement a class `MovingSum` that maintains a running sum of the last `n` elements from a stream of integers. The class should support adding new elements from the stream and querying the current sum. 1. **Method 1: `__init__(self: MovingSum, n: int) -> None`** * **Input**: An integer `n` representing the number of elements to include in the moving sum. * **Output**: Initializes a new instance of class `MovingSum`. 2. **Method 2: `add(self: MovingSum, num: int) -> None`** * **Input**: An integer `num` to be added to the stream. * **Output**: Adds the number to the stream and maintains the moving sum. 3. **Method 3: `get_sum(self: MovingSum) -> int`** * **Input**: None * **Output**: Returns the current moving sum of the last `n` elements. * **Constraints**: If there are fewer than `n` elements in the stream, the sum of existing elements should be returned. # Example ```python # Test case 1 ms = MovingSum(3) ms.add(1) assert ms.get_sum() == 1 ms.add(2) assert ms.get_sum() == 3 ms.add(3) assert ms.get_sum() == 6 ms.add(4) assert ms.get_sum() == 9 ms.add(5) assert ms.get_sum() == 12 # Test case 2 ms = MovingSum(1) ms.add(1) assert ms.get_sum() == 1 ms.add(10) assert ms.get_sum() == 10 ms.add(100) assert ms.get_sum() == 100 # Test case 3 ms = MovingSum(5) ms.add(1) assert ms.get_sum() == 1 ms.add(-2) assert ms.get_sum() == -1 ms.add(3) assert ms.get_sum() == 2 ms.add(-4) assert ms.get_sum() == -2 ms.add(5) assert ms.get_sum() == 3 ms.add(-6) assert ms.get_sum() == -4 ``` # Your implementation should correctly handle edge cases: * Adding zero or negative numbers. * Initializing with `n` equal to 1. * Querying moving sum before adding `n` elements. ```","solution":"from collections import deque class MovingSum: def __init__(self, n: int): Initializes the MovingSum with a specified window size n. self.n = n self.window = deque() self.current_sum = 0 def add(self, num: int) -> None: Adds a new number to the stream and updates the moving sum. self.window.append(num) self.current_sum += num # Remove the oldest element if window exceeds size n if len(self.window) > self.n: self.current_sum -= self.window.popleft() def get_sum(self) -> int: Returns the current moving sum of the last n elements. return self.current_sum"},{"question":"Problem Description You are tasked with implementing a function that can serialize and deserialize a nested dictionary structure representing a file system. The file system is a simplified hierarchical directory structure that includes directories and files. Directories contain files and other directories, while files are represented by their names and sizes. Task 1. **Serialize the File System**: * Write a function `serialize_file_system` that converts a given file system dictionary into a flat string representation. * Each directory is represented by its name followed by a colon and the contents within parentheses. * Each file is represented by its name followed by the size in bytes within parentheses. * Nested directories and files should be properly nested within the flat string representation. * Example: Folder structure ``` { \\"root\\": { \\"subdir\\": { \\"file2.txt\\": 50 }, \\"file1.txt\\": 100 } } ``` should be serialized to `\\"root(subdir(file2.txt(50))file1.txt(100))\\"` 2. **Deserialize the File System**: * Write a function `deserialize_file_system` that takes a flat string representation of a file system and converts it back into a dictionary. * Ensure the resulting data structure matches the original hierarchical directory structure. # Input and Output Formats Function 1: `serialize_file_system` * **Input**: * A `file_system` (dictionary) representing the file system. * Example: ```python file_system = { \\"root\\": { \\"subdir1\\": { \\"file2.txt\\": 50 }, \\"file1.txt\\": 100 } } ``` * **Output**: * A single string representing the serialized file system. * `\\"root(subdir1(file2.txt(50))file1.txt(100))\\"` * **Example**: ```python serialize_file_system(file_system) == \\"root(subdir1(file2.txt(50))file1.txt(100))\\" ``` Function 2: `deserialize_file_system` * **Input**: * A `serialized_string` (string) representing the serialized file system. * Example: `\\"root(subdir1(file2.txt(50))file1.txt(100))\\"` * **Output**: * A dictionary structure representing the file system. * Example: ```python { \\"root\\": { \\"subdir1\\": { \\"file2.txt\\": 50 }, \\"file1.txt\\": 100 } } ``` * **Example**: ```python deserialize_file_system(\\"root(subdir1(file2.txt(50))file1.txt(100))\\") == { \\"root\\": { \\"subdir1\\": { \\"file2.txt\\": 50 }, \\"file1.txt\\": 100 } } ``` Implementation Details 1. Implement `serialize_file_system` to convert a nested dictionary into the flat string representation. 2. Implement `deserialize_file_system` to parse the flat string back into the nested dictionary format. 3. Make sure the functions handle nested structures correctly and consistently.","solution":"def serialize_file_system(file_system): Converts a given file system dictionary into a flat string representation. def serialize_helper(d): result = \\"\\" for key, value in d.items(): if isinstance(value, dict): result += f\\"{key}({serialize_helper(value)})\\" else: result += f\\"{key}({value})\\" return result return serialize_helper(file_system) def deserialize_file_system(serialized_string): Converts a flat string representation of a file system back into a dictionary. index = 0 def deserialize_helper(): nonlocal index result = {} while index < len(serialized_string): if serialized_string[index] == \')\': index += 1 break key_start = index while index < len(serialized_string) and serialized_string[index] not in \'()\': index += 1 key = serialized_string[key_start:index] if index < len(serialized_string) and serialized_string[index] == \'(\': index += 1 if serialized_string[index].isdigit(): # It\'s a file size size_start = index while index < len(serialized_string) and serialized_string[index].isdigit(): index += 1 size = int(serialized_string[size_start:index]) assert serialized_string[index] == \')\' index += 1 result[key] = size else: # It\'s a subdirectory result[key] = deserialize_helper() return result return deserialize_helper()"},{"question":"# Optimizing Delivery Routes in a City You\'re tasked with developing an algorithm to optimize delivery routes across a city that is represented as a grid. The grid consists of cells, each potentially containing an obstacle. A delivery driver can only move horizontally or vertically from a cell. Your goal is to determine the shortest delivery route from the top-left corner of the grid (starting point) to the bottom-right corner (destination). If a route is not possible, indicate so. **Objective**: Implement a function `shortest_path(grid: List[List[int]]) -> int` to calculate the minimum number of steps required to reach the destination. **Requirements**: 1. **Function**: - **Input**: * `grid`: A list of lists where each inner list represents a row of the grid with integers (0 for empty cell, 1 for obstacle). - **Output**: * An integer representing the minimum number of steps from the top-left to the bottom-right. Return -1 if no feasible route exists. **Constraints**: * The dimensions of `grid` are `m x n` where `1 <= m, n <= 100`. * A cell in the grid can either be empty (0) or blocked by an obstacle (1). * Top-left corner (grid[0][0]) and bottom-right corner (grid[m-1][n-1]) will always be empty (0). **Example**: ```python # Example 1 grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path(grid) == 8 # Expected: 8 # Example 2 grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert shortest_path(grid) == -1 # Expected: -1 (no path) ``` **Solution Template**: ```python from collections import deque def shortest_path(grid: List[List[int]]) -> int: if not grid: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) steps = 0 visited = set() visited.add((0, 0)) while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1 ```","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) steps = 0 visited = set() visited.add((0, 0)) while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1"},{"question":"# Coding Assessment Question Context Binary trees are fundamental data structures used in various algorithms involving search, sorting, and hierarchical data management. Understanding tree traversal techniques is crucial for solving many complex computational problems. Problem Write a Python function `zigzag_traversal(root)` that performs a zigzag (or spiral) level order traversal of a binary tree. In this traversal, the nodes on each level are visited from left to right, then right to left the next level, and so on. Expected Input and Output * **Input**: - `root` (TreeNode): The root node of a binary tree. * **Output**: - Returns a list of lists, with each inner list containing the values of nodes at each level (List[List[int]]). Constraints * The binary tree can be empty (i.e., `root` can be `None`). * Nodes in the binary tree contain integer values. * The tree can have up to 10000 nodes. Example ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzag_traversal(root: TreeNode) -> list[list[int]]: Returns the zigzag level order traversal of a binary tree. :param root: TreeNode: Root node of the binary tree. :return: List[List[int]]: Zigzag level order traversal of the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzag_traversal(root) [[1], [3, 2], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> zigzag_traversal(root) [[1]] >>> zigzag_traversal(None) [] # TODO: Implement this function pass # Example usage root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(zigzag_traversal(root)) # Output: [[1], [3, 2], [4, 5, 6, 7]] ``` Your solution should demonstrate: * Proper understanding and implementation of tree traversal techniques. * Efficient handling of tree structures. * Correctness of the zigzag traversal pattern.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def zigzag_traversal(root: TreeNode) -> list[list[int]]: Returns the zigzag level order traversal of a binary tree. :param root: TreeNode: Root node of the binary tree. :return: List[List[int]]: Zigzag level order traversal of the tree. if not root: return [] result, temp, stack, direction = [], [], [root], 1 while stack: for i in range(len(stack)): node = stack.pop(0) temp.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) result.append(temp[::direction]) temp = [] direction *= -1 return result"},{"question":"# **Matrix Chain Multiplication: Dynamic Programming Analysis** **Scenario**: You are given a sequence of matrices, and you need to determine the most efficient way to multiply these matrices together. The goal is to find the parenthesization of the product that minimizes the number of scalar multiplications. **Function Specifications**: Function 1: `matrix_chain_order_recursive(p: list) -> int` 1. **Input**: * `p` (list): A list of dimensions where the `i-th` matrix has dimensions `p[i-1] x p[i]`. 2. **Output**: * Returns the minimum number of scalar multiplications needed to multiply the chain of matrices. Function 2: `matrix_chain_order_top_down(p: list) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. Function 3: `matrix_chain_order_bottom_up(p: list) -> int` 1. **Input**: * Same as Function 1. 2. **Output**: * Same as Function 1. **Tasks**: 1. Implement the three functions as specified. Verify the correctness of each through test cases. 2. Analyze the time and space complexity of each function. 3. Compare the performance of the recursive and dynamic programming approaches. **Constraints**: * Ensure the length of list `p` is greater than or equal to 2. * The elements of the list `p` should be non-negative integers. **Performance Requirements**: * Verify that the dynamic programming solutions perform significantly better than the recursive approach as the length of `p` increases. ```python # You may utilize the test cases provided in the following main function. def main(): dimensions = [30, 35, 15, 5, 10, 20, 25] # Test the functions with varying dimensions assert matrix_chain_order_recursive([10, 20, 30, 40, 30]) == 30000 assert matrix_chain_order_top_down([10, 20, 30, 40, 30]) == 30000 assert matrix_chain_order_bottom_up([10, 20, 30, 40, 30]) == 30000 assert matrix_chain_order_recursive(dimensions) == 15125 assert matrix_chain_order_top_down(dimensions) == 15125 assert matrix_chain_order_bottom_up(dimensions) == 15125 print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main() ```","solution":"def matrix_chain_order_recursive(p): Returns the minimum number of scalar multiplications needed to multiply the chain of matrices. def recursive_chain(i, j): if i == j: return 0 min_count = float(\'inf\') for k in range(i, j): count = (recursive_chain(i, k) + recursive_chain(k + 1, j) + p[i - 1] * p[k] * p[j]) if count < min_count: min_count = count return min_count n = len(p) return recursive_chain(1, n - 1) def matrix_chain_order_top_down(p): Returns the minimum number of scalar multiplications needed to multiply the chain of matrices using top-down memoization. def memoized_chain(i, j, memo): if i == j: return 0 if memo[i][j] != float(\'inf\'): return memo[i][j] for k in range(i, j): count = (memoized_chain(i, k, memo) + memoized_chain(k + 1, j, memo) + p[i - 1] * p[k] * p[j]) if count < memo[i][j]: memo[i][j] = count return memo[i][j] n = len(p) memo = [[float(\'inf\')] * n for _ in range(n)] return memoized_chain(1, n - 1, memo) def matrix_chain_order_bottom_up(p): Returns the minimum number of scalar multiplications needed to multiply the chain of matrices using bottom-up dynamic programming. n = len(p) m = [[0] * n for _ in range(n)] for length in range(2, n): for i in range(1, n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q return m[1][n-1]"},{"question":"# Scenario You are developing a software application for an e-commerce platform that needs to handle a variety of operations involving products and orders. One key functionality is to keep track of the stock levels of each product and ensure accurate inventory management. # Problem Statement Implement a class `Inventory` that manages the stock levels of products. Your `Inventory` class should provide methods to add new products, update stock quantities, and handle orders that deduct stock quantities appropriately. If an order cannot be fulfilled due to insufficient stock, an appropriate error should be raised. # Specifications * **Class Definition**: Implement a class `Inventory` with the following methods: * `add_product(product_id: int, quantity: int) -> None`: Adds a new product with a given quantity to the inventory. If the product already exists, increase its stock by the specified quantity. * `update_stock(product_id: int, quantity: int) -> None`: Updates the stock level of an existing product to the specified quantity. * `place_order(product_id: int, quantity: int) -> None`: Processes an order by reducing the stock of the given product by the specified quantity. If the product does not exist or if the stock is insufficient, raise a `ValueError` with an appropriate message. * **Constraints**: * `product_id` will be a positive integer. * `quantity` will be a non-negative integer. * The system should be able to handle a maximum of 10,000 products. * All methods should have an average time complexity of O(1). # Example ```python inventory = Inventory() # Adding products inventory.add_product(101, 50) inventory.add_product(102, 20) # Updating stock inventory.update_stock(101, 80) # Placing orders try: inventory.place_order(101, 30) print(\\"Order placed successfully.\\") except ValueError as e: print(e) # Expected to not raise an error. try: inventory.place_order(103, 10) except ValueError as e: print(e) # Expected to print: \\"Product ID 103 does not exist.\\" try: inventory.place_order(102, 25) except ValueError as e: print(e) # Expected to print: \\"Insufficient stock for product ID 102.\\" ``` # Bonus Extend the `Inventory` class to support transactional operations, where stock updates or orders can be batched in a transaction that can be either committed or rolled back in case of errors.","solution":"class Inventory: def __init__(self): # Dictionary to store product_id as key and its quantity as value self.stock = {} def add_product(self, product_id: int, quantity: int) -> None: if product_id in self.stock: self.stock[product_id] += quantity else: self.stock[product_id] = quantity def update_stock(self, product_id: int, quantity: int) -> None: if product_id in self.stock: self.stock[product_id] = quantity else: raise ValueError(f\\"Product ID {product_id} does not exist.\\") def place_order(self, product_id: int, quantity: int) -> None: if product_id not in self.stock: raise ValueError(f\\"Product ID {product_id} does not exist.\\") if self.stock[product_id] < quantity: raise ValueError(f\\"Insufficient stock for product ID {product_id}.\\") self.stock[product_id] -= quantity"},{"question":"# Coding Assessment Question **Problem Statement**: A \\"look-and-say\\" sequence is a sequence of digits where successive terms are generated by describing the previous one in terms of consecutive runs of the same digit. The first few terms of the look-and-say sequence are the following: 1. `1` 2. `11` (one 1) 3. `21` (two 1\'s) 4. `1211` (one 2, then one 1) 5. `111221` (one 1, one 2, then two 1\'s) 6. `312211` (three 1\'s, two 2\'s, one 1) Write a function that returns the `n`-th term of the look-and-say sequence as a string. **Function Signature**: ```python def look_and_say(n: int) -> str: pass ``` **Input**: - `n` (int): The position in the look-and-say sequence (1-based index). **Output**: - (str): The `n`-th term in the look-and-say sequence. **Constraints**: - 1 <= n <= 30 **Examples**: ```python >>> look_and_say(1) \\"1\\" >>> look_and_say(4) \\"1211\\" >>> look_and_say(6) \\"312211\\" ``` **Guidelines**: * To generate the sequence, iteratively build each term from the previous one. * Implement the logic to describe a term in terms of runs of consecutive digits. * Ensure your implementation is efficient within the given constraints and handles edge cases correctly. * Thoroughly test your function with various values of `n` to ensure correctness.","solution":"def look_and_say(n: int) -> str: if n == 1: return \\"1\\" def next_term(term: str) -> str: result = [] i = 0 while i < len(term): count = 1 while i + 1 < len(term) and term[i] == term[i + 1]: i += 1 count += 1 result.append(f\\"{count}{term[i]}\\") i += 1 return \'\'.join(result) current_term = \\"1\\" for _ in range(2, n + 1): current_term = next_term(current_term) return current_term"},{"question":"# Problem Statement You are working with a system that needs to keep track of the highest frequency of characters in a string efficiently. To achieve this, you need to implement a function that finds the character with the highest frequency in a given string and returns it. In case of a tie, return the lexicographically smallest character among those with the highest frequency. # Enhanced Requirements 1. Implement an efficient algorithm to determine the highest frequency character. 2. Handle edge cases such as an empty string or a string with all unique characters. 3. Optimize for time and space complexity considering large inputs. # Function Signature ```python def highest_frequency_char(s: str) -> str: pass ``` # Expected Input and Output * **Input**: * A string `s` consisting of lowercase English letters only (`1 <= len(s) <= 10^5`). * **Output**: * A single character representing the one with the highest frequency. If multiple characters have the same highest frequency, return the lexicographically smallest one. * **Constraints**: * You must handle cases with large input sizes efficiently. * Should properly handle ties by selecting the lexicographically smallest character. # Performance Requirements * The solution must have a time complexity of O(n) where n is the length of the string, and a space complexity of O(1) considering the fixed size of the character set. # Example Usage ```python assert highest_frequency_char(\\"aabbbccdd\\") == \'b\' assert highest_frequency_char(\\"aabbcc\\") == \'a\' assert highest_frequency_char(\\"abcd\\") == \'a\' assert highest_frequency_char(\\"\\") == \'\' ``` # Hints 1. Use a dictionary or array to count the frequency of each character in the string. 2. Iterate through the frequency counts to find the maximum frequency and track the lexicographically smallest character with that frequency. 3. Consider edge cases such as an empty string or strings with unique characters.","solution":"def highest_frequency_char(s: str) -> str: if not s: return \'\' frequency = [0] * 26 # for a-z for char in s: frequency[ord(char) - ord(\'a\')] += 1 max_freq = 0 result_char = None for i in range(26): if frequency[i] > max_freq or (frequency[i] == max_freq and result_char is not None and chr(i + ord(\'a\')) < result_char): max_freq = frequency[i] result_char = chr(i + ord(\'a\')) return result_char"},{"question":"# Unique Email Generation Background In a large software development team, ensuring that email addresses are unique and consistent is crucial for maintaining proper communication channels. You are tasked with developing a feature that ensures each newly generated email address is unique. Task Implement a function to generate unique email addresses by appending a number to the base email address (before the \'@\' symbol) if that email address already exists in a provided list of existing emails. Requirements 1. Define a function `generate_unique_email` that takes: * A base email address in the format \\"username@domain.com\\". * A list of existing email addresses. 2. The function should return a unique email address by appending a number at the end before the \'@\' symbol if necessary. The numbering should start from 1 and increment by 1 until a unique address is found. 3. Ensure the provided base email address format is valid and handle any invalid inputs appropriately. Function Signature ```python def generate_unique_email(base_email: str, existing_emails: list) -> str: ``` Parameters * `base_email` (str): The base email address in the format \\"username@domain.com\\". * `existing_emails` (list): A list of currently existing email addresses (each in the format \\"username@domain.com\\"). Constraints * The base email and all existing emails are assumed to be in lower-case format. * The function should return a valid email address, handling cases where the base email or the domain part is malformed. * Ensure that the base email follows the standard email format (i.e., \\"username@domain.com\\"). Example Usage ```python existing_emails = [ \\"john.doe@example.com\\", \\"jane.doe@example.com\\", \\"john.doe1@example.com\\", \\"john.doe2@example.com\\" ] # Attempt to generate a unique email for \\"john.doe@example.com\\" given the existing emails new_email = generate_unique_email(\\"john.doe@example.com\\", existing_emails) print(new_email) # Output: \\"john.doe3@example.com\\" # Generate a unique email for \\"alex.smith@example.com\\" which does not yet exist new_email = generate_unique_email(\\"alex.smith@example.com\\", existing_emails) print(new_email) # Output: \\"alex.smith@example.com\\" ``` This new question tests string manipulation, list handling, and validation of input formats. It complements the given weight unit conversion question by continuing the theme of creating functions with specific utility, while varying in the specific skill set required to solve it.","solution":"import re def generate_unique_email(base_email: str, existing_emails: list) -> str: Generates a unique email address by appending a number to the base email address if necessary. Parameters: base_email (str): The base email address in the format \\"username@domain.com\\". existing_emails (list): A list of currently existing email addresses. Returns: str: A unique email address. # Validate email format email_pattern = r\\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\\" if not re.match(email_pattern, base_email): raise ValueError(\\"Invalid email format\\") if base_email not in existing_emails: return base_email username, domain = base_email.split(\'@\') i = 1 while True: new_email = f\\"{username}{i}@{domain}\\" if new_email not in existing_emails: return new_email i += 1"},{"question":"# Question You have been tasked with implementing several data serialization and deserialization functions from scratch. These functions include JSON, XML, and binary serialization. Below is the detailed description of the functions you need to implement. 1. **JSON Serialization**: Write a function `json_serialize(obj: Any) -> str` that serializes a Python data structure to a JSON formatted string. 2. **JSON Deserialization**: Write a function `json_deserialize(json_str: str) -> Any` that deserializes a JSON formatted string back to a Python data structure. 3. **XML Serialization**: Write a function `xml_serialize(obj: Any) -> str` that serializes a Python data structure to an XML formatted string. 4. **XML Deserialization**: Write a function `xml_deserialize(xml_str: str) -> Any` that deserializes an XML formatted string back to a Python data structure. 5. **Binary Serialization**: Write a function `binary_serialize(obj: Any) -> bytes` that serializes a Python data structure to a binary format using the `pickle` module. 6. **Binary Deserialization**: Write a function `binary_deserialize(binary_data: bytes) -> Any` that deserializes binary data back to a Python data structure using the `pickle` module. Ensure your functions handle edge cases and optimize for performance where possible. Below are the constraints and expected inputs/outputs for each function: 1. **JSON Serialization**: - **Input**: `obj` (any Python data structure such as dict, list, etc.). - **Output**: JSON formatted string. 2. **JSON Deserialization**: - **Input**: `json_str` (a JSON formatted string). - **Output**: Corresponding Python data structure. 3. **XML Serialization**: - **Input**: `obj` (any Python data structure such as dict, list, etc.). - **Output**: XML formatted string. 4. **XML Deserialization**: - **Input**: `xml_str` (an XML formatted string). - **Output**: Corresponding Python data structure. 5. **Binary Serialization**: - **Input**: `obj` (any Python data structure such as dict, list, etc.). - **Output**: Serialized binary data. 6. **Binary Deserialization**: - **Input**: `binary_data` (binary data produced by the `pickle` module). - **Output**: Corresponding Python data structure. Provide complete implementations of these functions with proper error handling, taking care of edge cases, performance optimizations, and ensuring correct results for different input scenarios.","solution":"import json import pickle import xml.etree.ElementTree as ET def json_serialize(obj): Serializes a Python data structure to a JSON formatted string. try: return json.dumps(obj) except (TypeError, ValueError) as e: raise ValueError(f\\"Unable to serialize object to JSON: {str(e)}\\") def json_deserialize(json_str): Deserializes a JSON formatted string to a Python data structure. try: return json.loads(json_str) except json.JSONDecodeError as e: raise ValueError(f\\"Unable to deserialize JSON string: {str(e)}\\") def dict_to_xml(tag, d): Helper function to convert a dictionary to an XML string. elem = ET.Element(tag) for key, val in d.items(): child = ET.Element(key) child.text = str(val) elem.append(child) return elem def xml_serialize(obj): Serializes a Python data structure to an XML formatted string. if not isinstance(obj, dict): raise ValueError(\\"XML serialization only supports Python dicts\\") root_name = \\"root\\" root = dict_to_xml(root_name, obj) return ET.tostring(root, encoding=\'unicode\') def xml_deserialize(xml_str): Deserializes an XML formatted string to a Python data structure. try: root = ET.fromstring(xml_str) return {child.tag: child.text for child in root} except ET.ParseError as e: raise ValueError(f\\"Unable to deserialize XML string: {str(e)}\\") def binary_serialize(obj): Serializes a Python data structure to a binary format using the pickle module. return pickle.dumps(obj) def binary_deserialize(binary_data): Deserializes binary data to a Python data structure using the pickle module. return pickle.loads(binary_data)"},{"question":"# Problem Statement A palindrome is a string that reads the same backward as forward, ignoring spaces, punctuation, and capitalization. The problem requires checking if two given strings can be rearranged to form palindrome pairs, i.e., both strings need to form palindromes when rearranged. Task Write a function `can_form_palindrome_pair(str1: str, str2: str) -> bool` that determines if it\'s possible to rearrange the characters of `str1` and `str2` such that both become palindromes. Input * `str1` (str): The first input string, containing only lowercase alphabets and spaces (0 ≤ len(str1) ≤ 100). * `str2` (str): The second input string, containing only lowercase alphabets and spaces (0 ≤ len(str2) ≤ 100). Output * Returns a boolean value `True` if both strings can be rearranged to form palindromes, and `False` otherwise. Constraints * Ignore spaces when checking for palindromes. * Consider edge cases such as empty strings or strings with only spaces. # Example ```python assert can_form_palindrome_pair(\\"civic\\", \\"racecar\\") == True assert can_form_palindrome_pair(\\"aabb\\", \\"xxyy\\") == True assert can_form_palindrome_pair(\\"abcd\\", \\"efgh\\") == False assert can_form_palindrome_pair(\\" \\", \\" \\") == True assert can_form_palindrome_pair(\\"\\", \\"\\") == True assert can_form_palindrome_pair(\\"abc\\", \\"cba\\") == False ``` Additional Notes For a string to be rearranged into a palindrome: * If the string length is odd, only one character can appear an odd number of times; the rest must appear an even number of times. * If the string length is even, all characters must appear an even number of times. Consider using helper functions or efficient data structures to check the character counts and determine the possibility of rearrangement.","solution":"def can_form_palindrome_pair(str1: str, str2: str) -> bool: from collections import Counter def can_form_palindrome(s: str) -> bool: s = s.replace(\\" \\", \\"\\") count = Counter(s) odd_count = sum(v % 2 for v in count.values()) return odd_count <= 1 return can_form_palindrome(str1) and can_form_palindrome(str2)"},{"question":"# Problem Statement You are tasked with processing a list of tuples representing the start and end times of various meetings in a single day. Your goal is to determine if a person can attend all the meetings without any overlaps. Write a function `can_attend_all_meetings(meetings: List[Tuple[int, int]]) -> bool` which returns `True` if the person can attend all meetings without any overlapping times and `False` otherwise. # Input - `meetings` (List[Tuple[int, int]]): A list of tuples, where each tuple consists of two integers representing the start time and the end time of a meeting. Each start time and end time is within the range (0 leq start, end leq 24 * 60) (i.e., the number of minutes in a day). # Output - (bool): `True` if there are no overlapping meetings and the person can attend all. Otherwise, `False`. # Constraints - Meetings are represented in military minutes (0 to 1440 representing 12:00 AM to next 12:00 AM). - Meeting end times are always greater than start times. - The length of the meetings list will not exceed 10^5. # Example ```python assert can_attend_all_meetings([(30, 150), (180, 240), (151, 179)]) == True assert can_attend_all_meetings([(30, 150), (90, 240), (151, 179)]) == False ``` # Performance Expectations - The solution should handle large lists of meetings efficiently, considering possible optimizations in sorting and comparative checks. # Implementation Guidelines - Sort the list of meetings by their start times. - Iterate through the sorted list and check for any overlapping intervals. - If any two consecutive meetings overlap, return `False`. - If no overlaps are detected, return `True`.","solution":"from typing import List, Tuple def can_attend_all_meetings(meetings: List[Tuple[int, int]]) -> bool: Determines if a person can attend all meetings without any overlapping times. Parameters: - meetings: List of tuples where each tuple contains the start and end times of a meeting. Returns: - True if the person can attend all meetings without overlaps, False otherwise. # Sort meetings based on start times meetings.sort() # Iterate through the sorted list and check for overlaps for i in range(1, len(meetings)): if meetings[i-1][1] > meetings[i][0]: # End time of previous meeting is greater than start time of current return False return True"},{"question":"Book Inventory Management System You are required to create a function that manages the inventory of a bookstore. This function should maintain a list of books in the inventory, including their titles, authors, and quantities. The function should be able to add new books to the inventory, remove books, update the quantity of a book, and retrieve the current list of books. Objective Write a class `BookInventory` that implements the following methods: - `__init__(self)`: Initializes an empty inventory. - `add_book(self, title: str, author: str, quantity: int) -> None`: Adds a new book to the inventory or updates the quantity of an existing book. - `remove_book(self, title: str) -> bool`: Removes a book from the inventory and returns `True` if successful, or `False` if the book was not found. - `update_quantity(self, title: str, quantity: int) -> bool`: Updates the quantity of a specific book and returns `True` if successful, or `False` if the book was not found. - `get_inventory(self) -> list`: Returns a list of dictionaries, each representing a book with its title, author, and quantity. Methods Specifications: * `add_book`: If the book already exists in the inventory, only the quantity should be updated. * `remove_book`: If the book is not found, return `False`. * `update_quantity`: If the book is not found, return `False`. * `get_inventory`: Each dictionary in the returned list should have the keys \\"title\\", \\"author\\", and \\"quantity\\". Example: ```python class BookInventory: def __init__(self): # Initialize the inventory as an empty dictionary self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: # If the book already exists, update the quantity if title in self.inventory: self.inventory[title][\'quantity\'] += quantity else: # Add the new book to the inventory self.inventory[title] = {\'author\': author, \'quantity\': quantity} def remove_book(self, title: str) -> bool: # Remove the book if it exists if title in self.inventory: del self.inventory[title] return True return False def update_quantity(self, title: str, quantity: int) -> bool: # Update the quantity if the book exists if title in self.inventory: self.inventory[title][\'quantity\'] = quantity return True return False def get_inventory(self) -> list: # Return the inventory as a list of dictionaries return [{\'title\': title, \'author\': book[\'author\'], \'quantity\': book[\'quantity\']} for title, book in self.inventory.items()] # Example usage inventory = BookInventory() inventory.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 5) inventory.add_book(\\"1984\\", \\"George Orwell\\", 3) inventory.update_quantity(\\"1984\\", 4) inventory.remove_book(\\"To Kill a Mockingbird\\") books = inventory.get_inventory() for book in books: print(f\\"Title: {book[\'title\']}, Author: {book[\'author\']}, Quantity: {book[\'quantity\']}\\") ``` This should produce output similar to: ``` Title: 1984, Author: George Orwell, Quantity: 4 ``` # Additional Notes: - Ensure all methods handle edge cases, such as trying to remove or update a non-existent book, gracefully. - Maintain a clean and understandable code structure. - You may assume the book titles are unique in the inventory.","solution":"class BookInventory: def __init__(self): # Initialize the inventory as an empty dictionary self.inventory = {} def add_book(self, title: str, author: str, quantity: int) -> None: # If the book already exists, update the quantity if title in self.inventory: self.inventory[title][\'quantity\'] += quantity else: # Add the new book to the inventory self.inventory[title] = {\'author\': author, \'quantity\': quantity} def remove_book(self, title: str) -> bool: # Remove the book if it exists if title in self.inventory: del self.inventory[title] return True return False def update_quantity(self, title: str, quantity: int) -> bool: # Update the quantity if the book exists if title in self.inventory: self.inventory[title][\'quantity\'] = quantity return True return False def get_inventory(self) -> list: # Return the inventory as a list of dictionaries return [{\'title\': title, \'author\': book[\'author\'], \'quantity\': book[\'quantity\']} for title, book in self.inventory.items()]"},{"question":"# Problem Statement You are given two strings, `needle` and `haystack`. Your task is to implement a function that finds the first occurrence of the `needle` in the `haystack` and returns its starting index. If the `needle` is not found in the `haystack`, the function should return `-1`. # Function Signature ```python def str_str(haystack: str, needle: str) -> int: pass ``` # Input The function `str_str` accepts two arguments: * `haystack`: a string to be searched. * `needle`: a string to search for in the `haystack`. # Output The function should return: * An integer representing the starting index of the first occurrence of `needle` in `haystack`. * If `needle` is not found in `haystack`, return `-1`. # Constraints * The length of `haystack` and `needle` will be between 0 and 10^4. * Both `haystack` and `needle` consist of only lowercase English characters. # Example ```python haystack = \\"hello\\" needle = \\"ll\\" index = str_str(haystack, needle) print(index) ``` Expected output: ```python 2 ``` ```python haystack = \\"aaaaa\\" needle = \\"bba\\" index = str_str(haystack, needle) print(index) ``` Expected output: ```python -1 ``` # Notes * Consider edge cases such as the `needle` being an empty string or the `haystack` being an empty string. * Make sure to handle cases where the `needle` is longer than the `haystack`. * Implement efficient string search algorithms to ensure the performance is optimal. # Performance Requirements The solution should handle typical string search operations efficiently, aiming for a time complexity of O(n + m), where `n` is the length of `haystack` and `m` is the length of `needle`.","solution":"def str_str(haystack: str, needle: str) -> int: Returns the starting index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. # handle edge cases if not needle: return 0 if not haystack or len(needle) > len(haystack): return -1 # use the in-built find method for optimal performance index = haystack.find(needle) return index"},{"question":"**Context**: You are creating a scheduling application that requires finding gaps in a daily timetable. Given a list of existing time slots (each with a start and end time), determine the free periods in the schedule. **Coding Task**: Write a function named `find_free_slots` that takes two parameters: * `daily_start` (a string, the start time of the day in \\"HH:MM\\" format), * `daily_end` (a string, the end time of the day in \\"HH:MM\\" format), * `booked_slots` (a list of tuples, where each tuple contains two strings representing the start and end time of an existing booking in \\"HH:MM\\" format). Your function should return a list of tuples representing the free time slots available between `daily_start` and `daily_end`, ensuring no overlaps with the booked slots. # Input * The function will be called as: `find_free_slots(daily_start: str, daily_end: str, booked_slots: List[Tuple[str, str]]) -> List[Tuple[str, str]]` * `daily_start` (a string): The start time of the day in \\"HH:MM\\" format (00:00 ≤ HH:MM ≤ 23:59) * `daily_end` (a string): The end time of the day in \\"HH:MM\\" format (00:00 ≤ HH:MM ≤ 23:59) * `booked_slots` (a list of tuples): Each tuple contains two strings representing the start and end time of a booking in \\"HH:MM\\" format. The list may be empty. # Output * Return a list of tuples, each representing a free time slot, where the tuple contains two strings (start time and end time in \\"HH:MM\\" format). # Constraints * Booked slots are non-overlapping and within the daily start and end times. * Ensure the solution handles edge cases, such as no bookings or fully booked days. # Example ```python def find_free_slots(daily_start: str, daily_end: str, booked_slots: List[Tuple[str, str]]) -> List[Tuple[str, str]]: # Your implementation here # Example usage print(find_free_slots(\\"09:00\\", \\"17:00\\", [(\\"10:00\\", \\"11:30\\"), (\\"12:15\\", \\"13:00\\"), (\\"14:00\\", \\"15:00\\")])) # Output: [(\\"09:00\\", \\"10:00\\"), (\\"11:30\\", \\"12:15\\"), (\\"13:00\\", \\"14:00\\"), (\\"15:00\\", \\"17:00\\")] print(find_free_slots(\\"09:00\\", \\"17:00\\", [])) # Output: [(\\"09:00\\", \\"17:00\\")] print(find_free_slots(\\"09:00\\", \\"17:00\\", [(\\"09:00\\", \\"17:00\\")])) # Output: [] ``` # Explanation * In the first example, the booked slots divide the day into free slots of \\"09:00 to 10:00\\", \\"11:30 to 12:15\\", \\"13:00 to 14:00\\", and \\"15:00 to 17:00\\". * In the second example, there are no bookings, so the entire day is free. * In the third example, the entire day is booked, leaving no free slots.","solution":"from typing import List, Tuple def find_free_slots(daily_start: str, daily_end: str, booked_slots: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Finds free slots in a daily timetable based on existing bookings. Args: daily_start (str): Start time of the day (\\"HH:MM\\"). daily_end (str): End time of the day (\\"HH:MM\\"). booked_slots (List[Tuple[str, str]]): List of booked slots as tuples of start and end times (\\"HH:MM\\", \\"HH:MM\\"). Returns: List[Tuple[str, str]]: List of free time slots as tuples of start and end times. booked_slots.sort() free_slots = [] if not booked_slots: return [(daily_start, daily_end)] if daily_start < booked_slots[0][0]: free_slots.append((daily_start, booked_slots[0][0])) for i in range(len(booked_slots) - 1): end_current = booked_slots[i][1] start_next = booked_slots[i + 1][0] if end_current < start_next: free_slots.append((end_current, start_next)) if booked_slots[-1][1] < daily_end: free_slots.append((booked_slots[-1][1], daily_end)) return free_slots"},{"question":"# Task Implement an extension to the K-Means Clustering algorithm to include the option for mini-batch K-Means clustering. Mini-batch K-Means clustering is an efficient version of the standard K-Means that uses small, random subsets of the data (mini-batches) to update the centroids. # Problem Statement You need to implement a class `MiniBatchKMeans` that extends `KMeans` to include the mini-batch approach. This technique improves the performance for large datasets by using mini-batches to update the cluster centroids iteratively. # Requirements: 1. Modify the `fit` method to incorporate mini-batches. 2. Implement a `predict` method to assign clusters to new data points. 3. Ensure that the `fit` method works seamlessly with the mini-batch approach. 4. Provide a method to plot the clustered data points and the centroids. # Class Signature ```python class MiniBatchKMeans(KMeans): def __init__(self, n_clusters: int = 8, batch_size: int = 100, max_iter: int = 300) -> None: # Your code here def fit(self, x_train: np.ndarray) -> None: # Your code here def predict(self, x_data: np.ndarray) -> np.ndarray: # Your code here def plot(self, x_data: np.ndarray, labels: np.ndarray) -> None: # Your code here ``` # Input and Output - `MiniBatchKMeans(n_clusters: int = 8, batch_size: int = 100, max_iter: int = 300)`: - **n_clusters**: the number of clusters to form. - **batch_size**: the size of the mini-batches. - **max_iter**: the maximum number of iterations for the mini-batch updates. - Raises ValueError if n_clusters, batch_size, or max_iter are non-positive. - `fit(x_train: np.ndarray)`: - **x_train**: data points for clustering. - Fit the model using mini-batch K-Means clustering technique. - `predict(x_data: np.ndarray)`: - **x_data**: data points for which to predict the clusters. - Returns a one-dimensional numpy array of cluster indices corresponding to each data point. - `plot(x_data: np.ndarray, labels: np.ndarray)`: - **x_data**: data points for plotting. - **labels**: cluster labels for each data point. - Plots the clustered data points and centroids. # Constraints - Number of clusters should be a positive integer. - Batch size should be a positive integer. - Maximum iterations should be a positive integer. - Input data for both x should be a two-dimensional numpy array. # Performance Requirements - The `fit` method should handle large dataset sizes efficiently with the mini-batch approach. - The model should provide a good approximation of the standard K-Means clustering while being faster for large datasets. Given we analyzed K-Means Clustering\'s properties and challenges, implement the classes and methods as described in the inputs and outputs for an effective assessment.","solution":"import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans class MiniBatchKMeans(KMeans): def __init__(self, n_clusters: int = 8, batch_size: int = 100, max_iter: int = 300) -> None: if n_clusters <= 0 or batch_size <= 0 or max_iter <= 0: raise ValueError(\\"n_clusters, batch_size, and max_iter must be positive integers.\\") self.n_clusters = n_clusters self.batch_size = batch_size self.max_iter = max_iter self.centroids = None def fit(self, x_train: np.ndarray) -> None: n_samples, n_features = x_train.shape self.centroids = x_train[np.random.choice(n_samples, self.n_clusters, replace=False)] for _ in range(self.max_iter): mini_batch_indices = np.random.choice(n_samples, self.batch_size, replace=False) mini_batch = x_train[mini_batch_indices] distances = np.linalg.norm(mini_batch[:, None] - self.centroids, axis=2) closest = np.argmin(distances, axis=1) for i in range(self.n_clusters): cluster_points = mini_batch[closest == i] if len(cluster_points) > 0: self.centroids[i] = cluster_points.mean(axis=0) def predict(self, x_data: np.ndarray) -> np.ndarray: distances = np.linalg.norm(x_data[:, None] - self.centroids, axis=2) return np.argmin(distances, axis=1) def plot(self, x_data: np.ndarray, labels: np.ndarray) -> None: plt.scatter(x_data[:, 0], x_data[:, 1], c=labels, s=50, cmap=\'viridis\') plt.scatter(self.centroids[:, 0], self.centroids[:, 1], c=\'red\', s=200, alpha=0.75) plt.show()"},{"question":"# Summation of Primes As part of a team working on a number theory project, you are asked to implement a solution that calculates the summation of prime numbers up to a given integer `n`. This task will aid in data analysis for prime number distribution. # Task You need to implement a function `sum_primes(n: int) -> int` that calculates and returns the sum of all prime numbers less than or equal to `n`. # Input and Output Formats * **Input**: - `n`: an integer representing the upper limit for the summation of prime numbers. * **Output**: - The function should return an integer, which is the sum of all prime numbers up to and including `n`. # Example: ```python sum_primes(10) # Returns 17, since the prime numbers up to 10 are 2, 3, 5, and 7. sum_primes(20) # Returns 77, since the prime numbers up to 20 are 2, 3, 5, 7, 11, 13, 17, and 19. ``` # Constraints: * `n` will be a non-negative integer. * `n` will be less than or equal to 10^6. # Performance: * The implementation should be efficient and capable of processing the upper limit effectively. * Consider utilizing advanced algorithms for prime number generation, such as the Sieve of Eratosthenes. # Hints: 1. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. 2. The Sieve of Eratosthenes is a highly efficient way to find all primes smaller than a given limit. 3. Optimize your implementation to handle large values of `n` within a reasonable time frame.","solution":"def sum_primes(n): Returns the sum of all prime numbers less than or equal to n. Args: n (int): The upper limit for the summation of prime numbers. Returns: int: Sum of all prime numbers up to and including n. if n < 2: return 0 sieve = [True] * (n+1) sieve[0] = sieve[1] = False # 0 and 1 are not primes p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, n+1, p): sieve[i] = False p += 1 prime_sum = 0 for p in range(n+1): if sieve[p]: prime_sum += p return prime_sum"},{"question":"# Task In this task, you need to implement the `simulate_vending_machine` function to simulate the behavior of a vending machine. The vending machine sells items of different types, accepts coins, and maintains an internal count of the coins and items sold. You will also write a `test_vending_machine` function to verify the proper working of the vending machine simulation. # Requirements: * Implement `simulate_vending_machine` to: - Track the inventory of items. - Accept coin payments and calculate whether the inserted coins are sufficient for the desired item. - Dispense the item if sufficient payment is made and adjust the inventory and coin count accordingly. - Return the inserted coins if the item is out of stock or if the inserted coins are insufficient. - Print the vending machine\'s state after each transaction (inventory and coin count). * Implement `test_vending_machine` to: - Simulate a sequence of transactions and verify that the responses and machine states are as expected. - Print the expected and actual responses for each transaction. # Input Format: - `initial_inventory`: A dictionary where keys are item names (strings) and values are tuples representing the stock quantity and price. - `initial_coins`: A dictionary where keys are coin denominations (integers) and values are the count of those coins. - `transactions`: A list of tuples, where each tuple represents a transaction and contains the name of the item (string) and a list of inserted coins (integers). # Output Format: - For each transaction, print the state of the vending machine (inventory and coin count). - In `test_vending_machine`, for each transaction, print the expected response and actual response. # Constraints: - Assume all coin denominations are positive integers. - There will always be sufficient items in the initial inventory for the given transactions to execute at least one transaction successfully. # Example Usage: Given: ```python initial_inventory = { \\"soda\\": (5, 120), \\"chips\\": (3, 50), \\"chocolate\\": (2, 100) } initial_coins = { 1: 10, 5: 10, 10: 10, 20: 5, 50: 2 } transactions = [ (\\"soda\\", [100, 10, 10, 5]), (\\"chips\\", [50]), (\\"chocolate\\", [100, 20]) ] ``` After running `simulate_vending_machine` function, the output might be: ```python Transaction: soda, Inserted coins: [100, 10, 10, 5] Dispensed soda. Remaining inventory: {\'soda\': (4, 120), \'chips\': (3, 50), \'chocolate\': (2, 100)} Coin count: {1: 10, 5: 11, 10: 12, 20: 6, 50: 3} Transaction: chips, Inserted coins: [50] Dispensed chips. Remaining inventory: {\'soda\': (4, 120), \'chips\': (2, 50), \'chocolate\': (2, 100)} Coin count: {1: 10, 5: 11, 10: 12, 20: 6, 50: 4} Transaction: chocolate, Inserted coins: [100, 20] Insufficient payment. Inserted coins returned. Remaining inventory: {\'soda\': (4, 120), \'chips\': (2, 50), \'chocolate\': (2, 100)} Coin count: {1: 10, 5: 11, 10: 12, 20: 6, 50: 4} ``` Implement the functions `simulate_vending_machine` and `test_vending_machine` to check if your solution works correctly.","solution":"def simulate_vending_machine(initial_inventory, initial_coins, transactions): inventory = initial_inventory.copy() coins = initial_coins.copy() for item, inserted_coins in transactions: print(f\\"Transaction: {item}, Inserted coins: {inserted_coins}\\") total_inserted = sum(inserted_coins) item_quantity, item_price = inventory.get(item, (0, 0)) if item_quantity == 0: print(\\"Item out of stock. Inserted coins returned.\\") print_state(inventory, coins) continue if total_inserted < item_price: print(\\"Insufficient payment. Inserted coins returned.\\") print_state(inventory, coins) continue # Dispense item inventory[item] = (item_quantity - 1, item_price) # Update coin count for coin in inserted_coins: coins[coin] = coins.get(coin, 0) + 1 # Dispense item message print(f\\"Dispensed {item}.\\") print_state(inventory, coins) def print_state(inventory, coins): print(f\\"Remaining inventory: {inventory}\\") print(f\\"Coin count: {coins}n\\")"},{"question":"# Problem Description You are tasked with implementing a function to solve the \\"Minesweeper Board\\" problem. Given a board of mixed values and empty spaces, you need to determine the number of mines surrounding each cell and update the board accordingly. # Function Signature ```python def minesweeper_board(board: list[list[str]]) -> list[list[str]]: Generate the Minesweeper board with numbers indicating the count of mines surrounding each cell. Parameters: board (list[list[str]]): A 2D list representing the Minesweeper board where \'M\' represents a mine and \'E\' represents an empty cell. Returns: list[list[str]]: A Minesweeper board where each empty cell \'E\' is replaced by a number indicating the count of mines in adjacent cells (including diagonals). Raises: ValueError: If the board is not valid (e.g., contains invalid characters or is not a proper 2D list) ``` # Input * A list of lists containing `M` for mines and `E` for empty cells. Each sub-list represents a row on the board. # Output * A list of lists where each empty cell `E` is replaced by a number indicating the count of mines in adjacent cells (including diagonals). Mine cells `M` remain unchanged. # Example ```python # Example 1 input_board = [ [\'E\', \'E\', \'E\', \'E\', \'E\'], [\'E\', \'E\', \'M\', \'E\', \'E\'], [\'E\', \'E\', \'E\', \'E\', \'E\'], [\'E\', \'E\', \'E\', \'E\', \'E\']] print(minesweeper_board(input_board)) # Expected Output: # [[\'0\', \'1\', \'1\', \'1\', \'0\'], # [\'0\', \'1\', \'M\', \'1\', \'0\'], # [\'0\', \'1\', \'1\', \'1\', \'0\'], # [\'0\', \'0\', \'0\', \'0\', \'0\']] # Example 2 input_board = [ [\'E\', \'M\', \'E\'], [\'E\', \'E\', \'E\'], [\'M\', \'E\', \'M\']] print(minesweeper_board(input_board)) # Expected Output: # [[\'1\', \'M\', \'1\'], # [\'2\', \'3\', \'2\'], # [\'M\', \'2\', \'M\']] ``` # Instructions 1. Your task is to complete the `minesweeper_board` function that generates the Minesweeper board based on the given input board. 2. Ensure that cells marked with `M` remain mines and cells marked with `E` are updated with the correct count of surrounding mines. 3. Handle edge cases and validate the input board to ensure it only contains valid characters (`M` or `E`) and is a proper 2D list.","solution":"def minesweeper_board(board): if not board or not all(isinstance(row, list) for row in board): raise ValueError(\\"The board must be a 2D list.\\") rows = len(board) cols = len(board[0]) for row in board: if len(row) != cols or not all(cell in {\'M\', \'E\'} for cell in row): raise ValueError(\\"The board must contain only \'M\' and \'E\' characters and be a uniform matrix.\\") # Directions to check for adjacent cells (including diagonals) directions = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] result_board = [[\'0\' for _ in range(cols)] for _ in range(rows)] for r in range(rows): for c in range(cols): if board[r][c] == \'M\': result_board[r][c] = \'M\' else: mine_count = 0 for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] == \'M\': mine_count += 1 result_board[r][c] = str(mine_count) return result_board"},{"question":"# Question: Validate Parentheses Balance Context You are developing a coding application that frequently processes mathematical expressions and needs to ensure that all parentheses within expressions are properly balanced. This requirement is crucial for ensuring the expressions are valid and can be evaluated correctly. Task Implement the function `validate_parentheses(expression: str) -> bool` that takes a string representing a mathematical expression as its input and returns a boolean indicating whether the parentheses in the expression are valid and balanced. Function Signature ```python def validate_parentheses(expression: str) -> bool: pass ``` Input * A single string `expression` containing the mathematical expression with parentheses `( )`. Output * A boolean value: * `True` if the parentheses in the expression are balanced. * `False` otherwise. Constraints * The string may contain letters, digits, operators such as +, -, *, /, spaces, and parentheses. * You only need to consider parentheses: ignore other characters while checking for balance. Example ```python validate_parentheses(\\"((a+b)*c)\\") ➞ True validate_parentheses(\\"((a+b)*c\\") ➞ False validate_parentheses(\\"a+b)\\") ➞ False validate_parentheses(\\"a+(b*(c/d))\\") ➞ True validate_parentheses(\\"()\\") ➞ True validate_parentheses(\\")(\\") ➞ False ``` Additional Notes * An empty string is considered to have balanced parentheses as there aren\'t any to match or mismatch. * Your function should perform efficiently to handle strings of significant length, although typical expressions are expected to be reasonably short.","solution":"def validate_parentheses(expression: str) -> bool: Checks whether the parentheses in the given expression are balanced. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"Polynomial Evaluation # Given Problem You are required to write a function that evaluates the value of a given polynomial for a specified value of ( x ). The polynomial is represented by an array of coefficients, starting with the coefficient for the highest power of ( x ). # Requirements 1. **Function Name**: evaluate_polynomial 2. **Arguments**: - `coefficients` (List[float]): A list of coefficients representing the polynomial, - `x` (float): The value at which the polynomial is to be evaluated. 3. **Output**: The value of the polynomial at ( x ). 4. **Constraints**: - The `coefficients` list is non-empty. - The input must handle real numbers for coefficients and ( x ). # Examples ```python # Evaluate for x = 2 for polynomial 3x^2 + 2x + 1 evaluate_polynomial([3, 2, 1], 2) # Output: 17 # Evaluate for x = 1 for polynomial 4x^3 - x^2 + 2x + 1 evaluate_polynomial([4, -1, 2, 1], 1) # Output: 6 # Evaluate for x = 0 for polynomial 2x^2 + 5 evaluate_polynomial([2, 0, 5], 0) # Output: 5 # Evaluate for x = -3 for polynomial x^2 - 3x + 2 evaluate_polynomial([1, -3, 2], -3) # Output: 20 ``` # Implementation Write the function `evaluate_polynomial` to meet the above requirements. **Function Signature**: ```python def evaluate_polynomial(coefficients: List[float], x: float) -> float: pass ``` **Notes**: - You can use Python\'s built-in sum function and list comprehension to help simplify the implementation. - Remember to validate the input to ensure the `coefficients` list is non-empty.","solution":"def evaluate_polynomial(coefficients, x): Evaluates the polynomial with given coefficients at the value x. Arguments: coefficients -- List of coefficients (float), with coefficients[i] being the coefficient of x^(n-i) x -- The value at which the polynomial is to be evaluated (float) Returns: The value of the polynomial evaluated at x (float) n = len(coefficients) result = sum(coef * (x ** (n - i - 1)) for i, coef in enumerate(coefficients)) return result"},{"question":"# Problem Statement You are given a list of non-negative integers `nums` and an integer `k`. Your task is to determine if there exists a pair of distinct indices (i) and (j) such that: 1. (0 leq i, j < text{len}(nums)) 2. (text{nums}[i] = text{nums}[j]) 3. (|i - j| leq k) # Function Signature ```python def contains_nearby_duplicate(nums: List[int], k: int) -> bool: pass ``` # Input - `nums` (0 <= len(nums) <= 10^5): a list of non-negative integers. - `k` (0 <= k <= 10^5): an integer representing the allowable difference in indices. # Output - A boolean value `True` if such a pair exists, otherwise `False`. # Example ```python contains_nearby_duplicate([1, 2, 3, 1], 3) # Output: True contains_nearby_duplicate([1, 0, 1, 1], 1) # Output: True contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) # Output: False contains_nearby_duplicate([], 1) # Output: False contains_nearby_duplicate([1, 2, 3, 4, 5], 0)# Output: False ``` # Constraints - Handle the case where the input list is empty. - Consider large values for `k` and large lengths of `nums` efficiently. - Optimize both time and space complexity to handle the largest constraints effectively.","solution":"from typing import List def contains_nearby_duplicate(nums: List[int], k: int) -> bool: Determine if there are two distinct indices i and j in the list such that nums[i] == nums[j] and the absolute difference between i and j is at most k. num_indices = {} for i, num in enumerate(nums): if num in num_indices and i - num_indices[num] <= k: return True num_indices[num] = i return False"},{"question":"# Problem Statement You are given the task of creating and manipulating a matrix to solve several practical requirements. The matrix is represented using a 2D list, and you need to implement various functions to manipulate and analyze it. # Requirements 1. Implement a function `transpose` that returns the transpose of the given matrix. 2. Implement a function `rotate_90_clockwise` to rotate the matrix 90 degrees clockwise. 3. Implement a function `set_zeroes` such that if an element in a cell is 0, its entire row and column are set to 0. 4. Implement a function `spiral_order` to return all elements of the matrix in spiral order. # Provided Code You are required to write the implementation of the functions within a Matrix class. # Function Signatures ```python def transpose(self) -> List[List[int]]: pass def rotate_90_clockwise(self) -> List[List[int]]: pass def set_zeroes(self) -> None: pass def spiral_order(self) -> List[int]: pass ``` # Input and Output Formats * **transpose**: - **Input**: No additional input. - **Output**: The transposed matrix as a list of lists. * **rotate_90_clockwise**: - **Input**: No additional input. - **Output**: The matrix rotated 90 degrees clockwise as a list of lists. * **set_zeroes**: - **Input**: No additional input. - **Output**: No output. The matrix is modified in place. * **spiral_order**: - **Input**: No additional input. - **Output**: A list of integers representing the matrix elements in spiral order. # Constraints 1. Assume the matrix is of size m x n where 1 ≤ m, n ≤ 100. 2. Handle edge cases like empty or single-element matrices appropriately. 3. The matrix elements can be any integer value. # Scenario Anna is a data analyst working with matrix data structures for efficient data manipulation and transformation. She needs the ability to perform transpositions, rotations, zeroing operations, as well as extracting data in spiral order to facilitate her data processing tasks. Implement the functions to assist Anna in her data manipulation requirements. # Usage Example ```python matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) print(matrix.transpose()) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] print(matrix.rotate_90_clockwise()) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] matrix.set_zeroes() # Modifies matrix in place print(matrix.spiral_order()) # Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` To implement the `transpose`, `rotate_90_clockwise`, `set_zeroes`, and `spiral_order` methods, add them to your `Matrix` class accordingly and test them with the provided scenarios.","solution":"from typing import List class Matrix: def __init__(self, data: List[List[int]]): self.data = data def transpose(self) -> List[List[int]]: return [list(row) for row in zip(*self.data)] def rotate_90_clockwise(self) -> List[List[int]]: return [list(reversed(col)) for col in zip(*self.data)] def set_zeroes(self) -> None: rows, cols = len(self.data), len(self.data[0]) zero_rows, zero_cols = set(), set() for r in range(rows): for c in range(cols): if self.data[r][c] == 0: zero_rows.add(r) zero_cols.add(c) for r in zero_rows: for c in range(cols): self.data[r][c] = 0 for c in zero_cols: for r in range(rows): self.data[r][c] = 0 def spiral_order(self) -> List[int]: res = [] while self.data: res += self.data.pop(0) if self.data and self.data[0]: for row in self.data: res.append(row.pop()) if self.data: res += self.data.pop()[::-1] if self.data and self.data[0]: for row in self.data[::-1]: res.append(row.pop(0)) return res"},{"question":"# Knapsack Problem: Recursive Solution You are given a set of items, each with a weight and a value. Your task is to implement a method `max_value` to determine the maximum value that can be obtained from items without exceeding a specified weight limit using a recursive solution to the knapsack problem. Implement the following method: ```python def max_value(self, weights: List[int], values: List[int], capacity: int) -> int: pass ``` # Function Specification * **Input**: * `weights` (List[int]): A list of weights for the items. * `values` (List[int]): A list of values for the items. * `capacity` (int): The maximum weight capacity of the knapsack. * **Output**: * Return the maximum value (int) that can be achieved with the given weight capacity. # Constraints * The number of items (len(weights)) is up to 100. * The weight of each item and the capacity of the knapsack are positive integers up to 1000. * The value of each item is a positive integer up to 1000. Example ```python weights = [1, 2, 3, 5] values = [10, 20, 30, 50] capacity = 6 print(max_value(weights, values, capacity)) # Output: 60 ``` # Explanation 1. In the example, the maximum value without exceeding the capacity of 6 can be achieved by taking the items with weights 1 and 5 (total weight 6) having values 10 and 50, resulting in a maximum value of 60. This problem tests your understanding of recursive problem-solving, particularly in the context of the knapsack problem. The recursive approach involves making choices about whether to include each item based on the remaining capacity and the value thus far.","solution":"from typing import List def max_value(weights: List[int], values: List[int], capacity: int) -> int: Calculate the maximum value that can be achieved with the given weight capacity using a recursive solution. # Helper function for the recursion def knapsack_recursive(n, remaining_capacity): if n == 0 or remaining_capacity == 0: return 0 if weights[n-1] > remaining_capacity: return knapsack_recursive(n-1, remaining_capacity) include_item = values[n-1] + knapsack_recursive(n-1, remaining_capacity - weights[n-1]) exclude_item = knapsack_recursive(n-1, remaining_capacity) return max(include_item, exclude_item) return knapsack_recursive(len(weights), capacity)"},{"question":"# Coding Question: Implementing a Directed Acyclic Graph (DAG) Topological Sort Context: You are tasked with implementing a topological sort for a directed acyclic graph (DAG). Topological sorting of a DAG is a linear ordering of its vertices such that for every directed edge `uv` from vertex `u` to vertex `v`, `u` comes before `v` in the ordering. Task: Create a function that performs a topological sort on a given DAG. Requirements: * **Function Signature**: `def topological_sort(graph: Dict[int, List[int]], v: int) -> List[int]:` * **Input**: * `graph`: A dictionary representing the adjacency list of the graph where `graph[i]` is a list of vertices that vertex `i` has edges to. * `v`: An integer representing the number of vertices in the graph. * **Output**: * A list of vertices in topologically sorted order. * **Constraints**: * The graph is guaranteed to be a DAG. * 1 ≤ V ≤ 1000 Here is a sample code structure for reference: ```python def topological_sort(graph, v): visited = [False] * v stack = [] def dfs(vertex): visited[vertex] = True for neighbor in graph.get(vertex, []): if not visited[neighbor]: dfs(neighbor) stack.append(vertex) for i in range(v): if not visited[i]: dfs(i) return stack[::-1] ``` Challenge: Enhance the provided code structure to handle any initial given graph in adjacency list format and perform an efficient topological sort for a directed acyclic graph.","solution":"def topological_sort(graph, v): This function performs a topological sort on a given directed acyclic graph (DAG). Parameters: - graph: A dictionary representing the adjacency list of the graph. - v: An integer representing the number of vertices in the graph. Returns: - A list of vertices in topologically sorted order. visited = [False] * v stack = [] def dfs(vertex): visited[vertex] = True for neighbor in graph.get(vertex, []): if not visited[neighbor]: dfs(neighbor) stack.append(vertex) for i in range(v): if not visited[i]: dfs(i) return stack[::-1]"},{"question":"# Sentence Reversal Algorithm Challenge **Context:** String manipulation is a fundamental aspect of coding, requiring various techniques and methods to handle different text scenarios. One such scenario is the reversal of word order in a given sentence. **Problem Statement:** Write a Python function `reverse_words(sentence: str) -> str` that takes a string `sentence` and returns a new string with the order of the words reversed. Each word in the sentence is separated by a single space. The sentence should be returned with words in reversed order but with their original spacing retained. **Input Format:** - A string `sentence` where the number of characters (1 leq text{len(sentence)} leq 1000). - The string contains only printable ASCII characters and spaces. **Output Format:** - Return a string with the words in reverse order of their appearance in the input sentence. **Constraints:** - The input string will contain at least one word. - There will not be leading, trailing, or multiple consecutive spaces in the input sentence. **Example:** ```python assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"Python is great\\") == \\"great is Python\\" assert reverse_words(\\"OpenAI creates powerful AI tools\\") == \\"tools AI powerful creates OpenAI\\" ``` # Functions to Implement: 1. `reverse_words(sentence: str) -> str` # Notes: - Ensure to handle phrases of varying lengths and complexities. - Retain the original whitespace formatting between words during reversal.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Args: sentence (str): A string where words are separated by a single space. Returns: str: A string with words in reversed order. words = sentence.split() reversed_words = \\" \\".join(reversed(words)) return reversed_words"},{"question":"# Problem Description You are tasked with creating a function to manage and evaluate student grades in a class. Specifically, you will need to keep track of students\' names and their corresponding scores, and then determine the highest and lowest scores, and the average score of the class. # Function Requirements Write a function `evaluate_grades` that takes a dictionary of student names and their scores as input and returns a tuple containing the highest score, the lowest score, and the average score of the class. Input * `grades` (Dict[str, int]): A dictionary where the keys are student names (strings) and the values are their corresponding scores (integers). Output * Tuple[int, int, float]: A tuple where: - The first element is the highest score (int). - The second element is the lowest score (int). - The third element is the average score (float), rounded to two decimal places. Constraints 1. There will be at least one student in the dictionary. 2. Scores are non-negative integers and will not exceed 100. 3. Student names will be unique. # Examples ```python assert evaluate_grades({\'Alice\': 85, \'Bob\': 92, \'Charlie\': 78}) == (92, 78, 85.00) assert evaluate_grades({\'Dave\': 50, \'Eve\': 50, \'Frank\': 50}) == (50, 50, 50.00) assert evaluate_grades({\'Grace\': 100}) == (100, 100, 100.00) ``` # Instructions 1. Calculate the highest score from the dictionary. 2. Calculate the lowest score from the dictionary. 3. Calculate the average score, ensuring it is rounded to two decimal places. 4. Ensure your function is efficient and handles edge cases appropriately. # Test your implementation with the provided examples to ensure correctness.","solution":"def evaluate_grades(grades): Evaluates the highest, lowest, and average grade from a dictionary of grades. Args: grades (Dict[str, int]): A dictionary with student names as keys and their scores as values. Returns: Tuple[int, int, float]: A tuple containing the highest score, the lowest score, and the average score. scores = grades.values() highest_score = max(scores) lowest_score = min(scores) average_score = round(sum(scores) / len(scores), 2) return (highest_score, lowest_score, average_score)"},{"question":"# Coding Assessment Question You are given a sequence of events and the time it takes for each event to occur. Your task is to implement a `process_events` function that schedules these events in such a way that each subsequent event starts only after the previous event has completely finished. Additionally, you need to calculate the total time taken to process all events. # Inputs * events: A list of integers representing the time duration (in seconds) for each event to occur. # Outputs * total_time: An integer representing the total time taken to process all events. # Example ```python events = [2, 3, 5, 7] # The total time taken would be 2+3+5+7 = 17 ``` # Constraints * Let n be the number of events. * (1 leq n leq 10^3) * (1 leq time leq 10^3) # Implementation You need to complete the implementation of the `process_events` function: ```python def process_events(events): total_time = 0 for event_time in events: total_time += event_time return total_time ``` Test your implementation with multiple cases to ensure correctness.","solution":"def process_events(events): Schedules the events and returns the total time taken to process all events. Parameters: events (list of int): List of event durations in seconds Returns: int: Total time taken to process all events total_time = 0 for event_time in events: total_time += event_time return total_time"},{"question":"# Problem Description You are given a list of flight routes where each route consists of a source city, a destination city, and a distance between them. The task is to find the shortest path between a given starting city and a destination city using Dijkstra\'s algorithm. Implement a function to determine the shortest distance and return the path taken. # Function Signature ```python def find_shortest_path(routes: list[tuple[str, str, int]], start: str, destination: str) -> dict[str, any]: ``` # Parameters - **routes** (list of tuple of (str, str, int)): A list of flights where each flight is represented as a tuple containing a source city, a destination city, and the distance between them. - **start** (str): The starting city. - **destination** (str): The destination city. # Returns - A dictionary with two keys: - `\'distance\'`: The shortest distance from the starting city to the destination city as an integer. - `\'path\'`: A list of strings showing the path taken including the starting and destination cities. # Constraints - There will always be at least one route given. - The graph might not be connected; return `{\'distance\': float(\'inf\'), \'path\': []}` if no path exists between the start and destination. - All distances are positive integers. - Cities are represented by non-empty strings. # Examples ```python >>> find_shortest_path( ... [(\'A\', \'B\', 1), (\'B\', \'C\', 2), (\'A\', \'C\', 4), (\'C\', \'D\', 1)], ... \'A\', \'D\' ... ) {\'distance\': 4, \'path\': [\'A\', \'B\', \'C\', \'D\']} >>> find_shortest_path( ... [(\'A\', \'B\', 1), (\'B\', \'C\', 5), (\'A\', \'C\', 10)], ... \'A\', \'C\' ... ) {\'distance\': 6, \'path\': [\'A\', \'B\', \'C\']} >>> find_shortest_path( ... [(\'A\', \'B\', 1), (\'C\', \'D\', 2)], ... \'A\', \'D\' ... ) {\'distance\': float(\'inf\'), \'path\': []} ``` # Additional Notes - Ensure to handle edge cases, such as graphs with disjoint sets of cities. - Focus on implementing an efficient version of Dijkstra\'s algorithm.","solution":"import heapq from typing import List, Tuple, Dict, Any def find_shortest_path(routes: List[Tuple[str, str, int]], start: str, destination: str) -> Dict[str, Any]: # Create a graph from the routes graph = {} for src, dst, dist in routes: if src not in graph: graph[src] = [] if dst not in graph: graph[dst] = [] graph[src].append((dist, dst)) graph[dst].append((dist, src)) # Since the routes can be two-way # Dijkstra\'s algorithm to find the shortest path priority_queue = [(0, start, [])] visited = set() while priority_queue: current_dist, current_node, path = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) path = path + [current_node] # If we reached the destination, return the result if current_node == destination: return {\'distance\': current_dist, \'path\': path} # Push adjacent nodes to the priority queue for distance, neighbor in graph.get(current_node, []): if neighbor not in visited: heapq.heappush(priority_queue, (current_dist + distance, neighbor, path)) # If we get here, there is no path return {\'distance\': float(\'inf\'), \'path\': []}"}]'),z={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},F={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],N={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",N,"See more"))],8,R)):u("",!0)])}const j=h(z,[["render",D],["__scopeId","data-v-d0ec8473"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/9.md","filePath":"drive/9.md"}'),Y={name:"drive/9.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{B as __pageData,V as default};
