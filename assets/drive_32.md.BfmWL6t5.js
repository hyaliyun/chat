import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-18d38cec"]]),S=JSON.parse('[{"question":"# Scenario: You are developing a data structure to manage a dynamic array of integers. This array is used frequently in a system that requires two main operations: updating the value of an element at a given index and querying the sum of a subarray. To handle both types of operations efficiently, you decide to use a **Segment Tree**. # Task: Implement a class to support the following operations: 1. **update_value(index: int, value: int)**: Update the integer at the specified index to the new value. 2. **sum_query(start_index: int, end_index: int)**: Compute and return the sum of the elements within the range [start_index, end_index). # Constraints: - `0 <= index < N`, where `N` is the size of the array. - `-10^9 <= value <= 10^9` - `0 <= start_index < end_index <= N` - You cannot use built-in library functions for querying ranges (like `sum`). # Function Signature: ```python class DynamicArray: def __init__(self, size: int) -> None: ... def update_value(self, index: int, value: int) -> None: ... def sum_query(self, start_index: int, end_index: int) -> int: ... # Example Usage: # arr = DynamicArray(6) # arr.update_value(2, 10) # arr.update_value(3, 5) # print(arr.sum_query(1, 4)) # Output: 15 (5 + 10) # arr.update_value(2, 7) # print(arr.sum_query(2, 6)) # Output: 12 (7 + 5) ``` # Notes: - Ensure that the solution efficiently supports both value updates and sum queries. - Handle edge cases where updates or queries might include boundary values. - Maintain the performance goals of Segment Trees to achieve optimal querying and updating time complexity. This new question aligns with the given guidelines by focusing on the creation and handling of a dynamic array structure, employing advanced data structures (like the Segment Tree) to manage efficient range queries and updates, complementing the existing question set\'s coverage of related concepts.","solution":"class DynamicArray: def __init__(self, size: int) -> None: self.size = size self.arr = [0] * size self.seg_tree = [0] * (4 * size) self._build(0, 0, size - 1) def _build(self, node, start, end): if start == end: self.seg_tree[node] = self.arr[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self._build(left_node, start, mid) self._build(right_node, mid + 1, end) self.seg_tree[node] = self.seg_tree[left_node] + self.seg_tree[right_node] def _update(self, node, start, end, idx, value): if start == end: self.arr[idx] = value self.seg_tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self._update(left_node, start, mid, idx, value) else: self._update(right_node, mid + 1, end, idx, value) self.seg_tree[node] = self.seg_tree[left_node] + self.seg_tree[right_node] def _sum_query(self, node, start, end, l, r): if r < start or l > end: return 0 if l <= start and end <= r: return self.seg_tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 sum_left = self._sum_query(left_node, start, mid, l, r) sum_right = self._sum_query(right_node, mid + 1, end, l, r) return sum_left + sum_right def update_value(self, index: int, value: int) -> None: self._update(0, 0, self.size - 1, index, value) def sum_query(self, start_index: int, end_index: int) -> int: return self._sum_query(0, 0, self.size - 1, start_index, end_index - 1)"},{"question":"# Coding Assessment Question Context You have been hired by a company to write software that processes textual data. One of the functionalities required is the ability to count the occurrences of each unique word within a given text string. Problem Description Write a function `word_count` that takes a single string `text` as an argument and returns a dictionary where the keys are unique words (case-insensitive), and the values are the counts of those words. The function should normalize the casing of words and remove punctuation to ensure accurate counts. Input and Output - **Input**: - `text` (str): A string of text from which to count word occurrences. - **Output**: - A dictionary where keys are words (str) and values are their respective counts (int). Constraints - You are only allowed to use standard Python libraries. - Words are separated by whitespace characters and punctuation marks should be ignored. - Treat uppercase and lowercase versions of a word as the same word. Examples ``` >>> word_count(\\"Hello, world! Hello!\\") {\'hello\': 2, \'world\': 1} >>> word_count(\\"Python is great. Python is popular. Python!\\") {\'python\': 3, \'is\': 2, \'great\': 1, \'popular\': 1} >>> word_count(\\"Data, data everywhere... and not a byte to spare!\\") {\'data\': 2, \'everywhere\': 1, \'and\': 1, \'not\': 1, \'a\': 1, \'byte\': 1, \'to\': 1, \'spare\': 1} ``` Performance Requirement Your solution should efficiently handle text strings of up to 10,000 characters. Hints - Consider using the `re` library for regular expressions to aid in removing punctuation. - Utilize the `str.lower()` method to normalize the case of words.","solution":"import re from collections import defaultdict def word_count(text): Given a string `text`, returns a dictionary with the count of each unique word (case insensitive). Punctuation is ignored in the count. Args: text (str): input string containing the text. Returns: dict: dictionary where keys are unique lowercase words and values are their counts. # Normalize text to lowercase and remove punctuation text = re.sub(r\'[^ws]\', \'\', text).lower() words = text.split() # Count the occurrences of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Financial Data Analysis using Python You are required to implement a Python function to parse and analyze stock trading data from a CSV file and then generate summary statistics. This task aims to assess your data manipulation, analysis capabilities, and proficiency with the Pandas library in Python. Context: You are given a CSV file containing historical stock prices and trading volumes for multiple companies over a period of time. The CSV file includes columns: \'Date\', \'Company\', \'Close_Price\', \'Volume\'. Your goal is to read this data, process it, and provide statistical summaries of closing prices and volumes for each company. Task: 1. Write a function `analyze_stock_data(filename: str) -> dict` that reads a CSV file, processes the data, and returns a dictionary with companies as keys and their summary statistics as values. 2. In the same function, compute the following statistics per company: - Average closing price. - Standard deviation of closing prices. - Total volume of stocks traded. Input: - `filename`: (str) The name of the CSV file containing the stock data. The CSV file is expected to have columns: \'Date\' (string), \'Company\' (string), \'Close_Price\' (float), and \'Volume\' (integer). Output: - A dictionary where each key is a company name (string) and the value is another dictionary with the keys \'Average_Price\', \'Price_StdDev\', and \'Total_Volume\', containing the corresponding calculated values. Notes: - Assume all columns in the CSV file are correctly formatted and contain valid data. - Use the Pandas library for data loading and manipulation. - Ensure to handle large files efficiently. - Handle potential missing or NaN values appropriately by excluding them from calculations. - Code should be written in a modular and readable manner. Example: Here is an example of expected function usage: ```python filename = \\"stock_data.csv\\" summary_statistics = analyze_stock_data(filename) # Example of the returned dictionary: # { # \\"CompanyA\\": { # \\"Average_Price\\": 150.5, # \\"Price_StdDev\\": 12.34, # \\"Total_Volume\\": 1050000 # }, # \\"CompanyB\\": { # \\"Average_Price\\": 75.4, # \\"Price_StdDev\\": 8.24, # \\"Total_Volume\\": 850000 # } # } ``` # Sample CSV File (`stock_data.csv`): ``` Date,Company,Close_Price,Volume 2023-01-01,CompanyA,155.2,10000 2023-01-02,CompanyA,152.3,8500 2023-01-01,CompanyB,78.9,15000 2023-01-02,CompanyB,72.0,17000 ```","solution":"import pandas as pd def analyze_stock_data(filename: str) -> dict: # Read the CSV file into a DataFrame df = pd.read_csv(filename) # Initialize result dictionary result = {} # Group the data by Company grouped = df.groupby(\'Company\') # Iterate over each group to compute statistics for name, group in grouped: # Drop NaN values in Close_Price and Volume columns close_prices = group[\'Close_Price\'].dropna() volumes = group[\'Volume\'].dropna() # Compute statistics avg_price = close_prices.mean() stddev_price = close_prices.std() total_volume = volumes.sum() # Store results in the dictionary result[name] = { \'Average_Price\': avg_price, \'Price_StdDev\': stddev_price, \'Total_Volume\': total_volume } return result"},{"question":"# Coding Assessment Question Context Sorting algorithms are fundamental in computer science, and understanding them is crucial for efficiency in data handling. We\'re going to explore one of the classic sorting algorithms, Merge Sort, and see how it performs on different data sets. The Task Using your knowledge of sorting algorithms, implement the **Merge Sort** algorithm to sort a list of integers and test its performance on varied input sizes and values. Input A list of integers `arr` (0 ≤ len(arr) ≤ 10^5) where each integer can range from -10^9 to 10^9. Output A new list with the elements from `arr` sorted in non-decreasing order. Performance Requirements - Your solution should be efficient: aim for O(n log n) time complexity and O(n) space complexity. # Implementation Guide 1. Implement the main function `merge_sort(arr: List[int]) -> List[int]` using the Merge Sort algorithm: * Handle edge cases where the list length is 0 or 1. * Use a divide-and-conquer approach to split the list into smaller sublists. * Merge the sorted sublists back together to form the sorted list. 2. Test your implementation with various inputs to ensure correctness. Include edge cases like empty lists, already sorted lists, and lists with all elements the same. # Example Usage ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: # Your code here to implement merge sort # Example usage: print(merge_sort([])) # Output: [] print(merge_sort([5])) # Output: [5] print(merge_sort([3, 1, 2])) # Output: [1, 2, 3] print(merge_sort([10, -1, 100, 4])) # Output: [-1, 4, 10, 100] ```","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr # Splitting the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index = right_index = 0 # Merging the two halves until one is exhausted while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append any remaining elements from left and right halves sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Coding Assessment: Compute Greatest Common Divisor (GCD) Context As part of a mathematical toolkit, you are tasked with implementing a function to compute the Greatest Common Divisor (GCD) of two integers. The GCD is the largest integer that divides both numbers without leaving a remainder. Your implementation will involve using the Euclidean algorithm, a well-known efficient method for this purpose. Requirements Implement the following function: 1. **gcd(a: int, b: int) -> int**: * Computes the GCD of two non-negative integers `a` and `b` using the Euclidean algorithm. Input * Two non-negative integers `a` and `b`, where `a >= 0` and `b >= 0`. * Example: ```python a = 48 b = 18 ``` Output * The function should return the GCD of the two input integers. Example ```python # Example provided inputs: a = 48 b = 18 # Expected Output: 6 ``` Note * If both `a` and `b` are zero, return `0` as the GCD would be meaningless. * Ensure your implementation handles edge cases, such as when one or both numbers are zero. ```python def gcd(a: int, b: int) -> int: while b != 0: a, b = b, a % b return a # Example usage: a = 48 b = 18 print(gcd(a, b)) # Output: 6 ``` Ensure your implementation follows the Euclidean algorithm accurately and efficiently handles possible edge cases.","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers a and b using the Euclidean algorithm. while b != 0: a, b = b, a % b return a # Example usage: a = 48 b = 18 print(gcd(a, b)) # Output: 6"},{"question":"# Problem Statement You need to implement a function to find the determinant of a matrix and use this determinant function to check if a system of linear equations has a unique solution or not. These operations are essential in solving and understanding linear systems widely used in engineering, physics, and computer science. # Function Definitions 1. `determinant(matrix: List[List[float]]) -> float` - **Input**: A square matrix represented as a list of lists. - **Output**: The determinant of the matrix, which is a single floating point number. 2. `has_unique_solution(coeff_matrix: List[List[float]], const_vector: List[float]) -> bool` - **Input**: - `coeff_matrix`: A square matrix represented as a list of lists containing the coefficients of the system of linear equations. - `const_vector`: A list containing the constants of the system of linear equations. - **Output**: `True` if the system of linear equations has a unique solution, `False` otherwise. - **Constraints**: - Ensure that `coeff_matrix` and `const_vector` have compatible dimensions. - The system of equations is considered to have a unique solution if the determinant of `coeff_matrix` is non-zero (this assumes consistency of the system). # Example ```python matrix = [ [2, -1, 0], [1, 3, -2], [0, -1, 4] ] constants = [1, 2, 3] assert np.isclose(determinant(matrix), -17.0) assert has_unique_solution(matrix, constants) == True ``` # Note - Make sure to handle appropriate error checking, such as ensuring the provided matrix is square. - Consider the edge cases where the determinant might be zero, indicating that the system might have no solution or infinitely many solutions. Hints - You may use recursive methods or LU decomposition for computing the determinant. - Ensure to properly code for edge cases like 1x1 matrices or larger matrices where precision might be a consideration.","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix using recursion (Laplace expansion). if len(matrix) != len(matrix[0]): raise ValueError(\\"Matrix must be square\\") if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): sub_matrix = [row[:c] + row[c+1:] for row in matrix[1:]] det += ((-1) ** c) * matrix[0][c] * determinant(sub_matrix) return det def has_unique_solution(coeff_matrix: List[List[float]], const_vector: List[float]) -> bool: Check if the system of linear equations represented by coeff_matrix and const_vector has a unique solution by checking if the determinant of coeff_matrix is non-zero. if len(coeff_matrix) != len(const_vector): raise ValueError(\\"The coefficient matrix and the constant vector must have compatible dimensions\\") det = determinant(coeff_matrix) return det != 0"},{"question":"# Coding Assessment Question **Scenario**: You are developing a software application that handles file and directory operations. One common operation is calculating the total size of files within a specific directory. To facilitate this, you need to implement a function that can compute the cumulative size of all files in a given directory, including its subdirectories. **Task**: Write a function `directory_size` that: - Takes a single argument, `path`, which is a string representing the path to a directory. - Returns the total size (in bytes) of all the files contained within the directory and its subdirectories. - Raises a `NotADirectoryError` if `path` is not a valid directory. **Input**: - A single string, `path`, representing the directory path. If `path` is not a valid directory, a `NotADirectoryError` should be raised. **Output**: - An integer representing the total size (in bytes) of all files within the directory and its subdirectories. **Constraints**: - You should not use any external libraries for directory or file handling. - Your function should handle directories with a large number of files efficiently. **Function Signature**: ```python import os def directory_size(path: str) -> int: ``` **Examples**: ```python # Assuming the following directory structure and sizes: # /home/user/dir # ├── file1.txt (100 bytes) # ├── file2.txt (200 bytes) # └── subdir # ├── file3.txt (300 bytes) # └── file4.txt (400 bytes) directory_size(\\"/home/user/dir\\") # Expected output: 1000 # Assuming the directory \\"/invalid/dir\\" does not exist directory_size(\\"/invalid/dir\\") # Expected output: NotADirectoryError ``` Write comprehensive test cases to verify the correctness of your implementation. The function should pass all provided example cases, ensuring accurate size calculation and appropriate error handling for invalid directory paths.","solution":"import os def directory_size(path: str) -> int: Calculate the total size of all files in the given directory and its subdirectories. Parameters: path (str): Path of the directory. Returns: int: Total size of all files in bytes. Raises: NotADirectoryError: If the path is not a valid directory. if not os.path.isdir(path): raise NotADirectoryError(f\\"The path {path} is not a valid directory\\") total_size = 0 for root, dirs, files in os.walk(path): for file in files: file_path = os.path.join(root, file) if os.path.isfile(file_path): total_size += os.path.getsize(file_path) return total_size"},{"question":"Problem Statement # Objective Write a function `find_missing_number(arr: list[int]) -> int` that finds the missing number in an array containing n distinct numbers taken from the range [0, n]. # Constraints - The function must take a list of distinct integers `arr` where the integers are in the range [0, n]. - The function should raise a `ValueError` if the input array is empty or if the values do not follow the specifications. - The function should raise a `TypeError` if the input is not a list of integers. # Input - `arr`: A list of distinct integers in the range [0, n], where exactly one of the numbers in this range is missing. # Output - The function should return the missing integer in the range [0, n]. # Examples ```python >>> find_missing_number([0, 1, 3]) 2 >>> find_missing_number([4, 2, 0, 3]) 1 >>> find_missing_number([1]) 0 >>> find_missing_number([]) Traceback (most recent call last): ... ValueError: Input array cannot be empty >>> find_missing_number([1, 2, 2]) Traceback (most recent call last): ... ValueError: Input array must contain distinct integers in the range [0, n] >>> find_missing_number(5) Traceback (most recent call last): ... TypeError: Input value must be a list of integers ``` # Performance Requirements - The function should operate in O(n) time complexity. - The function should use O(1) additional space. # Task Implement the `find_missing_number` function in Python, ensuring that you handle edge cases appropriately and validate the input.","solution":"def find_missing_number(arr: list[int]) -> int: if not isinstance(arr, list): raise TypeError(\\"Input value must be a list of integers\\") n = len(arr) if n == 0: raise ValueError(\\"Input array cannot be empty\\") if not all(isinstance(x, int) for x in arr) or len(set(arr)) != len(arr) or not all(0 <= x <= n for x in arr): raise ValueError(\\"Input array must contain distinct integers in the range [0, n]\\") expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Coding Assessment Question Data Stream Median Calculation **Scenario**: You are tasked with continuously computing the median of a stream of integer data that can be infinitely long. The data arrives one integer at a time, and after each integer is received, your algorithm needs to provide the current median of all received integers. Requirements: You are required to implement a `MedianFinder` class with the following methods: 1. **add_num(num: int)**: Adds a number from the data stream to the data structure. 2. **find_median() -> float**: Returns the median of all elements so far. If the number of elements is odd, return the middle one; if even, return the average of the middle two. Implementation Details: 1. **Dynamic Data Structure**: - Utilize two heaps to store the lower and upper halves of the data stream. This will allow you to maintain balance and quickly access the median. - A max-heap for the lower half (invert values to create a max-heap using Python\'s `heapq` which only supports min-heap operations). - A min-heap for the upper half. 2. **Balancing Heaps**: - Ensure that the heaps are balanced such that the difference in the number of elements between the two heaps is at most one. - After each insertion, adjust the heaps to maintain this balance. Constraints: - The `add_num` method can be called at most 10^6 times. - The value of each number in the stream falls within the range [-10^5, 10^5]. Example: ``` stream_finder = MedianFinder() stream_finder.add_num(1) stream_finder.add_num(2) print(stream_finder.find_median()) # -> 1.5 stream_finder.add_num(3) print(stream_finder.find_median()) # -> 2 ``` Function Signatures: ```python import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.lower_half = [] # max-heap (invert values) self.upper_half = [] # min-heap def add_num(self, num: int) -> None: Adds a number from the data stream to the data structure. pass def find_median(self) -> float: Returns the median of all elements so far. pass ``` Implement the `__init__`, `add_num`, and `find_median` methods to achieve the given functionality.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. self.lower_half = [] # max-heap (invert values to simulate max-heap) self.upper_half = [] # min-heap def add_num(self, num: int) -> None: Adds a number from the data stream to the data structure. # Add to max-heap (invert value to use min-heap as max-heap) heapq.heappush(self.lower_half, -num) # Ensure every element in lower_half is <= every element in upper_half if (self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0])): val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) # Balance the lengths of the two heaps if len(self.lower_half) > len(self.upper_half) + 1: val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) if len(self.upper_half) > len(self.lower_half): val = heapq.heappop(self.upper_half) heapq.heappush(self.lower_half, -val) def find_median(self) -> float: Returns the median of all elements so far. if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] return (-self.lower_half[0] + self.upper_half[0]) / 2"},{"question":"Sudoku Solver You are given a partially filled 9x9 Sudoku grid where each cell contains an integer between 1 and 9 or a 0 indicating an empty cell. Implement an algorithm to solve the Sudoku puzzle by filling in the empty cells such that the following rules are satisfied: 1. Each row contains the numbers 1-9 without repetition. 2. Each column contains the numbers 1-9 without repetition. 3. Each of the nine 3x3 sub-grids contains the numbers 1-9 without repetition. # Function Signature ```python def solve_sudoku(grid: List[List[int]]) -> bool: ``` # Input - `grid`: A 9x9 2D list of integers where each integer is between 0 and 9. # Output - Modify the grid in place to represent a solved Sudoku puzzle. The function should return `True` if the puzzle is solved successfully, or `False` if no solution exists. # Constraints - The grid will always be a 9x9 matrix. - There may be multiple solutions, but you only need to find one valid solution. # Example ```python grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] solve_sudoku(grid) print(grid) # Output: [ # [5, 3, 4, 6, 7, 8, 9, 1, 2], # [6, 7, 2, 1, 9, 5, 3, 4, 8], # [1, 9, 8, 3, 4, 2, 5, 6, 7], # [8, 5, 9, 7, 6, 1, 4, 2, 3], # [4, 2, 6, 8, 5, 3, 7, 9, 1], # [7, 1, 3, 9, 2, 4, 8, 5, 6], # [9, 6, 1, 5, 3, 7, 2, 8, 4], # [2, 8, 7, 4, 1, 9, 6, 3, 5], # [3, 4, 5, 2, 8, 6, 1, 7, 9] # ] ``` # Note * You can use backtracking to solve this problem efficiently.","solution":"from typing import List def solve_sudoku(grid: List[List[int]]) -> bool: def is_valid(num, row, col): # Check if \'num\' is unique in the row for i in range(9): if grid[row][i] == num: return False # Check if \'num\' is unique in the column for i in range(9): if grid[i][col] == num: return False # Check if \'num\' is unique in the 3x3 sub-grid start_row = (row // 3) * 3 start_col = (col // 3) * 3 for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if grid[i][j] == num: return False return True def solve(): for row in range(9): for col in range(9): if grid[row][col] == 0: for num in range(1, 10): if is_valid(num, row, col): grid[row][col] = num if solve(): return True grid[row][col] = 0 return False return True return solve()"},{"question":"# Coding Assessment Question Problem Statement: You are given an array of integers and a target integer. Your task is to find all unique sets of four numbers in the array that sum up to the target integer. Write a function `find_four_sum(nums: List[int], target: int) -> List[List[int]]` that takes a list of integers `nums` and an integer `target`, and returns a list of lists, with each list containing four integers that sum up to the target. Input: * `nums` (1 <= len(nums) <= 200): A list of integers, where each integer can range from -10^9 to 10^9. * `target` (-10^9 <= target <= 10^9): An integer representing the target sum for the four numbers. Output: * A list of lists, where each sublist is a unique set of four integers that add up to `target`. Example: ```python assert find_four_sum([1, 0, -1, 0, -2, 2], 0) == [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] assert find_four_sum([2, 2, 2, 2, 2], 8) == [[2, 2, 2, 2]] assert find_four_sum([-1, 0, 1, 2, -1, -4], -1) == [[-4, 0, 1, 2], [-1, -1, 0, 1]] assert find_four_sum([], 0) == [] ``` Constraints: * Ensure the function avoids duplicates in the output list of lists. * Consider edge cases where the input list is empty or contains insufficient elements to form a set of four. Performance: * Aim for a solution that operates efficiently within the given constraints, using appropriate data structures to manage and check uniqueness.","solution":"from typing import List def find_four_sum(nums: List[int], target: int) -> List[List[int]]: nums.sort() n = len(nums) result = [] for i in range(n - 3): # Avoid duplicates for the first number if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): # Avoid duplicates for the second number if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: sum_val = nums[i] + nums[j] + nums[left] + nums[right] if sum_val == target: result.append([nums[i], nums[j], nums[left], nums[right]]) # Avoid duplicates for the third and fourth numbers while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_val < target: left += 1 else: right -= 1 return result"},{"question":"# Sum of Numbers in a Range Divisible by a Given Number **Problem Description**: Given a range of integers and a divisor, we need to find the sum of all numbers within that range that are divisible by the given divisor. For instance, for the range 1 to 10 and the divisor 2, the numbers that are divisible by 2 are 2, 4, 6, 8, and 10, and their sum is 30. **Your Task**: Write a function named `sum_divisible_by(n: int, m: int, d: int) -> int` that takes three integers `n`, `m`, and `d`, and returns the sum of all integers between `n` and `m` (inclusive) which are divisible by `d`. **Function Signature**: ```python def sum_divisible_by(n: int, m: int, d: int) -> int: pass ``` **Input**: * `n` (-10^6 ≤ n ≤ 10^6): An integer specifying the start of the range. * `m` (-10^6 ≤ m ≤ 10^6): An integer specifying the end of the range. * `d` (1 ≤ d ≤ 10^6): An integer specifying the divisor. **Output**: * Returns an integer representing the sum of all numbers within the range `[n, m]` that are divisible by `d`. **Examples**: ```python sum_divisible_by(1, 10, 2) # Returns 30 (2 + 4 + 6 + 8 + 10) sum_divisible_by(5, 15, 3) # Returns 45 (6 + 9 + 12 + 15) sum_divisible_by(-10, 10, 4) # Returns 0 (-8 - 4 + 4 + 8) ``` **Constraints**: * You may assume that `n` and `m` can be in any order, i.e., `n` could be greater than `m` or vice versa. * The result will fit within the limits of a 64-bit integer. **Hints**: 1. Consider using a loop to iterate through the range and sum the numbers divisible by `d`. 2. To avoid looping through all numbers in the range, think about mathematical summation formulas or optimizations that leverage series and sequences. 3. Handle cases where the range can be negative or span across zero.","solution":"def sum_divisible_by(n: int, m: int, d: int) -> int: Returns the sum of all numbers between n and m (inclusive) that are divisible by d. if n > m: n, m = m, n first_divisible = n if n % d == 0 else n + (d - n % d) last_divisible = m if m % d == 0 else m - (m % d) if first_divisible > m or last_divisible < n: return 0 count = (last_divisible - first_divisible) // d + 1 # Arithmetic sum of an evenly spaced series return count * (first_divisible + last_divisible) // 2"},{"question":"# Problem Description Your task is to create an algorithm that generates unique identifiers for a list of strings. Each identifier should be a hash that quickly identifies the string content. # Function Specification Implement a function `generate_hashes` that computes a unique hash for each string in a given list of strings using a consistent hashing mechanism. Input - A list `str_list` of `n` strings, each consisting of ASCII characters. Output - A list of `n` integers, each representing the hash for the corresponding string in `str_list`. # Constraints - The input list will contain between 1 and 10^5 (100,000) strings. - Each string in the list will have a length of 1 to 200 characters. - The input strings will only contain ASCII characters (0-127). # Example Usage ```python >>> generate_hashes([\'apple\', \'banana\', \'cherry\']) [99162322, 225786220, 267283956] >>> generate_hashes([\'dog\', \'cat\', \'fish\']) [957123, 3221818, 101234501] >>> generate_hashes([\'The quick brown fox\', \'jumps over the\', \'lazy dog\']) [210748555, 518975106, 143242355] ``` # Requirements - Ensure the function performs efficiently with an overall time complexity close to O(n * m), where `n` is the number of strings and `m` is the average length of the strings. - Handle scenarios where the list contains identical strings, returning identical hashes accordingly. - Use a reliable hash function that minimizes collisions for ASCII character strings.","solution":"import hashlib def generate_hashes(str_list): Generates a unique hash for each string in the input list. Parameters: str_list (list of str): List of strings to be hashed. Returns: list of int: List of hashes for each input string. hashes = [] for s in str_list: hash_value = int(hashlib.md5(s.encode()).hexdigest(), 16) hashes.append(hash_value) return hashes"},{"question":"# Question: **Context**: You are given a binary search tree (BST) and a target value. Your task is to find a node in the BST such that the sum of the node\'s value and one of its descendants\' value equals the target value. You need to implement an efficient method to solve this problem using the properties of the BST. **Objective**: Implement a function `find_target_sum_in_bst` that takes the root of the BST and a target value, then returns True if such a pair of nodes exists, or False otherwise. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target_sum_in_bst(root: TreeNode, target: int) -> bool: pass ``` # Input: * **root**: The root node of a binary search tree. * **target**: An integer representing the target sum value. # Output: * Returns True if there exists a pair of nodes (one being a descendant of the other) whose values sum up to the target value, otherwise returns False. # Constraints: * The number of nodes in the BST will not exceed 10^4. * Node values are integers and can be both positive and negative. # Example: ```python # The BST: # 5 # / # 3 7 # / # 2 4 8 # Target: 12 root = TreeNode(5) root.left = TreeNode(3, TreeNode(2), TreeNode(4)) root.right = TreeNode(7, None, TreeNode(8)) target = 12 result = find_target_sum_in_bst(root, target) print(result) # Expected: True (5 + 7) ``` # Notes: * Assume that the given tree is a valid binary search tree. * Aim for efficient time and space complexities by leveraging the properties of the binary search tree. * You can use auxiliary storage such as a set or dictionary to keep track of visited nodes\' values.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target_sum_in_bst(root: TreeNode, target: int) -> bool: Check if there exists a pair of nodes in the BST such that their values sum up to the target value. def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Store the in-order traversal of the BST which returns a sorted list values = inorder_traversal(root) # Use two pointers technique on the sorted list to find the target sum left, right = 0, len(values) - 1 while left < right: current_sum = values[left] + values[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"# Balanced Binary Tree Validation You have been provided with the root of a binary tree. Your task is to determine if the tree is height-balanced. A binary tree is height-balanced if the depth of the two subtrees of every node never differs by more than 1. # Function Signature ```python def is_balanced(root: Optional[TreeNode]) -> bool: ``` # Input - A TreeNode `root` representing the root of the binary tree. - `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Returns `True` if the binary tree is height-balanced, `False` otherwise. # Constraints - The number of nodes in the tree is at most `10^4`. - The tree node values are integers between `-10^5` and `10^5`. # Examples 1. Input: `root = [3,9,20,null,null,15,7]` Output: `True` 2. Input: `root = [1,2,2,3,3,null,null,4,4]` Output: `False` 3. Input: `root = []` Output: `True` # Explanation - **Example 1**: The tree is structured as follows: ``` 3 / 9 20 / 15 7 ``` Each node\'s two subtrees differ in height by no more than 1. - **Example 2**: The tree is structured as follows: ``` 1 / 2 2 / 3 3 / 4 4 ``` The left subtree of node 2 has a height difference greater than 1. # Performance Requirements Your implementation should efficiently determine the balance status of the binary tree. An optimal solution should have a time complexity of O(n), where n is the number of nodes in the tree. Implement the function `is_balanced` to solve the balanced binary tree validation problem outlined above.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced _, balanced = check_balance(root) return balanced"},{"question":"# Coding Question: Calculate i-Modulus of an Array Given an array of integers, your task is to implement two functions that perform operations based on the modulus of each element with its index (1-based indexing). 1. **Function 1: `modulus_lst(lst: list[int]) -> list[int]`**: * **Input**: A list of integers `lst`. * **Output**: A list of integers where each element is the modulus of the original element by its 1-based index. * **Constraints**: The list has at least one element, and all elements are positive integers. 2. **Function 2: `modulus_summary(lst: list[int]) -> tuple[int, int, float]`**: * **Input**: A list of integers `lst`. * **Output**: A tuple `(count_zero, sum_all, average_all)` where: - `count_zero` is the count of elements in the result of `modulus_lst` that are zero. - `sum_all` is the sum of all elements in the result of `modulus_lst`. - `average_all` is the average value of all elements in the result of `modulus_lst`. # Example ```python # Test case 1 lst = [6, 7, 8, 9] assert modulus_lst(lst) == [0, 1, 2, 1] assert modulus_summary(lst) == (1, 4, 1.0) # Test case 2 lst = [3, 4, 5, 6, 7] assert modulus_lst(lst) == [0, 0, 2, 2, 2] assert modulus_summary(lst) == (2, 6, 1.2) # Test case 3 lst = [10, 20, 30] assert modulus_lst(lst) == [0, 0, 0] assert modulus_summary(lst) == (3, 0, 0.0) ``` # Notes: * The list has at least one element. * Ensure that the output matches the specified format. * Consider edge cases, such as lists with all elements divisible by their indices, and lists where no elements are divisible by their indices.","solution":"def modulus_lst(lst): Returns a list of the modulus of each element with its 1-based index. return [elem % (i + 1) for i, elem in enumerate(lst)] def modulus_summary(lst): Returns a tuple containing the count of zeros, sum of all elements, and average of all elements in the result of modulus_lst. mod_list = modulus_lst(lst) count_zero = sum(1 for x in mod_list if x == 0) sum_all = sum(mod_list) average_all = sum_all / len(mod_list) if mod_list else 0 return count_zero, sum_all, average_all"},{"question":"# Problem Statement: You are responsible for implementing a simple file directory management system. The system should allow you to create directories, add files to directories, and calculate the total size of files within a directory, including all its subdirectories. # Requirements: 1. **Input**: * A series of commands to create directories, add files, and compute directory sizes. 2. **Output**: * For each size calculation command, output the total size of files within the specified directory, including all its subdirectories. # Constraints: * The number of commands will be between 1 and 1000. * Each directory or file name will be non-empty strings with a maximum length of 20 characters. * File sizes will be integers between 1 and 10^6. * The directory structure can form an arbitrary tree but will not contain cycles. # Instructions: 1. Implement a `Directory` class to encapsulate the attributes and behaviors of a directory. 2. Implement a `File` class to encapsulate the attributes and behaviors of a file. 3. Implement a `FileSystem` class to manage directories, files, and their interactions. 4. Write a function `process_commands` that takes a list of commands and processes them according to the rules specified. # Function Signatures: ```python class Directory: def __init__(self, name): pass class File: def __init__(self, name, size): pass class FileSystem: def __init__(self): pass def create_directory(self, path, name): pass def add_file(self, path, name, size): pass def get_directory_size(self, path): pass def process_commands(commands): pass ``` # Example: ```python if __name__ == \\"__main__\\": commands = [ (\\"create_directory\\", \\"root\\", \\"sub1\\"), (\\"create_directory\\", \\"root/sub1\\", \\"sub2\\"), (\\"add_file\\", \\"root\\", \\"file1.txt\\", 100), (\\"add_file\\", \\"root/sub1\\", \\"file2.txt\\", 200), (\\"add_file\\", \\"root/sub1/sub2\\", \\"file3.txt\\", 300), (\\"get_directory_size\\", \\"root\\"), (\\"get_directory_size\\", \\"root/sub1\\"), (\\"get_directory_size\\", \\"root/sub1/sub2\\"), ] results = process_commands(commands) print(results) # [600, 500, 300] ``` Each command will be a tuple where the first element is the command type (\\"create_directory\\", \\"add_file\\", \\"get_directory_size\\") and the subsequent elements are the parameters for that command. Write the `process_commands` function so that it handles the series of commands and returns a list of results for the size calculation commands.","solution":"class Directory: def __init__(self, name): self.name = name self.files = [] self.subdirectories = {} def add_subdirectory(self, subdir): self.subdirectories[subdir.name] = subdir def add_file(self, file): self.files.append(file) def get_size(self): total_size = sum(file.size for file in self.files) for subdir in self.subdirectories.values(): total_size += subdir.get_size() return total_size class File: def __init__(self, name, size): self.name = name self.size = size class FileSystem: def __init__(self): self.root = Directory(\\"root\\") self.directories = {\\"root\\": self.root} def create_directory(self, path, name): parent_dir = self._find_directory(path) new_dir = Directory(name) parent_dir.add_subdirectory(new_dir) self.directories[f\\"{path}/{name}\\"] = new_dir def add_file(self, path, name, size): directory = self._find_directory(path) new_file = File(name, size) directory.add_file(new_file) def get_directory_size(self, path): directory = self._find_directory(path) return directory.get_size() def _find_directory(self, path): return self.directories[path] def process_commands(commands): fs = FileSystem() results = [] for command in commands: if command[0] == \\"create_directory\\": _, path, name = command fs.create_directory(path, name) elif command[0] == \\"add_file\\": _, path, name, size = command fs.add_file(path, name, size) elif command[0] == \\"get_directory_size\\": _, path = command results.append(fs.get_directory_size(path)) return results"},{"question":"# Question Scenario: You have been tasked with enhancing an existing web application\'s search feature. Your team is currently working on optimizing a prefix-based search feature to help users quickly locate item names based on their initial characters. For this, you need to implement a function that filters item names by a given prefix. Task: Write a Python function `filter_by_prefix` that takes a list of item names and a prefix string, then returns a list of names that start with the given prefix. If no names match the prefix, return an empty list. Ensure that the search is case-sensitive. Function Signature: ```python def filter_by_prefix(names: list[str], prefix: str) -> list[str]: ``` Input: - A list of strings, `names` (1 <= len(names) <= 10^4), where each string represents an item name (1 <= len(name) <= 100). - A string, `prefix` representing the prefix to filter by (1 <= len(prefix) <= 100). Output: - A list of strings containing the item names that start with the given prefix. Constraints: - The search should be case-sensitive, meaning \\"Item\\" and \\"item\\" should be considered different. - The input list and prefix will only contain printable ASCII characters. Example Usage: ```python >>> filter_by_prefix([\\"Apple\\", \\"Apricot\\", \\"Banana\\", \\"Blueberry\\", \\"Cherry\\"], \\"Ap\\") [\\"Apple\\", \\"Apricot\\"] >>> filter_by_prefix([\\"Dog\\", \\"Cat\\", \\"Bird\\", \\"Fish\\"], \\"Bi\\") [\\"Bird\\"] >>> filter_by_prefix([\\"Flower\\", \\"Fence\\", \\"Fruit\\", \\"Forest\\"], \\"Fo\\") [\\"Forest\\"] >>> filter_by_prefix([\\"Table\\", \\"Chair\\", \\"Desk\\", \\"Lamp\\"], \\"Ca\\") [] >>> filter_by_prefix([\\"Notebook\\", \\"Notebook Pro\\", \\"Notebook Air\\", \\"Laptop\\", \\"Tablet\\"], \\"Notebook\\") [\\"Notebook\\", \\"Notebook Pro\\", \\"Notebook Air\\"] ``` Remember to ensure your function adheres to typical performance expectations and handles diverse edge cases appropriately.","solution":"def filter_by_prefix(names: list[str], prefix: str) -> list[str]: Filters a list of item names by a given prefix. Args: names (list of str): A list of item names. prefix (str): The prefix to filter by. Returns: list of str: A list of names that start with the given prefix. return [name for name in names if name.startswith(prefix)]"},{"question":"Problem Statement A bank maintains a log of account transactions. Each transaction in the log is represented as a string with the following format: `\\"<transaction_id>:<amount>:<description>\\"`. Your task is to write a function `process_transactions` that takes a list of transaction logs and returns a summary report as a dictionary. The summary should contain the total amount transacted, the highest transaction amount, the lowest transaction amount, and the transaction count. # Input * `transactions` (list of strings): A list of transaction logs with each element in the format `\\"<transaction_id>:<amount>:<description>\\"`. Constraints: (1 leq text{len(transactions)} leq 10^6). # Output * A dictionary with the following keys: - `\\"total_amount\\"`: The sum of all transaction amounts (float). - `\\"highest_amount\\"`: The highest transaction amount (float). - `\\"lowest_amount\\"`: The lowest transaction amount (float). - `\\"transaction_count\\"`: The total number of transactions (integer). # Examples ```python transactions = [ \\"TXN001:100.50:Salary Payment\\", \\"TXN002:250.75:Invoice Payment\\", \\"TXN003:85.20:Refund\\" ] process_transactions(transactions) # Expected output: # { # \\"total_amount\\": 436.45, # \\"highest_amount\\": 250.75, # \\"lowest_amount\\": 85.20, # \\"transaction_count\\": 3 # } transactions = [ \\"TXN001:0:Zero Payment\\", \\"TXN002:0:Zero Again\\" ] process_transactions(transactions) # Expected output: # { # \\"total_amount\\": 0.0, # \\"highest_amount\\": 0.0, # \\"lowest_amount\\": 0.0, # \\"transaction_count\\": 2 # } ``` # Constraints * Each transaction amount is a non-negative float. * Ensure the function can handle large lists of transactions efficiently.","solution":"def process_transactions(transactions): Process a list of transaction logs and return a summary report. Args: transactions (list of str): List of transaction logs in the format \\"<transaction_id>:<amount>:<description>\\". Returns: dict: Summary containing total amount, highest amount, lowest amount, and transaction count. total_amount = 0.0 highest_amount = float(\'-inf\') lowest_amount = float(\'inf\') transaction_count = 0 for transaction in transactions: parts = transaction.split(\\":\\") amount = float(parts[1]) total_amount += amount highest_amount = max(highest_amount, amount) lowest_amount = min(lowest_amount, amount) transaction_count += 1 # Handling case where all transactions have a zero amount. if highest_amount == float(\'-inf\'): highest_amount = 0.0 if lowest_amount == float(\'inf\'): lowest_amount = 0.0 return { \\"total_amount\\": total_amount, \\"highest_amount\\": highest_amount, \\"lowest_amount\\": lowest_amount, \\"transaction_count\\": transaction_count }"},{"question":"# Question: Consider a company where each employee has a unique ID between 1 and N. Every employee has one immediate manager except for the CEO, who has no manager. Each employee, except the CEO, may have multiple direct subordinates. This structure forms a tree where the CEO is the root. Given a list of pairs representing the relationships of employees to their direct manager, write a function `find_ceo(N: int, relationships: List[Tuple[int, int]]) -> int` to identify the CEO\'s ID. # Input and Output: * **Input**: * `N`: (an integer) representing the number of employees (2 <= N <= 10^5) * `relationships`: (a list of tuples) where each tuple (x, y) represents an employee x reporting to manager y. * **Output**: * `int`: the ID of the CEO. # Constraints: * Each employee, except for the CEO, has exactly one direct manager. * The relationships list contains exactly N-1 pairs. # Edge cases to consider: * The CEO has only one direct subordinate. * All employees except the CEO form a direct single line chain of management. # Function Signature: ```python from typing import List, Tuple def find_ceo(N: int, relationships: List[Tuple[int, int]]) -> int: pass ``` # Example: ```python # Example 1 N = 3 relationships = [(2, 1), (3, 1)] print(find_ceo(N, relationships)) # Output: 1 # Example 2 N = 4 relationships = [(2, 1), (3, 2), (4, 2)] print(find_ceo(N, relationships)) # Output: 1 # Example 3 N = 5 relationships = [(2, 3), (3, 4), (4, 5), (1, 5)] print(find_ceo(N, relationships)) # Output: 5 ``` # Solution: Using a set-based approach, determine the employee who is not a subordinate of any other employee, as this employee would be the CEO.","solution":"from typing import List, Tuple def find_ceo(N: int, relationships: List[Tuple[int, int]]) -> int: # Step 1: Create a set for all employees and another set for those who are direct subordinates employees = set(range(1, N+1)) subordinates = set() # Step 2: Populate the subordinates set for emp, mgr in relationships: subordinates.add(emp) # Step 3: The CEO will be the one who is not a subordinate of anyone else ceo = employees - subordinates # Step 4: Convert the set to list and return the first (and only) element return list(ceo)[0]"},{"question":"# Question You are given a dataset stored in a CSV file, and your task is to calculate some statistical values based on the data present in a specific column. The CSV file represents a collection of numerical data and has a header. # Function Specification **Task**: * Write a function `calculate_statistics` that reads a CSV file, extracts the numerical data from a specified column, and calculates the mean, median, and standard deviation. **Functions to Implement**: ```python def calculate_statistics(file_path: str, column_name: str) -> dict: pass ``` **Parameters**: * `file_path` (str): The path to the input CSV file. * `column_name` (str): The name of the column from which the data will be extracted. **Returns**: * A dictionary with the keys \\"mean\\", \\"median\\", and \\"standard_deviation\\" each pointing to their respective calculated values. # Constraints: * Assume the CSV file always exists and is in the correct format. * The specified column will always contain numerical data. * Use external libraries like pandas and numpy to assist with data handling and calculations. * Handle cases where the column might have missing (NaN) values. # Examples: Assuming `file_path` is the path to \\"data.csv\\" and it contains a column named \\"age\\", ```python # Calculate statistics for \'age\' column stats = calculate_statistics(\\"data.csv\\", \\"age\\") print(stats) # Expected output: # { \\"mean\\": 30.5, \\"median\\": 28, \\"standard_deviation\\": 5.2 } ``` # Implementation Notes: * Use `pandas` for reading the CSV file and handling missing values. * Use `numpy` or `pandas` functions to calculate the required statistics. # Performance Considerations: * Ensure the function handles large datasets efficiently. * Use vectorized operations provided by `pandas` and `numpy` to improve performance.","solution":"import pandas as pd import numpy as np def calculate_statistics(file_path: str, column_name: str) -> dict: Reads a CSV file, extracts numerical data from a specified column, and calculates mean, median, and standard deviation. Parameters: file_path (str): The path to the input CSV file. column_name (str): The name of the column from which the data will be extracted. Returns: dict: A dictionary with keys \\"mean\\", \\"median\\", and \\"standard_deviation\\" containing the respective calculated values. # Read the CSV file into a DataFrame df = pd.read_csv(file_path) # Extract the specified column and drop any NA values column_data = df[column_name].dropna() # Calculate the statistics mean_value = column_data.mean() median_value = column_data.median() std_deviation = column_data.std() # Construct the result dictionary result = { \\"mean\\": mean_value, \\"median\\": median_value, \\"standard_deviation\\": std_deviation } return result"},{"question":"# Problem Description You are tasked with enhancing a Linked List by implementing specific additional functionalities. Your goal is to improve the linked list by providing new operations while ensuring efficiency and correctness. # Objectives 1. Implement the `move_last_to_front` method, which moves the last element of the list to the front. 2. Add a feature to remove duplicate values from an unsorted linked list. 3. Introduce a method to reverse the linked list in groups of given size `k`. # Requirements Part 1: `move_last_to_front` * **Function Signature**: `def move_last_to_front(self) -> None:` * **Inputs**: None. * **Outputs**: The linked list with the last element moved to the front. If the list is empty or has only one node, it remains unchanged. Part 2: Duplicate Removal * **Function Signature**: `def remove_duplicates(self) -> None:` * **Inputs**: None. * **Outputs**: The linked list with all duplicates removed, preserving the order of first occurrences. Part 3: Reverse in Groups * **Function Signature**: `def reverse_in_groups(self, k: int) -> None:` * **Inputs**: An integer `k` representing the group size. * **Outputs**: The linked list reversed in groups of size `k`. If the number of nodes in the last group is less than `k`, leave it as is. * **Constraints**: - `k` is a positive integer. - The list can contain any number of nodes including zero. # Input and Output Format ```python # Example for Part 1 ll = LinkedList() ll.append(1, 2, 3, 4, 5) ll.move_last_to_front() print(ll.display()) # Output should be [5, 1, 2, 3, 4] # Example for Part 2 ll = LinkedList() ll.append(1, 2, 3, 2, 4, 3, 5) ll.remove_duplicates() print(ll.display()) # Output should be [1, 2, 3, 4, 5] # Example for Part 3 ll = LinkedList() ll.append(1, 2, 3, 4, 5, 6, 7, 8, 9) ll.reverse_in_groups(3) print(ll.display()) # Output should be [3, 2, 1, 6, 5, 4, 9, 8, 7] ``` Performance and Constraints - Ensure operations are efficient, considering the constraints of linked list manipulations. - Handle edge cases such as empty list, single-node list, and group sizes larger than the list length. # Function Details 1. `move_last_to_front(self) -> None` 2. `remove_duplicates(self) -> None` 3. `reverse_in_groups(self, k: int) -> None` 4. Other necessary functions to facilitate list manipulations (like `append` and `display`). # Scenario Consider a streaming service playlist where users often modify song sequences. You need to frequently update the playlist with new songs, remove repeated tracks to keep diversity, and allow users to reverse the order of songs in chunks for variety. Enhancing the playlist represented by a linked list with these features ensures a dynamic and user-friendly experience, keeping the application responsive and organized.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, *args): for data in args: new_node = Node(data) if not self.head: self.head = new_node else: last = self.head while last.next: last = last.next last.next = new_node def display(self): elements = [] current = self.head while current: elements.append(current.data) current = current.next return elements def move_last_to_front(self): if not self.head or not self.head.next: return second_last = None last = self.head while last.next: second_last = last last = last.next if second_last: second_last.next = None last.next = self.head self.head = last def remove_duplicates(self): if not self.head: return current = self.head seen = set([current.data]) while current and current.next: if current.next.data in seen: current.next = current.next.next else: seen.add(current.next.data) current = current.next def reverse_in_groups(self, k): if not self.head or k <= 1: return def reverse_k_group(head, k): prev = None current = head next_node = None count = 0 while current and count < k: next_node = current.next current.next = prev prev = current current = next_node count += 1 if next_node: head.next = reverse_k_group(next_node, k) return prev self.head = reverse_k_group(self.head, k)"},{"question":"# Problem: Alphabet Shifting Cipher You are provided with a rudimentary cipher algorithm that shifts each letter in the alphabet by a specified number of positions to encode a message. Your task is to create this algorithm and extend its functionality to handle both encoding and decoding based on a given shift value. # Requirements 1. **Input**: - A string `message` which can be a combination of upper-case, lower-case letters, and spaces. - An integer `shift` representing the number of positions each letter in the message should be shifted. The shift can be both positive and negative. - A boolean `encode` where `True` indicates encoding and `False` indicates decoding. 2. **Output**: - A string that represents the encoded or decoded message based on the shift and the encode parameter. # Function Specification Implement a function `shift_cipher(message, shift, encode)` that accepts: - `message`: A string representing the message to be encoded or decoded. - `shift`: An integer representing the shift value. - `encode`: A boolean indicating whether to encode (`True`) or decode (`False`) the message. # Encoding and Decoding Instructions 1. **Character Shifting**: - Shift each letter in the message by the specified number of positions in the alphabet. For encoding, shift forwards, and for decoding, shift backwards. - Handle wrapping around the alphabet (e.g., shifting \'z\' forward by 1 should result in \'a\'). - Maintain case (lower-case letters shift to lower-case letters, upper-case letters shift to upper-case letters). - Spaces should remain unchanged. 2. **Efficiency**: - Ensure the algorithm processes the message in a time-efficient manner, especially for large inputs. # Constraints - The message will only contain alphabetic characters and spaces. - The shift value will be an integer within the range [-25, 25]. # Example ```python shift_cipher(\\"Hello World\\", 3, True) # Output: \\"Khoor Zruog\\" shift_cipher(\\"Khoor Zruog\\", 3, False) # Output: \\"Hello World\\" ``` # Notes 1. **Correctness**: Verify the correctness of your algorithm with both positive and negative shift values. 2. **Robustness**: Make sure your function handles edge cases gracefully, such as an empty string or a shift value at the edge of the constraints.","solution":"def shift_cipher(message, shift, encode): Encode or decode the given message using a shift cipher. Parameters: - message (str): The message to encode or decode. - shift (int): The number of positions to shift the letters. - encode (bool): True to encode, False to decode. Returns: - str: The encoded or decoded message. if not encode: # If decoding, invert the shift shift = -shift def shift_char(c, shift): if \'a\' <= c <= \'z\': # Handle lowercase letters return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': # Handle uppercase letters return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) return c # Non-alphabetic characters remain unchanged return \'\'.join(shift_char(c, shift) for c in message)"},{"question":"# Given Context You are developing a command-line utility that processes server logs. The utility should be able to filter logs based on specified criteria and generate a summary report. The current implementation can read logs from a file and print them to the console. You need to extend the functionality to support filtering logs by date range and log level, and to generate a summary report that counts the number of logs for each log level within the specified date range. # Task 1. Implement the `filter_logs` function to support filtering logs based on a given date range and log level. 2. Implement the `generate_summary` function to produce a summary report of the number of logs for each log level within the specified date range. # Input and Output Formats * **Functions to implement**: * `filter_logs` - Filters logs based on a given date range and log level. * Input: * logs (list of dict): List of log entries, where each log entry is a dictionary with keys `timestamp`, `level`, and `message`. * start_date (str): Start date in the format `YYYY-MM-DD`. * end_date (str): End date in the format `YYYY-MM-DD`. * log_level (str): Log level to filter by (e.g., \\"ERROR\\", \\"WARN\\", \\"INFO\\"). * Output: * filtered_logs (list of dict): List of log entries that match the specified criteria. * `generate_summary` - Generates a summary report of the number of logs for each log level within the specified date range. * Input: * logs (list of dict): List of log entries, where each log entry is a dictionary with keys `timestamp`, `level`, and `message`. * start_date (str): Start date in the format `YYYY-MM-DD`. * end_date (str): End date in the format `YYYY-MM-DD`. * Output: * summary (dict): Dictionary with log levels as keys and counts as values. * **Constraints**: * The `timestamp` key in each log entry is a string in the format `YYYY-MM-DDTHH:MM:SS`. * The `level` key contains the log level, which can be \\"ERROR\\", \\"WARN\\", \\"INFO\\", or \\"DEBUG\\". # Example Scenario Assume you have a list of logs and need to filter them for log entries between \\"2023-01-01\\" and \\"2023-01-31\\" with the log level \\"ERROR\\". After filtering the logs, you need to generate a summary report of the number of logs for each log level within the same date range. # Sample Data ```python logs = [ {\\"timestamp\\": \\"2023-01-01T12:00:00\\", \\"level\\": \\"INFO\\", \\"message\\": \\"Service started\\"}, {\\"timestamp\\": \\"2023-01-02T10:15:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Failed to connect to database\\"}, {\\"timestamp\\": \\"2023-01-03T11:30:00\\", \\"level\\": \\"WARN\\", \\"message\\": \\"High memory usage\\"}, {\\"timestamp\\": \\"2023-02-01T10:25:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Database timeout\\"}, {\\"timestamp\\": \\"2023-01-15T14:00:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Network error\\"}, ] # Filter logs with date range \\"2023-01-01\\" to \\"2023-01-31\\" and level \\"ERROR\\" filtered_logs = filter_logs(logs, \\"2023-01-01\\", \\"2023-01-31\\", \\"ERROR\\") # Generate summary report with date range \\"2023-01-01\\" to \\"2023-01-31\\" summary = generate_summary(logs, \\"2023-01-01\\", \\"2023-01-31\\") ``` # Starter Code ```python from datetime import datetime from typing import List, Dict def filter_logs(logs: List[Dict], start_date: str, end_date: str, log_level: str) -> List[Dict]: Filters logs based on the given date range and log level start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") filtered_logs = [] for log in logs: log_dt = datetime.strptime(log[\\"timestamp\\"], \\"%Y-%m-%dT%H:%M:%S\\") if start_dt <= log_dt <= end_dt and log[\\"level\\"] == log_level: filtered_logs.append(log) return filtered_logs def generate_summary(logs: List[Dict], start_date: str, end_date: str) -> Dict[str, int]: Generates a summary report of the number of logs for each log level start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") summary = {\\"ERROR\\": 0, \\"WARN\\": 0, \\"INFO\\": 0, \\"DEBUG\\": 0} for log in logs: log_dt = datetime.strptime(log[\\"timestamp\\"], \\"%Y-%m-%dT%H:%M:%S\\") if start_dt <= log_dt <= end_dt: summary[log[\\"level\\"]] += 1 return summary ```","solution":"from datetime import datetime from typing import List, Dict def filter_logs(logs: List[Dict], start_date: str, end_date: str, log_level: str) -> List[Dict]: Filters logs based on the given date range and log level start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") filtered_logs = [] for log in logs: log_dt = datetime.strptime(log[\\"timestamp\\"], \\"%Y-%m-%dT%H:%M:%S\\") if start_dt <= log_dt <= end_dt and log[\\"level\\"] == log_level: filtered_logs.append(log) return filtered_logs def generate_summary(logs: List[Dict], start_date: str, end_date: str) -> Dict[str, int]: Generates a summary report of the number of logs for each log level start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") summary = {\\"ERROR\\": 0, \\"WARN\\": 0, \\"INFO\\": 0, \\"DEBUG\\": 0} for log in logs: log_dt = datetime.strptime(log[\\"timestamp\\"], \\"%Y-%m-%dT%H:%M:%S\\") if start_dt <= log_dt <= end_dt: summary[log[\\"level\\"]] += 1 return summary"},{"question":"Question: Implement Custom Linked List You are required to implement a custom singly linked list data structure in Python. This will test your understanding of classes, object-oriented programming, and basic data structures. Implement methods to manage the linked list effectively, ensuring you handle edge cases. # Linked List Operations to Implement 1. **Node Class**: Define a class for the nodes of the linked list. ```python class Node: def __init__(self, value: int): self.value = value self.next = None ``` 2. **LinkedList Class**: Define a class for the linked list with the following methods: 1. **Initialization**: Initializes an empty linked list. ```python def __init__(self): pass ``` 2. **Insert At Head**: Inserts a new node with the given value at the head of the list. ```python def insert_at_head(self, value: int): pass ``` 3. **Insert At Tail**: Inserts a new node with the given value at the tail of the list. ```python def insert_at_tail(self, value: int): pass ``` 4. **Delete Value**: Deletes the first occurrence of a node with the given value. ```python def delete_value(self, value: int): pass ``` 5. **Find**: Returns `True` if a node with the given value is found, `False` otherwise. ```python def find(self, value: int) -> bool: pass ``` 6. **Traversal**: Returns a list of all values in the linked list in order. ```python def traverse(self) -> List[int]: pass ``` # Input & Output Specifications: - Assume all values to be inserted are integers. - If attempting to delete a value that doesn\'t exist, simply do nothing. - If the linked list is empty, traversal should return an empty list. # Example Usage: ```python ll = LinkedList() ll.insert_at_head(1) ll.insert_at_head(2) ll.insert_at_head(3) print(ll.traverse()) # Output: [3, 2, 1] ll.insert_at_tail(4) print(ll.traverse()) # Output: [3, 2, 1, 4] print(ll.find(2)) # Output: True print(ll.find(5)) # Output: False ll.delete_value(2) print(ll.traverse()) # Output: [3, 1, 4] ll.delete_value(5) # No effect ll.insert_at_tail(5) print(ll.traverse()) # Output: [3, 1, 4, 5] ``` # Constraints: - Ensure your implementation maintains efficiency in both time and space. - Consider edge cases such as inserting into an empty list, deleting from an empty list, and finding a value in an empty list. # Performance Requirements: - Your linked list should manage up to 10,000 insertions and deletions efficiently in a reasonable time frame.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert_at_head(self, value: int): new_node = Node(value) new_node.next = self.head self.head = new_node def insert_at_tail(self, value: int): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def delete_value(self, value: int): current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next return prev = current current = current.next def find(self, value: int) -> bool: current = self.head while current: if current.value == value: return True current = current.next return False def traverse(self) -> list: values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"# Question: File Access Tracker Context You are working as a software engineer at a company that needs to monitor the access patterns of different users on various files in their file system. To achieve this, you need to create a system that logs each file access event and allows querying of these logs by filename and by user. Task Implement a class `FileAccessTracker` that tracks file access events. Each event consists of a username and a filename. Requirements 1. **log_access(username: str, filename: str) -> None**: - Logs an access event where a user accesses a file. 2. **get_accesses_by_filename(filename: str) -> List[str]**: - Returns a list of usernames who have accessed the specified file, in the order of their access. 3. **get_accesses_by_user(username: str) -> List[str]**: - Returns a list of filenames accessed by the specified user, in the order of their access. Input Format - `log_access`: A string for the `username` and a string for the `filename`. - `get_accesses_by_filename`: A string for the `filename`. - `get_accesses_by_user`: A string for the `username`. Output Format - `log_access`: No return value. - `get_accesses_by_filename`: A list of strings representing usernames. - `get_accesses_by_user`: A list of strings representing filenames. Constraints - Usernames and filenames are non-empty strings and consist of alphanumeric characters. - There are no restrictions on the number of access events that can be logged. Examples ```python tracker = FileAccessTracker() tracker.log_access(\\"user1\\", \\"fileA\\") tracker.log_access(\\"user2\\", \\"fileA\\") tracker.log_access(\\"user1\\", \\"fileB\\") tracker.log_access(\\"user2\\", \\"fileB\\") tracker.log_access(\\"user3\\", \\"fileA\\") >>> tracker.get_accesses_by_filename(\\"fileA\\") [\'user1\', \'user2\', \'user3\'] >>> tracker.get_accesses_by_filename(\\"fileB\\") [\'user1\', \'user2\'] >>> tracker.get_accesses_by_user(\\"user1\\") [\'fileA\', \'fileB\'] >>> tracker.get_accesses_by_user(\\"user2\\") [\'fileA\', \'fileB\'] >>> tracker.get_accesses_by_user(\\"user3\\") [\'fileA\'] ``` Notes - Each filename and username can appear multiple times in the logs since access events are time-ordered. - Ensure to handle cases when there are no access events yet for a given filename or user gracefully (return an empty list).","solution":"from collections import defaultdict from typing import List class FileAccessTracker: def __init__(self): self.file_access_log = defaultdict(list) self.user_access_log = defaultdict(list) def log_access(self, username: str, filename: str) -> None: self.file_access_log[filename].append(username) self.user_access_log[username].append(filename) def get_accesses_by_filename(self, filename: str) -> List[str]: return self.file_access_log[filename] def get_accesses_by_user(self, username: str) -> List[str]: return self.user_access_log[username]"},{"question":"# Coding Assessment Question: Context: You are tasked with building a basic library management system for a local library. One of the key features of this system is maintaining and updating the records of all books. The system should allow the librarian to add new books, remove books by their identifier, and search for books based on different criteria like title, author, and publication year. Task: Implement a class `Library` that includes methods to manage the book records. Each method should perform specific operations and handle potential errors gracefully. 1. `add_book(book_id, title, author, publication_year)`: Adds a new book to the library records. 2. `remove_book(book_id)`: Removes a book from the library records by its identifier. 3. `search_by_title(title)`: Searches for books by title and returns a list of matching books. 4. `search_by_author(author)`: Searches for books by author and returns a list of matching books. 5. `search_by_year(publication_year)`: Searches for books by publication year and returns a list of matching books. Requirements: 1. Use a dictionary to store book records, where the key is the `book_id` and the value is a dictionary containing `title`, `author`, and `publication_year`. 2. Implement error-handling mechanisms for cases such as trying to remove a non-existent book or searching by criteria that yield no results. 3. Document the methods with appropriate docstrings. Expected Input and Output: **Input**: - Method calls on the `Library` class instance with relevant parameters: - `book_id` (Integer): Unique identifier for the book. - `title` (String): Title of the book. - `author` (String): Author of the book. - `publication_year` (Integer): Year the book was published. **Output**: - Informative console messages about the success or failure of add/remove operations. - Lists of books matching the search criteria. Constraints: - Assume `book_id` is unique for each book. - Methods should handle up to 1000 books efficiently. Example: ```python class Library: def __init__(self): self.records = {} def add_book(self, book_id, title, author, publication_year): if book_id in self.records: print(f\\"Book with ID {book_id} already exists.\\") return self.records[book_id] = { \\"title\\": title, \\"author\\": author, \\"publication_year\\": publication_year } print(f\\"Book \'{title}\' added successfully.\\") def remove_book(self, book_id): if book_id not in self.records: print(f\\"No book found with ID {book_id}.\\") return removed_book = self.records.pop(book_id) print(f\\"Book \'{removed_book[\'title\']}\' removed successfully.\\") def search_by_title(self, title): results = [book for book in self.records.values() if book[\'title\'].lower() == title.lower()] if not results: print(f\\"No books found with title \'{title}\'.\\") return results def search_by_author(self, author): results = [book for book in self.records.values() if book[\'author\'].lower() == author.lower()] if not results: print(f\\"No books found by author \'{author}\'.\\") return results def search_by_year(self, publication_year): results = [book for book in self.records.values() if book[\'publication_year\'] == publication_year] if not results: print(f\\"No books found published in {publication_year}.\\") return results # Example Usage library = Library() library.add_book(1, \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) print(library.search_by_author(\\"Harper Lee\\")) library.remove_book(1) print(library.search_by_year(1951)) ``` Implementation Notes: - Use the `records` dictionary to store book information. - Ensure methods return meaningful messages and handle errors gracefully. - Include appropriate docstrings for each method to describe their functionality clearly.","solution":"class Library: def __init__(self): self.records = {} def add_book(self, book_id, title, author, publication_year): Adds a new book to the library records. :param book_id: Unique identifier for the book. :param title: Title of the book. :param author: Author of the book. :param publication_year: Year the book was published. if book_id in self.records: print(f\\"Book with ID {book_id} already exists.\\") return self.records[book_id] = { \\"title\\": title, \\"author\\": author, \\"publication_year\\": publication_year } print(f\\"Book \'{title}\' added successfully.\\") def remove_book(self, book_id): Removes a book from the library records by its identifier. :param book_id: Unique identifier for the book to be removed. if book_id not in self.records: print(f\\"No book found with ID {book_id}.\\") return removed_book = self.records.pop(book_id) print(f\\"Book \'{removed_book[\'title\']}\' removed successfully.\\") def search_by_title(self, title): Searches for books by title and returns a list of matching books. :param title: Title to search for. :return: List of books with matching title. results = [book for book in self.records.values() if book[\'title\'].lower() == title.lower()] if not results: print(f\\"No books found with title \'{title}\'.\\") return results def search_by_author(self, author): Searches for books by author and returns a list of matching books. :param author: Author to search for. :return: List of books by matching author. results = [book for book in self.records.values() if book[\'author\'].lower() == author.lower()] if not results: print(f\\"No books found by author \'{author}\'.\\") return results def search_by_year(self, publication_year): Searches for books by publication year and returns a list of matching books. :param publication_year: Year to search for. :return: List of books published in the specified year. results = [book for book in self.records.values() if book[\'publication_year\'] == publication_year] if not results: print(f\\"No books found published in {publication_year}.\\") return results"},{"question":"# Coding Assessment Question Context You are building a text processing utility that identifies and counts distinct words in a given paragraph, ignoring case sensitivity and punctuation. Objective Your goal is to write a function that processes a paragraph and returns a dictionary where keys are the unique words found in the text (case-insensitive), and values are the counts of each word. Requirements 1. Implement the function `word_count(paragraph: str) -> dict` which takes a single string as its input and returns a dictionary with words as keys and their counts as values. 2. The function should ignore punctuation and be case-insensitive. 3. Ensure the function handles edge cases, such as empty strings and strings with only punctuation. Constraints * Words are separated by spaces. * Punctuation includes: `. , ; : ! ? ( ) [ ] { } \\" \'` * Ignore case (i.e., \\"Word\\" and \\"word\\" should be counted as the same word). Examples ```python def word_count(paragraph: str) -> dict: # Your implementation here pass # Example usage and results: assert word_count(\\"Hello, hello! How are you?\\") == {\\"hello\\": 2, \\"how\\": 1, \\"are\\": 1, \\"you\\": 1} assert word_count(\\"This is a test. This... is only a test.\\") == {\\"this\\": 2, \\"is\\": 2, \\"a\\": 2, \\"test\\": 2, \\"only\\": 1} assert word_count(\\"\\") == {} assert word_count(\\"Punctuation! Should; be--ignored.\\") == {\\"punctuation\\": 1, \\"should\\": 1, \\"be\\": 1, \\"ignored\\": 1} ``` Notes: * You may use Python\'s built-in string methods and libraries to help with text processing. * Consider how to handle words with embedded punctuation or hyphens, and decide on a consistent rule for your implementation. * Test your function thoroughly to make sure it handles various edge cases.","solution":"import re from collections import defaultdict def word_count(paragraph: str) -> dict: Processes a paragraph and returns a dictionary where keys are the unique words (case-insensitive and punctuation removed) and values are the counts of each word. # Convert to lower case paragraph = paragraph.lower() # Remove punctuation using regular expression paragraph = re.sub(r\'[^ws]\', \'\', paragraph) # Split the paragraph into words words = paragraph.split() # Count the words word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"# Fibonacci Sequence Compression Scenario You are working on an algorithm that compresses sequences to save space while still allowing the reconstruction of certain types of sequences, specifically the Fibonacci sequence. The compression scheme is simple: instead of storing the entire Fibonacci sequence, store just the first two numbers and the length of the sequence. The decompression algorithm should be able to regenerate the original sequence from these parameters. Problem Statement Implement a function, `compress_and_decompress_fibonacci(start1: int, start2: int, length: int) -> list[int]`, that: 1. Takes three parameters: - `start1`: the first number of the Fibonacci sequence. - `start2`: the second number of the Fibonacci sequence. - `length`: the number of terms to generate in the sequence. 2. Compresses this information by storing the values of `start1`, `start2`, and `length`. 3. Decompresses the sequence using these stored values to regenerate the original Fibonacci sequence of the specified length. Input - `start1`: an integer representing the first term of the Fibonacci sequence. - `start2`: an integer representing the second term of the Fibonacci sequence. - `length`: an integer specifying the number of terms to generate in the sequence. Output - A list of integers representing the regenerated Fibonacci sequence of the specified length. Constraints - The function should handle valid inputs for `start1`, `start2`, and `length` (all non-negative integers, with `length` at least 2). Example ```python start1 = 3 start2 = 5 length = 6 result = compress_and_decompress_fibonacci(start1, start2, length) # Expected result: [3, 5, 8, 13, 21, 34] ``` This function should regenerate the Fibonacci sequence starting with 3 and 5, for a length of 6, resulting in [3, 5, 8, 13, 21, 34].","solution":"def compress_and_decompress_fibonacci(start1: int, start2: int, length: int) -> list[int]: Generates a Fibonacci sequence of the specified length starting with start1 and start2. Parameters: - start1: The first number of the Fibonacci sequence. - start2: The second number of the Fibonacci sequence. - length: The number of terms to generate in the sequence. Returns: - A list of integers representing the regenerated Fibonacci sequence of the specified length. if length < 2: raise ValueError(\\"Length should be at least 2.\\") # Initialize the sequence with the first two numbers fibonacci_sequence = [start1, start2] # Generate the rest of the sequence for _ in range(2, length): next_term = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_term) return fibonacci_sequence"},{"question":"# Question: Implement a Consistent Hashing System You are tasked with creating a consistent hashing system to distribute a set of servers evenly across a hash space and support basic operations of adding and removing servers. Your consistent hashing implementation should be responsible for: 1. **Adding** a server to the hash circle. 2. **Removing** a server from the hash circle. 3. **Getting** a server given a specific key using the current hash circle configuration. Class Requirements: `ConsistentHashing` Your class needs to: - Implement a `__init__` function to initialize the hash circle. - Implement an `add_server` function to add a server to the hash circle. - Implement a `remove_server` function to remove a server from the hash circle. - Implement a `get_server` function to return the server corresponding to a given key using the current configuration of the hash circle. # Input: - Each server is represented as a string (e.g., `\\"Server1\\"`, `\\"Server2\\"`, etc.). - The key is represented as a string in the `get_server` function. # Output: - `add_server` and `remove_server` functions will return nothing. - `get_server` will return the server (str) assigned to the given key (str). # Constraints: - Assume there are no duplicate server names. - The hash function you use should be consistent. # Example: ```python ch = ConsistentHashing() ch.add_server(\\"Server1\\") ch.add_server(\\"Server2\\") ch.add_server(\\"Server3\\") assert ch.get_server(\\"my_key_1\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} assert ch.get_server(\\"my_key_2\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} assert ch.get_server(\\"my_key_3\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} ch.remove_server(\\"Server2\\") assert ch.get_server(\\"my_key_1\\") in {\\"Server1\\", \\"Server3\\"} assert ch.get_server(\\"my_key_2\\") in {\\"Server1\\", \\"Server3\\"} assert ch.get_server(\\"my_key_3\\") in {\\"Server1\\", \\"Server3\\"} ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python import hashlib class ConsistentHashing: def __init__(self): self.ring = {} self.servers = set() def add_server(self, server: str) -> None: # Add your solution here pass def remove_server(self, server: str) -> None: # Add your solution here pass def get_server(self, key: str) -> str: # Add your solution here pass def _hash_function(self, key: str) -> int: # Add your solution here to return a consistent hash value return int(hashlib.md5(key.encode()).hexdigest(), 16) # Test your implementation if __name__ == \\"__main__\\": ch = ConsistentHashing() ch.add_server(\\"Server1\\") ch.add_server(\\"Server2\\") ch.add_server(\\"Server3\\") assert ch.get_server(\\"my_key_1\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} assert ch.get_server(\\"my_key_2\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} assert ch.get_server(\\"my_key_3\\") in {\\"Server1\\", \\"Server2\\", \\"Server3\\"} ch.remove_server(\\"Server2\\") assert ch.get_server(\\"my_key_1\\") in {\\"Server1\\", \\"Server3\\"} assert ch.get_server(\\"my_key_2\\") in {\\"Server1\\", \\"Server3\\"} assert ch.get_server(\\"my_key_3\\") in {\\"Server1\\", \\"Server3\\"} ```","solution":"import hashlib from bisect import bisect_right, insort class ConsistentHashing: def __init__(self): self.ring = [] self.nodes = {} def add_server(self, server: str) -> None: hash_val = self._hash_function(server) if hash_val not in self.nodes: self.nodes[hash_val] = server insort(self.ring, hash_val) def remove_server(self, server: str) -> None: hash_val = self._hash_function(server) if hash_val in self.nodes: self.ring.remove(hash_val) del self.nodes[hash_val] def get_server(self, key: str) -> str: if not self.ring: raise Exception(\\"No servers in the ring\\") hash_val = self._hash_function(key) idx = bisect_right(self.ring, hash_val) % len(self.ring) return self.nodes[self.ring[idx]] def _hash_function(self, key: str) -> int: return int(hashlib.md5(key.encode()).hexdigest(), 16)"},{"question":"# Coding Assessment Question: Palindrome Substrings Finder Context You\'ve been working on a string manipulation library that includes various utility functions such as reversing strings, finding substrings, and determining the longest common prefix. For your next task, you need to implement a function that identifies all distinct palindromic substrings within a given string. A palindrome is a string that reads the same backward as forward. Identifying palindromic substrings is useful in various applications such as DNA sequence analysis, text data mining, and cryptography. Task Implement a function within the provided `StringUtil` class to find all distinct palindromic substrings in a given string. Function Signature ```python def find_palindromic_substrings(self, s: str) -> List[str]: Returns a list of all distinct palindromic substrings in the input string. Args: s (str): The input string to analyze. Returns: List[str]: A list of distinct palindromic substrings. ``` Input - `s` (str): A string consisting of lower case alphabets. Output - A list of strings representing all distinct palindromic substrings found in the input string. Constraints - The function must handle strings up to a length of 1,000 characters. - The list should not contain duplicate palindromic substrings. Example ```python # Example 1 s1 = \\"abba\\" string_util = StringUtil() print(string_util.find_palindromic_substrings(s1)) # Expected output: [\\"a\\", \\"b\\", \\"bb\\", \\"abba\\"] # Example 2 s2 = \\"racecar\\" print(string_util.find_palindromic_substrings(s2)) # Expected output: [\\"a\\", \\"c\\", \\"r\\", \\"e\\", \\"cec\\", \\"aceca\\", \\"racecar\\"] # Example 3 s3 = \\"abc\\" print(string_util.find_palindromic_substrings(s3)) # Expected output: [\\"a\\", \\"b\\", \\"c\\"] ``` Additional Notes - Ensure that your function efficiently identifies palindromic substrings, as suboptimal solutions may lead to performance issues for long strings. - The order of substrings in the output list does not matter. - Utilize appropriate data structures to store and recognize distinct palindromic substrings.","solution":"class StringUtil: def find_palindromic_substrings(self, s: str): Returns a list of all distinct palindromic substrings in the input string. Args: s (str): The input string to analyze. Returns: list: A list of distinct palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return list(palindromes)"},{"question":"# Problem Statement Newton\'s second law of motion states that the acceleration of an object is directly proportional to the net force acting upon the object and inversely proportional to the object\'s mass. This principle is foundational in classical mechanics. Task Your task is to write a function `newtons_second_law` that calculates the acceleration of an object based on the provided force and mass. You must also handle and raise appropriate exceptions for invalid inputs. Function Signature ```python def newtons_second_law(force: float, mass: float) -> float: ``` Input * `force` (float): The net force acting on the object in Newtons (N). Can be any real number. * `mass` (float): The mass of the object in kilograms (kg). Must be greater than 0. Output * Returns a float representing the acceleration in meters per second squared (m/s^2). Constraints * If `mass` is less than or equal to 0, raise a `ValueError` with the message \\"Impossible mass\\". Performance Requirements * The function should run efficiently with a time complexity of O(1). * Ensure validation checks are in place and handle error scenarios accordingly. Example Usage ```python >>> newtons_second_law(force=10, mass=5) 2.0 >>> newtons_second_law(force=-20, mass=4) -5.0 >>> newtons_second_law(force=0, mass=2) 0.0 >>> newtons_second_law(force=15, mass=0) Traceback (most recent call last): ... ValueError: Impossible mass >>> newtons_second_law(force=15, mass=-3) Traceback (most recent call last): ... ValueError: Impossible mass ``` Notes - Ensure your function provides correct results and handles all edge cases effectively. - You can assume valid floating-point accuracy for the force and mass values.","solution":"def newtons_second_law(force: float, mass: float) -> float: Calculates the acceleration of an object based on the provided force and mass. Parameters: force (float): The net force acting on the object in Newtons (N). mass (float): The mass of the object in kilograms (kg). Must be greater than 0. Returns: float: The acceleration in meters per second squared (m/s^2). Raises: ValueError: If mass is less than or equal to 0. if mass <= 0: raise ValueError(\\"Impossible mass\\") acceleration = force / mass return acceleration"},{"question":"# Problem Statement You are given a 2D matrix `mat` of size `n x m` consisting of only 0s and 1s, where `1` represents land and `0` represents water. An island is defined as a group of 1s connected horizontally or vertically. Write a program to identify the number of distinct islands in the matrix. # Function Specifications 1. **`num_islands(mat: list[list[int]]) -> int`**: This function takes a 2D matrix `mat` as input and returns the number of distinct islands. # Input/Output Specifications - Input: - `mat`: A 2D list of integers (0s and 1s) representing the map of water and land. - Output: - Return an integer representing the number of distinct islands. # Constraints - ( 1 leq n, m leq 300 ) - `mat[i][j]` is either `0` or `1`. # Example ```python mat1 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] print(num_islands(mat1)) # Output: 3 mat2 = [ [1, 1, 0, 1], [1, 0, 0, 0], [0, 0, 1, 1], [0, 1, 1, 0] ] print(num_islands(mat2)) # Output: 3 mat3 = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] print(num_islands(mat3)) # Output: 0 ``` # Task You need to implement the function `num_islands` to correctly compute the number of distinct islands within the given 2D matrix based on the specifications and constraints mentioned above.","solution":"def num_islands(mat): Returns the number of distinct islands in the 2D matrix mat. An island is defined as a group of 1s connected horizontally or vertically. if not mat: return 0 n = len(mat) m = len(mat[0]) visited = [[False for _ in range(m)] for _ in range(n)] def dfs(x, y): # Check boundaries if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or mat[x][y] == 0: return # Mark current cell as visited visited[x][y] = True # Explore neighbors dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands = 0 for i in range(n): for j in range(m): if mat[i][j] == 1 and not visited[i][j]: dfs(i, j) islands += 1 return islands"},{"question":"# Algorithmic Problem: Water Trapping Objective Develop a function `trap_water(height: List[int]) -> int` to calculate the total amount of water that can be trapped between the bars after raining. Expected Input and Output Formats * **Input**: * A list `height` of non-negative integers where each element represents the height of a bar. * **Output**: * An integer representing the total amount of water that can be trapped between the bars. Constraints and Limitations * The list `height` can be of variable length ranging from 0 to (10^4). * Each element in `height` is non-negative and will not exceed (10^5). Performance Requirements * Ensure the solution is efficient in terms of time and space complexity, potentially employing linear time and constant space strategies. Scenario Consider a histogram where the width of each bar is 1. Given an input list where each element is the height of a bar, your task is to compute how much water can be trapped if it rains. This problem is significant in arenas such as geographical water capture analysis or architectural design. # Function Requirements The function should implement the following steps: 1. Determine the left and right maximum heights for each bar. 2. Calculate the amount of water trapped at each bar by comparing the lesser of the two maximums and the height of the bar itself. 3. Sum these values to get the total trapped water. Implement the `trap_water` function considering the above requirements: ```python from typing import List def trap_water(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped # Example Usage if __name__ == \\"__main__\\": height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_water(height)) # Output: 6 ``` The `trap_water` function ensures that the solution is computationally efficient and adheres to the constraints set forth.","solution":"from typing import List def trap_water(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"# Coding Assessment Question **Context**: You are tasked with enriching a software application for tracking users\' activities. One of the requirements is to implement a function that processes logs of users\' online and offline times to calculate total active time for each user in a given period. The logs are provided as a list of events, where each event includes a user ID, a timestamp, and an action (`login` or `logout`). # Task Your task is to implement a function that calculates the total active time for each user given the event logs. **Specifications**: 1. Implement the function `calculate_active_times(logs)` that calculates the total active time for each user. - Parameters: * `logs`: A list of tuples, where each tuple contains three elements: `user_id` (an integer), `timestamp` (an integer representing minutes since day start), and `action` (a string, either \'login\' or \'logout\'). - Returns: A dictionary where keys are user IDs and values are total active times (in minutes) for each user. - Constraints: * The logs list contains at least one entry. * Each `login` action for a given user is always followed by a corresponding `logout` action before another `login` action for the same user. * User IDs are unique integers. * Timestamps are non-negative integers representing minutes since the beginning of the day. **Steps**: 1. Traverse the logs to calculate the accumulated active time for each user. 2. Store the active times in a dictionary, where each key is a user ID and the corresponding value is the total active time in minutes. **Example**: ```python logs = [ (1, 30, \'login\'), (2, 35, \'login\'), (1, 90, \'logout\'), (1, 100, \'login\'), (2, 120, \'logout\'), (1, 200, \'logout\') ] calculate_active_times(logs) # Expected output: {1: 160, 2: 85} # Explanation: # User 1 was active from minute 30 to 90 (60 minutes) and from minute 100 to 200 (100 minutes), totaling 160 minutes. # User 2 was active from minute 35 to 120 (85 minutes). ``` **Note**: - Consider handling any edge cases where user login/logout times coincide or are very close in time. - Ensure efficient processing to handle large log lists within reasonable time constraints.","solution":"def calculate_active_times(logs): Calculate total active times for each user based on login and logout event logs. Parameters: logs (list of tuples): List where each tuple contains (user_id, timestamp, action) Returns: dict: Dictionary where keys are user IDs and values are their total active times in minutes. active_times = {} login_times = {} for user_id, timestamp, action in logs: if action == \'login\': login_times[user_id] = timestamp elif action == \'logout\': if user_id in login_times: active_time = timestamp - login_times.pop(user_id, 0) if user_id in active_times: active_times[user_id] += active_time else: active_times[user_id] = active_time return active_times"},{"question":"# Coding Assessment Question: Maximum Subarray with Target Sum Problem Statement: You are given an array of integers `nums` and an integer `target`. Your task is to find the length of the longest contiguous subarray within `nums` that sums up to a given `target`. If no such subarray exists, return `0`. Function Signature: ```python def max_length_subarray_with_target(nums: List[int], target: int) -> int: Find the length of the longest contiguous subarray within nums that sums up to target. ``` Constraints: 1. The array `nums` contains at least one element and at most `10^5` elements. 2. Each element in `nums` is an integer. 3. The target `target` is an integer. Example: 1. Input: `nums = [1, -1, 5, -2, 3]`, `target = 3` Output: `4` Explanation: The subarray `[1, -1, 5, -2]` sums to `3` and its length is `4`. 2. Input: `nums = [-2, -1, 2, 1]`, `target = 1` Output: `2` Explanation: The subarray `[-1, 2, 1]` sums to `1` and its length is `2`, but the longest subarray is `[-2, -1, 2, 1]` and its length is `4`. 3. Input: `nums = [1, 2, 3, 4, 5]`, `target = 15` Output: `5` Explanation: The entire array sums to `15` and its length is `5`. Notes: - Consider using a sliding window or a hashmap to efficiently solve the problem. - Ensure the solution handles both positive and negative integers in the array. Evaluation criteria: - Correctness: The algorithm should correctly return the length of the longest subarray for various inputs. - Efficiency: Solution should be optimized for a large number of elements. - Edge Cases: Proper handling of edge cases such as single-element arrays and arrays with no valid subarray.","solution":"from typing import List def max_length_subarray_with_target(nums: List[int], target: int) -> int: Finds the length of the longest contiguous subarray within nums that sums up to target. sum_dict = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target: max_length = i + 1 if (current_sum - target) in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - target]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length"},{"question":"```markdown # Problem Statement You are tasked with creating a function that takes an integer input `n` representing the number of levels of Pascal\'s Triangle, and returns the flattened list of all numbers in the triangle up to that level. Pascal\'s Triangle is a triangular array of the binomial coefficients. # Function Signature ```python def pascals_triangle(n: int) -> List[int]: ``` # Input - An integer `n` representing the number of levels of Pascal\'s Triangle. - Constraints: `1 <= n <= 30` # Output - A list of integers representing the flattened Pascal\'s Triangle up to the given level. # Example ```python assert pascals_triangle(3) == [1, 1, 1, 1, 2, 1] assert pascals_triangle(4) == [1, 1, 1, 1, 2, 1, 1, 3, 3, 1] assert pascals_triangle(1) == [1] assert pascals_triangle(5) == [1, 1, 1, 1, 2, 1, 1, 3, 3, 1, 1, 4, 6, 4, 1] ``` # Constraints - The function should be optimized for both time and space complexity considering the input constraints. # Notes - Pascal\'s Triangle starts with a single `1` at the top. - Each number in a level of Pascal\'s Triangle is the sum of the two directly above it. - Handle large values efficiently by pre-calculating the triangle up to the required level. # Edge Cases - Ensure the function returns the correct level of Pascal\'s Triangle for the minimum input value of `1`. - Consider the constraints and avoid unnecessary computations or excessive memory usage. ```","solution":"from typing import List def pascals_triangle(n: int) -> List[int]: if n == 1: return [1] # Initialize the first row of Pascal\'s Triangle triangle = [[1]] for i in range(1, n): row = [1] # Start each row with a 1 # Fill middle entries with sum of two directly above entries for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) # End each row with a 1 triangle.append(row) # Flatten the triangle into a single list flattened_list = [num for row in triangle for num in row] return flattened_list"},{"question":"# Problem Statement Write a function `balance_parentheses(expression)` that checks if a mathematical expression has balanced parentheses. # Input * `expression`: A string representing a mathematical expression containing various types of parentheses: `()`, `{}`, `[]`. The string may also contain other characters, but we only care about parentheses. # Output * Return `True` if the parentheses in the expression are balanced, otherwise return `False`. # Example ```python print(balance_parentheses(\\"a + b * (c / d)\\")) # Output should be True print(balance_parentheses(\\"[a + {b * (c / d)}]\\")) # Output should be True print(balance_parentheses(\\"a + b * (c / d\\")) # Output should be False print(balance_parentheses(\\"[a + {b * (c / d)])\\")) # Output should be False ``` # Constraints and Notes * The function should correctly identify matching pairs of all three types of parentheses: `()`, `{}`, `[]`. * It should return `False` for mismatched, unclosed, or improperly nested parentheses. * Ignore non-parenthesis characters when checking for balance. * Aim to traverse the string as few times as possible to ensure efficiency. # Performance * Your solution should handle expressions of up to several thousands of characters efficiently. Implement your solution in Python: ```python def balance_parentheses(expression): stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in \'({[\': stack.append(char) elif char in \')}]\': if not stack or stack[-1] != matching_parentheses[char]: return False stack.pop() return not stack # Example usage print(balance_parentheses(\\"a + b * (c / d)\\")) # Output should be True print(balance_parentheses(\\"[a + {b * (c / d)}]\\")) # Output should be True print(balance_parentheses(\\"a + b * (c / d\\")) # Output should be False print(balance_parentheses(\\"[a + {b * (c / d)])\\")) # Output should be False ``` This question tests understanding of using stacks for managing nested structures and ensuring correctness of paired symbols in strings.","solution":"def balance_parentheses(expression): stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in \'({[\': stack.append(char) elif char in \')}]\': if not stack or stack[-1] != matching_parentheses[char]: return False stack.pop() return not stack"},{"question":"# Duplicate Removal in a List **Context**: In a scenario where you are tasked with data processing, an essential step may involve removing duplicate entries from a list to ensure data integrity and effective analysis. For this task, you need to implement a functionality that removes duplicates from a list while preserving the order of the first occurrences. **Task**: Implement the function `remove_duplicates(input_list: List[int]) -> List[int]` that removes duplicate integers from a list while preserving the order of first occurrences. **Function Signature**: ```python def remove_duplicates(input_list: List[int]) -> List[int]: ``` **Input**: - `input_list` (List[int]): A list of integers which may contain duplicates. The elements are not sorted. **Output**: - (List[int]): A list of integers with duplicates removed, maintaining the original order of the first occurrence. **Constraints**: - The input_list can have a mix of positive and negative integers. - The integers in the list range between `-1,000` to `1,000`. - The length of the input list is between `0` and `10,000`. **Examples**: ```python assert remove_duplicates([1, 2, 2, 3, 4, 4, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert remove_duplicates([7, 7, 8, 9, 10, 10, 7]) == [7, 8, 9, 10] assert remove_duplicates([1, -1, 2, 2, -1, -1, 3]) == [1, -1, 2, 3] assert remove_duplicates([]) == [] ``` **Additional Notes**: 1. **Use auxiliary data structures** such as sets or dictionaries to track the presence of elements efficiently. 2. Ensure that the order of first appearances is preserved. 3. The implementation should be able to handle large input sizes efficiently.","solution":"from typing import List def remove_duplicates(input_list: List[int]) -> List[int]: Removes duplicates from the input list while preserving the order of the first occurrence. Parameters: input_list (List[int]): A list of integers which may contain duplicates. Returns: List[int]: A list of integers with duplicates removed, maintaining the original order of the first occurrence. seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"Coding Assessment Question # Context You are developing a text analysis tool that needs to quickly identify the most frequent words in a given text. To achieve this, you decide to implement a Trie data structure that enables efficient storage and retrieval of words. # Task Implement a Trie (prefix tree) with functions to insert words and find the most frequent word. # Function Specifications **Function 1: Insert Words** - **Function Name**: `insert_word` - **Input**: - The root of the Trie (`root: TrieNode`). - A single word (`word: str`). - **Output**: None **Function 2: Find Most Frequent Word** - **Function Name**: `find_most_frequent_word` - **Input**: The root of the Trie (`root: TrieNode`). - **Output**: The most frequent word (`str`). # TrieNode Class Specifications - **Class Name**: `TrieNode` - **Attributes**: - `children`: A dictionary mapping characters to `TrieNode` objects. - `end_of_word`: A boolean indicating the end of a word. - `frequency`: An integer indicating how many times the word ends here. - **Methods**: - `__init__(self)`: Initializes a TrieNode object. # Constraints - Each word contains only lowercase English alphabets. - The input texts can be large, so efficiency is crucial. # Performance Requirements - The `insert_word` function should aim for linear time complexity relative to the length of the word. - The `find_most_frequent_word` function should aim for linear time complexity relative to the total number of Trie nodes. # Example Usage ```python class TrieNode: def __init__(self): self.children = {} self.end_of_word = False self.frequency = 0 def insert_word(root, word): current = root for character in word: if character not in current.children: current.children[character] = TrieNode() current = current.children[character] current.end_of_word = True current.frequency += 1 def find_most_frequent_word(root): most_frequent_word = \'\' highest_frequency = 0 def dfs(node, path): nonlocal most_frequent_word, highest_frequency if node.end_of_word and node.frequency > highest_frequency: most_frequent_word = path highest_frequency = node.frequency for char, next_node in node.children.items(): dfs(next_node, path + char) dfs(root, \'\') return most_frequent_word # Example usage root = TrieNode() words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"] for word in words: insert_word(root, word) most_frequent = find_most_frequent_word(root) print(most_frequent) # Expected output: \\"apple\\" ``` # Notes - Ensure that your Trie implementation handles repeated insertions correctly. - Carefully manage memory usage, especially with large texts. Ensure to handle edge cases such as inserting an empty string or finding the most frequent word in an empty Trie.","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False self.frequency = 0 def insert_word(root, word): current = root for character in word: if character not in current.children: current.children[character] = TrieNode() current = current.children[character] current.end_of_word = True current.frequency += 1 def find_most_frequent_word(root): most_frequent_word = \'\' highest_frequency = 0 def dfs(node, path): nonlocal most_frequent_word, highest_frequency if node.end_of_word and node.frequency > highest_frequency: most_frequent_word = path highest_frequency = node.frequency for char, next_node in node.children.items(): dfs(next_node, path + char) dfs(root, \'\') return most_frequent_word"},{"question":"Binary Search Tree (BST) Level-Order Traversal Context: You are tasked with enhancing a Binary Search Tree (BST) utility by adding level-order traversal functionality. In a level-order traversal, nodes are visited level by level, from left to right. Task: Implement a `bst_level_order_traversal` function that performs a level-order traversal on a given BST and returns the values of the nodes in the traversal order. Function Signature: ```python def bst_level_order_traversal(root) -> list: pass ``` Input and Output: - **Input**: The root node of a binary search tree. - **Output**: A list of values representing the level-order traversal of the tree. Constraints: - The BST nodes have the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - The tree can be empty (i.e., the root is `None`). - Each node contains a unique integer value. Performance Requirements: - The algorithm should visit each node exactly once, ensuring an O(n) time complexity where n is the number of nodes. - Extra space usage should be minimal and should ideally be proportional to the breadth of the tree (number of nodes per level). Examples: 1. For the BST represented by the array `[3, 9, 20, None, None, 15, 7]`: ``` 3 / 9 20 / 15 7 ``` `bst_level_order_traversal(root)` should return `[3, 9, 20, 15, 7]`. 2. For the BST represented by the array `[1, 2, 3, 4, 5, 6, 7]`: ``` 1 / 2 3 / / 4 5 6 7 ``` `bst_level_order_traversal(root)` should return `[1, 2, 3, 4, 5, 6, 7]`. 3. For an empty BST (`root=None`): `bst_level_order_traversal(root)` should return `[]`. Notes: - Consider using a queue data structure to facilitate the level-order traversal. - Handle edge cases such as an empty tree by returning an empty list.","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def bst_level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"Problem Statement You are working on a flight scheduling system where you need to manage flight routes between airports. The flight routes are represented as a directed, weighted graph. Your task is to implement a class representing this graph and a function to find the shortest path from a source airport to a destination airport using Dijkstra\'s algorithm. The algorithm should efficiently identify the shortest path from the source to all other airports and return the distances and the paths taken. # Function Signature ```python def dijkstra_algo(graph: GraphDirectedWeighted[str], start: str, end: str) -> tuple[dict[str, int], dict[str, list[str]]]: ``` # Class `GraphDirectedWeighted` Implement the necessary methods for the `GraphDirectedWeighted` class: * `add_airport(airport: str) -> None`: Adds an airport to the graph. * `add_route(airport1: str, airport2: str, distance: int) -> None`: Adds a directed route between two airports with a given distance. # Requirements 1. **Graph Representation**: * The graph is directed and weighted. * Use an adjacency list for representing the graph. 2. **Dijkstra\'s Algorithm**: * Use a min-heap-based priority queue for selecting the minimal distance node efficiently. * Keep track of the shortest distance from the start airport to each airport. * Keep track of the path taken to reach each airport. 3. **Output**: * Return a tuple with two dictionaries: - `distances`: Keys are the airports, and values are the shortest distances from the start airport to that airport. - `paths`: Keys are the airports, and values are lists of airports representing the path from the start airport to that airport. # Example ```python graph = GraphDirectedWeighted() graph.add_route(\\"JFK\\", \\"LAX\\", 3000) graph.add_route(\\"JFK\\", \\"ATL\\", 800) graph.add_route(\\"ATL\\", \\"LAX\\", 2100) graph.add_route(\\"ATL\\", \\"ORD\\", 600) graph.add_route(\\"LAX\\", \\"ORD\\", 2000) graph.add_route(\\"ORD\\", \\"DFW\\", 900) distances, paths = dijkstra_algo(graph, \\"JFK\\", \\"ORD\\") # Expect: # distances = {\\"JFK\\": 0, \\"LAX\\": 2900, \\"ATL\\": 800, \\"ORD\\": 1400, \\"DFW\\": 2300} # paths = {\\"JFK\\": [\\"JFK\\"], \\"LAX\\": [\\"JFK\\", \\"ATL\\", \\"LAX\\"], \\"ATL\\": [\\"JFK\\", \\"ATL\\"], \\"ORD\\": [\\"JFK\\", \\"ATL\\", \\"ORD\\"], \\"DFW\\": [\\"JFK\\", \\"ATL\\", \\"ORD\\", \\"DFW\\"]} ``` # Constraints * The number of airports in the graph is between 1 and 1000. * The distances of the routes are positive integers not exceeding 10,000. * The graph may contain loops and multiple routes between the same two airports. * Handle disconnected parts of the graph by returning the distances as infinity and the paths as empty lists for unreachable airports.","solution":"import heapq from collections import defaultdict, deque from typing import List, Dict, Tuple class GraphDirectedWeighted: def __init__(self): self.graph = defaultdict(list) def add_airport(self, airport: str) -> None: if airport not in self.graph: self.graph[airport] = [] def add_route(self, airport1: str, airport2: str, distance: int) -> None: self.graph[airport1].append((airport2, distance)) def dijkstra_algo(graph: GraphDirectedWeighted, start: str, end: str) -> Tuple[Dict[str, int], Dict[str, List[str]]]: pq = [] heapq.heappush(pq, (0, start)) distances = {airport: float(\'inf\') for airport in graph.graph} previous = {airport: None for airport in graph.graph} distances[start] = 0 while pq: current_distance, current_airport = heapq.heappop(pq) if current_distance > distances[current_airport]: continue for neighbor, weight in graph.graph[current_airport]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous[neighbor] = current_airport heapq.heappush(pq, (distance, neighbor)) paths = {airport: [] for airport in graph.graph} for airport in graph.graph: if distances[airport] == float(\'inf\'): continue path = [] current = airport while current: path.append(current) current = previous[current] path.reverse() paths[airport] = path return distances, paths"},{"question":"# Problem Statement You are given a list of integers representing the temperatures recorded over a week in a non-linear sequence. Your task is to implement a function that uses a stack data structure to find and return the list of the next day\'s warmer temperatures for each day. **Function Signature:** ```python def next_warmer_temperatures(temperatures: list[int]) -> list[int]: ``` **Input:** * `temperatures` (List[int]): A list of integers where each integer represents the temperature recorded on a specific day. **Output:** * List[int]: A list of integers where each element represents the number of days you have to wait until a warmer temperature. If there is no future day with a warmer temperature, the value should be 0 for that day. # Requirements: * Implement the function to use a stack to keep track of indices. * Efficiently find the next warmer temperature for each day. * Handle cases where the list has no days with warmer temperatures ahead. # Constraints: * The length of the list will be between 1 and 1000. * The temperature values will be between -50 and 100. # Performance: The algorithm should aim for a time complexity of O(n) and use space efficiently with O(n) due to the stack. # Example: ```python temperatures = [73, 74, 75, 71, 69, 72, 76, 73] print(next_warmer_temperatures(temperatures)) # Output: [1, 1, 4, 2, 1, 1, 0, 0] temperatures = [30, 40, 50, 60] print(next_warmer_temperatures(temperatures)) # Output: [1, 1, 1, 0] temperatures = [30, 20, 10, 5] print(next_warmer_temperatures(temperatures)) # Output: [0, 0, 0, 0] ``` # Additional Information * Ensure that your function handles both positive and negative temperatures correctly. * It is acceptable for the function to use in-built Python data structures like lists to mimic stack behavior.","solution":"def next_warmer_temperatures(temperatures: list[int]) -> list[int]: Returns a list of days to wait for a warmer temperature for each day in the temperatures list. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() result[idx] = i - idx stack.append(i) return result"},{"question":"# Problem Statement Implement a class `WordSearcher` for managing a list of words and efficiently supporting the following operations: 1. **Initialization**: Construct the class with an initial list of words. 2. **Add Word**: Add a new word to the list. 3. **Search Word**: Check if a word exists in the list. 4. **Find Words with Prefix**: Retrieve all words in the list that start with a given prefix. # Function Signatures ```python class WordSearcher: def __init__(self, words: list[str]) -> None: Initializes the word searcher with the given list of words. def add_word(self, word: str) -> None: Adds a new word to the list. def search_word(self, word: str) -> bool: Checks if the word exists in the list. def find_words_with_prefix(self, prefix: str) -> list[str]: Returns a list of words that start with the given prefix. ``` # Input Constraints - The input list of words and the new words added will have lengths between `1` and `100,000`. - Each word will consist of lowercase English letters and will have a length between `1` and `100`. - The number of queries (add/search/prefix) will be up to `10^5`. # Example Usage ```python # Initialize the word searcher ws = WordSearcher([\\"apple\\", \\"apply\\", \\"banana\\", \\"applet\\"]) # Search for a word in the list print(ws.search_word(\\"apple\\")) # Output: True # Add a new word to the list ws.add_word(\\"apricot\\") # Search for a newly added word print(ws.search_word(\\"apricot\\")) # Output: True # Find words with prefix print(ws.find_words_with_prefix(\\"app\\")) # Output: [\'apple\', \'apply\', \'applet\'] # Find words with another prefix print(ws.find_words_with_prefix(\\"ban\\")) # Output: [\'banana\'] ``` # Constraints - The implementation must handle edge cases such as an empty initial list of words. - The operations should be optimized for efficient querying especially when the list of words grows large. - Consider the case-sensitivity in searching and matching prefixes. All words are lowercase by constraint.","solution":"class WordSearcher: def __init__(self, words: list[str]) -> None: Initializes the word searcher with the given list of words. self.words = set(words) def add_word(self, word: str) -> None: Adds a new word to the list. self.words.add(word) def search_word(self, word: str) -> bool: Checks if the word exists in the list. return word in self.words def find_words_with_prefix(self, prefix: str) -> list[str]: Returns a list of words that start with the given prefix. return [word for word in self.words if word.startswith(prefix)]"},{"question":"# Question: Find the K-th Largest Element in a Binary Search Tree You are tasked with finding the k-th largest element in a Binary Search Tree (BST). Given a BST and an integer k, your job is to implement a function that returns the k-th largest element in the BST. 1. **Function Implementation**: - `kth_largest_element_in_bst(root: TreeNode, k: int) -> int`: Compute the k-th largest element in the given BST. 2. **Input and Output Formats**: - Input: The input consists of a binary search tree (BST) and an integer k. - The binary search tree is represented by its root node. - The value of k is such that 1 ≤ k ≤ number of nodes in the BST. - Output: A single integer which is the k-th largest element in the BST. 3. **Constraints**: - The binary search tree contains unique values. - The binary search tree is well-formed with respect to the BST property. - The number of nodes in the tree will be between 1 and 1000. 4. **Example Tree and Function Call Example**: ``` 5 / 3 7 / / 2 4 6 8 ``` ```python root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) root.right.right = TreeNode(8) print(kth_largest_element_in_bst(root, 3)) # Output: 6 print(kth_largest_element_in_bst(root, 1)) # Output: 8 print(kth_largest_element_in_bst(root, 5)) # Output: 4 ``` 5. **Edge Cases**: - The BST has only one node. - k is equal to the number of nodes in the tree, which means the smallest value should be returned. # Requirements Your implementation will be evaluated based on: - Correctness of the returned k-th largest element. - Efficiency in traversing the tree to find the k-th largest element. - Proper use of the properties of a binary search tree to optimize the search. # Submission Submit your implementation of the `kth_largest_element_in_bst` function. Ensure to include edge case handling and consider the performance requirements specified. **Note**: The TreeNode class definition is provided below for your reference. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest_element_in_bst(root: TreeNode, k: int) -> int: Computes the k-th largest element in the given BST. Parameters: root (TreeNode): The root of the binary search tree. k (int): The k-th largest element to find. Returns: int: The k-th largest element. # We use reverse in-order traversal (right-root-left) to get elements in descending order def reverse_inorder_traversal(node): if node is None: return [] return reverse_inorder_traversal(node.right) + [node.val] + reverse_inorder_traversal(node.left) ordered_elements = reverse_inorder_traversal(root) return ordered_elements[k-1]"},{"question":"# Advanced Problem: Efficient URL Shortening Service Scenario You are tasked with implementing a URL shortening service similar to bit.ly. The service should take a long URL and shorten it to a shorter, more manageable form, while also providing functionality to retrieve the original URL from the shortened version. # Problem Statement Write a Python class `URLShortener` that provides methods to shorten a URL and to retrieve the original URL from the shortened version. Requirements: 1. **Class Definition**: - Implement a class `URLShortener` with the following methods: - `shorten(self, long_url: str) -> str`: Takes a long URL as input and returns a shortened URL. - `retrieve(self, short_url: str) -> str`: Takes a shortened URL as input and returns the original long URL. 2. **Functional Constraints**: - The service should generate unique shortened URLs. - Ensure that the shortened URL is significantly smaller in length than the original URL. - Implement a mechanism to handle the persistence and retrieval of shortened URLs (e.g., using an in-memory dictionary). 3. **Optimization**: - Minimize the overhead in generating and storing shortened URLs. - Ensure efficient retrieval of the original URL from the shortened form. Example: ```python url_shortener = URLShortener() short_url = url_shortener.shorten(\\"https://www.example.com/some/very/long/url\\") print(short_url) # Should print a shortened version of the URL original_url = url_shortener.retrieve(short_url) print(original_url) # Should print the original long URL: \\"https://www.example.com/some/very/long/url\\" ``` # Additional Notes: - Consider edge cases such as shortening the same URL multiple times. - Ensure proper error handling for invalid inputs. - Handle scenarios where a shortened URL does not exist in the system. - Implement a robust and collision-resistant mechanism for generating the shortened URLs.","solution":"import hashlib class URLShortener: def __init__(self): self.url_map = {} self.short_to_long = {} self.base_url = \\"http://short.url/\\" def shorten(self, long_url: str) -> str: if long_url in self.url_map: return self.base_url + self.url_map[long_url] # Creating a unique hash for the long URL url_hash = hashlib.md5(long_url.encode()).hexdigest()[:6] short_url = self.base_url + url_hash self.url_map[long_url] = url_hash self.short_to_long[url_hash] = long_url return short_url def retrieve(self, short_url: str) -> str: key = short_url.replace(self.base_url, \\"\\") if key in self.short_to_long: return self.short_to_long[key] else: return None"},{"question":"# Problem Statement: You are tasked with implementing a function to solve a system of linear equations using the Gauss-Seidel iterative method. The Gauss-Seidel method is an iterative technique for solving a square system of linear equations. # Requirements: 1. Implement a method `gauss_seidel` which takes the following parameters: - `a`: A 2D list or numpy array representing the coefficient matrix ( A ). - `b`: A list or numpy array representing the right-hand side vector ( b ). - `initial_guess`: A list or numpy array representing the initial guess for the solution vector ( x ). - `tolerance`: A float representing the tolerance for convergence. The iteration should stop when the maximum difference between successive iterations is less than this tolerance. - `max_iterations`: An integer representing the maximum number of iterations to perform if convergence is not reached earlier. 2. The function should iteratively solve for ( x ) by updating each element of the solution vector using the Gauss-Seidel formula. 3. If the system does not converge within the maximum number of iterations specified, raise an appropriate exception. # Constraints: - **Input Validation**: Ensure that the input matrix ( A ) is square and that the dimensions of ( A ) and ( b ) are compatible. - **Performance**: Implement the solution efficiently, making sure to handle the maximum number of iterations constraint. # Function Signature: ```python def gauss_seidel( a: Union[list[list[float]], np.ndarray], b: Union[list[float], np.ndarray], initial_guess: Union[list[float], np.ndarray], tolerance: float, max_iterations: int ) -> np.ndarray: pass ``` # Example: ```python a = [ [4, 1, 2], [3, 5, 1], [1, 1, 3] ] b = [4, 7, 3] initial_guess = [0, 0, 0] tolerance = 1e-5 max_iterations = 100 result = gauss_seidel(a, b, initial_guess, tolerance, max_iterations) print(result) # Output should be the solution vector [x1, x2, x3] ``` # Note: - Utilize numpy for matrix operations if necessary but ensure the essence of the Gauss-Seidel iterative process is preserved. - Implement thorough input validation and handle edge cases appropriately to prevent runtime errors. - Document each step within your function to clarify the process for solving the system iteratively.","solution":"import numpy as np def gauss_seidel(a, b, initial_guess, tolerance, max_iterations): Solves the system of linear equations Ax = b using the Gauss-Seidel iterative method. Parameters: a : list of list of floats or np.ndarray The coefficient matrix A (must be square). b : list of floats or np.ndarray The right-hand side vector b. initial_guess : list of floats or np.ndarray The initial guess for the solution vector x. tolerance : float The tolerance for convergence. max_iterations : int The maximum number of iterations to perform. Returns: np.ndarray The solution vector x. Raises: ValueError If the input matrix or vectors have incompatible dimensions. RuntimeError If the method does not converge within the maximum number of iterations. a = np.array(a, dtype=float) b = np.array(b, dtype=float) x = np.array(initial_guess, dtype=float) n = len(b) if a.shape[0] != a.shape[1]: raise ValueError(\\"Coefficient matrix \'a\' must be square.\\") if len(b) != a.shape[0]: raise ValueError(\\"Vector \'b\' must be the same length as the dimensions of \'a\'.\\") if len(x) != len(b): raise ValueError(\\"Initial guess \'x\' must be the same length as vector \'b\'.\\") for iteration in range(max_iterations): x_new = np.copy(x) for i in range(n): sum1 = np.dot(a[i, :i], x_new[:i]) sum2 = np.dot(a[i, i+1:], x[i+1:]) x_new[i] = (b[i] - (sum1 + sum2)) / a[i, i] # Check for convergence if np.allclose(x, x_new, atol=tolerance, rtol=0): return x_new x = x_new raise RuntimeError(\\"Gauss-Seidel method did not converge within the maximum number of iterations\\") # Example usage: a = [ [4, 1, 2], [3, 5, 1], [1, 1, 3] ] b = [4, 7, 3] initial_guess = [0, 0, 0] tolerance = 1e-5 max_iterations = 100 result = gauss_seidel(a, b, initial_guess, tolerance, max_iterations) print(result) # Output should be the solution vector [x1, x2, x3]"},{"question":"# Car Fuel Efficiency Calculation Problem You are tasked with developing a system to analyze car journeys and their fuel efficiency. Your system should be capable of calculating the total fuel consumed during a journey and predicting future fuel consumption based on the efficiency of the car and distance traveled. **Task**: Write two functions: 1. `total_fuel_consumed(distance_traveled: float, fuel_efficiency: float) -> float` 2. `predict_fuel_needed(distance: float, fuel_efficiency: float) -> float` Each function must: 1. Calculate the amount of fuel required or consumed based on the given inputs. 2. Raise a `ValueError` if the input distance or fuel efficiency is zero or negative: - `\\"Invalid inputs. Distance and fuel efficiency must be positive values.\\"` 3. Assume fuel efficiency is given in kilometers per liter (km/L). # Function Descriptions and Examples 1. **total_fuel_consumed** - **Input**: - `distance_traveled` (float): distance traveled in kilometers. - `fuel_efficiency` (float): fuel efficiency of the car in km/L. - **Output**: - Returns the total fuel consumed (float) in liters. - **Examples**: ```python from math import isclose assert isclose(total_fuel_consumed(100.0, 10.0), 10.0) assert isclose(total_fuel_consumed(350.0, 7.0), 50.0) ``` 2. **predict_fuel_needed** - **Input**: - `distance` (float): distance to be traveled in kilometers. - `fuel_efficiency` (float): fuel efficiency of the car in km/L. - **Output**: - Returns the predicted fuel needed (float) in liters. - **Examples**: ```python from math import isclose assert isclose(predict_fuel_needed(500.0, 20.0), 25.0) assert isclose(predict_fuel_needed(200.0, 15.0), 13.333333333333334) ``` Ensure that the functions raise appropriate errors for invalid inputs as described above.","solution":"def total_fuel_consumed(distance_traveled: float, fuel_efficiency: float) -> float: Calculate the total fuel consumed based on the distance traveled and fuel efficiency. :param distance_traveled: float - Distance traveled in kilometers. :param fuel_efficiency: float - Fuel efficiency in km/L. :return: float - Total fuel consumed in liters. :raises ValueError: if distance_traveled or fuel_efficiency is zero or negative. if distance_traveled <= 0 or fuel_efficiency <= 0: raise ValueError(\\"Invalid inputs. Distance and fuel efficiency must be positive values.\\") return distance_traveled / fuel_efficiency def predict_fuel_needed(distance: float, fuel_efficiency: float) -> float: Predict the fuel needed based on the distance and fuel efficiency. :param distance: float - Distance to be traveled in kilometers. :param fuel_efficiency: float - Fuel efficiency in km/L. :return: float - Predicted fuel needed in liters. :raises ValueError: if distance or fuel_efficiency is zero or negative. if distance <= 0 or fuel_efficiency <= 0: raise ValueError(\\"Invalid inputs. Distance and fuel efficiency must be positive values.\\") return distance / fuel_efficiency"},{"question":"# Question: Event Brite - Booking Management System Scenario You are working for an event management platform called \\"Event Brite.\\" The platform needs to manage users\' bookings for various events. Each user can book multiple events, and each event can have multiple users. You have to implement a booking management system to efficiently track which users have booked which events and generate various reports. Task Create a class `EventBrite` that manages the event bookings. This class should include methods to add users, add events, book events for users, and generate reports on bookings. Implement and document the following methods: 1. `add_user(user_id: int, user_name: str) -> Union[str, None]`: Adds a user to the system. 2. `add_event(event_id: int, event_name: str) -> Union[str, None]`: Adds an event to the system. 3. `book_event(user_id: int, event_id: int) -> str`: Books an event for a specified user. 4. `get_user_bookings(user_id: int) -> Union[str, List[str]]`: Generates a list of event names that a specified user has booked. 5. `get_event_bookings(event_id: int) -> Union[str, List[str]]`: Generates a list of user names that have booked a specified event. # Input and Output add_user * **Input**: An integer `user_id` and a string `user_name` representing the user\'s ID and name. * **Output**: Returns `None` if the user is added successfully, or an error message if the user ID already exists. add_event * **Input**: An integer `event_id` and a string `event_name` representing the event\'s ID and name. * **Output**: Returns `None` if the event is added successfully, or an error message if the event ID already exists. book_event * **Input**: An integer `user_id` and an integer `event_id`. * **Output**: Returns a message string indicating whether the booking was successful or if there was an error (user or event not found). get_user_bookings * **Input**: An integer `user_id`. * **Output**: Returns a list of event names the user has booked, or an error message if the user is not found. get_event_bookings * **Input**: An integer `event_id`. * **Output**: Returns a list of user names who have booked the event, or an error message if the event is not found. # Example Inputs and Outputs ```python event_brite = EventBrite() # Adding users print(event_brite.add_user(1, \\"Alice\\")) # Expected: None print(event_brite.add_user(1, \\"Bob\\")) # Expected: \\"User ID already exists\\" # Adding events print(event_brite.add_event(101, \\"Python Conference\\")) # Expected: None print(event_brite.add_event(101, \\"AI Workshop\\")) # Expected: \\"Event ID already exists\\" # Booking events print(event_brite.book_event(1, 101)) # Expected: \\"Booking successful\\" print(event_brite.book_event(2, 101)) # Expected: \\"User ID not found\\" print(event_brite.book_event(1, 103)) # Expected: \\"Event ID not found\\" # User bookings print(event_brite.get_user_bookings(1)) # Expected: [\\"Python Conference\\"] print(event_brite.get_user_bookings(2)) # Expected: \\"User ID not found\\" # Event bookings print(event_brite.get_event_bookings(101)) # Expected: [\\"Alice\\"] print(event_brite.get_event_bookings(103)) # Expected: \\"Event ID not found\\" ``` # Constraints * User IDs and Event IDs must be unique integers. * User names and Event names must be non-empty strings. * Limit the number of users and events to 1000. # Requirements - Implement error handling for adding duplicate users/events and booking non-existent users/events. - Ensure the system handles multiple bookings accurately. - Provide clear and comprehensive documentation for each method, including examples of their usage.","solution":"from typing import Union, List class EventBrite: def __init__(self): self.users = {} # user_id: user_name self.events = {} # event_id: event_name self.bookings = {} # user_id: list of event_ids def add_user(self, user_id: int, user_name: str) -> Union[str, None]: if user_id in self.users: return \\"User ID already exists\\" self.users[user_id] = user_name self.bookings[user_id] = [] return None def add_event(self, event_id: int, event_name: str) -> Union[str, None]: if event_id in self.events: return \\"Event ID already exists\\" self.events[event_id] = event_name return None def book_event(self, user_id: int, event_id: int) -> str: if user_id not in self.users: return \\"User ID not found\\" if event_id not in self.events: return \\"Event ID not found\\" if event_id not in self.bookings[user_id]: self.bookings[user_id].append(event_id) return \\"Booking successful\\" def get_user_bookings(self, user_id: int) -> Union[str, List[str]]: if user_id not in self.users: return \\"User ID not found\\" return [self.events[event_id] for event_id in self.bookings[user_id]] def get_event_bookings(self, event_id: int) -> Union[str, List[str]]: if event_id not in self.events: return \\"Event ID not found\\" return [self.users[user_id] for user_id, events in self.bookings.items() if event_id in events]"},{"question":"# Question: Efficient Pairwise Sum Check for Target Value Background In this task, you will write a function to determine if there are any two distinct integers in a given list that sum up to a specified target value. Given a list of integers and a target sum, your function will return `True` if such a pair exists and `False` otherwise. The solution should be efficient enough to handle large lists. Function Signature ```python def has_pair_with_sum(numbers: list[int], target: int) -> bool: Checks if there are two distinct integers in the list that add up to the target value. Returns True if such a pair exists, otherwise False. ``` Input - `numbers`: A list of integers where each integer can be positive, negative, or zero. - `target`: An integer representing the target sum value. Constraints: - The length of `numbers` will not exceed (10^5). - Each element in the `numbers` list will be between (-10^9) and (10^9). Output * `True` if there are two distinct integers in the list that sum up to the target value. * `False` otherwise. Example Usage ```python print(has_pair_with_sum([2, 7, 11, 15], 9)) # Output: True (2 + 7 = 9) print(has_pair_with_sum([1, 2, 3, 4, 5], 10)) # Output: False print(has_pair_with_sum([-1, -2, -3, -4, -5], -8)) # Output: True (-3 + -5 = -8) print(has_pair_with_sum([0, 1, 2], 1)) # Output: True (0 + 1 = 1) ``` Notes * Implement the function with an optimal approach to handle large lists efficiently. * Ensure that your code handles edge cases such as an empty list or a list that does not contain any valid pair.","solution":"def has_pair_with_sum(numbers, target): Checks if there are two distinct integers in the list that add up to the target value. Returns True if such a pair exists, otherwise False. seen_numbers = set() for number in numbers: complement = target - number if complement in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"# Coding Assessment Question Objective: Implement a function to perform matrix rotation by 90 degrees clockwise. The function must handle square matrices of varying sizes and ensure optimal time and space complexity. Problem Statement: You are given a square matrix represented as a list of lists. Your task is to implement a function that rotates the matrix 90 degrees clockwise. Function Signature: ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Args: matrix: A square matrix represented as a list of lists. Returns: A new matrix representing the input matrix rotated by 90 degrees clockwise. ``` Inputs: - matrix: A list of lists where each sub-list represents a row of a square matrix. (1 <= len(matrix) <= 15, 1 <= len(matrix[0]) <= 15) Outputs: - A list of lists representing the matrix rotated 90 degrees clockwise. Constraints: - The matrix will only contain integers. - The matrix is guaranteed to be square. Example: ```python # Example 1: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2: matrix = [ [1, 2], [3, 4] ] # Output: # [ # [3, 1], # [4, 2] # ] ``` Note: 1. The original matrix must not be modified during the process. 2. Consider both time and space complexity to ensure the function can handle the upper-limit size efficiently. 3. Utilize appropriate built-in functions and libraries to achieve the desired result in a neat and readable manner.","solution":"def rotate_matrix(matrix): Rotates a given square matrix by 90 degrees clockwise. Args: matrix: A square matrix represented as a list of lists. Returns: A new matrix representing the input matrix rotated by 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Problem Statement: Given an undirected graph represented as an edge list, write a function `find_connected_components(edges: List[Tuple[int, int]], n: int) -> List[Set[int]]` that finds all the connected components in the graph. # Input: * `edges`: A list of tuples, where each tuple `(a, b)` represents an undirected edge between nodes `a` and `b`. * `n`: An integer representing the number of nodes in the graph, labeled from `0` to `n-1`. # Output: * Returns a list of sets, where each set contains the nodes that form a connected component. # Example: ```python >>> find_connected_components([(0, 1), (1, 2), (3, 4)], 5) [{0, 1, 2}, {3, 4}] >>> find_connected_components([(0, 1), (2, 3), (3, 4)], 5) [{0, 1}, {2, 3, 4}] ``` # Constraints: * The graph can have up to 10^4 vertices and edges in total. * The graph contains only non-negative integers as vertices. # Requirements: * Your function should run efficiently for large inputs. * Ensure that your solution handles cases with isolated nodes appropriately. # Points to Consider: * Think about how to traverse the graph to identify connected components. * How would you handle scenarios where some nodes have no edges? * Consider testing your function with graphs that have varying numbers of nodes and edges, including edge cases with no edges or fully connected graphs. # Note: You can define helper functions if needed, but the main function to be evaluated should be `find_connected_components`.","solution":"from typing import List, Tuple, Set from collections import defaultdict, deque def find_connected_components(edges: List[Tuple[int, int]], n: int) -> List[Set[int]]: def bfs(node, visited, adj_list): queue = deque([node]) component = set([node]) visited.add(node) while queue: curr = queue.popleft() for neighbor in adj_list[curr]: if neighbor not in visited: visited.add(neighbor) component.add(neighbor) queue.append(neighbor) return component adj_list = defaultdict(list) for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) visited = set() components = [] for node in range(n): if node not in visited: component = bfs(node, visited, adj_list) components.append(component) return components"},{"question":"# Reverse a Doubly Linked List Context: You are working as a developer at a software company. One of the data structures you frequently work with is a doubly linked list. A common operation on doubly linked lists is reversing the order of nodes. Your task is to implement this operation efficiently. Task: Write a function `reverse_doubly_linked_list` that takes in the head of a doubly linked list and returns the new head after reversing the list. # Function Signature ```python class Node: def __init__(self, data: int): self.data = data self.next = None self.prev = None def reverse_doubly_linked_list(head: Node) -> Node: ``` # Parameters: * `head` (Node): The head node of the doubly linked list. The node has attributes `data`, `next`, and `prev`. # Returns: * The new head node of the reversed doubly linked list. # Constraints: 1. The input list may be empty (head is None), in which case the function should return None. 2. Duplicate values are allowed. 3. Nodes should only be moved by changing their `next` and `prev` pointers, not by changing their `data`. # Examples: ```python # Example 1 node1 = Node(1) node2 = Node(2) node3 = Node(3) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 new_head = reverse_doubly_linked_list(node1) # The new head should be node3 with the following structure: # node3 <-> node2 <-> node1 # Example 2 node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 node3.next = node4 node4.prev = node3 new_head = reverse_doubly_linked_list(node1) # The new head should be node4 with the following structure: # node4 <-> node3 <-> node2 <-> node1 ``` # Note: Your function should handle various edge cases including a singly node list and a None (empty list) input.","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None self.prev = None def reverse_doubly_linked_list(head: Node) -> Node: if not head: return None current = head new_head = None while current: prev_node = current.prev next_node = current.next current.next = prev_node current.prev = next_node new_head = current current = next_node return new_head"},{"question":"# Coding Challenge Context/Scenario You are required to write a function to determine the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm. The Euclidean algorithm is based on the principle that the greatest common divisor of two numbers does not change if the larger number is replaced by its difference with the smaller number. Function Signature Create a function `gcd`: ```python def gcd(a: int, b: int) -> int: Given two non-negative integers a and b, return their greatest common divisor (GCD). ``` Expected Input and Output Formats * **Input**: - `a (int)`: A non-negative integer [(0 ≤ a ≤ 10^9)]. - `b (int)`: A non-negative integer [(0 ≤ b ≤ 10^9)]. * **Output**: - `int`: The greatest common divisor of the two numbers. Constraints and Limitations - If both `a` and `b` are 0, return 0 since the GCD is undefined, but treat it as a special case returning zero. Performance Requirements - The function should run in logarithmic time O(log(min(a, b))). Example ```python >>> gcd(48, 18) 6 >>> gcd(0, 5) 5 >>> gcd(7, 0) 7 >>> gcd(0, 0) 0 >>> gcd(9, 28) 1 ```","solution":"def gcd(a, b): Given two non-negative integers a and b, return their greatest common divisor (GCD) using the Euclidean algorithm. while b: a, b = b, a % b return a"},{"question":"# Question: Design an Inventory Tracking System for Online Retail **Scenario**: You are developing an online retail system to manage the inventory of products. Your task is to write a Python class that tracks the stock levels, sales, and restocking events for various products. This system should handle typical events gracefully and ensure that stock levels cannot drop below zero. **Class to Implement**: Implement the class `Inventory` that includes methods to add new products, sell products, and restock products. The class should also provide functions to get the current stock level of a product and handle invalid operations sensibly by raising appropriate errors. **Class Methods**: 1. `add_product(product_name: str, initial_stock: int) -> None`: Adds a new product with an initial stock level. 2. `sell_product(product_name: str, quantity: int) -> None`: Sells a specified quantity of a product, reducing its stock. 3. `restock_product(product_name: str, quantity: int) -> None`: Restocks a specified quantity of a product, increasing its stock. 4. `get_stock(product_name: str) -> int`: Returns the current stock level of a product. **Requirements**: 1. A new product cannot be added if it already exists. 2. Selling a product cannot reduce its stock below zero. 3. Restocking or selling a product that does not exist should raise an error. 4. All quantities must be positive integers. Invalid quantities should raise an error. **Input**: - Strings for product names. - Positive integers for stock quantities. **Output**: - Methods either modify the inventory or return the stock levels. - Errors should be raised with appropriate error messages when operations are invalid. **Constraints**: - Use appropriate exception handling for invalid operations. - Ensure the efficiency and performance of the inventory system. **Example Cases**: ```python >>> inventory = Inventory() >>> inventory.add_product(\\"Laptop\\", 50) >>> inventory.add_product(\\"Phone\\", 30) >>> inventory.get_stock(\\"Laptop\\") 50 >>> inventory.sell_product(\\"Laptop\\", 20) >>> inventory.get_stock(\\"Laptop\\") 30 >>> inventory.restock_product(\\"Laptop\\", 10) >>> inventory.get_stock(\\"Laptop\\") 40 >>> inventory.sell_product(\\"Laptop\\", 50) Traceback (most recent call last): ... ValueError: Insufficient stock for product \'Laptop\' >>> inventory.get_stock(\\"Tablet\\") Traceback (most recent call last): ... KeyError: Product \'Tablet\' does not exist >>> inventory.sell_product(\\"Laptop\\", 0) Traceback (most recent call last): ... ValueError: Quantity must be a positive integer >>> inventory.add_product(\\"Laptop\\", 10) Traceback (most recent call last): ... ValueError: Product \'Laptop\' already exists ``` **Class Template**: ```python class Inventory: def __init__(self): Initialize the inventory with an empty dictionary to hold product stock levels. self.products = {} def add_product(self, product_name: str, initial_stock: int) -> None: Add a new product with the specified initial stock level. :param product_name: Name of the product to add :param initial_stock: Initial stock level of the product :raises ValueError: If the product already exists or initial_stock is not a positive integer if product_name in self.products: raise ValueError(f\\"Product \'{product_name}\' already exists\\") if not isinstance(initial_stock, int) or initial_stock <= 0: raise ValueError(\\"Initial stock must be a positive integer\\") self.products[product_name] = initial_stock def sell_product(self, product_name: str, quantity: int) -> None: Sell a specified quantity of a product. :param product_name: Name of the product to sell :param quantity: Quantity to sell :raises KeyError: If the product does not exist :raises ValueError: If the quantity is not a positive integer or not enough stock if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if self.products[product_name] < quantity: raise ValueError(f\\"Insufficient stock for product \'{product_name}\'\\") self.products[product_name] -= quantity def restock_product(self, product_name: str, quantity: int) -> None: Restock a specified quantity of a product. :param product_name: Name of the product to restock :param quantity: Quantity to restock :raises KeyError: If the product does not exist :raises ValueError: If the quantity is not a positive integer if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") self.products[product_name] += quantity def get_stock(self, product_name: str) -> int: Get the current stock level of a product. :param product_name: Name of the product :return: Current stock level of the product :raises KeyError: If the product does not exist if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") return self.products[product_name] if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"class Inventory: def __init__(self): Initialize the inventory with an empty dictionary to hold product stock levels. self.products = {} def add_product(self, product_name: str, initial_stock: int) -> None: Add a new product with the specified initial stock level. :param product_name: Name of the product to add :param initial_stock: Initial stock level of the product :raises ValueError: If the product already exists or initial_stock is not a positive integer if product_name in self.products: raise ValueError(f\\"Product \'{product_name}\' already exists\\") if not isinstance(initial_stock, int) or initial_stock <= 0: raise ValueError(\\"Initial stock must be a positive integer\\") self.products[product_name] = initial_stock def sell_product(self, product_name: str, quantity: int) -> None: Sell a specified quantity of a product. :param product_name: Name of the product to sell :param quantity: Quantity to sell :raises KeyError: If the product does not exist :raises ValueError: If the quantity is not a positive integer or not enough stock if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") if self.products[product_name] < quantity: raise ValueError(f\\"Insufficient stock for product \'{product_name}\'\\") self.products[product_name] -= quantity def restock_product(self, product_name: str, quantity: int) -> None: Restock a specified quantity of a product. :param product_name: Name of the product to restock :param quantity: Quantity to restock :raises KeyError: If the product does not exist :raises ValueError: If the quantity is not a positive integer if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") if not isinstance(quantity, int) or quantity <= 0: raise ValueError(\\"Quantity must be a positive integer\\") self.products[product_name] += quantity def get_stock(self, product_name: str) -> int: Get the current stock level of a product. :param product_name: Name of the product :return: Current stock level of the product :raises KeyError: If the product does not exist if product_name not in self.products: raise KeyError(f\\"Product \'{product_name}\' does not exist\\") return self.products[product_name]"},{"question":"# Prime Anagram **Problem Description**: A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Two numbers are considered anagrams of each other if they contain the exact same digits in a different order. For example, `213` and `231` are anagrams of `123`. Your task is to find the smallest prime number which, when its digits are rearranged, includes another prime number. In other words, among all prime numbers, you need to return the smallest one such that one or more of its permutations is also a prime number. **Your Task**: Write a function named `find_smallest_prime_anagram() -> int` that returns the smallest prime number which has at least one prime number anagram. **Function Signature**: ```python def find_smallest_prime_anagram() -> int: pass ``` **Input**: * There are no direct inputs to this function, but it must internally manage to compute with prime numbers efficiently. **Output**: * Returns an integer representing the smallest prime number which has at least one other prime anagram. **Examples**: ```python find_smallest_prime_anagram() # Returns 13 (because 31 is also a prime) ``` **Constraints**: * Consider primes up to 10^5 to find the smallest anagram prime. **Hints**: 1. Use a prime generating function (such as the Sieve of Eratosthenes) to find primes up to a certain range. 2. Implement a function to check if the permutations of a number are prime. 3. Utilize efficient permutation and prime checking techniques to ensure your solution runs within a reasonable time frame.","solution":"from itertools import permutations def sieve_of_eratosthenes(limit): sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False primes = [] for num in range(2, limit + 1): if sieve[num]: primes.append(num) for multiple in range(num*num, limit + 1, num): sieve[multiple] = False return primes def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_smallest_prime_anagram(): limit = 100000 primes = sieve_of_eratosthenes(limit) prime_set = set(primes) for prime in primes: prime_str = str(prime) perms = set(map(lambda x: int(\'\'.join(x)), permutations(prime_str))) for perm in perms: if perm != prime and perm in prime_set: return prime print(find_smallest_prime_anagram())"},{"question":"# Coding Assessment Question: Implement a Stack with Minimum Element Retrieval Context: You are tasked with extending the functionality of a basic stack by adding a feature that allows retrieval of the minimum element in constant time. Task: Implement a `MinStack` class with the following methods: 1. `push(value: int) -> None`: Push an integer value onto the stack. 2. `pop() -> int`: Remove and return the top value of the stack. 3. `top() -> int`: Return the top value without removing it. 4. `get_min() -> int`: Return the minimum value in the stack. Expected Behavior: - Pushing values should add them to the stack. - Popping values should remove and return the top element. - `top` should return the current top element without removing it. - `get_min` should return the minimum value in the stack in O(1) time. Input and Output Formats: * `push(value: int)`: * **Input**: An integer value to be pushed onto the stack. * **Output**: None. * `pop()`: * **Input**: None. * **Output**: The integer value removed from the top of the stack. * `top()`: * **Input**: None. * **Output**: The integer value currently at the top of the stack. * `get_min()`: * **Input**: None. * **Output**: The minimum integer value in the stack. Constraints: 1. All integer values passed to `push` will be non-negative. 2. The `pop` and `top` operations should raise an exception if the stack is empty. 3. The stack will never exceed a size of 10^5 elements. 4. Use an additional stack to keep track of the minimum values to achieve O(1) time complexity for `get_min`. Performance Requirements: - The `push`, `pop`, `top`, and `get_min` operations must all run in O(1) time. Complete the method definitions in the class `MinStack`: ```python class MinStack: def __init__(self): self.__stack = [] self.__min_stack = [] def push(self, value: int) -> None: Push new element onto the stack self.__stack.append(value) if not self.__min_stack or value <= self.__min_stack[-1]: self.__min_stack.append(value) def pop(self) -> int: Remove the top element off the stack if not self.__stack: raise IndexError(\'pop from empty stack\') value = self.__stack.pop() if value == self.__min_stack[-1]: self.__min_stack.pop() return value def top(self) -> int: Return the top element of the stack if not self.__stack: raise IndexError(\'top from empty stack\') return self.__stack[-1] def get_min(self) -> int: Return the minimum element in the stack if not self.__min_stack: raise IndexError(\'get_min from empty stack\') return self.__min_stack[-1] # Example: # min_stack = MinStack() # min_stack.push(5) # min_stack.push(3) # min_stack.push(8) # print(min_stack.get_min()) # 3 # min_stack.pop() # print(min_stack.get_min()) # 3 # min_stack.pop() # print(min_stack.get_min()) # 5 # print(min_stack.top()) # 5 ```","solution":"class MinStack: def __init__(self): self.__stack = [] self.__min_stack = [] def push(self, value: int) -> None: Push new element onto the stack self.__stack.append(value) if not self.__min_stack or value <= self.__min_stack[-1]: self.__min_stack.append(value) def pop(self) -> int: Remove the top element off the stack if not self.__stack: raise IndexError(\'pop from empty stack\') value = self.__stack.pop() if value == self.__min_stack[-1]: self.__min_stack.pop() return value def top(self) -> int: Return the top element of the stack if not self.__stack: raise IndexError(\'top from empty stack\') return self.__stack[-1] def get_min(self) -> int: Return the minimum element in the stack if not self.__min_stack: raise IndexError(\'get_min from empty stack\') return self.__min_stack[-1]"},{"question":"# Problem Statement You are given two sorted singly linked lists. Write a function `merge_sorted_lists`, which takes the heads of these two linked lists as arguments and returns the head of a new linked list that is the result of merging the two input lists in sorted order. Input - `head1`: The head of the first singly linked list. - `head2`: The head of the second singly linked list. Output - The head of a new singly linked list, which is a sorted merge of the two input lists. Constraints - The nodes of the singly linked list will contain integer values such that `-1000 <= node.val <= 1000`. - The provided linked lists may have different lengths, and they are not empty. Definition for singly linked list node: ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` Example ```python # Input: 1st linked list: 1 -> 3 -> 5 # 2nd linked list: 2 -> 4 -> 6 # Output: Merged linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 # Input: 1st linked list: 1 -> 2 -> 4 # 2nd linked list: 1 -> 3 -> 5 # Output: Merged linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 5 def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: dummy = ListNode(0) current = dummy while head1 and head2: if head1.val < head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next if head1: current.next = head1 if head2: current.next = head2 return dummy.next ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: dummy = ListNode(0) current = dummy while head1 and head2: if head1.val < head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next if head1: current.next = head1 if head2: current.next = head2 return dummy.next"},{"question":"# Question: Cyclically Rotate an Array Write a function that cyclically rotates an array by one position to the right. Input * A list of integers `arr`. * The length of the list `n`. Output * A list of integers representing the array after one cyclic rotation to the right. # Constraints * `1 <= n <= 10^5` * `-10^9 <= arr[i] <= 10^9` # Requirements * Ensure the function performs the rotation in an efficient manner with a time complexity of O(n). * Avoid using extra space beyond a constant amount (O(1) space complexity). # Function Signature ```python def rotate_array(arr: list[int], n: int) -> list[int]: pass ``` # Example ```python >>> rotate_array([1, 2, 3, 4, 5], 5) [5, 1, 2, 3, 4] >>> rotate_array([0, 0, 0], 3) [0, 0, 0] >>> rotate_array([1], 1) [1] >>> rotate_array([1, -1, 2, -2, 3, -3], 6) [-3, 1, -1, 2, -2, 3] ``` Ensure to handle edge cases such as arrays with a single element, all elements being the same, and negative values.","solution":"def rotate_array(arr, n): Cyclically rotates the given array by one position to the right. Parameters: arr (list): The list of integers to be rotated. n (int): The length of the list. Returns: list: The rotated list of integers. if n <= 1: return arr # No rotation needed if the array has 0 or 1 elements last_element = arr[-1] # Shift elements to the right by one position for i in range(n-1, 0, -1): arr[i] = arr[i-1] arr[0] = last_element return arr"},{"question":"# Programming Question: Implement Median of Medians for Linear Time Selection You are tasked with implementing the Median of Medians algorithm to find the k-th smallest element in an unsorted array. The Median of Medians algorithm is a deterministic algorithm that provides an efficient approach to selection in linear time. **Function Signature:** ```python def median_of_medians(array: list, k: int) -> int: Finds the k-th smallest element in the array using the Median of Medians algorithm. :param array: List of integers from which to find the k-th smallest element. :param k: The order of the smallest element to find (1-based index). :return: The k-th smallest element in the array. ``` # Constraints * Input array length: `1 <= len(array) <= 10^6` * Array elements: individual integers where `-10^9 <= element <= 10^9` * `1 <= k <= len(array)` # Requirements * Your implementation must use the Median of Medians algorithm to achieve O(n) time complexity. * The function should handle edge cases, such as arrays with duplicate elements and extreme values. # Input & Output Examples 1. **Example 1:** ```python array = [7, 10, 4, 3, 20, 15] k = 3 median_of_medians(array, k) # Output: 7 ``` (3rd smallest element is 7) 2. **Example 2:** ```python array = [1, 3, 5, 7, 9] k = 1 median_of_medians(array, k) # Output: 1 ``` (1st smallest element is 1) 3. **Example 3:** ```python array = [100, 5, 2, 6, 14, 99, -50, 72] k = 5 median_of_medians(array, k) # Output: 14 ``` (5th smallest element is 14) 4. **Example 4:** ```python array = [-1, -5, -3, -13, -44] k = 2 median_of_medians(array, k) # Output: -13 ``` (2nd smallest element is -13) # Additional Notes * Ensure that your implementation is well-tested and handles edge cases efficiently. * Consider performance implications and ensure the algorithm works within linear time constraints for large input sizes.","solution":"def partition(arr, low, high, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def select(arr, low, high, k): while True: if low == high: return arr[low] pivot_index = median_of_medians(arr[low:high+1], (high - low + 1) // 2) pivot_index = partition(arr, low, high, arr.index(pivot_index)) if k == pivot_index: return arr[k] elif k < pivot_index: high = pivot_index - 1 else: low = pivot_index + 1 def median_of_medians(arr, k): n = len(arr) if n <= 5: return sorted(arr)[k] medians = [] for i in range(0, n, 5): group = sorted(arr[i:i+5]) medians.append(group[len(group) // 2]) return median_of_medians(medians, len(medians) // 2) def median_of_medians_main(array, k): return select(array, 0, len(array) - 1, k - 1)"},{"question":"# Question: Enhanced Data Stream Processor **Context**: Data streams are frequently used for processing continuous flows of data in real-time. A common requirement is to process each element in the stream and perform an aggregation, such as maintaining a running average, while the data is still flowing. **Task**: Implement the `DataStreamProcessor` class, which processes a stream of numbers. The most recent `n` elements of the stream should be aggregated to compute a running average. Additionally, the processor should support dynamically adjusting the window size and provide the maximum value encountered so far in the stream. **Class Signature**: ```python class DataStreamProcessor: def __init__(self, window_size: int): Initialize the DataStreamProcessor with a designated window size. Args: - window_size (int): The number of elements to use for the running average calculation. pass def process(self, value: float) -> None: Process the incoming value and update the stream with it. Args: - value (float): The new data value to process. pass def get_running_average(self) -> float: Return the current running average of the most recent `window_size` elements. Returns: - float: The running average of the current data window. pass def get_maximum(self) -> float: Return the maximum value encountered so far in the data stream. Returns: - float: The maximum value seen in the stream. pass def update_window_size(self, new_size: int) -> None: Update the window size for running average calculations. Args: - new_size (int): The new window size. pass # Example: # dsp = DataStreamProcessor(3) # dsp.process(10) # dsp.process(20) # dsp.process(30) # dsp.process(40) # print(dsp.get_running_average()) # Output should be 30.0 (average of [20, 30, 40]) # print(dsp.get_maximum()) # Output should be 40 (maximum value encountered) # dsp.update_window_size(2) # dsp.process(50) # print(dsp.get_running_average()) # Output should be 45.0 (average of [40, 50]) # print(dsp.get_maximum()) # Output should still be 50 ``` **Requirements**: 1. The `DataStreamProcessor` class should manage the window of the most recent `n` elements efficiently. 2. Running average calculation should update dynamically as new elements are processed. 3. The class should handle the dynamic resizing of the window size and adjust the running average calculation accordingly. 4. Maximum value tracking should be efficient and should reflect any new maximum values encountered in the data stream. **Hint**: - Consider using a queue or a deque to manage the window of elements efficiently. - Max-heap or other efficient structures can be used to track the maximum value encountered.","solution":"from collections import deque class DataStreamProcessor: def __init__(self, window_size: int): Initialize the DataStreamProcessor with a designated window size. Args: - window_size (int): The number of elements to use for the running average calculation. self.window_size = window_size self.data_window = deque(maxlen=window_size) self.current_sum = 0 self.current_max = float(\'-inf\') def process(self, value: float) -> None: Process the incoming value and update the stream with it. Args: - value (float): The new data value to process. if len(self.data_window) == self.data_window.maxlen: # Subtract the value that is going to be removed from the window self.current_sum -= self.data_window[0] self.data_window.append(value) self.current_sum += value if value > self.current_max: self.current_max = value def get_running_average(self) -> float: Return the current running average of the most recent `window_size` elements. Returns: - float: The running average of the current data window. if len(self.data_window) == 0: return 0.0 return self.current_sum / len(self.data_window) def get_maximum(self) -> float: Return the maximum value encountered so far in the data stream. Returns: - float: The maximum value seen in the stream. return self.current_max def update_window_size(self, new_size: int) -> None: Update the window size for running average calculations. Args: - new_size (int): The new window size. self.window_size = new_size # Create a new deque with the new size new_data_window = deque(self.data_window, maxlen=new_size) self.current_sum = sum(new_data_window) self.data_window = new_data_window"},{"question":"# Find Longest Subarray With Equal Number of 0s and 1s Problem Statement You need to write an algorithm that finds the longest contiguous subarray within a binary array that has an equal number of 0s and 1s. The length of this subarray should be maximized. Function Signature ```python def find_max_length(arr: list[int]) -> int: ``` Input - `arr: list[int]` - a list of integers containing only 0s and 1s, where `1 <= len(arr) <= 10^5`. Output - An integer representing the maximum length of the contiguous subarray with an equal number of 0s and 1s. Example ```plaintext Input: [0, 1, 0, 0, 1, 1, 0] Output: 6 ``` Constraints - The input array contains only 0s and 1s. - Your implementation should have a time complexity of O(n). Notes 1. Utilize an appropriate data structure to optimize the solution and minimize the time complexity. 2. Make sure to handle edge cases, such as when the input array is empty or contains only 0s or only 1s.","solution":"def find_max_length(arr: list[int]) -> int: Finds the longest contiguous subarray within a binary array that has an equal number of 0s and 1s. # Dictionary to store the first occurrence of a balance value balance_index_map = {0: -1} max_length = 0 balance = 0 for i, num in enumerate(arr): # Increment balance for 1 and decrement for 0 if num == 1: balance += 1 else: balance -= 1 if balance in balance_index_map: # Calculate the length of the subarray and update max_length subarray_length = i - balance_index_map[balance] max_length = max(max_length, subarray_length) else: # Store the first occurrence of the balance balance_index_map[balance] = i return max_length"},{"question":"# Coding Assessment Question **Title**: Implement Dynamic Matrix Rotation **Objective**: Write a program that can rotate an NxN matrix by 90 degrees either clockwise or counterclockwise. The rotation direction will be specified by the user. Ensure that the solution can handle matrices of different sizes efficiently. **Context**: Bob is working on a graphics processing task where he needs to rotate an NxN image represented as a matrix. Depending on user interactions, he may need to rotate the image 90 degrees clockwise or counterclockwise. Bob wants an efficient way to perform these rotations dynamically. **Task**: Write a function `rotate_matrix` to rotate a given NxN matrix by 90 degrees in a specified direction. # Requirements Function Definition ```python def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: Rotate an NxN matrix by 90 degrees in the given direction. Args: matrix (list[list[int]]): The NxN matrix to be rotated. direction (str): The direction of rotation; either \'clockwise\' or \'counterclockwise\'. Returns: list[list[int]]: The rotated matrix. pass ``` # Constraints and Input: 1. **Matrix**: NxN matrix where 1 ≤ N ≤ 100. 2. **Direction**: The direction of rotation, provided as a string (\'clockwise\' or \'counterclockwise\'). Examples: **Example 1** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] direction = \\"clockwise\\" rotated_matrix = rotate_matrix(matrix, direction) print(rotated_matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` **Example 2** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] direction = \\"counterclockwise\\" rotated_matrix = rotate_matrix(matrix, direction) print(rotated_matrix) # Output should be: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] ``` # Performance Requirements: - The solution should run efficiently for matrices of size up to 100x100. # Assumptions: - The input matrix will always be a valid NxN matrix. - The input direction will always be either \'clockwise\' or \'counterclockwise\'.","solution":"def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: Rotate an NxN matrix by 90 degrees in the given direction. Args: matrix (list[list[int]]): The NxN matrix to be rotated. direction (str): The direction of rotation; either \'clockwise\' or \'counterclockwise\'. Returns: list[list[int]]: The rotated matrix. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] if direction == \\"clockwise\\": for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] elif direction == \\"counterclockwise\\": for i in range(N): for j in range(N): rotated_matrix[N-1-j][i] = matrix[i][j] else: raise ValueError(\\"Invalid direction. Use \'clockwise\' or \'counterclockwise\'.\\") return rotated_matrix"},{"question":"# Sorting a List of Dictionaries by Multiple Keys You are given a task to sort a list of dictionaries based on multiple criteria. Each dictionary represents a book with the following attributes: `title`, `author`, and `year`. Function Specifications Write a function `sort_books` with the following signature: ```python def sort_books(books: list[dict], sort_by: list[str]) -> list[dict]: ``` Input - `books`: A list of dictionaries. Each dictionary represents a book and contains the following keys: - `\\"title\\"` (str): The title of the book. - `\\"author\\"` (str): The author of the book. - `\\"year\\"` (int): The year of publication. - `sort_by`: A list of strings specifying the sort order. Each element in the list is one of the keys: `\\"title\\"`, `\\"author\\"`, or `\\"year\\"`. The list specifies the sort order from primary to secondary to tertiary. For example, if the list is `[\\"author\\", \\"year\\", \\"title\\"]`, the books should be sorted primarily by author. Within books by the same author, they should be sorted by year, and within books by the same author and year, they should be sorted by title. Output The function should return the sorted list of dictionaries. Constraints - The `title` and `author` are non-empty strings consisting of alphanumeric characters and spaces. - The `year` is an integer between 0 and 2050. - The `books` list will contain between 1 and 1000 books. Example ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1945} ] sort_by = [\\"author\\", \\"year\\", \\"title\\"] result = sort_books(books, sort_by) print(result) # Output: # [ # {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, # {\\"title\\": \\"Animal Farm\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1945}, # {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, # {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960} # ] ``` Notes 1. Sorting should be stable, i.e., if two dictionaries have the same values for the sort key(s), their relative order should be the same as in the input list. 2. The list of dictionaries may contain books with duplicate titles, authors, or years.","solution":"def sort_books(books: list[dict], sort_by: list[str]) -> list[dict]: Sorts a list of dictionaries representing books based on multiple criteria. Args: books (list[dict]): List of dictionaries with keys \'title\', \'author\', and \'year\'. sort_by (list[str]): List of strings specifying the order to sort by. Returns: list[dict]: Sorted list of dictionaries. return sorted(books, key=lambda x: tuple(x[key] for key in sort_by))"},{"question":"# Question: Generate and Validate Sudoku Puzzles Context: You need to develop a solution that can create a valid Sudoku puzzle of various difficulties and also validate a given Sudoku board to ensure it meets the puzzle requirements. The Sudoku puzzle must follow the standard rules, where each row, column, and 3x3 sub-grid contains all digits from 1 to 9 without repetition. Requirements: 1. **Sudoku Generator**: Implement a function to generate a Sudoku puzzle with a specified number of pre-filled cells. 2. **Sudoku Validator**: Implement a separate function to validate any given Sudoku board to check if it\'s correctly filled according to Sudoku rules. Main Function Specification: ```python import random def generate_sudoku(pre_filled: int = 30) -> List[List[int]]: Generate a Sudoku puzzle with a specified number of pre-filled cells. Parameters: pre_filled (int): Number of cells to pre-fill. Default is 30. Returns: List[List[int]]: A 9x9 grid representing the Sudoku puzzle. pass def validate_sudoku(board: List[List[int]]) -> bool: Validate a given Sudoku board. Parameters: board (List[List[int]]): A 9x9 grid representing the Sudoku board. Returns: bool: True if the board is valid, else False. pass ``` * **Input**: For `generate_sudoku`, an integer specifying the number of pre-filled cells. For `validate_sudoku`, a 9x9 grid. * **Output**: For `generate_sudoku`, a 9x9 grid of integers representing the Sudoku puzzle. For `validate_sudoku`, a boolean indicating if the board is valid. Constraints: - For `generate_sudoku`: - The function should ensure a solvable puzzle, meaning there should exist at least one solution. - The pre-filled cells should be randomly distributed but should all uniquely satisfy Sudoku rules. - For `validate_sudoku`: - The function should return `True` if the board is a valid Sudoku solution. - The function should return `False` if any row, column, or 3x3 sub-grid has duplicate numbers or if there are cells that break the Sudoku rules. Example: ```python # Example usage for generate_sudoku generated_puzzle = generate_sudoku(pre_filled=30) print(generated_puzzle) # Example usage for validate_sudoku sudoku_board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] is_valid = validate_sudoku(sudoku_board) print(is_valid) # Expected output: True or False ``` Performance Requirements: - The generation of the Sudoku puzzle should be optimized to avoid unnecessary recalculations and retries. - The validation function should run in a reasonable time (e.g., < 1 second) even for dense Sudoku boards. Note: Provide a well-documented and tested solution showcasing your understanding of algorithms, randomization, and Sudoku puzzle constraints.","solution":"import random from typing import List def generate_empty_sudoku() -> List[List[int]]: return [[0]*9 for _ in range(9)] def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool: Check if it\'s valid to place num at board[row][col]. for i in range(9): if board[row][i] == num or board[i][col] == num: return False start_row, start_col = (row // 3) * 3, (col // 3) * 3 for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve_sudoku(board: List[List[int]]) -> bool: Solve a Sudoku puzzle using backtracking. for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve_sudoku(board): return True board[row][col] = 0 return False return True def generate_sudoku(pre_filled: int = 30) -> List[List[int]]: Generate a Sudoku puzzle with a specified number of pre-filled cells. board = generate_empty_sudoku() solve_sudoku(board) count = 81 - pre_filled while count > 0: row, col = random.randint(0, 8), random.randint(0, 8) while board[row][col] == 0: row, col = random.randint(0, 8), random.randint(0, 8) board[row][col] = 0 count -= 1 return board def validate_sudoku(board: List[List[int]]) -> bool: Validate the given Sudoku board. def is_valid_line(line): nums = [n for n in line if n != 0] return len(nums) == len(set(nums)) for i in range(9): if not is_valid_line(board[i]) or not is_valid_line([board[j][i] for j in range(9)]): return False for i in range(3): for j in range(3): block = [board[x][y] for x in range(i*3, (i+1)*3) for y in range(j*3, (j+1)*3)] if not is_valid_line(block): return False return True"},{"question":"# Coding Assessment: Currency Conversion Rate Finder Context You are developing a program that helps users convert amounts from one currency to another based on exchange rates. To do this, you need to create a function that searches for and returns the conversion rate between two specified currencies. Problem Statement Implement the function `find_conversion_rate` that takes a dictionary of currency pairs with their respective conversion rates and two currency codes representing the source and target currencies. The function should return the conversion rate between the specified currencies. Function to Be Implemented ```python def find_conversion_rate( conversion_rates: dict[str, float], source_currency: str, target_currency: str ) -> float: Find the conversion rate between two specified currencies. - conversion_rates: A dictionary where keys are two-character currency codes concatenated together (e.g., \'USDEUR\') and the values are the conversion rates. - source_currency: A string representing the source currency code. - target_currency: A string representing the target currency code. >>> find_conversion_rate({\'USDEUR\': 0.89, \'EURUSD\': 1.12}, \'USD\', \'EUR\') 0.89 >>> find_conversion_rate({\'USDEUR\': 0.89, \'EURUSD\': 1.12}, \'EUR\', \'GBP\') KeyError: \'Conversion rate from EUR to GBP not found.\' key = source_currency + target_currency if key not in conversion_rates: raise KeyError(f\\"Conversion rate from {source_currency} to {target_currency} not found.\\") return conversion_rates[key] ``` Requirements 1. **Input Validation**: - Ensure `source_currency` and `target_currency` are three-character string codes. - Raise a `ValueError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - If the conversion rate for the specified currency pair is not found in the dictionary, raise a `KeyError` with an appropriate message. 3. **Improved Clarity**: - Provide clear and concise docstrings. Input/Output Format * **Input**: - `conversion_rates`: A dictionary with keys as strings representing currency pairs (concatenated codes) and values as floats representing the conversion rates. - `source_currency`: A string representing the source currency code (3 characters). - `target_currency`: A string representing the target currency code (3 characters). * **Output**: - A float value representing the conversion rate between the specified currencies. Constraints 1. Each currency code in the dictionary and input must be a three-character string. 2. The function should handle cases where the specified currency pair does not exist in the dictionary. Example ```python conversion_rates = {\'USDEUR\': 0.89, \'EURUSD\': 1.12, \'USDGBP\': 0.75} try: print(find_conversion_rate(conversion_rates, \'USD\', \'EUR\')) # Outputs: 0.89 print(find_conversion_rate(conversion_rates, \'EUR\', \'USD\')) # Outputs: 1.12 print(find_conversion_rate(conversion_rates, \'USD\', \'GBP\')) # Outputs: 0.75 print(find_conversion_rate(conversion_rates, \'EUR\', \'GBP\')) # Raises KeyError except ValueError as ve: print(f\\"ValueError: {ve}\\") except KeyError as ke: print(f\\"KeyError: {ke}\\") ```","solution":"def find_conversion_rate(conversion_rates: dict[str, float], source_currency: str, target_currency: str) -> float: Find the conversion rate between two specified currencies. Args: - conversion_rates: A dictionary where keys are six-character currency codes concatenated together (e.g., \'USDEUR\') and the values are the conversion rates. - source_currency: A string representing the source currency code (3 characters). - target_currency: A string representing the target currency code (3 characters). Returns: - float: The conversion rate between the specified currencies. Raises: - ValueError: If either currency code is not a three-character string. - KeyError: If the conversion rate for the specified currency pair is not found. Example: >>> find_conversion_rate({\'USDEUR\': 0.89, \'EURUSD\': 1.12}, \'USD\', \'EUR\') 0.89 >>> find_conversion_rate({\'USDEUR\': 0.89, \'EURUSD\': 1.12}, \'EUR\', \'GBP\') KeyError: \'Conversion rate from EUR to GBP not found.\' if not isinstance(source_currency, str) or len(source_currency) != 3: raise ValueError(\\"source_currency must be a three-character string\\") if not isinstance(target_currency, str) or len(target_currency) != 3: raise ValueError(\\"target_currency must be a three-character string\\") key = source_currency + target_currency if key not in conversion_rates: raise KeyError(f\\"Conversion rate from {source_currency} to {target_currency} not found.\\") return conversion_rates[key]"},{"question":"# Fibonacci Sequence Modification **Context**: The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. Now, consider a modified version of the Fibonacci sequence where instead of summing the last two numbers, the sequence is defined by the sum of the last three numbers. **Task**: Write a function that takes an integer `n` and returns the first `n` numbers in this modified Fibonacci sequence starting with 0, 1, and 1. **Function Signature**: ```python def modified_fibonacci(n: int) -> List[int]: pass ``` **Input and Output**: * **Input**: * `n` - A positive integer indicating the number of terms in the modified Fibonacci sequence to return. * **Output**: * A list of integers representing the first `n` terms of the modified Fibonacci sequence. **Constraints**: * 1 ≤ n ≤ 1000 **Performance Requirements**: * Time Complexity: O(n) * Space Complexity: O(n) **Example**: ```python assert modified_fibonacci(1) == [0] assert modified_fibonacci(3) == [0, 1, 1] assert modified_fibonacci(5) == [0, 1, 1, 2, 4] assert modified_fibonacci(10) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81] ``` ***Explanation***: The sequence starts with 0, 1, and 1. - The 4th term is 0+1+1=2. - The 5th term is 1+1+2=4. - The 6th term is 1+2+4=7. And so on. The sequence grows by summing the last three terms of the preceding part of the sequence.","solution":"from typing import List def modified_fibonacci(n: int) -> List[int]: Returns the first n numbers in a modified Fibonacci sequence where each term is the sum of the last three terms. if n == 1: return [0] elif n == 2: return [0, 1] elif n == 3: return [0, 1, 1] sequence = [0, 1, 1] for i in range(3, n): next_term = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_term) return sequence"},{"question":"You need to implement a function `find_best_hike` that helps hikers decide the best trail to take based on elevation gains and losses. Each trail is represented as a list of integers, where each integer represents the elevation at that point. Your function should determine which trail has the least total elevation change (the sum of absolute differences between adjacent elevations) and return the corresponding trail. # Function Signature ```python def find_best_hike(trails: List[List[int]]) -> List[int]: ``` # Input - `trails`: A list of lists, each sublist containing integers representing elevations of a trail. # Output - Returns a list of integers representing the trail with the least total elevation change. # Constraints - All trails have at least 2 elevations. - Each elevation value is between `-1000` and `1000`. - There are at least 2 trails provided. # Example ```python hikes = [ [280, 300, 280, 100, 80], [120, 130, 140, 150, 160], [50, 60, 70, 100, 90] ] print(find_best_hike(hikes)) ``` Expected output should be: ``` [120, 130, 140, 150, 160] ``` # Explanation - The first trail has elevation changes: `20 -> 20 -> 180 -> 20` (total 240) - The second trail has elevation changes: `10 -> 10 -> 10 -> 10` (total 40) - The third trail has elevation changes: `10 -> 10 -> 30 -> 10` (total 60) - The trail [120, 130, 140, 150, 160] has the least total elevation change, thus it is the best hike.","solution":"from typing import List def find_best_hike(trails: List[List[int]]) -> List[int]: Determines the best trail with the least total elevation change. Parameters: trails (List[List[int]]): A list of lists, each sublist containing integers representing elevations of a trail. Returns: List[int]: The trail with the least total elevation change. def total_elevation_change(trail: List[int]) -> int: return sum(abs(trail[i] - trail[i + 1]) for i in range(len(trail) - 1)) best_trail = min(trails, key=total_elevation_change) return best_trail"},{"question":"# Coding Assessment Question Problem Statement: You are given an integer `n` representing the number of rows in a pyramid of integers. Your task is to build this pyramid such that each row contains an increasing sequence of integers, starting with 1 at the top and continuing in sequence. Return a 2-dimensional list representing the pyramid structure. Input: - An integer `n` (1 <= n <= 20). Output: - A 2-dimensional list of integers representing the pyramid structure. Constraints: - The input `n` will be within the given range. - Each row `i` should contain `i` numbers. Function Signature: ```python def build_pyramid(n: int) -> list: pass ``` Example: ```python print(build_pyramid(3)) # Output: # [ # [1], # [2, 3], # [4, 5, 6] # ] print(build_pyramid(5)) # Output: # [ # [1], # [2, 3], # [4, 5, 6], # [7, 8, 9, 10], # [11, 12, 13, 14, 15] # ] ``` Context: You are developing a visualization tool that generates numeric pyramids for educational purposes. In order to display the pyramid accurately, you need an algorithm to construct the rows properly. # Requirements: - Ensure the pyramid is built correctly starting from 1 and incrementing accordingly. - The solution should handle the maximum constraints effectively. Hint: You can use nested loops to construct each row of the pyramid, keeping track of the current number to be added.","solution":"def build_pyramid(n: int) -> list: Build a pyramid structure with n rows in a specific sequence. Each row i contains i elements and starts with the next integer in sequence. pyramid = [] current_num = 1 for row in range(1, n + 1): current_row = [] for col in range(row): current_row.append(current_num) current_num += 1 pyramid.append(current_row) return pyramid"},{"question":"# Question: You are developing a text processing module, and you need to write two functions to analyze the structure of a given piece of text. Task: 1. **Function 1: `word_frequencies(text: str) -> dict`** - Input: - `text`: A string containing the text to analyze. - Output: - A dictionary where the keys are unique words from the text, and the values are the frequencies of those words. - Implementation details: - Ignore punctuation and case while determining word frequencies. - Treat words with different cases (e.g., \\"Word\\" and \\"word\\") as the same word. 2. **Function 2: `sentence_lengths(text: str) -> list`** - Input: - `text`: A string containing the text to analyze. - Output: - A list of integers representing the lengths (in words) of each sentence in the text. - Implementation details: - Define a sentence as any collection of words ending with a period (.), exclamation mark (!), or question mark (?). - Ignore leading and trailing whitespace. Examples: - Word Frequencies: ```python word_frequencies(\\"Hello World! Hello, hello.\\") # Output: {\'hello\': 3, \'world\': 1} word_frequencies(\\"A quick brown fox jumps over the lazy dog.\\") # Output: {\'a\': 1, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, \'the\': 1, \'lazy\': 1, \'dog\': 1} ``` - Sentence Lengths: ```python sentence_lengths(\\"Hello World! Hello, hello.\\") # Output: [2, 2] sentence_lengths(\\"A quick brown fox. Jumps over the lazy dog.\\") # Output: [4, 5] ``` Ensure your solution efficiently handles large texts and correctly handles irregular punctuation or whitespace.","solution":"import re from collections import defaultdict def word_frequencies(text: str) -> dict: Returns a dictionary with the frequencies of each unique word in the given text. text = text.lower() # Convert text to lowercase words = re.findall(r\'bw+b\', text) # Extract words using regex frequencies = defaultdict(int) for word in words: frequencies[word] += 1 return dict(frequencies) def sentence_lengths(text: str) -> list: Returns a list of sentence lengths in words. # Identify sentences using regex and split the text accordingly sentences = re.split(r\'[.!?]\', text) lengths = [] for sentence in sentences: words = re.findall(r\'bw+b\', sentence) if words: # Ignore empty sentences that may occur due to split lengths.append(len(words)) return lengths"},{"question":"# Radix Sort Implementation Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. Your task is to implement the `radix_sort` function, which sorts a list of non-negative integers using Radix Sort. # Function Signature ```python def radix_sort(arr: list[int]) -> list[int]: ``` # Parameters - `arr (list[int])`: A list of non-negative integers to be sorted. # Returns - `sorted_arr (list[int])`: A list of integers sorted in ascending order. # Constraints - The length of `arr` will be between 1 and 10^5. - Each integer in `arr` will be between 0 and 10^9. # Examples The function should handle the following cases: ```python >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) [2, 24, 45, 66, 75, 90, 170, 802] >>> radix_sort([1, 4, 1, 2, 7, 5, 2]) [1, 1, 2, 2, 4, 5, 7] >>> radix_sort([0, 0, 1, 5, 9, 8]) [0, 0, 1, 5, 8, 9] ``` # Implementation Guidelines Here are the basic steps to implement Radix Sort: 1. Identify the maximum number to determine the number of digits. 2. Perform a counting sort for each digit, starting from the least significant digit to the most significant one. # Additional Notes - You may assume all integers in the input array `arr` are non-negative. - Radix Sort is particularly useful for sorting large datasets of integers. Write your implementation of the function `radix_sort`, ensuring it sorts the list correctly and efficiently for the given constraints.","solution":"def counting_sort(arr, exp): A function to perform counting sort based on the exponent value (digits place). n = len(arr) # Output array output = [0] * n # Initialize count array count = [0] * 10 # Store the count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] now contains the actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[], so that arr[] now contains # sorted numbers according to the current digit for i in range(n): arr[i] = output[i] def radix_sort(arr): Function to perform radix sort on the given list of non-negative integers. # Find the maximum number to know the number of digits max_num = max(arr) # Do counting sort for every digit. Note that instead of passing the digit number, # exp is passed. exp is 10^i where i is the current digit number. exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Scenario You are working on a project that involves data analysis from multiple sensor inputs. Each sensor provides a list of integer readings, and you need to efficiently merge these sorted lists into one single sorted list. This is a common task in applications involving real-time data streams and analytics. # Task Implement a function `merge_sorted_lists` that takes a list of sorted integer lists and merges them into a single sorted list. # Function Signature ```python def merge_sorted_lists(lists: list) -> list: Merges multiple sorted integer lists into one sorted list. :param lists: List of sorted integer lists (e.g., [[1, 4, 5], [1, 3, 4], [2, 6]]). :return: A single sorted list containing all elements from the input lists. ``` # Input - `lists`: A list of k sorted integer lists, where 1 ≤ k ≤ 10^4 and the length of each list is between 0 and 10^3. # Output - The function should return a single sorted list containing all the elements from `lists` in non-decreasing order. # Constraints - The integers in the input lists are within the range -10^9 to 10^9. - Ensure that the implementation is efficient in time and space complexity. # Performance Requirements - The algorithm should run in O(N log k) time, where N is the total number of elements in all the input lists and k is the number of lists. # Example ```python lists = [[1, 4, 5], [1, 3, 4], [2, 6]] merged_list = merge_sorted_lists(lists) print(merged_list) # Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` # Notes - Consider using a heap (priority queue) to efficiently merge the lists. - Make sure to handle edge cases, such as empty lists and lists with negative integers.","solution":"import heapq def merge_sorted_lists(lists): Merges multiple sorted integer lists into one sorted list. :param lists: List of sorted integer lists (e.g., [[1, 4, 5], [1, 3, 4], [2, 6]]). :return: A single sorted list containing all elements from the input lists. # Initialize a min-heap min_heap = [] # Add the first element of each list along with the list index and element index within the list # to the heap for tracking. for i, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst[0], i, 0)) # Initialize the merged list merged_list = [] # Extract the smallest element from the heap and add the next element # from the same list to the heap. while min_heap: val, list_idx, elem_idx = heapq.heappop(min_heap) merged_list.append(val) if elem_idx + 1 < len(lists[list_idx]): next_tuple = (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1) heapq.heappush(min_heap, next_tuple) return merged_list"},{"question":"# Data Compression Using Run-Length Encoding In this problem, you need to implement a data compression algorithm known as Run-Length Encoding (RLE). RLE is a basic form of lossless data compression in which runs of data are stored as a single data value and count, rather than as the original run. # Requirements 1. **Function Implementation**: Implement a function `compress(data: str) -> str` that takes a string and returns its Run-Length Encoded format. 2. **Decompression Feature**: Implement a corresponding function `decompress(encoded_data: str) -> str` that decodes a Run-Length Encoded string back to its original form. # Input/Output Format - **Input**: - `compress(data: str) -> str`: Compresses the input string using RLE. - `decompress(encoded_data: str) -> str`: Decompresses the RLE formatted string back to its original form. - **Output**: - Both functions should return a string representing the compressed or decompressed data, respectively. # Performance Requirements - Aim for a time complexity of `O(n)` where `n` is the length of the string. - Both functions should have a space complexity of `O(n)`. # Constraints - The input `data` for `compress` and `encoded_data` for `decompress` can contain any printable characters. - The run lengths in the compressed format should not exceed 9 to ensure single character representation for counts. # Example Workflow ```python compressed_data = compress(\\"aaabbbcccaa\\") print(compressed_data) # OUTPUT: \\"a3b3c3a2\\" decompressed_data = decompress(compressed_data) print(decompressed_data) # OUTPUT: \\"aaabbbcccaa\\" ``` # Hints for Consideration - Think about how to handle edge cases such as an empty string or a string with no repeating characters. - Ensure your `compress` function maintains readability of the output. - Verify that the decompression process accurately reconstructs the original string from the encoded data.","solution":"def compress(data: str) -> str: Compress the input string using Run-Length Encoding (RLE). if not data: return \\"\\" compressed = [] count = 1 current_char = data[0] for i in range(1, len(data)): if data[i] == current_char: count += 1 if count == 9: # reset every 9 to maintain single char representation compressed.append(f\\"{current_char}{count}\\") count = 0 else: if count > 0: compressed.append(f\\"{current_char}{count}\\") current_char = data[i] count = 1 if count > 0: compressed.append(f\\"{current_char}{count}\\") return \'\'.join(compressed) def decompress(encoded_data: str) -> str: Decompress the RLE encoded string back to its original form. if not encoded_data: return \\"\\" decompressed = [] i = 0 while i < len(encoded_data): char = encoded_data[i] count = int(encoded_data[i + 1]) decompressed.append(char * count) i += 2 return \'\'.join(decompressed)"},{"question":"# Question: Implement Depth First Search (DFS) Traversal of an Undirected Graph You are provided with the implementation of an `UndirectedGraph` data structure representing an undirected graph. Your task is to implement a function that performs a Depth-First Search (DFS) traversal starting from a given node and returns the order of nodes visited. # Objective Implement the method `dfs_traversal` of the `UndirectedGraph` class. This method should take a starting node `s` and return a list where the elements are the nodes in the order they are visited during the DFS traversal. # Input - An instance of `UndirectedGraph`. - A starting node `s`. # Output - A list representing the order of nodes visited during the DFS traversal from the starting node `s`. # Constraints - The graph will have at least one node and can have up to 5,000 nodes and 20,000 edges. - The graph is connected, meaning there is a path from the starting node to every other node in the graph. # Performance Requirements - The implementation must efficiently handle graphs with the upper constraint limits. - The traversal should have a time complexity of O(V + E). # Function Signature ```python class UndirectedGraph: # ... (other methods in class definition) def dfs_traversal(self, s): # Your implementation here pass ``` # Example ```python # Example usage of the method after implementation graph = UndirectedGraph() graph.add_pair(0, 1) graph.add_pair(0, 2) graph.add_pair(1, 3) graph.add_pair(1, 4) graph.add_pair(2, 5) graph.add_pair(2, 6) visited_order = graph.dfs_traversal(0) print(visited_order) # Output could be [0, 1, 3, 4, 2, 5, 6] or any DFS valid order ``` # Notes - Input validation is not required. - You may use an iterative approach with a stack or a recursive approach as per your preference.","solution":"class UndirectedGraph: def __init__(self): self.adjacency_list = {} def add_pair(self, u, v): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs_traversal(self, s): visited = set() stack = [s] order = [] while stack: node = stack.pop() if node not in visited: visited.add(node) order.append(node) # Add nodes in reverse order to visit them as per DFS nature (LIFO) for neighbor in reversed(self.adjacency_list[node]): if neighbor not in visited: stack.append(neighbor) return order"},{"question":"# Inventory Management System You are tasked with developing an inventory management system for a small retail store using Python. The system should allow for adding to inventory, removing from inventory, checking current stock levels, and handling error cases, such as trying to remove an item that is not in stock or passing invalid inputs. # Requirements 1. **Class Implementation**: Create an `Inventory` class with the following methods: * `add_item(item_name: str, quantity: int) -> None`: Adds the specified quantity of the item to the inventory. * `remove_item(item_name: str, quantity: int) -> None`: Removes the specified quantity of the item from the inventory. * `get_stock(item_name: str) -> int`: Returns the current stock level of the specified item. 2. **Error Handling**: * Raise exceptions for invalid operations, such as removing more items than are in stock or adding/removing negative quantities. * Provide meaningful error messages to assist with debugging. 3. **Testing and Validation**: * Provide a set of test cases to validate your class methods. * Ensure your class can handle edge cases such as adding/removing items that are not in the inventory. # Scenario Context A small retail store wants to keep track of its inventory using a simple Python script. The store manager needs to add new stock, remove sold items, and check current stock levels throughout the day. The script should be robust and handle various edge cases while providing helpful error messages. # Input and Output * Input: Method calls to the `Inventory` class with item names and quantities. * Output: Updates to the inventory and printed messages indicating success or failure of operations. # Constraints * Item names will be non-empty strings. * Quantities will be non-negative integers. ```python class Inventory: def __init__(self): self.stock = {} def add_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if item_name in self.stock: self.stock[item_name] += quantity else: self.stock[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if item_name not in self.stock or self.stock[item_name] < quantity: raise ValueError(\\"Insufficient stock or item does not exist.\\") self.stock[item_name] -= quantity if self.stock[item_name] == 0: del self.stock[item_name] def get_stock(self, item_name: str) -> int: return self.stock.get(item_name, 0) # Example Usage if __name__ == \\"__main__\\": store_inventory = Inventory() store_inventory.add_item(\\"apple\\", 50) store_inventory.add_item(\\"banana\\", 30) print(f\\"Apple stock: {store_inventory.get_stock(\\"apple\\")}\\") # Output: Apple stock: 50 store_inventory.remove_item(\\"apple\\", 10) print(f\\"Apple stock: {store_inventory.get_stock(\\"apple\\")}\\") # Output: Apple stock: 40 try: store_inventory.remove_item(\\"orange\\", 5) except ValueError as e: print(e) # Output: Insufficient stock or item does not exist. try: store_inventory.add_item(\\"banana\\", -10) except ValueError as e: print(e) # Output: Quantity cannot be negative. ``` - Ensure your implementation handles basic inventory operations and edge cases. - Validate your solution with various test cases to ensure reliability.","solution":"class Inventory: def __init__(self): self.stock = {} def add_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if item_name in self.stock: self.stock[item_name] += quantity else: self.stock[item_name] = quantity def remove_item(self, item_name: str, quantity: int) -> None: if quantity < 0: raise ValueError(\\"Quantity cannot be negative.\\") if item_name not in self.stock or self.stock[item_name] < quantity: raise ValueError(\\"Insufficient stock or item does not exist.\\") self.stock[item_name] -= quantity if self.stock[item_name] == 0: del self.stock[item_name] def get_stock(self, item_name: str) -> int: return self.stock.get(item_name, 0)"},{"question":"Implement a Python function `find_longest_balanced_substring` that takes a string `s` as input and returns the longest balanced substring of `s`. A balanced substring is defined as a substring where the number of opening brackets \'(\' equals the number of closing brackets \')\'. # Requirements: 1. The input string `s` should contain only characters \'(\' and \')\'. 2. The function should handle edge cases such as empty strings or strings with no balanced substrings. 3. The result should be the longest balanced substring. In case of multiple substrings with the same length, return the first one encountered. # Input: - `s` (len(s) >= 0): String consisting only of \'(\' and \')\'. # Output: - A string representing the longest balanced substring. # Function Signature ```python def find_longest_balanced_substring(s: str) -> str: pass ``` # Example ```python # Example usage: # Find the longest balanced substring of the given input strings print(find_longest_balanced_substring(\\"(()())\\")) # Output: \\"(()())\\" print(find_longest_balanced_substring(\\")()())()())\\")) # Output: \\"()()\\" print(find_longest_balanced_substring(\\"\\")) # Output: \\"\\" print(find_longest_balanced_substring(\\"((())))\\")) # Output: \\"((()))\\" ``` # Constraints: - Only the characters \'(\' and \')\' are allowed in the input string. - The length of the input string can be 0 or more. # Notes: - Consider using a stack-based approach or dynamic programming to solve the problem efficiently. - Ensure that your function handles different edge cases and long strings effectively.","solution":"def find_longest_balanced_substring(s: str) -> str: max_length = 0 start_index = 0 stack = [] last_invalid_index = -1 for i, char in enumerate(s): if char == \'(\': stack.append(i) else: if stack: stack.pop() if stack: length = i - stack[-1] else: length = i - last_invalid_index if length > max_length: max_length = length start_index = i - max_length + 1 else: last_invalid_index = i return s[start_index:start_index + max_length]"},{"question":"# Fibonacci Sequence and Modular Arithmetic Context: The Fibonacci sequence is often encountered in programming challenges. For this task, you are required to efficiently calculate the Fibonacci numbers and apply modular arithmetic to keep the values manageable. Requirements: 1. **Function 1**: Implement a function `fibonacci(n: int) -> int` that returns the n-th Fibonacci number. The function should: * Utilize an iterative approach to ensure optimal performance. * Handle edge cases where the input is non-positive. * Ensure the function operates with a time complexity of (O(n)). 2. **Function 2**: Implement a function `fibonacci_mod_m(n: int, m: int) -> int` that returns the n-th Fibonacci number modulo `m`. The function should: * Ensure that the input values `n` and `m` are positive integers. * Utilize the `fibonacci` function to calculate the Fibonacci number. * Apply modular arithmetic to return the result. Constraints: * Ensure that both functions manage invalid inputs appropriately and provide clear error notifications. * Aim to create the `fibonacci_mod_m` function with the minimal possible overall time complexity by leveraging the `fibonacci` function. Input: - `fibonacci` function: * A single integer `n`. - `fibonacci_mod_m` function: * Two positive integers `n` and `m`. Output: - `fibonacci` function: * Returns an integer representing the n-th Fibonacci number. - `fibonacci_mod_m` function: * Returns an integer representing the n-th Fibonacci number modulo `m`. Example Usage: ```python >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(-1) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer. >>> fibonacci_mod_m(5, 3) 2 >>> fibonacci_mod_m(10, 7) 6 >>> fibonacci_mod_m(-1, 3) Traceback (most recent call last): ... ValueError: Both parameters must be positive integers. >>> fibonacci_mod_m(5, -2) Traceback (most recent call last): ... ValueError: Both parameters must be positive integers. ```","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def fibonacci_mod_m(n, m): Returns the n-th Fibonacci number modulo m. if not isinstance(n, int) or not isinstance(m, int) or n < 0 or m <= 0: raise ValueError(\\"Both parameters must be positive integers.\\") fib_n = fibonacci(n) return fib_n % m"},{"question":"# Coding Assessment Question Scenario In numerical computations and data analysis, summing up large datasets is a common operation. Sometimes, to ensure the performance and accuracy of your program, you might need to implement summing algorithms without using built-in functions. This task will help you demonstrate your ability to manipulate and process numerical data efficiently. Problem Statement Write a function `custom_sum(numbers: List[int]) -> int` that takes a list of integers `numbers` and returns the sum of all the elements in the list without using the built-in `sum()` function. Input and Output - **Input**: A list `numbers` containing integers. (0 ≤ len(numbers) ≤ 1000, -10^6 ≤ numbers[i] ≤ 10^6 for each integer) - **Output**: An integer representing the sum of all integers in the list. If the list is empty, the function should return 0. Constraints - You are not allowed to use the built-in `sum()` function. - You must handle edge cases such as an empty list and lists with negative numbers. Example ```python >>> custom_sum([1, 2, 3, 4]) 10 >>> custom_sum([-1, -2, -3, -4]) -10 >>> custom_sum([]) 0 >>> custom_sum([100, -50, 25, -75]) 0 ``` Provide the implementation for the `custom_sum` function. Ensure your code passes the given examples and consider any edge cases.","solution":"def custom_sum(numbers): Returns the sum of all the elements in the list `numbers` without using the built-in sum() function. total = 0 for number in numbers: total += number return total"},{"question":"# Coding Question: Movie Database Query Challenge Context You\'re required to create a function that fetches and filters movies from a fictional movie database API based on a given genre. Task Implement a function `fetch_movies_by_genre(genre: str) -> List[dict]` which takes a genre string as input and returns a list of dictionaries. Each dictionary should contain details about the movies in the given genre, specifically the movie title, release year, and rating. You should handle potential errors gracefully and ensure robust performance for the function. Input * `genre` - A string representing the genre to fetch movies for (e.g., \\"Action\\", \\"Comedy\\"). Output * A list of dictionaries. Each dictionary contains three keys: - `title`: The title of the movie (string). - `year`: The release year of the movie (integer). - `rating`: The rating of the movie (float). Constraints * Handle timeouts and HTTP errors gracefully with appropriate error messages. * Ensure that the JSON parsing handles edge cases where certain elements might be missing. * The API endpoint is `https://fictional-movie-database.com/api/movies?genre=`. Performance Requirements * Optimize for time by reducing unnecessary network calls and parsing efforts. * Ensure your solution does not significantly exceed O(n) time and space complexity for fetching and parsing the data (where n is the size of the JSON response). Example Usage ```python # Example of calling the fetch_movies_by_genre function movies = fetch_movies_by_genre(\\"Action\\") for movie in movies: print(f\\"Title: {movie[\'title\']}, Year: {movie[\'year\']}, Rating: {movie[\'rating\']}\\") ``` Additional Information * You can use third-party libraries such as `requests` which are already imported in the provided code snippet. * If any changes occur in the data structure of the JSON response, update your parsing logic accordingly. * Add necessary error handling for unpredictable scenarios such as connection issues or changes in response structure.","solution":"import requests from typing import List, Dict def fetch_movies_by_genre(genre: str) -> List[Dict[str, any]]: url = f\\"https://fictional-movie-database.com/api/movies?genre={genre}\\" try: response = requests.get(url, timeout=10) response.raise_for_status() # Raises HTTPError, if one occurred movies_data = response.json() movies_list = [] for movie in movies_data: title = movie.get(\'title\', \'N/A\') year = movie.get(\'year\', 0) rating = movie.get(\'rating\', 0.0) movies_list.append({ \'title\': title, \'year\': year, \'rating\': rating }) return movies_list except requests.exceptions.RequestException as e: print(f\\"An error occurred: {e}\\") return []"},{"question":"# Context You are designing a social media platform, and one of the features is to identify the most popular hashtag within a given set of posts. Your task is to implement a function that finds the most frequently occurring hashtag in the provided list of posts. # Problem Statement Implement a function `most_popular_hashtag(posts: list[str]) -> str` that takes in a list of posts, where each post is a string containing text and hashtags. The function should return the most frequently occurring hashtag from all the posts. If there is a tie, return any one of the most frequent hashtags. # Input - `posts`: A list of strings where each string is a text post that may contain multiple hashtags. # Output - A string representing the most frequently occurring hashtag. In case of a tie, return any one of the most frequent hashtags. # Constraints 1. Each hashtag starts with a \'#\' and is followed by alphanumeric characters (a-z, A-Z, 0-9). 2. Each post is a non-empty string. 3. The maximum length of each post is 280 characters (similar to a tweet). 4. The list of posts can contain up to 10^5 posts. 5. If no hashtags are found, return an empty string. # Examples ```python >>> most_popular_hashtag([\\"#fun #happy #coding\\", \\"#coding #python #fun\\", \\"Just a regular post\\", \\"#happy #fun\\"]) \'#fun\' >>> most_popular_hashtag([\\"#a #b #c\\", \\"#a #b\\", \\"#a\\"]) \'#a\' >>> most_popular_hashtag([\\"Tweet without hashtag\\", \\"Just text\\", \\"Another one\\"]) \'\' >>> most_popular_hashtag([\\"#same\\", \\"#same\\", \\"#same\\"]) \'#same\' >>> most_popular_hashtag([\\"#tie1 #tie2\\", \\"#tie2 #tie1\\", \\"#tie1\\", \\"#tie2\\"]) \'#tie1\' # or \'#tie2\' ``` # Notes - In the first example, hashtags `#fun` and `#coding` both appear twice, but `#fun` appears in two different posts whereas `#coding` also appears twice in two posts, so either can be considered the answer. - In the second example, `#a` is the most frequent hashtag appearing 3 times. Your implementation should aim for a time complexity of O(n) where n is the total number of characters in all the posts combined.","solution":"def most_popular_hashtag(posts: list[str]) -> str: from collections import Counter import re hashtag_pattern = re.compile(r\'#w+\') hashtags = [] for post in posts: hashtags.extend(hashtag_pattern.findall(post)) if not hashtags: return \\"\\" hashtag_count = Counter(hashtags) return max(hashtag_count, key=hashtag_count.get)"},{"question":"# Problem Statement You are given a string of lowercase English letters and you need to determine the minimum number of operations required to make the string a palindrome. In one operation, you can insert any character at any position in the string. # Input - `s`: A string of lowercase English letters (1 ≤ len(s) ≤ 500). # Output - An integer representing the minimum number of insertions needed to make the input string a palindrome. # Constraints - The input string consists only of lowercase English letters. # Requirements - Time Complexity: O(n^2) - Space Complexity: O(n^2) # Example ```python assert min_insertions_to_palindrome(\\"race\\") == 3 # Insert \\"e\\" at the beginning, \\"c\\" at the beginning, and \\"r\\" at the beginning to form \\"ecarace\\". assert min_insertions_to_palindrome(\\"google\\") == 2 # Insert \\"g\\" at the beginning and \\"o\\" at the end to form \\"egoogle\\". assert min_insertions_to_palindrome(\\"madam\\") == 0 # Already a palindrome, so no insertions needed. assert min_insertions_to_palindrome(\\"ab\\") == 1 # Insert \\"b\\" at the beginning or \\"a\\" at the end to form \\"aba\\" or \\"bab\\". ``` # Function Signature ```python def min_insertions_to_palindrome(s: str) -> int: ```","solution":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the input string a palindrome. n = len(s) # Create a table to store the results of subproblems dp = [[0] * n for _ in range(n)] # Fill in the table for gap in range(1, n): l = 0 for h in range(gap, n): if s[l] == s[h]: dp[l][h] = dp[l+1][h-1] else: dp[l][h] = min(dp[l][h-1], dp[l+1][h]) + 1 l += 1 # The result is the minimum number of insertions needed for the entire string return dp[0][n-1]"},{"question":"# Problem Statement You have recently joined a team developing a banking application. One of the requirements is to create a function that can validate and format credit card numbers according to specific rules. Your task is to write a function `validate_credit_card` that takes a credit card number as input and performs the following tasks: 1. Verifies that the number is exactly 16 digits long. 2. Uses the Luhn algorithm to check if the number is valid. 3. Returns the credit card number formatted as groups of four digits separated by spaces if it is valid. 4. Raises appropriate exceptions for any invalid inputs or invalid card numbers. Input: - `card_num`: str (A string representing the credit card number) Output: - A string representing the `card_num` in the format \\"XXXX XXXX XXXX XXXX\\" if valid. Constraints: - The `card_num` should be a string and exactly 16 characters long. - The function should handle only numeric characters in the input. - Efficiency considerations: Aim for a time complexity of O(n) and space complexity of O(1). # Examples: 1. `validate_credit_card(\\"1234567812345670\\")` should return `\'1234 5678 1234 5670\'`. 2. `validate_credit_card(\\"4485275742308327\\")` should return `\'4485 2757 4230 8327\'`. 3. `validate_credit_card(\\"1234567812345678\\")` should raise a `ValueError` for an invalid card number. # Notes: - The Luhn algorithm should be used to validate the credit card number. - A `ValueError` should be raised if the card number is not exactly 16 digits long or contains non-numeric characters. - A `ValueError` should be raised for invalid credit card numbers as per the Luhn algorithm.","solution":"def validate_credit_card(card_num): Validate and format the credit card number using the Luhn algorithm. :param card_num: str : Credit card number to be validated and formatted :return: str : Formatted credit card number if valid :raises ValueError: If card number is invalid or input is not as expected # Check if card number is of valid length and contains only digits if len(card_num) != 16 or not card_num.isdigit(): raise ValueError(\\"Card number must be exactly 16 digits long and contain only numeric characters.\\") # Luhn algorithm to validate the credit card number def luhn_checksum(card_num): def digits_of(n): return [int(d) for d in str(n)] digits = digits_of(card_num) odd_digits = digits[-1::-2] even_digits = digits[-2::-2] checksum = sum(odd_digits) for d in even_digits: checksum += sum(digits_of(d * 2)) return checksum % 10 if luhn_checksum(card_num) != 0: raise ValueError(\\"Invalid credit card number.\\") # Format the card number into groups of four digits separated by spaces formatted_card_num = \\" \\".join([card_num[i:i+4] for i in range(0, 16, 4)]) return formatted_card_num"},{"question":"# Linear Search for Nearest Value Problem Statement You are provided with an unsorted list of integers. Your task is to implement a function that finds the number in the list that is closest in value to a given target number. If there are two numbers equally close to the target, return the smaller number. Write a function `nearest_value` that follows the signature: ```python def nearest_value(nums: list[int], target: int) -> int: ``` The function should: 1. **Raise a `ValueError`** if the `nums` list is empty. 2. Compute the closest number to the target in the list. 3. If two numbers are equally close to the target, return the smaller number. 4. Return the closest number in the list. Examples ```python >>> nearest_value([4, 7, 10, 11, 12, 17], 9) 10 >>> nearest_value([4, 7, 10, 11, 12, 17], 8) 7 >>> nearest_value([4, 7, 10, 11, 12, 17], 5) 4 >>> nearest_value([4, 4, 4, 4], 3) 4 >>> nearest_value([-10, -5, 0, 5, 10], -7) -5 >>> nearest_value([1, 2, 3], 2) 2 >>> nearest_value([], 5) Traceback (most recent call last): ... ValueError: The list `nums` must not be empty. ``` Provide an efficient implementation that finds the nearest value using a linear search. Pay special attention to handling edge cases and ensuring the function performs well even with large input lists.","solution":"def nearest_value(nums: list[int], target: int) -> int: if not nums: raise ValueError(\\"The list `nums` must not be empty.\\") closest_num = nums[0] min_diff = abs(nums[0] - target) for num in nums: diff = abs(num - target) if diff < min_diff or (diff == min_diff and num < closest_num): closest_num = num min_diff = diff return closest_num"},{"question":"# Coding Question: Valid Mountain Array You are given a list of integers representing an array. An array is considered a mountain array if: 1. It has at least three elements. 2. There exists some index `i` (0 < i < n-1) such that: - numbers[0] < numbers[1] < ... < numbers[i] - numbers[i] > numbers[i+1] > ... > numbers[n-1] Implement the function `is_mountain_array(numbers: list[int]) -> bool` which checks if an array is a mountain array. Input - `numbers`: A list of integers `numbers[0], numbers[1], ..., numbers[n-1]`, where `0 <= n <= 10^4` and `-10^4 <= numbers[i] <= 10^4`. Output - Return a boolean `True` if the array is a mountain array, otherwise return `False`. Constraints - Consider edge cases such as: arrays with fewer than three elements, arrays with strictly increasing or decreasing elements, and arrays with any repeated elements at the peak or elsewhere. Examples ```python >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 5]) False >>> is_mountain_array([0, 3, 2, 1]) True >>> is_mountain_array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) False >>> is_mountain_array([2, 0, 2]) False >>> is_mountain_array([3, 4, 1]) True ``` Performance Considerations The function should be efficient in both time and space complexity, ensuring it smoothly handles the input limit of up to `10^4` elements. Detailed Explanation: 1. Traverse the array in one pass to find the peak element. 2. Split the array into two parts: increasing and decreasing segments based on the peak. 3. Ensure that the transitions are strictly increasing followed by strictly decreasing. 4. Address edge cases such as insufficient length or no valid peak transition.","solution":"def is_mountain_array(numbers): Checks if the given list of numbers is a mountain array. if len(numbers) < 3: return False i = 0 # Ascending part while i + 1 < len(numbers) and numbers[i] < numbers[i + 1]: i += 1 # There must be a peak, meaning i cannot be 0 or the last index if i == 0 or i == len(numbers) - 1: return False # Descending part while i + 1 < len(numbers) and numbers[i] > numbers[i + 1]: i += 1 return i == len(numbers) - 1"},{"question":"# Question: Finding All Paths in a Directed Acyclic Graph (DAG) Given a Directed Acyclic Graph (DAG) with `N` nodes and `E` edges, you are required to implement a function that finds all possible paths from a given start node to a given end node. # Functions to Implement: 1. `all_paths_dag(N: int, edges: list[tuple[int, int]], start: int, end: int) -> list[list[int]]`: - **Input**: - `N`: Number of nodes in the graph (nodes are labeled from `1` to `N`). - `edges`: List of tuples where each tuple `(u, v)` represents a directed edge from node `u` to node `v`. - `start`: The starting node ID. - `end`: The ending node ID. - **Output**: A list of all possible paths, where each path is represented as a list of node IDs from `start` to `end`. # Constraints: - `1 <= N <= 100` - `1 <= E <= 1000` - The graph is a DAG, meaning it has no cycles. - Node IDs range from `1` to `N`. # Example: Given the following graph representation: ``` 1 -> 2 -> 4 / -> 3 ---- ``` With edges: [(1, 2), (1, 3), (2, 4), (3, 4)] ```python assert all_paths_dag(4, [(1, 2), (1, 3), (2, 4), (3, 4)], 1, 4) == [[1, 2, 4], [1, 3, 4]] assert all_paths_dag(4, [(1, 2), (1, 3), (2, 4), (3, 4)], 1, 3) == [[1, 3]] ``` Implement the `all_paths_dag` function considering the constraints and ensure that the output is efficient and correct for all possible valid inputs.","solution":"def all_paths_dag(N, edges, start, end): from collections import defaultdict # Build the graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) all_paths = [] def dfs(current, path): if current == end: all_paths.append(path) return for neighbor in graph[current]: dfs(neighbor, path + [neighbor]) dfs(start, [start]) return all_paths"},{"question":"# Problem Statement Consider converting a non-negative integer into a hexadecimal string. The hexadecimal representation should follow these rules: 1. The digits `0-9` represent values `0` to `9`. 2. The letters `a-f` (lowercase) represent values `10` to `15`. 3. There should be no leading zeros in the output unless the integer is `0`. **Task**: Write a Python function to convert a given non-negative integer into its hexadecimal string representation. # Function Signature ```python def to_hex(n: int) -> str: pass ``` # Inputs * `n` (int): A non-negative integer (0 <= n <= 2^32 - 1). # Outputs * Returns (str): The hexadecimal string representation of the integer. # Constraints * Input n should be a non-negative integer. * Handle the case where n is 0 and ensure no leading zeros in other cases. # Examples 1. `to_hex(26)` -> `\\"1a\\"` 2. `to_hex(0)` -> `\\"0\\"` 3. `to_hex(255)` -> `\\"ff\\"` 4. `to_hex(4096)` -> `\\"1000\\"` # Scenario You are given a problem where you need to convert a non-negative integer into its corresponding hexadecimal representation. This conversion must be efficient enough to handle values up to the maximum range of 32-bit unsigned integers. Implement this conversion by handling digit-to-character mapping manually, ensuring the output format meets the specified criteria.","solution":"def to_hex(n: int) -> str: Convert a non-negative integer to its hexadecimal string representation. Args: n (int): A non-negative integer Returns: str: Hexadecimal string representation of the integer if n == 0: return \\"0\\" hex_digits = \\"0123456789abcdef\\" result = [] while n > 0: result.append(hex_digits[n % 16]) n = n // 16 return \'\'.join(result[::-1])"},{"question":"# Random Forest Classifier Coding Question You are given a dataset containing various features of customers and whether or not they have subscribed to a term deposit. Your task is to implement a function using `RandomForestClassifier` that trains on these features to predict if a customer will subscribe. Ensure to follow these specific steps for implementation: **Function Implementation:** 1. **Function Signature**: `def random_forest_predict(data: dict) -> np.ndarray:` 2. **Input**: The input will be a dictionary with two keys, - `data`: A list of lists where each inner list represents the features of a customer. - `target`: A list of binary labels (1 for subscribed, 0 for not subscribed) corresponding to each list of features in `data`. 3. **Process**: * Split the dataset into training and testing sets using a 70-30 ratio for training and testing respectively. * Train the RandomForestClassifier using the training dataset. * Predict the subscription status for the test dataset. 4. **Output**: A numpy array containing the predicted subscription statuses for the test dataset. **Constraints**: * Ensure that all necessary preprocessing of the data is performed within the function. * Use appropriate RandomForest hyperparameters to balance the bias-variance trade-off. * Evaluate the model performance using Accuracy, Precision, Recall, and F1 Score. **Example**: ```python >>> data = { ... \\"data\\": [ ... [37, 1, 4, 30000, 1, 0, 2, 1], ... [53, 0, 5, 40000, 0, 1, 3, 0], ... # Add more feature sets ... ], ... \\"target\\": [1, 0, # Add more target labels ... ] ... } >>> random_forest_predict(data) array([1, 0]) # Example output representing predicted subscription statuses (not actual) ``` **Note**: The example provided in the main function of the code snippet is based on a generic term deposit subscription dataset. Refer to this example for guidance on processing and feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def random_forest_predict(data: dict) -> np.ndarray: Trains a RandomForestClassifier to predict the subscription status. Parameters: data (dict): A dictionary with keys \'data\' corresponding to features and \'target\' corresponding to labels. Returns: np.ndarray: Predicted subscription statuses for the test dataset. features = data[\'data\'] labels = data[\'target\'] # Split the dataset into training and testing sets (70% training, 30% testing) X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.3, random_state=42) # Initialize RandomForestClassifier clf = RandomForestClassifier(n_estimators=100, random_state=42) # Train the classifier clf.fit(X_train, y_train) # Predict on the test set y_pred = clf.predict(X_test) # Calculate and print metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) print(f\'Accuracy: {accuracy:.4f}\') print(f\'Precision: {precision:.4f}\') print(f\'Recall: {recall:.4f}\') print(f\'F1 Score: {f1:.4f}\') return y_pred"},{"question":"# Problem Statement You are required to write a function that takes a list of integers and returns a new list containing only the prime numbers from the original list. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. This function will be useful in applications where filtering for prime elements within a list is necessary. The implementation should be optimized to handle large lists efficiently. # Details 1. **Function Name**: `extract_primes` 2. **Input**: A list, `numbers` with n elements where each element is a non-negative integer. 3. **Output**: A new list with only the prime numbers from the input list. 4. **Constraints**: - The input list can be of any length from 0 to 10^5. - Each element in the input list is between 0 and 10^6. # Expectations: * **Correctness**: The returned list should contain only prime numbers in the order they appeared in the input list. * **Performance**: The solution should efficiently handle the given constraints. * **Edge Cases**: Consider empty lists, lists with no prime numbers, and lists where all elements are prime numbers. # Example ```python def extract_primes(numbers: list) -> list: # Your implementation here assert extract_primes([10, 11, 12, 13, 14, 15, 3, 5]) == [11, 13, 3, 5] assert extract_primes([]) == [] assert extract_primes([1, 4, 6, 8, 10]) == [] assert extract_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] assert extract_primes([0, 1, 1, 0]) == [] ``` # Code Constraints * You must write a helper function to determine if a number is prime. * You should use efficient algorithms to check for primality to handle the upper limits of the constraints effectively. * The implementation should be able to process the input list in a reasonable amount of time for large lists.","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def extract_primes(numbers): Returns a list of prime numbers from the input list \'numbers\'. return [num for num in numbers if is_prime(num)]"},{"question":"# Question: You are to write a function that takes an integer `n` and returns all the prime numbers up to `n` using the Sieve of Eratosthenes algorithm. The function should handle edge cases such as when `n` is less than 2 by returning an empty list. Function Signature: ```python def sieve_of_eratosthenes(n: int) -> List[int]: pass ``` Parameters: - `n` (int): An integer up to which prime numbers are to be found. Output: - The function should return a list of integers representing all prime numbers from 2 to `n`, inclusive. Constraints: - If `n` is less than 2, return an empty list. Example: ```python assert sieve_of_eratosthenes(10) == [2, 3, 5, 7] assert sieve_of_eratosthenes(25) == [2, 3, 5, 7, 11, 13, 17, 19, 23] assert sieve_of_eratosthenes(2) == [2] assert sieve_of_eratosthenes(1) == [] assert sieve_of_eratosthenes(0) == [] assert sieve_of_eratosthenes(-10) == [] ```","solution":"from typing import List def sieve_of_eratosthenes(n: int) -> List[int]: Returns all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False # 0 and 1 are not primes p = 2 while p * p <= n: if is_prime[p]: for multiple in range(p * p, n + 1, p): is_prime[multiple] = False p += 1 return [num for num in range(2, n + 1) if is_prime[num]]"},{"question":"# Coding Assessment Question: Implement Trie Data Structure for Prefix Search **Context**: You are developing a text editor that includes an efficient auto-completion feature. To accomplish this, you need to implement a Trie (prefix tree) data structure that allows fast insertion of words and prefix-based searches. **Problem Statement**: Write a class named `Trie` that implements a Trie for storing strings and supports two operations: inserting a word and searching for words that start with a given prefix. **Class Definition**: ```python class Trie: def __init__(self): Initialize the root of the trie. pass def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string representing the word to be inserted. pass def search_prefix(self, prefix: str) -> list[str]: Returns a list of all words in the trie that start with the given prefix. :param prefix: A string representing the prefix to be searched. :returns: A list of strings representing the words that start with the given prefix. pass ``` **Input**: - `word`: A string to be inserted into the Trie. - `prefix`: A string representing the prefix for searching in the Trie. **Output**: - For the `insert` method, there is no output. - For the `search_prefix` method, return a list of strings that represent all the words starting with the given prefix. **Constraints**: - 1 ≤ length of word ≤ 100 - 1 ≤ length of prefix ≤ 100 - All words contain lowercase English letters only. - You can assume no duplicate words will be inserted into the trie. **Performance Requirements**: - Insertion and search operations should be efficient and handle up to 10^5 operations efficiently. **Example**: ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"application\\") trie.insert(\\"banana\\") trie.insert(\\"band\\") print(trie.search_prefix(\\"app\\")) # Expected Output: [\\"apple\\", \\"app\\", \\"application\\"] print(trie.search_prefix(\\"ban\\")) # Expected Output: [\\"banana\\", \\"band\\"] print(trie.search_prefix(\\"cat\\")) # Expected Output: [] ``` Your implementation will be tested against various cases, including edge cases and performance-critical situations. Ensure your solution is both correct and efficient.","solution":"class TrieNode: def __init__(self): Initialize the TrieNode with a children dictionary and a boolean indicator for end of word. self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the root of the trie. self.root = TrieNode() def insert(self, word: str) -> None: Inserts a word into the trie. :param word: A string representing the word to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_prefix(self, prefix: str) -> list[str]: Returns a list of all words in the trie that start with the given prefix. :param prefix: A string representing the prefix to be searched. :returns: A list of strings representing the words that start with the given prefix. def dfs(node, prefix): if node.is_end_of_word: results.append(prefix) for char, child_node in node.children.items(): dfs(child_node, prefix + char) # First, find the end node of the given prefix node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix) return results"},{"question":"# Question: Implement a Uniform Cost Search Algorithm for the Shortest Path in a Grid Context: You are required to implement a pathfinding algorithm using the Uniform Cost Search (UCS) strategy to determine the shortest path in a grid. The grid will be represented as a 2D array of integers where each cell indicates the cost of moving through that cell. The algorithm should account for movements in the four cardinal directions (up, down, left, right) and should avoid cells that are labeled with a cost of -1 (these cells are considered obstacles). Requirements: 1. **Function Signature**: - `def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[int]` 2. **Input and Output Formats**: - The function accepts three parameters: - `grid`: A 2D list of integers representing the cost grid. - `start`: A tuple of two integers representing the starting cell coordinates (row, col). - `goal`: A tuple of two integers representing the goal cell coordinates (row, col). - The function returns an integer representing the minimal cost of the path from `start` to `goal`, or `None` if no path exists. 3. **Constraints**: - The grid can have dimensions up to 100x100. - All costs are non-negative integers (excluding -1 for obstacles). - The start and goal coordinates will always be within valid indices of the grid and not on obstacle cells. - The goal cell coordinates can be the same as the start cell coordinates. - Implement error handling for invalid inputs (non-list grid, non-tuple start/goal, etc.). 4. **Performance Requirements**: - Your solution should run efficiently with a time complexity of O(m * n log(m * n)), where m is the number of rows and n is the number of columns in the grid. Example Usage: ```python grid = [ [1, 2, 3], [1, -1, 4], [1, 1, 1] ] start = (0, 0) goal = (2, 2) assert find_shortest_path(grid, start, goal) == 5 # The path costs 1 (start) + 1 (down) + 1 (down) + 1(right) + 1(right) grid = [ [1, 2, 3], [1, -1, 4], [1, -1, 1] ] goal = (2, 1) assert find_shortest_path(grid, start, goal) == None # No path due to obstacles assert find_shortest_path([], start, goal) == ValueError(\\"grid is empty\\") assert find_shortest_path(grid, (100, 100), goal) == ValueError(\\"start position out of bounds\\") ``` Instructions: 1. Write the `find_shortest_path` function following the mentioned specifications. 2. Implement the Uniform Cost Search algorithm ensuring it respects cardinal direction constraints. 3. Ensure your code is well-tested with provided assertions. 4. Handle all edge cases and potential exceptions gracefully, including but not limited to empty grids and out-of-bounds coordinates.","solution":"from heapq import heappop, heappush from typing import List, Tuple, Optional def find_shortest_path(grid: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[int]: if not isinstance(grid, list) or not grid: raise ValueError(\\"grid is empty or not a list\\") if not (isinstance(start, tuple) and len(start) == 2 and isinstance(goal, tuple) and len(goal) == 2): raise ValueError(\\"start or goal is not a valid tuple\\") rows, cols = len(grid), len(grid[0]) if not (0 <= start[0] < rows and 0 <= start[1] < cols): raise ValueError(\\"start position out of bounds\\") if not (0 <= goal[0] < rows and 0 <= goal[1] < cols): raise ValueError(\\"goal position out of bounds\\") def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] != -1: yield nx, ny pq = [(grid[start[0]][start[1]], start)] min_cost = {start: grid[start[0]][start[1]]} while pq: current_cost, (x, y) = heappop(pq) if (x, y) == goal: return current_cost for nx, ny in get_neighbors(x, y): new_cost = current_cost + grid[nx][ny] if (nx, ny) not in min_cost or new_cost < min_cost[(nx, ny)]: min_cost[(nx, ny)] = new_cost heappush(pq, (new_cost, (nx, ny))) return None"},{"question":"**Problem Description**: You are working on designing a scheduling algorithm for a round-robin execution system. In this system, tasks are assigned with priority levels and the goal is to determine the number of complete iterations needed to process all tasks exactly once. Each task must be processed entirely in one iteration and no fraction of a task can be split across iterations. The scheduling strictly adheres to round-robin order, meaning each task gets its turn in sequence before any task is repeated. **Function Specification**: Implement the function `round_robin_iterations(task_lengths: List[int], time_quantum: int) -> int`. This function should take a list of integers `task_lengths` representing the processing time required for each task, and an integer `time_quantum` representing the maximum time a task can take in one iteration. The function should return an integer representing the number of complete iterations required to process all tasks exactly once. **Constraints**: * The list `task_lengths` will contain at least one element and at most 10^5 elements. * The time quantum `time_quantum` will be a positive integer. **Input**: * `task_lengths` - List of integers, where each element represents the processing time required for each task and is within the range [1, 10^5]. * `time_quantum` - A positive integer representing the time quantum for each task. **Output**: * An integer representing the number of complete iterations required to process all tasks exactly once under the given time quantum constraint. **Examples**: ```python round_robin_iterations([5, 10, 15, 20], 10) == 2 round_robin_iterations([7, 7, 7, 7], 5) == 2 round_robin_iterations([1, 2, 3, 4], 4) == 1 round_robin_iterations([10, 20, 30], 15) == 2 ``` **Function Signature**: ```python from typing import List def round_robin_iterations(task_lengths: List[int], time_quantum: int) -> int: # Implement the function pass ``` **Notes**: * Raise a `ValueError` if the time quantum is not a positive integer. * Ensure to handle all edge cases including lists with tasks whose lengths are exactly the same as the time quantum or very large numbers. * Focus on optimizing the performance for large input sizes.","solution":"from typing import List import math def round_robin_iterations(task_lengths: List[int], time_quantum: int) -> int: Returns the number of complete iterations required to process all tasks exactly once. :param task_lengths: List of integers representing the time required for each task :param time_quantum: An integer representing the maximum time a task can take in one iteration :return: An integer representing the number of complete iterations required to process all tasks once if time_quantum <= 0: raise ValueError(\\"Time quantum must be a positive integer.\\") iterations = 0 for task in task_lengths: iterations = max(iterations, math.ceil(task / time_quantum)) return iterations"},{"question":"**Title**: Find and Fix Broken Elements in a Sorted List **Objective**: Write a function to identify elements in a given sorted list that do not fit the sorted order, and return a list of indices of these broken elements. **Function Signature**: ```python def find_broken_elements(lst: List[int]) -> List[int]: pass ``` **Input**: * lst (List[int]): A list of integers that is supposed to be in non-decreasing order but may have a few elements out of place. **Output**: * List[int]: A list of indices where elements in the original list are out of non-decreasing order. **Constraints**: * The list will have between 1 and 10^4 elements. * The elements are not necessarily unique. * The list is mostly sorted with at most `x` elements out of place, where `x` is significantly smaller than the length of the list. **Performance Requirements**: * Time Complexity: `O(N)` * Space Complexity: `O(1)` (excluding the space required for the input and output) **Context**: The given list should be in a non-decreasing order, but due to some anomalies, certain elements might be out of place. Your task is to identify the indices of these broken elements. **Example**: ```python # Example sorted list usage lst = [1, 3, 2, 4, 5, 7, 6, 8, 10] result = find_broken_elements(lst) print(result) # Output: [1, 5] # Explanation: # Element 3 at index 1 breaks the sorting order since 3 > 2. # Element 7 at index 5 breaks the sorting order since 7 > 6. ``` **Note**: * Ensure you only return the indices where the sorted order is broken. * The list may have multiple elements out of place, but it\'s important to check each element only once and maintain linear time complexity.","solution":"from typing import List def find_broken_elements(lst: List[int]) -> List[int]: broken_indices = [] for i in range(len(lst) - 1): if lst[i] > lst[i + 1]: if i not in broken_indices: broken_indices.append(i) if i + 1 not in broken_indices: broken_indices.append(i + 1) return broken_indices"},{"question":"# Problem Statement You are developing a function that processes sales data from a JSON API and computes the total sales revenue for a specific product within a given date range. This task will involve making network requests, parsing JSON data, and filtering based on dates. # Functionality Requirements - Implement a function `calculate_product_revenue(product_id: int, start_date: str, end_date: str) -> float` that fetches sales data and computes the total revenue for the specified product within the given date range. - The API endpoint for fetching sales data is `https://example.com/api/sales`. - Each entry in the sales data includes `{\\"product_id\\": int, \\"sale_date\\": str, \\"amount\\": float}`. - The function should handle errors such as network issues or invalid API responses gracefully. - Ensure the date format for `start_date` and `end_date` is `YYYY-MM-DD`. # Constraints - The function should not exceed 10 seconds per API request. - You must use the `requests` library for sending HTTP requests. - The API might return large datasets; ensure efficient processing. # Input - `product_id` (int): The unique identifier for the product. - `start_date` (str): The start date in `YYYY-MM-DD` format. - `end_date` (str): The end date in `YYYY-MM-DD` format. # Output - A float representing the total sales revenue for the specified product within the date range. # Examples ```python calculate_product_revenue(101, \\"2023-01-01\\", \\"2023-01-31\\") ``` should return: ```python 3450.75 ``` # Scenario You are building an analytics dashboard for a retail company. The dashboard requires real-time calculation of sales revenue for various products over different time periods. Ensuring accurate and efficient revenue computation is crucial. # Performance Requirements - Handle large datasets efficiently to avoid performance bottlenecks. - Make sure the function can handle edge cases like invalid dates or empty datasets. - Optimize for minimal network calls and quick processing. # Hints - Use date parsing libraries like `datetime` to handle date range filtering. - Consider paginating API requests if the dataset is large to avoid timeouts or performance issues. - Utilize try-except blocks to handle network errors and invalid data gracefully.","solution":"import requests from datetime import datetime def calculate_product_revenue(product_id: int, start_date: str, end_date: str) -> float: Fetches sales data from a JSON API and computes the total sales revenue for a specific product within a given date range. :param product_id: The unique identifier for the product. :param start_date: The start date in YYYY-MM-DD format. :param end_date: The end date in YYYY-MM-DD format. :return: The total sales revenue for the specified product within the date range. api_url = \\"https://example.com/api/sales\\" start_date_obj = datetime.strptime(start_date, \\"%Y-%m-%d\\") end_date_obj = datetime.strptime(end_date, \\"%Y-%m-%d\\") total_revenue = 0.0 try: response = requests.get(api_url, timeout=10) response.raise_for_status() sales_data = response.json() for record in sales_data: if record[\'product_id\'] == product_id: sale_date = datetime.strptime(record[\'sale_date\'], \\"%Y-%m-%d\\") if start_date_obj <= sale_date <= end_date_obj: total_revenue += record[\'amount\'] except requests.RequestException as e: print(f\\"Network or API error occurred: {e}\\") except ValueError as e: print(f\\"Error parsing response data: {e}\\") return total_revenue"},{"question":"# Problem Statement In this task, you will implement the Radix Sort algorithm to sort a list of integers. Radix Sort is a non-comparative sorting algorithm that sorts numbers by processing individual digits. # Requirements 1. Write a function named `radix_sort` in Python. 2. The function should take a list of integers and return the list sorted in ascending order. 3. Your implementation should adhere to the following steps: - Identify the number with the maximum number of digits in the given list. - Implement a stable counting sort subroutine to sort numbers based on each digit, starting from the least significant digit to the most significant digit. 4. Do not use any existing sorting functions provided by Python. # Function Signature ```python def radix_sort(array: list[int]) -> list[int]: pass ``` # Input * A list of integers, which can include negative numbers (e.g., `[170, 45, 75, 90, 802, 24, 2, 66]`). # Output * A list of integers sorted in ascending order. # Constraints * The input list can have up to 1000 elements. * The integers in the list range from -10^4 to 10^4. # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([]) == [] assert radix_sort([10, 1, 1000, 100]) == [1, 10, 100, 1000] assert radix_sort([-10, -1, -1000, -100]) == [-1000, -100, -10, -1] ``` # Notes - Ensure that the implementation can handle both positive and negative numbers. - Pay special attention to edge cases, such as empty lists. - Make sure to efficiently handle the range of numbers provided in the constraints. - Optimize both time and space complexity of your solution.","solution":"def radix_sort(array: list[int]) -> list[int]: def counting_sort(arr, exp, base): n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = (arr[i] // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] if len(array) == 0: return array max_num = max(array, key=abs) base = 10 exp = 1 while abs(max_num) // exp > 0: counting_sort(array, exp, base) exp *= base negative_part = [num for num in array if num < 0] non_negative_part = [num for num in array if num >= 0] return negative_part + non_negative_part"},{"question":"# Coding Assessment Question **Scenario**: In computer science, sorting algorithms are essential for efficiently organizing data. Sorting large datasets can significantly improve performance in data retrieval and manipulation tasks. While there are various common sorting algorithms like quicksort and mergesort, it is often insightful to implement custom sorting algorithms to better understand their mechanics. **Problem Statement**: You are required to implement a custom sorting algorithm that sorts a list of integers. Design the following function in Python: 1. `custom_sort(arr: List[int]) -> List[int]`: This function should sort the list of integers in non-decreasing order using a custom sorting algorithm. Implement Bucket Sort for this task. # Function Signature ```python def custom_sort(arr: List[int]) -> List[int]: pass ``` # Input and Output Format * **Input**: * `arr` (List[int]): A list of integers that you want to sort. * **Output**: * `arr` (List[int]): A list of integers sorted in non-decreasing order. # Constraints * The length of `arr` will be between 0 and 10^6. * Each integer in `arr` will be between -10^9 and 10^9. # Example ```python assert custom_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8] assert custom_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert custom_sort([-5, 3, 0, -2, -1, 2, 1, 4, -3, -4]) == [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4] assert custom_sort([]) == [] ``` # Algorithm 1. **Bucket Creation**: Create `n` empty buckets where `n` is the number of elements in the list. 2. **Scatter**: Go through the original list and put each element into a bucket. 3. **Sort Individual Buckets**: Sort each non-empty bucket using insertion sort. 4. **Concatenate**: Concatenate all sorted buckets to get the sorted list. Implement the `custom_sort` function as described, ensuring it handles all potential edge cases, including empty lists and lists containing negative numbers.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: if not arr: return arr min_val, max_val = min(arr), max(arr) bucket_range = (max_val - min_val) // len(arr) + 1 buckets = [[] for _ in range((max_val - min_val) // bucket_range + 1)] for num in arr: bucket_index = (num - min_val) // bucket_range buckets[bucket_index].append(num) sorted_arr = [] for bucket in buckets: insertion_sort(bucket) sorted_arr.extend(bucket) return sorted_arr def insertion_sort(bucket): for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key"},{"question":"# Coding Assessment Question Objective: Show your ability to work with linked lists and perform manipulations such as reversing sublists within the linked list. Problem Statement: Given the head of a singly linked list and two integers `left` and `right` where **1 ≤ left ≤ right ≤ n** (n is the length of the linked list), reverse the nodes of the list from position `left` to position `right` and return the modified list. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, left: int, right: int) -> ListNode: # Your code here ``` # Input 1. `head`: The head node of a singly linked list. 2. `left`: An integer representing the starting position of the sublist to reverse. 3. `right`: An integer representing the ending position of the sublist to reverse. # Output - The head of the modified linked list after reversing the sublist from position `left` to `right`. # Constraints - The number of nodes in the linked list is in the range `[1, 500]`. - `-500 ≤ Node.val ≤ 500` - `1 ≤ left ≤ right ≤ n` # Example ```python # Example 1: node5 = ListNode(5) node4 = ListNode(4, node5) node3 = ListNode(3, node4) node2 = ListNode(2, node3) head1 = ListNode(1, node2) result1 = reverse_between(head1, 2, 4) # The linked list becomes 1->4->3->2->5 # Convert linked list to list for easy assertion def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result assert linked_list_to_list(result1) == [1, 4, 3, 2, 5] # Example 2: node2 = ListNode(2) head2 = ListNode(5, node2) result2 = reverse_between(head2, 1, 2) # The linked list becomes 2->5 assert linked_list_to_list(result2) == [2, 5] ``` Guidelines: 1. Traverse to the `left` position in the list. 2. Reverse the sublist from position `left` to `right`. 3. Reconnect the reversed sublist with the rest of the list. 4. Handle edge cases where sublist to reverse includes the head or the tail of the list. Use dummy nodes if necessary for easier manipulation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, left: int, right: int) -> ListNode: # Base case: If head is None or there\'s no need to reverse, return head if not head or left == right: return head # Step 1: Create a dummy node to handle edge cases smoothly dummy = ListNode(0) dummy.next = head prev = dummy # Step 2: Move prev to the node just before the \\"left\\" position for _ in range(left - 1): prev = prev.next # Step 3: Start reversing the sublist from left to right reverse_start = prev.next curr = reverse_start.next for _ in range(right - left): reverse_start.next = curr.next curr.next = prev.next prev.next = curr curr = reverse_start.next return dummy.next"},{"question":"**Context**: In a database-driven application, you often need to manage data within structured datasets like tables, grids, or spreadsheets. A common task is to identify the most frequently occurring items within a dataset to make data-driven decisions. **Coding Task**: Write a function named `most_frequent_item` that takes a list of items and returns the item that appears most frequently. To break ties, return the first item that reaches the highest frequency. # Input * The function will be called as: `most_frequent_item(items: List[str]) -> str` * `items` (a list of strings): A list of items (1 ≤ len(items) ≤ 10^6). Each item is a non-empty string. # Output * Return a string, indicating the item that appears most frequently in the input list. * If there is a tie, return the item that first reached the highest frequency. # Constraints * Ensure the solution is optimized for large datasets. # Example ```python def most_frequent_item(items: List[str]) -> str: # Your implementation here # Example usage print(most_frequent_item([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"])) # Output: \\"apple\\" print(most_frequent_item([\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"mouse\\"])) # Output: \\"cat\\" ``` # Explanation * In the first example, \\"apple\\" appears 3 times, which is more than any other item. * In the second example, \\"cat\\" and \\"dog\\" both appear twice, but \\"cat\\" reaches a frequency of 2 first in the list. Therefore, \\"cat\\" is returned.","solution":"from typing import List def most_frequent_item(items: List[str]) -> str: Returns the most frequent item in the list. In case of a tie, it returns the first item reaching the highest frequency. frequency = {} max_count = 0 max_item = None for item in items: frequency[item] = frequency.get(item, 0) + 1 if frequency[item] > max_count: max_count = frequency[item] max_item = item return max_item"},{"question":"# Prime Number Finder Scenario Prime numbers are fundamental in various fields within computer science and mathematics. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your task is to implement an efficient algorithm to find all prime numbers up to a given number `n` using the Sieve of Eratosthenes. Task 1. Implement the Sieve of Eratosthenes algorithm to find all prime numbers up to `n`. 2. Write a function `generate_primes` to generate prime numbers. 3. Ensure your function can handle inputs up to 100,000 efficiently. Requirements * **Function Signature**: ```python def generate_primes(n: int) -> List[int]: ``` * **Input**: * The `generate_primes` function should take an integer `n` as input, representing the upper limit for generating primes. * **Output**: * The `generate_primes` function should return a list of integers containing all prime numbers up to `n`. Constraints * The input number `n` will be a positive integer no greater than 100,000. Example ```python def generate_primes(n): primes = [] is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 for p in range(2, n + 1): if is_prime[p]: primes.append(p) return primes # Test the function n = 30 print(f\\"Primes up to {n}: {generate_primes(n)}\\") # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Performance Requirements * Implement the Sieve of Eratosthenes in a way that efficiently computes the result. * Ensure that for a large value of `n` (up to 100,000), your function can complete in a reasonable time frame. This question tests your ability to implement an efficient algorithm for a common mathematical problem, ensuring you understand both algorithm design and optimization within given constraints.","solution":"from typing import List def generate_primes(n: int) -> List[int]: Generate all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. :param n: Upper limit to generate primes. :return: A list of all prime numbers up to and including n. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for p in range(2, int(n ** 0.5) + 1): if is_prime[p]: for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return [num for num in range(2, n + 1) if is_prime[num]]"},{"question":"# Coding Question: Merge Overlapping Intervals Context: Merging overlapping intervals is a common problem in computational geometry, scheduling applications, and various algorithmic challenges. It involves combining intervals that overlap into a single interval and is essential for optimizing resources and simplifying data representation. Task: Write a Python function `merge_intervals(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]` to merge overlapping intervals in a given list. Input Format: * `intervals`: A list of tuples, where each tuple consists of two integers, representing the start and end of an interval. The intervals may not be sorted initially. Output Format: Return a list of tuples representing the merged intervals in sorted order. Constraints: 1. The input list can be empty. 2. The tuples represent intervals, where the first integer is less than or equal to the second integer. 3. The function should work with any number of intervals. 4. You must return the intervals sorted based on the starting values. Example: ```plaintext Input: [(1, 3), (2, 6), (8, 10), (15, 18)] Output: [(1, 6), (8, 10), (15, 18)] Input: [(1, 4), (4, 5)] Output: [(1, 5)] Input: [(6, 8), (1, 3), (2, 4)] Output: [(1, 4), (6, 8)] Input: [] Output: [] ``` Notes: * This problem tests your understanding of sorting algorithms, interval manipulations, and edge case handling. * Pay close attention to edge cases such as intervals that are exactly adjacent or completely non-overlapping. * Ensure your solution is efficient and handles the intervals in a way that avoids unnecessary computations.","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of merged intervals sorted by starting values. Parameters: intervals (list of tuples): The list of intervals where each interval is represented by a tuple (start, end). Returns: list of tuples: The merged and sorted list of intervals. if not intervals: return [] # Sort intervals by starting value intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] # If the current interval overlaps with the previous interval if current[0] <= previous[1]: # Merge the two intervals merged[-1] = (previous[0], max(previous[1], current[1])) else: # Add the current interval to the list merged.append(current) return merged"},{"question":"# Palindromic Index Finder Context Given a sequence of characters, a palindrome is a sequence that reads the same backwards as forwards. For example, \\"racecar\\" and \\"level\\" are palindromes. Task You need to implement the function `first_palindromic_index(chars: str, length: int) -> int` which finds the starting index of the first palindromic substring of the specified length. If no such substring exists, the function should return -1. Function Signature ```python def first_palindromic_index(chars: str, length: int) -> int ``` Input * `chars` (str): A string consisting of lowercase letters. * `length` (int): An integer representing the length of the palindromic substring to find. Output * Returns an integer representing the starting index of the first palindromic substring of the specified length. Constraints * Ensure the length of the substring never exceeds the length of `chars`. * If `length` is greater than the length of `chars`, return -1. * The function should be optimized for sequences up to length `10^5`. Examples ```python first_palindromic_index(\\"abacdfgdcabba\\", 3) -> 0 # \\"aba\\" is the first substring of length 3 which is a palindrome. first_palindromic_index(\\"abcdefg\\", 3) -> -1 # No palindrome of length 3. first_palindromic_index(\\"madamracecar\\", 5) -> 0 # \\"madam\\" is the first palindrome of length 5. ``` Note * Ensure the function handles edge cases where there may be multiple palindromic substrings within the input sequence. * Use efficient string manipulation and checking techniques to ensure performance on large sequences. Hints 1. Consider using two-pointer technique or slicing for checking palindromes. 2. Ensure the function iterates efficiently without redundant checks.","solution":"def first_palindromic_index(chars: str, length: int) -> int: Returns the starting index of the first palindromic substring of specified length. If no such substring exists, returns -1. n = len(chars) if length > n: return -1 for i in range(n - length + 1): substr = chars[i:i+length] if substr == substr[::-1]: return i return -1"},{"question":"# Problem Statement You are given a list of integers representing the heights of buildings along a straight road. Your task is to implement a function that finds the maximum sunlit building height. A building is sunlit if there is no taller building to its left blocking the sunlight. # Function Signature ```python def max_sunlit_building(heights: List[int]) -> int: pass ``` # Input * A list `heights` of integers (1 ≤ `len(heights)` ≤ 1000, 1 ≤ `heights[i]` ≤ 10^4), where each integer represents the height of a building. # Output * A single integer representing the height of the tallest sunlit building. # Example ```python print(max_sunlit_building([4, 3, 5, 1, 3])) # Should output 5 print(max_sunlit_building([10, 20, 22, 21, 19])) # Should output 22 ``` # Constraints * The input list will always contain at least one building. * The returned result should be a valid integer height of a sunlit building. # Performance Requirements Your implementation should be efficient enough to handle the largest possible input size within reasonable time limits, considering the constraints provided.","solution":"from typing import List def max_sunlit_building(heights: List[int]) -> int: Finds the maximum height of sunlit buildings. A building is sunlit if no taller building is to its left. max_height = 0 max_sunlit_height = heights[0] for height in heights: if height > max_height: max_height = height max_sunlit_height = max(max_sunlit_height, height) return max_sunlit_height"},{"question":"Problem Description You are tasked with creating a tournament ranking system for a sporting event. Teams are awarded points based on their match results, and you need to determine the final standings. # Input - A list of strings where each string represents the result of one match in the format \\"Team1 Score1 - Score2 Team2\\". Each match result describes the scores of two competing teams separated by a dash (`-`) and a space. The match\'s result can be a win, loss, or draw. # Output - A list of strings, where each string represents a team and its total points, sorted in descending order of points. In case of a tie in points, teams should be ordered alphabetically by their team name. # Explanation - Winning team gets 3 points. - Losing team gets 0 points. - In case of a draw, both teams get 1 point each. # Function Signature ```python def rank_teams(matches: list[str]) -> list[str]: pass ``` # Constraints - Each team will have a unique name. - Each match result is valid and contains non-negative integer scores. - The list of match results contains at most 1000 matches. - No team will play more than 100 matches. # Example ```python matches = [ \\"TeamA 3 - 1 TeamB\\", \\"TeamC 2 - 2 TeamD\\", \\"TeamA 1 - 1 TeamC\\", \\"TeamB 0 - 3 TeamD\\" ] print(rank_teams(matches)) # Output: [\'TeamA 4\', \'TeamD 4\', \'TeamC 2\', \'TeamB 0\'] ``` # Notes - Ensure to handle all edge cases, such as teams with zero points or teams that have only played drawn matches. - Implement the function to process the list of match results, calculate the total points for each team, and return the sorted standings according to the described rules. - Points should be calculated and stored correctly before sorting the results.","solution":"def rank_teams(matches: list[str]) -> list[str]: # Dictionary to store the points for each team team_points = {} # Process each match result for match in matches: parts = match.split(\\" - \\") team1, score1 = parts[0].rsplit(\\" \\", 1) score2, team2 = parts[1].split(\\" \\", 1) score1 = int(score1) score2 = int(score2) if team1 not in team_points: team_points[team1] = 0 if team2 not in team_points: team_points[team2] = 0 if score1 > score2: team_points[team1] += 3 elif score1 < score2: team_points[team2] += 3 else: team_points[team1] += 1 team_points[team2] += 1 # Sort teams first by points in descending order, then by name in ascending order sorted_teams = sorted(team_points.items(), key=lambda item: (-item[1], item[0])) # Prepare the final output in desired format result = [f\\"{team} {points}\\" for team, points in sorted_teams] return result"},{"question":"# Coding Question Context: You are tasked with analyzing a sequence of operations on a stack data structure. Your goal is to detect balanced parentheses and evaluate postfix expressions utilizing the stack\'s properties. This is crucial for validating programming languages\' syntax and evaluating mathematical expressions. Requirements: 1. **Function Implementations**: * Implement the `is_balanced_parentheses` function to verify if a string contains balanced parentheses. * Implement the `evaluate_postfix` function to compute the result of a postfix expression. 2. **Input Format**: * `is_balanced_parentheses`: A string containing parentheses. * `evaluate_postfix`: A string representing a postfix expression containing integers and operators (`+`, `-`, `*`, `/`). 3. **Output Format**: * `is_balanced_parentheses`: A boolean value (`True` if it is balanced, `False` otherwise). * `evaluate_postfix`: An integer/float value representing the result of the postfix evaluation. 4. **Constraints**: * The input strings for both functions can be empty. * The `evaluate_postfix` function should handle division accurately (e.g., integer division). * Raise `ValueError` for invalid inputs (e.g., incorrect characters in the input). Function Signatures: ```python def is_balanced_parentheses(s: str) -> bool: pass def evaluate_postfix(expression: str) -> float: pass ``` Example: ```python # Example for is_balanced_parentheses print(is_balanced_parentheses(\\"()\\")) # Output: True print(is_balanced_parentheses(\\"(()\\")) # Output: False print(is_balanced_parentheses(\\"((()))\\")) # Output: True print(is_balanced_parentheses(\\")(\\")) # Output: False # Example for evaluate_postfix print(evaluate_postfix(\\"3 4 +\\")) # Output: 7 print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Output: 14 print(evaluate_postfix(\\"2 3 1 * + 9 -\\")) # Output: -4 print(evaluate_postfix(\\"\\")) # Output: 0.0 ``` Description: 1. **`is_balanced_parentheses` Function**: * Takes a string `s` as input. * Returns `True` if the input string has balanced parentheses, `False` otherwise. * Raises `ValueError` for non-string inputs. 2. **`evaluate_postfix` Function**: * Takes a string `expression` as input. * Evaluates the postfix expression and returns the result. * Raises `ValueError` for invalid characters or malformed expressions. * Returns `0.0` if the input string is empty.","solution":"def is_balanced_parentheses(s: str) -> bool: stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack def evaluate_postfix(expression: str) -> float: stack = [] if not expression: return 0.0 for token in expression.split(): if token.isdigit(): stack.append(int(token)) elif token in {\'+\', \'-\', \'*\', \'/\'}: if len(stack) < 2: raise ValueError(\\"Invalid postfix expression\\") b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) else: raise ValueError(\\"Invalid character in postfix expression\\") if len(stack) != 1: raise ValueError(\\"Invalid postfix expression\\") return stack.pop()"},{"question":"# Coding Assessment Question **Problem Statement:** You are tasked with writing a function that determines if a given word is readable when typed on a single row of the QWERTY keyboard layout. The QWERTY keyboard layout on a standard keyboard looks like this: - First row (top row): \\"qwertyuiop\\" - Second row (home row): \\"asdfghjkl\\" - Third row (bottom row): \\"zxcvbnm\\" Your function should check if all the characters of the input word can be found on exactly one of these rows. If the word is readable on a single row, return `True`; otherwise, return `False`. **Function Signature:** ```python def is_readable_on_one_row(word: str) -> bool: pass ``` # Input: - A single string `word` consisting of lowercase alphabetical characters. # Output: - Returns a boolean value `True` if the word can be typed using letters from one row of the QWERTY keyboard, `False` otherwise. # Constraints: - The input string `word` will not contain any spaces or non-alphabetical characters. # Example Usage: ```python print(is_readable_on_one_row(\\"typ\\")) # Output: True print(is_readable_on_one_row(\\"hello\\")) # Output: False ``` # Edge Cases: - Input word contains letters only from one row. - Input word contains letters from multiple rows. **Test Cases:** 1. `is_readable_on_one_row(\\"hello\\")` should return `False`. 2. `is_readable_on_one_row(\\"type\\")` should return `True`. 3. `is_readable_on_one_row(\\"qwerty\\")` should return `True`. 4. `is_readable_on_one_row(\\"asdfg\\")` should return `True`. 5. `is_readable_on_one_row(\\"moon\\")` should return `False`.","solution":"def is_readable_on_one_row(word: str) -> bool: first_row = set(\\"qwertyuiop\\") second_row = set(\\"asdfghjkl\\") third_row = set(\\"zxcvbnm\\") # Determine which row the first character belongs to if word[0] in first_row: row = first_row elif word[0] in second_row: row = second_row else: row = third_row # Check if all characters of the word are in the same row for char in word: if char not in row: return False return True"},{"question":"# Question: Develop a Simple Text Analysis Tool Context Text analysis is an essential aspect of natural language processing, where words and their frequencies in a document are often analyzed to understand better the document\'s content. This task requires implementing a basic text analysis tool that processes a given input text to determine the frequency of each word. Task Implement a function `word_frequency(text: str) -> dict` that computes the frequency of each word in the given text string. The function should handle punctuation and case insensitivity and return a dictionary with words as keys and their respective frequencies as values. Requirements 1. **Function Signature**: ```python def word_frequency(text: str) -> dict: ``` 2. **Inputs**: - `text`: A string representing the input text containing a sequence of words. 3. **Output**: - A dictionary where keys are words and values are their frequencies in the input text. 4. **Behavior**: - Words are considered the same regardless of their case (e.g., \\"Word\\" and \\"word\\" are treated as the same). - Punctuation is to be ignored (e.g., \\"hello,\\" and \\"hello\\" are treated as the same). 5. **Constraints**: - The input string can contain any printable ASCII characters. - There are no constraints on the length of the input string, but the function should handle cases where the input is empty. 6. **Error Handling**: - If the input string is empty, return an empty dictionary. Examples ```python >>> text = \\"Hello, world! Hello, Programming.\\" >>> word_frequency(text) {\'hello\': 2, \'world\': 1, \'programming\': 1} >>> text = \\"Python is great. Isn\'t Python great?\\" >>> word_frequency(text) {\'python\': 2, \'is\': 1, \'great\': 2, \'isnt\': 1} >>> text = \\"\\" >>> word_frequency(text) {} ```","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Computes the frequency of each word in the given text string. Words are treated case-insensitively and punctuation is ignored. if not text: return {} # Convert text to lowercase and remove punctuation using regular expression text = text.lower() text = re.sub(r\\"[^ws]\\", \\"\\", text) # Split the text into words words = text.split() # Use defaultdict to count word frequencies frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Coding Assessment Question Given a string `s` containing only lowercase alphabets, write a function `most_frequent_char(s: str) -> str` that returns the most frequent character in the string. In the case of a tie, return the lexicographically smallest character among them. # Input - `s` (string): A string containing only lowercase alphabets. (1 ≤ len(s) ≤ 100,000) # Output - Return a single character (string) that occurs most frequently in the input string. If there is a tie, return the lexicographically smallest character. # Constraints: - Character counts should be efficiently calculated to ensure performance with long strings. - Dictionary or counter collections may be useful to maintain and compare character frequencies. # Example: ```python def most_frequent_char(s: str) -> str: pass # Implement the function here print(most_frequent_char(\\"aabbbcc\\")) # Output: b print(most_frequent_char(\\"abcdabcdabcde\\")) # Output: a print(most_frequent_char(\\"zzzzxy\\")) # Output: z ``` Utilize appropriate data structures and algorithms to efficiently determine the most frequent character and handle ties based on lexicographical order. Perform thorough testing on diverse edge cases to ensure robustness.","solution":"def most_frequent_char(s: str) -> str: from collections import Counter # Create a counter for all characters in the string count = Counter(s) # Find the maximum frequency of any character max_frequency = max(count.values()) # Get all characters with the maximum frequency candidates = [char for char, freq in count.items() if freq == max_frequency] # Return the lexicographically smallest character among the candidates return min(candidates)"},{"question":"# Coding Challenge: Unique Paths in a Grid Objective: Create a function that calculates the number of unique paths from the top-left corner to the bottom-right corner of a `m x n` grid, only moving either down or right at any point in time. Function Signature: ```python def unique_paths(m: int, n: int) -> int: pass ``` Input: * `m`: An integer representing the number of rows in the grid (`1 <= m <= 100`). * `n`: An integer representing the number of columns in the grid (`1 <= n <= 100`). Output: * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. Constraints: * Your solution should be efficient, handling the upper limit of input sizes. Example: ```python assert unique_paths(3, 2) == 3 # The 3 unique paths are: Right -> Down -> Down, Down -> Down -> Right, Down -> Right -> Down assert unique_paths(7, 3) == 28 # Number of unique paths in a 7x3 grid ``` # Task Description: 1. **Dynamic Programming Table:** Create a 2D table to store the number of unique paths to each cell. 2. **Initialization:** Initialize the first row and first column of the table. There is only one way to reach any cell in the first row (all rights) or the first column (all downs). 3. **Filling the Table:** Use the relation that each cell `(i, j)` is the sum of the cell directly above it `(i-1, j)` and the cell directly to the left `(i, j-1)` to fill in the rest of the table. 4. **Final Output:** The value at the bottom-right corner of the table will be the number of unique paths from the top-left to the bottom-right. This framework ensures that the question integrates well with the existing set, maintaining a similar style, complexity, and scope.","solution":"def unique_paths(m: int, n: int) -> int: # Create a 2D array with all elements initialized to 1 dp = [[1] * n for _ in range(m)] # Iterate through the array starting from (1, 1) to fill in the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the number of unique paths return dp[m-1][n-1]"},{"question":"# Problem Statement You are given an unbounded knapsack with an infinite supply of items, each with a specific weight and value. Your task is to implement a function `unbounded_knapsack` to determine the maximum value that can be achieved with a given capacity of the knapsack. # Function Signature ```python def unbounded_knapsack(W: int, val: list[int], wt: list[int]) -> int: pass ``` # Input - `W`: An integer representing the maximum capacity of the knapsack. - `val`: A list of integers representing the values of the items. - `wt`: A list of integers representing the weights of the items. # Output - Returns an integer representing the maximum value achievable with the given knapsack capacity. # Constraints - 1 ≤ len(val) = len(wt) ≤ 1000 - 1 ≤ W ≤ 10000 - 1 ≤ val[i], wt[i] ≤ 1000 for each valid `i` # Example ```python capacity = 8 values = [10, 40, 50, 70] weights = [1, 3, 4, 5] print(unbounded_knapsack(capacity, values, weights)) # Output: 110 ``` # Notes - The order of items in input lists `val` and `wt` corresponds to each other, meaning `val[i]` and `wt[i]` represent the value and weight of the same item respectively. - The function should take into account that items can be chosen multiple times to achieve the maximum value within the knapsack\'s capacity.","solution":"def unbounded_knapsack(W: int, val: list[int], wt: list[int]) -> int: # Initialize the dp array where dp[i] will store the maximum value # with knapsack capacity i dp = [0] * (W + 1) # Traverse all capacities from 0 to W for i in range(W + 1): # Traverse all items for j in range(len(val)): # If the weight of item j is less than or equal to current capacity i if wt[j] <= i: # Update dp[i] to the maximum value of either not taking item j or # taking item j and adding its value to the remaining capacity dp dp[i] = max(dp[i], dp[i - wt[j]] + val[j]) # The answer will be the maximum value with the full capacity W return dp[W]"},{"question":"**Question:** You are developing a performance tracking system for an online gaming platform. The system must efficiently manage and query player statistics across multiple multiplayer games. Each game has a leaderboard summarizing the scores of players in real time, and it frequently requires updates and querying of rank ranges. **TASK**: Create a class called `LeaderboardManager` that includes the following methods: 1. `__init__(self, scores: List[int])`: Initializes the class with a given list of player scores. 2. `update_score(self, player_id: int, score: int)`: Updates the score for the player with `player_id` to the new score. 3. `get_score(self, player_id: int) -> int`: Retrieves the score of the player with the given `player_id`. 4. `get_top_scores(self, n: int) -> List[int]`: Returns the list of top `n` scores. 5. `get_average_score_in_range(self, lower: int, upper: int) -> float`: Returns the average score of players whose ranks fall between `lower` and `upper` (inclusive). **Function Signature**: ```python class LeaderboardManager: def __init__(self, scores: List[int]): pass def update_score(self, player_id: int, score: int): pass def get_score(self, player_id: int) -> int: pass def get_top_scores(self, n: int) -> List[int]: pass def get_average_score_in_range(self, lower: int, upper: int) -> float: pass ``` **Constraints**: - `0 <= player_id < len(scores)` - `1 <= n <= len(scores)` - `1 <= lower <= upper <= len(scores)` **Performance Requirements**: - All operations should maintain efficiency, especially considering dynamic updates and requesting top scores or average rank ranges. **Example**: ```python scores = [1200, 950, 1100, 1600, 1350] lm = LeaderboardManager(scores) # Update player scores lm.update_score(2, 1400) # Retrieve a score print(lm.get_score(2)) # Output: 1400 # Get top 3 scores print(lm.get_top_scores(3)) # Output: [1600, 1400, 1350] # Average score of players ranked between 2 and 4 (1-based ranks) print(lm.get_average_score_in_range(2, 4)) # Output: 1283.33 (average of 1400, 1350, 1100) ```","solution":"from typing import List class LeaderboardManager: def __init__(self, scores: List[int]): self.scores = scores self.rankings = sorted(((score, idx) for idx, score in enumerate(scores)), reverse=True) def update_score(self, player_id: int, score: int): original_score = self.scores[player_id] self.scores[player_id] = score # Update rankings self.rankings = list(filter(lambda x: x[1] != player_id, self.rankings)) insertion_point = self._find_insertion_point(score) self.rankings.insert(insertion_point, (score, player_id)) def get_score(self, player_id: int) -> int: return self.scores[player_id] def get_top_scores(self, n: int) -> List[int]: return [score for score, _ in self.rankings[:n]] def get_average_score_in_range(self, lower: int, upper: int) -> float: selected_scores = [score for score, _ in self.rankings[lower-1:upper]] return sum(selected_scores) / len(selected_scores) def _find_insertion_point(self, new_score: int) -> int: left, right = 0, len(self.rankings) while left < right: mid = (left + right) // 2 if self.rankings[mid][0] > new_score: left = mid + 1 else: right = mid return left"},{"question":"# Context: You are given a circular list that represents values in a circular buffer. In this list, the last value wraps back around to the first one. Your task is to implement a function to rotate the circular list by a given number of positions. Rotating the list involves moving each element to the right by a certain number of positions, while elements that would go past the end of the list wrap back around to the beginning. # Task: **Implement** the rotation mechanism described below. # Function Definitions: 1. **rotate_circular_list**(`circular_list: list[int], positions: int`) -> `list[int]`: - **Input**: A list of integers `circular_list` representing the circular buffer and an integer `positions` which indicates the number of positions to rotate the list. - **Output**: A new list representing the rotated values in the circular buffer. # Constraints: - Each element in the circular list is an integer between `-1000` and `1000` inclusive. - The number of positions to rotate will be a non-negative integer. - The input circular list will have at least one element and at most 100 elements. # Example: ```python def rotate_circular_list(circular_list: list[int], positions: int) -> list[int]: # Your implementation here pass if __name__ == \\"__main__\\": print(rotate_circular_list([1, 2, 3, 4, 5], 2)) # [4, 5, 1, 2, 3] print(rotate_circular_list([10, 20, 30, 40], 1)) # [40, 10, 20, 30] ``` **Example Usage**: ```python print(rotate_circular_list([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_circular_list([10, 20, 30, 40], 1)) # Output: [40, 10, 20, 30] ```","solution":"def rotate_circular_list(circular_list: list[int], positions: int) -> list[int]: Rotates the circular list by the given number of positions. Parameters: circular_list (list[int]): The list of integers representing the circular buffer. positions (int): The number of positions to rotate the list. Returns: list[int]: The rotated list. n = len(circular_list) # Normalize positions to be within the range of 0 to n-1 positions %= n return circular_list[-positions:] + circular_list[:-positions]"},{"question":"# Coding Challenge: Prefix-Free Encoding Validator Scenario You work for a data encoding company that uses prefix-free binary encodings to represent sets of characters. A prefix-free encoding is a type of encoding where no code is a prefix of any other code in the set. This ensures that the encoded data can be uniquely decoded without ambiguity. Task Write a function `is_prefix_free(codes)` that takes a list of binary strings and determines if the set of codes is prefix-free. Expected Function Signature ```python def is_prefix_free(codes: List[str]) -> bool: codes: a list of strings where each string represents a binary code ``` Input - A list of binary strings, where each string represents a binary code. Output - A boolean value: `True` if the list of codes is prefix-free, and `False` otherwise. Constraints - The length of the list `codes` will be between 1 and 1000. - Each binary string `s` within the list will have a length between 1 and 100. - You should aim for an efficient solution, avoiding unnecessary comparisons. Example ```python codes1 = [\\"101\\", \\"10\\", \\"1110\\", \\"1111\\"] # Should return False codes2 = [\\"101\\", \\"1001\\", \\"1110\\", \\"1111\\"] # Should return True print(is_prefix_free(codes1)) # Output: False print(is_prefix_free(codes2)) # Output: True ``` Additional Information - Remember that a set of codes is prefix-free if and only if no code in the set is the prefix of any other code in the set. - Consider using trie data structures or sorting techniques to optimize your solution.","solution":"def is_prefix_free(codes): Determines if the given list of binary codes is prefix-free. :param codes: List of strings where each string represents a binary code. :return: Boolean value True if the list is prefix-free, otherwise False. # Sort the list of codes codes.sort() # Traverse the sorted list and check for prefix condition for i in range(len(codes) - 1): # If the current code is a prefix of the next one, return False if codes[i+1].startswith(codes[i]): return False return True"},{"question":"Expanding a URL Shortener Service You are tasked with extending an existing URL shortener service to support tracking the number of clicks for each shortened URL. You will build a function based on the provided code snippets. # Function Signature ```python class URLShortener: def __init__(self): self.url_map = {} self.click_tracker = {} def shorten_url(self, original_url: str) -> str: pass def retrieve_url(self, short_url: str) -> str: pass def get_clicks(self, short_url: str) -> int: pass ``` # Objective 1. Implement the `shorten_url` method to generate a unique shortened URL for a given original URL and store the mapping. 2. Implement the `retrieve_url` method to retrieve the original URL when provided with the shortened URL, and increment the click count each time the short URL is retrieved. 3. Implement the `get_clicks` method to return the number of times a shortened URL has been accessed. # Input/Output Format * Methods of the `URLShortener` class: * `shorten_url(original_url: str) -> str`: Returns a unique shortened URL. * `retrieve_url(short_url: str) -> str`: Returns the original URL corresponding to the shortened URL and increments the click count for this URL. * `get_clicks(short_url: str) -> int`: Returns the number of times the shortened URL has been accessed. # Constraints * Assume the unique shortened URL generated can be a simple alphanumeric string. * The size of the URL map and click tracker should be optimized for large sets of URLs. * You may use any standard Python libraries. # Context This service will be used by various web applications to shorten URLs and track their usage. Ensuring accurate and efficient tracking of URL accesses is critical for analytics and user experience. # Performance Requirements * Ensure optimal performance for both URL shortening and retrieval with minimal delay. * Efficiently manage the storage and retrieval of URL mappings and click counts. # Implementation Notes * Use a simple hash function or incremental ID generator to create unique shortened URLs. * Ensure both `shorten_url` and `retrieve_url` methods work with O(1) average time complexity for insertion and access operations. Design and implement the `URLShortener` class and its methods according to the above requirements.","solution":"import hashlib class URLShortener: def __init__(self): self.url_map = {} self.click_tracker = {} def shorten_url(self, original_url: str) -> str: Generates a unique shortened URL for a given original URL and stores the mapping. Uses SHA256 hash truncated to 8 characters to ensure uniqueness. :param original_url: The original URL to be shortened. :return: The shortened URL as a string. short_url = hashlib.sha256(original_url.encode()).hexdigest()[:8] self.url_map[short_url] = original_url if short_url not in self.click_tracker: self.click_tracker[short_url] = 0 return short_url def retrieve_url(self, short_url: str) -> str: Retrieves the original URL when provided with the shortened URL and increments the click count for this URL. :param short_url: The shortened URL. :return: The original URL as a string. if short_url in self.url_map: self.click_tracker[short_url] += 1 return self.url_map[short_url] return None def get_clicks(self, short_url: str) -> int: Returns the number of times a shortened URL has been accessed. :param short_url: The shortened URL. :return: The number of clicks as an integer. return self.click_tracker.get(short_url, 0)"},{"question":"# Coding Assessment Question **Scenario:** A cybersecurity firm needs to analyze network traffic logs for potential anomalies. Specifically, they are interested in identifying sequences or patterns in the logs that correspond to specific attack signatures. One common method is using substring matching with wildcards, where certain characters can represent any sequence of characters. **Task:** Implement an algorithm to determine if a log entry contains a given attack signature pattern. The pattern can include a wildcard character `\'*\'`, which can represent any sequence (including an empty sequence) of characters. # Requirements: 1. **Function 1:** `is_match(log: str, pattern: str) -> bool` - Takes a log entry and a pattern containing wildcards. - Returns a boolean indicating if the pattern matches the log entry. # Input: - **`log`**: A string representing the log entry (e.g., \\"ERROR at 10.0.0.1: Connection timed out\\"). - **`pattern`**: A string representing the attack signature pattern, where `\'*\'` can match any sequence of characters (e.g., \\"*10.0.0.*: Connection*\\"). # Output: - A boolean (`True` or `False`), where `True` indicates the pattern matches the log entry, and `False` otherwise. # Constraints: - Both `log` and `pattern` are non-empty strings consisting of printable ASCII characters. - Wildcard `\'*\'` can appear multiple times in the pattern. - Consider edge cases where the pattern has leading, trailing, or multiple successive wildcards. # Example: ```python log = \\"ERROR at 10.0.0.1: Connection timed out\\" pattern = \\"*10.0.0.*: Connection*\\" print(is_match(log, pattern)) ``` **Output:** ``` True ``` # Edge Cases to Consider: 1. Pattern with only wildcards. 2. Log entries with special characters or spaces. 3. Patterns that are exact matches without wildcards. # Explanation: - The wildcard `\'*\'` in the pattern can match any substring of the log, so a pattern like `*10.0.0.*: Connection*` would match a log that contains the substring \\"10.0.0.\\" followed by \\": Connection\\" and any other characters thereafter. - Patterns with multiple `\'*\'` wildcards need to account for sequences of any length between specific sub-patterns. This problem assesses the candidate\'s understanding of string manipulation, pattern matching, and handling special characters in strings.","solution":"def is_match(log: str, pattern: str) -> bool: Determines if the pattern matches the log entry, where \'*\' in the pattern can match any sequence of characters. # Split the pattern by \'*\' to handle each sub-pattern individually parts = pattern.split(\'*\') index = 0 for part in parts: if part: # Find the part in the log string starting from the current index index = log.find(part, index) if index == -1: return False # Move index to the end of the found part index += len(part) return True"},{"question":"# Problem Statement: You have to implement a function that formats a string representing a mathematical expression by adding spaces around each operator (+, -, *, /). The formatted string should have a single space before and after each operator, but no leading or trailing spaces, and no extraneous spaces between operands. # Function Signature: ```python def format_expression(expression: str) -> str: Formats the given mathematical expression by adding spaces around each operator. Parameters: expression (str): The input string representing a mathematical expression. Returns: str: The formatted string with spaces around each operator. ``` # Input: - A string representing a mathematical expression. - Constraints: - The length of the input string will be between 1 and 10^6 characters. - The string will contain only digits (0-9), the operators (+, -, *, /), and no spaces. # Output: - A string with properly spaced operators. # Examples: ```python # Example 1 expression = \\"3+5*2-8/4\\" print(format_expression(expression)) # Expected Output: \\"3 + 5 * 2 - 8 / 4\\" # Example 2 expression = \\"12*3-4+5/6\\" print(format_expression(expression)) # Expected Output: \\"12 * 3 - 4 + 5 / 6\\" # Example 3 expression = \\"7+8-2*3/1\\" print(format_expression(expression)) # Expected Output: \\"7 + 8 - 2 * 3 / 1\\" ``` **Note**: Your solution should be able to efficiently handle the upper limit of the input size.","solution":"def format_expression(expression: str) -> str: Formats the given mathematical expression by adding spaces around each operator. Parameters: expression (str): The input string representing a mathematical expression. Returns: str: The formatted string with spaces around each operator. operators = set(\\"+-*/\\") formatted_expression = \\"\\" for char in expression: if char in operators: formatted_expression += f\\" {char} \\" else: formatted_expression += char # remove any possible extraneous spaces (although there shouldn\'t be any in this particular implementation) return \' \'.join(formatted_expression.split()) # Example usage: # expression = \\"3+5*2-8/4\\" # print(format_expression(expression)) # Expected Output: \\"3 + 5 * 2 - 8 / 4\\""},{"question":"# Consecutive Duplicates Removal In a text processing application, you need to write a function that removes consecutive duplicate characters in a given string. The function should ensure that if the same character appears consecutively multiple times, only one instance of it should remain in the output string. # Function Specification **Function Name**: `remove_consecutive_duplicates` **Input**: 1. `input_string` (str): The string from which to remove consecutive duplicate characters. **Output**: - Returns a string where all consecutive duplicate characters from the input string are removed. # Constraints: - The input string will contain at most 10^5 characters. - The input string will consist of ASCII characters. # Examples: ```python remove_consecutive_duplicates(\\"aaabbbcccccdddeee\\") # Output: \'abcde\' remove_consecutive_duplicates(\\"aabbcc\\") # Output: \'abc\' remove_consecutive_duplicates(\\"abcd\\") # Output: \'abcd\' remove_consecutive_duplicates(\\"\\") # Output: \'\' ``` # Additional Notes: Make sure your implementation efficiently handles long strings and correctly manages edge cases like an empty input string or strings with no consecutive duplicates. # Testing: * Handle an empty input string. * Handle strings with no consecutive duplicates. * Handle strings with all characters being the same. Write the function `remove_consecutive_duplicates` such that it efficiently removes consecutive duplicate characters from the given string.","solution":"def remove_consecutive_duplicates(input_string): Returns a string where all consecutive duplicate characters are removed. if not input_string: return \\"\\" result = [input_string[0]] for char in input_string[1:]: if char != result[-1]: result.append(char) return \'\'.join(result)"},{"question":"# Problem Statement A company manages several projects, some of which depend on others for completion. Given a list of projects and dependencies, your task is to determine the order of project completion using a topological sort. # Function Signature ```python def find_project_order(projects: list[str], dependencies: list[tuple[str, str]]) -> list[str]: :param projects: a list of strings where each string represents the name of a project :param dependencies: a list of tuples where each tuple (a, b) indicates that project \'a\' must be completed before project \'b\' :return: a list of strings representing the order in which projects should be completed Raises ValueError if the graph has cycles or if the input criteria are not met (e.g., projects not being strings or dependencies not in correct tuple format). ``` # Example ```python print(find_project_order([\\"A\\", \\"B\\", \\"C\\", \\"D\\"], [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")])) # Expected output: [\'A\', \'B\', \'C\', \'D\'] print(find_project_order([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\")])) # Expected output: [\'A\', \'B\', \'C\', \'D\', \'E\'] print(find_project_order([\\"A\\", \\"B\\"], [(\\"A\\", \\"B\\"), (\\"B\\", \\"A\\")])) # Expected to raise ValueError due to a cycle in the graph ``` # Constraints * You can assume the following: - `projects` is a list of unique strings, each representing a project name. - `dependencies` is a list of tuples of the form (a, b), where `a` and `b` are valid project names from the `projects` list. - The length of `projects` is at most 1000. - The length of `dependencies` is at most 2000. # Tasks 1. Implement validation to handle erroneous inputs. 2. Use a topological sorting algorithm (e.g., Kahn\'s algorithm or DFS-based approach) to determine the project order. 3. Consider edge cases, such as projects without any dependencies or cycles within the dependency graph. # Notes - Ensure your solution handles invalid inputs, such as cyclic dependencies. - Aim for an efficient implementation given the constraints. - Modularize your code using helper functions if necessary.","solution":"def find_project_order(projects: list[str], dependencies: list[tuple[str, str]]) -> list[str]: from collections import defaultdict, deque # Validate inputs if not all(isinstance(project, str) for project in projects): raise ValueError(\\"All projects must be strings.\\") if not all(isinstance(dep, tuple) and len(dep) == 2 and isinstance(dep[0], str) and isinstance(dep[1], str) for dep in dependencies): raise ValueError(\\"All dependencies must be tuples of two strings.\\") # Build the graph and compute in-degrees. graph = defaultdict(list) in_degree = {project: 0 for project in projects} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Perform Kahn\'s algorithm for topological sorting. zero_in_degree_queue = deque([project for project in projects if in_degree[project] == 0]) topological_order = [] while zero_in_degree_queue: current_project = zero_in_degree_queue.popleft() topological_order.append(current_project) for neighbor in graph[current_project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) if len(topological_order) != len(projects): raise ValueError(\\"The graph has at least one cycle or some projects are missing.\\") return topological_order"},{"question":"# Problem Statement: Modern applications often require the analysis of text data to perform various tasks, such as identifying the most frequent words. One of these tasks is to count the frequency of each word in a given text and list the words in descending order of their frequency. **Goal**: Implement a function to count the frequency of each word in a given string of text and return a list of tuples, where each tuple contains a word and its frequency, sorted primarily by frequency in descending order and then alphabetically by word in ascending order. # Input: - A single string `text` that contains words separated by spaces, punctuation, or other non-alphabetic characters. Words are case-insensitive and should be treated as the same word regardless of capitalization. # Output: - A list of tuples, where each tuple contains a word (in lowercase) and its frequency, sorted by the frequency in descending order. If two words have the same frequency, they should be sorted alphabetically by word. # Constraints: - Assume the input text length will not exceed 1,000,000 characters. - Only alphabetic characters should be considered part of words. Non-alphabetic characters should be treated as word separators. # Example: For example: ```python >>> word_frequencies(\\"The quick brown fox jumps over the lazy dog.\\") [(\'the\', 2), (\'brown\', 1), (\'dog\', 1), (\'fox\', 1), (\'jumps\', 1), (\'lazy\', 1), (\'over\', 1), (\'quick\', 1)] >>> word_frequencies(\\"A quick brown Fox quickly jumps over the lazy dog!\\") [(\'quick\', 1), (\'quickly\', 1), (\'the\', 1), (\'jumps\', 1), (\'lazy\', 1), (\'dog\', 1), (\'fox\', 1), (\'brown\', 1), (\'a\', 1), (\'over\', 1)] >>> word_frequencies(\\"Hello, hello? HELLO!\\") [(\'hello\', 3)] >>> word_frequencies(\\"123 123 123\\") [] ``` # Scenario: An author is analyzing their manuscript to better understand their use of certain words. Your task is to build a function that effectively processes the text and provides meaningful insights into word frequencies, facilitating a deeper understanding of word usage patterns.","solution":"import re from collections import Counter def word_frequencies(text): Returns a list of tuples containing words and their frequencies, sorted by frequency in descending order, then alphabetically by word in ascending order. # Convert to lower case text = text.lower() # Use regex to extract words (alphabetic) words = re.findall(r\'b[a-z]+b\', text) # Count frequencies using Counter freq_count = Counter(words) # Sort by frequency descending and then alphabetically ascending sorted_words = sorted(freq_count.items(), key=lambda x: (-x[1], x[0])) return sorted_words"},{"question":"# Problem: Maximum Frequency Stack You are provided with a class `FreqStack` which implements a stack that supports the following operations: 1. `push(val)` - Pushes an integer `val` onto the stack. 2. `pop()` - Removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the top of the stack is removed and returned. Your task is to implement the `FreqStack` class with efficient time complexity for both operations. # Function Signature: ```python class FreqStack: def __init__(self): Initialize the data structures to support the operations. pass def push(self, val: int) -> None: Pushes an integer val onto the stack. Args: val (int): The value to be pushed onto the stack. Returns: None. pass def pop(self) -> int: Removes and returns the most frequent element in the stack. If there is a tie, the element closest to the top of the stack is removed and returned. Returns: int: The most frequent element in the stack. pass ``` # Input: * For `push` method, `val` an integer. * For `pop` method, no input. # Constraints: * New values for `val` are in the range [-10^4, 10^4]. * At most 10^5 `push` and `pop` operations will be made. # Output: * For `push` method, no output. * For `pop` method, the most frequent element in the stack is returned. # Example: ```python fs = FreqStack() fs.push(5) fs.push(7) fs.push(5) fs.push(7) fs.push(4) fs.push(5) print(fs.pop()) # Output: 5 print(fs.pop()) # Output: 7 print(fs.pop()) # Output: 5 print(fs.pop()) # Output: 4 ``` # Hints: * Use a dictionary to keep track of the frequency of each element. * Use a dictionary of stacks to store elements with the same frequency. * Maintain a variable to keep track of the maximum frequency. Implementing the `FreqStack` class requires careful handling of data organization and retrieval to ensure operations are efficient.","solution":"from collections import defaultdict, deque class FreqStack: def __init__(self): self.freq = defaultdict(int) self.group = defaultdict(deque) self.maxfreq = 0 def push(self, val: int) -> None: f = self.freq[val] + 1 self.freq[val] = f if f > self.maxfreq: self.maxfreq = f self.group[f].append(val) def pop(self) -> int: val = self.group[self.maxfreq].pop() self.freq[val] -= 1 if not self.group[self.maxfreq]: self.maxfreq -= 1 return val"},{"question":"# Dice Roll Simulation Problem Statement Write a function `calculate_probability(n: int, x: int) -> float` that calculates the probability of getting a sum exactly equal to `x` when rolling `n` six-sided dice. Each of the dice have faces numbered from 1 to 6, and each face has an equal chance of appearing. Input * `n` (int): The number of six-sided dice being rolled. (1 <= `n` <= 50) * `x` (int): The target sum to achieve. (n <= `x` <= 6n) Output * Return a float representing the probability of achieving the sum `x` when rolling `n` dice. Constraints * 1 ≤ n ≤ 50 * n ≤ x ≤ 6n Examples ```python calculate_probability(2, 7) -> 0.16666666666666666 # Explanation: Possible combinations to get 7: (1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1). Total combinations when rolling 2 dice is 36, hence probability is 6/36 = 0.16666... calculate_probability(3, 18) -> 0.004629629629629629 ``` Additional Information You should break down the problem using dynamic programming or memoization to efficiently compute the probabilities. Consider all possible combinations and build up the solution incrementally. Test your function with various values of `n` and `x` to ensure it handles a wide range of inputs correctly.","solution":"def calculate_probability(n: int, x: int) -> float: # Initialize the DP table dp = [[0] * (x+1) for _ in range(n+1)] # There\'s one way to get a sum of 0 with 0 dice dp[0][0] = 1 # Fill the DP table for dice in range(1, n+1): for target in range(dice, min(dice*6, x)+1): dp[dice][target] = sum(dp[dice-1][target-face] for face in range(1, 7) if target-face >= 0) # Calculate total number of possible outcomes which is 6^n total_outcomes = 6 ** n # The number of ways to achieve the sum \'x\' with \'n\' dice is stored in dp[n][x] successful_outcomes = dp[n][x] # Return the probability return successful_outcomes / total_outcomes"},{"question":"New Question # Scenario You are developing a network analysis tool that needs to traverse and analyze connectivity in a graph structure. The tool must efficiently visit all nodes starting from a given node, hashing edge cases of disconnected components or cycles gracefully. # Function Signature ```python def depth_first_search(graph: Dict[int, List[int]], start_vertex: int) -> List[int]: pass ``` # Input * `graph`: A dictionary where each key is a vertex, and the value is a list of vertices that are directly connected to the key vertex. * `start_vertex`: An integer representing the vertex from which the DFS traversal should begin. # Output * A list of integers representing the order in which the vertices are visited during the DFS traversal starting from `start_vertex`. # Constraints * The graph can be directed or undirected. * Handle edge cases such as an empty graph (i.e., an empty dictionary) or a graph where the start vertex has no edges. # Examples ```python depth_first_search({1: [2, 3], 2: [4], 3: [4], 4: []}, 1) # Output: [1, 2, 4, 3] (Note: The order may vary) depth_first_search({1: [2], 2: [3], 3: [4], 4: [5]}, 2) # Output: [2, 3, 4, 5] depth_first_search({}, 1) # Output: [] ``` # Performance Requirements * Aim for an average-case time complexity of O(V + E), where V is the number of vertices and E is the number of edges. * Ensure the function handles the recursion depth effectively to avoid stack overflow issues on very large graphs. # Notes * Consider using an iterative approach with a stack to implement DFS in order to manage stack depth. * Remember to mark visited vertices to avoid cycles or repeated visits. Happy coding!","solution":"def depth_first_search(graph, start_vertex): Perform a depth-first search on a graph starting from the given vertex. :param graph: A dictionary where the key is a vertex and the value is a list of directly connected vertices. :param start_vertex: The starting vertex for DFS traversal. :return: A list of vertices in the order they were visited. if start_vertex not in graph: return [] visited = set() stack = [start_vertex] result = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) result.append(vertex) # Add connected vertices to stack in reverse order to maintain order stack.extend(reversed(graph.get(vertex, []))) return result"},{"question":"# Coding Assessment Question Objective Implement a function that finds all combinations of numbers within an input list that sum to a given target value. This task assesses understanding of backtracking algorithms and combination generation. Problem Statement You are given a list of unique integers `candidates` and a target integer `target`. Write a function: ```python def combination_sum(candidates: list[int], target: int) -> list[list[int]]: ... ``` This function should return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. The same number may be chosen from `candidates` an unlimited number of times. Numbers must be in non-decreasing order in both individual combinations and the final list of combinations. Input - `candidates`: A list of unique integers with a length between 1 and 30, each ranging from 1 to 200. - `target`: An integer ranging from 1 to 500. Output - A list of lists, where each list contains a unique combination of integers that sum up to `target`. Constraints 1. The function must handle edge cases such as an empty list of candidates or no possible combinations summing to `target`. 2. Each combination in the output must be unique and sorted in non-decreasing order. Example ```python print(combination_sum([2, 3, 6, 7], 7)) # Output: [[2, 2, 3], [7]] print(combination_sum([2, 3, 5], 8)) # Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] print(combination_sum([2], 1)) # Output: [] print(combination_sum([1], 2)) # Output: [[1, 1]] ``` # Additional Requirements - Ensure to validate the inputs. - The implementation should handle the upper limit of constraints efficiently. - Avoid returning duplicate combinations. This question requires understanding recursion, backtracking, and ensuring result order and uniqueness.","solution":"def combination_sum(candidates, target): def backtrack(start, path, target): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(candidates)): backtrack(i, path + [candidates[i]], target - candidates[i]) candidates.sort() # Ensure candidates are in ascending order result = [] backtrack(0, [], target) return result"},{"question":"# Matrix Diagonal Sum Calculation **Context**: You are developing a library for matrix operations that include various algorithmic functionalities. One of the tasks is to compute the sum of the elements present in both the main diagonal and the secondary diagonal of a given square matrix. **Requirements**: 1. Implement the `diagonal_sum` function. 2. The function should correctly calculate the sum of the main diagonal and the secondary diagonal, ensuring no element is counted twice if it lies on the intersection of the diagonals (in case of an odd-sized matrix). 3. Ensure the implementation handles empty matrices and non-square matrices with appropriate errors or returns. **Function Signature**: ```python def diagonal_sum(matrix: list) -> int: pass ``` **Input**: - `matrix`: A list of lists representing a square matrix of integers. **Output**: - Returns an integer representing the sum of the elements in both the main and the secondary diagonals. **Constraints**: - The matrix will always be a square matrix, i.e., `n x n` (number of rows = number of columns). **Examples**: ```python # Example 1 assert diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 25 # 1 + 5 + 9 + 3 + 5 + 7 = 25 (note the 5 in the center) # Example 2 assert diagonal_sum([]) == 0 # Empty matrix edge case # Example 3 assert diagonal_sum([ [2] ]) == 2 # Single element matrix # Example 4 assert diagonal_sum([ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) == 5 # 1 + 1 + 1 + 1 + 1 = 5 ``` **Performance Note**: Your function should operate in O(n) time complexity, where n is the number of rows (or columns) in the matrix. **Hints**: 1. Remember that the main diagonal consists of elements where the row index equals the column index. 2. The secondary diagonal consists of elements where the sum of the row and column indices is equal to n-1. Good luck with your implementation!","solution":"def diagonal_sum(matrix: list) -> int: Returns the sum of the elements in both the main diagonal and the secondary diagonal of a given square matrix, ensuring no element is counted twice. if not matrix: return 0 n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # main diagonal total_sum += matrix[i][n - 1 - i] # secondary diagonal # If n is odd, subtract the middle element which was added twice if n % 2 == 1: total_sum -= matrix[n // 2][n // 2] return total_sum"},{"question":"# Objective Design a function that encodes a given string using Run-Length Encoding (RLE) and then decodes the encoded string back to its original form. # Description The function `encode_decode_string(input_string: str) -> Tuple[str, str]` should: 1. Encode the input string using Run-Length Encoding (RLE). 2. Decode the RLE string back to the original string. # Input * `input_string`: A string containing alphanumeric characters (both uppercase and lowercase). # Output * A tuple containing the encoded RLE string and the decoded string. # Constraints * The input string will always be a valid, non-empty string with a maximum length of 100 characters. # Requirements 1. Implement the Run-Length Encoding algorithm, where sequences of the same character are replaced by that character followed by the number of times it appears consecutively. 2. Implement the decoding algorithm to reconstruct the original string from the RLE string. 3. Ensure both encoding and decoding processes are lossless. # Example ```python from typing import Tuple def encode_decode_string(input_string: str) -> Tuple[str, str]: def encode(s: str) -> str: encoding = \'\' i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoding += s[i] + str(count) i += 1 return encoding def decode(rle: str) -> str: decoding = \'\' i = 0 while i < len(rle): ch = rle[i] count = int(rle[i + 1]) decoding += ch * count i += 2 return decoding encoded_string = encode(input_string) decoded_string = decode(encoded_string) return (encoded_string, decoded_string) # Example usage: input_string = \'aaabccdddde\' encoded, decoded = encode_decode_string(input_string) print(\'Encoded:\', encoded) # \'a3b1c2d4e1\' print(\'Decoded:\', decoded) # \'aaabccdddde\' ``` This question requires the candidate to understand string manipulation, encoding, and decoding algorithms. It ensures that they can work with string processing and maintain data integrity through both processes.","solution":"from typing import Tuple def encode_decode_string(input_string: str) -> Tuple[str, str]: def encode(s: str) -> str: encoding = \'\' i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoding += s[i] + str(count) i += 1 return encoding def decode(rle: str) -> str: decoding = \'\' i = 0 while i < len(rle): ch = rle[i] count = int(rle[i + 1]) decoding += ch * count i += 2 return decoding encoded_string = encode(input_string) decoded_string = decode(encoded_string) return (encoded_string, decoded_string)"},{"question":"# Implementing a Matrix Class with Basic Operations **Scenario**: You are tasked with creating a basic matrix library that can handle operations such as addition, multiplication, and transposition. The library should be able to work with matrices of any size and ensure that the operations are mathematically valid. **Task**: Implement the `Matrix` class with the following methods: ```python class Matrix: def __init__(self, data): Initialize the matrix with a 2D list of numbers. Parameters: data : list of list of numbers A 2D list where each sublist represents a row of the matrix. pass def add(self, other): Add two matrices if they have the same dimensions. Parameters: other : Matrix Another matrix to add to the current matrix. Returns: Matrix : A new matrix with the result of addition. Raises: ValueError : If the dimensions of the matrices do not match. pass def multiply(self, other): Multiply two matrices if the number of columns of the first matrix is equal to the number of rows of the second matrix. Parameters: other : Matrix Another matrix to multiply with the current matrix. Returns: Matrix : A new matrix with the result of multiplication. Raises: ValueError : If the matrices cannot be multiplied due to dimension mismatch. pass def transpose(self): Transpose the current matrix. Returns: Matrix : A new matrix which is the transpose of the current matrix. pass ``` **Input and Output Formats**: - `data`: A 2D list where each sublist represents a row of the matrix. - The methods `add`, `multiply`, and `transpose` should return a new `Matrix` object representing the result of the operation. **Constraints**: 1. The elements of the matrix are integers or floats. 2. The dimensions must be valid for the matrix operations. **Examples**: ```python # Example 1: Matrix Addition m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) result_add = m1.add(m2) assert result_add.data == [[6, 8], [10, 12]] # Example 2: Matrix Multiplication m3 = Matrix([[1, 2, 3], [4, 5, 6]]) m4 = Matrix([[7, 8], [9, 10], [11, 12]]) result_multiply = m3.multiply(m4) assert result_multiply.data == [[58, 64], [139, 154]] # Example 3: Matrix Transposition m5 = Matrix([[1, 2, 3], [4, 5, 6]]) result_transpose = m5.transpose() assert result_transpose.data == [[1, 4], [2, 5], [3, 6]] ``` **Note**: Ensure to handle invalid operations (e.g., dimension mismatch) gracefully by raising appropriate errors.","solution":"class Matrix: def __init__(self, data): Initialize the matrix with a 2D list of numbers. Parameters: data : list of list of numbers A 2D list where each sublist represents a row of the matrix. self.data = data def add(self, other): Add two matrices if they have the same dimensions. Parameters: other : Matrix Another matrix to add to the current matrix. Returns: Matrix : A new matrix with the result of addition. Raises: ValueError : If the dimensions of the matrices do not match. if not (len(self.data) == len(other.data) and all(len(row) == len(other_row) for row, other_row in zip(self.data, other.data))): raise ValueError(\\"Matrices must have the same dimensions for addition\\") result = [[self.data[i][j] + other.data[i][j] for j in range(len(self.data[i]))] for i in range(len(self.data))] return Matrix(result) def multiply(self, other): Multiply two matrices if the number of columns of the first matrix is equal to the number of rows of the second matrix. Parameters: other : Matrix Another matrix to multiply with the current matrix. Returns: Matrix : A new matrix with the result of multiplication. Raises: ValueError : If the matrices cannot be multiplied due to dimension mismatch. if len(self.data[0]) != len(other.data): raise ValueError(\\"Number of columns in the first matrix must be equal to the number of rows in the second matrix for multiplication\\") result = [[sum(self.data[i][k] * other.data[k][j] for k in range(len(other.data))) for j in range(len(other.data[0]))] for i in range(len(self.data))] return Matrix(result) def transpose(self): Transpose the current matrix. Returns: Matrix : A new matrix which is the transpose of the current matrix. result = [[self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0]))] return Matrix(result)"},{"question":"# Problem Statement Given a list of integers where each integer represents the height of a block, write a function to find the maximum amount of water that can be trapped between the blocks after raining. The width of each block is 1. Function Signature ```python def max_water_trap(height: List[int]) -> int: pass ``` Input - `height`: List[int] - A list of non-negative integers representing the height of each block (0 <= len(height) <= 10^5, 0 <= height[i] <= 10^4). Output - `returns`: int - The maximum amount of water that can be trapped. Constraints - You must solve this problem using O(n) time complexity. # Examples ```python >>> max_water_trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> max_water_trap([4,2,0,3,2,5]) 9 >>> max_water_trap([]) 0 >>> max_water_trap([1]) 0 >>> max_water_trap([1,2,3,4,5,6]) 0 ``` # Explanation In the first example, 6 units of water are trapped: - Between `0` and `2`, 1 unit - Between `1` and `2`, 1 unit - Between `0` and `1`, 1 unit - Between `3` and `2`, 2 units - Between `2` and `1`, 1 unit. # Note - You can use two-pointer technique to achieve O(n) time complexity. - Make sure to handle edge cases like empty list and list with only one element.","solution":"from typing import List def max_water_trap(height: List[int]) -> int: if not height: return 0 left, right = 0, len(height) - 1 max_left, max_right = height[left], height[right] water_trapped = 0 while left < right: if height[left] < height[right]: left += 1 max_left = max(max_left, height[left]) water_trapped += max_left - height[left] else: right -= 1 max_right = max(max_right, height[right]) water_trapped += max_right - height[right] return water_trapped"},{"question":"# Climbing Stairs with Variable Steps You are tasked with writing a function that calculates the number of distinct ways to climb a staircase. Each time you can climb either 1, 2, or 3 steps. The goal is to determine the number of ways to reach the top of a staircase with `n` steps. **Objective**: Write a Python function `climb_stairs(n: int) -> int` that returns the number of distinct ways to climb a staircase of `n` steps using strides of 1, 2, or 3 steps. Input - `n`: An integer representing the number of steps in the staircase (0 ≤ n ≤ 50). Output - Returns an integer that represents the number of distinct ways to climb the staircase. Constraints - The input `n` will be a non-negative integer no greater than 50. Example ```python >>> climb_stairs(3) 4 >>> climb_stairs(4) 7 >>> climb_stairs(5) 13 >>> climb_stairs(0) 1 ``` Edge Cases 1. When `n` is 0, there is one way to stay at the bottom without climbing any steps. 2. When `n` is 1, there is exactly one way to climb one step. 3. When `n` is 2, there are two ways to climb the stairs (1+1 or 2). 4. When `n` is 3, the function should correctly identify the multiple combinations of strides (1+1+1, 1+2, 2+1, or 3). Implementation ```python def climb_stairs(n: int) -> int: if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n] ``` Test your implementation using various test cases including the examples and edge cases provided.","solution":"def climb_stairs(n: int) -> int: Calculate the number of distinct ways to climb a staircase of `n` steps allowing strides of 1, 2, or 3 steps. if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"# Coding Assessment Question **Scenario**: You are part of a development team working on a library management system. One of your tasks is to implement a feature that tracks which books are currently available in the library. Given that multiple transactions (borrowings and returns) happen throughout the day, you need to maintain an efficient record of the book inventory. **Task**: Implement a function to determine the available books in the library. You will be given a list of books currently in the library and a list of transactions. Each transaction specifies a book being borrowed or returned. **Function Signature**: ```python def update_inventory(books: list[str], transactions: list[tuple[str, str]]) -> list[str]: Update the inventory of books based on the transactions. :param books: list[str] - List of books initially in the library. :param transactions: list[tuple[str, str]] - List of tuples where each tuple contains the book title and the transaction type (\'borrow\' or \'return\'). :return: list[str] - Updated list of books currently available in the library. ``` **Input**: - `books`: A list of strings where each string represents a book title in the library (0 <= length of books <= 10^6). - `transactions`: A list of tuples where each tuple consists of a string representing the book title and a string representing the transaction type (\\"borrow\\" or \\"return\\") (0 <= length of transactions <= 10^6). **Output**: - A list of strings representing the titles of books currently available in the library. **Constraints**: - Each book title is a non-empty string that only contains alphanumeric characters and spaces (1 <= length of each book title <= 100). - Transactions are processed in order, and there will be no borrowings of books that are not available and no returns of books that were not borrowed. **Example**: ```python assert update_inventory( [\\"The Great Gatsby\\", \\"1984\\", \\"To Kill a Mockingbird\\"], [(\\"1984\\", \\"borrow\\"), (\\"The Great Gatsby\\", \\"borrow\\"), (\\"1984\\", \\"return\\")] ) == [\\"To Kill a Mockingbird\\", \\"1984\\"] assert update_inventory( [\\"A Tale of Two Cities\\", \\"Moby Dick\\"], [(\\"The Catcher in the Rye\\", \\"return\\"), (\\"Moby Dick\\", \\"borrow\\"), (\\"A Tale of Two Cities\\", \\"borrow\\")] ) == [] assert update_inventory([], []) == [] ```","solution":"def update_inventory(books: list[str], transactions: list[tuple[str, str]]) -> list[str]: Update the inventory of books based on the transactions. :param books: list[str] - List of books initially in the library. :param transactions: list[tuple[str, str]] - List of tuples where each tuple contains the book title and the transaction type (\'borrow\' or \'return\'). :return: list[str] - Updated list of books currently available in the library. available_books = set(books) for title, action in transactions: if action == \'borrow\': available_books.discard(title) elif action == \'return\': available_books.add(title) return sorted(list(available_books))"},{"question":"# Scenario In a cloud storage system, you need to manage and retrieve files based on their paths. You should create a directory-like structure where you can store and look up files using their absolute paths. Your task is to write a class that handles these operations. # Task Implement the class `FileStorage` with the following methods: 1. `add_file(path: str) -> None`: Adds a file to the storage. 2. `find_file(path: str) -> bool`: Returns `True` if the file exists in the storage, otherwise `False`. # Class Signature ```python class FileStorage: def __init__(self): pass def add_file(self, path: str) -> None: pass def find_file(self, path: str) -> bool: pass ``` # Input: * `path` is a string representing the absolute path of the file and follows Unix-style notation (e.g., `/home/user/file.txt`). # Constraints: * `path` will always start with a `/`. * Each segment of the path contains only letters, digits, and underscores (`_`). # Examples: ```python # Example usage: storage = FileStorage() storage.add_file(\\"/home/user/file.txt\\") assert storage.find_file(\\"/home/user/file.txt\\") == True assert storage.find_file(\\"/home/user/anotherfile.txt\\") == False ``` 1. Adding file: `\\"/data/logs/log1.txt\\"` Checking file exists: `\\"/data/logs/log1.txt\\"` Output: `True` 2. Adding file: `\\"/data/logs/log2.txt\\"` Checking file exists: `\\"/data/logs/log3.txt\\"` Output: `False` # Note: The implementation should be efficient and capable of handling a large number of files with varying depths in the path hierarchy.","solution":"class FileStorage: def __init__(self): self.storage = set() def add_file(self, path: str) -> None: self.storage.add(path) def find_file(self, path: str) -> bool: return path in self.storage"},{"question":"```markdown # Unique Binary Search Trees II Context You have been tasked with generating all unique Binary Search Trees (BSTs) that store values `1...n`. A Binary Search Tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. For each node, all values in the left subtree are less than the value of the node, and all values in the right subtree are greater than the value of the node. Objective Implement a function `generate_trees(n: int) -> List[TreeNode]` which will return all possible unique BSTs that store values `1...n`. 1. Define the structure of the TreeNode class. 2. Implement the `generate_trees` function to construct all unique BSTs for 1 to n. 3. The tree nodes should be returned as a list. Requirements - **Input/Output Specifications**: * The function will take an integer `n` as input. * It should return a list of `TreeNode` objects representing all unique BSTs. * `TreeNode` class should have attributes `val`, `left`, and `right`. - **Constraints**: * 1 ≤ n ≤ 8 * The solution should be optimal in terms of both time and space complexity. * Ensure correctness and uniqueness of the generated trees. Implementation Reimplement the required functionality. Here is a function definition and TreeNode class for reference: ```python from typing import List, Optional, Tuple class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate_trees_helper(start: int, end: int) -> List[Optional[TreeNode]]: if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees_helper(start, i - 1) right_trees = generate_trees_helper(i + 1, end) for l in left_trees: for r in right_trees: curr_tree = TreeNode(i) curr_tree.left = l curr_tree.right = r all_trees.append(curr_tree) return all_trees return generate_trees_helper(1, n) ``` Example Usage: ```python result = generate_trees(3) # Output: A list of TreeNode objects representing all unique BSTs. # Example structure: # Tree 1: Tree 2: Tree 3: Tree 4: Tree 5: # 1 1 2 3 3 # / / / # 3 2 1 3 2 1 # / # 2 3 1 2 for tree in result: print_inorder(tree) # Implement a function to print the BST in-order. ``` Make sure to run comprehensive tests to ensure correctness for all values from 1 to n. Implement utility functions like `print_inorder` to verify the structure of the generated trees. ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def generate_trees(n: int) -> List[Optional[TreeNode]]: if n == 0: return [] def generate_trees_helper(start: int, end: int) -> List[Optional[TreeNode]]: if start > end: return [None] all_trees = [] for i in range(start, end + 1): left_trees = generate_trees_helper(start, i - 1) right_trees = generate_trees_helper(i + 1, end) for l in left_trees: for r in right_trees: curr_tree = TreeNode(i) curr_tree.left = l curr_tree.right = r all_trees.append(curr_tree) return all_trees return generate_trees_helper(1, n)"},{"question":"Coding Assessment Question **Question: Implement a Custom Data Structure for Efficient Minimum Retrieval** You are required to implement a custom data structure that supports efficient insertion, deletion, and retrieval of the minimum element. The data structure should allow the following operations in the specified time complexities: 1. `insert(x)`: Insert an integer `x` into the data structure. 2. `delete(x)`: Remove an integer `x` from the data structure. If `x` is not present, do nothing. 3. `get_min()`: Return the minimum element currently in the data structure. If the data structure is empty, return `None`. # Function Signature ```python class CustomDataStructure: def __init__(self): pass def insert(self, x: int) -> None: pass def delete(self, x: int) -> None: pass def get_min(self) -> int: pass ``` # Requirements * All operations (`insert`, `delete`, and `get_min`) should be optimized to run in logarithmic time if possible. * Handle edge cases where the structure might be empty. * Maintain correct functionality even after multiple insertions and deletions. # Example ```python # Initializing the data structure data_structure = CustomDataStructure() # Inserting elements data_structure.insert(5) data_structure.insert(10) data_structure.insert(3) # Getting the minimum element assert data_structure.get_min() == 3 # 3 is the smallest element # Deleting an element data_structure.delete(3) # Getting the minimum element after deletion assert data_structure.get_min() == 5 # 5 is now the smallest element # Deleting an element that does not exist does not alter the structure data_structure.delete(3) assert data_structure.get_min() == 5 # 5 is still the smallest element # Further operations data_structure.insert(1) assert data_structure.get_min() == 1 # 1 is the new smallest element data_structure.delete(1) assert data_structure.get_min() == 5 # 5 is again the smallest element data_structure.delete(5) data_structure.delete(10) assert data_structure.get_min() == None # The structure is empty ``` # Explanation * You need to implement the `CustomDataStructure` class that efficiently supports insertion, deletion, and minimum retrieval operations. * Ensure that the retrieval of the minimum element and other operations maintain optimal time complexity. * Test your implementation to handle a wide range of scenarios, including empty data structure cases and large number of operations.","solution":"import bisect class CustomDataStructure: def __init__(self): self.elements = [] def insert(self, x: int) -> None: bisect.insort(self.elements, x) def delete(self, x: int) -> None: index = bisect.bisect_left(self.elements, x) if index < len(self.elements) and self.elements[index] == x: self.elements.pop(index) def get_min(self) -> int: return self.elements[0] if self.elements else None"},{"question":"# Problem Statement Write a function that computes the Greatest Common Divisor (GCD) of a list of integers using the Euclidean algorithm. The function should handle edge cases and return appropriate errors when the list of integers is empty or contains non-integer elements. # Function Signature ```python def gcd_of_list(numbers: List[int]) -> int: pass ``` # Expected Input and Output Formats - **Input**: - `numbers`: A list of integers. - **Output**: - An integer representing the greatest common divisor of the list. # Constraints and Limitations 1. The list will contain integers but can be of any length. 2. Raise an appropriate exception if the list is empty. 3. Raise an appropriate exception if any element in the list is not an integer. 4. All integers will be non-negative. # Example ```python assert gcd_of_list([12, 15, 21]) == 3, \\"Test case failed\\" assert gcd_of_list([6, 9, 12, 15]) == 3, \\"Test case failed\\" assert gcd_of_list([25, 50, 75]) == 25, \\"Test case failed\\" assert gcd_of_list([101, 103]) == 1, \\"Test case failed\\" ``` # Performance Requirements The algorithm should: - Compute the GCD efficiently for typical lengths of lists provided. - Handle edge cases such as large values of integers and empty lists gracefully by raising appropriate exceptions. # Scenario Consider the example of simplifying a set of fractions, where you need to compute the greatest common divisor of the numerators to determine the simplest form in which they can be represented. Your implementation of the GCD function will enable accurate and efficient computation of such values.","solution":"from typing import List import math def gcd_of_list(numbers: List[int]) -> int: Returns the greatest common divisor (GCD) of a list of integers. :param numbers: A list of integers :return: An integer representing the greatest common divisor of the list :raises ValueError: if the list is empty or contains non-integer elements if not numbers: raise ValueError(\\"The list must not be empty\\") if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements in the list must be integers\\") gcd_result = numbers[0] for number in numbers[1:]: gcd_result = math.gcd(gcd_result, number) if gcd_result == 1: # Early stop if GCD is 1 return gcd_result return gcd_result"},{"question":"# Question: Implementing a Dynamic Priority Queue **Context**: You are developing a system that requires frequent priority-based task scheduling. You need to implement a dynamic priority queue that efficiently inserts tasks and fetches the highest priority task. The queue should always maintain tasks sorted according to their priority, with the highest priority being fetched first. Tasks with the same priority should be fetched in the order they were inserted (FIFO for same priorities). **Requirements**: 1. Implement a class `DynamicPriorityQueue` with methods for insertion and fetching tasks. 2. The `insert` method should add a task with a given priority to the queue. 3. The `fetch` method should remove and return the highest priority task from the queue. 4. Tasks with the same priority should follow FIFO (First-In-First-Out) order. **Class Signature**: ```python class DynamicPriorityQueue: def __init__(self): pass def insert(self, task: str, priority: int) -> None: pass def fetch(self) -> str: pass ``` **Input**: - `task (str)`: The task description. - `priority (int)`: The priority of the task (higher values indicate higher priority). **Output**: - The `insert` method does not return anything. - The `fetch` method returns a string representing the highest priority task description. **Constraints**: - 1 <= len(task) <= 100 - 1 <= priority <= 1000 - The queue should handle up to 10^5 operations efficiently. **Examples**: ```python >>> pq = DynamicPriorityQueue() >>> pq.insert(\\"task1\\", 2) >>> pq.insert(\\"task2\\", 1) >>> pq.insert(\\"task3\\", 3) >>> pq.fetch() \'task3\' >>> pq.insert(\\"task4\\", 3) >>> pq.insert(\\"task5\\", 2) >>> pq.fetch() \'task4\' >>> pq.fetch() \'task1\' >>> pq.fetch() \'task5\' >>> pq.fetch() \'task2\' ``` **Hint**: Consider using a data structure that supports efficient insertion and removal based on priority, such as a heapq in Python, but also maintains the order for tasks with the same priority.","solution":"import heapq from collections import deque class DynamicPriorityQueue: def __init__(self): self.priority_queue = [] self.entry_map = {} self.counter = 0 def insert(self, task: str, priority: int) -> None: if priority not in self.entry_map: self.entry_map[priority] = deque() self.entry_map[priority].append((self.counter, task)) heapq.heappush(self.priority_queue, (-priority, self.counter, task)) self.counter += 1 def fetch(self) -> str: while self.priority_queue: priority, counter, task = heapq.heappop(self.priority_queue) if self.entry_map[-priority] and self.entry_map[-priority][0][1] == task: self.entry_map[-priority].popleft() if not self.entry_map[-priority]: del self.entry_map[-priority] return task return \\"\\""},{"question":"# Question: Implement a Custom KMeans Clustering with KMeans++ You are tasked with implementing KMeans clustering algorithm with the KMeans++ initialization to enhance the performance and accuracy of clustering. Step 1: Implement KMeans++ Initialization 1. **Function Signature**: ```python def kmeans_plus_plus_initialization(data: np.ndarray, k: int) -> np.ndarray: ``` 2. **Inputs**: - `data`: Numpy array of shape (m, n) representing the data points. - `k`: Integer, the number of clusters. 3. **Outputs**: - `centroids`: Numpy array of shape (k, n) containing the initialized centroids. 4. **Procedure**: - Choose the first centroid randomly from the data points. - For each remaining centroid, select a point based on a probability proportional to the distance squared from the closest centroid. - Repeat until `k` centroids are chosen. Step 2: Implement KMeans Clustering 1. **Function Signature**: ```python def kmeans_clustering( data: np.ndarray, k: int, max_iter: int = 300, tol: float = 1e-4 ) -> Tuple[np.ndarray, np.ndarray]: ``` 2. **Inputs**: - `data`: Numpy array of shape (m, n) with the data points. - `k`: Integer, the number of clusters. - `max_iter`: Integer, the maximum number of iterations (default is 300). - `tol`: Float, the tolerance for convergence (default is 1e-4). 3. **Outputs**: - `centroids`: Numpy array of shape (k, n) containing the final centroids. - `labels`: Numpy array of shape (m,) with the cluster index for each data point. 4. **Procedure**: - Initialize centroids using KMeans++. - Assign each data point to the nearest centroid. - Update centroids by computing the mean of the assigned points. - Repeat until the centroids do not change significantly (within the `tol`) or the maximum number of iterations is reached. Step 3: Performance Verification 1. Verify your KMeans implementation with a synthetic dataset generated using `sklearn.datasets.make_blobs`. 2. Evaluate the clustering results by calculating the inertia (sum of squared distances to the nearest centroid). 3. Compare the performance and accuracy of your KMeans++ based implementation with a random centroid initialization. ```python # Example usage: from sklearn.datasets import make_blobs # Generate sample data data, _ = make_blobs(n_samples=300, centers=4, n_features=2, random_state=42) # Optimal number of clusters k = 4 # Initialize centroids initial_centroids = kmeans_plus_plus_initialization(data, k) # Perform KMeans clustering final_centroids, labels = kmeans_clustering(data, k) # Evaluate the result inertia = np.sum((data - final_centroids[labels])**2) print(f\\"Inertia: {inertia}\\") ``` **Note**: Refrain from using libraries such as `scikit-learn` for implementing the clustering algorithm, but you may use them for data generation and verification purposes.","solution":"import numpy as np from typing import Tuple def kmeans_plus_plus_initialization(data: np.ndarray, k: int) -> np.ndarray: Perform KMeans++ initialization to select initial centroids. Parameters: data (np.ndarray): The data array of shape (m, n). k (int): The number of clusters. Returns: np.ndarray: An array of shape (k, n) with the initialized centroids. m, n = data.shape centroids = np.zeros((k, n)) # Initialize the first centroid randomly centroids[0] = data[np.random.randint(0, m)] for i in range(1, k): # Compute the distance from each point to the closest centroid dists = np.min([np.linalg.norm(data - centroids[j], axis=1)**2 for j in range(i)], axis=0) # Compute the probability of selecting each point based on distance probs = dists / np.sum(dists) # Choose the next centroid based on the computed probabilities cumulative_probs = np.cumsum(probs) r = np.random.rand() idx = np.searchsorted(cumulative_probs, r) centroids[i] = data[idx] return centroids def kmeans_clustering( data: np.ndarray, k: int, max_iter: int = 300, tol: float = 1e-4 ) -> Tuple[np.ndarray, np.ndarray]: Perform KMeans clustering using KMeans++ initialization. Parameters: data (np.ndarray): The data array of shape (m, n). k (int): The number of clusters. max_iter (int): The maximum number of iterations (default is 300). tol (float): The tolerance for convergence (default is 1e-4). Returns: Tuple: A tuple containing final centroids (np.ndarray of shape (k, n)) and labels (np.ndarray of shape (m,)). m, n = data.shape centroids = kmeans_plus_plus_initialization(data, k) labels = np.zeros(m) for iteration in range(max_iter): # Assign each point to the nearest centroid labels = np.argmin(np.linalg.norm(data[:, np.newaxis] - centroids, axis=2), axis=1) # Compute new centroids new_centroids = np.array([data[labels == j].mean(axis=0) if np.any(labels == j) else centroids[j] for j in range(k)]) # Check for convergence if np.linalg.norm(new_centroids - centroids) < tol: break centroids = new_centroids return centroids, labels"},{"question":"# Sum of Non-Adjacent Numbers You are required to implement a function that calculates the maximum sum of non-adjacent numbers in a list of integers. **Input Format:** A list of integers `arr` representing the sequence of numbers. **Output Format:** Return an integer representing the maximum sum of non-adjacent numbers. **Constraints:** 1. The length of `arr` will be between 1 and 1000 inclusive. 2. Each integer in `arr` will be between -10^4 and 10^4 inclusive. 3. The list could include zero or negative numbers. **Performance Requirements:** The implementation should efficiently handle the maximum constraints, ideally operating in O(n) time complexity where `n` is the length of the list. **Examples:** ```python max_non_adjacent_sum([3, 2, 5, 10, 7]) # 15 max_non_adjacent_sum([-2, 1, 3, -4, 5]) # 8 max_non_adjacent_sum([3, 2, 7, 10]) # 13 max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) # 110 ``` **Function Signature:** ```python def max_non_adjacent_sum(arr: list) -> int: # Your code goes here pass ``` **Note:** Consider using dynamic programming to keep track of the maximum sum including and excluding the current element as you iterate through the list. This approach will help you achieve the desired time complexity and handle edge cases effectively.","solution":"def max_non_adjacent_sum(arr: list) -> int: if not arr: return 0 incl = 0 # Max sum including the current element excl = 0 # Max sum excluding the current element for num in arr: # If the current element is included, the maximum sum is the sum of the current element # and the maximum sum excluding the previous element new_incl = excl + num # If the current element is excluded, the maximum sum is simply the maximum sum including # or excluding the previous element excl = max(incl, excl) incl = new_incl return max(incl, excl)"},{"question":"# Problem Statement Develop a function `merge_sorted_arrays` that accepts multiple sorted arrays and returns one single sorted array containing all the elements from the input arrays. You should ensure the result is sorted in non-decreasing order. # Function Signature ```python def merge_sorted_arrays(*arrays: list) -> list: pass ``` # Input - `arrays` (list): A variable number of lists, each containing sorted integers. Each list is guaranteed to be sorted in non-decreasing order. # Output - A list containing all the integers from the input arrays merged into a single list and sorted in non-decreasing order. # Constraints - You may assume the total number of integers across all arrays does not exceed 2 * 10^6. - Each individual array\'s length will be between 1 and 10^5. # Examples ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2], [3, 4], [5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([-10, 0, 10], [-5, 5, 15]) [-10, -5, 0, 5, 10, 15] >>> merge_sorted_arrays([1], [2], [3]) [1, 2, 3] ``` # Notes 1. Ensure that the function handles an arbitrary number of array arguments. 2. The merging should maintain the non-decreasing order of elements. 3. Consider using a heap or priority queue for efficient merging of the arrays.","solution":"from heapq import heappop, heappush, heapify def merge_sorted_arrays(*arrays): min_heap = [] result = [] for index, array in enumerate(arrays): if array: heappush(min_heap, (array[0], index, 0)) while min_heap: value, array_index, element_index = heappop(min_heap) result.append(value) if element_index + 1 < len(arrays[array_index]): next_tuple = (arrays[array_index][element_index + 1], array_index, element_index + 1) heappush(min_heap, next_tuple) return result"},{"question":"Coding Assessment Question Context You are developing an application that processes large sets of numerical data. One of the tasks involves efficiently computing running statistics for a series of numbers provided in real-time. Specifically, you need to implement a system that calculates the median of a growing list of numbers as new data points are added sequentially. Objective Write a class to handle the dynamic computation of the median for a stream of integers. Your class should support adding new numbers and retrieving the current median at any point. Class Signature ```python class MedianFinder: def __init__(self): Initialize your data structure here. pass def add_num(self, num: int) -> None: Add a number to the data stream. Args: num (int): The new number to add. pass def find_median(self) -> float: Calculate and return the median of the current data stream. Returns: float: The median of the data stream. pass ``` Input & Output * **Input**: The class has methods to process and retrieve data. * `add_num(num: int)`: Accepts an integer to be added to the data stream. * `find_median()`: Returns the median of the numbers processed so far as a float. * **Output**: The median of the data stream at the time `find_median` is called. Constraints * The function should handle a large number of elements efficiently. * The data stream could contain up to 10^5 elements. * The numbers are within the range of [-10^6, 10^6]. Example ```python mf = MedianFinder() mf.add_num(1) mf.add_num(2) assert mf.find_median() == 1.5 mf.add_num(3) assert mf.find_median() == 2.0 ``` Performance Requirements * The implementation should efficiently compute the median in logarithmic time complexity for insertions and sub-linear time complexity for finding the median.","solution":"import heapq class MedianFinder: def __init__(self): Initialize your data structure here. # Max heap to store the smaller half of the numbers self.small = [] # Min heap to store the larger half of the numbers self.large = [] def add_num(self, num: int) -> None: Add a number to the data stream. Args: num (int): The new number to add. # We invert the values for the small heap to simulate a max heap using Python\'s heapq (which is a min heap) heapq.heappush(self.small, -num) # Make sure the elements in self.small are less than or equal to the elements in self.large if self.small and self.large and (-self.small[0] > self.large[0]): val = -heapq.heappop(self.small) heapq.heappush(self.large, val) # Balance the lengths of the two heaps so that the heaps have the same length or self.small has one more element than self.large if len(self.small) > len(self.large) + 1: val = -heapq.heappop(self.small) heapq.heappush(self.large, val) if len(self.large) > len(self.small): val = heapq.heappop(self.large) heapq.heappush(self.small, -val) def find_median(self) -> float: Calculate and return the median of the current data stream. Returns: float: The median of the data stream. if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Coding Question: Create functions for the `LinkedList` class to manipulate and process singly linked lists: 1. **Function to reverse the linked list**: Implement a method `reverse` to reverse the linked list in place. The function should not return anything; it should modify the linked list directly. ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None # existing methods... def reverse(self) -> None: Reverse the linked list in place. >>> LinkedList.from_list([1, 2, 3, 4, 5]).reverse() >>> print(LinkedList.to_list()) # Output: [5, 4, 3, 2, 1] # Your implementation here ``` 2. **Function to detect a cycle in the linked list**: Implement a method `has_cycle` which checks whether the linked list contains a cycle. The method should return a boolean indicating whether a cycle exists. ```python class LinkedList: # existing methods... def has_cycle(self) -> bool: Check if the linked list contains a cycle. Returns: A boolean indicating if there is a cycle in the linked list. >>> l = LinkedList.from_list([1, 2, 3, 4, 5]) >>> l.head.next.next.next.next = l.head.next >>> l.has_cycle() True >>> l = LinkedList.from_list([1, 2, 3, 4, 5]) >>> l.has_cycle() False # Your implementation here ``` # Constraints: * The linked list node values are integers. * The list may have up to 10^6 nodes. * You can assume that the input list does not contain duplicate values. # Examples: ```python # Creating a linked list with elements [1, 2, 3, 4, 5] l = LinkedList.from_list([1, 2, 3, 4, 5]) # Reversing the linked list l.reverse() print(LinkedList.to_list()) # Output: [5, 4, 3, 2, 1] # Detecting a cycle in the linked list l.head.next.next.next.next = l.head.next print(l.has_cycle()) # Output: True # Detecting no cycle in the linked list l = LinkedList.from_list([1, 2, 3, 4, 5]) print(l.has_cycle()) # Output: False ``` # Additional Notes: * Make sure the `reverse` function modifies the linked list in place without using extra space. * Ensure the `has_cycle` function runs in O(n) time complexity and O(1) space complexity using Floyd’s Tortoise and Hare algorithm.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None @staticmethod def from_list(values): Create a linked list from a list of values. ll = LinkedList() if values: ll.head = ListNode(values[0]) current = ll.head for value in values[1:]: current.next = ListNode(value) current = current.next return ll def to_list(self): Convert the linked list to a list of values. values = [] current = self.head while current: values.append(current.value) current = current.next return values def reverse(self) -> None: Reverse the linked list in place. prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self) -> bool: Check if the linked list contains a cycle. slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Problem Statement: You are given two functions that convert between Roman numerals and integers: 1. `int_to_roman` - Converts an integer to its Roman numeral representation. 2. `roman_to_int` - Converts a Roman numeral to its integer representation. Your task is to write a new function `roman_numeral_conversion` that tests the accuracy of both provided functions by converting an integer to a Roman numeral and then back to an integer. Verify if the final result matches the original input integer, and return a boolean value indicating if they are equal. # Function Signature: ```python def roman_numeral_conversion(num: int) -> bool: pass ``` # Input: * `num`: A positive integer (1 <= num <= 3999). # Output: * Returns `True` if converting `num` to a Roman numeral and back yields the same integer, otherwise returns `False`. # Constraints: * Input will always be a positive integer. * Implement the function using both provided methods and compare their outputs. # Example: ```python assert roman_numeral_conversion(100) == True assert roman_numeral_conversion(1) == True assert roman_numeral_conversion(1990) == True assert roman_numeral_conversion(3999) == True ``` # Note: * Use the given functions `int_to_roman` and `roman_to_int` as black-boxes, you do not need to modify them. # Provided Functions: ```python # Example implementations (you don\'t need to modify these) def int_to_roman(num: int) -> str: val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num def roman_to_int(s: str) -> int: rom_val = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 num = 0 while i < len(s): if i+1 < len(s) and s[i:i+2] in rom_val: num += rom_val[s[i:i+2]] i += 2 else: num += rom_val[s[i]] i += 1 return num ```","solution":"def roman_numeral_conversion(num: int) -> bool: Converts an integer to a Roman numeral and then back to an integer. Verifies if the final result matches the original input integer. Returns True if they are equal, otherwise False. roman_numeral = int_to_roman(num) converted_back_int = roman_to_int(roman_numeral) return converted_back_int == num def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. rom_val = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000, \'IV\': 4, \'IX\': 9, \'XL\': 40, \'XC\': 90, \'CD\': 400, \'CM\': 900 } i = 0 num = 0 while i < len(s): if i+1 < len(s) and s[i:i+2] in rom_val: num += rom_val[s[i:i+2]] i += 2 else: num += rom_val[s[i]] i += 1 return num"},{"question":"# Coding Challenge: Dictionary Flattening **Objective**: Write a function that flattens a nested dictionary. The keys of the flattened dictionary should be the path to each value in the original dictionary, separated by a given delimiter. Function Signature ```python def flatten_dictionary(nested_dict: Dict[str, Any], delimiter: str = \'.\') -> Dict[str, Any]: pass ``` Input - `nested_dict` (dict): The dictionary to be flattened. It can be nested arbitrarily. - `delimiter` (str): The delimiter to use for the flattened keys. It defaults to a period (`.`). Output - `Dict[str, Any]`: The flattened dictionary with concatenated keys. Constraints - The dictionary can only contain other dictionaries or basic types (integers, strings, etc.) as values. - The depth of the dictionary will not exceed 10 levels. - The total number of key-value pairs in the flattened dictionary will not exceed 1000. Examples ```python assert flatten_dictionary({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) == {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} assert flatten_dictionary({\\"x\\": {\\"y\\": {\\"z\\": 4}}}, delimiter=\'-\') == {\\"x-y-z\\": 4} assert flatten_dictionary({\\"key\\": {\\"subkey\\": \\"value\\"}, \\"anotherkey\\": 5}) == {\\"key.subkey\\": \\"value\\", \\"anotherkey\\": 5} assert flatten_dictionary({}) == {} ``` # Implementation Notes 1. Start with an empty dictionary to hold the flattened key-value pairs. 2. Define a helper function to recursively traverse the dictionary. 3. For each key in the nested dictionary, concatenate it with the previous keys using the given delimiter. 4. If the value is a dictionary, recursively process the nested dictionary. 5. If the value is a basic type, add it to the result dictionary with the concatenated key. 6. Return the flattened dictionary. Good luck!","solution":"def flatten_dictionary(nested_dict, delimiter=\'.\'): def _flatten(current_dict, parent_key): items = [] for k, v in current_dict.items(): new_key = f\\"{parent_key}{delimiter}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten(v, new_key).items()) else: items.append((new_key, v)) return dict(items) return _flatten(nested_dict, \\"\\") # Example usage: # assert flatten_dictionary({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) == {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} # assert flatten_dictionary({\\"x\\": {\\"y\\": {\\"z\\": 4}}}, delimiter=\'-\') == {\\"x-y-z\\": 4} # assert flatten_dictionary({\\"key\\": {\\"subkey\\": \\"value\\"}, \\"anotherkey\\": 5}) == {\\"key.subkey\\": \\"value\\", \\"anotherkey\\": 5} # assert flatten_dictionary({}) == {}"},{"question":"# Reverse Elements in List by Group Size Given a list of integers and a specified group size, reverse each group of the specified size within the list. If there are not enough elements to complete a group at the end of the list, reverse only the remaining elements. # Function Signature ```python def reverse_in_groups(lst: List[int], k: int) -> List[int]: pass ``` # Input: * `lst`: A list of integers. * `k`: An integer representing the group size. # Output: * Return a list where each group of size `k` is reversed. # Constraints: * `1 <= len(lst) <= 10^4` * `1 <= k <= 10^4` * `1 <= lst[i] <= 10^6` for each integer in the list. # Requirements: 1. The function should handle cases where `k` is greater than the length of the list. 2. If `k` is 1, the output list should be the same as the input list. 3. The function should not modify the input list but return a new modified list. # Examples: ```python assert reverse_in_groups([1, 2, 3, 4, 5], 2) == [2, 1, 4, 3, 5] assert reverse_in_groups([1, 2, 3, 4, 5, 6, 7, 8], 3) == [3, 2, 1, 6, 5, 4, 8, 7] assert reverse_in_groups([1, 2, 3], 4) == [3, 2, 1] assert reverse_in_groups([5, 12, 11, 3, 20], 1) == [5, 12, 11, 3, 20] assert reverse_in_groups([5, 12, 11, 3, 20, 17, 8], 3) == [11, 12, 5, 17, 20, 3, 8] ``` Implement the function in Python and test it considering the provided examples and edge cases.","solution":"from typing import List def reverse_in_groups(lst: List[int], k: int) -> List[int]: n = len(lst) result = [] for i in range(0, n, k): group = lst[i:i + k] result.extend(reversed(group)) return result"},{"question":"# Question Style Task Develop a function that performs a specific operation on a given structured data input, maintaining consistency with the format and presentation of the sample questions provided. # Problem Statement Implement a function `number_to_words(n: int) -> str` that converts a given non-negative integer n into its corresponding English words representation. # Problem Statement Given a non-negative integer `n`, implement a function that maps the number to its English words string equivalent. 1. **Input:** - An integer `n` where `0 ≤ n ≤ 999,999` 2. **Output:** - A string representing the English words equivalent of the provided number `n`. 3. **Constraints:** - The input integer `n` will be in the range from 0 to 999999. - Ensure proper handling of singular and plural forms as well as correct grouping for thousands and hundreds. 4. **Examples:** ```python assert number_to_words(123) == \\"one hundred twenty-three\\" assert number_to_words(0) == \\"zero\\" assert number_to_words(1001) == \\"one thousand one\\" assert number_to_words(999999) == \\"nine hundred ninety-nine thousand nine hundred ninety-nine\\" ``` # Solution Template ```python def number_to_words(n: int) -> str: Convert a non-negative integer to its English words representation. The n parameter should be in the range [0, 999999], other numbers aren\'t tested. Parameters: n (int): The non-negative integer to convert (0 ≤ n ≤ 999999) Returns: str: The English words representation of the integer # Handle special cases if n == 0: return \\"zero\\" # Initial lookup arrays ones = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] # Define the helper function for grouping numbers def helper(num): if num == 0: return \\"\\" elif num < 20: return ones[num] + \\" \\" elif num < 100: return tens[num // 10] + \\" \\" + ones[num % 10] + \\" \\" else: return ones[num // 100] + \\" hundred \\" + helper(num % 100) res = \\"\\" if n >= 1000: res += helper(n // 1000) + \\"thousand \\" n %= 1000 res += helper(n) # Remove leading/trailing spaces return res.strip() ```","solution":"def number_to_words(n: int) -> str: Convert a non-negative integer to its English words representation. The n parameter should be in the range [0, 999999], other numbers aren\'t tested. Parameters: n (int): The non-negative integer to convert (0 ≤ n ≤ 999999) Returns: str: The English words representation of the integer if n == 0: return \\"zero\\" ones = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] def helper(num): if num == 0: return \\"\\" elif num < 20: return ones[num] + \\" \\" elif num < 100: return tens[num // 10] + \\" \\" + ones[num % 10] + \\" \\" else: return ones[num // 100] + \\" hundred \\" + helper(num % 100) res = \\"\\" if n >= 1000: res += helper(n // 1000) + \\"thousand \\" n %= 1000 res += helper(n) return res.strip()"},{"question":"# Binary Tree - Farthest Leaf Node In this exercise, you are tasked with implementing a function `farthest_leaf_distance` that computes the maximum distance from the root node to any leaf node in a given binary tree. Your task involves traversing the binary tree and identifying the path from the root to the farthest leaf node. You will be working with the following `TreeNode` and `BinaryTree` classes: ```python from typing import Any from dataclasses import dataclass @dataclass class TreeNode: data: Any left: \'TreeNode\' | None = None right: \'TreeNode\' | None = None @dataclass class BinaryTree: root: \'TreeNode\' | None = None ``` Your task is to add a method `farthest_leaf_distance` to the `BinaryTree` class, which should return an integer representing the maximum distance (in terms of edges) from the root node to any leaf node. # Function Signature ```python def farthest_leaf_distance(self) -> int: pass ``` # Constraints - Assume the binary tree may contain any number of nodes (including zero nodes). - The function should handle edge cases like empty trees and trees with only one node correctly. - Your implementation should use a depth-first search strategy. - Aim for a time complexity of O(n), where n is the number of nodes in the tree. - Aim for a space complexity of O(h), where h is the height of the tree due to the call stack in the depth-first search. # Examples ```python >>> binary_tree = BinaryTree() >>> binary_tree.root = TreeNode(1) >>> binary_tree.root.left = TreeNode(2) >>> binary_tree.root.right = TreeNode(3) >>> binary_tree.root.left.left = TreeNode(4) >>> binary_tree.root.left.right = TreeNode(5) >>> binary_tree.farthest_leaf_distance() 2 >>> binary_tree2 = BinaryTree() >>> binary_tree2.root = TreeNode(1) >>> binary_tree2.farthest_leaf_distance() 0 >>> binary_tree3 = BinaryTree() >>> binary_tree3.farthest_leaf_distance() 0 ``` Add this function to the `BinaryTree` class and ensure its correctness with appropriate edge cases and varied tree structures.","solution":"from typing import Any, Optional from dataclasses import dataclass @dataclass class TreeNode: data: Any left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None @dataclass class BinaryTree: root: Optional[TreeNode] = None def farthest_leaf_distance(self) -> int: def dfs(node: Optional[TreeNode]) -> int: if not node: return -1 left_depth = dfs(node.left) right_depth = dfs(node.right) return 1 + max(left_depth, right_depth) if not self.root: return 0 return dfs(self.root)"},{"question":"# Question: Implement an Efficient Anagram Checker As part of a new feature in your company\'s messaging platform, you are to develop a function to determine if two provided strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. To ensure optimal performance, your implementation must be efficient in terms of both time and space complexity. **Function Signature:** ```python def are_anagrams(s1: str, s2: str) -> bool: pass ``` **Input:** - Two strings `s1` and `s2` of lengths `1 <= len(s1), len(s2) <= 10^5`, containing lowercase and uppercase alphabets. **Output:** - Return a boolean value `True` if `s1` and `s2` are anagrams, otherwise return `False`. **Constraints:** 1. Consider that \'A\' and \'a\' are the same characters (i.e., the function should be case-insensitive). 2. Optimize for time complexity as much as possible. **Examples:** ```python assert are_anagrams(\\"Listen\\", \\"Silent\\") == True assert are_anagrams(\\"Hello\\", \\"Olelh\\") == True assert are_anagrams(\\"Dormitory\\", \\"Dirtyroom\\") == True assert are_anagrams(\\"Hi\\", \\"Bye\\") == False assert are_anagrams(\\"Astronomer\\", \\"Moon starer\\") == True ``` **Scenario:** The messaging platform processes a high volume of text data and must quickly identify anagrams to support various text analysis features. Your solution should ensure high efficiency and handle very large inputs gracefully, without excessive memory usage.","solution":"from collections import Counter def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are anagrams of each other, considering case-insensitivity and ignoring spaces. # Normalize by removing spaces and converting to lowercase s1 = s1.replace(\\" \\", \\"\\").lower() s2 = s2.replace(\\" \\", \\"\\").lower() # Anagrams must have the same length after normalization if len(s1) != len(s2): return False # Compare the character counts return Counter(s1) == Counter(s2)"},{"question":"# Problem Statement Scenario: You are working on a simulation of a simplified version of the game \\"Pac-Man\\". The game is played on a grid where some cells are walls and others are open paths. Pac-Man can move up, down, left, or right, but not through walls. You need to determine if Pac-Man can reach a specific target cell from his starting position. Task: Implement functions to represent the grid, manage Pac-Man\'s movements, and determine if the target can be reached. Requirements: - Define a function `can_reach_target(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> bool` that checks if Pac-Man can reach the target position from the start position. - Pac-Man can move to a cell if it contains 0 (open path). - Pac-Man cannot move to a cell if it contains 1 (wall). - Use Breadth-First Search (BFS) for the implementation to find the shortest path. Inputs: 1. `grid` (list[list[int]]): A 2D list representing the grid where 0 is an open path and 1 is a wall. 2. `start` (tuple[int, int]): A tuple representing the starting cell (row, column) where Pac-Man is initially located. 3. `target` (tuple[int, int]): A tuple representing the target cell (row, column) Pac-Man needs to reach. Outputs: - Returns `True` if Pac-Man can reach the target cell, `False` otherwise. Constraints: - The grid is a list of lists containing only 0s and 1s. - The dimensions of the grid are constrained to 1 ≤ rows, columns ≤ 100. - The starting and target positions are guaranteed to be within the grid and on open paths. Example: ```python # Example 1 grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 1], [0, 1, 0, 0] ] start = (0, 0) target = (2, 2) # Expected Output: True # Example 2 grid = [ [0, 1], [1, 0] ] start = (0, 0) target = (1, 1) # Expected Output: False ``` Code Usage: ```python if __name__ == \\"__main__\\": test_grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 1], [0, 1, 0, 0] ] start_position = (0, 0) target_position = (2, 2) print(can_reach_target(test_grid, start_position, target_position)) # Output: True ``` Ensure that your implementation handles various edge cases and efficiently processes different grid sizes and configurations.","solution":"from collections import deque def can_reach_target(grid, start, target): Determines if Pac-Man can reach the target cell from the start cell in a given grid. Parameters: - grid (list[list[int]]): A 2D list representing the grid where 0 is an open path and 1 is a wall. - start (tuple[int, int]): The starting cell (row, column) where Pac-Man is initially located. - target (tuple[int, int]): The target cell (row, column) Pac-Man needs to reach. Returns: - bool: True if Pac-Man can reach the target cell, False otherwise. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() if (r, c) == target: return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: queue.append((nr, nc)) visited.add((nr, nc)) return False"},{"question":"**Objective**: To gain proficiency in designing data structures, performing string operations, and managing edge cases with custom constraints. **Phone Directory Challenge**: Implement a Python class `PhoneDirectory` which manages a list of contacts and can search for contacts based on prefix matching. The contact names should be case-insensitive and unique. # Tasks 1. **add_contact**: Write a method `add_contact` which takes `name` (a string of the contact\'s name) as a parameter. Add the contact name to the directory. If the contact already exists, return `False`. Otherwise, add it to the directory and return `True`. 2. **delete_contact**: Write a method `delete_contact` which takes `name` (a string) as a parameter and deletes the contact from the directory. Return `True` if deletion was successful, otherwise `False` if the contact was not found. 3. **search_contact**: Write a method `search_contact` which takes `prefix` (a string) as a parameter and returns a list of all contacts that start with the given prefix. The search should be case-insensitive. 4. **list_contacts**: Write a method `list_contacts` which returns all contacts sorted in ascending order. The comparison should be case-insensitive but the original case should be preserved in the output. # Specifications - The `name` of the contact can contain spaces and should be treated as a single entity (no partial matching except for prefix search). - Handle empty strings or strings with only spaces appropriately. - Ensure the add and delete operations are efficient and handle duplicate names gracefully. - Use appropriate data structures to optimize the prefix search and listing operations. - Develop a simple `__main__` method to demonstrate the usage of your class and methods. # Example ```python # Example usage directory = PhoneDirectory() print(directory.add_contact(\\"Alice Wonderland\\")) # Output: True print(directory.add_contact(\\"alice wonderland\\")) # Output: False (Duplicate entry) print(directory.search_contact(\\"ali\\")) # Output: [\'Alice Wonderland\'] print(directory.add_contact(\\"Bob Builder\\")) # Output: True print(directory.list_contacts()) # Output: [\'Alice Wonderland\', \'Bob Builder\'] print(directory.delete_contact(\\"Charlie Brown\\")) # Output: False print(directory.delete_contact(\\"Alice Wonderland\\")) # Output: True print(directory.list_contacts()) # Output: [\'Bob Builder\'] ``` # Constraints: - Each contact name `name` should be a string with a maximum length of 50 characters. - Prefix length `prefix` can range up to the maximum length of the contact name. - The total number of contacts in the directory should not exceed 10^5. **Note**: Handle edge cases such as duplicate additions, deletion of non-existing contacts, and searches with no matching results efficiently.","solution":"class PhoneDirectory: def __init__(self): self.contacts = set() self.contacts_case_insensitive = {} def add_contact(self, name): Adds a contact to the phone directory. Returns True if added successfully, False if the contact already exists. cleaned_name = name.strip() if not cleaned_name: return False lower_name = cleaned_name.lower() if lower_name in self.contacts_case_insensitive: return False self.contacts.add(cleaned_name) self.contacts_case_insensitive[lower_name] = cleaned_name return True def delete_contact(self, name): Deletes a contact from the phone directory. Returns True if deletion was successful, False if the contact was not found. lower_name = name.strip().lower() if lower_name not in self.contacts_case_insensitive: return False original_name = self.contacts_case_insensitive[lower_name] self.contacts.remove(original_name) del self.contacts_case_insensitive[lower_name] return True def search_contact(self, prefix): Searches for contacts that start with the given prefix. Returns a list of all matching contacts. lower_prefix = prefix.strip().lower() if not lower_prefix: return [] matching_contacts = [ original_name for lower_name, original_name in self.contacts_case_insensitive.items() if lower_name.startswith(lower_prefix) ] return sorted(matching_contacts, key=lambda name: name.lower()) def list_contacts(self): Returns all contacts sorted in ascending order. return sorted(self.contacts, key=lambda name: name.lower())"},{"question":"# Question Context: You are a developer working on a travel planning application. A key feature in your application is to find the shortest path between two cities in a larger network of cities using road connections. # Coding Task: Implement a function `find_shortest_path` which takes an adjacency list representation of a graph, a start city, and an end city. The goal is to return the shortest path in terms of distance between the start and end cities. # Input: * A dictionary (adjacency list) where the keys are city names (strings) and the values are lists of tuples, each containing a neighboring city and the distance to that city. * A string representing the start city. * A string representing the end city. # Output: * A list of strings representing the sequence of cities in the shortest path from the start city to the end city, including the start and end cities. # Constraints: * The cities are represented as alphanumeric strings. * Distances are positive integers. * There exists at least one path from the start city to the end city. # Performance Requirements: * Your solution should be efficient with respect to both time and space complexities. * Aim to achieve a time complexity close to O((V + E) log V), where V is the number of cities and E is the number of connections, using Dijkstra\'s algorithm or a similar approach. # Scenario: Consider the following example scenario to better understand the task requirements. ```python def find_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: # Your implementation here pass # Example: graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } start = \'A\' end = \'D\' # Calling the function should return [\'A\', \'B\', \'C\', \'D\'] since this is the shortest path with a distance of 4 print(find_shortest_path(graph, start, end)) # Output: [\'A\', \'B\', \'C\', \'D\'] ```","solution":"import heapq from typing import List, Tuple, Dict def find_shortest_path(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> List[str]: Uses Dijkstra\'s algorithm to find the shortest path from start to end city in the given graph. :param graph: A dictionary representing the adjacency list of graph where keys are city names, and values are lists of tuples with neighboring city and distance. :param start: Starting city name as a string. :param end: Destination city name as a string. :return: A list of strings representing the sequence of cities in the shortest path. # Priority queue to store (distance, city, path) pq = [(0, start, [start])] # Dictionary to store the minimum distances to each city min_dist = {start: 0} while pq: current_dist, current_city, path = heapq.heappop(pq) if current_city == end: return path for neighbor, weight in graph.get(current_city, []): distance = current_dist + weight if neighbor not in min_dist or distance < min_dist[neighbor]: min_dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor, path + [neighbor])) return [] # return an empty list if no path found (although the problem guarantees at least one path) # Example usage graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } start = \'A\' end = \'D\' print(find_shortest_path(graph, start, end)) # Expected Output: [\'A\', \'B\', \'C\', \'D\']"},{"question":"# Coding Assessment Question **Context**: A sequence of integers is defined as follows: the first term is 1, and each subsequent term is twice the sum of all previous terms plus 1. More formally, the sequence is ( a_1 = 1 ), and ( a_n = 2 times (a_1 + a_2 + ldots + a_{n-1}) + 1 ) for ( n > 1 ). We need you to write a function to determine the ( n )-th term of this sequence. **Function Signature**: ```python def nth_term_of_sequence(n: int) -> int: This function returns the nth term of the sequence defined as specified. ``` **Input**: * An integer `n` (1 ≤ n ≤ 20). **Output**: * An integer representing the nth term of the sequence. **Example**: ```python >>> nth_term_of_sequence(1) 1 >>> nth_term_of_sequence(2) 3 >>> nth_term_of_sequence(3) 9 >>> nth_term_of_sequence(4) 27 >>> nth_term_of_sequence(5) 81 ``` **Constraints/Notes**: * The sequence grows rapidly; ensure that the implementation handles the upper bounds of ( n ) appropriately. * To keep the solution efficient, consider how the sum of all previous terms can be computed without repeatedly iterating through the sequence.","solution":"def nth_term_of_sequence(n: int) -> int: This function returns the nth term of the sequence defined as specified. if n == 1: return 1 terms = [1] for i in range(2, n + 1): next_term = 2 * sum(terms) + 1 terms.append(next_term) return terms[-1]"},{"question":"Scenario You are developing an application that involves managing a list of tasks with deadlines and durations. The application needs to maximize the number of tasks that can be completed before their deadlines. Each task has a specific deadline and a duration, and tasks cannot be partially completed—they must be completed in one go. Your task is to determine the maximum number of tasks that can be completed within their deadlines. Problem Statement Write a function `maximize_tasks` that, given a list of tasks with their deadlines and durations, returns the maximum number of tasks that can be completed before their deadlines. # Function Signature ```python def maximize_tasks(tasks: List[Tuple[int, int]]) -> int: ``` # Input * A list of tuples `tasks` where each tuple represents a task: * The first element is the deadline of the task (an integer). * The second element is the duration of the task (an integer). # Output * Return an integer representing the maximum number of tasks that can be completed before their deadlines. # Constraints * 1 <= number of tasks <= 1000 * 1 <= deadline <= 1000 * 1 <= duration <= 100 # Example ```python tasks = [(4, 3), (2, 1), (4, 1), (3, 2)] result = maximize_tasks(tasks) # This should return the maximum number of tasks that can be completed # (e.g., 3) ``` # Additional Information * The tasks are indexed starting from 0 in the order they are provided in the input list. * You are free to schedule the tasks in any order to maximize the number of tasks completed before their deadlines. * Perform necessary checks to efficiently handle large lists and ensure the optimal number of tasks are scheduled and completed.","solution":"from typing import List, Tuple def maximize_tasks(tasks: List[Tuple[int, int]]) -> int: Determines the maximum number of tasks that can be completed within their deadlines. Parameters: tasks (List[Tuple[int, int]]): A list of tasks where each task is represented as a tuple (deadline, duration). Returns: int: The maximum number of tasks that can be completed before their deadlines. # Sort the tasks based on their deadlines tasks.sort(key=lambda x: x[0]) current_time = 0 count = 0 for deadline, duration in tasks: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"Question: Implement Basic List Operations You are tasked with implementing several fundamental list operations without using external libraries. This will test your knowledge of basic data structures, loops, and list manipulations. Ensure that edge cases and non-conventional inputs are handled appropriately. # Operations to Implement 1. **Concatenation**: Concatenates two lists. ```python def concatenate(lst1: List[Any], lst2: List[Any]) -> List[Any]: pass ``` 2. **Element-wise Addition**: Adds corresponding elements of two lists of the same length. If lengths don\'t match, raise `ValueError`. ```python def element_wise_add(lst1: List[float], lst2: List[float]) -> List[float]: pass ``` 3. **Flatten**: Flattens a nested list into a single list. ```python def flatten(nested_lst: List[Any]) -> List[Any]: pass ``` 4. **Intersection**: Returns the intersection of two lists. ```python def intersection(lst1: List[Any], lst2: List[Any]) -> List[Any]: pass ``` 5. **Unique Elements**: Returns a list containing only the unique elements of the input list, preserving the order of their first occurrence. ```python def unique_elements(lst: List[Any]) -> List[Any]: pass ``` # Input & Output Specifications: - Lists can contain any data type. - Raise `ValueError` if lengths of input lists in `element_wise_add` do not match. - Raise `TypeError` if inputs are not lists where applicable. # Example Usage: ```python lst1 = [1, 2, 3] lst2 = [4, 5, 6] nested_lst = [1, [2, 3], [4, [5, 6]]] print(concatenate(lst1, lst2)) # Output: [1, 2, 3, 4, 5, 6] print(element_wise_add(lst1, lst2)) # Output: [5, 7, 9] print(flatten(nested_lst)) # Output: [1, 2, 3, 4, 5, 6] print(intersection([1, 2, 3, 4], [3, 4, 5, 6])) # Output: [3, 4] print(unique_elements([1, 2, 2, 3, 4, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Constraints: - Assume maximum list length is 1000. - Elements inside the lists can be of any hashable type for all operations except `element_wise_add`, which will have only floats. # Performance Requirements: Ensure that operations are efficient and handle lists up to the maximum length within acceptable performance limits.","solution":"from typing import List, Any def concatenate(lst1: List[Any], lst2: List[Any]) -> List[Any]: Concatenates two lists. if not isinstance(lst1, list) or not isinstance(lst2, list): raise TypeError(\\"Both inputs must be lists\\") return lst1 + lst2 def element_wise_add(lst1: List[float], lst2: List[float]) -> List[float]: Adds corresponding elements of two lists of the same length. Raises ValueError if lengths don\'t match. if not isinstance(lst1, list) or not isinstance(lst2, list): raise TypeError(\\"Both inputs must be lists\\") if len(lst1) != len(lst2): raise ValueError(\\"Lists must be of the same length for element-wise addition\\") return [a + b for a, b in zip(lst1, lst2)] def flatten(nested_lst: List[Any]) -> List[Any]: Flattens a nested list into a single list. if not isinstance(nested_lst, list): raise TypeError(\\"Input must be a list\\") flat_list = [] def _flatten(sublist): for item in sublist: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_lst) return flat_list def intersection(lst1: List[Any], lst2: List[Any]) -> List[Any]: Returns the intersection of two lists. if not isinstance(lst1, list) or not isinstance(lst2, list): raise TypeError(\\"Both inputs must be lists\\") return [item for item in lst1 if item in lst2] def unique_elements(lst: List[Any]) -> List[Any]: Returns a list containing only the unique elements of the input list, preserving the order of their first occurrence. if not isinstance(lst, list): raise TypeError(\\"Input must be a list\\") seen = set() unique_lst = [] for item in lst: if item not in seen: unique_lst.append(item) seen.add(item) return unique_lst"},{"question":"Question: In this task, you are required to implement a function that evaluates a string containing valid mathematical expressions and computes their results. This exercise is intended to assess your comprehension and ability to handle basic arithmetic operations and expression parsing. # Requirements: 1. **Function**: `def evaluate_expression(expression: str) -> float:` 2. **Input**: * A string `expression`, e.g., `\\"3 + 2 * 2\\"`. 3. **Output**: * A floating-point result of the evaluated expression. 4. **Constraints**: * The input string will only contain digits (0-9), operators (`+`, `-`, `*`, `/`), and spaces. * Assume that the input string is a valid mathematical expression and does not require additional validation. * The result should be computed using standard operator precedence. # Scenario: You have been asked by a colleague to help automate the calculation of simple mathematical expressions they receive in string format. They need a robust solution that ensures accurate and efficient computation. # Example: Input: `\\"3 + 2 * 2\\"` Output: `7.0` # Edge Cases to Consider: * The algorithm should handle an empty expression gracefully by returning 0. * It should accurately compute expressions that involve division by handling floating-point results. * Consider cases with multiple consecutive operations and spaces. # Additional Tests: Ensure your implementation returns the expected outputs for the following scenarios: 1. Input: `\\" 3+5 / 2 \\"` Output: `5.5` 2. Input: `\\"10 - 3 * 2 + 1\\"` Output: `5.0` 3. Input: `\\"0 / 1 + 2 * 3\\"` Output: `6.0` # Instructions: * Implement your solution in Python. * Ensure the code is well-organized and includes necessary comments for clarity. * Test your solution against multiple test cases to verify the correctness and handle various scenarios effectively.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a string containing a mathematical expression and returns its result as a float. def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == \'+\': operands.append(a + b) elif operator == \'-\': operands.append(a - b) elif operator == \'*\': operands.append(a * b) elif operator == \'/\': operands.append(a / b) if not expression.strip(): return 0 operands, operators = [], [] i, n = 0, len(expression) while i < n: ch = expression[i] if ch.isdigit() or ch == \'.\': num = [] while i < n and (expression[i].isdigit() or expression[i] == \'.\'): num.append(expression[i]) i += 1 operands.append(float(\\"\\".join(num))) continue elif ch in \\"+-*/\\": while operators and precedence(operators[-1]) >= precedence(ch): apply_operator(operands, operators.pop()) operators.append(ch) i += 1 while operators: apply_operator(operands, operators.pop()) return operands[0] def precedence(op): if op in \'+-\': return 1 elif op in \'*/\': return 2 return 0"},{"question":"# Median of a Stream of Numbers You are tasked with developing a real-time analytics system where one of the key requirements is to calculate the median of a continuously flowing stream of numbers. Your function should efficiently compute the median so the system can quickly update with each new number added to the stream. Task: Write a function `median_stream` to compute the median of numbers from a stream. ```python def median_stream(numbers_iter: Iterator[float]) -> Iterator[float]: # implement the function pass ``` Parameters: * **numbers_iter** (Iterator[float]): An iterator providing a sequence of numbers. Returns: * **Iterator[float]**: An iterator that yields the median for each added number in the input sequence. Details: * The median is the middle value in an ordered list of numbers. * If the list has an odd number of numbers, the median is the number in the middle. * If the list has an even number of numbers, the median is the average of the two middle numbers. Examples: ```python >>> list(median_stream(iter([2.0, 5, 3, 8, 6, 9, 10]))) [2.0, 3.5, 3.0, 4.0, 5.0, 5.5, 6.0] ``` Constraints: * The input sequence will have at least one number. * All numbers are represented as floating-point numbers. * The numbers may arrive in any order and can include duplicates. Notes: * Handle edge cases such as when the input stream has only one number. * Aim for an efficient solution to handle large streams, potentially using data structures that support efficient median updates. * Avoid unnecessary performance overhead or excessive memory usage in your implementation.","solution":"import heapq from typing import Iterator def median_stream(numbers_iter: Iterator[float]) -> Iterator[float]: min_heap = [] max_heap = [] medians = [] def add_number(num: float): if len(max_heap) == 0 or num <= -max_heap[0]: heapq.heappush(max_heap, -num) else: heapq.heappush(min_heap, num) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) def get_median() -> float: if len(max_heap) == len(min_heap): return (-max_heap[0] + min_heap[0]) / 2.0 else: return -max_heap[0] for number in numbers_iter: add_number(number) medians.append(get_median()) return iter(medians)"},{"question":"# Reverse the Digits of an Integer Context Reversing the digits of an integer is a common task in various programming challenges. This kind of problem tests your understanding of basic control structures and number manipulations. Task Write a function `reverse_integer(n: int) -> int` that reverses the digits of a given integer `n`. The function should handle both positive and negative integers. Input/Output Formats * **Input**: A single integer `n`, where `-10^9 <= n <= 10^9`. * Example: `123` * **Output**: A single integer which is the reversed version of `n`. * Example: `321` Constraints * Handle the sign of the integer accordingly. * If the reversed integer overflows, return 0. Performance Requirements * The function should execute in a constant space and linear time complexity relative to the number of digits in the integer, i.e., O(d) time and O(1) space, where d is the number of digits. Example Code ```python def reverse_integer(n: int) -> int: sign = -1 if n < 0 else 1 n = abs(n) reversed_n = 0 while n != 0: pop = n % 10 n //= 10 if reversed_n > (2**31 - 1) // 10: return 0 reversed_n = reversed_n * 10 + pop return sign * reversed_n # Test Cases print(reverse_integer(123)) # Output: 321 print(reverse_integer(-123)) # Output: -321 print(reverse_integer(120)) # Output: 21 print(reverse_integer(0)) # Output: 0 # Edge cases print(reverse_integer(1534236469)) # Output: 0 (because the reversed integer overflows) print(reverse_integer(-2147483648)) # Output: 0 (because the reversed integer overflows when negative) ``` Note * Ensure to handle edge cases such as zero and overflow conditions properly. * Inputs that may result in integer overflow when reversed should return `0`.","solution":"def reverse_integer(n: int) -> int: # Determine the sign of the given integer sign = -1 if n < 0 else 1 # Work with the absolute value to simplify reversal logic n = abs(n) reversed_n = 0 # Process each digit of the number while n != 0: pop = n % 10 n //= 10 # Check for overflow conditions if reversed_n > (2**31 - 1) // 10 or (reversed_n == (2**31 - 1) // 10 and pop > 7): return 0 reversed_n = reversed_n * 10 + pop return sign * reversed_n"},{"question":"# File System Simulation Challenge Scenario You are required to develop a simulation of a file system that supports basic directory and file operations. The file system should be able to handle creating directories, adding files, navigating through directories, and displaying the contents. This exercise will help you understand and implement tree structures and file system operations. Task Implement a class named `FileSystem` with the following requirements: Class: `FileSystem` 1. **Attributes**: * `root` (Node): The root directory of the file system. * `current_directory` (Node): Points to the current directory where operations are being performed. 2. **Methods**: * `__init__(self)`: Constructor to initialize the file system with a root directory. * `create_directory(self, name)`: Creates a new directory with the given name in the current directory. * `add_file(self, name, content)`: Creates a new file with the given name and content in the current directory. * `change_directory(self, name)`: Changes the current directory to the directory with the given name. * `list_contents(self)`: Lists the names of all directories and files in the current directory. * `read_file(self, name)`: Returns the content of the file with the given name in the current directory. * `get_current_path(self)`: Returns the current path from the root directory to the current directory. Constraints and Limitations * Ensure directory names and file names are unique within the same directory. * Handle cases where the specified directory or file does not exist. * Directories and files should be modeled as nodes in a tree structure. Input and Output Formats * Use the following methods for interaction with the file system: ```python class Node: def __init__(self, name, is_directory=False): self.name = name self.is_directory = is_directory self.content = \\"\\" if not is_directory else None self.children = {} class FileSystem: def __init__(self): # Initialize file system with root directory def create_directory(self, name): # Create a new directory with the given name in the current directory def add_file(self, name, content): # Create a new file with the given name and content in the current directory def change_directory(self, name): # Change the current directory to the named directory def list_contents(self): # List all directories and files in the current directory def read_file(self, name): # Return the content of the named file def get_current_path(self): # Return the path from the root directory to the current directory ``` Example ```python # Initialize the file system fs = FileSystem() # Create directories fs.create_directory(\'docs\') fs.create_directory(\'photos\') # Add files fs.add_file(\'readme.txt\', \'This is the readme file\') fs.add_file(\'todo.txt\', \'This is the todo file\') # Change the current directory fs.change_directory(\'docs\') # Add files in the \'docs\' directory fs.add_file(\'project.txt\', \'Project documentation\') # List contents in the current directory print(fs.list_contents()) # Output: [\'project.txt\'] # Read file content print(fs.read_file(\'project.txt\')) # Output: \'Project documentation\' # Get current path print(fs.get_current_path()) # Output: \'/docs\' # Navigate back to root fs.change_directory(\'..\') print(fs.get_current_path()) # Output: \'/\' ``` Ensure your implementation manages directories and files effectively and supports navigation and content retrieval within the file system.","solution":"class Node: def __init__(self, name, is_directory=False): self.name = name self.is_directory = is_directory self.content = \\"\\" if not is_directory else None self.children = {} self.parent = None # Reference to the parent node class FileSystem: def __init__(self): self.root = Node(\\"/\\", True) self.current_directory = self.root def create_directory(self, name): if name in self.current_directory.children: raise ValueError(f\\"Directory {name} already exists.\\") new_dir = Node(name, True) new_dir.parent = self.current_directory self.current_directory.children[name] = new_dir def add_file(self, name, content): if name in self.current_directory.children: raise ValueError(f\\"File {name} already exists.\\") new_file = Node(name, False) new_file.content = content self.current_directory.children[name] = new_file def change_directory(self, name): if name == \\"..\\": if self.current_directory.parent is not None: self.current_directory = self.current_directory.parent elif name in self.current_directory.children: if not self.current_directory.children[name].is_directory: raise NotADirectoryError(f\\"{name} is not a directory.\\") self.current_directory = self.current_directory.children[name] else: raise FileNotFoundError(f\\"No such directory: {name}\\") def list_contents(self): return list(self.current_directory.children.keys()) def read_file(self, name): if name in self.current_directory.children: if self.current_directory.children[name].is_directory: raise IsADirectoryError(f\\"{name} is a directory.\\") return self.current_directory.children[name].content else: raise FileNotFoundError(f\\"No such file: {name}\\") def get_current_path(self): current = self.current_directory path_elements = [] while current is not None: path_elements.append(current.name) current = current.parent return \\"/\\".join(reversed(path_elements)).replace(\\"//\\", \\"/\\")"},{"question":"# Scenario Many applications require the management of game scores or points, involving operations like updating, querying, and computing statistics over a range of scores. Consider a basic leaderboard system where scores are dynamically inserted and queried for statistics. # Task Write a Python class `Leaderboard` that manages a list of scores and supports the following operations: 1. `add_score(score: int) -> None`: Adds a new score to the leaderboard. 2. `remove_score(score: int) -> None`: Removes a score from the leaderboard. If the score does not exist, the operation does nothing. 3. `average_score() -> float`: Returns the average of all the scores in the leaderboard. If there are no scores, it should return `0.0`. 4. `top_n_scores(n: int) -> List[int]`: Returns the top `n` scores in descending order. If there are fewer than `n` scores, return all scores sorted in descending order. # Input Specifications * `score`: An integer representing the score, can be positive, zero, or negative. * `n`: A positive integer representing the number of top scores to retrieve. # Output Specifications * Each method should perform as described, catering to the given inputs. # Constraints * Score values are typical integer values used in gaming or similar applications. * The number of operations can be up to `10^5`. * The leaderboard will always handle typical performance constraints aligned with real-world usage. # Example ```python >>> leaderboard = Leaderboard() >>> leaderboard.add_score(50) >>> leaderboard.add_score(80) >>> leaderboard.add_score(70) >>> print(leaderboard.average_score()) 66.66666666666667 >>> print(leaderboard.top_n_scores(2)) [80, 70] >>> leaderboard.remove_score(70) >>> print(leaderboard.top_n_scores(2)) [80, 50] >>> print(leaderboard.average_score()) 65.0 ``` # Requirements * Ensure proper handling of performance for up to 100,000 operations. * Maintain the integrity of data with efficient data structures to support the described operations. * Methods should be flexible to handle an empty leaderboard when querying statistics.","solution":"from typing import List class Leaderboard: def __init__(self): self.scores = [] def add_score(self, score: int) -> None: self.scores.append(score) def remove_score(self, score: int) -> None: if score in self.scores: self.scores.remove(score) def average_score(self) -> float: if not self.scores: return 0.0 return sum(self.scores) / len(self.scores) def top_n_scores(self, n: int) -> List[int]: return sorted(self.scores, reverse=True)[:n]"},{"question":"# Coding Assessment Question Context: Sorting algorithms are fundamental for many computer science applications. One of the simplest sorting algorithms is the selection sort. In this algorithm, the list is divided into two parts: the sorted part at the start and the unsorted part at the end. Initially, the sorted part is empty and the unsorted part is the entire list. The algorithm repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted part and moves it to the end of the sorted part. Task: Implement a function `selection_sort` to sort an array of integers in ascending order using the selection sort algorithm. Specification: * **Function**: ```python def selection_sort(arr: List[int]) -> List[int]: ``` * **Input**: * `arr` - A list of integers to be sorted (List[int], length ≤ 1000). * **Output**: * Return the list of integers sorted in ascending order (List[int]). * **Constraints**: * Elements of `arr` should be integers. Examples: ```python >>> selection_sort([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort([5, 3, 6, 2, 10]) [2, 3, 5, 6, 10] >>> selection_sort([1]) [1] >>> selection_sort([]) [] >>> selection_sort([2, 1, 3, 3, 7]) [1, 2, 3, 3, 7] >>> selection_sort([-1, -5, -3, 0, 2]) [-5, -3, -1, 0, 2] ``` Note: The implementation should go through the input array and repeatedly find the minimum element from the unsorted part and move it to the sorted part until the entire array is sorted. Ensure that the function does not modify the input list and returns a new sorted list.","solution":"from typing import List def selection_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the selection sort algorithm. # Make a copy of the list to avoid modifying the input arr_copy = arr[:] n = len(arr_copy) # Traverse through all array elements for i in range(n): # Find the minimum element in remaining unsorted array min_index = i for j in range(i+1, n): if arr_copy[j] < arr_copy[min_index]: min_index = j # Swap the found minimum element with the first element arr_copy[i], arr_copy[min_index] = arr_copy[min_index], arr_copy[i] return arr_copy"},{"question":"# Scenario You are developing an e-commerce platform, and you need to implement a system to manage and apply discount codes. The system should be able to validate discount codes, apply them to a user\'s order, and calculate the final price. Given this context, you need to create a function to apply a discount code to an order, and write tests to ensure it behaves as expected. # Task 1. Implement a function `apply_discount` that takes a total amount and a discount code as arguments, and returns the new total after applying the discount. 2. Write unit tests for your function to cover various scenarios. # Requirements **Function Signature**: ```python def apply_discount(total: float, code: str) -> float: # Your implementation here ``` # Example ```python # Example of return value apply_discount(100.0, \\"SAVE20\\") # Expected output: 80.0 ``` # Constraints - Assume the following discount codes are valid: - \\"SAVE10\\": 10% off - \\"SAVE20\\": 20% off - \\"SAVE30\\": 30% off - If an invalid code is provided, the function should raise a `ValueError`. # Testing - Use the `pytest` library to write unit tests for the `apply_discount` function. - Ensure to test edge cases such as applying a discount that reduces the total to less than zero, and providing invalid discount codes. # Additional Information - Use `assert` statements in your tests to verify that the function returns the correct discounted total. - Handle floating-point precision issues appropriately to ensure accurate calculations.","solution":"def apply_discount(total: float, code: str) -> float: Applies a discount to the total amount based on the provided discount code. Args: total (float): The original total amount. code (str): The discount code to be applied. Returns: float: The new total after applying the discount. Raises: ValueError: If the discount code is invalid. discounts = { \\"SAVE10\\": 0.10, \\"SAVE20\\": 0.20, \\"SAVE30\\": 0.30, } if code not in discounts: raise ValueError(\\"Invalid discount code\\") discount = discounts[code] new_total = total * (1 - discount) return round(new_total, 2)"},{"question":"# Fibonacci Sequence Generator and Validator You are required to implement functions to generate the first `n` numbers in the Fibonacci sequence and to validate if a given number is part of the Fibonacci sequence. Your task is to write a Python function that generates the Fibonacci sequence and another function to validate a Fibonacci number. Function 1: generate_fibonacci Implement the `generate_fibonacci(n)` function which generates the first `n` numbers of the Fibonacci sequence. **Input**: - `n` (int): The number of Fibonacci numbers to generate. **Output**: - `fibonacci_sequence` (list): A list containing the first `n` numbers of the Fibonacci sequence. Function 2: validate_fibonacci Implement the `validate_fibonacci(number)` function which checks if the provided number is a Fibonacci number. **Input**: - `number` (int): The number to check if it is part of the Fibonacci sequence. **Output**: - `is_fibonacci` (bool): Returns `True` if the number is a Fibonacci number, `False` otherwise. Constraints: - The Fibonacci sequence is defined as: - `F(0) = 0`, `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for `n > 1` - Ensure that the generator can handle up to the first 10,000 Fibonacci numbers for large `n`. - For the validation, consider using a mathematical method to check for Fibonacci numbers. Example: ```python def generate_fibonacci(n: int) -> list[int]: # Your implementation here pass def validate_fibonacci(number: int) -> bool: # Your implementation here pass # Example usage fibonacci_sequence = generate_fibonacci(10) print(fibonacci_sequence) # Should print the first 10 Fibonacci numbers is_fibonacci = validate_fibonacci(34) print(is_fibonacci) # Should print True if 34 is a Fibonacci number ``` Ensure that your implementation correctly generates the Fibonacci sequence and validates Fibonacci numbers.","solution":"import math def generate_fibonacci(n): Generates the first n numbers in the Fibonacci sequence. :param n: Number of Fibonacci numbers to generate :return: List containing the first n numbers of the Fibonacci sequence if n <= 0: return [] elif n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): next_number = fibonacci_sequence[-1] + fibonacci_sequence[-2] fibonacci_sequence.append(next_number) return fibonacci_sequence def validate_fibonacci(number): Validates whether a given number is part of the Fibonacci sequence. :param number: Number to check :return: True if the number is a Fibonacci number, False otherwise # A number is a Fibonacci number if and only if one or both of (5 * n^2 + 4) or (5 * n^2 - 4) is a perfect square if number < 0: return False return is_perfect_square(5 * number * number + 4) or is_perfect_square(5 * number * number - 4) def is_perfect_square(x): Helper function to determine if x is a perfect square. :param x: Number to check :return: True if x is a perfect square, False otherwise s = int(math.isqrt(x)) return s * s == x"},{"question":"# Coding Assessment Question **Problem Statement:** You are tasked with developing a Python class that models a basic media player that can keep track of the playlist, shuffle the songs, and find the shortest song in the playlist. Requirements: 1. **Playlist Management**: Implement the `add_song` method to add a new song to the playlist. Each song is represented as a dictionary with the following structure: ```python {\\"title\\": str, \\"artist\\": str, \\"duration\\": float} ``` 2. **Shuffle Songs**: Implement the `shuffle` method that randomly shuffles the order of songs in the playlist using Python\'s built-in random library. 3. **Find Shortest Song**: Implement the `find_shortest_song` method that returns the song (as a dictionary) with the shortest duration from the playlist. If the playlist is empty, it should return `None`. Input: - Methods accepting song details (title, artist, duration) to add songs to the playlist. - A call to shuffle the playlist. - A call to find the shortest song. Output: - The shuffled playlist. - The shortest song in the playlist represented as a dictionary. Constraints: - Each song\'s duration is a positive float representing minutes. - The shuffle method should use randomness. - Assume that songs in the playlist have unique titles. Class & Method Signatures: ```python import random class MediaPlayer: def __init__(self): self.playlist = [] def add_song(self, title: str, artist: str, duration: float) -> None: song = {\\"title\\": title, \\"artist\\": artist, \\"duration\\": duration} self.playlist.append(song) def shuffle(self) -> None: random.shuffle(self.playlist) def find_shortest_song(self) -> dict | None: if not self.playlist: return None return min(self.playlist, key=lambda x: x[\'duration\']) # Example Usage: # player = MediaPlayer() # player.add_song(\\"Song A\\", \\"Artist A\\", 3.5) # player.add_song(\\"Song B\\", \\"Artist B\\", 4.0) # player.add_song(\\"Song C\\", \\"Artist C\\", 2.8) # player.shuffle() # print(player.playlist) # Playlist with shuffled songs # shortest_song = player.find_shortest_song() # print(shortest_song) # Expected shortest song ``` --- **Example:** ```python import random class MediaPlayer: def __init__(self): self.playlist = [] def add_song(self, title: str, artist: str, duration: float) -> None: song = {\\"title\\": title, \\"artist\\": artist, \\"duration\\": duration} self.playlist.append(song) def shuffle(self) -> None: random.shuffle(self.playlist) def find_shortest_song(self) -> dict | None: if not self.playlist: return None return min(self.playlist, key=lambda x: x[\'duration\']) # Test player = MediaPlayer() player.add_song(\\"Song A\\", \\"Artist A\\", 3.5) player.add_song(\\"Song B\\", \\"Artist B\\", 4.0) player.add_song(\\"Song C\\", \\"Artist C\\", 2.8) player.shuffle() print(player.playlist) # Playlist with shuffled songs shortest_song = player.find_shortest_song() print(shortest_song) # Expected shortest song \\"Song C\\" ```","solution":"import random class MediaPlayer: def __init__(self): self.playlist = [] def add_song(self, title: str, artist: str, duration: float) -> None: song = {\\"title\\": title, \\"artist\\": artist, \\"duration\\": duration} self.playlist.append(song) def shuffle(self) -> None: random.shuffle(self.playlist) def find_shortest_song(self) -> dict | None: if not self.playlist: return None return min(self.playlist, key=lambda x: x[\'duration\'])"},{"question":"# Scenario You are given a list of non-negative integers representing the amount of rainwater trapped between each pair of consecutive bars in a histogram. Each bar\'s width is 1. Your task is to determine the total amount of rainwater that would be trapped after a rainfall if each bar and the ground can contain water. # Task Write a function `trap_rainwater(height: List[int]) -> int` that takes a list of non-negative integers representing the height of bars in a histogram and returns the total amount of rainwater trapped. Function Signature ```python def trap_rainwater(height: List[int]) -> int: ``` # Input - `height`: A list of non-negative integers representing the heights of the bars. The list is guaranteed to be non-empty. # Output - An integer representing the total amount of trapped rainwater. # Constraints - The input list `height` has at least 1 and at most 1000 integers. - Each element in the list is an integer between 0 and 1000. # Example ```python height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] assert trap_rainwater(height) == 6 ``` In this example, 6 units of water are being trapped: ``` # # # # # # # 1 0 1 3 2 1 2 1 ``` # Example 2 ```python height = [4, 2, 0, 3, 2, 5] assert trap_rainwater(height) == 9 ``` In this example, 9 units of water are being trapped: ``` # # # #_ _ # # # # # # # # # # # # 4 2 0 3 2 5 ``` # Implementation Details - Implement the function using two-pointer technique or dynamic programming for an efficient solution. - Handle edge cases such as heights with no possibility of water being trapped. - Assume valid input within the provided constraints.","solution":"from typing import List def trap_rainwater(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[-1] = height[-1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"# Binary Tree Level Order Traversal Given a class to represent a binary tree, implement the method `level_order_traversal` that returns the level order traversal (breadth-first traversal) of the tree in the form of a list of lists. # Explanation: The `level_order_traversal` method should traverse the tree level by level from left to right and collect the nodes\' values at each level into separate sublists. # Function Signature: ```python class BinaryTree: ... def level_order_traversal(self) -> List[List[int]]: ... ``` # Expected Inputs and Outputs: * **Input**: * Tree: The initial binary tree. * **Output**: * A list of lists, where each sublist contains the values of the nodes at the respective level. # Example: ```python # Initial Binary Tree # 1 # / # 2 3 # / # 4 5 6 tree = BinaryTree() tree.insert(1) tree.insert(2) tree.insert(3) tree.insert(4) tree.insert(5) tree.insert(6) result = tree.level_order_traversal() # Expected output # [[1], [2, 3], [4, 5, 6]] assert result == [[1], [2, 3], [4, 5, 6]] ``` # Constraints: 1. The tree will contain between 0 and 10000 nodes. 2. Each node’s value will be a valid integer. # Testing: Your solution will be tested with the following scenarios: 1. Performing level order traversal on an empty tree. 2. Performing level order traversal on a tree with a single node. 3. Performing level order traversal on a tree with multiple levels. # Notes: Ensure to handle edge cases where the tree is empty or has only one node. Properly traverse all levels of the tree and collect the nodes\' values in the correct order.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, value: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert(self, value: int): if not self.root: self.root = TreeNode(value) else: queue = deque([self.root]) while queue: node = queue.popleft() if not node.left: node.left = TreeNode(value) return else: queue.append(node.left) if not node.right: node.right = TreeNode(value) return else: queue.append(node.right) def level_order_traversal(self) -> List[List[int]]: result = [] if not self.root: return result queue = deque([self.root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Coding Assessment Question: String Templating System As a software engineer, you\'re being asked to create a Python function that implements a simple string templating system. In this system, placeholders within a string should be replaced with corresponding values provided in a dictionary. Placeholders are marked by double curly braces `{{ }}`, and each placeholder corresponds to a key in the dictionary. Function: `template_replace(template: str, variables: dict) -> str` - **Input**: - A string `template` that may contain placeholders in the format `{{key}}`. - A dictionary `variables` where keys are placeholder names and values are the replacements. - **Output**: - A string with all placeholders replaced by their corresponding values from the dictionary. - **Constraints**: - The placeholders in the template string will only contain lowercase alphabetic characters `a-z`. - The keys in the dictionary match exactly with the placeholders in the template (case-sensitive). - If a placeholder in the template does not have a corresponding entry in the dictionary, it should remain unchanged in the output string. - There will be no nested placeholders and no empty placeholders. # Example: ```python >>> template_replace(\\"Hello, {{name}}!\\", {\\"name\\": \\"Alice\\"}) \'Hello, Alice!\' >>> template_replace(\\"{{greeting}}, {{name}}! Welcome to {{place}}.\\", {\\"greeting\\": \\"Hi\\", \\"name\\": \\"Bob\\", \\"place\\": \\"Wonderland\\"}) \'Hi, Bob! Welcome to Wonderland.\' >>> template_replace(\\"This is a {{adjective}} day.\\", {\\"adjective\\": \\"beautiful\\"}) \'This is a beautiful day.\' >>> template_replace(\\"This is a {{day}} day.\\", {\\"day\\": \\"great\\"}) \'This is a great day.\' ``` # Requirements: 1. Implement the function `template_replace(template: str, variables: dict) -> str`. 2. Ensure that the function performs efficiently, keeping the complexity as low as possible. 3. Handle edge cases, such as an empty template string or an empty dictionary. 4. Do not use any third-party libraries for template processing; implement the logic manually. Guidelines: * Document your code with helpful comments and explanations. * Include a main block that demonstrates the functionality of your function with valid test cases. * Make sure your function works for any reasonable length of the input string and dictionary size.","solution":"def template_replace(template: str, variables: dict) -> str: Replaces placeholders in the template string with corresponding values from the variables dictionary. :param template: A string with placeholders in the format {{key}}. :param variables: A dictionary where keys are placeholder names and values are the replacements. :return: A string with all placeholders replaced by their corresponding values from the dictionary. import re # Define a pattern to match the placeholders like {{key}} pattern = re.compile(r\'{{(.*?)}}\') # Function to replace a match with the corresponding value from variables dictionary def replace_placeholder(match): key = match.group(1) return variables.get(key, match.group(0)) # Use re.sub to replace all placeholders in the template result = pattern.sub(replace_placeholder, template) return result"},{"question":"# Problem Statement Given a list of integers `nums`, write a Python function `find_missing_number(nums: List[int], n: int) -> int` that finds the missing number in a list that contains the numbers from (0) to (n) with exactly one number missing. # Input * A list `nums` of integers of length ( n ) where each element is unique and lies between ( 0 ) and ( n ). * An integer ( n ) where ( 1 leq n leq 10^6 ). # Output * Return a single integer, the missing number from the list. # Constraints * Your solution should be efficient, ideally running in ( O(n) ) time. # Examples ```python def find_missing_number(nums: List[int], n: int) -> int: # Your implementation here # Example 1 print(find_missing_number([3, 0, 1], 3)) # Output: 2 # Example 2 print(find_missing_number([0, 1], 2)) # Output: 2 # Example 3 print(find_missing_number([9,6,4,2,3,5,7,0,1], 9)) # Output: 8 # Example 4 print(find_missing_number([0], 1)) # Output: 1 ``` # Explanation - In the first example, the list contains numbers from 0 to 3, with 2 missing. - In the second example, the list contains numbers 0 and 1 but is missing 2. - In the third example, the list representation of 0 to 9 is missing the number 8. - In the fourth example, the list contains only 0, so 1 is missing. # Notes * Consider the arithmetic series sum formula or utilize XOR operation to optimize your solution. * Ensure it works efficiently for large values of ( n ).","solution":"from typing import List def find_missing_number(nums: List[int], n: int) -> int: Finds the missing number in a list that contains the numbers from 0 to n with exactly one number missing. # Calculate the expected sum of numbers from 0 to n (inclusive). expected_sum = n * (n + 1) // 2 # Calculate the actual sum of numbers in the list. actual_sum = sum(nums) # The missing number is the difference between the expected sum and the actual sum. return expected_sum - actual_sum"},{"question":"# Problem Statement: Enhanced Caesar Cipher with Multi-Step Shift You are required to implement an advanced version of the classical Caesar cipher. This advanced version, the `AdvancedCaesarCipher` class, should support a multi-step shift derived from a numeric passcode. # Requirements: 1. **Character Set Validation**: The system should only accept valid alphanumeric characters for encryption and decryption. 2. **Numeric Passcode**: The passcode is a string of digits that determines the multi-step shift sequence. - Example: Passcode \\"123\\" performs shifts of 1, 2, 3, then repeats. 3. **Error Handling**: Appropriately handle scenarios where: * The passcode contains non-numeric characters. * Unsupported characters appear in the plaintext or encoded message. 4. **Shift Wrap-Around**: Ensure the shift wraps around within the character set (e.g., \'z\' shifts to \'a\' with a shift of 1). 5. **Edge Cases**: Consider edge cases such as very short plaintexts, very long plaintexts, very short or very long passcodes, and extremely high or low shift values. # Function Implementations: * `__init__`: Initialize the cipher with a passcode. * `__validate_passcode`: Ensure the passcode is purely numeric and non-empty. * `__generate_shift_sequence`: Create the shift sequence based on the passcode. * `decrypt`: Decrypt an encoded message. * `encrypt`: Encrypt a plaintext message. * `test_end_to_end`: A function to test the encryption and decryption processes. # Input Format: * The cipher is initialized with a numeric passcode provided as a string. * For encryption, the input is a plaintext string containing only alphanumeric characters. * For decryption, the input is an encoded string containing only alphanumeric characters. # Output Format: * For encryption, return the encoded message as a string. * For decryption, return the plaintext message as a string. # Performance Constraints: * The solution should handle messages up to 10,000 characters efficiently. * The passcode validation should ensure that it contains only numeric characters and is between 1 to 10 characters in length. # Example: ```python # Creating a new cipher instance cipher = AdvancedCaesarCipher(\\"314\\") # Encrypting a plaintext message encrypted_message = cipher.encrypt(\\"HelloWorld1\\") print(encrypted_message) # Output: <Encrypted message based on passcode> # Decrypting the encrypted message decrypted_message = cipher.decrypt(encrypted_message) print(decrypted_message) # Output: HelloWorld1 ``` # Hint: You may use Python\'s `ord` and `chr` functions to help with shifts across the alphanumeric character set. Make sure to handle both uppercase and lowercase letters appropriately.","solution":"class AdvancedCaesarCipher: def __init__(self, passcode): if not isinstance(passcode, str) or not passcode.isdigit() or len(passcode) == 0: raise ValueError(\\"Passcode must be a non-empty string of digits.\\") self.passcode = passcode self.shift_sequence = self.__generate_shift_sequence() def __generate_shift_sequence(self): return [int(digit) for digit in self.passcode] def __shift_char(self, char, shift): if \'0\' <= char <= \'9\': start = ord(\'0\') range_size = 10 elif \'a\' <= char <= \'z\': start = ord(\'a\') range_size = 26 elif \'A\' <= char <= \'Z\': start = ord(\'A\') range_size = 26 else: raise ValueError(\\"Invalid character for encryption/decryption\\") return chr(start + (ord(char) - start + shift) % range_size) def encrypt(self, plaintext): if not plaintext.isalnum(): raise ValueError(\\"Plaintext must contain only alphanumeric characters.\\") ciphertext = [] for i, char in enumerate(plaintext): shift = self.shift_sequence[i % len(self.shift_sequence)] ciphertext.append(self.__shift_char(char, shift)) return \'\'.join(ciphertext) def decrypt(self, ciphertext): if not ciphertext.isalnum(): raise ValueError(\\"Ciphertext must contain only alphanumeric characters.\\") plaintext = [] for i, char in enumerate(ciphertext): shift = self.shift_sequence[i % len(self.shift_sequence)] plaintext.append(self.__shift_char(char, -shift)) return \'\'.join(plaintext)"},{"question":"# Challenge: You are given a binary tree represented as a list in level order traversal. Your task is to write a function that converts this list representation into a proper binary tree structure, and then perform an inorder traversal of the binary tree. **Function Signature**: ```python def list_to_inorder_tree(arr: list) -> list: pass ``` # Requirements: - **Input**: A list of integers representing the binary tree in level order traversal. - The values in the list can include `None` to signify the absence of a node. - **Output**: A list of integers obtained from an inorder traversal of the binary tree. # Constraints: - The input list can have up to 10^3 elements. - A `None` value indicates an absent node in the binary tree. - Each node in the binary tree that is not `None` will have a unique non-negative integer value. # Example: **Input**: ```python [1, 2, 3, None, 4, 5] ``` **Output**: ```python [2, 4, 1, 5, 3] ``` # Additional Examples: **Example 2**: **Input**: ```python [3, 9, 20, None, None, 15, 7] ``` **Output**: ```python [9, 3, 15, 20, 7] ``` # Notes: 1. In level order traversal, the tree is read left to right, level by level. 2. An inorder traversal visits nodes in the order: left subtree, root, right subtree. 3. Make sure to handle edge cases such as an empty input list properly. Provide an implementation for the `list_to_inorder_tree` function that constructs a binary tree from the given list and returns the inorder traversal of this tree. Your implementation should account for all reasonable edge cases.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def list_to_tree(arr): if not arr: return None root = TreeNode(arr[0]) queue = [root] i = 1 while queue and i < len(arr): node = queue.pop(0) if arr[i] is not None: node.left = TreeNode(arr[i]) queue.append(node.left) i += 1 if i < len(arr) and arr[i] is not None: node.right = TreeNode(arr[i]) queue.append(node.right) i += 1 return root def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) def list_to_inorder_tree(arr): root = list_to_tree(arr) return inorder_traversal(root)"},{"question":"# Question: Graph Node Distance Calculation Function You need to implement a function that calculates the shortest distances from a given starting node to all other nodes in an unweighted graph using Breadth-First Search (BFS). Function Specifications: * **Function Name**: `shortest_path_unweighted` * **Input**: - `edges: List[Tuple[int, int]]` - A list of tuples where each tuple represents an edge between two nodes. - `num_nodes: int` - Total number of nodes in the graph (labelled 0 to num_nodes-1). - `start_node: int` - The starting node to calculate shortest distances from. * **Output**: A list of integers where the ith integer represents the shortest distance from the starting node to node i. If a node is not reachable, the distance should be -1. Constraints: - The graph is unweighted and undirected. - If the start_node is not valid (e.g., not within the bounds of the number of nodes), raise a ValueError with an informative error message. Example: ```python import collections def shortest_path_unweighted(edges, num_nodes, start_node): Calculate the shortest paths in an unweighted graph from a start node using BFS. Args: edges (List[Tuple[int, int]]): The edges of the graph. num_nodes (int): The total number of nodes in the graph. start_node (int): The node to start the search from. Returns: List[int]: The shortest distances from the start_node to all other nodes. if start_node < 0 or start_node >= num_nodes: raise ValueError(\\"Start node must be within the range of the number of nodes.\\") # Initialize distances with -1 (unreachable) distances = [-1] * num_nodes distances[start_node] = 0 queue = collections.deque([start_node]) # Create adjacency list representation of the graph graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) while queue: current = queue.popleft() for neighbor in graph[current]: if distances[neighbor] == -1: # not visited distances[neighbor] = distances[current] + 1 queue.append(neighbor) return distances # Example usage: # edges = [(0, 1), (0, 2), (1, 3), (2, 4)] # num_nodes = 5 # start_node = 0 # print(shortest_path_unweighted(edges, num_nodes, start_node)) # Output: [0, 1, 1, 2, 2] ``` In this problem, the function `shortest_path_unweighted` calculates the shortest distance from the start node to all other nodes in an unweighted graph. The function utilizes BFS to ensure the shortest path calculations and returns a list of distances with -1 indicating unreachable nodes.","solution":"import collections from typing import List, Tuple def shortest_path_unweighted(edges: List[Tuple[int, int]], num_nodes: int, start_node: int) -> List[int]: Calculate the shortest paths in an unweighted graph from a start node using BFS. Args: edges (List[Tuple[int, int]]): The edges of the graph. num_nodes (int): The total number of nodes in the graph. start_node (int): The node to start the search from. Returns: List[int]: The shortest distances from the start_node to all other nodes. if start_node < 0 or start_node >= num_nodes: raise ValueError(\\"Start node must be within the range of the number of nodes.\\") # Initialize distances with -1 (unreachable) distances = [-1] * num_nodes distances[start_node] = 0 queue = collections.deque([start_node]) # Create adjacency list representation of the graph graph = collections.defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) while queue: current = queue.popleft() for neighbor in graph[current]: if distances[neighbor] == -1: # not visited distances[neighbor] = distances[current] + 1 queue.append(neighbor) return distances # Example usage: # edges = [(0, 1), (0, 2), (1, 3), (2, 4)] # num_nodes = 5 # start_node = 0 # print(shortest_path_unweighted(edges, num_nodes, start_node)) # Output: [0, 1, 1, 2, 2]"},{"question":"# Coding Assessment: Validate License Plate Format Context You are hired as a software engineer at a firm that deals with processing and validating vehicle registrations. One of your main tasks is to ensure that license plate numbers are in the correct format before they are stored in the database. The accepted format for a license plate is two capital letters followed by four digits (e.g., \\"AB1234\\"). Task Write a function `validate_license_plate` that takes a list of strings representing license plate numbers and returns a new list of boolean values. Each boolean value should indicate whether the respective license plate number in the input list is valid based on the described format. Input - `plates`: A list of strings where each string represents a license plate number. The list is guaranteed to have at least one element. Output - A list of boolean values where each value is `True` if the corresponding license plate number is valid, and `False` otherwise. Constraints - The function should handle mixed-case inputs by validating them based on their uppercase equivalents. - Performance considerations should be given for larger lists up to 5,000 elements. Example ```python def validate_license_plate(plates: list[str]) -> list[bool]: # Your implementation here pass # Example Usage print(validate_license_plate([\\"AB1234\\", \\"XY5678\\", \\"12AB34\\", \\"A12345\\", \\"XYZ123\\"])) # Expected Output: [True, True, False, False, False] print(validate_license_plate([\\"ab1234\\", \\"xy5678\\", \\"ZZ9999\\", \\"AA0000\\"])) # Expected Output: [True, True, True, True] print(validate_license_plate([\\"AB12\\", \\"1234AB\\", \\"A1B2C3\\", \\"\\"])) # Expected Output: [False, False, False, False] ``` In your solution: 1. Convert each license plate to uppercase. 2. Check if a string has exactly 6 characters. 3. Ensure that the first two characters are capital letters. 4. Confirm that the last four characters are digits.","solution":"import re def validate_license_plate(plates): Returns a list of boolean values indicating if the corresponding license plate number is valid. A valid license plate has the format of two capital letters followed by four digits (e.g., \\"AB1234\\"). valid_format = [] pattern = re.compile(r\'^[A-Z]{2}d{4}\') # regular expression for the correct license plate format for plate in plates: if pattern.match(plate.upper()): valid_format.append(True) else: valid_format.append(False) return valid_format"},{"question":"# Coding Assessment Question Objective Implement a function that checks whether a given string of parentheses is balanced or not. The string can contain different types of parentheses: round `()`, square `[]`, and curly `{}`. **Function Signature**: ```python def is_balanced(s: str) -> bool: Returns whether the given string of parentheses is balanced. Parameters: s (str): A string containing only the characters \'(\', \')\', \'[\', \']\', \'{\', \'}\'. Returns: bool: True if the string is balanced, False otherwise. ``` Input format * A string `s` (1 ≤ len(s) ≤ 1000) consisting exclusively of the characters \'(\', \')\', \'[\', \']\', \'{\', \'}\'. Output format * Return a single boolean value, `True` if the string is balanced, `False` otherwise. Constraints * The input string will only contain the characters \'(\', \')\', \'[\', \']\', \'{\', \'}\'. * Handle the string efficiently, even for the upper input size limit. Example ```python >>> is_balanced(\\"()[]{}\\") True >>> is_balanced(\\"([{}])\\") True >>> is_balanced(\\"(]\\") False >>> is_balanced(\\"([{])}\\") False ``` Additional Information * You might use a stack to keep track of matching parentheses. * Consider edge cases where the string might be unbalanced due to missing pairs or misnesting.","solution":"def is_balanced(s: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} open_brackets = set(bracket_map.values()) for char in s: if char in open_brackets: stack.append(char) elif char in bracket_map: if not stack or stack[-1] != bracket_map[char]: return False stack.pop() return len(stack) == 0"},{"question":"Question # Problem Statement: You are given a string representing a binary number. Your task is to write a function `binary_addition(a: str, b: str) -> str` that adds the two binary numbers and returns the result as a binary string prefixed with \\"0b\\". # Function Signature: ```python def binary_addition(a: str, b: str) -> str: pass ``` # Input: - Two string inputs `a` and `b` representing non-negative binary numbers (e.g., \\"101\\", \\"1000\\"). The maximum length of each string is 100 characters. # Output: - A binary string prefixed with \\"0b\\" representing the sum of the two binary numbers. # Constraints: - The strings represent non-negative binary numbers. - The length of each binary string is no more than 100 characters. - The function should handle edge cases such as adding \\"0\\" to another binary number or adding two large binary numbers effectively. # Examples: ```python assert binary_addition(\\"101\\", \\"1100\\") == \'0b10001\' assert binary_addition(\\"111\\", \\"1\\") == \'0b1000\' assert binary_addition(\\"0\\", \\"0\\") == \'0b0\' assert binary_addition(\\"1010\\", \\"1011\\") == \'0b10101\' assert binary_addition(\\"1001\\", \\"1\\") == \'0b1010\' ``` # Additional Instructions: - Ensure the function properly validates that inputs are binary strings. - Consider handling leading zeros in the output properly to ensure the result is always in the minimal binary format prefixed with \\"0b\\".","solution":"def binary_addition(a: str, b: str) -> str: Adds two binary numbers represented as strings and returns the result as a binary string prefixed with \'0b\'. # Convert binary strings to integers int_a = int(a, 2) int_b = int(b, 2) # Add the integers sum_int = int_a + int_b # Convert the result back to a binary string and prefix with \'0b\' return bin(sum_int)"},{"question":"# Scenario You are working on a project to develop a basic spell-checker utility. The goal is to correct misspelled words in a text by suggesting a list of possible valid words from a given dictionary that have the closest distance to the misspelled word. To implement this, you decide to use the Damerau-Levenshtein distance algorithm, which calculates the minimum number of operations needed to transform one string into another, where operations include insertions, deletions, substitutions, and transpositions of two adjacent characters. # Task Implement a SpellChecker class that uses the Damerau-Levenshtein distance algorithm to find the closest words in a dictionary. # Detailed Requirements 1. **Class**: `SpellChecker` 2. **Method**: `damerau_levenshtein(self, word1: str, word2: str) -> int` - Input: Two strings `word1` and `word2` representing the words to be compared. - Output: Returns an integer representing the Damerau-Levenshtein distance between the two words. 3. **Method**: `get_closest_words(self, word: str, dictionary: List[str], max_distance: int) -> List[str]` - Input: A string `word` representing the misspelled word, a list of strings `dictionary` representing the valid words, and an integer `max_distance` representing the maximum acceptable distance for a word to be considered as a close match. - Output: Returns a list of strings representing the closest words from the dictionary that are within the specified maximum distance. # Constraints 1. The length of the words (m, n) will be `1 <= m, n <= 100`. 2. The dictionary size will be up to `10^3` words. 3. The maximum distance (`max_distance`) will be an integer between 1 and 10. # Example Usage ```python # Initialize the spell checker spell_checker = SpellChecker() # Example dictionary dictionary = [\\"hello\\", \\"world\\", \\"hell\\", \\"word\\", \\"hero\\"] # Calculate the Damerau-Levenshtein distance between \'word\' and \'world\' assert spell_checker.damerau_levenshtein(\\"word\\", \\"world\\") == 1 # Find the closest words to \'word\' within a maximum distance of 1 assert spell_checker.get_closest_words(\\"word\\", dictionary, 1) == [\\"world\\", \\"word\\"] # Find the closest words to \'hell\' within a maximum distance of 2 assert spell_checker.get_closest_words(\\"hell\\", dictionary, 2) == [\\"hello\\", \\"hell\\", \\"hero\\"] # Edge case with an empty dictionary – should return an empty list assert spell_checker.get_closest_words(\\"hell\\", [], 2) == [] # Edge case with the maximum distance larger than the actual maximum needed distance assert spell_checker.get_closest_words(\\"hello\\", dictionary, 10) == [\\"hello\\", \\"hell\\", \\"hero\\"] ``` Provide the SpellChecker class implementation adhering to the above requirements. Also, include sufficient unittests to validate the correctness of your implementation.","solution":"from typing import List class SpellChecker: def damerau_levenshtein(self, word1: str, word2: str) -> int: Computes the Damerau-Levenshtein distance between two words. len1, len2 = len(word1), len(word2) if len1 == 0: return len2 if len2 == 0: return len1 # Create a matrix to compute distances distance = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): distance[i][0] = i for j in range(1, len2 + 1): distance[0][j] = j # Compute the distances for i in range(1, len1 + 1): for j in range(1, len2 + 1): cost = 0 if word1[i - 1] == word2[j - 1] else 1 distance[i][j] = min( distance[i - 1][j] + 1, # deletion distance[i][j - 1] + 1, # insertion distance[i - 1][j - 1] + cost # substitution ) if i > 1 and j > 1 and word1[i - 1] == word2[j - 2] and word1[i - 2] == word2[j - 1]: distance[i][j] = min( distance[i][j], distance[i - 2][j - 2] + cost # transposition ) return distance[-1][-1] def get_closest_words(self, word: str, dictionary: List[str], max_distance: int) -> List[str]: Get a list of closest words from the dictionary within the specified maximum distance. closest_words = [] for dict_word in dictionary: if self.damerau_levenshtein(word, dict_word) <= max_distance: closest_words.append(dict_word) return closest_words"},{"question":"# Coding Assessment Question # Scenario Sorting algorithms are fundamental in computer science, used to organize data for efficient retrieval and processing. One common variant is sorting a list of dictionaries based on specific key values. # Task Implement a sorting function in Python that sorts a list of dictionaries by a given key. The function should handle both numerical and string keys gracefully, supporting nested dictionaries. # Requirements 1. Implement a function `sort_dicts` that: - Takes a list of dictionaries and a key as input. - Sorts the dictionaries based on the specified key in ascending order. - Supports sorting by keys that contain nested dictionaries. 2. Ensure your implementation handles the following: - Properly sorts dictionaries with integer and string values. - Correctly accesses and sorts by nested dictionary keys using dot notation (e.g., `\\"address.city\\"`). - Returns the sorted list of dictionaries. 3. Demonstrate your implementation with the following cases: - Sort by a primary key (e.g., `\\"name\\"`). - Sort by a nested key (e.g., `\\"address.city\\"`). Function Signature ```python def sort_dicts(dict_list: List[Dict], key: str) -> List[Dict]: # Implement the sorting logic here # Example usage people = [ {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"address\\": {\\"city\\": \\"New York\\", \\"zip\\": \\"10001\\"}}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"address\\": {\\"city\\": \\"San Francisco\\", \\"zip\\": \\"94105\\"}}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"address\\": {\\"city\\": \\"Boston\\", \\"zip\\": \\"02110\\"}}, ] sorted_by_name = sort_dicts(people, \\"name\\") print(sorted_by_name) # Expected output: sorted list of dictionaries by name sorted_by_city = sort_dicts(people, \\"address.city\\") print(sorted_by_city) # Expected output: sorted list of dictionaries by city in address property ``` Input Format - A list of dictionaries. - A string representing the key to sort by, which may include dot notation for nested keys. Output Format - A list of dictionaries sorted by the specified key. Constraints - The list does not contain more than 10,000 dictionaries. - The key provided exists in all dictionaries. - Nested keys will be accessed using dot notation, and every level of the nested keys up to the specified key exists in all dictionaries. Performance Requirements - The implementation should sort the list in `O(n log n)` time complexity.","solution":"from typing import List, Dict, Any def get_nested_value(d: Dict[str, Any], key: str) -> Any: keys = key.split(\'.\') for k in keys: d = d.get(k, None) return d def sort_dicts(dict_list: List[Dict[str, Any]], key: str) -> List[Dict[str, Any]]: return sorted(dict_list, key=lambda d: get_nested_value(d, key)) # Example usage: people = [ {\\"name\\": \\"Alice\\", \\"age\\": 25, \\"address\\": {\\"city\\": \\"New York\\", \\"zip\\": \\"10001\\"}}, {\\"name\\": \\"Bob\\", \\"age\\": 22, \\"address\\": {\\"city\\": \\"San Francisco\\", \\"zip\\": \\"94105\\"}}, {\\"name\\": \\"Charlie\\", \\"age\\": 30, \\"address\\": {\\"city\\": \\"Boston\\", \\"zip\\": \\"02110\\"}}, ] sorted_by_name = sort_dicts(people, \\"name\\") print(sorted_by_name) # Expected output: sorted list of dictionaries by name sorted_by_city = sort_dicts(people, \\"address.city\\") print(sorted_by_city) # Expected output: sorted list of dictionaries by city in address property"},{"question":"# Question: Implementing a Basic Circular Queue **Objective**: Design and implement a simple circular queue that holds integers. Implement a Python class and methods: ```python class CircularQueue: def __init__(self, capacity: int): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass def front(self) -> int: pass def is_empty(self) -> bool: pass def is_full(self) -> bool: pass ``` # Input/Output: * `__init__(capacity: int)`: Initializes the circular queue with a given capacity. * `enqueue(value: int) -> None`: Inserts an integer into the queue. If the queue is full, print \\"Queue is full\\". * `dequeue() -> int`: Removes and returns the front integer from the queue. If the queue is empty, print \\"Queue is empty\\" and return `-1`. * `front() -> int`: Returns the front integer from the queue without removing it. If the queue is empty, return `-1`. * `is_empty() -> bool`: Returns `True` if the queue is empty, otherwise `False`. * `is_full() -> bool`: Returns `True` if the queue is full, otherwise `False`. # Constraints: * The `capacity` will be between 1 and 1000. * The values will be integer numbers fit within the standard Python `int` type range. # Example: ```python # Example Call cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.enqueue(4) # Output: \\"Queue is full\\" print(cq.front()) # Expected output: 1 print(cq.dequeue()) # Expected output: 1 print(cq.dequeue()) # Expected output: 2 print(cq.is_empty()) # Expected output: False print(cq.is_full()) # Expected output: False cq.enqueue(4) print(cq.front()) # Expected output: 3 cq.enqueue(5) # Output: \\"Queue is full\\" print(cq.dequeue()) # Expected output: 3 print(cq.dequeue()) # Expected output: 4 print(cq.dequeue()) # Expected output: -1 (Output: \\"Queue is empty\\") ``` **Note**: Ensure proper handling for edge cases like enqueuing or dequeuing from an empty or full queue.","solution":"class CircularQueue: def __init__(self, capacity: int): self.capacity = capacity self.queue = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, value: int) -> None: if self.is_full(): print(\\"Queue is full\\") return self.queue[self.tail] = value self.tail = (self.tail + 1) % self.capacity self.size += 1 def dequeue(self) -> int: if self.is_empty(): print(\\"Queue is empty\\") return -1 value = self.queue[self.head] self.queue[self.head] = None # Clear the spot self.head = (self.head + 1) % self.capacity self.size -= 1 return value def front(self) -> int: if self.is_empty(): return -1 return self.queue[self.head] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Coding Assessment Question **Context**: A frequent task in text processing is to determine the most common word that appears in a text, excluding specific banned words. Your task is to create a function that, given a string of text and a list of banned words, returns the most frequent word that is not banned. **Objective**: Implement the function `most_common_word(text: str, banned: list[str]) -> str` that finds and returns the most frequent word in the `text` that is not present in the list of `banned` words. **Function Signature**: ```python def most_common_word(text: str, banned: list[str]) -> str: pass ``` **Input and Output Formats**: 1. `most_common_word(text, banned)`: - **Input**: - `text` (str): A string containing the text to be analyzed. - `banned` (list[str]): A list of strings representing the banned words. - **Output**: - Returns a string: the most common word in the `text` that is not banned. **Constraints**: - The `text` consists of words separated by spaces, and may contain punctuation marks such as `!`, `?\', \';\', \'.\', \',\'. - The words in the `text` are case-insensitive (e.g., \\"Word\\" and \\"word\\" are considered the same). - Banned words are provided in lowercase and are also case-insensitive. - If multiple words have the same maximum frequency, return any of them. **Performance**: - Your solution should handle large inputs efficiently. **Example**: ```python >>> most_common_word(\\"Bob hit a ball, the hit BALL flew far after it was hit.\\", [\\"hit\\"]) \\"ball\\" >>> most_common_word(\\"a.\\", []) \\"a\\" ``` **Description**: 1. Implement the function `most_common_word` that identifies the word that occurs most frequently in the given `text`, excluding any words that are present in the `banned` list. 2. The function should correctly handle case insensitivity and punctuation. **Notes**: - You may utilize the `re` module for regular expressions to handle punctuation. - Consider edge cases such as empty text or lists. **Hints**: - Convert text to lowercase and remove punctuation for uniform comparison. - Use a dictionary or Counter from the collections module to track word frequencies.","solution":"import re from collections import Counter def most_common_word(text: str, banned: list[str]) -> str: # Convert text to lowercase and replace punctuation with spaces text = re.sub(r\'[^ws]\', \' \', text).lower() # Split text into words words = text.split() # Filter out banned words words = [word for word in words if word not in banned] # Count the frequency of each word word_counts = Counter(words) # Find the most common word most_common = word_counts.most_common(1) return most_common[0][0] if most_common else \\"\\""},{"question":"# Question: Implementing Breadth-first Search for Shortest Path in a Grid Breadth-first search (BFS) is a fundamental algorithm in graph theory that explores all nodes at the present depth level before moving on to nodes at the next depth level. The BFS approach is particularly effective for finding the shortest path in an unweighted grid. Given a 2D grid of integers, where `0` represents an open cell and `1` represents an obstacle, implement the function `shortest_path_bfs(grid, start, goal)` that determines the shortest path from the start position to the goal position using BFS. **Input**: - `grid` (2D list of int): A grid representation where `0` is a walkable cell and `1` is an obstacle. - `start` (tuple of int): The starting position (row, col) in the grid. - `goal` (tuple of int): The goal position (row, col) in the grid. **Output**: - `path_length` (int): The length of the shortest path from start to goal. Return `-1` if no path exists. **Constraints**: - The grid is at most 100x100 in size. - Both `start` and `goal` are guaranteed to be valid grid positions. - The `start` and `goal` positions will always contain `0` (i.e., there will never be an obstacle at the start or goal position). **Performance Requirements**: - The BFS should execute efficiently within the given constraints. - Memory usage should be carefully managed, keeping within acceptable limits for a 100x100 grid. **Implementation Details**: - Implement an efficient queue-based BFS that explores grid cells level by level. - Ensure proper handling of cell boundaries and avoid revisiting nodes to improve performance. Example: ```python from collections import deque def shortest_path_bfs(grid, start, goal): # Implement the breadth-first search to find the shortest path from start to goal here pass # Example Usage: if __name__ == \\"__main__\\": grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) goal = (4, 4) path_length = shortest_path_bfs(grid, start, goal) print(f\\"The shortest path length is: {path_length}\\") ``` **Hints**: - Use a deque to implement the BFS efficiently with O(1) time complexity for adding and popping elements. - Track visited nodes to avoid revisiting and ensure the shortest path is found without redundant checks. - Consider using a dictionary to map nodes to their distances from the start for easy path length calculation.","solution":"from collections import deque def shortest_path_bfs(grid, start, goal): Finds the shortest path in a grid from start to goal using BFS. Parameters: grid (list of list of int): The grid where 0 is walkable and 1 is an obstacle. start (tuple of int): The starting position (row, col). goal (tuple of int): The goal position (row, col). Returns: int: The length of the shortest path from start to goal, or -1 if no path exists. # Determine the dimensions of the grid rows, cols = len(grid), len(grid[0]) # Directions for moving in the grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(r, c): # Check if the cell (r, c) is within grid bounds and walkable return 0 <= r < rows and 0 <= c < cols and grid[r][c] == 0 # Initialize the BFS queue and visited set queue = deque([(start[0], start[1], 0)]) # (row, col, distance from start) visited = set([start]) while queue: r, c, dist = queue.popleft() # If we reach the goal, return the distance if (r, c) == goal: return dist # Explore all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If no path is found, return -1 return -1"},{"question":"# In-Order Successor in BST Objective: Implement a function to find the in-order successor of a given node in a Binary Search Tree (BST). Context: In-order traversal of a BST yields nodes in ascending order. The in-order successor of a node is the next node in this sequence. This concept is crucial in scenarios such as database indexing, where maintaining sorted elements and quickly retrieving the next item is important. Problem Statement: Given a node in a Binary Search Tree (BST), write a function to find its in-order successor. Assume each node has a pointer to its parent. The function should return the in-order successor node or `None` if the given node has no in-order successor. Function Signature: ```python def in_order_successor(node: TreeNode | None): ``` Input: - `node`: A TreeNode representing the node whose in-order successor needs to be found. Each TreeNode has `val`, `left`, `right`, and `parent` attributes. The TreeNode can also be `None`. Output: - A TreeNode representing the in-order successor of the given node, or `None` if there is no in-order successor. Constraints: - The number of nodes in the tree is in the range [1, 10^4]. - 0 <= Node.val <= 10^5. Example: ```python # Example BST # 20 # / # 8 22 # / # 4 12 # / # 10 14 root = TreeNode(20) root.left = TreeNode(8, parent=root) root.right = TreeNode(22, parent=root) root.left.left = TreeNode(4, parent=root.left) root.left.right = TreeNode(12, parent=root.left) root.left.right.left = TreeNode(10, parent=root.left.right) root.left.right.right = TreeNode(14, parent=root.left.right) # Node: 10 Successor: 12 print(in_order_successor(root.left.right.left).val) # Output should be 12 # Node: 14 Successor: 20 print(in_order_successor(root.left.right.right).val) # Output should be 20 # Node: 22 Successor: None (No successor) print(in_order_successor(root.right)) # Output should be None ``` Note: - The input node is guaranteed to be part of the tree. - The solution should handle various scenarios, including nodes with no children and nodes at different tree depths. The implementation provided must leverage the properties of BSTs for efficiency, ensuring optimal performance given the constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def in_order_successor(node: TreeNode | None) -> TreeNode | None: Finds the in-order successor of the given node in a BST. if not node: return None # If node has a right child, then the successor is the leftmost node in the right subtree if node.right: return find_min(node.right) # If node has no right child, go up using the parent pointer until we find a node # which is the left child of its parent, then the parent will be the successor. current = node while current.parent and current == current.parent.right: current = current.parent return current.parent def find_min(node: TreeNode) -> TreeNode: Finds the minimum node in a BST (leftmost node). while node.left: node = node.left return node"},{"question":"# Coding Assessment Question You are provided with two implementations of an algorithm that computes the factorial of a non-negative integer. One implementation is iterative, and the other uses recursion. # Task Write a Python function that performs the following steps: 1. Reads in a non-negative integer. 2. Computes the factorial using both the iterative and recursive methods. 3. Compares the results of the two methods. 4. If they produce the same result, return a string \\"Matching Factorials: [value]\\". 5. If they produce different results, return a string \\"Discrepancy: Iterative calculated [iterative_value], Recursive calculated [recursive_value]\\". # Requirements 1. **Input**: A non-negative integer. 2. **Output**: A string message as specified above. 3. **Constraints**: * The input integer can be as large as 1,000. For the purpose of this question, assume that the factorial calculations will not result in integer overflow within the given constraints. # Performance: * Both implementations should be designed to handle the edge cases within the constraints efficiently. Examples: ```python # Example 1: input_number = 5 factorial_comparison(input_number) # Output: \\"Matching Factorials: 120\\" # Example 2: input_number = 0 factorial_comparison(input_number) # Output: \\"Matching Factorials: 1\\" # Example 3: input_number = 10 factorial_comparison(input_number) # Output: \\"Matching Factorials: 3628800\\" ```","solution":"def factorial_iterative(n): Computes the factorial of n using an iterative approach. result = 1 for i in range(2, n + 1): result *= i return result def factorial_recursive(n): Computes the factorial of n using a recursive approach. if n == 0 or n == 1: return 1 else: return n * factorial_recursive(n - 1) def factorial_comparison(number): Computes the factorial using both the iterative and recursive methods. Compares the results and returns a message indicating if they match or not. if number < 0: return \\"Invalid input, expected non-negative integer\\" iterative_result = factorial_iterative(number) recursive_result = factorial_recursive(number) if iterative_result == recursive_result: return f\\"Matching Factorials: {iterative_result}\\" else: return f\\"Discrepancy: Iterative calculated {iterative_result}, Recursive calculated {recursive_result}\\""},{"question":"# Coding Assessment Question Objective: To demonstrate your understanding of data structures, recursive functions, and tree traversal algorithms, you need to implement a function that finds the maximum depth of a binary tree. Scenario: Binary trees are fundamental data structures used in various algorithms and applications, such as searching, sorting, and hierarchical data representation. Suppose you\'re tasked with writing a function to determine the maximum depth of a binary tree to analyze the efficiency of a tree-based algorithm. Requirements: 1. **Function Name**: `max_depth` 2. **Input**: The root node of a binary tree. 3. **Output**: An integer representing the maximum depth (or height) of the binary tree. 4. **Constraints**: The binary tree can contain up to 100,000 nodes, and the depth can vary significantly. The function must be efficient. 5. **Performance**: Aim for a time complexity of O(n), where n is the number of nodes in the tree. Definitions: - The **maximum depth** of a binary tree is the number of nodes along the longest path from the root node to the farthest leaf node. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> print(max_depth(root)) 3 # Levels: [1 -> 2 -> 4] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> print(max_depth(root)) 4 # Levels: [1 -> 2 -> 3 -> 4] ``` Edge Cases to Consider: - Handle the scenario of an empty tree (root is None or null). - Ensure function works efficiently even for very deep and unbalanced trees. - Consider varying structures of trees like complete, full, and skewed trees. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1 # Test cases root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) print(max_depth(root1)) # Expected: 3 root2 = TreeNode(1) root2.right = TreeNode(2) root2.right.right = TreeNode(3) root2.right.right.right = TreeNode(4) print(max_depth(root2)) # Expected: 4 print(max_depth(None)) # Expected: 0 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Returns the maximum depth of a binary tree. if root is None: return 0 else: left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"New Question Creation for Coding Assessment # Wildcard Pattern Matching Implementation Given an input string and a pattern, implement a wildcard pattern matching function with support for \'?\' and \'*\'. The function should return a boolean indicating whether the input string matches the pattern. The wildcard characters work as follows: - \'?\' matches any single character. - \'*\' matches any sequence of characters (including the empty sequence). # Function Signature ```python def is_match(string: str, pattern: str) -> bool: pass ``` # Input - `string` (str): The input string to be matched (1 ≤ len(string) ≤ 1000). - `pattern` (str): The pattern string containing wildcard characters (1 ≤ len(pattern) ≤ 1000). # Output - Returns `True` if the string matches the pattern; otherwise, returns `False`. # Constraints - The input string consists of lowercase English letters. - The pattern string consists of lowercase English letters, \'?\' and \'*\'. # Example ```python assert is_match(\\"\\", \\"\\") == True assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"abc\\", \\"abc\\") == True assert is_match(\\"abc\\", \\"*c\\") == True assert is_match(\\"abc\\", \\"a*\\") == True assert is_match(\\"abc\\", \\"*a*\\") == True assert is_match(\\"abc\\", \\"?b?\\") == True assert is_match(\\"abc\\", \\"*?\\") == True assert is_match(\\"abc\\", \\"a*d\\") == False assert is_match(\\"abc\\", \\"a*c?\\") == False assert is_match(\\"baaabab\\", \\"*****ba*****ba\\") == False assert is_match(\\"baaabab\\", \\"*****ba*****ab\\") == True assert is_match(\\"aa\\", \\"*\\") == True ``` # Requirements 1. Implement the function using a dynamic programming approach. 2. Ensure it operates within O(m * n) time complexity. 3. Manage memory efficiently, keeping within O(m * n) space complexity. # Group Anagrams Given a list of strings, group anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. The function should return a list of groups of anagrams. # Function Signature ```python def group_anagrams(strs: list) -> list: pass ``` # Input - `strs` (list of str): A list of strings (1 ≤ len(strs) ≤ 10000, 1 ≤ len(strs[i]) ≤ 100). # Output - Returns a list of lists, where each sublist contains strings that are anagrams of each other. # Constraints - Each string contains only lowercase English letters. # Example ```python assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]) == [[\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]] ``` # Requirements 1. Implement the function efficiently with an average-case time complexity of O(n * k), where n is the number of strings and k is the maximum length of a string. 2. Optimize the space complexity to handle large inputs within the given constraints.","solution":"def is_match(string: str, pattern: str) -> bool: m, n = len(string), len(pattern) # Create a DP table with (m+1) x (n+1) size dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty pattern matches empty string dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif pattern[j - 1] == \'?\' or string[i - 1] == pattern[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n] def group_anagrams(strs: list) -> list: from collections import defaultdict anagrams = defaultdict(list) for string in strs: sorted_string = \'\'.join(sorted(string)) anagrams[sorted_string].append(string) return list(anagrams.values())"},{"question":"# Problem Statement You are given an integer array `arr` and an integer `x`. Your task is to find a pair of elements in the array whose product is closest to `x`. If there are multiple pairs, return any one of them. # Function Signature ```python def closest_pair_product(arr: List[int], x: int) -> Tuple[int, int]: ``` # Requirements 1. Implement the `closest_pair_product` function that takes as input a list of integers `arr` and an integer `x`. 2. The function should return a tuple containing two integers from `arr` whose product is closest to `x`. # Input/Output Format * **Input**: - `arr`: List of integers (can be positive, negative or zero). - `x`: An integer representing the target product. * **Output**: - A tuple containing two integers from `arr` whose product is closest to `x`. # Constraints - The length of `arr` will be between 2 and 10^4. - The elements of `arr` will be in the range of -10^4 to 10^4. - You can assume there is at least one valid pair in the array. # Example ```python arr = [1, 3, 5, 2, 7, 8, -1] x = 16 result = closest_pair_product(arr, x) # Output: (2, 8) or (1, 16) or any pair whose product is closest to 16 ``` # Additional Notes: - The function should handle edge cases such as arrays with duplicate elements and arrays containing zero. - You can use any necessary auxiliary functions, but avoid modifying the input list directly. - Ensure that the solution has efficient time complexity, ideally better than O(n^2).","solution":"from typing import List, Tuple def closest_pair_product(arr: List[int], x: int) -> Tuple[int, int]: closest_pair = None closest_diff = float(\'inf\') n = len(arr) # Try every combination of pairs (i, j) for i in range(n): for j in range(i + 1, n): prod = arr[i] * arr[j] diff = abs(prod - x) if diff < closest_diff: closest_diff = diff closest_pair = (arr[i], arr[j]) return closest_pair"},{"question":"# Coding Assessment Question Context You are continuing your work on a geometric calculator application, enhancing its ability to handle three-dimensional shapes. You have integrated support for regular dodecahedra and icosahedra. Now, you want to expand your library to include another polyhedron - a regular octahedron. Task Implement functions to compute the surface area and volume for a regular octahedron. A regular octahedron is a polyhedron with 8 equilateral triangle faces. Here are the formulas: * **Surface Area (S)**: ( S = 2 times sqrt{3} times a^2 ) * **Volume (V)**: ( V = frac{sqrt{2}}{3} times a^3 ) Requirements * **Function Names**: - `octahedron_surface_area(edge: float) -> float` - `octahedron_volume(edge: float) -> float` * **Input**: - A single float `edge` representing the length of the edge of the octahedron. * **Output**: - For `octahedron_surface_area`, return the surface area as a float. - For `octahedron_volume`, return the volume as a float. * **Constraints**: - `edge` must be a positive number; raise a `ValueError` if not. * **Performance**: - The implementation should be efficient, with each method operating in constant time. * **Tests**: - Include tests to validate your solution. For example: ```python >>> octahedron_surface_area(3) 31.17691453623979 >>> octahedron_volume(3) 6.928203230275509 >>> octahedron_surface_area(-3) Traceback (most recent call last): ... ValueError: Edge length must be a positive number. ``` Bonus Extend your solution to include a third function `describe_octahedron(edge: float) -> dict`, which returns a dictionary containing both surface area and volume.","solution":"import math def octahedron_surface_area(edge: float) -> float: Returns the surface area of a regular octahedron. Parameters: edge (float): The length of the edge of the octahedron. Returns: float: The surface area. Raises: ValueError: If the edge length is not a positive number. if edge <= 0: raise ValueError(\\"Edge length must be a positive number.\\") return 2 * math.sqrt(3) * edge * edge def octahedron_volume(edge: float) -> float: Returns the volume of a regular octahedron. Parameters: edge (float): The length of the edge of the octahedron. Returns: float: The volume. Raises: ValueError: If the edge length is not a positive number. if edge <= 0: raise ValueError(\\"Edge length must be a positive number.\\") return (math.sqrt(2) / 3) * edge * edge * edge def describe_octahedron(edge: float) -> dict: Returns a dictionary describing the octahedron, containing its surface area and volume. Parameters: edge (float): The length of the edge of the octahedron. Returns: dict: A dictionary with keys \'surface_area\' and \'volume\'. Raises: ValueError: If the edge length is not a positive number. if edge <= 0: raise ValueError(\\"Edge length must be a positive number.\\") surface_area = octahedron_surface_area(edge) volume = octahedron_volume(edge) return { \\"surface_area\\": surface_area, \\"volume\\": volume }"},{"question":"# Coding Question You are tasked with developing a utility for managing and analyzing event logs. The provided scripts include functionalities for parsing log entries, summarizing events, and searching for specific patterns within the logs. Objective Enhance the existing functionalities to improve performance and introduce new features to handle real-world log processing scenarios. 1. **Enhance Existing Functions**: - Modify the `parse_log_entry` function to support both ISO 8601 and custom timestamp formats without error. - Update the `summarize_events` function to group events by severity levels (INFO, WARNING, ERROR) and provide count summaries for each level. 2. **Add New Functionality**: - Implement a new function `search_logs` that allows searching for log entries containing specific keywords or patterns in either the message or metadata. - Introduce comprehensive input validation in the `main` function to prompt the user until valid log entry and search queries are provided. Function Implementations - **parse_log_entry(log: str) -> dict**: - Input: A string (log entry). - Output: Returns a dictionary parsed from the log entry, accommodating both ISO 8601 and custom timestamp formats. - **summarize_events(logs: list[dict]) -> dict**: - Input: A list of log entries (each as a dictionary). - Output: Returns a dictionary summarizing the counts by severity levels (INFO, WARNING, ERROR). - **search_logs(logs: list[dict], search_query: str) -> list[dict]**: - Input: A list of log entries (each as a dictionary) and a search query (string). - Output: Returns a list of log entries that match the search query in either the message or metadata. Example ```python >>> parse_log_entry(\\"2023-10-21T15:23:01 INFO User logged in\\") {\'timestamp\': \'2023-10-21T15:23:01\', \'severity\': \'INFO\', \'message\': \'User logged in\'} >>> summarize_events([ ... {\'timestamp\': \'2023-10-21T15:23:01\', \'severity\': \'INFO\', \'message\': \'User logged in\'}, ... {\'timestamp\': \'2023-10-21T15:24:15\', \'severity\': \'ERROR\', \'message\': \'Failed to connect to DB\'} ... ]) {\'INFO\': 1, \'ERROR\': 1, \'WARNING\': 0} >>> search_logs([ ... {\'timestamp\': \'2023-10-21T15:23:01\', \'severity\': \'INFO\', \'message\': \'User logged in\'}, ... {\'timestamp\': \'2023-10-21T15:24:15\', \'severity\': \'ERROR\', \'message\': \'Failed to connect to DB\'} ... ], \'connect\') [{\'timestamp\': \'2023-10-21T15:24:15\', \'severity\': \'ERROR\', \'message\': \'Failed to connect to DB\'}] ```","solution":"import re import datetime def parse_log_entry(log): Parses a log entry string into a dictionary. Supports both ISO 8601 and custom timestamp formats. Assumes the format \\"timestamp severity message\\". # Regex pattern for ISO 8601 and custom date formats iso_pattern = re.compile(r\\"(d{4}-d{2}-d{2}Td{2}:d{2}:d{2}) (INFO|WARNING|ERROR) (.+)\\") custom_pattern = re.compile(r\\"(d{4}/d{2}/d{2} d{2}:d{2}:d{2}) (INFO|WARNING|ERROR) (.+)\\") match = iso_pattern.match(log) if not match: match = custom_pattern.match(log) if match: timestamp, severity, message = match.groups() if custom_pattern.match(log): # Convert custom format to ISO 8601 standard custom_date = datetime.datetime.strptime(timestamp, \'%Y/%m/%d %H:%M:%S\') timestamp = custom_date.isoformat() return {\'timestamp\': timestamp, \'severity\': severity, \'message\': message} raise ValueError(\\"Log entry format is invalid\\") def summarize_events(logs): Summarizes events by severity levels (INFO, WARNING, ERROR). Returns a dictionary with counts of each severity level. summary = {\'INFO\': 0, \'WARNING\': 0, \'ERROR\': 0} for log in logs: severity = log[\'severity\'] if severity in summary: summary[severity] += 1 return summary def search_logs(logs, search_query): Searches log entries for the specific query in either the message or metadata. Returns a list of log entries that match the search query. results = [] for log in logs: if search_query in log[\'message\']: results.append(log) return results"},{"question":"# Question: Fibonacci Path Sum Given an integer matrix `grid` of size `m x n` and `m * n <= 10^5`, where each cell represents the cost of stepping on it, write a function `fibonacci_path_sum(grid: List[List[int]]) -> int` that calculates the minimum cost to reach the bottom-right corner from the top-left corner. The movement is restricted to cells corresponding to Fibonacci numbers (1, 2, 3, 5, 8, ...). Input * A 2D list of integers `grid` where (2 leq m, n leq 10^3). Output * An integer representing the minimum cost to reach the bottom-right corner from the top-left corner using the Fibonacci cells only. Constraints * If there is no valid path, return `-1`. * Movement is allowed only to the right or downward. Example ```python >>> grid = [ ... [1, 2, 3], ... [5, 2, 3], ... [3, 2, 2] ... ] >>> fibonacci_path_sum(grid) 6 # Path: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) with cost 1+2+3+3+2 = 11 >>> grid = [ ... [10, 5, 8], ... [7, 5, 18], ... [13, 1, 5] ... ] >>> fibonacci_path_sum(grid) -1 # No valid path ``` Note * Implement a helper function to check if a given number is a Fibonacci number. * Use a modified BFS or DFS to find the minimum cost path considering only Fibonacci number cells.","solution":"def is_fibonacci(n): Check if a number is a Fibonacci number. if n < 0: return False a, b = 0, 1 while b < n: a, b = b, a + b return b == n from typing import List from collections import deque def fibonacci_path_sum(grid: List[List[int]]) -> int: Calculate the minimal cost of a valid path moving on Fibonacci cells only from top-left to bottom-right. m, n = len(grid), len(grid[0]) # Check if the start and end are Fibonacci numbers if not is_fibonacci(grid[0][0]) or not is_fibonacci(grid[m-1][n-1]): return -1 # Directions to move: right (0, 1) and down (1, 0) directions = [(0, 1), (1, 0)] visited = [[False for _ in range(n)] for _ in range(m)] # BFS to find the minimum cost path queue = deque([(0, 0, grid[0][0])]) # (row, col, current_path_cost) visited[0][0] = True while queue: x, y, current_cost = queue.popleft() if x == m - 1 and y == n - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and is_fibonacci(grid[nx][ny]): visited[nx][ny] = True queue.append((nx, ny, current_cost + grid[nx][ny])) return -1"},{"question":"# Question You are provided with a Python class representing a **MinHeap**. A MinHeap is a complete binary tree where the value of each node is less than or equal to the values of its children. Your task is to complete the implementation of the `MinHeap` class by adding a method called `heapify_down`. This method is used to maintain the min-heap property starting from a given index and ensuring that the subtree rooted at this index satisfies the min-heap property. **Function Signature**: ```python def heapify_down(self, index: int) -> None: pass ``` # Instructions 1. **Function Details**: - **Input**: An integer `index` representing the position in the heap array from which to start the heapify down process. - **Output**: This function does not return anything. It modifies the heap in place. - **Constraints**: - The method should ensure the min-heap property is restored starting from the specified index down to the leaves. - The heap is represented as a list of integers. 2. **Class and Method Details**: ```python class MinHeap: def __init__(self): self.heap = [] def insert(self, value: int) -> None: self.heap.append(value) self.heapify_up(len(self.heap) - 1) def heapify_up(self, index: int) -> None: # This method is already implemented to restore the min-heap property from given index up to the root. pass def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extracting from an empty heap\\") min_value = self.heap[0] self.heap[0] = self.heap.pop() if len(self.heap) > 0: self.heapify_down(0) return min_value def heapify_down(self, index: int) -> None: # Your code here pass ``` 3. **Examples**: ```python # Example 1 min_heap = MinHeap() min_heap.insert(3) min_heap.insert(1) min_heap.insert(6) min_heap.insert(5) min_heap.insert(2) min_heap.insert(4) assert min_heap.heap == [1, 2, 4, 5, 3, 6] # The heap array representation # Example 2 min_heap = MinHeap() min_heap.insert(10) min_heap.insert(15) min_heap.insert(20) min_heap.insert(17) assert min_heap.extract_min() == 10 assert min_heap.heap == [15, 17, 20] ``` 4. **Guidelines**: - Follow the min-heap property rules strictly. - Handle edge cases such as when the heap is empty or when the heap contains only one element. # Additional Notes: - The `heapify_down` function should ensure the entire subtree follows the min-heap property by recursively comparing the parent node with its children and swapping where necessary. - Use the helper methods (`insert`, `heapify_up`, `extract_min`) provided as references for how the heap operations should behave. Implement the `heapify_down` method in the `MinHeap` class: # Code to Implement ```python class MinHeap: def __init__(self): self.heap = [] def insert(self, value: int) -> None: self.heap.append(value) self.heapify_up(len(self.heap) - 1) def heapify_up(self, index: int) -> None: while index > 0: parent = (index - 1) // 2 if self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent else: break def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extracting from an empty heap\\") min_value = self.heap[0] self.heap[0] = self.heap.pop() if len(self.heap) > 0: self.heapify_down(0) return min_value def heapify_down(self, index: int) -> None: # Your code here pass ```","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, value: int) -> None: self.heap.append(value) self.heapify_up(len(self.heap) - 1) def heapify_up(self, index: int) -> None: while index > 0: parent = (index - 1) // 2 if self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent else: break def extract_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"Extracting from an empty heap\\") min_value = self.heap[0] if len(self.heap) > 1: self.heap[0] = self.heap.pop() self.heapify_down(0) else: self.heap.pop() return min_value def heapify_down(self, index: int) -> None: child_index = 2 * index + 1 while child_index < len(self.heap): right_child = child_index + 1 if right_child < len(self.heap) and self.heap[right_child] < self.heap[child_index]: child_index = right_child if self.heap[index] <= self.heap[child_index]: break self.heap[index], self.heap[child_index] = self.heap[child_index], self.heap[index] index = child_index child_index = 2 * index + 1"},{"question":"# Balanced Parentheses Substring Background You are working on a syntax parser for a compiler project. One of the critical features is to ensure that parentheses in the given code are balanced and the longest balanced substring is identified for further analysis. Objective Implement a function `longest_balanced_substring` which, given a string containing only characters `(` and `)`, returns the length of the longest substring that consists of balanced parentheses. Input Format * A single string `s` of length (1 leq |s| leq 10^5). The string contains only characters `(` and `)`. Output Format * An integer representing the length of the longest balanced parentheses substring. Constraints * The solution must run in linear time (O(n)) where (n) is the length of the string. * Use at most linear space. Examples ```plaintext Example 1: Input: \\"(()())\\" Output: 6 Example 2: Input: \\")(()())\\" Output: 6 Example 3: Input: \\"(()))(\\" Output: 4 Example 4: Input: \\")))(((\\" Output: 0 ``` Implementation Requirements Write the function `longest_balanced_substring(s: str) -> int` which follows the specified input and output format. Utilize an efficient approach such as using a stack or a two-pointer technique to maintain optimal performance.","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced parentheses substring. max_length = 0 # Left to right pass left = right = 0 for char in s: if char == \'(\': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * right) elif right > left: left = right = 0 # Right to left pass left = right = 0 for char in reversed(s): if char == \'(\': left += 1 else: right += 1 if left == right: max_length = max(max_length, 2 * left) elif left > right: left = right = 0 return max_length"},{"question":"# Problem Statement You are tasked with implementing a system for managing and querying a simple in-memory key-value store, similar to a basic database. Your goal is to create a function that can perform multiple operations on this key-value store efficiently. Each operation can be one of the following types: - `\'SET <key> <value>\'`: Set the value for the given key. - `\'GET <key>\'`: Retrieve the value for the given key. - `\'DELETE <key>\'`: Delete the key and its value from the store. - `\'KEYS\'`: Return a sorted list of all keys present in the store. You need to implement a function that processes a list of operations and returns the results of the `\'GET\'` and `\'KEYS\'` operations. # Function Details: **Function Name**: `process_operations` **Input**: - `operations`: A list of strings, where each string represents an operation. Operations follow the format outlined above. **Output**: - A list containing the results of `\'GET\'` and `\'KEYS\'` operations, in the order they appear. **Constraints**: - Each key is a non-empty string consisting of alphanumeric characters. - Each value is a string. - The maximum number of operations will not exceed 10^6. - Attempting to `\'GET\'` or `\'DELETE\'` a non-existing key should be safely handled with appropriate responses. # Example: ```python def process_operations(operations: list) -> list: # Your implementation here pass # Example Test Cases print(process_operations([\'SET x 10\', \'GET x\', \'SET y 20\', \'GET y\', \'DELETE x\', \'GET x\', \'KEYS\'])) # Expected: [\'10\', \'20\', \'None\', [\'y\']] print(process_operations([\'SET key1 value1\', \'SET key2 value2\', \'GET key1\', \'DELETE key2\', \'GET key2\', \'KEYS\'])) # Expected: [\'value1\', \'None\', [\'key1\']] print(process_operations([\'SET a 1\', \'SET b 2\', \'SET c 3\', \'GET a\'])) # Expected: [\'1\'] ``` # Notes: - The function should handle the maximum constraint efficiently. - The `\'GET\'` operation should return `\'None\'` if the key does not exist. - The `\'KEYS\'` operation should return keys in sorted order. - Ensure proper handling of edge cases such as trying to delete non-existing keys.","solution":"def process_operations(operations): store = {} result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \'SET\': store[parts[1]] = parts[2] elif command == \'GET\': key = parts[1] result.append(store.get(key, \'None\')) elif command == \'DELETE\': key = parts[1] store.pop(key, None) elif command == \'KEYS\': result.append(sorted(store.keys())) return result"},{"question":"**Context**: You are developing a file management system and need to implement a function that simulates the processing of file operations in a directory. The operations include navigating to subdirectories, going back to the parent directory, and obtaining the current directory path. **Task**: Implement the class `FileManager` with the following methods: - `void cd(String path)`: Changes the current directory to the given path. - `String pwd()`: Returns the current directory path as a string. # Input * `path`: A string representing the directory path (1 <= len(path) <= 200). - The path can be an absolute path starting from the root (\\"/\\"), or a relative path. - The path uses \\"/\\" as the separator for directories. - The path \\"..\\" refers to the parent directory. # Output * `pwd()`: Returns the current directory path as a string. # Constraints * The initial directory is the root directory (\\"/\\"). * The system does not handle invalid paths (all given paths are valid). # Example Example 1 ```python fm = FileManager() fm.cd(\\"home/user/documents\\") assert fm.pwd() == \\"/home/user/documents\\" fm.cd(\\"..\\") assert fm.pwd() == \\"/home/user\\" fm.cd(\\"/\\") assert fm.pwd() == \\"/\\" ``` Example 2 ```python fm = FileManager() fm.cd(\\"/usr/local/bin\\") assert fm.pwd() == \\"/usr/local/bin\\" fm.cd(\\"../../..\\") assert fm.pwd() == \\"/\\" fm.cd(\\"var/log\\") assert fm.pwd() == \\"/var/log\\" ``` Example 3 ```python fm = FileManager() fm.cd(\\"a/b\\") assert fm.pwd() == \\"/a/b\\" fm.cd(\\"../c/d\\") assert fm.pwd() == \\"/a/c/d\\" ```","solution":"class FileManager: def __init__(self): self.current_path = [\\"\\"] # Initialize with the root directory def cd(self, path): if path.startswith(\\"/\\"): # If the path is absolute, start from the root self.current_path = [\\"\\"] path = path[1:] # Remove the leading slash for easier processing components = path.split(\\"/\\") for part in components: if part == \\"..\\": if len(self.current_path) > 1: self.current_path.pop() # Go up to the parent directory elif part and part != \\".\\": # Append the directory if it\'s not empty or current directory indicator self.current_path.append(part) def pwd(self): if len(self.current_path) == 1 and self.current_path[0] == \\"\\": return \\"/\\" return \\"/\\".join(self.current_path)"},{"question":"# Question: Implement Kruskal’s Algorithm with Union-Find Optimization You are tasked with implementing Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) of a connected, undirected graph. To optimize the algorithm, use a union-find data structure (disjoint-set) with path compression and union by rank. Requirements: 1. **Input**: * A list of edges in the graph, where each edge is represented as a tuple `(u, v, weight)`. * The total number of vertices in the graph `n`. 2. **Output**: * A list of edges included in the MST, each represented as a tuple `(u, v, weight)`. 3. **Constraints**: * The graph is connected and undirected. * Vertices are numbered from `0` to `n-1`. * Edge weights are positive integers. Example: ```python edges = [(0, 1, 4), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 3, 4)] n = 4 assert kruskal_mst(edges, n) == [(1, 2, 1), (1, 3, 2), (0, 2, 3)] ``` Steps to Implement: 1. **Sort Edges**: Begin by sorting all edges in non-decreasing order of their weight. 2. **Initialize Union-Find**: Create a union-find data structure to manage and merge disjoint sets. 3. **Kruskal\'s Algorithm**: 1. Iterate over the sorted edge list. 2. For each edge, check if the vertices of the edge belong to different sets using the union-find data structure. 3. If they do, add the edge to the MST and union their sets. 4. **Return MST**: Once all vertices are connected, return the list of edges included in the MST. Tips: * Implement the union-find data structure with path compression for efficient \\"find\\" operations. * Use union by rank to keep the tree flat and the unions efficient. * Verify the example output for correctness and ensure the function handles edge cases. ```python def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(edges, n): mst = [] edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while len(mst) < n-1: u, v, weight = edges.pop(0) x = find(parent, u) y = find(parent, v) if x != y: mst.append((u, v, weight)) union(parent, rank, x, y) return mst ``` Ensure your implementation correctly returns the minimum spanning tree for the given graph and satisfies the example case provided.","solution":"def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(edges, n): mst = [] edges = sorted(edges, key=lambda item: item[2]) parent = list(range(n)) rank = [0] * n for u, v, weight in edges: if len(mst) == n - 1: break root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst.append((u, v, weight)) union(parent, rank, root_u, root_v) return mst"},{"question":"# Problem Statement You are given a list of integers. Write a function `find_longest_arithmetic_subsequence(arr)` that returns the length of the longest arithmetic subsequence that can be formed from the given list. An arithmetic subsequence of a list is a subsequence that can be derived by deleting some or no elements of the list, and the difference between consecutive elements is constant. # Input - `arr` (1 ≤ len(`arr`) ≤ 1000, -10^6 ≤ `arr[i]` ≤ 10^6), a list of integers. # Output - An integer representing the length of the longest arithmetic subsequence. # Constraints - The function should handle lists efficiently, even for the maximum constraints. - Use dynamic programming to solve the problem within a reasonable time complexity. # Examples ```python def find_longest_arithmetic_subsequence(arr: list) -> int: # Your code here # Example 1 # Input: # arr = [3, 6, 9, 12] # Output: # 4 # Example 2 # Input: # arr = [9, 4, 7, 2, 10] # Output: # 3 # Example 3 # Input: # arr = [20, 1, 15, 3, 10, 5, 8] # Output: # 4 ``` # Explanation For the input `[3, 6, 9, 12]`: - The entire list is an arithmetic sequence with a difference of 3 between each element. - The length of the longest arithmetic subsequence is 4. For the input `[9, 4, 7, 2, 10]`: - One of the possible longest arithmetic subsequences is `[4, 7, 10]` with a difference of 3. - The length is 3. For the input `[20, 1, 15, 3, 10, 5, 8]`: - One of the possible longest arithmetic subsequences is `[20, 15, 10, 5]` with a difference of -5. - The length is 4. You need to implement a function `find_longest_arithmetic_subsequence` that computes the length of such a sequence efficiently using dynamic programming.","solution":"def find_longest_arithmetic_subsequence(arr): if not arr: return 0 dp = [{} for _ in range(len(arr))] max_length = 1 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # At least two elements (arr[j] and arr[i]) max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"# Coding Question: Network Traffic Congestion Detection Scenario You are tasked with implementing a system to detect traffic congestion in a computer network. The network is represented as an undirected graph where nodes correspond to servers and edges represent the communication links between them. Each communication link has a bandwidth capacity, and there is a certain amount of data traffic between pairs of servers. Task Implement a function `detect_congestion` in Python that identifies which communication links are congested based on the data traffic and bandwidth capacity. Function Signature ```python def detect_congestion( number_of_servers: int, edges: list, traffic: list ) -> list: ``` Parameters * `number_of_servers` (int): Total number of servers in the network. * `edges` (list): A list of tuples where each tuple `(u, v, capacity)` represents an undirected edge between servers `u` and `v` with the bandwidth capacity `capacity`. * `traffic` (list): A list of tuples where each tuple `(u, v, amount)` represents the amount of data traffic between servers `u` and `v`. Returns * `list`: A list of tuples where each tuple `(u, v)` represents a congested communication link. Constraints * (2 leq number_of_servers leq 1000) * (1 leq len(edges) leq 5000) * (0 leq capacity leq 10^6) * (1 leq len(traffic) leq 5000) * (0 leq amount leq 10^6) Example ```python # Example 1 number_of_servers = 4 edges = [(0, 1, 10), (1, 2, 5), (2, 3, 15), (3, 0, 10)] traffic = [(0, 1, 8), (1, 2, 6), (2, 3, 14), (3, 0, 12)] result = detect_congestion(number_of_servers, edges, traffic) # Output: [(1, 2), (3, 0)] # Example 2 number_of_servers = 3 edges = [(0, 1, 5), (1, 2, 10)] traffic = [(0, 1, 3), (1, 2, 9)] result = detect_congestion(number_of_servers, edges, traffic) # Output: [] ``` In this example, if the data traffic on a link exceeds its bandwidth capacity, that link is considered congested. Ensure your solution efficiently processes up to the maximum constraints.","solution":"def detect_congestion(number_of_servers, edges, traffic): Identifies which communication links are congested based on the data traffic and bandwidth capacity. :param number_of_servers: int, total number of servers in the network. :param edges: list, a list of tuples where each tuple (u, v, capacity) represents an undirected edge between servers u and v with the bandwidth capacity capacity. :param traffic: list, a list of tuples where each tuple (u, v, amount) represents the amount of data traffic between servers u and v. :return: list, a list of tuples where each tuple (u, v) represents a congested communication link. capacity_map = {} congestion_list = [] # Create a dictionary to store capacities of each edge for u, v, capacity in edges: capacity_map[(u, v)] = capacity capacity_map[(v, u)] = capacity # Check the traffic against the capacities for u, v, amount in traffic: capacity = capacity_map.get((u, v)) if capacity is not None and amount > capacity: # Ensure to add the edges in sorted order (u, v) where u < v for consistency if u < v: congestion_list.append((u, v)) else: congestion_list.append((v, u)) return congestion_list"},{"question":"# Coding Assessment Question Scenario: As a backend developer at a financial institution, you need to develop a function to manage user transaction histories. Your task is to generate a summary of transactions over a given period specified by a start and end date. Each transaction includes a date, description, and amount. Task: Implement a function `transaction_summary(transactions, start_date, end_date)` that returns a summary of transactions within the specified date range. Each transaction is represented as a tuple containing (date, description, amount). The summary should include the total number of transactions, the total amount spent, and a breakdown of transactions. Function Signature: ```python def transaction_summary(transactions: List[Tuple[str, str, float]], start_date: str, end_date: str) -> Dict[str, Any]: ``` Input: - `transactions` : A list of tuples where each tuple represents a transaction. Each tuple consists of: - `date` : A string in the format \'YYYY-MM-DD\' representing the transaction date. - `description` : A string describing the transaction. - `amount` : A float representing the amount spent in the transaction. - `start_date` : A string in the format \'YYYY-MM-DD\' representing the start date of the summary period. - `end_date` : A string in the format \'YYYY-MM-DD\' representing the end date of the summary period. Output: - Returns a dictionary with the following keys: - `total_transactions`: Integer representing the total number of transactions within the specified date range. - `total_amount`: Float representing the total amount spent within the specified date range. - `transactions`: List of tuples representing the filtered transactions within the specified date range. Constraints: - `start_date` and `end_date` will always be valid dates in \'YYYY-MM-DD\' format. - All dates in the transactions list will also be in the \'YYYY-MM-DD\' format. - The `start_date` is always less than or equal to the `end_date`. Example: ```python transactions = [ (\'2023-01-01\', \'Groceries\', 50.25), (\'2023-01-02\', \'Utilities\', 75.50), (\'2023-01-08\', \'Rent\', 1200.00), (\'2023-01-10\', \'Coffee\', 3.75), (\'2023-01-15\', \'Gym Membership\', 35.00) ] start_date = \'2023-01-01\' end_date = \'2023-01-10\' print(transaction_summary(transactions, start_date, end_date)) # Expected Output: # { # \'total_transactions\': 4, # \'total_amount\': 1329.5, # \'transactions\': [ # (\'2023-01-01\', \'Groceries\', 50.25), # (\'2023-01-02\', \'Utilities\', 75.50), # (\'2023-01-08\', \'Rent\', 1200.00), # (\'2023-01-10\', \'Coffee\', 3.75) # ] # } ``` Notes: - Assume that the dictionary key order in the output should be maintained as shown in the example. - The date comparisons should account for edge cases where the transaction date equals the start or end date. - Transactions outside the range specified by `start_date` and `end_date` should not be included in the summary.","solution":"from typing import List, Tuple, Dict, Any from datetime import datetime def transaction_summary(transactions: List[Tuple[str, str, float]], start_date: str, end_date: str) -> Dict[str, Any]: Returns a summary of transactions within the specified date range. # Convert string dates to datetime objects for comparison start_dt = datetime.strptime(start_date, \'%Y-%m-%d\') end_dt = datetime.strptime(end_date, \'%Y-%m-%d\') filtered_transactions = [ txn for txn in transactions if start_dt <= datetime.strptime(txn[0], \'%Y-%m-%d\') <= end_dt ] total_amount = sum(txn[2] for txn in filtered_transactions) total_transactions = len(filtered_transactions) return { \'total_transactions\': total_transactions, \'total_amount\': total_amount, \'transactions\': filtered_transactions }"},{"question":"# Question: Validate and Format Email Address Implement a function that validates an email address and ensures it conforms to the standard email format. If the email address is valid, the function should return a properly formatted version of the email address (lowercase and with no spaces). If the email address is invalid, it should raise a `ValueError` with an appropriate error message. Input: - A single string which is an email address. The string may contain leading or trailing spaces. Output: - A string representing the cleaned and validated email address, all in lowercase and with no surrounding spaces. Constraints: - The input string should adhere to the general format of `local_part@domain_part`. - The local part can contain letters, digits, underscores `_`, hyphens `-`, and dots `.`. - The domain part can contain letters, digits, hyphens `-`, and dots `.`. - The domain part must have at least one dot, and the last segment must be between 2 to 6 characters. - Any invalid input should raise a `ValueError` with an appropriate error message. Examples: ```python def validate_and_format_email(email: str) -> str: Validate and format an email address according to the specified rules. :param email: str: The email address to validate and format. :return: str: The formatted email address if valid. Examples: >>> validate_and_format_email(\\"EXAMPLE@DOMAIN.COM\\") \'example@domain.com\' >>> validate_and_format_email(\\" example@domain.com \\") \'example@domain.com\' >>> validate_and_format_email(\\"user.name+alias@domain.co.in\\") \'user.name+alias@domain.co.in\' >>> validate_and_format_email(\\"username@.domain.com\\") Traceback (most recent call last): ... ValueError: Invalid domain part in email address >>> validate_and_format_email(\\"username@domain.c\\") Traceback (most recent call last): ... ValueError: Invalid domain part in email address >>> validate_and_format_email(\\"@domain.com\\") Traceback (most recent call last): ... ValueError: Invalid local part in email address >>> validate_and_format_email(\\"username@domaincom\\") Traceback (most recent call last): ... ValueError: Invalid domain part in email address import re email = email.strip().lower() if not email: raise ValueError(\\"Empty string was passed to the function\\") # Check if the email matches the pattern for a valid email address pattern = re.compile( r\\"^(?P<local>[a-zA-Z0-9._%-]+)@(?P<domain>([a-zA-Z0-9-]+.)+[a-zA-Z]{2,6})\\" ) match = pattern.match(email) if not match: raise ValueError(\\"Invalid email address format\\") local_part = match.group(\\"local\\") domain_part = match.group(\\"domain\\") # Additional checks for local and domain parts if len(local_part) == 0: raise ValueError(\\"Invalid local part in email address\\") if len(domain_part.split(\\".\\")[-1]) < 2 or len(domain_part.split(\\".\\")[-1]) > 6: raise ValueError(\\"Invalid domain part in email address\\") return email if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Your task is to implement the `validate_and_format_email` function following the specifications above.","solution":"import re def validate_and_format_email(email: str) -> str: Validate and format an email address according to the specified rules. :param email: str: The email address to validate and format. :return: str: The formatted email address if valid. :raises ValueError: If the email address is invalid. Examples: >>> validate_and_format_email(\\"EXAMPLE@DOMAIN.COM\\") \'example@domain.com\' >>> validate_and_format_email(\\" example@domain.com \\") \'example@domain.com\' >>> validate_and_format_email(\\"user.name+alias@domain.co.in\\") \'user.name+alias@domain.co.in\' >>> validate_and_format_email(\\"username@.domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domain.c\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"@domain.com\\") Traceback (most recent call last): ... ValueError: Invalid email address format >>> validate_and_format_email(\\"username@domaincom\\") Traceback (most recent call last): ... ValueError: Invalid email address format email = email.strip().lower() if not email: raise ValueError(\\"Empty string provided as email address\\") # Email validation regex pattern pattern = re.compile( r\\"^(?P<local>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+.[a-zA-Z]{2,6})\\" ) match = pattern.match(email) if not match: raise ValueError(\\"Invalid email address format\\") local_part = match.group(\\"local\\") domain_part = match.group(\\"domain\\") # Validate local part if len(local_part) == 0: raise ValueError(\\"Invalid local part in email address\\") # Validate domain part if len(domain_part.split(\\".\\")[-1]) < 2 or len(domain_part.split(\\".\\")[-1]) > 6: raise ValueError(\\"Invalid domain part in email address\\") return email"},{"question":"**Objective**: To assess comprehension of basic data structures, algorithms, and optimization in Python by implementing a system to manage and process a dynamic queue with priority levels. **Dynamic Queue Management**: Implement a Python class `DynamicQueue` that simulates a queue system with varying priority levels for its elements. Your implementation should support standard queue operations with additional functionality to handle priorities. # Tasks 1. **enqueue**: Write a method `enqueue` which takes in two parameters, `element` (the item to be added to the queue) and `priority` (an integer representing the priority level, where lower numbers indicate higher priority). Add the element to the appropriate priority level within the queue. If no priority is provided, treat it as the lowest priority (e.g., priority 10). 2. **dequeue**: Write a method `dequeue` which removes and returns the element with the highest priority (i.e., the smallest priority number). If there are multiple elements of the same priority, dequeue the one that was added first. Return `None` if the queue is empty. 3. **peek**: Write a method `peek` that returns the element with the highest priority without removing it from the queue. If there are multiple elements with the same priority, return the one that was added first. Return `None` if the queue is empty. 4. **is_empty**: Write a method `is_empty` that checks whether the queue is empty. It should return `True` if the queue is empty, otherwise `False`. 5. **size**: Write a method `size` which returns the total number of elements in the queue across all priority levels. # Specifications - You can assume the elements are of any data type. - Priorities are non-negative integers. - Handle edge cases gracefully, such as adding elements without a priority and attempting to dequeue from an empty queue. # Example ```python # Example usage queue = DynamicQueue() queue.enqueue(\\"Task 1\\", 2) queue.enqueue(\\"Task 2\\", 1) queue.enqueue(\\"Task 3\\") print(queue.peek()) # Output: Task 2 print(queue.dequeue()) # Output: Task 2 print(queue.size()) # Output: 2 print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: Task 1 print(queue.dequeue()) # Output: Task 3 print(queue.dequeue()) # Output: None print(queue.is_empty()) # Output: True ``` # Constraints: - The queue should support an arbitrary number of priority levels. - Performance should be optimized to handle up to 10^5 enqueue and dequeue operations. - Each element has a priority level between 0 and 10^6. **Note**: Focus on how different priorities are managed within the queue and the implementation\'s efficiency in handling large numbers of operations.","solution":"from collections import deque, defaultdict class DynamicQueue: def __init__(self): self.queues = defaultdict(deque) self.size_count = 0 def enqueue(self, element, priority=10): self.queues[priority].append(element) self.size_count += 1 def dequeue(self): for priority_level in sorted(self.queues): if self.queues[priority_level]: self.size_count -= 1 return self.queues[priority_level].popleft() return None def peek(self): for priority_level in sorted(self.queues): if self.queues[priority_level]: return self.queues[priority_level][0] return None def is_empty(self): return self.size_count == 0 def size(self): return self.size_count"},{"question":"# Factory Production Line Simulation You have been tasked with simulating a simplified production line in a factory. The production line consists of multiple machines, each with a specific processing time. An item moves sequentially through each machine. Your goal is to determine the total time it takes for an item to go from the beginning of the production line to the end, given that each machine can process only one item at a time, and must finish processing one item before starting another. # Implementation Details Implement the function `simulate_production` that takes the number of items and their processing times in a list, and returns the total time required to process all items. Function Signature ```python def simulate_production(num_items: int, processing_times: list[float]) -> float: ... ``` Inputs - `num_items`: An integer representing the number of items to be processed. - `processing_times`: A list of floats, each representing the processing time of one machine in the production line. ``` [time1, time2, time3, ...] ``` Output - Return a float representing the total time required to process all items. Constraints - Each processing time is a positive float within the range `0.1` to `100.0`. - The number of items is an integer between `1` and `1000`. - The number of machines is an integer between `1` and `100`. Example ```python num_items = 3 processing_times = [2.5, 3.0, 1.5] print(simulate_production(num_items, processing_times)) # Outputs: 21.0 ``` Note - The production line is strictly sequential, meaning each item must pass through each machine in the order specified before moving to the next machine. - Think carefully about the order in which items are processed and the cumulative effect on total time.","solution":"def simulate_production(num_items: int, processing_times: list[float]) -> float: Simulates the total time to process all items through the production line. :param num_items: int - The number of items to be processed. :param processing_times: list[float] - A list of processing times for each machine in the production line. :return: float - The total time required to process all items. total_time = 0.0 num_machines = len(processing_times) for item in range(num_items): for machine in range(num_machines): total_time += processing_times[machine] return total_time"},{"question":"# CSV Parser Enhancement Task You are tasked with enhancing a basic CSV parser script written in Python. The current implementation reads data from a CSV file and converts it to a list of dictionaries, where each dictionary represents a row. Your goal is to improve the reliability, performance, and usability of the script by addressing its weaknesses and implementing additional features. # Requirements 1. **Function Implementation**: Create a function `enhanced_parse_csv(file_path: str, delimiter: str = \',\') -> list` that: * Takes a file path and an optional delimiter as input. * Returns the parsed CSV data as a list of dictionaries. * Utilizes streaming to read the CSV file to minimize memory usage. 2. **Error Handling**: * Gracefully handles file I/O errors, malformed CSV data, and missing files. * Logs meaningful error messages to help debug issues. 3. **Performance Optimization**: Ensure that the script efficiently handles large CSV files by using streaming and minimizing memory usage. 4. **Testing and Validation**: * Provide a set of test cases to validate your function. * Ensure your function can handle edge cases such as empty files, non-standard delimiters, and large files. # Scenario Context A team of data analysts at a financial institution frequently needs to process large CSV files containing transaction data. They require a reliable and efficient script that can handle occasional file format issues and process large files without exhausting system memory. # Input and Output * Input: File path of the CSV and an optional delimiter. * Output: List of dictionaries representing CSV data or an appropriate error message. # Constraints * File paths provided will be well-formed strings but may or may not point to actual files. * Ensure minimal memory usage for large file processing. ```python import csv import logging # Function to enhance def enhanced_parse_csv(file_path: str, delimiter: str = \',\') -> list: Parses a CSV file into a list of dictionaries with minimal memory usage. :param file_path: Path to the CSV file :param delimiter: Delimiter used in the CSV file :return: List of dictionaries representing CSV data parsed_data = [] try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file, delimiter=delimiter) for row in reader: parsed_data.append(row) except FileNotFoundError: logging.error(f\\"File not found: {file_path}\\") raise except csv.Error as e: logging.error(f\\"CSV parsing error: {e}\\") raise except Exception as e: logging.error(f\\"Unexpected error: {e}\\") raise return parsed_data if __name__ == \\"__main__\\": file_path = input(\\"Enter CSV file path: \\").strip() delimiter = input(\\"Enter delimiter (default is \',\'): \\").strip() delimiter = delimiter if delimiter else \',\' try: data = enhanced_parse_csv(file_path, delimiter) for row in data: print(row) print(f\\"Successfully parsed CSV data from {file_path}.\\") except Exception as e: print(f\\"Failed to parse CSV file: {e}\\") ```","solution":"import csv import logging def enhanced_parse_csv(file_path: str, delimiter: str = \',\') -> list: Parses a CSV file into a list of dictionaries with minimal memory usage. :param file_path: Path to the CSV file :param delimiter: Delimiter used in the CSV file :return: List of dictionaries representing CSV data parsed_data = [] try: with open(file_path, mode=\'r\', newline=\'\') as file: reader = csv.DictReader(file, delimiter=delimiter) for row in reader: parsed_data.append(row) except FileNotFoundError: logging.error(f\\"File not found: {file_path}\\") raise except csv.Error as e: logging.error(f\\"CSV parsing error: {e}\\") raise except Exception as e: logging.error(f\\"Unexpected error: {e}\\") raise return parsed_data"},{"question":"# Problem Statement **Context**: A vending machine dispenses different beverages based on the amount of money inserted by the user. Each beverage has a specific price, and the machine should return the correct change in the form of coins. The vending machine only accepts and returns coins of denominations [1, 5, 10, 25, 50, 100] cents. If the inserted money is less than the price of the selected beverage, the machine should return the inserted money and a message indicating insufficient funds. **Task**: Implement the `vending_machine` function that simulates the vending machine\'s behavior. The function should take the price of the beverage and the amount of money inserted, then determine the purchased beverage and the change to return in an optimal manner using the least number of coins. # Function Signature ```python def vending_machine(price: int, inserted_money: int) -> dict[str, any]: pass ``` # Input - `price`: An integer representing the price of the selected beverage (1 ≤ price ≤ 1000). - `inserted_money`: An integer representing the money inserted by the user (0 ≤ inserted_money ≤ 2000). # Output - A dictionary with two keys: - `message`: A string indicating if the user successfully purchased the beverage or if there were insufficient funds. - `change`: A dictionary where keys are coin denominations (1, 5, 10, 25, 50, 100) and values are the count of each denomination to be returned as change. # Constraints - Ensure the function correctly handles cases where `inserted_money` is exactly equal to or less than `price`. - Optimize the change computation to return the least number of coins. - Handle edge cases where no change needs to be returned. # Example ```python vending_machine(275, 300) # Output: {\'message\': \'Beverage purchased\', \'change\': {25: 1, 1: 0, 5: 0, 10: 0, 50: 0, 100: 0}} vending_machine(175, 200) # Output: {\'message\': \'Beverage purchased\', \'change\': {25: 1, 1: 0, 5: 0, 10: 0, 50: 0, 100: 0}} vending_machine(250, 100) # Output: {\'message\': \'Insufficient funds\', \'change\': {1: 100, 5: 0, 10: 0, 25: 0, 50: 0, 100: 0}} ``` **Hint**: Start by calculating the total change required and then use a greedy algorithm to determine the fewest number of coins needed.","solution":"def vending_machine(price: int, inserted_money: int) -> dict: if inserted_money < price: coins = {1: 0, 5: 0, 10: 0, 25: 0, 50: 0, 100: 0} coins[1] = inserted_money return {\'message\': \'Insufficient funds\', \'change\': coins} change = inserted_money - price coin_denominations = [100, 50, 25, 10, 5, 1] coins_to_return = {1: 0, 5: 0, 10: 0, 25: 0, 50: 0, 100: 0} for coin in coin_denominations: if change >= coin: coins_to_return[coin] = change // coin change %= coin return {\'message\': \'Beverage purchased\', \'change\': coins_to_return}"},{"question":"# Coding Assessment Question: Scenario: You are part of a team developing a recommendation system for an online bookstore. Your task is to generate recommendations based on user reading history. For this part of the project, you need to analyze a list of user transactions and determine the most frequently purchased books by genre. Task: Write a function `most_frequent_books_by_genre` that: 1. Accepts a list of transactions, where each transaction is a dictionary containing the keys `book_title` and `genre`. 2. Returns a dictionary where each key is a genre, and the corresponding value is the book title that appears most frequently in transactions of that genre. 3. If there are multiple books with the same highest frequency within a genre, return the lexicographically smallest book title. Constraints: * The length of the transactions list `t` will be between 1 and 10^4. * Each dictionary in the transactions list will have the `book_title` (string) and `genre` (string). Function Signature: ```python def most_frequent_books_by_genre(transactions: List[Dict[str, str]]) -> Dict[str, str]: pass ``` Input: * `transactions`: A list of dictionaries where each dictionary contains: - `book_title`: A string representing the title of the book. - `genre`: A string representing the genre of the book. Output: * A dictionary where the keys are genres and the values are the most frequently purchased book titles for each genre. Performance Requirements: * The implementation should efficiently count and compare book frequencies to handle large input sizes. Example: ```python transactions = [ {\\"book_title\\": \\"Book A\\", \\"genre\\": \\"Fantasy\\"}, {\\"book_title\\": \\"Book B\\", \\"genre\\": \\"Fantasy\\"}, {\\"book_title\\": \\"Book A\\", \\"genre\\": \\"Fantasy\\"}, {\\"book_title\\": \\"Book C\\", \\"genre\\": \\"Science Fiction\\"}, {\\"book_title\\": \\"Book D\\", \\"genre\\": \\"Science Fiction\\"}, {\\"book_title\\": \\"Book C\\", \\"genre\\": \\"Science Fiction\\"}, {\\"book_title\\": \\"Book C\\", \\"genre\\": \\"Science Fiction\\"}, {\\"book_title\\": \\"Book E\\", \\"genre\\": \\"Fantasy\\"}, ] result = most_frequent_books_by_genre(transactions) print(result) ``` Expected Output: ```python { \'Fantasy\': \'Book A\', \'Science Fiction\': \'Book C\' } ``` Note: * Assume that the `transactions` input will always contain valid dictionaries with the required keys. * Focus on optimizing the function to handle large datasets efficiently. * Ensure the function handles edge cases, such as genres with only one book, and books with equal highest frequencies.","solution":"from collections import defaultdict, Counter from typing import List, Dict def most_frequent_books_by_genre(transactions: List[Dict[str, str]]) -> Dict[str, str]: genre_books = defaultdict(list) # Group books by genre for transaction in transactions: genre_books[transaction[\'genre\']].append(transaction[\'book_title\']) result = {} # For each genre, count the frequencies of each book and determine the most frequent one for genre, books in genre_books.items(): book_counter = Counter(books) # Find the most frequent book with a preference for lexicographically smaller book titles on ties most_frequent_book = min(book_counter.keys(), key=lambda x: (-book_counter[x], x)) result[genre] = most_frequent_book return result"},{"question":"# Coding Question Objective Write a function `is_prime_number` to determine whether a given number is a prime number. A number is considered prime if it is greater than 1 and has no divisors other than 1 and itself. Function Signature ```python def is_prime_number(n: int) -> str: pass ``` Input * `n`: An integer representing the number to check. Output * A string \\"Prime\\" if the number is a prime number. * Otherwise, the string should be \\"Not Prime\\". Constraints * The function should raise a `ValueError` if the number is less than 1. Examples ```python >>> is_prime_number(11) \'Prime\' >>> is_prime_number(4) \'Not Prime\' >>> is_prime_number(17) \'Prime\' >>> is_prime_number(-3) Traceback (most recent call last): ... ValueError: Number must be greater than 0 >>> is_prime_number(1) Traceback (most recent call last): ... ValueError: Number must be greater than 0 ``` Additional Requirements * The function should aim for the most efficient time complexity, ideally O(sqrt(n)). * Ensure proper validation and raise an appropriate exception for numbers less than 1. * Consider edge cases and handle them effectively in the implementation. * Do not use any external libraries for the prime check; implement the logic yourself. This addition adheres to the original question set guidelines, maintaining consistency in style, length, difficulty level, and topic alignment while introducing a unique and related problem.","solution":"def is_prime_number(n: int) -> str: Determine if the given number is a prime. Return \\"Prime\\" if it is a prime number, otherwise return \\"Not Prime\\". Raise ValueError if the number is less than 1. Parameters: n (int): The number to check. Returns: str: \\"Prime\\" if the number is a prime, \\"Not Prime\\" otherwise. if n < 1: raise ValueError(\\"Number must be greater than 0\\") if n == 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"# Coding Assessment Question Background: You are given an array of integers where each number appears exactly three times, except for one number which appears exactly once. Your task is to find this unique number. Task: Write a function `findUniqueNumber(nums: List[int]) -> int` that returns the unique number from the array. Input: - A list of integers `nums` where each element appears exactly three times, except for one element which appears exactly once. Output: - An integer representing the unique number. Constraints: - The length of the list `nums` is in the range `[4, 10^4]`. - Each integer in the array is in the range `[-2^31, 2^31 - 1]`. Performance Requirements: - Your solution should aim for a time complexity of `O(N)`, where N is the number of elements in the array. - Space complexity should be `O(1)`. Example Usage: ```python # Example 1: nums = [2, 2, 3, 2] print(findUniqueNumber(nums)) # Output: 3 # Example 2: nums = [0, 1, 0, 1, 0, 1, 99] print(findUniqueNumber(nums)) # Output: 99 ``` Implementation: Based on the provided code snippet, implement the function following the structure and properties discussed.","solution":"from typing import List def findUniqueNumber(nums: List[int]) -> int: seen_once, seen_twice = 0, 0 for num in nums: # First appearance: # add num to seen_once # don\'t add to seen_twice because of presence in seen_once # Second appearance: # remove num from seen_once # add num to seen_twice # Third appearance: # don\'t add to seen_once because of presence in seen_twice # remove num from seen_twice seen_once = ~seen_twice & (seen_once ^ num) seen_twice = ~seen_once & (seen_twice ^ num) return seen_once"},{"question":"# Task Create a function that generates a sequence of numbers according to the \\"Look-and-say\\" sequence. The Look-and-say sequence starts with the seed \\"1\\" and each subsequent number is generated by describing the digits of the previous number. # Requirements: - **Input**: An integer ( n ) that indicates the number of terms of the sequence to generate. - **Output**: A list of strings, where each string represents a term in the Look-and-say sequence. # Constraints: - ( 1 leq n leq 25 ) # Function Signature: ```python def look_and_say(n: int) -> List[str]: pass ``` # Example: ```python # Example 1 n = 5 # Expected output: [\\"1\\", \\"11\\", \\"21\\", \\"1211\\", \\"111221\\"] # Example 2 n = 3 # Expected output: [\\"1\\", \\"11\\", \\"21\\"] ``` # Implementation Notes: 1. Start with the seed \\"1\\". 2. Generate each subsequent term by reading the previous term and describing the count and value of consecutive digits. 3. The function should be efficient for the given constraints. # Test Cases: You should include test cases in your implementation to verify the correctness of your function. The function should pass provided example test cases as well as additional edge cases. ```python # Example Test Cases assert look_and_say(1) == [\\"1\\"] assert look_and_say(2) == [\\"1\\", \\"11\\"] assert look_and_say(3) == [\\"1\\", \\"11\\", \\"21\\"] assert look_and_say(5) == [\\"1\\", \\"11\\", \\"21\\", \\"1211\\", \\"111221\\"] assert look_and_say(7) == [\\"1\\", \\"11\\", \\"21\\", \\"1211\\", \\"111221\\", \\"312211\\", \\"13112221\\"] ```","solution":"def look_and_say(n: int) -> list[str]: Generates a list of the first n terms in the Look-and-say sequence. if n < 1: return [] result = [\\"1\\"] for _ in range(1, n): prev_term = result[-1] next_term = \\"\\" i = 0 while i < len(prev_term): count = 1 while i + 1 < len(prev_term) and prev_term[i] == prev_term[i + 1]: i += 1 count += 1 next_term += str(count) + prev_term[i] i += 1 result.append(next_term) return result"},{"question":"# Path Existence in Undirected Graph Objective: Implement a function to check if there exists a path between two given nodes in an undirected graph. # Background: An undirected graph is a set of `nodes` connected by edges, where each edge is bidirectional. A path between two nodes exists if there is a sequence of edges connecting the two nodes. Function Signature: ```python def does_path_exist(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool: pass ``` Expected Input and Output: * **Input**: - `n`: an integer representing the number of nodes in the graph (0 ≤ n ≤ 10^4). - `edges`: a list of tuples where each tuple (u, v) denotes an undirected edge between nodes `u` and `v`. - `start`: an integer representing the starting node. - `end`: an integer representing the ending node. * **Output**: `True` if there exists a path between the `start` and `end` nodes, otherwise `False`. Constraints and Assumptions: * Nodes are numbered from 0 to `n-1`. * The graph can be disconnected. * You should handle invalid inputs by raising a ValueError. * Ensure the solution is efficient and can handle large graphs within a reasonable time frame. Guiding Points: 1. **Edge Handling**: Ensure your function correctly handles cases where `start` or `end` nodes are out of the valid range by throwing appropriate errors. 2. **Graph Representation**: Use an adjacency list to represent the graph for efficient traversal. 3. **Search Algorithm**: Implement a Breadth-First Search (BFS) or Depth-First Search (DFS) to explore the graph and determine the path existence. 4. **Connected Components**: Consider edge cases where the graph is disconnected and handle accordingly. Implementation Example ```python from typing import List, Tuple def does_path_exist(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool: if not (0 <= start < n) or not (0 <= end < n): raise ValueError(\\"Start or end node is out of bounds\\") # Create an adjacency list for the graph adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Function to perform BFS def bfs(visited, graph, node): queue = [] visited[node] = True queue.append(node) while queue: current = queue.pop(0) for neighbour in graph[current]: if neighbour == end: return True if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) return False # Initialize visited list visited = [False] * n return bfs(visited, adj_list, start) # Example Usage: # does_path_exist(5, [(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) should return True # does_path_exist(5, [(0, 1), (1, 2)], 0, 4) should return False ``` Submit your solution with test cases to confirm the implementation is correct.","solution":"from typing import List, Tuple def does_path_exist(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> bool: if not (0 <= start < n) or not (0 <= end < n): raise ValueError(\\"Start or end node is out of bounds\\") if start == end: return True # Create an adjacency list for the graph adj_list = {i: [] for i in range(n)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Function to perform BFS def bfs(visited, graph, node): queue = [] visited[node] = True queue.append(node) while queue: current = queue.pop(0) for neighbour in graph[current]: if neighbour == end: return True if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) return False # Initialize visited list visited = [False] * n return bfs(visited, adj_list, start)"},{"question":"# Machine Learning Model Evaluation **Objective:** Implement the function `evaluate_model_performance(dataset: str, model_type: str) -> dict` which takes as input a dataset filename and the type of model to train, and returns the evaluation metrics of the model\'s performance. **Input:** * A string `dataset` representing the path to a CSV file. * A string `model_type` which can be either `\\"linear\\"` for Linear Regression or `\\"tree\\"` for Decision Tree Regressor. **Output:** * A dictionary containing the following evaluation metrics: * `\\"RMSE\\"` (Root Mean Squared Error) * `\\"R2\\"` (R-squared coefficient) **Constraints:** * The CSV file will always contain numeric columns and the last column will be the target variable for regression. * Use scikit-learn library for model training and evaluation. * Split the dataset into training (80%) and testing (20%) subsets. * Ensure reproducibility by using a fixed random seed (e.g., `random_state=42`). **Context:** You are tasked with evaluating different machine learning models to determine which performs better on a given dataset. This involves training the models, making predictions, and computing the evaluation metrics. **Requirements:** 1. Read the dataset from the specified CSV file. 2. Split the data into features (X) and target (y), then further split into training and testing sets. 3. Based on the `model_type` parameter, train the appropriate regression model. 4. Evaluate the model on the testing set and compute the RMSE and R-squared metrics. 5. Return the evaluation metrics in a dictionary. **Example Usage:** ```python metrics = evaluate_model_performance(\\"data/housing.csv\\", \\"linear\\") print(metrics) ``` Expected output could be: ```python { \\"RMSE\\": 2.456, \\"R2\\": 0.789 } ``` Ensure the solution handles any potential issues gracefully, such as missing files or incorrect model types.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.tree import DecisionTreeRegressor from sklearn.metrics import mean_squared_error, r2_score import numpy as np def evaluate_model_performance(dataset: str, model_type: str) -> dict: Evaluates the performance of a specified model on a given dataset. Parameters: - dataset: str, path to the CSV file containing the data - model_type: str, \\"linear\\" for Linear Regression or \\"tree\\" for Decision Tree Regressor Returns: - dict: Dictionary containing RMSE and R2 metrics # Load dataset data = pd.read_csv(dataset) # Split the data into features (X) and target (y) X = data.iloc[:, :-1] y = data.iloc[:, -1] # Split into training and test sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize model if model_type == \\"linear\\": model = LinearRegression() elif model_type == \\"tree\\": model = DecisionTreeRegressor(random_state=42) else: raise ValueError(\\"Unsupported model type. Use \'linear\' or \'tree\'.\\") # Train the model model.fit(X_train, y_train) # Make predictions y_pred = model.predict(X_test) # Calculate evaluation metrics rmse = np.sqrt(mean_squared_error(y_test, y_pred)) r2 = r2_score(y_test, y_pred) # Return the metrics return {\\"RMSE\\": rmse, \\"R2\\": r2}"},{"question":"**Problem Statement**: You are given a string containing only three types of characters: \'(\', \')\', and \'*\'. Your task is to determine if the string is balanced. The string is considered balanced if: 1. Any left parenthesis \'(\' has a corresponding right parenthesis \')\'. 2. The number of left and right parentheses are balanced, considering that the \'*\' character can be treated as either \'(\', \')\', or an empty string. **Function Signature**: ```python def is_balanced_string(s: str) -> bool: ``` **Inputs**: - `s`: A string containing characters \'(\', \')\', and \'*\'. The length of the string will be between 0 and 10^5. **Outputs**: - Return a boolean value, `True` if the string is balanced, otherwise `False`. **Constraints**: - The string will only contain the characters \'(\', \')\', and \'*\'. - Aim to solve the problem with O(n) time complexity and efficient space complexity. **Scenario**: Imagine you are building a text editor that helps software developers by validating strings of code containing various types of parentheses and placeholders. You need to ensure the provided string of parentheses can form balanced pairs considering the flexibility of \'*\' character. **Examples**: ```python >>> is_balanced_string(\\"(*)\\") True >>> is_balanced_string(\\"(*))\\") True >>> is_balanced_string(\\"((*\\") False >>> is_balanced_string(\\"()\\") True >>> is_balanced_string(\\"**(()\\") False ``` **Requirements**: - Treat the \'*\' character as either \'(\' or \')\' or an empty string to help balance the parentheses. - Utilize an efficient algorithm to handle large input sizes within the given constraints.","solution":"def is_balanced_string(s: str) -> bool: Determine if the input string is balanced considering \'(\' as left parenthesis, \')\' as right parenthesis, and \'*\' as a wildcard that can be treated as \'(\', \')\', or empty. left_balance, right_balance = 0, 0 for char in s: if char == \'(\' or char == \'*\': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False for char in reversed(s): if char == \')\' or char == \'*\': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"# Question: You are working with a binary search tree (BST) that supports `insert`, `delete`, and `lookup` operations. However, you have encountered performance issues due to the tree\'s imbalance after multiple insertions and deletions. Your task is to remedy this by implementing a Self-Balancing Binary Search Tree (SBBST), specifically, an AVL Tree. An AVL Tree maintains its height balance by ensuring that the heights of the two child subtrees of any node differ by no more than one. If at any time they differ by more than one, rebalancing is performed through rotations. # Requirements: 1. **Implement an AVL Tree** with the following operations: - `insert(value: int) -> None`: Inserts a value into the tree while maintaining the balance. - `delete(value: int) -> None`: Deletes a value from the tree while maintaining the balance. - `lookup(value: int) -> bool`: Checks if a value exists in the tree. 2. Use appropriate AVL Tree rotations (single and double) to maintain balance after insertions and deletions. # Constraints: - The input integers will be in the range of -10^6 to 10^6. - The tree will contain at most 10^4 nodes. # Input Example: ```python # Sequence of operations operations = [ (\\"insert\\", 10), (\\"insert\\", 20), (\\"insert\\", 30), (\\"delete\\", 20), (\\"lookup\\", 30), (\\"lookup\\", 40) ] ``` # Expected Output: ```python # Result of lookup operations [True, False] ``` # Notes: - Upon `insert(30)`, the tree needs rebalancing, requiring a single rotation. - Upon `delete(20)`, the tree must adjust to maintain balance. # Implementation: Implement the AVL Tree class in Python, ensuring it correctly handles the balancing and performs the required operations efficiently.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AVLNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def lookup(self, key): return self._lookup(self.root, key) def _lookup(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._lookup(node.left, key) else: return self._lookup(node.right, key) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node): if not node: return 0 return node.height def _balance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"# Infix to Postfix Conversion Context: You are asked to implement a function that converts an infix expression (a normal arithmetic expression where operators are between operands) into a postfix expression (an expression where each operator follows its operands). This is useful for parsing and evaluating expressions in many computing applications. # Function: Infix to Postfix Write a function `infix_to_postfix(expression: str) -> str` that converts a given infix expression to its postfix form. The infix expression will only contain the operators `+`, `-`, `*`, `/`, parentheses `(`, `)`, and single-digit integers. Example: ```python >>> infix_to_postfix(\'3+4\') \'34+\' >>> infix_to_postfix(\'2*(3+4)\') \'234+*\' >>> infix_to_postfix(\'(1+2)*3\') \'12+3*\' >>> infix_to_postfix(\'1+(2*3)\') \'123*+\' >>> infix_to_postfix(\'7*(5+2)-((3+1)*4)\') \'752+*31+4*-\' ``` # Constraints: 1. The input expression is a valid infix expression and consists only of the characters `0-9`, `+`, `-`, `*`, `/`, `(`, and `)`. 2. No spaces appear in the input expression. 3. The postfix expression should be a string where each number and operator is consecutively concatenated without spaces. 4. Each single-digit integer operand in the input expression will be exactly one character long, without leading zeroes. # Note: - Use the standard precedence for operators: `*` and `/` have higher precedence than `+` and `-`. - Operators of the same precedence are left-associative. - Ensure that the function handles nested parentheses correctly. This additional question integrates seamlessly with the original set, maintaining consistency in style, tone, and complexity, while introducing a new but related concept of expression conversion and parsing within the realm of string processing and algorithms.","solution":"def infix_to_postfix(expression: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] operators = [] def has_higher_precedence(op1, op2): return precedence[op1] >= precedence[op2] for char in expression: if char.isdigit(): output.append(char) elif char in precedence: while (operators and operators[-1] != \'(\' and has_higher_precedence(operators[-1], char)): output.append(operators.pop()) operators.append(char) elif char == \'(\': operators.append(char) elif char == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return \'\'.join(output)"},{"question":"# Question: Combination Sum Context You are given an array of distinct integers and a target integer. Your task is to find all unique combinations in the array where the numbers sum to the target. Each number in the array may be used any number of times in the combination. Task * Implement a function `combination_sum(candidates: list[int], target: int) -> list[list[int]]` to find all unique combinations that sum up to the given target. * Each number in the `candidates` list can be used multiple times in the combination. * The combinations should not contain duplicate lists and each combination should be sorted in non-decreasing order. Input Format * A list of distinct integers `candidates` where (1 leq |candidates| leq 30) and (1 leq candidates[i] leq 200). * An integer `target` where (1 leq target leq 500). Output Format * A list of lists, where each inner list is a unique combination of numbers from the input list that sum to the target. Each combination should be sorted in non-decreasing order. Constraints * Each combination should be unique and the results should be returned in sorted order. Example ```python def combination_sum(candidates: list[int], target: int) -> list[list[int]]: # Your code here # Example usage assert sorted(combination_sum([2, 3, 6, 7], 7)) == sorted([[2, 2, 3], [7]]) assert sorted(combination_sum([2, 3, 5], 8)) == sorted([[2,2,2,2], [2,3,3], [3,5]]) ``` Notes * Use a backtracking approach to generate all possible combinations. * Avoid duplicate combinations by ensuring that each combination is added only once, and the elements in each combination appear in a non-decreasing order. * Consider edge cases such as an empty list of candidates or very large targets that cannot be reached with the given candidates.","solution":"def combination_sum(candidates, target): def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() result = [] candidates.sort() backtrack(target, [], 0) return result"},{"question":"**Context**: You are working as a software engineer at a company that requires you to encode and decode information securely. One common method of encoding is the Caesar cipher. Your task is to implement a modified version of the Caesar cipher that allows for both encoding and decoding of text with a given shift value. **Coding Task**: Write a function named `caesar_cipher` that takes three parameters: * `text` (a string, the text to be encoded/decoded), * `shift` (an integer, the number of positions each character in the text should be shifted), * `encode` (a boolean, indicating whether to encode or decode the given text). Your function should return the encoded or decoded version of the `text` based on the value of the `encode` parameter. * If `encode` is True, the function should encode the text by shifting characters forward by the `shift` value. * If `encode` is False, the function should decode the text by shifting characters backward by the `shift` value. # Input * The function will be called as: `caesar_cipher(text: str, shift: int, encode: bool) -> str` * `text` (a string): The text to encode or decode (1 ≤ len(text) ≤ 10^6) * `shift` (an integer): The number of positions to shift (0 ≤ shift ≤ 25) * `encode` (a boolean): A boolean indicating whether to encode (True) or decode (False) the text. # Output * Return the encoded or decoded version of the input `text` as a string. # Constraints * Only shift alphabetic characters (both lowercase and uppercase). * Non-alphabetic characters should remain unchanged in the output. * Ensure the solution performs efficiently even for large text lengths. # Example ```python def caesar_cipher(text: str, shift: int, encode: bool) -> str: # Your implementation here # Example usage print(caesar_cipher(\\"Hello, World!\\", 3, True)) # Output: \\"Khoor, Zruog!\\" print(caesar_cipher(\\"Khoor, Zruog!\\", 3, False)) # Output: \\"Hello, World!\\" ``` # Explanation * In the first example, encoding \\"Hello, World!\\" with a shift of 3 results in \\"Khoor, Zruog!\\". * In the second example, decoding \\"Khoor, Zruog!\\" with the same shift of 3 returns it back to \\"Hello, World!\\".","solution":"def caesar_cipher(text, shift, encode): def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) else: return c result = [] for char in text: if encode: result.append(shift_char(char, shift)) else: result.append(shift_char(char, -shift)) return \'\'.join(result) # Example usage print(caesar_cipher(\\"Hello, World!\\", 3, True)) # Output: \\"Khoor, Zruog!\\" print(caesar_cipher(\\"Khoor, Zruog!\\", 3, False)) # Output: \\"Hello, World!\\""},{"question":"# Triangle Area Calculation Function Context The area of a triangle can be calculated using various methods based on the data provided. Common methods include using the base and height, or using the lengths of all three sides with Heron\'s formula. This problem requires a function to compute the area of a triangle given adequate input values. Problem Statement Create a function `compute_triangle_area` which will compute and return the area of a triangle given either the base and height or all three sides of the triangle. The function should properly handle invalid inputs and raise appropriate exceptions when necessary. Function Signature ```python def compute_triangle_area( base: float = None, height: float = None, side1: float = None, side2: float = None, side3: float = None ) -> float: ``` Input - `base`: (float, optional) The base length of the triangle. - `height`: (float, optional) The height of the triangle from the base. - `side1`: (float, optional) The length of the first side of the triangle. - `side2`: (float, optional) The length of the second side of the triangle. - `side3`: (float, optional) The length of the third side of the triangle. Output - Returns the area of the triangle (float). Constraints - Either `base` and `height` should be provided, or all of `side1`, `side2`, and `side3`. - The values provided should be positive. - The values provided for `side1`, `side2`, and `side3` must adhere to the triangle inequality theorem (sum of any two sides must be greater than the third). Error Handling Raise a `ValueError` in case of: - Any parameter being provided with a non-positive value. - Inappropriate combination or number of parameters provided. - If the sides provided do not form a valid triangle according to the triangle inequality theorem. Examples ```python >>> compute_triangle_area(base=10, height=5) 25.0 >>> compute_triangle_area(side1=3, side2=4, side3=5) 6.0 >>> compute_triangle_area(base=10, height=-5) ValueError: All dimension values must be positive >>> compute_triangle_area(side1=1, side2=2, side3=10) ValueError: The provided side lengths do not form a valid triangle >>> compute_triangle_area(base=10, height=5, side1=3, side2=4, side3=5) ValueError: Provide either base and height or all three sides, not both ``` Explanation 1. **When base and height are provided**: The area should be computed as `0.5 * base * height`. 2. **When all three sides are provided**: The area should be computed using Heron\'s formula: [ text{Area} = sqrt{s(s - text{side1})(s - text{side2})(s - text{side3})} ] Where ( s ) is the semi-perimeter: [ s = frac{text{side1} + text{side2} + text{side3}}{2} ] 3. **Raise an error** if any input violates the constraints, including negative or zero inputs, invalid triangle sides, or conflicting input combinations.","solution":"import math def compute_triangle_area( base: float = None, height: float = None, side1: float = None, side2: float = None, side3: float = None ) -> float: # Validate input if (base is not None and height is not None) and (side1 is not None or side2 is not None or side3 is not None): raise ValueError(\\"Provide either base and height or all three sides, not both.\\") if base is not None and height is not None: if base <= 0 or height <= 0: raise ValueError(\\"All dimension values must be positive\\") return 0.5 * base * height if side1 is not None and side2 is not None and side3 is not None: if side1 <= 0 or side2 <= 0 or side3 <= 0: raise ValueError(\\"All dimension values must be positive\\") if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1: raise ValueError(\\"The provided side lengths do not form a valid triangle\\") s = (side1 + side2 + side3) / 2 area = math.sqrt(s * (s - side1) * (s - side2) * (s - side3)) return area raise ValueError(\\"Provide either base and height or all three sides.\\")"},{"question":"# Simulating Stock Prices Using Geometric Brownian Motion In this task, you are required to implement a simulation of stock prices using the Geometric Brownian Motion (GBM) model, which is a common method used in financial modeling to predict future stock prices based on historical volatility. Part 1: Stock Price Simulation Implement a function `simulate_stock_price` that simulates the price of a stock over a given number of days. Part 2: Calculate Expected Return Implement a function `calculate_expected_return` that calculates the expected return of the stock based on the simulated prices over multiple simulations. Function Signatures ```python def simulate_stock_price( initial_price: float, drift: float, volatility: float, days: int, simulations: int ) -> List[List[float]]: Simulates the stock price over a given number of days using Geometric Brownian Motion. Parameters: initial_price (float): The initial price of the stock. drift (float): The expected rate of return of the stock. volatility (float): The standard deviation of the stock\'s returns. days (int): The number of days to simulate. simulations (int): The number of simulation runs. Returns: List[List[float]]: A list containing lists of simulated stock prices for each simulation run. pass def calculate_expected_return( price_simulations: List[List[float]] ) -> float: Calculates the expected return of the stock based on the simulated prices. Parameters: price_simulations (List[List[float]]): A list containing lists of simulated stock prices for each simulation run. Returns: float: The calculated expected return of the stock. pass ``` # Constraints * `initial_price` should be a positive float. * `drift` and `volatility` should be floats. * `days` and `simulations` should be positive integers. # Example ```python # Simulate the stock price with an initial price of 100, 5% drift, 20% volatility, over 252 trading days (1 year), and 100 simulations. simulated_prices = simulate_stock_price(100, 0.05, 0.2, 252, 100) # Calculate the expected return based on the simulated prices. expected_return = calculate_expected_return(simulated_prices) print(expected_return) ``` # Requirements 1. Use appropriate libraries and tools for generating random variables and performing calculations (e.g., NumPy). 2. Apply the Geometric Brownian Motion formula: ( S_{t+1} = S_t times e^{(mu - 0.5sigma^2)Delta t + sigma sqrt{Delta t} Z} ), where ( Z ) is a random normal variable. 3. Ensure the functions handle edge cases gracefully, such as invalid input values. 4. Write clean, optimized, and well-documented code. This problem will test the candidate\'s understanding of stochastic processes, financial modeling, and implementation of mathematical models in code.","solution":"import numpy as np from typing import List def simulate_stock_price( initial_price: float, drift: float, volatility: float, days: int, simulations: int ) -> List[List[float]]: Simulates the stock price over a given number of days using Geometric Brownian Motion. Parameters: initial_price (float): The initial price of the stock. drift (float): The expected rate of return of the stock. volatility (float): The standard deviation of the stock\'s returns. days (int): The number of days to simulate. simulations (int): The number of simulation runs. Returns: List[List[float]]: A list containing lists of simulated stock prices for each simulation run. dt = 1 / days prices = [] for _ in range(simulations): price_path = [initial_price] for _ in range(1, days + 1): random_shock = np.random.normal() price = price_path[-1] * np.exp((drift - 0.5 * volatility**2) * dt + volatility * np.sqrt(dt) * random_shock) price_path.append(price) prices.append(price_path) return prices def calculate_expected_return( price_simulations: List[List[float]] ) -> float: Calculates the expected return of the stock based on the simulated prices. Parameters: price_simulations (List[List[float]]): A list containing lists of simulated stock prices for each simulation run. Returns: float: The calculated expected return of the stock. final_prices = [simulation[-1] for simulation in price_simulations] initial_price = price_simulations[0][0] expected_return = np.mean(final_prices) / initial_price - 1 return expected_return"},{"question":"# Coding Assessment Question Context Given a non-negative integer `num`, repeatedly add the digits of `num` until the result has only one digit. This process is known as finding the digital root of the number. Problem Statement Write a function `digital_root(num: int) -> int` that calculates the digital root of a given non-negative integer `num`. Function Signature ```python def digital_root(num: int) -> int: pass ``` Input - **num** (int): The non-negative integer for which the digital root is to be found. (0 <= num <= 10^9) Output - **int**: The single digit result from the repeated sum of digits of `num`. Example ```python assert digital_root(0) == 0 assert digital_root(16) == 7 assert digital_root(942) == 6 assert digital_root(132189) == 6 assert digital_root(493193) == 2 ``` Constraints 1. Your solution should efficiently calculate the result without unnecessary loops or excessive use of built-in Python operations. 2. Consider mathematical properties and approaches that can simplify the digit sum computation. Notes - For this problem, explore potential shortcuts using mathematical properties to make your solution more efficient. - Ensure thorough testing for edge cases such as the smallest and largest possible values for `num`.","solution":"def digital_root(num: int) -> int: Returns the digital root of a non-negative integer num. if num == 0: return 0 return 1 + (num - 1) % 9"},{"question":"# Objective Write a function `is_power_of_two` that determines if a given integer is a power of two. The function should return `True` if the input is a power of two, and `False` otherwise. # Input & Output * **Input**: A single integer `n`. * **Output**: A boolean value `True` if `n` is a power of two, otherwise `False`. # Constraints 1. The input integer `n` can be positive, negative, or zero. 2. Optimize the function to have O(1) time complexity and O(1) space complexity. 3. Do not use any library functions or predefined methods for direct power-of-two checks. # Example ```python # Example 1 # Input: 16 # Output: True # Example 2 # Input: 18 # Output: False # Example 3 # Input: -8 # Output: False # Example 4 # Input: 1 # Output: True ``` # Scenario Imagine you are building a software that needs to validate if users\' input numbers are powers of two for a specific feature to function correctly (e.g., memory allocation sizes in low-level programming). Implementing a custom `is_power_of_two` function would provide an essential validation step. # Function Signature ```python def is_power_of_two(n: int) -> bool: pass ```","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer is a power of two. Args: n (int): The input integer. Returns: bool: True if the input is a power of two, False otherwise. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"**Problem Statement:** You need to implement and test a Least Recently Used (LRU) Cache using a combination of `OrderedDict` from the `collections` module. The cache should have the following functionalities: 1. `__init__(self, capacity: int)`: Initializes the cache with a given capacity. Once the capacity is reached, the least recently used item should be removed to make space for a new item. 2. `get(self, key: Any) -> Any`: Retrieves the value associated with the key if the key exists in the cache and returns it. If the key does not exist, returns `-1`. 3. `put(self, key: Any, value: Any) -> None`: Sets or inserts the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. 4. `__repr__(self) -> str`: Returns a string representation of the cache\'s current state for debugging purposes. # Input and Output Format: * **Input**: * The `put` method takes two arguments: `key` (any non-null type) and `value` (any type). * The `get` method takes one argument: `key` (any non-null type). * **Output**: * The `put` method does not return any value. * The `get` method returns the value associated with the `key` if it exists, or `-1` if the `key` is not present. * The `__repr__` method returns a string representation of the cache. # Constraints: * Ensure the `get` and `put` operations have an average time complexity of `O(1)`. * Use the `OrderedDict` collection to maintain the order of elements based on usage. # Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 assert cache.get(3) == -1 # returns -1 (not found) cache.put(3, 3) # LRU key was 2, evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # LRU key was 1, evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Implement the `LRUCache` class in Python with the methods specified above. ```python from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: Any) -> Any: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: Any, value: Any) -> None: if key in self.cache: # Remove it so we can update its position self.cache.pop(key) elif len(self.cache) == self.capacity: # Remove the first (least recently used) item self.cache.popitem(last=False) self.cache[key] = value def __repr__(self) -> str: return str(self.cache) # Example usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 assert cache.get(3) == -1 cache.put(3, 3) assert cache.get(2) == -1 cache.put(4, 4) assert cache.get(1) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4 ```","solution":"from collections import OrderedDict from typing import Any class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a given capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: Any) -> Any: Retrieve the value associated with the key if the key exists in the cache. Return -1 if the key does not exist. if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: Any, value: Any) -> None: Set or insert the value if the key is not already present. When the cache reaches its capacity, invalidate the least recently used item before inserting the new item. if key in self.cache: self.cache.pop(key) elif len(self.cache) == self.capacity: self.cache.popitem(last=False) self.cache[key] = value def __repr__(self) -> str: Return a string representation of the cache\'s current state for debugging purposes. return str(self.cache)"},{"question":"# Reinforcement Learning for Simple Tic-Tac-Toe AI You are tasked with building a simplified reinforcement learning agent to play Tic-Tac-Toe. Your goal is to implement a Q-learning-based AI that can play Tic-Tac-Toe optimally against another player. The state of the board and the allowed actions form the agent\'s environment, and the agent learns a policy to win the game through exploration and exploitation. # Task **Method Signature**: ```python def train_tic_tac_toe_ai( episodes: int, learning_rate: float, discount_factor: float, exploration_rate: float, exploration_decay: float ) -> dict: ``` **Inputs**: 1. `episodes (int)`: The number of training episodes. 2. `learning_rate (float)`: The learning rate (α). 3. `discount_factor (float)`: The discount factor (γ). 4. `exploration_rate (float)`: The initial exploration rate (ε). 5. `exploration_decay (float)`: The rate at which exploration probability decays. **Outputs**: - **Returns**: A Q-table (`dict`) containing the state-action values after training. **Constraints**: - States can be represented as strings (e.g., \'XOXOX O\'). - Actions are represented by the index (0-8) of the move on the board. - Assume \'X\' is the AI and \'O\' is the opponent. # Example Usage ```python q_table = train_tic_tac_toe_ai( episodes=1000, learning_rate=0.1, discount_factor=0.95, exploration_rate=1.0, exploration_decay=0.999 ) # Print out a sample learned Q-value for a specific board state. print(q_table[\'XOXOX O\']) # Example State: The AI\'s Q-values for this scenario. ``` # Implementation Requirements - Initialize the Q-table to store state-action values. - Implement the Q-learning algorithm to update the Q-table with the Bellman equation. - Simulate Tic-Tac-Toe games where the AI plays both X and O to learn from varying situations. - Ensure the AI can handle exploration (random moves) and exploitation (greedy moves). - Include mechanisms for the exploration rate to decay over time to transition the AI from exploration to exploitation. - Provide comprehensive testing to validate that the AI improves over episodes and can perform optimally. This task will test your understanding of reinforcement learning concepts and your ability to implement a learning agent using Q-learning techniques.","solution":"import numpy as np import random def train_tic_tac_toe_ai(episodes, learning_rate, discount_factor, exploration_rate, exploration_decay): q_table = {} def get_board_string(board): return \'\'.join(board) def get_possible_actions(board): return [i for i, cell in enumerate(board) if cell == \' \'] def choose_action(board, exploration_rate): state_str = get_board_string(board) if state_str not in q_table: q_table[state_str] = np.zeros(9) if random.uniform(0, 1) < exploration_rate: return random.choice(get_possible_actions(board)) else: possible_actions = get_possible_actions(board) q_values = q_table[state_str][possible_actions] max_q_value = np.max(q_values) max_q_actions = [action for action in possible_actions if q_table[state_str][action] == max_q_value] return random.choice(max_q_actions) def update_q_table(board, action, reward, next_board, learning_rate, discount_factor): state_str = get_board_string(board) next_state_str = get_board_string(next_board) if state_str not in q_table: q_table[state_str] = np.zeros(9) if next_state_str not in q_table: q_table[next_state_str] = np.zeros(9) best_next_action = np.argmax(q_table[next_state_str]) td_target = reward + discount_factor * q_table[next_state_str][best_next_action] td_error = td_target - q_table[state_str][action] q_table[state_str][action] += learning_rate * td_error def switch_player(player): return \'O\' if player == \'X\' else \'X\' def check_winner(board): winning_combinations = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], # rows [0, 3, 6], [1, 4, 7], [2, 5, 8], # columns [0, 4, 8], [2, 4, 6] # diagonals ] for combo in winning_combinations: if board[combo[0]] == board[combo[1]] == board[combo[2]] != \' \': return board[combo[0]] if \' \' not in board: return \'Draw\' return None def simulate_game(learning_rate, discount_factor, exploration_rate): board = [\' \'] * 9 current_player = \'X\' while True: action = choose_action(board, exploration_rate) board[action] = current_player winner = check_winner(board) if winner: reward = 1 if winner == \'X\' else -1 if winner == \'O\' else 0 update_q_table(board, action, reward, board, learning_rate, discount_factor) return next_board = board.copy() next_board[action] = current_player update_q_table(board, action, 0, next_board, learning_rate, discount_factor) current_player = switch_player(current_player) if current_player == \'O\': next_action = random.choice(get_possible_actions(board)) board[next_action] = current_player current_player = switch_player(current_player) winner = check_winner(board) if winner: reward = 1 if winner == \'X\' else -1 if winner == \'O\' else 0 update_q_table(board, action, reward, board, learning_rate, discount_factor) return for episode in range(episodes): simulate_game(learning_rate, discount_factor, exploration_rate) exploration_rate *= exploration_decay return q_table"},{"question":"# Coding Assessment Question Context You need to solve a problem that involves finding the longest substring without repeating characters in a given string. This problem tests your ability to effectively use data structures to manage dependencies and constraints. Problem Statement Write a function `longest_unique_substring(s: str) -> int` that takes a string `s` and returns the length of the longest substring without repeating characters. Input * `s` (string): A string consisting of alphanumeric characters and spaces. Output * Returns an integer representing the length of the longest substring without repeating characters. Examples ```python >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\" \\") 1 >>> longest_unique_substring(\\"dvdf\\") 3 ``` Constraints * The length of the input string `s` is between 1 and 10^5 characters. * The solution must be efficient, employing a sliding window or similar technique to ensure a linear time complexity.","solution":"def longest_unique_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. Parameters: s (str): Input string Returns: int: Length of the longest substring without repeating characters char_index_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# AVL Tree Insertion and Balance You are required to implement an AVL Tree, a self-balancing binary search tree, to test your understanding of advanced data structures and tree balancing algorithms in Python. Problem Statement Design and implement the following methods for an AVL Tree: 1. `insert(root, key)`: Inserts a new key into the AVL Tree while maintaining its balanced property. 2. `preorder_traversal(root)`: Returns a list of the keys in the tree following a preorder traversal. # Function Definitions: 1. **`insert(root, key)`**: - **Input**: The root node of an AVL Tree and an integer `key` to be inserted. - **Output**: The root node of the AVL Tree after the insertion and necessary balancing. - **Constraints**: Assume all keys in the tree are unique. 2. **`preorder_traversal(root)`**: - **Input**: The root node of an AVL Tree. - **Output**: A list of the keys from the tree in preorder traversal order. Example: ```python root = None keys = [10, 20, 30, 40, 50, 25] for key in keys: root = insert(root, key) preorder_keys = preorder_traversal(root) print(f\\"Preorder Traversal: {preorder_keys}\\") ``` Expected Output: - Preorder Traversal: [30, 20, 10, 25, 40, 50] # Additional Requirements: - Implement the necessary rotations (single and double) to maintain the AVL balance after each insertion. - Ensure the height balance property of AVL trees is maintained, with the balance factor of each node being -1, 0, or 1. - Handle edge cases like an empty tree for the initial insertion. - Optimize your implementation for both time and space efficiency. You may use helper classes and methods to define `AVLNode` and perform subtree rotations if needed.","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def insert(root, key): # Perform the normal BST insertion if not root: return AVLNode(key) if key < root.key: root.left = insert(root.left, key) else: root.right = insert(root.right, key) # Update the height of the ancestor node root.height = 1 + max(get_height(root.left), get_height(root.right)) # Get the balance factor to check whether this node became unbalanced balance = get_balance(root) # If this node becomes unbalanced, then we have 4 cases # Left Left Case if balance > 1 and key < root.left.key: return right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) # Return the (unchanged) node pointer return root def left_rotate(z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(get_height(z.left), get_height(z.right)) y.height = 1 + max(get_height(y.left), get_height(y.right)) # Return the new root return y def right_rotate(y): x = y.left T2 = x.right # Perform rotation x.right = y y.left = T2 # Update heights y.height = 1 + max(get_height(y.left), get_height(y.right)) x.height = 1 + max(get_height(x.left), get_height(x.right)) # Return the new root return x def get_height(node): if not node: return 0 return node.height def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def preorder_traversal(root): res = [] if root: res.append(root.key) res = res + preorder_traversal(root.left) res = res + preorder_traversal(root.right) return res"},{"question":"You are tasked with implementing a function to determine whether a string can be transformed into another string through a series of allowed rotations. Specifically, you will: 1. Check if by rotating the first string (s1) any number of times, it can become equivalent to the second string (s2). 2. Return `True` if such a rotation exists, and `False` otherwise. # Function Signature ```python def can_rotate_to_match(s1: str, s2: str) -> bool: Determine if one string can be rotated to match another string. ``` # Input - `s1` (str): The first string for comparison. - `s2` (str): The second string for comparison. # Output - Returns `True` if s1 can be rotated to become s2, `False` otherwise. # Example ```python can_rotate_to_match(\\"abcdef\\", \\"defabc\\") # Expected output: True can_rotate_to_match(\\"hello\\", \\"world\\") # Expected output: False ``` # Constraints * Both strings, `s1` and `s2`, will only contain lowercase English letters. * The length of each string will be in the range [1, 1000]. * You need to handle string manipulations efficiently to avoid excessive computation time. # Scenario Imagine you are developing a feature for a text editor where the user can rotate text blocks within a sentence. To implement this feature, you need to determine if a given block of text can be transformed into another block of text by rotating it. This function will help you validate if such transformations are possible.","solution":"def can_rotate_to_match(s1: str, s2: str) -> bool: Determine if one string can be rotated to match another string. if len(s1) != len(s2): return False # Double the first string doubled_s1 = s1 + s1 # Check if the second string is a substring of the doubled first string return s2 in doubled_s1"},{"question":"# Problem Statement You are tasked with developing a function that takes a list of integers and returns the list with duplicates removed while maintaining the original order of appearance. # Input and Output Format * **Input**: A list of integers `nums` with a length in the range `[0, 10^5]`. - Each integer in the list can range from `-10^6` to `10^6`. * **Output**: A list of integers that has all duplicate values removed, retaining the original order of the first occurrence. # Constraints - The input list may contain up to `100,000` integers. - Each integer can be as large as `1,000,000` in magnitude, either positive or negative. # Example ```python # Example input nums = [1, 2, 2, 1, 3, 4, 3] # Example output output = [1, 2, 3, 4] ``` # Task Implement the function `remove_duplicates(nums: List[int]) -> List[int]` to remove duplicates from the input list while preserving the order of their first appearance. ```python from typing import List def remove_duplicates(nums: List[int]) -> List[int]: # Implement your function here pass # Example usage nums = [1, 2, 2, 1, 3, 4, 3] print(remove_duplicates(nums)) # Output should be # [1, 2, 3, 4] ```","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of their first appearance. seen = set() result = [] for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Coding Challenge: Implementing a Custom Stack with Min Operations In this task, you will implement a custom stack data structure that supports the usual push and pop operations, along with a function to retrieve the minimum element in the stack efficiently. **Objective**: Implement a custom stack class that supports the following methods: 1. `push(x)`: Push element x onto the stack. 2. `pop()`: Remove the element on the top of the stack. 3. `top()`: Get the top element. 4. `get_min()`: Retrieve the minimum element in the stack. # Task **Class Signature**: ```python class MinStack: def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def get_min(self) -> int: pass ``` **Constraints**: - Each method should run in constant time, i.e., O(1) time complexity. - You can assume all operations are valid and will be called according to the problem requirements. # Example ```python # Create a new MinStack min_stack = MinStack() # Perform various operations min_stack.push(2) min_stack.push(0) min_stack.push(3) min_stack.push(0) # Get the minimum element (should be 0) assert min_stack.get_min() == 0 # Pop the top element min_stack.pop() # Get the top element (should be 3) assert min_stack.top() == 3 # Get the minimum element (should be 0 again) assert min_stack.get_min() == 0 # Pop the top element min_stack.pop() min_stack.pop() # Get the minimum element (should now be 2) assert min_stack.get_min() == 2 ``` # Implementation Requirements - You need to complete the `MinStack` class by implementing the methods `__init__`, `push`, `pop`, `top`, and `get_min`. - Ensure the solution has constant time complexity for the push, pop, top, and get_min operations. - Use appropriate data structures to maintain the current state of the stack and keep track of the minimum values.","solution":"class MinStack: def __init__(self): Initialize the stack data structure with two stacks: one for the actual stack and one to keep track of minimums. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto the stack. Also handle the min stack to maintain the current min. self.stack.append(x) # If min_stack is empty or x is smaller/equal to the top of min_stack, # push x onto min_stack as well. if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Remove the element on the top of the stack. Also handle the min stack accordingly. if self.stack: top_element = self.stack.pop() # If the popped element is the same as the top of the min_stack, # pop it from min_stack as well. if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element of the stack. if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"# Scenario You are provided with a list of student grades and their corresponding weights. Your objective is to write a function that calculates the weighted average of the grades for a given student. # Task Write a Python function, `calculate_weighted_average()`, that takes in a dictionary of student grades and their weights and returns the weighted average of the grades. # Requirements 1. **Function Signature**: ```python def calculate_weighted_average(grades: dict[str, tuple[float, float]]) -> float: ``` 2. **Input**: A dictionary where each key is a string representing the name of a subject, and the value is a tuple containing the grade (a float) and the weight (a float) associated with that grade. 3. **Output**: A float representing the weighted average of the grades, rounded to two decimal places. 4. **Constraints**: * The grades and weights will be non-negative. * The sum of the weights is guaranteed to be greater than zero. * The list of grades will contain at least one subject. # Example ```python grades = { \'Math\': (85.0, 0.3), \'English\': (90.0, 0.2), \'History\': (78.0, 0.5) } calculate_weighted_average(grades) ``` The weighted average would be calculated as: ``` (85.0 * 0.3) + (90.0 * 0.2) + (78.0 * 0.5) = 25.5 + 18.0 + 39.0 = 82.5 ``` Thus, the function should return: ``` 82.5 ``` # Additional Guidelines * You should ensure your function handles cases with varying lengths of the dictionary. * Your function should be efficient and handle potential edge cases, such as empty weights or subjects with weight zero. * Write additional test cases to verify the correctness of your implementation.","solution":"def calculate_weighted_average(grades): Calculates the weighted average of grades based on provided weights. Args: grades (dict): A dictionary where keys are the names of subjects and values are tuples containing the grade (float) and the weight (float) of each grade. Returns: float: The computed weighted average rounded to two decimal places. total_weight = 0.0 weighted_sum = 0.0 for subject, (grade, weight) in grades.items(): weighted_sum += grade * weight total_weight += weight weighted_average = weighted_sum / total_weight return round(weighted_average, 2)"},{"question":"# Context In computer science, binary search is a popular algorithm for finding an item in a sorted list. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. # Problem Statement Using the given `binary_search_recursive` function, you are required to implement a function `find_insert_position(arr, target)` that takes a sorted list `arr` and a target value `target`, and returns the index where the target should be inserted to maintain the sorted order if it\'s not already present in the list. If the target is present in the list, return its existing index. # Function Signature ```python def find_insert_position(arr: List[int], target: int) -> int: pass ``` # Input and Output * **Input**: - `arr` (List[int]): A sorted list of integers. - `target` (int): The target integer to find the position for. * **Output**: - `int`: The index position for the target integer. # Constraints * The length of `arr` can range from 0 to (10^4). * The integers in `arr` are in non-decreasing order. * The integer values in `arr` and `target` can be within the range ([-10^5, 10^5]). # Performance Requirements The function should be efficient, using an O(log n) approach. # Example ```python arr = [1, 3, 5, 6] target = 5 result = find_insert_position(arr, target) print(result) # Expected output: 2 arr = [1, 3, 5, 6] target = 2 result = find_insert_position(arr, target) print(result) # Expected output: 1 arr = [1, 3, 5, 6] target = 7 result = find_insert_position(arr, target) print(result) # Expected output: 4 arr = [1, 3, 5, 6] target = 0 result = find_insert_position(arr, target) print(result) # Expected output: 0 ``` # Implementation Notes 1. Utilize the binary search technique to minimize the number of comparisons. 2. Make sure to handle edge cases where the target is less than the smallest element or greater than the largest element in the list. 3. The main focus is to ensure the function performs efficiently even for larger input sizes.","solution":"from typing import List def find_insert_position(arr: List[int], target: int) -> int: This function returns the index where the target should be inserted to maintain the sorted order if it\'s not present in the list. If the target is present, it returns its index. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Coding Question You are designing a function to analyze a social media user\'s online activity by processing a series of timestamped events to identify their most active hour of the day. Your function should take an array of timestamps and return the hour (in 24-hour format) during which the user had the highest number of activities. Your task is to implement the following function: # Function Signature ```python from typing import List from collections import Counter def most_active_hour(timestamps: List[str]) -> int: pass ``` # Parameters - `timestamps` (List[str]): A list of timestamp strings formatted as \\"YYYY-MM-DD HH:MM:SS\\". # Return - Return an integer representing the hour (0 to 23) during which the user had the highest number of activities. If there is a tie, return the earliest hour. # Example ```python timestamps = [ \\"2023-04-01 02:15:30\\", \\"2023-04-01 02:45:30\\", \\"2023-04-01 14:05:20\\", \\"2023-04-02 14:12:00\\", \\"2023-04-02 23:59:59\\", \\"2023-04-03 23:50:00\\" ] # The most active hour is 2, since there are 2 activities recorded at hour 2 (02:15:30 and 02:45:30). print(most_active_hour(timestamps)) # Output: 2 ``` # Requirements 1. Efficiently parse the timestamps to extract the hour for each event. 2. Count the number of occurrences for each hour. 3. Determine the hour with the highest number of activities. 4. Handle potential ties by returning the earliest hour. # Constraints - The input list may contain at most 100,000 timestamps. - Timestamps are guaranteed to be valid and properly formatted. Ensure your solution efficiently handles large inputs and accurately identifies the most active hour based on the provided timestamps.","solution":"from typing import List from collections import Counter def most_active_hour(timestamps: List[str]) -> int: # Extract the hour part from each timestamp hours = [int(timestamp.split()[1].split(\':\')[0]) for timestamp in timestamps] # Use Counter to get the occurrences of each hour hour_counts = Counter(hours) # Find the hour with the maximum count most_active = max(hour_counts.items(), key=lambda x: (x[1], -x[0])) # Return the hour (the first element of the tuple) return most_active[0]"},{"question":"# Graph Traversal and Shortest Path Detection **Scenario/Context:** You are working on a navigation system that helps users find the shortest path between locations on a city map. Each location is a node and each direct route between two locations is an edge with a given distance. The system needs to determine the shortest path from a starting location to a destination using the Dijkstra algorithm. **Task:** Implement a function to compute the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. The function should validate its input and handle potential edge cases gracefully. **Function Signature:** ```python def dijkstra( graph: dict, start_node: str, end_node: str ) -> list: pass ``` # Input 1. **graph** (dict): A dictionary where keys are node names (strings) and values are dictionaries of connected nodes with the edge weights as values (floats). 2. **start_node** (str): The starting node for the path. 3. **end_node** (str): The destination node for the path. # Output - A list of node names representing the shortest path from the start node to the end node. # Constraints - All edge weights are positive floats. - The graph is connected, meaning there\'s at least one path between any two nodes. - Nodes are identifiable by unique strings. - Proper validation for edge cases, such as invalid nodes or empty graph. # Performance Requirements - Efficient computation considering the nature of the Dijkstra algorithm. # Example ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } start = \'A\' end = \'D\' # Expected Output: # [\'A\', \'B\', \'C\', \'D\'] print(dijkstra(graph, start, end)) ``` # Validation Implement proper validation checks for the inputs to ensure they meet the following criteria: - `graph` must be a dictionary with string keys and nested dictionaries as values, containing string keys and float values. - `start_node` and `end_node` must be strings that exist in the graph. - Edge weights must be positive floats. --- This question focuses on implementing a specific algorithm (Dijkstra\'s) within the context of graph traversal and shortest path detection, closely aligning with the complexity and style of the original question.","solution":"import heapq def dijkstra(graph, start_node, end_node): # Validate the input if not isinstance(graph, dict): raise ValueError(\\"The graph must be a dictionary.\\") if not isinstance(start_node, str) or not isinstance(end_node, str): raise ValueError(\\"The start node and end node must be strings.\\") if start_node not in graph or end_node not in graph: raise ValueError(\\"The start node and end node must exist in the graph.\\") for node, edges in graph.items(): if not isinstance(edges, dict): raise ValueError(\\"Each node\'s edges must be a dictionary.\\") for neighbor, weight in edges.items(): if not isinstance(neighbor, str) or not isinstance(weight, (int, float)) or weight <= 0: raise ValueError(\\"Edge weights must be positive floats.\\") # Initialization queue = [(0, start_node, [])] seen = set() min_dist = {start_node: 0} while queue: (cost, node, path) = heapq.heappop(queue) if node in seen: continue seen.add(node) path = path + [node] if node == end_node: return path for neighbor, weight in graph[node].items(): if neighbor in seen: continue prev = min_dist.get(neighbor, None) next = cost + weight if prev is None or next < prev: min_dist[neighbor] = next heapq.heappush(queue, (next, neighbor, path)) return [] # Example usage: graph_test = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } start_test = \'A\' end_test = \'D\' print(dijkstra(graph_test, start_test, end_test)) # Output: [\'A\', \'B\', \'C\', \'D\']"},{"question":"# Problem Description You are tasked with implementing a Priority Queue using a Min-Heap. The goal is to efficiently support basic priority queue operations while maintaining the properties of a Min-Heap. Implement a class `PriorityQueue` with methods to insert an element, extract the minimum element, and get the current minimum element without removing it. # Class Definition ```python class PriorityQueue: def __init__(self): pass def insert(self, value: int) -> None: pass def extract_min(self) -> int: pass def get_min(self) -> int: pass ``` # Methods `__init__(self)`: Initializes an empty priority queue. `insert(self, value: int) -> None`: Inserts an integer `value` into the priority queue. `extract_min(self) -> int`: Removes and returns the smallest element from the priority queue. If the queue is empty, it should raise an appropriate exception. `get_min(self) -> int`: Returns the smallest element without removing it from the priority queue. If the queue is empty, it should raise an appropriate exception. # Constraints * Each method should handle up to 10^5 operations efficiently. * Assume all integer values for `insert` are within the range [−10^9, 10^9]. * Methods should have an average time complexity of O(log N). # Examples ```python pq = PriorityQueue() pq.insert(5) pq.insert(3) pq.insert(10) assert pq.get_min() == 3 assert pq.extract_min() == 3 assert pq.get_min() == 5 pq.insert(1) assert pq.get_min() == 1 assert pq.extract_min() == 1 assert pq.extract_min() == 5 assert pq.extract_min() == 10 ``` # Notes * Ensure the internal data structure maintains the Min-Heap properties after each operation. * Consider using an array (list in Python) for the internal representation of the heap. * Raise an `IndexError` with an appropriate message if `extract_min` or `get_min` is called on an empty queue.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, value: int) -> None: heapq.heappush(self.heap, value) def extract_min(self) -> int: if not self.heap: raise IndexError(\\"extract_min from an empty priority queue\\") return heapq.heappop(self.heap) def get_min(self) -> int: if not self.heap: raise IndexError(\\"get_min from an empty priority queue\\") return self.heap[0]"},{"question":"# Problem Statement: Implement a function to perform an in-order traversal of a binary search tree (BST) and return the kth smallest element. A binary search tree is a binary tree where the left subtree of a node contains values less than or equal to the node\'s value, and the right subtree contains values greater than the node\'s value. # Function Signature: ```python def kth_smallest_element_in_bst(tree: dict, k: int) -> int: pass ``` # Input: - `tree`: A dictionary representing a binary tree. The keys are integers representing the node values, and each value is a tuple of two integers (left_child, right_child), representing the left and right children of the node, respectively. A child that does not exist is represented by `None`. - `k`: An integer representing the 1-based index of the smallest element to find. # Output: - Returns an integer which is the kth smallest element in the BST. # Constraints: - `tree` will always represent a valid binary search tree. - Vertices are represented as non-negative integers. - The input tree may have zero nodes (an empty dictionary). - 1 ≤ k ≤ number of nodes in the tree. # Example: ```plaintext tree = { 5: (3, 6), 3: (2, 4), 6: (None, None), 2: (1, None), 4: (None, None), 1: (None, None) } k = 3 kth_smallest_element_in_bst(tree, k) # Output: 3 ``` # Explanation: An in-order traversal of the given BST `[1, 2, 3, 4, 5, 6]` places the elements in ascending order. Therefore, the 3rd smallest element is `3`. # Other Considerations: - Ensure the function can handle edge cases like an empty tree or very small trees with just one node.","solution":"def kth_smallest_element_in_bst(tree: dict, k: int) -> int: Returns the kth smallest element in a Binary Search Tree (BST). Parameters: - tree (dict): A dictionary representing the BST. - k (int): The 1-based index of the smallest element to find. Returns: - int: The kth smallest element in the BST. def in_order_traversal(node): if node is not None: in_order_traversal(tree[node][0]) # Traverse the left subtree in_order_list.append(node) # Visit the node in_order_traversal(tree[node][1]) # Traverse the right subtree in_order_list = [] if tree: root = next(iter(tree)) # Get an arbitrary start point for the traversal else: return None # If the tree is empty in_order_traversal(root) return in_order_list[k - 1] # k is 1-based, so adjust index by -1"},{"question":"# Question Title: Connected Components in an Undirected Graph **Objective**: Write a function to find all the connected components in an undirected graph. A connected component is a maximal set of nodes such that each pair of nodes is either directly connected or connected through a series of nodes. **Function Signature**: ```python def connected_components(edges: List[Tuple[int, int]], num_nodes: int) -> List[List[int]]: pass ``` **Input**: 1. `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents an undirected edge between two nodes. 2. `num_nodes` (int): Total number of nodes in the graph, labeled from 0 to `num_nodes - 1`. **Output**: 1. `List[List[int]]`: A list of connected components, where each component is represented as a list of node labels. The nodes in each component should be sorted in ascending order. The overall list should be sorted in ascending order based on the first node of each component. **Constraints**: - 1 <= num_nodes <= 1000 - 0 <= len(edges) <= 5000 - No self-loops or parallel edges. **Example**: ```python >>> connected_components([(0, 1), (1, 2), (3, 4)], 5) [[0, 1, 2], [3, 4]] >>> connected_components([(0, 1), (2, 3)], 4) [[0, 1], [2, 3]] >>> connected_components([], 4) [[0], [1], [2], [3]] >>> connected_components([(0, 1)], 2) [[0, 1]] ``` **Note**: - Handle cases where some nodes have no edges connecting them. - Ensure each node appears in exactly one component. - Use either Depth-First Search (DFS) or Breadth-First Search (BFS) to explore the graph. **Hint**: - Use an adjacency list to represent the graph. - Maintain a visited list to keep track of explored nodes and avoid cycles.","solution":"from typing import List, Tuple def connected_components(edges: List[Tuple[int, int]], num_nodes: int) -> List[List[int]]: # Create adjacency list representation of the graph adj_list = {i: [] for i in range(num_nodes)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize visited set and components list visited = [False] * num_nodes components = [] def dfs(node): stack = [node] component = [] while stack: current = stack.pop() if not visited[current]: visited[current] = True component.append(current) for neighbor in adj_list[current]: if not visited[neighbor]: stack.append(neighbor) return sorted(component) for node in range(num_nodes): if not visited[node]: component = dfs(node) components.append(component) # Sort components by the first node of each component components.sort(key=lambda x: x[0]) return components"},{"question":"# List Even-Indexed Elements You are tasked with creating a function that extracts all elements from a list that are located at even indices (i.e., 0, 2, 4, ...). The function will return a new list consisting only of these elements. # Task Write a function `even_index_elements(lst: List[int]) -> List[int]` that: 1. Takes in a list of integers, `lst`. 2. Returns a new list containing all elements from the original list that are at even indices. **Function Signature:** ```python def even_index_elements(lst: List[int]) -> List[int] ``` Input - A list of integers `lst` where `0 <= len(lst) <= 10^4`. Output - A list of integers containing the elements at even indices from `lst`. Constraints - The function should work for lists of varying lengths, including an empty list. # Scenario For example: - `even_index_elements([10, 20, 30, 40, 50])` should return `[10, 30, 50]`, because the elements at indices 0, 2, and 4 are 10, 30, and 50, respectively. - `even_index_elements([5, 15, 25, 35, 45, 55, 65])` should return `[5, 25, 45, 65]`. Edge Cases - An empty list should return an empty list: `even_index_elements([])` should return `[]`. - A list with one element should return a list with that single element: `even_index_elements([99])` should return `[99]`. Performance Ensure that your implementation is efficient and handles large input sizes within reasonable time limits. # Example ```python print(even_index_elements([1, 2, 3, 4, 5, 6])) # [1, 3, 5] print(even_index_elements([9, 8, 7, 6, 5, 4, 3, 2])) # [9, 7, 5, 3] ``` Your task is to implement the `even_index_elements` function as defined above.","solution":"from typing import List def even_index_elements(lst: List[int]) -> List[int]: Returns a list of elements that are at even indices from the original list. Parameters: lst (List[int]): A list of integers. Returns: List[int]: A list of integers at even indices. return [lst[i] for i in range(0, len(lst), 2)]"},{"question":"# Challenging Coding Assessment Question Context Graph traversal algorithms are pivotal in solving numerous problems in computer science, ranging from route optimization to network analysis. You are to implement an algorithm that determines the shortest path in an unweighted graph using one of the fundamental traversal techniques. Task Implement a function `shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]` that finds the shortest path between two nodes in an unweighted graph. Use the following guidelines and constraints: Input and Output Formats: ```python def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: pass # Example usage: graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } print(shortest_path(graph, 0, 4)) # Output: [0, 2, 3, 4] print(shortest_path(graph, 1, 4)) # Output: [1, 3, 4] ``` Constraints: * The graph is represented as an adjacency list. * `0 <= start, end < len(graph)` * There is at least one path connecting the start and end nodes. * The graph can contain up to 10^3 nodes. Requirements: 1. **Breadth-First Search (BFS):** Utilize the BFS algorithm for finding the shortest path in an unweighted graph. 2. **Path Reconstruction:** Ensure the function not only finds the shortest path length but also reconstructs the exact path taken. 3. **Edge Case Handling:** Consider edge cases where the start and end nodes are the same or directly connected. Performance Goals: * Aim for O(V + E) time complexity, where V is the number of vertices and E is the number of edges. * Optimize space usage to efficiently handle graphs with up to 10^3 nodes. Implement the `shortest_path` function to meet the specifications, ensuring it performs optimally and handles all constraints effectively.","solution":"from collections import deque from typing import List, Dict def shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: Finds the shortest path in an unweighted graph using BFS. :param graph: A dictionary representing the adjacency list of the graph. :param start: The starting node. :param end: The ending node. :return: A list of nodes representing the shortest path from start to end. if start == end: return [start] queue = deque([start]) visited = set([start]) parent = {start: None} while queue: current = queue.popleft() for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) parent[neighbor] = current if neighbor == end: path = [] while neighbor is not None: path.append(neighbor) neighbor = parent[neighbor] path.reverse() return path return []"},{"question":"# Problem: Valid Parenthesis String Context Given a string that consists of the characters \'(\', \')\', \'*\', where \'*\' can represent either \'(\', \')\', or an empty string, you need to determine if the resulting string is valid. A string is considered valid if, by replacing any occurrence of \'*\' with \'(\', \')\', or an empty string, we can obtain a balanced parentheses string. A balanced parentheses string is one where open parentheses have corresponding closing parentheses in the correct order. Question Write a function `check_valid_parenthesis_string(s: str) -> bool` that takes a string `s` containing the characters \'(\', \')\', and \'*\' and determines if it can be converted into a valid parentheses string. Input - A string `s` containing the characters \'(\', \')\', and \'*\'. Output - Return a boolean value (`True` or `False`), indicating whether the string can be transformed into a valid parentheses string. Algorithm Requirements 1. Implement the function using a dynamic approach that ensures the string\'s validity through checks of different possibilities for the \'*\' characters. 2. Consider edge cases such as multiple consecutive \'*\' or mixed parentheses without sufficient balancing counterparts. Constraints - The length of the string `s` should be within the range of 1 to 100. Example ```python def check_valid_parenthesis_string(s: str) -> bool: pass # Example usage: print(check_valid_parenthesis_string(\\"()\\")) # Expected Output: True print(check_valid_parenthesis_string(\\"(*)\\")) # Expected Output: True print(check_valid_parenthesis_string(\\"(*))\\")) # Expected Output: True print(check_valid_parenthesis_string(\\")(\\")) # Expected Output: False ``` Performance Requirements - Ensure the algorithm runs efficiently within the input size constraints. - Optimize the logic to minimize unnecessary checks and early exits for obvious invalid cases.","solution":"def check_valid_parenthesis_string(s: str) -> bool: Determines if a given string with \'(\', \')\', and \'*\' characters can be transformed into a valid parentheses string. # Initialize two counters for the lowest and highest counts of open parentheses low = high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low -= 1 high -= 1 elif char == \'*\': low -= 1 high += 1 # Ensure low is never negative if low < 0: low = 0 # If high is negative, there are too many closing parentheses if high < 0: return False # If low is zero, it means we can form a valid string return low == 0"},{"question":"**Context**: In a popular voice command application, users can issue voice commands to execute various tasks. Each command is composed of multiple words, and the application needs to determine whether the issued command is valid based on predefined rules. A command is considered valid if it doesn\'t contain any sub-sequence of words that appear consecutively twice in the issued command. **Task**: Write a function `is_command_valid(command: str) -> bool` that determines if a given command is valid or not. **Function Specifications**: * **Input**: - `command`: A string representing the voice command, consisting of multiple words separated by single spaces. * **Output**: - Returns a boolean value: `True` if the command is valid, `False` otherwise. **Constraints**: * The `command` parameter must be a non-empty string. * Each word in the command consists of alphabetic characters only, and words are separated by single spaces. * The command must be checked for sub-sequences of words that appear consecutively twice. **Examples**: ```python >>> is_command_valid(\\"turn on the lights\\") True >>> is_command_valid(\\"turn on turn on the lights\\") False >>> is_command_valid(\\"set the temperature to twenty one degrees\\") True >>> is_command_valid(\\"play music play music from playlist\\") False ``` **Additional Considerations**: * Your implementation should handle edge cases such as: - Commands with a single word. - Commands with non-consecutive repetition (which should still be considered valid). * Consider performance implications for longer commands; ensure your approach efficiently handles checks for subsequences.","solution":"def is_command_valid(command: str) -> bool: Determines if a command is valid based on the presence of any sub-sequence of words that appears consecutively twice in the issued command. words = command.split() n = len(words) # Check for any subsequences that repeat consecutively for sz in range(1, n // 2 + 1): for i in range(n - 2 * sz + 1): if words[i:i + sz] == words[i + sz:i + 2 * sz]: return False return True"},{"question":"# Coding Assessment Question As a back-end developer, you are asked to improve a ride-sharing application by enhancing its trip calculation functionality and ensuring accurate trip cost estimations. Your task is to refactor and add new features to the existing trip calculation system to make it more comprehensive and user-friendly. Your tasks are: 1. **Refactor the `calculate_trip_cost` function:** - Update the function to accept additional parameters such as vehicle type, time of day, and surge pricing multiplier. - The function should now calculate the trip cost based on these inputs along with distance and base fare. 2. **Introduce multiple fuel options:** - Modify the function to accommodate different fuel types (e.g., gasoline, electric, hybrid) and adjust the cost calculation accordingly. - Ensure the function uses appropriate efficiency rates for each fuel type to calculate fuel costs. 3. **Enhance error handling:** - Implement robust error handling to manage scenarios such as invalid input data, missing parameters, and calculation errors. - Provide meaningful error messages and ensure the system logs these errors for further analysis. 4. **Extend the feature to estimate arrival time:** - Add a new function `estimate_arrival_time` that calculates the estimated time of arrival based on the distance, average speed of the vehicle, and current traffic conditions. - The function should account for rush hour, road closures, and other potential delays. **Input:** - Multiple integers and floats representing the parameters for distance, base fare, vehicle type, time of day, and surge pricing multiplier. - Strings representing fuel type and current traffic condition as either \\"normal\\", \\"heavy\\", or \\"light\\". **Output:** - A floating-point number representing the trip cost. - A time string indicating the estimated time of arrival. **Constraints:** - The fuel efficiency rates (in miles per gallon for gasoline vehicles, miles per kWh for electric vehicles, and a combination for hybrid vehicles) will be provided. - Surge pricing multiplication factor range: 1.0 to 3.0. - Average speeds: 60 mph for light traffic, 40 mph for normal traffic, and 25 mph for heavy traffic. - Ensure calculation handles edge cases such as zero distance and extreme surge multipliers. **Scenario Context:** Imagine an updated algorithm for a popular ride-sharing app that aims to provide users with transparent and detailed cost estimations while accommodating varying vehicle types and traffic conditions. The updated system should enhance the user\'s experience by delivering precise trip costs and realistic arrival times, even during peak hours or in unusual traffic scenarios.","solution":"def calculate_trip_cost(distance, base_fare, vehicle_type, time_of_day, surge_multiplier, fuel_type): Calculates the total cost of the trip based on the provided inputs. Parameters: distance (float): The distance of the trip in miles. base_fare (float): The base fare of the trip. vehicle_type (str): The type of vehicle (e.g., \'sedan\', \'suv\', \'truck\'). time_of_day (str): The time of day (e.g., \'day\', \'night\'). surge_multiplier (float): The surge pricing multiplier. fuel_type (str): The type of fuel (e.g., \'gasoline\', \'electric\', \'hybrid\'). Returns: float: The total cost of the trip. # Validate inputs if distance < 0: raise ValueError(\\"Distance cannot be negative\\") if base_fare < 0: raise ValueError(\\"Base fare cannot be negative\\") if surge_multiplier < 1.0 or surge_multiplier > 3.0: raise ValueError(\\"Surge multiplier must be between 1.0 and 3.0\\") if vehicle_type not in [\'sedan\', \'suv\', \'truck\']: raise ValueError(\\"Invalid vehicle type\\") if time_of_day not in [\'day\', \'night\']: raise ValueError(\\"Invalid time of day\\") if fuel_type not in [\'gasoline\', \'electric\', \'hybrid\']: raise ValueError(\\"Invalid fuel type\\") # Determine fuel efficiency rates fuel_efficiency = { \'gasoline\': 25, # miles per gallon \'electric\': 3, # miles per kWh \'hybrid\': 50 # miles per gallon equivalent } # Calculate cost per distance if fuel_type == \'gasoline\': fuel_cost_per_mile = 2.50 / fuel_efficiency[\'gasoline\'] elif fuel_type == \'electric\': fuel_cost_per_mile = 0.13 / fuel_efficiency[\'electric\'] elif fuel_type == \'hybrid\': fuel_cost_per_mile = 2.00 / fuel_efficiency[\'hybrid\'] # Calculate total cost trip_cost = base_fare + (distance * fuel_cost_per_mile * surge_multiplier) return trip_cost def estimate_arrival_time(distance, average_speed, traffic_condition): Estimates the arrival time based on the provided inputs. Parameters: distance (float): The distance of the trip in miles. average_speed (float): The average speed of the vehicle in mph. traffic_condition (str): The current traffic condition (\'normal\', \'heavy\', \'light\'). Returns: str: The estimated time of arrival. # Validate inputs if distance < 0: raise ValueError(\\"Distance cannot be negative\\") if average_speed <= 0: raise ValueError(\\"Average speed must be positive\\") if traffic_condition not in [\'normal\', \'heavy\', \'light\']: raise ValueError(\\"Invalid traffic condition\\") # Determine speed based on traffic condition speeds = { \'light\': 60, \'normal\': 40, \'heavy\': 25 } # Calculate travel time speed = speeds[traffic_condition] travel_time_hours = distance / speed return f\\"{int(travel_time_hours)}h {int((travel_time_hours * 60) % 60)}m\\""},{"question":"# Stock Price Fluctuations You work for a financial software company that provides real-time stock price information to clients. One of the functionalities you need to implement is the detection of significant price fluctuations within a given timeframe. You are tasked with writing a function that identifies and returns the maximum price drop within a given period. # Task: Write a function `max_price_drop(prices: List[int]) -> int` that takes as input a list of integers representing the stock prices recorded sequentially at regular intervals and returns the maximum drop in prices that occurred during that period. If no drop is observed, return 0. # Input: * `prices` - A list of integers where each element represents the stock price at a specific time interval. # Output: * An integer representing the maximum price drop observed during the time period. # Constraints: * The length of `prices` will be between `1` and `10,000`. * Each price in the list will be a positive integer in the range `[1, 100,000]`. # Example: ```python prices = [100, 80, 120, 90, 70, 110, 80, 60] output = max_price_drop(prices) # Expected output: 60 # Explanation: The maximum price drop occurs between prices[2] (120) and prices[7] (60). prices = [100, 105, 110, 115, 120] output = max_price_drop(prices) # Expected output: 0 # Explanation: There is no drop in prices during the period. ``` # Instructions: 1. Iterate through the list of prices to determine the highest price seen so far. 2. For each subsequent price, calculate the drop by subtracting it from the highest price observed up to that point. 3. Keep track of the maximum drop encountered and return it as the result. 4. Ensure the solution efficiently handles the input constraints.","solution":"def max_price_drop(prices): Returns the maximum price drop observed in the given list of stock prices. Parameters: prices (list of int): List of stock prices at regular intervals. Returns: int: Maximum price drop observed. if not prices or len(prices) < 2: return 0 max_price_so_far = prices[0] max_drop = 0 for price in prices: if price > max_price_so_far: max_price_so_far = price else: drop = max_price_so_far - price if drop > max_drop: max_drop = drop return max_drop"},{"question":"# Problem Statement You are developing a feature for an online bookstore that displays book titles in a consistent format. To do so, you need to implement a function that standardizes book titles by capitalizing the first letter of each word while converting all other letters to lowercase. Words are defined as any sequences of alphabetical characters, separated by spaces. # Function Signature ```python def format_book_title(title: str) -> str: ``` # Input - A single string `title`, representing the title of the book. - Length: 1-100 characters. - The string may contain alphabetical characters and spaces only. # Output - Return a string where each word in the original title is capitalized appropriately. - All other letters in each word should be converted to lowercase. # Constraints - The string will contain at least one word. - The input title will not contain leading or trailing spaces. - The input title will not contain multiple spaces between words. # Examples 1. `format_book_title(\\"the great gatsby\\")` should return `\\"The Great Gatsby\\"` 2. `format_book_title(\\"TO KILL a MOCKINGBIRD\\")` should return `\\"To Kill A Mockingbird\\"` 3. `format_book_title(\\"1984\\")` should return `\\"1984\\"` 4. `format_book_title(\\"a tale of two cities\\")` should return `\\"A Tale Of Two Cities\\"` 5. `format_book_title(\\"pride and prejudice\\")` should return `\\"Pride And Prejudice\\"` # Guidelines - Iterate through the title and capitalize each word properly. - Avoid using built-in functions that directly solve the problem. - Focus on understanding how to manipulate and format strings efficiently.","solution":"def format_book_title(title: str) -> str: Returns the book title with each word capitalized appropriately. words = title.split() formatted_words = [word.capitalize() for word in words] return \' \'.join(formatted_words)"},{"question":"# Coding Task: Implement a Dynamic Programming Solution for the Longest Increasing Subsequence Description You are given an unsorted array of integers. Your task is to implement a dynamic programming solution to find the length of the longest increasing subsequence (LIS) in the array. An increasing subsequence is one in which the elements are sorted in strictly increasing order, and you may skip elements in between. Requirements 1. Implement the `LongestIncreasingSubsequence` class. 2. The class should contain a method to compute the length of the LIS. 3. Optimize the solution to have a time complexity of O(n^2). Input Format - An unsorted list of integers. Output Format - An integer representing the length of the longest increasing subsequence. Constraints 1. The length of the input list (n) does not exceed 10^3. 2. The elements of the list are within the range of -10^9 to 10^9. Example ```python # Input nums = [10, 9, 2, 5, 3, 7, 101, 18] # Initializing LIS computation lis_computer = LongestIncreasingSubsequence(nums) # Computing the LIS length length = lis_computer.compute() print(length) # Expected Output: 4 ``` Implement the `LongestIncreasingSubsequence` class based on the given example above.","solution":"class LongestIncreasingSubsequence: def __init__(self, nums): self.nums = nums def compute(self): if not self.nums: return 0 n = len(self.nums) dp = [1] * n for i in range(1, n): for j in range(i): if self.nums[i] > self.nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"**Scenario**: You are given an array `brackets` where `brackets[i] = \'(\'` or `\')\'` which represents an expression consisting of only these two types of characters. Your task is to find the length of the longest valid parentheses substring. A valid parentheses substring is one where every opening bracket `(` has a corresponding closing bracket `)`. **Instructions**: - Implement the `Parentheses` class as described. - The `longest_valid_substring` method should compute and return the length of the longest valid parentheses substring. - The `is_valid` method should return `True` if a given substring `exp` is valid, otherwise `False`. **Function Signature**: The function signatures should be as follows: ```python class Parentheses: def __init__(self, brackets: List[str]): # Initialization code goes here def longest_valid_substring(self) -> int: # Algorithm code goes here def is_valid(self, exp: List[str]) -> bool: # Code to check if the expression is valid goes here ``` # Expected Input and Output **Input**: - `brackets` (List[str]): List of brackets, each of which is either \'(\' or \')\'. **Output**: - `longest_valid_substring` method should return the length of the longest valid parentheses substring. - `is_valid` method should return `True` or `False` indicating whether a given expression `exp` is valid. # Sample Input: ```python brackets = [\'(\', \')\', \'(\', \'(\', \')\', \')\'] p = Parentheses(brackets) print(p.longest_valid_substring()) # Output should be 6 print(p.is_valid([\'(\', \')\', \'(\', \')\'])) # Output should be True print(p.is_valid([\'(\', \'(\', \')\'])) # Output should be False ``` **Constraints**: - The length of `brackets` is within the range `[1, 10^5]`. **Performance Requirements**: The solution should work efficiently with a time complexity of O(n). **Note**: To evaluate the longest valid parentheses substring, you can use a dynamic approach or utilize a stack to keep track of the balance between opening and closing brackets while iterating through the `brackets` array.","solution":"from typing import List class Parentheses: def __init__(self, brackets: List[str]): self.brackets = brackets def longest_valid_substring(self) -> int: max_length = 0 stack = [-1] for i, char in enumerate(self.brackets): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length @staticmethod def is_valid(exp: List[str]) -> bool: balance = 0 for char in exp: if char == \'(\': balance += 1 else: balance -= 1 if balance < 0: return False return balance == 0"},{"question":"# Scenario: You are working on a home automation system where you need to manage and schedule appliances. One of the appliances has different modes of operation, and each mode lasts for a specific period. You need to determine if the total time required for all modes of an appliance doesn\'t exceed the daily operational limit for that appliance. # Task: Write a function `validate_appliance_schedule` that takes a list of integers representing the durations of different modes of an appliance and an integer representing the daily operational limit in minutes. The function should return `True` if the sum of the durations does not exceed the limit, and `False` otherwise. # Expected Function: ```python def validate_appliance_schedule(durations: list, limit: int) -> bool: ``` # Input Format: * A list of integers `durations` with length `n` where `0 <= n <= 10^4`, and each integer represents the duration of a mode in minutes. Each mode lasts between 1 and 10^3 minutes. * An integer `limit` where `0 <= limit <= 10^6` representing the daily operational time limit in minutes. # Output Format: * A boolean value `True` or `False`. # Constraints: * The function should handle up to the maximum constraints efficiently. * The sum of durations in the list should not exceed the limit of an integer. # Example: ```python >>> validate_appliance_schedule([30, 90, 45], 200) True >>> validate_appliance_schedule([60, 120, 150, 90], 300) False >>> validate_appliance_schedule([15, 15, 15], 45) True >>> validate_appliance_schedule([1000, 1000, 1000, 1000], 4000) True >>> validate_appliance_schedule([], 500) True ``` # Notes: 1. Your implementation should handle all edge cases including empty lists and zero limits. 2. Ensure thorough testing for accuracy and performance.","solution":"def validate_appliance_schedule(durations: list, limit: int) -> bool: Checks if the sum of durations of appliance modes does not exceed the daily operational limit. :param durations: List of integers representing the duration of each mode in minutes. :param limit: Integer representing the daily operational limit in minutes. :return: Boolean value indicating whether the total duration is within the limit. return sum(durations) <= limit"},{"question":"# Context You are developing a system for managing the reservations at a restaurant. The reservations are logged in the order they are made, and each reservation has an associated customer name and the number of people in the party. The restaurant has a policy that a reservation cannot be made for more than 6 people, and it prioritizes seating parties in the order of the reservations. # Task Write a Python function that takes a list of reservations, provides a summary of the total number of people to be served, and counts how many reservations have been made for groups of different sizes (1 through 6). # Function Signature ```python def reservation_summary(reservations: list[tuple[str, int]]) -> dict[str, int | dict[int, int]]: pass ``` # Input - `reservations` (list of tuples): Each tuple contains two elements: - a string representing the customer\'s name, - an integer between 1 and 6 representing the number of people in the party. # Output A dictionary with the following keys and values: - `\\"total_people\\"` (int): Total number of people expected based on the reservations. - `\\"group_sizes\\"` (dict of int: int): A dictionary where keys are integers from 1 to 6, representing the group sizes, and values are the counts of reservations for each group size. # Constraints - The length of `reservations` will be at least 1 and at most 1000. - Each group size will be between 1 and 6 inclusive. # Example ```python reservations = [(\\"Alice\\", 2), (\\"Bob\\", 4), (\\"Charlie\\", 1), (\\"David\\", 6), (\\"Eve\\", 3)] expected_output = { \\"total_people\\": 16, \\"group_sizes\\": { 1: 1, 2: 1, 3: 1, 4: 1, 5: 0, 6: 1 } } assert reservation_summary(reservations) == expected_output ```","solution":"def reservation_summary(reservations): Returns the summary of the total number of people to be served and counts how many reservations have been made for groups of different sizes (1 through 6). :param reservations: List of tuples containing customer\'s name and the number of people in the party. :type reservations: list of (str, int) :return: Dictionary with total people and group sizes. :rtype: dict[str, int | dict[int, int]] total_people = 0 group_sizes = {i: 0 for i in range(1, 7)} for name, people in reservations: total_people += people group_sizes[people] += 1 return { \\"total_people\\": total_people, \\"group_sizes\\": group_sizes }"},{"question":"# Problem Statement Create a function that finds the closest integer palindrome greater than the input integer. An integer palindrome is a number that remains the same when its digits are reversed, such as 121 or 1331. This function is often used in fields like digital signal processing, cryptography, and in applications requiring symmetrical data structures. # Requirements Function Signature ```python def next_palindrome(number: int) -> int: ``` Functionality Description - The function should accept a single parameter: * `number` (int): The input integer. - The function should return the smallest palindrome integer that is greater than the given `number`. # Constraints 1. The `number` must be a non-negative integer. 2. The input integer will be at most 10^9. # Error Handling 1. Raise a `ValueError` if `number` is not an integer. 2. Raise a `ValueError` if `number` is negative. # Performance Requirements - Implement the function such that it operates efficiently for the given constraint limits. - The function should handle edge cases, including when the input number is already a palindrome. # Example Usage ```python >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 >>> next_palindrome(121) 131 >>> next_palindrome(1001) 1111 >>> next_palindrome(0) 1 ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> next_palindrome(-10) Traceback (most recent call last): ... ValueError: Expected a non-negative integer, but got -10 >>> next_palindrome(\\"123\\") Traceback (most recent call last): ... ValueError: Expected an integer input, but got <class \'str\'> ``` Ensure the function not only meets the performance requirements but also adheres to the constraints and example usages provided. Properly handle edge cases and invalid inputs to ensure robustness of the implementation.","solution":"def next_palindrome(number: int) -> int: Finds the smallest palindrome integer greater than the input integer. Args: number (int): The input integer. Returns: int: The smallest palindrome integer greater than the given number. if not isinstance(number, int): raise ValueError(f\\"Expected an integer input, but got {type(number)}\\") if number < 0: raise ValueError(f\\"Expected a non-negative integer, but got {number}\\") def is_palindrome(n): return str(n) == str(n)[::-1] number += 1 while not is_palindrome(number): number += 1 return number"},{"question":"# Coding Question Objective Write a function `parse_log` that processes server log entries and returns the frequency of IP addresses making requests to the server. Function Signature ```python def parse_log(log_entries: list) -> dict: pass ``` Input * `log_entries`: A list of strings, where each string represents a log entry containing an IP address followed by the resource path accessed, separated by a space. Output * A dictionary where keys are IP addresses and values are the number of requests made by each IP address. Constraints * Each log entry string will be in the format \\"IP_address resource_path\\". * The IP address is a valid IPv4 address. * The list can contain up to 10,000 log entries. * Each IP address in the log entry should be counted only for valid requests. * Invalid log entries (ones not conforming to the format) should be ignored. Examples ```python >>> log_entries = [ \\"192.168.1.1 /home\\", \\"10.0.0.1 /api/data\\", \\"192.168.1.1 /about\\", \\"invalid_entry\\", \\"10.0.0.2 /api/info\\", \\"192.168.1.1 /contact\\" ] >>> parse_log(log_entries) { \'192.168.1.1\': 3, \'10.0.0.1\': 1, \'10.0.0.2\': 1 } ``` Additional Requirements * The function should be optimized to process the log entries efficiently with a time complexity of O(n). * The function should handle malformed log entries gracefully, ignoring them and not including them in the count. * Include error handling to manage empty or improperly formatted log entries while ensuring valid entries are counted accurately.","solution":"def parse_log(log_entries): Processes server log entries and returns the frequency of IP addresses making requests to the server. Parameters: log_entries (list of str): List of log entry strings, where each string is in the format \\"IP_address resource_path\\". Returns: dict: A dictionary where keys are IP addresses and values are the number of requests made by each IP address. from collections import defaultdict import re # Regex to validate IPv4 addresses ip_pattern = re.compile(r\'^d{1,3}(.d{1,3}){3}\') ip_count = defaultdict(int) for entry in log_entries: parts = entry.split() if len(parts) != 2: continue ip_address, _ = parts if ip_pattern.match(ip_address): ip_count[ip_address] += 1 return dict(ip_count)"},{"question":"# Scenario: You are developing a messaging system where users can send, retrieve, and manage their messages. Each user can have multiple messages in their inbox, and these messages should be organized efficiently to support operations like retrieval of the most recent message and deletion of specific messages. # Task: Implement a `UserInbox` class to manage the user\'s messages. Your implementation should support adding new messages, retrieving the most recent message, deleting messages by their IDs, and checking if the inbox is empty. # Requirements: 1. **Initialization**: Initialize the user inbox without any messages. 2. **Methods**: * `add_message(message_id, content)`: Add a new message with a unique `message_id` and its `content`. * `get_recent_message()`: Retrieve the most recent message\'s content. * `delete_message(message_id)`: Delete the message with the given `message_id`. * `is_empty()`: Check if the inbox has no messages. 3. **Constraints**: * Assume `message_id` is a unique positive integer for each message. * The system should efficiently handle insertion, deletion, and retrieval operations. * If `get_recent_message()` is called on an empty inbox, return `None`. * If `delete_message` is called with a non-existent `message_id`, it should do nothing. # Input Format: - For `add_message` method: * `message_id`: Integer ID of the message. * `content`: The content of the message (string). # Output Format: - `get_recent_message`: String representing the content of the most recent message. - `add_message`: No return value. - `delete_message`: No return value. - `is_empty`: Boolean indicating whether the inbox is empty. # Example: ```python # Initializing the user inbox inbox = UserInbox() # Adding messages inbox.add_message(1, \'Hello World\') inbox.add_message(2, \'Welcome to the system\') inbox.add_message(3, \'Your profile is created\') # Retrieve the most recent message print(inbox.get_recent_message()) # Expected output: \'Your profile is created\' # Check if the inbox is empty print(inbox.is_empty()) # Expected output: False # Delete a message inbox.delete_message(2) # Retrieve the most recent message again after deletion print(inbox.get_recent_message()) # Expected output: \'Your profile is created\' # Deleting all messages inbox.delete_message(1) inbox.delete_message(3) # Check if the inbox is empty again print(inbox.is_empty()) # Expected output: True ``` Implement the `UserInbox` class in Python with the above specifications.","solution":"class UserInbox: def __init__(self): self.messages = {} self.order = [] def add_message(self, message_id, content): self.messages[message_id] = content self.order.append(message_id) def get_recent_message(self): if not self.order: return None recent_message_id = self.order[-1] return self.messages[recent_message_id] def delete_message(self, message_id): if message_id in self.messages: del self.messages[message_id] self.order.remove(message_id) def is_empty(self): return not self.messages"},{"question":"# Binary Tree Path Sum Context: A binary tree is a hierarchical structure where each node has at most two children referred to as the left child and the right child. One common problem involving binary trees is finding certain paths from the root to the leaves. Problem Statement: Given a binary tree and a target sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given target sum. Input: - The input consists of: - A list of integers representing the binary tree in level order traversal (use `null` for no node). - An integer `targetSum` representing the desired path sum. Output: - Return `True` if such a path exists, otherwise return `False`. Constraints: - The number of nodes in the tree is in the range `[0, 5000]`. - `-1000 <= Node value <= 1000` - The `targetSum` is an integer in the range `[-10000, 10000]`. Example: **Input:** ``` [5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1] 22 ``` **Output:** ``` True ``` **Explanation:** The root-to-leaf path is `[5, 4, 11, 2]` which sums to 22. **Input:** ``` [1, 2, 3] 5 ``` **Output:** ``` False ``` **Explanation:** There is no root-to-leaf path that sums to 5. # Implementation Requirements: - You need to implement the main method `hasPathSum(root, targetSum)` that determines if such a path exists. - Handle diverse scenarios including empty trees, single node trees, and trees where multiple paths might need to be checked. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def hasPathSum(root, targetSum): if not root: return False if not root.left and not root.right: # if it\'s a leaf node return targetSum == root.val return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val) def build_tree(level_nodes): if not level_nodes: return None root = TreeNode(level_nodes[0]) queue = [root] i = 1 while i < len(level_nodes): current = queue.pop(0) if level_nodes[i] is not None: current.left = TreeNode(level_nodes[i]) queue.append(current.left) i += 1 if i < len(level_nodes) and level_nodes[i] is not None: current.right = TreeNode(level_nodes[i]) queue.append(current.right) i += 1 return root"},{"question":"```markdown # Problem Statement Write a function that calculates the minimum distance three insects can walk to meet at a point on a rectangular grid. # Function Signature ```python def minimum_meeting_distance(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> int: ``` # Input - **grid_size**: A tuple of two integers representing the number of rows and columns in the grid `(rows, cols)`. - **positions**: A list of three tuples, each representing the position `(row, col)` of an insect on the grid. # Output - Returns an integer representing the minimum total distance the three insects must walk to meet at a point on the grid. # Constraints - The grid size is in the range `[1, 1000]` for both rows and columns. - The positions of the insects are valid grid coordinates within the grid size. # Example ```python print(minimum_meeting_distance((5, 5), [(1, 2), (2, 3), (4, 1)])) # Output: 5 print(minimum_meeting_distance((3, 3), [(0, 0), (2, 2), (1, 1)])) # Output: 4 ``` # Requirements 1. The function should efficiently compute distances between the insects considering Manhattan distance on the grid. 2. Calculate the optimal meeting point within the grid by considering the median of the positions. 3. Compute and return the total walking distance for the three insects to meet at the optimal point. **Note**: Thoroughly consider edge cases and efficiency, especially for larger grids and varied insect positions, to ensure the function performs optimally. ```","solution":"from typing import List, Tuple def minimum_meeting_distance(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> int: Calculate the minimum total walked distance for three insects to meet at a point on the grid. rows, cols = zip(*positions) # To minimize walking distance, the optimal meeting point is at the median of the positions median_row = sorted(rows)[1] median_col = sorted(cols)[1] # Calculate total distance to this meeting point total_distance = sum(abs(r - median_row) + abs(c - median_col) for r, c in positions) return total_distance"},{"question":"# Coding Assessment Question: Dijkstra\'s Algorithm for Single-Source Shortest Path You are given a graph represented by an adjacency list and tasked with implementing Dijkstra\'s algorithm to find the shortest path from a given start node to all other nodes within the graph. # Specifications 1. **Function Name**: `dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]` 2. **Input**: - The function receives a dictionary representing the graph, where keys are node IDs, and values are lists of tuples representing the neighboring node ID and the edge weight. - An integer representing the start node. - The graph is guaranteed to have (1 leq text{number of nodes} leq 1000). - Edge weights are non-negative integers. 3. **Output**: - The function should return a dictionary where keys are node IDs and values are the shortest distances from the start node to the respective node. 4. **Constraints**: - The graph may contain cycles and multiple edges between nodes. - The graph is connected, with all nodes reachable from the start node. # Instructions 1. Implement the function using Dijkstra\'s algorithm. 2. Ensure an efficient handling of the priority queue to maintain the current shortest distances to each node. 3. Handle edge cases such as single-node graphs and nodes with no outgoing edges properly. # Example ```python from typing import Dict, List, Tuple import heapq # Consider using heapq for maintaining the priority queue def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: pass # Your code goes here # Examples graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 expected_output = { 0: 0, 1: 3, 2: 1, 3: 4 } print(dijkstra(graph, start)) # Should print: {0: 0, 1: 3, 2: 1, 3: 4} ``` # Evaluation Ensure your implementation correctly provides the expected shortest paths for various graph configurations and handles edge cases effectively. Provide clear explanation comments, and maintain code cleanliness and readability.","solution":"from typing import Dict, List, Tuple import heapq def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Implementation of Dijkstra\'s algorithm to find the shortest path from start node to all other nodes in the graph. Args: graph: Dict[int, List[Tuple[int, int]]] - Adjacency list representation of the graph. Keys are node IDs, and values are lists of tuples (neighbor, edge weight). start: int - The starting node ID. Returns: Dict[int, int] - The shortest distances from the start node to each node in the graph. # Priority queue to store the nodes to explore pq = [(0, start)] # Dictionary to store the shortest distances from the start node to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while pq: curr_dist, curr_node = heapq.heappop(pq) if curr_dist > distances[curr_node]: continue for neighbor, weight in graph[curr_node]: distance = curr_dist + weight # If found a shorter path to neighbor, update the neighbor\'s distance and push to queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Question: You are given a list of integers `numbers` and an integer `threshold`. Your task is to write a function `max_subarray_sum_under_threshold` that returns the maximum sum of any contiguous subarray whose sum is less than or equal to `threshold`. Function Signature: ```python def max_subarray_sum_under_threshold(threshold: int, numbers: list[int]) -> int: # your implementation here ``` Input: - `threshold`: An integer. - `numbers`: A list of integers. Output: - An integer representing the maximum sum of any contiguous subarray whose sum is less than or equal to `threshold`. - If no such subarray exists, return 0. Constraints: - The `threshold` could be any integer. - The `numbers` list can be empty. - Elements in `numbers` can be negative, zero, or positive integers. Examples: ```python >>> max_subarray_sum_under_threshold(7, [2, 3, 1, 2, 4, 3]) 7 >>> max_subarray_sum_under_threshold(7, [2, 3, -1, 2, 4, -3]) 6 >>> max_subarray_sum_under_threshold(10, [1, 2, 3, 4, 5]) 10 >>> max_subarray_sum_under_threshold(5, [1, -1, 2, 1, -1, 3]) 5 >>> max_subarray_sum_under_threshold(0, []) 0 >>> max_subarray_sum_under_threshold(6, [10, 20, 30]) 0 >>> max_subarray_sum_under_threshold(2, [1, 1, 1, 1, 1]) 2 >>> max_subarray_sum_under_threshold(-5, [-10, -20, -30]) -10 >>> max_subarray_sum_under_threshold(4, []) 0 >>> max_subarray_sum_under_threshold(3, [1, 2, 3]) 3 >>> max_subarray_sum_under_threshold(8, None) 0 >>> max_subarray_sum_under_threshold(2, \\"XYZ\\") Traceback (most recent call last): ... ValueError: numbers must be an iterable of integers ``` Constraints to Consider: - If `numbers` is `None` or not a valid iterable of integers, raise a ValueError with the message \\"numbers must be an iterable of integers\\". # Performance Requirements: - Your solution should run in linear time O(n), where n is the length of the input list `numbers`.","solution":"def max_subarray_sum_under_threshold(threshold: int, numbers: list[int]) -> int: if numbers is None or not isinstance(numbers, list) or not all(isinstance(i, int) for i in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") if len(numbers) == 0: return 0 max_sum = 0 current_sum = 0 for num in numbers: current_sum += num if current_sum > threshold: current_sum = 0 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement You are developing a function to evaluate passwords for a secure application. Your goal is to implement a function that checks whether a given password is both secure and valid based on the following criteria: - The password must be at least 8 characters long. - It must contain at least one uppercase letter (\'A\'-\'Z\'). - It must contain at least one lowercase letter (\'a\'-\'z\'). - It must contain at least one digit (\'0\'-\'9\'). - It must contain at least one special character from the set `!@#%^&*()-_+=<>?`. # Function Signature ```python def is_secure_password(password: str) -> bool: ``` # Input - A single string `password`, representing the password to be checked. - Valid length: 0-100 characters. # Output - Return `True` if the password meets all the criteria. - Return `False` otherwise. # Constraints - You may assume every password only contains printable ASCII characters. # Examples 1. `is_secure_password(\\"Password123!\\")` should return `True` 2. `is_secure_password(\\"Password\\")` should return `False` 3. `is_secure_password(\\"12345678\\")` should return `False` 4. `is_secure_password(\\"P@ssw0rd\\")` should return `True` 5. `is_secure_password(\\"short!\\")` should return `False` # Guidelines - Use regular expressions to define validation patterns. - Ensure the pattern matching is comprehensive, considering all specified criteria. - Optimize for accuracy and efficiency in the regex design.","solution":"import re def is_secure_password(password: str) -> bool: Checks if the given password is secure based on the following criteria: - At least 8 characters long. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from the set !@#%^&*()-_+=<>? Args: password (str): The password to be checked. Returns: bool: True if the password meets all criteria, False otherwise. if len(password) < 8: return False has_upper = re.search(r\'[A-Z]\', password) has_lower = re.search(r\'[a-z]\', password) has_digit = re.search(r\'[0-9]\', password) has_special = re.search(r\'[!@#%^&*()-_=+<>?]\', password) return bool(has_upper and has_lower and has_digit and has_special)"},{"question":"# Problem: Implement a Linked List Cycle Detection Algorithm **Context**: You are provided with a class `LinkedList` and a nested class `Node` representing a singly linked list. This linked list can potentially have a cycle, meaning that some node\'s `next` pointer points back to one of the previous nodes creating an infinite loop. Your task is to implement a method to detect if there is a cycle present in the linked list. **Problem Statement**: Extend the `LinkedList` class to include a method `has_cycle` which detects if the linked list contains a cycle. # Requirements * **Class Extension**: Extend the class `LinkedList`. * Add the ability to detect cycles. * **Function Implementation**: * `has_cycle() -> bool` * Output: - A boolean value, `True` if a cycle is detected, otherwise `False`. # Example ```python class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def append(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def create_cycle(self, pos): # This function is used to create a cycle in the linked list. if pos == -1: return cycle_start = self.head end_node = self.head while pos > 0 and cycle_start.next: cycle_start = cycle_start.next pos -= 1 while end_node.next: end_node = end_node.next end_node.next = cycle_start # Usage example: linked_list = LinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.create_cycle(1) # Create a cycle at position 1 result = linked_list.has_cycle() # should return True ``` # Constraints * You may assume the linked list has at most `10^4` nodes. * Aim for a solution with `O(n)` time complexity where `n` is the number of nodes in the linked list. * Do not modify the linked list structure during the check. **Note**: Consider using Floyd’s Cycle-Finding Algorithm, also known as the Tortoise and Hare Algorithm, to implement the cycle detection logic efficiently.","solution":"class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def append(self, value): new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def create_cycle(self, pos): # This function is used to create a cycle in the linked list. if pos == -1: return cycle_start = self.head end_node = self.head while pos > 0 and cycle_start.next: cycle_start = cycle_start.next pos -= 1 while end_node.next: end_node = end_node.next end_node.next = cycle_start def has_cycle(self) -> bool: slow_pointer = self.head fast_pointer = self.head while fast_pointer and fast_pointer.next: slow_pointer = slow_pointer.next fast_pointer = fast_pointer.next.next if slow_pointer == fast_pointer: return True return False"},{"question":"# Coding Assessment Question **Context**: You are tasked with analyzing a string of text and determining an encoded message within it. The encoding follows a specific pattern where words of a certain length are reversed, and all other words remain unchanged. The goal is to decode the message by identifying and reversing the appropriate words. **Task**: Write a function `decode_message(message: str, length_to_reverse: int) -> str` that: 1. Receives a string `message` comprising words separated by spaces. 2. Receives an integer `length_to_reverse` representing the length of the words that should be reversed. 3. Returns the decoded message with the specified words reversed. **Input**: - A string `message` of length up to 100,000 characters. - An integer `length_to_reverse` specifying the length of the words to reverse. **Output**: - A string representing the decoded message. **Constraints**: - The function should efficiently handle the maximum message length. - Only words of exactly `length_to_reverse` should be reversed. **Example**: ```python print(decode_message(\\"this is a secret message\\", 6)) # Output: \\"this is a terces message\\" print(decode_message(\\"coding is fun\\", 2)) # Output: \\"coding si fun\\" print(decode_message(\\"hello world\\", 5)) # Output: \\"olleh dlrow\\" ``` **Function Signature**: ```python def decode_message(message: str, length_to_reverse: int) -> str: pass ``` Ensure your function properly identifies words of the specified length and reverses their characters while leaving all other words unchanged.","solution":"def decode_message(message: str, length_to_reverse: int) -> str: Decodes the message by reversing words of the specified length. Parameters: message (str): The string of words separated by spaces. length_to_reverse (int): The length of words that should be reversed. Returns: str: The decoded message with appropriate words reversed. decoded_words = [] words = message.split() for word in words: if len(word) == length_to_reverse: decoded_words.append(word[::-1]) else: decoded_words.append(word) return \' \'.join(decoded_words)"},{"question":"# Question: Implement a Dynamic Programming Solution for Inventory Restocking Context: You are given an e-commerce system that needs to restock inventory of different items periodically. The system tracks daily sales of items and requires a strategy to determine the minimum number of restocking operations needed to meet demand, while minimizing warehouse storage costs. Task: Develop a dynamic programming solution to calculate the minimum restocking operations needed to ensure enough inventory is available each day to meet the sales demand. Specifications: 1. **Input**: - `daily_sales` : A list of integers where each integer represents the number of units sold each day. - `restock_operations` : A list of integers where each value represents the maximum number of units that can be restocked on that day. 2. **Output**: - An integer representing the minimum number of restocking operations needed to meet the daily sales demand. 3. **Constraints**: - Daily sales and restock values are non-negative integers. - There is no limit on inventory capacity, but operations should be kept to a minimum. - The algorithm should handle up to 10^5 days efficiently. Example Input: ```python daily_sales = [3, 7, 5, 6, 8] restock_operations = [10, 15, 7, 10, 10] ``` Example Output: ```python 4 ``` This output indicates that at least four restocking operations are needed to ensure the daily sales demand is met over the period. Instructions: 1. **Initialize State Variables**: Create a list to store the minimum restocking operations required for each day. 2. **Filling the DP Table**: Use dynamic programming to fill the table by comparing the required operations against the maximum restock values. 3. **Compute Minimum Restocks**: Iterate through the list and increment the restock count only when necessary. 4. **Testing**: Write at least 3 test cases to verify the solution, including edge cases such as zero sales or maximum daily sales. --- By following these instructions, you should implement a function that effectively uses dynamic programming to minimize restocking operations while ensuring that sales demand is met every day.","solution":"def min_restock_operations(daily_sales, restock_operations): n = len(daily_sales) if n == 0: return 0 # Inventory tracking inventory = 0 restock_count = 0 for i in range(n): if daily_sales[i] > inventory: restock_needed = daily_sales[i] - inventory inventory += restock_operations[i] restock_count += 1 # After restock, check if it covers sales inventory -= daily_sales[i] return restock_count"},{"question":"# String Manipulation and Pattern Matching As a software engineer, you are required to develop functions dealing with the manipulation and matching of strings. Task: Implement the following functions: 1. **Pattern Search**: Given a text string and a pattern string, print all starting indices where the pattern is found within the text. 2. **Longest Common Substring**: Given two strings, find and print the length and content of the longest common substring of both. 3. **String Rotation Check**: Determine if one string is a rotation of another string. 4. **Palindrome Check**: Check if the given string is a palindrome or not, ignoring spaces, punctuation, and case sensitivity. Specifications: * **Input Format**: - For Pattern Search: - Text string: `txt` - Pattern string: `pat` - For Longest Common Substring: - Two strings: `str1`, `str2` - For String Rotation Check: - Two strings: `str1`, `str2` - For Palindrome Check: - A single string: `s` * **Output Format**: - **Pattern Search**: List of starting indices. - **Longest Common Substring**: Length and content of the substring. - **String Rotation Check**: Boolean indicating if one string is a rotation of the other. - **Palindrome Check**: Boolean indicating if the string is a palindrome. * **Constraints**: - 1 ≤ length of any string ≤ 1000 Additional Information: 1. Assume all strings will be ASCII. 2. For pattern search, you may use any efficient algorithm such as KMP, Rabin-Karp, or a simple sliding window with substring comparison. 3. Ensure edge cases are considered, such as empty strings and strings with no common substrings. 4. Ignore case and non-alphanumeric characters for the palindrome check. Example: ```python Input for Pattern Search: Text: \\"abracadabra\\" Pattern: \\"abra\\" Output: Starting indices: [0, 7] Input for Longest Common Substring: String 1: \\"abcxyz\\" String 2: \\"xyzabc\\" Output: Length: 3 Substring: \\"abc\\" Input for String Rotation Check: String 1: \\"waterbottle\\" String 2: \\"erbottlewat\\" Output: Is Rotation: True Input for Palindrome Check: String: \\"A man, a plan, a canal, Panama\\" Output: Is Palindrome: True ``` This question focuses on string manipulation and pattern matching, presenting tasks that require an understanding of algorithms and efficient string handling techniques, aligning well with the complexity and scope of the existing sample questions.","solution":"import re def pattern_search(txt, pat): Returns a list of starting indices where the pattern is found within the text. indices = [] pat_len = len(pat) for i in range(len(txt) - pat_len + 1): if txt[i:i + pat_len] == pat: indices.append(i) return indices def longest_common_substring(str1, str2): Returns the length and content of the longest common substring of both strings. len1, len2 = len(str1), len(str2) max_length = 0 ending_index = len1 length = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if str1[i-1] == str2[j-1]: length[i][j] = length[i-1][j-1] + 1 if length[i][j] > max_length: max_length = length[i][j] ending_index = i return max_length, str1[ending_index - max_length: ending_index] def is_rotation(str1, str2): Checks if one string is a rotation of another. if len(str1) != len(str2): return False return str2 in str1 + str1 def is_palindrome(s): Checks if the given string is a palindrome, ignoring spaces, punctuation, and case sensitivity. filtered_s = re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() return filtered_s == filtered_s[::-1]"},{"question":"# Problem Description Implement a function to evaluate a mathematical expression given in the form of a string using the Shunting Yard algorithm for parsing and the Reverse Polish Notation (RPN) for evaluation. # Input and Output **Function Signature**: ```python def evaluate_expression(expression: str) -> float: pass ``` **Inputs**: * `expression` (str): A string containing a mathematical expression, which may include integers, parentheses, and the operators \'+\', \'-\', \'*\', and \'/\'. The expression will have spaces separating each token. **Outputs**: * Returns a float representing the evaluated result of the expression. # Constraints * The expression is guaranteed to be a valid mathematical expression. * Division by zero will not occur. * Operands and operators are separated by single spaces. * Operators and operands follow infix notation. # Example ```python expression = \\"3 + 5 * ( 2 / ( 3 - 1 ) )\\" result = evaluate_expression(expression) print(result) # Output should be 8.0 ``` # Task Implement the `evaluate_expression` function using the Shunting Yard algorithm to convert the infix expression to Reverse Polish Notation (RPN) and then evaluate the RPN to obtain the final result. Ensure proper handling and precedence of operators, as well as correct evaluation of the final RPN expression.","solution":"def evaluate_expression(expression: str) -> float: def shunting_yard(expression): precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} output = [] operators = [] tokens = expression.split() for token in tokens: if token.isdigit(): output.append(token) elif token in precedence: while (operators and operators[-1] != \'(\' and precedence.get(operators[-1], 0) >= precedence[token]): output.append(operators.pop()) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators and operators[-1] != \'(\': output.append(operators.pop()) operators.pop() # Remove the \'(\' from the stack while operators: output.append(operators.pop()) return output def evaluate_rpn(tokens): stack = [] for token in tokens: if token.isdigit(): stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) return stack[0] rpn = shunting_yard(expression) result = evaluate_rpn(rpn) return result"},{"question":"# Problem Statement You are asked to develop a log analysis tool that helps in identifying periods of high error rates within a system. Your task is to write a function that finds the maximum number of errors logged within any sliding window of size `k` given a sorted list of timestamps and their corresponding error counts. # Function Specification `max_error_window(k: int, logs: list[tuple[str, int]]) -> int` * **Input**: * `k`: An integer representing the size of the sliding window. * `logs`: A list of tuples, where each tuple consists of a timestamp string (`\'YYYY-MM-DD HH:MM:SS\'`) and an integer indicating the number of errors at that timestamp. The list is sorted in ascending order of timestamps. * **Output**: * An integer representing the maximum number of errors recorded within any sliding window of size `k` from the provided logs. # Constraints * The list `logs` contains at most `10^5` entries. * Each error count is a non-negative integer. * The value of `k` is guaranteed to be at most the length of the `logs`. # Examples ```python logs = [ (\\"2023-10-01 10:00:00\\", 5), (\\"2023-10-01 10:05:00\\", 2), (\\"2023-10-01 10:10:00\\", 3), (\\"2023-10-01 10:15:00\\", 8), (\\"2023-10-01 10:20:00\\", 6) ] k = 3 result = max_error_window(k, logs) # Expected Output: 16 ``` # Notes * The sliding window should consist of exactly `k` consecutive entries from the logs list. * If `logs` contains `n` entries and `k` is `n`, the function should return the sum of all error counts in the entire list. * Ensure the solution is efficient to handle the maximum constraints.","solution":"def max_error_window(k: int, logs: list[tuple[str, int]]) -> int: Finds the maximum number of errors logged within any sliding window of size k. if k > len(logs): return 0 # Initial window sum calculation current_window_sum = sum(logs[i][1] for i in range(k)) max_window_sum = current_window_sum # Sliding through the logs list for i in range(k, len(logs)): # Slide the window to the right by updating the sum current_window_sum += logs[i][1] - logs[i - k][1] max_window_sum = max(max_window_sum, current_window_sum) return max_window_sum"},{"question":"# Binary Search for First Occurrence **Context**: In many search-related problems, it is often required to find the first occurrence of a given element in a sorted list. Binary search is a highly efficient method when dealing with sorted data, and it can be adapted to locate the first appearance of an element. **Task**: Implement a function to perform a binary search to find the index of the first occurrence of a given target in a sorted list of integers. **Function Signature**: ```python def first_occurrence(arr: list, target: int) -> int: pass ``` **Input**: * A list of integers `arr` where -10^6 <= arr[i] <= 10^6, sorted in non-decreasing order. * An integer `target` where -10^6 <= target <= 10^6. **Output**: * The index of the first occurrence of `target` in `arr`, or -1 if `target` is not present. **Constraints**: * The implementation should have a time complexity of O(log n), where n is the length of the list. * The list may contain duplicate elements. **Examples**: ```python assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 3) == 4 assert first_occurrence([1, 2, 2, 2, 3, 4, 5], 6) == -1 assert first_occurrence([], 3) == -1 ``` **Additional Information**: * The function should return the smallest index where `target` appears in `arr`. * If `target` is not present in the list, the function should return -1.","solution":"def first_occurrence(arr: list, target: int) -> int: Finds the first occurrence of the target in a sorted list using binary search. Parameters: arr (list): A list of sorted integers. target (int): The target integer to find. Returns: int: The index of the first occurrence of the target in the list, or -1 if not found. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: result = mid right = mid - 1 # Look on the left side for the first occurrence elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Coding Challenge: Sequence Pattern Matching You are provided with a sequence of integers representing certain events and a pattern sequence you want to detect in the main sequence. The task is to implement a function that identifies if the pattern sequence can be formed by deleting some elements from the main sequence without reordering the remaining elements. Function Signature ```python def is_pattern_in_sequence(main_sequence: list[int], pattern: list[int]) -> bool: pass ``` Parameters - `main_sequence`: The main sequence of integers where you want to detect the pattern. - `pattern`: The pattern sequence to be detected in the main sequence. Constraints - 1 <= len(main_sequence) <= 10^3 - 1 <= len(pattern) <= len(main_sequence) - All integers in `main_sequence` and `pattern` are between -10^3 and 10^3. Output - Returns `True` if `pattern` can be formed by deleting some elements from `main_sequence` without reordering the remaining elements; otherwise, returns `False`. # Example ```python main_sequence = [1, 2, 3, 4, 5] pattern = [1, 3, 5] is_found = is_pattern_in_sequence(main_sequence, pattern) print(is_found) ``` **Output:** ```python True ``` ```python main_sequence = [1, 2, 4, 3, 5] pattern = [1, 2, 3, 6] is_found = is_pattern_in_sequence(main_sequence, pattern) print(is_found) ``` **Output:** ```python False ``` Write the function `is_pattern_in_sequence` to solve the problem.","solution":"def is_pattern_in_sequence(main_sequence: list[int], pattern: list[int]) -> bool: Determines if the pattern sequence can be formed by deleting some elements from the main sequence without reordering the remaining elements. pattern_index = 0 pattern_length = len(pattern) for el in main_sequence: if pattern_index < pattern_length and el == pattern[pattern_index]: pattern_index += 1 if pattern_index == pattern_length: return True return False"},{"question":"**Question**: Given an array of integers, design a function that finds and returns the first non-repeating element. If all elements are repeated, the function should return -1. The function should be efficient and consider edge cases such as empty arrays or arrays with a single element. # Function Signature ```python def first_non_repeating_element(arr: list) -> int: pass ``` # Input * **arr (list of int)**: A list containing integers that can include repeated numbers. # Output * **Returns (int)**: The first non-repeating integer in the list. If all integers are repeated, return -1. # Constraints * The length of the input array can be up to ( 10^5 ) elements. * Each element in the array can be an integer within the range ([-10^9, 10^9]). # Example ```python print(first_non_repeating_element([9, 4, 9, 6, 7, 4])) # Output: 6 print(first_non_repeating_element([1, 2, 2, 3, 3])) # Output: 1 print(first_non_repeating_element([7, 7, 8, 8, 8])) # Output: -1 print(first_non_repeating_element([])) # Output: -1 ``` # Explanation 1. **Example 1**: The first non-repeating integer is 6, since 9 and 4 both repeat before it. 2. **Example 2**: 1 is the first non-repeating element as 2 and 3 both repeat. 3. **Example 3**: All elements are repeated in this case, so the function returns -1. 4. **Example 4**: The array is empty, so the function returns -1. # Performance Requirements Your implementation should work efficiently within the given constraints, ensuring that the time and space complexity are optimal for large input sizes.","solution":"def first_non_repeating_element(arr: list) -> int: Returns the first non-repeating element in the array. If all elements are repeated, returns -1. if not arr: return -1 element_count = {} # Count occurrences of each element for el in arr: if el in element_count: element_count[el] += 1 else: element_count[el] = 1 # Find the first non-repeating element for el in arr: if element_count[el] == 1: return el # Return -1 if all elements are repeated return -1"},{"question":"# Question: Implement a Function to Perform Left Rotation on a Custom Data Structure You are tasked with writing a function that performs a left rotation on a custom data structure similar to a list but with additional constraints on access methods. Scenario Imagine you have a custom data structure called `MyCircularList`. This custom list class holds numerical data and provides only the following methods: * `get_len()` - returns the number of elements in the list. * `get_element(index)` - fetches the element at the specified index (indexing starts from 0). * `set_element(index, value)` - sets the element at the specified index to the given value. Your task is to implement a function `left_rotate_custom(my_list: MyCircularList, k: int) -> None` that left rotates the elements of `MyCircularList` by `k` positions. Specification * **Function Name:** `left_rotate_custom` * **Input:** * `my_list` - an instance of `MyCircularList` containing the elements to be processed. * `k` - an integer representing the number of positions to rotate left. * **Output:** * This function doesn\'t return anything. It modifies `my_list` in place to perform the left rotation. Constraints: * The list will contain at least one element. * All elements are numerical (integers or floating-point numbers). * You cannot convert `MyCircularList` to a standard Python list or use any standard list methods. Example Usage: ```python class MyCircularList: def __init__(self, elements): self.elements = elements def get_len(self): return len(self.elements) def get_element(self, index): return self.elements[index] def set_element(self, index, value): self.elements[index] = value # Example: my_list = MyCircularList([1, 2, 3, 4, 5]) left_rotate_custom(my_list, 2) print([my_list.get_element(i) for i in range(my_list.get_len())]) # Should output [3, 4, 5, 1, 2] my_list = MyCircularList([-1, 0, 1]) left_rotate_custom(my_list, 1) print([my_list.get_element(i) for i in range(my_list.get_len())]) # Should output [0, 1, -1] ``` Performance Requirements: * Your implementation should be efficient, ensuring that each element is moved at most once, running in O(n) time where n is the number of elements in `MyCircularList`. You should account for potential edge cases and ensure your function is robust against improper uses.","solution":"def left_rotate_custom(my_list, k): Rotates the elements of my_list to the left by k positions in place. :param my_list: Instance of MyCircularList :param k: Number of positions to rotate left n = my_list.get_len() # Normalize the rotation value k = k % n if k == 0: return # No rotation needed # Create a temporary list to store the rotated elements temp = [my_list.get_element((i + k) % n) for i in range(n)] # Set elements back to original list for i in range(n): my_list.set_element(i, temp[i])"},{"question":"# Question: Find Maximum Gap in Sorted Array Given an array of distinct integers, you need to find the maximum gap between any two consecutive elements in the sorted version of the array. If the array contains fewer than two elements, return 0. Task Write a function `maximum_gap(nums: List[int]) -> int` that returns the maximum gap between any two consecutive elements in the sorted array. Function Signature ```python def maximum_gap(nums: List[int]) -> int: pass ``` Input - `nums` (List[int]): A list of distinct integers. Output - (int): The maximum gap between any two consecutive elements in the sorted array. Return 0 if the array has fewer than two elements. Constraints - The length of `nums` will be in the range [0, 10^5]. - Each integer in `nums` will be within the range [-10^9, 10^9]. Examples ```python >>> maximum_gap([3, 6, 9, 1]) 3 >>> maximum_gap([10]) 0 >>> maximum_gap([1, 1000000]) 999999 >>> maximum_gap([5, 3, 1, 9]) 4 ``` Performance Requirements Your function should operate in linear time, (O(n)), and use (O(1)) additional space beyond the input array, making use of efficient sorting and/or other analytical techniques for large datasets.","solution":"from typing import List def maximum_gap(nums: List[int]) -> int: if len(nums) < 2: return 0 nums.sort() max_gap = 0 for i in range(1, len(nums)): max_gap = max(max_gap, nums[i] - nums[i - 1]) return max_gap"},{"question":"# Problem Statement You are tasked with implementing two functions to find the greatest common divisor (GCD) and least common multiple (LCM) of a list of integers. Function Definitions 1. **GCD Function (`gcd_list`)**: - **Input**: A list of non-negative integers `nums`. - **Output**: An integer representing the GCD of all the numbers in the list. 2. **LCM Function (`lcm_list`)**: - **Input**: A list of non-negative integers `nums`. - **Output**: An integer representing the LCM of all the numbers in the list. Example: ```python def gcd_list(nums: list) -> int: pass # Your implementation here. def lcm_list(nums: list) -> int: pass # Your implementation here. ``` Requirements - Both functions should raise a `ValueError` for lists containing negative integers, non-integer types, or empty lists. - Input constraints: All integers in the list should be within the range ( 0 leq num leq 10^9 ). Example Scenarios - **GCD List**: - `gcd_list([24, 36, 48])` should return `12`. - `gcd_list([5, 10, 15])` should return `5`. - **LCM List**: - `lcm_list([4, 6, 8])` should return `24`. - `lcm_list([2, 3, 5])` should return `30`. Constraints & Performance - Your solution should handle lists with a large number of elements efficiently. - Use efficient algorithms for computing GCD and LCM, such as the Euclidean algorithm for GCD. - Ensure your code is robust and handles edge cases seamlessly.","solution":"from math import gcd from functools import reduce def gcd_list(nums): if not nums or any(not isinstance(n, int) or n < 0 for n in nums): raise ValueError(\\"List must contain only non-negative integers.\\") def gcd_multiple(numbers): return reduce(gcd, numbers) return gcd_multiple(nums) def lcm(a, b): return a * b // gcd(a, b) def lcm_list(nums): if not nums or any(not isinstance(n, int) or n < 0 for n in nums): raise ValueError(\\"List must contain only non-negative integers.\\") def lcm_multiple(numbers): return reduce(lcm, numbers) return lcm_multiple(nums)"},{"question":"# Question Description Context In programming, it\'s common to manipulate and transform data structures. One such operation is reversing the elements of a data structure. This question will test your understanding and ability to handle basic data transformations. Task You are required to design a function that reverses the order of words in a string. A word is defined as a sequence of non-space characters separated by spaces. Detailed Instructions * **Function Signature**: ```python def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: A new string with words in reversed order. ``` * **Expected Input and Output Formats**: * The function accepts a single string `s`. * The function returns a new string with the original words in reverse order. * **Constraints**: * Ensure the input is a string. * Words are separated by single spaces. * The input string does not contain leading or trailing spaces, and there is only one space between words. * **Performance Requirements**: The function should operate in linear time relative to the size of the input string, i.e., O(n), where n is the length of the string. Examples: ```python >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"Python is fun\\") \\"fun is Python\\" >>> reverse_words(\\"a b c d\\") \\"d c b a\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"singleword\\") \\"singleword\\" ``` Edge Cases: 1. If the input string is empty, the function should return an empty string. 2. If the input string contains only one word, the function should return the same word.","solution":"def reverse_words(s: str) -> str: Reverse the order of words in a given string. :param s: Input string to reverse words in. :return: A new string with words in reversed order. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a new string return \' \'.join(reversed_words)"},{"question":"# Binary Search Tree - Range Sum In this task, you will implement a Binary Search Tree (BST) and write a function to calculate the sum of all nodes in a given range [L, R]. # Objective Implement a `BinarySearchTree` class and create a method `range_sum` to return the sum of all node values between L and R (inclusive). # Function Signatures 1. `__init__(self) -> None` 2. `insert(self, val: int) -> None` 3. `range_sum(self, L: int, R: int) -> int` # Requirements - **Class**: `BinarySearchTree` - **Methods and Behaviors**: - `insert`: Inserts a value into the BST, ensuring the tree structure remains valid. - `range_sum`: Computes the sum of all node values between L and R, including L and R. # Example ```python # Create an instance of BinarySearchTree bst = BinarySearchTree() # Insert elements into the BST bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(18) # Calculate the range sum between 7 and 15 assert bst.range_sum(7, 15) == 32 # The sum of nodes 7, 10, and 15 ``` # Constraints - Nodes\' values will be unique and within the range of -10^4 to 10^4. - Number of nodes in the BST will not exceed 10^4. - Values L and R will always exist within the range of the BST. # Implementation Details - **Insertion**: Maintain the invariant properties of the BST during insertion. - **Range Sum Calculation**: The `range_sum` method should efficiently traverse the BST to calculate the sum within the specified range, leveraging the properties of the BST to skip unnecessary nodes.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def range_sum(self, L, R): return self._range_sum(self.root, L, R) def _range_sum(self, node, L, R): if not node: return 0 if node.val < L: return self._range_sum(node.right, L, R) elif node.val > R: return self._range_sum(node.left, L, R) else: return node.val + self._range_sum(node.left, L, R) + self._range_sum(node.right, L, R)"},{"question":"# Question You are required to implement and test a function that reads a comma-separated values (CSV) file containing information about individuals\' salaries and calculates specific statistics. The CSV file will have the following structure: ``` Name,Age,Department,Salary John Doe,34,Engineering,75000 Jane Smith,29,Marketing,56000 Alice Johnson,45,Finance,81000 Bob Brown,38,Engineering,72000 ``` # Function Specification **Function Signature** ```python def salary_statistics(file_path: str) -> Tuple[int, float, float, float]: pass ``` **Input** - `file_path` (string): The path to the CSV file containing salary information. **Output** - Returns a tuple with four elements: - `total_employees` (int): Total number of employees listed in the file. - `average_salary` (float): Average salary of all employees. - `max_salary` (float): Maximum salary among all employees. - `min_salary` (float): Minimum salary among all employees. **Constraints** - The function should handle file I/O errors gracefully. - Assume that the file is correctly formatted with valid data. # Example ```python # Given the CSV content shown above in a file located at \'salaries.csv\' stats = salary_statistics(\'salaries.csv\') print(f\\"Total employees: {stats[0]}\\") print(f\\"Average salary: {stats[1]:.2f}\\") print(f\\"Maximum salary: {stats[2]:.2f}\\") print(f\\"Minimum salary: {stats[3]:.2f}\\") ``` This should output: ``` Total employees: 4 Average salary: 71000.00 Maximum salary: 81000.00 Minimum salary: 56000.00 ``` # Instructions 1. Use Python\'s built-in `csv` module to read the CSV file. 2. Write the `salary_statistics` function to open the file, read the contents, and compute the required statistics. 3. Ensure proper error handling for cases such as missing files or incorrect formats. 4. Test the function with different CSV files to verify its correctness.","solution":"import csv from typing import Tuple def salary_statistics(file_path: str) -> Tuple[int, float, float, float]: try: with open(file_path, mode=\'r\') as file: csv_reader = csv.DictReader(file) salaries = [float(row[\'Salary\']) for row in csv_reader] total_employees = len(salaries) if total_employees == 0: return (0, 0.0, 0.0, 0.0) average_salary = sum(salaries) / total_employees max_salary = max(salaries) min_salary = min(salaries) return (total_employees, average_salary, max_salary, min_salary) except FileNotFoundError: print(f\\"Error: File {file_path} not found.\\") return (0, 0.0, 0.0, 0.0) except Exception as e: print(f\\"Error: {e}\\") return (0, 0.0, 0.0, 0.0)"},{"question":"# Question Classic Towers of Hanoi Problem As a software developer, you are tasked with writing a simulation of the classic Towers of Hanoi problem. The problem involves three pegs and a number of disks of different sizes. The objective is to move all the disks from the first peg to the third peg following these rules: 1. Only one disk can be moved at a time. 2. A disk can only be placed on top of a larger disk or an empty peg. 3. You must use a recursive approach to solve this problem. Write a function to print the detailed steps to move the disks from the source peg to the destination peg using the auxiliary peg. Requirements 1. Implement the `towers_of_hanoi` function. 2. The function should take the following parameters: - `n` (int): The number of disks. - `source` (int): The peg number where the disks are initially placed (commonly 1). - `destination` (int): The peg number where the disks need to be moved (commonly 3). - `auxiliary` (int): The peg number used as an auxiliary (commonly 2). 3. The function should print a step-by-step guide in the format \\"Move disk <disk_number> from peg <source> to peg <destination>\\". **Constraints:** - `n` should be a positive integer. **Example:** ```python towers_of_hanoi(3, 1, 3, 2) ``` **Expected Output:** ```plaintext Move disk 1 from peg 1 to peg 3 Move disk 2 from peg 1 to peg 2 Move disk 1 from peg 3 to peg 2 Move disk 3 from peg 1 to peg 3 Move disk 1 from peg 2 to peg 1 Move disk 2 from peg 2 to peg 3 Move disk 1 from peg 1 to peg 3 ``` **Additional Tests:** ```python def test_case_1(): expected_output = [ \\"Move disk 1 from peg 1 to peg 2\\", \\"Move disk 2 from peg 1 to peg 3\\", \\"Move disk 1 from peg 2 to peg 3\\" ] assert towers_of_hanoi(2, 1, 3, 2) == expected_output def test_case_2(): expected_output = [ \\"Move disk 1 from peg 1 to peg 3\\", \\"Move disk 2 from peg 1 to peg 2\\", \\"Move disk 1 from peg 3 to peg 2\\", \\"Move disk 3 from peg 1 to peg 3\\", \\"Move disk 1 from peg 2 to peg 1\\", \\"Move disk 2 from peg 2 to peg 3\\", \\"Move disk 1 from peg 1 to peg 3\\" ] assert towers_of_hanoi(3, 1, 3, 2) == expected_output def test_case_3(): try: towers_of_hanoi(-1, 1, 3, 2) except ValueError as e: assert str(e) == \\"Number of disks must be a positive integer.\\" ``` Write your implementation to fulfill these requirements and pass the provided test cases.","solution":"def towers_of_hanoi(n, source, destination, auxiliary): Solve the Towers of Hanoi problem and print each move step. Arguments: n -- number of disks source -- starting peg destination -- target peg auxiliary -- auxiliary peg if n <= 0: raise ValueError(\\"Number of disks must be a positive integer.\\") # Base case: move one disk directly from source to destination. if n == 1: print(f\\"Move disk {n} from peg {source} to peg {destination}\\") return # Move n-1 disks from source to auxiliary, using destination as an auxiliary peg. towers_of_hanoi(n-1, source, auxiliary, destination) # Move the nth disk from source to destination. print(f\\"Move disk {n} from peg {source} to peg {destination}\\") # Move the n-1 disks from auxiliary to destination, using source as an auxiliary peg. towers_of_hanoi(n-1, auxiliary, destination, source)"},{"question":"Problem Statement # Context You are tasked with implementing a feature for a text editor that processes deeply nested structures of text blocks. Specifically, you need an efficient method to flatten these nested structures into a single list of individual elements, maintaining the original ordering. # Task Write a Python function `flatten_nested_list` that takes a nested list and returns a flattened version of the list. The nested list can have arbitrary depth. # Requirements * **Input**: * `lst` (list): A nested list containing integers and/or other nested lists. (0 ≤ len(lst) ≤ 10^5). * **Output**: * A flattened list of integers. # Constraints 1. The nested list can contain other nested lists down to any level. 2. Handle edge cases such as empty lists or lists with only nested empty lists. # Function Signature ```python def flatten_nested_list(lst: list) -> list[int]: pass ``` # Example ```python assert flatten_nested_list([1, [2, [3, [4, 5]]]]) == [1, 2, 3, 4, 5] assert flatten_nested_list([1, [2, 3], [4, [5, 6, [7]], 8], 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_nested_list([[[[]]], [1, [2, [3]]]]) == [1, 2, 3] assert flatten_nested_list([]) == [] assert flatten_nested_list([[[[]]]]) == [] ``` # Performance Considerations Your solution should efficiently handle the potentially large and deeply nested structures without exceeding memory constraints. This question tests your ability to work with recursion or iterative approaches to process nested structures and maintain order while flattening. Be mindful of large and deeply nested inputs in terms of both time and space complexity.","solution":"def flatten_nested_list(lst: list) -> list[int]: Takes a nested list and returns a flattened list. flattened = [] def flatten(sublist): for element in sublist: if isinstance(element, list): flatten(element) else: flattened.append(element) flatten(lst) return flattened"},{"question":"# Efficient Pathfinding in a Graph You are given an undirected graph represented by a list of edges and a starting node. Each edge is defined by three integers, `(u, v, w)`, where `u` and `v` are nodes connected by an edge, and `w` is the weight of that edge. Your task is to implement a function that finds the shortest path from the starting node to all other nodes in the graph using Dijkstra\'s Algorithm. Task Create a function named `dijkstra_shortest_path` which accepts the number of nodes in the graph, a list of edges, and a starting node. The function should return a dictionary where the keys are the nodes and the values are the shortest distance from the starting node to that node. Function Signature ```python def dijkstra_shortest_path( num_nodes: int, edges: list[tuple[int, int, int]], start_node: int ) -> dict[int, int]: pass ``` Constraints 1. The number of nodes (`num_nodes`) is between 1 and 1000. 2. Each edge weight (`w`) is a non-negative integer. 3. There are no negative weights in the graph. 4. The graph may be disconnected, in which case the distance to unreachable nodes should be represented as `float(\'inf\')`. 5. The starting node will always be a valid node within the given number of nodes. Example ```python num_nodes = 5 edges = [ (0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3) ] start_node = 0 # Expected output: {0: 0, 1: 2, 2: 3, 3: 9, 4: 6} print(dijkstra_shortest_path(num_nodes, edges, start_node)) ``` Explanation In the example, the shortest path from node 0 to: - node 0 is itself, so the distance is `0`. - node 1 is via edge (0, 1), with a distance of `2`. - node 2 is via edges (0, 1) -> (1, 2), with a distance of `2 + 1 = 3`. - node 3 is via edges (0, 1) -> (1, 3), with a distance of `2 + 7 = 9`. - node 4 is via edges (0, 1) -> (1, 2) -> (2, 4), with a distance of `2 + 1 + 3 = 6`. Evaluation Criteria 1. Correct implementation of Dijkstra\'s Algorithm. 2. Efficient handling of the graph and edge weights. 3. Proper dealing with disconnected nodes. 4. Code quality and readability.","solution":"import heapq def dijkstra_shortest_path(num_nodes, edges, start_node): graph = {i: [] for i in range(num_nodes)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distances = {i: float(\'inf\') for i in range(num_nodes)} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question Scenario Your team is developing a utility for processing lists of integers. One of the tasks involves determining if a list of integers is a \\"zigzag\\" list. A list is considered a \\"zigzag\\" if the numbers alternate between strictly increasing and strictly decreasing. Objective Implement a function named `is_zigzag` that determines whether a given list of integers is a zigzag list. Function Signature ```python def is_zigzag(nums: List[int]) -> bool: Check if the given list of integers is a zigzag list. Args: - nums (List[int]): The input list of integers. Returns: - bool: True if the list is a zigzag, False otherwise. ``` Input * A list of integers `nums`. Output * A boolean value: True if `nums` is a zigzag list, False otherwise. Constraints * The list can be of any length, including zero. * The integers can be negative, zero, or positive. Example ```python assert is_zigzag([1, 3, 2, 4, 3]) == True # Alternates between increasing and decreasing assert is_zigzag([3, 3, 3, 3]) == False # All elements are the same assert is_zigzag([7, 6, 5, 4]) == False # Strictly decreasing assert is_zigzag([1]) == True # Single element assert is_zigzag([]) == True # Empty list ``` Notes * Consider edge cases such as empty lists and lists with very few elements. * Focus on efficiency to ensure the solution scales well with larger lists. * Carefully think through all possible scenarios to verify the correctness of the implementation.","solution":"from typing import List def is_zigzag(nums: List[int]) -> bool: if len(nums) < 2: return True for i in range(1, len(nums)-1): if not ((nums[i-1] < nums[i] > nums[i+1]) or (nums[i-1] > nums[i] < nums[i+1])): return False return True"},{"question":"# Question: Reverse a Linked List in K-Group Intervals **Context**: You need to develop a function that reverses a linked list in groups of `k` nodes. This means that if the linked list has nodes 1 -> 2 -> 3 -> 4 -> 5 and `k` is 2, the linked list should be modified to 2 -> 1 -> 4 -> 3 -> 5. However, if `k` is 3, the linked list would become 3 -> 2 -> 1 -> 4 -> 5, reversing every set of `k` nodes. If the number of nodes is not a multiple of `k`, the last group of nodes should remain in their original order. **Function to Implement**: Implement the following function: ```python def reverse_k_group(head, k): Reverses the nodes of a linked list in k-group intervals. Parameters: head : ListNode The head node of the linked list. k : int The size of groups to reverse. Returns: ListNode The head node of the modified linked list. ``` **Input/Output**: - **Input**: - `head`: The head node of the singly linked list. - `k`: An integer representing the group size for reversal. - **Output**: - The head node of the linked list after reversing every `k` nodes. **Constraints**: - The number of nodes in the list is at most 5000. - The value of each node is in the range -1000 to 1000. - 1 ≤ `k` ≤ the number of nodes in the linked list. **Example**: ```python # Suppose you have a linked list class ListNode defined as follows: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example: # Input: head = [1, 2, 3, 4, 5], k = 2 # Output: [2, 1, 4, 3, 5] # Input: head = [1, 2, 3, 4, 5], k = 3 # Output: [3, 2, 1, 4, 5] ``` **Requirements**: - Implement a helper function to reverse part of the linked list. - Ensure the algorithm efficiently traverses the list and handles `k`-group reversals. - Consider edge cases such as `k` being 1 or greater than the length of the list. - Maintain the original references for efficient reversal and output generation.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_k_group(head, k): Reverses the nodes of a linked list in k-group intervals. Parameters: head : ListNode The head node of the linked list. k : int The size of groups to reverse. Returns: ListNode The head node of the modified linked list. if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head cur, cur_dummy = head, dummy length = 0 while cur: next_cur = cur.next length += 1 if length % k == 0: next_dummy = cur_dummy.next reverse(cur_dummy, cur.next) cur_dummy = next_dummy cur = next_cur return dummy.next def reverse(start, end): prev, cur = None, start.next first = cur while cur != end: temp = cur.next cur.next = prev prev = cur cur = temp start.next = prev first.next = cur"},{"question":"# Word Frequency Counter: Comprehensive Analysis Context You are tasked with creating a utility to analyze text documents and provide in-depth word frequency statistics. The utility should handle large inputs efficiently and support multiple options for sorting and filtering results. Task Implement the following functions: 1. `count_words(text: str) -> dict`: * Counts the occurrences of each word in the given text and returns a dictionary with words as keys and their respective counts as values. 2. `top_n_words(word_count: dict, n: int) -> list[tuple]`: * Returns a list of the top `n` most frequent words and their counts, sorted in descending order of frequency. 3. `filter_words(word_count: dict, min_length: int, max_length: int) -> dict`: * Filters the words in the word count dictionary to include only those whose lengths are within the specified range, returning a new dictionary. Input * `text`: A string representing the text document to be analyzed. * `word_count`: A dictionary containing words and their respective counts. * `n`: An integer representing the number of top frequent words to return. * `min_length`: An integer specifying the minimum length of words to keep after filtering. * `max_length`: An integer specifying the maximum length of words to keep after filtering. Output * For `count_words`: A dictionary with words as keys and their counts as values. * For `top_n_words`: A list of tuples, each containing a word and its count, sorted by count in descending order. * For `filter_words`: A dictionary containing only words with lengths within the specified range. Constraints * `1 <= len(text) <= 10^6` * `0 <= n <= len(word_count)` * `1 <= min_length <= max_length` * Assume words are case-insensitive, and punctuation should be ignored. * Efficiency in processing and memory usage is crucial for handling large texts. Function Signature ```python def count_words(text: str) -> dict: pass def top_n_words(word_count: dict, n: int) -> list[tuple]: pass def filter_words(word_count: dict, min_length: int, max_length: int) -> dict: pass ``` Example Scenarios 1. Counting words in a text: * Input: `\\"Hello, world! Hello, Python. world of Python.\\"` * Output: `{\'hello\': 2, \'world\': 2, \'python\': 2, \'of\': 1}` 2. Getting top 2 frequent words: * Input: `({\'hello\': 2, \'world\': 2, \'python\': 2, \'of\': 1}, 2)` * Output: `[(\'hello\', 2), (\'world\', 2)]` 3. Filtering words with length between 4 and 6: * Input: `({\'hello\': 2, \'world\': 2, \'python\': 2, \'of\': 1}, 4, 6)` * Output: `{\'hello\': 2, \'world\': 2}` Write the code to fulfill these requirements, ensuring it follows robust error handling and efficient processing practices.","solution":"import re from collections import Counter def count_words(text: str) -> dict: Counts the occurrences of each word in the given text and returns a dictionary with words as keys and their respective counts as values. Words are case-insensitive and punctuation is ignored. # Convert text to lowercase and use regex to find words text = text.lower() words = re.findall(r\'bw+b\', text) return dict(Counter(words)) def top_n_words(word_count: dict, n: int) -> list[tuple]: Returns a list of the top `n` most frequent words and their counts, sorted in descending order of frequency. return sorted(word_count.items(), key=lambda x: x[1], reverse=True)[:n] def filter_words(word_count: dict, min_length: int, max_length: int) -> dict: Filters the words in the word count dictionary to include only those whose lengths are within the specified range, returning a new dictionary. return {word: count for word, count in word_count.items() if min_length <= len(word) <= max_length}"},{"question":"**Scenario**: You are helping a friend who is managing a bookstore. They want to implement a feature that allows them to track the prices of books. Specifically, they need a utility that can generate a list of books priced within a specified range. This feature will help them easily identify books that are under a certain budget or within a promotional offer range. **Task**: Develop a function `filter_books_by_price` that takes two arguments: a dictionary `books` and a tuple `price_range`. The `books` dictionary has book titles (strings) as keys and their prices (floats) as values. The `price_range` tuple has two floats representing the minimum and maximum price range, respectively. Your function should return a list of book titles that fall within the given price range, sorted alphabetically. # Input Format: - `books` (dict): A dictionary where keys are book titles (str) and values are their prices (float). - `price_range` (tuple): A tuple of two floats representing the minimum and maximum price range. # Output Format: - Return a list of book titles (str) that are within the specified price range, sorted alphabetically. # Example: ```python def filter_books_by_price(books: dict, price_range: tuple) -> list: Filter and return the list of book titles that fall within the given price range, sorted alphabetically. >>> books = { ... \\"The Great Gatsby\\": 10.99, ... \\"War and Peace\\": 12.99, ... \\"Crime and Punishment\\": 9.50, ... \\"To Kill a Mockingbird\\": 6.99, ... \\"1984\\": 19.99 ... } >>> price_range = (10.00, 15.00) >>> filter_books_by_price(books, price_range) [\'The Great Gatsby\', \'War and Peace\'] >>> price_range = (5.00, 10.00) >>> filter_books_by_price(books, price_range) [\'Crime and Punishment\', \'To Kill a Mockingbird\'] >>> price_range = (20.00, 30.00) >>> filter_books_by_price(books, price_range) [] >>> price_range = (0.00, 20.00) >>> filter_books_by_price(books, price_range) [\'1984\', \'Crime and Punishment\', \'The Great Gatsby\', \'To Kill a Mockingbird\', \'War and Peace\'] min_price, max_price = price_range filtered_books = [title for title, price in books.items() if min_price <= price <= max_price] filtered_books.sort() return filtered_books if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Constraints: - Each book\'s price is a non-negative float. - The price range tuple will always contain two floats where the first float is less than or equal to the second float. - The function should handle cases where no books fall within the specified price range and return an empty list. **Notes**: - Ensure proper error handling for edge cases like empty dictionary input. - Maintain a clean and readable code format, following the function signature and example outputs provided.","solution":"def filter_books_by_price(books: dict, price_range: tuple) -> list: Filter and return the list of book titles that fall within the given price range, sorted alphabetically. :param books: Dictionary with book titles as keys and their prices as values. :param price_range: Tuple with minimum and maximum price range. :return: List of book titles within the specified price range, sorted alphabetically. min_price, max_price = price_range filtered_books = [title for title, price in books.items() if min_price <= price <= max_price] filtered_books.sort() return filtered_books"},{"question":"# Coding Assessment Question: Scenario: You are required to implement a function that returns the longest common prefix (LCP) among an array of strings. The LCP is the longest shared beginning sequence of characters in each string within the array. This function helps in tasks like command-line autocompletion, genetic sequence analysis, and many more. Function Specification: Write a function `longest_common_prefix(strs: List[str]) -> str` that computes the longest common prefix. Input: * `strs`: A list of strings (1 <= len(strs) <= 200, 0 <= len(strs[i]) <= 200) for which the longest common prefix needs to be determined. Output: * Returns the longest common prefix among the given list of strings. If there is no common prefix, return an empty string. Constraints: * The input list can be empty, in such a case, return an empty string. * All strings are assumed to be in lowercase. Examples: ```python >>> longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\",\\"interstellar\\",\\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"throne\\",\\"dungeon\\"]) \\"\\" >>> longest_common_prefix([\\"throne\\",\\"throne\\"]) \\"throne\\" >>> longest_common_prefix([]) \\"\\" ``` Ensure that your function handles edge cases, is optimized, and validates input correctly. Aiming for a solution with a time complexity of O(n*m), where n is the number of strings and m is the length of the shortest string, is advisable.","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" # Start with the first string in the list as a prefix prefix = strs[0] # Compare this prefix with each string in the list for string in strs: # Reduce the prefix size until it matches the start of `string` while string[:len(prefix)] != prefix: prefix = prefix[:len(prefix)-1] if not prefix: return \\"\\" return prefix"},{"question":"# Coding Assessment Question: Rotate and Reflect a 2D Array Context You are working on a software tool that involves processing and transforming 2D arrays. A common task is to rotate the array by 90 degrees and then reflect it horizontally for further analysis and storage. Task Write two functions: 1. A function `rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]` that takes a square 2D array (a list of lists) and returns the array rotated by 90 degrees clockwise. 2. A function `reflect_2d_array(matrix: list[list[int]]) -> list[list[int]]` that takes a 2D array and returns the array reflected along its horizontal axis. Specifications * `rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]` * **Input**: * `matrix`: A square 2D array represented as a list of lists of integers. * **Output**: * A 2D array of the same dimensions rotated by 90 degrees clockwise. * `reflect_2d_array(matrix: list[list[int]]) -> list[list[int]]` * **Input**: * `matrix`: A 2D array represented as a list of lists of integers. * **Output**: * A 2D array of the same dimensions reflected along its horizontal axis. Constraints * The `rotate_2d_array` function must handle only square matrices (where the number of rows equals the number of columns). * The input 2D matrix is non-empty. * The `reflect_2d_array` function must handle general 2D arrays (not necessarily square). Examples * Example 1: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated = rotate_2d_array(matrix) assert rotated == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] reflected = reflect_2d_array(rotated) assert reflected == [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` * Example 2: ```python matrix = [ [1, 2], [3, 4] ] rotated = rotate_2d_array(matrix) assert rotated == [ [3, 1], [4, 2] ] reflected = reflect_2d_array(rotated) assert reflected == [ [4, 2], [3, 1] ] ``` Notes * Ensure that your functions handle edge cases gracefully, such as very small matrices (e.g., 1x1). * The input should be validated to confirm it meets the required constraints (e.g., squareness for the rotate function). Consider raising an appropriate exception for invalid input.","solution":"def rotate_2d_array(matrix): Rotates a square 2D matrix by 90 degrees clockwise. Args: matrix (list[list[int]]): A square 2D array. Returns: list[list[int]]: The rotated 2D array. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix.\\") n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def reflect_2d_array(matrix): Reflects a 2D matrix along its horizontal axis. Args: matrix (list[list[int]]): A 2D array. Returns: list[list[int]]: The reflected 2D array. if not matrix or not all(len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Input must be a non-empty 2D array with consistent row lengths.\\") n = len(matrix) reflected = [row[:] for row in matrix] for i in range(n // 2): reflected[i], reflected[n - 1 - i] = reflected[n - 1 - i], reflected[i] return reflected"},{"question":"# Problem Statement In this task, you will write a function that checks if a number is a circular prime. A circular prime is a prime number that remains prime when its digits are cyclically rotated in any order. # Guidelines - Implement a function `is_circular_prime(n: int) -> bool` that returns `True` if the input number `n` is a circular prime, and `False` otherwise. # Input and Output - **Input**: An integer `n` where (2 leq n leq 10^6). - **Output**: Return a boolean value `True` if `n` is a circular prime, and `False` otherwise. # Constraints - The function should efficiently check the primality of all cyclic rotations of the digits of `n`. # Example ```python def is_circular_prime(n: int) -> bool: # Your implementation here # Example usage: assert is_circular_prime(197) == True assert is_circular_prime(101) == False assert is_circular_prime(71) == True assert is_circular_prime(107) == False assert is_circular_prime(11) == True ``` # Description of Example In the provided example, the function checks the number 197, rotates its digits cyclically (197, 971, 719), and verifies that all resulting numbers are primes. Thus, it returns `True` for 197. For 101, one of the rotations (011) is not a prime, thus it returns `False`. # Hints - Use a helper function to check for primality. - Generate all cyclic rotations of the digits to perform the primality check on each one. - Consider edge cases such as single-digit numbers and numbers containing \'0\' in their rotations.","solution":"def is_prime(num): Helper function to check if a number is prime. if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def rotations(n): Generate all cyclic rotations of an integer n. s = str(n) return [int(s[i:] + s[:i]) for i in range(len(s))] def is_circular_prime(n): Check if the number n is a circular prime. return all(is_prime(rot) for rot in rotations(n))"},{"question":"**Context**: You are tasked with designing a custom log management system. The system should be able to produce a summary of log entries based on severity levels, which range from 1 (lowest) to 5 (highest). Each log entry contains a timestamp, severity level, and a message. # Task: Implement a class `LogManager` that can add log entries and generate a summary report. # Specifications: 1. **Class Definition**: Define a class `LogManager`. 2. **Method**: `add_log_entry(timestamp: str, severity: int, message: str) -> None` - Adds a log entry to the system. - Ensure log entries are stored appropriately for later retrieval and summarization. 3. **Method**: `get_summary(severity: int) -> List[str]` - Returns a list of log messages with the specified severity. - The messages should be sorted by their timestamps in ascending order. # Input: * `timestamp`: A string representing the log entry\'s timestamp in the format `\\"YYYY-MM-DD HH:MM:SS\\"`. * `severity`: An integer representing the severity level (1-5). * `message`: A string containing the log message. # Output: * The `get_summary` method should return a list of strings, where each string is the log message corresponding to the specified severity level, sorted by timestamp. # Example: ```python class LogManager: def __init__(self): # Your implementation here def add_log_entry(self, timestamp: str, severity: int, message: str) -> None: # Your implementation here def get_summary(self, severity: int) -> List[str]: # Your implementation here # Usage log_manager = LogManager() log_manager.add_log_entry(\\"2023-10-01 10:00:00\\", 3, \\"This is a level 3 log.\\") log_manager.add_log_entry(\\"2023-10-01 09:00:00\\", 1, \\"This is a level 1 log.\\") log_manager.add_log_entry(\\"2023-10-01 10:05:00\\", 3, \\"This is another level 3 log.\\") summary = log_manager.get_summary(3) print(summary) # Expected output: [\\"This is a level 3 log.\\", \\"This is another level 3 log.\\"] ``` # Constraints: * The severity level is an integer between 1 and 5 inclusive. * The timestamp format will always be valid and in the specified format. * Handle a large number of log entries efficiently. # Performance Requirements: * Solutions should manage up to 100,000 log entries efficiently and support quick retrieval for summary reports.","solution":"from typing import List, Tuple from collections import defaultdict class LogManager: def __init__(self): self.logs = defaultdict(list) def add_log_entry(self, timestamp: str, severity: int, message: str) -> None: Adds a log entry to the log manager. Args: timestamp (str): The timestamp of the log entry in the format \\"YYYY-MM-DD HH:MM:SS\\". severity (int): The severity level (1-5) of the log entry. message (str): The log message. if severity < 1 or severity > 5: raise ValueError(\\"Severity level must be between 1 and 5\\") self.logs[severity].append((timestamp, message)) def get_summary(self, severity: int) -> List[str]: Returns a summary of log messages with the specified severity, sorted by timestamp. Args: severity (int): The severity level to filter log messages. Returns: List[str]: Sorted list of log messages with the specified severity. if severity not in self.logs: return [] sorted_logs = sorted(self.logs[severity], key=lambda x: x[0]) return [message for _, message in sorted_logs]"},{"question":"# Implementation of Simple K-Means Clustering You are required to implement the K-Means clustering algorithm from scratch. Your task is to: 1. Download and process a given dataset. 2. Implement the K-Means algorithm to cluster the data points. 3. Evaluate the clustering performance using within-cluster sum of squares (WCSS). Dataset The dataset contains multiple columns, each representing a feature of the data points. The first row contains headers. **Download URL**: ``` https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv ``` Task Requirements 1. **Function to Collect Dataset**: - Read and return the dataset as a matrix. - Parse the CSV data from the URL. 2. **Function to Compute Distance**: - Calculate the Euclidean distance between two data points. 3. **Function to Assign Clusters**: - Assign each data point to the nearest cluster center. 4. **Function to Update Centroids**: - Compute the new centroid positions based on the current cluster assignments. 5. **Function to Compute WCSS**: - Calculate the within-cluster sum of squares to quantify the clustering performance. 6. **Function to Run K-Means Clustering**: - Integrate all the above functions to perform the K-Means algorithm. 7. **Main Execution**: - Load the data, process it, and run K-Means clustering. - Print the final cluster centers and the within-cluster sum of squares. Function Signatures You should implement the following functions: 1. `collect_dataset() -> np.matrix` 2. `euclidean_distance(point1: np.array, point2: np.array) -> float` 3. `assign_clusters(data: np.matrix, centroids: np.matrix) -> np.array` 4. `update_centroids(data: np.matrix, clusters: np.array, k: int) -> np.matrix` 5. `compute_wcss(data: np.matrix, clusters: np.array, centroids: np.matrix) -> float` 6. `run_k_means(data: np.matrix, k: int, max_iters: int) -> Tuple[np.matrix, float]` Input & Output Format - Input: **None**. The function should fetch the dataset and perform computations internally. - Output: **Cluster centers and within-cluster sum of squares (WCSS)**, printed in the console. Example ```python def main(): # Collect and process the dataset data = collect_dataset() data = data[:, :-1].astype(float) # Remove the class labels k = 3 # Number of clusters max_iters = 100 # Maximum number of iterations # Run K-Means clustering centroids, wcss = run_k_means(data, k, max_iters) print(f\\"Final cluster centers:n{centroids}\\") print(f\\"Within-cluster sum of squares: {wcss:.5f}\\") if __name__ == \\"__main__\\": main() ``` Constraints - Handle cases where the dataset contains missing values. - Properly initialize the cluster centers to ensure a good starting point. - The model should run within a reasonable time frame, assuming the dataset has fewer than 1000 data points.","solution":"import numpy as np import pandas as pd from urllib.request import urlopen def collect_dataset(): url = \\"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv\\" df = pd.read_csv(url) data = df.drop(columns=[\'species\']).values return data def euclidean_distance(point1, point2): return np.sqrt(np.sum((point1 - point2) ** 2)) def assign_clusters(data, centroids): clusters = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] clusters.append(np.argmin(distances)) return np.array(clusters) def update_centroids(data, clusters, k): new_centroids = [] for i in range(k): cluster_points = data[clusters == i] if len(cluster_points) > 0: new_centroid = np.mean(cluster_points, axis=0) else: new_centroid = data[np.random.randint(0, data.shape[0])] new_centroids.append(new_centroid) return np.array(new_centroids) def compute_wcss(data, clusters, centroids): wcss = 0 for i, point in enumerate(data): centroid = centroids[clusters[i]] wcss += euclidean_distance(point, centroid) ** 2 return wcss def run_k_means(data, k, max_iters=100): n_samples, n_features = data.shape centroids = data[np.random.choice(n_samples, k, replace=False)] for _ in range(max_iters): clusters = assign_clusters(data, centroids) new_centroids = update_centroids(data, clusters, k) if np.all(centroids == new_centroids): break centroids = new_centroids wcss = compute_wcss(data, clusters, centroids) return centroids, wcss"},{"question":"# Coding Question: Array Split Sums You are given an array of positive integers. Your task is to write a function `split_array_sums(nums: List[int]) -> List[List[int]]` that splits the array into all possible contiguous subarrays and returns a list of sums of each subarray. **Input:** - A list of integers `nums` (1 ≤ len(nums) ≤ 1000, 1 ≤ nums[i] ≤ 1000), representing the array of positive integers. **Output:** - A list of lists, where each inner list contains the sums of one of the possible contiguous subarrays from the input array in the order they were encountered. **Example:** ```python >>> split_array_sums([1, 2, 3]) [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]] >>> split_array_sums([2, 3, 4]) [[2], [2, 3], [2, 3, 4], [3], [3, 4], [4]] ``` **Constraints:** - The array should be split into all possible contiguous subarrays. - Return the sums of these subarrays. **Performance Requirements:** - Aim for an efficient solution that avoids unnecessary computations and redundant storage, with a time complexity of O(n^2) due to generating subarrays and summing them. **Hint:** Consider using nested loops to generate the subarrays and calculate their sums.","solution":"from typing import List def split_array_sums(nums: List[int]) -> List[List[int]]: n = len(nums) result = [] for i in range(n): temp_sum = 0 for j in range(i, n): temp_sum += nums[j] result.append(temp_sum) return result"},{"question":"# Media Post Creation **Objective**: Implement a function to post media with a text caption, robustly handling potential types and structuring the output clearly. **Scenario**: In a social media application, users can post photos or videos along with a text caption. Ensure the function validates inputs properly, providing clear feedback on errors and structuring the response in a uniform format. **Requirements**: - Define a function `create_media_post(media_url: str, caption: str, media_type: str) -> dict` that: - Takes a media URL (string), a caption (string), and a media type (string that can be \'photo\' or \'video\'). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"message\\"` (string containing URL and caption on success or an error message on failure). - Handle empty or invalid URLs by returning an error message. - Handle an invalid media type by returning an error message. - Return an appropriate message if the caption exceeds 280 characters. **Function Signature**: ```python def create_media_post(media_url: str, caption: str, media_type: str) -> dict: pass ``` **Constraints**: - The input URL must be a non-empty string. - The caption must be a string of maximum length 280. - The media type must be either \\"photo\\" or \\"video\\". **Examples**: 1. `create_media_post(\\"https://example.com/photo.jpg\\", \\"This is a photo caption\\", \\"photo\\")` - Should return: ```python { \\"success\\": True, \\"message\\": \\"Media URL: https://example.com/photo.jpg | Caption: This is a photo caption\\" } ``` 2. `create_media_post(\\"\\", \\"This is an invalid URL example\\", \\"photo\\")` - Should return: ```python { \\"success\\": False, \\"message\\": \\"Invalid media URL.\\" } ``` 3. `create_media_post(\\"https://example.com/video.mp4\\", \\"This is a video caption\\", \\"movie\\")` - Should return: ```python { \\"success\\": False, \\"message\\": \\"Invalid media type. Please use \'photo\' or \'video\'.\\" } ``` 4. `create_media_post(\\"https://example.com/photo.jpg\\", \\"x\\" * 300, \\"photo\\")` - Should return: ```python { \\"success\\": False, \\"message\\": \\"Caption exceeds the maximum allowed length of 280 characters.\\" } ```","solution":"def create_media_post(media_url: str, caption: str, media_type: str) -> dict: Creates a media post with the given URL, caption, and media type. Returns a dictionary with a success status and a message. if not media_url: return { \\"success\\": False, \\"message\\": \\"Invalid media URL.\\" } if len(caption) > 280: return { \\"success\\": False, \\"message\\": \\"Caption exceeds the maximum allowed length of 280 characters.\\" } if media_type not in [\\"photo\\", \\"video\\"]: return { \\"success\\": False, \\"message\\": \\"Invalid media type. Please use \'photo\' or \'video\'.\\" } return { \\"success\\": True, \\"message\\": f\\"Media URL: {media_url} | Caption: {caption}\\" }"},{"question":"# Coding Assessment Question Scenario As a software engineer, you are working on a feature for a social media application that enhances user experience by visually highlighting specific keywords within a text. Your objective is to implement a function that wraps each occurrence of a set of target keywords in a given string with a specified HTML tag. Task Write a function `highlight_keywords` that takes three parameters: a string `text`, a list of keywords `keywords`, and an HTML tag `tag`. The function should return a new string where every occurrence of each keyword in the original text is wrapped with the specified HTML tag. Input * A single string `text` (1 ≤ |text| ≤ 10^6) where |text| represents the length of the string. * A list of strings `keywords` (1 ≤ |keywords| ≤ 1000), where each keyword is non-empty and up to 100 characters long. * A string `tag` representing an HTML tag (e.g., \\"b\\" for bold or \\"i\\" for italic). Output * A single string where each keyword in the list is wrapped with the specified HTML tag. Each occurrence of the keyword should be case-insensitive but preserve the original case in the output. Constraints * The function must handle texts up to 1,000,000 characters efficiently. * Each keyword should be matched in a case-insensitive manner, but the text should maintain the original case within the HTML tags. * You must not use external libraries for the case-insensitive search or alteration. Example ```python assert highlight_keywords(\\"Hello world!\\", [\\"world\\"], \\"b\\") == \\"Hello <b>world</b>!\\" assert highlight_keywords(\\"Programming in Python is fun!\\", [\\"python\\", \\"fun\\"], \\"i\\") == \\"Programming in <i>Python</i> is <i>fun</i>!\\" assert highlight_keywords(\\"The quick brown fox jumps over the lazy dog\\", [\\"quick\\", \\"fox\\", \\"dog\\"], \\"u\\") == \\"The <u>quick</u> brown <u>fox</u> jumps over the lazy <u>dog</u>\\" assert highlight_keywords(\\"Case INsensitive MATCH\\", [\\"case\\", \\"match\\"], \\"b\\") == \\"<b>Case</b> INsensitive <b>MATCH</b>\\" ```","solution":"def highlight_keywords(text, keywords, tag): Function to wrap specified keywords within the text with the given HTML tag. import re def replace(match): return f\\"<{tag}>{match.group(0)}</{tag}>\\" for keyword in keywords: pattern = re.compile(re.escape(keyword), re.IGNORECASE) text = pattern.sub(replace, text) return text"},{"question":"# Coding Assessment Question: String Manipulation: Word Reversal You are tasked with implementing a function that performs a specific string manipulation: reversing the order of words in a given sentence while maintaining the words\' original order of characters, and a function that checks if the reversal process was successful by validating the input and output sentences. - **Function 1: `reverse_words(sentence: str) -> str`** - **Description**: Reverse the order of words in a sentence. - **Input**: A string sentence containing words separated by spaces. - **Output**: A string with the words in reversed order. - **Constraints**: - The input must be a non-empty string. - **Edge Cases**: - Return an empty string if the input only consists of spaces. - Handle multiple consecutive spaces by treating them as single spaces. - **Function 2: `validate_reversal(original: str, reversed: str) -> bool`** - **Description**: Check if the `reversed` sentence is a correct word reversal of the `original` sentence. - **Input**: Two strings, `original` and `reversed`. - **Output**: A boolean indicating if the reversed sentence correctly reverses the words of the original sentence. - **Constraints**: - Inputs must be valid string sentences. - **Edge Cases**: - Return `False` if either input is not a valid non-empty string with words. Example: ```python # Example Function Calls: print(reverse_words(\\"hello world\\")) # Output: \\"world hello\\" print(validate_reversal(\\"hello world\\", \\"world hello\\")) # Output: True print(validate_reversal(\\"hello world\\", \\"hello world\\")) # Output: False # Example with multiple spaces: print(reverse_words(\\" hello world \\")) # Output: \\"world hello\\" print(validate_reversal(\\" hello world \\", \\"world hello\\")) # Output: True # Empty string example: print(reverse_words(\\"\\")) # Output: \\"\\" print(validate_reversal(\\"\\", \\"\\")) # Output: False ``` Performance Requirement: - The `reverse_words` function should operate in linear time, O(n), where n is the number of characters in the input sentence. - The `validate_reversal` function should similarly run in O(n) time for both string comparisons. **Notes**: - You may assume that each word in the sentence consists only of alphabetic characters. - Ensure proper exception handling and input validation for robustness. Implement the functions according to the given specifications.","solution":"def reverse_words(sentence: str) -> str: Reverse the order of words in a sentence. :param sentence: A string containing words separated by spaces. :return: A string with the words in reversed order. # Removing leading and trailing spaces and then split by spaces words = sentence.strip().split() # If there are no words, return an empty string if not words: return \\"\\" # Join the words in reverse order reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence def validate_reversal(original: str, reversed_sentence: str) -> bool: Check if the `reversed_sentence` is a correct word reversal of the `original` sentence. :param original: The original sentence. :param reversed_sentence: The reversed sentence. :return: A boolean indicating if the reversed sentence correctly reverses the words of the original sentence. # If either string is empty, return False if not original.strip() or not reversed_sentence.strip(): return False # Compare the output of reverse_words(original) with reversed_sentence return reverse_words(original) == reversed_sentence"},{"question":"# Problem Statement You are required to implement a function `list_combinations` that takes a list of numbers and an integer `k`, then returns a list of all possible combinations of `k` numbers from the input list without repeating the same combination in different orders. **Function:** `list_combinations` - **Input:** - `numbers`: A list of integers. - `k`: An integer representing the number of elements each combination should have. - **Output:** A list containing all unique combinations, each as a tuple, where each tuple contains `k` integers. **Constraints**: - The elements in each combination should be in non-decreasing order. - The function should handle empty input list or when `k` is zero. - If `k` is greater than the length of the `numbers` list, the function should return an empty list. - The input list of numbers may contain duplicates, but combinations must be unique. # Example ```python from itertools import combinations def list_combinations(numbers: list, k: int) -> list: \'\'\' This function generates all unique combinations of \'k\' elements from the input list \'numbers\'. \'\'\' pass # TODO: Write the implementation here # Test Cases assert list_combinations([1, 2, 3, 4], 2) == [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert list_combinations([1, 1, 2, 2], 2) == [(1, 1), (1, 2), (2, 2)] assert list_combinations([1, 2, 3], 0) == [] assert list_combinations([], 2) == [] assert list_combinations([1, 2, 3], 4) == [] try: result = list_combinations([1, 2, 3], 1) assert result == [(1,), (2,), (3,)] except Exception as e: print(f\\"Failed with exception: {e}\\") # Additional Note: # Ensure the function handles edge cases such as empty input list, `k` equals 0, and `k` greater than the length of the input list properly. # The implementation should be efficient and correctly handle large input data within constraints. ```","solution":"from itertools import combinations def list_combinations(numbers: list, k: int) -> list: \'\'\' This function generates all unique combinations of \'k\' elements from the input list \'numbers\'. \'\'\' if k == 0 or k > len(numbers): return [] unique_combinations = set(combinations(sorted(numbers), k)) return sorted(list(unique_combinations))"},{"question":"# Coding Question **Context**: Luna is organizing a coding bootcamp and needs a program to help manage student records. She wants an application that can maintain a list of students, adding new students, retrieving student information based on unique IDs, and displaying all students\' information in a structured format. **Task**: Write a Python class `StudentRecords` that: 1. Allows adding a new student with the following details: ID, name, and grade. 2. Provides a method to retrieve a student\'s information by ID. 3. Provides a method to display all student records sorted by their IDs. **Class Definition**: ```python class StudentRecords: def __init__(self): Initializes an empty student records list. pass def add_student(self, student_id: int, name: str, grade: str) -> None: Adds a new student to the records. :param student_id: int - unique identifier for the student :param name: str - name of the student :param grade: str - grade of the student pass def get_student_by_id(self, student_id: int) -> dict: Retrieves the student\'s information by their ID. :param student_id: int - unique identifier for the student :return: dict - a dictionary containing the student\'s information (ID, name, grade) pass def display_all_students(self) -> None: Displays all student records sorted by their IDs in ascending order. pass ``` **Constraints**: * Ensure that the student ID is unique. If a student with the same ID is added, print an appropriate error message. * Handle invalid ID lookups by returning None or printing an appropriate message. * Assume the student IDs are positive integers. * The grade can be any string representing the academic performance like \\"A\\", \\"B\\", \\"C\\", etc. **Example**: ```python records = StudentRecords() records.add_student(101, \\"Alice\\", \\"A\\") records.add_student(102, \\"Bob\\", \\"B\\") records.add_student(103, \\"Charlie\\", \\"A\\") print(records.get_student_by_id(102)) # Output: {\'student_id\': 102, \'name\': \'Bob\', \'grade\': \'B\'} records.display_all_students() ``` Output when `display_all_students` is called: ``` ID: 101, Name: Alice, Grade: A ID: 102, Name: Bob, Grade: B ID: 103, Name: Charlie, Grade: A ``` Additionally, ensure the class handles cases where it tries to add a student with an existing ID or retrieve information for a non-existent student ID. Make sure the output format matches the provided example in display methods.","solution":"class StudentRecords: def __init__(self): Initializes an empty student records list. self.records = {} def add_student(self, student_id: int, name: str, grade: str) -> None: Adds a new student to the records. :param student_id: int - unique identifier for the student :param name: str - name of the student :param grade: str - grade of the student if student_id in self.records: print(f\\"Error: A student with ID {student_id} already exists.\\") else: self.records[student_id] = {\'name\': name, \'grade\': grade} def get_student_by_id(self, student_id: int) -> dict: Retrieves the student\'s information by their ID. :param student_id: int - unique identifier for the student :return: dict - a dictionary containing the student\'s information (ID, name, grade) return self.records.get(student_id, None) def display_all_students(self) -> None: Displays all student records sorted by their IDs in ascending order. for student_id in sorted(self.records): print(f\\"ID: {student_id}, Name: {self.records[student_id][\'name\']}, Grade: {self.records[student_id][\'grade\']}\\")"},{"question":"# Problem Statement You are required to implement a function that calculates the product of all integers in a given list, but with the option to exclude one element at a certain index. Your task is to design a highly efficient and robust function that adheres to strict input validation rules and handles edge cases effectively. # Function Signature ```python def product_except_index(nums: list, index: int) -> int: Take in a list of integers and an index, return the product of all integers in the list except for the one at the given index. :param nums: List of integers :param index: Integer, the index of the element to exclude :return: An integer, the product of all integers in `nums` except the one at `index`. Raise ValueError for invalid indices. Raise TypeError for non-list or non-integer index types. ``` # Input * `nums`: A list of integers. * `index`: An integer specifying which element to exclude from the product operation. # Output * Return a single integer representing the product of all integers in the list except for the one at the specified index. # Constraints * The list `nums` contains at least two elements. * Type errors and out-of-bound indices should be handled appropriately by raising `TypeError` and `ValueError`, respectively. * The input integers in `nums` can be positive, negative, or zero. # Performance Requirements * The function should be optimized to handle large lists efficiently. # Examples ```python assert product_except_index([1, 2, 3, 4, 5], 2) == 40 assert product_except_index([3, 2, 1], 1) == 3 assert product_except_index([-1, 2, -3, 4], 3) == 6 assert product_except_index([10, 0, 4, 5], 1) == 200 assert product_except_index([7, 9], 0) == 9 ``` # Error Handling ```python try: product_except_index([1, 2, 3], -1) except ValueError as e: assert str(e) == \\"Index out of bounds\\" try: product_except_index([1, 3, 5], 3) except ValueError as e: assert str(e) == \\"Index out of bounds\\" try: product_except_index(123, 1) except TypeError as e: assert str(e) == \\"Input nums must be a list of integers\\" try: product_except_index([1, 2, 3], \\"1\\") except TypeError as e: assert str(e) == \\"Index must be an integer\\" ``` # Implementation Notes To achieve the desired efficiency, you should iterate through the list while maintaining the product of all numbers, excluding the specified index. Consider avoiding creating unnecessary intermediate lists.","solution":"def product_except_index(nums: list, index: int) -> int: Take in a list of integers and an index, return the product of all integers in the list except for the one at the given index. :param nums: List of integers :param index: Integer, the index of the element to exclude :return: An integer, the product of all integers in `nums` except the one at `index`. Raise ValueError for invalid indices. Raise TypeError for non-list or non-integer index types. # Type checks if not isinstance(nums, list): raise TypeError(\\"Input nums must be a list of integers\\") if not isinstance(index, int): raise TypeError(\\"Index must be an integer\\") # Bounds check if index < 0 or index >= len(nums): raise ValueError(\\"Index out of bounds\\") total_product = 1 for i, num in enumerate(nums): if i != index: total_product *= num return total_product"},{"question":"**Problem Description**: You are given an array of integers where each integer represents the elevation of a point at that index. The objective is to calculate the maximum amount of water that can be trapped after raining, given the elevation map. **Objective**: Write a function `max_water_trapped(elevations: List[int]) -> int` that returns the maximum amount of water that can be trapped after raining. **Function Signature**: ```python def max_water_trapped(elevations: List[int]) -> int: pass ``` **Input**: - `elevations`: A list of integers where each integer represents elevation at that index. The length of the list will be between 1 and 100,000, and each integer will be between 0 and 10,000. **Output**: - An integer representing the maximum amount of water trapped. **Constraints**: 1. If the input list has fewer than 3 elements, the function should return 0. 2. The solution should efficiently handle the given constraints on input size and range. **Performance Requirements**: - The solution should ideally be linear in time complexity, i.e., O(n). **Example**: ```python >>> max_water_trapped([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_water_trapped([4, 2, 0, 3, 2, 5]) 9 >>> max_water_trapped([1, 2]) 0 >>> max_water_trapped([3, 0, 2, 0, 4]) 7 ``` **Explanation**: 1. This problem involves using two-pointer technique or pre-computed arrays to determine the water trapped at each index. 2. Ensure efficient traversal of the list to respect time complexity constraints. 3. Handling of edge cases like very small input lists is crucial to the robustness of the solution.","solution":"from typing import List def max_water_trapped(elevations: List[int]) -> int: if len(elevations) < 3: return 0 left, right = 0, len(elevations) - 1 left_max, right_max = elevations[left], elevations[right] water_trapped = 0 while left < right: if elevations[left] < elevations[right]: left += 1 left_max = max(left_max, elevations[left]) water_trapped += max(0, left_max - elevations[left]) else: right -= 1 right_max = max(right_max, elevations[right]) water_trapped += max(0, right_max - elevations[right]) return water_trapped"},{"question":"# Problem Statement You are given a grid representing a maze with `n` rows and `m` columns, where each cell in the grid is either a wall (`\'#\'`) or a free space (`\'.\'`). A robot starts at the top-left corner of the maze and needs to reach the bottom-right corner. The robot can move up, down, left, or right, but cannot pass through walls. Design a function `find_shortest_path` that finds the shortest path from the start to the destination, or returns `-1` if no such path exists. # Input Format: - An integer `n`, the number of rows in the maze. - An integer `m`, the number of columns in the maze. - A list of `n` strings, each string representing a row of the maze. Each character in a string is either `\'.\'` or `\'#\'`. # Output Format: - An integer representing the length of the shortest path from the top-left corner to the bottom-right corner, or `-1` if no such path exists. # Constraints: - 1 ≤ n, m ≤ 100 - The maze will always have at least one cell (i.e., n, m ≥ 1). - The cell at the top-left corner (0, 0) and the bottom-right corner (n-1, m-1) will always be `\'.\'`. # Example: ```python find_shortest_path(3, 4, [ \\"....\\", \\"..\\", \\"....\\" ]) # 5 find_shortest_path(3, 4, [ \\"....\\", \\"\\", \\"....\\" ]) # -1 find_shortest_path(1, 1, [ \\".\\" ]) # 0 ``` # Task Requirements: - Implement the function `find_shortest_path(n, m, maze)` that returns the length of the shortest path, or `-1` if no path exists. - Optimize your solution to run efficiently given the constraints. # Notes: - You may use BFS (Breadth-First Search) for finding the shortest path in an unweighted grid. - Consider edge cases such as very small grids or grids with no walls. ```python from collections import deque def find_shortest_path(n, m, maze): # Implement your shortest path finding algorithm here # Directions for movement: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): # Check if a cell is within the grid and not a wall return 0 <= x < n and 0 <= y < m and maze[x][y] == \'.\' queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Example usage: # print(find_shortest_path(3, 4, [\\"....\\", \\"..\\", \\"....\\"])) # Output: 5 # print(find_shortest_path(3, 4, [\\"....\\", \\"\\", \\"....\\"])) # Output: -1 # print(find_shortest_path(1, 1, [\\".\\"])) # Output: 0 ```","solution":"from collections import deque def find_shortest_path(n, m, maze): Finds the shortest path from the top-left corner to the bottom-right corner in a maze. Returns the length of the shortest path, or -1 if no path exists. # Directions for movement: down, up, right, left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): # Check if a cell is within the grid and not a wall return 0 <= x < n and 0 <= y < m and maze[x][y] == \'.\' queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # Example usage: # print(find_shortest_path(3, 4, [\\"....\\", \\"..\\", \\"....\\"])) # Output: 5 # print(find_shortest_path(3, 4, [\\"....\\", \\"\\", \\"....\\"])) # Output: -1 # print(find_shortest_path(1, 1, [\\".\\"])) # Output: 0"},{"question":"# Task You are required to implement a function that performs matrix multiplication on two given matrices. Ensure the function handles both square and non-square matrices efficiently. # Function Signature ```python def matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: pass ``` # Input * `matrix_a (list[list[int]])`: A list of lists where each sublist represents a row of the first matrix. All rows will have the same number of elements. * `matrix_b (list[list[int]])`: A list of lists where each sublist represents a row of the second matrix. All rows will have the same number of elements. # Output * A list of lists where each sublist represents a row of the resulting matrix after multiplication. # Constraints * The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. * Both matrices will contain only integer elements. # Example ```python # Example matrices matrix_a = [[1, 2], [3, 4]] matrix_b = [[5, 6], [7, 8]] # Multiplying the matrices result_matrix = matrix_multiply(matrix_a, matrix_b) print(result_matrix) # Output: [[19, 22], [43, 50]] ``` # Notes You should implement the `matrix_multiply` function to ensure it checks for the compatibility of matrix dimensions for multiplication before proceeding with the calculations. Ensure that the function handles edge cases, such as empty matrices or incompatible dimensions, appropriately. # Considerations * Efficiently nested loops can be used for matrix multiplication. * Make sure to account for potential large input sizes and optimize where possible.","solution":"def matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Multiplies two matrices matrix_a and matrix_b. # Number of rows and columns in the resulting matrix num_rows_a = len(matrix_a) num_cols_a = len(matrix_a[0]) num_cols_b = len(matrix_b[0]) # Initialize the resulting matrix with zeros result_matrix = [[0 for _ in range(num_cols_b)] for _ in range(num_rows_a)] # Perform matrix multiplication for i in range(num_rows_a): for j in range(num_cols_b): for k in range(num_cols_a): result_matrix[i][j] += matrix_a[i][k] * matrix_b[k][j] return result_matrix"},{"question":"# Longest Consecutive Sequence (HashSet Technique) Context: You need to find the length of the longest consecutive elements sequence from an unsorted array of integers. The algorithm should run in O(n) time complexity. Input: An unsorted array of integers. Output: Return a single integer, which represents the length of the longest sequence of consecutive numbers. Requirements: * The solution is expected to achieve O(n) time complexity using a HashSet. Constraints: * All numbers in the array are unique. * Array length can be up to 10,000. * The range of the array elements is from -10^6 to 10^6. Example: Given the following array: ``` [100, 4, 200, 1, 3, 2] ``` The output should be: ``` 4 ``` Explanation: The longest consecutive elements sequence is `[1, 2, 3, 4]`, and its length is 4. # Task: Implement the function `longest_consecutive(nums: List[int]) -> int` which returns the length of the longest consecutive elements sequence. ```python from typing import List def longest_consecutive(nums: List[int]) -> int: # Your implementation goes here pass # Example Usage: # assert longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 ```","solution":"from typing import List def longest_consecutive(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Only start counting if `num` is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Question: Bitwise Manipulation for Efficient Memory Use Background Bitwise operations allow efficient manipulation of individual bits in binary numbers. They are particularly useful in systems and applications where memory and performance considerations are critical. Task Your task is to implement a set of functions that use bitwise operations to manipulate and query individual bits within an integer. This can be useful for compression, fast access, and flag handling in systems programming. # Function Specifications `set_bit(number: int, position: int) -> int` - **Input**: `number` (int), `position` (int) - **Output**: Returns the integer obtained by setting the bit at `position` to 1. - **Constraints**: - `position` should be between 0 and 31 inclusive. `clear_bit(number: int, position: int) -> int` - **Input**: `number` (int), `position` (int) - **Output**: Returns the integer obtained by clearing the bit at `position` (setting it to 0). - **Constraints**: - `position` should be between 0 and 31 inclusive. `toggle_bit(number: int, position: int) -> int` - **Input**: `number` (int), `position` (int) - **Output**: Returns the integer obtained by toggling the bit at `position` (flipping it from 0 to 1 or from 1 to 0). - **Constraints**: - `position` should be between 0 and 31 inclusive. `check_bit(number: int, position: int) -> bool` - **Input**: `number` (int), `position` (int) - **Output**: Returns `True` if the bit at `position` is 1, otherwise `False`. - **Constraints**: - `position` should be between 0 and 31 inclusive. # Example Usage ```python print(set_bit(8, 1)) # Output: 10 print(clear_bit(10, 1)) # Output: 8 print(toggle_bit(10, 1)) # Output: 8 print(toggle_bit(8, 1)) # Output: 10 print(check_bit(8, 3)) # Output: True print(check_bit(10, 1)) # Output: True ``` # Notes 1. Ensure that invalid positions or out-of-range inputs are handled with appropriate error messages or exceptions. 2. Optimize bitwise operations to leverage the speed and efficiency of low-level bit manipulation. By extending your skills in bitwise operations, you\'ll gain a deeper understanding of how binary representations and efficient memory usage can impact software performance.","solution":"def set_bit(number: int, position: int) -> int: Sets the bit at the specified position to 1. :param number: Integer number to modify. :param position: Position of the bit to set (0-indexed). :return: Integer with the bit at the specified position set to 1. if position < 0 or position > 31: raise ValueError(\\"Position must be between 0 and 31 inclusive.\\") return number | (1 << position) def clear_bit(number: int, position: int) -> int: Clears the bit at the specified position (sets it to 0). :param number: Integer number to modify. :param position: Position of the bit to clear (0-indexed). :return: Integer with the bit at the specified position cleared. if position < 0 or position > 31: raise ValueError(\\"Position must be between 0 and 31 inclusive.\\") return number & ~(1 << position) def toggle_bit(number: int, position: int) -> int: Toggles the bit at the specified position (flips it from 0 to 1 or from 1 to 0). :param number: Integer number to modify. :param position: Position of the bit to toggle (0-indexed). :return: Integer with the bit at the specified position toggled. if position < 0 or position > 31: raise ValueError(\\"Position must be between 0 and 31 inclusive.\\") return number ^ (1 << position) def check_bit(number: int, position: int) -> bool: Checks if the bit at the specified position is 1. :param number: Integer number to check. :param position: Position of the bit to check (0-indexed). :return: True if the bit at the specified position is 1, otherwise False. if position < 0 or position > 31: raise ValueError(\\"Position must be between 0 and 31 inclusive.\\") return (number & (1 << position)) != 0"},{"question":"# Problem Statement: Create a function `factorial_trailing_zeros(n: int) -> int` that returns the number of trailing zeros in the factorial of a given non-negative integer `n`. # Input: - `n`: A non-negative integer (0 <= n <= 10^5). # Output: - The number of trailing zeros in `n!`. # Constraints: 1. The input integer `n` is within the range from 0 to 100,000 inclusive. # Performance Requirements: - Your solution should efficiently handle the maximum constraints within a reasonable time frame. # Example: Consider the following value of `n`: ``` n = 100 ``` 100! (factorial of 100) has 24 trailing zeros. # Function Signature: ```python def factorial_trailing_zeros(n: int) -> int: pass ``` # Notes: - A trailing zero is created with multiples of 10 and could be counted by counting pairs of 2s and 5s in the factors of all numbers up to `n`. - Since there are usually more factors of 2 than 5, count the number of 5s in the factors of the numbers from 1 to `n`. # Example Test Case: ```python def test_factorial_trailing_zeros(): assert factorial_trailing_zeros(100) == 24 assert factorial_trailing_zeros(50) == 12 assert factorial_trailing_zeros(10) == 2 assert factorial_trailing_zeros(0) == 0 assert factorial_trailing_zeros(5) == 1 # Additional tests needed for complete verification ``` Write code that efficiently calculates the number of trailing zeros in the factorial of a given number.","solution":"def factorial_trailing_zeros(n: int) -> int: Returns the number of trailing zeros in the factorial of a given non-negative integer n. count = 0 power_of_five = 5 while n >= power_of_five: count += n // power_of_five power_of_five *= 5 return count"},{"question":"# Problem Statement: You have been assigned to create a data compression algorithm that minimizes the storage space required for certain text files. One popular approach in data compression is the Run-Length Encoding (RLE) which encodes consecutive repeated characters as a single character followed by the number of repetitions. Your task is to implement the RLE algorithm to compress input strings. # Function Signature: ```python def run_length_encode(input_string: str) -> str: ``` # Input: - `input_string` (str): A non-empty string consisting of printable ASCII characters. # Output: - (str): The compressed string using RLE. # Constraints: - The input string will have at most length 10^5. # Example: ```python >>> run_length_encode(\'AAAABBBCCDAA\') \'A4B3C2D1A2\' >>> run_length_encode(\'ABCD\') \'A1B1C1D1\' ``` # Requirements: 1. Implement the Run-Length Encoding algorithm. 2. Optimize the function to handle large input strings efficiently. 3. Consider edge cases such as input strings with varying types and distributions of characters. # Notes: - Ensure that the encoded string is correctly formatted as described. - Pay attention to performance for long strings and aim to keep the implementation efficient in terms of both time and space complexity. Good luck with your implementation!","solution":"def run_length_encode(input_string: str) -> str: Implement the Run-Length Encoding (RLE) algorithm to compress input strings. Args: - input_string (str): A non-empty string consisting of printable ASCII characters. Returns: - str: The compressed string using RLE. if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{current_char}{count}\\") current_char = char count = 1 encoded_string.append(f\\"{current_char}{count}\\") return \'\'.join(encoded_string)"},{"question":"# Problem Statement You are given an array of integers `nums` with length `n` representing signal strengths. Your task is to write a function that finds the maximum number of signals that can form a strictly increasing sequence without reordering the elements in the array. # Input * An array `nums` of length `n` where `n` is at least 1 and at most 10^3 and each `nums[i]` is an integer in the range [-10^4, 10^4]. # Output * An integer representing the length of the longest strictly increasing subsequence within `nums`. # Constraints 1. The array `nums` may contain both positive and negative integers. 2. The sequence should be increasing but the elements must retain their order in the initial array `nums`. # Example Example 1: ```python nums = [10, 9, 2, 5, 3, 7, 101, 18] ``` * Output: `4` (The longest increasing subsequence is [2, 3, 7, 18]) Example 2: ```python nums = [0, 1, 0, 3, 2, 3] ``` * Output: `4` (The longest increasing subsequence is [0, 1, 2, 3]) # Function Signature ```python def length_of_LIS(nums: List[int]) -> int: ``` # Detailed Explanation Your task is to implement the above function to compute the length of the longest increasing subsequence efficiently. Remember, subsequences are not required to be contiguous, but they must respect the original order of elements in the array. Utilize dynamic programming to ensure your solution is optimized for performance within the given constraints. Be sure to handle edge cases and validate input where necessary.","solution":"def length_of_LIS(nums): Finds the length of the longest increasing subsequence in nums. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question **Problem Statement**: You are given a data structure representing a basic binary tree with integer values. Your task is to implement functionality to find the sum of values at each level of the binary tree and return a list containing the sum for each level. **Objective**: 1. Write a function called `level_sum(root: Optional[TreeNode]) -> List[int]` that accepts a binary tree root node and returns a list where each element represents the sum of values at that level of the tree. - The function should return an empty list if the tree is empty (i.e., the root is `None`). **Constraints**: - The number of nodes in the tree will be in the range 0 to 1000. - Each node\'s value will be between -1000 and 1000. **Input**: - The root of a binary tree. **Output**: - A list of integers, where the i-th element is the sum of the values of nodes at the i-th level of the tree. **Examples**: 1. Given the binary tree: ``` 1 / 2 3 / 4 5 6 ``` `level_sum` should return `[1, 5, 15]`. 2. Given the binary tree: ``` 5 / 3 8 / 2 ``` `level_sum` should return `[5, 11, 2]`. 3. Given the binary tree: ``` -10 / 20 30 ``` `level_sum` should return `[-10, 50]`. 4. Given an empty tree: ``` None ``` `level_sum` should return `[]`. **Notes**: This problem will test your understanding of tree traversal techniques (especially level order traversal) and handling edge cases such as empty trees. --- This question ensures that candidates can handle tree traversal and data aggregation, which are important skills in many coding exercises and real-world applications.","solution":"from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def level_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) result = [] while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"**Least Common Multiple Array Query** **Objective**: Implement a function to precompute the Least Common Multiple (LCM) values for all pairs of integers from 1 to `n`. The function should also efficiently handle queries to return the LCM for given pairs. **Problem Statement**: Write a function `precompute_lcm_and_query(n: int, queries: list) -> list` that performs the following tasks: 1. Computes the LCM values for all pairs of integers (i, j) where 1 ≤ i ≤ j ≤ `n`. 2. Handles a list of queries, where each query is a tuple of two integers `(a, b)`, and returns the precomputed LCM value for the given pair `(a, b)`. **Function Signature**: ```python def precompute_lcm_and_query(n: int, queries: list) -> list: pass ``` **Input**: * `n` (integer, 1 ≤ n ≤ 500): The upper limit for calculating LCM values. * `queries` (list, 1 ≤ len(queries) ≤ 10^5): List of tuples where each tuple `(a, b)` (1 ≤ a, b ≤ n) represents a query to get the LCM value for the pair `(a, b)`. **Output**: * List of integers where the `i-th` element is the LCM of the pair `(a, b)` from `queries[i]`. **Constraints**: * Efficiently precompute the LCM values for pairs within the given range. * Optimize the query process to return the results in constant time after precomputation. **Example**: ```python n = 10 queries = [(1, 2), (3, 4), (5, 10), (6, 6)] result = precompute_lcm_and_query(n, queries) print(result) # Result should be [2, 12, 10, 6] ``` **Explanation**: For `n = 10`, the relevant LCM calculations should yield feasible values: * LCM(1, 2) = 2 * LCM(3, 4) = 12 * LCM(5, 10) = 10 * LCM(6, 6) = 6 Query results: * LCM(1, 2) = 2 * LCM(3, 4) = 12 * LCM(5, 10) = 10 * LCM(6, 6) = 6 These results should be returned in the order matching the query list.","solution":"from math import gcd def lcm(x, y): return x * y // gcd(x, y) def precompute_lcm_and_query(n: int, queries: list) -> list: lcm_table = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(i, n + 1): lcm_table[i][j] = lcm(i, j) results = [] for a, b in queries: if b < a: a, b = b, a results.append(lcm_table[a][b]) return results"},{"question":"# Coding Question: You are required to implement a function that checks whether a given sequence of integers can form an arithmetic progression after at most one swap of any two elements. **Function Signature:** ```python def can_form_arithmetic_seq(arr: list[int]) -> bool: pass ``` # Input: - `arr` (list of int): A list of integers representing the sequence to be checked. # Output: - Returns `True` if it\'s possible to rearrange the sequence (by making at most one swap) to form an arithmetic progression, otherwise `False`. # Constraints: 1. The length of `arr` will be between 2 and 10<sup>5</sup>. 2. The elements of `arr` will be between -10<sup>9</sup> and 10<sup>9</sup>. # Performance Requirements: - The function should run in O(n) time complexity where n is the length of the input list. - The space complexity should be O(1) apart from input storage. # Test Cases: 1. `can_form_arithmetic_seq([3, 1, 2])` should return `True` (sequence after sorting: 1, 2, 3). 2. `can_form_arithmetic_seq([1, 3, 3, 1, 2])` should return `False` (cannot form an arithmetic progression). 3. `can_form_arithmetic_seq([1, 2, 4, 3])` should return `True` (one swap between 3 and 4 forms the sequence 1, 2, 3, 4). 4. `can_form_arithmetic_seq([-1, 0, 1])` should return `True` (already forms an arithmetic progression). 5. `can_form_arithmetic_seq([5, 10, 15, 5])` should return `False` (cannot form an arithmetic progression). # Scenario: This problem can be quite relevant in data analysis or verifying patterns in sequences where the datasets might have minor discrepancies due to errors. For example, ensuring the integrity of time series data that might be slightly out of order due to data collection issues. Implement the function following these guidelines and ensure it handles various edge cases robustly.","solution":"def can_form_arithmetic_seq(arr): Checks whether a given sequence can form an arithmetic progression after at most one swap of any two elements. Parameters: arr (list of int): The sequence of integers to check. Returns: bool: True if one swap can result in an arithmetic progression, False otherwise. n = len(arr) if n <= 2: return True # Any sequence of length 2 or less is trivially an arithmetic sequence sorted_arr = sorted(arr) diffs = [sorted_arr[i] - sorted_arr[i - 1] for i in range(1, n)] if len(set(diffs)) == 1: return True # Already can form an arithmetic progression # Test the possibility with one swap def is_arithmetic_with_one_swap(arr): for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] if len(set(arr[k] - arr[k - 1] for k in range(1, n))) == 1: return True arr[i], arr[j] = arr[j], arr[i] return False return is_arithmetic_with_one_swap(arr)"},{"question":"# Question You are asked to implement a function to generate the tribonacci sequence. The tribonacci sequence is similar to the Fibonacci sequence except that each term is the sum of the preceding three terms. The sequence starts with three specified initial terms `a`, `b`, and `c`. Implementation Details Write a Python function `tribonacci(n: int, a: int, b: int, c: int) -> List[int]` that generates the first `n` terms of the tribonacci sequence starting with the given initial terms. Input * `n` (int): The number of terms to generate (`n` >= 1). * `a` (int): The first term of the sequence. * `b` (int): The second term of the sequence. * `c` (int): The third term of the sequence. Output * A list of integers representing the first `n` terms of the tribonacci sequence. Constraints * If `n < 1`, the function should raise a `ValueError` with the message \\"Invalid input: n must be >= 1.\\" Example ```python >>> tribonacci(1, 0, 1, 1) [0] >>> tribonacci(5, 0, 1, 1) [0, 1, 1, 2, 4] >>> tribonacci(7, 3, 5, 6) [3, 5, 6, 14, 25, 45, 84] >>> tribonacci(4, -1, -1, -2) [-1, -1, -2, -4] >>> tribonacci(0, 1, 2, 3) Traceback (most recent call last): ... ValueError: Invalid input: n must be >= 1. ``` **Hint**: Use a loop to generate each term after the initial three, keeping track of the last three terms at each step.","solution":"def tribonacci(n, a, b, c): Generate the first n terms of the tribonacci sequence starting with a, b, and c. if n < 1: raise ValueError(\\"Invalid input: n must be >= 1.\\") sequence = [] if n >= 1: sequence.append(a) if n >= 2: sequence.append(b) if n >= 3: sequence.append(c) for i in range(3, n): next_term = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_term) return sequence"},{"question":"# Coding Assessment Question Context You have been assigned to develop a feature that verifies the integrity of data being processed by a function used within a data pipeline. One part of this task involves ensuring that the function `process_data` correctly processes and returns cleaned data, removing any malformed entries from an input list of dictionaries. Task Implement a function `test_process_data_cleans_data` using unit testing and mocking to verify that the `process_data` function properly filters out invalid data entries. Function Signature ```python def test_process_data_cleans_data(): pass ``` Description 1. **Setup**: - Write a test case using the `unittest` framework to validate the functionality of the `process_data` function. - Use mock data that includes a mixture of valid and malformed dictionary entries. 2. **Data Criteria**: - A dictionary is considered valid if it contains specific required keys: `name`, `age`, and `email`, each with non-empty values. - Malformed entries may be dictionaries missing any of the required keys or containing empty values for these keys. 3. **Interactions**: - The test should call the `process_data` function with the mixed list of dictionaries. - Verify that the resulting list contains only those dictionaries that meet the validity criteria. 4. **Assertions**: - Validate the length of the output list to match the number of valid dictionaries. - Ensure each entry in the output list is a valid dictionary according to the given criteria. - Confirm that no malformed entries are present in the result. Example ```python def test_process_data_cleans_data(): # Sample mock data including valid and invalid dictionaries. mock_data = [ {\\"name\\": \\"John Doe\\", \\"age\\": 30, \\"email\\": \\"john.doe@example.com\\"}, {\\"name\\": \\"\\", \\"age\\": 25, \\"email\\": \\"jane.doe@example.com\\"}, {\\"name\\": \\"Alice\\", \\"email\\": \\"alice@example.com\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 44, \\"email\\": \\"\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 29, \\"email\\": \\"charlie@example.com\\"} ] # Expected output after processing would only include valid entries: expected_result = [ {\\"name\\": \\"John Doe\\", \\"age\\": 30, \\"email\\": \\"john.doe@example.com\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 29, \\"email\\": \\"charlie@example.com\\"} ] # Call the process_data function with the mock data result = process_data(mock_data) # Assert the result matches the expected output assert result == expected_result, f\\"Expected {expected_result} but got {result}\\" # Additional assertions can be added if necessary pass # You should test the structure by running it with a mock implementation of process_data. ``` Constraints - Use the `unittest` framework for structuring your test. - Assume `process_data` is a function from the `data_pipeline.processing` module. - Be mindful of various edge cases, such as entirely empty dictionaries or ones with unexpected additional keys. Additional Notes - Focus on validating the core functionality of the data cleaning process. - Consider edge cases and how your test might need to be adapted to handle them adequately. - This test should not depend on extraneous state or global variables to ensure consistency.","solution":"def process_data(data): Filters out invalid entries in the list of dictionaries. A dictionary is considered valid if it contains non-empty \'name\', \'age\', and \'email\' keys. required_keys = {\'name\', \'age\', \'email\'} def is_valid(entry): # Check if all required keys are in the dictionary and non-empty return all(key in entry and entry[key] for key in required_keys) # Filter data and return only valid entries return [entry for entry in data if is_valid(entry)]"},{"question":"# Coding Assessment Question **Context**: Iterating over cyclical sequences efficiently can be crucial in scenarios such as dealing with circular queues or round-robin scheduling. **Question**: Implement a function `find_kth_element(sequence: List[int], k: int) -> int` that returns the k-th element in a list when treated as circular. The indexing is 0-based. **Function Signature**: ```python def find_kth_element(sequence: List[int], k: int) -> int: ``` **Input**: * `sequence` (List[int]): A list of integers that represents the sequence. * `k` (int): A non-negative integer specifying the index in the sequence, considering the list as circular. **Output**: * An integer representing the k-th element in the circular sequence. **Constraints**: * The input list will have at least one and at most 10^5 elements. * The value of `k` will be in the range [0, 10^9]. * Elements of the list can be negative or positive integers. **Performance Requirements**: * The solution should have a time complexity of O(1), independent of the length of the sequence, and utilizing modulo arithmetic. * The space complexity should be O(1), with no additional data structures to be used beyond a few variables for calculations. **Examples**: 1. `find_kth_element([1, 2, 3, 4, 5], 7) -> 3` 2. `find_kth_element([10, 20, 30], 4) -> 20` 3. `find_kth_element([5], 999) -> 5` 4. `find_kth_element([8, 6, 7, 5, 3, 0, 9], 10) -> 5` 5. `find_kth_element([-1, -2, -3], 2) -> -3` **Notes**: * Ensure that your function handles very large values of `k` efficiently. * Think about the minimal mathematical operations required to determine the k-th element. * Edge cases such as single-element lists should return the element itself regardless of k\'s value.","solution":"def find_kth_element(sequence, k): Returns the k-th element in the sequence when treated as circular. n = len(sequence) return sequence[k % n]"},{"question":"# Coding Assessment Question **Context**: Navigating through a grid-like structure is a common problem in robotics, pathfinding algorithms, and game development. One foundational problem in grid navigation is identifying the path of minimum cost from one cell to another, where each cell has an associated movement cost. **Problem Statement**: Implement a function `min_cost_path` that calculates the minimum cost path from the top-left corner to the bottom-right corner of a 2D grid. The cost of path is defined as the sum of the values of the cells along the path. You may only move right or down at any point in time. # Function Signature: ```python def min_cost_path(grid: list[list[int]]) -> int: pass ``` # Input: * `grid` (List[List[int]]): A non-empty 2D grid of integers where `grid[i][j]` represents the cost at cell (i, j). # Output: * Returns an integer indicating the minimum path cost from the top-left corner to the bottom-right corner of the grid. # Constraints: * The dimensions of the grid will be `[1...100][1...100]`. * The cost values `grid[i][j]` will be non-negative integers within the range `[0, 100]`. # Performance Requirements: * Time Complexity should be O(m * n), where m and n are the number of rows and columns of the grid respectively. * Space Complexity should be O(m * n) due to the use of an auxiliary 2D table. # Example: ```python >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6]]) 12 >>> min_cost_path([[1]]) 1 >>> min_cost_path([[10, 20], [30, 40]]) 70 >>> min_cost_path([[1, 2], [1, 1]]) 3 ``` # Additional Requirements: * Ensure that the function handles edge cases correctly including single cell grids. * Minimize the space complexity by optimizing the auxiliary space used, if possible. # Hints: * Use dynamic programming to build up the solution incrementally by storing the minimum cost to reach each cell. * Traverse the grid and for each cell, choose the minimum cost from the top or left cell plus the current cell’s cost.","solution":"def min_cost_path(grid: list[list[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"# Word Frequency Counter Scenario You are developing a feature for a document analysis tool that requires counting the frequency of each word in a given text. This tool will help users quickly identify the most common words in their documents. Problem Statement Write a function `word_frequency` that takes a string `document` and returns a dictionary with words as keys and their respective frequency counts as values. Input and Output * **Input**: A string `document` containing words separated by whitespace. Punctuation should be ignored, and words should be treated as case-insensitive. * **Output**: A dictionary where the keys are words (in lowercase) and the values are integers representing the count of each word in the document. Constraints: * The function must handle strings of length up to 10^5. * Only typical ASCII characters will be in the string. * Punctuation includes: .,!?;:\'\\"ntr, which should be ignored when counting words. Example: ```python >>> word_frequency(\\"Hello, world! Hello!\\") {\'hello\': 2, \'world\': 1} >>> word_frequency(\\"Python is great. Python is fun!\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'fun\': 1} >>> word_frequency(\\"A man, a plan, a canal, Panama.\\") {\'a\': 3, \'man\': 1, \'plan\': 1, \'canal\': 1, \'panama\': 1} >>> word_frequency(\\" \\") {} >>> word_frequency(\\"\\") {} ``` Requirements: * Write the function to adhere closely to efficient string parsing operations in terms of time and space complexity. * It should handle mixed-character input and edge cases gracefully. Notes: * You can assume that words are delimited by whitespace characters only. * The function must be self-contained and should not depend on any external modules other than basic Python libraries.","solution":"import re from collections import defaultdict def word_frequency(document): Returns a dictionary with the frequency count of each word in the document. Punctuation is ignored, words are treated as case-insensitive. Args: document (str): The input text document. Returns: dict: Dictionary with words as keys and their frequencies as values. # Lowercase the entire document to make it case-insensitive document = document.lower() # Remove punctuation document = re.sub(r\'[^ws]\', \'\', document) # Split the document into words words = document.split() # Initialize a default dictionary to store word frequencies word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Scenario and Context In a cybersecurity application, it\'s necessary to detect anomalies in time-stamped event logs. Your task is to design a filter function that identifies potential anomalies based on irregular time gaps between successive log entries. # Task Description Write a function named `detect_anomalies` that identifies potential anomalies in a list of time-stamped event logs. The function should check the gaps between successive timestamps and flag entries that exceed a predefined threshold. The output should be a list of indices where anomalies occur. # Function Signature ```python def detect_anomalies( timestamps: List[str], threshold: int ) -> List[int]: pass ``` # Input and Output - **Inputs**: - `timestamps` (List[str]): A list of event timestamps in ISO 8601 format (e.g., \\"2023-10-01T14:48:00\\"). - `threshold` (int): The maximum allowed gap (in seconds) between successive timestamps. - **Output**: - Returns a list of indices where the gap between successive timestamps exceeds the given threshold. The index should correspond to the latter timestamp in the anomaly. # Constraints - Ensure the `timestamps` list is in chronological order. - The function should handle lists of various lengths, including edge cases with no anomalies. # Examples ```python >>> timestamps = [\\"2023-10-01T14:48:00\\", \\"2023-10-01T14:49:00\\", \\"2023-10-01T15:00:00\\", \\"2023-10-01T15:30:00\\"] >>> threshold = 600 >>> detect_anomalies(timestamps, threshold) [2, 3] >>> timestamps = [\\"2023-10-01T14:48:00\\", \\"2023-10-01T14:49:00\\"] >>> threshold = 120 >>> detect_anomalies(timestamps, threshold) [] ```","solution":"from typing import List from datetime import datetime def detect_anomalies(timestamps: List[str], threshold: int) -> List[int]: Identifies potential anomalies in a list of time-stamped event logs based on gaps between successive timestamps that exceed a specified threshold. Parameters: - timestamps (List[str]): A list of event timestamps in ISO 8601 format. - threshold (int): The maximum allowed gap (in seconds) between successive timestamps. Returns: - List[int]: A list of indices where anomalies occur. The index corresponds to the latter timestamp in the anomaly. anomalies = [] for i in range(1, len(timestamps)): t1 = datetime.fromisoformat(timestamps[i - 1]) t2 = datetime.fromisoformat(timestamps[i]) gap = (t2 - t1).total_seconds() if gap > threshold: anomalies.append(i) return anomalies"},{"question":"# Problem Description You are tasked with implementing a function to generate a report of students\' grades from a list of scores using a specific grading scale. The function must validate the input to ensure it contains valid scores (integers between 0 and 100 inclusive). If any score is invalid, the function should raise a `ValueError`. # Function Signature ```python def generate_grade_report(scores: list) -> dict: pass ``` # Input * **scores** (list): A list of integers representing students\' scores, each between 0 and 100 inclusive. # Output * **report** (dict): A dictionary mapping letter grades (\'A\', \'B\', \'C\', \'D\', \'F\') to the count of students who received each grade. # Grading Scale - \'A\' for scores between 90 and 100 inclusive - \'B\' for scores between 80 and 89 inclusive - \'C\' for scores between 70 and 79 inclusive - \'D\' for scores between 60 and 69 inclusive - \'F\' for scores below 60 # Constraints * The list must contain valid integers between 0 and 100 inclusive. * If any score is outside the valid range, the function should raise a `ValueError`. # Examples ```python >>> generate_grade_report([95, 85, 75, 65, 55]) {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} >>> generate_grade_report([90, 90, 80, 70, 60, 50]) {\'A\': 2, \'B\': 1, \'C\': 1, \'D\': 1, \'F\': 1} >>> generate_grade_report([100, 49, 78, 83, 92, 67, 85]) {\'A\': 2, \'B\': 2, \'C\': 1, \'D\': 1, \'F\': 1} >>> generate_grade_report([101, 85, 90]) Traceback (most recent call last): ... ValueError: Scores must be integers between 0 and 100 inclusive. ``` # Note - You should ensure correctness and performance for typical use cases, such as processing scores for a class of students. - Handle edge cases where the input list contains scores at the boundaries of the grade ranges.","solution":"def generate_grade_report(scores): # Initialize the grade report report = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} # Validate scores and increment respective grade count for score in scores: if not isinstance(score, int) or not (0 <= score <= 100): raise ValueError(\\"Scores must be integers between 0 and 100 inclusive.\\") if 90 <= score <= 100: report[\'A\'] += 1 elif 80 <= score <= 89: report[\'B\'] += 1 elif 70 <= score <= 79: report[\'C\'] += 1 elif 60 <= score <= 69: report[\'D\'] += 1 else: report[\'F\'] += 1 return report"},{"question":"# Context In this assessment, you are required to implement a function that involves manipulating strings based on palindrome principles. Your understanding of string manipulation, recursion, and recognizing palindromic structures will be essential to solving this problem efficiently. # Problem Statement Design a function `recursive_make_palindrome` that takes a string and, by recursively adding the minimum number of characters to the original string, transforms it into a palindrome. # Function Signature ```python def recursive_make_palindrome(s: str) -> str: ``` # Input * A string `s` of lowercase alphabets. # Output * The function should return the shortest palindromic string that can be formed by adding characters to the input string `s`. # Constraints * You must use a recursive approach. * The input string `s` will have a length between 1 and 1000. * The output should be the lexicographically smallest palindrome if there is more than one solution. # Example ```python # Example 1 s = \\"race\\" print(recursive_make_palindrome(s)) # Output: \\"ecarace\\" # Example 2 s = \\"ab\\" print(recursive_make_palindrome(s)) # Output: \\"aba\\" # Example 3 s = \\"a\\" print(recursive_make_palindrome(s)) # Output: \\"a\\" ``` # Hints * Consider the base case where the string is already a palindrome. * Think about how you can recursively add characters to the beginning or end of the string to form a palindrome. * Use helper functions if necessary to keep the code clean and readable.","solution":"def recursive_make_palindrome(s: str) -> str: Transforms the input string into a palindrome by adding the minimum number of characters. # Helper function to check if a string is a palindrome def is_palindrome(x: str) -> bool: return x == x[::-1] # Base case: if the string is already a palindrome, return it if is_palindrome(s): return s # Recursive case: # If the first and last characters are the same, recursively process the substring without the first and last characters. # If they are not the same, we have two choices: # 1. Add the last character to the front and solve for s[1:] # 2. Add the first character to the end and solve for s[:-1] if s[0] == s[-1]: return s[0] + recursive_make_palindrome(s[1:-1]) + s[-1] else: option1 = s[-1] + recursive_make_palindrome(s[:-1]) + s[-1] option2 = s[0] + recursive_make_palindrome(s[1:]) + s[0] return min(option1, option2)"},{"question":"# Context Write a function to find the first non-repeating character in a given string. If there are no non-repeating characters, return an empty string. # Function Signature Write a function called `first_non_repeating_character` that takes in a single input string and returns a character. # Input * A single string ( s ) consisting of lowercase and/or uppercase English letters and digits. - ( 0 leq |s| leq 10^5 ) # Output * Returns the first non-repeating character in the string as a single character string. If no such character exists, return an empty string. # Constraints 1. The function should be case-sensitive. 2. Your implementation should be efficient with a time complexity of ( O(n) ). # Examples * `first_non_repeating_character(\\"swiss\\")` should return `\\"w\\"`. * `first_non_repeating_character(\\"teeter\\")` should return `\\"r\\"`. * `first_non_repeating_character(\\"aabbcc\\")` should return `\\"\\"`. * `first_non_repeating_character(\\"aA1bc1a\\")` should return `\\"A\\"`. # Implementation Ensure your solution handles edge cases such as empty strings or strings where all characters repeat.","solution":"def first_non_repeating_character(s): Finds the first non-repeating character in the input string. Params: s (str): Input string containing lowercase, uppercase, and/or digits. Returns: str: The first non-repeating character or empty string if none exist. char_count = {} # First pass to count the occurrence of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first character with a single occurrence for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"# Maximum Subarray Sum Function **Context:** You are working on a financial analysis tool that includes identifying the periods of highest profitability. One way to do this is by calculating the maximum sum of a contiguous subarray, which can indicate the best period of profit. **Task:** Implement the `max_subarray_sum` function in Python, which finds the maximum sum of any contiguous subarray within the given list of numerical data points. **Function Signature:** ```python def max_subarray_sum(data: Sequence[int]) -> int: pass ``` **Input:** * `data` (Sequence[int]): A list of integers representing time series data points (e.g., daily stock returns). **Output:** * Returns an integer representing the maximum sum of any contiguous subarray within the input data list. **Constraints:** * The input list can be empty or contain negative and positive integers. Handle edge cases appropriately. * Ensure your function is efficient and can handle large input sizes up to 10,000 data points. **Performance Requirements:** * Time complexity should be O(n), where n is the length of the input data. **Examples:** ```python >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-3, -2, -1, -4]) -1 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, 2, 3, -4, 5, -1]) 6 ``` **Notes:** Ensure the solution accounts for edge cases, such as empty input lists and all negative numbers. The function should return 0 if the input list is empty. For a list with only negative numbers, return the maximum of those numbers.","solution":"from typing import Sequence def max_subarray_sum(data: Sequence[int]) -> int: if not data: return 0 current_max = global_max = data[0] for num in data[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"# Shortest Path in a Weighted Directed Graph Context You are tasked with implementing an algorithm to find the shortest path from a given source node to all other nodes in a weighted directed graph. The graph is represented as an adjacency list, where each node has a list of tuples representing its neighbors and the weights of the edges connecting them. Task Write a function `shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]` that computes the shortest path from the `start` node to all other nodes using Dijkstra\'s algorithm. The function should return a dictionary where keys are node identifiers and values are the shortest distances from the `start` node to that key node. Requirements * **Input Format**: - `graph` (Dict[int, List[Tuple[int, int]]]): A dictionary of nodes where each key is a node id and the value is a list of tuples (neighbor_id, weight). - `start` (int): The starting node id. * **Output Format**: - Dict[int, int]: A dictionary where each key is a node id and the value is the shortest distance from the `start` node to that key node. * **Constraints**: - The number of nodes in the graph is at least 1 and at most 10^4. - The weights of the edges are non-negative integers. - If a node is unreachable from the start node, its shortest distance should be considered as float(\'inf\'). Performance * The function should efficiently handle graphs with up to 10^4 nodes and edges. Example Usage ```python # Example 1 graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } start = 0 distances = shortest_path(graph, start) print(distances) # Output: {0: 0, 1: 3, 2: 1, 3: 4} # Example 2 graph = { 0: [(1, 1), (2, 4)], 1: [(2, 2), (3, 6)], 2: [(3, 3)], 3: [] } start = 0 distances = shortest_path(graph, start) print(distances) # Output: {0: 0, 1: 1, 2: 3, 3: 6} ``` Edge Cases * Graph with a single node. * Graph with disconnected components where some nodes are unreachable from the start node. * Graph with multiple edges between two nodes with different weights.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Computes the shortest path from the start node to all other nodes using Dijkstra\'s algorithm. If a node is unreachable from the start node, its shortest distance is set to float(\'inf\'). distances = {node: float(\'inf\') for node in graph} distances[start] = 0 priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Scenario You want to create a simple queue system where people can join the queue, be removed from the queue, and check who is first in the queue. Your task is to implement a class that models this queue behavior. # Task Implement the class `SimpleQueue` which provides methods to add a person to the queue (`enqueue`), remove the first person from the queue (`dequeue`), and check the first person in the queue (`front`). # Class Signature ```python class SimpleQueue: def __init__(self): pass def enqueue(self, name: str) -> None: pass def dequeue(self) -> str: pass def front(self) -> str: pass ``` # Methods: * `__init__(self)` - Initializes the queue. * `enqueue(self, name: str) -> None` - Adds a person `name` (a string) to the end of the queue. * `dequeue(self) -> str` - Removes and returns the first person from the queue. If the queue is empty, return \\"Queue is empty\\". * `front(self) -> str` - Returns the first person in the queue without removing them. If the queue is empty, return \\"Queue is empty\\". # Examples: 1. Initialize the queue: ```python q = SimpleQueue() ``` 2. Add people to the queue: ```python q.enqueue(\\"Alice\\") q.enqueue(\\"Bob\\") q.enqueue(\\"Charlie\\") ``` 3. Check the first person: ```python q.front() # Output: \\"Alice\\" ``` 4. Remove the first person: ```python q.dequeue() # Output: \\"Alice\\" ``` 5. Check the first person again: ```python q.front() # Output: \\"Bob\\" ``` 6. Remove all remaining people: ```python q.dequeue() # Output: \\"Bob\\" q.dequeue() # Output: \\"Charlie\\" q.dequeue() # Output: \\"Queue is empty\\" ``` # Constraints: - The names in the queue will be non-empty strings. - The methods should handle cases where the queue is empty appropriately. - The implementation should ensure efficient management of the queue. # Note: Ensure the class handles the queue operations efficiently, mimicking a real-world queue behavior using appropriate data structures.","solution":"class SimpleQueue: def __init__(self): self.queue = [] def enqueue(self, name: str) -> None: Adds a person \'name\' to the end of the queue. self.queue.append(name) def dequeue(self) -> str: Removes and returns the first person from the queue. If the queue is empty, returns \\"Queue is empty\\". if self.queue: return self.queue.pop(0) else: return \\"Queue is empty\\" def front(self) -> str: Returns the first person in the queue without removing them. If the queue is empty, returns \\"Queue is empty\\". if self.queue: return self.queue[0] else: return \\"Queue is empty\\""},{"question":"# String Manipulation: Reverse Each Word Background In many text processing applications, we often need to manipulate strings. One common operation is reversing the order of characters in each word of a given sentence while keeping the words in the same order. Task Write a function `reverse_each_word(sentence: str) -> str` that takes a string sentence consisting of multiple words separated by spaces, and returns a new string where each word in the input sentence is reversed, but the order of the words remains unchanged. Input - `sentence`: A string containing words separated by single spaces. There will be no leading or trailing spaces, and there will be no consecutive spaces. Output - Returns a string where each word from the input sentence is reversed but appears in the original order. Constraints - `sentence` contains only printable ASCII characters and has a length between 1 and 1000 characters. Example ```python >>> reverse_each_word(\'Hello world\') \'olleH dlrow\' >>> reverse_each_word(\'Python programming is fun\') \'nohtyP gnimmargorp si nuf\' ``` Additional Notes - Ensure that the function handles sentences with varying lengths and word counts efficiently. - You may assume that words are strictly alphabetic for simplicity, though the function should handle any printable ASCII characters in practice.","solution":"def reverse_each_word(sentence: str) -> str: This function takes a string sentence consisting of multiple words separated by spaces, and returns a new string where each word in the input sentence is reversed, but the order of the words remains unchanged. words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"**Coding Problem: Implementing the A* Pathfinding Algorithm** # Problem Statement You are required to implement the A* pathfinding algorithm to find the shortest path from a given start node to a target node in a weighted, directed graph. To efficiently manage the node exploration, use a priority queue to select the next node with the lowest estimated total cost. You must implement the `a_star(graph, start, target, heuristic)` function. The `graph` is represented as an adjacency list where each entry `graph[node]` contains a list of tuples representing the neighbors and their respective edge weights. The `heuristic` is a function that estimates the cost from any node to the target. The `a_star` function should return the shortest path as a list of nodes from the `start` node to the `target` node. # Input - `graph`: A dictionary representing the graph, where keys are node names and values are lists of tuples `(neighbor, weight)`. Example: ```python { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } ``` - `start`: The starting node for the A* algorithm (a string). - `target`: The target node for the A* algorithm (a string). - `heuristic`: A function that takes two arguments, a current node and the target node, and returns an estimated cost (a numerical value) from the current node to the target. # Output - A list representing the shortest path from the start node to the target node. # Constraints - The graph contains no negative weight edges. - There is a valid path from the start node to the target node. - The heuristic function is admissible (never overestimates the true cost). # Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' target = \'D\' heuristic = lambda x, y: 0 # Simplified heuristic for demonstration print(a_star(graph, start, target, heuristic)) # Output: [\'A\', \'B\', \'C\', \'D\'] ``` # Implementation Details 1. Initialize the priority queue with the start node and set its cost to 0. 2. Maintain a dictionary to store the shortest known cost from the start to each node. 3. Use a dictionary to maintain the path taken to reach each node. 4. Use the priority queue to explore nodes with the lowest estimated total cost (current cost + heuristic). 5. Update the costs and paths of the neighbors and add or update them in the priority queue accordingly. 6. Repeat until the target node is reached or all reachable nodes have been explored. 7. Reconstruct the path from the start to the target using the path dictionary.","solution":"import heapq def a_star(graph, start, target, heuristic): Implements the A* pathfinding algorithm to find the shortest path from the start to the target node. Arguments: graph -- A dictionary representing the graph. start -- The starting node. target -- The target node. heuristic -- A function that estimates the cost from any node to the target. Returns: A list representing the shortest path from the start node to the target node. # Priority queue to store (cost, current_node, path taken) pq = [(0, start, [])] # Dictionary to store the best cost to reach each node costs = {start: 0} # Visited nodes visited = set() while pq: current_cost, current_node, path = heapq.heappop(pq) if current_node in visited: continue path = path + [current_node] if current_node == target: return path visited.add(current_node) for neighbor, weight in graph.get(current_node, []): new_cost = current_cost + weight if neighbor not in costs or new_cost < costs[neighbor]: costs[neighbor] = new_cost priority = new_cost + heuristic(neighbor, target) heapq.heappush(pq, (priority, neighbor, path)) # If we exit the while loop without finding the target, there\'s no path return []"},{"question":"Coding Assessment Question # Context: There is a game where the character collects coins placed in a series of houses along a street. The character must decide which houses to rob in order to maximize the total amount of coins collected. The character cannot rob two consecutive houses because it will alert the guards. Your task is to help the character determine the maximum amount of coins they can collect. # Problem: Given a list of integers representing the amount of coins in each house, determine the maximum amount of coins that can be collected without robbing two consecutive houses. # Function Signature: ```python def max_coins(houses: List[int]) -> int: ``` Input: - **houses**: A list of integers where each integer represents the amount of coins in a house. Output: - An integer representing the maximum amount of coins that can be collected. Constraints: - `1 ≤ len(houses) ≤ 1000` - `0 ≤ houses[i] ≤ 10^4` # Example: ```python # Input houses = [3, 2, 5, 10, 7] # Output 15 ``` # Explanation: The character can rob house 1 (coins = 3), house 3 (coins = 5), and house 4 (coins = 10). The total amount of coins collected is 3 + 5 + 7 = 15. # Guidelines: * Implement a dynamic programming solution to handle the constraints efficiently. * Keep track of the maximum coins collected up to each house considering whether the house is robbed or not. # Note: Consider various edge cases, such as: * Only one house available. * All houses have zero coins. * Maximum coins are only obtained by robbing non-consecutive houses.","solution":"from typing import List def max_coins(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] n = len(houses) dp = [0] * n dp[0] = houses[0] if n > 1: dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"# Coding Question Context In software systems, it\'s common to manage large amounts of data and perform operations on it efficiently. One challenge is to analyze chunked data streams where subsets of the data are processed separately and need to be correctly reassembled. In this question, you will implement a solution to manage and sort chunked data given in multiple parts, and then merge these parts to form the final sorted dataset. Task You are required to implement a function to manage the merging and sorting of chunked data streams: 1. **merge_and_sort_chunks(chunks: List[List[int]]) -> List[int]**: * Merges multiple sorted sub-lists (chunks) into a single sorted list. Input and Output Formats * `merge_and_sort_chunks`: * Input: A list of lists of integers, where each sub-list is already sorted. * Output: A single list of integers in sorted order. Performance Requirements Ensure that your solution is efficient and can handle large datasets. The total number of integers across all chunks combined will not exceed 10^6. Constraints * Each integer in the chunks will be in the range of -10^6 to 10^6. * Each chunk (sub-list) is individually sorted in non-decreasing order. * There can be between 1 and 10^5 chunks. * The total number of integers across all chunks combined will not exceed 10^6. Example ```python # Test cases assert merge_and_sort_chunks([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert merge_and_sort_chunks([[1, 3, 5], [2, 4, 6]]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort_chunks([[10, 20], [1, 2, 30], [-5, 0, 15]]) == [-5, 0, 1, 2, 10, 15, 20, 30] ```","solution":"import heapq from typing import List def merge_and_sort_chunks(chunks: List[List[int]]) -> List[int]: Merges multiple sorted sub-lists (chunks) into a single sorted list. # Use a min-heap to efficiently merge the sorted chunks. min_heap = [] for i, chunk in enumerate(chunks): if chunk: heapq.heappush(min_heap, (chunk[0], i, 0)) sorted_list = [] while min_heap: value, chunk_index, element_index = heapq.heappop(min_heap) sorted_list.append(value) # If there is another element in the same chunk, push it to the heap. if element_index + 1 < len(chunks[chunk_index]): next_element = chunks[chunk_index][element_index + 1] heapq.heappush(min_heap, (next_element, chunk_index, element_index + 1)) return sorted_list"},{"question":"# Matrix Transpose Function You need to implement a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list representing a matrix and returns its transpose. The transpose of a matrix is obtained by swapping the rows and columns, effectively flipping it over its diagonal. Requirements: 1. The function should take a 2D list `matrix` and return a new 2D list that is the transpose of the original matrix. 2. If the provided matrix is empty, the function should return an empty list. 3. The function should handle non-rectangular matrices (i.e., lists of lists with different lengths), transposing as far as possible. Constraints: - The `matrix` can be empty or contain up to 10^4 elements in total. - Elements of the matrix will be integers. Input: - `matrix: List[List[int]]` - a 2D list of integers representing the matrix to be transposed. Output: - `List[List[int]]` - a 2D list of integers representing the transposed matrix. Example: ```python assert transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert transpose_matrix([]) == [] assert transpose_matrix([[1, 2], [3]]) == [[1, 3], [2]] ``` # Function Signature: ```python from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] max_cols = max(len(row) for row in matrix) transposed = [] for col in range(max_cols): new_row = [] for row in matrix: if col < len(row): new_row.append(row[col]) else: new_row.append(None) transposed.append(new_row) # Remove None values from the end of rows transposed = [[elem for elem in row if elem is not None] for row in transposed] return transposed"},{"question":"# Problem Statement You are given two sorted lists `arr1` and `arr2`. Your task is to implement a function `find_common_elements(arr1: list, arr2: list) -> list` that finds all the common elements between the two lists and returns them in a new sorted list. # Function Signature ```python def find_common_elements(arr1: list, arr2: list) -> list: pass ``` # Input * `arr1` (list): The first sorted list of integers. (0 ≤ |arr1| ≤ 1000) * `arr2` (list): The second sorted list of integers. (0 ≤ |arr2| ≤ 1000) # Output * `list`: A sorted list containing the common elements from `arr1` and `arr2`. # Constraints * You may assume that the integers in `arr1` and `arr2` are unique within each list but may appear in both lists. * If there are no common elements, return an empty list. * The function should maintain the order in which elements appear in the original lists. # Examples ```python >>> find_common_elements([1, 2, 4, 5, 6], [2, 3, 5, 7]) [2, 5] >>> find_common_elements([10, 20, 30, 40, 50], [15, 25, 35, 45]) [] >>> find_common_elements([7, 8, 9], [7, 8, 9]) [7, 8, 9] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([100, 200], [50, 100, 150, 200]) [100, 200] ``` # Notes * Optimize the function to handle large lists efficiently. * Ensure the solution retains the sorted nature of the lists in the final output.","solution":"def find_common_elements(arr1, arr2): Finds the common elements between two sorted lists and returns them in sorted order. Parameters: - arr1: list, the first sorted list of integers - arr2: list, the second sorted list of integers Returns: - list: a sorted list containing the common elements # Initialize pointers for both lists i, j = 0, 0 result = [] # Traverse both lists until we reach the end of one of them while i < len(arr1) and j < len(arr2): if arr1[i] == arr2[j]: result.append(arr1[i]) i += 1 j += 1 elif arr1[i] < arr2[j]: i += 1 else: j += 1 return result"},{"question":"# Scenario A software company is creating a sorting algorithm to handle large, diverse datasets efficiently. They want a custom implementation that sorts an array of integers while optimally handling duplicate values. # Task Implement a function `custom_sort(arr: List[int]) -> List[int]` that sorts an array of integers in ascending order. This function should address cases where there are duplicate values by maintaining their relative order in the array (stable sort). # Input - `arr`: A list of integers, where each integer `x` satisfies -10^6 ≤ `x` ≤ 10^6, and the length of the list is between 1 and 10^5. # Output - A list of integers sorted in ascending order, with duplicates maintaining their relative ordering from the original array. # Constraints and Notes - Ensure the sorting algorithm you use maintains stability. - Handle large input sizes efficiently, aiming for time complexity as close to O(n log n) as possible. - Consider evaluating the algorithm\'s performance to ensure it meets efficiency requirements. # Example ```python >>> custom_sort([3, 3, 2, 1, 2]) [1, 2, 2, 3, 3] >>> custom_sort([4, -1, 0, 4, -1, -1]) [-1, -1, -1, 0, 4, 4] >>> custom_sort([1000000, -1000000, 0, 500000, -500000]) [-1000000, -500000, 0, 500000, 1000000] ``` # Additional Notes - Use a built-in sorting function if it guarantees stability and efficiency. - Test your function with various cases, including edge cases, to ensure correctness and performance.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sorts the array in ascending order while maintaining the relative order of duplicate elements. # Using Python\'s built-in sorted function which is stable and has O(n log n) time complexity return sorted(arr)"},{"question":"# Question: Implement a Custom Sorting Function You are given a list of integers where each integer lies within a specific range. Your task is to implement a custom sorting function called **modified_radix_sort** which utilizes the Radix Sort algorithm constrained by the assumption that all integers lie within the range of 0 to 999. Radix Sort is a non-comparative sorting algorithm that sorts integers by distributing them into buckets according to their individual digits. # Function Signature ```python def modified_radix_sort(arr: list) -> list: Arguments: arr: A list of integers. Returns: A list of integers sorted in ascending order. ``` # Expected Input and Output * **Input**: * `arr`: A list of integers (length n) where each integer is between 0 and 999. * **Output**: * A list of integers sorted in ascending order. * **Constraints**: * The length of the input list will be up to 10^6. * Each integer in the list is guaranteed to be in the range [0, 999]. # Example ```python >>> arr = [170, 45, 75, 90, 802, 24, 2, 66] >>> modified_radix_sort(arr) [2, 24, 45, 66, 75, 90, 170, 802] ``` # Performance Your implementation should efficiently handle inputs with sizes up to 10^6 within the given constraints. # Notes * Describe the algorithmic steps in your function. * Ensure your implementation handles large lists effectively and adheres to input constraints. Avoid unnecessary computations and focus on the bucket-based strategy of the Radix Sort.","solution":"def modified_radix_sort(arr: list) -> list: Performs Radix Sort on a list of integers ranging from 0 to 999. Arguments: arr: A list of integers. Returns: A list of integers sorted in ascending order. # Function to do counting sort based on the digit represented by exp def counting_sort(arr, exp): n = len(arr) # Initialize output array and count array output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] # Find the maximum number to know the number of digits max1 = max(arr) # Do counting sort for every digit. Note that instead of passing digit number, # exp is passed. exp is 10^i where i is the current digit number exp = 1 while max1 // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Sorting Employee Records Given a list of tuples where each tuple represents an employee record with the following format: `(employee_id, name, salary, department)` 1. `employee_id` (`int`): A unique integer identifier for the employee. 2. `name` (`str`): The full name of the employee. 3. `salary` (`float`): The salary of the employee. 4. `department` (`str`): The department where the employee works. Implement a function `sort_employees` that sorts this list of employee records based on the following criteria in order: 1. By `department` in ascending order. 2. Within each `department`, by `salary` in descending order. 3. Within each salary group, by `name` in alphabetical order. Function Signature: ```python def sort_employees(employee_records: list) -> list: ``` Inputs: - `employee_records` (`list`): A list of tuples, where each tuple has four elements corresponding to employee\'s ID, name, salary, and department. Output: - `list`: The sorted list of employee records. Constraints: - All elements of the `employee_records` list follow the specified tuple format. - Employee names are unique across the list. - The list will contain at least one record. Example Usage: ```python employee_records = [ (1, \\"Alice Smith\\", 70000.00, \\"Engineering\\"), (2, \\"Bob Johnson\\", 48000.00, \\"Marketing\\"), (3, \\"Carol Daniels\\", 62000.00, \\"Engineering\\"), (4, \\"David King\\", 72000.00, \\"Engineering\\"), (5, \\"Eve Sparks\\", 48000.00, \\"Marketing\\"), (6, \\"Frank Li\\", 59000.00, \\"Human Resources\\"), ] print(sort_employees(employee_records)) # Expected output: # [ # (3, \\"Carol Daniels\\", 62000.00, \\"Engineering\\"), # (1, \\"Alice Smith\\", 70000.00, \\"Engineering\\"), # (4, \\"David King\\", 72000.00, \\"Engineering\\"), # (6, \\"Frank Li\\", 59000.00, \\"Human Resources\\"), # (5, \\"Eve Sparks\\", 48000.00, \\"Marketing\\"), # (2, \\"Bob Johnson\\", 48000.00, \\"Marketing\\"), # ] ``` Implement `sort_employees` ensuring to sort the records efficiently and correctly handle the tie-breaking criteria.","solution":"def sort_employees(employee_records: list) -> list: Sorts employee records by department (ascending), salary (descending), and name (alphabetically). # Sorting with multiple keys can be achieved using a tuple for key values in sorted method sorted_records = sorted(employee_records, key=lambda x: (x[3], -x[2], x[1])) return sorted_records"},{"question":"# Given Context You are given a dataset of student exam scores in various subjects. Each row in the dataset represents a student\'s scores in multiple subjects. You need to perform some analysis on this dataset to determine specific statistics. # Task 1. Write a function `get_top_students` that takes in the dataset and the number of top students to select and returns the names of the top students based on their average scores. If there are multiple students with the same average score, they should be sorted by their names alphabetically. 2. Write a function `get_subject_statistics` that returns a dictionary mapping each subject to a tuple containing the minimum score, the maximum score, and the average score for that subject. # Input and Output Formats **Input** - The dataset is a list of dictionaries, where each dictionary represents a student\'s scores and contains the following keys: \'name\', \'math\', \'english\', \'science\', and \'history\'. - Example: ```python dataset = [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"english\\": 85, \\"science\\": 90, \\"history\\": 80}, {\\"name\\": \\"Bob\\", \\"math\\": 80, \\"english\\": 88, \\"science\\": 85, \\"history\\": 86}, {\\"name\\": \\"Charlie\\", \\"math\\": 78, \\"english\\": 68, \\"science\\": 70, \\"history\\": 90}, {\\"name\\": \\"David\\", \\"math\\": 95, \\"english\\": 75, \\"science\\": 85, \\"history\\": 89}, ] ``` **Output** - The `get_top_students` function should return a list of names of the top students. - The `get_subject_statistics` function should return a dictionary mapping the subject names to the corresponding statistics tuple. # Constraint - The dataset contains at least one student. - The number of top students to select is a positive integer and less than or equal to the number of students in the dataset. # Example Scenario Given the dataset: ```python [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"english\\": 85, \\"science\\": 90, \\"history\\": 80}, {\\"name\\": \\"Bob\\", \\"math\\": 80, \\"english\\": 88, \\"science\\": 85, \\"history\\": 86}, {\\"name\\": \\"Charlie\\", \\"math\\": 78, \\"english\\": 68, \\"science\\": 70, \\"history\\": 90}, {\\"name\\": \\"David\\", \\"math\\": 95, \\"english\\": 75, \\"science\\": 85, \\"history\\": 89}, ] ``` - Calling `get_top_students(dataset, 2)` should return `[\'Alice\', \'David\']` - Calling `get_subject_statistics(dataset)` should return: ```python { \\"math\\": (78, 95, 87.0), \\"english\\": (68, 88, 79.0), \\"science\\": (70, 90, 82.5), \\"history\\": (80, 90, 86.25) } ``` # Starter Code ```python from typing import List, Dict, Tuple def get_top_students(dataset: List[Dict[str, int]], top_n: int) -> List[str]: # Implement the logic to return the top N students based on average scores pass def get_subject_statistics(dataset: List[Dict[str, int]]) -> Dict[str, Tuple[int, int, float]]: # Implement the logic to return subject statistics pass # Example usage: dataset = [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"english\\": 85, \\"science\\": 90, \\"history\\": 80}, {\\"name\\": \\"Bob\\", \\"math\\": 80, \\"english\\": 88, \\"science\\": 85, \\"history\\": 86}, {\\"name\\": \\"Charlie\\", \\"math\\": 78, \\"english\\": 68, \\"science\\": 70, \\"history\\": 90}, {\\"name\\": \\"David\\", \\"math\\": 95, \\"english\\": 75, \\"science\\": 85, \\"history\\": 89}, ] print(get_top_students(dataset, 2)) print(get_subject_statistics(dataset)) ```","solution":"from typing import List, Dict, Tuple def get_top_students(dataset: List[Dict[str, int]], top_n: int) -> List[str]: # Calculate the average score for each student for student in dataset: student[\'average\'] = (student[\'math\'] + student[\'english\'] + student[\'science\'] + student[\'history\']) / 4.0 # Sort students by average score in descending order, then by name alphabetically sorted_students = sorted(dataset, key=lambda x: (-x[\'average\'], x[\'name\'])) # Return the names of the top_n students return [student[\'name\'] for student in sorted_students[:top_n]] def get_subject_statistics(dataset: List[Dict[str, int]]) -> Dict[str, Tuple[int, int, float]]: subjects = [\'math\', \'english\', \'science\', \'history\'] statistics = {} for subject in subjects: scores = [student[subject] for student in dataset] min_score = min(scores) max_score = max(scores) avg_score = sum(scores) / len(scores) statistics[subject] = (min_score, max_score, avg_score) return statistics # Example usage: dataset = [ {\\"name\\": \\"Alice\\", \\"math\\": 95, \\"english\\": 85, \\"science\\": 90, \\"history\\": 80}, {\\"name\\": \\"Bob\\", \\"math\\": 80, \\"english\\": 88, \\"science\\": 85, \\"history\\": 86}, {\\"name\\": \\"Charlie\\", \\"math\\": 78, \\"english\\": 68, \\"science\\": 70, \\"history\\": 90}, {\\"name\\": \\"David\\", \\"math\\": 95, \\"english\\": 75, \\"science\\": 85, \\"history\\": 89}, ] print(get_top_students(dataset, 2)) print(get_subject_statistics(dataset))"},{"question":"# Problem Statement You are given an array of numbers representing rainfall amounts recorded over a series of days. You need to determine the first day after each given day when the rainfall amount is greater. If there is no future day with a greater amount of rainfall, return -1 for that position. Your task is to implement the function `next_rainy_day(arr: list[float]) -> list[int]:` that efficiently finds the next days with higher rainfall using a stack-based approach with a time complexity of O(n). # Input Format - A single list `arr` of length n (1 ≤ n ≤ 10^6) containing numeric elements represent rainfall amounts. The elements can be integers or floats. # Output Format - Return a list of length n where each element is the index of the next day with higher rainfall. If no such day exists, return -1 for that position. # Constraints - The array can contain both positive and negative numbers, representing the rainfall amounts. - The elements in the array can be repeated. # Example Input ```python arr = [2.0, 5.1, 1.5, 2.3, 1.9, 7.2, 3.4] ``` Output ```python [1, 5, 3, 5, 5, -1, -1] ``` # Detailed Explanation - For the element at index `0` (rainfall `2.0`), the next greater rainfall is at index `1` (rainfall `5.1`). - For the element at index `1` (rainfall `5.1`), the next greater rainfall is at index `5` (rainfall `7.2`). - For the element at index `2` (rainfall `1.5`), the next greater rainfall is at index `3` (rainfall `2.3`). - For the element at index `3` (rainfall `2.3`), the next greater rainfall is at index `5` (rainfall `7.2`). - For the element at index `4` (rainfall `1.9`), the next greater rainfall is at index `5` (rainfall `7.2`). - For the element at index `5` (rainfall `7.2`), no greater rainfall exists, so return `-1`. - For the element at index `6` (rainfall `3.4`), no greater rainfall exists, so return `-1`. # Function Signature ```python from typing import List def next_rainy_day(arr: List[float]) -> List[int]: pass ``` # Requirements 1. You must implement the function `next_rainy_day` using an optimal approach with a time complexity of O(n). 2. Use a stack-based approach to achieve the desired efficiency. Good luck!","solution":"from typing import List def next_rainy_day(arr: List[float]) -> List[int]: This function returns a list containing the indices of the next day with higher rainfall for each day in the input list. If no such day exists, it returns -1 for that position. n = len(arr) result = [-1] * n # Initialize the result list with -1s stack = [] # Initialize an empty stack to keep track of indices for i in range(n): # While stack is not empty and the current rainfall is greater than the rainfall at the index of the top of the stack while stack and arr[i] > arr[stack[-1]]: # Pop the index from the stack and update the result for that index j = stack.pop() result[j] = i # Push current index onto the stack stack.append(i) return result"},{"question":"# Problem Statement You are given two arrays `arr_a` and `arr_b` of positive integers where each array represents the digits of a large number. Your task is to implement a function `add_large_numbers(arr_a, arr_b)` that returns an array representing the sum of the numbers. # Function Signature ```python def add_large_numbers(arr_a: list[int], arr_b: list[int]) -> list[int]: pass ``` # Input - `arr_a`: A list of integers where each integer is a single digit (0-9) of the large number. - `arr_b`: Another list of integers where each integer is a single digit (0-9) of the large number. # Output - A list of integers where each integer is a single digit (0-9) representing the digits of the sum of the two large numbers. # Constraints - `arr_a` and `arr_b` are both non-empty lists. - The digits in the lists are ordered such that the most significant digit comes first. # Example ```python add_large_numbers([9, 9, 9], [1]) # Expected output: [1, 0, 0, 0] add_large_numbers([2, 7, 4], [5, 6, 8]) # Expected output: [8, 4, 2] add_large_numbers([0], [0]) # Expected output: [0] ``` # Notes - The length of each input list can be up to 10^6 digits. - You should handle the possibility of carrying over digits when the sum exceeds 9 in a given place. - Think about the performance and how to efficiently carry out the digit additions especially for large lists. - Consider edge cases such as when one of the arrays represents the number 0 or when the arrays have different lengths.","solution":"def add_large_numbers(arr_a, arr_b): Adds two large numbers represented as arrays of digits. Args: arr_a: A list of integers representing the digits of the first large number. arr_b: A list of integers representing the digits of the second large number. Returns: A list of integers representing the digits of the sum of the two large numbers. # Reverse the lists to make the addition process easier (least significant to most significant) arr_a = arr_a[::-1] arr_b = arr_b[::-1] # Initialize the variables max_length = max(len(arr_a), len(arr_b)) result = [] carry = 0 # Iterate over each digit and perform the addition for i in range(max_length): digit_a = arr_a[i] if i < len(arr_a) else 0 digit_b = arr_b[i] if i < len(arr_b) else 0 total = digit_a + digit_b + carry carry = total // 10 result.append(total % 10) # If there\'s any carry left, append it to the result if carry > 0: result.append(carry) # Reverse the result to represent the number from most significant to least significant digit result.reverse() return result"},{"question":"# Question: You are to implement a feature to help manage a task scheduler which schedules tasks based on their priority and deadlines. Each task is characterized by a unique ID, priority, and deadline. Your task is to design data structures to manage these tasks optimally and ensure efficient scheduling operations. The task scheduler should support the following operations: - `add_task(task_id, priority, deadline)`: Add a task to the scheduler with the specified `task_id`, `priority`, and `deadline`. - `get_next_task()`: Return the task ID of the highest-priority task that is due next. If multiple tasks have the same priority, return the one with the earliest deadline. If no tasks are available, return `None`. - `remove_completed_task(task_id)`: Remove the task with the given `task_id` from the scheduler. **Requirements**: - Implement class `TaskScheduler` that supports the task scheduling operations. - Ensure methods are optimized for performance, aiming for O(log n) complexity for add and remove operations. - Include a method for viewing the state of the task scheduler. **Input/Output**: - `add_task(task_id: int, priority: int, deadline: int) -> None` - `get_next_task() -> int | None` - `remove_completed_task(task_id: int) -> None` **Constraints**: - The number of `add_task` and `remove_completed_task` operations will be in the range of [1, 10^5]. - Task IDs, priorities, and deadlines will be in the range of [1, 10^5]. **Example**: ```python scheduler = TaskScheduler() scheduler.add_task(1, 10, 5) scheduler.add_task(2, 15, 3) scheduler.add_task(3, 10, 2) print(scheduler.get_next_task()) # returns 3 scheduler.remove_completed_task(3) print(scheduler.get_next_task()) # returns 2 scheduler.add_task(4, 20, 4) print(scheduler.get_next_task()) # returns 4 scheduler.remove_completed_task(4) print(scheduler.get_next_task()) # returns 1 ``` **Challenge**: Implement the `TaskScheduler` class ensuring that the complexity of the operations allows handling a large number of tasks efficiently, especially focusing on the insertion and removal operations.","solution":"import heapq class TaskScheduler: def __init__(self): self.task_map = {} self.min_heap = [] def add_task(self, task_id, priority, deadline): Add a task to the scheduler with the specified task_id, priority, and deadline. task = (priority, deadline, task_id) heapq.heappush(self.min_heap, (-priority, deadline, task_id)) self.task_map[task_id] = task def get_next_task(self): Return the task ID of the highest-priority task that is due next. If multiple tasks have the same priority, return the one with the earliest deadline. If no tasks are available, return None. while self.min_heap: priority, deadline, task_id = heapq.heappop(self.min_heap) if task_id in self.task_map: heapq.heappush(self.min_heap, (priority, deadline, task_id)) return task_id return None def remove_completed_task(self, task_id): Remove the task with the given task_id from the scheduler. if task_id in self.task_map: del self.task_map[task_id] def view_state(self): View the current state of the task scheduler. return list(self.task_map.values())"},{"question":"# Coding Challenge # Problem Statement You are given a list of integers where each element represents the cost of a step you must take. You can either take one or two steps at a time to move from the start to the end of the list. Your task is to find the minimum possible cost to reach the end of the list. # Input - A list of integers where each integer represents the cost of a step. # Output - An integer representing the minimum cost to reach the end of the list. # Example Input ``` [10, 15, 20] ``` Output ``` 15 ``` Input ``` [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ``` Output ``` 6 ``` # Explanation For the first example, the minimum cost path is to take one step to the second element (cost 15), then two steps to the end (total cost = 15). For the second example, the minimum cost path is to take one step to the first element (cost 1), then two steps to the third element (cost 1), then two steps to the fifth element (cost 1), then two steps to the seventh element (cost 1), then two steps to the end (total cost = 6). # Function Signature ```python def min_cost_climbing_stairs(cost: List[int]) -> int: pass ``` # Constraints - 1 ≤ len(cost) ≤ 1000 - 0 ≤ cost[i] ≤ 999 # Scenario You are developing a function to optimize a system that needs to minimize operational costs based on a sequence of decisions. Each decision has a potential cost, and you can either proceed to the next immediate step or skip one step for a slightly different future cost. This task involves optimizing resource usage with dynamic programming techniques.","solution":"from typing import List def min_cost_climbing_stairs(cost: List[int]) -> int: Return the minimum cost to reach the end of the stairs. n = len(cost) if n == 1: return cost[0] # Initialize dp array to store minimum cost to reach each step dp = [0] * n dp[0] = cost[0] if n > 1: dp[1] = cost[1] # Fill dp array with the min cost to reach each step for i in range(2, n): dp[i] = cost[i] + min(dp[i-1], dp[i-2]) # The cost to reach the end will be the minimum of the last two steps return min(dp[-1], dp[-2])"},{"question":"# List Subtraction Function You are tasked with writing a function to subtract elements of one list from another. The function should remove all occurrences of each element in the second list from the first list. Function Signature ```python def list_subtract(main_list: list, sub_list: list) -> list: ``` Inputs: - `main_list` (list): The list from which elements are to be removed. - `sub_list` (list): The list of elements to be removed from the `main_list`. Output: - (list): The list after removing all occurrences of elements present in `sub_list` from `main_list`. Constraints: - Both input lists may contain any types of elements (e.g., integers, strings). - The elements in `sub_list` should be removed wherever they appear in `main_list`. - If the `sub_list` is empty, the `main_list` should remain unchanged. - The input list `main_list` can be empty. Example Usage: ```python >>> list_subtract([1, 2, 3, 4, 2, 3], [2, 3]) [1, 4] >>> list_subtract([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"], [\\"apple\\"]) [\\"banana\\", \\"cherry\\"] >>> list_subtract([1, 1, 1], [1]) [] >>> list_subtract([1, 2, 3], []) [1, 2, 3] >>> list_subtract([], [1, 2]) [] ``` Explanation: Write a function that: 1. Accepts two lists as input. 2. Iterates through the `main_list` and removes all occurrences of each item in `sub_list`. 3. Returns the modified `main_list` with the elements of `sub_list` removed. 4. Handles edge cases such as empty `main_list` or `sub_list`. Ensure your solution efficiently handles all specified scenarios and edge cases.","solution":"def list_subtract(main_list: list, sub_list: list) -> list: Returns a list with all occurrences of elements in sub_list removed from main_list. sub_set = set(sub_list) return [item for item in main_list if item not in sub_set]"},{"question":"# Question: Implement a Function to Detect a Cycle in a Directed Graph You are given a task to implement an algorithm to detect if there is a cycle in a directed graph. The graph is represented by an adjacency list, and you need to return a boolean indicating if a cycle exists. Function Specification You need to implement the following function: ```python def has_cycle(n: int, edges: list[tuple[int, int]]) -> bool: :param n: int - The number of vertices in the graph. :param edges: list of tuples - The list of directed edges in the graph where each edge is represented as a tuple (u, v) indicating an edge from u to v. :return: bool - True if there is a cycle in the graph, False otherwise. Example: >>> has_cycle(4, [(0, 1), (1, 2), (2, 0), (2, 3)]) True >>> has_cycle(4, [(0, 1), (1, 2), (2, 3)]) False pass ``` Input * An integer `n` representing the number of vertices (0-indexed). * A list of tuples `edges` where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Output * A boolean value `True` if there is a cycle in the graph, or `False` if there is not. Constraints * 1 ≤ n ≤ 1000 * 0 ≤ len(edges) ≤ 10000 * Each vertex index `u`, `v` is within the range `[0, n-1]`. Example ```python >>> has_cycle(6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]) False >>> has_cycle(6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]) True ``` Hints - Consider using Depth-First Search (DFS) traversal. - Use an auxiliary array to keep track of the recursion stack. - Recur for all the vertices adjacent to the current vertex and check their visit status.","solution":"def has_cycle(n: int, edges: list[tuple[int, int]]) -> bool: from collections import defaultdict def dfs(vertex): if recursion_stack[vertex]: return True # found a cycle if visited[vertex]: return False # no cycle from this vertex visited[vertex] = True recursion_stack[vertex] = True for neighbor in adj_list[vertex]: if dfs(neighbor): return True recursion_stack[vertex] = False return False adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) visited = [False] * n recursion_stack = [False] * n for i in range(n): if not visited[i]: if dfs(i): return True return False"},{"question":"# Longest Common Subsequence Challenge You are required to implement an optimized version of the Longest Common Subsequence (LCS) algorithm which is widely used in bioinformatics, text comparison, and other fields to find the longest subsequence present in both sequences without reordering characters. Task Given two sequences (strings) `s1` and `s2`, write a function `optimized_longest_common_subsequence` that calculates the length of their longest common subsequence. Prioritize optimizing the time and space complexity of your solution. Implementation Requirements 1. **Function Signature**: `def optimized_longest_common_subsequence(s1: str, s2: str) -> int:` 2. **Input Parameters**: * `s1`: A string representing the first sequence. * `s2`: A string representing the second sequence. 3. **Output**: An integer representing the length of the longest common subsequence. 4. **Constraints**: * `s1` and `s2` will have lengths at most 1000. 5. **Performance**: * Aim to reduce both time and space complexity compared to the naive O(n * m) space dynamic programming approach. Example ```python s1 = \\"AGGTAB\\" s2 = \\"GXTXAYB\\" # The Longest Common Subsequence is \\"GTAB\\", with length 4. length_of_lcs = optimized_longest_common_subsequence(s1, s2) print(length_of_lcs) # Output: 4 ``` Notes Make sure to: * Handle edge cases where one or both strings are empty. * Optimize the space usage by utilizing techniques such as space-efficient dynamic programming. * Ensure the solution is clean and well-documented to explain optimization choices.","solution":"def optimized_longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. Uses a space-optimized dynamic programming approach that only keeps the current and previous row of the DP table. n = len(s1) m = len(s2) if n == 0 or m == 0: return 0 # We only need two rows, current and previous previous = [0] * (m + 1) current = [0] * (m + 1) for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) # Move to the next row previous, current = current, previous return previous[m]"},{"question":"# Binary Search Tree (BST) Enhancements Enhance the `BinarySearchTree` class to include additional functionalities and optimizations for improved performance and utility. # Problem Statement 1. **Implementation**: - Implement a method for finding the kth smallest element in the BST. - Implement a method to determine if the BST is balanced. - Add functionality to print the BST in level order (BFS). 2. **Function Signature**: ```python class BinarySearchTree: ... def find_kth_smallest(self, k: int) -> int: Returns the kth smallest element in the BST. pass def is_balanced(self) -> bool: Returns True if the BST is balanced, otherwise False. pass def level_order_print(self) -> None: Prints the elements of the BST in level order. pass ``` # Input and Output - `find_kth_smallest`: - **Input**: An integer k. - **Output**: An integer representing the kth smallest element in the BST. - `is_balanced`: - **Input**: None. - **Output**: A boolean indicating if the BST is balanced. - `level_order_print`: - **Input**: None. - **Output**: None (prints elements in level order to standard output). # Constraints - The BST will contain at most 10^5 nodes. - The nodes are unique integers. - The methods should leverage efficient algorithms to handle large trees. - For `find_kth_smallest`, 1 <= k <= number of nodes in the BST. # Example ```python # BinarySearchTree Methods Implementation class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find_kth_smallest(self, k: int) -> int: # Implement the method to find the kth smallest element in the BST pass def is_balanced(self) -> bool: # Implement the method to check if the BST is balanced pass def level_order_print(self) -> None: # Implement the method to print the BST in level order pass # Example Usage # Create the BST bst = BinarySearchTree() values = [7, 3, 10, 1, 5, 8, 12] for value in values: bst.insert(value) # Find kth smallest print(bst.find_kth_smallest(3)) # Expected: 5 (third smallest element) # Check if balanced print(bst.is_balanced()) # Expected: True # Level Order Print bst.level_order_print() # Expected: # 7 # 3 10 # 1 5 8 12 ``` # Note Ensure that your implementation is optimized for efficient execution, especially considering the high number of nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find_kth_smallest(self, k: int) -> int: def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] return inorder_traversal(self.root)[k - 1] def is_balanced(self) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, balanced return check_balance(self.root)[1] def level_order_print(self) -> None: from collections import deque q = deque([self.root]) while q: node = q.popleft() if node: print(node.val, end=\' \') q.append(node.left) q.append(node.right) print()"},{"question":"# Problem Statement Write a function that takes a list of International Standard Book Numbers (ISBNs) in both 10-digit and 13-digit forms and validates them. Each ISBN is a string and must be checked for correct format and validity. The function should return a list of booleans indicating whether each ISBN in the input list is valid or not. # Function Signature ```python def validate_isbns(isbns: List[str]) -> List[bool]: ... ``` # Input - `isbns`: A list of strings, where each string is an ISBN-10 or ISBN-13. # Output A list of boolean values corresponding to each ISBN in the input list. `True` if the ISBN is valid, `False` otherwise. # Constraints - An ISBN-10 is valid if it consists of 9 digits followed by a checksum character (a digit or \'X\') and passes the ISBN-10 checksum formula. - An ISBN-13 is valid if it consists of 13 digits and passes the ISBN-13 checksum formula. - All ISBNs are guaranteed to be non-empty strings and in correct format (i.e., 10 or 13 characters, only digits and possibly an \'X\' in the 10th position for ISBN-10). # Requirements 1. Implement proper validation for both ISBN-10 and ISBN-13, including length and character checks. 2. Compute and verify checksums using the standard ISBN-10 and ISBN-13 algorithms. 3. Return results in the same order as the input list. # Example ```python >>> validate_isbns([\\"123456789X\\", \\"1234567890\\", \\"9780306406157\\", \\"9780306406158\\"]) [True, False, True, False] >>> validate_isbns([\\"0306406152\\", \\"9780306406157\\", \\"ABCDEFGHIJ\\"]) Traceback (most recent call last): ... ValueError: Invalid format for ISBN: ABCDEFGHIJ ``` # Note - The 10th character of an ISBN-10 can be \'X\', which represents the value 10. - The function should raise a `ValueError` if any string in the input list does not conform to valid ISBN-10 or ISBN-13 format (length or content issues). # Detailed Algorithm ISBN-10 Validation: 1. Verify that the ISBN is 10 characters long. 2. Ensure the first 9 characters are digits and the 10th character is either a digit or \'X\'. 3. Compute checksum using the formula: [ text{Checksum} = sum_{i=1}^{9} (i cdot text{digit}_i) + 10 cdot text{digit}_{10} ] 4. The checksum must be divisible by 11. ISBN-13 Validation: 1. Verify that the ISBN is 13 digits long. 2. Ensure all characters are digits. 3. Compute checksum using the formula: [ text{Checksum} = 10 - left( sum_{i=1}^{12} (text{digit}_i cdot text{weight}_i) mod 10 right) ] where the weights alternate between 1 and 3, starting with 1. 4. The checksum digit (13th digit) must equal the result of the checksum formula. Ensure your implementation adheres to these requirements and provides necessary error handling and validation.","solution":"from typing import List def validate_isbns(isbns: List[str]) -> List[bool]: def is_valid_isbn10(isbn): if len(isbn) != 10: return False if not isbn[:9].isdigit() or (isbn[9] not in \\"0123456789X\\"): return False total = sum((i + 1) * int(num) for i, num in enumerate(isbn[:9])) checksum = total % 11 if isbn[9] == \'X\': return checksum == 10 else: return checksum == int(isbn[9]) def is_valid_isbn13(isbn): if len(isbn) != 13 or not isbn.isdigit(): return False total = sum((1 if i % 2 == 0 else 3) * int(num) for i, num in enumerate(isbn[:12])) checksum = (10 - (total % 10)) % 10 return checksum == int(isbn[12]) result = [] for isbn in isbns: if len(isbn) == 10: result.append(is_valid_isbn10(isbn)) elif len(isbn) == 13: result.append(is_valid_isbn13(isbn)) else: raise ValueError(f\\"Invalid format for ISBN: {isbn}\\") return result"},{"question":"Arithmetic Expression Evaluator Implement a function that evaluates a basic arithmetic expression given as a string. The expression will consist of non-negative integers and the operators `+`, `-`, `*`, `/` (integer division). The expressions will have proper parenthesis which should be evaluated correctly following the standard operator precedence. # Input - A single string containing a valid arithmetic expression. The expression may have spaces, which should be ignored. # Output - An integer value which is the result of evaluating the arithmetic expression. # Constraints - Assume the input expression is always valid. - Division should perform integer division (like `//` in Python). - Do not use `eval()` or any similar built-in function for evaluating the expressions. - Input length will not exceed 100 characters. # Example ```python # Example function invocation print(evaluate_expression(\\"2 + 3 * (4 - 2)\\")) # Output: 8 print(evaluate_expression(\\"10 + (5 - 3) * 2\\")) # Output: 14 print(evaluate_expression(\\"(5 + 2) * (8 - 3) / 2\\")) # Output: 17 ``` # Points of Consideration - Your implementation should handle operator precedence: `*` and `/` have higher precedence than `+` and `-`. - Parentheses must be evaluated first. - Ensure that your implementation can handle expressions with varying levels of nested parentheses. **Note**: Use of the Shunting Yard Algorithm might be helpful to handle operator precedence and associativity.","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression given as a string. Supports +, -, *, / and parentheses. def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(left // right) def precedence(op): if op in {\'+\', \'-\'}: return 1 if op in {\'*\', \'/\'}: return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (operators and operators[-1] != \'(\' and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values.pop() # Example function invocations print(evaluate_expression(\\"2 + 3 * (4 - 2)\\")) # Output: 8 print(evaluate_expression(\\"10 + (5 - 3) * 2\\")) # Output: 14 print(evaluate_expression(\\"(5 + 2) * (8 - 3) / 2\\")) # Output: 17"},{"question":"# Context Morse code is a method used in telecommunication to encode text characters as standardized sequences of two different signal durations, called dots and dashes. Each Morse code symbol is made of a series of dots (\'.\') and dashes (\'-\'), separated by short pauses. For simplicity, Morse code can be represented as just dots and dashes. # Task Write a function `morse_to_text(morse_code: str) -> str` that translates a given Morse code string into its corresponding English text. # Input - A string `morse_code` that represents a sentence in Morse code, with individual Morse letters separated by spaces and words separated by slashes (\'/\'). # Output - Return the decoded English sentence as a string. # Constraints - Signal input will only contain dots (\'.\'), dashes (\'-\'), spaces (\' \'), and slashes (\'/\'). - Output text will only contain uppercase English letters and spaces between words. # Example Tests ```python print(morse_to_text(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\")) # Should return: \\"HELLO WORLD\\" print(morse_to_text(\\"- .... .. ... / .. ... / .- / - . ... -\\")) # Should return: \\"THIS IS A TEST\\" print(morse_to_text(\\"--. --- --- -.. / -- --- .-. -. .. -. --.\\")) # Should return: \\"GOOD MORNING\\" ``` # Notes - Ensure to handle and ignore any potential extraneous spaces. - The Morse code standards typically don\'t include numbers or punctuation for this problem\'s scope. # Morse Code Mappings Use the following Morse code mappings for the translation: ```python MORSE_CODE_DICT = { \\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\", \\"..-.\\": \\"F\\", \\"--.\\": \\"G\\", \\"....\\": \\"H\\", \\"..\\": \\"I\\", \\".---\\": \\"J\\", \\"-.-\\": \\"K\\", \\".-..\\": \\"L\\", \\"--\\": \\"M\\", \\"-.\\": \\"N\\", \\"---\\": \\"O\\", \\".--.\\": \\"P\\", \\"--.-\\": \\"Q\\", \\".-.\\": \\"R\\", \\"...\\": \\"S\\", \\"-\\": \\"T\\", \\"..-\\": \\"U\\", \\"...-\\": \\"V\\", \\".--\\": \\"W\\", \\"-..-\\": \\"X\\", \\"-.--\\": \\"Y\\", \\"--..\\": \\"Z\\" } ```","solution":"MORSE_CODE_DICT = { \\".-\\": \\"A\\", \\"-...\\": \\"B\\", \\"-.-.\\": \\"C\\", \\"-..\\": \\"D\\", \\".\\": \\"E\\", \\"..-.\\": \\"F\\", \\"--.\\": \\"G\\", \\"....\\": \\"H\\", \\"..\\": \\"I\\", \\".---\\": \\"J\\", \\"-.-\\": \\"K\\", \\".-..\\": \\"L\\", \\"--\\": \\"M\\", \\"-.\\": \\"N\\", \\"---\\": \\"O\\", \\".--.\\": \\"P\\", \\"--.-\\": \\"Q\\", \\".-.\\": \\"R\\", \\"...\\": \\"S\\", \\"-\\": \\"T\\", \\"..-\\": \\"U\\", \\"...-\\": \\"V\\", \\".--\\": \\"W\\", \\"-..-\\": \\"X\\", \\"-.--\\": \\"Y\\", \\"--..\\": \\"Z\\" } def morse_to_text(morse_code: str) -> str: words = morse_code.strip().split(\' / \') decoded_sentence = [] for word in words: letters = word.split() decoded_word = \'\'.join(MORSE_CODE_DICT.get(letter, \'\') for letter in letters) decoded_sentence.append(decoded_word) return \' \'.join(decoded_sentence)"},{"question":"# Problem Statement Create a function `closest_pair(numbers: list) -> tuple` that finds the two distinct elements in the list with the smallest absolute difference. If there are multiple such pairs, return the pair with the smaller elements first. Function Signature: ```python def closest_pair(numbers: list) -> tuple: ``` # Input * A list of integers `numbers` where: * `2 <= len(numbers) <= 10^5` * `-10^9 <= numbers[i] <= 10^9` * All elements of the list are distinct. # Output * Return a tuple of two integers which are the closest pair in terms of absolute difference. Ensure the smaller number appears first in the tuple. # Example ```python print(closest_pair([4, 9, 1, 17, 8, 3, 5])) # Output: (3, 4) print(closest_pair([-5, 1, 10, 2, -4])) # Output: (-5, -4) ``` # Constraints * You must use an efficient algorithm (Hint: Sorting the array first may help). * Your function should handle large datasets efficiently to satisfy the O(n log n) complexity. # Testing * Your solution will be tested for correctness and performance using various test cases, including large datasets to ensure efficiency. * Handle edge cases such as both positive and negative numbers effectively. # Implementation Guide 1. Sort the input list. 2. Initialize variables to keep track of the smallest difference encountered and the corresponding pair. 3. Iterate through the sorted list and compare each pair of consecutive elements to update the smallest difference and the corresponding pair. 4. Return the pair with the smallest absolute difference. Good luck and happy coding!","solution":"def closest_pair(numbers: list) -> tuple: Finds the two distinct elements in the list with the smallest absolute difference. # Sort the list to make it easier to find closest pairs numbers.sort() # Initialize the smallest difference to a large number smallest_diff = float(\'inf\') closest_pair = (0, 0) # Iterate through sorted list and check consecutive pairs for i in range(len(numbers) - 1): diff = abs(numbers[i] - numbers[i + 1]) if diff < smallest_diff: smallest_diff = diff closest_pair = (numbers[i], numbers[i + 1]) return closest_pair"},{"question":"# Fibonacci Checker Objective Write a function that determines if a given positive integer is a Fibonacci number. Your solution should use an efficient mathematical approach. Problem Statement Given a positive integer, return `True` if the number is a Fibonacci number, or `False` otherwise. Handle edge cases such as negatives and non-integer inputs appropriately. Input - A single positive integer `number`. Output - A boolean value `True` if the number is a Fibonacci number, `False` otherwise. - If the number is negative or not an integer, raise the appropriate error. Function Signature ```python def is_fibonacci(number: int) -> bool: ``` Constraints - The input number will be within the range ((-infty, 2^{31} - 1)). Examples ```python >>> is_fibonacci(0) True >>> is_fibonacci(1) True >>> is_fibonacci(2) True >>> is_fibonacci(3) True >>> is_fibonacci(4) False >>> is_fibonacci(21) True >>> is_fibonacci(22) False >>> is_fibonacci(-5) # Raises ValueError >>> is_fibonacci(4.5) # Raises TypeError ``` Performance Requirements - Must run in O(1) time and require O(1) space. Notes - Utilize the property that a number is a Fibonacci number if and only if one (or both) of (5 times n^2 + 4) or (5 times n^2 - 4) is a perfect square. - Ensure the input is strictly an integer and within valid bounds (non-negative). This new question aligns with the original one in terms of style, complexity, and scope, ensuring consistency within the coding assessment.","solution":"import math def is_fibonacci(number: int) -> bool: Determines if a given positive integer is a Fibonacci number. if not isinstance(number, int): raise TypeError(\\"Input must be an integer.\\") if number < 0: raise ValueError(\\"Input must be a non-negative integer.\\") def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x return is_perfect_square(5 * number * number + 4) or is_perfect_square(5 * number * number - 4)"},{"question":"# Sorting with Custom Comparator **Context**: You\'re implementing a custom sorting algorithm for a data processing application. The challenge involves sorting a list of strings based on a specific set of rules defined by a custom comparator. The comparator prioritizes primary sorting by the length of the strings (shorter first) and secondary sorting alphabetically. **Task**: Implement the `custom_sort` function that sorts a list of strings primarily by their length and secondarily by their lexicographical order. You must ensure the function is optimized and effectively handles various edge cases. # Function Signature: ```python def custom_sort(strings: list[str]) -> list[str]: strings: a list of strings returns: a list of strings sorted by the given custom comparator ``` # Constraints: 1. The input list may contain empty strings. 2. You should optimize your code to handle large lists efficiently. 3. The function should not alter the original list but return a new sorted list. # Expected Input/Output: - **Input**: A list of strings. - **Output**: A new list of strings sorted based on the specified rules. **Example**: ```python strings = [\\"apple\\", \\"pie\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"] # Applying custom_sort sorted_strings = custom_sort(strings) # Expected output: [\\"fig\\", \\"pie\\", \\"date\\", \\"apple\\", \\"grape\\", \\"banana\\", \\"cherry\\"] ``` # Additional Notes: - Ensure that your code efficiently handles the sorting logic for a potentially large and diverse set of strings. - Consider any edge cases, such as lists with strings of the same length or completely empty strings.","solution":"def custom_sort(strings: list[str]) -> list[str]: Sorts the list of strings primarily by their length and secondarily by their lexicographical order. return sorted(strings, key=lambda s: (len(s), s))"},{"question":"# Question: Implement a Custom Fibonacci Generator with Constraints **Scenario**: You are developing a custom Fibonacci number generator for a financial application. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. However, your task is to implement a finite Fibonacci generator that stops at a specified limit and handles various conditions gracefully. **Function to Implement**: Implement the function `custom_fibonacci(limit: int) -> List[int]` that generates a list of Fibonacci numbers up to a given limit. Ensure that the function conforms to specific requirements and constraints: **Requirements**: 1. Validate the input to ensure it’s a non-negative integer. 2. Handle inputs that: * Are negative or zero. * Are of incorrect types (e.g., floats, strings). 3. Generate the Fibonacci series up to and including the specified limit. 4. If the limit is zero, return an empty list. 5. Ensure performance with large limits within typical computational constraints. **Input**: - A single integer, `limit`, which specifies the upper bound value for the Fibonacci sequence. **Output**: - A list of integers representing the Fibonacci sequence up to and including the specified limit. **Constraints**: - If `limit` is not a non-negative integer, raise a `ValueError`. - Ensure the function handles very large limits efficiently. **Example Cases**: ```python >>> custom_fibonacci(0) [] >>> custom_fibonacci(1) [0, 1, 1] >>> custom_fibonacci(10) [0, 1, 1, 2, 3, 5, 8] >>> custom_fibonacci(21) [0, 1, 1, 2, 3, 5, 8, 13, 21] >>> custom_fibonacci(-5) Traceback (most recent call last): ... ValueError: Input value must be a non-negative integer >>> custom_fibonacci(0.5) Traceback (most recent call last): ... TypeError: Input value must be an integer >>> custom_fibonacci(\\"10\\") Traceback (most recent call last): ... TypeError: Input value must be an integer ``` **Function Template**: ```python from typing import List def custom_fibonacci(limit: int) -> List[int]: Generate a list of Fibonacci numbers up to a specified limit. :param limit: The upper bound value for the Fibonacci sequence. :return: A list of Fibonacci numbers up to and including the specified limit. :raises ValueError: If input is a negative integer :raises TypeError: If input is not an integer # Your implementation goes here if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def custom_fibonacci(limit: int) -> List[int]: Generate a list of Fibonacci numbers up to a specified limit. :param limit: The upper bound value for the Fibonacci sequence. :return: A list of Fibonacci numbers up to and including the specified limit. :raises ValueError: If input is a negative integer :raises TypeError: If input is not an integer if not isinstance(limit, int): raise TypeError(\\"Input value must be an integer\\") if limit < 0: raise ValueError(\\"Input value must be a non-negative integer\\") if limit == 0: return [] fib_sequence = [0, 1] while True: next_val = fib_sequence[-1] + fib_sequence[-2] if next_val > limit: break fib_sequence.append(next_val) return fib_sequence"},{"question":"# Question: Implement a Non-Recursive Fibonacci Sequence Generator You are tasked with creating a Fibonacci sequence generator that avoids recursion to improve performance and manageability, particularly for large values of `n`. The traditional recursive approach can result in excessive calls and significant overhead, especially for higher sequence values. Your implementation should use an iterative method to calculate the Fibonacci sequence efficiently. # Requirements: 1. Implement the function `fibonacci_iterative(n: int) -> int`: * **`n` (int)**: The position in the Fibonacci sequence to compute. 2. Use an iterative approach to compute the nth Fibonacci number. 3. Optimize the function to handle large values of `n` efficiently in terms of time and memory. # Example: ```python print(fibonacci_iterative(10)) ``` This should output `55`, as the 10th Fibonacci number is `55`. # Constraints: * 0 <= n <= 1000 # Performance Requirements: * The iterative solution should handle the maximum constraint (n=1000) efficiently, ensuring it does not suffer from the exponential time complexity of the recursive approach.","solution":"def fibonacci_iterative(n): Computes the nth Fibonacci number using an iterative approach. Args: n (int): The index in the Fibonacci sequence. Returns: int: The nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Advanced Optics: Enhanced Lens Formula Calculations In this problem, you are required to enhance the existing lens formula calculations to account for extended capabilities in a converging and diverging lens context. You will implement a class `LensOptics` that encapsulates the functionality of calculating object distance, image distance, and focal length. Additionally, you will add methods for validating and adjusting sign conventions for both types of lenses. # Class and Methods Specification: Class: ```python class LensOptics: def __init__(self, lens_type: str): pass def calculate_focal_length(self, distance_of_object: float, distance_of_image: float) -> float: pass def calculate_object_distance(self, focal_length: float, distance_of_image: float) -> float: pass def calculate_image_distance(self, focal_length: float, distance_of_object: float) -> float: pass def validate_distances(self, *distances: float) -> None: pass ``` # Method Description: * `__init__(self, lens_type: str)`: Initialize the `LensOptics` instance with the lens type. The `lens_type` can be either `\'converging\'` or `\'diverging\'`. * `calculate_focal_length(self, distance_of_object: float, distance_of_image: float) -> float`: Calculates the focal length using object and image distances. Validates distances using the `validate_distances` method. * `calculate_object_distance(self, focal_length: float, distance_of_image: float) -> float`: Calculates the object distance using given image distance and focal length. Validates distances using the `validate_distances` method. * `calculate_image_distance(self, focal_length: float, distance_of_object: float) -> float`: Calculates the image distance using given object distance and focal length. Validates distances using the `validate_distances` method. * `validate_distances(self, *distances: float) -> None`: Validates that inputs are non-zero and follow the sign conventions for lenses: 1. Ensure all input distances are non-zero. 2. Ensure distances follow valid sign conventions in optics. # Constraints: - All distances are measured in meters and can be positive or negative depending on the context. - Inputs will always be floating-point numbers. - The `lens_type` initialization parameter must be either `\'converging\'` or `\'diverging\'`. # Examples: ```python lens_optics_converging = LensOptics(\'converging\') lens_optics_diverging = LensOptics(\'diverging\') # Example for calculating focal length with a converging lens: focal_len = lens_optics_converging.calculate_focal_length(10, 20) print(focal_len) # Output should match the expected precision # Example for calculating object distance with a converging lens: object_dist = lens_optics_converging.calculate_object_distance(30, 20) print(object_dist) # Output should match the expected precision # Example for calculating image distance with a diverging lens: image_dist = lens_optics_diverging.calculate_image_distance(10, -40) print(image_dist) # Output should match the expected precision ``` Additional validation: 1. If the input distance is \'0\', throw a ValueError with the message: `\'Invalid inputs. Enter non-zero values with respect to the sign convention.\'`.","solution":"class LensOptics: def __init__(self, lens_type: str): if lens_type not in [\'converging\', \'diverging\']: raise ValueError(\\"lens_type must be \'converging\' or \'diverging\'\\") self.lens_type = lens_type def calculate_focal_length(self, distance_of_object: float, distance_of_image: float) -> float: self.validate_distances(distance_of_object, distance_of_image) return 1 / ((1 / distance_of_object) + (1 / distance_of_image)) def calculate_object_distance(self, focal_length: float, distance_of_image: float) -> float: self.validate_distances(focal_length, distance_of_image) return 1 / ((1 / focal_length) - (1 / distance_of_image)) def calculate_image_distance(self, focal_length: float, distance_of_object: float) -> float: self.validate_distances(focal_length, distance_of_object) return 1 / ((1 / focal_length) - (1 / distance_of_object)) def validate_distances(self, *distances: float) -> None: for distance in distances: if distance == 0: raise ValueError(\'Invalid inputs. Enter non-zero values with respect to the sign convention.\')"},{"question":"# Scenario You are contributing to a library management system. One of the features is to categorize books based on the author\'s country and publication year. The system needs a function that sorts a list of books by the author\'s country and then by the publication year in ascending order. # Function Signature ```python def sort_books(books: List[Tuple[str, str, int]]) -> List[Tuple[str, str, int]]: ``` # Expected Input and Output - **Input**: * `books`: a list of tuples where each tuple contains three elements: * `author_country`: a string representing the author\'s country. * `book_title`: a string representing the title of the book. * `publication_year`: an integer representing the year of publication. - **Output**: * A list of tuples sorted first by the `author_country` in alphabetical order, and then by the `publication_year` in ascending order. # Constraints 1. `books` contains at most 1000 tuples. 2. `author_country` and `book_title` are both non-empty strings with a maximum length of 100 characters. 3. `publication_year` is a positive integer. # Performance Requirements - The solution should efficiently handle sorting with a time complexity close to O(n log n). # Examples 1. **Example 1**: ```python sort_books([(\\"USA\\", \\"The Great Gatsby\\", 1925), (\\"Japan\\", \\"Norwegian Wood\\", 1987), (\\"USA\\", \\"To Kill a Mockingbird\\", 1960)]) ``` - **Input**: `[(\\"USA\\", \\"The Great Gatsby\\", 1925), (\\"Japan\\", \\"Norwegian Wood\\", 1987), (\\"USA\\", \\"To Kill a Mockingbird\\", 1960)]` - **Output**: `[(\\"Japan\\", \\"Norwegian Wood\\", 1987), (\\"USA\\", \\"The Great Gatsby\\", 1925), (\\"USA\\", \\"To Kill a Mockingbird\\", 1960)]` 2. **Example 2**: ```python sort_books([(\\"UK\\", \\"1984\\", 1949), (\\"Russia\\", \\"War and Peace\\", 1867), (\\"France\\", \\"The Stranger\\", 1942), (\\"UK\\", \\"Brave New World\\", 1932)]) ``` - **Input**: `[(\\"UK\\", \\"1984\\", 1949), (\\"Russia\\", \\"War and Peace\\", 1867), (\\"France\\", \\"The Stranger\\", 1942), (\\"UK\\", \\"Brave New World\\", 1932)]` - **Output**: `[(\\"France\\", \\"The Stranger\\", 1942), (\\"Russia\\", \\"War and Peace\\", 1867), (\\"UK\\", \\"Brave New World\\", 1932), (\\"UK\\", \\"1984\\", 1949)]` # Objective Implement the `sort_books` function ensuring it complies with the above requirements and constraints. The implementation will be evaluated on correctness, performance, and handling of edge cases.","solution":"from typing import List, Tuple def sort_books(books: List[Tuple[str, str, int]]) -> List[Tuple[str, str, int]]: Function to sort a list of books first by the author\'s country, and then by the publication year in ascending order. return sorted(books, key=lambda x: (x[0], x[2]))"},{"question":"# Coding Assessment Question **Problem Statement:** Given a directed acyclic graph (DAG), your task is to implement a function to perform a topological sort on the graph. The function should return a list of vertices in topologically sorted order. Implement both Kahn\'s algorithm (using in-degree) and a Depth-First Search (DFS) approach. **Function Signatures**: ```python def topological_sort_kahn(graph: Dict[int, List[int]]) -> List[int]: def topological_sort_dfs(graph: Dict[int, List[int]]) -> List[int]: ``` **Expected Input/Output**: - `graph`: A dictionary where the keys are node identifiers (integers) and the values are lists of integers representing edges from the key node to other nodes. - The function should return a list of integers representing the nodes in topological order. **Constraints**: - The graph is a directed acyclic graph (DAG). - The graph contains up to 10,000 nodes and 50,000 edges. - Node identifiers are integers. **Example**: Given the following graph represented as an adjacency list: ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [4], 4: [] } ``` **Output**: - `topological_sort_kahn(graph)` should return a list of nodes in topological order, for example: `[0, 2, 1, 3, 4]` - `topological_sort_dfs(graph)` should return a list of nodes in topological order, for example: `[0, 2, 1, 3, 4]` **Note**: - Ensure your implementations handle graphs with multiple valid topological orders. - Consider edge cases like an empty graph and a graph where some nodes have no outgoing edges in your implementation. - When implementing Kahn\'s algorithm, you may use a queue to manage nodes with zero in-degree. - When implementing the DFS approach, ensure you properly handle visited nodes to avoid repeating them in the order.","solution":"from collections import deque, defaultdict from typing import Dict, List def topological_sort_kahn(graph: Dict[int, List[int]]) -> List[int]: in_degree = {u: 0 for u in graph} for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([u for u in graph if in_degree[u] == 0]) sorted_order = [] while queue: u = queue.popleft() sorted_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) if len(sorted_order) == len(graph): return sorted_order else: raise ValueError(\\"Graph has at least one cycle, which is not a valid DAG\\") def topological_sort_dfs(graph: Dict[int, List[int]]) -> List[int]: def dfs(v): if visited[v] == -1: raise ValueError(\\"Graph has at least one cycle, which is not a valid DAG\\") if visited[v] == 1: return visited[v] = -1 for u in graph[v]: dfs(u) visited[v] = 1 result.append(v) visited = {u: 0 for u in graph} result = [] for u in graph: if visited[u] == 0: dfs(u) return result[::-1]"},{"question":"# Coding Assessment Question Objective Create a function to find the longest sequence of continuous integers in an array. Function Signature ```python def longest_continuous_sequence(nums: List[int]) -> int: pass ``` Input * `nums`: A list of integers which may include positive and negative values, and may have duplicates. Output * An integer representing the length of the longest sequence of continuous integers present in the array. Example ```python # Given the array: [100, 4, 200, 1, 3, 2], the longest sequence is [1, 2, 3, 4] sequence_length = longest_continuous_sequence([100, 4, 200, 1, 3, 2]) ``` Should return: ``` 4 ``` Constraints * The array can have up to 10,000 elements. * The sequence must be continuous without skips (e.g., [1, 2, 3, 4] but not [1, 2, 4]). * The sequence does not need to be ordered in the array. Implementation Notes 1. Convert the list to a set to allow O(1) lookups. 2. Iterate through the set and check for the start of a sequence. 3. Expand the sequence by checking for subsequent integers. 4. Track the maximum length of such sequences. Additional Considerations Students should handle edge cases such as the presence of negative values, duplicate elements, and non-sequential arrays.","solution":"from typing import List def longest_continuous_sequence(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Hexadecimal to Binary Converter Objective Create a function `hex_to_binary(hex_string)` that converts a given hexadecimal string into its binary representation. Background Hexadecimal (base-16) uses sixteen symbols, including digits `0-9` and letters `A-F`, to represent values. Each hexadecimal digit can represent four binary digits (bits). Therefore, converting a hexadecimal number into a binary number can be done by directly mapping each hexadecimal digit to its corresponding 4-bit binary equivalent. Task 1. Implement the `hex_to_binary` function that: - Accepts a valid hexadecimal string input (which can contain characters `0-9` and `A-F`, case insensitive). - Converts the hexadecimal string to its binary representation string. 2. Ensure the binary representation does not include leading zeros unless the entire number is zero. Implementation Requirements 1. **Function Definition**: - `def hex_to_binary(hex_string: str) -> str:` 2. **Functionality**: - Convert the hexadecimal string to a binary string, maintaining proper conversion for both uppercase and lowercase inputs. - Handle hexadecimal strings that start with `0x`, `0X`, or without any prefix. - Remove any leading \'0b\' that may appear in the Python binary formatting. - Ensure the binary number is free from leading zeros, unless the number is \'0\'. Constraints 1. The input string will be a valid hexadecimal string, which may or may not start with \\"0x\\" or \\"0X\\". 2. The input string will not be empty. Example ```python # Case 1 input_hex = \\"1A3F\\" # Binary: \\"1101000111111\\" print(hex_to_binary(input_hex)) # Output: \\"1101000111111\\" # Case 2 input_hex = \\"0xFA13\\" # Binary: \\"1111101000010011\\" print(hex_to_binary(input_hex)) # Output: \\"1111101000010011\\" # Case 3 input_hex = \\"0\\" # Binary: \\"0\\" print(hex_to_binary(input_hex)) # Output: \\"0\\" ``` Hints - Use Python\'s built-in functions to handle conversions. - Consider handling both prefixed and non-prefixed hexadecimal strings. - Remove unnecessary leading zeros in the binary representation. --- Example Implementation ```python def hex_to_binary(hex_string: str) -> str: # Remove \'0x\' or \'0X\' prefix if present if hex_string.lower().startswith(\\"0x\\"): hex_string = hex_string[2:] # Convert hexadecimal string to binary string and remove \'0b\' prefix binary_str = bin(int(hex_string, 16))[2:] # If the original number is 0, ensure we return \'0\' if binary_str == \\"\\": binary_str = \\"0\\" return binary_str ```","solution":"def hex_to_binary(hex_string: str) -> str: # Remove \'0x\' or \'0X\' prefix if present if hex_string.lower().startswith(\\"0x\\"): hex_string = hex_string[2:] # Convert hexadecimal string to binary string and remove \'0b\' prefix binary_str = bin(int(hex_string, 16))[2:] # Remove leading zeros, unless the result is the single character \'0\' binary_str = binary_str.lstrip(\'0\') if binary_str == \\"\\": binary_str = \\"0\\" return binary_str"},{"question":"# Assessment Question: Serialize and Deserialize a Binary Tree You are tasked with writing functions to serialize and deserialize a binary tree. The serialization process should convert the binary tree into a string representation, and the deserialization process should reconstruct the binary tree from that string representation. The input tree may contain null nodes, and the serialization should handle them appropriately. Consider the following constraints for your solution: - The binary tree will only contain integer values. - Your solution should handle an empty tree (represented by None). Function Signatures ```python def serialize(root: TreeNode | None) -> str: pass def deserialize(data: str) -> TreeNode | None: pass ``` Input and Output Format - Input: A reference to the root of the binary tree or None, and a serialized string representation of a binary tree. - Output: A serialized string representation of the binary tree and a reference to the root of the reconstructed binary tree. Example ```python >>> # Example binary tree >>> # 1 >>> # / >>> # 2 3 >>> # / >>> # 4 5 >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> serialized_str = serialize(root) >>> print(serialized_str) \'1,2,null,null,3,4,null,null,5,null,null\' >>> deserialized_tree = deserialize(serialized_str) >>> assert deserialized_tree.val == 1 >>> assert deserialized_tree.left.val == 2 >>> assert deserialized_tree.right.val == 3 >>> assert deserialized_tree.right.left.val == 4 >>> assert deserialized_tree.right.right.val == 5 ``` # Constraints 1. The number of nodes in the binary tree is between 0 and 10^4. 2. The values of the nodes are between -1000 and 1000. # Performance Requirements - Ensure that the serialize and deserialize functions both run efficiently, with average time complexities of O(n), where n is the number of nodes in the binary tree. # Additional Information - TreeNode class is predefined and uses the following structure: ```python @dataclass class TreeNode: val: int = 0 left: \\"TreeNode\\" | None = None right: \\"TreeNode\\" | None = None ``` Write the functions `serialize` and `deserialize` to fulfill the above requirements.","solution":"from typing import Optional from dataclasses import dataclass @dataclass class TreeNode: val: int = 0 left: Optional[\\"TreeNode\\"] = None right: Optional[\\"TreeNode\\"] = None def serialize(root: Optional[TreeNode]) -> str: Serializes a binary tree to a string. result = [] def helper(node): if node: result.append(str(node.val)) helper(node.left) helper(node.right) else: result.append(\\"null\\") helper(root) return \\",\\".join(result) def deserialize(data: str) -> Optional[TreeNode]: Deserializes a string to a binary tree. values = iter(data.split(\\",\\")) def helper(): val = next(values) if val == \\"null\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node return helper()"},{"question":"# Coding Assessment Question You are given a list of strings representing dictionary words and a string representing a scrambled input word. The task is to determine if any permutation of the scrambled input word is a valid word from the dictionary. You are required to implement a function `is_permutation_in_dictionary(dictionary: Sequence[str], scrambled_word: str) -> bool` in Python, which checks if any permutation of the scrambled input word exists in the dictionary. Function Signature ```python def is_permutation_in_dictionary(dictionary: Sequence[str], scrambled_word: str) -> bool: ``` Input * `dictionary` (Sequence[str]): A list of strings where each string represents a valid dictionary word. All strings consist of lowercase English letters, and the length of each string is between 1 and 100. * `scrambled_word` (str): A string of lowercase English letters representing the scrambled version of a word. The length of this string will be between 1 and 100. Output * Return `True` if any permutation of the scrambled input word is a valid word from the dictionary, otherwise return `False`. Constraints * The dictionary might contain up to 10^4 words. * The dictionary words are all unique. * Scrambled word can have repeated letters. Example ```python >>> is_permutation_in_dictionary([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"apple\\"], \\"tinsel\\") True # \\"tinsel\\" is a permutation of \\"silent\\", which is in the dictionary. >>> is_permutation_in_dictionary([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"apple\\"], \\"stone\\") False # No permutation of \\"stone\\" matches any word in the dictionary. >>> is_permutation_in_dictionary([\\"rat\\", \\"tar\\", \\"art\\"], \\"tar\\") True # \\"tar\\" is exactly in the dictionary. >>> is_permutation_in_dictionary([\\"rat\\", \\"tar\\", \\"art\\"], \\"car\\") False # No permutation of \\"car\\" matches any word in the dictionary. ``` Notes * You can assume that the words in the dictionary and the scrambled word all contain only lowercase English letters.","solution":"from typing import Sequence def is_permutation_in_dictionary(dictionary: Sequence[str], scrambled_word: str) -> bool: Checks if any permutation of the scrambled input word exists in the dictionary. from collections import Counter scrambled_word_counter = Counter(scrambled_word) # Check if any word in the dictionary has the same character count for word in dictionary: if Counter(word) == scrambled_word_counter: return True return False"},{"question":"# Coding Assessment Question: **Context**: You are developing a utility function for a logging system that manages IP addresses. To ensure proper logging, all IP addresses need to be validated and classified into their respective classes (A, B, C, D, or E). **Task**: Write a Python function `classify_ip` that takes a string representing an IPv4 address and returns its class. **Specifications**: * Function name: `classify_ip` * Input: * A string `ip_address` representing a valid IPv4 address in \\"xxx.xxx.xxx.xxx\\" format, where `xxx` ranges from 0 to 255. * Output: * A string indicating the class of the IP address (\\"A\\", \\"B\\", \\"C\\", \\"D\\", or \\"E\\"). **IP Address Classes**: * Class A: 0.0.0.0 to 127.255.255.255 * Class B: 128.0.0.0 to 191.255.255.255 * Class C: 192.0.0.0 to 223.255.255.255 * Class D: 224.0.0.0 to 239.255.255.255 * Class E: 240.0.0.0 to 255.255.255.255 **Example**: ```python def classify_ip(ip_address: str) -> str: Classify a given IPv4 address into its respective class (A, B, C, D, or E). Parameters: ip_address (str): A string representing a valid IPv4 address in dotted-decimal format. Returns: str: A string indicating the class of the IP address. Examples: >>> classify_ip(\\"10.0.0.1\\") \'A\' >>> classify_ip(\\"172.16.0.1\\") \'B\' >>> classify_ip(\\"192.168.1.1\\") \'C\' >>> classify_ip(\\"224.0.0.1\\") \'D\' >>> classify_ip(\\"240.0.0.1\\") \'E\' pass ``` **Notes**: * Validate that the input always represents a valid IPv4 address. * If the IP address is invalid, you may assume it\'s handled outside this function. * Ensure that the classification is done accurately and efficiently.","solution":"def classify_ip(ip_address): Classify a given IPv4 address into its respective class (A, B, C, D, or E). Parameters: ip_address (str): A string representing a valid IPv4 address in dotted-decimal format. Returns: str: A string indicating the class of the IP address. first_octet = int(ip_address.split(\'.\')[0]) if 0 <= first_octet <= 127: return \'A\' elif 128 <= first_octet <= 191: return \'B\' elif 192 <= first_octet <= 223: return \'C\' elif 224 <= first_octet <= 239: return \'D\' elif 240 <= first_octet <= 255: return \'E\' else: raise ValueError(\\"Invalid IP Address\\")"},{"question":"# Problem Statement Given a list of integers representing the quantities of different types of items available for sale, write a function, `max_min_product`, that computes the maximum product achievable by multiplying the minimum quantities from any two different types. # Function Signature ```python def max_min_product(quantities: list[int]) -> int: ``` # Input - `quantities`: List of integers where each integer represents the quantity of an item. The length of the list ( (n) ) will be between 2 and 10^5 inclusive. # Output - Returns an integer representing the maximum product of the minimum quantities from two different types. # Examples ```python assert max_min_product([3, 6, 5, 8]) == 24 # Maximum product of minimum quantities is 6*4 = 24 assert max_min_product([1, 7, 3, 9, 4]) == 28 # Maximum product of minimum quantities is 7*4 = 28 assert max_min_product([2, 1, 2, 2]) == 4 # Maximum product of minimum quantities is 2*2 = 4 assert max_min_product([5, 4]) == 20 # Maximum product of minimum quantities is 5*4 = 20 ``` # Constraints & Notes - The list will contain at least two items. - Quantities will be positive integers. - Ensure the solution handles large lists efficiently with a linearithmic complexity of ( O(n log n) ) if sorting is used, or ( O(n) ) if solved linearly. - Consider edge cases such as lists with many identical quantities.","solution":"def max_min_product(quantities): Computes the maximum product achievable by multiplying the minimum quantities from any two different types. Parameters: quantities (list of int): List of integers where each integer represents the quantity of an item. Returns: int: The maximum product of the minimum quantities from two different types. # Sort the quantities in descending order quantities.sort(reverse=True) # The maximum product of two different minimum quantities will be the product of the first and second largest numbers return quantities[0] * quantities[1]"},{"question":"# Problem Statement **Palindrome Permutation Check** Welcome to the special task force working on optimizing data storage efficiency. Your team lead has asked you to come up with a strategy to identify whether any permutation of a given string can form a palindrome. This will help in compressing and indexing certain types of data more effectively. A palindrome is a word or phrase that reads the same backward as forward. For instance, \\"racecar\\" and \\"level\\" are palindromes. For a string to have a permutation that is a palindrome, it must have at most one character with an odd count (for odd-length strings), and all other characters must have even counts. Write a Python function `can_form_palindrome(s: str) -> bool` that checks if any permutation of the given string can be rearranged to form a palindrome. **Input Format:** - A single string `s` containing only alphabets (both uppercase and lowercase). **Output Format:** - Returns `True` if any permutation of the given string can form a palindrome, otherwise returns `False`. **Constraints:** - The string consists only of alphabetic characters (a-z, A-Z). - The function should handle incorrect input types by raising a `ValueError` with an appropriate message. **Examples:** ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"\\") Traceback (most recent call last): ... ValueError: Input string cannot be empty >>> can_form_palindrome(\\"AbleWasiEreISawElba\\") True >>> can_form_palindrome(12345) Traceback (most recent call last): ... ValueError: Input must be a string >>> can_form_palindrome(\\"madam\\") True >>> can_form_palindrome(\\"MadAm\\") True ``` Implement the function using the specified description above.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Checks if any permutation of the string s can form a palindrome. :param s: The input string consisting of alphabetic characters only. :return: True if any permutation of s can form a palindrome, False otherwise. :raises ValueError: If the input is not a string or is empty. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if s == \\"\\": raise ValueError(\\"Input string cannot be empty\\") s = s.lower() counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Question: Implement a Custom Sorting Algorithm for Mixed Type Elements Overview: You are tasked with implementing a custom sorting function for a list containing mixed data types such as integers, floating-point numbers, and strings. The sorting should be conducted based on a custom comparator function that you will define. The comparator should prioritize integers, followed by floating-point numbers, and then strings. Within each type, perform an ascending order sort. Function Signature: ```python def custom_sort_mixed_type_elements(arr: list) -> list: Sorts a mixed list of integers, floating-point numbers, and strings based on a custom comparator. - Integers should come before floating-point numbers, which should come before strings. - Within each type, elements should be sorted in ascending order. Parameters: arr (list): A list containing integers, floating-point numbers, and strings. Returns: list: The sorted list according to the custom criteria. pass ``` Input: * `arr` - A list containing unsorted elements. (0 <= len(arr) <= 10^5) * The list will contain only integers, floating-point numbers, and strings. Output: * Return a list sorted according to the custom comparator rules. Constraints: * Ensure that the sorting function maintains a time complexity of O(n log n). Example: ```python assert custom_sort_mixed_type_elements([4, \'apple\', 2.2, 3, \'banana\', 1.1]) == [3, 4, 1.1, 2.2, \'apple\', \'banana\'] assert custom_sort_mixed_type_elements([\'cat\', 1, \'bat\', 0.5, 3, 2]) == [1, 3, 2, 0.5, \'bat\', \'cat\'] assert custom_sort_mixed_type_elements([]) == [] ``` Notes: - Ensure edge cases like empty lists and lists with only one type of element are handled correctly. - Your implementation should be able to sort efficiently and use a stable sorting algorithm where applicable.","solution":"def custom_sort_mixed_type_elements(arr): Sorts a mixed list of integers, floating-point numbers, and strings based on a custom comparator. - Integers should come before floating-point numbers, which should come before strings. - Within each type, elements should be sorted in ascending order. Parameters: arr (list): A list containing integers, floating-point numbers, and strings. Returns: list: The sorted list according to the custom criteria. def custom_key(item): if isinstance(item, int): return (0, item) elif isinstance(item, float): return (1, item) else: # item is a string return (2, item) return sorted(arr, key=custom_key)"},{"question":"# Sum of Alternate Nodes in a Linked List Problem Statement Given a singly linked list, write a function to return the sum of the data of alternative nodes starting with the head node. Write a function `sum_alternate_nodes(head: Optional[ListNode]) -> int` that takes the head of a singly linked list as input and returns the sum of the data of alternate nodes. Input Format * A singly linked list where each node contains an integer data. Output Format * A single integer representing the sum of the data of alternate nodes. Example Input: ```python # The linked list: 1 -> 2 -> 3 -> 4 -> 5 class ListNode: def __init__(self, x): self.val = x self.next = None head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) head.next.next.next.next = ListNode(5) ``` Output: ```python 9 # (1 + 3 + 5) ``` Additional Example Scenarios Input: ```python # The linked list: 2 -> 5 -> 8 head = ListNode(2) head.next = ListNode(5) head.next.next = ListNode(8) ``` Output: ```python 10 # (2 + 8) ``` Constraints * Ensure the function can handle scenario inputs where the linked list might be empty. * The input linked list nodes can contain any integer data (positive, negative, or zero). * The linked list can have up to 10^4 nodes. Requirements * Implement the function `sum_alternate_nodes` with the following signature: ```python def sum_alternate_nodes(head: Optional[ListNode]) -> int: ``` Performance * The implementation should run with a time complexity of O(n), where n is the number of nodes in the linked list. ```python class ListNode: def __init__(self, x): self.val = x self.next = None def sum_alternate_nodes(head: Optional[ListNode]) -> int: current = head total = 0 count = 1 while current: if count % 2 != 0: total += current.val current = current.next count += 1 return total ``` This question ensures that the assessment covers an important data structure (Linked List) and operations on it, matching the complexity and problem-solving skills required for the given examples.","solution":"from typing import Optional class ListNode: def __init__(self, x): self.val = x self.next = None def sum_alternate_nodes(head: Optional[ListNode]) -> int: current = head total = 0 count = 0 while current: if count % 2 == 0: total += current.val current = current.next count += 1 return total"},{"question":"New Question # Coding Question: Stock Price Analysis Using Moving Average You are required to implement a function to analyze the stock price trend based on moving average. This function will help in identifying the rolling average of stock prices over a specified window. Requirements: - **Function Signature**: `def moving_average(stock_prices: List[float], window_size: int) -> List[float]:` - **Input**: - `stock_prices` - A list of floats representing the stock prices recorded over a period. - `window_size` - An integer representing the window size for calculating the moving averages. - **Output**: A list of floats representing the moving average of the stock prices over the specified window size. Constraints: - `1 ≤ len(stock_prices) ≤ 10,000` - `1 ≤ window_size ≤ len(stock_prices)` - Float values of stock prices range from `0` to `10,000`. Notes: - The moving average for the first `window_size - 1` elements is undefined; you may return these as `None`. - Ensure the resulting list has the same length as the input list of stock prices. Performance: - Aim to maintain time complexity within O(n), where n is the length of the `stock_prices`. Example: ```python stock_prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] window_size = 3 assert moving_average(stock_prices, window_size) == [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] stock_prices = [3, 5, 7, 9, 11, 13, 15, 17] window_size = 4 assert moving_average(stock_prices, window_size) == [None, None, None, 6.0, 8.0, 10.0, 12.0, 14.0] stock_prices = [100, 200, 300, 400, 500] window_size = 5 assert moving_average(stock_prices, window_size) == [None, None, None, None, 300.0] ``` --- This new question aligns with the existing style, complexity, and scope of the questions provided, examining a common coding task relevant to analyzing stock price trends using a rolling window calculation.","solution":"from typing import List def moving_average(stock_prices: List[float], window_size: int) -> List[float]: Calculates the moving average for a list of stock prices over a specified window size. The moving average for the first `window_size - 1` elements is undefined (None). :param stock_prices: List of stock prices (floats). :param window_size: The size of the window for moving average calculation. :return: List of moving averages (floats) with None for undefined values. n = len(stock_prices) if window_size > n or window_size < 1: raise ValueError(\\"Invalid window size\\") result = [None] * (window_size - 1) current_sum = sum(stock_prices[:window_size]) result.append(current_sum / window_size) for i in range(window_size, n): current_sum += stock_prices[i] - stock_prices[i - window_size] result.append(current_sum / window_size) return result"},{"question":"# Determine the Type of Triangle Given the lengths of three sides of a triangle, determine the type of triangle these sides form. The possible types of triangles are: - Equilateral: All three sides are equal. - Isosceles: Exactly two sides are equal. - Scalene: All three sides are different. - Not a triangle: The given sides do not form a valid triangle (e.g., the sum of any two sides must be greater than the third side). # Task Write a function `classify_triangle` that takes three integers `a`, `b`, and `c` representing the lengths of the sides of a triangle and returns a string indicating the type of triangle these sides form. # Constraints * 1 ≤ a, b, c ≤ 1000. # Input * Three integers `a`, `b`, and `c` representing the lengths of the sides of the triangle. # Output * A string representing the type of triangle: \\"Equilateral\\", \\"Isosceles\\", \\"Scalene\\", or \\"Not a triangle\\". # Examples ```python >>> classify_triangle(3, 3, 3) \'Equilateral\' >>> classify_triangle(3, 4, 5) \'Scalene\' >>> classify_triangle(4, 4, 6) \'Isosceles\' >>> classify_triangle(1, 2, 3) \'Not a triangle\' >>> classify_triangle(10, 1, 1) \'Not a triangle\' ``` # Function Signature ```python def classify_triangle(a: int, b: int, c: int) -> str: pass ``` # Performance Requirements Ensure that the solution checks the triangle inequality properly and handles all given input constraints. The solution should be efficient and concise.","solution":"def classify_triangle(a: int, b: int, c: int) -> str: if a + b <= c or a + c <= b or b + c <= a: return \\"Not a triangle\\" elif a == b == c: return \\"Equilateral\\" elif a == b or a == c or b == c: return \\"Isosceles\\" else: return \\"Scalene\\""},{"question":"# Question: Count Consecutive Characters Your task is to write a function to count the number of consecutive characters in a given string. The function should return a string where each character is followed by its consecutive count. Function Signature ```python def count_consecutive_chars(input_str: str) -> str: Count consecutive characters in the input string. :param input_str: A string to process. :return: A new string with characters followed by their consecutive counts. ``` Input - A single string `input_str` with characters in the printable Unicode range. Output - A string where each character from the input is followed by a number representing its consecutive count. Constraints - The length of the string is between 1 and 10^6 characters. Performance Requirements - The solution should run in O(n) time complexity where n is the length of the string. Examples ```python # Example 1: # Input: \\"aaabbc\\" # Output: \\"a3b2c1\\" # Example 2: # Input: \\"abcd\\" # Output: \\"a1b1c1d1\\" # Example 3: # Input: \\"zzzzy\\" # Output: \\"z4y1\\" # Example 4: # Input: \\"\\" # Output: \\"\\" ``` Additional Notes - Consider edge cases such as strings with a single character, strings with all unique characters, and empty strings. - Make sure to handle strings that might contain numbers, punctuation, spaces, and special characters.","solution":"def count_consecutive_chars(input_str: str) -> str: Count consecutive characters in the input string. :param input_str: A string to process. :return: A new string with characters followed by their consecutive counts. if not input_str: return \\"\\" result = [] current_char = input_str[0] count = 1 for char in input_str[1:]: if char == current_char: count += 1 else: result.append(current_char + str(count)) current_char = char count = 1 # Append the last group result.append(current_char + str(count)) return \'\'.join(result)"},{"question":"You have been given a time series data which contains temperature readings measured at a weather station. Your task is to implement a function, `moving_average`, that computes the moving average of the temperature readings with a given window size. Function Signature ```python def moving_average(data: List[float], window_size: int) -> List[float]: ``` Parameters * `data`: A list of float values representing the temperature readings. * `window_size`: An integer representing the window size for which to compute the moving average. Output * Returns a list of float values containing the moving average of the readings. The length of this list will be `len(data) - window_size + 1`. Description 1. Create a function to compute the moving average over the temperature data with a specified window size. 2. Use a sliding window to compute the averages efficiently. 3. Make sure to handle edge cases, such as when `data` is empty or when `window_size` is larger than the length of `data`. Example ```python data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0] window_size = 3 avg = moving_average(data, window_size) print(avg) ``` This should print `[2.0, 3.0, 4.0, 5.0, 6.0]`, which are the moving averages of the temperature readings with a window size of 3. **Constraints**: - The function should handle different window sizes efficiently. - Ensure that the algorithm works correctly for any list of float values. - The function should return an empty list if the `data` list is empty or if the `window_size` is too large to produce any averages.","solution":"from typing import List def moving_average(data: List[float], window_size: int) -> List[float]: Computes the moving average of the temperature readings with a given window size. Parameters: - data: List of float values representing the temperature readings. - window_size: Integer representing the window size for the moving average. Returns: - List of float values containing the moving average of the readings. if not data or window_size <= 0 or window_size > len(data): return [] result = [] window_sum = sum(data[:window_size]) result.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] result.append(window_sum / window_size) return result"},{"question":"# Morse Code Converter Implementation Context You are tasked with implementing a Morse Code Converter to encode and decode messages between plain text and Morse code. Morse code represents letters, digits, and punctuation as sequences of dots (.) and dashes (-). The provided mappings for Morse Code are: ```python MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \', \': \'--..--\', \'.\': \'.-.-.-\', \'?\': \'..--..\', \'/\': \'-..-.\', \'-\': \'-....-\', \'(\': \'-.--.\', \')\': \'-.--.-\' } ``` Task Implement two methods of the MorseCodeConverter class in Python: `encode` and `decode`. Method Details 1. **encode(message: str) -> str**: - **Input**: A message string containing only alphabetic characters, digits, and standard punctuation. - **Output**: The encoded message as a string of morse code with each character separated by a single space and words separated by a slash (\'/\'). - **Example**: ```python converter = MorseCodeConverter() assert converter.encode(\\"HELLO WORLD\\") == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" ``` 2. **decode(message: str) -> str**: - **Input**: A string containing Morse code sequences separated by spaces, and words separated by slashes (\'/\'). - **Output**: The decoded, original message as a string. - **Example**: ```python converter = MorseCodeConverter() assert converter.decode(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") == \\"HELLO WORLD\\" ``` You can use a reverse lookup for decoding where each Morse code sequence maps back to the corresponding character. Constraints - Assume input messages will be reasonably small to medium-sized. - Ignore case sensitivity; treat all input as uppercase. - Only consider standard Morse Code characters. Performance - Aim for linear processing time relative to message length. - Ensure minimal additional space usage beyond what is necessary for processing the message.","solution":"MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\', \'0\': \'-----\', \', \': \'--..--\', \'.\': \'.-.-.-\', \'?\': \'..--..\', \'/\': \'-..-.\', \'-\': \'-....-\', \'(\': \'-.--.\', \')\': \'-.--.-\' } class MorseCodeConverter: def encode(self, message): morse_message = [] for word in message.upper().split(\' \'): morse_word = \' \'.join(MORSE_CODE_DICT[char] for char in word) morse_message.append(morse_word) return \' / \'.join(morse_message) def decode(self, message): text_message = [] for morse_word in message.split(\' / \'): word = \'\'.join({v: k for k, v in MORSE_CODE_DICT.items()}[char] for char in morse_word.split()) text_message.append(word) return \' \'.join(text_message)"},{"question":"Problem Statement You are tasked with implementing a function to compute the n-th element in the Catalan number sequence using dynamic programming. The Catalan numbers form a sequence of natural numbers that appear in various counting problems, often involving recursive structures. # Function Signature ```python def catalan_number(n: int) -> int: pass ``` # Expected Input and Output Formats - **Input**: An integer `n` (0 ≤ n ≤ 1000), representing the position in the Catalan sequence. - **Output**: An integer, the n-th Catalan number. # Constraints 1. The input integer `n` will be between 0 and 1000. 2. The function must efficiently compute the Catalan number using dynamic programming. # Performance Requirements - The implementation should ideally have a time complexity of O(n^2). - The function should use space efficiently, ensuring not to exceed necessary memory usage required by a dynamic programming approach. # Example ```python >>> catalan_number(0) 1 >>> catalan_number(1) 1 >>> catalan_number(5) 42 >>> catalan_number(10) 16796 ``` # Additional Information To solve this task, consider the following approach: 1. Use the recursive relation for Catalan numbers: ( C_{n} = sum_{i=0}^{n-1} C_{i} * C_{n-1-i} ) 2. Implement a dynamic programming solution that uses an array to store computed values of Catalan numbers to avoid redundant calculations. **Note**: Python handles large integers natively, but aim for an implementation that ensures performance constraints are met by leveraging the properties of dynamic programming.","solution":"def catalan_number(n: int) -> int: Returns the n-th Catalan number using dynamic programming. if n == 0: return 1 # Array to store the computed Catalan numbers catalan = [0] * (n + 1) catalan[0] = 1 # C0 is 1 # Calculate the rest using the recursive relation for i in range(1, n + 1): for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[n]"},{"question":"# Coding Question: Find the First Non-Repeating Character in a String Context You have been tasked with creating a function that finds the first non-repeating character in a given string. This can be useful in applications that involve string processing, text analysis, or data cleaning, where identifying unique characters is key. Task Write a function `first_non_repeating_character(s: str) -> str` that takes a string `s` as input and returns the first non-repeating character. If there is no non-repeating character, the function should return an empty string `\\"\\"`. Expected Input and Output * **Input**: A single string parameter `s`. * **Output**: The first non-repeating character in the string or an empty string `\\"\\"` if no unique character exists. Constraints 1. The function should raise a `TypeError` if the input is not a string. 2. The function should perform in O(n) time complexity, where n is the length of the string. 3. The string may contain any printable ASCII characters. Performance Requirements * The solution must operate efficiently in O(n) time and O(1) space for the auxiliary data structures used. Examples ```python >>> first_non_repeating_character(\\"hello\\") \'h\' >>> first_non_repeating_character(\\"swiss\\") \'w\' >>> first_non_repeating_character(\\"releveler\\") \'v\' >>> first_non_repeating_character(\\"aabbcc\\") \'\' >>> first_non_repeating_character(\\"a\\") \'a\' >>> first_non_repeating_character(\\"\\") \'\' >>> first_non_repeating_character(123) Traceback (most recent call last): ... TypeError: input must be a string ``` - **Single Character String Example**: `first_non_repeating_character(\\"z\\")` should return `\'z\'`. - **Empty String Example**: `first_non_repeating_character(\\"\\")` should return `\\"\\"`. # Edge Cases and Performance Expectations Consider and handle edge cases such as: * An empty string as input. * A string with only duplicate characters. * A string with a single character. * Large strings. Your solution should account for these scenarios and operate efficiently.","solution":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If no such character exists, returns an empty string. Parameters: s (str): The input string Returns: str: The first non-repeating character or an empty string if none exists Raises: TypeError: If the input is not a string if not isinstance(s, str): raise TypeError(\\"input must be a string\\") char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 for char in s: if char_count[char] == 1: return char return \\"\\""},{"question":"# Coding Assessment: Array Rotation You are tasked with implementing a function that rotates the elements of an array to the right by a given number of steps. The function should handle arrays of any length and efficiently manage rotations greater than the array length by using modular arithmetic. # Function Signature ```python def rotate_array(arr: list, steps: int) -> list: Rotate the elements of the array to the right by the given number of steps. Args: arr (list): List of elements to be rotated. steps (int): Number of steps to rotate the array. Returns: list: The rotated array. ``` # Input and Output Formats **Input**: - A list of elements `arr` (integers or other types). - An integer `steps` representing the number of steps to rotate the array to the right. **Output**: - A list containing the elements of the original array, rotated to the right by the specified number of steps. # Constraints * The input array `arr` can be of any length, including empty. * `steps` is a non-negative integer. # Example ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([\'a\', \'b\', \'c\'], 1) [\'c\', \'a\', \'b\'] ``` # Requirements 1. Implement the `rotate_array` function to handle arrays efficiently, even when `steps` is larger than the array length. 2. Consider edge cases such as empty arrays and zero rotation steps during your implementation. 3. Optimize for simplicity and performance. # Note Including test cases to validate your implementation is recommended to ensure correctness across various scenarios. Good luck!","solution":"def rotate_array(arr: list, steps: int) -> list: Rotate the elements of the array to the right by the given number of steps. Args: arr (list): List of elements to be rotated. steps (int): Number of steps to rotate the array. Returns: list: The rotated array. if not arr: return arr n = len(arr) steps = steps % n # Handle cases where steps are greater than array length return arr[-steps:] + arr[:-steps]"},{"question":"# Coding Assessment Question Objective: Implement a function to validate and compute the sum of differences between consecutive elements in a list of integers. Description: You are tasked with writing a function `sum_of_differences` to calculate the sum of the absolute differences between each pair of consecutive elements in a provided list of integers. The function should validate the input to ensure it\'s a list of integers and handle any invalid inputs appropriately. Input: - A list of integers. Output: - Return a single integer which is the sum of the absolute differences between each pair of consecutive elements in the list. Constraints: - Follow proper error handling for invalid inputs (non-list inputs, non-integer elements within the list, etc.). - If the list contains zero or one element, the function should return 0. Example: ```python input_list = [3, 8, 15, 24] expected_output = 26 # Explanation: |8-3| + |15-8| + |24-15| = 5 + 7 + 9 = 21 ``` Function Signature: ```python def sum_of_differences(nums: list) -> int: pass ``` Implementation Instructions: 1. Implement input validation to ensure the input is a non-empty list of integers. 2. Calculate the sum of absolute differences between consecutive elements. 3. Ensure the function is efficient and readable.","solution":"from typing import List def sum_of_differences(nums: List[int]) -> int: Returns the sum of the absolute differences between each pair of consecutive elements in the list. :param nums: List of integers. :return: Sum of absolute differences or 0 for invalid input or insufficient elements. if not isinstance(nums, list) or not all(isinstance(i, int) for i in nums): return 0 if len(nums) < 2: return 0 total_sum = 0 for i in range(1, len(nums)): total_sum += abs(nums[i] - nums[i - 1]) return total_sum"},{"question":"# Coding Question: Implementing Dijkstra\'s Algorithm In this task, you will implement Dijkstra\'s algorithm to find the shortest paths from a source vertex to all other vertices in a weighted, directed graph. You will be provided with the graph as a dictionary, where the keys are vertices and the values are lists of tuples representing the adjacent vertices and the edge weights. Function Signature: ```python def dijkstra(graph: dict[int, list[tuple[int, int]]], source: int) -> list[int]: pass ``` # Input: - **graph**: A dictionary where each key is an integer representing a vertex, and each value is a list of tuples. Each tuple contains two integers: the adjacent vertex and the weight of the edge connecting the key vertex to the adjacent vertex. - **source**: An integer representing the starting vertex for Dijkstra\'s algorithm. # Output: - A list of integers where the (i)-th element represents the minimum distance from the source vertex to vertex (i). # Constraints: - The graph contains (n) vertices, where (1 leq n leq 100). - The graph is connected, so there is a path from the source vertex to every other vertex. - The graph does not contain negative weight edges. - The vertex indices are between (0) and (n-1). # Examples: 1. **Input**: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 ``` **Output**: ```python [0, 3, 1, 4] ``` 2. **Input**: ```python graph = { 0: [(1, 10), (2, 2)], 1: [(2, 1), (3, 5)], 2: [(1, 3), (3, 9)], 3: [] } source = 0 ``` **Output**: ```python [0, 5, 2, 10] ``` # Explanation: In the first example, the shortest path from vertex 0 to vertex 1 is through vertex 2 with a total weight of 3 (path: 0 -> 2 -> 1). The shortest path from vertex 0 to vertex 3 is through vertex 1 with a total weight of 4 (path: 0 -> 2 -> 1 -> 3). In the second example, the shortest path from vertex 0 to vertex 1 is directly through vertex 2 with a total weight of 5 (path: 0 -> 2 -> 1). The shortest path from vertex 0 to vertex 3 is through vertex 1 with a total weight of 10 (path: 0 -> 2 -> 1 -> 3). # Notes: Ensure your implementation optimizes for both time and space complexity, suitable for graphs up to the maximum constraint. Consider using a priority queue to efficiently determine the next vertex to process.","solution":"import heapq def dijkstra(graph: dict[int, list[tuple[int, int]]], source: int) -> list[int]: n = len(graph) distances = [float(\'inf\')] * n distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Time-Based Greeting Assignment Problem Statement You are tasked with writing a function `time_based_greeting(time_str)` that returns an appropriate greeting based on the provided time. The time will be given in a 24-hour clock format (`HH:MM`). The greetings should follow these rules: - \\"Good Morning\\" for times between 05:00 and 11:59 (inclusive). - \\"Good Afternoon\\" for times between 12:00 and 16:59 (inclusive). - \\"Good Evening\\" for times between 17:00 and 20:59 (inclusive). - \\"Good Night\\" for times between 21:00 and 04:59 (inclusive). Function Signature ```python def time_based_greeting(time_str: str) -> str: ``` Input - **time_str**: A string representing the time in `HH:MM` format where `HH` is between `00` and `23` and `MM` is between `00` and `59`. Output - The function should return a string with the appropriate greeting. Constraints - The input string will always be in valid `HH:MM` format. - 00 <= HH <= 23 - 00 <= MM <= 59 Example ```python time_based_greeting(\\"06:30\\") ``` Output: `Good Morning` ```python time_based_greeting(\\"12:00\\") ``` Output: `Good Afternoon` ```python time_based_greeting(\\"19:45\\") ``` Output: `Good Evening` ```python time_based_greeting(\\"23:15\\") ``` Output: `Good Night` Additional Details - Ensure that edge times exactly at the boundary of two time periods are handled properly. - The function should not raise any exceptions for the given valid input format.","solution":"def time_based_greeting(time_str: str) -> str: Returns an appropriate greeting based on the given time. :param time_str: A string representing the time in `HH:MM` format. :return: A string with the appropriate greeting. hour = int(time_str[:2]) if 5 <= hour < 12: return \\"Good Morning\\" elif 12 <= hour < 17: return \\"Good Afternoon\\" elif 17 <= hour < 21: return \\"Good Evening\\" else: return \\"Good Night\\""},{"question":"# Problem Statement You need to implement a persistent stack data structure. A persistent stack allows you to create different versions of the stack that can be accessed later without altering the original stack state. More specifically, it should allow pushing and popping elements from the stack while preserving older versions of the stack for future access. # Requirements 1. **Push**: Implement a method to push a new element onto the stack, creating a new version of the stack. 2. **Pop**: Implement a method to pop an element from the stack, creating a new version of the stack. 3. **Top**: Implement a method to return the top element of a particular version of the stack. 4. **GetVersion**: Implement a method to retrieve the stack of a particular version. 5. **Print**: Implement a method to print all elements of a particular version of the stack. # Function Signatures You should define the following methods in a PersistentStack class: ```python class PersistentStack: def __init__(self) -> None: pass def push(self, version: int, value: int) -> int: pass def pop(self, version: int) -> int: pass def top(self, version: int) -> int: pass def get_version(self, version: int) -> List[int]: pass def print_version(self, version: int) -> None: pass ``` # Input/Output Format: - **Push**: Should take a version number and a single integer, return the new version number. - **Pop**: Should take a version number, return the new version number. - **Top**: Should take a version number, return the top integer of that version. - **GetVersion**: Should take a version number, return a list of integers representing the state of the stack at that version. - **Print**: Should take a version number and print the elements of that version in order from top to bottom. # Constraints - All operations should have a time complexity of O(1) except for Print which should be O(N), where N is the number of elements in the stack. - Version numbers are unique and start from 0 for the initial empty stack. # Example Usage: ```python ps = PersistentStack() v1 = ps.push(0, 10) # Creates version 1 v2 = ps.push(v1, 20) # Creates version 2 v3 = ps.pop(v2) # Creates version 3 print(ps.top(v1)) # Output: 10 print(ps.top(v2)) # Output: 20 print(ps.top(v3)) # Output: 10 ps.print_version(v2) # Output: 20 10 ps.print_version(v3) # Output: 10 ``` # Notes: - Ensure that the methods handle edge cases, such as accessing elements from an invalid version, gracefully. - Include appropriate error handling and raise exceptions where applicable.","solution":"class PersistentStack: def __init__(self) -> None: self.versions = {0: []} # Initialize with version 0 as an empty list def push(self, version: int, value: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") new_version = len(self.versions) new_stack = self.versions[version][:] # Create a copy of the current stack new_stack.append(value) self.versions[new_version] = new_stack return new_version def pop(self, version: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") if not self.versions[version]: raise IndexError(\\"Cannot pop from an empty stack\\") new_version = len(self.versions) new_stack = self.versions[version][:] # Create a copy of the current stack new_stack.pop() self.versions[new_version] = new_stack return new_version def top(self, version: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") if not self.versions[version]: raise IndexError(\\"The stack is empty\\") return self.versions[version][-1] def get_version(self, version: int) -> list: if version not in self.versions: raise ValueError(\\"Version does not exist\\") return self.versions[version] def print_version(self, version: int) -> None: if version not in self.versions: raise ValueError(\\"Version does not exist\\") # Print each element from top to bottom for item in reversed(self.versions[version]): print(item)"},{"question":"# Problem Description You have been given a string consisting of only lowercase English alphabets. Your task is to implement a function that counts the number of duplicate characters in the string. A duplicate character is defined as a character that appears more than once in the string. # Function Signature ```python def count_duplicate_characters(s: str) -> int: ``` # Input * `s` (str): A non-empty string consisting of only lowercase English alphabets. # Output * Returns an integer representing the number of duplicate characters in the string. # Constraints * The length of the string `s` is at least 1 and at most 10^5. # Performance Requirements * Your implementation should have a time complexity of O(n) and a space complexity of O(1) considering the fixed alphabet size. # Example ```python assert count_duplicate_characters(\\"aabcc\\") == 2 assert count_duplicate_characters(\\"abcdefg\\") == 0 assert count_duplicate_characters(\\"abacaba\\") == 3 ``` # Edge Cases * **Edge Case 1**: Ensure the input is a non-empty string. * **Edge Case 2**: Handle strings with no duplicate characters. * **Edge Case 3**: Consider strings with multiple duplicates of multiple characters.","solution":"def count_duplicate_characters(s: str) -> int: Returns the number of duplicate characters in the string s. from collections import Counter char_count = Counter(s) duplicate_count = sum(1 for count in char_count.values() if count > 1) return duplicate_count"},{"question":"# Question **Smallest Multiple** The task is to find the smallest positive number that is evenly divisible by all of the numbers from 1 to a given limit. Write a function `find_smallest_multiple(limit: int) -> int` that returns the smallest multiple of all numbers from 1 up to `limit`. # Input - `limit` (integer): the upper bound of the range, an integer `limit >= 1`. # Output - An integer representing the smallest positive number that is evenly divisible by all of the numbers from 1 to `limit`. # Constraints - Your solution should efficiently handle limits up to the order of 20. - Consider edge cases with small values for the limit. # Example ```python def find_smallest_multiple(limit: int) -> int: # Your implementation here. # Example Usage print(find_smallest_multiple(10)) # Expected output: 2520 ``` # Explanation * The smallest number that is evenly divisible by all of the numbers from 1 to 10 is 2520. - Factors of 2520 include all numbers from 1 to 10: - 2520 / 1 = 2520 - 2520 / 2 = 1260 - 2520 / 3 = 840 - 2520 / 4 = 630 - 2520 / 5 = 504 - 2520 / 6 = 420 - 2520 / 7 = 360 - 2520 / 8 = 315 - 2520 / 9 = 280 - 2520 / 10 = 252","solution":"from math import gcd def find_smallest_multiple(limit: int) -> int: Find the smallest positive number that is evenly divisible by all of the numbers from 1 to a given limit. Parameters: limit (int): Upper bound of the range. Returns: int: Smallest multiple of all numbers from 1 to limit. def lcm(x, y): return x * y // gcd(x, y) smallest_multiple = 1 for number in range(2, limit + 1): smallest_multiple = lcm(smallest_multiple, number) return smallest_multiple"},{"question":"# Problem Statement: Create a function to simulate the basic operations of a library\'s book management system. The system should allow users to: 1. Add a new book. 2. Borrow a book. 3. Return a book. 4. Check the status of a book. # Your Task: Implement four functions to manage the library\'s book inventory: 1. `add_book(title: str) -> None`: Adds a new book to the inventory. 2. `borrow_book(title: str) -> str`: Marks a book as borrowed if available. 3. `return_book(title: str) -> None`: Marks a book as returned. 4. `get_book_status(title: str) -> str`: Returns the status of a book (\\"Available\\" or \\"Borrowed\\"). # Specifications: 1. **Input Format:** * `title` is a non-empty string containing the title of the book. 2. **Output Format:** * The function `borrow_book` should return: - `\\"Borrowed Successfully\\"` if the book was borrowed successfully. - `\\"Book Not Available\\"` if the book is not in the inventory or already borrowed. * The function `get_book_status` should return: - `\\"Available\\"` if the book is available to borrow. - `\\"Borrowed\\"` if the book is currently borrowed. 3. **Constraints:** * Each book title is unique and case-sensitive. * The library initially contains no books. * Functions should handle cases where operations are performed on non-existent books gracefully. 4. **Performance Consideration:** * Aim for efficient book lookups and updates. Consider using appropriate data structures. # Example: ```python def add_book(title: str) -> None: # Implement function to add a book to the inventory def borrow_book(title: str) -> str: # Implement function to borrow a book from the inventory and return status message def return_book(title: str) -> None: # Implement function to return a borrowed book to the inventory def get_book_status(title: str) -> str: # Implement function to check and return the status of the book ``` ```python # Example Implementation: add_book(\\"The Great Gatsby\\") print(get_book_status(\\"The Great Gatsby\\")) # Expected output: \\"Available\\" print(borrow_book(\\"The Great Gatsby\\")) # Expected output: \\"Borrowed Successfully\\" print(get_book_status(\\"The Great Gatsby\\")) # Expected output: \\"Borrowed\\" return_book(\\"The Great Gatsby\\") print(get_book_status(\\"The Great Gatsby\\")) # Expected output: \\"Available\\" ``` # Hints: * Use a dictionary to keep track of the book inventory and their statuses. * Ensure to handle scenarios like trying to borrow a book that does not exist in the inventory. * Consider edge cases like returning a book that is not borrowed or not in the inventory.","solution":"library_inventory = {} def add_book(title: str) -> None: Adds a new book to the inventory. if title not in library_inventory: library_inventory[title] = \\"Available\\" def borrow_book(title: str) -> str: Marks a book as borrowed if available. Returns: str: \\"Borrowed Successfully\\" if the book was borrowed successfully. \\"Book Not Available\\" if the book is not in the inventory or already borrowed. if title in library_inventory: if library_inventory[title] == \\"Available\\": library_inventory[title] = \\"Borrowed\\" return \\"Borrowed Successfully\\" else: return \\"Book Not Available\\" else: return \\"Book Not Available\\" def return_book(title: str) -> None: Marks a book as returned. if title in library_inventory and library_inventory[title] == \\"Borrowed\\": library_inventory[title] = \\"Available\\" def get_book_status(title: str) -> str: Returns the status of a book. Returns: str: \\"Available\\" if the book is available to borrow. \\"Borrowed\\" if the book is currently borrowed. if title in library_inventory: return library_inventory[title] else: return \\"Book Not Available\\""},{"question":"# Question Create a function named `deep_merge_dicts` that takes two dictionaries `dict1` and `dict2` and recursively merges `dict2` into `dict1`. If there are overlapping keys, the values from `dict2` should overwrite the values from `dict1`. The function should return the merged dictionary. The dictionaries will only contain basic data types (integers, floats, strings, lists, and other dictionaries) as values. Lists encountered at the same key should be concatenated together. # Required Function Signature ```python def deep_merge_dicts(dict1: dict, dict2: dict) -> dict: pass ``` # Examples ```python >>> dict1 = {\'a\': 1, \'b\': {\'x\': 10, \'y\': 20}, \'c\': [1, 2]} >>> dict2 = {\'b\': {\'y\': 30, \'z\': 40}, \'c\': [3, 4], \'d\': \'new\'} >>> deep_merge_dicts(dict1, dict2) {\'a\': 1, \'b\': {\'x\': 10, \'y\': 30, \'z\': 40}, \'c\': [1, 2, 3, 4], \'d\': \'new\'} >>> dict1 = {\'a\': {\'b\': {\'c\': 1}}, \'d\': [1, 2]} >>> dict2 = {\'a\': {\'b\': {\'d\': 2}}, \'d\': [3, 4]} >>> deep_merge_dicts(dict1, dict2) {\'a\': {\'b\': {\'c\': 1, \'d\': 2}}, \'d\': [1, 2, 3, 4]} >>> dict1 = {\'key1\': \'value1\'} >>> dict2 = {\'key2\': \'value2\'} >>> deep_merge_dicts(dict1, dict2) {\'key1\': \'value1\', \'key2\': \'value2\'} ``` # Constraints - The dictionaries can be arbitrarily nested. - If a key exists in both dictionaries, the value in `dict2` should overwrite the value in `dict1`. - Lists in the same key should be concatenated together. - Input dictionaries will not contain non-hashable types (e.g., sets or tuples). - The function should handle empty dictionaries appropriately.","solution":"def deep_merge_dicts(dict1: dict, dict2: dict) -> dict: Recursively merges dict2 into dict1. If there are overlapping keys, the values from dict2 overwrite the values from dict1. Lists encountered at the same key are concatenated together. for key, value in dict2.items(): if key in dict1: if isinstance(dict1[key], dict) and isinstance(value, dict): deep_merge_dicts(dict1[key], value) elif isinstance(dict1[key], list) and isinstance(value, list): dict1[key] += value else: dict1[key] = value else: dict1[key] = value return dict1"},{"question":"# Question: Implement Prim\'s Algorithm for Minimum Spanning Tree You are given an undirected, connected graph with `n` nodes and `m` edges, and each edge has a given positive weight. Your task is to implement Prim\'s Algorithm to find the total weight of the Minimum Spanning Tree (MST). Implement the function `prim_mst(n: int, edges: list[tuple[int, int, int]]) -> int`, which takes the number of nodes `n`, and a list of edges `edges`, where each edge is represented as a tuple `(u, v, w)`, indicating an undirected edge between nodes `u` and `v` with weight `w`. Input: - `n` (1 ≤ n ≤ 1000): The number of nodes. - `edges` (1 ≤ len(edges) ≤ 100000): A list of tuples representing undirected edges in the graph. Output: - An integer representing the total weight of the Minimum Spanning Tree. # Constraints: - Nodes are indexed from `0` to `n-1`. - All nodes and edges are valid and properly formatted. # Examples: Example 1: **Input**: ```python n = 4 edges = [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4), (0, 2, 5)] ``` **Output**: ```python 6 ``` Example 2: **Input**: ```python n = 3 edges = [(0, 1, 1), (1, 2, 1), (0, 2, 2)] ``` **Output**: ```python 2 ``` # Notes: - The graph is connected, so an MST is always possible. - Ensure your function handles all possible edge cases efficiently. - You can assume the input graph has no self-loops or multiple edges between the same pair of nodes. # Function Signature: ```python def prim_mst(n: int, edges: list[tuple[int, int, int]]) -> int: pass ```","solution":"import heapq from collections import defaultdict def prim_mst(n: int, edges: list[tuple[int, int, int]]) -> int: adj = defaultdict(list) result = 0 visited = [False] * n # Build the adjacency list for u, v, w in edges: adj[u].append((w, v)) adj[v].append((w, u)) # Priority queue for Prim\'s algorithm pq = [(0, 0)] # (weight, vertex) while pq: weight, u = heapq.heappop(pq) if visited[u]: continue # Add weight of current edge to the total weight result += weight visited[u] = True # Explore the neighbors for next_weight, v in adj[u]: if not visited[v]: heapq.heappush(pq, (next_weight, v)) return result"},{"question":"# Coding Assessment Question Context You have been recruited to help enhance the functionality of a text processing system. Specifically, you need to refine the system’s ability to efficiently find and replace certain patterns in a given text. Task Write a function `find_and_replace(text: str, target: str, replacement: str) -> str` which scans the given `text` for all occurrences of the `target` string and replaces each occurrence with the `replacement` string. Your implementation should handle edge cases and avoid unnecessary computations. Input/Output Format * **Input**: Three strings `text`, `target`, and `replacement`, where: - `text` represents the original text in which replacements are to be made. - `target` specifies the substring to be replaced. - `replacement` denotes the string to replace each occurrence of the `target`. * **Output**: A new string with all occurrences of `target` replaced by `replacement`. Constraints 1. Handle cases where `target` is an empty string (`target` will not be an empty string in the true edge cases). 2. Ensure efficient performance even for large texts. 3. If `target` is not found in `text`, the output should be the original `text`. Example ```python >>> find_and_replace(\\"hello world\\", \\"world\\", \\"there\\") \\"hello there\\" >>> find_and_replace(\\"banana\\", \\"na\\", \\"123\\") \\"ba123123\\" >>> find_and_replace(\\"aaaaaa\\", \\"a\\", \\"b\\") \\"bbbbbb\\" >>> find_and_replace(\\"no change needed\\", \\"xyz\\", \\"\\") \\"no change needed\\" ``` Write your solution considering optimal string manipulation techniques to ensure the system works efficiently for large inputs.","solution":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all occurrences of target string with replacement string in the given text. Parameters: text (str): The original text in which replacements are to be made. target (str): The substring to be replaced. replacement (str): The string to replace each occurrence of the target. Returns: str: The new string with all occurrences of target replaced by replacement. if target == \'\': return text # Edge case: no-op when target is empty return text.replace(target, replacement)"},{"question":"# Coding Question: Rotated Array Minimum Value Finder You are given an array that has been rotated at an unknown pivot. The array was originally sorted in ascending order but is now possibly rotated. Your task is to find the minimum value in this rotated array in O(log n) time complexity. Input and Output Format * **Input**: A list of integers `arr` which is non-empty and has been rotated. * **Output**: An integer representing the minimum value in the array. Example ```python >>> find_min_rotated([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_min_rotated([7, 8, 1, 2, 3, 4, 5, 6]) 1 >>> find_min_rotated([11, 13, 15, 17]) 11 ``` Constraints - The array will contain at least one element. - All elements in the array are unique. - The array length will not exceed 10^5. - The elements are integers and can be both negative and positive. Function Signature ```python def find_min_rotated(arr: list[int]) -> int: pass ``` Implement the function `find_min_rotated(arr: list[int]) -> int` to solve the problem as described.","solution":"def find_min_rotated(arr: list[int]) -> int: Finds the minimum value in a rotated sorted array. :param arr: List of integers that is non-empty and has been rotated. :return: The minimum value in the array. left, right = 0, len(arr) - 1 if arr[left] < arr[right]: return arr[left] while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 else: right = mid return arr[left]"},{"question":"# Coding Assessment Question: Implementing the Custom Power Function Context Exponentiation is a common operation in programming, often used in mathematical calculations, algorithms, and even data transformations. This exercise will help you demonstrate understanding of recursive functions and efficiency in custom implementations by asking you to implement a power function without using built-in libraries. Problem Statement Write a function `power(base: float, exp: int) -> float` that returns `base` raised to the power of `exp`. It should handle both positive and negative exponents effectively using a recursive approach. Input and Output * The input will be a floating-point number `base` and an integer `exp`. * The output should be a floating-point number which is the result of `base` raised to the power of `exp`. Constraints * The input value `base` will be a valid floating-point number within the range of -10^6 to 10^6. * The input value `exp` will be a valid integer within the range of -10^6 to 10^6. * Do not use any external libraries such as `math.pow` or the `**` operator. Edge Cases * Consider how to handle `exp` as zero, which should return 1 (since any number to the power of 0 is 1). * Ensure the implementation efficiently handles large values of `exp` and both negative and positive exponents. * Ensure the implementation is efficient with a time complexity of O(log n), where n is the exponent. Example ```python def power(base: float, exp: int) -> float: Return base raised to the power of exp. :param base: the base number :param exp: the exponent :return: base raised to the power of exp >>> power(2.0, 3) 8.0 >>> power(2.0, -3) 0.125 >>> power(5.0, 0) 1.0 >>> power(1.0, 1000) 1.0 >>> power(0.0, 5) 0.0 >>> power(0.0, 0) # As a convention, 0^0 is usually defined as 1 1.0 pass ``` Implement the function and ensure it passes all the provided tests.","solution":"def power(base: float, exp: int) -> float: Return base raised to the power of exp using a recursive approach. :param base: the base number :param exp: the exponent :return: base raised to the power of exp # Base case: any number to the power of 0 is 1 if exp == 0: return 1.0 # If exp is negative, convert it to positive and take reciprocal at the end if exp < 0: return 1 / power(base, -exp) # If exp is positive and even if exp % 2 == 0: half_power = power(base, exp // 2) return half_power * half_power # If exp is positive and odd else: half_power = power(base, (exp - 1) // 2) return half_power * half_power * base"},{"question":"# Question: Implement Breadth-First Search (BFS) for Graph Traversal Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. Your task is to implement the BFS algorithm for an unweighted graph represented as an adjacency list in Python. Function Signature ```python def bfs(graph: dict, start_node: int) -> list: Performs a breadth-first search traversal of an unweighted graph. Parameters: graph (dict): The graph represented as an adjacency list where keys are node identifiers and values are lists of adjacent nodes. start_node (int): The starting node for the BFS traversal. Returns: list: A list of nodes in the order they are visited in the BFS traversal. Example: >>> bfs({0: [1, 2, 3], 1: [0, 4, 5], 2: [0], 3: [0], 4: [1], 5: [1]}, 0) [0, 1, 2, 3, 4, 5] pass ``` Input - `graph`: A dictionary where keys are integers representing nodes, and values are lists of integers representing adjacent nodes. - `start_node`: An integer that is the starting node for the BFS traversal. Output - A list of integers representing the order in which nodes are visited during the BFS traversal. Constraints - The graph will not contain any cycles. - The number of nodes in the graph will be between 1 and 10^5. - The graph is connected, meaning there is a path from the `start_node` to any other node. Examples - `bfs({0: [1, 2, 3], 1: [0, 4, 5], 2: [0], 3: [0], 4: [1], 5: [1]}, 0)` should return `[0, 1, 2, 3, 4, 5]`. - `bfs({1: [2, 3], 2: [1, 4], 3: [1], 4: [2]}, 1)` should return `[1, 2, 3, 4]`. Guidelines 1. Use a queue to manage the nodes to be explored, adding adjacent nodes to the queue as you visit each node. 2. Track the nodes that have been visited to avoid processing a node more than once. 3. Ensure the function efficiently traverses large graphs by handling up to 10^5 nodes and edges. # Notes - Pay attention to the order of nodes as they are visited to ensure BFS traversal correctness. - Handle edge cases such as graphs with only one node or nodes with no adjacent nodes.","solution":"from collections import deque def bfs(graph: dict, start_node: int) -> list: Performs a breadth-first search traversal of an unweighted graph. Parameters: graph (dict): The graph represented as an adjacency list where keys are node identifiers and values are lists of adjacent nodes. start_node (int): The starting node for the BFS traversal. Returns: list: A list of nodes in the order they are visited in the BFS traversal. visited = set() # Set to track visited nodes queue = deque([start_node]) # Queue initialized with the start node traversal_order = [] # List to store the order of traversal while queue: current_node = queue.popleft() # Get the next node from the queue if current_node not in visited: # Only proceed if the node hasn\'t been visited visited.add(current_node) # Mark the node as visited traversal_order.append(current_node) # Add node to traversal order # Add all unvisited adjacent nodes to the queue for neighbor in graph[current_node]: if neighbor not in visited: queue.append(neighbor) return traversal_order"},{"question":"# Question: Minimum Cost to Buy Items with Discounts You are in charge of implementing an algorithm to minimize the total cost when buying a list of items, considering that there are special discount offers available. Each discount offer specifies a bundle of items that can be purchased together at a discounted price. Your goal is to determine the minimum total cost required to buy all the items on the list, making optimal use of the discount offers. Function Signature ```python def min_cost_to_buy_items(prices: List[int], offers: List[List[int]], needs: List[int]) -> int: ``` Inputs 1. `prices`: A list of integers where each integer `prices[i]` represents the price of the `i`-th item. 2. `offers`: A list of lists where each sub-list represents a special offer. Each sub-list contains integers where the first `n` integers represent the quantity of each item in the offer, and the last integer represents the price of the bundled offer. 3. `needs`: A list of integers where each integer `needs[i]` represents the required quantity of the `i`-th item. Output - An integer representing the minimum total cost required to buy all the items. Constraints - The number of items `n` will be between 1 and 6. - Each item quantity and prices will be non-negative integers. - There will be at most 100 offers. - The sum of the required item quantities will not exceed 100. # Example ```python prices = [2, 5, 3] offers = [[1, 1, 0, 5], [2, 2, 1, 12]] needs = [3, 2, 1] result = min_cost_to_buy_items(prices, offers, needs) print(result) # Output: 14 ``` In the above example, you need to buy 3 units of the first item, 2 units of the second item, and 1 unit of the third item. You have two offers: - The first offer allows you to buy 1 unit of the first and second items for a total of 5. - The second offer allows you to buy 2 units of the first and second items and 1 unit of the third item for a total of 12. The optimal way is to use the second offer once which meets the needs `[2, 2, 1]` and then buy one more unit of the first item at a price of 2. Thus, the minimal cost will be 12 + 2 = 14.","solution":"from typing import List def min_cost_to_buy_items(prices: List[int], offers: List[List[int]], needs: List[int]) -> int: def total_price(needs): return sum(needs[i] * prices[i] for i in range(len(needs))) def dfs(needs): cost = total_price(needs) for offer in offers: temp_needs = [needs[i] - offer[i] for i in range(len(needs))] if all(x >= 0 for x in temp_needs): cost = min(cost, offer[-1] + dfs(temp_needs)) return cost return dfs(needs)"},{"question":"# Matrix Multiplication and Reduction Your Task: Implement a function that multiplies two matrices, A and B, and then reduces the resulting matrix to a single value using a specified reduction operation. Function Description 1. **matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]** - Multiplies two matrices A and B. The number of columns in A must be equal to the number of rows in B. - Returns the resulting matrix from the multiplication. 2. **matrix_reduce(matrix: List[List[int]], operation: str) -> int** - Reduces the matrix to a single value using the specified reduction operation. - Supported operations: `\'sum\'` (sum of all elements), `\'min\'` (minimum value in the matrix), `\'max\'` (maximum value in the matrix). 3. **matrix_mult_and_reduce(A: List[List[int]], B: List[List[int]], operation: str) -> int** - This high-level function should: 1. Call `matrix_multiply` to get the resulting matrix from A and B. 2. Call `matrix_reduce` on the resulting matrix using the specified operation. - Returns the single value from the reduction. # Constraints * Assume that matrices are non-empty and contain only integers. * Matrices can be up to 1000x1000 in size. * The reduction operation will always be a valid string from the set {\'sum\', \'min\', \'max\'}. # Examples ```python # Sample matrices A = [[1, 2, 3], [4, 5, 6]] B = [[7, 8], [9, 10], [11, 12]] # Expected matrix multiplication result # C = [[58, 64], # [139, 154]] # Example usage print(matrix_mult_and_reduce(A, B, \'sum\')) # Expected output: 415 print(matrix_mult_and_reduce(A, B, \'min\')) # Expected output: 58 print(matrix_mult_and_reduce(A, B, \'max\')) # Expected output: 154 ``` # Implementation ```python from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: num_rows_A, num_cols_A = len(A), len(A[0]) num_rows_B, num_cols_B = len(B), len(B[0]) assert num_cols_A == num_rows_B, \\"Number of columns in A must be equal to number of rows in B\\" C = [[0] * num_cols_B for _ in range(num_rows_A)] for i in range(num_rows_A): for j in range(num_cols_B): for k in range(num_cols_A): # same as num_rows_B C[i][j] += A[i][k] * B[k][j] return C def matrix_reduce(matrix: List[List[int]], operation: str) -> int: flat_matrix = [item for row in matrix for item in row] if operation == \'sum\': return sum(flat_matrix) elif operation == \'min\': return min(flat_matrix) elif operation == \'max\': return max(flat_matrix) else: raise ValueError(\\"Unsupported operation\\") def matrix_mult_and_reduce(A: List[List[int]], B: List[List[int]], operation: str) -> int: result_matrix = matrix_multiply(A, B) return matrix_reduce(result_matrix, operation) ``` Ensure that your function handles matrix multiplication and reduction correctly and efficiently for the given constraints.","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: num_rows_A, num_cols_A = len(A), len(A[0]) num_rows_B, num_cols_B = len(B), len(B[0]) assert num_cols_A == num_rows_B, \\"Number of columns in A must be equal to number of rows in B\\" C = [[0] * num_cols_B for _ in range(num_rows_A)] for i in range(num_rows_A): for j in range(num_cols_B): for k in range(num_cols_A): # same as num_rows_B C[i][j] += A[i][k] * B[k][j] return C def matrix_reduce(matrix: List[List[int]], operation: str) -> int: flat_matrix = [item for row in matrix for item in row] if operation == \'sum\': return sum(flat_matrix) elif operation == \'min\': return min(flat_matrix) elif operation == \'max\': return max(flat_matrix) else: raise ValueError(\\"Unsupported operation\\") def matrix_mult_and_reduce(A: List[List[int]], B: List[List[int]], operation: str) -> int: result_matrix = matrix_multiply(A, B) return matrix_reduce(result_matrix, operation)"},{"question":"# ToDo Task Reminder You have been assigned to automate the creation of reminder emails for upcoming ToDo tasks using the task list from a JSON file. The JSON file contains an array of tasks, each with a title, description, and due date. The goal is to develop two functions that will fetch the tasks from the JSON file and generate reminder emails for tasks that are due within the next three days. Requirements: 1. **Function `load_tasks_from_json`**: - Takes a filename as input. - Reads the tasks from the specified JSON file. - Validates the JSON structure to ensure it contains an array of task objects. - Returns a list of task dictionaries. 2. **Function `generate_reminder_emails`**: - Takes a list of tasks and the current date as input. - Generates reminder emails for tasks that are due within the next three days. - Each reminder email should contain the task title, description, and due date. - Returns a list of reminder emails in the format: ``` Subject: Task Reminder - <task title> Body: <task description> Due Date: <due date> ``` 3. **Constraints**: - The due date in the JSON file is in the format \\"YYYY-MM-DD\\". - The current date should be passed as a string in the format \\"YYYY-MM-DD\\". - Use the `datetime` library for date calculations. - The generated reminder emails should be returned as a list of strings. Input & Output Formats: * The `load_tasks_from_json` function should return a list of tasks. * The `generate_reminder_emails` function should return a list of reminder email strings. Example: Given a JSON file `tasks.json` with the following content: ```json [ { \\"title\\": \\"Buy groceries\\", \\"description\\": \\"Milk, Bread, Eggs, Cheese\\", \\"due_date\\": \\"2023-10-25\\" }, { \\"title\\": \\"Submit report\\", \\"description\\": \\"Annual Financial Report\\", \\"due_date\\": \\"2023-10-28\\" } ] ``` And the current date `\\"2023-10-25\\"`, the script should: 1. Load the tasks from the JSON file. 2. Generate reminder emails for tasks due until `\\"2023-10-28\\"`, inclusive. ```python import json from datetime import datetime, timedelta def load_tasks_from_json(filename: str) -> list: try: with open(filename, \'r\') as file: tasks = json.load(file) if not isinstance(tasks, list): raise ValueError(\\"Invalid JSON format: Expected an array of tasks\\") for task in tasks: if not all(key in task for key in (\\"title\\", \\"description\\", \\"due_date\\")): raise ValueError(\\"Invalid task format: Missing title, description, or due_date\\") return tasks except (IOError, json.JSONDecodeError) as e: print(f\\"An error occurred while reading the JSON file: {e}\\") return [] except ValueError as e: print(e) return [] def generate_reminder_emails(tasks: list, current_date: str) -> list: reminders = [] try: current_date_obj = datetime.strptime(current_date, \\"%Y-%m-%d\\") for task in tasks: due_date_obj = datetime.strptime(task[\'due_date\'], \\"%Y-%m-%d\\") if current_date_obj <= due_date_obj <= current_date_obj + timedelta(days=3): reminders.append( f\\"Subject: Task Reminder - {task[\'title\']}n\\" f\\"Body: {task[\'description\']}n\\" f\\"Due Date: {task[\'due_date\']}n\\" ) except ValueError as e: print(f\\"Invalid date format: {e}\\") return [] return reminders if __name__ == \\"__main__\\": tasks = load_tasks_from_json(\'tasks.json\') current_date = \\"2023-10-25\\" reminder_emails = generate_reminder_emails(tasks, current_date) for email in reminder_emails: print(email) ``` This example ensures that tasks due within the next three days are properly identified and formatted as reminder emails.","solution":"import json from datetime import datetime, timedelta def load_tasks_from_json(filename: str) -> list: Loads tasks from a JSON file. Parameters: filename (str): The path to the JSON file. Returns: list: A list of tasks. try: with open(filename, \'r\') as file: tasks = json.load(file) if not isinstance(tasks, list): raise ValueError(\\"Invalid JSON format: Expected an array of tasks\\") for task in tasks: if not all(key in task for key in (\\"title\\", \\"description\\", \\"due_date\\")): raise ValueError(\\"Invalid task format: Missing title, description, or due_date\\") return tasks except (IOError, json.JSONDecodeError) as e: print(f\\"An error occurred while reading the JSON file: {e}\\") return [] except ValueError as e: print(e) return [] def generate_reminder_emails(tasks: list, current_date: str) -> list: Generates reminder emails for tasks due within the next three days. Parameters: tasks (list): A list of tasks. current_date (str): The current date in the format \\"YYYY-MM-DD\\". Returns: list: A list of reminder email strings. reminders = [] try: current_date_obj = datetime.strptime(current_date, \\"%Y-%m-%d\\") due_within_days = current_date_obj + timedelta(days=3) for task in tasks: due_date_obj = datetime.strptime(task[\'due_date\'], \\"%Y-%m-%d\\") if current_date_obj <= due_date_obj <= due_within_days: reminders.append( f\\"Subject: Task Reminder - {task[\'title\']}n\\" f\\"Body: {task[\'description\']}n\\" f\\"Due Date: {task[\'due_date\']}n\\" ) except ValueError as e: print(f\\"Invalid date format: {e}\\") return [] return reminders"},{"question":"# Problem Statement You are given a matrix that contains only 0s and 1s. A connected component in the matrix is a group of 1s that are adjacent in either the horizontal or vertical direction. Implement a function `largest_component_size` to find and return the size of the largest connected component in the matrix. # Function Signature ```python def largest_component_size(matrix: List[List[int]]) -> int: ``` # Input - `matrix`: A list of lists of integers representing the binary matrix. # Output - Returns an integer representing the size of the largest connected component of 1s. # Constraints - The dimensions of the matrix are in the range `[1, 100] x [1, 100]`. - Each element in the matrix is either 0 or 1. # Example ```python matrix1 = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0], [1, 1, 1, 0, 0] ] # Largest component of 1s: # Size = 4 print(largest_component_size(matrix1)) # Output: 4 matrix2 = [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ] # Largest component of 1s: # Size = 1 (any single 1 as they are all isolated) print(largest_component_size(matrix2)) # Output: 1 ``` # Detailed Description 1. **Algorithm to Find Largest Component Size** - Use Depth-First Search (DFS) or Breadth-First Search (BFS) to explore each component. - Maintain a visited matrix to keep track of the cells that have already been visited. - For every unvisited cell that contains a 1, initiate a search (DFS/BFS) to find the size of the connected component. - Update the maximum component size accordingly. 2. **Steps to Implement** - Implement a helper function that performs DFS or BFS to compute the size of a connected component. - Iterate through every cell in the matrix, and for each unvisited cell containing a 1, use the helper function to compute the size of the component starting from that cell. - Keep track of the maximum component size found during the process. # Code Template ```python from typing import List def largest_component_size(matrix: List[List[int]]) -> int: def dfs(x, y): if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size if not matrix or not matrix[0]: return 0 visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))] max_size = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size ``` Validate your implementation with the provided examples and ensure it correctly handles edge cases like matrices with no 1s, matrices where all 1s are isolated, and large matrices.","solution":"from typing import List def largest_component_size(matrix: List[List[int]]) -> int: def dfs(x, y): if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]) or matrix[x][y] == 0 or visited[x][y]: return 0 visited[x][y] = True size = 1 size += dfs(x+1, y) size += dfs(x-1, y) size += dfs(x, y+1) size += dfs(x, y-1) return size if not matrix or not matrix[0]: return 0 visited = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))] max_size = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 1 and not visited[i][j]: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"# Problem: Implement a Tic-Tac-Toe Game Background Tic-Tac-Toe is a classic paper-and-pencil game for two players (X and O) who take turns marking the spaces in a 3×3 grid. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game. You are required to create a Tic-Tac-Toe game where two players can play against each other in the console. Task Implement a `TicTacToe` class in Python that allows two players to play a game of Tic-Tac-Toe. Input - Players will input their moves as coordinates in the format (row, column), where row and column are integers between 0 and 2 inclusive. - The class should also provide a method to get the current state of the board. Output - The game should output messages indicating: - Invalid moves (e.g., out-of-bounds coordinates or occupied spaces). - The player\'s turn. - The winner of the game or if the game is a draw. Constraints 1. Coordinates provided must be within the range of 0 to 2 (inclusive). 2. Players can only place marks on empty spaces. 3. The game ends when a player wins or if there\'s a draw (when all spaces are filled without a winner). Example ```python class TicTacToe: def __init__(self): self.board = [[\' \' for _ in range(3)] for _ in range(3)] self.current_player = \'X\' self.winner = None self.moves_made = 0 def print_board(self): for row in self.board: print(\'|\'.join(row)) print(\'-\' * 5) def is_winner(self): winning_combinations = [ [(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)], [(0, 0), (1, 0), (2, 0)], [(0, 1), (1, 1), (2, 1)], [(0, 2), (1, 2), (2, 2)], [(0, 0), (1, 1), (2, 2)], [(0, 2), (1, 1), (2, 0)], ] for combo in winning_combinations: if self.board[combo[0][0]][combo[0][1]] == self.board[combo[1][0]][combo[1][1]] == self.board[combo[2][0]][combo[2][1]] != \' \': self.winner = self.board[combo[0][0]][combo[0][1]] return True return False def make_move(self, row, column): if row < 0 or row >= 3 or column < 0 or column >= 3 or self.board[row][column] != \' \': return False self.board[row][column] = self.current_player self.moves_made += 1 if self.is_winner(): print(f\\"Player {self.current_player} wins!\\") self.print_board() elif self.moves_made == 9: print(\\"The game is a draw!\\") self.print_board() else: self.current_player = \'O\' if self.current_player == \'X\' else \'X\' return True return False if __name__ == \\"__main__\\": game = TicTacToe() game.print_board() while not game.winner and game.moves_made < 9: try: row, col = map(int, input(f\\"Player {game.current_player}, enter your move (row and column): \\").split()) if not game.make_move(row, col): print(\\"Invalid move, try again.\\") except ValueError: print(\\"Invalid input, please enter row and column as two integers.\\") ```","solution":"class TicTacToe: def __init__(self): self.board = [[\' \' for _ in range(3)] for _ in range(3)] self.current_player = \'X\' self.winner = None self.moves_made = 0 def print_board(self): for row in self.board: print(\'|\'.join(row)) print(\'-\' * 5) def is_winner(self): winning_combinations = [ [(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)], [(0, 0), (1, 0), (2, 0)], [(0, 1), (1, 1), (2, 1)], [(0, 2), (1, 2), (2, 2)], [(0, 0), (1, 1), (2, 2)], [(0, 2), (1, 1), (2, 0)], ] for combo in winning_combinations: if self.board[combo[0][0]][combo[0][1]] == self.board[combo[1][0]][combo[1][1]] == self.board[combo[2][0]][combo[2][1]] != \' \': self.winner = self.board[combo[0][0]][combo[0][1]] return True return False def make_move(self, row, column): if row < 0 or row >= 3 or column < 0 or column >= 3 or self.board[row][column] != \' \': return False self.board[row][column] = self.current_player self.moves_made += 1 if self.is_winner(): print(f\\"Player {self.current_player} wins!\\") self.print_board() elif self.moves_made == 9: print(\\"The game is a draw!\\") self.print_board() else: self.current_player = \'O\' if self.current_player == \'X\' else \'X\' return True return False def get_board(self): return self.board def get_current_player(self): return self.current_player def get_winner(self): return self.winner"},{"question":"**Context**: As a software developer, you have been tasked with writing a component that helps keep track of inventory in a warehouse. The warehouse stores different types of products, and each product has a unique ID, a name, a quantity, and a price per unit. The system needs to perform various operations such as adding new products, updating the quantity of existing products, and calculating the total value of the inventory. **Task**: Implement a class named `Inventory` that keeps track of products and their quantities. The class should support adding new products, updating quantities, and calculating the total value based on the current inventory. # Requirements: * Implement a class named `Inventory` in Python. * The class should have the following methods: - `add_product(product_id: int, name: str, quantity: int, price_per_unit: float) -> None`: Adds a new product with the given details to the inventory. If the product already exists, it updates its details. - `update_quantity(product_id: int, quantity: int) -> None`: Updates the quantity of the specified product. If the product does not exist, it raises a `ValueError` with the message \\"Product not found\\". - `total_inventory_value() -> float`: Calculates and returns the total value of the inventory as the sum of the product of quantity and price per unit for all products. # Additional Constraints: * The product `quantity` will always be a non-negative integer. * The `price_per_unit` will always be a non-negative float. * The product `name` is a non-empty string. # Class Signature: ```python class Inventory: def add_product(self, product_id: int, name: str, quantity: int, price_per_unit: float) -> None: pass def update_quantity(self, product_id: int, quantity: int) -> None: pass def total_inventory_value(self) -> float: pass ``` # Example: ```python warehouse = Inventory() warehouse.add_product(1, \\"Widget\\", 100, 2.5) warehouse.add_product(2, \\"Gadget\\", 200, 3.5) assert warehouse.total_inventory_value() == 100 * 2.5 + 200 * 3.5 # 900.0 warehouse.update_quantity(1, 150) assert warehouse.total_inventory_value() == 150 * 2.5 + 200 * 3.5 # 1025.0 try: warehouse.update_quantity(3, 50) except ValueError as e: assert str(e) == \\"Product not found\\" ``` # Hint: Use a dictionary to store product details, where the key is the product ID.","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: int, name: str, quantity: int, price_per_unit: float) -> None: self.products[product_id] = { \'name\': name, \'quantity\': quantity, \'price_per_unit\': price_per_unit } def update_quantity(self, product_id: int, quantity: int) -> None: if product_id in self.products: self.products[product_id][\'quantity\'] = quantity else: raise ValueError(\\"Product not found\\") def total_inventory_value(self) -> float: return sum(product[\'quantity\'] * product[\'price_per_unit\'] for product in self.products.values())"},{"question":"# Question Radix Sort Implementation Challenge You are required to implement the Radix Sort algorithm. Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. A stable sub-sort, such as Counting Sort, is used internally. The algorithm is often implemented to handle positive integers, and this challenge will focus on that version. Function Signature ```python def radix_sort(collection: list[int]) -> list[int]: ``` Input * `collection`: A list of positive integers which need to be sorted. (1 ≤ len(collection) ≤ 10^5, 0 ≤ element ≤ 10^9) Output * Returns a sorted list of integers in ascending order, adhering to the same input constraints. Performance Requirements * The solution should aim for an average case time complexity of O(nk), where n is the number of items and k is the number of digits in the largest number (which in this case, a maximum of 9 digits). * Space complexity should be O(n) due to the use of stable sorting in each digit position. Description and Steps 1. Find the maximum number to determine the number of digits. 2. For each digit, sort the array using Counting Sort or another stable sort mechanism. 3. Repeat the sorting process for each digit, starting from the least significant digit to the most significant. 4. Return the sorted list. # Example ```python print(radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(radix_sort([123, 1, 45, 72, 8, 12])) # Output: [1, 8, 12, 45, 72, 123] print(radix_sort([])) # Output: [] ``` Considerations * Ensure the solution handles edge cases such as empty lists or lists with a single element. * Handle lists with numbers of varying digit lengths efficiently. * Use stable sorting to maintain relative order when sorting by individual digits. This additional question aligns with the style, complexity, and scope of the given sample by focusing on implementing a specific sorting algorithm, handling a range of inputs, and meeting performance requirements.","solution":"def radix_sort(collection: list[int]) -> list[int]: Performs Radix Sort on a list of integers. Parameters: collection (list[int]): A list of positive integers to be sorted. Returns: list[int]: Sorted list of integers. if len(collection) == 0: return collection # Function to perform Counting Sort on the basis of digit represented by exp. def counting_sort(arr, exp): n = len(arr) output = [0] * n # Output array initialized to 0. count = [0] * 10 # Count array to store count of occurrences of digits 0-9. for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] max_val = max(collection) exp = 1 # Initial exponent (1, 10, 100, ...) while max_val // exp > 0: counting_sort(collection, exp) exp *= 10 return collection"},{"question":"# Graph Coloring Problem Context You are developing a software to assist in scheduling exams at a university. The challenge is to assign time slots to exams in such a way that no student has two exams at the same time. Each student can be taking multiple courses, and hence their courses should not have overlapping exam times. This scenario can be modeled as a graph coloring problem where each node represents an exam and an edge between two nodes indicates that there is at least one student enrolled in both courses. Task Implement a graph coloring algorithm to assign the minimum number of time slots (colors) required to schedule all exams. Your task is to: 1. Read the input graph data representing the conflict between exams. 2. Apply a graph coloring algorithm to assign time slots. 3. Ensure no two adjacent nodes (exams with common students) share the same color (time slot). Function Signature ```python def graph_coloring(exam_graph: Dict[int, List[int]]) -> Dict[int, int]: # your implementation here pass ``` Input * **exam_graph**: A dictionary where the keys are integers representing exam IDs, and the values are lists of integers representing conflicted exam IDs. For example, `exam_graph[3] = [2, 4]` means exam 3 has conflicts with exams 2 and 4. Output * Returns a dictionary where keys are exam IDs and values are integers representing the assigned time slots (colors). Time slots are represented as contiguous integers starting from 0. Constraints * Assume the input graph is valid and always has a solution. * Try to minimize the number of used time slots. * If multiple valid colorings exist, any one is acceptable. **Notes**: * Be mindful of edge cases where multiple courses share students. * Explore different algorithms like Greedy coloring or DSATUR and choose the most efficient one for this problem. Example ```python # Example function call exam_graph = { 0: [1, 2], 1: [0, 2, 3], 2: [0, 1], 3: [1] } coloring = graph_coloring(exam_graph) print(\\"Coloring:\\", coloring) # Expected output here could be: # Coloring: {0: 0, 1: 1, 2: 2, 3: 0} ```","solution":"def graph_coloring(exam_graph): Returns a dictionary where each key is an exam id and the value is the assigned time slot (color). def get_available_color(used_colors): Returns the smallest non-negative integer not in the used_colors set. color = 0 while color in used_colors: color += 1 return color coloring = {} for node in exam_graph: used_colors = set() for neighbor in exam_graph[node]: if neighbor in coloring: used_colors.add(coloring[neighbor]) coloring[node] = get_available_color(used_colors) return coloring"},{"question":"# Problem Statement You are working on a text-processing tool that converts formatted text into a simplified HTML structure. Your task is to implement a function that converts a given text into an HTML code snippet with proper tagging for paragraphs and headers. # Requirements You are to implement the function `text_to_html` which processes blocks of text and returns a simplified HTML representation. The text can contain headers marked with `#` (for `<h1>`), `` (for `<h2>`), and paragraphs of plain text. # Input and Output 1. **Input** - `text_to_html(text: str) -> str` - `text`: a string containing plain text, headers, and paragraphs. 2. **Output** - Return a string representing the HTML formatted version of the input text where: - Single `#` at the beginning of a line denotes an `<h1>` header. - Double `` at the beginning of a line denotes an `<h2>` header. - Plain text lines are enclosed in `<p>` tags. # Example ```python text = # This is a Header This is a paragraph. This is a Subheader This is another paragraph. text_to_html(text) # Output: \\"<h1>This is a Header</h1><p>This is a paragraph.</p><h2>This is a Subheader</h2><p>This is another paragraph.</p>\\" ``` # Notes - The input text may contain multiple headers and paragraphs. - Consecutive lines of text are separated into individual paragraphs. - Ensure that the output string maintains the order and structure as specified. # Implementation Implement the function `text_to_html` to achieve the described transformation. Here is a possible prototype: ```python def text_to_html(text: str) -> str: # Define a list to hold the HTML lines html_lines = [] # Split the text into lines lines = text.split(\'n\') # Process each line for line in lines: stripped_line = line.strip() if stripped_line.startswith(\'# \'): html_lines.append(f\\"<h1>{stripped_line[2:]}</h1>\\") elif stripped_line.startswith(\' \'): html_lines.append(f\\"<h2>{stripped_line[3:]}</h2>\\") elif stripped_line: html_lines.append(f\\"<p>{stripped_line}</p>\\") # Join the HTML lines into a single string return \'\'.join(html_lines) ```","solution":"def text_to_html(text: str) -> str: Converts a given text into a simplified HTML structure. Headers marked with \'#\' (for <h1>), \'\' (for <h2>), and plain text into <p>. # Define a list to hold the HTML lines html_lines = [] # Split the text into lines lines = text.split(\'n\') # Process each line for line in lines: stripped_line = line.strip() if stripped_line.startswith(\'# \'): html_lines.append(f\\"<h1>{stripped_line[2:]}</h1>\\") elif stripped_line.startswith(\' \'): html_lines.append(f\\"<h2>{stripped_line[3:]}</h2>\\") elif stripped_line: html_lines.append(f\\"<p>{stripped_line}</p>\\") # Join the HTML lines into a single string return \'\'.join(html_lines)"},{"question":"# Scenario Bob is working on a project that involves finding palindrome substrings within larger strings. He needs a function that identifies the longest palindromic substring in a given string. A palindrome is a sequence of characters that reads the same forward and backward. # Coding Task Write a function `longest_palindromic_substring(s: str) -> str` that finds and returns the longest palindrome substring in the given string `s`. # Input and Output Format - **Input**: - `s` (a non-empty string consisting of alphanumeric characters, length 1 ≤ len(s) ≤ 1000) - **Output**: - A string representing the longest palindromic substring in `s`. If there are multiple palindromic substrings of the same maximum length, return the one which appears first in the string. # Constraints and Assumptions: - The given string `s` will contain only alphabetic characters (\'a\'-\'z\', \'A\'-\'Z\') and numbers (\'0\'-\'9\'). - The function should have O(n^2) time complexity or better to efficiently handle the maximum length of the string. # Example - Example 1: - `s = \\"babad\\"` - Output: `\\"bab\\"` (Another valid output could be `\\"aba\\"` as both are palindromes of the same length) - Example 2: - `s = \\"cbbd\\"` - Output: `\\"bb\\"` (The longest palindrome substring is \\"bb\\") - Example 3: - `s = \\"a\\"` - Output: `\\"a\\"` (A single character is a palindrome itself) **Note**: Edge cases like single character strings, strings with no distinct palindromic substrings longer than 1 character, and strings with multiple palindromes of the same length should be tested.","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string `s`. n = len(s) if n <= 1: return s start, max_length = 0, 1 for i in range(1, n): # Check for even length palindrome low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindrome low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"Sparse Matrix Multiplication Optimization The provided algorithm multiplies two sparse matrices represented in a coordinate list (COO) format. Your task is to enhance this algorithm to handle larger dimensions and sparse densities efficiently, specifically for dimensions up to 1000x1000 with sparsity up to 0.1% density. # Problem Statement Optimize the sparse matrix multiplication algorithm to handle large matrices efficiently, focusing on time and space complexity improvements using appropriate data structures and algorithms. # Requirements Write a function `sparse_matrix_multiplication(A: List[Tuple[int, int, int]], B: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]` that accepts two sparse matrices in COO format and returns their product, also in COO format. # Input * `A` and `B`: Two lists of tuples representing the non-zero entries of the sparse matrices. - Each tuple in `A` and `B` is of the form `(row, col, value)` where `row` and `col` are the row and column indices (0-indexed) and `value` is the non-zero integer value. - Both matrices will have dimensions up to 1000x1000. - Both matrices will have non-zero densities up to 0.1%. # Output * A list of tuples representing the non-zero entries of the product matrix in COO format. - Each tuple should be of the form `(row, col, value)`. # Constraints * The dimensions of `A` and `B` will be up to 1000x1000. * The number of non-zero entries in `A` and `B` will not exceed 1000 (0.1% density). # Optimization Requirements * Aim for an efficient memory usage and faster computation leveraging sparse matrix properties. * Consider optimizing the storage and traversal methods within the multiplication process to minimize operations and space usage. # Scenario/Context Multiplying sparse matrices is common in various computational fields such as scientific computing, computer graphics, and machine learning. Efficient handling of sparse matrices, especially large ones, is crucial for high-performance applications. # Example ```python A = [ (0, 0, 1), (1, 2, 2), (2, 3, 3) ] B = [ (0, 1, 4), (2, 0, 5), (3, 3, 6) ] result = sparse_matrix_multiplication(A, B) print(result) # Expected output: [(0, 1, 4), (1, 0, 10), (2, 3, 18)] ``` Your implementation should efficiently handle the sparse nature of the matrices and provide accurate results, leveraging effective data structures and algorithms tailored for sparse matrix operations.","solution":"from collections import defaultdict from typing import List, Tuple def sparse_matrix_multiplication(A: List[Tuple[int, int, int]], B: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: # Step 1: Convert B to a dictionary format for faster lookup B_dict = defaultdict(list) for row, col, value in B: B_dict[row].append((col, value)) # Step 2: Initialize a default dictionary to store the product results result_dict = defaultdict(int) # Step 3: Multiply sparse matrices for row_a, col_a, val_a in A: if col_a in B_dict: for col_b, val_b in B_dict[col_a]: result_dict[(row_a, col_b)] += val_a * val_b # Step 4: Convert the result dictionary to a list of tuples in COO format result = [(row, col, val) for (row, col), val in result_dict.items() if val != 0] return result"},{"question":"# Coding Assessment Question Scenario You are developing a robo-advisor application designed to help users optimize their investment portfolios. One of the features is to calculate the maximum possible profit that can be achieved from a list of daily stock prices by buying and selling the stock at most twice (i.e., at most two transactions). Task Write a function named `max_profit_two_transactions` that takes a list of integers as an argument. Each integer in the list represents the daily stock prices in chronological order. The function should return an integer representing the maximum possible profit that can be achieved with at most two transactions. Input * `prices`: A list of integers representing daily stock prices (( 0 leq text{prices}[i] leq 10^5 )). Output * An integer representing the maximum profit that can be made with at most two buy-and-sell transactions. Constraints * You may assume the length of `prices` is at least 2 and at most ( 10^5 ). Function Signature ```python def max_profit_two_transactions(prices: list[int]) -> int: ``` # Example ```python assert max_profit_two_transactions([3,3,5,0,0,3,1,4]) == 6 assert max_profit_two_transactions([1,2,3,4,5]) == 4 assert max_profit_two_transactions([7,6,4,3,1]) == 0 ``` Explanation - In the first example, the maximum profit is achieved by buying on day 3 (price = 0) and selling on day 6 (price = 3), then buying on day 7 (price = 1) and selling on day 8 (price = 4), resulting in a profit of ( 3 - 0 + 4 - 1 = 6 ). - In the second example, the best strategy is to buy on day 1 (price = 1) and sell on day 5 (price = 5), making a profit of ( 4 ). - In the third example, as prices are continually decreasing, no profit can be made, so the maximum profit is 0. Notes - Ensure that the solution handles edge cases effectively, such as when prices list contains all identical values. - Consider the performance of the algorithm, aiming for optimized solutions that can handle the upper bound of input size efficiently.","solution":"def max_profit_two_transactions(prices): if not prices: return 0 n = len(prices) # Initialize profit array profit = [0] * n # First Pass (Left to Right) - Compute maximum profit with one transaction min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit[i] = max(profit[i - 1], prices[i] - min_price) # Second Pass (Right to Left) - Compute maximum profit with second transaction max_price = prices[n - 1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit[i] = max(profit[i + 1], max_price - prices[i] + profit[i]) # The answer is the max value in profit array return profit[0] # profit[0] will be the maximum profit with at most two transactions"},{"question":"Write a function `is_palindrome_permutation(s: str) -> bool` that checks if any permutation of the input string \'s\' can form a palindrome. A string is a palindrome if it reads the same forwards and backwards. The permutation can ignore spaces and is case-insensitive. # Example ```python print(is_palindrome_permutation(\\"Tact Coa\\")) # Output: True (\\"Tact Coa\\" is a permutation of \\"taco cat\\", which is a palindrome) print(is_palindrome_permutation(\\"Hello\\")) # Output: False print(is_palindrome_permutation(\\"A man a plan a canal Panama\\")) # Output: True (\\"A man a plan a canal Panama\\" is a permutation that can form the palindrome \\"A man a plan a canal Panama\\") ``` # Constraints 1. The input string will only contain letters and spaces. 2. The function should be case-insensitive. 3. The function should have a time complexity of O(n), where n is the length of the input string. # Task Implement the `is_palindrome_permutation` function. Implementation Details: - You may use a dictionary or any other data structure to count the frequency of characters. - To form a palindrome, each character (except at most one character for odd-length strings) must appear an even number of times. - Ignore whitespaces and consider the string as case-insensitive. # Solution ```python def is_palindrome_permutation(s: str) -> bool: from collections import Counter # Normalize the string: Remove spaces and convert to lower case normalized_s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(normalized_s) # Check the palindrome condition: At most one character with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 ```","solution":"def is_palindrome_permutation(s: str) -> bool: from collections import Counter # Normalize the string: Remove spaces and convert to lower case normalized_s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(normalized_s) # Check the palindrome condition: At most one character with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Coding Assessment Question Problem Description: Implement a function that takes a list of integers and returns the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to 1. The function should efficiently handle sequences of up to 10^5 elements. You should implement the following function: ```python def longest_subarray(arr: list[int]) -> int: ``` Expected Input and Output: * **Input**: A list of integers `arr`. * Constraints: 1 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6. * **Output**: An integer representing the length of the longest valid contiguous subarray. Context: Finding the longest subarray with the described properties is important in various real-life scenarios such as analyzing sequences of measurements, stock prices, or any situation where stable periods need to be identified. Example ```python assert longest_subarray([1, 3, 3, 2, 1, 2, 5]) == 5 assert longest_subarray([4, 4, 4, 4]) == 4 assert longest_subarray([10, 11, 12, 14, 15, 18, 18, 17, 16]) == 4 assert longest_subarray([1, 2, 2, 2, 3, 4]) == 6 ``` **Note**: Efficiently handling large sequences is crucial. Focus on achieving a time complexity of O(n) and space complexity of O(1). Constraints: - Ensure your solution efficiently processes the input list regardless of its size. - Handle edge cases like extremely small or large values within the specified range effectively.","solution":"def longest_subarray(arr: list[int]) -> int: if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 return max(max_len, current_len)"},{"question":"# Coding Challenge: Maximum Sum of Non-Adjacent Elements **Objective**: Write a function to find the maximum sum of non-adjacent elements in a list of positive integers. **Function Signature**: ```python def max_non_adjacent_sum(nums: List[int]) -> int: ``` **Input**: * **nums** (*list of integers*): A list of positive integers. (1 <= len(nums) <= 10^6, 1 <= nums[i] <= 10^9) **Output**: * **result** (*integer*): The maximum sum of non-adjacent elements in the list. **Constraints**: * The function must handle large input sizes efficiently. * Consider edge cases where the list might contain very few elements. * Use techniques that minimize the time complexity, and can handle the upper limits of input size within reasonable execution time. **Scenario**: Given a list of integers, you need to calculate the maximum sum that can be obtained by summing elements that are not next to each other. This problem can be approached using dynamic programming to ensure computational efficiency. **Example**: ```python # Example 1 print(max_non_adjacent_sum([3, 2, 5, 10, 7])) # Output: 15 (Sum of elements: 3, 10, or 3, 5, 7) # Example 2 print(max_non_adjacent_sum([5, 5, 10, 100, 10, 5])) # Output: 110 (Sum of elements: 5, 100, 5) ``` **Explanation**: 1. For the input list [3, 2, 5, 10, 7], the maximum sum without adjacent elements is 15, which can be obtained by summing 3, 10 or 3, 5, 7. 2. For the input list [5, 5, 10, 100, 10, 5], the maximum sum without adjacent elements is 110, which is obtained by summing 5, 100, 5. Develop the function `max_non_adjacent_sum` and ensure it passes these example tests.","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize two variables to store the max sum including and excluding the previous element include = nums[0] exclude = 0 for num in nums[1:]: # Current max excluding i (No two adjacent elements) new_exclude = max(include, exclude) # Current max including i include = exclude + num exclude = new_exclude # Return max of include and exclude return max(include, exclude)"},{"question":"# Implementation Question: Advanced List Processing for Summation of Distinct Even Numbers **Problem Statement**: You are given a list of integers. Write a function named `sum_distinct_even_numbers` that sums up the distinct even numbers from the list. The function should ensure that duplicates are only counted once and odd numbers are excluded from the summation. **Function Signature**: ```python def sum_distinct_even_numbers(numbers: list[int]) -> int: Sums the distinct even numbers from the given list of integers. Parameters: numbers (list of int): A list of integers which may contain duplicates and odd numbers. Returns: int: The sum of distinct even numbers. Raises: TypeError: When the input is not a list of integers. pass ``` **Input/Output Examples**: ```python >>> sum_distinct_even_numbers([1, 2, 3, 4, 4, 5, 6, 6]) 12 # (2 + 4 + 6) >>> sum_distinct_even_numbers([7, 8, 9, 8, 10, 13, 16]) 34 # (8 + 10 + 16) >>> sum_distinct_even_numbers([2, 2, 2, 2]) 2 # (2) >>> sum_distinct_even_numbers([]) 0 # No numbers to sum >>> sum_distinct_even_numbers([1, 3, 5, 7, 9]) 0 # No even numbers in the list >>> sum_distinct_even_numbers([\\"a\\", 2, \\"b\\", 4]) Traceback (most recent call last): ... TypeError: The list should contain only integers. ``` **Constraints**: * The input must be a list of integers. * Each integer will be in the range [-10^6, 10^6]. * The length of the list will be between 0 and 10^5 elements. # Hints: 1. Use a set to hold the distinct even numbers for efficient membership checking and summation. 2. Validate the input to ensure it is a list of integers before performing the summation. This new question tests the candidate\'s ability to work with lists, sets, and the validation of input data types, matching the complexity and scope of the provided example problem.","solution":"def sum_distinct_even_numbers(numbers: list[int]) -> int: Sums the distinct even numbers from the given list of integers. Parameters: numbers (list of int): A list of integers which may contain duplicates and odd numbers. Returns: int: The sum of distinct even numbers. Raises: TypeError: When the input is not a list of integers. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"The list should contain only integers.\\") return sum(set(num for num in numbers if num % 2 == 0))"},{"question":"# Problem Statement You are given a weighted undirected graph represented by an adjacency matrix. Your task is to implement the function `prims_algorithm(matrix: List[List[int]]) -> List[Tuple[int, int, int]]`, which takes an adjacency matrix `matrix` and returns a list of edges in the Minimum Spanning Tree (MST) using Prim\'s Algorithm. # Input * `matrix`: A list of lists, where `matrix[i][j]` is a positive integer representing the weight of the edge between vertex `i` and vertex `j`. If there is no edge between `i` and `j`, the weight will be zero. # Output * A list of tuples representing the edges in the MST in the form `(u, v, weight)`, where `u` and `v` are the vertices and `weight` is the weight of the edge. # Constraints 1. The graph does not contain any self-loops or negative weights. 2. The graph is connected. 3. The number of vertices in the graph will not exceed 100. # Requirements * Implement Prim\'s Algorithm to find the MST. * Optimize for small to medium-sized graphs. * Ensure the function handles graphs with varying weights gracefully. # Example ```python from typing import List, Tuple def prims_algorithm(matrix: List[List[int]]) -> List[Tuple[int, int, int]]: pass # Your implementation goes here # Example usage adj_matrix = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0] ] mst_edges = prims_algorithm(adj_matrix) print(mst_edges) # Output may vary, but one correct MST could be: # [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] ```","solution":"from typing import List, Tuple def prims_algorithm(matrix: List[List[int]]) -> List[Tuple[int, int, int]]: num_vertices = len(matrix) in_mst = [False] * num_vertices edge_weights = [float(\'inf\')] * num_vertices parent = [-1] * num_vertices edge_weights[0] = 0 for _ in range(num_vertices): min_weight = float(\'inf\') u = -1 for v in range(num_vertices): if not in_mst[v] and edge_weights[v] < min_weight: min_weight = edge_weights[v] u = v in_mst[u] = True for v in range(num_vertices): if matrix[u][v] > 0 and not in_mst[v] and matrix[u][v] < edge_weights[v]: edge_weights[v] = matrix[u][v] parent[v] = u mst_edges = [] for i in range(1, num_vertices): if parent[i] != -1: mst_edges.append((parent[i], i, matrix[i][parent[i]])) return mst_edges"},{"question":"# Question: Implement String Pattern Matching with Wildcards Design a function that checks if a given string matches a specified pattern, which may include wildcard characters. The pattern includes: - `?` which matches any single character. - `*` which matches any sequence of characters (including the empty sequence). Implement an algorithm that determines whether the entire string matches the given pattern. Requirements: 1. **Function Signature**: ```python def is_match(s: str, p: str) -> bool: ``` 2. **Inputs**: - `s`: A string that you need to check for matching (0 <= len(s) <= 1000). - `p`: A pattern string that may include wildcard characters (0 <= len(p) <= 1000). 3. **Output**: - Return `True` if the entire string matches the given pattern, `False` otherwise. 4. **Approach**: - Use dynamic programming to build a 2D table where `dp[i][j]` will be `True` if the first `i` characters in the string `s` match the first `j` characters of the pattern `p`. - Implement the handling for `?` to match a single character and `*` to match zero or more characters. - Optimize for time and space complexity. Example: ```python assert is_match(\\"adceb\\", \\"*a*b\\") == True assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"cb\\", \\"?a\\") == False assert is_match(\\"acdcb\\", \\"a*c?b\\") == False assert is_match(\\"badge\\", \\"ba?ge\\") == True ``` Constraints: - Do not use any built-in regular expression libraries. ```python # Example Usage print(is_match(\\"adceb\\", \\"*a*b\\")) # Output: True print(is_match(\\"acdcb\\", \\"a*c?b\\")) # Output: False ``` Steps: 1. Initialize a 2D list `dp` where `dp[i][j]` is `True` if the substring `s[:i]` matches the pattern `p[:j]`. 2. Handle the base case where both the string and the pattern are empty. 3. Iterate through the string and pattern, updating the `dp` table based on the current characters and wildcard rules. 4. Finally, return the value at `dp[len(s)][len(p)]` which represents whether the entire string matches the entire pattern. Here is the skeleton code to get you started: ```python def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n] ``` # Explanation: - The `dp` table keeps track of whether substrings match up to current indices. - Handle matching characters and wildcards `?` (single character) and `*` (zero or more characters) appropriately. - Iterate through all characters of the string and pattern to build up the solution. Ensure you test your function thoroughly with edge cases and large inputs to validate performance.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == \'?\' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"# Scenario You are given an array of integers and your task is to remove duplicates from this array so that each element appears only once. Additionally, you should maintain the relative order of occurrences of the elements. # Function Signature ```python def remove_duplicates(arr: list) -> list: pass ``` # Input * `arr`: A list of integers. # Output * `remove_duplicates` should return a list of integers, where all duplicates have been removed and the relative order of the elements is preserved. # Constraints * The elements in the array are integers. # Performance Requirements * Aim for a solution that has time complexity of O(n) and space complexity of O(n). # Notes 1. Use a set to track the elements that have already been seen. 2. Preserve the relative order of elements as they appeared in the original list. # Example ```python arr = [4, 5, 6, 5, 4, 3] # Expected Output: [4, 5, 6, 3] print(remove_duplicates(arr)) # Output: [4, 5, 6, 3] ``` # Edge Cases 1. If `arr` is empty, the expected output is an empty list. 2. If `arr` contains only one integer, the expected output is the same single element in a list. 3. Test the function with large lists to ensure performance meets the requirements. Implement the `remove_duplicates` function and ensure that your solution passes the provided test cases.","solution":"def remove_duplicates(arr: list) -> list: Removes duplicates from the given list while preserving the relative order of elements. Args: arr (list): A list of integers. Returns: list: A list with duplicates removed and relative order preserved. seen = set() result = [] for num in arr: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Problem Statement Given a sorted array, you are required to find the index of the pivot element around which the array has been rotated. The pivot element is the largest element in the original array, and the next element to it is the smallest element in the array. Implement an efficient algorithm to find the index of this pivot element. # Function: `find_pivot(arr: List[int]) -> int` * **Input Parameters**: - `arr` (List[int]): A sorted array that has been rotated. The array will contain at least two elements. * **Output**: - Returns an integer representing the index of the pivot element. * **Constraints**: - 2 <= len(arr) <= 10^6 - All elements in `arr` are distinct. # Requirements: 1. Implement `find_pivot(arr: List[int]) -> int`. 2. Ensure efficient computation with the time complexity of O(log n). # Examples: Example 1 ```python >>> find_pivot([4, 5, 6, 7, 0, 1, 2]) 3 ``` Example 2 ```python >>> find_pivot([10, 11, 12, 1, 2, 3]) 2 ``` Example 3 ```python >>> find_pivot([15, 16, 1, 2, 3, 4, 5, 6]) 1 ``` Example 4 ```python >>> find_pivot([3, 4, 5, 1, 2]) 2 ``` # Explanation: 1. `find_pivot([4, 5, 6, 7, 0, 1, 2])` returns 3 because index 3 has the value 7, which is the largest element before rotation. 2. `find_pivot([10, 11, 12, 1, 2, 3])` returns 2 because index 2 has the value 12, which is the pivot element and the largest before rotation. 3. `find_pivot([15, 16, 1, 2, 3, 4, 5, 6])` returns 1 because index 1 has the value 16, which is the largest in the original sorted array. 4. `find_pivot([3, 4, 5, 1, 2])` returns 2 because index 2 has the value 5, which is the largest element before the rotation.","solution":"def find_pivot(arr): This function takes a rotated sorted array and returns the index of the pivot element. The pivot element is the largest element in the original array. low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 # Check if mid is pivot if mid < high and arr[mid] > arr[mid + 1]: return mid # Check if mid-1 is pivot if mid > low and arr[mid] < arr[mid - 1]: return mid - 1 # Decide the side to search if arr[low] >= arr[mid]: high = mid - 1 else: low = mid + 1 return -1 # pivot not found in the array, this should not be reached for valid input constraints"},{"question":"# Inventory Management System You are tasked with enhancing an inventory management system used to track items in a warehouse. This system should support additional functionalities for item retrieval based on specific criteria. Requirements: 1. **Fetch Items By Location**: Implement a function `fetch_by_location(location: str) -> List[str]` that returns a list of item names stored at the given location. 2. **Fetch Items By Category**: Implement a function `fetch_by_category(category: str) -> List[str]` that returns a list of item names belonging to the given category. 3. **Invalid Criteria**: If an invalid location or category is provided, raise a `ValueError` with a descriptive error message. # Input Specifications: 1. `fetch_by_location(location: str) -> List[str]`: This function retrieves item names stored at the given location. 2. `fetch_by_category(category: str) -> List[str]`: This function retrieves item names belonging to the given category. # Output Specifications: 1. Functions should return lists of item names as per the given criterion. 2. If a location or category is invalid, a `ValueError` should be raised. # Constraints: 1. The locations and categories provided must be valid; otherwise, a `ValueError` should be raised. 2. Ensure the system maintains an internal data structure to store item details such as name, category, and location. # Scenarios and Examples: 1. **Fetching by Location**: - `fetch_by_location(\\"Section A\\")` should return `[\\"Nuts\\", \\"Bolts\\"]`. - `fetch_by_location(\\"Section Z\\")` raises `ValueError` with a message like `\\"Invalid location: Section Z. Valid locations are: Section A, Section B, Section C.\\"`. 2. **Fetching by Category**: - `fetch_by_category(\\"Hardware\\")` should return `[\\"Nuts\\", \\"Bolts\\", \\"Screws\\"]`. - `fetch_by_category(\\"Electronics\\")` raises `ValueError` with a message like `\\"Invalid category: Electronics. Valid categories are: Hardware, Grocery, Furniture.\\"`. # Boilerplate Code ```python from typing import List, Dict class InventorySystem: def __init__(self): self.items = [ {\\"name\\": \\"Nuts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Bolts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Apples\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Bananas\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Screws\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section C\\"}, {\\"name\\": \\"Table\\", \\"category\\": \\"Furniture\\", \\"location\\": \\"Section C\\"}, ] self.valid_locations = {item[\\"location\\"] for item in self.items} self.valid_categories = {item[\\"category\\"] for item in self.items} def fetch_by_location(self, location: str) -> List[str]: if location not in self.valid_locations: raise ValueError( f\\"Invalid location: {location}. Valid locations are: {\', \'.join(self.valid_locations)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"location\\"] == location] def fetch_by_category(self, category: str) -> List[str]: if category not in self.valid_categories: raise ValueError( f\\"Invalid category: {category}. Valid categories are: {\', \'.join(self.valid_categories)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"category\\"] == category] if __name__ == \\"__main__\\": system = InventorySystem() import doctest def test_fetch_by_location(): assert system.fetch_by_location(\\"Section A\\") == [\\"Nuts\\", \\"Bolts\\"] assert system.fetch_by_location(\\"Section B\\") == [\\"Apples\\", \\"Bananas\\"] assert system.fetch_by_location(\\"Invalid Section\\") == \\"Error\\" def test_fetch_by_category(): assert system.fetch_by_category(\\"Hardware\\") == [\\"Nuts\\", \\"Bolts\\", \\"Screws\\"] assert system.fetch_by_category(\\"Grocery\\") == [\\"Apples\\", \\"Bananas\\"] assert system.fetch_by_category(\\"Invalid Category\\") == \\"Error\\" doctest.testmod() ``` # End of Question 2","solution":"from typing import List class InventorySystem: def __init__(self): self.items = [ {\\"name\\": \\"Nuts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Bolts\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section A\\"}, {\\"name\\": \\"Apples\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Bananas\\", \\"category\\": \\"Grocery\\", \\"location\\": \\"Section B\\"}, {\\"name\\": \\"Screws\\", \\"category\\": \\"Hardware\\", \\"location\\": \\"Section C\\"}, {\\"name\\": \\"Table\\", \\"category\\": \\"Furniture\\", \\"location\\": \\"Section C\\"}, ] self.valid_locations = {item[\\"location\\"] for item in self.items} self.valid_categories = {item[\\"category\\"] for item in self.items} def fetch_by_location(self, location: str) -> List[str]: if location not in self.valid_locations: raise ValueError( f\\"Invalid location: {location}. Valid locations are: {\', \'.join(self.valid_locations)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"location\\"] == location] def fetch_by_category(self, category: str) -> List[str]: if category not in self.valid_categories: raise ValueError( f\\"Invalid category: {category}. Valid categories are: {\', \'.join(self.valid_categories)}.\\" ) return [item[\\"name\\"] for item in self.items if item[\\"category\\"] == category]"},{"question":"# Prime Gap Finder **Context**: A prime gap is the difference between two successive prime numbers. The problem of finding large prime gaps has applications in number theory and cryptography. In this exercise, you will implement a function to find the first pair of consecutive primes within a specified range `[start, end]` that have the largest gap between them. **Task**: 1. Implement a function to generate all prime numbers within a given range using the Sieve of Eratosthenes. 2. Implement a function to identify and return the first pair of consecutive primes within that range that have the largest gap. **Requirements**: 1. **Function 1**: `sieve_of_eratosthenes(start: int, end: int) -> list` - Generate and return a list of all primes in the range `[start, end)`. - Assume `end > start >= 2`. 2. **Function 2**: `find_largest_gap_prime_pair(start: int, end: int) -> tuple` - Find and return the first pair of consecutive primes `(p1, p2)` within the range `[start, end)` that have the largest gap `(p2 - p1)`. - If there are no pairs of primes within the range, return `None`. ```python def sieve_of_eratosthenes(start: int, end: int) -> list: sieve = [True] * end sieve[0] = sieve[1] = False for i in range(2, int(end**0.5) + 1): if sieve[i]: for j in range(i * i, end, i): sieve[j] = False primes = [i for i in range(start, end) if sieve[i]] return primes def find_largest_gap_prime_pair(start: int, end: int) -> tuple: primes = sieve_of_eratosthenes(start, end) if len(primes) < 2: return None max_gap = (0, 0, 0) # (p1, p2, gap) for i in range(1, len(primes)): p1, p2 = primes[i-1], primes[i] gap = p2 - p1 if gap > max_gap[2]: max_gap = (p1, p2, gap) return (max_gap[0], max_gap[1]) if max_gap[2] > 0 else None # Example Usage: # print(find_largest_gap_prime_pair(10, 50)) # Output might be (23, 29) ``` **Performance Requirements**: - The sieve function should be efficient enough to handle ranges up to `10^6`. **Constraints**: - The input range `[start, end)` will be integers where `2 <= start < end <= 10^6`. Ensure the function names, parameters, and output formats are consistent as specified. Use appropriate methods and type hints for clarity.","solution":"def sieve_of_eratosthenes(start: int, end: int) -> list: sieve = [True] * end sieve[0] = sieve[1] = False for i in range(2, int(end**0.5) + 1): if sieve[i]: for j in range(i * i, end, i): sieve[j] = False primes = [i for i in range(start, end) if sieve[i]] return primes def find_largest_gap_prime_pair(start: int, end: int) -> tuple: primes = sieve_of_eratosthenes(start, end) if len(primes) < 2: return None max_gap = (0, 0, 0) # (p1, p2, gap) for i in range(1, len(primes)): p1, p2 = primes[i-1], primes[i] gap = p2 - p1 if gap > max_gap[2]: max_gap = (p1, p2, gap) return (max_gap[0], max_gap[1]) if max_gap[2] > 0 else None"},{"question":"Valid Parentheses Sequence **Context:** A common task in computer science is to ensure that sequences of various delimiters (like parentheses, brackets, and braces) are well-formed. A well-formed sequence means that all types of delimiters are correctly opened and closed in the proper order. This problem often arises in syntax parsing and checking the correctness of code or mathematical expressions. **Task:** Write a function to determine if a given string of delimiters is valid. A string is considered valid if every opening delimiter has a corresponding closing delimiter and the delimiters are properly nested. **Specifications:** 1. **Function Signature:** - `def is_valid_sequence(s: str) -> bool` 2. **Constraints:** - The string `s` consists only of characters: \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - The length of `s` is between 1 and 10^4. 3. **Expected Time Complexity:** - The solution should run in linear time, O(n), where n is the length of the string `s`. **Example Usage:** ```python print(is_valid_sequence(\\"()\\")) # True print(is_valid_sequence(\\"()[]{}\\")) # True print(is_valid_sequence(\\"(]\\")) # False print(is_valid_sequence(\\"([)]\\")) # False print(is_valid_sequence(\\"{[]}\\")) # True ``` **Edge Cases:** - Strings with a single type of bracket. - Strings with improperly nested brackets. - Empty strings (considered valid). **Performance Requirements:** - The algorithm should maintain an efficient use of space and time, with space complexity being O(n) due to the use of a stack to keep track of open delimiters. - The algorithm should handle strings up to the maximum constraint in a performant manner. **Implementation Hint:** - Utilize a stack data structure to ensure each opened delimiter is properly matched and closed in a last-in, first-out (LIFO) manner. ```python def is_valid_sequence(s: str) -> bool: stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack # Example usage print(is_valid_sequence(\\"()\\")) # True print(is_valid_sequence(\\"()[]{}\\")) # True print(is_valid_sequence(\\"(]\\")) # False print(is_valid_sequence(\\"([)]\\")) # False print(is_valid_sequence(\\"{[]}\\")) # True ``` Ensure your implementation correctly evaluates sequences of delimiters, accurately determining their validity as per the specified rules.","solution":"def is_valid_sequence(s: str) -> bool: stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: # Check if the char is a closing bracket top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: # It is an opening bracket stack.append(char) return not stack"},{"question":"# Problem Statement You are assigned to work on a project where you need to handle and manipulate a library system for book management. The goal is to implement a `Library` class that can manage a collection of books and perform several operations. Specifically, your objectives are: 1. **Adding and Removing Books:** Implement functionality to add and remove books from the library. 2. **Handling Book Availability:** Implement a method to loan out a book to a member and mark it as unavailable. Also, implement functionality to return a book back to the library and mark it as available. 3. **Searching Books:** Implement functionality to search for books by either title or author. # Task Requirements Implement the following methods in the `Library` class: 1. **add_book(self, title: str, author: str) -> None:** - Adds a book with the specified title and author to the library. Each book should have a unique title. 2. **remove_book(self, title: str) -> None:** - Removes the book with the specified title from the library. If the book does not exist, do nothing. 3. **loan_out_book(self, title: str, member: str) -> bool:** - Marks the specified book as unavailable and associates it with the given member. Returns `True` if the operation is successful (i.e., the book exists and is currently available). Returns `False` otherwise (i.e., the book does not exist or is already loaned out). 4. **return_book(self, title: str) -> bool:** - Marks the specified book as available. Returns `True` if the operation is successful (i.e., the book exists and is currently loaned out). Returns `False` otherwise (i.e., the book does not exist or is not currently loaned out). 5. **search_books(self, query: str, search_by: str) -> list[str]:** - Searches for books based on the query. `search_by` can be either `\\"title\\"` or `\\"author\\"`. Returns a list of book titles that match the query based on the specified search parameter. The search should be case-insensitive. # Input - `title` is a string representing the title of the book. - `author` is a string representing the author of the book. - `member` is a string representing the library member\'s name. - `query` is a string used to search for books. - `search_by` is a string set to either `\\"title\\"` or `\\"author\\"` to determine the search parameter. # Output - For `loan_out_book` and `return_book`, return a boolean. - For `search_books`, return a list of strings representing the book titles. # Constraints 1. A library can have up to `10^4` books. 2. Each book has a unique title. 3. Search queries and titles will only include alphanumeric characters and spaces. # Example ```python library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"1984\\", \\"George Orwell\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") print(library.search_books(\\"George Orwell\\", \\"author\\")) # Output: [\\"1984\\"] print(library.loan_out_book(\\"1984\\", \\"John Doe\\")) # Output: True print(library.loan_out_book(\\"1984\\", \\"Jane Doe\\")) # Output: False print(library.return_book(\\"1984\\")) # Output: True print(library.search_books(\\"Gatsby\\", \\"title\\")) # Output: [\\"The Great Gatsby\\"] library.remove_book(\\"1984\\") print(library.search_books(\\"1984\\", \\"title\\")) # Output: [] ``` Implement the methods in such a way that they handle the provided constraints and ensure efficient performance.","solution":"class Library: def __init__(self): self.books = {} self.loaned_books = {} def add_book(self, title: str, author: str) -> None: if title not in self.books: self.books[title] = {\'author\': author, \'available\': True, \'member\': None} def remove_book(self, title: str) -> None: if title in self.books: self.books.pop(title) def loan_out_book(self, title: str, member: str) -> bool: if title in self.books and self.books[title][\'available\']: self.books[title][\'available\'] = False self.books[title][\'member\'] = member return True return False def return_book(self, title: str) -> bool: if title in self.books and not self.books[title][\'available\']: self.books[title][\'available\'] = True self.books[title][\'member\'] = None return True return False def search_books(self, query: str, search_by: str) -> list[str]: result = [] query = query.lower() if search_by == \\"title\\": for title in self.books: if query in title.lower(): result.append(title) elif search_by == \\"author\\": for title, details in self.books.items(): if query in details[\'author\'].lower(): result.append(title) return result"},{"question":"# Problem Statement: **String Segmentation Validator** You are given a string `s` and a list of words `wordList`. Your task is to determine if the string can be segmented into a space-separated sequence of one or more dictionary words from `wordList`. # Function Signature: ```python def can_segment_string(s: str, wordList: list) -> bool: ``` # Input: - `s`: A string that needs to be segmented. - `wordList`: A list of strings representing the dictionary words. # Output: - A boolean value: `True` if the string `s` can be segmented into a sequence of one or more dictionary words from `wordList`, `False` otherwise. # Constraints: - The length of string `s` will be between 0 and 300. - The length of `wordList` will be between 0 and 1000. - Each word in `wordList` will have a length between 1 and 20. # Example: ```python assert can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False assert can_segment_string(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == True assert can_segment_string(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == True assert can_segment_string(\\"catsanddogs\\", [\\"cats\\", \\"dogs\\", \\"sand\\", \\"and\\"]) == True ``` # Implementation Requirements: 1. The time complexity of the solution should be efficient enough to handle the maximum constraint. 2. The function should use dynamic programming or another efficient strategy to determine the possibility of segmenting the string. # Scenario: Imagine you are tasked with validating if a given string can be constructed using a list of known words. This problem is crucial in text processing tasks such as tokenization in natural language processing, where you need to break down a large string into meaningful words. This problem tests your ability to implement an efficient validation mechanism using string manipulation and dynamic programming. # Constraints to Consider: - Ensure that the solution handles edge cases such as an empty string and minimal dictionary sizes appropriately. - Optimize for performance to handle the upper limits of the input sizes gracefully.","solution":"def can_segment_string(s: str, wordList: list) -> bool: Function to determine if the string s can be segmented into a space-separated sequence of one or more dictionary words from wordList. wordSet = set(wordList) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in wordSet: dp[i] = True break return dp[-1]"},{"question":"# Scenario A product recommendation engine works by finding the intersection of products liked by two different users. Given two lists of product names liked by two users, your task is to determine the common products liked by both users. # Task Description Implement a function `common_products` that takes two lists of strings, `user1_likes` and `user2_likes`, and returns a list of strings containing the product names liked by both users. The order of the common products in the returned list does not matter. # Function Signature ```python def common_products(user1_likes: list[str], user2_likes: list[str]) -> list[str]: pass ``` # Input * Two lists, `user1_likes` and `user2_likes`, where each list contains strings representing product names. * Each list will have a length of at most 10^3. * Each product name will be a non-empty string and will have a maximum length of 50 characters. The product names will not contain spaces. # Output * A list of strings containing the product names liked by both users. If no common products are found, return an empty list. # Constraints * Each list can have up to 10^3 strings. * Product names are case-sensitive. # Example Example 1 ```python user1_likes = [\\"Laptop\\", \\"Mouse\\", \\"Keyboard\\", \\"Monitor\\"] user2_likes = [\\"Mouse\\", \\"Keyboard\\", \\"Headphones\\"] print(common_products(user1_likes, user2_likes)) # Output: [\\"Mouse\\", \\"Keyboard\\"] ``` Example 2 ```python user1_likes = [\\"Phone\\", \\"Tablet\\"] user2_likes = [\\"Laptop\\", \\"Monitor\\"] print(common_products(user1_likes, user2_likes)) # Output: [] ``` Example 3 ```python user1_likes = [\\"Camera\\"] user2_likes = [\\"Camera\\"] print(common_products(user1_likes, user2_likes)) # Output: [\\"Camera\\"] ``` # Notes * You can assume that the function call will always provide two valid lists of product names. * The intersection operation should be optimized for performance given the potential size of the input lists.","solution":"def common_products(user1_likes: list[str], user2_likes: list[str]) -> list[str]: Returns a list of common products liked by both users. Parameters: user1_likes (list of str): List of product names liked by the first user. user2_likes (list of str): List of product names liked by the second user. Returns: list of str: List of common product names liked by both users. # Convert lists to sets to utilize set intersection for finding common elements user1_set = set(user1_likes) user2_set = set(user2_likes) # Find the intersection of both sets common_set = user1_set.intersection(user2_set) # Convert the set back to a list and return return list(common_set)"},{"question":"# Matrix Manipulation Problem Objective Implement a function `connector_ways` that calculates the number of unique ways to connect the top-left corner of a matrix to the bottom-right corner. Movement is only allowed to the right or downward, and certain cells are blocked. # Requirements - The function should take in a matrix representing the grid. - Each cell in the matrix contains either a 0 (free space) or 1 (blocked space). - Return the total number of unique paths from the top-left to the bottom-right. Input Format: - **matrix**: `list[list[int]]` - A 2D list where each element is either 0 (free) or 1 (blocked). Output Format: - **int** - The total number of unique paths from the top-left to the bottom-right cell. If no such path exists, return 0. Constraints: - 1 ≤ number of rows, columns ≤ 100 - The matrix is initially set with the top-left (start) and bottom-right (end) cells being 0 (free). Example: ```python matrix = [ [0, 0, 1], [1, 0, 0], [0, 0, 0] ] print(connector_ways(matrix)) # Output: 2 ``` # Implementation Steps: 1. **Initialization and Base Checking**: Verify if the matrix has valid start and end points. If either is blocked, immediately return 0. 2. **Dynamic Programming Setup**: - Create a DP table where `dp[i][j]` represents the number of ways to reach cell `(i, j)`. - Initialize `dp[0][0]` to 1 as the starting point. 3. **Fill DP Table**: - Iterate through each cell in the original matrix. - For each free cell, calculate the number of ways by adding the possible paths from the top and left cells. 4. **Return Result**: The value at `dp[-1][-1]` will contain the total number of unique ways to reach the bottom-right corner. Edge Cases: - No valid path due to blocked cells. - Small matrices with direct paths or no paths (1x1 matrices). ```python def connector_ways(matrix: list[list[int]]) -> int: if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = 1 for i in range(rows): for j in range(cols): if matrix[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Example usage: matrix = [ [0, 0, 1], [1, 0, 0], [0, 0, 0] ] print(connector_ways(matrix)) # Output: 2 ```","solution":"def connector_ways(matrix: list[list[int]]) -> int: if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = 1 for i in range(rows): for j in range(cols): if matrix[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Example usage: matrix = [ [0, 0, 1], [1, 0, 0], [0, 0, 0] ] print(connector_ways(matrix)) # Output: 2"},{"question":"# FIFO Cache Implementation # Background In computing, a **FIFO (First-In-First-Out) Cache** is an abstract data type that follows the order of insertion. Items added first are removed first when the cache reaches its capacity to make room for new items. This type of cache is useful for managing resources in systems with limited memory. # Problem Write a class `FIFOCache` that implements a fixed-size FIFO cache. The cache should support the following operations: 1. **insert(key: str, value: str) -> None**: Adds a key-value pair to the cache. If the cache is full, it should evict the earliest added item. 2. **retrieve(key: str) -> str**: Retrieves the value associated with the key. If the key is not present, return `\\"Key not found\\"`. # Inputs - `capacity`: An integer indicating the maximum number of items the cache can hold. - `insert(key, value)`: A method to insert a key-value pair into the cache. - `retrieve(key)`: A method to retrieve the value associated with the key. # Outputs - For the `retrieve` method, return the value associated with the key or `\\"Key not found\\"` if the key does not exist in the cache. # Constraints - The `capacity` must be greater than 0. - Keys and values are strings with lengths between 1 and 100 characters. # Examples ```python # Create a FIFO cache with capacity 2 cache = FIFOCache(2) # Insert key-value pairs cache.insert(\\"a\\", \\"apple\\") cache.insert(\\"b\\", \\"banana\\") # Retrieve values assert cache.retrieve(\\"a\\") == \\"apple\\" assert cache.retrieve(\\"b\\") == \\"banana\\" # Insert another key-value pair, this will evict the oldest item (\\"a\\") cache.insert(\\"c\\", \\"cherry\\") assert cache.retrieve(\\"a\\") == \\"Key not found\\" assert cache.retrieve(\\"b\\") == \\"banana\\" assert cache.retrieve(\\"c\\") == \\"cherry\\" # Insert another key-value pair, this will evict the next oldest item (\\"b\\") cache.insert(\\"d\\", \\"date\\") assert cache.retrieve(\\"b\\") == \\"Key not found\\" assert cache.retrieve(\\"c\\") == \\"cherry\\" assert cache.retrieve(\\"d\\") == \\"date\\" ``` **Your task** is to implement the `FIFOCache` class that supports the insert and retrieve functionality as specified. Ensure that your implementation correctly handles cache evictions based on the FIFO principle.","solution":"class FIFOCache: def __init__(self, capacity): Initialize the FIFO Cache with a fixed capacity if capacity <= 0: raise ValueError(\\"Capacity must be greater than zero.\\") self.capacity = capacity self.cache = {} self.order = [] def insert(self, key, value): Add a key-value pair to the cache. If the cache is full, evict the earliest added item. if key in self.cache: # If the key is already in the cache, update the value but maintain position self.cache[key] = value else: if len(self.cache) == self.capacity: # Evict the first item added oldest_key = self.order.pop(0) del self.cache[oldest_key] # Add the new item self.cache[key] = value self.order.append(key) def retrieve(self, key): Retrieve the value associated with the key, or return \\"Key not found\\" if the key does not exist. return self.cache.get(key, \\"Key not found\\")"},{"question":"# Combination Sum IV You are tasked with finding the number of possible combinations that add up to a target sum using a given list of positive integers. You can use each element in the list any number of times. # Function Requirements You need to implement the function `combination_sum4(nums: list[int], target: int) -> int` following these requirements: 1. **Input**: - `nums` (list of int): A list of distinct positive integers. - `target` (int): A positive integer representing the target sum. 2. **Output**: - An integer representing the number of possible combinations that add up to the `target`. # Steps: 1. **Dynamic Programming Setup**: - Create a list `dp` where `dp[i]` represents the number of possible combinations to get the sum `i`. 2. **Initialization**: - Initialize `dp[0] = 1` as there is one way to reach the sum of 0, which is using no elements. 3. **Fill DP Array**: - Update `dp` by iterating through each number in `nums` and for each number, iterate through all possible sums from the number up to `target`. # Constraints: - The function should work efficiently and handle a reasonable range of inputs. - The length of `nums` will be in the range [1, 200]. - The target will be in the range [1, 1000]. # Example: ```python >>> combination_sum4([1, 2, 3], 4) 7 >>> combination_sum4([2, 3, 5], 8) 6 ``` Explanation: - For the first example `[1, 2, 3]`, the number of combinations that add up to 4 are: - (1,1,1,1) - (1,1,2) - (1,2,1) - (2,1,1) - (2,2) - (1,3) - (3,1) Hence, there are 7 combinations. - For the second example `[2, 3, 5]`, the number of combinations that add up to 8 are: - (2,2,2,2) - (2,2,3,3) - (2,3,3,2) - (3,2,3,2) - (3,5) - (5,3) Hence, there are 6 combinations. # Implementation: Write your solution as a function in Python. ```python def combination_sum4(nums: list[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target] ``` Provide accompanying explanations for critical parts and document any assumptions or constraints.","solution":"def combination_sum4(nums: list[int], target: int) -> int: Returns the number of possible combinations that add up to the target sum using the given list of positive integers. Each number in the list can be used any number of times. :param nums: List of distinct positive integers. :param target: Positive integer representing the target sum. :return: Integer representing the number of possible combinations. # Initialize a list to store the count of combinations for each sum up to target. dp = [0] * (target + 1) # There is one way to achieve a sum of 0: by using no elements. dp[0] = 1 # Fill the dp array by summing counts of each number combination. for i in range(1, target + 1): for num in nums: if i >= num: dp[i] += dp[i - num] return dp[target]"},{"question":"# Problem Statement You are tasked with finding a series of consecutive integers starting from `1` whose sum of squares equals a given number `N`. # Requirements 1. **Input**: A single positive integer `N` (1 <= N <= 10^9). 2. **Output**: A list of consecutive integers starting from 1 such that the sum of their squares equals `N`. If such a series does not exist, return an empty list. 3. **Constraints**: The solution must efficiently check for the existence of such a series and not rely on brute force. # Additional Information - The sum of squares of the first `k` integers is calculated by the formula: ( S = sum_{i=1}^{k} i^2 = frac{k(k + 1)(2k + 1)}{6} ) - Your task is to determine the smallest `k` such that this sum equals `N`, if possible. # Performance Requirements Your solution should use mathematical properties or an efficient algorithm to find `k` such that the sum of squares equals `N`, keeping the runtime significantly less than O(10^9) iterations. Implement the function `find_consecutive_sum_of_squares(N: int) -> list`: ```python def find_consecutive_sum_of_squares(N: int) -> list: Finds the series of consecutive integers starting from 1 whose sum of squares equals N. Args: N (int): The target sum of squares. Returns: list: The list of consecutive integers starting from 1 whose sum of squares equals N. If no such series exists, returns an empty list. pass ``` # Usage Example ```python print(find_consecutive_sum_of_squares(55)) # Output should be [1, 2, 3, 4, 5], since 1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 55 print(find_consecutive_sum_of_squares(10)) # Output should be [1, 3], since 1^2 + 3^2 = 10 print(find_consecutive_sum_of_squares(11)) # Output should be [], since no such series exists ``` **Note:** You must leverage mathematical formulations and optimization techniques to solve the problem, not brute force.","solution":"def find_consecutive_sum_of_squares(N: int) -> list: Finds the series of consecutive integers starting from 1 whose sum of squares equals N. Args: N (int): The target sum of squares. Returns: list: The list of consecutive integers starting from 1 whose sum of squares equals N. If no such series exists, returns an empty list. def sum_of_squares(k): return k * (k + 1) * (2 * k + 1) // 6 low, high = 1, 10**5 # using a bit large value for high side to start with as we need to deal up to 10^9 while low <= high: mid = (low + high) // 2 current_sum = sum_of_squares(mid) if current_sum == N: return list(range(1, mid + 1)) elif current_sum < N: low = mid + 1 else: high = mid - 1 return []"},{"question":"# Question: JSON Path Parsing and Manipulation You are required to implement a class, `JsonPathReader`, that performs path-based extraction and manipulation of values from JSON data structures. The class should support operations such as getting a value by a JSON path, updating a value by a JSON path, and deleting a value by a JSON path. Your task: Implement the `JsonPathReader` class with the following functionalities: 1. **Initialization**: - Initialize the class with a JSON object. 2. **Get Value**: - `get_value(self, path: str) -> Any`: Retrieve the value at the specified JSON path. 3. **Set Value**: - `set_value(self, path: str, value: Any) -> None`: Set or update the value at the specified JSON path. 4. **Delete Value**: - `delete_value(self, path: str) -> None`: Delete the value at the specified JSON path. Requirements: * Name of the class: `JsonPathReader` * The paths should support nested keys and list indices, denoted by a dot (`.`) and square brackets (`[]`), respectively (e.g., \\"key1.key2[0].key3\\"). * Ensure the class handles invalid paths gracefully (e.g., raising appropriate exceptions). Example Scenarios & Edge Cases: 1. **Edge Cases**: * Paths that do not exist in the JSON structure. * Operations on nested lists within the JSON structure. 2. **Example Usage**: ```python example_json = { \\"name\\": \\"John\\", \\"address\\": { \\"city\\": \\"New York\\", \\"street\\": \\"123 Main St\\", \\"postalCode\\": \\"10001\\" }, \\"phoneNumbers\\": [ {\\"type\\": \\"home\\", \\"number\\": \\"212-555-1234\\"}, {\\"type\\": \\"office\\", \\"number\\": \\"646-555-4567\\"} ] } reader = JsonPathReader(example_json) # Retrieving value print(reader.get_value(\\"address.city\\")) # Expected: \\"New York\\" # Updating value reader.set_value(\\"address.city\\", \\"Los Angeles\\") print(reader.get_value(\\"address.city\\")) # Expected: \\"Los Angeles\\" # Deleting value reader.delete_value(\\"phoneNumbers[1]\\") print(reader.get_value(\\"phoneNumbers\\")) # Expected: [{\\"type\\": \\"home\\", \\"number\\": \\"212-555-1234\\"}] ``` Implement the class with all necessary methods and ensure that it passes testing for the edge cases and examples provided.","solution":"import json class JsonPathReader: def __init__(self, data): Initialize the JsonPathReader with a JSON object. self.data = data def _resolve_path(self, path): keys = path.replace(\'[\', \'.\').replace(\']\', \'\').split(\'.\') return keys def get_value(self, path: str): keys = self._resolve_path(path) current = self.data for key in keys: if key.isdigit(): key = int(key) current = current[key] return current def set_value(self, path: str, value: any): keys = self._resolve_path(path) current = self.data for i, key in enumerate(keys): if key.isdigit(): key = int(key) if i == len(keys) - 1: current[key] = value else: current = current[key] def delete_value(self, path: str): keys = self._resolve_path(path) current = self.data for i, key in enumerate(keys): if key.isdigit(): key = int(key) if i == len(keys) - 1: if isinstance(current, list): current.pop(key) else: del current[key] else: current = current[key]"},{"question":"# Image Compression using K-Means Clustering Context You are tasked with implementing an image compression algorithm using K-Means clustering. The K-Means algorithm involves partitioning the dataset into K clusters, where each data point belongs to the cluster with the nearest mean. For image compression, this means reducing the number of colors in the image to K representative colors. Task Write a function `compress_image(image: List[List[Tuple[int, int, int]]], k: int) -> List[List[Tuple[int, int, int]]]` that compresses an image by reducing its colors using the K-Means clustering algorithm. The function should perform the following steps: 1. Convert the 2D image array into a 1D list of RGB tuples. 2. Perform K-Means clustering on these tuples to find K cluster centers (representative colors). 3. Replace each pixel\'s color with the nearest cluster center. 4. Convert the modified 1D list back into a 2D image array with the same dimensions. Requirements * **Input Format**: - `image` (List[List[Tuple[int, int, int]]]): A 2D list representing the image, where each element is a tuple (r, g, b) corresponding to the RGB values of a pixel. - `k` (int): The number of cluster centers (representative colors). Must be at least 1. * **Output Format**: - (List[List[Tuple[int, int, int]]]): A compressed 2D list of the image with the same dimensions. * **Constraints**: - If `k` is less than 1, raise a `ValueError`. - The image list is non-empty, and each sub-list is non-empty. - RGB values are integers in the range [0, 255]. Performance * The function should handle standard image sizes (e.g., 512x512) efficiently. Example Usage ```python # Example 1 image = [ [(255, 0, 0), (255, 0, 0), (0, 255, 0)], [(0, 255, 0), (0, 0, 255), (0, 0, 255)] ] k = 2 compressed_image = compress_image(image, k) print(compressed_image) ``` Edge Cases * Handling invalid input where `k` is less than 1. * Ensure proper conversion between 2D and 1D representations. * Efficiently handle images with large dimensions. [Note: Make sure to use an existing K-Means clustering implementation from a library such as `scikit-learn` for efficiency, or implement a basic but efficient version if libraries are not allowed.]","solution":"from typing import List, Tuple import numpy as np from sklearn.cluster import KMeans def compress_image(image: List[List[Tuple[int, int, int]]], k: int) -> List[List[Tuple[int, int, int]]]: if k < 1: raise ValueError(\\"k must be at least 1\\") # Get the dimensions of the image height, width = len(image), len(image[0]) # Flatten the 2D image array into a 1D list of RGB tuples flat_image = [pixel for row in image for pixel in row] # Convert the flat image list to a numpy array flat_image_np = np.array(flat_image) # Perform K-Means clustering to find K cluster centers (representative colors) kmeans = KMeans(n_clusters=k) kmeans.fit(flat_image_np) cluster_centers = kmeans.cluster_centers_ labels = kmeans.labels_ # Replace each pixel\'s color with the nearest cluster center compressed_flat_image = [tuple(map(int, cluster_centers[label])) for label in labels] # Convert the modified 1D list back into a 2D image array with the same dimensions compressed_image = [ [compressed_flat_image[i * width + j] for j in range(width)] for i in range(height) ] return compressed_image"},{"question":"# **Problem Statement:** You have been assigned the task of developing a software component that will format JSON-like text by correcting inconsistencies with respect to indentation. JSON data follows a strict style where each level of nesting should be indented by a certain number of spaces. # **Function Specification:** 1. **`format_json(json_string: str, indent: int) -> str`** * **Input**: `json_string` (a multiline string representing JSON data), `indent` (an integer representing the number of spaces to be used for each level of indentation). * **Output**: A well-formatted JSON string with proper indentation. Example: ```python >>> json_data = \'\'\' { \\"name\\": \\"John\\", \\"age\\": 30, \\"children\\": [ \\"Ann\\", \\"Billy\\" ], \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": \\"10001\\" } } \'\'\' >>> format_json(json_data, 4) \'\'\' { \\"name\\": \\"John\\", \\"age\\": 30, \\"children\\": [ \\"Ann\\", \\"Billy\\" ], \\"address\\": { \\"city\\": \\"New York\\", \\"zip\\": \\"10001\\" } } \'\'\' ``` # **Implementation Notes:** * For each level of nesting, add `indent` number of spaces. * Ensure that the beginning and end braces/brackets align correctly with the nested contents. * Handle empty arrays and objects gracefully while maintaining proper format. * All non-whitespace characters in the JSON string should be retained as is. # **Constraints:** * 1 ≤ indent ≤ 8 * 1 ≤ length of `json_string` ≤ 2000 * `json_string` will be a valid JSON formatted as a multiline string. # **Performance Requirements:** * The function should efficiently format the input JSON string within the given constraints. * It\'s important to preserve the integrity of the input JSON content while adjusting only the whitespaces for indentation. Good luck!","solution":"import json def format_json(json_string: str, indent: int) -> str: Formats a JSON string with proper indentation. Args: json_string (str): A multiline string representing JSON data. indent (int): Number of spaces to be used for each level of indentation. Returns: str: A properly formatted JSON string with correct indentation. # Parse the JSON string into a Python object json_object = json.loads(json_string) # Convert the Python object back into a JSON string with the specified indentation formatted_json_string = json.dumps(json_object, indent=indent) return formatted_json_string"},{"question":"# Coding Challenge: Simulate a Simple Blockchain Transaction **Context**: Blockchain technology employs a decentralized ledger to record transactions. One of the key aspects of blockchain is the immutability and consistency it provides. In this task, you are required to simulate a simple blockchain transaction system. **Task**: You need to implement a blockchain simulation where transactions can be added, and each block contains a hash of the previous block to ensure the chain\'s integrity. **Input**: - A `list` of tuples, where each tuple contains: - A `string` representing the sender\'s address. - A `string` representing the receiver\'s address. - An `int` representing the amount to be transferred. **Output**: - A `list` of `dict` objects representing the blockchain. Each block should contain: - The transaction details (sender, receiver, amount). - The hash of the current block. - The hash of the previous block. **Constraints**: - Each transaction follows the format: `(sender, receiver, amount)`. - The amount transferred is always a positive integer. - The list of transactions can be empty. - The hash function to be used is a simplified SHA256. **Function Signature**: ```python import hashlib def hash_block(block: dict) -> str: block_string = f\\"{block[\'sender\']}{block[\'receiver\']}{block[\'amount\']}{block[\'previous_hash\']}\\" return hashlib.sha256(block_string.encode()).hexdigest() def add_to_blockchain(transactions: list) -> list: pass ``` **Requirements**: 1. Each transaction is processed and added as a block in the blockchain. 2. Each block contains: - `sender`: The sender\'s address. - `receiver`: The receiver\'s address. - `amount`: The amount transferred. - `hash`: The hash of the current block. - `previous_hash`: The hash of the previous block (use \'0\' for the first block\'s previous hash). **Example**: ```python transactions = [(\\"Alice\\", \\"Bob\\", 50), (\\"Bob\\", \\"Charlie\\", 30), (\\"Alice\\", \\"Charlie\\", 20)] blockchain = add_to_blockchain(transactions) expected_blockchain = [ { \'sender\': \'Alice\', \'receiver\': \'Bob\', \'amount\': 50, \'hash\': \'somehashvalue1\', \'previous_hash\': \'0\' }, { \'sender\': \'Bob\', \'receiver\': \'Charlie\', \'amount\': 30, \'hash\': \'somehashvalue2\', \'previous_hash\': \'somehashvalue1\' }, { \'sender\': \'Alice\', \'receiver\': \'Charlie\', \'amount\': 20, \'hash\': \'somehashvalue3\', \'previous_hash\': \'somehashvalue2\' } ] assert blockchain == expected_blockchain ``` **Note**: Your focus should be on the integrity of the blockchain by ensuring each block\'s hash correctly references the previous block\'s hash. You can use SHA256 from the `hashlib` library for hashing purposes.","solution":"import hashlib from typing import List, Tuple, Dict def hash_block(block: Dict) -> str: block_string = f\\"{block[\'sender\']}{block[\'receiver\']}{block[\'amount\']}{block[\'previous_hash\']}\\" return hashlib.sha256(block_string.encode()).hexdigest() def add_to_blockchain(transactions: List[Tuple[str, str, int]]) -> List[Dict]: blockchain = [] previous_hash = \\"0\\" for sender, receiver, amount in transactions: block = { \\"sender\\": sender, \\"receiver\\": receiver, \\"amount\\": amount, \\"previous_hash\\": previous_hash } current_hash = hash_block(block) block[\\"hash\\"] = current_hash blockchain.append(block) previous_hash = current_hash return blockchain"},{"question":"# Coding Question You are tasked with writing a function to efficiently merge and sort multiple large files. Each file contains a sorted list of integers, and your task is to merge all these files into a single sorted file. You should optimize the process to handle a significant number of large files within an efficient time frame and minimal memory usage. Your function should take the following parameters: - `input_files` (List[str]): A list of paths to the input files containing sorted integers. - `output_file` (str): Path to the file where the merged and sorted output should be saved. The input files are guaranteed to contain integers sorted in ascending order. The output file should also contain integers sorted in ascending order, with each integer on a new line. # Function Signature ```python from typing import List def merge_and_sort_files( input_files: List[str], output_file: str ) -> None: pass ``` # Requirements: 1. Efficiently merge and sort the integers from all input files. 2. Handle large input files and many input files without running out of memory. 3. Ensure the output file is written in a sorted manner. # Example Suppose you have the following input files: ``` file1.txt: 1 5 9 file2.txt: 2 6 10 file3.txt: 3 7 11 file4.txt: 4 8 12 ``` Calling the function as follows: ```python merge_and_sort_files( input_files=[\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\", \\"file4.txt\\"], output_file=\\"output.txt\\" ) ``` The `output.txt` should contain: ``` 1 2 3 4 5 6 7 8 9 10 11 12 ``` # Implementation Notes - Consider using a min-heap to efficiently merge the sorted files. - Ensure the function can handle a large number of files without excessive memory usage. - Use file I/O operations effectively to manage the large inputs and outputs.","solution":"from typing import List import heapq def merge_and_sort_files(input_files: List[str], output_file: str) -> None: Merges multiple sorted files into a single sorted output file. Args: input_files: List of paths to the input files containing sorted integers. output_file: Path to the output file where the merged and sorted integers will be saved. min_heap = [] # Open all input files and store file iterators in a list file_iters = [open(file, \'r\') for file in input_files] try: # Initialize the heap with the first element from each file for i, f_iter in enumerate(file_iters): line = f_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_file, \'w\') as output_f: while min_heap: smallest, file_index = heapq.heappop(min_heap) output_f.write(f\\"{smallest}n\\") current_iter = file_iters[file_index] line = current_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), file_index)) finally: # Ensure all file handles are closed properly for f_iter in file_iters: f_iter.close()"},{"question":"# Problem Statement: Imagine you are given a string `s` consisting of lowercase English letters and a list `indices` of integers such that each integer in `indices` is a valid index in the string `s`. You need to reorder the characters of `s` according to the positions specified in `indices`. Specifically, the character at index `i` in the original string `s` should go to index `indices[i]` in the new string. Your task is to implement the following function: ```python def restore_string(s: str, indices: List[int]) -> str: pass ``` # Input: - `s` (1 ≤ len(s) ≤ 100) - A string of lowercase English letters. - `indices` - A list of integers of the same length as `s`, containing a permutation of `[0, 1, ..., len(s)-1]`. # Output: - Return a string with the characters of `s` reordered according to `indices`. # Example: ```python >>> restore_string(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" ``` # Explanation: 1. For `\\"abc\\"` with indices `[2, 1, 0]`: - Character at index `0` in `s` (\'a\') goes to index `2`. - Character at index `1` in `s` (\'b\') goes to index `1`. - Character at index `2` in `s` (\'c\') goes to index `0`. - Resulting string: `\\"cba\\"` 2. For `\\"aiohn\\"` with indices `[3, 1, 4, 2, 0]`: - Character at index `0` in `s` (\'a\') goes to index `3`. - Character at index `1` in `s` (\'i\') goes to index `1`. - Character at index `2` in `s` (\'o\') goes to index `4`. - Character at index `3` in `s` (\'h\') goes to index `2`. - Character at index `4` in `s` (\'n\') goes to index `0`. - Resulting string: `\\"nihao\\"` # Constraints: - Ensure your solution handles the reordering within a reasonable time frame for the given input size.","solution":"from typing import List def restore_string(s: str, indices: List[int]) -> str: # Create a list of the same length as `s`, filled with empty strings restored = [\'\'] * len(s) # Place characters from `s` to their respective positions in `restored` for i, idx in enumerate(indices): restored[idx] = s[i] # Join the list into a string and return return \'\'.join(restored)"},{"question":"**Context**: You are developing a system to manage student records for a university. Each student has a unique ID, a name, and a series of grades for different subjects. The system needs to calculate the GPA (Grade Point Average) for each student based on their grades. The GPA is calculated by averaging the grades, where each grade is on a scale from 0 to 4. **Task**: Write a function `calculate_gpa(student_records: Dict[int, Dict[str, Union[str, List[float]]]]) -> Dict[int, float]` that calculates the GPA for each student and returns a dictionary mapping student IDs to their GPA. **Function Specifications**: * **Input**: - `student_records`: A dictionary where the keys are student IDs (integers). The value is another dictionary with keys: - `\\"name\\"`: The student\'s name (string). - `\\"grades\\"`: A list of floats representing the student\'s grades for different subjects. * **Output**: - A dictionary where the keys are student IDs (integers) and the values are floats representing the calculated GPA for each student. **Constraints**: * Grades are on a scale from 0 to 4 (inclusive). * Each student has at least one grade. * The `student_records` dictionary contains valid input data with consistent structures. **Examples**: ```python >>> calculate_gpa({ 1: {\'name\': \'Alice\', \'grades\': [4.0, 3.7, 3.8]}, 2: {\'name\': \'Bob\', \'grades\': [3.4, 2.8, 3.2]}, 3: {\'name\': \'Charlie\', \'grades\': [2.8, 2.9, 3.1, 3.0]} }) {1: 3.8333333333333335, 2: 3.1333333333333333, 3: 2.95} >>> calculate_gpa({ 101: {\'name\': \'David\', \'grades\': [4.0]}, 102: {\'name\': \'Eva\', \'grades\': [3.3, 3.7]} }) {101: 4.0, 102: 3.5} >>> calculate_gpa({ 201: {\'name\': \'Frank\', \'grades\': [2.6, 3.1]}, 202: {\'name\': \'Grace\', \'grades\': [0.0, 1.5, 2.2, 1.8]} }) {201: 2.85, 202: 1.375} ``` **Additional Considerations**: * Ensure the function handles scenarios with diverse grade distributions gracefully. * Make sure the original student records are not modified during the GPA calculation. * Aim to provide a clear and efficient solution suitable for a larger dataset.","solution":"def calculate_gpa(student_records): Calculate the GPA for each student based on their grades. Args: student_records (dict): A dictionary where keys are student IDs and values are another dictionary with keys \\"name\\" and \\"grades\\" containing the student\'s name and a list of grades respectively. Returns: dict: A dictionary where keys are student IDs and values are the calculated GPA. gpa_records = {} for student_id, info in student_records.items(): grades = info[\'grades\'] gpa = sum(grades) / len(grades) gpa_records[student_id] = gpa return gpa_records"},{"question":"# Coding Assessment Question Scenario You are assisting in the development of a data processing library used for creating and analyzing financial models. One task involves identifying \\"unlucky\\" amounts from a sequence of transaction amounts. A transaction amount is deemed \\"unlucky\\" if it contains the digit \'4\' or the digit \'7\'. Task Implement the following function: ```python def find_unlucky_transactions(transactions: List[int]) -> List[int]: Identify all unlucky transactions. Parameters: - transactions: A list of integers representing transaction amounts. Returns: - A list of integers containing all unlucky transactions from the input list. ``` Requirements 1. **`find_unlucky_transactions` Implementation**: Use list comprehension and string manipulation to identify unlucky transactions efficiently. 2. **Input Constraints**: The length of the transactions list is at most (10^4) and each transaction amount is a non-negative integer no greater than (10^6). 3. **Output**: A list containing all the unlucky transactions in the same order they appear in the input list. Example ```python assert find_unlucky_transactions([153, 47, 28, 475, 127]) == [47, 475, 127] assert find_unlucky_transactions([123, 56, 89]) == [] assert find_unlucky_transactions([4, 77, 14, 70]) == [4, 77, 14, 70] ``` Additional Notes - Ensure the function handles empty lists correctly. - Preserve the order of transactions as in the input list. - Focus on the efficiency of your solution particularly given the constraints.","solution":"from typing import List def find_unlucky_transactions(transactions: List[int]) -> List[int]: Identify all unlucky transactions. Parameters: - transactions: A list of integers representing transaction amounts. Returns: - A list of integers containing all unlucky transactions from the input list. return [transaction for transaction in transactions if \'4\' in str(transaction) or \'7\' in str(transaction)]"},{"question":"# Sum of Array Using Recursion You have been given an array of integers. Your task is to compute the sum of all elements in the array using a recursive approach. --- # Function Specification **Function Name**: `sum_of_array` **Input**: - A list of integers, `arr`, which will be non-empty. **Output**: - Integer: Returns the sum of all elements in the array. # Example ```python assert sum_of_array([1, 2, 3, 4]) == 10 assert sum_of_array([10, -2, 5, 3]) == 16 assert sum_of_array([0, 0, 0]) == 0 assert sum_of_array([7]) == 7 assert sum_of_array([-5, -3, -2]) == -10 ``` # Constraints - The list will contain between 1 and 10^5 elements. - Each element of the list will be between -10^6 and 10^6. # Additional Information - Lists with fewer than 1 element or more than 10^5 elements will not be passed to the function. - The sum calculation must be performed using recursion. # Performance Requirements - The recursion depth should be handled efficiently to avoid maximum recursion depth exceeded errors. - Aim to achieve O(n) time complexity where n is the number of elements in the array. --- # Implementation Task Write a function `sum_of_array(arr: list) -> int` that adheres to the specifications and passes all the given test cases. Ensure that the solution does not use iterative structures like loops for summing the array elements.","solution":"def sum_of_array(arr): Returns the sum of all elements in the array using a recursive approach. if len(arr) == 0: return 0 else: return arr[0] + sum_of_array(arr[1:])"},{"question":"# LRU Cache Implementation Implement a Least Recently Used (LRU) cache with a fixed capacity that supports the following operations: - `get(key: int) -> int`: Fetch the value of the key if it exists in the cache; otherwise, return -1. - `put(key: int, value: int) -> None`: Insert or update the value of the key. If the key exists, update its value. If the cache exceeds its capacity, evict the least recently used item before inserting the new one. The LRU Cache should operate in constant time for both operations. Input Format You\'ll be provided with a list of operations to perform on the cache along with their associated keys and values. Initialize the cache with a given capacity and process each operation sequentially. Example Input ```python operations = [\\"LRUCache\\", \\"put\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"put\\", \\"get\\", \\"get\\", \\"get\\"] inputs = [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] ``` Example Output ```python [null, null, null, 1, null, -1, null, -1, 3, 4] ``` # Explanation 1. `LRUCache(2)` initializes the cache with capacity 2. 2. `put(1, 1)` stores key 1 with value 1 in the cache. 3. `put(2, 2)` stores key 2 with value 2 in the cache. 4. `get(1)` returns 1 as it is present in the cache. 5. `put(3, 3)` adds key 3 with value 3, and evicts key 2 as the cache exceeds its capacity. 6. `get(2)` returns -1 as key 2 was evicted. 7. `put(4, 4)` adds key 4 with value 4, and evicts key 1. 8. `get(1)` returns -1 as key 1 was evicted. 9. `get(3)` returns 3 as it is present in the cache. 10. `get(4)` returns 4 as it is present in the cache. # Constraints * The number of operations will not exceed 10000. * A key\'s value will always be a non-negative integer. Implementation Details - Use a combination of a dictionary and a doubly linked list to accomplish constant time operations for both `put` and `get`. ```python class ListNode: def __init__(self, key = 0, value = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: ListNode) -> None: prev = node.prev next = node.next prev.next, next.prev = next, prev def _add(self, node: ListNode) -> None: prev = self.tail.prev prev.next, node.prev = node, prev node.next, self.tail.prev = self.tail, node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = ListNode(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key] ``` # Performance Requirements * The solution should aim for O(1) time complexity for both `put` and `get` operations. * Space complexity is O(c) where c is the capacity of the cache.","solution":"class ListNode: def __init__(self, key = 0, value = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.head = ListNode() self.tail = ListNode() self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: ListNode) -> None: prev = node.prev next = node.next prev.next, next.prev = next, prev def _add(self, node: ListNode) -> None: prev = self.tail.prev prev.next, node.prev = node, prev node.next, self.tail.prev = self.tail, node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = ListNode(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Coding Assessment Question Scenario You are developing a social media platform and need a function to detect the most commonly used hashtags in a list of posts. This feature will help in identifying trending topics and enhancing user engagement through relevant content suggestions. Task Implement a Python function that receives a list of strings, where each string represents a social media post containing hashtags. The function should return the top `k` most frequently used hashtags. Function Signature ```python def top_k_hashtags(posts: List[str], k: int) -> List[str]: ``` Input - `posts`: A list of strings, where each string is a social media post containing zero or more hashtags. Hashtags are words prefixed with the `#` symbol. - `k`: An integer representing the number of top hashtags to return. Output - A list of strings representing the top `k` most frequently used hashtags sorted by their frequency in descending order. If there is a tie in frequency, sort the hashtags lexicographically. Constraints - The length of `posts` will be between 1 and 10^4. - Each post will be a non-empty string of maximum length 280 characters. - The value of `k` will be between 1 and 100, and there will be at least `k` unique hashtags in the input. Example ```python posts = [ \\"Just learned about #AI and #ML. #AI is fascinating!\\", \\"Exploring #DataScience with #python. #ML rocks!\\", \\"#AI is transforming #tech world.\\", \\"I love #python and #programming.\\", \\"Building projects using #python and #AI.\\" ] assert top_k_hashtags(posts, 3) == [\\"#AI\\", \\"#python\\", \\"#ML\\"] assert top_k_hashtags(posts, 2) == [\\"#AI\\", \\"#python\\"] ``` Note - Hashtags are case sensitive. For example, `#ai` and `#AI` are considered different hashtags. - Ensure your function handles edge cases such as posts with no hashtags or multiple hashtags with the same frequency.","solution":"from typing import List from collections import Counter import re def top_k_hashtags(posts: List[str], k: int) -> List[str]: Returns the top `k` most frequently used hashtags from a list of social media posts. Args: posts (List[str]): List of strings where each string is a social media post. k (int): Number of top hashtags to return. Returns: List[str]: List of top `k` most frequently used hashtags. hashtag_pattern = re.compile(r\\"#w+\\") hashtags = [] for post in posts: hashtags.extend(hashtag_pattern.findall(post)) hashtag_counts = Counter(hashtags) most_common_hashtags = hashtag_counts.most_common() # In case of ties in frequency, sort lexicographically sorted_hashtags = sorted(most_common_hashtags, key=lambda x: (-x[1], x[0])) return [hashtag for hashtag, count in sorted_hashtags[:k]]"},{"question":"# Question You are given a task to implement a function that computes the determinant of a given square matrix. The function will take a square matrix as input and return its determinant. Requirements 1. The function should check if the input matrix is square. If the matrix is not square, raise a ValueError. 2. Implement the determinant calculation using recursion and cofactor expansion. 3. Add appropriate documentation and type hints to your function. Function Signature ```python def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix. :param matrix: List of lists representing a square matrix. :return: A float representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. pass ``` Input - `matrix`: A square list of lists of floats, representing a matrix of dimension n x n (1 <= n <= 10). Output - Returns a float representing the determinant of the input matrix. Constraints - The function should handle matrices up to size 10x10. - Ensure the function handles the base cases: - The determinant of a 1x1 matrix is the single element in the matrix. - The determinant of a 2x2 matrix is calculated as `ad - bc` for matrix `[[a, b], [c, d]]`. Example ```python matrix = [ [4, 3], [6, 3] ] det = calculate_determinant(matrix) # Output: # det = -6.0 # In case of a non-square matrix matrix = [ [2, -2, 1], [0, 1, 2] ] # Raises ValueError ``` Hints - Utilize recursion to break down the matrix into smaller submatrices. - Pay attention to the sign alternation in the cofactor expansion. - You may find it useful to create a helper function to extract submatrices for cofactor expansion.","solution":"def calculate_determinant(matrix: list[list[float]]) -> float: Calculate the determinant of a given square matrix. :param matrix: List of lists representing a square matrix. :return: A float representing the determinant of the matrix. :raises ValueError: If the input matrix is not square. def get_submatrix(matrix, skip_row, skip_col): Return a submatrix after removing the specified row and column. return [ [elem for j, elem in enumerate(row) if j != skip_col] for i, row in enumerate(matrix) if i != skip_row ] n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The input matrix must be square\\") if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for col in range(n): submatrix = get_submatrix(matrix, 0, col) sign = (-1) ** col cofactor = sign * matrix[0][col] * calculate_determinant(submatrix) determinant += cofactor return determinant"},{"question":"# Coding Assessment Question You are provided with a basic implementation of a sorting algorithm. Your task is to extend this by implementing a hybrid sorting algorithm that combines the strengths of both Merge Sort and Insertion Sort for improved performance, particularly on nearly sorted datasets. # Requirements 1. Implement a function `hybrid_sort(arr: List[int], threshold: int) -> List[int>` such that: - `arr`: The list of integers to be sorted. - `threshold`: The size below which the algorithm should switch to Insertion Sort from Merge Sort. 2. The function should perform the following: - Use Merge Sort for sorting all subarrays larger than the threshold. - Use Insertion Sort for sorting subarrays of size less than or equal to the threshold. - Ensure the integration between the two sorting techniques is seamless. 3. Your implementation should optimize for the following: - Efficient handling of large and small datasets. - Improved performance on nearly sorted data. - Minimal overhead when switching between sorting algorithms. # Example Input and Output ```python >>> res = hybrid_sort([38, 27, 43, 3, 9, 82, 10], 5) >>> res == [3, 9, 10, 27, 38, 43, 82] True >>> res = hybrid_sort([1, 2, 3, 5, 4, 7, 6], 3) >>> res == [1, 2, 3, 4, 5, 6, 7] True ``` # Constraints - The list `arr` can have up to 1,000,000 elements. - Elements in `arr` are distinct integers. - The value of `threshold` will be a positive integer less than or equal to the length of `arr`. **Note**: Do not use any built-in sorting functions. Focus on the effective implementation of both Merge Sort and Insertion Sort, and the logic to switch between them based on the given threshold.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int) -> None: Perform insertion sort on the subarray arr[left:right+1] for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int) -> None: Merge two sorted subarrays arr[left:mid+1] and arr[mid+1:right+1] n1 = mid - left + 1 n2 = right - mid L = arr[left:left+n1] R = arr[mid+1:mid+1+n2] i = j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def hybrid_sort_recursive(arr: List[int], left: int, right: int, threshold: int) -> None: if left < right: if right - left + 1 <= threshold: insertion_sort(arr, left, right) else: mid = (left + right) // 2 hybrid_sort_recursive(arr, left, mid, threshold) hybrid_sort_recursive(arr, mid + 1, right, threshold) merge(arr, left, mid, right) def hybrid_sort(arr: List[int], threshold: int) -> List[int]: hybrid_sort_recursive(arr, 0, len(arr) - 1, threshold) return arr"},{"question":"# Sorting a List of Tuples by Second Element Now that you have implemented algorithms for sorting lists of numbers and strings, let\'s take a step further by working with sorting complex data structures like lists of tuples. # Objective Implement a function `sort_tuples_by_second_element` that sort a list of tuples based on the second element of each tuple. # Function Signature 1. `sort_tuples_by_second_element(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]` # Requirements - **Input**: - `tuples_list`: A list of tuples where each tuple contains exactly two integers. - **Output**: - Returns the list of tuples sorted in ascending order based on the second element of each tuple. # Example ```python input_tuples = [(3, 2), (1, 4), (5, 1), (7, 3)] sorted_tuples = sort_tuples_by_second_element(input_tuples) assert sorted_tuples == [(5, 1), (3, 2), (7, 3), (1, 4)] ``` # Constraints - Consider edge cases where elements might have the same second value. - The function should be able to handle an empty list of tuples gracefully. - Ensure that the original tuples are not modified in place.","solution":"from typing import List, Tuple def sort_tuples_by_second_element(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples by the second element of each tuple. Parameters: tuples_list (List[Tuple[int, int]]): A list of tuples where each tuple contains exactly two integers. Returns: List[Tuple[int, int]]: A list of tuples sorted in ascending order based on the second element of each tuple. return sorted(tuples_list, key=lambda x: x[1])"},{"question":"# Sorting Characters in a String by Frequency **Context**: You are working on a text analysis tool and need to implement a function to sort characters in a string by their frequency in descending order. If two characters have the same frequency, they should appear in the order of their first appearance in the string. # Task: Implement the function `frequency_sort` that takes a string as input and returns a new string with characters sorted by their frequency in descending order. If frequencies are the same, maintain the order from the original string. # Function Signature: ```python def frequency_sort(s: str) -> str: ``` # Input: - `s`: A string consisting of alphanumeric characters and/or punctuation. # Output: - Returns a string sorted by character frequency in descending order, with ties broken by the order of first appearance. # Constraints: - The input string `s` can be empty or have a length up to 1000 characters. # Example: ```python # Example 1 s1 = \\"tree\\" result1 = frequency_sort(s1) print(result1) # Output could be \\"eert\\" or \\"eetr\\" # Example 2 s2 = \\"cccaaa\\" result2 = frequency_sort(s2) print(result2) # Output could be \\"cccaaa\\" # Example 3 s3 = \\"Aabb\\" result3 = frequency_sort(s3) print(result3) # Output could be \\"bbAa\\" ``` # Notes: - Pay special attention to the sorting logic to ensure that characters with the same frequency maintain their relative order from the original string. - Consider using a data structure that allows for stable sorting with custom criteria. - The output need not be unique if multiple solutions are possible; any valid output adhering to the constraints is acceptable.","solution":"def frequency_sort(s: str) -> str: from collections import Counter counter = Counter(s) sorted_chars = sorted(s, key=lambda x: (-counter[x], s.index(x))) return \'\'.join(sorted_chars)"},{"question":"# Problem Statement: You are tasked with implementing a function to find the minimum number of moves required to convert a given string `S` into a palindrome. A move is defined as selecting any character in the string and changing it to any other character. A palindrome is a string that reads the same forward and backward. # Function Signature: ```python def min_moves_to_palindrome(S: str) -> int: ``` # Input: - `S` (str): A non-empty string consisting of lowercase English letters. # Output: - (int): The minimum number of moves required to convert the string into a palindrome. # Constraints: - The input string will have at most length 10^5. # Example: ```python >>> min_moves_to_palindrome(\'abccba\') 0 >>> min_moves_to_palindrome(\'abcdef\') 3 >>> min_moves_to_palindrome(\'racecar\') 0 >>> min_moves_to_palindrome(\'abca\') 1 ``` # Requirements: 1. Compute the minimum number of moves required to convert the given string into a palindrome. 2. Optimize your function to handle large input strings efficiently. 3. Consider edge cases such as strings with varying lengths and characters. # Notes: - The string may already be a palindrome, in which case no moves are required. - Pay attention to the performance for long strings and aim to keep the implementation as efficient as possible in terms of both time and space complexity. Good luck with your implementation!","solution":"def min_moves_to_palindrome(S: str) -> int: Returns the minimum number of moves required to convert the string S into a palindrome. n = len(S) moves = 0 # Compare characters from opposite ends of the string for i in range(n // 2): if S[i] != S[n - i - 1]: moves += 1 return moves"},{"question":"# Question: Implement a Trie Structure with Wildcard Search Capability You need to implement a Trie (prefix tree) data structure that supports insertion of words and a search operation with wildcard support. The wildcard character `\'.\'` can represent any single letter. Class Definition ```python class WildcardTrie: def __init__(self): pass def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` Method Signatures * `insert(word: str) -> None`: Inserts a word into the trie. * `search(word: str) -> bool`: Searches the trie for the given word which may contain the wildcard character `\'.\'`. Input * `word` in `insert`: A string representing the word to be inserted into the trie. The word will only contain lowercase English letters. * `word` in `search`: A string representing the word to be searched in the trie. The word may contain the wildcard character `\'.\'` which can match any single letter. Output * `search` method should return `True` if the word (considering the wildcard) is present in the trie, otherwise `False`. Constraints * The length of words will not exceed 20. * The number of words inserted into the trie will not exceed 10^4. * The total number of characters across all words inserted will not exceed 10^5. * The words will contain only lowercase English letters. Requirements 1. Implement the trie\'s insert operation. 2. Implement the search operation with support for the wildcard character `\'.\'`. # Example ```python trie = WildcardTrie() trie.insert(\\"bad\\") trie.insert(\\"dad\\") trie.insert(\\"mad\\") assert trie.search(\\"pad\\") == False # \'pad\' is not in the trie assert trie.search(\\"bad\\") == True # \'bad\' is in the trie assert trie.search(\\".ad\\") == True # \'.ad\' matches \'bad\', \'dad\', and \'mad\' assert trie.search(\\"b..\\") == True # \'b..\' matches \'bad\' ```","solution":"class WildcardTrie: class TrieNode: def __init__(self): self.children = {} self.end_of_word = False def __init__(self): self.root = self.TrieNode() def insert(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = self.TrieNode() current = current.children[char] current.end_of_word = True def search(self, word: str) -> bool: def dfs(node, i): if i == len(word): return node.end_of_word if word[i] == \'.\': return any(dfs(child, i + 1) for child in node.children.values()) if word[i] in node.children: return dfs(node.children[word[i]], i + 1) return False return dfs(self.root, 0)"},{"question":"# Validate and Format JSON Input **Objective**: Implement a function to validate and format incoming JSON data to meet specified criteria and ensure its structure is consistent. **Scenario**: In a data processing system, users submit JSON data which needs to be validated and reformatted before it can be processed. The data needs to be in a specific structure, including required fields and proper data types. **Requirements**: - Define a function `validate_and_format_json(data: dict) -> dict` that: - Takes a dictionary representing the JSON data as input. - Returns a dictionary with two keys: `\\"valid\\"` (boolean) and `\\"formatted_data\\"` (the reformatted data on success or an error message on failure). - Validates that the input data contains the required fields: `\\"name\\"` (string), `\\"age\\"` (integer), and `\\"emails\\"` (list of strings). - Ensures that `\\"name\\"` is a non-empty string and `\\"age\\"` is a non-negative integer. - If valid, formats the `\\"emails\\"` to lowercase. - If any validation fails, returns an appropriate error message. **Function Signature**: ```python def validate_and_format_json(data: dict) -> dict: pass ``` **Constraints**: - The input data is a dictionary. - The `\\"name\\"` field must be a non-empty string of maximum length 50. - The `\\"age\\"` field must be a non-negative integer not exceeding 120. - The `\\"emails\\"` field must be a non-empty list of valid email strings. **Examples**: 1. `validate_and_format_json({\\"name\\": \\"John Doe\\", \\"age\\": 28, \\"emails\\": [\\"JOHN@example.com\\", \\"DOE@example.com\\"]})` - Should return: ```python { \\"valid\\": True, \\"formatted_data\\": { \\"name\\": \\"John Doe\\", \\"age\\": 28, \\"emails\\": [\\"john@example.com\\", \\"doe@example.com\\"] } } ``` 2. `validate_and_format_json({\\"name\\": \\"\\", \\"age\\": 28, \\"emails\\": [\\"JOHN@example.com\\", \\"DOE@example.com\\"]})` - Should return: ```python { \\"valid\\": False, \\"formatted_data\\": \\"Invalid name: must be a non-empty string.\\" } ``` 3. `validate_and_format_json({\\"name\\": \\"John Doe\\", \\"age\\": -5, \\"emails\\": [\\"JOHN@example.com\\", \\"DOE@example.com\\"]})` - Should return: ```python { \\"valid\\": False, \\"formatted_data\\": \\"Invalid age: must be a non-negative integer.\\" } ``` 4. `validate_and_format_json({\\"name\\": \\"John Doe\\", \\"age\\": 28, \\"emails\\": [\\"JOHN@example.com\\", \\"invalid-email\\"]})` - Should return: ```python { \\"valid\\": False, \\"formatted_data\\": \\"Invalid email in the emails list.\\" } ```","solution":"def validate_and_format_json(data: dict) -> dict: # Validate name if \\"name\\" not in data or not isinstance(data[\\"name\\"], str) or not data[\\"name\\"]: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid name: must be a non-empty string.\\"} if len(data[\\"name\\"]) > 50: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid name: must be a non-empty string not exceeding 50 characters.\\"} # Validate age if \\"age\\" not in data or not isinstance(data[\\"age\\"], int) or data[\\"age\\"] < 0: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid age: must be a non-negative integer.\\"} if data[\\"age\\"] > 120: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid age: must not exceed 120.\\"} # Validate emails if \\"emails\\" not in data or not isinstance(data[\\"emails\\"], list) or not data[\\"emails\\"]: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid emails: must be a non-empty list of strings.\\"} formatted_emails = [] for email in data[\\"emails\\"]: if not isinstance(email, str) or \\"@\\" not in email or \\".\\" not in email.split(\\"@\\")[-1]: return {\\"valid\\": False, \\"formatted_data\\": \\"Invalid email in the emails list.\\"} formatted_emails.append(email.lower()) formatted_data = { \\"name\\": data[\\"name\\"], \\"age\\": data[\\"age\\"], \\"emails\\": formatted_emails } return {\\"valid\\": True, \\"formatted_data\\": formatted_data}"},{"question":"# Coding Assessment Question: Recursive Digit Sum Calculation Objective Implement a function to compute the recursive sum of digits of a number until a single-digit result is achieved. Problem Statement You are given an integer `n`. Your task is to: 1. Write a function `recursive_digit_sum(n: int) -> int` that recursively sums the digits of the number until a single-digit number is obtained. 2. Implement the function considering optimal performance for large inputs. Example ```python def recursive_digit_sum(n: int) -> int: # Your implementation here # Example usage: print(recursive_digit_sum(9875)) # Output: 2 (9 + 8 + 7 + 5 = 29, 2 + 9 = 11, 1 + 1 = 2) print(recursive_digit_sum(1234)) # Output: 1 (1 + 2 + 3 + 4 = 10, 1 + 0 = 1) print(recursive_digit_sum(9)) # Output: 9 print(recursive_digit_sum(0)) # Output: 0 ``` Constraints * The input integer `n` will be non-negative and within the range [0, (10^{18})]. * You should handle the cases where `n` is already a single-digit number efficiently. Note * You may use mathematical properties or efficient algorithms to minimize the number of recursive calls.","solution":"def recursive_digit_sum(n: int) -> int: Computes the recursive sum of digits until a single-digit number is obtained. :param n: The input number. :return: The single-digit result. # If n is 0, the digit sum is 0 if n == 0: return 0 # Digital root formula, which simplifies the process # If n is a multiple of 9 and greater than 0, the digital root is 9 return 9 if (n % 9 == 0 and n != 0) else n % 9"},{"question":"# Pathfinding for Delivery Drones You are tasked with developing a system to guide delivery drones through a city grid. The city is represented as a 2D grid of cells, where each cell can either be an open space the drone can pass, or an obstacle (e.g., building) the drone must avoid. The system should find the shortest path from a designated starting point to a delivery point. Your task is to implement a class `DronePathfinder` that provides a method for determining the shortest path from the start to the delivery point using the A* search algorithm. # Requirements 1. Implement the class `DronePathfinder` with the following methods: * **`__init__(self, grid: List[List[int]])`**: * Initialize with a grid (`grid`) representing the city. * Each cell in the grid is either `0` (open space) or `1` (obstacle). * **`find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]`**: * Use A* search algorithm to find the shortest path from `start` to `goal`. * Return the path as a list of coordinates (row, column). If no path exists, return an empty list. 2. Ensure the A* algorithm considers the Manhattan distance as the heuristic for pathfinding. 3. Consider edge cases including but not limited to: invalid start or goal points, all paths blocked, and out of bound indices. # Constraints * The grid size will not exceed 100x100. * Both `start` and `goal` will always be within the grid bounds. * The start and goal points will always be open spaces (`0`). # Example Usage ```python grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0], ] drone = DronePathfinder(grid) # Find path from top-left to bottom-right path = drone.find_path((0, 0), (3, 3)) print(\\"Path:\\", path) # Expected output: Path: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (3, 3)] ``` # Expected Input & Output * **Input**: `find_path((0, 0), (3, 3))` on the given `grid`. * **Output**: `List[Tuple[int, int]]` representing the coordinates of the cells in the shortest path. Implement the `DronePathfinder` class, ensuring to handle edge cases and verify with thorough testing.","solution":"import heapq class DronePathfinder: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) def heuristic(self, a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_path(self, start, goal): if not self.grid or not self.is_valid(start) or not self.is_valid(goal): return [] open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: self.heuristic(start, goal)} while open_set: current = heapq.heappop(open_set)[1] if current == goal: return self.reconstruct_path(came_from, current) for neighbor in self.get_neighbors(current): tentative_g_score = g_score[current] + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal) heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] def get_neighbors(self, position): neighbors = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for direction in directions: neighbor = (position[0] + direction[0], position[1] + direction[1]) if self.is_valid(neighbor): neighbors.append(neighbor) return neighbors def is_valid(self, position): row, col = position return 0 <= row < self.rows and 0 <= col < self.cols and self.grid[row][col] == 0 def reconstruct_path(self, came_from, current): path = [] while current in came_from: path.append(current) current = came_from[current] path.append(current) return path[::-1]"},{"question":"# Scenario: You are developing a logistics tracking system for a delivery company. The company needs to determine the optimal sequence of stops for a delivery route in order to minimize travel time. The input consists of a list of delivery locations specified by their coordinates. You need to compute the shortest possible route that visits each location exactly once and returns to the starting point. # Task: Implement a function `find_shortest_route(coords: list) -> float` that determines the minimal travel distance for the given delivery locations using the Traveling Salesman Problem (TSP) approach. Use a heuristic or approximation method to achieve a solution in a reasonable time frame, as the exact solution is computationally infeasible for larger datasets. # Function Signature: ```python def find_shortest_route(coords: list) -> float: pass ``` # Input: * `coords`: A list of tuples where each tuple consists of two integers representing the x and y coordinates of a delivery location. # Output: * Return the minimal travel distance as a floating-point number. # Example: ```python >>> find_shortest_route([(0, 0), (1, 1), (2, 2), (3, 3)]) 6.828 >>> find_shortest_route([(0, 0), (2, 0), (2, 2), (0, 2)]) 8.0 >>> find_shortest_route([(5, 5), (6, 6), (5, 6), (6, 5)]) 4.0 ``` # Constraints: * Expect to handle up to 20 delivery locations efficiently. # Notes: * Assume the distance between any two coordinates (x1, y1) and (x2, y2) is calculated using the Euclidean distance formula. * Implement and test your `find_shortest_route` function thoroughly considering it needs to handle inexact solutions due to heuristic methods.","solution":"import itertools import math def calculate_distance(point1, point2): Helper function to calculate the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def find_shortest_route(coords): Find the shortest route that visits each delivery coordinate exactly once and returns to the starting point. This implementation uses a nearest neighbor heuristic for the Traveling Salesman Problem. Arguments: coords -- list of tuples, where each tuple contains two integers representing the x and y coordinates. Returns: float -- the minimal travel distance. if not coords: return 0.0 total_distance = 0.0 num_points = len(coords) visited = [False] * num_points current_index = 0 visited[0] = True route = [coords[0]] for _ in range(1, num_points): min_distance, next_index = float(\'inf\'), -1 for i in range(num_points): if not visited[i]: distance = calculate_distance(coords[current_index], coords[i]) if distance < min_distance: min_distance = distance next_index = i total_distance += min_distance current_index = next_index visited[current_index] = True route.append(coords[current_index]) # Returning to the start point total_distance += calculate_distance(coords[current_index], coords[0]) # For debug, we can print out the route # print(f\\"Route: {route}\\") return total_distance"},{"question":"**Context**: You are developing a system to manage a queue of tasks with varying priorities. This system should allow tasks to be dynamically added to the queue, processed in order of priority, and efficiently retrieve the highest-priority task. **Task**: Implement a `PriorityQueue` class that uses a min-heap to manage tasks by their priorities. The min-heap should ensure that tasks with the highest priority (lowest numerical value) are processed first. # Function Signature ```python class PriorityQueue: def __init__(self): pass def insert(self, task: str, priority: int) -> None: pass def extract_min(self) -> str: pass def get_min(self) -> str: pass ``` # Requirements 1. **Constructor**: Initialize an empty priority queue. 2. **Insert Function**: Insert a task with a given priority into the queue. 3. **Extract_min Function**: Remove and return the task with the highest priority. If the queue is empty, return `\\"Queue is empty\\"`. 4. **Get_min Function**: Return the task with the highest priority without removing it. If the queue is empty, return `\\"Queue is empty\\"`. # Constraints - Tasks are represented as strings. - Priorities are integers where a lower value indicates higher priority. - Assume all tasks have unique priorities. # Example ```python # Create a priority queue pq = PriorityQueue() # Insert tasks with priorities pq.insert(\\"Task1\\", 3) pq.insert(\\"Task2\\", 5) pq.insert(\\"Task3\\", 1) pq.insert(\\"Task4\\", 2) # Retrieve the minimum priority task without removing it assert pq.get_min() == \\"Task3\\" # Extract the minimum priority task assert pq.extract_min() == \\"Task3\\" assert pq.extract_min() == \\"Task4\\" # Extract from an empty queue assert pq.extract_min() == \\"Queue is empty\\" ``` **Note**: Ensure your implementation correctly maintains the min-heap property during insertions and extractions.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.task_map = {} def insert(self, task: str, priority: int) -> None: heapq.heappush(self.heap, (priority, task)) self.task_map[task] = priority def extract_min(self) -> str: if not self.heap: return \\"Queue is empty\\" priority, task = heapq.heappop(self.heap) del self.task_map[task] return task def get_min(self) -> str: if not self.heap: return \\"Queue is empty\\" priority, task = self.heap[0] return task"},{"question":"# Coding Assessment Question: Scenario: You are tasked with creating a function that sorts a list of tuples based on the second element of each tuple. The function should leverage custom key functions to achieve this sorting. Function Specification: Write a function `sort_tuples_by_second_element(pairs: List[Tuple[Any, Any]]) -> List[Tuple[Any, Any]]` that sorts a list of tuples in ascending order based on the second element of each tuple. Input: * `pairs`: a list of tuples, where each tuple consists of exactly two elements (Any, Any). Output: * Returns a list of tuples sorted by the second element. Constraints: * If the second elements are equal, the order of the original list should be maintained (stable sort). * The list can be empty, or contain tuples with mixed data types as long as the second elements are comparable. Examples: ```python >>> sort_tuples_by_second_element([(1, 3), (3, 2), (2, 1)]) [(2, 1), (3, 2), (1, 3)] >>> sort_tuples_by_second_element([(\\"apple\\", 2), (\\"orange\\", 1), (\\"banana\\", 3)]) [(\\"orange\\", 1), (\\"apple\\", 2), (\\"banana\\", 3)] >>> sort_tuples_by_second_element([(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)]) [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] >>> sort_tuples_by_second_element([(1, \\"b\\"), (3, \\"a\\"), (2, \\"c\\")]) [(3, \\"a\\"), (1, \\"b\\"), (2, \\"c\\")] >>> sort_tuples_by_second_element([(1, [2, 3]), (2, [1, 4]), (3, [3, 5])]) [(2, [1, 4]), (1, [2, 3]), (3, [3, 5])] >>> sort_tuples_by_second_element([]) [] ``` Ensure your function handles edge cases appropriately, utilizes a key function for sorting, and maintains the order of elements with the same second value. Your implementation should be efficient and easy to understand.","solution":"from typing import List, Tuple, Any def sort_tuples_by_second_element(pairs: List[Tuple[Any, Any]]) -> List[Tuple[Any, Any]]: Sorts a list of tuples by the second element in each tuple. :param pairs: List of tuples to be sorted. :return: List of tuples sorted by the second elements. return sorted(pairs, key=lambda x: x[1])"},{"question":"# Coding Question You are tasked with determining the number of unique characters in the longest substring without repeating characters of a given string `s`. **Objective**: Create a function `length_of_longest_substring(s: str) -> int` that takes a string `s` and returns the length of the longest substring without repeating characters. Input/Output Format * **Input**: - `s` (string): A string containing alphanumeric characters and symbols (1 ≤ len(s) ≤ 10^4). * **Output**: - Return an integer representing the length of the longest substring without repeating characters. Constraints - 1 ≤ len(s) ≤ 10^4 - The string contains only alphanumeric characters and symbols. **Performance Requirement**: - The solution should run efficiently for the given constraints. Example ```python >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"au\\") 2 ``` **Instructions**: - Implement the function `length_of_longest_substring(s: str) -> int` - The function should adhere to the input/output requirements and handle edge cases properly.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: input string :return: length of the longest substring without repeating characters start = 0 max_length = 0 used_chars = {} for end, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, end - start + 1) used_chars[char] = end return max_length"},{"question":"# Problem Statement Design a simplified Ride-Sharing system where drivers can register their availability, and riders can request a ride. When a ride request is made, an available driver is assigned to the rider, prioritizing the driver who registered their availability first. Implement the system with the following features: 1. **Driver Registration**: - Allow drivers to register their availability in the system. 2. **Ride Request**: - Allow riders to request a ride. Once a request is made, assign an available driver to the rider based on the registration queue (FIFO - first in, first out). 3. **Driver Availability Status**: - A driver who is assigned a ride is no longer available until manually marked as available again. # Method Signatures ```python class RideSharingSystem: def __init__(self): Initialize the RideSharingSystem with no drivers and an empty queue for ride requests. self.available_drivers = [] self.busy_drivers = set() def register_driver(self, driver_id: int) -> None: Register a driver as available in the system if they are not already registered or busy. Args: - driver_id (int): The unique identifier of the driver. if driver_id not in self.busy_drivers and driver_id not in self.available_drivers: self.available_drivers.append(driver_id) def request_ride(self) -> int | None: Allocate an available driver to the requesting rider. Returns: - int: The id of the assigned driver, or None if no drivers are available. if self.available_drivers: assigned_driver = self.available_drivers.pop(0) self.busy_drivers.add(assigned_driver) return assigned_driver return None def mark_driver_available(self, driver_id: int) -> None: Mark a driver as available again after completing a ride. Args: - driver_id (int): The unique identifier of the driver. if driver_id in self.busy_drivers: self.busy_drivers.remove(driver_id) self.available_drivers.append(driver_id) ``` # Example Usage ```python # Initialize the RideSharingSystem ride_sharing_system = RideSharingSystem() # Register drivers ride_sharing_system.register_driver(101) ride_sharing_system.register_driver(102) ride_sharing_system.register_driver(103) # Request rides driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 101 as it\'s the first registered driver driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 102 as it\'s the next available driver # Mark driver 101 as available again ride_sharing_system.mark_driver_available(101) # Request a ride again driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 103, next in line driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 101, since it was made available again # Register a new driver ride_sharing_system.register_driver(104) # Request a ride driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 104, new driver # No available drivers driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print None as no drivers are currently available # Mark driver 103 as available again ride_sharing_system.mark_driver_available(103) driver_id = ride_sharing_system.request_ride() print(driver_id) # Should print 103 ``` **Your task is to complete the implementation of the `RideSharingSystem` class as specified above. Ensure proper registration, ride allocation, and availability management of drivers.**","solution":"class RideSharingSystem: def __init__(self): Initialize the RideSharingSystem with no drivers and an empty queue for ride requests. self.available_drivers = [] self.busy_drivers = set() def register_driver(self, driver_id: int) -> None: Register a driver as available in the system if they are not already registered or busy. Args: - driver_id (int): The unique identifier of the driver. if driver_id not in self.busy_drivers and driver_id not in self.available_drivers: self.available_drivers.append(driver_id) def request_ride(self) -> int | None: Allocate an available driver to the requesting rider. Returns: - int: The id of the assigned driver, or None if no drivers are available. if self.available_drivers: assigned_driver = self.available_drivers.pop(0) self.busy_drivers.add(assigned_driver) return assigned_driver return None def mark_driver_available(self, driver_id: int) -> None: Mark a driver as available again after completing a ride. Args: - driver_id (int): The unique identifier of the driver. if driver_id in self.busy_drivers: self.busy_drivers.remove(driver_id) self.available_drivers.append(driver_id)"},{"question":"# Quadratic Equation Solver **Scenario**: You\'ve been assigned to develop a fundamental mathematical utility that can solve quadratic equations. A quadratic equation in the form ( ax^2 + bx + c = 0 ) can have two real roots, one real root, or no real roots based on the discriminant value. You need to implement the core functionality to determine and return the real roots of the quadratic equation, if they exist. # Task: Implement a function `solve_quadratic_equation` that takes the coefficients of the quadratic equation as input and returns the real roots. # Function Signature: ```python def solve_quadratic_equation(a: float, b: float, c: float) -> list: ``` # Input: 1. `a` (float): Coefficient of ( x^2 ). 2. `b` (float): Coefficient of ( x ). 3. `c` (float): Constant term. # Output: - Return a list of real roots (float). If there are no real roots, return an empty list. The list should contain the roots in ascending order if there are two distinct roots. # Constraints: - Assume `a` is not zero (i.e., it\'s always a quadratic equation). # Example: ```python print(solve_quadratic_equation(1, -3, 2)) # Output: [1.0, 2.0] print(solve_quadratic_equation(1, 2, 1)) # Output: [-1.0] print(solve_quadratic_equation(1, 0, 1)) # Output: [] ``` # Notes: - For a given quadratic equation ( ax^2 + bx + c = 0 ), the discriminant (( Delta )) is calculated as ( b^2 - 4ac ). - If ( Delta > 0 ), there are two distinct real roots. - If ( Delta = 0 ), there is one real root. - If ( Delta < 0 ), there are no real roots.","solution":"import math def solve_quadratic_equation(a: float, b: float, c: float) -> list: Solve the quadratic equation ax^2 + bx + c = 0 and return the real roots. If there are no real roots, return an empty list. If there are two real roots, return them in ascending order. discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return sorted([root1, root2]) elif discriminant == 0: root = -b / (2*a) return [root] else: return []"},{"question":"# Scenario You are working on a logging system that tracks and reports application errors. Whenever a significant error is detected, the system should log the error details, including the timestamp, error message, severity level, and the stack trace if available. # Task Implement the function `log_error` that records error details to a log file. Your implementation should include: 1. Appending new error entries to the log file. 2. Formatting each log entry with the timestamp, error message, severity level, and stack trace (if available). 3. Ensuring the log file does not exceed a specified size limit by rotating logs (renaming the current log and starting a new one) when necessary. # Function Signature ```python def log_error(log_file: str, error_message: str, severity: str, stack_trace: str = None, max_log_size: int = 1048576) -> None: pass ``` # Input * `log_file` (str): The path to the log file. * `error_message` (str): The error message to log. * `severity` (str): The severity level of the error (e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\"). * `stack_trace` (str): The stack trace associated with the error, if available. Defaults to None. * `max_log_size` (int): Maximum allowed size of the log file in bytes before rotating. Defaults to 1 MB. # Output * None # Constraints * `error_message` will not exceed 2000 characters. * `log_file` will be a valid file path. * `severity` will be one of \\"INFO\\", \\"WARNING\\", \\"ERROR\\". * Rotation should rename the existing log file and create a new log file. # Example ```python log_error(\\"/var/log/app_errors.log\\", \\"Database connection failed\\", \\"ERROR\\", \\"Traceback (most recent call last):n ...\\", 1048576) ``` # Notes * Log entry should follow this format: `[TIMESTAMP] [SEVERITY] [ERROR_MESSAGE] [STACK_TRACE]`. For example: ``` [2023-10-05 14:23:45] [ERROR] Database connection failed Traceback (most recent call last):n ... ``` * Use `datetime.now()` to get the current timestamp. * Check the size of the log file before appending and rotate if necessary. * Properly handle file operations and ensure no data loss during log rotation.","solution":"import os from datetime import datetime def log_error(log_file: str, error_message: str, severity: str, stack_trace: str = None, max_log_size: int = 1048576) -> None: Logs the error details to the specified log file. Rotates the log file if it exceeds max_log_size. :param log_file: The path to the log file. :param error_message: The error message to log. :param severity: The severity level, e.g., \\"INFO\\", \\"WARNING\\", \\"ERROR\\". :param stack_trace: The stack trace associated with the error, if available. :param max_log_size: Maximum allowed size for the log file in bytes before rotation. Defaults to 1MB. timestamp = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") log_entry = f\\"[{timestamp}] [{severity}] {error_message}\\" if stack_trace: log_entry += f\\" {stack_trace}\\" log_entry += \\"n\\" if os.path.exists(log_file) and os.path.getsize(log_file) > max_log_size: os.rename(log_file, log_file + \\".old\\") with open(log_file, \'a\') as file: file.write(log_entry)"},{"question":"# Coding Question: Efficient Container Area Finder You are tasked with developing a feature for a graphics application that calculates the maximum possible area of water that can be held between containers represented by vertical lines on a coordinate plane. Each line’s height is provided, and the lines are spaced equally along the x-axis. # Requirements: 1. Implement the `maximize_water_container(heights: list[int]) -> int` function. 2. The function should efficiently determine the maximum area of water that can be trapped between any two vertical lines. 3. Utilize an optimal approach in terms of time complexity, aiming better than a brute-force O(N^2) approach. # Input: * `heights`: A list of integers where each integer represents the height of a vertical line. # Output: * An integer representing the maximum area of water that can be held between any two lines. # Constraints: * The list `heights` is non-empty and contains at least two elements. * Each height value is a non-negative integer. # Performance Requirements: * Your solution must achieve better performance than the naive O(N^2) approach, ideally O(N). # Function Signature: ```python def maximize_water_container(heights: list[int]) -> int: pass ``` # Example: ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] assert maximize_water_container(heights) == 49 # Expected maximum area heights = [1, 1] assert maximize_water_container(heights) == 1 # Expected maximum area heights = [4, 3, 2, 1, 4] assert maximize_water_container(heights) == 16 # Expected maximum area heights = [1, 2, 1] assert maximize_water_container(heights) == 2 # Expected maximum area ``` # Additional Notes: * Consider edge cases like minimum input size and when all heights are the same. * Adequate testing with diverse `heights` lists will be crucial to ensure your function\'s efficiency and correctness. This new question is designed to fit seamlessly with the provided advanced median finder question, matching in style, complexity, topic, and length while introducing a unique problem scenario related to calculating maximum areas efficiently.","solution":"def maximize_water_container(heights: list[int]) -> int: Returns the maximum area of water that can be trapped between two vertical lines. :param heights: List[int] - A list of integers representing the height of vertical lines. :return: int - The maximum area of water that can be contained between two lines. left, right = 0, len(heights) - 1 max_area = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_area = max(max_area, width * height) # Move the pointer that is at the shorter line if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"# Logistic Regression for Classification Scenario You are working on a machine learning project where you need to implement and evaluate a logistic regression model to classify whether a given individual earns more than 50K annually based on their features from a provided dataset. Your task is to preprocess the data, train the model, and evaluate its performance. Problem Statement Implement a function, `income_classification(file_path: str) -> dict`, that: 1. Takes the file path of a CSV data file as input. 2. The CSV file contains columns such as age, workclass, education, marital-status, occupation, relationship, race, gender, hours-per-week, native-country, and income. 3. Preprocesses the data: - Handle missing values. - Encode categorical variables. - Normalize numerical features. 4. Split the data into training and testing sets. 5. Train a logistic regression model on the training set. 6. Evaluate the model on the testing set and return a dictionary containing: - `\\"accuracy\\"`: the accuracy score of the model. - `\\"precision\\"`: the precision score of the model. - `\\"recall\\"`: the recall score of the model. - `\\"f1_score\\"`: the F1 score of the model. Input - `file_path`: A string representing the file path to the CSV data file. Output - A dictionary with keys `\\"accuracy\\"`, `\\"precision\\"`, `\\"recall\\"`, and `\\"f1_score\\"`, and their respective scores as float values. Constraints - Use scikit-learn for model implementation and evaluation. - Assume the `income` column is the target variable with values `<=50K` and `>50K`. - The dataset will have no header row. Example Assume a sample CSV file `adult_data.csv` with the following content: ``` 39, State-gov, Bachelors, Never-married, Adm-clerical, Not-in-family, White, Male, 40, United-States, <=50K 50, Self-emp-not-inc, Bachelors, Married-civ-spouse, Exec-managerial, Husband, White, Male, 13, United-States, >50K ... ``` ```python result = income_classification(\\"adult_data.csv\\") print(result) # Example output: {\'accuracy\': 0.85, \'precision\': 0.76, \'recall\': 0.73, \'f1_score\': 0.74} ``` This should read data from `adult_data.csv`, preprocess it, train a logistic regression model, evaluate it, and return the performance metrics.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler, LabelEncoder from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score def income_classification(file_path: str) -> dict: # Load the data column_names = [\\"age\\", \\"workclass\\", \\"education\\", \\"marital-status\\", \\"occupation\\", \\"relationship\\", \\"race\\", \\"gender\\", \\"hours-per-week\\", \\"native-country\\", \\"income\\"] data = pd.read_csv(file_path, names=column_names) # Handle missing values by filling with the most frequent value for col in data.columns: data[col].fillna(data[col].mode()[0], inplace=True) # Encode categorical variables label_encoder = LabelEncoder() for col in data.select_dtypes(include=[\'object\']).columns: data[col] = label_encoder.fit_transform(data[col]) # Separate features and target variable X = data.drop(\\"income\\", axis=1) y = data[\\"income\\"] # Normalize numerical features scaler = StandardScaler() X = scaler.fit_transform(X) # Split the data into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Train a logistic regression model model = LogisticRegression() model.fit(X_train, y_train) # Predictions on the test set y_pred = model.predict(X_test) # Evaluation metrics accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) # Return the metrics return { \\"accuracy\\": accuracy, \\"precision\\": precision, \\"recall\\": recall, \\"f1_score\\": f1 }"},{"question":"# String Frequency Counter Problem You are given a list of strings, and you need to count the frequency of each unique string. Implement the function `string_frequency_counter` which returns a dictionary where the keys are the unique strings, and the values are their corresponding frequencies. Function Signature ```python def string_frequency_counter(strings: list) -> dict: ``` Input - `strings` (list): A list of strings where each string can be of any length (0 ≤ len(strings[i]) ≤ 1000). Output - Returns a dictionary where the keys are the unique strings and the values are their corresponding frequencies. Constraints - The input list can be empty. - If the input list is empty, return an empty dictionary. Examples ```python # Example 1 assert string_frequency_counter([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) == {\\"apple\\": 3, \\"banana\\": 2, \\"cherry\\": 1} # Example 2 assert string_frequency_counter([\\"dog\\", \\"cat\\", \\"dog\\", \\"dog\\", \\"cat\\", \\"dog\\"]) == {\\"dog\\": 4, \\"cat\\": 2} # Example 3 assert string_frequency_counter([\\"a\\", \\"b\\", \\"a\\", \\"a\\", \\"c\\", \\"b\\", \\"a\\", \\"c\\", \\"c\\"]) == {\\"a\\": 4, \\"b\\": 2, \\"c\\": 3} # Example 4 assert string_frequency_counter([]) == {} # Example 5 assert string_frequency_counter([\\"x\\", \\"y\\", \\"z\\", \\"x\\", \\"x\\", \\"y\\"]) == {\\"x\\": 3, \\"y\\": 2, \\"z\\": 1} ``` Detailed Explanation 1. **Dictionary Creation**: - Initialize an empty dictionary to store string frequencies. 2. **Frequency Counting**: - Iterate over each string in the list. - If the string is already a key in the dictionary, increment its value by 1. - If the string is not present in the dictionary, add it with a value of 1. 3. **Return**: - Return the dictionary containing the frequencies of all unique strings. Provide a robust implementation of the function `string_frequency_counter` following these guidelines and ensuring that all edge cases are handled correctly.","solution":"def string_frequency_counter(strings: list) -> dict: Returns a dictionary where the keys are the unique strings and the values are their corresponding frequencies. :param strings: list of strings :return: dictionary with string frequencies frequency_counter = {} for string in strings: if string in frequency_counter: frequency_counter[string] += 1 else: frequency_counter[string] = 1 return frequency_counter"},{"question":"Questions for Coding Assessment # Context In the realm of quantum computing, the Quantum Fourier Transform (QFT) is a pivotal algorithm similar to the classical discrete Fourier Transform (DFT). It is extensively employed in quantum algorithms, including Shor\'s algorithm for integer factorization, and quantum phase estimation. The task is to design and implement the QFT for a given number of qubits using Python\'s Qiskit library. # Task Write a Python function `quantum_fourier_transform()` that constructs the quantum circuit for the QFT for a specified number of qubits. It should simulate the circuit and return the result counts after measurement. # Function Signature ```python def quantum_fourier_transform(number_of_qubits: int) -> dict: pass ``` # Input - `number_of_qubits`: An integer representing the number of qubits in the circuit. (1 ≤ number_of_qubits ≤ 10) # Output - A dictionary with measurement results where keys are binary strings representing states and values are the counts of occurrences. # Requirements - Implement a complete quantum Fourier transform circuit. - Simulate the circuit using 10000 shots. - Ensure error handling for invalid inputs (non-integer, negative, or too large values). # Constraints 1. The function should raise a `TypeError` if the input is not an integer. 2. The function should raise a `ValueError` for integers ≤ 0 or > 10. 3. The function should consider integer type and valid range before constructing the quantum circuit. # Example ```python result = quantum_fourier_transform(2) print(result) # Expected type: {\'00\': 2500, \'01\': 2500, \'10\': 2500, \'11\': 2500} ``` # Notes - Utilize Qiskit library functions such as `QuantumCircuit`, `QuantumRegister`, `ClassicalRegister`, and `Aer, execute`. - The circuit should use Hadamard gates (H), Controlled-Phase gates (CP), and SWAP gates properly to construct the QFT. - The measurement should ensure all qubits are measured and results collected over 10000 shots using a Qasm simulator backend. # Reference: - [Quantum Fourier Transform](https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html) # Context Determining whether a number is prime is a critical aspect in several fields such as cryptography. One efficient probabilistic algorithm used for this purpose is the Miller-Rabin primality test. This test can identify large prime numbers quickly but may occasionally return false positives for composite numbers. The task is to utilize the Miller-Rabin test to check the primality of a number. # Task Write a Python function `is_prime()` that implements the Miller-Rabin primality test to verify if a given number is prime. The function should handle multiple test rounds to reduce the probability of false positives. # Function Signature ```python def is_prime(n: int, k: int = 5) -> bool: pass ``` # Input - `n`: An integer to be tested for primality. (2 ≤ n ≤ 10^9) - `k`: An optional integer representing the number of accuracy rounds. Default value is 5. # Output - A boolean value `True` if the number is probably prime, otherwise `False`. # Requirements - Implement the Miller-Rabin primality test. - Perform `k` rounds of testing to improve accuracy. - Handle invalid inputs and raise appropriate errors. # Constraints 1. The function should raise a `ValueError` if `n` is less than 2 or greater than 10^9. 2. The function should raise a `TypeError` if `n` or `k` is not an integer. 3. The function defaults to 5 accuracy rounds if `k` is not provided. # Example ```python result = is_prime(17) print(result) # Expected output: True result = is_prime(18) print(result) # Expected output: False ``` # Notes - The Miller-Rabin test should be implemented as described in [Miller-Rabin Primality Test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test). - Use modular exponentiation to handle large numbers efficiently. - Return `True` for prime numbers and `False` for composite numbers after `k` rounds of testing.","solution":"import math def miller_rabin_test(d, n): Perform the Miller-Rabin test on the number n. :param d: The odd part of n-1 (i.e., n-1 = 2^r * d). :param n: The number to be tested for primality. :return: False if n is composite, True otherwise. import random a = 2 + (random.randint(1, n - 4) % (n - 4)) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False def is_prime(n, k=5): Determine if a number n is prime using the Miller-Rabin primality test. :param n: The number to be tested for primality. :param k: Optional parameter for number of accuracy rounds. Default value is 5. :return: True if the number is probably prime, False otherwise. if not isinstance(n, int) or not isinstance(k, int): raise TypeError(\\"Both n and k should be integers\\") if n <= 1 or n > 10**9: raise ValueError(\\"n must be in the range [2, 10^9]\\") if n <= 3: return True if n % 2 == 0: return False d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin_test(d, n): return False return True"},{"question":"# Game Board Path Finder Context: In many board games, a player must navigate from a starting point to a goal while avoiding obstacles. We want to implement functionality to find the shortest path from the start to the goal on a rectangular game board, represented as a grid. Task: Implement a function `find_shortest_path(board: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Union[int, str]` that finds the shortest path from the start to the goal on the game board. Requirements: 1. **Function Definition** - The function will accept a `board` represented as a list of lists where `0` represents an open path and `1` represents an obstacle. - `start` and `goal` are tuples representing coordinates on the `board` (e.g., `(0, 0)`). 2. **Pathfinding Algorithm** - Implement an appropriate pathfinding algorithm such as Breadth-First Search (BFS) to find the shortest path from the `start` to the `goal`. 3. **Output Format** - If a path exists, return the length of the shortest path (number of steps). - If no path exists, return the string \\"No Path\\". 4. **Constraints** - The `board` may be irregular in shape but will be rectangular. - Both `start` and `goal` are guaranteed to be within the bounds of the board. - The `start` will never be an obstacle. - The `goal` may be adjacent to or the same as `start`. Input/Output: - **Input**: ``` board = [ [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0] ] start = (0, 0) goal = (3, 3) ``` - **Output**: ``` 6 ``` Constraints: - The board size is at most 100x100. - There are no guarantees that a path exists between `start` and `goal`. Example Usage: ```python >>> board = [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 1], ... [1, 1, 0, 0] ... ] >>> start = (0, 0) >>> goal = (3, 3) >>> find_shortest_path(board, start, goal) 6 >>> board = [ ... [0, 1, 1, 0], ... [0, 1, 0, 1], ... [1, 1, 0, 1], ... [1, 1, 0, 0] ... ] >>> start = (0, 0) >>> goal = (3, 3) >>> find_shortest_path(board, start, goal) \'No Path\' ``` Function Signature: ```python from typing import List, Tuple, Union def find_shortest_path(board: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Union[int, str]: # Implement the function ```","solution":"from typing import List, Tuple, Union from collections import deque def find_shortest_path(board: List[List[int]], start: Tuple[int, int], goal: Tuple[int, int]) -> Union[int, str]: Finds the shortest path in terms of steps from start to goal in a board represented as a grid, where 0 indicates an open path and 1 indicates an obstacle. if start == goal: return 0 rows, cols = len(board), len(board[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # four possible movements: up, down, left, right visited = set() queue = deque([(start, 0)]) # stores (current_position, current_path_length) visited.add(start) while queue: (current_x, current_y), current_path_length = queue.popleft() for direction in directions: next_x, next_y = current_x + direction[0], current_y + direction[1] if 0 <= next_x < rows and 0 <= next_y < cols and (next_x, next_y) not in visited and board[next_x][next_y] == 0: if (next_x, next_y) == goal: return current_path_length + 1 queue.append(((next_x, next_y), current_path_length + 1)) visited.add((next_x, next_y)) return \\"No Path\\""},{"question":"# Coding Question: Calculating the Surface Area of a Torus Extend the functionality of surface area calculations to include the surface area of a torus. A torus is a doughnut-shaped surface defined by a circle of radius (r) that revolves around an axis in its plane at a distance (R) from the circle’s center. Implement the function `surface_area_torus(R: float, r: float) -> float` that calculates the surface area using the formula: [ A = 4 pi^2 R r ] Input/Output Specifications * **Input**: Two floating-point numbers (R) and (r) representing the major radius (the distance from the center of the tube to the center of the torus) and the minor radius (the radius of the tube), respectively. * **Output**: A floating-point number representing the surface area of the torus. Constraints and Considerations * The function should raise a `ValueError` if any of the input values are non-positive. * Handle invalid input types gracefully by raising a `TypeError`. Example ```python >>> surface_area_torus(5, 3) 592.176 >>> surface_area_torus(10, 2) 789.568 >>> surface_area_torus(-5, 3) Traceback (most recent call last): ... ValueError: surface_area_torus() only accepts positive non-zero values ```","solution":"import math def surface_area_torus(R: float, r: float) -> float: Calculate the surface area of a torus given the major radius R and minor radius r. Parameters: R (float): Major radius r (float): Minor radius Returns: float: Surface area of the torus Raises: ValueError: If R or r is not positive. TypeError: If R or r is not a float or int. if not isinstance(R, (int, float)) or not isinstance(r, (int, float)): raise TypeError(\\"surface_area_torus() only accepts numbers.\\") if R <= 0 or r <= 0: raise ValueError(\\"surface_area_torus() only accepts positive non-zero values\\") return 4 * math.pi**2 * R * r"},{"question":"# Problem Statement You are required to design and implement a scheduler to manage a list of tasks. Each task has a start time, end time, and a priority score. Your scheduler should support querying for the highest priority task that overlaps with a given time interval. The priority score of a task determines its importance, with higher scores indicating higher priority. # Requirements 1. Implement a `Task` class to store the details of each task. 2. Implement a `Scheduler` class that supports adding tasks and querying for the highest priority task that overlaps with a given time interval. # Constraints - The start time and end time of tasks are given as integer timestamps. - Tasks can partially overlap. - Two tasks with the same priority score are considered equal in priority. # Function Signatures For Task Class ```python class Task: def __init__(self, start: int, end: int, priority: int): Initialize the task with its start time, end time, and priority score. def __str__(self) -> str: String representation of the task for easy reading. def __lt__(self, other: \\"Task\\") -> bool: Less than comparison operator, primarily to support sorting and comparisons. ``` For Scheduler Class ```python class Scheduler: def __init__(self): Initialize an empty scheduler. def add_task(self, task: Task): Add a new task to the scheduler. def query_highest_priority(self, start: int, end: int) -> Optional[Task]: Query for the highest priority task that overlaps with the given time interval [start, end]. ``` # Example Usage - Add tasks with different start times, end times, and priority scores. - Query to find the highest priority task that overlaps with a given time interval. ```python scheduler = Scheduler() task1 = Task(1, 4, 10) task2 = Task(3, 5, 20) task3 = Task(6, 8, 15) scheduler.add_task(task1) scheduler.add_task(task2) scheduler.add_task(task3) # Query for overlap in time interval [2, 7] highest_priority_task = scheduler.query_highest_priority(2, 7) print(highest_priority_task) # Expected to be task2 # Query for overlap in time interval [5, 6] highest_priority_task = scheduler.query_highest_priority(5, 6) print(highest_priority_task) # Expected to be task3 ``` Implement the necessary classes and methods to add tasks to the scheduler and query for the highest priority task within a specified time interval.","solution":"from typing import Optional class Task: def __init__(self, start: int, end: int, priority: int): self.start = start self.end = end self.priority = priority def __str__(self) -> str: return f\\"Task(start: {self.start}, end: {self.end}, priority: {self.priority})\\" def __lt__(self, other: \\"Task\\") -> bool: return self.priority < other.priority class Scheduler: def __init__(self): self.tasks = [] def add_task(self, task: Task): self.tasks.append(task) def query_highest_priority(self, start: int, end: int) -> Optional[Task]: highest_priority_task = None for task in self.tasks: if task.end >= start and task.start <= end: if highest_priority_task is None or task.priority > highest_priority_task.priority: highest_priority_task = task return highest_priority_task"},{"question":"# Question: Implement a Movie Rental System with Priority Handling You are tasked with creating a Movie Rental System that allows users to rent and return movies. The system should prioritize movies based on their popularity (number of rentals). Additionally, it should manage movie availability and keep track of rental histories. **Features to Implement**: 1. **Rent Movie**: Allow a user to rent a movie. If the movie is not available, inform the user. 2. **Return Movie**: Allow a user to return a rented movie, making it available for others. 3. **Check Availability**: Check if a movie is available for rent. 4. **Popular Movies**: Retrieve the top `n` most popular movies based on the number of rentals. 5. **Rental History**: Allow a user to view their rental history. # Function Definitions: ```python class MovieRentalSystem: def __init__(self) -> None: # Initialize the system with an empty set of movies and rental history self.movies = {} self.rental_history = {} def add_movie(self, movie_id: int, quantity: int) -> None: \'\'\' Add a movie to the system with the initial quantity. Args: movie_id (int): The unique ID of the movie. quantity (int): The number of copies available for rent. \'\'\' pass def rent_movie(self, user_id: int, movie_id: int) -> str: \'\'\' Rent a movie to a user if available. Args: user_id (int): The unique ID of the user. movie_id (int): The unique ID of the movie. Returns: str: Confirmation message or availability notification. \'\'\' pass def return_movie(self, user_id: int, movie_id: int) -> str: \'\'\' Return a rented movie back to the system. Args: user_id (int): The unique ID of the user. movie_id (int): The unique ID of the movie. Returns: str: Confirmation message. \'\'\' pass def is_movie_available(self, movie_id: int) -> bool: \'\'\' Check if a movie is available for rent. Args: movie_id (int): The unique ID of the movie. Returns: bool: True if available, False otherwise. \'\'\' pass def get_popular_movies(self, top_n: int) -> list[int]: \'\'\' Retrieve the top N most popular movies based on rentals. Args: top_n (int): The number of top movies to retrieve. Returns: list[int]: List of movie IDs, sorted by popularity. \'\'\' pass def get_rental_history(self, user_id: int) -> list[int]: \'\'\' Retrieve the rental history of a user. Args: user_id (int): The unique ID of the user. Returns: list[int]: List of movie IDs rented by the user. \'\'\' pass ``` Input Format: 1. For `add_movie`: `(movie_id, quantity)` where `movie_id` is an integer representing the movie\'s unique identifier, and `quantity` is the number of copies available. 2. For `rent_movie`: `(user_id, movie_id)` where `user_id` and `movie_id` are integers representing unique identifiers. 3. For `return_movie`: `(user_id, movie_id)` where `user_id` and `movie_id` are integers representing unique identifiers. 4. For `is_movie_available`: `(movie_id)` an integer representing the movie\'s unique identifier. 5. For `get_popular_movies`: `(top_n)` an integer representing the number of top movies to retrieve. 6. For `get_rental_history`: `(user_id)` an integer representing the user\'s unique identifier. Output Format: 1. For `rent_movie`: Returns a confirmation message string indicating the rental status. 2. For `return_movie`: Returns a confirmation message string indicating the return status. 3. For `is_movie_available`: Returns `True` if the movie is available, otherwise `False`. 4. For `get_popular_movies`: Returns a list of the top N movie IDs sorted by popularity. 5. For `get_rental_history`: Returns a list of movie IDs representing the user\'s rental history. Constraints: - Ensure accurate management of movie availability to avoid over-renting. - Handle rental and return operations efficiently to minimize delays. - Maintain the popularity list dynamically to always reflect the latest rental activities. Example Usage: ```python # Creating an instance of MovieRentalSystem movie_system = MovieRentalSystem() # Adding movies to the system movie_system.add_movie(1, 5) # Movie ID 1 with 5 copies movie_system.add_movie(2, 3) # Movie ID 2 with 3 copies # Renting movies print(movie_system.rent_movie(101, 1)) # User 101 rents Movie 1 print(movie_system.rent_movie(102, 1)) # User 102 rents Movie 1 # Checking movie availability print(movie_system.is_movie_available(1)) # Output: True # Returning movies print(movie_system.return_movie(101, 1)) # User 101 returns Movie 1 # Getting popular movies print(movie_system.get_popular_movies(2)) # Output: [1, 2] # Viewing rental history print(movie_system.get_rental_history(101)) # Output: [1] ```","solution":"class MovieRentalSystem: def __init__(self) -> None: self.movies = {} self.rented_movies = {} self.rental_history = {} self.popularity = {} def add_movie(self, movie_id: int, quantity: int) -> None: self.movies[movie_id] = self.movies.get(movie_id, 0) + quantity self.popularity[movie_id] = self.popularity.get(movie_id, 0) def rent_movie(self, user_id: int, movie_id: int) -> str: if self.movies.get(movie_id, 0) > 0: self.movies[movie_id] -= 1 self.rented_movies.setdefault(user_id, []).append(movie_id) self.rental_history.setdefault(user_id, []).append(movie_id) self.popularity[movie_id] += 1 return f\\"Movie {movie_id} rented successfully to user {user_id}.\\" else: return f\\"Movie {movie_id} is not available.\\" def return_movie(self, user_id: int, movie_id: int) -> str: if user_id in self.rented_movies and movie_id in self.rented_movies[user_id]: self.movies[movie_id] += 1 self.rented_movies[user_id].remove(movie_id) return f\\"Movie {movie_id} returned successfully by user {user_id}.\\" else: return f\\"Movie {movie_id} was not rented by user {user_id}.\\" def is_movie_available(self, movie_id: int) -> bool: return self.movies.get(movie_id, 0) > 0 def get_popular_movies(self, top_n: int) -> list[int]: sorted_movies = sorted(self.popularity.items(), key=lambda item: item[1], reverse=True) return [movie_id for movie_id, _ in sorted_movies[:top_n]] def get_rental_history(self, user_id: int) -> list[int]: return self.rental_history.get(user_id, [])"},{"question":"# Flight Reservation System You need to implement a rudimentary flight reservation system. The system allows you to add flights, reserve seats, and check seat availability. # Requirements 1. **Class**: `Flight` - **Attributes**: - `flight_number` (str): Unique identifier for the flight. - `capacity` (int): Total number of seats on the flight. - `reservations` (List[bool]): List of boolean values representing reserved (True) or available (False) seats. - **Methods**: - `reserve_seat(seat_number: int) -> bool` - Reserves a seat if available. - Returns `True` if the reservation was successful, `False` otherwise. - `is_seat_available(seat_number: int) -> bool` - Checks if a seat is available. - Returns `True` if the seat is available, `False` if reserved. 2. **Class**: `FlightReservationSystem` - **Attributes**: - `flights` (Dict[str, Flight]): A dictionary mapping flight numbers to `Flight` objects. - **Methods**: - `add_flight(flight_number: str, capacity: int) -> None` - Adds a new flight to the system. - `reserve(flight_number: str, seat_number: int) -> bool` - Reserves a specified seat on a specified flight. - Returns `True` if the reservation was successful, `False` otherwise. - `check_availability(flight_number: str, seat_number: int) -> bool` - Checks if a specified seat on a specified flight is available. - Returns `True` if the seat is available, `False` if reserved. # Examples ```python # Create the flight reservation system system = FlightReservationSystem() # Add flights system.add_flight(\\"AA123\\", 100) system.add_flight(\\"BB456\\", 50) # Reserve seats assert system.reserve(\\"AA123\\", 10) == True assert system.reserve(\\"AA123\\", 10) == False # Seat already reserved assert system.check_availability(\\"AA123\\", 10) == False assert system.check_availability(\\"AA123\\", 11) == True assert system.reserve(\\"BB456\\", 20) == True assert system.check_availability(\\"BB456\\", 20) == False # Attempt to reserve or check availability on non-existent flights or seats out of range assert system.reserve(\\"CC789\\", 1) == False # Flight does not exist assert system.reserve(\\"AA123\\", 101) == False # Seat number out of range assert system.check_availability(\\"BB456\\", 51) == False # Seat number out of range ``` # Notes - The flight number is a unique string identifier for each flight. - Seat numbers are 0-indexed. - Handle edge cases such as reserving a seat on a non-existent flight, checking availability of a seat with an out-of-bounds index, etc. - You do not need to handle concurrency issues.","solution":"class Flight: def __init__(self, flight_number: str, capacity: int): self.flight_number = flight_number self.capacity = capacity self.reservations = [False] * capacity def reserve_seat(self, seat_number: int) -> bool: if 0 <= seat_number < self.capacity and not self.reservations[seat_number]: self.reservations[seat_number] = True return True return False def is_seat_available(self, seat_number: int) -> bool: if 0 <= seat_number < self.capacity: return not self.reservations[seat_number] return False class FlightReservationSystem: def __init__(self): self.flights = {} def add_flight(self, flight_number: str, capacity: int) -> None: if flight_number not in self.flights: self.flights[flight_number] = Flight(flight_number, capacity) def reserve(self, flight_number: str, seat_number: int) -> bool: if flight_number in self.flights: return self.flights[flight_number].reserve_seat(seat_number) return False def check_availability(self, flight_number: str, seat_number: int) -> bool: if flight_number in self.flights: return self.flights[flight_number].is_seat_available(seat_number) return False"},{"question":"# File Compression and Decompression Implementation Develop a basic compression and decompression tool using the Run-Length Encoding (RLE) algorithm in Python. The tool will include functions to compress and decompress text, and handle file operations for reading and writing. # Requirements: 1. **Compression Function** - Implement a function to compress a given string using RLE. - `compress(text: str) -> str` 2. **Decompression Function** - Implement a function to decompress a RLE-compressed string back to the original. - `decompress(compressed_text: str) -> str` 3. **File Handling Functions** - Write functions to handle file operations for compression and decompression. - `compress_file(input_filename: str, output_filename: str) -> None` - `decompress_file(input_filename: str, output_filename: str) -> None` # Constraints: - The compression function should convert consecutive repeated characters into the character followed by the count. - Example: `\\"aaaabbbcc\\"` should be compressed to `\\"a4b3c2\\"`. - The decompression function should accurately reconstruct the original text from the compressed format. - Example: `\\"a4b3c2\\"` should be decompressed to `\\"aaaabbbcc\\"`. - The functions should handle file read/write errors gracefully. # Example Usage: ```python def main() -> None: filename = \\"sample.txt\\" response = input(r\\"CompressDecompress [cd]: \\") if response.lower().startswith(\\"c\\"): mode = \\"compress\\" elif response.lower().startswith(\\"d\\"): mode = \\"decompress\\" if mode == \\"compress\\": input_filename = \\"original_text.txt\\" compressed_filename = \\"compressed_text.txt\\" compress_file(input_filename, compressed_filename) print(f\\"Compressed file saved as {compressed_filename}\\") elif mode == \\"decompress\\": compressed_filename = \\"compressed_text.txt\\" decompressed_filename = \\"decompressed_text.txt\\" decompress_file(compressed_filename, decompressed_filename) print(f\\"Decompressed file saved as {decompressed_filename}\\") if __name__ == \'__main__\': main() ``` Implement these functions and test with appropriate input files to ensure correctness and performance.","solution":"def compress(text: str) -> str: Compresses a given string using Run-Length Encoding (RLE). if not text: return \\"\\" compressed_text = [] current_char = text[0] count = 0 for char in text: if char == current_char: count += 1 else: compressed_text.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed_text.append(f\\"{current_char}{count}\\") return \'\'.join(compressed_text) def decompress(compressed_text: str) -> str: Decompresses a given RLE-compressed string back to its original form. if not compressed_text: return \\"\\" decompressed_text = [] i = 0 while i < len(compressed_text): char = compressed_text[i] count = \\"\\" i += 1 while i < len(compressed_text) and compressed_text[i].isdigit(): count += compressed_text[i] i += 1 decompressed_text.append(char * int(count)) return \'\'.join(decompressed_text) def compress_file(input_filename: str, output_filename: str) -> None: Compresses the content of a file using RLE and writes the result to another file. try: with open(input_filename, \'r\') as file: text = file.read() compressed_text = compress(text) with open(output_filename, \'w\') as file: file.write(compressed_text) except IOError as e: print(f\\"File error: {e}\\") def decompress_file(input_filename: str, output_filename: str) -> None: Decompresses the content of a compressed file back to its original form and writes it to another file. try: with open(input_filename, \'r\') as file: compressed_text = file.read() decompressed_text = decompress(compressed_text) with open(output_filename, \'w\') as file: file.write(decompressed_text) except IOError as e: print(f\\"File error: {e}\\")"},{"question":"# Circular Linked List Manipulation You are required to implement a circular linked list and perform certain operations on it. Specifically, you need to create a circular linked list from a given list of values and implement functions to traverse the list and delete a node with a specific value. Requirements 1. **`CircularLinkedList` class**: * **Methods**: * `__init__(self)`: Initializes an empty circular linked list. * `create_from_list(self, values: list[int])`: Creates and populates the circular linked list from a given list of values. * `traverse(self) -> list[int]`: Traverses the circular linked list and returns the values in a list. * `delete_node(self, value: int) -> bool`: Deletes the first occurrence of the node with the specified value. Returns `True` if the deletion was successful, `False` otherwise. * **Class Signature**: ```python class CircularLinkedList: def __init__(self): def create_from_list(self, values: list[int]): def traverse(self) -> list[int]: def delete_node(self, value: int) -> bool: ``` Constraints * Input list values must be non-negative integers. * The input list can be empty. * Deleting a node in an empty list should return `False`. Example ```python # Example usage of CircularLinkedList cll = CircularLinkedList() cll.create_from_list([1, 2, 3, 4, 5]) print(cll.traverse()) # Output: [1, 2, 3, 4, 5] deletion_result = cll.delete_node(3) print(deletion_result) # Output: True print(cll.traverse()) # Output: [1, 2, 4, 5] deletion_result = cll.delete_node(10) print(deletion_result) # Output: False print(cll.traverse()) # Output: [1, 2, 4, 5] ``` Notes * Ensure that your implementation adequately handles the circular nature of the list. * If multiple nodes have the same value, only the first one encountered during traversal should be deleted. Happy coding!","solution":"class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def create_from_list(self, values: list[int]): if not values: self.head = None return self.head = Node(values[0]) last = self.head for value in values[1:]: new_node = Node(value) last.next = new_node last = new_node last.next = self.head # Make it circular def traverse(self) -> list[int]: if not self.head: return [] result = [] current = self.head while True: result.append(current.data) current = current.next if current == self.head: break return result def delete_node(self, value: int) -> bool: if not self.head: return False current = self.head prev = None while True: if current.data == value: if prev: prev.next = current.next else: if self.head.next == self.head: self.head = None else: prev = self.head while prev.next != self.head: prev = prev.next self.head = self.head.next prev.next = self.head return True prev = current current = current.next if current == self.head: return False"},{"question":"# Question Prompt We\'ve designed a simplified version of a logistics system for a warehouse. The system needs to optimize the storage allocation and retrieval of items to minimize the total amount of movement. Implement the missing parts in the provided class `Warehouse`, ensuring efficient operations for insertion, retrieval, and storage strategy. 1. **Insert Item**: Place an item in the nearest available slot from the entrance. 2. **Retrieve Item**: Retrieve an item by minimizing the distance traveled within the warehouse. 3. **Optimization Strategy**: Implement a simple storage optimization strategy which re-arranges items periodically to ensure frequently accessed items are closer to the entrance. Expected Input and Output - **Input**: - `action`: A string indicating the action to be performed (\\"insert\\", \\"retrieve\\", \\"optimize\\"). - `item_id`: An integer representing the unique identifier for the item (applicable for \\"insert\\" and \\"retrieve\\" actions). - `slots`: A list of lists representing the warehouse grid. - **Output**: - For \\"insert\\" action, the coordinates where the item was placed. - For \\"retrieve\\" action, the coordinates from where the item was retrieved. - For \\"optimize\\" action, the updated layout of the warehouse grid. Constraints and Limitations - Ensure to minimize movement distances for all operations. - The optimization strategy should be callable periodically and should effectively re-organize the grid. - The grid (warehouse) can be as large as 50x50 with up to 5000 items being handled. ```python class Warehouse: def __init__(self, width: int, height: int): self.width = width self.height = height self.grid = [[None for _ in range(width)] for _ in range(height)] self.frequency = {} # To track access frequency of items def insert_item(self, item_id: int) -> tuple: Places an item in the nearest available slot from the entrance (0, 0). # Implement insertion logic here for y in range(self.height): for x in range(self.width): if self.grid[y][x] is None: self.grid[y][x] = item_id return (y, x) raise ValueError(\\"Warehouse is full\\") def retrieve_item(self, item_id: int) -> tuple: Retrieves an item and returns its previous coordinates. # Implement retrieval logic here for y in range(self.height): for x in range(self.width): if self.grid[y][x] == item_id: self.grid[y][x] = None self.frequency[item_id] = self.frequency.get(item_id, 0) + 1 return (y, x) raise ValueError(\\"Item not found\\") def optimize_storage(self) -> None: Re-arranges items to bring frequently accessed items closer to the entrance. # Implement optimization strategy here items = [(self.frequency.get(self.grid[y][x], 0), self.grid[y][x]) for y in range(self.height) for x in range(self.width) if self.grid[y][x] is not None] items.sort(reverse=True, key=lambda x: x[0]) # Sort items by frequency index = 0 for y in range(self.height): for x in range(self.width): if index < len(items): self.grid[y][x] = items[index][1] index += 1 else: self.grid[y][x] = None def perform_action(self, action: str, item_id: int = None) -> any: if action == \\"insert\\": return self.insert_item(item_id) elif action == \\"retrieve\\": return self.retrieve_item(item_id) elif action == \\"optimize\\": self.optimize_storage() return self.grid else: raise ValueError(\\"Invalid action\\") # Example usage warehouse = Warehouse(5, 5) print(warehouse.perform_action(\\"insert\\", 101)) # Possible output (0, 0) print(warehouse.perform_action(\\"insert\\", 102)) # Possible output (0, 1) print(warehouse.perform_action(\\"retrieve\\", 101)) # Possible output (0, 0) warehouse.perform_action(\\"optimize\\") print(warehouse.grid) # After optimization based on access frequency ``` Objectives: 1. Implement the `insert_item` method to efficiently place items starting from the nearest slot to the entrance. 2. Implement the `retrieve_item` method to efficiently locate and retrieve items, tracking access frequency. 3. Implement the `optimize_storage` method to rearrange the warehouse layout based on item access frequency. **Hint**: Use auxiliary data structures like lists and dictionaries to track frequency and ease of access.","solution":"class Warehouse: def __init__(self, width: int, height: int): self.width = width self.height = height self.grid = [[None for _ in range(width)] for _ in range(height)] self.frequency = {} # To track access frequency of items def insert_item(self, item_id: int) -> tuple: Places an item in the nearest available slot from the entrance (0, 0). for y in range(self.height): for x in range(self.width): if self.grid[y][x] is None: self.grid[y][x] = item_id return (y, x) raise ValueError(\\"Warehouse is full\\") def retrieve_item(self, item_id: int) -> tuple: Retrieves an item and returns its previous coordinates. for y in range(self.height): for x in range(self.width): if self.grid[y][x] == item_id: self.grid[y][x] = None self.frequency[item_id] = self.frequency.get(item_id, 0) + 1 return (y, x) raise ValueError(\\"Item not found\\") def optimize_storage(self) -> None: Re-arranges items to bring frequently accessed items closer to the entrance. items = [(self.frequency.get(self.grid[y][x], 0), self.grid[y][x]) for y in range(self.height) for x in range(self.width) if self.grid[y][x] is not None] items.sort(reverse=True, key=lambda x: x[0]) # Sort items by frequency index = 0 for y in range(self.height): for x in range(self.width): if index < len(items): self.grid[y][x] = items[index][1] index += 1 else: self.grid[y][x] = None def perform_action(self, action: str, item_id: int = None): if action == \\"insert\\": return self.insert_item(item_id) elif action == \\"retrieve\\": return self.retrieve_item(item_id) elif action == \\"optimize\\": self.optimize_storage() return self.grid else: raise ValueError(\\"Invalid action\\") # Example usage: # warehouse = Warehouse(5, 5) # print(warehouse.perform_action(\\"insert\\", 101)) # Possible output (0, 0) # print(warehouse.perform_action(\\"insert\\", 102)) # Possible output (0, 1) # print(warehouse.perform_action(\\"retrieve\\", 101)) # Possible output (0, 0) # warehouse.perform_action(\\"optimize\\") # print(warehouse.grid) # After optimization based on access frequency"},{"question":"# Scenario You are developing a text editor that allows users to format text by capitalizing the first letter of each word. Your task is to implement a function that performs this formatting. # Problem Statement Write a function called `title_case(s: str) -> str` that takes a string `s` and returns the string with the first letter of each word capitalized. Words are defined as sequences of characters separated by spaces. The function should handle any combination of uppercase and lowercase input. # Function Signature ```python def title_case(s: str) -> str: ``` # Input * `s` (string, 0 ≤ len(s) ≤ 1000): The input string containing the text to be formatted. # Output * Returns the formatted string with the first letter of each word capitalized. # Examples ```python assert title_case(\\"hello world\\") == \\"Hello World\\" assert title_case(\\"PYTHON programming\\") == \\"Python Programming\\" assert title_case(\\"capitalize each WORD\\") == \\"Capitalize Each Word\\" ``` # Constraints * Ensure the function handles single words, multiple words, and empty strings correctly. * Pay attention to strings that include multiple spaces. # Notes * Think about potential edge cases, such as strings with leading or trailing spaces, or multiple spaces between words. * The function should work efficiently even if the string is very long. # Hints * The `str.split` method can help you break the string into words. * The `str.join` method will be useful for assembling the final formatted string.","solution":"def title_case(s: str) -> str: Capitalizes the first letter of each word in the string s. return \' \'.join(word.capitalize() for word in s.split())"},{"question":"# Coding Assessment Question You are a programmer designing utilities for string manipulation commonly needed in text processing applications. One of the required utilities is to ensure that a string only contains alphanumeric characters, as non-alphanumeric characters can cause errors in various systems. Problem Statement Write a function named `is_alphanumeric` that checks if a given string consists solely of alphanumeric characters (letters and digits) without any symbols or spaces. The function should return `True` if the string is alphanumeric, and `False` otherwise. Function Signature ```python def is_alphanumeric(s: str) -> bool: pass ``` Input - `s`: A string, which may contain letters (both uppercase and lowercase), digits, symbols, and spaces. Output - Returns a boolean: - `True` if the string contains only alphanumeric characters. - `False` otherwise. Example ```python assert is_alphanumeric(\\"hello123\\") == True assert is_alphanumeric(\\"hello 123\\") == False assert is_alphanumeric(\\"hello!\\") == False assert is_alphanumeric(\\"H3LLO\\") == True assert is_alphanumeric(\\" \\") == False assert is_alphanumeric(\\"\\") == False ``` Constraints - The function must run in O(n) time complexity where n is the length of the string. - The string may contain any printable ASCII characters. - An empty string should return `False`. Requirements - Implement the function `is_alphanumeric` as described. - Ensure the function passes basic tests to verify its correctness.","solution":"def is_alphanumeric(s: str) -> bool: Check if the given string s consists only of alphanumeric characters. Parameters: s (str): The input string. Returns: bool: True if the string is alphanumeric, False otherwise. if not s: # An empty string should return False return False return s.isalnum()"},{"question":"# Manage a Library Inventory System You are tasked with developing a simple library inventory management system. Your function should implement the following requirements: 1. Add a new book to the library inventory with the following attributes: - Title of the book. - Author of the book. - ISBN number (a unique identifier for every book). 2. Retrieve book information based on a search by title or ISBN number. 3. Remove a book from the inventory based on its ISBN number. 4. Implement robust error handling to manage scenarios where a book does not exist in the inventory. The function signature should be: ```python def library_inventory_system(command: str, details: dict) -> dict: Manages the library inventory system based on the command provided. ``` Input: The function takes two inputs: - `command` (str): The command to execute. It can be \\"add\\", \\"search\\", or \\"remove\\". - `details` (dict): A dictionary containing the details relevant to the command: - For \\"add\\": {\'title\': str, \'author\': str, \'isbn\': str} - For \\"search\\": {\'title\': str} or {\'isbn\': str} - For \\"remove\\": {\'isbn\': str} Output: The function returns: - For \\"add\\": {\'message\': \'Book added: <title>\'} - For \\"search\\": {\'title\': str, \'author\': str, \'isbn\': str} or {\'error\': \'Book not found\'} - For \\"remove\\": {\'message\': \'Book removed: <isbn>\'} or {\'error\': \'Book not found\'} Constraints: - Ensure the ISBN number is unique for each book. - Handle errors appropriately, such as when a book being added already exists, or when a book being searched/removed does not exist. - Assume that all ISBN numbers are correctly formatted and valid. Example: ```python # Adding a book print(library_inventory_system(\'add\', {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'isbn\': \'1234567890\'})) # {\'message\': \'Book added: The Great Gatsby\'} # Searching for a book by title print(library_inventory_system(\'search\', {\'title\': \'The Great Gatsby\'})) # {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'isbn\': \'1234567890\'} # Removing a book by ISBN print(library_inventory_system(\'remove\', {\'isbn\': \'1234567890\'})) # {\'message\': \'Book removed: 1234567890\'} ``` Use the following code snippet to get you started and improve it according to the instructions: ```python library_inventory = {} def library_inventory_system(command: str, details: dict) -> dict: global library_inventory if command == \'add\': title = details.get(\'title\') author = details.get(\'author\') isbn = details.get(\'isbn\') if isbn in library_inventory: return {\'error\': \'Book with this ISBN already exists\'} library_inventory[isbn] = {\'title\': title, \'author\': author} return {\'message\': f\'Book added: {title}\'} elif command == \'search\': title = details.get(\'title\') isbn = details.get(\'isbn\') if isbn: book = library_inventory.get(isbn) if not book: return {\'error\': \'Book not found\'} return book elif title: for book in library_inventory.values(): if book[\'title\'] == title: return book return {\'error\': \'Book not found\'} elif command == \'remove\': isbn = details.get(\'isbn\') if isbn in library_inventory: del library_inventory[isbn] return {\'message\': f\'Book removed: {isbn}\'} return {\'error\': \'Book not found\'} else: return {\'error\': \'Invalid command\'} # Usage examples: print(library_inventory_system(\'add\', {\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'isbn\': \'1234567890\'})) print(library_inventory_system(\'search\', {\'title\': \'The Great Gatsby\'})) print(library_inventory_system(\'remove\', {\'isbn\': \'1234567890\'})) ``` Make sure to test your function for various scenarios and edge cases, such as: - Adding a book with an existing ISBN - Searching for a non-existing book - Removing a non-existing book Good luck!","solution":"library_inventory = {} def library_inventory_system(command: str, details: dict) -> dict: global library_inventory if command == \'add\': title = details.get(\'title\') author = details.get(\'author\') isbn = details.get(\'isbn\') if isbn in library_inventory: return {\'error\': \'Book with this ISBN already exists\'} library_inventory[isbn] = {\'title\': title, \'author\': author} return {\'message\': f\'Book added: {title}\'} elif command == \'search\': title = details.get(\'title\') isbn = details.get(\'isbn\') if isbn: book = library_inventory.get(isbn) if not book: return {\'error\': \'Book not found\'} return {\'title\': book[\'title\'], \'author\': book[\'author\'], \'isbn\': isbn} elif title: for isbn, book in library_inventory.items(): if book[\'title\'] == title: return {\'title\': book[\'title\'], \'author\': book[\'author\'], \'isbn\': isbn} return {\'error\': \'Book not found\'} elif command == \'remove\': isbn = details.get(\'isbn\') if isbn in library_inventory: del library_inventory[isbn] return {\'message\': f\'Book removed: {isbn}\'} return {\'error\': \'Book not found\'} else: return {\'error\': \'Invalid command\'}"},{"question":"**Coding Problem: Implementing a Stack with Maximum Functionality** # Problem Statement You are tasked with implementing a stack data structure that, in addition to the usual stack operations (push, pop, peek), provides an efficient function to return the maximum element in the stack in constant time. You must implement the `MaxStack` class with the following methods: - `push(x)`: Pushes element `x` onto the stack. - `pop()`: Removes the element on top of the stack and returns that element. - `peek()`: Gets the element on the top of the stack without removing it. - `get_max()`: Retrieves the maximum element in the stack. # Input Each method should be called on an instance of `MaxStack`. # Output - `push(x)`: No output. - `pop()`: Returns the popped element. - `peek()`: Returns the top element of the stack. - `get_max()`: Returns the maximum element in the stack. # Constraints - All elements will be integers. - Elements pushed to the stack are within the range (-10^4) to (10^4). - The number of operations will be at most (10^5). # Example ```python # Example operations sequence: stack = MaxStack() stack.push(3) stack.push(1) stack.push(5) stack.push(2) print(stack.get_max()) # Output: 5 print(stack.pop()) # Output: 2 print(stack.get_max()) # Output: 5 print(stack.peek()) # Output: 5 stack.pop() stack.pop() print(stack.get_max()) # Output: 3 ``` # Implementation Details 1. Use an auxiliary stack to track the maximum elements efficiently. 2. During the `push(x)` operation, if the auxiliary stack is empty or the pushed value is greater than or equal to the current maximum, also push it onto the auxiliary stack. 3. During the `pop()` operation, if the popped value is equal to the top of the auxiliary stack, also pop from the auxiliary stack. 4. For `get_max()`, simply return the top value of the auxiliary stack. 5. Ensure all operations are handled in constant time. ```python class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: x = self.stack.pop() if x == self.max_stack[-1]: self.max_stack.pop() return x def peek(self) -> int: if self.stack: return self.stack[-1] def get_max(self) -> int: if self.max_stack: return self.max_stack[-1] ```","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if self.stack: x = self.stack.pop() if x == self.max_stack[-1]: self.max_stack.pop() return x def peek(self) -> int: if self.stack: return self.stack[-1] def get_max(self) -> int: if self.max_stack: return self.max_stack[-1]"},{"question":"# Problem: Implement a Simple Calculator for Basic Arithmetic Operations You are tasked with implementing a simple calculator that can perform basic arithmetic operations: addition, subtraction, multiplication, and division. The calculator should take a string input representing a mathematical expression and return the computed result. Input * **expression**: A string representing the mathematical expression to be evaluated. Output * Return a float representing the result of the evaluated expression. # Constraints 1. The expression will only contain digits, operators (`+`, `-`, `*`, `/`), and spaces. 2. Ensure proper handling of division by zero by raising a `ZeroDivisionError` with the message \\"division by zero\\". 3. The expression can contain float numbers. 4. The expression will always be valid and contain at least two operands. # Example ```python print(evaluate_expression(\\"3 + 5\\")) # Outputs: 8.0 print(evaluate_expression(\\"10 - 2 * 3\\")) # Outputs: 4.0 print(evaluate_expression(\\"2.5 * 4\\")) # Outputs: 10.0 print(evaluate_expression(\\"8 / 2 + 3\\")) # Outputs: 7.0 ``` # Notes * Ensure that division operations involving zero are properly handled by raising an appropriate exception. * You may use Python\'s `eval` function, but ensure necessary precautions to handle potential errors and edge cases. # Function Signature ```python def evaluate_expression(expression: str) -> float: # You need to implement this function ``` # Context This problem will test your ability to handle string manipulation, arithmetic operations, and exception handling. It simulates the functionality of a basic calculator and is a common task in many programming scenarios requiring mathematical computations.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string and returns the result as a float. # Define a scope with restricted built-in functions for eval allowed_names = {\\"__builtins__\\": None} expression = expression.replace(\' \', \'\') # Remove spaces in the expression # Try to evaluate the expression using eval within the restricted scope try: result = eval(expression, allowed_names) return float(result) except ZeroDivisionError: raise ZeroDivisionError(\\"division by zero\\") except SyntaxError: raise ValueError(\\"Invalid expression provided\\") except Exception as e: raise ValueError(f\\"An error occurred: {e}\\") # Example Usage: # print(evaluate_expression(\\"3 + 5\\")) # Outputs: 8.0 # print(evaluate_expression(\\"10 - 2 * 3\\")) # Outputs: 4.0 # print(evaluate_expression(\\"2.5 * 4\\")) # Outputs: 10.0 # print(evaluate_expression(\\"8 / 2 + 3\\")) # Outputs: 7.0"},{"question":"# Question You have been tasked with developing a feature for a text-based game that involves traversing a grid. The player can move up, down, left, or right, and you need to validate and execute their moves. Implement a function `is_valid_move` to verify whether a move is valid given the current position and the grid boundaries. Also, implement a function `move_player` to update the position of the player based on valid moves. Function 1: `is_valid_move` * **Input**: - `grid`: A list of lists (2D grid) representing the game map. - `current_position`: A tuple `(row, column)` representing the player\'s current position. - `direction`: A string representing the move direction, which can be \\"UP\\", \\"DOWN\\", \\"LEFT\\", or \\"RIGHT\\". * **Output**: A boolean indicating whether the move is valid. A move is valid if it remains within the bounds of the grid. Function 2: `move_player` * **Input**: - `grid`: A list of lists (2D grid) representing the game map. - `current_position`: A tuple `(row, column)` representing the player\'s current position. - `direction`: A string representing the move direction, which can be \\"UP\\", \\"DOWN\\", \\"LEFT\\", or \\"RIGHT\\". * **Output**: A tuple `(new_row, new_column)` representing the new position of the player after making the move. If the move is invalid, return the original position. **Constraints**: - The grid is always rectangular and non-empty. - The directions \\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\" are case-insensitive. **Example Usage**: ```python def is_valid_move(grid, current_position, direction): rows = len(grid) cols = len(grid[0]) row, col = current_position if direction.lower() == \\"up\\": return row > 0 elif direction.lower() == \\"down\\": return row < rows - 1 elif direction.lower() == \\"left\\": return col > 0 elif direction.lower() == \\"right\\": return col < cols - 1 return False def move_player(grid, current_position, direction): if not is_valid_move(grid, current_position, direction): return current_position row, col = current_position if direction.lower() == \\"up\\": new_position = (row - 1, col) elif direction.lower() == \\"down\\": new_position = (row + 1, col) elif direction.lower() == \\"left\\": new_position = (row, col - 1) elif direction.lower() == \\"right\\": new_position = (row, col + 1) return new_position assert is_valid_move([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (1, 1), \\"UP\\") == True assert is_valid_move([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 1), \\"UP\\") == False assert move_player([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (1, 1), \\"UP\\") == (0, 1) assert move_player([[0, 0, 0], [0, 0, 0], [0, 0, 0]], (0, 1), \\"UP\\") == (0, 1) ```","solution":"def is_valid_move(grid, current_position, direction): Checks if the move is valid within the grid boundaries. Parameters: grid (list of lists): The game map. current_position (tuple): The current position of the player (row, col). direction (str): The move direction (\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"). Returns: bool: True if the move is valid, False otherwise. rows = len(grid) cols = len(grid[0]) row, col = current_position if direction.lower() == \\"up\\": return row > 0 elif direction.lower() == \\"down\\": return row < rows - 1 elif direction.lower() == \\"left\\": return col > 0 elif direction.lower() == \\"right\\": return col < cols - 1 return False def move_player(grid, current_position, direction): Updates the player\'s position based on the move direction if it is valid. Parameters: grid (list of lists): The game map. current_position (tuple): The current position of the player (row, col). direction (str): The move direction (\\"UP\\", \\"DOWN\\", \\"LEFT\\", \\"RIGHT\\"). Returns: tuple: The new position of the player (new_row, new_col), or original position if move is invalid. if not is_valid_move(grid, current_position, direction): return current_position row, col = current_position if direction.lower() == \\"up\\": new_position = (row - 1, col) elif direction.lower() == \\"down\\": new_position = (row + 1, col) elif direction.lower() == \\"left\\": new_position = (row, col - 1) elif direction.lower() == \\"right\\": new_position = (row, col + 1) return new_position"},{"question":"# Coding Challenge **Problem Statement**: You are provided with a string `s` that contains only lowercase letters. A string is said to be a \\"palindromic anagram\\" if its characters can be rearranged to form a palindrome. Your task is to determine if the given string `s` can be rearranged to form a palindrome. **Function Specifications**: Complete the function `can_form_palindromic_anagram(s: str) -> bool` which takes in the following parameter: - `s`: A string containing only lowercase letters. The function should return `True` if the string can be rearranged to form a palindrome and `False` otherwise. **Input Constraints**: - The length of `s` is between 0 and 1000. **Output**: - A boolean value, `True` or `False`. **Example**: ```python assert can_form_palindromic_anagram(\\"civic\\") == True assert can_form_palindromic_anagram(\\"ivicc\\") == True assert can_form_palindromic_anagram(\\"hello\\") == False assert can_form_palindromic_anagram(\\"a\\") == True assert can_form_palindromic_anagram(\\"racecar\\") == True assert can_form_palindromic_anagram(\\"aabb\\") == True assert can_form_palindromic_anagram(\\"abc\\") == False ``` **Additional Specifications**: - You must solve the problem using an efficient algorithm. - Optimize for time and space where possible. **Explanation**: Given the string `\\"civic\\"`, it is already a palindrome, so the output is `True`. Given the string `\\"ivicc\\"`, it can be rearranged to `\\"civic\\"`, which is a palindrome, so the output is `True`. Given the string `\\"hello\\"`, it cannot be rearranged to form a palindrome, so the output is `False`.","solution":"def can_form_palindromic_anagram(s: str) -> bool: Determine if the given string can be rearranged to form a palindrome. :param s: A string containing only lowercase letters. :return: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"# Coding Assessment Question: Image Compression Using Run-Length Encoding Context You are developing software to manage and store large image files efficiently. One common technique for compressing simple images is Run-Length Encoding (RLE), which is particularly effective for images with large contiguous regions of the same color. Task Implement functions to compress and decompress an image using Run-Length Encoding. You are required to provide the following functionality: 1. **Compression**: Convert a 2D image represented by a matrix of pixel values into a Run-Length Encoded format. 2. **Decompression**: Convert the Run-Length Encoded format back into the original 2D image. Input and Output Formats 1. **compress_image(image: List[List[int]]) -> List[Tuple[int, int]]** - `image`: A 2D list of integers representing the pixel values in the image. ```python image = [ [1, 1, 1, 2, 2], [3, 3, 3, 3, 1], ... [2, 2, 1, 1, 1] ] ``` - Returns a list of tuples, where each tuple represents a pixel value and its run length. ```python compressed_image = [ (1, 3), (2, 2), (3, 4), (1, 1), ... (2, 2), (1, 3) ] ``` 2. **decompress_image(compressed_image: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]** - `compressed_image`: A list of tuples generated by the compression function. - `rows`: The number of rows in the original image. - `cols`: The number of columns in the original image. - Returns the reconstructed 2D list of integers representing the decompressed image. Constraints - The image size can be up to 10,000 x 10,000 pixels. - Pixel values range from 0 to 255. - Ensure the implementation is efficient and can handle large images without excessive memory usage. Example Usage ```python image = [ [1, 1, 1, 2, 2], [3, 3, 3, 3, 1], [2, 2, 1, 1, 1] ] compressed_image = compress_image(image) print(f\\"Compressed image: {compressed_image}\\") rows, cols = 3, 5 decompressed_image = decompress_image(compressed_image, rows, cols) print(f\\"Decompressed image: {decompressed_image}\\") ``` Notes - Handle edge cases such as images with only one row, one column, or all pixels having the same value. - Validate the dimensions provided for decompression to ensure they match the original image. - Document any assumptions and decisions made in your code comments.","solution":"from typing import List, Tuple def compress_image(image: List[List[int]]) -> List[Tuple[int, int]]: Compress a 2D image using Run-Length Encoding. :param image: List[List[int]] - A 2D list of integers representing the pixel values. :return: List[Tuple[int, int]] - A list of tuples representing the pixel values and their run lengths. if not image or not image[0]: return [] compressed = [] for row in image: current_pixel = row[0] count = 1 for pixel in row[1:]: if pixel == current_pixel: count += 1 else: compressed.append((current_pixel, count)) current_pixel = pixel count = 1 compressed.append((current_pixel, count)) return compressed def decompress_image(compressed_image: List[Tuple[int, int]], rows: int, cols: int) -> List[List[int]]: Decompress a Run-Length Encoded image back to its original 2D format. :param compressed_image: List[Tuple[int, int]] - A list of tuples generated by the compression function. :param rows: int - The number of rows in the original image. :param cols: int - The number of columns in the original image. :return: List[List[int]] - The reconstructed 2D list of integers representing the decompressed image. if not compressed_image: return [[] for _ in range(rows)] decompressed = [] row = [] for (pixel, count) in compressed_image: while count > 0: if len(row) < cols: row.append(pixel) count -= 1 if len(row) == cols: decompressed.append(row) row = [] return decompressed"},{"question":"# Question: Determine Longest Subsequence with Unique Characters You are given a string `s` consisting of lowercase English letters. Write a function that returns the length of the longest subsequence of `s` that contains only unique characters. # Input * A string `s` (1 ≤ len(s) ≤ 1000), consisting of lowercase English letters. # Output * Return an integer representing the length of the longest subsequence in `s` that contains only unique characters. # Constraints * You must ensure the solution runs efficiently even for the upper limits of input size. * Dynamically determine the longest subsequence without generating all possible subsequences. # Example Input ```python s = \'abcabcbb\' ``` Output ```python 3 ``` Input ```python s = \'bbbbb\' ``` Output ```python 1 ``` # Function Signature ```python def longest_unique_subsequence(s: str) -> int: pass ```","solution":"def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence with unique characters in the string s. if not s: return 0 unique_chars = set(s) return len(unique_chars)"},{"question":"# Problem Statement Given the necessary skills to manipulate strings and track their occurrences, this problem tests your ability to identify the first unique character in a string. A unique character is one that appears exactly once in the string. Task Write a function `first_unique_char(s: str) -> int` to find the first non-repeating character in the string and return its index. If it does not exist, return -1. Input * `s` (str): The input string containing only lowercase English letters. (1 ≤ len(s) ≤ 100,000) Output * Returns the index of the first non-repeating character, or -1 if there are no unique characters. Constraints * Your implementation should be efficient, considering both time and space complexities. * Handle edge cases such as strings with all characters repeating or the shortest possible string. # Example ```python assert first_unique_char(\\"leetcode\\") == 0 assert first_unique_char(\\"loveleetcode\\") == 2 assert first_unique_char(\\"aabb\\") == -1 assert first_unique_char(\\"aaaabbbbccccdddde\\") == 16 assert first_unique_char(\\"a\\") == 0 ``` Additional Notes For the input `\\"loveleetcode\\"`, `\'l\'` and `\'o\'` both appear more than once, so the first unique character is `\'v\'`, which appears at index 2.","solution":"def first_unique_char(s: str) -> int: Finds the first non-repeating character in the string and returns its index. If it does not exist, returns -1. # Dictionary to keep count of each character char_count = {} # Populate the dictionary with character counts for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index # If no unique character found, return -1 return -1"},{"question":"Tree Traversal - In-order with Iterative Approach Implement an in-order traversal of a binary tree using an iterative approach. Given a binary tree node class, complete the function to perform the in-order traversal and return the result as a list of node values. # Class Definition ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' | None = None, right: \'TreeNode\' | None = None): self.val = val self.left = left self.right = right ``` # Function Implementation Using the `TreeNode` class, implement an iterative in-order traversal of the binary tree. Create necessary methods to 1. Construct a sample binary tree for demonstration. 2. Perform in-order traversal and return the list of values. Requirements 1. **Function Name**: `inorder_traversal` * **Input**: The root node of a binary tree. * **Output**: A list of integers representing the node values in in-order traversal. # Example ```python root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) result = inorder_traversal(root) print(result) # Output: [1, 3, 2] ``` # Constraints * The number of nodes in the tree is in the range [0, 100]. * Each node\'s value is composed of a unique integer. * The solution must use an iterative approach, not recursion. Implement the `inorder_traversal` function below. ```python def inorder_traversal(root: TreeNode) -> list[int]: # Your code here ```","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list[int]: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Recursive Depth Calculation of Nested Lists Scenario: You are given a list that can contain nested sub-lists, and you need to determine the maximum depth of these nested lists. The maximum depth is defined as the deepest level of nested lists within the given list. For example, the depth of `[1, [2, [3, [4]], 5]]` is 4. Task: Implement a function `max_depth` that computes the maximum depth of a list, which may contain nested sub-lists. You should handle cases where the input list is empty. Function Signature: ```python def max_depth(nested_list: list) -> int: Compute the maximum depth of a list containing nested sub-lists. :param list nested_list: The list to compute the maximum depth for. :return int: The maximum depth of the nested lists. Examples: >>> max_depth([1, 2, 3]) 1 >>> max_depth([1, [2, [3, [4]], 5]]) 4 >>> max_depth([]) 1 >>> max_depth([1, [], [2], [[[3]]]]) 4 >>> max_depth(5) Traceback (most recent call last): ... TypeError: Input must be a list. >>> max_depth([1, [2, [3, [4, [5]]]]]) 5 # Your implementation goes here ``` Constraints: - The input must be a list. - Raise a `TypeError` for non-list input with the message: \\"Input must be a list.\\" - The function must handle empty lists properly. - Nested lists can have arbitrary depths. Performance Requirement: - The function should be able to handle lists of reasonable size efficiently. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"def max_depth(nested_list: list) -> int: Compute the maximum depth of a list containing nested sub-lists. :param list nested_list: The list to compute the maximum depth for. :return int: The maximum depth of the nested lists. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list.\\") def get_depth(lst, level): if not lst: return level return max(get_depth(item, level + 1) if isinstance(item, list) else level for item in lst) return get_depth(nested_list, 1)"},{"question":"# Context Bob is developing a software package that involves various operations on strings. One of the tasks involves checking for repeated substrings within a given string. He needs a function that can determine the longest repeated substring in the input string. # Task Write a function `longest_repeated_substring` that takes a string as input and returns the longest repeated substring within that string. If there are multiple substrings of the same maximum length, return the one that appears first. If there are no repeated substrings, return an empty string. # Input - A single string `s` where the length of `s` is between 1 and 2000. # Output - A string representing the longest repeated substring. If no such substring exists, return an empty string. # Example ```python s = \\"banana\\" longest_repeated_substring(s) ``` Expected Output: ``` \\"ana\\" ``` # Constraints - The input string will have a length of 1 to 2000 characters. # Performance Requirements - Optimize the computation to handle the input size efficiently.","solution":"def longest_repeated_substring(s: str) -> str: Returns the longest repeated substring within the input string s. If there are multiple substrings of the same maximum length, returns the one that appears first. If there are no repeated substrings, returns an empty string. n = len(s) if n <= 1: return \\"\\" suffixes = [s[i:] for i in range(n)] suffixes.sort() def lcp(str1, str2): length = min(len(str1), len(str2)) for i in range(length): if str1[i] != str2[i]: return str1[:i] return str1[:length] longest_substring = \\"\\" for i in range(n - 1): common_prefix = lcp(suffixes[i], suffixes[i + 1]) if len(common_prefix) > len(longest_substring): longest_substring = common_prefix return longest_substring"},{"question":"# Question: Implement the Floyd-Warshall Algorithm for All-Pairs Shortest Paths Context You are working as a software developer for a company that needs to analyze traffic patterns in a city to optimize travel times between all pairs of intersections. Given a map of intersections (nodes) and possible direct routes (edges) between them, each with an associated travel time, you need to determine the shortest travel time between every pair of intersections. Task Write a function `find_all_pairs_shortest_paths(graph: Graph) -> List[List[int]]` that finds the shortest travel times between all pairs of nodes using the Floyd-Warshall algorithm. Utilize the `Graph` class template provided below, which represents the graph and contains the necessary methods to add edges and perform the Floyd-Warshall algorithm. Graph Class Definition You can use the following `Graph` class template: ```python class Graph: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.graph = [[float(\'inf\')] * num_of_nodes for _ in range(num_of_nodes)] for i in range(num_of_nodes): self.graph[i][i] = 0 def add_edge(self, u: int, v: int, weight: int) -> None: self.graph[u][v] = weight def floyd_warshall(self) -> List[List[int]]: dist = [row[:] for row in self.graph] for k in range(self.num_of_nodes): for i in range(self.num_of_nodes): for j in range(self.num_of_nodes): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist ``` Function Signature ```python def find_all_pairs_shortest_paths(graph: Graph) -> List[List[int]]: pass ``` Input - `graph`: An instance of the `Graph` class with nodes and edges added. Output - A 2D list representing the shortest travel times between every pair of nodes in the graph. Constraints - The graph can have up to `500` nodes. - Each edge weight is a positive integer. - There might be no path between some pairs of nodes, which should be represented as `float(\'inf\')`. Example ```python g = Graph(4) edges = [ (0, 1, 5), (0, 3, 10), (1, 2, 3), (2, 3, 1) ] for u, v, w in edges: g.add_edge(u, v, w) shortest_paths = find_all_pairs_shortest_paths(g) for row in shortest_paths: print(row) # Output: # [0, 5, 8, 9] # [inf, 0, 3, 4] # [inf, inf, 0, 1] # [inf, inf, inf, 0] ``` Note The provided `Graph` class includes the necessary methods for the Floyd-Warshall algorithm, but students must structure their solution to use these methods appropriately to achieve the correct result. Make sure to handle large input sizes efficiently.","solution":"from typing import List class Graph: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.graph = [[float(\'inf\')] * num_of_nodes for _ in range(num_of_nodes)] for i in range(num_of_nodes): self.graph[i][i] = 0 def add_edge(self, u: int, v: int, weight: int) -> None: self.graph[u][v] = weight def floyd_warshall(self) -> List[List[int]]: dist = [row[:] for row in self.graph] for k in range(self.num_of_nodes): for i in range(self.num_of_nodes): for j in range(self.num_of_nodes): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist def find_all_pairs_shortest_paths(graph: Graph) -> List[List[int]]: return graph.floyd_warshall()"},{"question":"# Sentiment Analysis Using Transformer-Based Models Context You are provided with a dataset containing text reviews and their corresponding sentiment labels. Your task is to use this data to train a transformer-based model (e.g., BERT) to classify the sentiments of the reviews. This problem will test your understanding of data preprocessing, transformer-based model architecture, and the intricacies of text classification. Task 1. **Data Preprocessing**: - Load the provided `reviews_data.csv` file. - Preprocess the text data by tokenizing the reviews and converting them to a format suitable for a pre-trained transformer model. - Split the dataset into training and testing sets, ensuring a stratified split based on sentiment labels. 2. **Model Construction**: - Use a pre-trained transformer model (e.g., `bert-base-uncased`) and fine-tune it for the sentiment classification task. - Train the model using the training data. 3. **Prediction and Evaluation**: - Predict the sentiment labels on the test dataset. - Evaluate the model\'s performance using accuracy and F1 Score. Constraints - Use `numpy`, `pandas`, `transformers`, `torch`, and `sklearn` libraries for your implementation. - Ensure that the text data is appropriately tokenized and padded for the transformer model. - Handle any NAN or missing values in the dataset appropriately. Input - A CSV file named `reviews_data.csv` with text reviews (first column) and sentiment labels (second column: `0` for negative, `1` for positive). Output - Print the accuracy and F1 Score of your predictions on the test dataset. - Return the predicted sentiment labels for the test dataset. Function Signature ```python def transformer_sentiment_analysis(file_path: str) -> (float, float, list): Function to train a transformer-based model for sentiment analysis and evaluate its performance. Params: file_path: str: Path to the csv file containing text reviews and sentiment labels. Returns: accuracy: float: Accuracy of the model\'s predictions on the test dataset. f1: float: F1 Score of the model\'s predictions on the test dataset. predictions: list: List of predicted sentiment labels for the test period. pass ``` Example Suppose `reviews_data.csv` contains: ``` \\"Great product!\\", 1 \\"Terrible service.\\", 0 ... ``` Your function should preprocess this data, build the transformer model, and return the accuracy, F1 Score, and a list of predicted sentiment labels.","solution":"import pandas as pd import numpy as np from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score, f1_score from transformers import BertTokenizer, BertForSequenceClassification, AdamW from torch.utils.data import DataLoader, Dataset import torch import torch.nn.functional as F class ReviewsDataset(Dataset): def __init__(self, texts, labels, tokenizer, max_len): self.texts = texts self.labels = labels self.tokenizer = tokenizer self.max_len = max_len def __len__(self): return len(self.texts) def __getitem__(self, index): text = str(self.texts[index]) label = self.labels[index] encoding = self.tokenizer.encode_plus( text, max_length=self.max_len, add_special_tokens=True, truncation=True, padding=\'max_length\', return_token_type_ids=False, return_attention_mask=True, return_tensors=\'pt\' ) return { \'review_text\': text, \'input_ids\': encoding[\'input_ids\'].flatten(), \'attention_mask\': encoding[\'attention_mask\'].flatten(), \'label\': torch.tensor(label, dtype=torch.long) } def create_data_loader(df, tokenizer, max_len, batch_size): ds = ReviewsDataset( texts=df.text.to_numpy(), labels=df.label.to_numpy(), tokenizer=tokenizer, max_len=max_len ) return DataLoader(ds, batch_size=batch_size) def train_epoch(model, data_loader, loss_fn, optimizer, device): model = model.train() losses = [] correct_predictions = 0 for d in data_loader: input_ids = d[\\"input_ids\\"].to(device) attention_mask = d[\\"attention_mask\\"].to(device) labels = d[\\"label\\"].to(device) outputs = model( input_ids=input_ids, attention_mask=attention_mask ) _, preds = torch.max(outputs.logits, dim=1) loss = loss_fn(outputs.logits, labels) correct_predictions += torch.sum(preds == labels) losses.append(loss.item()) loss.backward() optimizer.step() optimizer.zero_grad() return correct_predictions.double() / len(data_loader.dataset), np.mean(losses) def eval_model(model, data_loader, loss_fn, device): model = model.eval() losses = [] correct_predictions = 0 with torch.no_grad(): for d in data_loader: input_ids = d[\\"input_ids\\"].to(device) attention_mask = d[\\"attention_mask\\"].to(device) labels = d[\\"label\\"].to(device) outputs = model( input_ids=input_ids, attention_mask=attention_mask ) _, preds = torch.max(outputs.logits, dim=1) loss = loss_fn(outputs.logits, labels) correct_predictions += torch.sum(preds == labels) losses.append(loss.item()) return correct_predictions.double() / len(data_loader.dataset), np.mean(losses) def get_predictions(model, data_loader, device): model = model.eval() review_texts = [] predictions = [] prediction_probs = [] real_values = [] with torch.no_grad(): for d in data_loader: texts = d[\\"review_text\\"] input_ids = d[\\"input_ids\\"].to(device) attention_mask = d[\\"attention_mask\\"].to(device) labels = d[\\"label\\"].to(device) outputs = model( input_ids=input_ids, attention_mask=attention_mask ) _, preds = torch.max(outputs.logits, dim=1) review_texts.extend(texts) predictions.extend(preds) real_values.extend(labels) predictions = torch.stack(predictions).cpu() real_values = torch.stack(real_values).cpu() return predictions, real_values def transformer_sentiment_analysis(file_path: str) -> (float, float, list): # Load data df = pd.read_csv(file_path) df = df.dropna() # Preprocess data tokenizer = BertTokenizer.from_pretrained(\'bert-base-uncased\') df.rename(columns={df.columns[0]: \'text\', df.columns[1]: \'label\'}, inplace=True) train_data, test_data = train_test_split(df, test_size=0.2, stratify=df.label, random_state=42) train_data_loader = create_data_loader(train_data, tokenizer, max_len=128, batch_size=16) test_data_loader = create_data_loader(test_data, tokenizer, max_len=128, batch_size=16) # Model construction device = torch.device(\\"cuda\\" if torch.cuda.is_available() else \\"cpu\\") model = BertForSequenceClassification.from_pretrained(\'bert-base-uncased\', num_labels=2) model = model.to(device) optimizer = AdamW(model.parameters(), lr=2e-5, correct_bias=False) loss_fn = torch.nn.CrossEntropyLoss().to(device) epochs = 2 for epoch in range(epochs): train_acc, train_loss = train_epoch( model, train_data_loader, loss_fn, optimizer, device ) # Prediction and Evaluation y_pred, y_test = get_predictions(model, test_data_loader, device) acc = accuracy_score(y_test, y_pred) f1 = f1_score(y_test, y_pred, average=\'weighted\') return acc, f1, y_pred.tolist()"},{"question":"# Coding Assessment Question Scenario: You are developing a feature that involves working with dates and event durations. Given a set of events, each with a start and end time, you need to identify overlapping events. Specifically, you need to determine the maximum number of events that are overlapping at any given point in time. Objective: Write a function named `max_overlapping_events` that: - Accepts a list of tuples, where each tuple contains two strings representing the start and end times of an event in the format \\"HH:MM\\". - Returns an integer indicating the maximum number of events that overlap at any given point in time. Implementation Requirements: - **Input**: A list of tuples, `events`, where each tuple `(start_time, end_time)` is represented as `\\"HH:MM\\"`. - **Output**: An integer representing the maximum number of overlapping events. - Your solution should efficiently handle the sorting and comparison of event times. Function Signature: ```python def max_overlapping_events(events: List[Tuple[str, str]]) -> int: pass ``` Example: ```python events = [(\\"09:00\\", \\"10:30\\"), (\\"09:30\\", \\"11:00\\"), (\\"10:00\\", \\"11:30\\"), (\\"11:00\\", \\"12:00\\")] assert max_overlapping_events(events) == 3 # Explanation: Between 10:00 and 10:30, three events overlap events = [(\\"09:00\\", \\"09:30\\"), (\\"09:15\\", \\"10:00\\"), (\\"09:45\\", \\"10:15\\"), (\\"10:15\\", \\"11:00\\")] assert max_overlapping_events(events) == 2 # Explanation: Between 09:15 and 09:30, two events overlap ``` Constraints: - The time format will always be valid and within 24-hour format (`\\"HH:MM\\"`). - The number of events can be up to (10^5). - Start time is always before end time for each event. - Events can overlap or be contiguous adjacently without gap times. Note: Provide comprehensive tests to validate your implementation, considering both minimal and maximal input sizes and various edge cases of overlapping events.","solution":"from typing import List, Tuple def max_overlapping_events(events: List[Tuple[str, str]]) -> int: # Convert times to tuples of (minutes_since_midnight, is_start) times = [] for start, end in events: start_minutes = int(start[:2]) * 60 + int(start[3:]) end_minutes = int(end[:2]) * 60 + int(end[3:]) times.append((start_minutes, 1)) times.append((end_minutes, -1)) # Sort the times, if two times are the same the end event should come first times.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for time, is_start in times: current_overlap += is_start if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"# Problem Statement Implement a least-recently used (LRU) cache data structure to optimize the retrieval speed of frequently accessed elements. Your task is to design and develop an LRU cache class that supports insertion, retrieval, and deletion operations while adhering to the constraints of limited cache size. # Requirements 1. **Class Definition**: Define the class `LRUCache`. 2. **Constructor**: Initialize the cache with a fixed size defined during instantiation. 3. **Get Method**: Implement the `get` method which retrieves the value of the key if it exists in the cache, moving the accessed key-value pair to the most recently used position. 4. **Put Method**: Implement the `put` method which inserts the key-value pair into the cache. If the cache exceeds the defined size, evict the least-recently used item. 5. **Delete Method**: Implement the `delete` method which removes the key-value pair if it exists in the cache. 6. **State Method**: Implement the `state` method which returns a list of the key-value pairs in the cache in the order of most to least recently used. 7. **Edge Cases Handling**: Ensure the methods handle edge cases such as accessing or deleting a non-existent key, and inserting beyond the cache capacity properly. 8. **Constraints**: - The keys and values are all integers. - Cache operations should be efficient, aiming for time complexity of O(1) for each operation. # Function Signature ```python class LRUCache: def __init__(self, capacity: int): # Your code here def get(self, key: int) -> int: # Your code here def put(self, key: int, value: int) -> None: # Your code here def delete(self, key: int) -> None: # Your code here def state(self) -> List[Tuple[int, int]]: # Your code here ``` # Input and Output * `__init__(capacity: int)`: initializes the cache with specified capacity. * `get(key: int) -> int`: retrieves the value associated with the key if it exists; otherwise, returns -1. * `put(key: int, value: int) -> None`: inserts the key-value pair into the cache. * `delete(key: int) -> None`: deletes the key-value pair if it exists. * `state() -> List[Tuple[int, int]]`: returns the list of key-value pairs in the cache. # Example ```python lru_cache = LRUCache(2) lru_cache.put(1, 1) lru_cache.put(2, 2) print(lru_cache.get(1)) # Output: 1 lru_cache.put(3, 3) # Evicts key 2 print(lru_cache.get(2)) # Output: -1 (not found) lru_cache.put(4, 4) # Evicts key 1 print(lru_cache.get(1)) # Output: -1 (not found) print(lru_cache.get(3)) # Output: 3 print(lru_cache.get(4)) # Output: 4 print(lru_cache.state()) # Output: [(4, 4), (3, 3)] lru_cache.delete(3) print(lru_cache.state()) # Output: [(4, 4)] ``` # Performance Requirements * Ensure that all operations adhere to O(1) time complexity. * Handle cache capacity constraints efficiently. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time and space complexity of the solution must meet the requirements. * **Robustness**: Handling edge cases and constraints properly. * **Code Quality**: Clean, readable, and maintainable code.","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key in self.cache: # Move the key to the end to mark it as recently used self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: if key in self.cache: # Update value and move the key to the end to mark it as recently used self.cache[key] = value self.order.remove(key) else: if len(self.cache) >= self.capacity: # Remove the least recently used key oldest_key = self.order.pop(0) del self.cache[oldest_key] self.cache[key] = value # Add to the end to mark as recently used self.order.append(key) def delete(self, key: int) -> None: if key in self.cache: del self.cache[key] self.order.remove(key) def state(self) -> list: return [(key, self.cache[key]) for key in reversed(self.order)]"},{"question":"# Problem Statement You are given a two-dimensional grid of integers representing elevations, where each cell in the grid represents the elevation at that location. Your task is to implement a function that identifies the \\"valley points\\" in the grid. A valley point is defined as a cell in the grid where the elevation is strictly less than the elevations of its adjacent cells (top, bottom, left, and right). The function should return a list of tuples representing the coordinates of all valley points in the grid. Each tuple contains the row and column indices of a valley point. # Function Signature ```python def find_valley_points(grid: list[list[int]]) -> list[tuple[int, int]]: ``` # Input Format * A single argument: `grid` (list of list of ints, 0 <= len(grid) <= 100, 0 <= len(grid[0]) <= 100) - a two-dimensional grid where each element is an integer representing the elevation at that cell. # Output Format * Return a list of tuples - each tuple contains two integers representing the row and column indices of a valley point in the grid. # Constraints * 0 <= len(grid) <= 100 * 0 <= len(grid[0]) <= 100 * The elements in `grid` will have values within the range of [-10^6, 10^6] # Example ```python Input grid = [ [5, 3, 4], [2, 1, 6], [7, 5, 8] ] Output [(1, 1)] Input grid = [ [1, 2, 3], [2, 4, 2], [3, 2, 1] ] Output [(0, 0), (2, 2)] ``` # Notes * You must properly handle edge cases, such as when the input grid is empty or contains a single cell. * Ensure that each element\'s adjacency is considered correctly. For cells on the edges or corners, not all four comparisons might be necessary. * Do not alter the input grid while processing. # Implementation Advice * Loop through each cell in the grid and compare its elevation to those of its adjacent cells. * Pay particular attention to the grid boundaries to avoid out-of-bounds errors. * Collect and return the coordinates of cells that meet the valley point criteria efficiently.","solution":"def find_valley_points(grid): Identifies valley points in a given grid. A valley point is a cell where the elevation is strictly less than the elevations of its adjacent cells (top, bottom, left, and right). Args: grid (list of list of int): Two-dimensional grid of integers representing elevations. Returns: list of tuple of int: List of tuples representing the coordinates of valley points. if not grid or not grid[0]: return [] rows = len(grid) columns = len(grid[0]) valleys = [] for i in range(rows): for j in range(columns): cell = grid[i][j] top = grid[i - 1][j] if i > 0 else float(\'inf\') bottom = grid[i + 1][j] if i < rows - 1 else float(\'inf\') left = grid[i][j - 1] if j > 0 else float(\'inf\') right = grid[i][j + 1] if j < columns - 1 else float(\'inf\') if cell < top and cell < bottom and cell < left and cell < right: valleys.append((i, j)) return valleys"},{"question":"**Unique Meal Planner** You are developing a weekly meal planner that ensures the meals are diverse and healthy. Each meal is represented by its nutritional value (calories, protein, and dietary fiber). You need to determine if you can plan exactly one week (7 days) of meals such that the total nutritional values of the seven meals meet predefined target criteria (calories, proteins, and fibers). Your task is to write a function that checks whether it is possible to select exactly seven meals from the list that sum up to the given nutritional targets. # Function Signature ```python def unique_meal_planner(meals: list, target: tuple) -> bool: Determines if it\'s possible to select exactly seven meals that meet the nutritional targets. Parameters: - meals (list): A list of tuples where each tuple (c, p, f) represents a meal\'s calories c, proteins p, and dietary fibers f. All values are positive integers. - target (tuple): A tuple (calories_target, protein_target, fiber_target) representing the nutritional targets. All targets are positive integers. Returns: - can_plan (bool): True if exactly seven meals can be selected to meet the targets, False otherwise. # Constraints - All nutritional values and targets are positive integers. - There can be at most 50 meals. - The total of each nutritional target is within the range 1000 to 5000. # Example Consider the following examples: ```python # Example 1 meals = [(500, 30, 10), (700, 50, 20), (200, 20, 5), (800, 40, 30), (600, 60, 15), (400, 20, 25), (450, 30, 10)] target = (3650, 250, 115) assert unique_meal_planner(meals, target) == True # Example 2 meals = [(500, 30, 10), (700, 50, 20), (200, 20, 5), (300, 30, 15), (100, 10, 10), (250, 20, 5), (400, 40, 15)] target = (2500, 150, 80) assert unique_meal_planner(meals, target) == False ``` In the first example, it is possible to select the given seven meals to meet the exact nutritional targets, hence the function returns True. In the second example, there are no combinations of exactly seven meals that meet the targets, hence the function returns False.","solution":"from itertools import combinations def unique_meal_planner(meals, target): # There should be exactly 7 meals in the combination if len(meals) < 7: return False calories_target, protein_target, fiber_target = target # Generate all possible combinations of 7 meals for comb in combinations(meals, 7): calories_sum = sum(meal[0] for meal in comb) protein_sum = sum(meal[1] for meal in comb) fiber_sum = sum(meal[2] for meal in comb) # Check if the current combination meets the target if (calories_sum == calories_target and protein_sum == protein_target and fiber_sum == fiber_target): return True return False"},{"question":"Coding Assessment Question # [Question 2]: Implement In-Place Wiggle Sort II Given an unsorted array `nums`, reorder it in-place such that `nums[0] < nums[1] > nums[2] < nums[3]...`. You should implement the Wiggle Sort II algorithm which aims to rearrange the elements to form a sequence where the even indices are less than their subsequent odd indices. # Function Signature ```python def wiggleSort(nums: list) -> None: pass ``` # Input - `nums` (list of ints): The list to be reordered. # Output - The function returns `None`. It rearranges the list `nums` in place. # Constraints - List may contain up to `10^4` elements. - Elements can be negative or positive integers. - All elements in the array are guaranteed to fit within a 32-bit signed integer. - You must ensure in-place rearrangement without returning the list. # Performance Requirements - Expected time complexity: O(n log n) for sorting-based implementations or O(n) for optimized solutions. # Example ```python nums = [1, 5, 1, 1, 6, 4] wiggleSort(nums) print(nums) # Output: [1, 6, 1, 5, 1, 4] (Variation possible due to different valid orderings) nums = [1, 3, 2, 2, 3, 1] wiggleSort(nums) print(nums) # Output: [2, 3, 1, 3, 1, 2] (Variation possible due to different valid orderings) ``` # Scenarios to Validate - Ensure the wiggle sort property (nums[0] < nums[1] > nums[2] < nums[3]...) holds for the whole list. - Performance check with large lists close to the upper constraint. - Handling of lists with duplicate values. - Performance check with lists containing negative and positive integers.","solution":"def wiggleSort(nums: list) -> None: nums.sort() half = len(nums[::2]) nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]"},{"question":"# Problem Description Design a program that simulates a cashier system in a grocery store. This system must be able to perform the following actions: 1. Add items to the cart. 2. Calculate the total cost of items in the cart. 3. Apply discounts based on specific conditions. 4. Remove items from the cart. # Function Specifications 1. **add_item(item: str, price: float)**: Add an item to the cart. - **Input**: A string `item` representing the name of the item and a float `price` representing the price of the item. - **Output**: None - **Behavior**: Adds the specified item to the cart with the given price. 2. **calculate_total() -> float**: Calculate the total cost of items in the cart. - **Input**: None - **Output**: A float representing the total cost of all items in the cart. 3. **apply_discount(condition: callable, discount: float)**: Apply a discount to the total cost if the condition is met. - **Input**: A callable `condition` which takes the cart as input and returns a boolean indicating whether the discount should be applied, and a float `discount` representing the discount percentage (e.g., 0.10 for 10% discount). - **Output**: None - **Behavior**: Applies the discount if the condition is satisfied. 4. **remove_item(item: str)**: Remove an item from the cart. - **Input**: A string `item` representing the name of the item to be removed. - **Output**: None - **Behavior**: Removes the specified item from the cart. If the item does not exist, the function should do nothing. # Constraints - Item names will be unique within the cart. - Price and discount values will always be non-negative. - Only one instance of an item can exist in the cart at a time. - Discount percentages will be between 0 and 1. # Example ```python cashier = Cashier() cashier.add_item(\\"Apple\\", 1.0) cashier.add_item(\\"Banana\\", 0.5) print(cashier.calculate_total()) # Output: 1.5 cashier.apply_discount(lambda cart: sum(cart.values()) > 1, 0.10) print(cashier.calculate_total()) # Output: 1.35 cashier.remove_item(\\"Apple\\") print(cashier.calculate_total()) # Output: 0.45 ``` # Requirements - Ensure the program efficiently handles the addition and removal of items. - The program should provide accurate total cost calculations. - Carefully manage edge cases such as applying discounts with no items in the cart.","solution":"class Cashier: def __init__(self): self.cart = {} def add_item(self, item, price): self.cart[item] = price def calculate_total(self): return sum(self.cart.values()) def apply_discount(self, condition, discount): if condition(self.cart): total = self.calculate_total() new_total = total * (1 - discount) # To prevent floating point precision issues for item in self.cart: self.cart[item] = round(self.cart[item] * (1 - discount), 2) def remove_item(self, item): if item in self.cart: del self.cart[item]"},{"question":"# Context: You have been given data related to flight ticket bookings for a month. The data consists of the ticket prices for each day and is represented by an array. You are required to efficiently perform the following operations: 1. Update the ticket prices for a specific day. 2. Query the total ticket sales for a given range of days. To handle this problem efficiently, you decide to use a Fenwick Tree (Binary Indexed Tree). # Task: Complete the given Fenwick Tree class by implementing the necessary functions `update` and `query` from the template provided below: ```python class FenwickTree: def __init__(self, size: int) -> None: # Implementation details def build(self, a: list[int]) -> None: # Implementation details def update(self, idx: int, delta: int) -> None: # To be implemented by students def query(self, idx: int) -> int: # To be implemented by students def range_query(self, left: int, right: int) -> int: # To be implemented by students ``` # Requirements: - Implement the `update` function to update the value at a specific index and propagate the change up the tree. - Implement the `query` function to return the prefix sum from the start of the array to a given index. - Implement the `range_query` function to return the sum of values in the range from `left` to `right` using the `query` function. # Constraints: - 1 ≤ size ≤ 10^5 - 1 ≤ idx, left, right ≤ size - -10^6 ≤ ticket price ≤ 10^6 - The operations will be made such that the array size, updates, and queries fit within reasonable space and time needs for competitive programming. # Examples: ```python A = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] fenwick_tree = FenwickTree(10) fenwick_tree.build(A) print(fenwick_tree.range_query(1, 5)) # Should output 150 (10 + 20 + 30 + 40 + 50) fenwick_tree.update(3, 10) # Increase the price at index 3 by 10 print(fenwick_tree.range_query(1, 5)) # Should output 160 print(fenwick_tree.range_query(4, 7)) # Should output 200 (40 + 50 + 60 + 50) ```","solution":"class FenwickTree: def __init__(self, size: int) -> None: self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: for idx, value in enumerate(a, 1): self.update(idx, value) def update(self, idx: int, delta: int) -> None: while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: sum_val = 0 while idx > 0: sum_val += self.tree[idx] idx -= idx & -idx return sum_val def range_query(self, left: int, right: int) -> int: return self.query(right) - self.query(left - 1)"},{"question":"# Coding Assessment Question Context You are tasked with developing a utility function for file processing in a hypothetical text editor. The function should help users determine word frequencies of a given text file. The text file contains a sequence of words separated by spaces, newlines, or punctuation marks. Task Implement a function named `word_frequencies` that accepts a single parameter `file_path` representing the path to a plain text file. The function should read the file and return a dictionary where the keys are words, and the values are the frequencies of those words in the text. The function should handle common punctuation (e.g., .,?!;:()[]) and normalize the words to lowercase to ensure accurate counting. Function Signature ```python def word_frequencies(file_path: str) -> dict[str, int]: pass ``` Input * `file_path` (str): The path to the text file that needs to be processed. Output * A dictionary with words as keys and their frequencies as values. Constraints * The text file will be non-empty and contain only alphabetical characters and common punctuation. * Words are separated by spaces, newlines, or punctuation marks. * Value counts should be case insensitive and punctuation should not be considered part of a word. Examples Assume we have a text file `example.txt` with the following content: ``` Hello, world! This is a test. Hello again; hello. ``` ```python >>> word_frequencies(\'example.txt\') {\'hello\': 3, \'world\': 1, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 1, \'again\': 1} ``` Assume we have a text file `sample.txt` with the following content: ``` An apple a day keeps the doctor away. An apple a day indeed. ``` ```python >>> word_frequencies(\'sample.txt\') {\'an\': 2, \'apple\': 2, \'a\': 2, \'day\': 2, \'keeps\': 1, \'the\': 1, \'doctor\': 1, \'away\': 1, \'indeed\': 1} ``` Additional Notes * You can use any standard Python library for reading the file and processing the text. * Handle file reading exceptions appropriately. * Don\'t include numeric values or special characters in the word count. Only consider alphabetical characters after normalizing.","solution":"import re from collections import defaultdict def word_frequencies(file_path: str) -> dict: Reads a text file and returns a dictionary with word frequencies. Words are normalized to lowercase and punctuation is ignored. word_count = defaultdict(int) try: with open(file_path, \'r\') as file: contents = file.read() # Normalize to lowercase and split using regex to ignore punctuation words = re.findall(r\'bw+b\', contents.lower()) for word in words: word_count[word] += 1 except FileNotFoundError: print(\\"File not found. Please check the provided file path.\\") return dict(word_count)"},{"question":"# Coding Assessment Question: Scenario: You are working for a data analytics company that deals with large-scale financial transaction data. Your team needs a way to efficiently summarize and query the data to provide insights to the clients. You decide to implement a data structure that can support efficient range sum queries. Task: Write a class `TransactionData` that: 1. Accepts a list of integers representing daily transaction amounts during initialization. 2. Implements a method `update` that takes two arguments: an index `i` and a value `val`, updating the transaction amount at index `i` to `val`. 3. Implements a method `sumRange` that takes two arguments `left` and `right`, and returns the sum of transactions between the indices `left` and `right` inclusive. Constraints: * The length of the transactions list `n` will be between 1 and 10^5. * The transaction amounts will be between -10^5 and 10^5. * The number of queries (updates and sumRange calls) will be between 1 and 10^4. Class Signature: ```python class TransactionData: def __init__(self, transactions: List[int]): pass def update(self, i: int, val: int) -> None: pass def sumRange(self, left: int, right: int) -> int: pass ``` Input: * `transactions`: A list of integers representing the daily transaction amounts. * `i`: An integer representing the index to update. * `val`: An integer representing the new transaction amount at index `i`. * `left` and `right`: Integers representing the indices for the sum range query. Output: * `update`: This method does not return a value. * `sumRange`: Returns the sum of the transactions between the indices `left` and `right` inclusive. Performance Requirements: * The implementation should use an efficient data structure (e.g., Fenwick Tree or Segment Tree) to handle large input sizes and frequent updates/queries. Example: ```python # Initialize the transaction data transactions = [1, 3, 5] trans_data = TransactionData(transactions) # Perform a sum range query (from index 0 to 2) print(trans_data.sumRange(0, 2)) # Output: 9 # Update the transaction at index 1 to 2 trans_data.update(1, 2) # Perform the sum range query again (from index 0 to 2) print(trans_data.sumRange(0, 2)) # Output: 8 ``` Note: * Ensure your class handles initialization, updates, and range queries efficiently. * You may use any efficient data structure for range sum queries as necessary.","solution":"class TransactionData: def __init__(self, transactions): self.n = len(transactions) self.transactions = transactions self.tree = [0] * self.n + transactions # Binary Indexed Tree initialized for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, i, val): # Update the value in transactions and tree pos = i + self.n self.tree[pos] = val while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def sumRange(self, left, right): # Calculate range sum from left to right left += self.n right += self.n sum = 0 while left <= right: if left % 2 == 1: sum += self.tree[left] left += 1 if right % 2 == 0: sum += self.tree[right] right -= 1 left //= 2 right //= 2 return sum"},{"question":"# Problem: Implementing Prim\'s Algorithm for Minimum Spanning Tree You are tasked with implementing Prim\'s Algorithm to find the Minimum Spanning Tree (MST) of a given connected, undirected graph with weighted edges. Prim\'s Algorithm is a greedy algorithm that builds the MST by selecting edges with the smallest weights and ensuring no cycles are formed. Your task is to write a function `prims_algorithm` which takes in the following parameter: - `graph`: An adjacency matrix of an undirected weighted graph, where `graph[i][j]` represents the weight of the edge between vertex `i` and vertex `j`. If there is no edge, the weight will be represented by `float(\'inf\')`. The function should return a list of edges that constitute the MST. Each edge should be represented as a tuple `(u, v, weight)` where `u` and `v` are the vertices connected by the edge, and `weight` is the weight of the edge. # Constraints: - The graph is represented by an `n x n` adjacency matrix, where `n` is the number of vertices. - The input graph is connected, meaning there is a path between any two vertices. - The weights are non-negative. # Expected Function Signature: ```python def prims_algorithm(graph: List[List[float]]) -> List[Tuple[int, int, float]]: pass ``` # Example: ```python # Example graph adjacency matrix representation graph = [[0, 2, float(\'inf\'), 6, float(\'inf\')], [2, 0, 3, 8, 5], [float(\'inf\'), 3, 0, float(\'inf\'), 7], [6, 8, float(\'inf\'), 0, 9], [float(\'inf\'), 5, 7, 9, 0]] mst = prims_algorithm(graph) print(mst) # Output would be a list of edges in the MST: # e.g., [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] ``` # Notes: 1. Ensure your solution efficiently handles adjacency matrices using appropriate data structures to minimize complexity. 2. You can assume that `graph[i][j]` will always be equal to `graph[j][i]`. 3. The function should efficiently construct the MST using a priority queue to select the minimum weight edge at every step of the algorithm. Your function will be tested with various graphs of different sizes and configurations to ensure correctness and performance.","solution":"import heapq from typing import List, Tuple def prims_algorithm(graph: List[List[float]]) -> List[Tuple[int, int, float]]: n = len(graph) visited = [False] * n edge_list = [] min_heap = [(0, 0, -1)] # (weight, to_node, from_node) while min_heap: weight, to_node, from_node = heapq.heappop(min_heap) if visited[to_node]: continue visited[to_node] = True if from_node != -1: edge_list.append((from_node, to_node, weight)) for next_node in range(n): if not visited[next_node] and graph[to_node][next_node] != float(\'inf\'): heapq.heappush(min_heap, (graph[to_node][next_node], next_node, to_node)) return edge_list"},{"question":"# Coding Assessment Question Scenario You are developing a function to calculate the n-th Fibonacci number, which is a number in a sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1. However, for this task, you must optimize the function to handle large values of n efficiently using dynamic programming to ensure a fast runtime. Problem Statement Implement a function that calculates the n-th Fibonacci number using dynamic programming. Function Requirements and Constraints 1. **Function Signature** ```python def fibonacci(n: int) -> int ``` 2. **Parameters**: * `n` - a non-negative integer representing the position in the Fibonacci sequence. (0 <= n <= 10^5) 3. **Return Values**: * The function should return the n-th Fibonacci number. Example Cases * `fibonacci(0)` should return `0` * `fibonacci(1)` should return `1` * `fibonacci(10)` should return `55` * `fibonacci(50)` should return `12586269025` * `fibonacci(100)` should return `354224848179261915075` # Function Description 1. **Function: `fibonacci(n: int) -> int`** - Implement a function that calculates the n-th Fibonacci number using dynamic programming to optimize the calculation time for large values of n. - You should create an array or list to store the Fibonacci numbers up to `n` and iteratively fill it based on the Fibonacci recurrence relation: `F(n) = F(n-1) + F(n-2)`. - Ensure the function can handle the upper limit efficiently (n = 10^5). **Note**: Pay attention to the potential constraints on memory usage and time efficiency for large inputs. Use techniques that ensure the function runs quickly and efficiently even for the largest values of n.","solution":"def fibonacci(n: int) -> int: Calculate the n-th Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i-1] + fib[i-2] return fib[n]"},{"question":"# Introduction In a given directory, you need to find the longest path of folders/files. A path consists of directory names and file names separated by the \'/\' character, with each subdirectory or file name being a separate component in the path. The length of the path is the sum of the lengths of the names of all components plus the number of separators (\'/\') required. # Task Write a function named `longest_path(directory: str) -> str` to find and return the longest path in the given directory string. The directory input is a single string formatted as nested folder structures and file names. # Requirements * **Function Signature**: `def longest_path(directory: str) -> str:` * **Input**: A single string `directory` containing the entire directory structure with subdirectories and files separated by newline (\'n\') characters and indented with a tab character (\'t\') to denote levels of nesting. * **Output**: A single string representing the longest path within the directory. # Constraints 1. The path components (directories and files) consist of alphanumeric characters and possibly dots. 2. The input string can be empty; in such a case, return an empty string. 3. Consider leading and trailing whitespace, but the core names are always alphanumeric with possible periods for separating extension in files. 4. Assume proper directory structure is passed; no need to validate the format beyond handling described edge cases. # Examples ```python >>> directory = \\"dirntsubdir1ntsubdir2nttfile.ext\\" >>> longest_path(directory) \'dir/subdir2/file.ext\' >>> directory = \\"dirntsubdir1nttfile1.extntsubdir2nttsubsubdir1ntttsubsubsubdir1nttttfile2.ext\\" >>> longest_path(directory) \'dir/subdir2/subsubdir1/subsubsubdir1/file2.ext\' >>> directory = \\"dir1ntdir2nttdir3\\" >>> longest_path(directory) \'dir1/dir2/dir3\' >>> directory = \\"\\" >>> longest_path(directory) \'\' ``` # Additional Notes * Test your function thoroughly with various test cases including complex nested structures for robust solutions. * Use a stack or similar data structure to manage the current path as you iterate through levels of nesting. * Ensure to handle edge cases like directories with no files, multiple subdirectories, and varying levels of nesting when determining the longest path.","solution":"def longest_path(directory: str) -> str: Finds and returns the longest path in the given directory string. Args: - directory: str: A single string formatted as nested folder structures and file names. Returns: - str: The longest path within the directory. if not directory: return \'\' max_len = 0 max_path = \\"\\" path_stack = [] current_path_len = 0 for line in directory.split(\'n\'): level = line.count(\'t\') name = line.replace(\'t\', \'\') while len(path_stack) > level: removed_len = len(path_stack.pop()) current_path_len -= removed_len + 1 path_stack.append(name) current_path_len += len(name) + 1 if \'.\' in name: if current_path_len - 1 > max_len: max_len = current_path_len - 1 max_path = \\"/\\".join(path_stack) return max_path"},{"question":"In this exercise, you are tasked with implementing a system to process and manage a set of records for employees within a company. Each employee record consists of a name, age, department, and salary. The system should support adding new records, updating existing records, deleting records, and retrieving records meeting specific criteria. # Class to Implement 1. **EmployeeRecordSystem**: This class should manage a list of employee records and provide methods for the operations described below. # Methods to Implement 1. **add_employee**(name: str, age: int, department: str, salary: float) -> None: Add a new employee record to the system. 2. **update_employee**(name: str, age: Optional[int] = None, department: Optional[str] = None, salary: Optional[float] = None) -> bool: Update the existing employee record with the specified name. If the employee does not exist, return `False`. Otherwise, return `True`. 3. **delete_employee**(name: str) -> bool: Delete the employee record with the specified name. If the employee does not exist, return `False`. Otherwise, return `True`. 4. **get_employees_by_department**(department: str) -> List[Dict[str, Union[str, int, float]]]: Return a list of all employees in the specified department. 5. **get_employees_above_salary**(salary: float) -> List[Dict[str, Union[str, int, float]]]: Return a list of all employees with a salary above the specified amount. # Input and Output * **Input**: - For **add_employee**: `name` (string), `age` (integer), `department` (string), and `salary` (float). - For **update_employee**: `name` (string), and optionally `age` (integer), `department` (string), and `salary` (float). - For **delete_employee**: `name` (string). - For **get_employees_by_department**: `department` (string). - For **get_employees_above_salary**: `salary` (float). * **Output**: - For **add_employee**: None - For **update_employee**: Boolean - For **delete_employee**: Boolean - For **get_employees_by_department** and **get_employees_above_salary**: A list of dictionaries; each dictionary should have the keys: \\"name\\", \\"age\\", \\"department\\", and \\"salary\\". # Example ```python class EmployeeRecordSystem: def __init__(self): self.records = [] def add_employee(self, name: str, age: int, department: str, salary: float) -> None: pass def update_employee(self, name: str, age: Optional[int] = None, department: Optional[str] = None, salary: Optional[float] = None) -> bool: pass def delete_employee(self, name: str) -> bool: pass def get_employees_by_department(self, department: str) -> List[Dict[str, Union[str, int, float]]]: pass def get_employees_above_salary(self, salary: float) -> List[Dict[str, Union[str, int, float]]]: pass # Example usage: system = EmployeeRecordSystem() system.add_employee(\\"Alice\\", 30, \\"Engineering\\", 70000) system.add_employee(\\"Bob\\", 25, \\"Marketing\\", 50000) system.add_employee(\\"Charlie\\", 32, \\"Engineering\\", 80000) print(system.get_employees_by_department(\\"Engineering\\")) # Example Output: [{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, # {\\"name\\": \\"Charlie\\", \\"age\\": 32, \\"department\\": \\"Engineering\\", \\"salary\\": 80000}] print(system.get_employees_above_salary(60000)) # Example Output: [{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"department\\": \\"Engineering\\", \\"salary\\": 70000}, # {\\"name\\": \\"Charlie\\", \\"age\\": 32, \\"department\\": \\"Engineering\\", \\"salary\\": 80000}] ```","solution":"from typing import List, Dict, Union, Optional class EmployeeRecordSystem: def __init__(self): self.records = [] def add_employee(self, name: str, age: int, department: str, salary: float) -> None: self.records.append({ \\"name\\": name, \\"age\\": age, \\"department\\": department, \\"salary\\": salary }) def update_employee(self, name: str, age: Optional[int] = None, department: Optional[str] = None, salary: Optional[float] = None) -> bool: for record in self.records: if record[\\"name\\"] == name: if age is not None: record[\\"age\\"] = age if department is not None: record[\\"department\\"] = department if salary is not None: record[\\"salary\\"] = salary return True return False def delete_employee(self, name: str) -> bool: for i, record in enumerate(self.records): if record[\\"name\\"] == name: del self.records[i] return True return False def get_employees_by_department(self, department: str) -> List[Dict[str, Union[str, int, float]]]: return [record for record in self.records if record[\\"department\\"] == department] def get_employees_above_salary(self, salary: float) -> List[Dict[str, Union[str, int, float]]]: return [record for record in self.records if record[\\"salary\\"] > salary]"},{"question":"Implement a function that calculates and retrieves cryptocurrency data from the CoinGecko API. The objective is to process input robustly, make API requests, and efficiently handle and format the response data. # Function to Implement Implement a function `get_crypto_data(crypto_id: str) -> dict` that takes a cryptocurrency ID string and returns a dictionary summarizing the cryptocurrency\'s current data. The dictionary should contain the following fields: - \\"Name\\" - \\"Symbol\\" - \\"Current Price\\" - \\"Market Cap\\" - \\"24h Trading Volume\\" - \\"24h High\\" - \\"24h Low\\" - \\"Price Change Percentage (24h)\\" # Constraints * The cryptocurrency ID is a string that represents a valid cryptocurrency on CoinGecko (e.g., \\"bitcoin\\", \\"ethereum\\"). * Your function should handle invalid cryptocurrency IDs gracefully by returning an empty dictionary. * In case of any errors during the API request or JSON parsing, your function should return an empty dictionary. * You can assume the cryptocurrency ID input is valid and does not require further validation within the function. # Expected Input and Output * **Input**: A valid cryptocurrency ID string. * **Output**: A dictionary summarizing the current cryptocurrency data, with the keys mentioned above. If the cryptocurrency data is incomplete, include only the available keys. # Example ```python get_crypto_data(\\"bitcoin\\") ``` Expected output: ```python { \\"Name\\": \\"Bitcoin\\", \\"Symbol\\": \\"BTC\\", \\"Current Price\\": 47654.23, \\"Market Cap\\": 923872749123, \\"24h Trading Volume\\": 35482374923, \\"24h High\\": 48234.34, \\"24h Low\\": 46783.89, \\"Price Change Percentage (24h)\\": -1.83 } ``` Use the `requests` module to make the HTTP call and handle possible exceptions. Remember to handle JSON decoding errors and missing fields appropriately.","solution":"import requests def get_crypto_data(crypto_id: str) -> dict: url = f\\"https://api.coingecko.com/api/v3/coins/{crypto_id}\\" try: response = requests.get(url) response.raise_for_status() # Raise an exception for HTTP errors data = response.json() result = { \\"Name\\": data[\'name\'], \\"Symbol\\": data[\'symbol\'].upper(), \\"Current Price\\": data[\'market_data\'][\'current_price\'][\'usd\'], \\"Market Cap\\": data[\'market_data\'][\'market_cap\'][\'usd\'], \\"24h Trading Volume\\": data[\'market_data\'][\'total_volume\'][\'usd\'], \\"24h High\\": data[\'market_data\'][\'high_24h\'][\'usd\'], \\"24h Low\\": data[\'market_data\'][\'low_24h\'][\'usd\'], \\"Price Change Percentage (24h)\\": data[\'market_data\'][\'price_change_percentage_24h\'], } return result except (requests.RequestException, KeyError, ValueError): # Handle unexpected data structure and network exceptions return {}"},{"question":"# Longest Prefix Matching **Context**: You are tasked with implementing a URL router for a web service. The router will determine the correct route handler based on the longest prefix of the requested path that exists in a predefined list of routes. **Objective**: Implement the function `longest_prefix_matching` which uses a trie data structure to efficiently find the best matching route based on the list of predefined routes. # Requirements 1. **Input**: - A list `routes` of `m` strings where `1 ≤ m ≤ 10^4`. - A string `path` representing the requested URL path. 2. **Output**: - A string representing the longest matching route from the list that is a prefix of the given path. If no such route exists, return an empty string. 3. **Constraints**: - Route and path strings will contain only lowercase alphabetic characters and slashes. - Route strings are always prefixes and do not necessarily terminate with a slash. # Function Signature ```python from typing import List def longest_prefix_matching(routes: List[str], path: str) -> str: pass ``` # Example ```python assert longest_prefix_matching([\\"/home\\", \\"/home/about\\", \\"/home/products\\"], \\"/home/about/us\\") == \\"/home/about\\" assert longest_prefix_matching([\\"/api/v1\\", \\"/api/v2\\", \\"/api\\"], \\"/api/v2/users\\") == \\"/api/v2\\" assert longest_prefix_matching([\\"/home\\", \\"/about\\"], \\"/contact\\") == \\"\\" assert longest_prefix_matching([\\"/\\"], \\"/any/path\\") == \\"/\\" ``` # Implementation Notes - Use a trie for efficient prefix matching. - Ensure the algorithm runs in O(n) time for insertion and O(m) time for searching, where n is the total length of all routes and m is the length of the path.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_route = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, route: str): current = self.root for char in route: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_route = True def search_longest_prefix(self, path: str) -> str: current = self.root longest_prefix = \\"\\" temp_prefix = \\"\\" for char in path: if char in current.children: current = current.children[char] temp_prefix += char if current.is_end_of_route: longest_prefix = temp_prefix else: break return longest_prefix def longest_prefix_matching(routes: List[str], path: str) -> str: trie = Trie() for route in routes: trie.insert(route) return trie.search_longest_prefix(path)"},{"question":"# Objective Write a function `is_palindrome_permutation` to determine if a given string is a permutation of a palindrome. This means the string can be rearranged to form a palindrome. # Input & Output * **Input**: A single string `s`. * **Output**: A boolean value - `True` if the string is a permutation of a palindrome, `False` otherwise. # Constraints 1. The function should be case-insensitive. 2. Ignore spaces and non-alphanumeric characters. 3. The function should have optimal performance with a time complexity of O(n) and space complexity of O(1). # Example ```python # Example 1 # Input: \\"Taco cat\\" # Output: True # Explanation: \\"Taco cat\\" can be rearranged to form \\"tacocat\\", which is a palindrome. # Example 2 # Input: \\"Hello\\" # Output: False # Explanation: \\"Hello\\" cannot be rearranged to form a palindrome. # Example 3 # Input: \\"Able was I ere I saw Elba\\" # Output: True # Explanation: \\"Able was I ere I saw Elba\\" can be rearranged to form \\"AblewasiereIsawelba\\", which is a palindrome. ``` # Scenario Consider that you are working on a text processing system that needs to identify if a given input can potentially be a palindrome after rearranging it. This functionality is essential for optimizing searches and analyzing text patterns. # Function Signature ```python def is_palindrome_permutation(s: str) -> bool: pass ```","solution":"def is_palindrome_permutation(s: str) -> bool: Determines if a string is a permutation of a palindrome. from collections import Counter # Normalize the string: make it case insensitive and remove non-alphanumeric characters normalized_str = \'\'.join(c.lower() for c in s if c.isalnum()) # Count the frequency of each character char_count = Counter(normalized_str) # To be a permutation of a palindrome, there must be at most one character with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Problem Statement You are given a matrix of integers representing a grid. Your task is to implement a function `island_count(grid: list[list[int]]) -> int` that returns the number of islands in the grid. An island is defined as a group of `1`s (representing land) connected horizontally or vertically (not diagonally). The border of the grid is surrounded by water, which is represented by `0`s. Each cell may either be a `1` (land) or `0` (water). # Input - `grid`: A list of lists of integers representing the grid (1 ≤ len(grid), len(grid[0]) ≤ 300). # Output - An integer representing the number of islands in the grid. # Constraints - The grid is surrounded by water. - 1 ≤ len(grid), len(grid[0]) ≤ 300. # Requirements - Time Complexity: O(m * n) where m is the number of rows and n is the number of columns. - Space Complexity: O(m * n) # Example ```python assert island_count([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ]) == 3 assert island_count([ [1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 1] ]) == 4 ``` # Function Signature ```python def island_count(grid: list[list[int]]) -> int: ``` # Scenario In a mapping system for disaster response, you might need to identify isolated land masses (islands) in a grid. Implement the `island_count` function that accepts a 2D grid map and returns the count of distinct islands. This helps in better planning and allocation of resources during natural calamities. # Requirements To solve this problem, you might use a depth-first search (DFS) or breadth-first search (BFS) algorithm to traverse the grid and count the number of disconnected components (islands). Use the space complexity efficiently.","solution":"def island_count(grid: list[list[int]]) -> int: def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 # Mark as visited directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dr, dc in directions: dfs(r + dr, c + dc) if not grid: return 0 row, col = len(grid), len(grid[0]) count = 0 for r in range(row): for c in range(col): if grid[r][c] == 1: count += 1 dfs(r, c) return count"},{"question":"# Question: Generate Sequential User IDs **Context:** Suppose you are working on a web application that manages user accounts. Each user is assigned a unique User ID (UID) sequentially, starting from a predefined initial value. To maintain system performance and to ensure that the UIDs are unique and sequential, the task of generating new UIDs needs to be efficient and reliable. **Problem Statement:** Write a class `UserIDManager` that manages user IDs in a web application. It should have methods to initialize the manager with a starting ID, generate the next sequential ID, and reset the ID generator. **Requirements:** 1. The class should ensure that UIDs are always unique and follow a sequential order. 2. The method to generate the next UID should be efficient, considering that the system might need to generate IDs frequently. 3. The method to reset the ID generator should allow the resetting of the next ID to a predefined starting value. **Class Signature:** ```python class UserIDManager: def __init__(self, starting_id: int): pass def get_next_id(self) -> int: pass def reset(self, new_start_id: int) -> None: pass ``` **Input:** * `starting_id`: An integer representing the initial value of the UID generator. * `new_start_id`: An integer representing the new starting value for the UID generator after a reset. **Output:** * `get_next_id`: Should return the next unique sequential UID as an integer. * `reset`: Should not return anything (`None`), but reset the UID generator to start from the `new_start_id`. **Constraints:** * The `starting_id` and `new_start_id` must be non-negative integers. **Examples:** ```python # Example 1: uid_manager = UserIDManager(1000) print(uid_manager.get_next_id()) # Expected output: 1000 print(uid_manager.get_next_id()) # Expected output: 1001 # Example 2: uid_manager.reset(2000) print(uid_manager.get_next_id()) # Expected output: 2000 print(uid_manager.get_next_id()) # Expected output: 2001 # Example 3: uid_manager.reset(0) print(uid_manager.get_next_id()) # Expected output: 0 ``` Ensure that your implementation is efficient and handles the generation and reset operations seamlessly.","solution":"class UserIDManager: def __init__(self, starting_id: int): Initialize the UID manager with a starting ID. self.current_id = starting_id def get_next_id(self) -> int: Generate the next unique sequential UID. next_id = self.current_id self.current_id += 1 return next_id def reset(self, new_start_id: int) -> None: Reset the UID generator to start from the new starting value. self.current_id = new_start_id"},{"question":"**Shortest Path in Weighted Grid** You are developing software for a delivery company that navigates a city grid. The streets are represented as a 2D grid where each cell contains a non-negative integer representing the time (in minutes) required to travel through that cell. To ensure the fastest delivery, you need to determine the shortest possible time to get from the top-left corner of the grid to the bottom-right corner. Your task is to implement a function `shortest_path` that takes a 2D list of integers (representing the grid) and returns the shortest time to travel from the top-left to the bottom-right corner. You can move to adjacent cells in the grid (left, right, up, down) but not diagonally. # Function Signature ```python def shortest_path(grid: list[list[int]]) -> int: ``` # Input * `grid` (list[list[int]]): A 2D list of integers where `1 ≤ len(grid), len(grid[0]) ≤ 100` and each cell value is `0 ≤ grid[i][j] ≤ 10`. # Output * `int`: The shortest time (in minutes) to travel from the top-left to the bottom-right corner. # Constraints * The grid dimensions are at least 1x1 and at most 100x100. * All cells contain non-negative integers representing time costs. * Moving off the grid is not allowed. * The grid is guaranteed to have at least one valid path from the top-left to the bottom-right corner. # Examples ```python shortest_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) # Expected output: 7 shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Expected output: 21 shortest_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) # Expected output: 5 ``` # Notes 1. Use an appropriate algorithm (such as Dijkstra’s or A*) to ensure efficiency. 2. Ensure that your solution handles all edge cases (e.g., single-cell grids). 3. Minimize the time complexity to handle the upper limits of the constraints efficiently. # Test Case Note The function should pass all given examples and handle various grid sizes and values within the specified constraints. Specific error handling and input validation are part of the task.","solution":"import heapq def shortest_path(grid): Returns the shortest path time from the top-left to the bottom-right corner in a weighted grid. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up # Priority queue to manage the exploration of cells, initialized with the starting point pq = [(grid[0][0], 0, 0)] # (current_time, row, col) min_time = [[float(\'inf\')] * cols for _ in range(rows)] min_time[0][0] = grid[0][0] while pq: current_time, r, c = heapq.heappop(pq) # If we reached the bottom-right corner, return the current_time if r == rows - 1 and c == cols - 1: return current_time for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: new_time = current_time + grid[nr][nc] if new_time < min_time[nr][nc]: min_time[nr][nc] = new_time heapq.heappush(pq, (new_time, nr, nc)) return min_time[rows - 1][cols - 1]"},{"question":"# Coding Assessment Question You are required to extend a program that interacts with a public API for fetching weather data. The existing implementation fetches current weather data for a specified city using OpenWeatherMap API. Now, extend the functionality to include fetching the weather forecast for the next 7 days for a specified city. Task: 1. Implement a function `get_weather_forecast(api_key: str, city: str) -> list` that: - Fetches the 7-day weather forecast data from the OpenWeatherMap API for the specified city. - Returns a list of dictionaries, each containing daily forecast data (date, temperature, weather description). 2. Optimize the error handling in the existing `get_current_weather` function to manage edge cases, such as invalid city names or network issues. Expected Input and Output: * `get_weather_forecast`: - **Input**: `api_key`: str, `city`: str - **Output**: List of dictionaries (each dictionary should contain \'date\', \'temperature\', \'weather_description\'). * `get_current_weather`: - **Input**: `api_key`: str, `city`: str - **Output**: Returns the current weather data as a dictionary (containing \'temperature\', \'weather_description\'), or an error message in case of failure. Constraints: - The API key and city name will be non-empty strings. - The city name will be a valid city recognized by the OpenWeatherMap API. Performance Requirements: - Ensure network requests are handled efficiently. - Include robust error handling to manage potential issues (e.g., invalid API key, network timeout). Hints: - Utilize Python\'s `requests` library for making HTTP requests. - Handle JSON responses and potential exceptions gracefully. Implement the following: ```python import requests def get_weather_forecast(api_key: str, city: str) -> list: Fetch the 7-day weather forecast for the given city. url = f\\"http://api.openweathermap.org/data/2.5/forecast/daily\\" params = { \\"q\\": city, \\"cnt\\": 7, \\"appid\\": api_key, \\"units\\": \\"metric\\" } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"list\\"] result = [] for day in data: result.append({ \\"date\\": day[\\"dt\\"], \\"temperature\\": day[\\"temp\\"][\\"day\\"], \\"weather_description\\": day[\\"weather\\"][0][\\"description\\"] }) return result except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return [] def get_current_weather(api_key: str, city: str) -> dict: Fetch the current weather for the given city. url = f\\"http://api.openweathermap.org/data/2.5/weather\\" params = { \\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\" } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() weather_data = response.json() result = { \\"temperature\\": weather_data[\\"main\\"][\\"temp\\"], \\"weather_description\\": weather_data[\\"weather\\"][0][\\"description\\"] } return result except requests.RequestException as e: return {\\"error\\": str(e)} ```","solution":"import requests def get_weather_forecast(api_key: str, city: str) -> list: Fetch the 7-day weather forecast for the given city. url = f\\"http://api.openweathermap.org/data/2.5/onecall\\" try: # First, get the latitude and longitude of the city geocode_url = f\\"http://api.openweathermap.org/data/2.5/weather\\" geocode_params = { \\"q\\": city, \\"appid\\": api_key, } geocode_response = requests.get(geocode_url, params=geocode_params, timeout=10) geocode_response.raise_for_status() geocode_data = geocode_response.json() lat = geocode_data[\'coord\'][\'lat\'] lon = geocode_data[\'coord\'][\'lon\'] # Now fetch the 7-day forecast using the coordinates params = { \\"lat\\": lat, \\"lon\\": lon, \\"exclude\\": \\"current,minutely,hourly\\", \\"appid\\": api_key, \\"units\\": \\"metric\\" } response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"daily\\"] result = [] for day in data[:7]: # Only take the next 7 days result.append({ \\"date\\": day[\\"dt\\"], \\"temperature\\": day[\\"temp\\"][\\"day\\"], \\"weather_description\\": day[\\"weather\\"][0][\\"description\\"] }) return result except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return [] def get_current_weather(api_key: str, city: str) -> dict: Fetch the current weather for the given city. url = f\\"http://api.openweathermap.org/data/2.5/weather\\" params = { \\"q\\": city, \\"appid\\": api_key, \\"units\\": \\"metric\\" } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() weather_data = response.json() result = { \\"temperature\\": weather_data[\\"main\\"][\\"temp\\"], \\"weather_description\\": weather_data[\\"weather\\"][0][\\"description\\"] } return result except requests.RequestException as e: return {\\"error\\": str(e)}"},{"question":"# Text File Manipulation Task Scenario You are asked to automate the process of summarizing log files generated by an application. The log files are plain text files where each line represents a log entry with a specific format. Your task is to implement a function that reads a log file, analyzes its content, and generates a summary report detailing the count of each type of log entry (e.g., ERROR, WARNING, INFO). Requirements Implement a function `summarize_logs()` that processes a log file and generates a summary with the following features: 1. **Log Type Counting**: * Count the occurrences of each log type (e.g., ERROR, WARNING, INFO). 2. **Summarize Daily Entries**: * Provide a count of each log type per day, assuming each log entry includes a timestamp formatted as `YYYY-MM-DD HH:MM:SS`. 3. **Graceful Handling of Missing Log Types**: * If a log type is absent from the file, it should be mentioned in the summary with a count of 0. Function Signature ```python def summarize_logs(file_path: str) -> dict: pass ``` Input * `file_path` (str): The path to the log file to be analyzed. Output * Returns a dictionary where each key is a date (str), and its value is another dictionary with log types as keys (e.g., ERROR, WARNING, INFO) and their counts (int) as values. Constraints * Assume log entries are well-formed and contain only the mentioned types (ERROR, WARNING, INFO). * The function should read the file line by line to handle large files efficiently. * Use standard libraries only (e.g., `datetime` for date manipulation). Example Log File Content ``` 2023-08-01 12:45:23 ERROR Failed to connect to database 2023-08-01 14:15:00 INFO User logged in 2023-08-01 14:20:10 WARNING Disk space running low 2023-08-02 09:01:12 INFO Scheduled maintenance completed 2023-08-02 11:25:45 INFO User logged out 2023-08-02 11:30:22 ERROR Timeout while processing request ``` Test Case Example Input: ```python file_path = \\"sample_log.txt\\" ``` Expected Output: ```python { \\"2023-08-01\\": {\\"ERROR\\": 1, \\"WARNING\\": 1, \\"INFO\\": 1}, \\"2023-08-02\\": {\\"ERROR\\": 1, \\"WARNING\\": 0, \\"INFO\\": 2} } ```","solution":"from collections import defaultdict import datetime def summarize_logs(file_path: str) -> dict: Summarizes log entries in a given log file by date and log type. Args: - file_path (str): The path to the log file to be analyzed. Returns: - dict: A dictionary where each key is a date (str), and its value is another dictionary with log types as keys and their counts as values. summary = defaultdict(lambda: defaultdict(int)) log_types = [\'ERROR\', \'WARNING\', \'INFO\'] with open(file_path, \'r\') as file: for line in file: try: date_str, time_str, log_type, _ = line.split(\' \', 3) date = datetime.datetime.strptime(date_str, \'%Y-%m-%d\').date() if log_type in log_types: summary[str(date)][log_type] += 1 except ValueError: continue dates = summary.keys() for date in dates: for log_type in log_types: if log_type not in summary[date]: summary[date][log_type] = 0 # Convert defaultdict to a regular dict before returning result = {date: dict(types) for date, types in summary.items()} return result"},{"question":"# Coding Assessment Question: You are tasked with developing a simplified library management system to manage book inventories and user accounts. This system should allow adding new books, borrowing books, returning books, and viewing the current status of books and user accounts. Objectives: 1. **Book Management**: Implement functionality to add new books to the inventory. Each book should have attributes like title, author, and ISBN. 2. **User Account Management**: Implement functionality to add new users to the library system. Each user should have attributes like name, user ID, and a list of borrowed books. 3. **Borrowing and Returning Books**: Add features to allow users to borrow and return books, ensuring that no book can be borrowed more than once or returned if not borrowed. 4. **Status Viewing**: Implement methods to display the current status of all books (showing availability) and the details of users (including the list of borrowed books). Function Specification: * **Expected Input and Output Formats**: - **Input**: Strings for book titles, authors, ISBNs, and user names; integers for user IDs. - **Output**: Relevant messages for user actions, and lists or dictionaries for status views. * **Constraints and Limitations**: - Assume valid, non-empty strings for book and user information. - Handle scenarios where users try to borrow unavailable books or return books not borrowed by them. - Ensure that a user can borrow up to a maximum of three books at a time. Implementation Requirements: 1. Create a class `Library` which: - Adds new books with the method `add_book`. - Adds new users with the method `add_user`. - Allows users to borrow books with the method `borrow_book`. - Allows users to return books with the method `return_book`. - Displays the status of books with the method `show_books`. - Displays user details with the method `show_user_details`. 2. Ensure that borrowed books are marked as unavailable and can only be returned by the user who borrowed them. 3. Implement appropriate error handling for invalid operations (e.g., borrowing a book that is already borrowed, returning a book that is not borrowed). 4. Include comments and documentation for clarity. Function Signature: ```python from typing import Dict, List class Library: def __init__(self): self.books = {} self.users = {} def add_book(self, title: str, author: str, isbn: str) -> None: Adds a new book to the library inventory. # Implementation goes here. def add_user(self, name: str, user_id: int) -> None: Adds a new user to the library system. # Implementation goes here. def borrow_book(self, user_id: int, isbn: str) -> str: Allows a user to borrow a book if available. # Implementation goes here. def return_book(self, user_id: int, isbn: str) -> str: Allows a user to return a book they had borrowed. # Implementation goes here. def show_books(self) -> List[Dict]: Displays the current status of all books. # Implementation goes here. def show_user_details(self, user_id: int) -> Dict: Displays the details of a specific user. # Implementation goes here. ``` # Example Usage: ```python # Initialize the library system library = Library() # Add books to the inventory library.add_book(\\"1984\\", \\"George Orwell\\", \\"123456789\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"987654321\\") # Add users to the system library.add_user(\\"Alice\\", 1) library.add_user(\\"Bob\\", 2) # User borrows a book print(library.borrow_book(1, \\"123456789\\")) # Output: \\"Book borrowed successfully.\\" # User tries to borrow an unavailable book print(library.borrow_book(2, \\"123456789\\")) # Output: \\"Book is not available.\\" # User returns a book print(library.return_book(1, \\"123456789\\")) # Output: \\"Book returned successfully.\\" # View the status of books print(library.show_books()) # View user details print(library.show_user_details(1)) ``` Ensure your implementation is efficient, handles edge cases appropriately, and includes necessary documentation and comments for understanding.","solution":"from typing import Dict, List class Library: MAX_BORROW = 3 def __init__(self): self.books = {} self.users = {} def add_book(self, title: str, author: str, isbn: str) -> None: Adds a new book to the library inventory. self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"available\\": True, \\"borrowed_by\\": None } def add_user(self, name: str, user_id: int) -> None: Adds a new user to the library system. self.users[user_id] = { \\"name\\": name, \\"borrowed_books\\": [] } def borrow_book(self, user_id: int, isbn: str) -> str: Allows a user to borrow a book if available. if user_id not in self.users: return \\"User not found.\\" if isbn not in self.books: return \\"Book not found.\\" user = self.users[user_id] book = self.books[isbn] if not book[\\"available\\"]: return \\"Book is not available.\\" if len(user[\\"borrowed_books\\"]) >= Library.MAX_BORROW: return \\"User has already borrowed maximum number of books.\\" book[\\"available\\"] = False book[\\"borrowed_by\\"] = user_id user[\\"borrowed_books\\"].append(isbn) return \\"Book borrowed successfully.\\" def return_book(self, user_id: int, isbn: str) -> str: Allows a user to return a book they had borrowed. if user_id not in self.users: return \\"User not found.\\" if isbn not in self.books: return \\"Book not found.\\" user = self.users[user_id] book = self.books[isbn] if book[\\"available\\"]: return \\"Book was not borrowed.\\" if book[\\"borrowed_by\\"] != user_id: return \\"User did not borrow this book.\\" book[\\"available\\"] = True book[\\"borrowed_by\\"] = None user[\\"borrowed_books\\"].remove(isbn) return \\"Book returned successfully.\\" def show_books(self) -> List[Dict]: Displays the current status of all books. return [{\\"title\\": book[\\"title\\"], \\"author\\": book[\\"author\\"], \\"isbn\\": isbn, \\"available\\": book[\\"available\\"]} for isbn, book in self.books.items()] def show_user_details(self, user_id: int) -> Dict: Displays the details of a specific user. if user_id not in self.users: return {} user = self.users[user_id] return { \\"name\\": user[\\"name\\"], \\"borrowed_books\\": user[\\"borrowed_books\\"] }"},{"question":"**Context**: You are given a list of integers that represents the weights of different items. Your task is to partition these items into two subsets such that the absolute difference of the sums of the subsets is minimized. You need to implement a function that calculates this minimum difference. **Task**: Write a Python function that takes a list of integers and returns the minimum possible difference between the sums of two subsets into which the list can be partitioned. **Function Signature**: ```python def min_subset_difference(weights: list[int]) -> int: ... ``` **Input Format**: - `weights`: A list of integers where each integer represents the weight of an item. **Output Format**: - An integer representing the minimum possible difference between the sums of the two subsets. **Example**: ```python weights = [1, 6, 11, 5] print(min_subset_difference(weights)) # Output: 1 ``` **Constraints**: - The sum of weights will not exceed 10,000. - Each individual weight will be a positive integer. **Performance Notes**: - Your solution should be efficient in both time and space complexity, suitable for large input lists. **Additional Information**: - You can assume there\'s always at least one object in the list. - The optimal solution uses dynamic programming.","solution":"def min_subset_difference(weights: list[int]) -> int: total_sum = sum(weights) n = len(weights) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if weights[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j"},{"question":"# Introduction You\'re employed by a logistics company to develop a software system that keeps track of warehouse storage and inventory management. Part of the system involves managing storage units with different maximum capacities and tracking items stored within these units, ensuring that no storage unit exceeds its capacity. # Problem Description Write two functions `add_item` and `remove_item` that manage the storage units by adding or removing items and ensuring the capacities are not exceeded or underflowed. If the operation fails due to capacity constraints, the function should raise an appropriate exception. Function 1: `add_item` Write a function `add_item` to add a quantity of an item to a storage unit. **Function Signature**: ```python def add_item(storage_units: dict, unit_id: str, item: str, quantity: int) -> dict: ``` **Input**: - `storage_units` (dict): A dictionary where keys are storage unit IDs and values are dictionaries with item names as keys and quantities as values. Each storage unit dictionary also includes a \'max_capacity\' key that defines the unit\'s maximum capacity. - `unit_id` (str): The ID of a storage unit. - `item` (str): The name of the item to add. - `quantity` (int): The quantity of the item to add. **Output**: - (dict): Updated storage units dictionary after adding the item. **Constraints**: - Quantities of items should be non-negative integers. - The resulting total quantity of items in a storage unit must not exceed its \'max_capacity\'. - Raise a `ValueError` if the unit_id is not found or if the addition would exceed the capacity. Function 2: `remove_item` Write a function `remove_item` to remove a quantity of an item from a storage unit. **Function Signature**: ```python def remove_item(storage_units: dict, unit_id: str, item: str, quantity: int) -> dict: ``` **Input**: - `storage_units` (dict): A dictionary where keys are storage unit IDs and values are dictionaries with item names as keys and quantities as values. Each storage unit dictionary also includes a \'max_capacity\' key that defines the unit\'s maximum capacity. - `unit_id` (str): The ID of a storage unit. - `item` (str): The name of the item to remove. - `quantity` (int): The quantity of the item to remove. **Output**: - (dict): Updated storage units dictionary after removing the item. **Constraints**: - Quantities of items should be non-negative integers. - The resulting quantity of the item in a storage unit must not be negative. - Raise a `ValueError` if the unit_id is not found, if the item is not found, or if the removal would result in a negative quantity. # Example ```python storage_units = { \\"unit1\\": {\\"max_capacity\\": 100, \\"itemA\\": 30, \\"itemB\\": 20}, \\"unit2\\": {\\"max_capacity\\": 200, \\"itemA\\": 50} } # Adding items storage_units = add_item(storage_units, \\"unit1\\", \\"itemA\\", 10) assert storage_units[\\"unit1\\"][\\"itemA\\"] == 40 # Removing items storage_units = remove_item(storage_units, \\"unit2\\", \\"itemA\\", 20) assert storage_units[\\"unit2\\"][\\"itemA\\"] == 30 ``` # Note - Ensure the `add_item` and `remove_item` functions handle invalid inputs as specified in the constraints. - The solution should include necessary imports and follow proper coding standards.","solution":"def add_item(storage_units: dict, unit_id: str, item: str, quantity: int) -> dict: Adds a quantity of an item to a storage unit, ensuring that the unit does not exceed its max capacity. Parameters: storage_units (dict): A dictionary containing storage units and their contents. unit_id (str): The ID of the storage unit to which the item is to be added. item (str): The name of the item to add. quantity (int): The quantity of the item to add. Returns: dict: The updated storage units dictionary. Raises: ValueError: If the unit_id is not found or if the addition would exceed the max capacity. if unit_id not in storage_units: raise ValueError(\\"Storage unit ID not found.\\") unit = storage_units[unit_id] max_capacity = unit[\\"max_capacity\\"] current_total = sum([v for k, v in unit.items() if k != \\"max_capacity\\"]) if current_total + quantity > max_capacity: raise ValueError(\\"Cannot add items exceeding the maximum capacity.\\") if item in unit: unit[item] += quantity else: unit[item] = quantity return storage_units def remove_item(storage_units: dict, unit_id: str, item: str, quantity: int) -> dict: Removes a quantity of an item from a storage unit, ensuring that the quantity does not become negative. Parameters: storage_units (dict): A dictionary containing storage units and their contents. unit_id (str): The ID of the storage unit from which the item is to be removed. item (str): The name of the item to remove. quantity (int): The quantity of the item to remove. Returns: dict: The updated storage units dictionary. Raises: ValueError: If the unit_id is not found, if the item is not found, or if the removal would result in a negative quantity. if unit_id not in storage_units: raise ValueError(\\"Storage unit ID not found.\\") unit = storage_units[unit_id] if item not in unit: raise ValueError(\\"Item not found in the storage unit.\\") if unit[item] < quantity: raise ValueError(\\"Cannot remove items resulting in negative quantity.\\") unit[item] -= quantity if unit[item] == 0: del unit[item] return storage_units"},{"question":"# Problem Details: We are aiming to continue the theme of working with algorithms in graph theory by introducing another classical algorithm. Let\'s proceed with Dijkstra\'s algorithm, which is typically used for finding shortest paths in graphs. --- # Dijkstra\'s Algorithm Challenge You are given a weighted directed graph with `V` vertices and `E` edges. The weights of the edges are non-negative. Your task is to implement Dijkstra\'s algorithm to compute the shortest paths from a given source vertex to all other vertices in the graph. # Function Signature: ```python def dijkstra(graph: List[List[Tuple[int, int]]], src: int) -> List[float]: ``` # Input: - An adjacency list `graph`, where `graph[u]` contains a list of tuples `(v, w)` representing an edge from vertex `u` to vertex `v` with weight `w`. - `0 <= u, v < V` - `0 <= w <= 1000` - An integer `src`, representing the source vertex where the shortest paths should start. # Output: - A list `dist`, where `dist[i]` represents the shortest distance from the source vertex `src` to vertex `i`. - If a vertex `i` is not reachable from `src`, `dist[i]` should be `float(\'inf\')`. # Example: Input: ```python graph = [ [(1, 2), (2, 4)], [(2, 1)], [(3, 1)], [] ] src = 0 ``` Output: ```python [0, 2, 3, 4] ``` # Constraints: - 1 <= V <= 100 (For simplicity) - The weights are non-negative. **Note**: - You must handle the input properly and ensure the correctness of the resultant shortest path list. - You can use any suitable data structures to implement Dijkstra\'s algorithm efficiently. - It\'s encouraged to write any helper functions that you find necessary.","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], src: int) -> List[float]: Implements Dijkstra\'s algorithm to find the shortest paths from src to all other vertices in a graph. Parameters: graph (List[List[Tuple[int, int]]]): The weighted graph represented as an adjacency list. src (int): The source vertex. Returns: List[float]: The shortest distances from src to every other vertex. V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > dist[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist"},{"question":"# Problem Statement Given a string `s`, your task is to determine whether it is possible to rearrange the characters of `s` such that each adjacent character pair consists of different characters. If such a rearrangement is possible, return one valid rearrangement. If it is not possible, return an empty string. Implement the function `rearrange_string`: ```python def rearrange_string(s: str) -> str: Determine if it\'s possible to rearrange the given string such that no two adjacent characters are the same. Args: - s (str): The input string consisting of lowercase English letters. Returns: - str: A valid rearranged string or an empty string if no such rearrangement is possible. ``` # Example: ```python assert rearrange_string(\\"aab\\") in [\\"aba\\"] # One valid rearrangement assert rearrange_string(\\"aaab\\") == \\"\\" # No valid rearrangement ``` # Constraints: * The input string `s` consists of lowercase English letters only. * The length of `s` will not exceed 100,000. This problem tests your ability to work with character frequencies and handle cases efficiently where a rearrangement may or may not be possible.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s: str) -> str: Determine if it\'s possible to rearrange the given string such that no two adjacent characters are the same. Args: - s (str): The input string consisting of lowercase English letters. Returns: - str: A valid rearranged string or an empty string if no such rearrangement is possible. # Count the frequency of each character in the input string counter = Counter(s) # Max-heap to store characters sorted by their frequency in descending order heap = [] for char, freq in counter.items(): heappush(heap, (-freq, char)) result = [] previous_char = None prev_freq = 0 while heap: freq, char = heappop(heap) # Append the current character to the result result.append(char) # If the previous character count is still greater than 0, push it back to the heap if previous_char and prev_freq < 0: heappush(heap, (prev_freq, previous_char)) # Update the previous character and its frequency previous_char = char prev_freq = freq + 1 rearranged_string = \'\'.join(result) # Check if the rearranged string is valid by comparing its length to the original string\'s length if len(rearranged_string) == len(s): return rearranged_string else: return \\"\\""},{"question":"# Question: Distinct Integer Pairs with Given Difference Create a function that identifies the number of distinct pairs `(a, b)` in an array `arr` such that their absolute difference is exactly `k`. Pairs `(a, b)` and `(b, a)` are considered the same, and each element in the array can only be used once in forming a pair. **Function Signature:** ```python def count_pairs_with_difference(arr: List[int], k: int) -> int: ``` **Input:** * A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6`. * An integer `k` where `0 <= k <= 10^6`. **Output:** * An integer representing the count of distinct pairs with the given difference. **Constraints:** * The pairs must be distinct. * Pairs `(a, b)` and `(b, a)` are considered the same. **Example:** ```python >>> count_pairs_with_difference([1, 5, 3, 4, 2], 3) 2 >>> count_pairs_with_difference([8, 12, 16, 4, 0, 20], 4) 5 >>> count_pairs_with_difference([1, 2, 2, 1], 1) 1 >>> count_pairs_with_difference([1, 1, 1, 1], 0) 1 ``` **Explanation:** 1. For the array `[1, 5, 3, 4, 2]` with `k = 3`, the pairs are (1, 4) and (2, 5). There are 2 such pairs. 2. For the array `[8, 12, 16, 4, 0, 20]` with `k = 4`, the pairs are (8, 12), (12, 16), (4, 8), (0, 4), and (16, 20). There are 5 such pairs. 3. For the array `[1, 2, 2, 1]` with `k = 1`, the only distinct pair is (1, 2). There is 1 such pair. 4. For the array `[1, 1, 1, 1]` with `k = 0`, the only distinct pair is (1, 1). There is 1 such pair. **Performance Considerations:** * Ensure the function runs efficiently within the given constraints. Use appropriate data structures to minimize the time complexity.","solution":"from typing import List def count_pairs_with_difference(arr: List[int], k: int) -> int: seen = set() pairs = set() for num in arr: if num + k in seen: pairs.add((min(num, num + k), max(num, num + k))) if num - k in seen: pairs.add((min(num, num - k), max(num, num - k))) seen.add(num) return len(pairs)"},{"question":"# Rotate Matrix Counterclockwise **Context**: You are part of a software team developing a graphics transformation tool, and one of the features involves rotating images by different angles. As a preliminary task, you need to rotate a given matrix counterclockwise by 90 degrees. **Objective**: Implement a function that rotates a given square matrix (2D list) counterclockwise by 90 degrees. Task Write a function `rotate_matrix_counterclockwise` with the following specifications: * **Input**: 1. `matrix` (list of list of int): A 2D list representing a square matrix where each element is an integer. * **Output**: * A new 2D list (same dimensions as `matrix`) representing the matrix rotated counterclockwise by 90 degrees. Constraints * The input matrix will always be a square matrix (i.e., the number of rows equals the number of columns). * The dimensions of the matrix (n x n) will be in the range 1 <= n <= 100. * Aim for an efficient implementation with respect to both time and space complexity. Example ```python def rotate_matrix_counterclockwise(matrix): # Your code here # Example usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = rotate_matrix_counterclockwise(matrix) for row in result: print(row) ``` **Expected Output:** ``` [3, 6, 9] [2, 5, 8] [1, 4, 7] ``` **Performance Note**: Ensure that your implementation can handle matrices up to 100x100 within a reasonable time frame.","solution":"def rotate_matrix_counterclockwise(matrix): Rotates a given square matrix counterclockwise by 90 degrees. Parameters: matrix (list of list of int): The input 2D list representing a square matrix. Returns: list of list of int: A new 2D list representing the matrix rotated counterclockwise by 90 degrees. n = len(matrix) rotated = [[0] * n for _ in range(n)] # Create a new n x n matrix for i in range(n): for j in range(n): rotated[n - 1 - j][i] = matrix[i][j] return rotated"},{"question":"# Sentence Reversal Function Background Reversing the words in a sentence is a common task in text manipulation. Here, you need to write a function that takes a given sentence (a string) and returns a new sentence with the words in reverse order. Words are defined as contiguous sequences of non-space characters. Objective You are to write a function that reverses the words in a given sentence. Function Signature ```python def reverse_sentence(sentence: str) -> str: ``` Input * `sentence` (str): A string representing a sentence. The string can include leading/trailing whitespace and multiple spaces between words. Output * Return a string with the words in reverse order. Preserve the original spaces between the words as much as possible. Constraints * The input string will have a length of up to 10,000 characters. Examples ```python >>> reverse_sentence(\\"Hello world\\") \'world Hello\' >>> reverse_sentence(\\" This is a test \\") \'test a is This \' >>> reverse_sentence(\\"Python is fun\\") \'fun is Python\' >>> reverse_sentence(\\" Leading and trailing \\") \' trailing and Leading \' >>> reverse_sentence(\\"\\") \'\' ```","solution":"def reverse_sentence(sentence: str) -> str: Returns a new sentence with words in reverse order. Preserves the original spaces between the words as much as possible. # Split the sentence by spaces to get a list of words and keep the spaces words = sentence.split(\' \') # Reverse the list of words reversed_words = \' \'.join(reversed(words)) return reversed_words"},{"question":"# Coding Assessment Question **Scenario**: You have been commissioned to develop a simple text editor which can efficiently handle dynamic text manipulation and user search queries. The editor needs to support operations that modify the text and find specific patterns. **Task**: Implement a text editor class that allows users to append text, delete characters, and search for substrings using the Knuth-Morris-Pratt (KMP) string matching algorithm. **Requirements**: 1. **Initialization**: - Provide a class `SimpleTextEditor` that initializes with an empty string. 2. **Append Text**: - Implement an `append` method to add text at the end of the current text. 3. **Delete Characters**: - Implement a `delete` method to remove the last `k` characters from the current text. 4. **Search Substrings**: - Implement a `search` method that uses the KMP algorithm to search for a specified substring and returns the starting index of the first occurrence, or -1 if the substring is not found. # Function Details - **Class**: `SimpleTextEditor` - **Constructor**: - `__init__(self) -> None` - Initializes with an empty string. - **Methods**: - `append(self, text: str) -> None` - Appends the given `text` to the editor content. - `delete(self, k: int) -> None` - Deletes the last `k` characters from the editor content. - `search(self, substring: str) -> int` - Returns the starting index of the first occurrence of the `substring`, or -1 if `substring` is not found. **Constraints**: - The total length of text appended and the total number of characters deleted across all operations will not exceed 10^6. - Only alphabetic characters (both uppercase and lowercase) should be considered for appending and searching. - The length of the substring for the search operation will not exceed 10^5. # Input Format: - Series of operations (append, delete, search) with respective parameters. - Example: Operations - [\\"append hello\\", \\"append world\\", \\"search low\\", \\"delete 5\\", \\"search ell\\"] # Output Format: - For each `search` operation, output the result of the search. # Example: ```python editor = SimpleTextEditor() editor.append(\\"hello\\") editor.append(\\"world\\") print(editor.search(\\"low\\")) # Output: 3 editor.delete(5) print(editor.search(\\"ell\\")) # Output: 1 ``` # Implementation Example: ```python class SimpleTextEditor: def __init__(self): self.content = \\"\\" def append(self, text): self.content += text def delete(self, k): self.content = self.content[:-k] def search(self, substring): return self.kmp_search(substring) def kmp_search(self, pat): M = len(pat) N = len(self.content) lps = [0] * M j = 0 self.compute_lps_array(pat, M, lps) i = 0 while i < N: if pat[j] == self.content[i]: i += 1 j += 1 if j == M: return i - j elif i < N and pat[j] != self.content[i]: if j != 0: j = lps[j-1] else: i += 1 return -1 def compute_lps_array(self, pat, M, lps): length = 0 lps[0] = 0 i = 1 while i < M: if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 ```","solution":"class SimpleTextEditor: def __init__(self): self.content = \\"\\" def append(self, text): self.content += text def delete(self, k): self.content = self.content[:-k] def search(self, substring): return self.kmp_search(substring) def kmp_search(self, pat): M = len(pat) N = len(self.content) lps = [0] * M j = 0 self.compute_lps_array(pat, M, lps) i = 0 while i < N: if pat[j] == self.content[i]: i += 1 j += 1 if j == M: return i - j elif i < N and pat[j] != self.content[i]: if j != 0: j = lps[j-1] else: i += 1 return -1 def compute_lps_array(self, pat, M, lps): length = 0 lps[0] = 0 i = 1 while i < M: if pat[i] == pat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1"},{"question":"# Efficient Route Planning for Delivery Truck A delivery truck company wants to optimize its route planning to reduce fuel consumption and time. The truck can carry up to `n` packages, and it must deliver these packages to `m` different locations. Each location has a specific distance from the starting point, and the truck must calculate the shortest route that visits each delivery location exactly once before returning to the starting point. Assume the truck always starts and ends at the depot located at point 0. Function Signature ```python def find_optimal_route( num_packages: int, locations: List[int] ) -> List[int]: ``` Parameters - **num_packages** (*int*): Number of packages the truck needs to deliver. Must be a positive integer less than or equal to the number of locations. - **locations** (*List[int]*): A list of integers representing the distance of each delivery location from the starting point (depot). The distance is given in kilometers and each element must be positive. Both **num_packages** and elements of **locations** must be positive integers. If either of these conditions is violated, raise a `ValueError` with the message `\\"Invalid input: num_packages and locations distances must be positive.\\"` Output - **Returns** (*List[int]*): A list of integers representing the indices of the locations in the order the truck should visit to minimize travel distance. The list should start and end with 0, indicating the starting and ending at the depot. Requirements 1. Ensure that the number of packages does not exceed the number of locations. 2. Calculate the shortest possible route that visits each location exactly once before returning to the depot. 3. Return the indices of the locations in the order they should be visited to achieve the shortest route. Example ```python # Example 1: optimal_route = find_optimal_route(3, [10, 20, 30, 40]) print(optimal_route) # Output: [0, 1, 2, 3, 4, 0] or another optimal route depending on the distances # Example 2: optimal_route = find_optimal_route(2, [15, 25]) print(optimal_route) # Output: [0, 1, 2, 0] or [0, 2, 1, 0] ``` Ensure to write well-documented, optimized, and readable code to solve this problem efficiently.","solution":"from typing import List import itertools def find_optimal_route(num_packages: int, locations: List[int]) -> List[int]: Finds the shortest route for delivering packages to given locations. if num_packages <= 0 or any(dist <= 0 for dist in locations): raise ValueError(\\"Invalid input: num_packages and locations distances must be positive.\\") if num_packages > len(locations): raise ValueError(\\"Number of packages cannot exceed number of locations.\\") # Generate all permutations of locations perms = itertools.permutations(range(1, num_packages + 1)) # Start and End depot is at index 0 optimal_route = [] min_distance = float(\'inf\') for perm in perms: current_distance = 0 current_route = [0] # Traversing through the permutation for i in range(len(perm)): if i == 0: current_distance += locations[perm[i] - 1] else: current_distance += abs(locations[perm[i] - 1] - locations[perm[i - 1] - 1]) current_route.append(perm[i]) # Adding the return trip to the depot current_distance += abs(locations[perm[-1] - 1] - 0) current_route.append(0) # Check if this route is better than the best found so far if current_distance < min_distance: min_distance = current_distance optimal_route = current_route return optimal_route"},{"question":"# Question: Implement a Custom `QueueWithStacks` Class Design a `QueueWithStacks` class that simulates the behavior of a queue using two stacks. Implement the following methods: 1. `enqueue(x)`: Adds the element `x` to the end of the queue. 2. `dequeue()`: Removes and returns the element from the front of the queue. 3. `peek()`: Returns the front element of the queue without removing it. 4. `is_empty()`: Returns `True` if the queue is empty, otherwise `False`. Ensure that all operations maintain average O(1) time complexity. # Function Signature ```python class QueueWithStacks: def enqueue(self, x: int) -> None: pass def dequeue(self) -> int | None: pass def peek(self) -> int | None: pass def is_empty(self) -> bool: pass ``` # Input Format - The functions will be called on an instance of the `QueueWithStacks` class with their respective arguments. # Output Format - The `enqueue` method will not return anything. - The `dequeue` method will return an integer or `None` if the queue is empty. - The `peek` method will return an integer or `None` if the queue is empty. - The `is_empty` method will return a boolean indicating if the queue is empty or not. # Example ```python queue = QueueWithStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: 3 print(queue.is_empty()) # Output: True print(queue.dequeue()) # Output: None ``` # Constraints - Do not use any internal queue data structure or deque for implementing this functionality. - Assume the queue contains only integer values. - Ensure that the `dequeue` and `peek` operations have average O(1) time complexity.","solution":"class QueueWithStacks: def __init__(self): self.stack_in = [] self.stack_out = [] def _transfer_in_to_out(self): while self.stack_in: self.stack_out.append(self.stack_in.pop()) def enqueue(self, x: int) -> None: self.stack_in.append(x) def dequeue(self) -> int | None: if not self.stack_out: self._transfer_in_to_out() return self.stack_out.pop() if self.stack_out else None def peek(self) -> int | None: if not self.stack_out: self._transfer_in_to_out() return self.stack_out[-1] if self.stack_out else None def is_empty(self) -> bool: return not self.stack_in and not self.stack_out"},{"question":"# Word Search in 2D Board Given a 2D board of characters and a word, your task is to write an algorithm to find if the word exists in the board. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. # Problem Statement Write a function `exist(board: List[List[str]], word: str) -> bool` that takes a 2D list of characters `board` and a string `word`, and returns a boolean indicating whether the word exists in the board. # Requirements The function should perform efficiently, exploring the board in a manner that ensures the word is found if present, without revisiting cells unnecessarily. # Input * `board`: A 2D list of characters (`board: List[List[str]]`), where 1 <= len(board), len(board[0]) <= 200. * `word`: A string (`word: str`), where 1 <= len(word) <= 1000. # Output * A boolean (`bool`) indicating whether the word exists in the board. # Constraints * The characters of `board` consists of only lowercase English letters. * The word consists of only lowercase English letters. # Performance Requirements * The algorithm should efficiently perform depth-first search with careful consideration of backtracking. * Aim to minimize the number of times each cell is visited and revisited to optimize performance. # Scenario/Context Board search problems are a common topic in interviews and competitive programming contests. They test your understanding of algorithms, particularly depth-first search (DFS) and backtracking, and your ability to handle edge cases and optimize performance. # Example ```python board = [ [\\"A\\",\\"B\\",\\"C\\",\\"E\\"], [\\"S\\",\\"F\\",\\"C\\",\\"S\\"], [\\"A\\",\\"D\\",\\"E\\",\\"E\\"] ] word = \\"ABCCED\\" result = exist(board, word) print(result) # Output: true word = \\"SEE\\" result = exist(board, word) print(result) # Output: true word = \\"ABCB\\" result = exist(board, word) print(result) # Output: false ``` Your implementation should efficiently handle such inputs and provide accurate results, leveraging depth-first search with backtracking to explore all possible paths in the board.","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) def backtrack(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= rows or y >= cols or board[x][y] != word[index]: return False # Temporarily mark the current cell as visited temp, board[x][y] = board[x][y], \'#\' # Explore all possible directions: up, down, left, right found = (backtrack(x + 1, y, index + 1) or backtrack(x - 1, y, index + 1) or backtrack(x, y + 1, index + 1) or backtrack(x, y - 1, index + 1)) # Restore the current cell board[x][y] = temp return found for i in range(rows): for j in range(cols): if board[i][j] == word[0] and backtrack(i, j, 0): return True return False"},{"question":"# Order Processing System In this task, you will implement an order processing system for an online store. The system should process incoming orders, update inventory levels, and handle out-of-stock scenarios. Requirements: - Implement a function that processes orders by updating the inventory levels for the ordered items. - The function should return a summary of the order processing result, including any items that could not be fulfilled due to insufficient stock. - Manage concurrent order processing using thread-safe techniques to ensure consistent inventory updates. Function Signature: ```python def process_orders(orders: list, inventory: dict) -> dict: Process a list of orders and update inventory levels. Parameters: orders (list): A list of orders, where each order is represented by a dictionary with \'item\' and \'quantity\' keys. inventory (dict): A dictionary representing the current inventory with item names as keys and quantities as values. Returns: dict: A dictionary with \'processed\' and \'unfulfilled\' keys: - \'processed\' key should map to a list of orders that were successfully processed. - \'unfulfilled\' key should map to a list of orders that could not be fulfilled due to insufficient stock. ``` Constraints: - Each order and each inventory entry are represented by valid strings and positive integer values. - If an item in the order is not present in the inventory, treat it as out-of-stock. - Consider multiple concurrent calls to the `process_orders` function and ensure thread-safety. Example Usage: ```python orders = [ {\\"item\\": \\"apple\\", \\"quantity\\": 5}, {\\"item\\": \\"banana\\", \\"quantity\\": 3}, {\\"item\\": \\"orange\\", \\"quantity\\": 10}, ] inventory = { \\"apple\\": 10, \\"banana\\": 2, \\"orange\\": 8, } result = process_orders(orders, inventory) print(result) # Output: {\'processed\': [{\'item\': \'apple\', \'quantity\': 5}], \'unfulfilled\': [{\'item\': \'banana\', \'quantity\': 3}, {\'item\': \'orange\', \'quantity\': 10}]} ``` Performance Requirements: - The function should handle a large number of orders efficiently. - Ensure thread-safe updates to shared inventory data structures to prevent race conditions.","solution":"import threading # Lock for synchronizing access to the inventory inventory_lock = threading.Lock() def process_orders(orders, inventory): Process a list of orders and update inventory levels. Parameters: orders (list): A list of orders, where each order is represented by a dictionary with \'item\' and \'quantity\' keys. inventory (dict): A dictionary representing the current inventory with item names as keys and quantities as values. Returns: dict: A dictionary with \'processed\' and \'unfulfilled\' keys: - \'processed\' key should map to a list of orders that were successfully processed. - \'unfulfilled\' key should map to a list of orders that could not be fulfilled due to insufficient stock. processed = [] unfulfilled = [] # Iterate over each order for order in orders: item = order[\'item\'] quantity = order[\'quantity\'] with inventory_lock: # Check if there\'s enough stock to fulfill the order if item in inventory and inventory[item] >= quantity: inventory[item] -= quantity processed.append(order) else: unfulfilled.append(order) return {\'processed\': processed, \'unfulfilled\': unfulfilled}"},{"question":"**Question**: Design and implement a function to calculate the shortest path in an unweighted graph using Breadth-First Search (BFS) algorithm. Your function should identify the minimum number of edges to reach from a starting node to a target node. # Details - **Input**: - An integer `n` representing the number of nodes in the graph. - A list of pairs `edges` representing the undirected edges between nodes. - An integer `start` representing the starting node. - An integer `target` representing the target node. - **Output**: - An integer representing the shortest path length from start to target. If there is no path, return -1. - **Constraints**: - `2 <= n <= 10^4` - `1 <= len(edges) <= 2*10^4` - `0 <= start, target < n` # Function Signature ```python def shortest_path_bfs(n: int, edges: list, start: int, target: int) -> int: pass ``` # Example ```python def test_shortest_path_bfs(): assert shortest_path_bfs(6, [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 5)], 0, 5) == 3 assert shortest_path_bfs(4, [(0, 1), (1, 2), (2, 3)], 0, 3) == 3 assert shortest_path_bfs(5, [(0, 1), (1, 2), (3, 4)], 0, 3) == -1 assert shortest_path_bfs(3, [(0, 1), (1, 2)], 2, 0) == 2 assert shortest_path_bfs(7, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (0, 6)], 0, 4) == 3 print(\\"All test cases pass\\") test_shortest_path_bfs() ``` **Requirements**: - Implement the solution using the BFS algorithm to ensure the shortest path is found in an unweighted graph. - Verify correctness and efficiency, capable of handling edge cases such as disconnected graphs or graphs with large numbers of nodes.","solution":"from collections import deque, defaultdict def shortest_path_bfs(n: int, edges: list, start: int, target: int) -> int: Calculate the shortest path in an unweighted graph using BFS. :param n: Number of nodes in the graph :param edges: List of undirected edges in the graph :param start: Starting node :param target: Target node :return: Shortest path length from start to target, or -1 if no path exists if start == target: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: node, distance = queue.popleft() for neighbor in graph[node]: if neighbor == target: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1"},{"question":"# Question Context An engineer is designing an efficient text compression system. As part of the process, they need to analyze character frequencies to create Huffman codes, where characters occurring more frequently are assigned shorter codes. You are tasked with creating a function to compute the frequency of each character in a given string. Task Write a function `character_frequency` that computes the frequency of each character in a string. Function Signature ```python def character_frequency(text: str) -> dict: ``` Input * `text` (str): A string of any printable ASCII characters. (0 <= len(text) <= 10^5) Output * dict: A dictionary where the keys are characters, and the values are the frequencies of those characters in the string. Example ```python >>> character_frequency(\\"hello world!\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1, \'!\': 1} >>> character_frequency(\\"aaaa\\") {\'a\': 4} >>> character_frequency(\\"\\") {} ``` Constraints * The function should handle both empty strings and non-empty strings. * The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. * There should be no character filtering; all characters in the input string must be counted as they appear. * The output dictionary should respect the order of characters as they first appear in the text. Edge Cases * When the input string is empty, the function should return an empty dictionary. * When the input string contains only unique characters, the frequency of each character should be 1. * When the input string contains repeating characters, the function should accurately count their occurrences.","solution":"def character_frequency(text: str) -> dict: Computes the frequency of each character in the given text. Parameters: text (str): The input string to analyze. Returns: dict: A dictionary mapping each character in the string to its frequency. freq_dict = {} for char in text: if char in freq_dict: freq_dict[char] += 1 else: freq_dict[char] = 1 return freq_dict"},{"question":"# Problem Statement You are designing an enhanced function to simulate basic arithmetic operations with additional capabilities of handling fractional numbers using a string representation of fractions. The function should support operations such as addition, subtraction, multiplication, and division. # Objectives 1. **Develop a function capable of performing arithmetic operations on strings representing fractions.** 2. **Ensure the function handles errors gracefully, such as division by zero and invalid fraction strings.** 3. **Optimize for both accuracy and edge cases, ensuring proper handling of negative numbers and improper fractions.** # Requirements 1. Implement the function `fraction_arithmetics` that accepts the following parameters: * `num1` (str): The first fraction represented as a string (e.g., \\"3/4\\"). * `num2` (str): The second fraction represented as a string (e.g., \\"2/5\\"). * `operation` (str): The arithmetic operation to perform. It could be one of the following: \\"add\\", \\"subtract\\", \\"multiply\\", \\"divide\\". 2. Validate the input parameters: * Ensure `num1` and `num2` are valid fractions in string format (proper or improper fractions). * Ensure `operation` is a valid operation among the specified ones. * Raise appropriate error messages for invalid inputs. 3. Perform the specified arithmetic operation: * Handle conversions between fractions and ensure the final result is returned as a simplified fraction string. 4. Return the result as a simplified fraction string. # Input Format * `num1`: A string representing the first fraction. * `num2`: A string representing the second fraction. * `operation`: A string denoting the arithmetic operation to perform. # Output Format A string representing the result of the arithmetic operation in simplified fraction form. # Example ```python fraction_arithmetics(\\"3/4\\", \\"2/5\\", \\"add\\") # Output: \\"23/20\\" fraction_arithmetics(\\"3/4\\", \\"2/5\\", \\"subtract\\") # Output: \\"7/20\\" fraction_arithmetics(\\"3/4\\", \\"2/5\\", \\"multiply\\") # Output: \\"3/10\\" fraction_arithmetics(\\"3/4\\", \\"2/5\\", \\"divide\\") # Output: \\"15/8\\" ``` # Constraint * The function should handle invalid inputs and edge cases appropriately, raising meaningful error messages where applicable.","solution":"from fractions import Fraction def fraction_arithmetics(num1, num2, operation): Perform arithmetic operations on fractions. Parameters: num1 (str): The first fraction as a string (e.g., \\"3/4\\"). num2 (str): The second fraction as a string (e.g., \\"2/5\\"). operation (str): The operation to perform (add, subtract, multiply, divide). Returns: str: The result of the arithmetic operation on the fractions, in simplified form. # Validate fractions try: frac1 = Fraction(num1) frac2 = Fraction(num2) except ValueError: raise ValueError(\\"Invalid fraction format\\") # Perform the operation if operation == \\"add\\": result = frac1 + frac2 elif operation == \\"subtract\\": result = frac1 - frac2 elif operation == \\"multiply\\": result = frac1 * frac2 elif operation == \\"divide\\": if frac2 == 0: raise ZeroDivisionError(\\"Division by zero\\") result = frac1 / frac2 else: raise ValueError(\\"Invalid operation\\") return str(result)"},{"question":"# Intersecting Intervals Problem You are given a list of intervals where each interval is represented by a pair of integers `[start, end]`. Your task is to implement a function that finds all unique pairs of intervals that intersect. Two intervals `[a, b]` and `[c, d]` intersect if they share at least one common point, i.e., `max(a, c) <= min(b, d)`. Function Signature ```python def find_intersecting_intervals(intervals: list[list[int]]) -> list[tuple[int, int]]: ``` Input: - `intervals`: A list of lists, where each sub-list contains two integers `[start, end]` representing the start and end times of an interval. Output: - A list of tuples, where each tuple contains two indices representing the positions of the intersecting intervals in the input list. The indices should be in ascending order within each tuple, and the list of tuples should be sorted in ascending order by the first index and then by the second index. Constraints: - `1 <= len(intervals) <= 10^4` - `0 <= start < end <= 10^9` Example: ```python >>> intervals = [[1, 3], [2, 4], [5, 6]] >>> find_intersecting_intervals(intervals) [(0, 1)] >>> intervals = [[1, 5], [2, 6], [8, 10], [7, 8]] >>> find_intersecting_intervals(intervals) [(0, 1), (2, 3)] ``` Explanation: For the first example: The intervals are provided as [[1, 3], [2, 4], [5, 6]]. We have one pair of intersecting intervals: (0, 1) corresponding to intervals [1, 3] and [2, 4]. For the second example: The intervals are provided as [[1, 5], [2, 6], [8, 10], [7, 8]]. We have two pairs of intersecting intervals: (0, 1) corresponding to intervals [1, 5] and [2, 6], and (2, 3) corresponding to intervals [8, 10] and [7, 8]. Note: You must ensure that the returned list contains unique pairs and is sorted as specified.","solution":"def find_intersecting_intervals(intervals: list[list[int]]) -> list[tuple[int, int]]: Finds all unique pairs of intersecting intervals in the list of intervals. intersecting_pairs = [] n = len(intervals) for i in range(n): for j in range(i + 1, n): if max(intervals[i][0], intervals[j][0]) <= min(intervals[i][1], intervals[j][1]): intersecting_pairs.append((i, j)) return intersecting_pairs"},{"question":"# Find Missing Element in the Array Objective You are tasked with writing a function to find the missing number in a given sequence of unique integers, ranging from 1 to n. # Description Write a function `find_missing_number` that identifies the missing number from a given list of integers, where the list represents a sequence from 1 to n with one number missing. # Function Signature ```python def find_missing_number(arr: list) -> int: pass ``` # Input - `arr`: A list of integers representing a sequence from 1 to n with one integer missing. # Output - A single integer value representing the missing number in the sequence. # Constraints - The input list `arr` must contain unique integers. - The length of the input list `arr` will be n-1, where n is the largest number in the sequence. - The numbers in the input list `arr` will range from 1 to n, but exactly one number will be missing. - All inputs will be valid integers. Example Usage ```python assert find_missing_number([1, 2, 4, 5]) == 3 assert find_missing_number([2, 3, 4, 5, 6]) == 1 assert find_missing_number([1, 3, 4, 5]) == 2 assert find_missing_number([1, 2, 3, 4, 6]) == 5 ``` # Requirements - The function should validate the input: * Ensure `arr` is a list of integers. * Ensure the integers are unique and fit within the expected range (1 to n). - The function should handle the edge cases gracefully: * An empty list which is not allowed according to problem constraints. * A list where the missing number is either at the start or the end of the sequence. - The function should raise appropriate exceptions for invalid inputs. Possible Edge Cases - `find_missing_number([])` should raise a ValueError as the input list is empty. - `find_missing_number([\\"1\\", 2, 3, 4])` should raise a TypeError as one of the elements is a string. - `find_missing_number([1,1,2,3,4])` should raise a ValueError for a non-unique integer in the input list. Tips - Leverage mathematical formulas for the sum of the first n natural numbers to find the missing number efficiently. - Perform input validation checks before proceeding with calculations. By crafting the question using these guidelines, the new problem aligns well with the original set in terms of style, complexity, and scope.","solution":"def find_missing_number(arr): This function finds the missing number in a sequence from 1 to n. Parameters: arr (list): A list of unique integers from 1 to n with one number missing Returns: int: The missing number in the sequence Raises: ValueError: If the list is not unique or contains invalid integers TypeError: If the elements in the list are not integers if not arr: raise ValueError(\\"The list should not be empty.\\") n = len(arr) + 1 # Validate all elements are integers if not all(isinstance(item, int) for item in arr): raise TypeError(\\"All elements in the list must be integers.\\") # Validate all elements are unique if len(set(arr)) != len(arr): raise ValueError(\\"The list contains duplicate elements.\\") # Validate all elements are within the range 1 to n if not all(1 <= item <= n for item in arr): raise ValueError(\\"Elements are out of the expected range (1 to n).\\") # Calculate the sum of the first n natural numbers total_sum = n * (n + 1) // 2 # Subtract the sum of the given numbers actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"# Fibonacci Prime Detection # Background The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. An interesting problem emerges when you try to identify which of these Fibonacci numbers are prime. # Task You are required to implement a Python function that identifies all prime Fibonacci numbers up to a given limit. The function should return a list of these prime Fibonacci numbers. # Input - An integer `n` representing the inclusive upper limit of the Fibonacci sequence to check. # Output - A list of prime Fibonacci numbers up to the value `n`. # Constraints - The input `n` will be a positive integer not exceeding 100,000. # Function Signature ```python def prime_fibonacci(limit: int) -> List[int]: :param limit: int - The inclusive upper limit of the Fibonacci sequence to check. :return: List[int] - A list of prime Fibonacci numbers up to the given limit. ``` # Example Suppose the input is `n = 50`. The function should return `[2, 3, 5, 13]` since these are the prime numbers within the Fibonacci sequence up to 50. # Hints - Use an efficient algorithm to generate the Fibonacci sequence. - Utilize a primality test to check if a number in the Fibonacci sequence is prime. # Solution Template ```python from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_fibonacci(limit: int) -> List[int]: # Generating Fibonacci numbers up to the limit a, b = 0, 1 prime_fibs = [] while a <= limit: if is_prime(a): prime_fibs.append(a) a, b = b, a + b return prime_fibs # Example usage: if __name__ == \\"__main__\\": print(prime_fibonacci(50)) # Output: [2, 3, 5, 13] ``` Feel free to modify the example usage to test different limits for the Fibonacci sequence.","solution":"from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_fibonacci(limit: int) -> List[int]: a, b = 0, 1 prime_fibs = [] while a <= limit: if is_prime(a): prime_fibs.append(a) a, b = b, a + b return prime_fibs"},{"question":"# Predict Star Ratings Based on Customer Reviews Context Imagine you are a data scientist working for an e-commerce platform. You have been tasked with developing a tool to predict the star rating (out of 5) given by a customer based on their text review. This will help the company to better understand customer sentiment and improve product recommendations. Objective Implement a basic Natural Language Processing pipeline to build a model that predicts the star rating from customer reviews. Focus on preparing the text data by converting it into numerical features, and then use a simple machine learning model like Logistic Regression for multi-class classification. Input Format 1. A list `reviews` of strings where each string represents a customer review. 2. A list `ratings` of integers where each integer (1 to 5) represents the corresponding star rating for each review. 3. Maximum number of features `max_features` (integer) for the text vectorization. 4. Size of the split `split_ratio` (float) to divide the dataset into training and testing sets. Output Format 1. Print the accuracy of the model on both the training set and the testing set. 2. Print a sample of 5 predictions alongside the actual ratings for comparison. Constraints 1. The number of reviews `n` should be ≥ 50 and ≤ 10000. 2. The number of features `max_features` should be ≥ 100 and ≤ 10000. 3. The split ratio `split_ratio` should be between 0.1 and 0.9. # Function Signature ```python def predict_star_ratings(reviews: list, ratings: list, max_features: int, split_ratio: float) -> None: pass ``` # Example ```python reviews = [ \\"Great product, loved it!\\", \\"This was terrible, very disappointed.\\", \\"Average, not bad but not good either.\\", \\"Excellent quality, will buy again!\\", \\"Not as described, poor quality.\\" ] ratings = [5, 1, 3, 5, 2] max_features = 500 split_ratio = 0.8 predict_star_ratings(reviews, ratings, max_features, split_ratio) ``` In this example, the function `predict_star_ratings` should print the accuracy of the trained model on both the training and testing datasets, and display a sample of 5 predictions alongside the actual ratings. # Requirements 1. Preprocess the reviews by converting them to lowercase and removing special characters. 2. Vectorize the reviews using TF-IDF representation. 3. Split the dataset into training and testing sets based on the given split ratio. 4. Train a Logistic Regression model to predict star ratings. 5. Evaluate the model and print accuracy on training and testing datasets. 6. Display a sample of 5 predictions alongside the actual ratings to demonstrate performance. Good luck!","solution":"def predict_star_ratings(reviews: list, ratings: list, max_features: int, split_ratio: float) -> None: from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score import re def preprocess_text(text): Preprocess the given text by converting to lowercase and removing special characters. text = text.lower() text = re.sub(r\'[^ws]\', \'\', text) return text # Preprocess the reviews reviews = [preprocess_text(review) for review in reviews] # Vectorize the reviews using TF-IDF representation vectorizer = TfidfVectorizer(max_features=max_features) X = vectorizer.fit_transform(reviews) # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(X, ratings, test_size=1-split_ratio, random_state=42) # Train a Logistic Regression model model = LogisticRegression(multi_class=\'multinomial\', solver=\'lbfgs\', max_iter=1000, random_state=42) model.fit(X_train, y_train) # Make predictions y_train_pred = model.predict(X_train) y_test_pred = model.predict(X_test) # Evaluate the model and print accuracy train_accuracy = accuracy_score(y_train, y_train_pred) test_accuracy = accuracy_score(y_test, y_test_pred) print(f\\"Training accuracy: {train_accuracy:.2f}\\") print(f\\"Testing accuracy: {test_accuracy:.2f}\\") # Display a sample of 5 predictions alongside the actual ratings sample_size = min(5, len(y_test)) for i in range(sample_size): print(f\\"Review: {reviews[i]}\\") print(f\\"Actual Rating: {y_test[i]}\\") print(f\\"Predicted Rating: {y_test_pred[i]}\\") print(\\"-\\" * 20)"},{"question":"# Efficient Stock Span Calculation You are given a list of stock prices for `n` consecutive days. Your task is to implement a class `StockSpanner` which supports the following operations efficiently: 1. **Next Price**: Adds the price of a stock for the next day and returns the span of the stock\'s price for that day. * The span of the stock\'s price on a given day i is the maximum number of consecutive days (including the present day) the price of the stock has been less than or equal to its price on the day i. Input and Output Formats * **Input**: * For the `next` method: * `price` - an integer representing the stock price for the next day. * **Output**: * For the `next` method: An integer representing the span of the stock\'s price for the given day. Constraints * Assume price is a positive integer. * There will be at most `10^5` calls to the `next` method. Performance Requirements * Ensure that each call to the `next` method operates efficiently, ideally in O(1) average time complexity. # Example ```python spanner = StockSpanner() print(spanner.next(100)) # Output: 1 print(spanner.next(80)) # Output: 1 print(spanner.next(60)) # Output: 1 print(spanner.next(70)) # Output: 2 print(spanner.next(60)) # Output: 1 print(spanner.next(75)) # Output: 4 print(spanner.next(85)) # Output: 6 ``` # Implementation Implement the `StockSpanner` class by defining the `next` method which computes and returns the span for the given stock price. ```python class StockSpanner: def __init__(self): # Initialize the stack to keep track of price and their span self.stack = [] def next(self, price: int) -> int: span = 1 # Minimum span is 1 (the current day itself) # While the stack is not empty and the current price is greater or equal to the price # at the top of the stack, pop from the stack and add the span while self.stack and self.stack[-1][0] <= price: span += self.stack.pop()[1] # Push the current price and its span onto the stack self.stack.append((price, span)) # Return the computed span return span ```","solution":"class StockSpanner: def __init__(self): # Initialize the stack to keep track of prices and their spans self.stack = [] def next(self, price: int) -> int: span = 1 # Minimum span is 1 (the current day itself) # While the stack is not empty and the current price is greater or equal to the price # at the top of the stack, pop from the stack and add the span while self.stack and self.stack[-1][0] <= price: span += self.stack.pop()[1] # Push the current price and its span onto the stack self.stack.append((price, span)) # Return the computed span return span"},{"question":"# Problem Statement You are given a set of data that needs to be grouped and processed in parallel to efficiently compute the maximum value for each group. Your task is to implement two components to achieve this: 1. **DataGrouper**: This class should distribute data into groups based on a key, ensuring balanced partitioning. 2. **ParallelMaxCalculator**: This class should compute the maximum value for each group in parallel, making use of multiple processing cores. # Constraints - The data size is significant and cannot be processed sequentially within a reasonable time frame. - You should ensure that the data is evenly distributed across groups to optimize parallel processing. - Use Python\'s multiprocessing capabilities to parallelize the maximum value computation. # Function Signatures For DataGrouper Class ```python def __init__(self, data: List[Dict[str, Any]], key: str): Initialize with the dataset and the key used for grouping. def group_data(self) -> Dict[str, List[Dict[str, Any]]]: Group data into partitions based on the specified key. ``` For ParallelMaxCalculator Class ```python def __init__(self, grouped_data: Dict[str, List[Dict[str, Any]]], value_key: str): Initialize with the grouped data and the key to compute the maximum value. def compute_maximums(self) -> Dict[str, Any]: Compute the maximum value for each group in parallel. ``` # Example Usage - **Input Data**: ```python data = [ {\\"group\\": \\"A\\", \\"value\\": 10}, {\\"group\\": \\"B\\", \\"value\\": 20}, {\\"group\\": \\"A\\", \\"value\\": 15}, {\\"group\\": \\"B\\", \\"value\\": 25}, {\\"group\\": \\"C\\", \\"value\\": 5}, {\\"group\\": \\"C\\", \\"value\\": 30} ] ``` - **Key for Grouping**: `\\"group\\"` - **Key for Value Calculation**: `\\"value\\"` ```python from typing import List, Dict, Any import multiprocessing # Example data data = [ {\\"group\\": \\"A\\", \\"value\\": 10}, {\\"group\\": \\"B\\", \\"value\\": 20}, {\\"group\\": \\"A\\", \\"value\\": 15}, {\\"group\\": \\"B\\", \\"value\\": 25}, {\\"group\\": \\"C\\", \\"value\\": 5}, {\\"group\\": \\"C\\", \\"value\\": 30} ] # Group data data_grouper = DataGrouper(data, \\"group\\") grouped_data = data_grouper.group_data() # Compute maximum values in parallel max_calculator = ParallelMaxCalculator(grouped_data, \\"value\\") maximums = max_calculator.compute_maximums() print(maximums) # Output should be {\'A\': 15, \'B\': 25, \'C\': 30} ``` Implement the required classes and methods to successfully group the data and compute the maximum value for each group in parallel.","solution":"from typing import List, Dict, Any import multiprocessing class DataGrouper: def __init__(self, data: List[Dict[str, Any]], key: str): Initialize with the dataset and the key used for grouping. self.data = data self.key = key def group_data(self) -> Dict[str, List[Dict[str, Any]]]: Group data into partitions based on the specified key. grouped_data = {} for item in self.data: group_key = item[self.key] if group_key not in grouped_data: grouped_data[group_key] = [] grouped_data[group_key].append(item) return grouped_data class ParallelMaxCalculator: def __init__(self, grouped_data: Dict[str, List[Dict[str, Any]]], value_key: str): Initialize with the grouped data and the key to compute the maximum value. self.grouped_data = grouped_data self.value_key = value_key def _compute_group_max(self, group_data: List[Dict[str, Any]]) -> Any: Helper function to compute the maximum value for a single group. return max(item[self.value_key] for item in group_data) def compute_maximums(self) -> Dict[str, Any]: Compute the maximum value for each group in parallel. pool = multiprocessing.Pool() group_keys = list(self.grouped_data.keys()) group_values = list(self.grouped_data.values()) max_values = pool.map(self._compute_group_max, group_values) pool.close() pool.join() return dict(zip(group_keys, max_values))"},{"question":"# Problem Statement Given an unsorted list of integers, your task is to implement a function `count_unique_elements(lst: list) -> int` that returns the number of unique elements in the list. # Function Signature ```python def count_unique_elements(lst: list) -> int: pass ``` # Input * `lst` (list of integers): The list in which you need to determine the number of unique elements. (0 ≤ |lst| ≤ 1000) # Output * `int`: The number of unique elements in the list. # Constraints * The elements in the list are integers and can be both negative and positive. * If the list is empty, return 0. # Examples ```python >>> count_unique_elements([1, 2, 2, 3, 4, 4, 5]) 5 >>> count_unique_elements([1, 1, 1, 1, 1]) 1 >>> count_unique_elements([1, -1, -1, 2, 2, 3, 3]) 4 >>> count_unique_elements([]) 0 >>> count_unique_elements([5, 5, 5, 5, 5, 5, 5, 5]) 1 ``` # Notes * Ensure to handle edge cases such as an empty list and lists with a large number of identical elements. * Utilize an appropriate data structure to efficiently determine the count of unique elements.","solution":"def count_unique_elements(lst: list) -> int: Returns the number of unique elements in the given list. Parameters: - lst (list of integers): The list in which you need to determine the number of unique elements. Returns: - int: The number of unique elements in the list. return len(set(lst))"},{"question":"# Problem Statement You need to design a function that determines if it is possible to form a target string `t` by picking characters from a given string `s` in the exact order they appear in `t` while maintaining their sequence in `s`. For example, given `s = \\"coding_is_fun\\"` and `t = \\"cis\\"`, the output should be `True` because the characters `\'c\'`, `\'i\'`, and `\'s\'` appear in `s` in that order. However, if `t = \\"icf\\"`, the output should be `False` because the character `\'i\'` appears before `\'c\'` in `s`. # Function Signature ```python def can_form_target(s: str, t: str) -> bool: ``` # Input * `s`: A string of lowercase letters and/or special characters. * `t`: A string of lowercase letters and/or special characters which may contain only characters that are part of `s`. # Output * Returns a boolean value indicating whether the target string `t` can be formed by picking characters from `s` in order. # Constraints * All inputs are non-empty strings. * Strings `s` and `t` may contain non-alphabetic characters. # Examples ```python assert can_form_target(\\"coding_is_fun\\", \\"cis\\") == True assert can_form_target(\\"coding_is_fun\\", \\"icf\\") == False assert can_form_target(\\"abc@123\\", \\"@12\\") == True assert can_form_target(\\"abc@123\\", \\"a1b\\") == False assert can_form_target(\\"abcdefgh\\", \\"abc\\") == True assert can_form_target(\\"abcdefgh\\", \\"ahg\\") == False ```","solution":"def can_form_target(s: str, t: str) -> bool: Determines if it is possible to form the target string \'t\' by picking characters from the string \'s\' in the exact order they appear in \'t\' while maintaining their sequence in \'s\'. index_s = 0 index_t = 0 while index_s < len(s) and index_t < len(t): if s[index_s] == t[index_t]: index_t += 1 index_s += 1 return index_t == len(t)"},{"question":"# Implement a Circular Buffer (Ring Buffer) You are required to implement a circular buffer (also known as a ring buffer) in Python. A circular buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure is efficient for scenarios where buffer overflow needs to be managed seamlessly, such as in streaming data or multitasking systems. Your task is to implement the `CircularBuffer` class with the following functionalities: 1. **Initialization**: Create the circular buffer with a given size. 2. **BufferLength**: A method `buffer_length(self)` that returns the current number of elements in the buffer. 3. **IsFull**: A method `is_full(self)` that returns `True` if the buffer is full and `False` otherwise. 4. **IsEmpty**: A method `is_empty(self)` that returns `True` if the buffer is empty and `False` otherwise. 5. **Enqueue**: A method `enqueue(self, value)` that adds a new value to the buffer. If the buffer is full, it should overwrite the oldest value. 6. **Dequeue**: A method `dequeue(self)` that removes and returns the oldest value from the buffer. If the buffer is empty, it should raise an `IndexError`. **Input Format**: - `Initialize(size)` - an integer for the buffer size. - `buffer_length(self)` - no input parameters. - `is_full(self)` - no input parameters. - `is_empty(self)` - no input parameters. - `enqueue(self, value)` - an integer. - `dequeue(self)` - no input parameters. **Output Format**: - `buffer_length(self)` - an integer. - `is_full(self)` - a boolean (`True` or `False`). - `is_empty(self)` - a boolean (`True` or `False`). - `enqueue(self, value)` - `None`. - `dequeue(self)` - an integer (raises `IndexError` if buffer is empty). **Constraints**: - The buffer size provided during initialization is a positive integer (greater than 0). **Example**: ```python # Create a new Circular Buffer with size 3 cb = CircularBuffer(3) # Enqueue elements cb.enqueue(10) cb.enqueue(20) cb.enqueue(30) # Check buffer length print(cb.buffer_length()) # Should print 3 # Check if buffer is full print(cb.is_full()) # Should print True # Dequeue an element print(cb.dequeue()) # Should print 10 # Check if buffer is empty print(cb.is_empty()) # Should print False # Enqueue a new element (will overwrite oldest) cb.enqueue(40) # Dequeue all elements print(cb.dequeue()) # Should print 20 print(cb.dequeue()) # Should print 30 print(cb.dequeue()) # Should print 40 # Check if buffer is empty print(cb.is_empty()) # Should print True ``` Write your solution and perform appropriate tests to ensure all methods work as expected.","solution":"class CircularBuffer: def __init__(self, size): self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def buffer_length(self): return self.count def is_full(self): return self.count == self.size def is_empty(self): return self.count == 0 def enqueue(self, value): self.buffer[self.tail] = value if self.is_full(): self.head = (self.head + 1) % self.size else: self.count += 1 self.tail = (self.tail + 1) % self.size def dequeue(self): if self.is_empty(): raise IndexError(\\"Dequeue from an empty buffer\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return value"},{"question":"# File System Analyzer **Context**: Develop a class that simulates a small file system for managing files and directories. The system should support the creation of directories and files, file writing, file reading, and directory listing. The challenge is to manage the structure of the file system and retrieve or modify information accordingly. # Task: Implement the following methods in a `FileSystem` class: 1. **Create Directory** 2. **Create File** 3. **Write to File** 4. **Read File** 5. **List Directory** # Requirements: 1. **Create Directory**: - Create a new directory given a path. - **Input**: String path. - **Output**: None. 2. **Create File**: - Create a new file in a given directory. - **Input**: String path (includes file name). - **Output**: None. 3. **Write to File**: - Write or append data to an existing file. - **Input**: String path (includes file name) and String data. - **Output**: None. 4. **Read File**: - Read the contents of an existing file. - **Input**: String path (includes file name). - **Output**: String data. 5. **List Directory**: - List all files and directories in a given directory. - **Input**: String path. - **Output**: List of strings (names of files and directories). # Constraints: 1. Directory and file paths are specified as Unix-like paths (e.g., `/root/folder/subfolder/file.txt`). 2. Directory and file names will be unique within their parent directory. 3. Operations will be performed in a sequence that avoids invalid accesses. 4. Listing the root directory will be a common scenario. # Example: * Create Directory: `/root/projects` * Create File: `/root/projects/todo.txt` * Write to File: `/root/projects/todo.txt` with \\"Complete coding challenge\\" * Read File: `/root/projects/todo.txt` * List Directory: `/root` Expected output for reading file: * \\"Complete coding challenge\\" Expected output for listing directory: * `[\'projects\']` # Guidelines: 1. Handle nested directory structures. 2. Provide clear and efficient methods to navigate and manage the file system. 3. Avoid using built-in file system libraries; simulate the file and directory structure. # Implementation: ```python class File: def __init__(self, name): self.name = name self.content = \\"\\" class Directory: def __init__(self, name): self.name = name self.children = {} class FileSystem: def __init__(self): self.root = Directory(\\"/\\") def create_directory(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") curr = self.root for dir_name in dirs: if dir_name not in curr.children: curr.children[dir_name] = Directory(dir_name) curr = curr.children[dir_name] def create_file(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: if dir_name not in curr.children: curr.children[dir_name] = Directory(dir_name) curr = curr.children[dir_name] curr.children[file_name] = File(file_name) def write_to_file(self, path, content): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: curr = curr.children[dir_name] curr.children[file_name].content += content def read_file(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: curr = curr.children[dir_name] return curr.children[file_name].content def list_directory(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") curr = self.root for dir_name in dirs: if dir_name: curr = curr.children[dir_name] return list(curr.children.keys()) # Example Usage fs = FileSystem() fs.create_directory(\\"/root/projects\\") fs.create_file(\\"/root/projects/todo.txt\\") fs.write_to_file(\\"/root/projects/todo.txt\\", \\"Complete coding challenge\\") print(fs.read_file(\\"/root/projects/todo.txt\\")) print(fs.list_directory(\\"/root\\")) ``` This implementation provides a basic structure for a file system and includes methods for creating directories and files, writing and reading file content, and listing directory contents. Ensure your code passes the example scenario and handle all specified operations correctly.","solution":"class File: def __init__(self, name): self.name = name self.content = \\"\\" class Directory: def __init__(self, name): self.name = name self.children = {} class FileSystem: def __init__(self): self.root = Directory(\\"/\\") def create_directory(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") curr = self.root for dir_name in dirs: if dir_name not in curr.children: curr.children[dir_name] = Directory(dir_name) curr = curr.children[dir_name] def create_file(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: if dir_name not in curr.children: curr.children[dir_name] = Directory(dir_name) curr = curr.children[dir_name] curr.children[file_name] = File(file_name) def write_to_file(self, path, content): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: curr = curr.children[dir_name] curr.children[file_name].content += content def read_file(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") file_name = dirs.pop() curr = self.root for dir_name in dirs: curr = curr.children[dir_name] return curr.children[file_name].content def list_directory(self, path): dirs = path.strip(\\"/\\").split(\\"/\\") curr = self.root for dir_name in dirs: if dir_name: curr = curr.children[dir_name] return list(curr.children.keys())"},{"question":"# Scenario: You have been hired as a software engineer to optimize the performance of an e-commerce platform\'s recommendation system. The system utilizes collaborative filtering to provide product recommendations based on user-item interactions. The recommendation engine is built using matrix factorization techniques to decompose the user-item interaction matrix. # Task: Implement a function to perform matrix factorization using Singular Value Decomposition (SVD) to generate product recommendations for users. Your function should first decompose the user-item interaction matrix and then reconstruct it using a specified number of singular values to approximate the original matrix. # Function Signature: ```python def svd_recommendations(interaction_matrix: np.ndarray, num_singular_values: int) -> np.ndarray: Perform matrix factorization using Singular Value Decomposition to generate product recommendations. Parameters: - interaction_matrix (np.ndarray): The user-item interaction matrix with shape (num_users, num_items). - num_singular_values (int): The number of singular values to retain for the reconstruction. Returns: - np.ndarray: The reconstructed user-item interaction matrix with recommendations. ``` # Constraints: - The interaction matrix entries represent user interactions with items (e.g., rating scores, clicks, purchases). - Ensure that the reconstructed matrix closely approximates the original matrix using the specified number of singular values. - Handle matrices with up to 1000 users and 1000 items efficiently. # Performance: - Aim to balance between accuracy of reconstruction and computational efficiency. - The function should scale efficiently with the increase in the number of users and items. # Evaluation: - Your solution will be evaluated on correctness, efficiency, and the quality of the reconstruction. - Test your function on various interaction matrices with known patterns and evaluate the quality of recommendations generated. # Example: ```python import numpy as np # Sample user-item interaction matrix interaction_matrix = np.array([ [5, 3, 0, 1], [4, 0, 0, 1], [1, 1, 0, 5], [0, 0, 0, 4], [0, 1, 5, 4], ]) # Apply SVD matrix factorization with 2 singular values reconstructed_matrix = svd_recommendations(interaction_matrix, num_singular_values=2) print(reconstructed_matrix) ``` In this example, `reconstructed_matrix` should provide an approximation of `interaction_matrix`, capturing the essential user-item interactions while potentially filling in missing values with predicted interactions.","solution":"import numpy as np from scipy.linalg import svd def svd_recommendations(interaction_matrix: np.ndarray, num_singular_values: int) -> np.ndarray: Perform matrix factorization using Singular Value Decomposition to generate product recommendations. Parameters: - interaction_matrix (np.ndarray): The user-item interaction matrix with shape (num_users, num_items). - num_singular_values (int): The number of singular values to retain for the reconstruction. Returns: - np.ndarray: The reconstructed user-item interaction matrix with recommendations. # Perform SVD U, Sigma, Vt = svd(interaction_matrix, full_matrices=False) # Retain only the top \'num_singular_values\' singular values Sigma[num_singular_values:] = 0 # Reconstruct the interaction matrix reconstructed_matrix = np.dot(U, np.dot(np.diag(Sigma), Vt)) return reconstructed_matrix"},{"question":"# Scenario You are tasked with developing a small component for a text processing application that finds and formats phone numbers. Your function should be able to identify valid phone numbers in a given text and format them in a standard way. # Task Implement a function `format_phone_numbers` that extracts all valid phone numbers from an input string and formats them into a standardized format \\"(xxx) xxx-xxxx\\". # Function Signature ```python def format_phone_numbers(text: str) -> List[str]: ``` # Input * `text`: A string containing phone numbers and other text. # Output * Returns a list of formatted phone numbers found in the input text. # Constraints * A phone number is considered valid if it matches the format `xxx-xxx-xxxx` where `x` is a digit. * The function should correctly handle cases where there might be multiple valid phone numbers in the input text. * The function should handle empty strings and return an empty list in such cases. * Do not use any external libraries, and the function must be implemented from scratch. # Example ```python >>> format_phone_numbers(\\"Call me at 123-456-7890 or at 987-654-3210\\") [\'(123) 456-7890\', \'(987) 654-3210\'] >>> format_phone_numbers(\\"My number is 555-123-4567.\\") [\'(555) 123-4567\'] >>> format_phone_numbers(\\"No numbers here!\\") [] ``` # Performance Requirements * The solution should be efficient enough to handle input strings of length up to (10^7) characters. # Edge Cases * Ensure that your function ignores invalid phone numbers or incomplete sequences of digits. * Handle cases with multiple phone numbers correctly, ensuring no duplicates are included in the output unless they appear multiple times in the input.","solution":"import re from typing import List def format_phone_numbers(text: str) -> List[str]: Extracts all valid phone numbers from the text and formats them as (xxx) xxx-xxxx. A valid phone number is in the format xxx-xxx-xxxx. # Regular expression to find valid phone numbers in the text. phone_regex = r\'bd{3}-d{3}-d{4}b\' # Find all matches of the phone number format matches = re.findall(phone_regex, text) # Format each match found formatted_numbers = [f\\"({number[:3]}) {number[4:7]}-{number[8:]}\\" for number in matches] return formatted_numbers"},{"question":"# Question: Write a function that implements a simple cache system to optimize the computation of the Fibonacci sequence. Your task is to extend the implementation by modifying the `fib_with_cache` function to meet the following requirements: 1. **Edge Case Validation**: Ensure the function validates the input `n` such that it is a non-negative integer. If not, raise a `ValueError` with the message \\"Input must be a non-negative integer.\\" 2. **Cache Implementation**: Use a dictionary to store the previously computed Fibonacci numbers to avoid redundant calculations. 3. **Performance Tracking**: Add a counter to track and return the number of times a cached value is used during the computation. **Function Signature**: ```python def fib_with_cache(n: int) -> Tuple[int, int]: pass ``` **Input**: - `n`: A non-negative integer representing the position in the Fibonacci sequence. **Output**: - A tuple where the first element is the `n`th Fibonacci number and the second element is the number of times a cached value is used. **Constraints**: - The function should handle cases where `n` is 0 or 1 directly. - Use a local cache (a dictionary) within the function. **Example**: ```python >>> fib_with_cache(0) (0, 0) >>> fib_with_cache(1) (1, 0) >>> fib_with_cache(5) (5, 3) >>> fib_with_cache(10) (55, 37) ``` *Your task is to implement the `fib_with_cache` function according to the described requirements.*","solution":"from typing import Tuple def fib_with_cache(n: int) -> Tuple[int, int]: Compute the n-th Fibonacci number using a cache to optimize and track the number of cache hits. Parameters: n (int): The position in the Fibonacci sequence. Returns: Tuple[int, int]: n-th Fibonacci number and number of cache hits. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") cache = {} cache_hits = 0 def fib(n: int) -> int: nonlocal cache_hits if n in cache: cache_hits += 1 return cache[n] if n == 0: result = 0 elif n == 1: result = 1 else: result = fib(n - 1) + fib(n - 2) cache[n] = result return result result = fib(n) return (result, cache_hits)"},{"question":"# **Evaluate Postfix Expression** Your task is to evaluate a given postfix expression and return the final result. A postfix expression (also known as Reverse Polish notation) is a mathematical notation in which every operator follows all of its operands. This makes it easy to process expressions without needing to consider operator precedence or parentheses. # **Function Signature** ```python def evaluate_postfix(expression: str) -> float: pass ``` # **Input** - `expression`: A string representing the postfix expression. - The expression consists of integers and the operators `+`, `-`, `*`, `/` separated by spaces. - The expression is guaranteed to be valid and there will not be division by zero errors. # **Output** - Return a floating-point number representing the result of the postfix evaluation. # **Constraints** - The length of the expression will not be more than 1000 characters. # **Examples** ```python assert abs(evaluate_postfix(\\"3 4 +\\") - 7.0) < 1e-9 assert abs(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\") - 14.0) < 1e-9 assert abs(evaluate_postfix(\\"10 2 8 * + 3 -\\") - 23.0) < 1e-9 assert abs(evaluate_postfix(\\"6 2 /\\") - 3.0) < 1e-9 assert abs(evaluate_postfix(\\"1 2 + 3 4 * + 5 -\\") - 10.0) < 1e-9 ``` # **Notes** - The implementation should handle each token (number or operator) appropriately as it processes the input. - Use a stack data structure to keep track of the operands. - Return the final result as a floating-point number. - Ensure to handle floating-point arithmetic properly to account for operations that result in non-integer outputs.","solution":"def evaluate_postfix(expression: str) -> float: stack = [] for token in expression.split(): if token.isdigit() or (token[1:].isdigit() and token[0] == \'-\'): stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) return stack.pop() # Example usage print(evaluate_postfix(\\"5 1 2 + 4 * + 3 -\\")) # Should print 14.0"},{"question":"# Rot13 Cipher Implementation You have been provided with the implementation of the Rot13 Cipher, a simple substitution cipher that replaces a letter with the 13th letter after it in the alphabet. Your task is to extend this implementation to handle multiple ciphers, where the user can specify the number of rotations for encryption and decryption. Additionally, the implementation should handle both uppercase and lowercase letters, preserving non-alphabetic characters. # Requirements: 1. **Function Signature**: ```python def encrypt_texts(texts: list[str], rotations: int) -> list[str]: ``` ```python def decrypt_texts(encrypted_texts: list[str], rotations: int) -> list[str]: ``` 2. **Inputs**: * `texts`: A list of plaintext strings. * `rotations`: An integer representing the number of positions each letter in the text should be shifted. 3. **Outputs**: * For `encrypt_texts()`: Return a list of encrypted strings. * For `decrypt_texts()`: Return a list of decrypted strings. # Constraints: 1. The `texts` will only contain printable ASCII characters. 2. The length of each text element in the list will be at least 1. 3. There will not be more than 100 texts in the list. 4. The `rotations` value will be in the range [1, 25]. 5. Text lengths will not exceed 1000 characters. # Example: ```python >>> texts = [\\"Hello World!\\", \\"Python Programming\\"] >>> rotations = 13 >>> encrypted_texts = encrypt_texts(texts, rotations) >>> encrypted_texts [\'Uryyb Jbeyq!\', \'Clguba Cebtenzzvat\'] >>> decrypted_texts = decrypt_texts(encrypted_texts, rotations) >>> decrypted_texts [\'Hello World!\', \'Python Programming\'] ``` # Detailed Steps: 1. **Encryption Function**: Implement a function that iterates through each character in the text, shifts letters by the specified number of positions while preserving the case, and leaves non-alphabetic characters unchanged. 2. **Decryption Function**: Implement a function that reverses the encryption process by shifting the letters back by the specified number of positions, preserving the case, and leaving non-alphabetic characters unchanged. 3. **Edge Cases**: Handle edge cases such as texts with only non-alphabetic characters or varying cases correctly. # Implementation Tips: - Use string manipulation methods to handle case and character shifts efficiently. - Validate inputs to ensure rotation counts and text are correctly processed. - Leverage modular arithmetic to handle wrap-around shifts for both upper and lower case letters. ```python def encrypt_texts(texts: list[str], rotations: int) -> list[str]: def rotate_char(c, rotations): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + rotations) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + rotations) % 26 + ord(\'A\')) else: return c encrypted_texts = [] for text in texts: encrypted = \'\'.join(rotate_char(c, rotations) for c in text) encrypted_texts.append(encrypted) return encrypted_texts def decrypt_texts(encrypted_texts: list[str], rotations: int) -> list[str]: return encrypt_texts(encrypted_texts, -rotations) ```","solution":"def encrypt_texts(texts: list[str], rotations: int) -> list[str]: def rotate_char(c, rotations): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + rotations) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + rotations) % 26 + ord(\'A\')) else: return c encrypted_texts = [] for text in texts: encrypted = \'\'.join(rotate_char(c, rotations) for c in text) encrypted_texts.append(encrypted) return encrypted_texts def decrypt_texts(encrypted_texts: list[str], rotations: int) -> list[str]: def rotate_char(c, rotations): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') - rotations) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') - rotations) % 26 + ord(\'A\')) else: return c decrypted_texts = [] for text in encrypted_texts: decrypted = \'\'.join(rotate_char(c, rotations) for c in text) decrypted_texts.append(decrypted) return decrypted_texts"},{"question":"# Fibonacci Sequence Calculation Objective You are required to write a Python function that calculates the nth Fibonacci number. The implementation can be either iterative or recursive, but it should handle large values efficiently. Problem Statement Given a non-negative integer `n`, implement a function `fibonacci(n: int) -> int` that returns the nth Fibonacci number. You should also write a test suite to verify your implementation handles various cases correctly. Input and Output Format * **Input**: A non-negative integer `n`, where (0 <= n <= 30). * **Output**: An integer representing the nth Fibonacci number. Constraints * The input value will be a non-negative integer within the specified range. * The solution should efficiently handle cases where n is large within the range. Performance Requirements * Time Complexity: O(n) for iterative, O(2^n) for naive recursive approach; O(log n) for optimized solutions like matrix exponentiation. * Space Complexity: O(1) for iterative, O(n) for naive recursive (due to call stack). Example 1 * **Input**: `n = 0` * **Output**: `0` Example 2 * **Input**: `n = 7` * **Output**: `13` Example 3 * **Input**: `n = 10` * **Output**: `55` Tasks 1. Implement the function `fibonacci(n: int) -> int`. 2. Write a suite of test cases to ensure your implementation is correct, considering edge cases like the smallest and largest values within the range. Notes * Consider using an iterative solution for better performance with larger n. * Ensure your function is well-tested for edge cases and correctness.","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are given two strings `s` and `t`, and your task is to determine if it is possible to transform `s` into `t` by performing a series of shifts. A shift consists of moving the leftmost character of a string to the rightmost end. For example, if we shift \'abc\' once, it becomes \'bca\', and if we shift \'bca\' once, it becomes \'cab\'. # Function Specification Your task is to implement the following function: ```python def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed into string t through a series of shifts. Parameters: s (str): The original string to be transformed. t (str): The target string to achieve through shifts. Returns: bool: True if s can be transformed into t through a series of shifts, False otherwise. Example: >>> can_transform(\\"abc\\", \\"cab\\") True >>> can_transform(\\"abc\\", \\"bac\\") False ``` # Input Format 1. **s** (str): A string representing the original string to be transformed. It consists only of lowercase English letters. 2. **t** (str): A string representing the target string to achieve through shifts. It consists only of lowercase English letters and the same length as `s`. # Output Format A boolean value (`True` or `False`) indicating whether the string `s` can be transformed into string `t` using a series of shifts. # Constraints 1. ( 1 leq text{len}(s) = text{len}(t) leq 100 ) # Examples ```python >>> can_transform(\\"abc\\", \\"cab\\") True >>> can_transform(\\"abcd\\", \\"bcda\\") True >>> can_transform(\\"abc\\", \\"bac\\") False >>> can_transform(\\"a\\", \\"a\\") True ``` # Notes 1. You need to handle strings of varying lengths and ensure that your function is efficient. 2. Consider edge cases such as single-character strings and identical strings. 3. Make sure the function correctly identifies when no number of transformations will result in `t`.","solution":"def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed into string t through a series of shifts. Parameters: s (str): The original string to be transformed. t (str): The target string to achieve through shifts. Returns: bool: True if s can be transformed into t through a series of shifts, False otherwise. if len(s) != len(t): return False return t in (s + s)"},{"question":"# Longest Common Subsequence Problem **Scenario**: As a software engineer working on a text comparison tool, you are tasked with developing an algorithm to find the longest common subsequence (LCS) between two given strings, which can be utilized for tasks such as comparing document versions or DNA sequence analysis. **Task**: Implement a function `longest_common_subsequence(str1: str, str2: str) -> int` that efficiently calculates the length of the LCS. Input: - Two strings `str1` and `str2`, consisting of uppercase English letters (i.e., \'A\' to \'Z\'). - The lengths of `str1` and `str2` will be between 1 and 1000. Output: - An integer representing the length of the LCS of the two strings. Examples: ```python assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") == 4 assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 assert longest_common_subsequence(\\"ABC\\", \\"AC\\") == 2 ``` Constraints: - The strings will consist only of uppercase English letters. - The algorithm should aim for efficient space complexity and handle the given input size effectively. Performance Requirements: - The algorithm should run in O(m * n) time complexity, where `m` and `n` are the lengths of `str1` and `str2` respectively. - Optimize the algorithm to utilize minimal auxiliary space if possible. Instructions: 1. Implement the function `longest_common_subsequence` and ensure it adheres to the specified time complexity. 2. Test the algorithm using the provided examples and ensure it handles various cases, including edge cases efficiently. ```python def longest_common_subsequence(str1, str2): # Implement the function here pass # Example usage: str1 = \\"ABCBDAB\\" str2 = \\"BDCABA\\" print(\\"LCS Length:\\", longest_common_subsequence(str1, str2)) ```","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array in a bottom-up manner. for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coding Assessment Question Context You are given a dataset of movie reviews along with their sentiment scores (positive or negative). Your task is to implement a Naive Bayes classifier to predict the sentiment of a given movie review. The dataset is preprocessed such that each review is tokenized into words, and the frequency of each word in the dataset is provided. Task Your task is to complete the Naive Bayes classifier implementation and improve its accuracy by addressing the following: 1. **Laplace Smoothing**: Implement Laplace smoothing to handle words that may appear in the test set but not in the training set. 2. **Probability Calculation**: Ensure proper calculation of the probabilities to avoid numerical underflow. 3. **Efficiency**: Optimize the code for both time and space complexity, considering large datasets. Function Signature ```python def predict_sentiment(review: str, word_frequencies: dict, class_probabilities: dict) -> str: Naive Bayes sentiment prediction with Laplace smoothing. Parameters: review (str): The movie review to classify. word_frequencies (dict): A dictionary where keys are words and values are another dictionary with counts of the word in positive and negative reviews. class_probabilities (dict): A dictionary with the prior probabilities of positive and negative classes. Returns: str: The predicted sentiment, either \\"positive\\" or \\"negative\\". ``` Input * **review (str)**: A string containing the movie review to classify. * **word_frequencies (dict)**: A dictionary where keys are words and values are dictionaries containing the counts of the word in positive and negative reviews. Example: ```python { \\"excellent\\": {\\"positive\\": 5, \\"negative\\": 1}, \\"bad\\": {\\"positive\\": 1, \\"negative\\": 4}, # ... other words } ``` * **class_probabilities (dict)**: A dictionary with the prior probabilities of the positive and negative classes. Example: ```python { \\"positive\\": 0.6, \\"negative\\": 0.4 } ``` Output * The function should return the predicted sentiment as a string, either \\"positive\\" or \\"negative\\". Constraints * Use Laplace smoothing to handle words that may appear in the test review but were not in the training set. * Ensure your calculations are robust against numerical underflow by using logarithms. * Optimize the function for efficiency with respect to both time and space. Example ```python review = \\"excellent movie with a remarkable plot\\" word_frequencies = { \\"excellent\\": {\\"positive\\": 5, \\"negative\\": 1}, \\"movie\\": {\\"positive\\": 3, \\"negative\\": 2}, \\"with\\": {\\"positive\\": 4, \\"negative\\": 3}, \\"a\\": {\\"positive\\": 6, \\"negative\\": 6}, \\"remarkable\\": {\\"positive\\": 2, \\"negative\\": 1}, \\"plot\\": {\\"positive\\": 3, \\"negative\\": 2}, # ... other words } class_probabilities = { \\"positive\\": 0.6, \\"negative\\": 0.4 } result = predict_sentiment(review, word_frequencies, class_probabilities) print(result) # Expected \\"positive\\" ``` Good luck!","solution":"import math def predict_sentiment(review: str, word_frequencies: dict, class_probabilities: dict) -> str: Naive Bayes sentiment prediction with Laplace smoothing. Parameters: review (str): The movie review to classify. word_frequencies (dict): A dictionary where keys are words and values are another dictionary with counts of the word in positive and negative reviews. class_probabilities (dict): A dictionary with the prior probabilities of positive and negative classes. Returns: str: The predicted sentiment, either \\"positive\\" or \\"negative\\". # Tokenize the review by splitting on spaces words = review.split() # Initialize log probability for both classes log_prob_pos = math.log(class_probabilities[\\"positive\\"]) log_prob_neg = math.log(class_probabilities[\\"negative\\"]) # Calculate total word counts in positive and negative reviews total_words_pos = sum(word_frequencies[word][\\"positive\\"] for word in word_frequencies) total_words_neg = sum(word_frequencies[word][\\"negative\\"] for word in word_frequencies) # Calculate vocabulary size vocab_size = len(word_frequencies) # Apply Laplace smoothing and calculate the probabilities for each word in the review for word in words: word_count_pos = word_frequencies.get(word, {\\"positive\\": 0, \\"negative\\": 0})[\\"positive\\"] word_count_neg = word_frequencies.get(word, {\\"positive\\": 0, \\"negative\\": 0})[\\"negative\\"] # Using Laplace smoothing word_prob_pos = (word_count_pos + 1) / (total_words_pos + vocab_size) word_prob_neg = (word_count_neg + 1) / (total_words_neg + vocab_size) log_prob_pos += math.log(word_prob_pos) log_prob_neg += math.log(word_prob_neg) # Compare log probabilities to make the prediction if log_prob_pos > log_prob_neg: return \\"positive\\" else: return \\"negative\\""},{"question":"# Binary Search Tree Serialization and Deserialization **Scenario**: You are working on a project that involves transmitting a large dataset of hierarchical information over a network. To optimize the process, you need to serialize the data structure into a compact string format and then deserialize it back into its original form upon receipt. **Task**: Implement a class in Python for a Binary Search Tree (BST) that supports serialization and deserialization. The class should include the following functionalities: 1. Insert elements into the BST. 2. Serialize the BST into a compact string format. 3. Deserialize the string back into a BST structure. **Function Signature**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): pass class BST: def __init__(self) -> None: pass def insert(self, val: int) -> None: pass def serialize(self) -> str: pass @staticmethod def deserialize(data: str) -> \'BST\': pass ``` # Constraints: 1. **Inputs**: - `val`: Integer value to be inserted in the BST. - `data`: A string representing the serialized BST. 2. **Outputs**: - Serialized string from the BST. - A deserialized BST reconstructed from the input string. **Example**: ```python # Example of insertion and serialization: bst = BST() elements = [50, 30, 70, 20, 40, 60, 80] for el in elements: bst.insert(el) # Serialize the BST serialized_bst = bst.serialize() print(serialized_bst) # Output example: \\"50,30,20,40,70,60,80\\" # Deserialize the BST deserialized_bst = BST.deserialize(serialized_bst) # Validate the structure by serializing the deserialized BST again print(deserialized_bst.serialize()) # Output should match the initial serialized string. # Ensure handling of edge cases, like an empty tree empty_bst = BST() empty_serialized = empty_bst.serialize() print(empty_serialized) # Expected output: \\"\\" # Deserialize the empty tree deserialized_empty_bst = BST.deserialize(empty_serialized) print(deserialized_empty_bst.serialize()) # Expected: \\"\\" ``` # Performance Requirements: 1. Ensure the insertion, serialization, and deserialization methods are efficient and can handle large datasets, up to 10^4 nodes efficiently. 2. Optimize the operations to maintain O(n) time complexity for serialization and deserialization where n is the number of nodes in the BST.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert_recursive(self.root, val) def _insert_recursive(self, node: TreeNode, val: int): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert_recursive(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert_recursive(node.right, val) def serialize(self) -> str: def preorder(node): return [node.val] + preorder(node.left) + preorder(node.right) if node else [] return \',\'.join(map(str, preorder(self.root))) @staticmethod def deserialize(data: str) -> \'BST\': if not data: return BST() values = list(map(int, data.split(\',\'))) bst = BST() for val in values: bst.insert(val) return bst"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},R={class:"card-container"},N={key:0,class:"empty-state"},L=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",R,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,L)):u("",!0)])}const Y=h(F,[["render",D],["__scopeId","data-v-21ff9434"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/32.md","filePath":"drive/32.md"}'),j={name:"drive/32.md"},V=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,V as default};
