import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function N(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const E=c(k,[["render",N],["__scopeId","data-v-038f91df"]]),S=JSON.parse('[{"question":"# Question: Validate Word Pattern Mapping Given a pattern string and a sentence string, your task is to implement the function `is_bijective_pattern(pattern: str, sentence: str) -> bool` that verifies if the sentence follows the same pattern as defined by the pattern string. A sentence follows the pattern if there is a one-to-one and onto mapping (bijection) between each letter in the pattern and each word in the sentence. Input - `pattern` (string): A string of lowercase letters where each character represents a unique element in the bijection. - `sentence` (string): A string of lowercase words separated by single spaces. Output - Return `True` if the sentence follows the pattern by the given rules. - Return `False` otherwise. Constraints - The `pattern` string will only contain lowercase English letters. - The `sentence` string will only contain lowercase English words separated by single spaces. Examples 1. `is_bijective_pattern(\\"abba\\", \\"dog cat cat dog\\")` should return `True`. 2. `is_bijective_pattern(\\"abba\\", \\"dog cat cat fish\\")` should return `False`. 3. `is_bijective_pattern(\\"aaaa\\", \\"dog cat cat dog\\")` should return `False`. 4. `is_bijective_pattern(\\"abba\\", \\"dog dog dog dog\\")` should return `False`. Notes - You can assume that the `pattern` and `sentence` inputs are always non-empty and contain no leading or trailing spaces. - Use appropriate data structures to maintain mappings and ensure one-to-one correspondence. Function Definition ```python def is_bijective_pattern(pattern: str, sentence: str) -> bool: pass ```","solution":"def is_bijective_pattern(pattern: str, sentence: str) -> bool: words = sentence.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"Context Given a directed graph, you need to identify all the strongly connected components (SCCs). Each SCC is a maximal subgraph where every vertex is reachable from every other vertex in the same SCC. Task Write a function `find_strongly_connected_components(V, edges)` that takes: - `V` (an integer representing the number of vertices), - `edges` (a list of tuples representing the directed edges in the graph). The function should return a list of lists, where each inner list represents a strongly connected component containing vertex indices. Function Signature ```python def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: ``` Input - `V` (1 ≤ V ≤ (10^4)): The number of vertices. - `edges` (0 ≤ len(edges) ≤ (10^5)): A list of tuples where each tuple (u, v) indicates a directed edge from vertex ( u ) to vertex ( v ) (0 ≤ u, v < V). Output - A list of lists, where each list contains the vertices in one strongly connected component. Example ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] # Sample Output # [ # [1, 3, 2, 0], # [5, 4] # ] print(find_strongly_connected_components(V, edges)) ``` Constraints - You may assume the graph does not contain self-loops. - Ensure your algorithm runs in linear time complexity relative to the number of vertices and edges. Notes - The order of vertices within each SCC or the order of SCCs in the output list does not matter. - Think carefully about edge cases like completely disconnected vertices or graphs with no edges.","solution":"from typing import List, Tuple def find_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: index = [0] # single mutable integer to keep track of the index stack = [] indices = [-1] * V lowlink = [-1] * V on_stack = [False] * V sccs = [] def strongconnect(v): indices[v] = index[0] lowlink[v] = index[0] index[0] += 1 stack.append(v) on_stack[v] = True for (u, w) in edges: if u == v: if indices[w] == -1: strongconnect(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in range(V): if indices[v] == -1: strongconnect(v) return sccs"},{"question":"# Question: Implement a Weighted Moving Average Calculator **Scenario**: You are working on a project for a financial analytics firm. One of the tasks is to implement a weighted moving average calculator that gives more importance to recent data points compared to older ones in a sliding window. **Task**: Write a Python class `WeightedMovingAverage` that calculates the weighted moving average of a stream of integers. Each integer has a corresponding weight, and the most recent integer should have the highest weight. **Class Definition**: 1. **Initialization**: The class should be initialized with `size` which defines the maximum number of recent values to consider. 2. **Method**: - `next(val, weight)`: Adds the new value and its weight to the data structure and returns the weighted moving average. **Input and Output Specifications**: * `size` (in the constructor) - an integer defining the window size. * `next(val, weight)` - a method where: - `val` is an integer. - `weight` is a float representing the weight of the new value. - Returns a float which is the weighted moving average of the current window. **Constraints**: * 1 <= `size` <= 1000 * -10^5 <= `val` <= 10^5 * 0 <= `weight` <= 1 **Example**: ```python wma = WeightedMovingAverage(3) assert wma.next(1, 0.1) == 1.0 assert wma.next(10, 0.5) == (1*0.1 + 10*0.5) / (0.1 + 0.5) assert wma.next(3, 0.3) == (1*0.1 + 10*0.5 + 3*0.3) / (0.1 + 0.5 + 0.3) assert wma.next(5, 0.8) == (10*0.5 + 3*0.3 + 5*0.8) / (0.5 + 0.3 + 0.8) ``` **Note**: * Consider implementing the class using optimized data structures to maintain efficient performance. * Ensure the weights are stored and utilized correctly to maintain the order and calculation relevancy.","solution":"from collections import deque class WeightedMovingAverage: def __init__(self, size): self.size = size self.queue = deque() self.total_value = 0.0 self.total_weight = 0.0 def next(self, val, weight): # Adding the new value and weight self.queue.append((val, weight)) self.total_value += val * weight self.total_weight += weight # If the size exceeds the limit, remove the oldest value if len(self.queue) > self.size: old_val, old_weight = self.queue.popleft() self.total_value -= old_val * old_weight self.total_weight -= old_weight # Return the current weighted moving average if self.total_weight == 0: return 0 return self.total_value / self.total_weight"},{"question":"# Task Write a function `reverse_words_advanced` that reverses the order of words in a given sentence, taking into account multiple consecutive whitespaces and punctuation marks. # Detailed Specifications: 1. **Input**: A single string `sentence` which may contain leading, trailing, or multiple consecutive whitespaces. It may also include punctuation marks which should stay attached to their respective words. 2. **Output**: A string with words in reversed order, maintaining original punctuation and whitespaces. # Constraints: - Do not use additional libraries or built-in methods specifically for reversing strings or words (except for basic string operations like splitting and joining). - The function should handle up to 1000 words efficiently. # Function Signature: ```python def reverse_words_advanced(sentence: str) -> str: pass ``` # Example: ```python sentence = \\" Hello, world! This is a test. \\" # expected output: \\" test. a is This world! Hello, \\" print(reverse_words_advanced(sentence)) ``` # Hints: - Consider using a more sophisticated splitting that takes consecutive whitespaces into account. - Maintain punctuation marks attached to words during splitting. - Ensure that whitespaces between words are kept as in the original while reversing the words.","solution":"def reverse_words_advanced(sentence: str) -> str: Reverses the order of words in a sentence, handling multiple whitespaces and punctuation. # Split the sentence into words and intermediate whitespaces/punctuation segments = [] word = \'\' whitespace = \'\' for char in sentence: if char.isspace(): if word: segments.append(word) word = \'\' whitespace += char else: if whitespace: segments.append(whitespace) whitespace = \'\' word += char if word: segments.append(word) if whitespace: segments.append(whitespace) # Reverse the segments list and join it back into a string reversed_sentence = \'\'.join(segments[::-1]) return reversed_sentence"},{"question":"# Scenario Imagine you are designing a system to map out land and water regions from satellite imagery for geographical studies. You have been given a 2D grid map where \'1\' represents land and \'0\' represents water. Your task is to determine the number of isolated land masses, or \\"islands\\", to aid in this mapping. # Task Implement a function `num_islands(grid)` that takes a 2D list of characters (either \'1\' or \'0\') and returns the number of islands in the given grid. An island is defined as a group of adjacent \'1\'s connected horizontally or vertically (but not diagonally). The grid is surrounded by water on all four edges. # Input - `grid`: A 2D list of strings, where each element is either \\"1\\" or \\"0\\". The grid will have at least one row and one column. # Output - An integer representing the number of islands. # Constraints - Each \'1\' in the grid represents part of an island. - Each \'0\' in the grid represents water. - You may assume that all four edges of the grid are surrounded by water (implying no out-of-bounds errors). # Example ```python grid1 = [ [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"1\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"] ] # num_islands(grid1) should return 1 grid2 = [ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ] # num_islands(grid2) should return 3 ``` # Requirement - Your solution should handle grids of varying sizes up to 300x300. - Be mindful of potential stack overflow issues due to excessive recursion depth. Implement the function `num_islands` to complete the task.","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(x, y): # If it\'s out of bound or water, stop the exploration if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \\"0\\": return # Mark the land as visited grid[x][y] = \\"0\\" # Explore all four directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands = 0 for i in range(len(grid)): for j in range(len(grid[i])): if grid[i][j] == \\"1\\": islands += 1 dfs(i, j) return islands"},{"question":"# Scenario You are working at a prestigious restaurant known for serving pancakes in a very specific order—smallest to largest. The chef likes to sort the pancakes with a technique known as **Pancake Sorting** where you can flip a subset of pancakes from the top of the stack. Given an array representing pancakes of different sizes, you have to implement a function that sorts them using the pancake sorting algorithm. # Task Write a function `pancake_sort` that sorts an array of integers using the pancake sort algorithm. The pancake sort only allows you to reverse a prefix (initial segment) of the array at a time. # Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: List of integers of size `N` where 1 ≤ `N` ≤ 1000. # Output - Return the sorted array in ascending order. # Example ```python assert pancake_sort([3, 6, 1, 10, 2]) == [1, 2, 3, 6, 10] assert pancake_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert pancake_sort([4]) == [4] assert pancake_sort([]) == [] ``` # Constraints 1. Your implementation should have a time complexity of O(N^2). 2. Your implementation should sort the array in-place using only prefix reversals, no additional lists can be used except for the recursive call stack.","solution":"def pancake_sort(arr): def flip_end(end_index): Reverse the elements from arr[0] to arr[end_index]. start = 0 while start < end_index: arr[start], arr[end_index] = arr[end_index], arr[start] start += 1 end_index -= 1 def find_max_index(n): Find the index of the maximum element in arr[0:n]. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index n = len(arr) # Sorting procedure for size in range(n, 1, -1): # Find index of the maximum element within arr[0:size] max_index = find_max_index(size) # If the maximum element is not at its final position if max_index != size - 1: # Flip maximum to the top flip_end(max_index) # Then flip it to the final position flip_end(size - 1) return arr"},{"question":"# Question: Implement a Separate Chaining Hash Table with Resize The provided code implements a basic separate chaining hash table. Your task is to extend this implementation to include dynamic resizing and improve the hash distribution. Implement the following features: 1. **Resizing Mechanism**: * The table should resize (i.e., double its size) when the load factor (number of elements/table size) exceeds 0.7. 2. **Improved Hash Function**: * Update the hash function to reduce collisions by utilizing a prime number as the table size and incorporating both multiplicative and additive constants. Additional Requirements: * Ensure that the key-value pairs remain accurate after resizing. * Implement a method to check the current load factor. # Function Signatures ```python class ResizeSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def resize(self): Double the size of the table and rehash all existing key-value pairs. def put(self, key, value): Insert the key-value pair and resize if needed. super().put(key, value) def hash(self, key): Hash function that utilizes both multiplicative and additive constants. def load_factor(self): Return the current load factor of the table. ``` # Example ```python table = ResizeSeparateChainingHashTable() for i in range(20): table.put(f\'key{i}\', f\'value{i}\') assert len(table) == 20 print(table.load_factor()) # Should be <= 0.7 ``` # Constraints * Each key is a string. * Each value is a string. * Initial table size should be a prime number. Implement and test the `ResizeSeparateChainingHashTable` to ensure it meets the above requirements.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [None] * self.size self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) if self.table[index] is None: self.table[index] = Node(key, value) self.count += 1 else: current = self.table[index] while current: if current.key == key: current.value = value return if current.next is None: current.next = Node(key, value) self.count += 1 return current = current.next def get(self, key): index = self.hash(key) current = self.table[index] while current: if current.key == key: return current.value current = current.next return None def delete(self, key): index = self.hash(key) current = self.table[index] prev = None while current: if current.key == key: if prev is None: self.table[index] = current.next else: prev.next = current.next self.count -= 1 return True prev, current = current, current.next return False class ResizeSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def resize(self): old_table = self.table new_size = self._next_prime(self.size * 2) self.table = [None] * new_size self.size = new_size self.count = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def put(self, key, value): if self.load_factor() > 0.7: self.resize() super().put(key, value) def hash(self, key): A = 33 B = 89 return (A * sum(ord(char) for char in key) + B) % self.size def load_factor(self): return self.count / self.size def _is_prime(self, num): Check if a number is a prime if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def _next_prime(self, num): Get the next prime number greater than num while not self._is_prime(num): num += 1 return num"},{"question":"# Question: Implement a Topological Sort Algorithm with Error Handling Scenario You are tasked with implementing a topological sort algorithm for a project management tool. The input is a list of tasks and their prerequisite dependencies. For example, if task B cannot start before task A is finished, the input will reflect such a dependency. Your implementation should output the order in which tasks must be completed. Additionally, your function should detect cycles in the dependencies and raise an exception if any are found, indicating that the tasks cannot be completed due to circular dependencies. Requirements Write a function `topological_sort(tasks)` that takes in a dictionary `tasks` representing a directed acyclic graph (DAG). The keys are task identifiers, and the values are lists of task identifiers that must be completed before the key task can start. 1. **Input**: - `tasks`: A dictionary where each key is a task and the value is a list of prerequisite tasks. - Example: ```python tasks = { \'A\': [\'C\'], \'B\': [\'C\'], \'C\': [] } ``` 2. **Output**: - Return a list representing the topological ordering of tasks. - Example: ```python [\'C\', \'A\', \'B\'] ``` 3. **Constraints**: - The input graph is guaranteed to be valid (i.e., no duplicate edges). - The function must detect cycles and raise a `ValueError` with the message \\"cycle detected\\" if a cycle is present in the graph. 4. **Performance**: - Time complexity: O(V + E) - Space complexity: O(V) Function Signature ```python def topological_sort(tasks: Dict[str, List[str]]) -> List[str]: pass ``` Examples ```python tasks1 = { \'A\': [\'C\'], \'B\': [\'C\'], \'C\': [] } assert topological_sort(tasks1) == [\'C\', \'A\', \'B\'] or topological_sort(tasks1) == [\'C\', \'B\', \'A\'] tasks2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } try: topological_sort(tasks2) except ValueError as e: assert str(e) == \\"cycle detected\\" ``` Notes * Example outputs are not unique if the dependencies allow for different valid orderings. * Handle large graphs within given performance constraints. * Properly manage all edge cases as discussed in the analysis.","solution":"from typing import List, Dict def topological_sort(tasks: Dict[str, List[str]]) -> List[str]: from collections import defaultdict, deque # Calculate in-degrees and build a reverse graph (dependency graph) in_degrees = defaultdict(int) graph = defaultdict(list) for task, dependencies in tasks.items(): if task not in in_degrees: in_degrees[task] = 0 # Initialize in-degree for tasks without prerequisites for dep in dependencies: graph[dep].append(task) in_degrees[task] += 1 # Queue for tasks with 0 in-degrees (independent tasks) queue = deque([task for task in tasks if in_degrees[task] == 0]) result = [] while queue: current = queue.popleft() result.append(current) for dependent in graph[current]: in_degrees[dependent] -= 1 if in_degrees[dependent] == 0: queue.append(dependent) if len(result) != len(tasks): raise ValueError(\\"cycle detected\\") return result"},{"question":"# Fibonacci Number Calculation Objective You are to implement a function that efficiently computes the n-th Fibonacci number using dynamic programming. Problem Statement In mathematics, the Fibonacci numbers, commonly denoted F(n), form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Given a non-negative integer n, write a function that returns the n-th Fibonacci number. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input - n (0 <= n <= 10^6): a non-negative integer representing the position in the Fibonacci sequence. Output - An integer representing the n-th Fibonacci number. Constraints - Optimize for both time and space complexity. - The function should handle large values of n efficiently and avoid unnecessary computations. Example ```python print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(2)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(50)) # Output: 12586269025 ``` Notes - Think about how to avoid recalculations of the same Fibonacci numbers. - Consider edge cases such as small inputs (e.g., n = 0 or n = 1). Your task is to implement this function efficiently. You may use any optimization techniques necessary.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 # Use dynamic programming with two variables approach a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Removing Consecutive Duplicates from a Sorted Linked List As an advanced programming challenge, you are required to demonstrate your understanding of linked lists and algorithms to handle data efficiently. Your task is to write a function `remove_consecutive_duplicates` that removes all consecutive duplicate values from a given sorted linked list. Function Signature ```python def remove_consecutive_duplicates(head: Node) -> Node: pass ``` Input - `head`: The head node of a sorted linked list where each node contains an integer value. Output - The function should return the `head` of the modified linked list with all consecutive duplicate values removed. Constraints - The linked list is sorted in non-decreasing order. - The input linked list can be empty. - The maximum number of nodes in the linked list is 10^5. - You should aim for O(N) time complexity and O(1) space complexity. Example ```python # Given linked list: 1 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 5 # After duplication removal: 1 -> 2 -> 3 -> 4 -> 5 a = Node(1) b = Node(1) c = Node(2) d = Node(3) e = Node(3) f = Node(4) g = Node(5) h = Node(5) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g g.next = h new_head = remove_consecutive_duplicates(a) # Output linked list: 1 -> 2 -> 3 -> 4 -> 5 print_linked_list(new_head) ``` Detailed Explanation 1. Traverse through the linked list. 2. Compare each node’s value with the value of the node next to it. 3. If they are the same, adjust the next pointer to skip the duplicate. 4. Continue until the end of the list is reached. 5. Ensure no additional data structures are used, keeping space complexity constant. Write your function `remove_consecutive_duplicates` adhering to the described behavior and constraints.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_consecutive_duplicates(head: Node) -> Node: current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"**Markov Chain Text Simulator** Suppose you are given a Markov chain representing the transition probabilities of characters in a text. The Markov chain is described with a dictionary where keys are characters and values are dictionaries of subsequent characters with corresponding transition probabilities. Write a function `generate_text(markov_chain, start_char, length)` to generate a sequence of characters starting from `start_char` using the Markov Chain, having a specified `length`. # Input * `markov_chain`: A dictionary where keys are characters and values are dictionaries. The inner dictionary contains characters and their transition probabilities. * `start_char`: A character indicating the beginning of the generated sequence. * `length`: An integer representing the number of characters to generate including the start character. # Output * A string representing the sequence of generated characters. # Constraints * All probabilities in the transition maps sum to 1. * The chain is valid and non-empty. * `length` is a positive integer. # Example ```python markov_chain = { \'A\': {\'A\': 0.2, \'B\': 0.3, \'C\': 0.5}, \'B\': {\'A\': 0.7, \'C\': 0.3}, \'C\': {\'B\': 1.0} } start_char = \'A\' length = 10 print(generate_text(markov_chain, start_char, length)) ``` This should output a string of 10 characters starting with \'A\' based on the provided transition probabilities in the Markov chain. **Note:** Your implementation should handle the randomness inherent in the process and ensure that the generated text respects the transition probabilities.","solution":"import random def generate_text(markov_chain, start_char, length): Generates a sequence of characters starting from start_char using the Markov Chain, having a specified length. Parameters: markov_chain (dict): A dictionary where keys are characters and values are dictionaries of subsequent characters with corresponding transition probabilities. start_char (str): A character indicating the beginning of the generated sequence. length (int): An integer representing the number of characters to generate including the start character. Returns: str: A string representing the sequence of generated characters. result = [start_char] current_char = start_char for _ in range(length - 1): next_chars = list(markov_chain[current_char].keys()) probabilities = list(markov_chain[current_char].values()) current_char = random.choices(next_chars, probabilities)[0] result.append(current_char) return \'\'.join(result)"},{"question":"**Scenario**: You are a software engineer at a company that deals with large datasets. Your team has recently encountered performance issues with Insertion Sort on moderately sized datasets. You propose to use Shell Sort as a more efficient alternative. # Task Implement the `shell_sort` function that sorts a list of integers in ascending order using the Shell Sort algorithm. # Function Signature ```python def shell_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers. `1 <= len(arr) <= 10^5`. # Output - A list of integers sorted in ascending order. # Constraints - Your solution should have a time complexity better than O(n^2) for most cases. - Your function should not use any additional sorting libraries or functions (e.g., sort, sorted). # Performance Requirements - Your implementation should handle arrays of size up to 100,000 efficiently. # Example ```python # Example 1 input_list = [12, 34, 54, 2, 3] output_list = shell_sort(input_list) print(output_list) # Output: [2, 3, 12, 34, 54] # Example 2 input_list = [30, 20, 10] output_list = shell_sort(input_list) print(output_list) # Output: [10, 20, 30] ``` # Note - Carefully consider edge cases such as empty lists and lists with one element. - Ensure that your implementation is efficient and handles large lists within a reasonable time frame.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Shell Sort algorithm. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers in ascending order. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Permutation Generation Context You are working on a program that needs to generate all possible unique arrangements (permutations) of a given list of distinct integers. This can be used, for instance, in scenarios like generating possible game moves, solving puzzles, or testing combinations of input data. Task Implement a function `generate_permutations(numbers: List[int]) -> List[List[int]]` that takes a list of distinct integers `numbers` as input and returns a list of all possible permutations of those integers. Input * A list of distinct integers `numbers` with length `n`, where `1 <= n <= 9`. Output * A list of lists, where each inner list is a unique permutation of the input list `numbers`. Function Signature ```python from typing import List def generate_permutations(numbers: List[int]) -> List[List[int]]: pass ``` Example ```python numbers = [1, 2, 3] print(generate_permutations(numbers)) # Output: # [ # [1,2,3], # [1,3,2], # [2,1,3], # [2,3,1], # [3,1,2], # [3,2,1] # ] ``` Constraints * The function should return outputs within a reasonable time frame for inputs of length up to 9. * The generated permutations should not contain duplicates in any order. Notes * Consider edge cases like empty input list or list with a single element. * Optimize your solution to avoid excessive memory usage where possible.","solution":"from typing import List import itertools def generate_permutations(numbers: List[int]) -> List[List[int]]: Returns all possible permutations of the given list of distinct integers. return list(itertools.permutations(numbers))"},{"question":"- Merge k Sorted Linked Lists You are given an array of k singly linked lists, where each linked list is sorted in ascending order. Your task is to merge all the linked lists into one sorted linked list and return it. # Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Input Criteria * `lists`: A list of k (0 <= k <= 10^4) singly-linked lists, each of size n (0 <= n <= 500), sorted in ascending order. * Each ListNode contains an integer value (not null), and a `next` pointer to the next node in the list or None if it is the last node. # Output Criteria * Return the head of the merged singly linked list. # Constraints * The time complexity should be O(N log k), where N is the total number of nodes in all the linked lists. # Example ```python # Example 1: input = [ ListNode(1).next = ListNode(4).next = ListNode(5), ListNode(1).next = ListNode(3).next = ListNode(4), ListNode(2).next = ListNode(6) ] output = ListNode(1).next = ListNode(1).next = ListNode(2).next = ListNode(3).next = ListNode(4).next = ListNode(4).next = ListNode(5).next = ListNode(6) # Example 2: input = [] output = None # Example 3: input = [None, ListNode(1)] output = ListNode(1) ``` # Additional Notes * Consider edge cases such as all linked lists being empty or having lists of varying sizes. * You can assume that ListNode class and other necessary data structures will be provided. # Implementation Tips * Utilize a priority queue or binary heap to efficiently obtain the smallest current node among the heads of the linked lists. * Ensure memory-efficient handling to avoid unnecessarily increasing the heap size beyond k.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for i, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, i, lst)) dummy = ListNode(0) curr = dummy while min_heap: val, i, node = heapq.heappop(min_heap) curr.next = ListNode(val) curr = curr.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"Question: Message Decoding Ways You are given an encoded message containing digits. Each digit maps to a letter (\'A\' corresponds to 1, \'B\' to 2, ..., \'Z\' to 26). Your task is to implement a function to compute the total number of ways to decode this message. # Description An encoded message is represented as a string of digits. Your function should find out how many different ways this string can be decoded into letters. # Example For example, given the encoded message \\"12\\", there are two ways to decode it: * \\"12\\" can be decoded to \\"AB\\" (1 2) * \\"12\\" can be decoded to \\"L\\" (12) Thus, the function should return 2. # Input * The input is a string `s` which consists of digits only. # Output * The output should be an integer representing the total number of ways to decode the given message. # Constraints * `1 <= len(s) <= 100` * `s` contains only digits and may not start with \'0\'. # Function Signature ```python def count_decoding_ways(s: str) -> int: pass ``` # Requirements 1. Handle edge cases where the message starts with \'0\' or contains invalid combinations. 2. Ensure the solution is efficient with respect to time and space complexity.","solution":"def count_decoding_ways(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# **Coding Question: Flatten Nested Arrays** You are given a nested array, which means it may contain other arrays as its elements. Your task is to write a function that converts this nested array into a single, flat array. You also need to handle this efficiently to avoid issues with deeply nested structures. Function Signature ```python def flatten_nested_array(nested_array: list) -> list: pass ``` Input * A single input parameter: * `nested_array` (List): A list that may contain other nested lists or non-iterable elements (strings are considered non-iterable for this problem). Output * Returns a single, flat list containing all elements from the original nested array. Constraints * No constraints on the depth of nesting. The array can be arbitrarily deeply nested. * The input will not contain any cyclic references within its elements. # **Examples** ```python # Example 1 input_arr = [1, [2, [3, [4]], 5]] assert flatten_nested_array(input_arr) == [1, 2, 3, 4, 5] # Example 2 input_arr = [\\"a\\", [\\"b\\", [\\"c\\", [\\"d\\"]]], \\"e\\"] assert flatten_nested_array(input_arr) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] # Example 3 input_arr = [[], [[]], [[[]]], [[], [1, 2, [3, 4]], 5]] assert flatten_nested_array(input_arr) == [1, 2, 3, 4, 5] ``` # **Requirements** 1. Consider both list-based and iterator-based solutions. 2. Ensure that your function handles deeply nested arrays without hitting recursion depth limits. 3. Optimize the function to handle large datasets efficiently without using excessive memory.","solution":"def flatten_nested_array(nested_array): Flattens a nested array into a single flat list. Args: nested_array (list): A list that may contain other nested lists or non-iterable elements. Returns: list: A single, flat list containing all elements from the original nested array. def flatten(element): if isinstance(element, list): for item in element: yield from flatten(item) else: yield element return list(flatten(nested_array))"},{"question":"# Question: Pythagorean Triangle Solver Problem Statement You are tasked with writing a function to determine the length of an unknown side of a right-angled triangle. The lengths of the two known sides will be provided as inputs. If a side\'s length is unknown, the input will be `None`. Function Signature ```python def pythagorean_solver(opposite: Union[float, None], adjacent: Union[float, None], hypotenuse: Union[float, None]) -> str: Returns the length of the unknown side of a right-angled triangle, given the lengths of the other two sides. :param opposite: float or None, the length of the side opposite to the right angle. :param adjacent: float or None, the length of the side adjacent to the right angle. :param hypotenuse: float or None, the length of the hypotenuse. :return: str, message with the length of the unknown side or an error message if input invalid. Input Three inputs, one of which will be `None` to indicate the unknown side: - opposite: float (if known) or None (if unknown) - adjacent: float (if known) or None (if unknown) - hypotenuse: float (if known) or None (if unknown) Output A string indicating the length of the unknown side. For example: - \\"Opposite = 3.0\\" - \\"Adjacent = 4.0\\" - \\"Hypotenuse = 5.0\\" Constraints - Only one side will be `None` at a time. - All known sides will be positive floating-point numbers. - If there are invalid inputs (e.g., more than one `None` value, side lengths not forming a right triangle), return an error message. Examples ```python assert pythagorean_solver(None, 4.0, 5.0) == \\"Opposite = 3.0\\" assert pythagorean_solver(3.0, None, 5.0) == \\"Adjacent = 4.0\\" assert pythagorean_solver(3.0, 4.0, None) == \\"Hypotenuse = 5.0\\" assert pythagorean_solver(3.0, 4.0, 5.0) == \\"All sides are known!\\" assert pythagorean_solver(None, None, 5.0) == \\"Error: Invalid inputs.\\" ```","solution":"from typing import Union def pythagorean_solver(opposite: Union[float, None], adjacent: Union[float, None], hypotenuse: Union[float, None]) -> str: Returns the length of the unknown side of a right-angled triangle, given the lengths of the other two sides. if [opposite, adjacent, hypotenuse].count(None) != 1: return \\"Error: Invalid inputs.\\" if opposite is None: if adjacent is not None and hypotenuse is not None: if hypotenuse > adjacent: opposite = (hypotenuse ** 2 - adjacent ** 2) ** 0.5 return f\\"Opposite = {opposite:.1f}\\" else: return \\"Error: Invalid inputs.\\" else: return \\"Error: Invalid inputs.\\" if adjacent is None: if opposite is not None and hypotenuse is not None: if hypotenuse > opposite: adjacent = (hypotenuse ** 2 - opposite ** 2) ** 0.5 return f\\"Adjacent = {adjacent:.1f}\\" else: return \\"Error: Invalid inputs.\\" else: return \\"Error: Invalid inputs.\\" if hypotenuse is None: if opposite is not None and adjacent is not None: hypotenuse = (opposite ** 2 + adjacent ** 2) ** 0.5 return f\\"Hypotenuse = {hypotenuse:.1f}\\" else: return \\"Error: Invalid inputs.\\" return \\"Error: Invalid inputs.\\""},{"question":"# Move Zeroes to End - In-Place Algorithm Objective Implement an in-place algorithm that takes an array and moves all the zero elements to the end, while preserving the order of non-zero elements. Description You need to write a function `move_zeros` that accepts a list `arr` consisting of elements which can be integers, booleans, strings, etc. Your task is to modify the array in-place such that all the zeroes are moved to the end, preserving the order of other elements. Note that `False` should not be considered as zero. Function Signature ```python def move_zeros(arr: list) -> None: pass ``` Input Format - `arr`: A list of elements (integers, booleans, strings, etc.) Output Format - The function should modify the given list `arr` in-place and should not return anything. Constraints - The array can contain a maximum of 10^6 elements. - The elements in the array can be of mixed data types, but only integer `0` should be moved to the end. Examples ```python arr = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros(arr) print(arr) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] arr = [0, \\"hello\\", 0, 0, False, 55] move_zeros(arr) print(arr) # Output: [\'hello\', False, 55, 0, 0, 0] arr = [] move_zeros(arr) print(arr) # Output: [] ``` Note - The function modifies the list in place, hence no return. - Ensure you do not use extra space proportional to input size (i.e., aim for in-place solution).","solution":"def move_zeros(arr: list) -> None: Modify the list in-place to move all zeros to the end while preserving the order of other elements. non_zero_index = 0 # Iterate through each element in the array for i in range(len(arr)): if arr[i] != 0 or type(arr[i]) in [bool, str]: # Type check to ensure we don\'t move False arr[non_zero_index] = arr[i] if non_zero_index != i: # Optional check for efficiency arr[i] = 0 non_zero_index += 1 # From this point, all elements from non_zero_index to end of array should be 0 for i in range(non_zero_index, len(arr)): arr[i] = 0"},{"question":"# Question: Implement and Extend Radix Sort with Specific Edge Cases Context: You are required to implement a sorting function to sort a list of positive integers using the radix sort algorithm detailed above. Additionally, you should extend the radix sort to handle edge cases like sorting arrays with mixed positive and negative integers effectively. Requirements: 1. **Function Name**: `enhanced_radix_sort` 2. **Input/Output**: * **Input**: A list of integers `arr`. * **Output**: A sorted list of integers `sorted_arr`. 3. The function should handle: - Negative integers by sorting them in ascending order. - Positive integers and zero correctly. - Ensuring the overall sort is in ascending order. Constraints: - The list `arr` may contain up to (10^5) integers. - The integers in `arr` can range from (-10^9) to (10^9). Example: ```python assert enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert enhanced_radix_sort([-5, -10, 0, -3, 8, 5, -1]) == [-10, -5, -3, -1, 0, 5, 8] assert enhanced_radix_sort([]) == [] assert enhanced_radix_sort([-1, -5, -3, -4, -2]) == [-5, -4, -3, -2, -1] ``` Implement the function `enhanced_radix_sort`: ```python def enhanced_radix_sort(arr): # Your code here pass ```","solution":"def radix_sort(arr): Helper function to perform radix sort on a list of non-negative integers. max_element = max(arr) exp = 1 while max_element // exp > 0: counting_sort(arr, exp) exp *= 10 def counting_sort(arr, exp): Helper function to perform counting sort based on exponent value `exp`. n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] def enhanced_radix_sort(arr): Function to sort a list of integers using an enhanced radix sort that handles both positive and negative integers. if not arr: return [] negative_numbers = [-num for num in arr if num < 0] non_negative_numbers = [num for num in arr if num >= 0] if negative_numbers: radix_sort(negative_numbers) negative_numbers = [-num for num in reversed(negative_numbers)] if non_negative_numbers: radix_sort(non_negative_numbers) return negative_numbers + non_negative_numbers"},{"question":"# Implementing a Scalable Hash Table **Context**: You are a software developer working on a high-performance application that manages a dynamic dataset. Your task is to design an enhanced Hash Table that supports dynamic resizing and includes performance optimizations. **Objective**: Implement a `ScalableHashTable` class that builds upon the provided Hash Table infrastructure. Your version should automatically resize itself when the load factor exceeds a certain threshold and handle edge cases effectively. **Function Implementations**: 1. `__init__(self, initial_size=8)`: Initialize the hash table with a given size or with a default size. 2. `put(self, key, value)`: Insert the key-value pair into the table. If the table’s load factor exceeds 0.7 after the insertion, resize the table to double its current size. 3. `get(self, key)`: Retrieve the value associated with the given key. Return `None` if the key is absent. 4. `del_(self, key)`: Delete the key-value pair associated with the given key. 5. `resize(self, new_size)`: Resize the hash table to the new specified size and rehash all existing keys. **Class Template**: ```python class ScalableHashTable(object): _empty = object() _deleted = object() def __init__(self, initial_size=8): # Initialize the hash table with the given size pass def put(self, key, value): # Implementation to insert key-value pair and handle resizing pass def get(self, key): # Retrieve the value associated with the key pass def del_(self, key): # Delete the key-value pair associated with the given key pass def resize(self, new_size): # Double the current size while rehashing all keys pass ``` **Constraints**: - Keys will be positive integers. - Values can be any data type. - No duplicate keys; treat any `put` operation with an existing key as an update. **Performance Requirements**: - Ensure that resizing operations are efficiently handled. - Keep the average complexity close to O(1) for basic operations (insertion, lookup, deletion) despite dynamic resizing. **Hints**: - Consider using the provided hashing and rehashing logic. - Account for edge cases, such as when the table is full or nearly full and many continuous insertions trigger multiple resizes. **Example**: ```python htable = ScalableHashTable(initial_size=4) htable.put(1, \'A\') htable.put(2, \'B\') htable.put(3, \'C\') htable.put(4, \'D\') # This should trigger resize print(htable.get(1)) # Outputs: \'A\' htable.put(5, \'E\') print(htable.get(5)) # Outputs: \'E\' htable.del_(3) print(htable.get(3)) # Outputs: None ```","solution":"class ScalableHashTable(object): _empty = object() _deleted = object() def __init__(self, initial_size=8): self.table = [self._empty] * initial_size self.size = 0 def _hash(self, key): return key % len(self.table) def _probe(self, hash_value, key): index = hash_value first_deleted_index = None while self.table[index] is not self._empty: if self.table[index] is self._deleted: if first_deleted_index is None: first_deleted_index = index elif self.table[index][0] == key: return index index = (index + 1) % len(self.table) return first_deleted_index if first_deleted_index is not None else index def put(self, key, value): if self.size / len(self.table) > 0.7: self.resize(len(self.table) * 2) hash_value = self._hash(key) index = self._probe(hash_value, key) if self.table[index] in (self._empty, self._deleted): self.size += 1 self.table[index] = (key, value) def get(self, key): hash_value = self._hash(key) index = self._probe(hash_value, key) if self.table[index] in (self._empty, self._deleted) or self.table[index][0] != key: return None return self.table[index][1] def del_(self, key): hash_value = self._hash(key) index = self._probe(hash_value, key) if self.table[index] not in (self._empty, self._deleted) and self.table[index][0] == key: self.table[index] = self._deleted self.size -= 1 def resize(self, new_size): old_table = self.table self.table = [self._empty] * new_size self.size = 0 for entry in old_table: if entry not in (self._empty, self._deleted): self.put(entry[0], entry[1])"},{"question":"# Scenario You are developing a search feature for a small inventory management system. The inventory list is frequently updated and contains various items stored in no specific order. To keep the implementation simple, you\'d like to use a linear search algorithm to find items by their names. # Task Implement a Python function `find_item_index(inventory, item_name)` that will search for an item by name in the given inventory list and return the index of the item. If the item does not exist, the function should return -1. # Function Signature ```python def find_item_index(inventory: list, item_name: str) -> int: pass ``` # Input - `inventory`: A list of strings where each string represents the name of an item. - It can be of any length (`0 ≤ len(inventory) ≤ 10^4`). - `item_name`: A string representing the name of the item to find. # Output - An integer representing the index of the item in the inventory. - Return -1 if the item is not found. # Constraints - Do not use any built-in functions like `index` for searching. - The inventory list can contain duplicate entries, but the function should return the index of the first occurrence. # Examples ```python # Example 1 inventory = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] item_name = \\"cherry\\" print(find_item_index(inventory, item_name)) # Output: 2 # Example 2 inventory = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] item_name = \\"fig\\" print(find_item_index(inventory, item_name)) # Output: -1 # Example 3 inventory = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"cherry\\", \\"elderberry\\"] item_name = \\"cherry\\" print(find_item_index(inventory, item_name)) # Output: 2 ``` # Points to Consider - Ensure that the function handles an empty inventory list correctly. - Consider the performance impact of using a linear search on large inventories. - Pay attention to edge cases such as when the item is not present in the inventory.","solution":"def find_item_index(inventory, item_name): Searches for an item by name in the given inventory list and returns the index of the item. Returns -1 if the item does not exist. for index, item in enumerate(inventory): if item == item_name: return index return -1"},{"question":"# Instructions You are given a list of integers and a number N. Write a function `delete_nth` that returns a new list containing the elements of the original list but makes sure every number appears at most N times without changing the order. # Function Signature ```python def delete_nth(array: list[int], n: int) -> list[int]: ``` # Parameters * `array` (list of int): The list of integers to be filtered. * `n` (int): The maximum number of occurrences for each integer. # Returns * `list[int]`: A new list with elements from the original list occurring at most N times. # Constraints * The input list can have up to 10^6 elements. * Values in the list are integers within the range [-10^6, 10^6]. * N is a non-negative integer. If N is zero, return an empty list. # Example ```python array = [1, 2, 3, 1, 2, 1, 2, 3] n = 2 delete_nth(array, n) # Output: [1, 2, 3, 1, 2, 3] array = [20, 37, 20, 21] n = 1 delete_nth(array, n) # Output: [20, 37, 21] array = [5] n = 5 delete_nth(array, n) # Output: [5] array = [] n = 3 delete_nth(array, n) # Output: [] ``` # Notes * Ensure your implementation is efficient in terms of time and space complexity. * Take into account the edge cases mentioned in the constraints.","solution":"def delete_nth(array: list[int], n: int) -> list[int]: Returns a new list containing elements of the original list but each number appears at most N times without changing the order. from collections import defaultdict if n == 0: return [] result = [] counts = defaultdict(int) for number in array: if counts[number] < n: result.append(number) counts[number] += 1 return result"},{"question":"# Sorting Using a Specific Heap Objective Implement a sorting algorithm based on heaps that sorts an array in *descending* order. You are to create a hybrid heap sort that combines max heap and min heap mechanisms. Specifically, you will first use a max heap to push the highest elements to the end of the array. Then, you\'ll use a min heap starting from the end to place the smallest elements in their final positions. Function Signature ```python def hybrid_heap_sort(arr): Sorts the given array in descending order using a combination of max heap and min heap mechanisms. The function modifies the array in-place and returns the sorted array. Parameters: arr (List[int]): The array of integers to be sorted. Returns: List[int]: The sorted array in descending order. pass ``` Input and Output Formats # Input * A list of integers with a length between 1 and 10^3. Each integer will be in the range of -10^6 to 10^6. # Output * A list of integers sorted in descending order. Constraints and Limitations * You must modifiy the array in-place. * Do not use any built-in sort functions. Example # Input ```python arr = [3, 10, -2, 8, -1, 6] hybrid_heap_sort(arr) ``` # Output ```python [-1, -2, 3, 6, 8, 10] ``` Explanation 1. Build a max heap using the given array, then perform heap-sort by extracting the largest element and moving it to the end. 2. Use a min heap with the remaining part of the array to correctly place smaller elements in their final positions. Ensure your function handles the edge cases mentioned in the analysis.","solution":"def hybrid_heap_sort(arr): Sorts the given array in descending order using a combination of max heap and min heap mechanisms. The function modifies the array in-place and returns the sorted array. Parameters: arr (list[int]): The array of integers to be sorted. Returns: list[int]: The sorted array in descending order. def max_heapify(arr, n, i): # Function to maintain the max heap property largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def min_heapify(arr, n, i): # Function to maintain the min heap property smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] min_heapify(arr, n, smallest) n = len(arr) # Build a max heap for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) # Perform heap sort by moving max elements to the end for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0) # Now, we start placing elements using min heap for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i) # Reversing the array to get it in descending order as required arr.reverse() return arr"},{"question":"Given the `TreeNode` class definition for a binary tree, implement the class `BinarySearchTree`, which supports the following operations: 1. **Insert(value)**: Insert a value into the BST. 2. **Search(value)**: Check if a value exists in the BST. 3. **Delete(value)**: Delete a value from the BST. # Input and Output Format 1. **Insert(value)**: - Input: Integer `value` - Output: None - Effect: A new node with the given value is inserted into the tree following BST properties. 2. **Search(value)**: - Input: Integer `value` - Output: Boolean (`True` if the value exists in the BST, `False` otherwise) 3. **Delete(value)**: - Input: Integer `value` - Output: Boolean (`True` if the value was successfully deleted, `False` if the value was not found in the tree) Your implementation should ensure that the tree maintains its BST properties through all operations. # Constraints 1. All values inserted will be distinct. 2. Values will be integers within the range -10^9 to 10^9. 3. For the delete operation, if the tree is empty or the value does not exist, return `False`. # Implementation ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): # Implement the insert operation pass def search(self, value): # Implement the search operation pass def delete(self, value): # Implement the delete operation pass ``` # Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(4)) # Output: False print(bst.delete(3)) # Output: True print(bst.search(3)) # Output: False print(bst.delete(3)) # Output: False ```","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.val: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def search(self, value): return self._search_recursive(self.root, value) def _search_recursive(self, node, value): if node is None: return False if node.val == value: return True elif value < node.val: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value): self.root, deleted = self._delete_recursive(self.root, value) return deleted def _delete_recursive(self, node, value): if node is None: return node, False deleted = False if value == node.val: deleted = True if node.left and node.right: min_larger_node = self._get_min(node.right) node.val = min_larger_node.val node.right, _ = self._delete_recursive(node.right, min_larger_node.val) elif node.left: node = node.left elif node.right: node = node.right else: node = None elif value < node.val: node.left, deleted = self._delete_recursive(node.left, value) else: node.right, deleted = self._delete_recursive(node.right, value) return node, deleted def _get_min(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Binary Search Tree Balancer You are given an implementation of a Binary Search Tree (BST) with basic operations including insertion, searching, and different types of traversal. Your task is to enhance the BST to become a self-balancing tree. Specifically, you need to implement an AVL Tree, which is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. # Requirements 1. **Insertion**: Modify the insert function to ensure the tree remains balanced after every insertion by performing necessary rotations. 2. **Balancing**: Implement functions for single right rotation, single left rotation, double right-left rotation, and double left-right rotation. 3. **Height Maintenance**: Maintain the height of each node after every insertion to help with rebalancing. # Input and Output Format * The AVL tree will use integer values for simplicity. * The input will be a list of integers representing the elements to insert in the tree. * The output should be the inorder traversal of the AVL tree after all insert operations, displayed as a space-separated string. # Constraints 1. All input values are unique positive integers. 2. The maximum number of elements to be inserted is 1000. # Example Input ```plaintext [30, 20, 40, 10, 25, 50, 5] ``` Output ```plaintext 5 10 20 25 30 40 50 ``` # Implementation ```python class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return Node(key) elif key < root.data: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.data: return self.rightRotate(root) if balance < -1 and key > root.right.data: return self.leftRotate(root) if balance > 1 and key > root.left.data: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.data: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def inorderTraversal(self, root): res = [] self._inorderTraversal(root, res) return res def _inorderTraversal(self, root, res): if root: self._inorderTraversal(root.left, res) res.append(root.data) self._inorderTraversal(root.right, res) # Function to insert elements into AVL tree and print the inorder traversal def avl_tree_insertions(elements): avl_tree = AVLTree() root = None for element in elements: root = avl_tree.insert(root, element) return \\" \\".join(map(str, avl_tree.inorderTraversal(root))) # Example use case elements = [int(x) for x in input().split()] print(avl_tree_insertions(elements)) ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return Node(key) elif key < root.data: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.data: return self.rightRotate(root) if balance < -1 and key > root.right.data: return self.leftRotate(root) if balance > 1 and key > root.left.data: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.data: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def inorderTraversal(self, root): res = [] self._inorderTraversal(root, res) return res def _inorderTraversal(self, root, res): if root: self._inorderTraversal(root.left, res) res.append(root.data) self._inorderTraversal(root.right, res) # Function to insert elements into AVL tree and print the inorder traversal def avl_tree_insertions(elements): avl_tree = AVLTree() root = None for element in elements: root = avl_tree.insert(root, element) return \\" \\".join(map(str, avl_tree.inorderTraversal(root)))"},{"question":"You are asked to implement a function that takes a list of integers and an integer ( N ). The function should return a new list that includes each element from the original list at most ( N ) times, without reordering any elements. Function Signature: ```python def delete_nth(array: List[int], n: int) -> List[int]: ``` # Inputs 1. `array`: A list of integers [ ( -10^6 leq array[i] leq 10^6 ) ]. 2. `n`: An integer ( ( 0 leq n leq 10^6 ) ). # Outputs - A list of integers containing each number from the original `array` at most ( N ) times. # Example ```python assert delete_nth([1,2,3,1,2,1,2,3], 2) == [1,2,3,1,2,3] assert delete_nth([1,2,3,1,2,1,2,3], 1) == [1,2,3] assert delete_nth([], 2) == [] assert delete_nth([4,4,4,4], 2) == [4, 4] assert delete_nth([1,1,1,1], 0) == [] ``` # Constraints - Ensure to handle edge cases such as empty input lists or maximally repeated elements efficiently. - Your solution should aim for an ( O(n) ) time complexity for better performance. # Notes - **Maintaining Order**: The order of elements in the resultant list must be the same as they appear in the input array. - **No mutations** on the original list should be performed.","solution":"from typing import List def delete_nth(array: List[int], n: int) -> List[int]: Returns a list where each element appears at most n times. result = [] counts = {} for num in array: if counts.get(num, 0) < n: result.append(num) counts[num] = counts.get(num, 0) + 1 return result"},{"question":"# Scenario You are tasked with developing a function to reverse the words in sentences that may contain extra spaces. The goal is to ensure the function handles various edge cases, such as multiple spaces, leading/trailing spaces, and correctly transforms sentences. # Task Write a function `reverse_sentence(sentence: str) -> str` that takes a string `sentence` and returns the string with the words reversed. Ensure the function: - Trims any leading or trailing spaces. - Handles multiple spaces between words effectively. - Maintains a single space between words in the final string. # Input A single string `sentence` which may include leading, trailing, or multiple spaces. # Output A single string with words reversed and properly formatted, with a single space between words. # Constraints - The length of `sentence` is in the range [0, 1000]. - The string may contain English letters and spaces only. # Examples Example 1 Input: `\\" I love coding \\"` Output: `\\"coding love I\\"` Example 2 Input: `\\"Hello\\"` Output: `\\"Hello\\"` Example 3 Input: `\\" a b\\"` Output: `\\"b a\\"` Example 4 Input: `\\"\\"` Output: `\\"\\"` # Notes Your implementation should primarily use in-place operations or efficient use of space. You are expected to handle edge cases such as empty strings, multiple intermediate spaces, and leading/trailing spaces efficiently.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the words in the given sentence. Args: sentence (str): The sentence to reverse. Returns: str: The sentence with words reversed and properly formatted. # Split the sentence by spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list with a single space reversed_sentence = \\" \\".join(reversed_words) return reversed_sentence"},{"question":"Background Imagine you are building a search engine for a text editor, and you need to design a data structure that allows users to add words and search for words using literal matches as well as wildcard matches. In this scenario, the wildcard character `.` can represent any letter. Your task is to implement the `WordDictionary` class where you will manage the insertion and search operations, leveraging a data structure suitable for quick prefix-based and wildcard-based searches. Description Implement the `WordDictionary` class with the following methods: - `add_word(word: str) -> None`: Adds a word into the WordDictionary. - `search(word: str) -> bool`: Searches for a word in the WordDictionary. The word can include wildcard characters represented by `.`. Example ```python wordDict = WordDictionary() wordDict.add_word(\\"bad\\") wordDict.add_word(\\"dad\\") wordDict.add_word(\\"mad\\") print(wordDict.search(\\"pad\\")) # Output: False print(wordDict.search(\\"bad\\")) # Output: True print(wordDict.search(\\".ad\\")) # Output: True print(wordDict.search(\\"b..\\")) # Output: True ``` Constraints - Words consist of lowercase alphabets only. - Each input word is at most 500 characters long. - At most 3 * 10^4 method calls will be made to `add_word` and `search`. Solution Requirements 1. Ensure that adding a word has an average time complexity of O(L) and searching a word also has an average time complexity of O(L), where L is the length of the word. 2. Handle edge cases such as empty string inputs gracefully. 3. Optimize for space efficiency wherever possible, without compromising on time complexity.","solution":"class WordDictionary: def __init__(self): Initialize the WordDictionary data structure. self.trie = {} def add_word(self, word: str) -> None: Adds a word into the WordDictionary. node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: Searches for a word in the WordDictionary. The word can include wildcard characters represented by `.`. return self._search_in_node(word, 0, self.trie) def _search_in_node(self, word: str, index: int, node: dict) -> bool: if index == len(word): return \'#\' in node char = word[index] if char == \'.\': for key in node: if key != \'#\' and self._search_in_node(word, index + 1, node[key]): return True elif char in node: return self._search_in_node(word, index + 1, node[char]) return False"},{"question":"Scenario You are working as a software engineer at a logistics company responsible for ensuring efficient sorting of tracking numbers for parcels. Due to the high volume of parcels each day, it\'s crucial to have an optimal sorting algorithm in place to organize these tracking numbers quickly for dispatch. As part of the team, you are expected to implement a solution that can handle sorting of these tracking numbers efficiently. Problem Statement Implement the `radix_sort` function to sort an array of non-negative integers representing parcel tracking numbers. Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of non-negative integers using the radix sorting algorithm. Parameters: arr (List[int]): A list of non-negative integers to be sorted. simulation (bool): If True, prints the array after each sorting pass to simulate the sorting process. Returns: List[int]: Sorted list of non-negative integers. ``` Input * `arr`: A list of non-negative integers, where `0 <= len(arr) <= 10^6` and `0 <= arr[i] <= 10^9`. * `simulation`: A boolean flag (default is `False`). If `True`, the function should print the array after each significant digit sorting pass. Output * A list of sorted non-negative integers. Constraints * The time complexity of the solution should be O(nk + n), where n is the number of elements in the list and k is the digit length. * The space complexity should be O(n + k). Examples ```python # Example 1 print(radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Expected output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 print(radix_sort([3, 1, 2, 8, 5, 4])) # Expected output: [1, 2, 3, 4, 5, 8] ``` Note If the `simulation` parameter is set to `True`, the function should demonstrate how the array progresses through each significant digit sorting. For example: ```python # For arr = [170, 45, 75, 90, 802, 24, 2, 66], the output might be: iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : sorted array ``` Ensure the function handles edge cases appropriately, such as empty arrays, single-element arrays, and arrays with duplicates.","solution":"def radix_sort(arr, simulation=False): def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[(index) % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[(index) % 10] - 1] = arr[i] count[(index) % 10] -= 1 i -= 1 for i in range(n): arr[i] = output[i] max_num = max(arr) if arr else 0 exp = 1 iteration = 0 while max_num // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"You are given two binary trees `T1` and `T2`. Your task is to determine if `T2` is a subtree of `T1`. A subtree of `T1` is a tree consisting of a node in `T1` and all of its descendants in `T1`. # Function Signature ```python def is_subtree(big: Optional[TreeNode], small: Optional[TreeNode]) -> bool: ``` # Input * `big` (TreeNode): The root of the large tree `T1`. * `small` (TreeNode): The root of the smaller tree `T2`. # Output * `bool`: Return `True` if `T2` is a subtree of `T1`, otherwise return `False`. # Constraints * Both trees can be null, root nodes can have the same value. * `big` and `small` are binary trees with integer values. * Consider scenarios where one tree is significantly larger than the other. # Example Example 1: ```plaintext Input: big = [3, 4, 5, 1, 2] small = [4, 1, 2] Output: True ``` Example 2: ```plaintext Input: big = [3, 4, 5, 1, 2, None, None, None, None, 0] small = [4, 1, 2] Output: False ``` # Follow-up: * Discuss how you would handle the situation if `T2` is much smaller than `T1`. # Approach 1. Implement a BFS to traverse the large tree `T1`. 2. When a node in `T1` matches the root of `T2`, start a recursive comparison of all its descendants. 3. Ensure the comparison handles null nodes, and correctly identifies all matching nodes and their structures.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True # An empty tree is always a subtree if not big: return False # Non-empty small cannot be a subtree of an empty big tree if is_same_tree(big, small): return True # Recursively check left and right subtrees return is_subtree(big.left, small) or is_subtree(big.right, small) def is_same_tree(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False if t1.val != t2.val: return False return is_same_tree(t1.left, t2.left) and is_same_tree(t1.right, t2.right)"},{"question":"# Question: Enhance and Analyze Bogo Sort Context You are asked to implement and enhance a sorting algorithm known as Bogo Sort. Given its inefficiency, your task will also involve analyzing the performance under various conditions to understand and demonstrate its impracticality for real-world sorting tasks. Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Requirements 1. **Input**: * `arr`: A list of integers that needs to be sorted. * `simulation`: A boolean flag indicating whether to print each iteration of the algorithm. Defaults to `False`. 2. **Output**: * A list of integers sorted in ascending order. 3. **Constraints**: * The list can contain up to 10 elements. * Each element in the list is an integer between -1000 and 1000 inclusive. 4. **Performance Requirements**: * The solution should include mechanisms to track and print the number of iterations and the total number of shuffles performed until the array is sorted. * Even if `simulation` is `False`, return the number of iterations and shuffles as additional outputs in the form of a tuple. Detailed Specifications 1. Implement the bogo_sort function using the algorithm principles provided. 2. If `simulation` is set to `True`, print the state of the array after each shuffle iteration. 3. Always return the sorted array along with the number of iterations and shuffles required to achieve the sorted state. 4. Extend the functionality to capture and return both the number of iterations and the total number of shuffles performed. 5. Demonstrate the inefficiency of Bogo Sort with a provided test case in your solution. Example Usage ```python sorted_array, iterations, shuffles = bogo_sort([3, 2, 1], simulation=True) ``` Example Output ``` iteration 0: 3 2 1 iteration 1: 2 3 1 iteration 2: 3 1 2 ... iteration 7: 1 2 3 ([1, 2, 3], 7, 10) ``` This would mean 7 iterations were required and 10 shuffles were performed to sort the array `[3, 2, 1]` into `[1, 2, 3]`. Additional Points * Include comments in your code to explain what each section does. * Ensure your code handles edge cases (e.g., empty arrays, arrays with a single element).","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int, int]: Sort the array using Bogo Sort algorithm. Parameters: arr (List[int]): The array to sort. simulation (bool): If True, prints the array after each shuffle. Defaults to False. Returns: Tuple[List[int], int, int]: A tuple containing the sorted array, number of iterations, and shuffles performed. arr = arr[:] # Create a copy of the array to avoid modifying the original iterations = 0 shuffles = 0 while not is_sorted(arr): iterations += 1 if simulation: print(f\\"iteration {iterations}: {arr}\\") random.shuffle(arr) shuffles += 1 return arr, iterations, shuffles"},{"question":"Context In a system where data records can be cyclically shifted, quickly finding the smallest record might be crucial for certain tasks like identifying the earliest timestamp, the lowest value, etc. These cyclic shifts act as rotations on a sorted list of values. Problem Statement Given an array `array` that is sorted in ascending order and then rotated at some unknown pivot point, implement a function `find_min_rotate(array: List[int]) -> int` that finds and returns the minimum element of the array. The algorithm must have a time complexity of O(log N). You can assume that there are no duplicate elements in the array. Requirements: 1. Your solution must be implemented in Python. 2. The function should take a single parameter, `array`, which is a list of integers. 3. Return the smallest element in the array. Input * A list of integers `array` with no duplicates, sorted in ascending order and then rotated at some unknown pivot. Output * An integer representing the minimum element of the array. Constraints * 2 ≤ len(array) ≤ 10^4. * -10^4 ≤ array[i] ≤ 10^4. Example: ```python array = [4, 5, 6, 7, 0, 1, 2] print(find_min_rotate(array)) # Output: 0 array = [3, 4, 5, 1, 2] print(find_min_rotate(array)) # Output: 1 ``` Guidelines: 1. Implement an iterative approach in `find_min_rotate`. 2. Ensure the implementation handles the specified constraints effectively. 3. Consider and address edge cases, such as very small arrays and arrays that are not rotated.","solution":"from typing import List def find_min_rotate(array: List[int]) -> int: Given a rotated sorted array, this function finds and returns the minimum element. Uses binary search to achieve O(log N) time complexity. left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 if array[mid] > array[right]: # The minimum is in the right part left = mid + 1 else: # The minimum is in the left part including mid right = mid return array[left]"},{"question":"Scenario You are working on an application for an online education platform. One of the requirements is to implement a feature that checks if a student\'s answer follows a specific pattern. This matching mechanism must ensure that the pattern and the student\'s answer create a bijective relationship. Problem Statement Implement the function `pattern_match(pattern, string)` that takes in a `pattern` and a `string` and returns whether the `string` follows the `pattern`. A pattern is said to follow the string if every unique character in the pattern maps to a unique, non-empty substring in the string such that the constructed string by following the mapping completely matches the original string. Input - `pattern`: A non-empty string with only lowercase letters. - `string`: A non-empty string with only lowercase letters. Output - Return `True` if the `string` follows the `pattern`, otherwise return `False`. Constraints - Both pattern and string contain only lowercase English letters. Examples ```python pattern_match(\\"abab\\", \\"redblueredblue\\") # should return True pattern_match(\\"aaaa\\", \\"asdasdasdasd\\") # should return True pattern_match(\\"aabb\\", \\"xyzabcxzyabc\\") # should return False ``` Requirements * Your function should be optimized to handle average cases efficiently. * Handle edge cases like empty patterns and strings gracefully. * Pay attention to the constraints and provide thorough testing to ensure correctness.","solution":"def pattern_match(pattern, string): def backtrack(string_index, pattern_index, mapping, reverse_mapping): if pattern_index == len(pattern) and string_index == len(string): return True if pattern_index == len(pattern) or string_index == len(string): return False pattern_char = pattern[pattern_index] for i in range(string_index, len(string)): substring = string[string_index:i + 1] if pattern_char not in mapping and substring not in reverse_mapping: mapping[pattern_char] = substring reverse_mapping[substring] = pattern_char if backtrack(i + 1, pattern_index + 1, mapping, reverse_mapping): return True del mapping[pattern_char] del reverse_mapping[substring] elif pattern_char in mapping and mapping[pattern_char] == substring: if backtrack(i + 1, pattern_index + 1, mapping, reverse_mapping): return True return False return backtrack(0, 0, {}, {})"},{"question":"# Question: Decode an Encoded String You are given an encoded string following a specific format where substrings are repeated k times, defined by `k[encoded_string]`. Your task is to write a function that decodes this encoded string and returns the decoded result. Function Signature ```python def decode_string(s: str) -> str: Decodes an encoded string where the encoding rule is: k[encoded_string], with k being a positive integer indicating the number of repetitions of the encoded_string. Args: - s (str): The encoded input string (1 ≤ len(s) ≤ 30). Returns: - str: The decoded string. ``` Input - A single string `s` with length in the range (1 ≤ len(s) ≤ 30). Output - Return the decoded string. Constraints - The input string `s` is always valid; i.e., all square brackets are well-formed. - The input string `s` does not contain digits outside of the context of repeat counts. - The number `k` is a positive integer and is always valid. Examples 1. `decode_string(\\"3[a]2[bc]\\")` should return `\\"aaabcbc\\"`. 2. `decode_string(\\"3[a2[c]]\\")` should return `\\"accaccacc\\"`. 3. `decode_string(\\"2[abc]3[cd]ef\\")` should return `\\"abcabccdcdcdef\\"`. Explanation - Example 1: `\\"3[a]2[bc]\\"` decodes as three \\"a\\"s followed by two \\"bc\\"s, resulting in `\\"aaabcbc\\"`. - Example 2: `\\"3[a2[c]]\\"` involves nested decoding, where `\\"a2[c]\\"` results in `\\"acc\\"`, repeated three times. - Example 3: `\\"2[abc]3[cd]ef\\"` results in two `\\"abc\\"` strings followed by three `\\"cd\\"` strings and `\\"ef\\"` concatenated. # Notes - Use a stack for managing characters and repeat counts. - Handle nested encodings by ensuring the stack captures and correctly applies inner repetitions. - Ensure the function is efficient and handles constraints as described.","solution":"def decode_string(s: str) -> str: Decodes an encoded string where the encoding rule is: k[encoded_string], with k being a positive integer indicating the number of repetitions of the encoded_string. Args: - s (str): The encoded input string (1 ≤ len(s) ≤ 30). Returns: - str: The decoded string. stack = [] current_num = 0 current_string = [] for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string, current_num = [], 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string.append(char) return \'\'.join(current_string)"},{"question":"You are implementing a system where you need to encode a list of strings into a single string for transmission over a network and later decode it back into the original list of strings. Objectives 1. Implement the `encode` function that converts a list of strings into a single encoded string. 2. Implement the `decode` function that converts the encoded string back into the original list of strings. Function Signatures ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Input/Output Formats # `encode` * **Input**: A list of strings, `strs`, where each string in the list can contain any characters. * **Output**: A single encoded string. Example: ```python encode([\\"hello\\", \\"world\\"]) -> \\"5:hello5:world\\" encode([\\"abc\\", \\"def\\", \\"\\"]) -> \\"3:abc3:def0:\\" ``` # `decode` * **Input**: A single encoded string. * **Output**: A list of the original strings. Example: ```python decode(\\"5:hello5:world\\") -> [\\"hello\\", \\"world\\"] decode(\\"3:abc3:def0:\\") -> [\\"abc\\", \\"def\\", \\"\\"] ``` # Constraints * Each string in the list can have a length of up to 1000 characters. * The list of strings can contain up to 1000 elements. * The encoded string will be properly formatted and assumed to be valid. # Performance Requirements * The solution should be optimized for linear time complexity, i.e., O(n) for `encode` and O(m) for `decode`, where n is the total number of characters in all input strings and m is the length of the encoded string respectively. * Efficient use of memory is expected. # Instructions - Ensure that the functions handle edge cases appropriately. - Test your implementation with various cases, including empty strings and large inputs.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): List of strings to be encoded. Returns: str: Encoded string encoded_str = \'\' for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s (str): Encoded string Returns: List[str]: Decoded list of strings result = [] i = 0 while i < len(s): colon_index = s.find(\':\', i) # Find the next colon length = int(s[i:colon_index]) # This is the length of the next word start = colon_index + 1 end = start + length result.append(s[start:end]) i = end # Move index i to the end position of the decoded string return result"},{"question":"# Interpolation Search in Practice You are given a sorted array of integers which represent the ages of participants in a data science workshop. Your task is to implement a function that uses the Interpolation Search algorithm to find a specific participant\'s age given as input. This requires understanding the fundamental workings and efficient implementation of the Interpolation Search algorithm. Function Signature ```python def find_age(participants: List[int], age: int) -> int: This function takes a sorted list of participants\' ages and an age to search for, returning the index of the age if found, else returning -1 if the age is not present in the list. :param participants: List[int] - a list of integers representing the sorted ages of participants. :param age: int - The age to search for in the participants list. :returns: int - The index of the age if found, else -1. ``` # Input 1. `participants` - a list of sorted integers, where `1 <= len(participants) <= 10^5`. 2. `age` - an integer representing the age to be searched, where `0 <= age <= 150`. # Output - Return the index of `age` in the `participants` list if found, else return `-1`. # Constraints - All elements in `participants` are sorted in non-decreasing order. - The ages in `participants` are unique. - The search should be performed using the Interpolation Search technique for optimal performance. # Example 1. **Example 1**: - Input: `participants = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], age = 30` - Output: `2` - Explanation: Age `30` is at index `2` in the `participants` list. 2. **Example 2**: - Input: `participants = [5, 10, 15, 20, 25, 30, 35, 40], age = 50` - Output: `-1` - Explanation: Age `50` is not present in the `participants` list, hence return `-1`. 3. **Example 3**: - Input: `participants = [1, 2, 3, 4, 5], age = 1` - Output: `0` - Explanation: Age `1` is at index `0` in the list. # Note The function will be assessed for: - Correctness of the implementation. - The adherence to Interpolation Search\'s approach. - Handling of edge cases and performance on large datasets.","solution":"from typing import List def find_age(participants: List[int], age: int) -> int: Perform interpolation search to find the index of the given age in the sorted participants list. Return -1 if the age is not found. :param participants: List[int] - a list of integers representing the sorted ages of participants. :param age: int - The age to search for in the participants list. :returns: int - The index of the age if found, else -1. low = 0 high = len(participants) - 1 while low <= high and age >= participants[low] and age <= participants[high]: if low == high: if participants[low] == age: return low return -1 # Calculate the position using the interpolation formula pos = low + ((high - low) // (participants[high] - participants[low]) * (age - participants[low])) if participants[pos] == age: return pos if participants[pos] < age: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question Context In a digital circuit design, ensuring two binary strings match requires determining the number of bit changes needed. You are tasked with writing a function to find the minimal number of bit flips required to convert one integer into another. Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Inputs * `a` (int): A non-negative integer. * `b` (int): Another non-negative integer. Output * `int`: The minimal number of bits required to flip to convert integer `a` to integer `b`. Constraints * `0 <= a, b <= 10^9` (both a and b are within the range of a typical 32-bit integer). Example ```python # Example 1 input: a = 29, b = 15 output: 2 # Explanation: 29 in binary is 11101, 15 in binary is 01111. # Bits at positions (from right) 4 and 0 differ. # Example 2 input: a = 10, b = 20 output: 4 # Explanation: 10 in binary is 01010, 20 in binary is 10100. # Bits differ at all 4 positions. ``` Instructions * Write a function `count_flips_to_convert(a, b)` that returns the number of bit flips needed. * Ensure optimal performance for the given constraints. * Consider all edge cases and provide clear, documented code.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips needed to convert integer a to integer b. # XORing a and b will set the bits to 1 where a and b differ xor_result = a ^ b # count the number of 1s in the binary representation of xor_result bit_flips = bin(xor_result).count(\'1\') return bit_flips"},{"question":"# Advanced Graph Pathfinding Question You are given an unweighted, directed graph represented as an adjacency list. Your task is to implement a function that finds the longest path between two nodes. ```python def find_longest_path(graph, start, end): # Implementation here pass ``` # Input Format: - `graph`: Dict[str, List[str]], a dictionary where keys are node identifiers (strings) and values are lists of connected nodes (strings). - `start`: str, the starting node. - `end`: str, the ending node. # Output Format: - Returns a list of nodes representing the longest path from `start` to `end`. If no such path exists, returns `None`. # Constraints: - There may be multiple nodes and edges. - The graph is acyclic. - Nodes are identified by unique string identifiers. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } start = \'A\' end = \'D\' print(find_longest_path(graph, start, end)) # Output: [\'A\', \'C\', \'D\'] ``` # Description: 1. The function should explore each path using depth-first search. 2. It should backtrack to explore all potential paths to ensure the longest path is identified. 3. You must handle edge cases such as no path existing from `start` to `end`. # Performance Requirements: - Your solution should be efficient in terms of both time and space, taking into consideration the constraints provided. # Hints: - This problem resembles finding the shortest path but requires maximizing the path length. - Use backtracking with a depth-first search to explore paths. - Carefully manage visited nodes and path lengths to ensure correctness.","solution":"def find_longest_path(graph, start, end): def dfs(node, end, path, visited): if node == end: return path[:] visited.add(node) longest_path = None for neighbor in graph.get(node, []): if neighbor not in visited: current_path = dfs(neighbor, end, path + [neighbor], visited) if current_path is not None: if longest_path is None or len(current_path) > len(longest_path): longest_path = current_path visited.remove(node) return longest_path return dfs(start, end, [start], set())"},{"question":"You are developing a system that needs to verify if certain numeric strings remain valid when rotated 180 degrees. This property is known as being \\"strobogrammatic\\". Your task is to write a function to determine if a given number is strobogrammatic. # Function Signature ```python def is_strobogrammatic(num: str) -> bool: Determines if a given number (as a string) is strobogrammatic. Parameters: num (str): The number string to check. Returns: bool: True if the number is strobogrammatic, False otherwise. ``` # Input - The function `is_strobogrammatic` accepts a single parameter: - `num` (str): A string representing a numeric value. # Output - The function returns a boolean value: - `True` if the number is strobogrammatic. - `False` otherwise. # Examples ```python assert is_strobogrammatic(\\"69\\") == True assert is_strobogrammatic(\\"88\\") == True assert is_strobogrammatic(\\"818\\") == True assert is_strobogrammatic(\\"12321\\") == False assert is_strobogrammatic(\\"962\\") == False ``` # Constraints - The string `num` will contain only numeric characters. - The length of `num` will be at least 1 and at most 10^4. # Example Explanations * `\\"69\\"` is strobogrammatic because rotating it 180 degrees still looks like \\"69\\". * `\\"88\\"` is strobogrammatic because rotating it 180 degrees still looks like \\"88\\". * `\\"818\\"` is strobogrammatic because rotating it 180 degrees still looks like \\"818\\". * `\\"12321\\"` is not strobogrammatic because rotating \\"1\\" to the end makes it non-matching with \\"2\\". * `\\"962\\"` is not strobogrammatic because \\"2\\" and \\"6\\" are not strobogrammatic pairs. # Performance Requirements - Your solution should provide an answer within linear time complexity, O(n), where n is the length of the input string. - Space complexity should be maintained at O(1), not including input/output parameters. Implement the function considering the provided constraints and examples.","solution":"def is_strobogrammatic(num: str) -> bool: Determines if a given number (as a string) is strobogrammatic. Parameters: num (str): The number string to check. Returns: bool: True if the number is strobogrammatic, False otherwise. # Mapping of strobogrammatic pairs pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} # Two pointers approach to check if the string is strobogrammatic left, right = 0, len(num) - 1 while left <= right: if num[left] not in pairs or num[right] not in pairs: return False if pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"You are tasked with enhancing the provided `MovingAverage` class by incorporating an optimization for improved performance. Specifically, you are to implement an alternative approach that maintains a running sum to eliminate the necessity of summing up the entire queue upon each call to the `next` method. # Function Implementation You need to: 1. Initialize an instance of the MovingAverage class with a given window size. 2. Add a method to receive a new integer from the data stream. 3. Modify the method to maintain a running sum and utilize it for efficient moving average calculation. # Input and Output * **Input**: * An integer `val` representing the new value from the data stream. * **Output**: * A floating-point number representing the current moving average of the last `n` values in the stream. # Constraints * The window size is a positive integer. * The input stream contains integer values which can be positive, negative, or zero. * Your implementation should handle up to (10^6) integer inputs efficiently. * The `next` method should have an average time complexity of O(1). # Example Usage ```python # Initialize with a window size of 3 m = MovingAverage(3) # Add data points and get the moving average print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.666666666666667 print(m.next(5)) # Output: 6.0 ``` # Constraints and Limitations Ensure: * The class maintains a running sum to optimize the average computation. * The moving window mechanism correctly handles evicting the oldest element when the window is full.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): self.queue = deque() self.size = size self.window_sum = 0 def next(self, val: int) -> float: # Add new value to the queue self.queue.append(val) # Add the new value to the running sum self.window_sum += val # If the queue is longer than the desired window size, # subtract the oldest value from the running sum and pop it from the queue if len(self.queue) > self.size: self.window_sum -= self.queue.popleft() # Calculate and return the moving average return self.window_sum / len(self.queue)"},{"question":"# Dijkstra\'s Algorithm Challenge Given a directed graph represented as an adjacency matrix with non-negative edge weights, implement the Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices. Your implementation should be optimized using a priority queue to handle the `min_distance` retrieval efficiently. Function Signature ```python def dijkstra(vertex_count: int, graph: List[List[int]], src: int) -> List[int]: ``` # Input - **vertex_count** (int): The number of vertices in the graph. - **graph** (List[List[int]]): A 2D list representing the adjacency matrix of the graph, where `graph[i][j]` is the weight of the edge from vertex `i` to vertex `j`. - **src** (int): The source vertex from which to calculate the shortest path. # Output - **List[int]**: A list of distances where the index represents the vertex and the value at that index is the shortest distance from the source vertex to that vertex. # Constraints - `1 <= vertex_count <= 1000` - `0 <= graph[i][j] <= 1000` for all valid i and j - `0 <= src < vertex_count` # Performance Requirements - Use a priority queue to implement the `min_distance` retrieval to optimize the algorithm to run efficiently on larger graphs. # Example ```python # Example adjacency matrix for a graph with 5 vertices graph = [ [0, 9, 6, 0, 0], [9, 0, 3, 0, 0], [6, 3, 0, 2, 0], [0, 0, 2, 0, 4], [0, 0, 0, 4, 0] ] vertex_count = 5 src = 0 print(dijkstra(vertex_count, graph, src)) # Output should be [0, 9, 6, 8, 12] ``` Write your optimized implementation based on the details above. Consider edge cases and ensure your solution handles them gracefully.","solution":"import heapq from typing import List, Tuple def dijkstra(vertex_count: int, graph: List[List[int]], src: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest paths from the source vertex to all other vertices in a weighted directed graph. :param vertex_count: int - Number of vertices in the graph. :param graph: List[List[int]] - Adjacency matrix representing the graph. graph[i][j] represents the weight from vertex i to vertex j. :param src: int - The source vertex. :return: List[int] - List of shortest distances from the source vertex to each vertex. # Initialize the distances with infinity distances = [float(\'inf\')] * vertex_count distances[src] = 0 # Use a priority queue to store (distance, vertex) tuples priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Skip processing if we\'ve found a shorter path to current_vertex already if current_distance > distances[current_vertex]: continue # Process each neighbor of the current vertex for neighbor in range(vertex_count): weight = graph[current_vertex][neighbor] if weight > 0: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Question: String-Based Multiplication Algorithm Context You are given two non-negative integers represented as strings. Your task is to simulate the multiplication process as done manually and return the result as a string. This is useful in scenarios where the numbers are too large to handle using standard data types. Function Requirements Implement a function `multiply(num1: str, num2: str) -> str` that takes two non-negative integers `num1` and `num2` as arguments and returns their product represented as a string. Input Format - `num1` and `num2` are non-negative integers represented as strings. - The length of both `num1` and `num2` is less than 110. - Both strings contain only digits from \'0\' to \'9\'. - Both strings do not have leading zeros. Output Format - Return the product of `num1` and `num2` also as a string. Constraints - You must not use any built-in BigInteger libraries. - You must not convert the inputs directly to integers. Performance Requirements - Time Complexity: O(n * m), where n and m are the lengths of `num1` and `num2`. - Space Complexity: O(n + m). Example ```python assert multiply(\\"123\\", \\"456\\") == \\"56088\\" assert multiply(\\"0\\", \\"789\\") == \\"0\\" assert multiply(\\"999\\", \\"1\\") == \\"999\\" ``` Notes - Make sure you handle edge cases such as multiplication by zero and single-digit multiplications. - Your function should be efficient in terms of both time and space. Implement the function as described and ensure it passes the provided examples and any similar test cases you devise.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize the result array where the maximum length will be length of num1 + num2 result = [0] * (len(num1) + len(num2)) # Reverse both numbers to facilitate multiplication from least significant digit num1 = num1[::-1] num2 = num2[::-1] # Perform multiplication for i in range(len(num1)): for j in range(len(num2)): # Multiply the current digits and add to the corresponding position in result mul = int(num1[i]) * int(num2[j]) result[i + j] += mul # Handle carry over result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert result array back to string # Remove leading zeros if any while len(result) > 1 and result[-1] == 0: result.pop() return \'\'.join(map(str, result[::-1]))"},{"question":"# Huffman Coding Implementation and Testing Problem Statement You are provided with a partial implementation of the Huffman Coding algorithm, which is a data compression technique. Your task is to complete this implementation by adding the required methods and to write additional code for encoding and decoding text files. Tasks 1. **Implement Character Frequency Calculation**: Complete the method that calculates the frequency of each character in the input file. 2. **Build Huffman Tree**: Complete the method that builds the Huffman tree based on the character frequencies. 3. **Generate Huffman Codes**: Add code to generate binary codes for each character by traversing the Huffman tree. 4. **Perform Encoding and Writing**: Implement the methods to encode the input text and write the encoded data to an output file. 5. **Perform Decoding and Writing**: Complete the methods to decode the encoded data from the file and reconstruct the original text. Expected Input and Output Formats * **Input**: A text file containing a sequence of characters. * **Output**: - Encoded file containing the Huffman encoded binary data. - Decoded output text file that contains the original text. Constraints * The input file can contain any printable ASCII character. * The maximum size of the input file is 1MB. * Ensure the solution efficiently handles memory usage. Performance Requirements * The encoding and decoding processes should be completed within a reasonable time frame (e.g., less than a few seconds for files of size 1MB). # Implementation Using the provided code snippets, complete the missing parts and implement the required methods. The skeleton is already provided, so you need to fill in the gaps and ensure the entire process (from reading the input file to writing the encoded/decoded output file) works correctly. ```python # Class and method definitions given above; include HuffmanReader, HuffmanWriter, and HuffmanCoding classes. if __name__ == \\"__main__\\": import argparse parser = argparse.ArgumentParser(description=\\"Huffman Coding Algorithm\\") parser.add_argument(\\"mode\\", choices=[\\"encode\\", \\"decode\\"], help=\\"Mode of operation: either \'encode\' or \'decode\'\\") parser.add_argument(\\"input_file\\", help=\\"Input file name\\") parser.add_argument(\\"output_file\\", help=\\"Output file name\\") args = parser.parse_args() if args.mode == \\"encode\\": HuffmanCoding.encode_file(args.input_file, args.output_file) elif args.mode == \\"decode\\": HuffmanCoding.decode_file(args.input_file, args.output_file) else: print(\\"Invalid mode! Please use \'encode\' or \'decode\'\\") ``` Additional Instructions 1. Provide comments and documentation within your code for clarity. 2. Test your code with various input files to ensure correctness. 3. Handle edge cases appropriately and ensure your code is robust and error-free.","solution":"import heapq from collections import defaultdict, namedtuple # Define the structure of the Huffman Tree Node class HuffmanNode(namedtuple(\\"HuffmanNode\\", [\\"char\\", \\"freq\\", \\"left\\", \\"right\\"])): def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: @staticmethod def calculate_frequencies(text): Calculates the frequency of each character in the given text. frequencies = defaultdict(int) for char in text: frequencies[char] += 1 return frequencies @staticmethod def build_huffman_tree(frequencies): Build the Huffman Tree from the character frequencies. min_heap = [HuffmanNode(char, freq, None, None) for char, freq in frequencies.items()] heapq.heapify(min_heap) while len(min_heap) > 1: left = heapq.heappop(min_heap) right = heapq.heappop(min_heap) merged = HuffmanNode(None, left.freq + right.freq, left, right) heapq.heappush(min_heap, merged) return min_heap[0] @staticmethod def generate_huffman_codes(root): Generate the Huffman codes by traversing the Huffman Tree. huffman_codes = {} def generate_codes(node, current_code): if node is None: return if node.char is not None: huffman_codes[node.char] = current_code return generate_codes(node.left, current_code + \\"0\\") generate_codes(node.right, current_code + \\"1\\") generate_codes(root, \\"\\") return huffman_codes @staticmethod def encode_text(text, huffman_codes): Encode the input text using the Huffman codes. encoded_text = \\"\\".join(huffman_codes[char] for char in text) return encoded_text @staticmethod def decode_text(encoded_text, root): Decode the encoded text using the Huffman Tree. decoded_text = [] current_node = root for bit in encoded_text: if bit == \\"0\\": current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_text.append(current_node.char) current_node = root return \\"\\".join(decoded_text) @staticmethod def encode_file(input_file, output_file): Read the input file, encode its content and write the encoded data to the output file. with open(input_file, \'r\') as f: text = f.read() frequencies = HuffmanCoding.calculate_frequencies(text) huffman_tree_root = HuffmanCoding.build_huffman_tree(frequencies) huffman_codes = HuffmanCoding.generate_huffman_codes(huffman_tree_root) encoded_text = HuffmanCoding.encode_text(text, huffman_codes) with open(output_file, \'w\') as f: f.write(encoded_text) @staticmethod def decode_file(input_file, output_file): Read the encoded file, decode its content and write the decoded data to the output file. with open(input_file, \'r\') as f: encoded_text = f.read() characters = set(encoded_text) # This should come from a more sophisticated mechanism in practical implementations frequencies = HuffmanCoding.calculate_frequencies(encoded_text) huffman_tree_root = HuffmanCoding.build_huffman_tree(frequencies) decoded_text = HuffmanCoding.decode_text(encoded_text, huffman_tree_root) with open(output_file, \'w\') as f: f.write(decoded_text)"},{"question":"# Question You are building an application that processes URLs to extract the primary domain name. Given a URL string, write a function `extract_domain_name` that parses out the domain name and returns it as a string. Your function should handle various URL formats correctly and should not use any built-in string parsing libraries such as `re` (regular expressions) or `urlparse`, except for the `split()` method. Input Format * A single URL string (e.g., `http://www.example.com`). Output Format * A single string representing the domain name extracted from the URL (e.g., `example`). Example Scenarios 1. **Example 1:** - **Input:** `\\"http://github.com/SaadBenn\\"` - **Output:** `\\"github\\"` 2. **Example 2:** - **Input:** `\\"http://www.zombie-bites.com\\"` - **Output:** `\\"zombie-bites\\"` 3. **Example 3:** - **Input:** `\\"https://www.cnet.com\\"` - **Output:** `\\"cnet\\"` Constraints * You must not use any built-in parsing libraries such as `re` or `urlparse`. * You may assume that the input will always contain a valid URL in a format similar to the examples provided. # Function Signature ```python def extract_domain_name(url: str) -> str: pass ``` # Assessment Strategy Your solution will be evaluated based on: * Correctness: The returned domain name should be accurate as per the input URL. * Efficiency: The solution should perform efficiently for typical input sizes. * Edge cases: Handling of URLs with or without `www.` and different URL structures. * Code quality: The code should be concise, well-structured, and appropriately commented.","solution":"def extract_domain_name(url: str) -> str: Extracts the primary domain name from the given URL. # remove protocol (http://, https://, etc.) by splitting on \\"://\\" and taking the part after that if \\"://\\" in url: url = url.split(\\"://\\")[1] # split the URL based on \\"/\\" to handle cases where there are paths or parameters in the URL url = url.split(\\"/\\")[0] # remove \\"www.\\" if present by splitting based on \'.\' and considering the case with \\"www.\\" if url.startswith(\\"www.\\"): url = url[4:] # split by \'.\' to get the domain parts and return the first part as the domain name domain = url.split(\\".\\")[0] return domain"},{"question":"# Combinatorial Subset Selection You are given the task of implementing a function to calculate the number of ways to choose `r` items from `n` items. There are two methods provided, a plain recursive method and a memoized recursive method. Your task is to implement the memoized version of the combination calculation and optimize it further. **Function Signature:** ```python def optimized_combination(n: int, r: int) -> int: pass ``` **Input**: * `n`: a non-negative integer representing the total number of items. * `r`: a non-negative integer representing the number of items to select from the total. **Output**: * An integer representing the number of ways to choose `r` items from `n` items. **Constraints**: * `0 <= r <= n <= 1000` **Performance Requirements**: * Your solution should run efficiently even for large values of `n` and `r`. # Example ```python assert optimized_combination(5, 2) == 10 assert optimized_combination(6, 0) == 1 assert optimized_combination(6, 6) == 1 ``` # Notes: * Consider edge cases such as `r = 0`, `n = r`, and `0 <= r <= n`. * Aim to optimize both time and space complexities wherever possible.","solution":"def optimized_combination(n: int, r: int) -> int: Calculate the number of ways to choose r items from n items using memoization. if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a memoization table memo = [[0] * (r + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: memo[i][j] = 1 else: memo[i][j] = memo[i - 1][j - 1] + memo[i - 1][j] return memo[n][r]"},{"question":"You are working on a system that handles data packs. Each data pack\'s size must be a power of two to optimize the system\'s performance. You need to implement a function that checks whether the size of a given data pack is a power of two. # Function Signature ```python def check_power_of_two(size: int) -> bool: Determine if the given size is a power of two. Parameters: size (int): Size of the data pack. Returns: bool: True if size is a power of two, False otherwise. ``` # Input - An integer `size` where * ( 1 leq text{size} leq 10^9 ) # Output - Return `True` if the given size is a power of two. - Return `False` otherwise. # Example ```python assert check_power_of_two(16) == True assert check_power_of_two(18) == False ``` # Constraints - You must solve the problem with constant time complexity. - You cannot use any pre-existing libraries that directly solve this problem. # Notes - A power of two is a number of the form ( 2^k ) where k is a non-negative integer (0, 1, 2, ...). - This means only one bit is set in the binary representation of the number.","solution":"def check_power_of_two(size: int) -> bool: Determine if the given size is a power of two. Parameters: size (int): Size of the data pack. Returns: bool: True if size is a power of two, False otherwise. # A number is a power of two if and only if it has exactly one bit set in its binary representation. # We can check this by using the property that (n & (n-1)) == 0 for powers of two. if size <= 0: return False return (size & (size - 1)) == 0"},{"question":"# Question: Determine the Added Character in a Shuffled String Scenario: You are working on a feature that ensures data integrity when user inputs are received. To verify the integrity, any additional character introduced to a shuffled input string needs to be identified. Your task is to write a function that can identify the additional character in such cases. Problem Statement: Given two strings `s` and `t` where: - `t` is generated by shuffling string `s` and then adding one additional character at a random position. Write a function `find_difference(s, t)` to identify the character that was added. Input: - `s`: A string consisting of only lowercase letters, with length `n`. - `t`: A string consisting of only lowercase letters, with length `n + 1`. Output: - Return a single character representing the additional character in `t`. Constraints: - Both strings consist of only lowercase letters (\'a\' to \'z\'). - `0 ≤ n ≤ 10^5` Performance Requirements: - The function must run in O(n) time complexity. - The function must use O(1) space complexity, regardless of the input size. Example: ```python s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` **Note**: In the example above, `t` is generated by shuffling `s` (\\"abcd\\") and adding an extra character \'e\'.","solution":"def find_difference(s, t): Identify the added character in shuffled string t compared to string s. This solution utilizes the property of XOR. When you XOR the same numbers together, they cancel each other out because a ^ a = 0. By XORing all characters of both strings, the only character that does not get canceled out will be the additional character. result = 0 # Combine both strings in a single loop for char in s + t: result ^= ord(char) return chr(result)"},{"question":"# Unique Binary Search Trees: Counting with Dynamic Programming Problem Statement Given an integer (n), write a function `num_trees(n)` to determine the number of structurally unique Binary Search Trees (BSTs) that can be constructed using the values from 1 to (n). A Binary Search Tree follows these rules: 1. The left subtree of a node contains only nodes with keys less than the node\'s key. 2. The right subtree of a node contains only nodes with keys greater than the node\'s key. 3. Both the left and right subtrees must also be binary search trees. For example: - When (n = 3), there are a total of 5 unique BSTs: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Function Signature ```python def num_trees(n: int) -> int: ``` Input - `n` (integer (1 leq n leq 19)): The number of nodes in the BST. Output - Returns an integer representing the number of unique BSTs that can be constructed with (n) nodes. Constraints - Focus on optimizing both time and space complexity as (n) can be up to 19. Edge Cases to Consider - Minimum input values like (n = 1). - Boundary inputs like (n = 0), which should logically yield 1 (representing the empty tree). Example ```python print(num_trees(3)) # Output: 5 print(num_trees(1)) # Output: 1 print(num_trees(0)) # Output: 1 ``` Implement the function by applying the principles of dynamic programming to efficiently solve and count the number of unique BSTs.","solution":"def num_trees(n: int) -> int: Calculate the number of unique BSTs that can be constructed with `n` nodes. # Base case: if n is 0 or 1, there\'s exactly one unique BST (the empty tree, or the single node tree) if n == 0 or n == 1: return 1 # Dynamic programming table to store the number of unique BSTs for each number of nodes dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 # Fill the DP table for nodes in range(2, n + 1): total_trees = 0 for root in range(1, nodes + 1): left = dp[root - 1] right = dp[nodes - root] total_trees += left * right dp[nodes] = total_trees return dp[n]"},{"question":"# Most Frequent Values in an Array Given an array of integers, write a function to find the most frequent values in the array. The function should return a list containing all values that appear most frequently in the array. If there are multiple values with the same highest frequency, all those values should be included in the returned list. # Function Signature ```python def most_frequent_values(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers. The list can be empty or contain integers that may repeat. # Output - A list of integers representing the most frequent values in the input list. If there are multiple most frequent values, all should be included in the result list. # Constraints - The input list can be empty. - The elements of the input list are in the range of `-10^5` to `10^5`. # Example ```python assert most_frequent_values([1, 1, 2, 2, 3, 4]) == [1, 2] assert most_frequent_values([5, 5, 5, 3, 3, 2]) == [5] assert most_frequent_values([]) == [] assert most_frequent_values([7, 8, 9, 10]) == [7, 8, 9, 10] ``` # Explanation - In the first example, both `1` and `2` appear twice, so they are the most frequent values. - In the second example, `5` appears three times, more than any other value. - The third example demonstrates the function returns an empty list when the input is empty. - The fourth example shows that when all elements are unique, all are considered most frequent. # Implementation Requirements - The solution should have a time complexity of **O(n)**. - The solution should consider and handle edge cases such as empty lists and lists where all elements are unique. # Additional Notes - Do not use libraries or functions specifically designed to solve this problem (e.g., `collections.Counter`), as the goal is to assess your understanding of fundamental algorithm design principles.","solution":"from typing import List def most_frequent_values(arr: List[int]) -> List[int]: Function to find the most frequent values in the array. if not arr: return [] frequency_dict = {} for num in arr: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 max_frequency = max(frequency_dict.values()) most_frequent = [key for key, value in frequency_dict.items() if value == max_frequency] return most_frequent"},{"question":"# Multi-Source Shortest Path in Grid You are given an `m x n` 2D grid initialized with these three possible values: - `-1`: A wall or an obstacle. - `0`: A gate. - `INF`: Infinity means an empty room (use the value (2^{31} - 1 = 2147483647) to represent INF as you may assume that the distance to a gate is less than 2147483647). Write a function `walls_and_gates(rooms)` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room with `INF`. **Function Signature:** ```python def walls_and_gates(rooms: List[List[int]]) -> None: pass ``` **Input:** - `rooms` is a list of lists, where each list represents a row in the grid. The grid has dimensions `m x n`, where (1 leq m, n leq 300). **Output:** - The function should not return anything. Modify the `rooms` grid in-place. **Example:** ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] walls_and_gates(rooms) # Resulting grid: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` **Constraints:** - Gates are correctly placed with 0s. - Walls and empty rooms are represented properly before the modification. - Modify the grid in-place. # Important Notes: 1. Use a **Breadth-First Search (BFS)** to ensure you calculate the shortest path from multiple gates simultaneously. 2. Avoid using Depth-First Search (DFS) as it may lead to stack overflow issues for large grids. 3. Remember to check for boundaries to avoid out-of-bounds errors.","solution":"from collections import deque def walls_and_gates(rooms): Fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave the room as INF. Args: rooms (List[List[int]]): The m x n grid of rooms with gates, walls, and empty rooms. Returns: None: Modifies the grid in place. if not rooms: return INF = 2147483647 m, n = len(rooms), len(rooms[0]) queue = deque() # Enqueue all gates first for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"# Question: Consider a system where you need efficient storage and fast retrieval for prefix-based search operations on a large dataset of strings, such as an autocomplete feature in a search engine. Implement a class `Trie` with the following methods: 1. `insert(word: str) -> None`: Inserts the string `word` into the trie. 2. `search(word: str) -> bool`: Returns `True` if the string `word` is in the trie (i.e., previously inserted) and `False` otherwise. 3. `starts_with(prefix: str) -> bool`: Returns `True` if there is any string in the trie that starts with the string `prefix`. You may assume that all inputs are comprised of lowercase alphabetic characters (a-z). Example: ``` # Create a new Trie object. trie = Trie() # Insert words into the trie. trie.insert(\\"apple\\") trie.insert(\\"app\\") # Search for words. print(trie.search(\\"apple\\")) # Should return True print(trie.search(\\"app\\")) # Should return True print(trie.search(\\"appl\\")) # Should return False # Check for prefixes. print(trie.starts_with(\\"app\\")) # Should return True print(trie.starts_with(\\"apb\\")) # Should return False ``` Constraints: - All input strings (`word` and `prefix`) will be non-empty. - All operations (insert, search, startsWith) are case-insensitive. Ensure your implementation runs efficiently with a focus on time and space complexity.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are provided with a list of numeric values and a range specified by minimum and maximum limits. Your task is to implement a function that returns a new list containing only the elements from the original list that fall within the specified range (inclusive). If the minimum or maximum limit is not provided, consider the respective limit as unbounded. In other words: - If `min_limit` is None, consider it as negative infinity (no lower bound). - If `max_limit` is None, consider it as positive infinity (no upper bound). **Function Signature:** ```python def filter_range(arr: List[int], min_limit: Optional[int], max_limit: Optional[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers. - `min_limit`: An optional integer representing the lower bound (inclusive). - `max_limit`: An optional integer representing the upper bound (inclusive). # Output - A list containing only the integers from `arr` that fall within the `[min_limit, max_limit]` range. # Constraints - The length of the list `arr` is between 0 and 10^5. - The elements in `arr` are integers between -10^9 and 10^9. - `min_limit` and `max_limit` are also integers between -10^9 and 10^9, or None. # Examples 1. **Example 1**: ```python arr = [1, 2, 3, 4, 5] min_limit = None max_limit = 3 filter_range(arr, min_limit, max_limit) # Output: [1, 2, 3] ``` 2. **Example 2**: ```python arr = [-5, 0, 5, 10, 15] min_limit = 0 max_limit = 10 filter_range(arr, min_limit, max_limit) # Output: [0, 5, 10] ``` 3. **Example 3**: ```python arr = [] min_limit = 1 max_limit = 10 filter_range(arr, min_limit, max_limit) # Output: [] ``` 4. **Example 4**: ```python arr = [10, 20, 30, 40, 50] min_limit = 15 max_limit = None filter_range(arr, min_limit, max_limit) # Output: [20, 30, 40, 50] ``` # Note: - You should handle edge cases appropriately, such as empty input lists or when all elements fall outside the specified range. - Aim to achieve the most efficient solution possible given the constraints.","solution":"from typing import List, Optional def filter_range(arr: List[int], min_limit: Optional[int], max_limit: Optional[int]) -> List[int]: Filters elements within the specified range from the list. Args: arr (List[int]): The list of integers to filter. min_limit (Optional[int]): The lower bound of the range (inclusive). If None, consider it unbounded. max_limit (Optional[int]): The upper bound of the range (inclusive). If None, consider it unbounded. Returns: List[int]: A list of integers that fall within the specified range. if min_limit is None: min_limit = float(\'-inf\') if max_limit is None: max_limit = float(\'inf\') return [x for x in arr if min_limit <= x <= max_limit]"},{"question":"**Graph Traversal with BFS and DFS** # Problem Statement You are required to implement graph traversal algorithms using both Depth-First Search (DFS) and Breadth-First Search (BFS). You will implement iterative and recursive versions of DFS and an iterative BFS. The graph is represented using an adjacency list. # Function Implementations 1. **dfs_iterative(graph, start)**: - **Input**: A dictionary representing the graph (adjacency list), and a starting node. - **Output**: A set containing all nodes visited using iterative DFS starting from the provided starting node. 2. **dfs_recursive(graph, start, visited=None)**: - **Input**: A dictionary representing the graph (adjacency list), and a starting node. - **Output**: A set containing all nodes visited using recursive DFS starting from the provided starting node. 3. **bfs(graph, start)**: - **Input**: A dictionary representing the graph (adjacency list), and a starting node. - **Output**: A set containing all nodes visited using BFS starting from the provided starting node. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert dfs_iterative(graph, \'A\') == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} assert dfs_recursive(graph, \'A\') == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} assert bfs(graph, \'A\') == {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'} ``` # Constraints * All nodes in the graph are connected. * Node values are unique. * All edges are bidirectional (undirected graph). Ensure you account for any edge cases, such as isolated nodes or loops within the graph.","solution":"def dfs_iterative(graph, start): visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited def dfs_recursive(graph, start, visited=None): if visited is None: visited = set() visited.add(start) for neighbor in graph[start]: if neighbor not in visited: dfs_recursive(graph, neighbor, visited) return visited def bfs(graph, start): visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited) return visited"},{"question":"# Question: Implement Improved Cocktail Shaker Sort You are required to implement an enhanced version of Cocktail Shaker Sort. The enhancements are: 1. Optimize the number of comparisons by identifying the boundaries of the last swapped positions. 2. Implement a check for nearly sorted arrays to handle them more efficiently. # Function Signature ```python def improved_cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `[arr]` where `0 <= len(arr) <= 10^5`. # Output - A list of integers sorted in ascending order. # Constraints - The function should handle empty lists and single-element lists. - Your implementation should aim to be more efficient than the basic Cocktail Shaker Sort, especially for arrays that are already sorted or nearly sorted. - The algorithm should retain O(1) space complexity by sorting the array in place. # Examples - Given `[3, 2, 1]`, the function should return `[1, 2, 3]`. - Given `[1, 2, 3, 4, 5]`, the function should return `[1, 2, 3, 4, 5]`. # Explanation Your implementation should: 1. Use bidirectional processing to sort the list. 2. Track the last swapped positions to minimize the range of future passes. 3. Detect already sorted lists to exit early and improve performance.","solution":"from typing import List def improved_cocktail_shaker_sort(arr: List[int]) -> List[int]: Improved version of Cocktail Shaker Sort to sort a list of integers. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers. if len(arr) <= 1: return arr start = 0 end = len(arr) - 1 swapped = True while swapped: swapped = False new_end = 0 # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True new_end = i end = new_end if not swapped: break swapped = False new_start = 0 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True new_start = i start = new_start return arr"},{"question":"Strongly Connected Components in Directed Graph In a directed graph, a strongly connected component (SCC) is a set of vertices where each vertex is reachable from any other vertex in the same set. Given the implementation of a directed graph and a method to check if it is strongly connected, your task is to write a function to determine if a given graph is strongly connected or not. Function Signature: ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` Input: * `vertex_count`: An integer V representing the number of vertices in the graph (0 ≤ V ≤ 10^5). * `edges`: A list of tuples where each tuple (u, v) represents a directed edge from vertex `u` to vertex `v`. Output: * Return `True` if the graph is strongly connected, otherwise return `False`. Constraints: * The graph is directed and may have cycles. * There is no edge with the same start and end node (no self-loops). * Parameters `vertex_count` and `edges` will be provided in a valid format. Examples: 1. **Input**: ```python vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)] ``` **Output**: ```python True ``` 2. **Input**: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] ``` **Output**: ```python False ``` Notes: * You are required to use the provided information to implement the function that checks for strong connectivity. * Consider edge cases such as single-node graphs or graphs with multiple disjoint components.","solution":"from typing import List, Tuple from collections import defaultdict, deque def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: if vertex_count == 0: return True adjacency_list = defaultdict(list) reverse_adjacency_list = defaultdict(list) # Build the graph and its reverse for u, v in edges: adjacency_list[u].append(v) reverse_adjacency_list[v].append(u) def bfs(start_node, graph): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited # Check all nodes are reachable from the first node visited_from_start = bfs(0, adjacency_list) if len(visited_from_start) != vertex_count: return False # Check all nodes are reachable in the reversed graph reverse_visited_from_start = bfs(0, reverse_adjacency_list) if len(reverse_visited_from_start) != vertex_count: return False return True"},{"question":"# Markov Chain Text Generator You are tasked with creating a text generator based on Markov Chains. The generator will take an input text and generate a specified number of words as output, starting from a given initial word. You need to build the transition probabilities from the input text and use these probabilities to generate new text. Function Signature ```python def markov_text_generator(text: str, num_words: int, initial_word: str) -> str: Generates text using a Markov Chain based on the given input text. Args: text (str): The source text to build the Markov Chain. num_words (int): The number of words to generate. initial_word (str): The initial word to start text generation. Returns: str: The generated text. pass ``` Expected Input and Output Formats - **Input**: - `text`: A string containing the input text, which will be used to derive transition probabilities. - `num_words`: An integer representing the number of words to generate. - `initial_word`: A string representing the initial word to start the generated text from. - **Output**: - A string of generated words based on the Markov Chain built from the input text. Constraints - The `text` will not be empty. - The `initial_word` will be present in the `text`. - The words in `text` are separated by spaces and no punctuation is included. Performance Requirements - The solution should handle reasonably long texts and generate the required number of words within a practical time frame. Example Usage ```python text = \\"the quick brown fox jumps over the lazy dog the lazy dog sleeps\\" num_words = 5 initial_word = \\"the\\" print(markov_text_generator(text, num_words, initial_word)) # Possible output: \\"the lazy dog sleeps over the\\" ``` Implementation Details 1. Parse the `text` and build a transition probability dictionary based on word transitions. 2. Implement a function to choose the next word based on current word\'s transition probabilities. 3. Generate the required number of words starting from the `initial_word` using the Markov Chain. 4. Ensure edge cases such as the last word in input text handle correctly without breaking the function logic.","solution":"import random from collections import defaultdict def markov_text_generator(text: str, num_words: int, initial_word: str) -> str: Generates text using a Markov Chain based on the given input text. Args: text (str): The source text to build the Markov Chain. num_words (int): The number of words to generate. initial_word (str): The initial word to start text generation. Returns: str: The generated text. words = text.split() if initial_word not in words: raise ValueError(\\"Initial word not in text\\") # Build the transition dictionary transitions = defaultdict(list) for i in range(len(words) - 1): transitions[words[i]].append(words[i+1]) transitions[words[-1]] # Ensure the last word is in the transitions # Generate the text current_word = initial_word generated_words = [current_word] for _ in range(num_words - 1): if current_word not in transitions or not transitions[current_word]: break # no possible transitions from the current word next_word = random.choice(transitions[current_word]) generated_words.append(next_word) current_word = next_word return \' \'.join(generated_words)"},{"question":"Secure Communication using Diffie-Hellman Key Exchange **Scenario**: Alice and Bob wish to communicate securely over an unencrypted channel. They decide to use the Diffie-Hellman key exchange algorithm to establish a shared secret key. **Task**: Write a Python function `secure_shared_key(g, p)` that: 1. Confirms whether (p) is a prime number. 2. Determines if (g) is a primitive root of (p). 3. If both checks pass, performs the Diffie-Hellman key exchange between Alice and Bob. 4. Returns the shared secret key if the exchange is successful, or `None` if it fails. **Function Signature**: ```python def secure_shared_key(g: int, p: int) -> int: ``` # Input - `g` (int): Candidate for the primitive root of (p). - `p` (int): A large prime number. # Output - (int): Shared secret key, or `None` if inputs are invalid. # Constraints - (1 < g < p) - (p) is a sufficiently large prime number. # Example ```python # Example 1 print(secure_shared_key(5, 23)) # Output: Some shared secret key, e.g., 6 # Example 2 print(secure_shared_key(10, 20)) # Output: None (as 20 is not a prime number) ``` # Requirements: 1. Ensure (p) is prime using an efficient prime checking algorithm. 2. Verify that (g) is a primitive root of (p). 3. Perform the key exchange using the described steps. 4. Handle any invalid cases or errors gracefully by returning `None`. # Tips 1. Utilize helper functions for prime checking, primitive root finding, and the actual key exchange process. 2. Consider edge cases, such as small numbers or invalid inputs.","solution":"def is_prime(n): Efficiently checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Finds a primitive root modulo p. Returns None if no such root exists. if not is_prime(p): return None phi = p - 1 factors = prime_factors(phi) for g in range(2, p): if all(pow(g, phi // factor, p) != 1 for factor in factors): return g return None def prime_factors(n): Returns all prime factors of a number n. i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i if i not in factors: factors.append(i) if n > 1: factors.append(n) return factors def diffie_hellman(g, p): Performs the Diffie-Hellman key exchange and returns the shared secret. import random # Private keys a = random.randint(2, p - 2) b = random.randint(2, p - 2) # Public keys A = pow(g, a, p) B = pow(g, b, p) # Shared secret shared_secret_A = pow(B, a, p) shared_secret_B = pow(A, b, p) if shared_secret_A == shared_secret_B: return shared_secret_A return None def secure_shared_key(g: int, p: int) -> int: Confirms whether p is prime and g is a primitive root of p, and then performs the Diffie-Hellman key exchange. if not is_prime(p): return None if find_primitive_root(p) != g: return None return diffie_hellman(g, p)"},{"question":"Context You are given an undirected graph represented by an adjacency list. Your task is to find the number of connected components in this graph. A connected component is a maximal set of nodes such that there is a path between any two nodes in the set. Problem Statement Implement a function `count_connected_components` that takes an integer `n` (number of nodes) and an adjacency list `graph` as input and returns the number of connected components in the graph. Function Signature ```python def count_connected_components(n: int, graph: List[List[int]]) -> int: ``` Input * `n`: An integer representing the number of nodes in the graph. (1 ≤ n ≤ 1000) * `graph`: A list of lists where `graph[i]` contains the nodes connected to node `i` by an edge. (0 ≤ len(graph[i]) ≤ n-1) Output * An integer that represents the number of connected components in the graph. Example ```python n = 7 graph = [ [], # Node 0 (no edges since this is a 1-based index graph) [2], # Node 1 is connected to node 2 [1, 4, 5], # Node 2 is connected to nodes 1, 4, and 5 [7], # Node 3 is connected to node 7 [2, 6], # Node 4 is connected to nodes 2 and 6 [2, 6], # Node 5 is connected to nodes 2 and 6 [4, 5], # Node 6 is connected to nodes 4 and 5 [3] # Node 7 is connected to node 3 ] ``` Output ``` 2 ``` # Requirements 1. Ensure all edge cases are covered, such as isolated nodes, empty graphs, and fully connected graphs. 2. Consider optimizing recursion to iterative DFS or BFS if you encounter deep graphs.","solution":"from typing import List def count_connected_components(n: int, graph: List[List[int]]) -> int: def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) visited = [False] * n count = 0 for i in range(n): if not visited[i]: visited[i] = True dfs(i) count += 1 return count"},{"question":"Problem Statement You are required to implement a Binary Search Tree class in Python. The class should allow for: 1. Insertion of elements. 2. Searching for elements. 3. Determining the size of the tree. 4. Performing tree traversals (Preorder, Inorder, Postorder). Additionally, due to the risk of the tree becoming unbalanced, implement a `get_height` function to determine the height (or depth) of the tree, which will help in identifying the tree\'s balance state. A balanced tree has a height within `O(log N)` for `N` elements. Furthermore, implement a function to check if the tree is indeed balanced. # Requirements * Implement the `BST` class with the following methods: * `insert(data: int) -> bool`: Insert a given integer into the BST. Return `True` if the insertion was successful and `False` if the data already exists. * `search(data: int) -> bool`: Search a given integer in the BST. Return `True` if found and `False` otherwise. * `size() -> int`: Return the total number of elements in the BST. * `preorder() -> List[int]`: Return a list of elements in preorder traversal. * `inorder() -> List[int]`: Return a list of elements in inorder traversal. * `postorder() -> List[int]`: Return a list of elements in postorder traversal. * `get_height() -> int`: Return the height (maximum depth) of the BST. * `is_balanced() -> bool`: Return `True` if the tree is balanced, `False` otherwise. # Constraints * The tree should only store integers. * Tree height should be computed in O(N) time complexity. # Function Signature ```python class BST: def __init__(self): pass def insert(self, data: int) -> bool: pass def search(self, data: int) -> bool: pass def size(self) -> int: pass def preorder(self) -> List[int]: pass def inorder(self) -> List[int]: pass def postorder(self) -> List[int]: pass def get_height(self) -> int: pass def is_balanced(self) -> bool: pass ``` # Example ```python # Example to demonstrate the implementation and functions: tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) print(tree.search(9)) # Output: True print(tree.size()) # Output: 7 print(tree.preorder()) # Output: [10, 6, 4, 9, 15, 12, 24] print(tree.inorder()) # Output: [4, 6, 9, 10, 12, 15, 24] print(tree.postorder()) # Output: [4, 9, 6, 12, 24, 15, 10] print(tree.get_height()) # Output: 3 print(tree.is_balanced()) # Output: True or False depending on definition ``` Make sure your methods are efficient and cover edge cases effectively.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.count = 0 def insert(self, data: int) -> bool: if self.root is None: self.root = Node(data) self.count += 1 return True def recurse(node): if data < node.data: if node.left is None: node.left = Node(data) self.count += 1 return True else: return recurse(node.left) elif data > node.data: if node.right is None: node.right = Node(data) self.count += 1 return True else: return recurse(node.right) else: return False return recurse(self.root) def search(self, data: int) -> bool: def recurse(node): if node is None: return False if data < node.data: return recurse(node.left) elif data > node.data: return recurse(node.right) else: return True return recurse(self.root) def size(self) -> int: return self.count def preorder(self) -> list: result = [] def recurse(node): if not node: return result.append(node.data) recurse(node.left) recurse(node.right) recurse(self.root) return result def inorder(self) -> list: result = [] def recurse(node): if not node: return recurse(node.left) result.append(node.data) recurse(node.right) recurse(self.root) return result def postorder(self) -> list: result = [] def recurse(node): if not node: return recurse(node.left) recurse(node.right) result.append(node.data) recurse(self.root) return result def get_height(self) -> int: def height(node): if not node: return 0 return 1 + max(height(node.left), height(node.right)) return height(self.root) def is_balanced(self) -> bool: def check_balance(node): if not node: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) current_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) current_height = 1 + max(left_height, right_height) return current_balanced, current_height balanced, _ = check_balance(self.root) return balanced"},{"question":"# Skyline Problem Using Heap Problem Description: A city\'s skyline is defined by the contour formed by all its buildings when viewed from a distance. Given the locations and height of all the buildings in the city, write a function to compute the skyline. Each building is represented by a triplet of integers [Li, Ri, Hi], where: - Li is the x-coordinate of the left edge. - Ri is the x-coordinate of the right edge. - Hi is the height. Input: - A list of buildings, where each building is represented by [Li, Ri, Hi]. - It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. - The number of buildings will be in the range [0, 10000]. Output: - A list of \\"key points\\" in the format [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines the skyline. - The key points should be sorted by the x-coordinate. - No consecutive horizontal lines of equal height should be present in the output. Constraints: 1. Buildings are perfect rectangles grounded on a flat surface at height 0. 2. The input list is sorted in ascending order by the left x-position Li. 3. The last key point where the rightmost building ends should mark the termination of the skyline with height zero. Function Signature: ```python def get_skyline(buildings: List[List[int]]) -> List[List[int]]: pass ``` Example: ```python buildings = [ [2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8] ] # Returns: [ [2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0] ] assert get_skyline(buildings) == [ [2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0] ] ``` Notes: - The function should efficiently handle the sorting and merging of key points. - You may use heap operations to maintain the current tallest building and process the skyline correctly. - Ensure the resultant key points represent a unique view with no redundant segments.","solution":"def get_skyline(buildings): import heapq if not buildings: return [] events = [] for l, r, h in buildings: events.append((l, -h, r)) events.append((r, 0, 0)) events.sort() result = [[0, 0]] live_buildings = [(0, float(\\"inf\\"))] for x, neg_h, r in events: while live_buildings[0][1] <= x: heapq.heappop(live_buildings) if neg_h: heapq.heappush(live_buildings, (neg_h, r)) max_height = -live_buildings[0][0] if result[-1][1] != max_height: result.append([x, max_height]) return result[1:]"},{"question":"You are given a directed acyclic graph (DAG) represented as an adjacency list. Each key in the dictionary represents a node, and the associated value is a list of nodes to which the key has directed edges. Your task is to implement a function `find_cycles_and_top_sort(graph: Dict[int, List[int]]) -> Tuple[List[int], List[int]]` that performs the following: 1. **Cycle Detection**: Identify if the graph contains any cycles. 2. **Topological Sorting**: If no cycles are detected, return a valid topological sorting of the graph. # Input - `graph`: A dictionary where keys are integer nodes and the values are lists of integer nodes representing the edges. # Output - A tuple containing two lists: 1. The first list contains nodes part of any detected cycle. If no cycle exists, this list should be empty. 2. The second list contains nodes in topological order. If a cycle exists, this list should be empty. # Constraints - The graph is non-empty and contains at least one node. - The graph is a valid directed graph (edges are directed and no self-loops are present). # Example ```python graph = { 1: [2], 2: [3], 3: [1, 4], 4: [] } # Expected output: ([1, 2, 3], []) graph = { 1: [2], 2: [3], 3: [4], 4: [] } # Expected output: ([], [1, 2, 3, 4]) ``` # Notes - Your implementation should effectively handle large input sizes up to 1000 nodes and edges. - Consider efficiency both in terms of runtime and memory usage when devising your solution.","solution":"def find_cycles_and_top_sort(graph): Performs cycle detection and topological sorting on the given DAG. :param graph: A dictionary representing the directed graph. :return: A tuple containing a list of nodes part of any detected cycle, and a list of nodes in topological order. from collections import deque, defaultdict def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): cycle_path.append(node) return True visiting.remove(node) visited.add(node) top_order.appendleft(node) return False visited = set() visiting = set() top_order = deque() cycle_path = [] for node in graph: if node not in visited: if dfs(node): return (list(set(cycle_path)), []) return ([], list(top_order))"},{"question":"**Question:** You are given a directed graph represented as an adjacency list. Your task is to write a function that detects if there is a cycle in this graph using Depth-First Search (DFS) methodology. # Function Signature ```python def is_in_cycle(graph: Dict[str, List[str]], traversal_states: Dict[str, TraversalState], vertex: str) -> bool: pass def contains_cycle(graph: Dict[str, List[str]]) -> bool: pass ``` # Input * `graph` (dict): A dictionary where keys are vertex labels (strings) and values are lists of adjacent vertices (also strings). # Output * `bool`: A boolean value, `True` if the graph contains a cycle, `False` otherwise. # Constraints * The graph dictionary will contain between 0 and 10^4 vertices. * Vertex labels are unique. * The given graph is a directed graph. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } contains_cycle(graph) # Output: True graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } contains_cycle(graph2) # Output: False ``` # Context In this problem, you will implement two functions: one for determining if a specific vertex is part of a cycle (using DFS) and another for overall cycle detection in the graph. You need to manage traversal states effectively to detect cycles in the provided graph structure. # Detailed Requirements 1. Utilize the `TraversalState` enumeration to manage vertex states. 2. Implement `is_in_cycle`, which checks if a given vertex is part of a cycle. 3. Implement `contains_cycle`, which uses `is_in_cycle` to check the entire graph for cycles. 4. Ensure efficiency for large inputs, considering both time and space complexities. # Hint Think about depth-first search traversal and how you can use it to detect cycles by marking vertices during traversal.","solution":"from typing import Dict, List from enum import Enum class TraversalState(Enum): UNVISITED = 1 VISITING = 2 VISITED = 3 def is_in_cycle(graph: Dict[str, List[str]], traversal_states: Dict[str, TraversalState], vertex: str) -> bool: # If the current vertex is being visited, a cycle is detected if traversal_states[vertex] == TraversalState.VISITING: return True # If the current vertex is already visited, no need to explore further if traversal_states[vertex] == TraversalState.VISITED: return False # Mark this vertex as visiting traversal_states[vertex] = TraversalState.VISITING # Explore all adjacent vertices for neighbor in graph.get(vertex, []): if is_in_cycle(graph, traversal_states, neighbor): return True # Mark this vertex as visited traversal_states[vertex] = TraversalState.VISITED return False def contains_cycle(graph: Dict[str, List[str]]) -> bool: # Initialize all vertices to be unvisited traversal_states = {vertex: TraversalState.UNVISITED for vertex in graph} # Check each vertex for cycles for vertex in graph: if traversal_states[vertex] == TraversalState.UNVISITED: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"# Problem Description You are given a class `SegmentTree` that represents a Segment Tree data structure. This data structure supports efficient range queries and point updates using a given commutative function. Implement an additional method in this class called `range_update` that takes a range `[l, r]` and a value `v` and adds `v` to each element in the range. # Objective Enhance the functionality of the `SegmentTree` by implementing the `range_update` method. # Function Signature ```python def range_update(self, l: int, r: int, v: int): pass ``` # Input - `l` (int): start index of the range (inclusive). - `r` (int): end index of the range (inclusive). - `v` (int): the value to be added to each element in the range. # Output This method should update the internal structure of the Segment Tree, No specific output is required. # Constraints - Assume that `0 <= l <= r < n`, where `n` is the number of elements in the array used to initialize the Segment Tree. - The function provided during initialization is addition (`lambda a, b: a + b`). # Example Given the following initial array and operations: ```python arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr, lambda a, b: a + b) print(seg_tree.query(1, 3)) # Should print the sum of elements in range [1, 3], output: 15 seg_tree.range_update(1, 3, 2) # Adds 2 to each element in range [1, 3] print(seg_tree.query(1, 3)) # Should print the sum of updated elements in range [1, 3], output: 21 ``` Note: In this example, after `range_update`, the array would look like `[1, 5, 7, 9, 9, 11]`. # Performance Requirements - The `range_update` method should have a logarithmic time complexity with respect to the number of elements in the segment tree.","solution":"class SegmentTree: def __init__(self, data, func): self.n = len(data) self.tree = [0] * (2 * self.n) self.func = func for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 0: left = pos right = pos if pos % 2 == 0: right = pos + 1 else: left = pos - 1 self.tree[pos // 2] = self.func(self.tree[left], self.tree[right]) pos //= 2 def query(self, l, r): res = 0 l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res = self.func(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.func(res, self.tree[r]) l //= 2 r //= 2 return res def range_update(self, l, r, v): for i in range(l, r + 1): self.update(i, self.tree[self.n + i] + v)"},{"question":"Histogram Construction from List Context: You are working on a data analysis task where you need to compute the distribution of values in a dataset. One of the tasks involves creating a histogram that represents the frequency distribution of elements in a list. Task: Write a Python function `get_histogram(input_list: list) -> dict` that takes a list of elements and returns a dictionary representing the histogram of the input list. The keys of the dictionary should be the unique elements from the list, and the values should be the counts of how often each element appears in the list. Input: - `input_list`: A list of hashable elements (e.g., integers, strings). The list may be empty or contain duplicate elements. Output: - A dictionary where keys are the unique elements from `input_list`, and values are the corresponding counts of these elements. Constraints: - You may assume that all elements in `input_list` are hashable. - The function should handle an empty list by returning an empty dictionary. Examples: 1. `get_histogram([3, 3, 2, 1])` should return `{1: 1, 2: 1, 3: 2}` 2. `get_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7])` should return `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}` 3. `get_histogram([])` should return `{}` 4. `get_histogram([\'apple\', \'banana\', \'apple\'])` should return `{\'apple\': 2, \'banana\': 1}` Performance Requirements: - Your solution should have a time complexity of O(n), where n is the length of `input_list`. Good luck, and ensure your code is efficient and robust against edge cases!","solution":"def get_histogram(input_list): Takes a list of hashable elements and returns a dictionary representing the histogram of the input list. Keys of the dictionary are unique elements from the list and values are the counts of how often each element appears. Args: input_list (list): The input list of hashable elements. Returns: dict: A dictionary where keys are unique elements from the input list and values are their respective counts. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"# Digital Digits Context In digital forensics, it\'s often necessary to quickly determine the number of digits in a given number from metadata. This can help classify datasets, trigger specific processes, or check integrity of the forensic data. Problem Statement You are required to implement a function `num_digits(n)` that calculates the number of digits in the absolute value of an integer `n`. The function should: * Handle positive and negative integers as well as zero. * Return the number of digits efficiently using logarithmic properties. Function Signature ```python def num_digits(n: int) -> int: pass ``` Input - `n`: An integer (can be positive, negative, or zero). Output - Returns the number of digits in the absolute value of the integer `n`. Constraints - You should handle integer values within the range of a typical 32-bit signed integer: -2,147,483,648 to 2,147,483,647. - The function should execute in O(1) time. Example ```python num_digits(12345) # returns 5 num_digits(-9876) # returns 4 num_digits(0) # returns 1 ``` Notes - The function should not use any string conversion methods to determine the number of digits. - Ensure that the function handles edge cases efficiently.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the absolute value of an integer `n`. if n == 0: return 1 n = abs(n) return int(math.log10(n)) + 1"},{"question":"Selection Sort with Debugging You are given an immutable list of integers that you need to sort using the Selection Sort algorithm. Implement a function `selection_sort_with_debug(arr)` that returns a new list with the elements sorted in ascending order. Additionally, print the state of the list after each iteration of the outer loop for debugging purposes. Function Signature ```python def selection_sort_with_debug(arr: List[int]) -> List[int]: ``` Input * `arr`: List[int] - A list of integers (0 ≤ len(arr) ≤ 1000, -10^9 ≤ arr[i] ≤ 10^9). Output * Returns a new list with integers sorted in ascending order. * Prints the state of the list after each outer loop iteration. Example ```python input_array = [64, 25, 12, 22, 11] sorted_array = selection_sort_with_debug(input_array) print(\\"Sorted array:\\", sorted_array) ``` Expected Output: ``` iteration 0: [11, 25, 12, 22, 64] iteration 1: [11, 12, 25, 22, 64] iteration 2: [11, 12, 22, 25, 64] iteration 3: [11, 12, 22, 25, 64] iteration 4: [11, 12, 22, 25, 64] Sorted array: [11, 12, 22, 25, 64] ``` Constraints * Do not use any built-in sorting functions. * Ensure that the original array (`arr`) remains unchanged.","solution":"from typing import List def selection_sort_with_debug(arr: List[int]) -> List[int]: Sorts the list using the Selection Sort algorithm and returns a new list. Also prints the state of the list after each iteration of the outer loop. # Create a copy of the array to avoid modifying the original array arr_copy = arr.copy() n = len(arr_copy) for i in range(n): # Find the minimum element in the unsorted portion of the array min_idx = i for j in range(i + 1, n): if arr_copy[j] < arr_copy[min_idx]: min_idx = j # Swap the found minimum element with the first element of the unsorted portion arr_copy[i], arr_copy[min_idx] = arr_copy[min_idx], arr_copy[i] # Print the state of the list after each outer loop iteration print(f\\"iteration {i}: {arr_copy}\\") return arr_copy"},{"question":"As a software engineer at a network company, you are tasked to develop a crucial component for evaluating the shortest communication paths in a network. You are given an (n times n) adjacency matrix where each element represents the weight of the edge between nodes. If there is no edge between two nodes, the matrix will have a very large number indicating infinity (e.g., `float(\'inf\')`). Your task is to compute the shortest paths between every pair of nodes using the given adjacency matrix. # Implementation Requirements: Write a function `all_pairs_shortest_path(adj_matrix)` that takes: - `adj_matrix` (List[List[float]]): An (n times n) adjacency matrix of the graph. **Output**: - Returns a new (n times n) adjacency matrix where each element `[i][j]` holds the shortest distance from node `i` to node `j`. # Constraints: - The graph has no negative weight cycles. - Input matrix will have non-negative weights or `float(\'inf\')`. # Function Signature: ```python def all_pairs_shortest_path(adj_matrix: List[List[float]]) -> List[List[float]]: ``` # Example: ```python adj_matrix = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] # The output should be: # [ # [0, 3, 7, 5], # [2, 0, 6, 4], # [3, 1, 0, 5], # [5, 3, 2, 0] # ] print(all_pairs_shortest_path(adj_matrix)) ``` # Notes: - You must handle float(\'inf\') correctly to represent no path. - Ensure your code runs efficiently even for the upper constraint limits.","solution":"def all_pairs_shortest_path(adj_matrix): Computes the shortest path between all pairs of nodes in a graph using Floyd-Warshall algorithm. Args: - adj_matrix (List[List[float]]): An n x n adjacency matrix of the graph with edge weights. Returns: - List[List[float]]: An n x n adjacency matrix with the shortest path distances between all pairs of nodes. n = len(adj_matrix) # Create a copy of the adjacency matrix to store distances dist = [row[:] for row in adj_matrix] # Perform Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][k] + dist[k][j] < dist[i][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"Scenario In a simulation program for inventory management, you need to group items into pairs for an alternating inspection routine. Given a stack representing item IDs meant for inspection, you need to reorder the stack such that pairs of elements are swapped, starting from the bottom. If the number of items is odd, the last item remains in place. Problem Write a function `switch_item_pairs(stack)` that takes a stack as input and returns a new stack with pairs of elements swapped. Utilize an appropriate algorithm to ensure your function runs efficiently and within the constraints provided. ```python def switch_item_pairs(stack): Given a stack, switch_item_pairs function takes a stack as a parameter and returns a new stack with successive pairs of items swapped, starting at the bottom. Parameters: stack (list): A list representing a stack with item IDs. Returns: list: A new list representing the stack with swapped pairs. pass ``` Input * `stack`: A list `List[int]`, representing a stack of item IDs. (1 ≤ len(stack) ≤ 10^4). Output Return a list `List[int]` representing the stack with swapped pairs from the bottom. Constraints * Ensure minimal use of additional space. * Focus on execution efficiency. Example ```python stack = [3, 8, 17, 9, 1, 10] print(switch_item_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(switch_item_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` Notes * You may use either stack or queue as auxiliary storage. * Ensure the original stack order is preserved except for the swapped pairs.","solution":"def switch_item_pairs(stack): Given a stack, switch_item_pairs function takes a stack as a parameter and returns a new stack with successive pairs of items swapped, starting at the bottom. Parameters: stack (list): A list representing a stack with item IDs. Returns: list: A new list representing the stack with swapped pairs. # Create a new stack to hold the result new_stack = [] # Temporary storage for items temp_stack = [] # Move all items to temp_stack to reverse the order (bottom becomes top) while stack: temp_stack.append(stack.pop()) # Swap items in the reversed stack and push them back to the new_stack while temp_stack: first = temp_stack.pop() if temp_stack: second = temp_stack.pop() new_stack.append(second) new_stack.append(first) return new_stack"},{"question":"# Question: Implement Deletion in an AVL Tree As an experienced developer, you are aware of the importance of efficient data structures in maintaining performance for frequently changing datasets. The AVL Tree is a self-balancing binary search tree, which adjusts itself after every insertion or deletion to maintain its balanced property. This ensures that all basic operations such as insertions, deletions, and searches occur in logarithmic time. In this assessment, you are provided with a partially implemented AVL Tree class with insertion and balancing functionalities already in place. Your task is to extend this class by implementing the deletion operation in the AVL Tree. # Implementation Requirements Function Signature ```python def delete(self, key: int) -> None: ``` Input * `key` (int): The integer value to be deleted from the AVL tree. Output * None. Constraints * You can assume that the tree does not contain duplicate values. * The `TreeNode` and `AvlTree` classes with basic functionalities are provided. # Performance Requirements * The deletion operation must ensure that the tree remains balanced. # Scenario Assume you have a dataset that frequently changes due to deletions and insertions. You want to maintain this dataset in an AVL tree to ensure fast access times. Implement the deletion operation to help achieve this. # Example Here\'s how the extended class would be used: ```python avl_tree = AvlTree() avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(5) avl_tree.insert(6) avl_tree.insert(15) avl_tree.delete(10) print(avl_tree.in_order_traverse()) # Should print the in-order traversal of the tree excluding the deleted value. ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class AvlTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) else: self.root = self._insert(self.root, key) def delete(self, key): if self.root: self.root = self._delete(self.root, key) def _insert(self, node, key): # Perform normal BST insertion if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) # Update height node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) # Balance the node balance = self._get_balance(node) return self._balance_node(node, balance, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: # Node with only one child or no child if node.left is None: temp = node.right node = None return temp elif node.right is None: temp = node.left node = None return temp # Node with two children: Get the inorder successor (smallest in the right subtree) temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if node is None: return node # Update height node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) # Balance the node balance = self._get_balance(node) return self._balance_after_deletion(node, balance, key) def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _balance_node(self, node, balance, key): # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _balance_after_deletion(self, node, balance, key): # Left Left Case if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) # Left Right Case if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Right Case if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) # Right Left Case if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Matrix Multiplication Assessment Task Given two 2D lists (matrices), implement a function `mult_matrices(matrix1, matrix2)` that multiplies them if they are compatible, otherwise it raises a value error exception. # Function Signature ```python def mult_matrices(matrix1: List[List[int]], matrix2: List[List[int]]) -> List[List[int]]: pass ``` # Input - Two matrices (2D lists) `matrix1` and `matrix2`: - `matrix1`: A 2D list representing the first matrix. - `matrix2`: A 2D list representing the second matrix. # Output - A 2D list representing the resultant matrix from the multiplication of `matrix1` and `matrix2`. # Constraints - 1 <= number of rows and columns in each matrix <= 100 - All elements are integers within the range [-10^3, 10^3] # Example ```python matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [5, 6], [7, 8] ] print(mult_matrices(matrix1, matrix2)) # Output: [[19, 22], [43, 50]] ``` # Notes - Ensure the input matrices are of compatible sizes, otherwise raise a `ValueError` with a message \\"Matrices have incompatible sizes for multiplication\\".","solution":"def mult_matrices(matrix1, matrix2): Multiplies two matrices if they are compatible. Args: matrix1 : List[List[int]] - The first matrix. matrix2 : List[List[int]] - The second matrix. Returns: List[List[int]] - The resultant matrix from the multiplication of matrix1 and matrix2. Raises: ValueError - If the matrices have incompatible sizes for multiplication. # Check matrix dimensions for compatibility if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Matrices have incompatible sizes for multiplication\\") rows_matrix1 = len(matrix1) cols_matrix1 = len(matrix1[0]) cols_matrix2 = len(matrix2[0]) # Initialize result matrix with zeros result_matrix = [[0 for _ in range(cols_matrix2)] for _ in range(rows_matrix1)] # Perform matrix multiplication for i in range(rows_matrix1): for j in range(cols_matrix2): for k in range(cols_matrix1): result_matrix[i][j] += matrix1[i][k] * matrix2[k][j] return result_matrix"},{"question":"Implement a function `validate_rbtree(root)` that validates if a given binary tree is a valid red-black tree. To validate a red-black tree, you need to ensure the tree adheres to the red-black tree properties. Properties to validate: 1. Every node is colored either red or black. 2. The root is always black. 3. Every leaf (NIL node) is considered black. 4. If a red node has children then, its children must be black (no two reds in a row). 5. Every path from a node to its descendant NIL nodes must have the same number of black nodes. # Function Signature: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red def validate_rbtree(root: RBNode) -> bool: ``` # Input: - `root`: The root node of the binary tree to be validated. # Output: - Return `True` if the tree is a valid red-black tree. - Return `False` otherwise. # Constraints: - The tree can be empty. An empty tree is considered a valid red-black tree. - Node values are unique. # Example: ```python # Example usage root = RBNode(10, 0) root.left = RBNode(5, 1, root) root.right = RBNode(15, 0, root) print(validate_rbtree(root)) # Expected Output: False, the right child should not be black. ``` # Additional Notes: - You can design helper functions within the `validate_rbtree` function to facilitate your implementation. - Make sure to handle edge cases, such as an empty tree and single-node trees.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red def validate_rbtree(root: RBNode) -> bool: if not root: return True def is_valid_rb_node(node, black_count, path_black_count): if not node: if path_black_count is None: path_black_count = black_count return black_count == path_black_count, path_black_count if node.color == 0: # Black black_count += 1 elif node.color == 1: # Red if node.parent and node.parent.color == 1: return False, path_black_count left_valid, left_black_count = is_valid_rb_node(node.left, black_count, path_black_count) right_valid, right_black_count = is_valid_rb_node(node.right, black_count, path_black_count) if left_valid and right_valid and left_black_count == right_black_count: return True, left_black_count return False, path_black_count if root.color == 1: # Root must be black return False valid, _ = is_valid_rb_node(root, 0, None) return valid"},{"question":"# Problem Description Given a directed graph, determine if there exists a path from node `source` to node `target`. The graph is represented using an adjacency list. # Function Signature ```python def is_reachable(vertex_count: int, edges: [(int, int)], source: int, target: int) -> bool: ``` # Input * `vertex_count`: An integer representing the number of vertices in the graph. * `edges`: A list of tuples, where each tuple (source, target) represents an edge from `source` to `target`. * `source`: An integer representing the starting node. * `target`: An integer representing the destination node. # Output * A boolean value `True` if there exists a path from `source` to `target`, and `False` otherwise. # Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] source = 0 target = 3 print(is_reachable(vertex_count, edges, source, target)) # Output: True ``` # Constraints * You may assume that the graph does not contain any negative weight edges. * The graph may contain cycles. # Performance Requirements * Your solution should handle graphs with up to 10,000 vertices and 100,000 edges efficiently.","solution":"def is_reachable(vertex_count: int, edges: [(int, int)], source: int, target: int) -> bool: from collections import deque, defaultdict # Create adjacency list from edges graph = defaultdict(list) for (u, v) in edges: graph[u].append(v) # Perform BFS to check if there\'s a path from source to target visited = [False] * vertex_count queue = deque([source]) while queue: current = queue.popleft() if current == target: return True if not visited[current]: visited[current] = True for neighbor in graph[current]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"You are required to implement an improved variant of the Stooge Sort algorithm to sort an array of integers, but with an optimized stopping condition to reduce unnecessary comparisons. Specifically, if the array section to be sorted is already sorted, the function should return immediately without further recursive calls. Function Signature ```python def optimized_stoogesort(arr: List[int], l: int, h: int) -> None: ``` Input * **arr**: A list of integers, which might contain duplicates. * **l**: An integer, representing the starting index of the subsection of the array. * **h**: An integer, representing the ending index of the subsection of the array. Output * This function should sort the input list `arr` in-place and return `None`. Constraints * The length of the input list `arr` will be between 1 and 1000 inclusive. * All elements in `arr` will be integers in the range -10^6 to 10^6 inclusive. Example ```python from typing import List def optimized_stoogesort(arr: List[int], l: int, h: int) -> None: # Implement your optimized Stooge Sort here if __name__ == \\"__main__\\": array = [1, 3, 64, 5, 7, 8] optimized_stoogesort(array, 0, len(array) - 1) print(array) # Expected output: [1, 3, 5, 7, 8, 64] ``` # Requirements 1. Implement the `optimized_stoogesort` function with the improved stopping condition. 2. Consider the edge cases such as arrays of length 0 or 1. 3. Ensure that the function modifies the list `arr` in-place and does not return any value. # Performance Considerations * Your implementation should avoid unnecessary sorting operations when a subsection of the array is already sorted. * Although the base time complexity cannot be drastically improved due to the nature of the Stooge Sort, ensuring fewer comparisons can improve practical performance.","solution":"from typing import List def optimized_stoogesort(arr: List[int], l: int, h: int) -> None: if l >= h: return # Check if the section is already sorted is_sorted = True for i in range(l, h): if arr[i] > arr[i+1]: is_sorted = False break if is_sorted: return # Normal Stooge Sort operations if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 optimized_stoogesort(arr, l, h - t) optimized_stoogesort(arr, l + t, h) optimized_stoogesort(arr, l, h - t)"},{"question":"# Coding Challenge: Unique Cycle Sort **Scenario:** You are given an array containing `N` distinct integers, each integer in the range `1` to `N`. You need to sort this array using Cycle Sort but with additional requirements to handle edge cases and ensure robust performance. **Objective:** Implement the `cycle_sort` function to sort the array and return the sorted array. **Input:** * A list of integers, `arr`, with length `N` (1 ≤ N ≤ 10^3). * `arr` contains distinct integers in the range from `1` to `N`. **Output:** * A sorted list of integers. **Constraints:** * The algorithm needs to run in-place and must have a space complexity of O(1). * The algorithm must handle edge cases, such as arrays that are already sorted and completely reverse-sorted arrays, correctly. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Examples **Example 1:** ```python cycle_sort([4, 3, 2, 1]) # Output: [1, 2, 3, 4] ``` **Example 2:** ```python cycle_sort([1, 2, 3, 4]) # Output: [1, 2, 3, 4] ``` **Example 3:** ```python cycle_sort([3, 1, 4, 2]) # Output: [1, 2, 3, 4] ``` **Note:** * Ensure that you provide sufficient test cases to validate your implementation, covering various scenarios.","solution":"def cycle_sort(arr): Sorts the array using Cycle Sort algorithm and returns the sorted array. This algorithm performs the sort in-place with O(1) additional space. # Loop through the array to place each element to its correct position n = len(arr) for start in range(n): # Initialize current value and its correct position item = arr[start] pos = start # Find the correct position for the item for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the item is already in its correct position, skip it if pos == start: continue # Skip duplicate insertion while item == arr[pos]: pos += 1 # Place the item to its correct position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != start: pos = start # Find the correct position for the item for i in range(start + 1, n): if arr[i] < item: pos += 1 # Skip duplicate insertion while item == arr[pos]: pos += 1 # Place the item to its correct position arr[pos], item = item, arr[pos] return arr"},{"question":"# Question You are given the implementation snippets of a Red-Black Tree. Your task is to complete the implementation by adding a method to check if a given tree is a valid Red-Black Tree. A valid Red-Black Tree must satisfy the following properties: 1. Each node is either red or black. 2. The root is black. 3. All leaves (NIL nodes) are black. 4. If a node is red, then both its children must be black (no two red nodes can be adjacent). 5. Every path from a given node to its descendant leaves must have the same number of black nodes. # Task Implement a method `validate_rbtree()` in the `RBTree` class which returns `True` if the tree is a valid Red-Black Tree and `False` otherwise. # Input The input is implicitly the structure of the Red-Black Tree. # Output Return a boolean value: - `True` if the tree is a valid Red-Black Tree. - `False` otherwise. # Constraints - The tree can have up to 10^4 nodes. - Node values are unique integers. # Example ```python # assuming the initial code provided and further augmented to include input insertion if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) print(rb.inorder()) # [{val:, color:}, ...] print(rb.validate_rbtree()) # Your implementation should return True if valid ``` # Additional Instructions - Ensure that the `validate_rbtree` method uses the existing structure and properties of the Red-Black Tree to verify it thoroughly. - Handle edge cases such as an empty tree or isolated insertions correctly. - Performance is crucial; make sure the solution operates efficiently given the constraints.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 1 for red, 0 for black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NIL_LEAF = RBNode(0, 0) # Sentinel NIL node, considered black self.root = self.NIL_LEAF def insert(self, z): # Regular binary search tree (BST) insert code goes here, preserving NIL_LEAF for leaves pass def validate_rbtree(self): def is_red(node): return node is not None and node.color == 1 def is_black(node): return node is None or node.color == 0 def dfs(node): if node == self.NIL_LEAF: return True, 1 # NIL nodes are black, contributes 1 black node count if is_red(node): if is_red(node.left) or is_red(node.right): return False, 0 # Red violation, if parent\'s color is red, children must be black left_valid, left_black_height = dfs(node.left) right_valid, right_black_height = dfs(node.right) if left_black_height != right_black_height: return False, 0 # Black height violation, paths must have the same black node count if left_valid and right_valid: return True, left_black_height + (1 if is_black(node) else 0) return False, 0 if self.root and self.root.color == 1: return False # Root of red-black tree must be black valid, _ = dfs(self.root) return valid"},{"question":"# Problem: Efficient Matrix Exponentiation and Multiplication You are tasked with implementing a solution for efficiently computing powers of a given square matrix. The solution should also handle basic matrix multiplication and generation of an identity matrix. Function 1: `multiply(matA: list, matB: list) -> list` - **Objective**: Implement matrix multiplication for two square matrices. - **Parameters**: - `matA`: A list of lists representing an n x n matrix. - `matB`: A list of lists representing an n x n matrix. - **Returns**: A list of lists representing the resulting matrix after multiplying `matA` and `matB`. - **Constraints**: - Matrices are guaranteed to be square and have the same dimensions. Function 2: `identity(n: int) -> list` - **Objective**: Create an identity matrix of size n x n. - **Parameters**: - `n`: Size of the squared identity matrix. - **Returns**: A list of lists representing the identity matrix of dimension n x n. - **Constraints**: - `n` is a positive integer. Function 3: `matrix_exponentiation(mat: list, n: int) -> list` - **Objective**: Compute the exponentiation of a matrix to a non-negative integer power. - **Parameters**: - `mat`: A list of lists representing a d x d matrix. - `n`: A non-negative integer representing the power to which `mat` is to be raised. - **Returns**: A list of lists representing the matrix raised to the n-th power. - **Constraints**: - `mat` is a square matrix (d x d). - `n` is a non-negative integer. # Example ```python mat = [ [1, 2], [3, 4] ] n = 2 result = matrix_exponentiation(mat, n) # Expected Output: [ # [7, 10], # [15, 22] # ] ``` # Notes - Make sure to handle edge cases such as zero and unit exponent properly. - Optimize the implementation using the principles of matrix exponentiation described. - Your solution should be efficient and avoid unnecessary computations.","solution":"def multiply(matA, matB): Multiplies two square matrices matA and matB. n = len(matA) # Initialize result matrix with zeros result = [[0] * n for _ in range(n)] # Perform multiplication for i in range(n): for j in range(n): for k in range(n): result[i][j] += matA[i][k] * matB[k][j] return result def identity(n): Returns the identity matrix of size n x n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_exponentiation(mat, n): Computes the exponentiation of a matrix to a non-negative integer power n. if n == 0: return identity(len(mat)) if n == 1: return mat half_pow = matrix_exponentiation(mat, n // 2) half_pow_squared = multiply(half_pow, half_pow) if n % 2 == 0: return half_pow_squared else: return multiply(half_pow_squared, mat)"},{"question":"**Problem Statement**: You are given an integer, and your task is to write a function that computes the number of digits in the integer efficiently. Your implementation should aim for constant time complexity. **Function Signature**: ```python def num_digits(n: int) -> int: ``` **Input**: * An integer `n`, where `-10^9 <= n <= 10^9`. **Output**: * Return an integer representing the number of digits in the given integer `n`. **Examples**: ```python print(num_digits(12345)) # Output: 5 print(num_digits(-98765)) # Output: 5 print(num_digits(0)) # Output: 1 ``` **Constraints**: * The input will always be an integer within the range specified. * You should not use string conversion functions to determine the length of the number. **Additional Information**: Consider edge cases such as `0`, positive, and negative numbers. The function should maintain constant time complexity (O(1)) and handle all specified constraints effectively. **Performance Requirements**: * Aim for efficient computation with minimal overhead, ensuring the function can handle maximum input sizes within the given constraints.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the integer n. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Finding the K-th to Last Element in a Singly Linked List Context: In many practical scenarios, we need to identify elements in linked lists based on their relative position from the end. This problem assesses your understanding of traversal techniques and pointer manipulation in singly-linked lists. Problem Statement: You are given a singly-linked list and an integer `k`. Write a function `kth_to_last(head: Node, k: int) -> Union[Node, bool]:` that returns the k-th to last element of the singly linked list. If the k-th to last element doesn’t exist, return `False`. Function Signature: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Union[Node, bool]: pass ``` Input: - `head`: The head node of a singly-linked list. - `k`: A non-negative integer. Output: - Return the k-th to last node if it exists. - Return `False` otherwise. Constraints: - `k` can be zero or a non-negative integer. - The linked list can contain any number of elements including zero. Edge Cases: - Null `head` (Empty list). - `k` greater than the length of the list. - Negative `k` should be handled gracefully (return `False`). Example: ```python # Linked list: A -> B -> C -> D -> E -> F -> G # Example 1: head = Node(\\"A\\") head.next = Node(\\"B\\") head.next.next = Node(\\"C\\") head.next.next.next = Node(\\"D\\") head.next.next.next.next = Node(\\"E\\") head.next.next.next.next.next = Node(\\"F\\") head.next.next.next.next.next.next = Node(\\"G\\") k = 3 result = kth_to_last(head, k) # Should return Node with value \\"E\\" # Example 2: head = Node(\\"A\\") head.next = Node(\\"B\\") k = 2 result = kth_to_last(head, 3) # Should return False because k is greater than the number of elements ``` # Requirements: - The solution should have (O(n)) time complexity where (n) is the number of elements in the linked list. - No additional data structures beyond what is necessary should be used for optimal memory usage.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int): if k < 0: return False slow = fast = head for _ in range(k): if not fast: return False fast = fast.next if not fast: return False while fast.next: slow = slow.next fast = fast.next return slow if slow else False"},{"question":"# Problem Description: You are required to implement a Circular Array Queue, which resolves the performance issues related to the dynamic resizing of the array in the `ArrayQueue` class provided above. An additional advantage of circular queue is that you will not need to shift elements during `dequeue`. # CircularArrayQueue Class: Implement a circular queue using a fixed-size array with the following operations: - `__init__(capacity: int)`: Initializes the queue with a given capacity; the default capacity should be 10. - `enqueue(value: int)`: Adds a value to the rear of the queue. If the queue is full, it should raise an `OverflowError`. - `dequeue() -> int`: Removes and returns the value from the front of the queue. If the queue is empty, it should raise an `IndexError`. - `peek() -> int`: Returns the value at the front of the queue without removing it. If the queue is empty, it should raise an `IndexError`. - `is_empty() -> bool`: Returns `True` if the queue is empty, otherwise `False`. - `is_full() -> bool`: Returns `True` if the queue is full, otherwise `False`. - `size() -> int`: Returns the number of elements in the queue. # Input and Output: - **Input:** You do not need to handle input from the user. Implement the methods defined above. - **Output:** Implement and return the required functionality as specified in each method. # Constraints: 1. Queue capacity will be a positive integer ( ≥ 1). 2. Queue operations will be consistent with the described API. # Example: ```python q = CircularArrayQueue(3) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 q.enqueue(4) # This should work fine, no OverflowError print(q.dequeue()) # Output: 2 print(q.dequeue()) # Output: 3 print(q.dequeue()) # Output: 4 # If you try to dequeue from empty queue it should raise an exception try: print(q.dequeue()) # Should raise IndexError except IndexError as e: print(str(e)) # Output: Queue is empty ``` # Additional Requirement: Document any insights or edge cases you encounter and how you handle them in your solution.","solution":"class CircularArrayQueue: def __init__(self, capacity: int = 10): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.count = 0 def enqueue(self, value: int): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count"},{"question":"# Coding Challenge: Efficient Sorting Verification Problem Statement Given the inherent inefficiency of Bogo Sort, you are required to implement a function that verifies if a given array is sorted in non-decreasing order. This function will be used to exit early in more practical sorting algorithms, avoiding unnecessary shuffling or swapping operations. Function Signature ```python def is_sorted(arr: list) -> bool: Determines whether the given array is sorted in non-decreasing order. Parameters: - arr (list): A list of comparable elements. Returns: - bool: True if the list is sorted, False otherwise. pass ``` Input and Output - The **input** will be a list `arr` of comparable elements such as integers or strings. - The **output** will be a boolean value: `True` if the array is sorted, otherwise `False`. Constraints - The function should run in O(n) time complexity, where `n` is the number of elements in the array. - No additional space complexity beyond O(1) is allowed, except for input storage. Requirements 1. **Implementation**: Implement the function `is_sorted` based on the function signature. 2. **Edge Cases**: - An empty list should be considered sorted. - A single-element list should be considered sorted. 3. **Performance**: Ensure your solution handles large lists efficiently within the constraints provided. # Example ```python assert is_sorted([1, 2, 3, 4, 5]) == True assert is_sorted([3, 2, 1]) == False assert is_sorted([]) == True assert is_sorted([42]) == True assert is_sorted([1, 1, 1, 1]) == True assert is_sorted([1, 3, 2]) == False ``` Use these examples to test your function once implemented, ensuring it behaves correctly in each case.","solution":"def is_sorted(arr: list) -> bool: Determines whether the given array is sorted in non-decreasing order. Parameters: - arr (list): A list of comparable elements. Returns: - bool: True if the list is sorted, False otherwise. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True"},{"question":"You are given an unsorted list of integers, and your task is to sort this list using the Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers. Length can be between 0 to 10^5. Integers can be both positive and negative. # Output * A list of integers sorted in non-decreasing order. # Constraints * The solution should handle arrays with up to 100,000 elements within an acceptable time frame. * You need to implement the Comb Sort algorithm as explained. # Examples ```python # Example 1 input_array = [5, 3, 1, 4, 2] output_array = comb_sort(input_array) # Expected output: [1, 2, 3, 4, 5] # Example 2 input_array = [10, -3, 7, 3, 8] output_array = comb_sort(input_array) # Expected output: [-3, 3, 7, 8, 10] # Example 3 input_array = [] output_array = comb_sort(input_array) # Expected output: [] # Example 4 input_array = [2, 2, 2, 2, 2] output_array = comb_sort(input_array) # Expected output: [2, 2, 2, 2, 2] ``` # Notes * Ensure to test your implementation with edge cases such as empty lists, single-element lists, and large lists with repeated elements. * Consider efficiency improvements where possible to handle large inputs within a reasonable time.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor new_gap = (gap * 10) // 13 if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: You are given two two-dimensional lists (matrices), `multiplicand` and `multiplier`. Your task is to implement a function `optimized_multiply` that computes the product of these two matrices. Your implementation should aim to improve over the naive cubic time complexity if possible. Assume the matrices contain only integers. Function Signature: ```python def optimized_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: pass ``` Input: * `multiplicand` (List[List[int]]): A 2D list containing integers, representing the first matrix. * `multiplier` (List[List[int]]): A 2D list containing integers, representing the second matrix. Output: * A 2D list (List[List[int]]) containing integers, representing the product of the two matrices. Constraints: * The number of columns in `multiplicand` must equal the number of rows in `multiplier` to form a valid product. If this condition is not met, raise a `ValueError` with a message \\"Matrix dimensions are not compatible for multiplication.\\" * Matrix dimensions can be up to 500x500. Performance requirements: * Your solution should aim for better performance than the naive O(n^3) algorithm for large matrices. Example: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] output = optimized_multiply(multiplicand, multiplier) ``` Given the matrices above, `output` should be: ```python [ [58, 64], [139, 154] ] ``` **Note**: Make sure to handle edge cases, such as incompatible dimensions, properly and aim to improve performance, especially for larger matrices.","solution":"def optimized_multiply(multiplicand, multiplier): Multiplies two matrices using the Strassen algorithm for asymptotically faster matrix multiplication. def add_matrix(A, B): size = len(A) C = [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] return C def sub_matrix(A, B): size = len(A) C = [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] return C def strassen_multiply(A, B): n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] else: mid = n // 2 A11 = [[A[i][j] for j in range(mid)] for i in range(mid)] A12 = [[A[i][j] for j in range(mid, n)] for i in range(mid)] A21 = [[A[i][j] for j in range(mid)] for i in range(mid, n)] A22 = [[A[i][j] for j in range(mid, n)] for i in range(mid, n)] B11 = [[B[i][j] for j in range(mid)] for i in range(mid)] B12 = [[B[i][j] for j in range(mid, n)] for i in range(mid)] B21 = [[B[i][j] for j in range(mid)] for i in range(mid, n)] B22 = [[B[i][j] for j in range(mid, n)] for i in range(mid, n)] M1 = strassen_multiply(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_multiply(add_matrix(A21, A22), B11) M3 = strassen_multiply(A11, sub_matrix(B12, B22)) M4 = strassen_multiply(A22, sub_matrix(B21, B11)) M5 = strassen_multiply(add_matrix(A11, A12), B22) M6 = strassen_multiply(sub_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_multiply(sub_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(sub_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(sub_matrix(add_matrix(M1, M3), M2), M6) C = [[0] * n for _ in range(n)] for i in range(mid): for j in range(mid): C[i][j] = C11[i][j] C[i][j + mid] = C12[i][j] C[i + mid][j] = C21[i][j] C[i + mid][j + mid] = C22[i][j] return C def pad_matrix(matrix, size): padded_matrix = [[0] * size for _ in range(size)] for i in range(len(matrix)): for j in range(len(matrix[0])): padded_matrix[i][j] = matrix[i][j] return padded_matrix if not multiplicand or not multiplier: raise ValueError(\\"Matrices must not be empty\\") if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Matrix dimensions are not compatible for multiplication.\\") n = len(multiplicand) m = len(multiplicand[0]) p = len(multiplier[0]) new_size = max(n, m, p) new_size = 1 << (new_size - 1).bit_length() A = pad_matrix(multiplicand, new_size) B = pad_matrix(multiplier, new_size) result = strassen_multiply(A, B) final_result = [[result[i][j] for j in range(p)] for i in range(n)] return final_result"},{"question":"Minimum Value in Rotated Sorted Array Given an array sorted in ascending order and then possibly rotated at an unknown pivot, write a function to find the minimum element in this array. The array does not contain duplicates, and the solution should have a time complexity of O(log N). **Function Signature:** ```python def find_minimum(nums: List[int]) -> int: pass ``` # Input - The function takes one argument: - `nums` (List[int]): A list of integers sorted in ascending order and possibly rotated at an unknown pivot. The list will contain at least one element and no duplicates. # Output - Return an integer which is the minimum element in the given list. # Constraints - You must achieve the time complexity of O(log N). - The list does not contain duplicates. - The list contains at least one element. # Examples ```python assert find_minimum([3, 4, 5, 1, 2]) == 1 assert find_minimum([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_minimum([11, 13, 15, 17]) == 11 assert find_minimum([2]) == 2 ``` # Scenario & Context Imagine you are provided with usage data for an app, stored as an array of integers indicating user activity counts for each day, sorted by date but then rotated at some unknown pivot due to maintenance causing discontinuity. You need to write a function to find the day with the lowest activity count after the maintenance.","solution":"from typing import List def find_minimum(nums: List[int]) -> int: Function to find the minimum element in a rotated sorted array without duplicates. The time complexity should be O(log N). left, right = 0, len(nums) - 1 # Binary search approach while left < right: mid = left + (right - left) // 2 # If mid element is greater than the rightmost element, the min is to the right of mid if nums[mid] > nums[right]: left = mid + 1 else: # Otherwise, the min is to the left of mid or it is mid right = mid return nums[left]"},{"question":"# Question: Optimal Bucket Sort Implementation You are tasked to optimize and implement the bucket sort algorithm, as described below. Bucket sort works by distributing elements into several buckets and then sorting each bucket individually before combining the sorted buckets. # Requirements Function Signature ```python def bucket_sort(arr: List[float], num_buckets: int) -> List[float]: ``` Input * `arr`: A list of `n` floating-point numbers (0.0 <= arr[i] < 1.0). * `num_buckets`: An integer representing the number of buckets to be used. Output * Returns a list of elements sorted in non-decreasing order. # Constraints * The list can have up to `10^6` elements. * The number of buckets will be a positive integer and will not exceed the size of the input array. * You must handle the case where the input array is empty. # Performance Expectations * Optimize for time complexity better than O(n^2) whenever possible. * Minimize additional space usage while ensuring correctness. # Example ```python input_array = [0.78, 0.33, 0.53, 0.28, 0.84, 0.72, 0.91, 0.19, 0.65, 0.39] num_buckets = 5 print(bucket_sort(input_array, num_buckets)) # Expected Output: [0.19, 0.28, 0.33, 0.39, 0.53, 0.65, 0.72, 0.78, 0.84, 0.91] ``` # Guidelines * Implement the `bucket_sort` function using the bucket sorting approach as detailed in the provided code snippets. * Ensure your implementation handles edge cases like an empty list. * Explain any assumptions made and discuss potential optimizations in comments within your code.","solution":"from typing import List def bucket_sort(arr: List[float], num_buckets: int) -> List[float]: Sorts an array of floating-point numbers in the range [0.0, 1.0) using bucket sort. Parameters: arr (List[float]): The list of floating-point numbers to sort. num_buckets (int): The number of buckets to use for sorting. Returns: List[float]: The sorted list. if not arr: return [] # Create empty buckets buckets = [[] for _ in range(num_buckets)] # Distribute array elements into buckets for num in arr: # Compute the bucket index index = int(num * num_buckets) buckets[index].append(num) # Sort individual buckets and concatenate the results sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Question: Compute Binomial Coefficient You are given two non-negative integers n and k. Your task is to compute the binomial coefficient C(n, k), which denotes the number of ways to choose k elements from a set of n elements. You should implement the function using a recursive method. **Function Signature**: `def compute_binomial_coefficient(n: int, k: int) -> int:` # Input * `n (0 <= n <= 1000)`: The size of the set. * `k (0 <= k <= n)`: The number of elements to choose. # Output * An integer representing the binomial coefficient C(n, k). # Constraints * The input integers n and k will satisfy 0 <= k <= n. # Performance Requirements * Your implementation should have a time complexity of O(k). # Example ```python >>> compute_binomial_coefficient(5, 0) 1 >>> compute_binomial_coefficient(8, 2) 28 >>> compute_binomial_coefficient(500, 300) 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Implementation Notes * Use recursion and consider the properties of binomial coefficients to simplify the problem. * Ensure to handle the base cases and invalid inputs.","solution":"def compute_binomial_coefficient(n: int, k: int) -> int: This function computes the binomial coefficient C(n, k) using a recursive method. # Base cases if k == 0 or k == n: return 1 # Recursive case return compute_binomial_coefficient(n - 1, k - 1) + compute_binomial_coefficient(n - 1, k)"},{"question":"**Scenario**: You are developing an optimized insertion sort algorithm for use in your software that processes small-sized or nearly sorted datasets. To boost efficiency, particularly in finding the correct insertion points, you decide to integrate a binary search approach. **Task**: Implement a function `optimized_insertion_sort` that sorts an array of integers using the insertion sort algorithm with binary search for finding insertion points. **Function Signature**: ```python def optimized_insertion_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^5; -10^9 ≤ arr[i] ≤ 10^9). **Output**: - A list of integers sorted in non-decreasing order. **Constraints**: - Your implementation should use the helper method `search_insert` provided previously. - Avoid using any built-in sort functions. - Perform in-place sorting to address the space complexity requirement. **Performance Requirements**: - Even though the worst-case time complexity remains O(n^2), utilize binary search to optimize the insertion point search to O(log n) per insertion. **Example**: ```python # Given array arr = [4, 3, 2, 10, 12, 1, 5, 6] # Sorted array sorted_arr = optimized_insertion_sort(arr) print(sorted_arr) # Output: [1, 2, 3, 4, 5, 6, 10, 12] ``` **Hints**: 1. Use the provided `search_insert` function to determine the appropriate index for each element. 2. Make sure to shift the elements correctly after finding the insertion point.","solution":"from typing import List def search_insert(arr: List[int], val: int, start: int, end: int) -> int: Performs binary search to find the index at which val should be inserted to keep the array sorted from start to end. if start == end: if arr[start] > val: return start else: return start + 1 if start > end: return start mid = (start + end) // 2 if arr[mid] < val: return search_insert(arr, val, mid + 1, end) elif arr[mid] > val: return search_insert(arr, val, start, mid - 1) else: return mid def optimized_insertion_sort(arr: List[int]) -> List[int]: Sorts the array using an optimized insertion sort algorithm with binary search to find the correct insertion point. for i in range(1, len(arr)): key = arr[i] j = search_insert(arr, key, 0, i - 1) arr = arr[:j] + [key] + arr[j:i] + arr[i+1:] return arr"},{"question":"You are given a sorted array of integers and a target integer. Your task is to implement the `ternary_search` function to find the index of the target integer within the sorted array. If the target integer is found, return its index; otherwise, return -1. # Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ... ``` # Input - `left`: An integer, the left boundary of the search range (initially should be 0). - `right`: An integer, the right boundary of the search range (initially should be len(arr) - 1). - `key`: An integer, the value to be searched for in the array. - `arr`: A list of integers, sorted in ascending order. # Output - Return an integer, the index of the key if it is found in the array; otherwise, return -1. # Constraints 1. The array is non-empty and contains up to 10^5 elements. 2. The elements in the array are within the range [-10^9, 10^9]. 3. The array is sorted in ascending order. 4. The function should execute efficiently with a time complexity of O(log₃(N)). # Example ```python assert ternary_search(0, 4, 3, [1, 2, 3, 4, 5]) == 2 assert ternary_search(0, 6, 10, [-5, -4, 0, 2, 4, 8, 10]) == 6 assert ternary_search(0, 4, 9, [1, 2, 3, 4, 5]) == -1 ``` # Explanation 1. In the first example, the `key` value `3` is found at index `2`. 2. In the second example, the `key` value `10` is found at index `6`. 3. In the third example, the `key` value `9` is not in the array, so the function returns `-1`. Implement the function `ternary_search` using the provided template.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on a sorted array to find the index of the key. Parameters: left (int): The left boundary of the current search range. right (int): The right boundary of the current search range. key (int): The target value to find in the array. arr (List[int]): The sorted array of integers. Returns: int: The index of the key if found, otherwise -1. while right >= left: # Calculate the two mid points mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 # Check if the key is at one of the mid points if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 # Divide the search space into three parts if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 # Key was not found return -1"},{"question":"# Scenario You are tasked with sorting a large list of non-negative integers. You need to implement an efficient algorithm that can handle up to 100,000 integers, where the integers can be up to 10 digits long. Your solution should minimize both time and space complexity as much as possible. # Task Implement a function `optimized_radix_sort` that receives a list of non-negative integers and returns the sorted list. The function should incorporate optimizations for handling large datasets with varying digit lengths. # Function Signature ```python def optimized_radix_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` - A list of non-negative integers (0 <= arr[i] <= 9999999999, 0 <= len(arr) <= 100000) # Output A list of integers sorted in non-decreasing order. # Constraints 1. You are not allowed to use Python\'s built-in sort function. 2. Your implementation should be efficient both in terms of time (average-case O(nk)) and space. # Example ```python assert optimized_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert optimized_radix_sort([3, 6, 5, 4, 1, 2]) == [1, 2, 3, 4, 5, 6] assert optimized_radix_sort([]) == [] assert optimized_radix_sort([42]) == [42] ``` # Notes 1. Consider and handle edge cases explicitly. 2. Optimize the digit extraction process and minimize the use of extra space where possible. 3. Ensure stability of the sorting process.","solution":"from typing import List def optimized_radix_sort(arr: List[int]) -> List[int]: Returns the sorted list of non-negative integers using radix sort optimized for space and time. if not arr: # if the list is empty, return it as is return [] # Find the maximum number to determine the number of digits max_num = max(arr) exp = 1 # exponent to access each digit # While there are digits to process, iterate and sort while max_num // exp > 0: # Initialize buckets for each digit (0-9) buckets = [[] for _ in range(10)] for number in arr: # Find the digit at `exp` place digit = (number // exp) % 10 buckets[digit].append(number) # Flatten the list of buckets back into arr arr = [num for bucket in buckets for num in bucket] exp *= 10 # Move to the next digit place return arr"},{"question":"# Question Problem Statement You are given an array of integers, `nums`, where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to write a function, `single_number3`, that finds and returns the two elements that appear only once. Input Format - A list of integers, `nums`, where the number of elements is greater than or equal to two, and exactly two elements are unique while all others appear twice. Output Format - A list of two integers that appear only once in the input list. The order of the result is not important. Constraints 1. The list size is at least 2. 2. The list can contain both positive and negative integers. 3. Time complexity of the solution should be O(N). 4. Space complexity should be O(1). Examples **Example 1:** ```python Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] ``` **Example 2:** ```python Input: nums = [4, 1, 2, 1, 2, 5] Output: [4, 5] ``` **Example 3:** ```python Input: nums =[-1, 0, 0, 1] Output: [-1, 1] ``` Implementation Implement the function signature as follows: ```python def single_number3(nums): :type nums: List[int] :rtype: List[int] ``` Detailed Solution Steps 1. Use XOR to find `A^B`, where `A` and `B` are the two unique numbers. 2. Determine a bitmask by isolating the rightmost set bit of `A^B` to segregate numbers into two groups. 3. Use two separate XOR operations within each group to isolate the unique numbers `A` and `B`. Note: Ensure you handle bit manipulation correctly to avoid common pitfalls and efficiently segregate numbers into groups.","solution":"def single_number3(nums): Returns the two unique numbers in the list where all other numbers appear exactly twice. :type nums: List[int] :rtype: List[int] # Step 1: Get the XOR of the two unique numbers (A ^ B) xor_all = 0 for num in nums: xor_all ^= num # Step 2: Get the rightmost set bit (this bit is set in one unique number but not the other) rightmost_set_bit = xor_all & -xor_all # Step 3: Divide numbers into two groups and XOR each group to find the unique numbers unique1 = 0 unique2 = 0 for num in nums: if num & rightmost_set_bit: # Belongs to group 1 unique1 ^= num else: # Belongs to group 2 unique2 ^= num return [unique1, unique2]"},{"question":"You are given a partially implemented class `OrderedStack` that maintains elements in a descending order (highest value on top) and provides standard stack operations. Your task is to complete the implementation of the `OrderedStack` and write a function `sort_stack(cls, stack: OrderedStack) -> OrderedStack`. This function takes an `OrderedStack` instance containing unordered elements and returns a new `OrderedStack` with elements in descending order. # Function Signature: ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) @classmethod def sort_stack(cls, stack: OrderedStack) -> OrderedStack: # Your code to sort the stack pass ``` # Input: The function `sort_stack` will receive an instance of `OrderedStack` that may contain an unordered sequence of integers. # Output: The function should return a new `OrderedStack` instance containing the elements sorted in descending order. # Constraints: 1. Do not use any built-in sorting functions. 2. Only the stack operations defined in the `OrderedStack` class may be used to manipulate the stack. # Example: ```python input_stack = OrderedStack() input_stack.push_t(3) input_stack.push_t(1) input_stack.push_t(2) sorted_stack = OrderedStack.sort_stack(input_stack) # Output stack should have the elements in descending order: # sorted_stack.items -> [3, 2, 1] ``` # Performance Requirements: Ensure that the function efficiently manages the sorting given the constraints on stack operations.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items) @classmethod def sort_stack(cls, stack: \'OrderedStack\') -> \'OrderedStack\': temp_stack = OrderedStack() while not stack.is_empty(): # Pop out the first element tmp = stack.pop() # While temporary stack is not empty and top # of stack is greater than temp while not temp_stack.is_empty() and temp_stack.peek() < tmp: stack.push_t(temp_stack.pop()) # push temp in temporary of stack temp_stack.push_t(tmp) return temp_stack"},{"question":"Problem Statement Write a function `minimum_edit_distance(source, target)` that computes the edit distance between two given strings `source` and `target`. The edit distance is the minimum number of single-character insertions, deletions, and substitutions required to transform `source` into `target`. # Input - `source` (string): The original string. - `target` (string): The string to which we want to transform the source string. # Output - (int): The minimum number of operations required to transform `source` into `target`. # Constraints - (0 leq text{len(source)}, text{len(target)} leq 1000) - All characters in the input strings are lowercase English letters. # Example ```python # Example 1 source = \\"intention\\" target = \\"execution\\" # The minimum edit distance is 5 assert minimum_edit_distance(source, target) == 5 # Example 2 source = \\"kitten\\" target = \\"sitting\\" # The minimum edit distance is 3 assert minimum_edit_distance(source, target) == 3 ``` # Function Signature ```python def minimum_edit_distance(source: str, target: str) -> int: pass ``` # Explanation 1. Construct a 2D table where `edit[i][j]` represents the minimum edit distance between `source[0..i-1]` and `target[0..j-1]`. 2. Initialize the first row and first column with incremental values. 3. Fill the table using the recurrence relation: [ edit[i][j] = min(edit[i-1][j] + 1, edit[i][j-1] + 1, edit[i-1][j-1] + cost) ] where `cost` is 0 if `source[i-1] == target[j-1]`, otherwise cost is 1. 4. The value at `edit[len(source)][len(target)]` is the result. Implement the function `minimum_edit_distance` to compute the minimum edit distance between two given strings `source` and `target`.","solution":"def minimum_edit_distance(source, target): Computes the edit distance between two given strings source and target. The edit distance is the minimum number of single-character insertions, deletions, and substitutions required to transform source into target. m, n = len(source), len(target) # Create a dp table where dp[i][j] represents the edit distance between # source[0..i-1] and target[0..j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp table for i in range(m + 1): dp[i][0] = i # Cost of deleting all characters from source for j in range(n + 1): dp[0][j] = j # Cost of inserting all characters to target # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[m][n]"},{"question":"# Context You are tasked with adding functionality to an existing numerical conversion library. This library must convert numbers between different bases efficiently and handle edge cases gracefully. # Task Your job is to implement two primary functions: `int_to_base` and `base_to_int`. These functions will facilitate conversion between an integer and its string representation in a specified base. # Function Specifications 1. `int_to_base(num, base)`: - **Input**: - `num` (int): The integer to convert. - `base` (int): The base to which `num` should be converted (between 2 and 36 inclusive). - **Output**: - A string representing `num` in the specified base. 2. `base_to_int(str_to_convert, base)`: - **Input**: - `str_to_convert` (str): The string representation of the number in the specified base. - `base` (int): The base of the number string (between 2 and 36 inclusive). - **Output**: - The integer representation of the base-encoded string. # Constraints - `num` can be any integer (negative, zero, or positive). - `str_to_convert` will only contain valid characters for the given base. - The base will always be between 2 and 36 inclusive. # Examples ```python int_to_base(5, 2) # Returns \'101\' int_to_base(-15, 16) # Returns \'-F\' base_to_int(\'101\', 2) # Returns 5 base_to_int(\'-F\', 16) # Returns -15 ``` # Performance Requirements - Ensure your implementations handle edge cases, such as zero or negative inputs, and very large numbers. - Aim for concise and efficient code considering time and space complexity. # Edge Cases to Handle - Zero as input - Negative numbers - Handling invalid base values outside the provided constraints is not required. Write your implementations below: ```python def int_to_base(num, base): # Your code here def base_to_int(str_to_convert, base): # Your code here ```","solution":"def int_to_base(num, base): Convert an integer to its string representation in a specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \\"-\\" if num < 0 else \\"\\" num = abs(num) result = [] while num: num, remainder = divmod(num, base) result.append(digits[remainder]) return sign + \'\'.join(reversed(result)) def base_to_int(str_to_convert, base): Convert a string representation of a number in a specified base to an integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num_map = {char: index for index, char in enumerate(digits)} sign = -1 if str_to_convert[0] == \'-\' else 1 if str_to_convert[0] in (\'-\', \'+\'): str_to_convert = str_to_convert[1:] num = 0 for char in str_to_convert: num = num * base + num_map[char] return sign * num"},{"question":"# Assessment Question: Implement Red-Black Tree Operations **Objective**: Design an efficient red-black tree (RBTree) with additional functionalities to test understanding of balancing binary search trees. **Problem Statement**: You are required to extend the implementation of the Red-Black Tree provided. The RBTree must support a function to return the node with the kth smallest value. Implement the `kth_smallest_node` function which takes an integer k and returns the kth smallest node from the tree. # Requirements: 1. **Function Signature**: ```python def kth_smallest_node(self, k: int) -> \'RBNode\': pass ``` 2. **Expected Input and Output**: - **Input**: An integer `k` such that 1 ≤ k ≤ number of nodes in the tree. - **Output**: The kth smallest node (RBNode). 3. **Constraints**: - The tree will contain unique values. - The function should have O(log n) time complexity for the average case. # Detailed Instructions: 1. **Input Parsing**: Implement `kth_smallest_node` to validate and process the input value of `k`. 2. **Traversal**: Utilize in-order traversal to count nodes efficiently. 3. **Location**: Maintain tree balance properties to ensure that accessing the kth smallest node is efficient. 4. **Edge Cases**: Handle edge cases where k is either at the extreme ends of the allowed range. 5. **Additional Constraints**: Ensure no additional dependencies are introduced. # Example Scenario: ```python rb = RBTree() values = [20, 10, 30, 5, 15, 25, 35] for value in values: node = RBNode(value, is_red=True) rb.insert(node) # Finding 3rd smallest node kth_node = rb.kth_smallest_node(3) print(kth_node.val) # Expected Output: 15 ``` # Note: - Ensure that the complete Red-Black Tree functionality remains intact supporting balanced insertion and deletion. - Test your implementation thoroughly with edge cases and provide comments for clarity. **Hint**: Utilize properties of the Red-Black tree and efficient traversal to achieve the required time complexity.","solution":"class RBNode: def __init__(self, val, is_red=True, left=None, right=None, parent=None): self.val = val self.is_red = is_red self.left = left self.right = right self.parent = parent self.size = 1 # Size of subtree rooted at this node class RBTree: def __init__(self): self.NIL_LEAF = RBNode(val=None, is_red=False) self.root = self.NIL_LEAF def insert(self, node): if self.root == self.NIL_LEAF: self.root = node self.root.is_red = False self.root.parent = self.NIL_LEAF self.root.left = self.NIL_LEAF self.root.right = self.NIL_LEAF else: self._insert_node(self.root, node) self._fix_insert(node) self._update_size(node) def _insert_node(self, current, node): if node.val < current.val: if current.left == self.NIL_LEAF: current.left = node node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF else: self._insert_node(current.left, node) else: if current.right == self.NIL_LEAF: current.right = node node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF else: self._insert_node(current.right, node) def _fix_insert(self, node): # Fixing logic (not fully implemented here, as it\'s not critical for kth smallest) pass def _update_size(self, node): while node != self.NIL_LEAF: node.size = 1 + (self._size(node.left) if node.left != self.NIL_LEAF else 0) + (self._size(node.right) if node.right != self.NIL_LEAF else 0) node = node.parent def _size(self, node): return node.size if node != self.NIL_LEAF else 0 def kth_smallest_node(self, k: int): if self.root == self.NIL_LEAF: return None return self._kth_smallest(self.root, k) def _kth_smallest(self, node, k): left_size = self._size(node.left) if k == left_size + 1: return node elif k <= left_size: return self._kth_smallest(node.left, k) else: return self._kth_smallest(node.right, k - left_size - 1)"},{"question":"# Scenario You are given a singly linked list and tasked with implementing functions related to identifying whether the list is sorted in increasing order and performing insertions while maintaining its sorted property. This is useful in scenarios such as maintaining a priority queue represented by a linked list where new elements get inserted while keeping the order intact. # Question Write the following two functions: 1. **is_sorted(head)**: * Given the head of a singly linked list, return `True` if the list is sorted in non-decreasing order, and `False` otherwise. * **Input**: * `head` (Node): The head node of the linked list, or None if the list is empty. * **Output**: * `bool`: True if the linked list is sorted, otherwise False. * **Constraints**: The list contains integers and can be empty. 2. **insert_sorted(head, value)**: * Insert a new node with the given value into the linked list in its correct position to maintain the sorted order. * **Input**: * `head` (Node): The head node of the linked list, or None if the list is empty. * `value` (int): The value of the new node to be inserted. * **Output**: * `Node`: The head node of the modified linked list. * **Constraints**: * The list is already sorted. # Example ```python # Define the linked list node class class Node: def __init__(self, val=0, next=None): self.val = val self.next = next # List: 1 -> 2 -> 3 -> 4 head = Node(1, Node(2, Node(3, Node(4)))) assert is_sorted(head) == True # Inserting 2.5 into the list: 1 -> 2 -> 2.5 -> 3 -> 4 new_head = insert_sorted(head, 2.5) assert is_sorted(new_head) == True ``` # Notes - Include necessary helper functions, if any, to support the main functions. - Ensure your solutions handle edge cases such as empty lists and insertion into the beginning or end of the list.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Returns True if the linked list is sorted in non-decreasing order, False otherwise. # If the list is empty or has only one element, it is considered sorted if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True def insert_sorted(head, value): Inserts a new node with the given value into the linked list in its correct position to maintain the sorted order. new_node = Node(value) # Special case for the head end if not head or head.val >= value: new_node.next = head return new_node current = head while current.next and current.next.val < value: current = current.next new_node.next = current.next current.next = new_node return head"},{"question":"Context: You are working on a software module that deals with number theory-related computations, and part of your task involves ensuring proper handling and optimization for GCD and LCM calculations. The existing functions need enhancement to handle edge cases and ensure better performance with larger inputs. Task: Implement an enhanced version of the `lcm` and `trailing_zero` functions that: 1. **Ensure robustness** in accepting and properly handling edge cases as described: - If the input integer is zero or negative, return respective expected behavior. - **For `lcm`**, handle large integer values correctly. - **For `trailing_zero`**, ensure correct handling and proper error messaging for non-positive integers. 2. **Enhance performance** where possible, especially for large input values. 3. Ensure the overall correctness of the algorithm. Specifications: 1. **Function 1**: Enhanced LCM Calculation **Function Signature**: `def enhanced_lcm(a, b):` **Input**: - `a` (integer): A non-zero integer. - `b` (integer): Another non-zero integer. **Output**: - An integer representing the least common multiple of `a` and `b`. **Constraints**: - -10^18 ≤ a, b ≤ 10^18 - Either `a` or `b` may be negative. 2. **Function 2**: Enhanced Trailing Zero Counter **Function Signature**: `def enhanced_trailing_zero(x):` **Input**: - `x` (integer): A non-negative integer. **Output**: - An integer representing the number of trailing zeros in the binary representation of `x`. **Constraints**: - 0 ≤ x ≤ 10^18 Example: 1. For `enhanced_lcm`: ```python print(enhanced_lcm(6, 8)) # Output should be 24 print(enhanced_lcm(-15, 25)) # Output should be 75 ``` 2. For `enhanced_trailing_zero`: ```python print(enhanced_trailing_zero(40)) # Output should be 3 print(enhanced_trailing_zero(0)) # Output should be 0 ``` Notes: - Handle any edge cases appropriately. - Don’t forget to optimize for performance and correctness.","solution":"import math def enhanced_lcm(a, b): Returns the least common multiple (LCM) of two integers a and b. If either a or b is zero, returns 0. Supports negative values by treating them as their absolute values. if a == 0 or b == 0: return 0 a, b = abs(a), abs(b) return abs(a // math.gcd(a, b) * b) def enhanced_trailing_zero(x): Returns the number of trailing zeros in the binary representation of x. If x is non-positive, it returns 0. if x <= 0: return 0 count = 0 while x & 1 == 0: count += 1 x >>= 1 return count"},{"question":"# Problem: Resizing Separate Chaining Hash Table Imagine you are tasked with enhancing the provided `SeparateChainingHashTable` class to include an automatic resizing mechanism. The resizing should happen when the load factor (number of elements / table size) exceeds a certain threshold. When resizing, the table size should double, and all existing entries should be rehashed to the new table. **Your task** is to implement the resize mechanism in the `SeparateChainingHashTable`. # Requirements 1. **Method to Implement**: `resize()` 2. **Trigger for Resizing**: When load factor exceeds 0.75. 3. **New Table Size**: The table size should double when resizing. 4. **Rehash Entries**: All existing entries must be rehashed into the new resized table. You may add the `resize` method within the provided `SeparateChainingHashTable` class framework. Ensure all new elements are correctly placed in the new table. # Function Signature ```python def resize(self): pass ``` # Constraints * The hash function provided should be used. * All public methods (`put`, `get`, `del_`) must continue to function correctly after resizing. * You may assume all keys are hashable and keys/values are not `None`. # Example Suppose you have inserted 10 elements into the table of size 11 resulting in a load factor of 10/11 (~0.91). In such a case, the table should resize, doubling the size to 22 and rehashing all elements into this new table. Here is an example snippet demonstrating interaction (not including resize logic): ```python table = SeparateChainingHashTable() for i in range(10): table.put(f\'key{i}\', f\'value{i}\') assert len(table) == 10 assert table.size == 22 # After resize due to exceeding load factor ``` # Testing Ensure comprehensive coverage by considering edge cases like: * Inserting up to and beyond the resizing threshold. * Checking all methods (`put`, `get`, `del_`) work as expected before and after resizing. * Handling empty and non-empty tables.","solution":"class Node: def __init__(self, key, value, next_=None): self.key = key self.value = value self.next = next_ class SeparateChainingHashTable: def __init__(self, initial_capacity=11): self.size = initial_capacity self.table = [None] * self.size self.num_elements = 0 self.load_factor_threshold = 0.75 def _hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self._hash(key) head = self.table[idx] # Check if the key exists and update while head: if head.key == key: head.value = value return head = head.next # Insert new node new_node = Node(key, value, self.table[idx]) self.table[idx] = new_node self.num_elements += 1 # Check if resize is needed if self.num_elements / self.size > self.load_factor_threshold: self.resize() def get(self, key): idx = self._hash(key) head = self.table[idx] while head: if head.key == key: return head.value head = head.next return None def del_(self, key): idx = self._hash(key) head = self.table[idx] prev = None while head: if head.key == key: if prev: prev.next = head.next else: self.table[idx] = head.next self.num_elements -= 1 return prev = head head = head.next def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.num_elements = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def __len__(self): return self.num_elements"},{"question":"# Removing Excess Occurrences You are given a list of integers and an integer N. Your task is to ensure that no element in the list appears more than N times, while maintaining the original order of the list. Write a function `limit_occurrences(lst, N)` that takes a list `lst` and an integer `N`, and returns a new list where each element appears no more than N times. # Input - `lst`: A list of integers (0 <= len(lst) <= 10^5, 0 <= lst[i] <= 10^9) - `N`: An integer (0 <= N <= 10^5) # Output - A list of integers with the conditions specified above. # Constraints - The order of elements in the new list must be the same as their order in the input list. - Elements in the new list must not appear more than N times. - If N is 0, the output list should be empty. # Example ```python limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], N=2) # Output: [1, 2, 3, 1, 2, 3] ``` # Additional Information - Your solution should handle edge cases efficiently. - Aim for a solution with O(n) time complexity if possible. **Function Signature**: `def limit_occurrences(lst, N):` You should implement the function and test it with the given example to ensure its correctness.","solution":"def limit_occurrences(lst, N): Ensures that no element in the list appears more than N times, while maintaining the original order of the list. if N == 0: return [] occurrence_count = {} result = [] for element in lst: if occurrence_count.get(element, 0) < N: result.append(element) occurrence_count[element] = occurrence_count.get(element, 0) + 1 return result"},{"question":"# Encoding and Decoding Strings for Network Transmission Objective Your task is to implement two functions, `encode` and `decode`, which encode a list of strings to a single string for efficient network transmission, and decode the single string back to the original list of strings. Requirements 1. `encode(strs: List[str]) -> str`: * Encodes a list of strings to a single string where each string is prefixed by its length followed by a colon `:` and then the string contents. * Example: ```python Input: [\\"hello\\", \\"world\\"] Output: \\"5:hello5:world\\" ``` 2. `decode(s: str) -> List[str]`: * Decodes a previously encoded string back to the original list of strings. * Example: ```python Input: \\"5:hello5:world\\" Output: [\\"hello\\", \\"world\\"] ``` Constraints * Strings can contain any printable characters, including spaces and special characters. * The length of each string in the list is between 0 and 10,000. * The total number of strings in the list does not exceed 1000. Additional Considerations * Ensure your solution handles edge cases effectively, such as: * Empty strings. * Strings containing colons. * Optimize for readability and efficiency. Example Below are examples of the function usage: ```python # Example 1: encoded = encode([\\"hello\\", \\"world\\"]) print(encoded) # Output: \\"5:hello5:world\\" decoded = decode(encoded) print(decoded) # Output: [\\"hello\\", \\"world\\"] # Example 2: encoded = encode([\\"\\", \\"still\\", \\"works\\"]) print(encoded) # Output: \\"0:5:still5:works\\" decoded = decode(encoded) print(decoded) # Output: [\\"\\", \\"still\\", \\"works\\"] ``` Implement the `encode` and `decode` functions below: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your implementation here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your implementation here ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_str = \'\'.join(f\\"{len(s)}:{s}\\" for s in strs) return encoded_str def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i = 0 decoded_strs = [] while i < len(s): colon_index = s.find(\':\', i) length = int(s[i:colon_index]) i = colon_index + 1 + length decoded_strs.append(s[colon_index + 1:i]) return decoded_strs"},{"question":"Implement and Extend Caesar Cipher Context You have learned about the Caesar cipher and how it encrypts text by shifting characters. Now, as an exercise, you will implement the Caesar cipher and extend it to handle decryption as well. Objective Write functions to encrypt and decrypt text using the Caesar cipher. Tasks 1. **Implement the encryption function `caesar_cipher_encrypt(s, k)`**: - **Input**: - `s`: string (the input text to encrypt). - `k`: integer (the shift value). - **Output**: string (the encrypted text). 2. **Implement the decryption function `caesar_cipher_decrypt(s, k)`**: - **Input**: - `s`: string (the encrypted text to decrypt). - `k`: integer (the shift value). - **Output**: string (the decrypted text). Constraints - All characters in the input strings are ASCII characters. - Shifts can be positive or negative integers. Examples ```python >>> caesar_cipher_encrypt(\'hello, World!\', 3) \'khoor, Zruog!\' >>> caesar_cipher_decrypt(\'khoor, Zruog!\', 3) \'hello, World!\' >>> caesar_cipher_encrypt(\'Example\', 0) \'Example\' >>> caesar_cipher_decrypt(\'Example\', 0) \'Example\' >>> caesar_cipher_encrypt(\'abc\', -3) \'xyz\' >>> caesar_cipher_decrypt(\'xyz\', -3) \'abc\' ``` Requirements and Performance - Handle both uppercase and lowercase letters correctly. - Non-alphabetical characters should remain unchanged. - The function should correctly handle negative and large shifts.","solution":"def caesar_cipher_encrypt(s, k): Encrypts the input text s using Caesar cipher with a shift of k. encrypted_text = [] for char in s: if char.isalpha(): base = ord(\'A\') if char.isupper() else ord(\'a\') encrypted_char = chr((ord(char) - base + k) % 26 + base) encrypted_text.append(encrypted_char) else: encrypted_text.append(char) return \'\'.join(encrypted_text) def caesar_cipher_decrypt(s, k): Decrypts the input text s using Caesar cipher with a shift of k. return caesar_cipher_encrypt(s, -k)"},{"question":"# Question: Improved Insertion Sort You are provided with a simple implementation of the Insertion Sort algorithm. Your task is to optimize the Insertion Sort implementation to use Binary Search to find the correct position to insert each element. This should improve the time complexity of insertions from O(n) to O(log n). Detailed Description: - You should write a function `binary_insertion_sort(arr, simulation=False)` which accepts an array `arr` and a boolean flag `simulation`. - If `simulation` is `True`, the function should print the array at each iteration. Function Signature ```python def binary_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input and Output Formats * **Input**: - A list of integers `arr`, containing `n` elements. - An optional boolean `simulation` which defaults to `False`. * **Output**: - The sorted list should be returned. Constraints: - The length of `arr` (n) will be in the range 0 <= n <= 1000. - The elements of `arr` will be in the range -10^6 <= arr[i] <= 10^6. Example: *Example 1*: ```python arr = [12, 4, 3, 8, 4] print(binary_insertion_sort(arr)) # Output: [3, 4, 4, 8, 12] *Example 2*: ```python arr = [1, 2, 3, 4, 5] print(binary_insertion_sort(arr, simulation=True)) # Expected Output (similar to): # iteration 0 : 1 2 3 4 5 # iteration 1 : 1 2 3 4 5 # iteration 2 : 1 2 3 4 5 # iteration 3 : 1 2 3 4 5 # [1, 2, 3, 4, 5] ```","solution":"from typing import List def binary_search(arr, val, start, end): Helper function to perform binary search. Find the index where \'val\' should be inserted to keep \'arr\' sorted. if start == end: if arr[start] > val: return start else: return start + 1 if start > end: return start mid = (start + end) // 2 if arr[mid] < val: return binary_search(arr, val, mid + 1, end) elif arr[mid] > val: return binary_search(arr, val, start, mid - 1) else: return mid def binary_insertion_sort(arr: List[int], simulation: bool = False) -> List[int]: for i in range(1, len(arr)): val = arr[i] j = binary_search(arr, val, 0, i - 1) arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] if simulation: print(f\'iteration {i-1} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"Extended Ternary Search with Range You are given a sorted array of integers and a target integer. Implement an extended version of the ternary search algorithm that not only finds the target integer in the array but also returns the range of the indices where the target integer appears. If the target integer is not present, return `[-1, -1]`. Function Signature ```python def extended_ternary_search(arr: List[int], key: int) -> List[int]: ``` Input * `arr`: A sorted list of integers in ascending order. `1 <= len(arr) <= 10^5` * `key`: An integer to search for in the list. `-10^9 <= key <= 10^9` Output * A list of two integers representing the starting and ending indices of the range where the target integer appears in the array. If the target is not found, return `[-1, -1]`. Constraints * The array will contain at most `10^5` elements. * The algorithm needs to perform efficiently within the constraints. Example ```python assert extended_ternary_search([1, 2, 2, 2, 3, 4, 5], 2) == [1, 3] assert extended_ternary_search([1, 2, 3, 4, 5], 6) == [-1, -1] assert extended_ternary_search([1, 1, 1, 1, 1], 1) == [0, 4] assert extended_ternary_search([5], 5) == [0, 0] ``` Task 1. Implement an efficient `extended_ternary_search` using the principles of ternary search. 2. Ensure your function handles edge cases and performs efficiently within the provided constraints.","solution":"from typing import List def extended_ternary_search(arr: List[int], key: int) -> List[int]: def find_first(arr, key): low, high = 0, len(arr) - 1 first_occurrence = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == key: first_occurrence = mid high = mid - 1 elif arr[mid] < key: low = mid + 1 else: high = mid - 1 return first_occurrence def find_last(arr, key): low, high = 0, len(arr) - 1 last_occurrence = -1 while low <= high: mid = (low + high) // 2 if arr[mid] == key: last_occurrence = mid low = mid + 1 elif arr[mid] < key: low = mid + 1 else: high = mid - 1 return last_occurrence first = find_first(arr, key) if first == -1: return [-1, -1] last = find_last(arr, key) return [first, last]"},{"question":"Context: Stooge Sort is a recursive and inefficient sorting algorithm primarily used for educational purposes to illustrate recursion and divide-and-conquer techniques. Given its exponential time complexity, it’s not used in practice but understanding its working can enhance comprehension of recursive algorithms. Problem Statement: You are to implement the Stooge Sort algorithm as defined below. Given an array of integers, sort it in increasing order using Stooge Sort. Function Signature: ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your code goes here ``` Input: * `arr`: A list of integers to be sorted. (0 <= len(arr) <= 100, -10^6 <= arr[i] <= 10^6) * `l`: Starting index of the portion of the array to be sorted. * `h`: Ending index of the portion of the array to be sorted. Output: * Modifies the list `arr` in place, sorting it in non-decreasing order. Constraints: * Do not use built-in sort functions. * Ensure to handle all edge cases and constraints efficiently. Example: ```python array = [4, 3, 2, 1] stoogesort(array, 0, len(array) - 1) print(array) # Output: [1, 2, 3, 4] array = [1, 3, 64, 5, 7, 8] stoogesort(array, 0, len(array) - 1) print(array) # Output: [1, 3, 5, 7, 8, 64] ``` Explanation: The implemented Stooge Sort recursively divides the array into smaller parts and sorts them by comparing and potentially swapping elements. The crucial part is ensuring correct index handling and exhaustive testing on various array configurations.","solution":"def stoogesort(arr: list[int], l: int, h: int) -> None: Sorts the array arr[l:h+1] using Stooge Sort algorithm. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"# Flatten Nested Arrays You are tasked with implementing a function `flatten_array` that converts a nested array into a single, flat array. The function should handle arbitrary levels of nested arrays and maintain the order of elements. There are two versions to implement: one using a recursive approach and another using a generator for lazy evaluation. # Implement the following two functions: 1. **flatten_array_recursive(input_arr: List[Any]) -> List[Any]** This function takes a nested list as input and returns a flat list. **Input**: - input_arr: a list which may contain nested lists. **Output**: - A single, flat list containing all the elements of the nested input array. **Constraints**: - You can assume that the input list contains only lists or basic data types (integers, floats, strings). 2. **flatten_array_generator(input_arr: Iterable) -> Iterator[Any]** This function takes a nested iterable as input and returns an iterator that yields elements of the flattened input. **Input**: - input_arr: an iterable which may contain nested iterables. **Output**: - An iterator that yields elements of the flattened input array. **Constraints**: - You can assume that the input iterable contains only iterables or basic data types (integers, floats, strings). # Examples: ```python # Example for flatten_array_recursive function input_arr = [1, [2, [3, 4]], 5] print(flatten_array_recursive(input_arr)) # Output: [1, 2, 3, 4, 5] # Example for flatten_array_generator function input_arr = [1, [2, [3, 4]], 5] print(list(flatten_array_generator(input_arr))) # Output: [1, 2, 3, 4, 5] ``` # Performance Requirements: - Both functions should handle large and deeply nested structures efficiently. - Ensure that the generator version uses memory efficiently by yielding items lazily.","solution":"from typing import List, Any, Iterable, Iterator def flatten_array_recursive(input_arr: List[Any]) -> List[Any]: Converts a nested list into a single, flat list. result = [] for item in input_arr: if isinstance(item, list): result.extend(flatten_array_recursive(item)) else: result.append(item) return result def flatten_array_generator(input_arr: Iterable) -> Iterator[Any]: Converts a nested iterable into a single, flat iterable (iterator). for item in input_arr: if isinstance(item, Iterable) and not isinstance(item, (str, bytes)): yield from flatten_array_generator(item) else: yield item"},{"question":"**Objective** Implement a function to perform an in-place right rotation of elements in an array. You are required to demonstrate an efficient understanding of array manipulation without using extra space. **Prompt** A common problem is rotating an array\'s elements to the right by `k` steps. Given an array of `n` elements and an integer `k`, write a function that rotates the array to the right by `k` steps. **Requirements** - The function should modify the array in-place. - Do not use any additional array or list data structures. - Optimize for both time and space complexity. **Function Signature** ```python def rotate_in_place(array: List[int], k: int) -> None: Rotate the array to the right by k steps in-place. :param array: List[int] - Input array (non-empty) :param k: int - Number of steps to rotate (k >= 0) :rtype: None - Do not return anything, modify array in-place. pass ``` **Input** - An array of integers, `array`, with length `n` (1 ≤ n ≤ 10^5). - A non-negative integer `k` (0 ≤ k ≤ 10^5). **Output** - The function does not return anything. The input array should be modified in-place to reflect the rotation. **Examples** ```python # Example 1 arr1 = [1, 2, 3, 4, 5, 6, 7] rotate_in_place(arr1, 3) # Output: arr1 is modified to [5, 6, 7, 1, 2, 3, 4] # Example 2 arr2 = [-1, -100, 3, 99] rotate_in_place(arr2, 2) # Output: arr2 is modified to [3, 99, -1, -100] ``` **Constraints** - Handle edge cases such as empty arrays, arrays of a single element, and large values of `k` efficiently. - Ensure the function runs with a time complexity better than O(nk) and maintains an in-place approach. **Hint** - Consider methods that involve reversing parts of the array as a way to simplify the rotation logic.","solution":"def rotate_in_place(array, k): Rotate the array to the right by k steps in-place. :param array: List[int] - Input array (non-empty) :param k: int - Number of steps to rotate (k >= 0) :rtype: None - Do not return anything, modify array in-place. n = len(array) k = k % n # To handle the case when k > n if k == 0 or n == 1: return # Helper function to reverse a portion of the array def reverse(start, end): while start < end: array[start], array[end] = array[end], array[start] start, end = start + 1, end - 1 # Step 1: Reverse the whole array reverse(0, n - 1) # Step 2: Reverse the first k elements reverse(0, k - 1) # Step 3: Reverse the rest of the array reverse(k, n - 1)"},{"question":"# Question: Bitonic Sorting with Validations Context The bitonic sort algorithm is known for its effective parallel sorting capabilities, making it a prime candidate for sorting in distributed or multi-core environments. Given its unique property of requiring the array size to be a power of two, this algorithm leverages a divide-and-conquer approach to recursively split, sort, and merge sequences. Task Write a function to implement the bitonic sort algorithm. However, you must include additional validations and improvements: 1. Adapt the algorithm to work with arrays whose sizes are not powers of two by padding the array with `None` values. 2. Improve efficiency of the compare-step by using in-place operations and reduce additional memory consumption. 3. Ensure your implementation can handle both ascending and descending orders as specified by a boolean flag. Function Signature ```python def enhanced_bitonic_sort(arr: list, reverse: bool = False) -> list: pass ``` Input * `arr`: A list of integers to be sorted. Can have arbitrary size (not necessarily a power of two). * `reverse`: A boolean flag. If `True`, sort the array in ascending order. If `False`, sort the array in descending order. Output * Returns a sorted list of integers in the specified order. Constraints * Do not use built-in sorting functions. * Handle the non-power-of-two size property by padding the array if necessary. * Optimize in-place operations to minimize additional memory usage. Example ```python assert enhanced_bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5]) == [1, 2, 3, 4, 5, 6, 7, 8] assert enhanced_bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5], reverse=True) == [8, 7, 6, 5, 4, 3, 2, 1] assert enhanced_bitonic_sort([1, 3, 5, 2, 4, 6, 8, 7, 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Edge Cases * Empty arrays should return an empty list. * Arrays with a single element should return the same single-element list. * Handle arrays whose sizes are not powers of two by appropriately padding and then removing the padding after sorting. Use efficient in-place operations wherever possible to ensure optimized performance.","solution":"def enhanced_bitonic_sort(arr: list, reverse: bool = False) -> list: def bitonic_compare_and_swap(arr, low, cnt, direction): k = cnt // 2 for i in range(low, low + k): if (direction == (arr[i] > arr[i + k])): arr[i], arr[i + k] = arr[i + k], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: bitonic_compare_and_swap(arr, low, cnt, direction) k = cnt // 2 bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) # sort in ascending order bitonic_sort(arr, low + k, k, False) # sort in descending order bitonic_merge(arr, low, cnt, direction) n = len(arr) if n == 0: return [] # Next power of 2 size = 1 while size < n: size *= 2 # Pad with None values padded_arr = arr + [None] * (size - n) # Replace padding with maximum/minimum values based on direction fill_value = float(\'-inf\') if reverse else float(\'inf\') for i in range(n, size): padded_arr[i] = fill_value # Perform bitonic sort bitonic_sort(padded_arr, 0, size, not reverse) return padded_arr[:n]"},{"question":"# Linked List k-th to Last Element You are provided with a linked list and an integer k. Your task is to implement a function `find_kth_to_last` that finds the k-th to last element of the linked list. # Requirements * Implement the function `find_kth_to_last(head: Node, k: int) -> Node` where: - `head` is the head node of a singly linked list. - `k` is an integer representing the position from the end of the list. - The function returns the k-th to the last node or raises an `IndexError` if k is invalid. # Input * `head` (Node): The head of the singly linked list. * `k` (int): The k-th position from the end (1-based index). # Output * Returns the node which is k-th to the last in the linked list. # Constraints * `k` will be a non-negative integer. * The linked list will have at most `10^5` nodes. # Examples ``` # Example Linked List: A -> B -> C -> D -> E -> F -> G Input: head = Node(\\"A\\"), k = 3 Output: Node with value \\"E\\" Input: head = Node(\\"A\\"), k = 1 Output: Node with value \\"G\\" Input: head = Node(\\"A\\"), k = 7 Output: Node with value \\"A\\" Input: head = Node(\\"A\\"), k = 8 Output: IndexError ``` # Notes - Focus on optimizing for both time and space to handle large lists efficiently. - Safeguard against invalid input by performing necessary checks. # Function Signature ```python def find_kth_to_last(head: Node, k: int) -> Node: pass ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None def find_kth_to_last(head: Node, k: int) -> Node: Returns the k-th to last element of a linked list. Raises an IndexError if k is out of bounds. if k <= 0: raise IndexError(\\"k must be a positive integer.\\") # Use two-pointer technique first = head second = head # Move first pointer k steps ahead for _ in range(k): if not first: raise IndexError(\\"k is larger than the length of the linked list.\\") first = first.next # Move both pointers until the first pointer reaches the end while first: first = first.next second = second.next return second"},{"question":"You are given an array of integers that needs to be sorted. Your task is to implement the Stooge Sort algorithm as described. This sorting algorithm, although inefficient, must be used to understand the concept of recursive sorting techniques. Input: - An array of integers `arr` of length `n` where (1 leq n leq 100). Output: - The sorted array in non-decreasing order. Constraints: - The values within the array (arr) will fit in a 32-bit integer. # Scenario: You have been tasked with sorting arrays for a theoretical study where the efficiency of sorting algorithms does not matter. You have chosen Stooge Sort to fulfill this requirement. Implement the function `stoogesort(arr, l, h)` where `arr` is the array to be sorted, `l` is the starting index, and `h` is the ending index. # Function Signature: ```python def stoogesort(arr, l, h): # Implement Stooge Sort ``` # Example: Input: ```python arr = [5, 3, 2, 4, 1] stoogesort(arr, 0, len(arr) - 1) print(arr) ``` Output: ```python [1, 2, 3, 4, 5] ``` Implement and test your Stooge Sort algorithm for the given example and ensure it successfully sorts the input array.","solution":"def stoogesort(arr, l, h): if l >= h: return # If the element at the start is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the segment if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 elements stoogesort(arr, l, h - t) # Recursively sort last 2/3 elements stoogesort(arr, l + t, h) # Recursively sort first 2/3 elements again stoogesort(arr, l, h - t)"},{"question":"# Objective Implement a Red-Black Tree with complete insert, delete, and search functionalities while maintaining its self-balancing properties. # Problem Statement Given the `RBTree` and `RBNode` classes, implement the `search` method in the `RBTree` class. Your method should find and return a node with the given value in the tree or `None` if the value does not exist. Then, modify the existing methods (insert, delete) to maintain the red-black properties upon insertion and deletion. # Requirements 1. **Search Function** 2. **Proper Maintenance of Red-Black Properties** # Function Definition ```python class RBTree: ... def search(self, val: int) -> RBNode: Searches the tree for a node with the given value. :param val: Integer value to search for. :return: RBNode with the value if exists, otherwise None. pass ``` # Example Input and Output 1. **Inserting Nodes & Searching for a Value:** ```python rb = RBTree() values = [10, 20, 30, 15, 25] for val in values: rb.insert(RBNode(val, 1)) search_result = rb.search(15) assert search_result is not None and search_result.val == 15 ``` 2. **Deleting Nodes & Maintaining Red-Black Properties:** ```python rb.delete(rb.search(15)) search_result_after_delete = rb.search(15) assert search_result_after_delete is None ``` # Constraints * The `search` method should work in O(log n) time complexity. * The tree should maintain Red-Black properties after every insertion and deletion. # Notes * You are provided with a basic outline, and you should focus on preserving the Red-Black properties while implementing these operations.","solution":"class RBNode: def __init__(self, val, color, left=None, right=None, parent=None): self.val = val self.color = color # 1 . Red, 0 . Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def search(self, val): def search_tree_helper(node, key): if node == self.TNULL or key == node.val: return node if key < node.val: return search_tree_helper(node.left, key) return search_tree_helper(node.right, key) node = search_tree_helper(self.root, val) return node if node != self.TNULL else None # Implement other required methods for RBTree, such as insert, delete, and helper functions def insert(self, key): node = RBNode(key, 1) node.parent = None node.left = self.TNULL node.right = self.TNULL node.color = 1 y = None x = self.root while x != self.TNULL: y = x if node.val < x.val: x = x.left else: x = x.right node.parent = y if y is None: self.root = node elif node.val < y.val: y.left = node else: y.right = node if node.parent is None: node.color = 0 return if node.parent.parent is None: return self.fix_insert(node) def fix_insert(self, k): while k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self.right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self.left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self.right_rotate(k.parent.parent) if k == self.root: break self.root.color = 0 def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y"},{"question":"# Diffie-Hellman Key Exchange Coding Challenge **Objective**: Implement a secure Diffie-Hellman key exchange, and related supporting functions, to facilitate encrypted communication over a public channel. Your implementation should include steps to check primality, compute Euler\'s Totient function, determine the order of elements, and find primitive roots. Function Details 1. **prime_check(num: int) -> bool** - **Description**: Verify if a number is a prime. - **Input**: Integer `num`. - **Output**: Boolean indicating if `num` is prime. 2. **euler_totient(n: int) -> int** - **Description**: Compute the Euler\'s Totient function for a given integer. - **Input**: Integer `n`. - **Output**: Integer value of ϕ(n). 3. **find_order(a: int, n: int) -> int** - **Description**: Find the order of a modulo n. - **Input**: Integers `a` and `n`. - **Output**: Integer value representing the order, -1 if it does not exist. 4. **find_primitive_root(n: int) -> List[int]** - **Description**: Identify all primitive roots of n. - **Input**: Integer `n`. - **Output**: List of integers representing primitive roots of `n`. 5. **diffie_hellman_key_exchange(a: int, p: int) -> bool** - **Description**: Perform Diffie-Hellman key exchange and return if shared keys match. - **Input**: Integers `a` (primitive root), `p` (prime number). - **Output**: Boolean indicating if the shared keys match. Constraints - The inputs `a` and `p` will have `1 <= a < p` and `p` is a small prime number (for example, `p` could be less than 100). - Prime checks, totient calculations, and key exchanges should be implemented considering typical cryptographic constraints. Example ```python assert prime_check(7) == True assert prime_check(4) == False assert euler_totient(9) == 6 assert find_order(2, 7) == 3 assert find_primitive_root(7) == [3, 5] assert diffie_hellman_key_exchange(3, 7) == True ``` # Implementation Implement the described functions ensuring each provides accurate results as per their definitions.","solution":"def prime_check(num: int) -> bool: Verify if a number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n: int) -> int: Compute the Euler\'s Totient function for a given integer. if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a: int, n: int) -> int: Find the order of a modulo n. if a == 0 or a == 1: return 1 k = 1 mod = a % n while mod != 1: mod = (mod * a) % n k += 1 if k > n: return -1 return k def find_primitive_root(n: int) -> list: Identify all primitive roots of n. if not prime_check(n): return [] phi = euler_totient(n) primitive_roots = [] for a in range(1, n): if find_order(a, n) == phi: primitive_roots.append(a) return primitive_roots def diffie_hellman_key_exchange(a: int, p: int) -> bool: Perform Diffie-Hellman key exchange and return if shared keys match. if not prime_check(p): return False private_key_A = 6 # Private key for participant A private_key_B = 15 # Private key for participant B public_key_A = pow(a, private_key_A, p) # A\'s public key public_key_B = pow(a, private_key_B, p) # B\'s public key shared_secret_A = pow(public_key_B, private_key_A, p) # A\'s computed shared secret shared_secret_B = pow(public_key_A, private_key_B, p) # B\'s computed shared secret return shared_secret_A == shared_secret_B"},{"question":"Implement a stack that supports typical stack operations (`push`, `pop`, `peek`, and `is_empty`) and an additional operation `reverse_stack`, which reverses the current stack. Your task is to implement this functionality using both array-based (`ArrayStack`) and linked-list-based (`LinkedListStack`) implementations. Each implementation should reverse the elements of the stack, making the bottom element the new top and vice versa. # Input * There are no direct inputs to the function implementations. # Output * For the `reverse_stack` function, return the `self` object after reversing to maintain fluent interface. # Constraints * `ArrayStack` should handle stacks of dynamic size by resizing the array as needed. * `LinkedListStack` should efficiently handle the reverse operation by rearranging the node pointers. * Assume operations to be tested on sizes ranging from 0 to 10^5. # Function Signature ```python class ArrayStack(AbstractStack): def __init__(self, size=10): # implement initialization def push(self, value): # implement push operation def pop(self): # implement pop operation def peek(self): # implement peek operation def is_empty(self): # implement is_empty operation def reverse_stack(self): # implement reverse_stack operation class LinkedListStack(AbstractStack): def __init__(self): # implement initialization def push(self, value): # implement push operation def pop(self): # implement pop operation def peek(self): # implement peek operation def is_empty(self): # implement is_empty operation def reverse_stack(self): # implement reverse_stack operation ``` # Example ```python # ArrayStack example stack = ArrayStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse_stack() print(stack.pop()) # Output should be 1 # LinkedListStack example stack = LinkedListStack() stack.push(1) stack.push(2) stack.push(3) stack.reverse_stack() print(stack.pop()) # Output should be 1 ``` # Notes Ensure that your reverse implementation works efficiently for both array-based and linked list-based stacks without initializing additional space equivalent to the current stack size, although minor helper variables are allowed.","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [] self.size = size def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() else: raise IndexError(\\"pop from empty stack\\") def peek(self): if not self.is_empty(): return self.stack[-1] else: raise IndexError(\\"peek from empty stack\\") def is_empty(self): return len(self.stack) == 0 def reverse_stack(self): self.stack = self.stack[::-1] return self class Node: def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None def push(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def pop(self): if not self.is_empty(): value = self.head.value self.head = self.head.next return value else: raise IndexError(\\"pop from empty stack\\") def peek(self): if not self.is_empty(): return self.head.value else: raise IndexError(\\"peek from empty stack\\") def is_empty(self): return self.head is None def reverse_stack(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self"},{"question":"# Question: Custom Bitwise Subtraction Implement a function to subtract one positive integer from another without using the \'-\' operator. Utilize bitwise operations for the subtraction. Function Signature ```python def subtract_bitwise_operator(x: int, y: int) -> int: ``` Input * Two non-negative integers `x` and `y` where `x >= y`. Output * A single integer which is the result of `x - y`. Constraints * `0 <= x, y <= 10^9`, with the constraint `x >= y`. Example ```python Input: 10, 3 Output: 7 Input: 15, 5 Output: 10 ``` Explanation Use similar principles to the given bitwise addition algorithm. Consider the following operational steps: 1. Use bitwise NOT and AND operations to find where the \\"borrow bits\\" need to be applied. 2. Use bitwise NOT, XOR, and AND operations to perform each subtraction without borrowing. 3. Continue the process until no more borrow bits are needed. Hints * The bitwise NOT operation can be used to simulate the borrowing process. * Bitwise operations should be combined to iterate through each bit until the subtraction is complete.","solution":"def subtract_bitwise_operator(x: int, y: int) -> int: Subtracts y from x using bitwise operations. :param x: The minuend (x >= y). :param y: The subtrahend. :return: The result of x - y. while y != 0: # Borrow value borrow = (~x) & y # Subtracting y from x x = x ^ y # Update y to borrowed value shifted y = borrow << 1 return x"},{"question":"Generate All Subsets You have been tasked with generating all possible subsets of a given list of distinct integers. Your implementation should return a set of tuples, where each tuple represents a unique subset of the input list. # Function Signature: ```python def generate_all_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` # Input: * A list of distinct integers `nums` (1 <= len(nums) <= 16). # Output: * A set of tuples, where each tuple contains integers forming a subset of the given input list. # Constraints: * The solution must not contain duplicate subsets. * Bitwise operations or combinatorial logic must be utilized. * The output set can include the empty subset. # Example: ```python nums = [1,2,3] generate_all_subsets(nums) ``` Expected Output: ```python { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,) } ``` # Explanation: With input `nums = [1,2,3]`, there are 2^3 = 8 possible subsets, including the empty subset. Each subset can be represented by a combination of binary indicators on whether to include each element. # Notes: * Ensure subsets are unique. * Subsets should appear without particular order in the output set. Implement the function `generate_all_subsets(nums: List[int]) -> Set[Tuple[int]]` which generates all possible subsets of the given list of distinct integers provided as input.","solution":"from typing import List, Set, Tuple def generate_all_subsets(nums: List[int]) -> Set[Tuple[int]]: Generate all subsets of a given list of distinct integers. Returns a set of tuples, each of which represents a subset. def backtrack(start, path): result.add(tuple(path)) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = set() backtrack(0, []) return result"},{"question":"# Question You are required to implement the Radix Sort algorithm and validate its correctness and efficiency through the following tasks. Task Given an unsorted list of non-negative integers, implement the `radix_sort` function to sort the list in ascending order. Additionally, ensure your implementation handles edge cases effectively and optimizes performance where possible. Function Signature ```python def radix_sort(arr, simulation=False) -> list: ``` Input - `arr`: List of non-negative integers to be sorted. Each integer will be within the range [0, 10^9]. - `simulation` (optional): Boolean flag, if set to True, the function should print each iteration\'s intermediate sorted list for debugging purposes. Output - Returns a list of integers sorted in ascending order. Constraints - (1 leq len(arr) leq 10^6) - (0 leq arr[i] leq 10^9) Example **Input:** ```python radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) ``` **Output:** ```python [2, 24, 45, 66, 75, 90, 170, 802] ``` **Input:** ```python radix_sort([3, 6, 8, 10, 1, 2, 1], simulation=True) ``` **Output:** ``` iteration 0 : 3 6 8 10 1 2 1 iteration 1 : 10 1 2 3 6 8 1 iteration 2 : 1 1 2 3 6 8 10 [1, 1, 2, 3, 6, 8, 10] ``` Explanation - The function should follow the Radix Sort algorithm as explained in the analysis. - Ensure the output is correct by considering all edge cases. - Implement optimizations to handle the performance for the upper limit of the constraints.","solution":"def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] if simulation: print(f\\"iteration {exp}: {arr}\\") def radix_sort(arr, simulation=False): if not arr: return [] max_val = max(arr) exp = 1 while max_val // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Segment Tree Query & Update You are given a **Segment Tree** class which can perform range queries and single element updates. The segment tree is initialized with an array and a commutative function (a function where (f(a, b) = f(b, a))) such as `max`, `min`, or a lambda function for sum. Implement and test the `SegmentTree` class for the following operations: 1. **Range Query**: Retrieve the result of applying the commutative function over a specified range. 2. **Update**: Update a specific index in the array and reflect this change in the tree. # Function Signatures ```python class SegmentTree: def __init__(self, arr: list, function: callable): Constructs a segment tree from an array and a function. :param arr: List[int] or List[tuple] - initial array. :param function: callable - a commutative function to be applied in queries. def build_tree(self) -> None: Builds the segment tree from the initial array. pass def update(self, index: int, value) -> None: Updates the element at the specified index in the array. :param index: int - the index to update. :param value: same type as array elements - the new value. pass def query(self, left: int, right: int): Queries the range [left, right] applying the commutative function. :param left: int - start index of range. :param right: int - end index of range. :return: Result of the commutative function over the range. pass ``` # Requirements: 1. Your solution should handle arrays of integers and tuples of integers. 2. Ensure your commutative function works for all types mentioned above. 3. Your implementation should correctly handle updates and range queries as demonstrated. # Constraints: - (1 leq text{len(arr)} leq 10^5) - Array elements are between (-10^9) and (10^9) - There will be at most (10^5) queries and updates combined. # Example: ```python # Example 1 - Using max function tree = SegmentTree([2, 4, 5, 3, 4], max) print(tree.query(2, 4)) # Output: 5 tree.update(3, 6) print(tree.query(0, 3)) # Output: 6 # Example 2 - Using sum function (lambda function) tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(tree.query(0, 6)) # Output: 64 tree.update(2, -10) print(tree.query(0, 6)) # Output: 52 # Example 3 - Using sum function for tuples tree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(tree.query(0, 2)) # Output: (9, 13) tree.update(2, (-1, 2)) print(tree.query(0, 2)) # Output: (4, 10) ``` Focus on ensuring your solution is efficient and correct, taking into account edge cases and performance considerations.","solution":"class SegmentTree: def __init__(self, arr: list, function: callable): Constructs a segment tree from an array and a function. :param arr: List[int] or List[tuple] - initial array. :param function: callable - a commutative function to be applied in queries. self.arr = arr self.function = function self.n = len(arr) self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self) -> None: Builds the segment tree from the initial array. # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Calculate internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value) -> None: Updates the element at the specified index in the array. :param index: int - the index to update. :param value: same type as array elements - the new value. # Update the leaf node pos = index + self.n self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int): Queries the range [left, right] applying the commutative function. :param left: int - start index of range. :param right: int - end index of range. :return: Result of the commutative function over the range. left_pos = left + self.n right_pos = right + self.n + 1 result = None while left_pos < right_pos: if left_pos % 2 == 1: result = self.tree[left_pos] if result is None else self.function(result, self.tree[left_pos]) left_pos += 1 if right_pos % 2 == 1: right_pos -= 1 result = self.tree[right_pos] if result is None else self.function(result, self.tree[right_pos]) left_pos //= 2 right_pos //= 2 return result"},{"question":"Absolute Path Resolution with Error Handling In this coding challenge, your task is to enhance a given path resolution function. The function should not only convert a relative file path to an absolute path but also handle potential errors and validate the existence of the path. Additionally, it must provide a detailed log if any errors occur during the process. # Function Definition Write a function `resolve_and_validate_path(file_path: str) -> str` with the following specifications: 1. **Input**: * `file_path` (str): A file path that can be relative, containing user home directory symbols like `~`, or already absolute. 2. **Output**: * The function should return the absolute file path as a string. * If the path does not exist or an error occurs during the resolution, it should return a descriptive error message. # Implementation Details 1. Use `os.path.expanduser` to expand `~` user directory shortcut. 2. Use `os.path.abspath` to convert the path to an absolute path. 3. Validate the path using `os.path.exists` to check if the file or directory actually exists. 4. Use exception handling to catch any unexpected errors and return a clear error message. 5. Provide a descriptive log message in case of any errors. # Constraints 1. The function should handle empty strings by returning a suitable error message. 2. The function should handle malformed paths gracefully without crashing. 3. The function should log errors but should not throw exceptions that stop execution. # Examples ```python resolve_and_validate_path(\\"~/documents/file.txt\\") # Output: \\"/home/user/documents/file.txt\\" (if the path exists) resolve_and_validate_path(\\"invalid_path/\\") # Output: \\"Error: The provided path does not exist or is invalid.\\" resolve_and_validate_path(\\"\\") # Output: \\"Error: Provided path is empty.\\" resolve_and_validate_path(\\"../relative/path\\") # Output: \\"/absolute/path/to/relative/path\\" (if the path exists) ``` Write your implementation below: ```python import os def resolve_and_validate_path(file_path: str) -> str: try: if not file_path: return \\"Error: Provided path is empty.\\" expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) if not os.path.exists(absolute_path): return \\"Error: The provided path does not exist or is invalid.\\" return absolute_path except Exception as e: return f\\"Error: An unexpected error occurred - {str(e)}\\" ```","solution":"import os def resolve_and_validate_path(file_path: str) -> str: Converts a relative file path to an absolute path, validates the existence of the path, and handles potential errors. Parameters: file_path (str): A file path that can be relative or already absolute. Returns: str: The absolute file path if valid, otherwise an error message. try: if not file_path: return \\"Error: Provided path is empty.\\" expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) if not os.path.exists(absolute_path): return \\"Error: The provided path does not exist or is invalid.\\" return absolute_path except Exception as e: return f\\"Error: An unexpected error occurred - {str(e)}\\""},{"question":"# Word Dictionary with Tries You are tasked with implementing a Word Dictionary that uses the Trie data structure. Your implementation must efficiently support the operations of adding words and searching for words using regex with the dot (.) notation. Function Requirements 1. **add_word(self, word: str) -> None**: * Adds the word into the Trie. * Args: * `word`: A string representing the word to be added. 2. **search(self, word: str) -> bool**: * Searches for the word in the Trie. The search word can contain dot (.) that represents any character. * Args: * `word`: A string representing the word to search for. * Returns: * True if the word is found, False otherwise. Input and Output Format * **Function Input**: * Words will contain only lowercase English letters. * Functions should handle case normalization. * **Constraints**: * 1 <= word length <= 100 * You may assume that all inputs are valid lowercase alphabetic strings or dots. * **Example**: ```python obj = WordDictionary() obj.add_word(\\"bad\\") obj.add_word(\\"dad\\") obj.add_word(\\"mad\\") assert obj.search(\\"pad\\") == False assert obj.search(\\"bad\\") == True assert obj.search(\\".ad\\") == True assert obj.search(\\"b..\\") == True ``` Notes: * Ensure your implementation is clean and handles all edge cases (e.g., only dots, no letters). * Consider performance for larger datasets with similar prefixes. Provide comments on complex steps. # Your Task: Implement the `WordDictionary` class with the methods `add_word` and `search` as specified above.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: Adds a word into the Trie. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Searches for the word in the Trie. Supports \'.\' as any character. def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': # If the current character is \'.\', check all possible nodes at this children for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Merge Sort Algorithm Implementation Your task is to implement the Merge Sort algorithm to sort an array of integers. You need to write a function that divides the array into halves, recursively sorts each half, and then merges them back together in sorted order. # Function Specification Input - `arr`: A list of integers Output - A list of integers sorted in ascending order # Constraints - The input array will have length in the range [0, 10^5] - Each integer will be within the range [-10^6, 10^6] # Requirements - Your function must have an average case time complexity of O(n log(n)). - The implementation must be stable, preserving the order of equal elements. # Example ```python # Example 1 arr = [38, 27, 43, 3, 9, 82, 10] # Expected output: [3, 9, 10, 27, 38, 43, 82] # Example 2 arr = [1] # Expected output: [1] # Example 3 arr = [] # Expected output: [] # Example 4 arr = [5, 2, 5, 2] # Expected Output: [2, 2, 5, 5] ``` # Implementation Write your implementation for the `merge_sort` function below: ```python def merge_sort(arr): Merge Sort implementation that sorts a list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Helper function to merge two sorted lists. merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append any remaining elements from both sides merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged ```","solution":"def merge_sort(arr): Merge Sort implementation that sorts a list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Helper function to merge two sorted lists. merged = [] left_cursor, right_cursor = 0, 0 while left_cursor < len(left) and right_cursor < len(right): if left[left_cursor] <= right[right_cursor]: merged.append(left[left_cursor]) left_cursor += 1 else: merged.append(right[right_cursor]) right_cursor += 1 # Append any remaining elements from both sides merged.extend(left[left_cursor:]) merged.extend(right[right_cursor:]) return merged"},{"question":"# Question: Enhanced String Reversal Function Your task is to write a function `enhanced_reverse` that takes a string and a mode as input, reverses the string based on the specified mode, and returns the reversed string. The modes available are `\\"recursive\\"`, `\\"iterative\\"`, `\\"pythonic\\"`, and `\\"ultra_pythonic\\"`. Input * A string `s` (0 ≤ len(s) ≤ 10000) * A string `mode` that specifies the method of reverse (one of `\\"recursive\\"`, `\\"iterative\\"`, `\\"pythonic\\"`, `\\"ultra_pythonic\\"`) Output * A reversed string based on the mode specified. Constraints * The function should handle and correctly return results for edge cases such as empty or single character strings. * Performance should be considered, and the appropriate method should be utilized based on the mode input. Example ```python assert enhanced_reverse(\\"hello\\", \\"iterative\\") == \\"olleh\\" assert enhanced_reverse(\\"world\\", \\"recursive\\") == \\"dlrow\\" assert enhanced_reverse(\\"python\\", \\"pythonic\\") == \\"nohtyp\\" assert enhanced_reverse(\\"example\\", \\"ultra_pythonic\\") == \\"elpmaxe\\" ``` Instructions 1. Implement the function `enhanced_reverse` with the specified functionality. 2. Avoid using any direct built-in string reverse functions besides those allowed by the mode. 3. Ensure your function handles edge cases efficiently. Example function signature: ```python def enhanced_reverse(s: str, mode: str) -> str: # Implement your solution here pass ```","solution":"def enhanced_reverse(s: str, mode: str) -> str: Reverses the given string based on the specified mode. :param s: input string to be reversed :param mode: mode of reversing the string, can be \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\' :return: reversed string based on the mode specified def reverse_recursive(s: str) -> str: if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] if mode == \\"recursive\\": return reverse_recursive(s) elif mode == \\"iterative\\": reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str elif mode == \\"pythonic\\": return s[::-1] elif mode == \\"ultra_pythonic\\": return \'\'.join(reversed(s)) else: raise ValueError(\\"Invalid mode. Choose from \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\'.\\")"},{"question":"Context You run a system where users often enter two sequences of DNA, and you are required to find the commonality between them. As part of the bioinformatics module of your application, you want to implement a feature that computes the length of the longest common subsequence between two DNA sequences. Task Write a function that takes two strings, `s1` and `s2`, representing the DNA sequences and returns the length of their longest common subsequence. Function Signature ```python def longest_common_subsequence(s1: str, s2: str) -> int: :param s1: string - A sequence of DNA :param s2: string - Another sequence of DNA :return: int - Length of the longest common subsequence ``` Input - `s1` and `s2` are strings composed of lowercase English alphabets, representing DNA sequences. - 1 <= len(s1), len(s2) <= 1000 Output - Return the length of the longest common subsequence. Example ```python assert longest_common_subsequence(\'abcdgh\', \'aedfhr\') == 3 # The LCS is \'adh\' assert longest_common_subsequence(\'abc\', \'abc\') == 3 # The LCS is \'abc\' assert longest_common_subsequence(\'abc\', \'def\') == 0 # No common subsequence ``` Constraints - Efficiently handle sequences of length up to 1000. - No additional libraries/functions should be imported. Performance - Your solution must solve the problem within the specified time complexity of O(M*N). - Optimize space usage where possible.","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between two DNA sequences. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"**RSA Encryption Algorithm Implementation and Validation** # Objective As a data security consultant, you are tasked with implementing the RSA encryption and decryption processes, along with a custom primality test and modular inverse function. You need to handle edge cases and ensure efficient computation for secure key generation. # Problem Statement 1. **Implement the `is_prime` function** that checks whether a given number is a prime. 2. **Implement the `modinv` function** to find the modular multiplicative inverse of two integers. 3. **Create the `generate_key` function** to generate the public and private keys for RSA encryption: - Generate two distinct k-bit prime numbers. - Calculate the modulus n, totient ( phi(n) ), encryption exponent e, and decryption exponent d. 4. **Encrypt and decrypt a message using the generated keys** to validate the implementation. # Input/Output Formats * Input: `k` (integer): Bit length for the prime numbers. * Output: Tuple containing the public key (`n`, `e`) and private key (`n`, `d`). ```python def is_prime(num: int) -> bool: Check whether the given number is a prime. pass def modinv(a: int, m: int) -> int: Calculate the modular multiplicative inverse of a modulo m. pass def generate_key(k: int) -> Tuple[int, int, int]: Generate RSA public/private key pair. pass def encrypt(data: int, e: int, n: int) -> int: Encrypt the data using public key (n, e). pass def decrypt(data: int, d: int, n: int) -> int: Decrypt the data using private key (n, d). pass # Example validation function def validate_rsa(): k = 16 # Example key bit size; in real scenarios, use at least 2048 bits n, e, d = generate_key(k) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data, \\"Decryption failed\\" validate_rsa() ``` # Constraints and Requirements - Prime numbers should be as large as possible within the bit constraints. - Efficient implementation is necessary, especially for prime testing and modular arithmetic. - RSA key sizes should be validated to be secure in modern contexts (k >= 2048 recommended, but this can be modified for testing with smaller values). - Modular exponentiation operations should be optimized for large number handling using Python\'s built-in capabilities. # Performance Considerations - Ensure efficient modular inversion and primality testing to avoid delays in key generation. - Handle potential edge cases for very small primes and ensure robustness of encryption and decryption cycles.","solution":"import random from typing import Tuple def is_prime(num: int) -> bool: Check whether the given number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def modinv(a: int, m: int) -> int: Calculate the modular multiplicative inverse of a modulo m using the extended Euclidean algorithm. m0, x0, x1 = m, 0, 1 if m == 1: return 0 while a > 1: q = a // m m, a = a % m, m x0, x1 = x1 - q * x0, x0 if x1 < 0: x1 += m0 return x1 def generate_key(k: int) -> Tuple[int, int, int]: Generate RSA public/private key pair. def generate_prime_candidate(k): # generate random bits p = random.getrandbits(k) # apply a mask to set MSB and LSB to 1 p |= (1 << k - 1) | 1 return p def generate_prime_number(k): p = 4 while not is_prime(p): p = generate_prime_candidate(k) return p p = generate_prime_number(k) q = generate_prime_number(k) while q == p: q = generate_prime_number(k) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used public exponent d = modinv(e, phi) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: Encrypt the data using public key (n, e). return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: Decrypt the data using private key (n, d). return pow(data, d, n) def validate_rsa(): k = 16 # Example key bit size; in real scenarios, use at least 2048 bits n, e, d = generate_key(k) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data, \\"Decryption failed\\""},{"question":"Context You are working on a file management system that needs to handle various file paths provided by users. To ensure consistency and simplicity in handling these paths, it is crucial that all file paths are converted to their absolute form. Write a function `convert_path` that takes a file path as input and returns its absolute path. The function should handle user-specific paths by expanding `~` to the user’s home directory and should convert any relative paths to absolute paths. Function Signature ```python def convert_path(file_path: str) -> str: pass ``` Input * `file_path`: A string representing the file path. * Constraints: - Can include `~` for user’s home directory. - Can be a relative path or already an absolute path. - Will be a valid string (non-empty). Output * Return a string that represents the absolute path. Examples 1. `convert_path(\\"~/documents/report.txt\\")` should return the absolute path equivalent, e.g., `/home/username/documents/report.txt`. 2. `convert_path(\\"../notes.txt\\")` should return the absolute path based on the current working directory. 3. `convert_path(\\"/usr/local/bin\\")` should return `/usr/local/bin`. Note: The actual return values for relative paths depend on the current working directory of the system where the function is executed. Constraints * Ensure the function handles paths on both Unix-like systems and Windows systems. Implement the function `convert_path`.","solution":"import os def convert_path(file_path: str) -> str: Converts a file path to its absolute path. # Expand the user’s home directory if needed expanded_path = os.path.expanduser(file_path) # Convert to absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"You are asked to implement a slightly modified version of the Stooge Sort algorithm to understand recursive sorting techniques. The modification involves also sorting the array from both ends towards the middle in each recursive call, thus making it more complicated for analysis and ensuring you can handle more nuanced data structure manipulations. **Description**: * Implement a function `modified_stoogesort(arr, l, h)` that: 1. If the first element is greater than the last, swaps them. 2. If there are more than two elements, split it into three parts. 3. Recursively sort the first two-thirds of the array. 4. Recursively sort the last two-thirds of the array. 5. Recursively sort the middle three-fifths of the array. 6. Extend steps 3 and 4 so that the recursive calls ensure the array is being sorted from ends towards the middle efficiently. **Function Signature**: ```python def modified_stoogesort(arr: List[int], l: int, h: int) -> None: pass ``` **Input**: * A list `arr` of integers. * Two integers `l` and `h` representing the indices between which the array should be sorted. **Output**: * In-place sorted array based on the modified Stooge Sort algorithm. **Constraints**: * 0 ≤ len(arr) ≤ 1000 * -10^6 ≤ arr[i] ≤ 10^6 for any valid index `i` **Examples**: ```python # Example 1 arr = [5, 4, 3, 2, 1] modified_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] # Example 2 arr = [1, 3, 2] modified_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3] ``` **Additional Notes**: * Ensure you thoroughly test edge cases such as arrays with a single element and arrays with already sorted or reverse-sorted elements. * Analyze the performance and provide comments on how this modification has affected traditional Stooge Sort.","solution":"def modified_stoogesort(arr, l, h): if l >= h: return # If the first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort the first two-thirds modified_stoogesort(arr, l, h - t) # Recursively sort the last two-thirds modified_stoogesort(arr, l + t, h) # Recursively sort the middle three-fifths modified_stoogesort(arr, l, h - t)"},{"question":"# Question: Extended Euclidean Algorithm Context You have been assigned a task to implement some utility functions necessary for cryptographic operations. One specific requirement is to find integers s and t such that for two given integers num1 and num2, they satisfy Bézout\'s identity: [ text{num1} * s + text{num2} * t = text{gcd(num1, num2)} ] Task Implement the function `extended_gcd` that computes the coefficients of Bézout\'s identity and the GCD of two given integers. Function Signature ```python def extended_gcd(num1: int, num2: int) -> (int, int, int): Inputs: num1 (int): First integer number. num2 (int): Second integer number. Returns: (s, t, g) where - `s` (int): Coefficient for num1 - `t` (int): Coefficient for num2 - `g` (int): Greatest Common Divisor (GCD) of num1 and num2 Constraints: - Integer inputs can be negative. - Either number can be zero. - Result should respect the properties of Bézout\'s identity. ``` Examples 1. **Example 1:** ```python extended_gcd(30, 20) -> (1, -1, 10) ``` Explanation: Here, ( 30*1 + 20*(-1) = 10 ) 2. **Example 2:** ```python extended_gcd(35, 10) -> (1, -3, 5) ``` Explanation: Here, ( 35*1 + 10*(-3) = 5 ) Notes Make sure to handle edge cases such as one or both integers being zero as well as negative inputs appropriately.","solution":"def extended_gcd(num1, num2): if num1 == 0: return (0, 1, num2) else: s1, t1, g = extended_gcd(num2 % num1, num1) s = t1 - (num2 // num1) * s1 t = s1 return (s, t, g)"},{"question":"Matrix Inversion Objective: Your task is to implement a function that computes the inverse of a given n x n matrix using the steps outlined in the algorithm analysis. Problem Description: Given an n x n matrix A, determine the inverse B of the matrix such that AB = BA = In, where In is the identity matrix of size n. Requirements: You must implement the following function: ```python def invert_matrix(matrix): # Your implementation here pass ``` # Input: - A 2D list `matrix` representing an n x n matrix of integers or floating-point numbers. - Example: `[[2, 1], [5, 3]]` # Output: - A 2D list representing the inverse of the given matrix. - For the example input: `[[ 3, -1], [-5, 2]]` - If the matrix is non-invertible or invalid (non-square, empty, singular), return an error message or a specific indicator (e.g., `None` or a matrix filled with `-1`). Constraints: - The input matrix will have at most dimensions 10x10 for this assessment. - Ensure to handle edge cases such as singular matrices and invalid inputs. Performance Requirements: - Aim for a solution with a time complexity close to O(n^3) and space complexity of O(n^2). Example Function Signature: ```python def invert_matrix(matrix): # Your implementation here pass ``` Example: ```python matrix = [ [4, 7], [2, 6] ] output = invert_matrix(matrix) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] ``` Evaluation Criteria: - **Correctness**: Whether the function correctly inverts the matrix. - **Efficiency**: The implementation should be efficient within the given constraints. - **Edge Case Handling**: Properly handle and account for edge cases such as very small or singular matrices. - **Code Quality**: Clear, readable, and well-commented code. Good luck!","solution":"import numpy as np def invert_matrix(matrix): Returns the inverse of the given n x n matrix if it exists. If the matrix is not square or is singular, returns None. # Convert the input list of lists to a NumPy array for matrix operations try: np_matrix = np.array(matrix) # Check if the matrix is square if np_matrix.shape[0] != np_matrix.shape[1]: return None # Attempt to invert the matrix inv_matrix = np.linalg.inv(np_matrix) # Convert the result back to a list of lists before returning return inv_matrix.tolist() except np.linalg.LinAlgError: # Matrix is singular or not invertible return None"},{"question":"# Problem Description You are given a list of non-negative integers that you need to sort using the Bucket Sort algorithm. The provided implementation uses insertion sort for sorting individual buckets. Your task is to modify the bucket sort to handle edge cases more efficiently and optimize the sorting within buckets. # Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: ``` # Input * A list `arr` of non-negative integers with ( 1 leq text{len}(arr) leq 10^5 ). # Output * A list of integers sorted in non-decreasing order. # Constraints * Elements in the list `arr` will be non-negative integers. * Assume the maximum value that any element can take is ( 10^5 ). # Requirements * Your solution should efficiently handle edge cases. * Ensure your solution runs within acceptable performance limits for large inputs. * Optimize the sorting within each bucket. You can select an appropriate sorting algorithm different from insertion sort if it improves performance. # Additional Context Bucket sort works particularly well when the input is uniformly distributed. Ensure that your solution maintains this efficiency while addressing the drawbacks mentioned in the analysis. # Test Cases 1. **Edge Case**: Testing with empty array. ```python assert optimized_bucket_sort([]) == [] ``` 2. **Edge Case**: Single-element array. ```python assert optimized_bucket_sort([7]) == [7] ``` 3. **Normal Case**: Small-sized array. ```python assert optimized_bucket_sort([4, 3, 2, 1]) == [1, 2, 3, 4] ``` 4. **Normal Case**: Uniformly distributed large array. ```python assert optimized_bucket_sort([100, 200, 300, 1000, 500, 2000, 1001, 702, 601]) == [100, 200, 300, 500, 601, 702, 1000, 1001, 2000] ``` 5. **Stress Case**: Large array with high-range values. ```python large_array = list(range(100000, -1, -1)) assert optimized_bucket_sort(large_array) == list(range(100001)) ```","solution":"def optimized_bucket_sort(arr): if len(arr) <= 1: return arr # Step 1: Create buckets num_buckets = len(arr) max_value = max(arr) buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute elements into buckets for num in arr: index = num * num_buckets // (max_value + 1) buckets[index].append(num) # Step 3: Sort each bucket and concatenate sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Rabin-Miller Primality Test Implementation In this problem, you need to implement the Rabin-Miller primality test, which is a probabilistic algorithm used to determine whether a given number is prime with high probability. The function should be efficient and able to handle very large integers. # Function Signature ```python def is_probable_prime(n: int, k: int) -> bool: ``` # Parameters - `n` (int): The number to test for primality (where ( n geq 2 )). - `k` (int): The number of iterations or trials to check the probabilistic nature of the test. # Returns - `bool`: Returns `True` if `n` is a probable prime with high confidence. Returns `False` if `n` is composite. # Constraints 1. ( 2 leq n leq 10^{18} ) 2. ( 1 leq k leq 1000 ) # Example ```python print(is_probable_prime(13, 5)) # Output: True (since 13 is a prime number) print(is_probable_prime(18, 5)) # Output: False (since 18 is not a prime number) ``` # Notes - The function should handle edge cases gracefully, for instance when `n` is one of the first few primes (2, 3) or a small composite number. - Even though the algorithm is probabilistic, increasing the number of iterations `k` will decrease the error rate significantly. - Keep the complexity discussions in mind and aim for efficient computations, especially on larger values of `n`.","solution":"import random def is_probable_prime(n: int, k: int) -> bool: Miller-Rabin Primality test. Args: n : int : the number to test for primality k : int : number of iterations to run the test Returns: bool : True if n is probably prime, False if n is composite. # Handle very small n cases first if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n as d*2^r + 1 with d odd (by factoring out powers of 2 from n-1) r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Witness loop for _ in range(k): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: continue for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: break else: return False return True"},{"question":"Background You are tasked with designing a function that checks if one string is a rotated version of another. This concept is significant in various fields such as string matching algorithms, circular data structures, and in scenarios where cyclic permutations are frequent. Problem Statement Write a function `is_rotated_check(s1: str, s2: str) -> bool` that determines if the string `s2` is a rotated version of the string `s1`. Input - `s1`: A string representing the base string. - `s2`: A string representing the rotated string to check. Output - Return `True` if `s2` is a rotation of `s1`, otherwise return `False`. Constraints - The length of each string is between 0 and 100,000. - All characters in the strings are lowercase English letters. Example ```python assert is_rotated_check(\\"hello\\", \\"llohe\\") == True assert is_rotated_check(\\"hello\\", \\"helol\\") == False assert is_rotated_check(\\"abcde\\", \\"cdeab\\") == True assert is_rotated_check(\\"abcd\\", \\"dabc\\") == True assert is_rotated_check(\\"\\", \\"\\") == True assert is_rotated_check(\\"abc\\", \\"def\\") == False assert is_rotated_check(\\"a\\"*100000, \\"a\\"*100000) == True ``` Performance Requirement - Implement your solution with a time complexity of O(N) and space complexity of O(N). Special Notes - Account for edge cases like empty strings and identical strings. - Ensure that your solution does not exceed any memory limits.","solution":"def is_rotated_check(s1: str, s2: str) -> bool: Determine if s2 is a rotated version of s1. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"# Stooge Sort Assessment Context Stooge Sort is an inefficient yet interesting recursive sorting algorithm primarily useful for educational demonstrations. You are tasked with implementing this algorithm to sort an array of integers. Despite its inefficiency, understanding and configuring this sort can improve comprehension of recursion and algorithm design. Problem Statement Write a function `stoogesort(array)` that takes a list of integers `array` and sorts it in non-decreasing order using the Stooge Sort algorithm. Input - A list of integers `array`, where 1 ≤ len(array) ≤ 1000. Output - Return a sorted list of integers in non-decreasing order. Constraints - The function should not use any built-in sort functions. - The maximum length of the array will be 1000 to prevent extreme inefficiency. - Handle edge cases like empty arrays, single-element arrays, and arrays with duplicate values. # Function Signature ```python def stoogesort(array): # your code here ``` # Example ```python print(stoogesort([3, 1, 2])) # Output: [1, 2, 3] print(stoogesort([5, 4, 3, 2, 1]))# Output: [1, 2, 3, 4, 5] print(stoogesort([1])) # Output: [1] print(stoogesort([])) # Output: [] print(stoogesort([2, 2, 3, 1])) # Output: [1, 2, 2, 3] ``` Requirements - Ensure that the code handles recursion edge cases such as inputs with high depth of recursion efficiently.","solution":"def stoogesort(array, l=0, h=None): if h is None: h = len(array) - 1 if l >= h: return array # already sorted # If the element at the start is greater than the element at the end, swap them if array[l] > array[h]: array[l], array[h] = array[h], array[l] # If more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(array, l, h - t) # Sort first 2/3rds stoogesort(array, l + t, h) # Sort last 2/3rds stoogesort(array, l, h - t) # Sort first 2/3rds again return array"},{"question":"# Linked List Sorted Check You are given a singly linked list where each node contains an integer value. Your task is to write a function `is_sorted(head)` that returns `True` if the linked list is in non-decreasing order, and `False` otherwise. An empty linked list should be considered sorted. # Function Signature ```python def is_sorted(head): # Your code here ``` # Input * `head`: The head node of a singly linked list. Each node has two attributes: `val` (an integer) and `next` (a reference to the next node). # Output * `True`: If the linked list is sorted in non-decreasing order. * `False`: Otherwise. # Constraints * You are guaranteed that the values within the list nodes are integers. * The function should run in O(n) time complexity and use O(1) additional space. # Example * **Example 1:** * Input: `1 -> 2 -> 3 -> 4 -> None` * Output: `True` * **Example 2:** * Input: `1 -> 2 -> -1 -> 3 -> None` * Output: `False` * **Example 3:** * Input: `None` * Output: `True` * **Example 4:** * Input: `5 -> 5 -> 5 -> None` * Output: `True` # Hints * Think about how you can compare each node\'s value with its next node\'s value while traversing through the linked list. * Be sure to consider the edge cases where the list is empty or has only one node.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head): Check if a singly linked list is sorted in non-decreasing order. if not head or not head.next: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Coding Challenge: Implement Additional Features for a B-tree Objective Enhance the given B-tree implementation by adding the following features without disrupting the existing functionalities. Task Description 1. **Range Query**: Implement a method `range_query(start_key, end_key)` that returns all keys within the range `[start_key, end_key]`. 2. **Count Nodes**: Implement a method `count_nodes()` that returns the total number of nodes in the entire B-tree. 3. **Count Keys**: Implement a method `count_keys()` that returns the total number of keys stored in the B-tree. Requirements - **Range Query**: * Input: Two integers `start_key` and `end_key`. * Output: A list of integers containing all keys in the range `[start_key, end_key]` inclusive. - **Count Nodes**: * Input: None. * Output: An integer representing the total count of nodes in the tree. - **Count Keys**: * Input: None. * Output: An integer representing the total count of keys in the tree. Constraints - Use the given B-tree structure as a basis. - Handle all potential edge cases, such as: * An empty tree. * Non-existent range in the range query. Example ```python # Assuming the BTree class (with its Node class) has been implemented as provided. btree = BTree(t_val=3) keys = [20, 50, 40, 30, 10, 70, 60] for key in keys: btree.insert_key(key) print(btree.range_query(20, 50)) # Output: [20, 30, 40, 50] print(btree.count_nodes()) # Output: Actual number of nodes depending on how splits happened during insertion. print(btree.count_keys()) # Output: 7 ``` Extended Implementation Implement the following functions inside the BTree class: - `def range_query(self, start_key: int, end_key: int) -> List[int]:` - Returns keys in the given range. - `def count_nodes(self) -> int:` - Returns the total number of nodes. - `def count_keys(self) -> int:` - Returns the total number of keys. Ensure your functions are efficient and align with the B-tree properties.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.keys = [] self.children = [] self.leaf = leaf def insert_non_full(self, key): i = len(self.keys) - 1 if self.leaf: # If this is a leaf node # Insert the new key at the correct location self.keys.append(key) self.keys.sort() else: # If this node is not a leaf # Traverse the children nodes until we find one that can accommodate the new key while i >= 0 and key < self.keys[i]: i -= 1 i += 1 if len(self.children[i].keys) == 2*self.t - 1: self.split_child(i, self.children[i]) if key > self.keys[i]: i += 1 self.children[i].insert_non_full(key) def split_child(self, i, y): # Split child \'y\' of this node at index \'i\' t = self.t z = BTreeNode(y.t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[:t] def traverse(self): result = [] i = 0 for i in range(len(self.keys)): if not self.leaf: result.extend(self.children[i].traverse()) result.append(self.keys[i]) if not self.leaf: result.extend(self.children[i].traverse()) return result class BTree: def __init__(self, t): self.t = t self.root = BTreeNode(t, True) def insert_key(self, key): if len(self.root.keys) == 2*self.t - 1: s = BTreeNode(self.t, False) s.children.append(self.root) s.split_child(0, self.root) self.root = s self.root.insert_non_full(key) def range_query(self, start_key, end_key): return self._range_query(self.root, start_key, end_key) def _range_query(self, node, start_key, end_key): result = [] i = 0 while i < len(node.keys) and node.keys[i] < start_key: i += 1 while i < len(node.keys) and node.keys[i] <= end_key: if not node.leaf: result.extend(self._range_query(node.children[i], start_key, end_key)) result.append(node.keys[i]) i += 1 if not node.leaf: result.extend(self._range_query(node.children[i], start_key, end_key)) return result def count_nodes(self): return self._count_nodes(self.root) def _count_nodes(self, node): if node is None: return 0 count = 1 for child in node.children: count += self._count_nodes(child) return count def count_keys(self): return self._count_keys(self.root) def _count_keys(self, node): if node is None: return 0 count = len(node.keys) for child in node.children: count += self._count_keys(child) return count"},{"question":"# Background Efficient data serialization and deserialization are crucial in many applications such as networking, file handling, and database storage. Often, data needs to be converted to and from binary formats, with careful attention to the byte order (endianness). # Problem Statement Implement a pair of functions that convert an integer to a byte sequence and back, supporting both big-endian and little-endian formats. # Details Implement two functions, `int_to_bytes` and `bytes_to_int`, supporting the following signatures: ```python def int_to_bytes(num, endian=\'big\') -> bytes: Converts an integer to its byte sequence representation. :param num: Integer to be converted. :param endian: Specify the endianness (\'big\' or \'little\'). Default is \'big\'. :return: Byte sequence of the integer in the specified endianness. pass def bytes_to_int(bytestr, endian=\'big\') -> int: Converts a byte sequence back to an integer. :param bytestr: Byte sequence to be converted. :param endian: Specify the endianness (\'big\' or \'little\'). Default is \'big\'. :return: The integer representation of the byte sequence. pass ``` # Constraints * `num` is a non-negative integer. * `bytestr` is a sequence of bytes. * `endian` is either \'big\' or \'little\'. If not provided, default to \'big\'. * For simplicity, ignore the conversion of negative integers and assume all integers are non-negative. * The functions should handle edge cases, such as zero. # Examples ```python print(int_to_bytes(1024)) # Output: b\'x04x00\' print(int_to_bytes(1024, \'little\')) # Output: b\'x00x04\' print(bytes_to_int(b\'x04x00\')) # Output: 1024 print(bytes_to_int(b\'x00x04\', \'little\')) # Output: 1024 ``` # Requirements * The solution should be efficient in both time and space complexity. * Use appropriate data structures to handle edge cases gracefully. # Notes * You may use any additional helper functions if required. * Ensure to validate the `endian` parameter and handle unsupported endianness appropriately.","solution":"def int_to_bytes(num, endian=\'big\') -> bytes: Converts an integer to its byte sequence representation. :param num: Integer to be converted. :param endian: Specify the endianness (\'big\' or \'little\'). Default is \'big\'. :return: Byte sequence of the integer in the specified endianness. if not isinstance(num, int) or num < 0: raise ValueError(\\"num must be a non-negative integer\\") if endian not in (\'big\', \'little\'): raise ValueError(\\"endian must be \'big\' or \'little\'\\") length = (num.bit_length() + 7) // 8 # Calculate the number of bytes needed if length == 0: length = 1 # Ensure at least one byte for zero return num.to_bytes(length, byteorder=endian) def bytes_to_int(bytestr, endian=\'big\') -> int: Converts a byte sequence back to an integer. :param bytestr: Byte sequence to be converted. :param endian: Specify the endianness (\'big\' or \'little\'). Default is \'big\'. :return: The integer representation of the byte sequence. if not isinstance(bytestr, (bytes, bytearray)): raise ValueError(\\"bytestr must be a byte sequence\\") if endian not in (\'big\', \'little\'): raise ValueError(\\"endian must be \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endian)"},{"question":"You are given two binary trees. Implement a function `is_same_tree(tree_p, tree_q)` to check if they are equal. Two binary trees are considered equal if they are structurally identical and their nodes have the same value. # Function Signature ```python def is_same_tree(tree_p: TreeNode, tree_q: TreeNode) -> bool: pass ``` # Input - `tree_p` and `tree_q`: The root nodes of two binary trees. Each node contains an integer value and references to left and right children. # Output - Return a boolean value `True` if the trees are equal, otherwise, return `False`. # Constraints 1. The number of nodes in each tree is in the range [0, 100]. 2. The value of every node in the trees is in the range [-100, 100]. # Example ```python # Example 1 tree_p = [1, 2, 3] tree_q = [1, 2, 3] Output: True # Example 2 tree_p = [1, 2] tree_q = [1, None, 2] Output: False # Example 3 tree_p = [1, 2, 1] tree_q = [1, 1, 2] Output: False ``` # Note * If `tree_p` and `tree_q` are both `None`, return `True`. * Use Depth-First Search (DFS) recursively to solve this problem. * Ensure to handle edge cases proactively. # Evaluation Criteria 1. Correctness: The function should return the correct boolean result. 2. Time Complexity: Your solution should operate within the outlined complexity. 3. Space Complexity: Minimize additional data structures; make efficient use of recursion. 4. Code Quality: The code should be clean, well-documented, and follow good naming conventions.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p: TreeNode, tree_q: TreeNode) -> bool: # If both trees are empty, they are the same if not tree_p and not tree_q: return True # If one of the trees is empty, and the other is not, they are not the same elif not tree_p or not tree_q: return False # If the values of the current nodes are different, they are not the same elif tree_p.val != tree_q.val: return False # Recursively check the left and right subtrees else: return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"You have been assigned to find two unique numbers in a list where every other number appears exactly twice. This problem tests your ability to efficiently use bit manipulation to achieve the desired result with optimal time and space complexity. **Problem Statement**: Given an array of integers `nums`, where exactly two elements appear only once and all the other elements appear exactly twice, write a function `find_two_unique_numbers(nums)` to find the two elements that appear only once. **Function Signature**: ```python def find_two_unique_numbers(nums: List[int]) -> List[int]: pass ``` **Input**: * `nums` - a list of integers where exactly two elements appear only once and all the others appear twice (2 ≤ len(nums) ≤ 3 * 10^4). **Output**: * A list of two integers which are the elements in `nums` that appear only once. The order of the result is not important. **Constraints**: * Your solution should have a time complexity of O(N) and a space complexity of O(1). **Examples**: ```python assert find_two_unique_numbers([1, 2, 1, 3, 2, 5]) == [3, 5] or [5, 3] assert find_two_unique_numbers([4, 1, 2, 1, 2, 3]) == [4, 3] or [3, 4] ``` Ensure your solution is well-tested and handles all edge cases appropriately, such as the minimum and maximum size input arrays.","solution":"from typing import List def find_two_unique_numbers(nums: List[int]) -> List[int]: # Step 1: Get the XOR of the two unique numbers xor_result = 0 for num in nums: xor_result ^= num # Step 2: Get the rightmost set bit in the xor_result rightmost_set_bit = xor_result & -xor_result # Step 3: Divide the numbers into two groups based on the rightmost set bit num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"Solve Congruences with Chinese Remainder Theorem You are provided with `n` modular equations in the form: [ x % nums[i] = rems[i] ] where `i` ranges from `0` to `n-1`, and the integers in `nums` list are pairwise coprime. Your task is to implement a function that finds the smallest positive integer `x` that satisfies all the given congruences using the Chinese Remainder Theorem. Function Signature ```python def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: ``` Input * `nums`: A list of `n` positive integers (n >= 1) where all elements are greater than 1 and pairwise coprime. * `rems`: A list of `n` positive integers representing the remainders. Output * Return the smallest positive integer `x` that satisfies the given system of congruences. Constraints * The length of `nums` and `rems` shall be equal. * Each integer in `nums` will be greater than 1. * All integers in `nums` are pairwise coprime. Example ```python nums = [3, 4, 5] rems = [2, 3, 1] # Explanation: # x % 3 = 2 # x % 4 = 3 # x % 5 = 1 # The smallest such x is 11. result = solve_chinese_remainder(nums, rems) print(result) # Output: 11 ``` Edge Cases * Handling empty input lists should raise an exception. * Input lists `nums` and `rems` of different lengths should raise an exception. * All elements in `nums` must be pairwise coprime, otherwise, an exception should be raised. Performance * Ensure that the function is efficient for moderately sized input lists.","solution":"from typing import List from functools import reduce def solve_chinese_remainder(nums: List[int], rems: List[int]) -> int: Solves the system of congruences using the Chinese Remainder Theorem. :param nums: List of pairwise coprime integers. :param rems: List of remainders. :return: Smallest positive integer x that satisfies all given congruences. # Ensure that input lists are non-empty and of the same size if not nums or not rems or len(nums) != len(rems): raise ValueError(\\"Input lists must be non-empty and of the same length.\\") # Check if all elements in nums are pairwise coprime for i in range(len(nums)): for j in range(i+1, len(nums)): if gcd(nums[i], nums[j]) != 1: raise ValueError(\\"All integers in nums must be pairwise coprime.\\") def egcd(a, b): Extended Euclidean Algorithm Returns a tuple (g, x, y) such that a*x + b*y = g = gcd(a, b) if a == 0: return (b, 0, 1) else: g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x) def mod_inverse(a, m): Returns the modular inverse of a under modulo m, which is the number x such that (a * x) % m == 1 g, x, y = egcd(a, m) if g != 1: raise ValueError(f\\"No mod inverse for {a} and {m}, they are not coprime.\\") else: return x % m # Product of all numbers in nums prod = reduce(lambda a, b: a * b, nums) result = 0 for num, rem in zip(nums, rems): p = prod // num inv = mod_inverse(p, num) result += rem * inv * p return result % prod def gcd(a, b): Returns the greatest common divisor of a and b using Euclid\'s Algorithm. while b != 0: a, b = b, a % b return a"},{"question":"# ZigZag Iterator Generalization You are tasked with implementing a ZigZag Iterator that can handle `k` lists, not just two. This iterator should alternate between elements of all provided lists in a cyclic manner. Problem Statement Design and implement a `KZigZagIterator` class that alternates elements from `k` different lists until all elements are exhausted. Requirements 1. **Constructor**: `__init__(self, lists: List[List[int]])` - The constructor should take a single argument: a list of lists containing integers. 2. **next**: `def next(self) -> int` - This method should return the next element in the zigzag order of the lists. 3. **has_next**: `def has_next(self) -> bool` - This method should return `True` if there are more elements to be returned, otherwise `False`. Example Given three input lists: ``` l1 = [1, 2, 3] l2 = [4, 5] l3 = [6, 7, 8, 9] it = KZigZagIterator([l1, l2, l3]) ``` Calling the iterator methods in sequence should give: ``` it.next() -> 1 it.next() -> 4 it.next() -> 6 it.next() -> 2 it.next() -> 5 it.next() -> 7 it.next() -> 3 it.next() -> 8 it.next() -> 9 it.has_next() -> False ``` Constraints - The input list of lists will have `k` lists where `1 <= k <= 1000`. - The total number of elements across all lists will not exceed `10^5`. Implementation Notes - Implement the `KZigZagIterator` class to handle any number of input lists and correctly alternate between them. - Consider edge cases such as empty lists and lists of varying lengths. - Ensure the solution efficiently handles the input size within the provided constraints.","solution":"from collections import deque from typing import List class KZigZagIterator: def __init__(self, lists: List[List[int]]): self.queue = deque() for i, lst in enumerate(lists): if lst: self.queue.append((i, 0)) # Each element is a tuple (list_index, element_index) self.lists = lists def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") list_idx, elem_idx = self.queue.popleft() value = self.lists[list_idx][elem_idx] if elem_idx + 1 < len(self.lists[list_idx]): self.queue.append((list_idx, elem_idx + 1)) return value def has_next(self) -> bool: return bool(self.queue)"},{"question":"# Context Imagine you are a software engineer working on optimizing a large-scale data processing system that leverages parallel computing. Your task is to implement and extend a sorting algorithm that is efficient in parallel environments. # Problem Statement You need to implement a bitonic sort algorithm that sorts an array of integers. The bitonic sort should be able to handle arrays of arbitrary sizes by implementing necessary modifications. # Function Signature ```python def extended_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers of arbitrary size. - `reverse`: A boolean flag that, if set to `True`, sorts the array in increasing order. If `False`, sorts in decreasing order. Default is `False`. # Output - Returns the sorted list of integers. # Constraints - Your solution should handle arrays of any size, not just powers of two. - For arrays of size not a power of two, appropriately pad the array to the nearest power of two value with the maximum integer value `sys.maxsize` for increasing order and `sys.minint` for decreasing order, then remove the padding in the final step. # Performance Requirements - Aim for (O(n log(n)^2)) time complexity in non-parallel execution. - Ensure that the solution does not exceed (O(n)) additional space complexity due to padding. # Example ```python # For increasing order assert extended_bitonic_sort([12, 4, 78, 22]) == [4, 12, 22, 78] # For decreasing order assert extended_bitonic_sort([12, 4, 78, 22], reverse=True) == [78, 22, 12, 4] ``` Feel free to use standard library functions if necessary, but the core sorting logic should be your implementation of bitonic sort.","solution":"import sys from typing import List def bitonic_merge(arr, low, cnt, reverse): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if reverse == (arr[i] > arr[i + k]): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, reverse) bitonic_merge(arr, low + k, k, reverse) def bitonic_sort_recursive(arr, low, cnt, reverse): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, reverse) def nearest_power_of_two(x): return 1 << (x - 1).bit_length() def extended_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: n = len(arr) if n == 0: return arr nearest_pow2 = nearest_power_of_two(n) if nearest_pow2 != n: padding_value = -sys.maxsize - 1 if reverse else sys.maxsize arr.extend([padding_value] * (nearest_pow2 - n)) bitonic_sort_recursive(arr, 0, nearest_pow2, not reverse) if nearest_pow2 != n: arr = arr[:n] return arr"},{"question":"# Question: Pathfinding in an Undirected Graph You are required to implement three functions to find paths in an undirected graph represented as an adjacency list. The graph can contain multiple components (disconnected subgraphs). Each edge is bidirectional. **Function: `find_path`** - **Purpose**: This function should find any path between two nodes, `start` and `end`. - **Input**: - `graph`: A dictionary where each key is a node and its value is a list of connected nodes. - `start`: The starting node. - `end`: The destination node. - **Output**: A list representing a path from `start` to `end`. If no path exists, return `None`. **Function: `find_all_paths`** - **Purpose**: This function should find all paths between two nodes, `start` and `end`. - **Input**: - `graph`: A dictionary where each key is a node and its value is a list of connected nodes. - `start`: The starting node. - `end`: The destination node. - **Output**: A list of lists, where each sublist represents a separate path from `start` to `end`. If no paths exist, return an empty list. **Function: `find_shortest_path`** - **Purpose**: This function should find the shortest path between two nodes, `start` and `end`. - **Input**: - `graph`: A dictionary where each key is a node and its value is a list of connected nodes. - `start`: The starting node. - `end`: The destination node. - **Output**: A list representing the shortest path from `start` to `end`. If no path exists, return `None`. # Constraints - The graph contains at most `10^3` nodes. - Each node and each adjacency list are represented as strings. - Assume no parallel edges and no self-loops. - `start` and `end` will be valid nodes present in the graph. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } # Example for find_path assert find_path(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] # Example for find_all_paths assert find_all_paths(graph, \'A\', \'E\') == [[\'A\', \'B\', \'E\'], [\'A\', \'C\', \'F\', \'E\']] # Example for find_shortest_path assert find_shortest_path(graph, \'A\', \'E\') == [\'A\', \'B\', \'E\'] ``` You must implement these functions according to the specifications given and consider all edge cases discussed.","solution":"def find_path(graph, start, end, path=None): if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=None): if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths from collections import deque def find_shortest_path(graph, start, end): if start == end: return [start] visited = {start} queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next_node in set(graph[vertex]) - visited: if next_node == end: return path + [next_node] else: visited.add(next_node) queue.append((next_node, path + [next_node])) return None"},{"question":"# Scenario: You are a software engineer working on a data analysis module for a health monitoring system. In this system, you often need to filter out invalid sensor readings based on some predefined safe limits to ensure accurate health metrics. # Problem Statement: Write a function named `filter_readings` that takes an array of sensor readings and optional minimum and maximum limits. The function should return a new array containing only the readings within the specified limits. If a limit is not provided (i.e., `None`), it should default to the minimum or maximum value found in the array. # Function Signature: ```python def filter_readings(readings: List[int], min_limit: Optional[int] = None, max_limit: Optional[int] = None) -> List[int]: ``` # Input: * `readings`: A list of integers representing sensor readings. * `min_limit`: An optional integer representing the minimum value limit (inclusive). Defaults to `None`. * `max_limit`: An optional integer representing the maximum value limit (inclusive). Defaults to `None`. # Output: * A list of integers containing only the elements within the specified limits. # Constraints: 1. The input list `readings` can be of length 0 to (10^6). 2. The values in `readings` and the limits `min_limit` and `max_limit` are integers. 3. If both limits are None, the function should behave as if there are no limits and return the original array. # Example: *Example 1:* ```python filter_readings([15, 23, 8, 42, 7], min_limit=10, max_limit=30) ``` *Output:* ```python [15, 23] ``` *Example 2:* ```python filter_readings([10, 20, -5, 3, 55], min_limit=None, max_limit=10) ``` *Output:* ```python [10, -5, 3] ``` *Example 3:* ```python filter_readings([12, 5, 19, 7], min_limit=15, max_limit=None) ``` *Output:* ```python [19] ``` *Example 4:* ```python filter_readings([]) ``` *Output:* ```python [] ``` # Notes: 1. Ensure the solution handles edge cases like empty arrays. 2. The function should have a time complexity of O(n).","solution":"from typing import List, Optional def filter_readings(readings: List[int], min_limit: Optional[int] = None, max_limit: Optional[int] = None) -> List[int]: if not readings: return [] actual_min = min_limit if min_limit is not None else min(readings) actual_max = max_limit if max_limit is not None else max(readings) return [reading for reading in readings if actual_min <= reading <= actual_max]"},{"question":"# Scenario: You are tasked to implement a new type of data storage system for a high-speed trading application that requires very low latency for data access and modifications. The ideal data structure for this task should be able to handle frequent insertions, deletions, and lookups efficiently. # Task: Write a class `OptimizedHashTable` that extends the provided `ResizableHashTable` class. Implement a method `put` with optimized collision resolution using quadratic probing. Quadratic probing attempts to resolve collisions by checking the next available slot in a quadratic sequence (i.e., hash(key) + i^2). ```python class OptimizedHashTable(ResizableHashTable): def put(self, key, value): Add the key-value pair to the hash table. :param key: Key to be added :param value: Value to be associated with the key # Your code here ``` # Requirements: 1. Implement quadratic probing for collision resolution in the `put` method of `OptimizedHashTable`. 2. Ensure the hash table resizes appropriately to handle more keys if it reaches a 2/3 load factor. 3. Handle edge cases such as duplicate keys and deleted entries correctly. # Input/Output * **Input**: `key` (integer), `value` (any type) * **Output**: None # Constraints * The hash table size should be a power of two initially and should double in size when the load factor exceeds 2/3. * Ensure average case O(1) time complexity for `put`, `get`, and `del_` operations. Example: ```python hash_table = OptimizedHashTable() hash_table.put(1, \'a\') hash_table.put(12, \'b\') # Assuming size 11, causes collision and quadratic probing resolves it correctly value = hash_table.get(1) print(value) # Output: \'a\' value = hash_table.get(12) print(value) # Output: \'b\' del hash_table[1] value = hash_table.get(1) print(value) # Output: None ``` **Note**: You do not need to implement the `get` and `del_` methods; they can use the inherited behavior from `ResizableHashTable`.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.count = 0 self.load_factor_threshold = 2/3 self.table = [None] * self.size def hash(self, key): return key % self.size def resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None and item != \\"DELETED\\": self.put(item[0], item[1]) def get(self, key): index = self.hash(key) i = 0 while self.table[index] is not None: if self.table[index] != \\"DELETED\\" and self.table[index][0] == key: return self.table[index][1] i += 1 index = (self.hash(key) + i * i) % self.size return None def del_(self, key): index = self.hash(key) i = 0 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = \\"DELETED\\" self.count -= 1 return True i += 1 index = (self.hash(key) + i * i) % self.size return False class OptimizedHashTable(ResizableHashTable): def put(self, key, value): if self.count / self.size >= self.load_factor_threshold: self.resize() index = self.hash(key) i = 0 while self.table[index] is not None and self.table[index] != \\"DELETED\\": if self.table[index][0] == key: self.table[index] = (key, value) return i += 1 index = (self.hash(key) + i * i) % self.size self.table[index] = (key, value) self.count += 1"},{"question":"Scenario Imagine you are hired by a software company to develop a feature for displaying a hierarchical structure. Each hierarchy is represented as a binary tree, and you are required to show the values of nodes at each level. Task Write a function `level_order` that takes the root of a binary tree and returns a list of lists, where each list contains the values of nodes at that particular level from left to right. Function Signature ```python def level_order(root: \'TreeNode\') -> List[List[int]]: ``` Input - `root`: The root node of a binary tree, which could be `None` (indicating an empty tree). Output - A list of lists, where each inner list contains the values at that particular level of the binary tree from left to right. Constraints - The number of nodes in the tree won\'t exceed `1000`. - Node values are integers. Examples 1. For a binary tree: ``` 3 / 9 20 / 15 7 ``` The function should return: ``` python [[3], [9, 20], [15, 7]] ``` 2. For an empty binary tree: ``` python [] ``` 3. For a binary tree with a single node: ``` 1 ``` The function should return: ``` python [[1]] ``` Hints - Use a queue to keep track of nodes at each level. - Process all nodes at the current level before moving to the next level.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"**Tree Structure Printing** You are given a tree represented as a nested dictionary, where each key is a string corresponding to the name of a department and each value is a list of sub-elements. The sub-elements can either be strings (sub-departments) or integers (indicating some kind of metric related to the department). Your task is to implement a function `tree_print(tree: dict) -> None` that prints this tree structure with the following format: - Each department name should be printed followed by all its sub-elements. - If a sub-element is another department name or metric, print it inline. If it\'s an integer, add a newline and a space for further indentation. # Input - A dictionary `tree` where each key is a department name and each value is a list containing strings (sub-departments) and/or integers (metrics). # Output - Print the tree\'s hierarchical structure to the standard output. # Constraints - The tree will only be one level deep (i.e., each department has direct sub-elements, no nested sub-departments). - You can assume well-formed input. - Sub-elements follow the pattern: strings and integers. # Example Given the tree: ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } ``` The function call `tree_print(tree)` should output: ```plaintext a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Implement the function `tree_print(tree: dict) -> None` using the guidelines above.","solution":"def tree_print(tree: dict) -> None: Prints the tree structure as described. for department, sub_elements in tree.items(): line = f\\"{department} -> \\" line_elements = [] for sub_element in sub_elements: line_elements.append(str(sub_element)) line += \\" -> \\".join(line_elements) print(line)"},{"question":"# Run-Length Encoding and Decoding Objective Your task is to implement two functions, `encode_rle` and `decode_rle`, that perform run-length encoding and decoding, respectively. Detailed Implementation 1. **encode_rle(input_string)**: - **Input**: A string consisting of consecutive sequences of characters. - **Output**: A compressed run-length encoded string. 2. **decode_rle(encoded_string)**: - **Input**: A run-length encoded string. - **Output**: The original uncompressed string. Requirements 1. The `encode_rle` function should compress the input string by converting consecutive repeated characters into count-character pairs. 2. The `decode_rle` function should decompress back the encoded string to the original form. 3. Both functions should handle empty strings effectively. 4. Both functions should assume that valid inputs are provided and focus on correctly implementing the compression and decompression. Example ```python # Example run for encode_rle function assert encode_rle(\\"aaabbcc\\") == \\"3a2b2c\\" assert encode_rle(\\"aaaaaa\\") == \\"6a\\" assert encode_rle(\\"\\") == \\"\\" # Example run for decode_rle function assert decode_rle(\\"3a2b2c\\") == \\"aaabbcc\\" assert decode_rle(\\"6a\\") == \\"aaaaaa\\" assert decode_rle(\\"\\") == \\"\\" ``` Function Signatures ```python def encode_rle(input_string: str) -> str: pass def decode_rle(encoded_string: str) -> str: pass ``` Constraints * The input string for `encode_rle` will only consist of lowercase alphabets. * The encoded string for `decode_rle` will always be a valid run-length encoded string with properly formatted counts and characters.","solution":"def encode_rle(input_string: str) -> str: if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char encoded_string.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded_string) def decode_rle(encoded_string: str) -> str: if not encoded_string: return \\"\\" decoded_string = [] count = \\"\\" for char in encoded_string: if char.isdigit(): count += char else: decoded_string.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded_string)"},{"question":"# Merge k Sorted Linked Lists You are given an array of k linked lists, where each linked list is sorted in ascending order. Your task is to merge all the linked lists into one sorted linked list and return it. # Input Format: - **k** number of linked lists represented as an array of `Node` objects. - Each linked list is non-empty and sorted in ascending order. # Output Format: - Return the head of the merged linked list. # Constraints: - `1 <= k <= 10^4` - `Each linked list will have at most `10^3` nodes. # Performance Requirement: - The solution must efficiently handle merging `k` linked lists with up to `10^7` total nodes. - Aim for a time complexity of O(N log k), where N is the total number of nodes across all lists. # Example: ```python # Sample Inputs lists = [ Node([1, 4, 5]), Node([1, 3, 4]), Node([2, 6]) ] # Expected Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ``` # Implementation: Implement the function `merge_k_lists` to achieve this: ```python from heapq import heappop, heappush class Node: def __init__(self, x): self.val = x self.next = None def merge_k_lists(lists): if not lists: return None heap = [] for i in range(len(lists)): if lists[i]: heappush(heap, (lists[i].val, i, lists[i])) # (value, index, node) dummy = Node(0) current = dummy while heap: val, idx, node = heappop(heap) current.next = node current = current.next if node.next: heappush(heap, (node.next.val, idx, node.next)) return dummy.next # Example Usage lists = [ Node(1, Node(4, Node(5))), Node(1, Node(3, Node(4))), Node(2, Node(6)) ] merged_head = merge_k_lists(lists) print_linked_list(merged_head) # Custom print function to display list ```","solution":"from heapq import heappop, heappush class Node: def __init__(self, x): self.val = x self.next = None def merge_k_lists(lists): if not lists or len(lists) == 0: return None heap = [] # Initialize the min heap with the head nodes of each list for i in range(len(lists)): if lists[i]: heappush(heap, (lists[i].val, i, lists[i])) # (value, index, node) dummy = Node(0) current = dummy while heap: val, idx, node = heappop(heap) current.next = node current = current.next if node.next: heappush(heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"# Task: Advanced Interpolation Search Implementation Write a function `advanced_interpolation_search` which extends the given interpolation search algorithm to handle additional scenarios and optimize for non-uniform distributions. You need to implement the following additional features: 1. **Adapt the search strategy** if the interpolation formula does not yield a good distribution pattern and switch to binary search in such cases. 2. **Handle boundary conditions explicitly** where `array[high] == array[low]` to avoid division by zero. 3. **Pre-check the search key** to ensure it\'s within the array bounds to minimize unnecessary computations. 4. **Implement early exit conditions** to handle non-uniform distributions more gracefully and improve worst-case performance. # Function Signature ```python def advanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. Examples: >>> advanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> advanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> advanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> advanced_interpolation_search([10, 10, 10, 10], 10) 0 ``` # Input - `array`: A sorted list of integers. - `search_key`: An integer representing the key to search in the array. # Output - Returns the index of the `search_key` if found, otherwise -1. # Constraints - The array will have between 0 and 10^6 elements. - The elements in the array will be between -10^9 and 10^9. # Example Scenario Consider an e-commerce application\'s product prices which are sorted. Implementing an efficient search mechanism is crucial for quickly finding the price of a particular product from these sorted prices.","solution":"from typing import List def advanced_interpolation_search(array: List[int], search_key: int) -> int: Perform an advanced interpolation search to handle additional scenarios and optimize for non-uniform distributions. :param array: The sorted array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Handle boundary condition where array[high] == array[low] to avoid division by zero if array[high] == array[low]: if array[low] == search_key: return low else: return -1 # Estimate the position using interpolation formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Perform boundary checks if pos >= len(array): return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 # Adapt the strategy: if calculated position jumps too far, switch to binary search if pos < low or pos > high: low = low + (high - low) // 2 return -1"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Run-length Encoding (RLE) * **Type**: Compression algorithm * **Main Purpose**: To compress and decompress sequences by replacing consecutive repeating characters with a count followed by the character. # Complexity * **Time Complexity**: - `encode_rle`: O(n), where n is the length of the input string. - `decode_rle`: O(m), where m is the length of the encoded string. * **Space Complexity**: - `encode_rle`: O(1) additional space plus O(k) for the output string, where k is the length of the encoded string (≤ n). - `decode_rle`: O(1) additional space plus O(l) for the output string, where l is the length of the decoded string. # Principles * **Encode**: 1. Traverse the input string. 2. Count successive characters and store the count followed by the character. * **Decode**: 1. Traverse the encoded string. 2. For each number-character pair, repeat the character `number` times to form the original sequence. # Characteristics & Applications * **Properties**: - Lossless compression: the original data can be perfectly reconstructed. - More effective for data with repetitive sequences. * **Common Use Cases**: - Simple compression of text files or images where consecutive data elements repeat. - Basic data serialization. * **Strengths/Limitations**: - **Strengths**: Simple to implement, efficient for highly repetitive data. - **Limitations**: Ineffective for data without sufficient repetition, can increase size for non-repetitive data. # Implementation Challenges * **Edge Cases**: - Empty input string. - Input string with no repeating characters. - Single character input. * **Performance Bottlenecks**: - Large input strings can result in a proportional output size. - Decoding heavily relies on string manipulation which could be slow for very large strings. * **Error Scenarios**: - Invalid encoded string format (e.g., count not followed by a character). * **Optimization Points**: - String concatenation in Python is O(n), consider using `list.append()` followed by `\'\'.join(list)` for better performance in large strings. <|Analysis End|> <|Question Begin|> # Run-Length Encoding and Decoding **Context**: You are given a simple compression mechanism, Run-Length Encoding (RLE), which compresses sequences by replacing consecutive repeating characters with the character followed by its count. While this approach can effectively reduce the size of data with many repeating characters, it is less effective for non-repetitive data. **Task**: Implement a function to perform Run-Length Encoding and another to perform Run-Length Decoding based on given strings. Your goal is to compress and decompress string sequences. # Function Signature ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` # Input/Output Requirements: 1. **`encode_rle(input: str) -> str`**: - **Input**: A string `input` with a length of `n` (1 ≤ n ≤ 10^5), containing only uppercase/lowercase letters. - **Output**: A run-length encoded string. 2. **`decode_rle(input: str) -> str`**: - **Input**: A string `input` in a valid run-length encoded format. - **Output**: The original, uncompressed string. # Constraints: - The encoded string for any input will not exceed `10^6` characters in length. # Examples: ```python # Example 1: input_string = \\"aaabbc\\" encoded_string = encode_rle(input_string) # encoded_string should be \\"3a2b1c\\" decoded_string = decode_rle(encoded_string) # decoded_string should be \\"aaabbc\\" # Example 2: input_string = \\"abcd\\" encoded_string = encode_rle(input_string) # encoded_string should be \\"1a1b1c1d\\" decoded_string = decode_rle(encoded_string) # decoded_string should be \\"abcd\\" # Example 3: input_string = \\"a\\" encoded_string = encode_rle(input_string) # encoded_string should be \\"1a\\" decoded_string = decode_rle(encoded_string) # decoded_string should be \\"a\\" ``` # Performance Requirements: - Ensure that both functions work efficiently even for the upper limits of input sizes, maintaining the time and space complexities outlined above.","solution":"def encode_rle(input: str) -> str: Encode a given string using Run-Length Encoding. Args: input (str): Input string to encode. Returns: str: Run-Length Encoded string. if not input: return \\"\\" encoded_str = [] current_char = input[0] count = 1 for char in input[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_str.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: Decode a given Run-Length Encoded string. Args: input (str): Run-Length Encoded string to decode. Returns: str: Decoded original string. decoded_str = [] number = \\"\\" for char in input: if char.isdigit(): number += char else: decoded_str.append(char * int(number)) number = \\"\\" return \'\'.join(decoded_str)"},{"question":"# Problem Description You are given two strings, `s1` and `s2`. Your task is to determine if `s2` is a rotation of `s1`. A string is considered a rotation of another string if it can be obtained by shifting the characters of the original string to the right or left. Write a function `is_rotated(s1: str, s2: str) -> bool` that returns `True` if `s2` is a rotation of `s1` and `False` otherwise. # Input Format * The inputs are two strings `s1` and `s2` consisting of lower-case alphabets. # Output Format * Return a boolean value: `True` if `s2` is a rotation of `s1`, else `False`. # Performance Requirements * The solution should be efficient, with a time complexity of O(N) where N is the length of the strings, and a reasonable space complexity. # Constraints * `1 <= len(s1), len(s2) <= 1000` # Example Example 1 ```plaintext Input: s1 = \\"hello\\" s2 = \\"llohe\\" Output: True ``` Example 2 ```plaintext Input: s1 = \\"hello\\" s2 = \\"ohell\\" Output: True ``` Example 3 ```plaintext Input: s1 = \\"hello\\" s2 = \\"lleho\\" Output: False ``` # Edge Cases * Consider and handle situations where the strings are of different lengths. * Consider and handle cases where strings are empty or identical. # Constraints & Assumptions * Both strings contain only lowercase English letters. * Assumption that Python\'s substring search has an average-time complexity of O(N).","solution":"def is_rotated(s1: str, s2: str) -> bool: Checks if s2 is a rotation of s1. if len(s1) != len(s2): return False return s2 in (s1 + s1)"},{"question":"# Byte Order and Large Integer Arithmetic Endianness is an important aspect to consider in many computer systems when data is being transferred or stored. As an exercise, you are required to implement functions that not only convert integers to bytes and vice versa but also handle cases involving byte alignments and large numbers. Your task also involves ensuring the correctness of these conversions under all edge cases. Task 1. **Function 1**: Implement `optimized_int_to_bytes_big_endian(num)` which converts an integer `num` to a bytes object in big endian order. 2. **Function 2**: Implement `optimized_int_to_bytes_little_endian(num)` which converts an integer `num` to a bytes object in little endian order. 3. **Function 3**: Implement `optimized_bytes_big_endian_to_int(bytestr)` which converts a bytes object in big endian order back to an integer. 4. **Function 4**: Implement `optimized_bytes_little_endian_to_int(bytestr)` which converts a bytes object in little endian order back to an integer. Input - `num`: A positive integer in the range `[0, 10^18]`. - `bytestr`: A `bytes` object representing the integer in the respective endianness format. Output - For the byte conversion functions (`optimized_int_to_bytes_big_endian` and `optimized_int_to_bytes_little_endian`), return a `bytes` object. - For the integer conversion functions (`optimized_bytes_big_endian_to_int` and `optimized_bytes_little_endian_to_int`), return an integer. Constraints - Ensure that the functions handle edge cases, such as the integer `0` and very large integers. - Optimize your code to minimize memory allocation and improve execution efficiency. Examples ```python assert optimized_int_to_bytes_big_endian(305419896) == bytes([0x12, 0x34, 0x56, 0x78]) assert optimized_int_to_bytes_little_endian(305419896) == bytes([0x78, 0x56, 0x34, 0x12]) assert optimized_bytes_big_endian_to_int(bytes([0x12, 0x34, 0x56, 0x78])) == 305419896 assert optimized_bytes_little_endian_to_int(bytes([0x78, 0x56, 0x34, 0x12])) == 305419896 ``` You may use the provided code snippets as a reference to understand the necessary operations but remember to implement the optimizations suggested.","solution":"def optimized_int_to_bytes_big_endian(num): Converts an integer to a bytes object in big endian order. if num == 0: return bytes([0]) result = [] while num > 0: result.append(num & 0xFF) num >>= 8 return bytes(result[::-1]) def optimized_int_to_bytes_little_endian(num): Converts an integer to a bytes object in little endian order. if num == 0: return bytes([0]) result = [] while num > 0: result.append(num & 0xFF) num >>= 8 return bytes(result) def optimized_bytes_big_endian_to_int(bytestr): Converts a bytes object in big endian order back to an integer. result = 0 for byte in bytestr: result = (result << 8) | byte return result def optimized_bytes_little_endian_to_int(bytestr): Converts a bytes object in little endian order back to an integer. result = 0 for i in range(len(bytestr)): result |= bytestr[i] << (i * 8) return result"},{"question":"# Problem Description Given a string `s` and a dictionary set `dict`, write a function `countSentences(s: str, dict: set) -> int` that returns the number of possible ways the string can be split into valid words found in the dictionary set. # Input - A string `s` (1 <= len(s) <= 1000), composed of lowercase alphabetical characters. - A set `dict` containing unique words (each word `1 <= len(word) <= 100`) also composed of lowercase alphabetical characters. # Output - Return an integer representing the number of valid sentences that can be formed using the words from the dictionary. # Constraints - Assume all inputs are valid and non-empty. - Consider performance: aim for a solution better than the naive exponential method. # Scenario Imagine you\'re designing a text-based game where players type in sequences of characters. The game splits the sequence into valid words based on a predefined dictionary and calculates how many different ways this split can occur, rewarding players accordingly. # Example Example 1 ```python s = \\"appletablet\\" dict = {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"table\\", \\"t\\"} # There are 4 valid sentences: # 1. \\"apple\\" + \\"tablet\\" # 2. \\"apple\\" + \\"table\\" + \\"t\\" # 3. \\"applet\\" # 4. \\"app\\" + \\"let\\" + \\"able\\" + \\"t\\" Output: 4 ``` Example 2 ```python s = \\"thing\\" dict = {\\"thing\\"} # There is 1 valid sentence: # 1. \\"thing\\" Output: 1 ``` # Function Signature ```python def countSentences(s: str, dict: set) -> int: pass ``` **Note**: Implement the function while considering optimizations such as memoization or dynamic programming to achieve better performance.","solution":"def countSentences(s: str, dict: set) -> int: Returns the number of possible ways the string `s` can be split into valid words found in the dictionary `dict`. # Memoization dictionary to store the solution to subproblems memo = {} def dfs(start): # If we reached the end of the string, that\'s a valid sentence if start == len(s): return 1 # If we have already computed the subproblem, return the stored result if start in memo: return memo[start] count = 0 # Try every possible end position for current start position for end in range(start + 1, len(s) + 1): word = s[start:end] if word in dict: count += dfs(end) # Store the result in memo dictionary memo[start] = count return count return dfs(0)"},{"question":"# Context: Roadways Ltd. needs to lay out a network of roads connecting multiple cities such that the total construction cost is minimized. Each city is connected by some roads which have specific construction costs. Roadways Ltd. wants to ensure that every city can be reached from any other city, and the total cost of constructing the roads is as low as possible. # Task: Implement a function that uses **Kruskal\'s Algorithm** to find the **Minimum Spanning Tree (MST)** of a given weighted, connected, undirected graph, and returns the total weight of the MST. # Function Signature: ```python def find_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: :param vertex_count: Number of vertices in the graph :param edges: List of tuples where each tuple contains (source, target, weight) representing an edge in the graph. :return: The total weight of the minimum spanning tree. pass ``` # Input: * `vertex_count` (int) - Number of 1-indexed vertices in the graph (1 ≤ vertex_count ≤ 1000). * `edges` (List of Tuples) - List of edges in the graph (edge count `E` can be up to 3000). Each edge is represented by a tuple `(source, target, weight)`. # Output: * Returns an integer representing the total weight of the minimum spanning tree for the given graph. # Constraints: * Input graph will always be connected. * Duplicate edges and self-loops will not be present. # Example: ```python print(find_mst(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)])) # Output: 14 print(find_mst(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)])) # Output: 40 ``` # Explanation of Example: In the first example, the MST connecting all the vertices with minimum weight would have an edge total of 14. In the second example, the MST would have an edge total of 40.","solution":"from typing import List, Tuple def find_mst(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: Finds the total weight of the Minimum Spanning Tree (MST) using Kruskal\'s algorithm. :param vertex_count: Number of vertices in the graph :param edges: List of tuples where each tuple contains (source, target, weight) representing an edge in the graph. :return: The total weight of the minimum spanning tree. # Helper function to find the root of a set element def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to do union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort all the edges in non-decreasing order of their weight edges.sort(key=lambda x: x[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(vertex_count): parent.append(node) rank.append(0) mst_weight = 0 # Initialize result mst_edges = [] # List to store the edges of the MST # Number of edges to be taken is equal to V-1 i = 0 # index variable for sorted edges while len(mst_edges) < vertex_count - 1: # Pick the smallest edge and increment the index for next iteration u, v, w = edges[i] i += 1 x = find(parent, u-1) y = find(parent, v-1) # If including this edge does not cause cycle, include it in result # and increment the index of result for next edge if x != y: mst_edges.append((u, v, w)) mst_weight += w union(parent, rank, x, y) return mst_weight"},{"question":"# Word Symbol Bracketing You are given an array of words and an array of symbols. The task is to check each word for occurrences of the symbols, and replace the matched symbol in the word with the matched symbol surrounded by square brackets `[ ]`. If a word contains multiple symbols, you should choose the symbol that has the longest length. # Scenario Consider you are building a feature for a text editor that highlights specific keywords (symbols) in a document (words). The feature should highlight the longest matching keyword within each word. # Specification: **Function Signature:** ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: ``` **Input:** - `words`: A list of strings `words` where each string is a word in the document. - `symbols`: A list of strings `symbols` where each string is a symbol to search and replace in the words. **Output:** - Returns a list of words with the longest matching symbols highlighted in square brackets. If a word does not contain any of the symbols, the word is returned as is. **Constraints:** - All symbols and words are non-empty strings. - Symbols may overlap within the words. - Symbols can appear in any order within the symbols list. **Example:** ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] output = highlight_symbols(words, symbols) print(output) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] words = [\'apple\', \'banana\', \'cherry\'] symbols = [\'an\', \'rry\', \'pp\'] output = highlight_symbols(words, symbols) print(output) # Output: [\'a[pp]le\', \'b[an]ana\', \'che[rry]\'] ``` # Requirements: - Ensure the solution runs efficiently for larger inputs. - Handle edge cases, such as words without any symbols and multiple symbols within a single word appropriately. - Write clean, readable, and well-documented code.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: Returns a list of words with the longest matching symbols highlighted in square brackets. Args: words (List[str]): A list of words to search through. symbols (List[str]): A list of symbols to highlight in the words. Returns: List[str]: A list of words with matched symbols highlighted. # Sorting symbols by length in descending order so that we match longest first symbols = sorted(symbols, key=len, reverse=True) def highlight_word(word): for symbol in symbols: if symbol in word: return word.replace(symbol, f\'[{symbol}]\', 1) return word return [highlight_word(word) for word in words]"},{"question":"You are given a large text document and a pattern string. Your task is to implement a function that searches for the given pattern within the text using the Knuth-Morris-Pratt (KMP) algorithm. Upon finding the pattern, return the list of starting indices where the pattern appears in the text. # Function Signature ```python def knuth_morris_pratt(text : str, pattern : str) -> List[int]: ``` # Input - `text`: A string representing the main text in which the pattern needs to be searched. (1 ≤ len(text) ≤ 10^6) - `pattern`: A string representing the pattern to be searched in the text. (1 ≤ len(pattern) ≤ 10^5) # Output - A list of integers representing the starting indices in the text where the pattern is found. # Constraints - The text and the pattern consist of only lowercase English letters. # Example ```python >>> knuth_morris_pratt(\'ababcabcabababd\', \'ababd\') [10] >>> knuth_morris_pratt(\'aaaaa\', \'aa\') [0, 1, 2, 3] >>> knuth_morris_pratt(\'this is a simple example\', \'example\') [17] ``` # Notes - You must use the Knuth-Morris-Pratt algorithm for pattern searching. - Consider all possible edge cases during your implementation. - The function should run optimally within the constraints provided.","solution":"from typing import List def knuth_morris_pratt(text: str, pattern: str) -> List[int]: def compute_lps(pattern: str) -> List[int]: lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i = 0 j = 0 indices = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"**Context**: You are working on cleaning up a dataset where certain types of events occur very frequently, and your task is to filter out the excess occurrences beyond a specified threshold. Given a list of event IDs, you need to ensure that no specific event ID appears more than `N` times in its original occurrence order. # **Function Implementation Task** Implement a function `limit_occurrences(lst: List[int], N: int) -> List[int]` that processes the list `lst` and returns a new list where each event ID appears at most `N` times. The order of occurrences should remain the same as the original list. You also need to ensure that the solution performs efficiently for larger input sizes. **Input Format** - `lst` : List of integers representing the event IDs. - `N` : An integer representing the maximum number of occurrences allowed for each event ID. **Output Format** - Your function should return a list of integers where each element from `lst` appears at most `N` times. **Constraints** - `1 <= len(lst) <= 10^5` - `1 <= N <= 1000` - The event IDs in `lst` are positive integers. **Examples** **Example 1:** ```python lst = [1, 2, 3, 1, 2, 1, 2, 3] N = 2 ``` **Output:** ```python [1, 2, 3, 1, 2, 3] ``` **Example 2:** ```python lst = [2, 4, 4, 4, 4] N = 2 ``` **Output:** ```python [2, 4, 4] ``` **Example 3:** ```python lst = [] N = 3 ``` **Output:** ```python [] ``` **Example 4:** ```python lst = [5, 5, 5, 5, 5] N = 1 ``` **Output:** ```python [5] ``` **Edge Cases** - When `lst` is empty, your function should return an empty list. - When `N` is larger than the most frequent element\'s count, all elements should appear as is. # **Performance Requirements** The solution should have a time complexity of O(n) where n is the length of `lst`. It should also utilize space efficiently.","solution":"from typing import List from collections import defaultdict def limit_occurrences(lst: List[int], N: int) -> List[int]: Returns a new list where each event ID appears at most N times in the order of their first occurrences. occurrence_dict = defaultdict(int) result = [] for event in lst: if occurrence_dict[event] < N: result.append(event) occurrence_dict[event] += 1 return result"},{"question":"# Objective You are required to implement a function to sort an array of integers using the Bogo Sort algorithm. Given the inefficient nature of Bogo Sort, ensure to cap the number of iterations to avoid infinite loop situations. Additionally, pay particular attention to identifying and handling edge cases appropriately. # Function Signature `def bogo_sort_with_cap(arr: List[int], iteration_cap: int) -> Tuple[List[int], int]:` # Input - `arr` - a list of integers * Constraints: * 1 <= len(arr) <= 50 * -10^6 <= arr[i] <= 10^6 - `iteration_cap` - an integer representing the cap on the number of iterations. * Constraints: * 1 <= iteration_cap <= 10^6 # Output - A tuple where the first element is the sorted list (or the best attempt sorted list if iteration cap is reached) and the second element is the number of iterations performed. # Requirements: 1. If the array is already sorted, return immediately. 2. Shuffle the array and check if it\'s sorted, repeat until either it\'s sorted or the number of iterations reaches the cap. 3. Ensure the function completes within the given iteration limits. # Example ```python arr = [3, 2, 1] iteration_cap = 1000 print(bogo_sort_with_cap(arr, iteration_cap)) # Output: ([1, 2, 3], X) where X is the number of iterations performed ``` # Notes * The primary goal here is to monitor performance and ensure that the function does not go into an infinite loop. * Handle edge cases such as single-element arrays and empty arrays appropriately.","solution":"import random from typing import List, Tuple def bogo_sort_with_cap(arr: List[int], iteration_cap: int) -> Tuple[List[int], int]: Sort an array using the Bogo Sort algorithm with a cap on the number of iterations. def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iterations = 0 while iterations < iteration_cap: if is_sorted(arr): return arr, iterations random.shuffle(arr) iterations += 1 # If reached here, it means we hit the iteration cap return arr, iterations"},{"question":"You are tasked with augmenting the given `ResizableHashTable` to include an additional feature: a method `get_load_factor()` which computes and returns the current load factor of the hashtable. The load factor is defined as the ratio between the number of key-value pairs and the current size of the hashtable. # Requirements * Implement the method `get_load_factor()` in the `ResizableHashTable` class. * The method should return a float value representing the current load factor. # Expected Input and Output * **Method Signature**: `def get_load_factor(self) -> float:` * **Output**: A float representing the load factor of the hashtable, calculated as the number of key-value pairs divided by the hashtable size. # Constraints * The hashtable size should never be zero. * Assume the hash table does not support key types that lead to large amounts of collision deliberately. # Function Implementation Details 1. Define the method `get_load_factor` within the `ResizableHashTable` class. 2. The method should use the existing attributes of the class to compute the load factor. 3. Additional helper methods or attributes should not be required. # Example If there are 5 key-value pairs and the current size of the table is 11, then the load factor would be ( frac{5}{11} approx 0.4545 ). ```python # Example of how to use the method hash_table = ResizableHashTable() hash_table.put(1, \'a\') hash_table.put(2, \'b\') hash_table.put(3, \'c\') print(hash_table.get_load_factor()) # Output should be close to 0.375 (3/8) ``` # Evaluation Criteria * Correctness of load factor calculation. * Efficient use of class attributes. * Robustness against edge cases.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.size = initial_capacity self.table = [None] * self.size self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.count += 1 if self.count / self.size > 0.7: self._resize() def get(self, key): index = self.hash(key) if self.table[index] is None: return None for k, v in self.table[index]: if k == key: return v return None def _resize(self): new_size = self.size * 2 new_table = [None] * new_size old_table = self.table self.table = new_table self.size = new_size self.count = 0 for bucket in old_table: if bucket: for key, value in bucket: self.put(key, value) def get_load_factor(self): return self.count / self.size"},{"question":"# Question You are required to write a utility function that resolves file paths to their absolute form. This function should handle any relative path components like \'.\' or \'..\' and should also be capable of expanding \'~\' to the user’s home directory. # Function Signature ```python def resolve_path(file: str) -> str: pass ``` # Input - `file` (str): A string representing the file path which could include relative paths or user home directory notation. # Output - Returns a string, which is the absolute path corresponding to the `file` input. # Constraints - The input path string may be empty. - The function should handle paths up to 4096 characters in length. # Example ```python # Example 1 file_path = \'~/documents/../documents/test.txt\' print(resolve_path(file_path)) # Outputs: \'/home/user/documents/test.txt\' # Assuming the user\'s home directory is `/home/user` # Example 2 file_path = \'./project/main.py\' print(resolve_path(file_path)) # Outputs: \'/absolute/path_to/current_directory/project/main.py\' ``` # Requirements 1. Ensure to appropriately handle paths with `.` and `..` . 2. The function should not only expand `~` but also convert relative paths to absolute. 3. The path should be a valid path string up to 4096 characters. # Notes - You can assume a Unix-like environment where \'~\' is a valid notation for the home directory. - You do not need to perform file existence checks.","solution":"import os def resolve_path(file: str) -> str: Resolves file paths to their absolute form, handling relative path components and expanding the user home directory notation. if not file: return \'\' # Expand ~ to the user’s home directory expanded_path = os.path.expanduser(file) # Convert to an absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Roman Numeral Conversion with Custom Conditions You are given the task of converting an integer into its equivalent Roman numeral representation under custom constraints. The integer will be within the range from 1 to 4999. The Roman numerals follow classical rules but for the range above 3999, add a bar (represented as \\"_\\") above the numeral for thousands (i.e., 4000 is represented as _IV). **Function Signature**: ```python def int_to_custom_roman(num: int) -> str: pass ``` **Input**: - An integer `num` within the range from 1 to 4999. **Output**: - A string representing the Roman numeral of the specified integer under the given rules. **Constraints**: - 1 ≤ `num` ≤ 4999 **Examples**: ```python assert int_to_custom_roman(1) == \\"I\\" assert int_to_custom_roman(4) == \\"IV\\" assert int_to_custom_roman(3999) == \\"MMMCMXCIX\\" assert int_to_custom_roman(4000) == \\"_IV\\" assert int_to_custom_roman(4500) == \\"_IVD\\" ``` # Explanation: - Numerals up to 3999 follow standard rules. - From 4000 to 4999, prefix an underscore \\"_\\", denoting \\"IM\\", for thousands beyond 3000. **Your task** is to implement the function `int_to_custom_roman` that handles this conversion considering the above-stated rules and constraints.","solution":"def int_to_custom_roman(num: int) -> str: Convert an integer to its Roman numeral representation with a custom format for numbers above 3999. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] if num > 3999: thousands = num // 1000 remainder = num % 1000 # Prefix with \\"_\\" symbolizing bar over numeral for thousands roman_prefix = \\"_\\" + int_to_custom_roman(thousands) roman_body = int_to_custom_roman(remainder) return roman_prefix + roman_body else: roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral += symbols[i] return roman_numeral"},{"question":"# Question: Calculate Cosine Similarity Between Multiple Pairs of Vectors You are tasked with writing a function to compute the cosine similarity between multiple pairs of vectors efficiently. Specifically, you need to implement a function that computes cosine similarity for each pair of vectors provided in two lists of equal length. Function Signature ```python def batch_cosine_similarity(vectorsA, vectorsB): Calculate cosine similarity for each pair of vectors from vectorsA and vectorsB. :type vectorsA: List[List[float]] :type vectorsB: List[List[float]] :rtype: List[float] ``` Input - `vectorsA` (List of List of float): A list of vectors (each vector is a list of floats). - `vectorsB` (List of List of float): Another list of vectors with the same dimensions as in `vectorsA`. Output - Return a list of floats, where each float is the cosine similarity of the corresponding pairs of vectors from `vectorsA` and `vectorsB`. Constraints - The length of each vector in `vectorsA` and `vectorsB` will be at most 1000. - The number of vectors in `vectorsA` and `vectorsB` will be at most 1000. - Each number in the vectors will be between -1000.0 and 1000.0. # Example ```python vectorsA = [[1, 1, 1], [1, 2, 3]] vectorsB = [[1, 2, -1], [-1, -2, -3]] print(batch_cosine_similarity(vectorsA, vectorsB)) # Output: [0.47140452079103173, -1.0] ``` Detailed Explanation: In the example above, - The first pair of vectors is `[1, 1, 1]` and `[1, 2, -1]`. The cosine similarity between them is `0.47140452079103173`. - The second pair of vectors is `[1, 2, 3]` and `[-1, -2, -3]`. The cosine similarity between them is `-1.0`. Your task is to ensure the implementation of `batch_cosine_similarity` is efficient and handles all edge cases gracefully.","solution":"import math def cosine_similarity(vecA, vecB): Calculate the cosine similarity between two vectors. dot_product = sum(a * b for a, b in zip(vecA, vecB)) normA = math.sqrt(sum(a * a for a in vecA)) normB = math.sqrt(sum(b * b for b in vecB)) if normA == 0 or normB == 0: return 0.0 # Handle case to avoid division by zero. return dot_product / (normA * normB) def batch_cosine_similarity(vectorsA, vectorsB): Calculate cosine similarity for each pair of vectors from vectorsA and vectorsB. similarities = [cosine_similarity(vecA, vecB) for vecA, vecB in zip(vectorsA, vectorsB)] return similarities"},{"question":"# Question: Implement a Median Maintenance Algorithm In real-time data processing, it is often required to find the median of a dynamic set of numbers efficiently as new numbers are added. One efficient solution uses two heaps: a max heap to store the smaller half of the numbers, and a min heap to store the larger half. Task: Implement the `MedianFinder` class which maintains a dynamic list of numbers and calculates the median whenever needed. # Class Definition: ```python class MedianFinder: def __init__(self): # Initialize your data structure here. def add_num(self, num: int) -> None: # Add a number to the data structure def find_median(self) -> float: # Return the median of all elements so far ``` # Expected Behavior: 1. The `add_num(num: int)` method adds an integer `num` from the data stream to the data structure. 2. The `find_median()` method returns the median of all elements so far. The median is: * The middle element of a sorted list if the list length is odd. * The average of the two middle elements of a sorted list if the list length is even. # Constraints: 1. All integers in the data stream are in the range `[-10^5, 10^5]`. 2. The number of elements can be up to `10^4`. 3. The `add_num` and `find_median` methods should run in O(log(n)) and O(1) time complexity respectively. # Example: ```python median_finder = MedianFinder() median_finder.add_num(1) median_finder.add_num(2) print(median_finder.find_median()) # Output: 1.5 median_finder.add_num(3) print(median_finder.find_median()) # Output: 2 ``` # Implementation Notes: * Use two heaps (min-heap and max-heap) to track the lower and upper halves of the data stream. * Ensure that the max-heap contains the smaller half of the data and the min-heap contains the larger half. * Maintain the property that the number of elements in both heaps is balanced or the max-heap can contain one extra element.","solution":"import heapq class MedianFinder: def __init__(self): # Initialize two heaps: one max-heap and one min-heap self.small = [] # max-heap to store the smaller half of the numbers self.large = [] # min-heap to store the larger half of the numbers def add_num(self, num: int) -> None: heapq.heappush(self.small, -num) # Balance heaps: largest number in small is moved to large if self.small and self.large and (-self.small[0] > self.large[0]): heapq.heappush(self.large, -heapq.heappop(self.small)) # Ensure size property: small can have at most one more element than large if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: if len(self.small) > len(self.large): return -self.small[0] return (-self.small[0] + self.large[0]) / 2.0"},{"question":"# Edit Distance Calculation Scenario You are part of a development team for a spell-checking feature in a word processor. The feature should suggest words closest in spelling to the word entered by the user based on edit distance. Your task is to write a function to compute the edit (Levenshtein) distance between two words. Task Write a function `edit_distance(word_a, word_b)` that computes the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform `word_a` into `word_b`. Input - `word_a` (str): the first word (length_a) - `word_b` (str): the second word (length_b) Output - `int`: the edit distance between `word_a` and `word_b` Constraints - 0 ≤ length_a, length_b ≤ 1000 - `word_a` and `word_b` contain only lowercase alphabetic characters. Example ```python print(edit_distance(\\"food\\", \\"money\\")) # Output: 4 print(edit_distance(\\"kitten\\", \\"sitting\\")) # Output: 3 print(edit_distance(\\"\\", \\"test\\")) # Output: 4 ``` Performance Requirements - Time complexity: O(length_a * length_b) - Space complexity: O(length_a * length_b) Note - You should handle edge cases such as one or both input strings being empty. - Aim to write clean and efficient code, using comments where necessary to explain your logic.","solution":"def edit_distance(word_a, word_b): Computes the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform word_a into word_b. length_a = len(word_a) length_b = len(word_b) # Create a matrix to store distances dp = [[0] * (length_b + 1) for _ in range(length_a + 1)] # Initialize the matrix for the base cases for i in range(length_a + 1): dp[i][0] = i # Cost of deletions for j in range(length_b + 1): dp[0][j] = j # Cost of insertions # Fill in the matrix, bottom up manner for i in range(1, length_a + 1): for j in range(1, length_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No cost if characters are the same else: dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1 # Min of substitution, insertion, deletion return dp[length_a][length_b]"},{"question":"# Matrix Rotation and Inversion Challenge You are tasked with implementing functions to rotate and invert matrices based on the provided examples. Your implementation should focus on efficiently transforming the matrix while considering edge cases and performance constraints. Function Requirements: 1. **rotate_clockwise(matrix)**: Rotate the given matrix 90 degrees clockwise. 2. **rotate_counterclockwise(matrix)**: Rotate the given matrix 90 degrees counterclockwise. 3. **top_left_invert(matrix)**: Invert the matrix along the top-left to bottom-right diagonal. 4. **bottom_left_invert(matrix)**: Invert the matrix along the bottom-left to top-right diagonal. Input and Output Formats: - **Input**: A 2D list `matrix` containing integers. - **Output**: A new 2D list `matrix` that has been transformed based on the function\'s purpose. Constraints: - The input matrix may be non-square (i.e., different number of rows and columns). - Handle edge cases like empty matrices or matrices with a single element. Scenario: Imagine you are working on a game where you need to rotate or invert the game board correctly to match user interactions. Implementing these functionalities accurately is crucial to ensure correct game responses. Example: For the initial matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - `rotate_clockwise(matrix)`: ``` [ [7, 4, 1], [8, 5, 2], [9, 3, 0] ] ``` - `rotate_counterclockwise(matrix)`: ``` [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] ``` - `top_left_invert(matrix)`: ``` [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` - `bottom_left_invert(matrix)`: ``` [ [9, 6, 3], [8, 5, 2], [7, 4, 1] ] ``` Implement these functions with careful consideration to handle all edge cases and optimize for performance where possible.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. :param matrix: 2D list of integers :return: 2D list of integers rotated 90 degrees clockwise if not matrix or not matrix[0]: return matrix return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. :param matrix: 2D list of integers :return: 2D list of integers rotated 90 degrees counterclockwise if not matrix or not matrix[0]: return matrix return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Inverts the given matrix along the top-left to bottom-right diagonal. :param matrix: 2D list of integers :return: 2D list of integers inverted along the diagonal if not matrix or not matrix[0]: return matrix return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def bottom_left_invert(matrix): Inverts the given matrix along the bottom-left to top-right diagonal. :param matrix: 2D list of integers :return: 2D list of integers inverted along the diagonal if not matrix or not matrix[0]: return matrix num_rows = len(matrix) num_cols = len(matrix[0]) return [[matrix[num_rows - j - 1][num_cols - i - 1] for j in range(num_rows)] for i in range(num_cols)]"},{"question":"You are given a string `s` which can contain letters, digits, and special characters. Your task is to determine if the string is a palindrome. In this context, a string is considered a palindrome if it reads the same backward as forward when considering only alphanumeric characters and ignoring cases. # Implementation Instructions Implement a function `is_complex_palindrome(s)` that follows these requirements: * **Function Signature**: `def is_complex_palindrome(s: str) -> bool:` * **Input**: A single string `s` with length `0 <= len(s) <= 10^5`. * **Output**: Returns `True` if `s` is a palindrome, `False` otherwise. * **Constraints**: - Only consider alphanumeric characters (\'A\'-\'Z\', \'a\'-\'z\', \'0\'-\'9\'). - Ignore the cases (i.e., \'A\' should be considered the same as \'a\'). - The function should work efficiently even for the maximum input size. # Example ```python assert is_complex_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_complex_palindrome(\\"race a car\\") == False assert is_complex_palindrome(\\"\\") == True assert is_complex_palindrome(\\"!!!\\") == True ``` # Additional Notes * Consider edge cases like empty strings or strings that only contain special characters. * Your implementation should be optimized for performance given the constraints.","solution":"def is_complex_palindrome(s: str) -> bool: Determines if a string is a palindrome considering only alphanumeric characters and ignoring cases. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list is the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"**Context**: Heap Sort is a comparison-based sorting algorithm that uses binary heaps to achieve a time complexity of O(n log n). Unlike other quadratic sorting algorithms, it is more efficient for larger datasets. Max Heap Sort is commonly used for sorting, while Min Heap Sort is an alternate variation that sorts elements similarly. **Problem Statement**: Write a Python function that sorts an array of integers using Max Heap Sort. Your task is to implement the `max_heap_sort` function as specified. Ensure that your implementation handles edge cases effectively and performs efficiently. Additionally, write a helper function `max_heapify` that is used by the `max_heap_sort` function. # Function Specifications: 1. `max_heap_sort(arr: List[int]) -> List[int]`: * **Input**: List of integers `arr`. * **Output**: The input array sorted in ascending order. * **Constraints**: * The input array may contain negative numbers, zero, and positive numbers. * The input array length can be up to 10^5 elements. 2. `max_heapify(arr: List[int], end: int) -> None`: * **Input**: List of integers `arr` and integer `end` indicating the last index up to which the max-heap property should be maintained. * **Output**: Modify `arr` in place to ensure the max-heap property is maintained up to the index `end`. # Example: ```python >>> arr = [3, 1, 5, 6, 2, 4] >>> max_heap_sort(arr) [1, 2, 3, 4, 5, 6] >>> arr = [10, 7, 8, 9, 1, 5] >>> max_heap_sort(arr) [1, 5, 7, 8, 9, 10] ``` # Additional Requirements: 1. Your solution should handle edge cases, including empty arrays and single-element arrays. 2. The sorting algorithm should be implemented in place with a space complexity of O(1). 3. Include test cases covering: * Typical cases (random arrays). * Edge cases (empty and single-element arrays). * Worst-case scenarios (large sized arrays, reverse sorted arrays).","solution":"def max_heapify(arr, n, i): To maintain the max-heap property for the array `arr` up to index `n`. largest = i left = 2 * i + 1 # left child right = 2 * i + 2 # right child if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] max_heapify(arr, n, largest) def max_heap_sort(arr): Performs heap sort on the given list `arr`. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap max_heapify(arr, i, 0) return arr"},{"question":"Pigeonhole Sort is a sorting algorithm that is efficient for arrays where the range of the possible values (`Max - Min`) is not significantly larger than the number of elements `n`. In this task, you will implement a modified version of Pigeonhole Sort that can handle arrays containing negative values as well. # Objective Implement a function `pigeonhole_sort(arr)` that sorts the array `arr` using the Pigeonhole Sorting technique. # Requirements * **Input**: A list of integers `arr` which may contain negative values. * **Output**: The input list `arr` sorted in non-decreasing order. * **Constraints**: - The array will contain at most 10^5 elements. - The values of the elements in the array will be between -10^4 and 10^4. # Example Scenarios Example 1: * **Input**: `[-5, -10, 0, -3, 8, 5, -1, 10]` * **Output**: `[-10, -5, -3, -1, 0, 5, 8, 10]` Example 2: * **Input**: `[1, 1, 1, 0, 0, 0, -1, -1, -1]` * **Output**: `[-1, -1, -1, 0, 0, 0, 1, 1, 1]` Implementation Note Handle the creation of holes appropriately to manage the entire range of values, including negative values.","solution":"def pigeonhole_sort(arr): Sorts the array \'arr\' using the Pigeonhole Sorting technique. :param arr: List[int] - List of integers possibly containing negative values. :return: List[int] - The input list sorted in non-decreasing order. if len(arr) == 0: return [] # Find the minimum and maximum values in the array min_value = min(arr) max_value = max(arr) # Calculate the range of values range_of_values = max_value - min_value + 1 # Create holes based on the range of values holes = [[] for _ in range(range_of_values)] # Place each element into its corresponding hole for num in arr: holes[num - min_value].append(num) # Flatten the list of holes into a sorted list sorted_arr = [] for hole in holes: for num in hole: sorted_arr.append(num) return sorted_arr"},{"question":"Your task is to write a function `switch_endianness` that takes a byte string and switches its endianness. Specifically, if the input byte string is in big-endian format, the output should be in little-endian format and vice versa. # Input Format - A byte string `bytestr` (e.g., `b\'x01x02x03x04\'`). # Output Format - A byte string with opposite endianness. # Example ```python switch_endianness(b\'x01x02x03x04\') # Should return b\'x04x03x02x01\' switch_endianness(b\'x04x03x02x01\') # Should return b\'x01x02x03x04\' ``` # Constraints - The input byte string will have a length that is a multiple of 2. - Handle efficiently for byte strings up to 2^20 (1 MB). # Requirements - Your solution should have a time complexity of O(n), where (n) is the number of bytes in the input string. - Use built-in functions and standard libraries optimally to ensure efficiency.","solution":"def switch_endianness(bytestr): Switches the endianness of a byte string. Args: bytestr (bytes): A byte string where the endianness needs to be switched. Returns: bytes: A byte string with the endianness switched. return bytestr[::-1]"},{"question":"# Question: Enhanced Text Pattern Matching with Additional Conditions You are asked to implement an enhanced version of the Knuth-Morris-Pratt algorithm. Besides finding all occurrences of a pattern in a given text, our enhanced function should also return an indication if the pattern is overlapped at any position. Your task is to write a function `enhanced_knuth_morris_pratt` that returns a tuple with the following components: 1. A list of start indices where the pattern is found in the text. 2. A Boolean value indicating if there are any overlapping occurrences of the pattern. # Function Signature ```python def enhanced_knuth_morris_pratt(text: str, pattern: str) -> (List[int], bool): ``` # Input: - `text` (str): The main text in which the pattern search is conducted. - `pattern` (str): The pattern to search for in the text. # Output: - A tuple consisting of: 1. A list of integers representing the starting indices of the pattern in the text. 2. A Boolean value indicating the presence of overlapping occurrences of the pattern. `True` if there is overlap, `False` otherwise. # Constraints: - The length of the text `N` does not exceed `10^6`. - The length of the pattern `M` does not exceed `10^5`. # Requirements: - The function should handle edge cases, including: - Pattern longer than the text. - Pattern or text being an empty string. - Multiple overlapping occurrences of the pattern in the text. # Example: ```python >>> enhanced_knuth_morris_pratt(\'ababcababc\', \'ababc\') ([0, 5], False) >>> enhanced_knuth_morris_pratt(\'aaaaaa\', \'aaa\') ([0, 1, 2, 3], True) ``` Explanation: - In the first example, the pattern \'ababc\' occurs at indices 0 and 5 with no overlap. - In the second example, the pattern \'aaa\' occurs at indices 0, 1, 2, and 3 with overlap present. # Note: - Ensure your implementation is efficient in terms of both time and space complexity. - Think carefully about edge cases and ensure your code handles them appropriately.","solution":"from typing import List, Tuple def compute_lps(pattern: str) -> List[int]: Helper function to compute the longest prefix suffix (LPS) array length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def enhanced_knuth_morris_pratt(text: str, pattern: str) -> Tuple[List[int], bool]: if not text or not pattern: return ([], False) lps = compute_lps(pattern) indices = [] overlap = False i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 if len(indices) < 2: return (indices, False) for k in range(1, len(indices)): if indices[k] - indices[k - 1] < len(pattern): overlap = True break return (indices, overlap)"},{"question":"Objective Design and implement a function to serialize and deserialize a binary tree. Ensure your implementation can handle various edge cases and uses efficient algorithms with optimal complexity. Output * **`serialize(root: TreeNode) -> str`**: This function should take the root node of a binary tree and return a string that represents the serialized tree. * **`deserialize(data: str) -> TreeNode`**: This function should take a string that represents a serialized tree and return the root node of the deserialized binary tree. The input guarantee is that the string has been created by the `serialize` function. Constraints * Nodes contain integer values. * Serialize and deserialize methods must have O(n) time complexity. * Additional blank spaces or unusual characters must not alter serialization/deserialization processes. * Edge cases like empty trees, single-node trees, and skewed trees must be handled correctly. Example ``` python # Example tree: # 1 # / # 2 3 # / # 4 5 # Serialize the tree root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Output might be like \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize the string into a tree deserialized_root = deserialize(serialized) # Check tree structure by serializing it again print(serialize(deserialized_root)) # Output should be the same \\"1 2 # # 3 4 # # 5 # #\\" ``` Handle additional test cases and edge cases for a robust implementation.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a tree to a single string. def helper(node): if node is None: elements.append(\\"#\\") return elements.append(str(node.val)) helper(node.left) helper(node.right) elements = [] helper(root) return \\" \\".join(elements) def deserialize(data): Decodes your encoded data to tree. def helper(): val = next(values) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node values = iter(data.split()) return helper()"},{"question":"# Question You are tasked with implementing a function that performs a postorder traversal on a binary tree. The binary tree is represented by the `Node` class provided below. This traversal should return a list of node values in the postorder sequence (left subtree, right subtree, root). Node Class ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Problem Constraints - The function should handle an empty tree and return an empty list in such case. - Assume total nodes will not exceed 10,000. Function Signature Implement the following functions: 1. **Iterative Postorder Traversal** ```python def postorder_iterative(root: Node) -> List[int]: ``` 2. **Recursive Postorder Traversal** ```python def postorder_recursive(root: Node) -> List[int]: ``` Example You can assume tree structure created as follows: ```python # Example Tree # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) ``` - **Iterative**: `postorder_iterative(root)` should return `[4, 5, 2, 3, 1]`. - **Recursive**: `postorder_recursive(root)` should return `[4, 5, 2, 3, 1]`. Requirements * The solutions should have a time complexity of O(n). * The solutions should have a space complexity of O(n) for iterative and O(h) for recursive, where h is tree height. Implement the two functions and ensure they account for edge cases like an empty tree.","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> List[int]: if root is None: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Node) -> List[int]: result = [] def traverse(node: Node): if node: traverse(node.left) traverse(node.right) result.append(node.val) traverse(root) return result"},{"question":"# Binary Exponentiation: Implementation and Practical Application # Problem Statement Binary exponentiation is a method to compute `a^n` efficiently. Given two integers `a` and `n`, along with an optional modulus `mod`, implement an algorithm to compute `a^n`. If `mod` is provided, the result should be `a^n % mod`. # Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: # Your implementation here ``` Input - `a`: Base integer (0 ≤ a ≤ 10^9) - `n`: Exponent integer (0 ≤ n ≤ 10^9) - `mod`: Optional integer (1 ≤ mod ≤ 10^9) Output - Returns the computed result of `a^n` (or `a^n % mod` if modulus is provided). # Constraints - The function must handle large inputs efficiently. - Ensure logarithmic time complexity irrespective of the input size. - Optimize for both time and space. # Example Scenarios 1. **Example 1**: ```python power(2, 10) ``` **Output**: `1024` 2. **Example 2**: ```python power(2, 10, 100) ``` **Output**: `24` (as 2^10 is 1024 and 1024 % 100 is 24) 3. **Example 3**: ```python power(3, 0) ``` **Output**: `1` (since any number raised to the power 0 is 1) # Notes - Consider edge cases such as `n = 0` and `mod = 1`. - Modular arithmetic should be efficiently managed within the algorithm to avoid overflow issues. # Instructions Implement both iterative and recursive versions of the binary exponentiation algorithm in one function, controlled by a parameter. > Good luck and validate your approach against multiple test cases to ensure accuracy!","solution":"def power(a: int, n: int, mod: int = None) -> int: Computes a^n efficiently using binary exponentiation. If mod is provided, computes (a^n) % mod. :param a: Base integer (0 ≤ a ≤ 10^9) :param n: Exponent integer (0 ≤ n ≤ 10^9) :param mod: Optional modulus integer (1 ≤ mod ≤ 10^9) :return: The result of a^n or (a^n) % mod result = 1 base = a if mod is not None and mod == 1: return 0 while n > 0: if n % 2 == 1: if mod: result = (result * base) % mod else: result = result * base base = (base * base) % mod if mod else base * base n //= 2 return result"},{"question":"# Wiggle Sort Challenge Given an unsorted array `nums`, you are required to reorder it such that it follows a wiggle pattern: `nums[0] < nums[1] > nums[2] < nums[3]...`. The final arrangement should ensure that every peak is greater than or equal to its neighbors and every valley smaller than or equal to its neighbors. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Reorders nums in-place to satisfy the wiggle property. ``` Input - A single list of `n` integers (`nums`), with `1 <= n <= 10^4`. Output - No return value. The function should modify the input list in-place. Constraints - The list may contain positive, negative, and zero values. - Attempt to achieve the wiggle sort with linear time complexity and constant space complexity. Examples ```python # Example 1 nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) # The output could be [3, 5, 1, 6, 2, 4] # Example 2 nums = [1, 2, 3, 4, 5, 6] wiggle_sort(nums) # The output could be [1, 3, 2, 5, 4, 6] # Example 3 nums = [4] wiggle_sort(nums) # The output would still be [4] ``` Notes - There can be multiple correct wiggle sort configurations for a given input. - Focus on maintaining linear time complexity and constant space usage. - Handle edge cases such as empty arrays, arrays with a single element, and arrays with duplicates.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Reorders nums in-place to satisfy the wiggle property. for i in range(1, len(nums)): if (i % 2 == 1 and nums[i] < nums[i - 1]) or (i % 2 == 0 and nums[i] > nums[i - 1]): nums[i], nums[i - 1] = nums[i - 1], nums[i]"},{"question":"You are given a series of linked lists, and your task is to write a function to determine if there is a cycle present in each linked list. A cycle occurs when a node’s next pointer points back to a previous node, resulting in an infinite loop. # Function to Implement: ```python def is_cyclic(head): :param head: Head node of the linked list :type head: Node :return: True if there is a cycle, False otherwise :rtype: bool ``` # Input/Output: - **Input**: A singly linked list represented by its head node. - **Output**: A boolean `True` if the linked list contains a cycle, `False` otherwise. # Constraints: - **Node** class is provided as follows: ```python class Node: def __init__(self, val): self.val = val self.next = None ``` - The linked list can contain up to 10^4 nodes. - Solve it using constant extra space. # Example: 1. **Input**: A linked list with nodes [3, 2, 0, -4] where the last node points back to the node with value 2. **Output**: True 2. **Input**: A linked list with nodes [1, 2] where the last node points back to the node with value 1. **Output**: True 3. **Input**: A linked list with nodes [1] with no cycle. **Output**: False # Notes: - Consider edge cases such as an empty list or a single-node list with and without a cycle. - Ensure the solution\'s time complexity is O(n) and space complexity is O(1).","solution":"class Node: def __init__(self, val): self.val = val self.next = None def is_cyclic(head): Determines if a linked list has a cycle. :param head: Head node of the linked list :type head: Node :return: True if there is a cycle, False otherwise :rtype: bool if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"You are provided with a singly linked list and an integer `k`. Write a function `kth_to_last_node(head, k)` that returns the k-th to last node\'s value in the linked list. # Input - `head`: A Node object representing the head of the linked list. - `k`: An integer `k` (1 ≤ k ≤ linked list length). # Output - The value of the k-th to last node in the linked list. # Constraints 1. The linked list will contain at least one node. 2. `k` will always be a valid integer within the bounds of the linked list. 3. Do not use any built-in Python functions like `eval`. # Example ``` # Given Linked List: A -> B -> C -> D -> E # k = 2 # The 2nd to last element is D. # Assuming Node class is already defined as in the provided code snippet. a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e output = kth_to_last_node(a, 2) print(output) # Should print \\"D\\" ``` # Function Signature ```python def kth_to_last_node(head: Node, k: int) -> str: ``` # Solution Requirements 1. Your function should use an optimal approach similar to the `kth_to_last` function provided in the code snippet above. 2. Ensure the function handles all specified edge cases effectively. 3. Verify against time complexity constraints for larger input sizes.","solution":"class Node: def __init__(self, value, next=None): self.value = value self.next = next def kth_to_last_node(head: Node, k: int) -> str: Returns the value of the k-th to last node in the linked list. # Use two pointers approach slow = head fast = head # Move the fast pointer k steps ahead for _ in range(k): fast = fast.next # Move both pointers until fast reaches the end while fast: slow = slow.next fast = fast.next return slow.value"},{"question":"# Pancake Sort Implementation Scenario You are working as a software engineer in an educational technology company. Your task is to improve the visual demonstrations of sorting algorithms for an interactive learning platform. You need to implement the Pancake Sort algorithm, which sorts an array by reversing sections of it. Problem Statement Implement a function, `pancake_sort`, that sorts a given list of integers using the Pancake Sort algorithm. Your function should mutate the list in place and return the sorted list. Function Signature ```python def pancake_sort(arr: List[int]) -> List[int]: pass ``` Input * A list `arr` of integers where `1 <= len(arr) <= 1000` and `-10^9 <= arr[i] <= 10^9`. Output * The same list `arr` but sorted in non-decreasing order. Constraints * The function must use the Pancake Sort algorithm. * You are required to implement the sort in place with O(1) additional space. * Overall time complexity should be O(N^2). Examples Example 1: ```python arr = [3, 6, 1, 10, 7] print(pancake_sort(arr)) # Output: [1, 3, 6, 7, 10] ``` Example 2: ```python arr = [2, 4, 3, 1] print(pancake_sort(arr)) # Output: [1, 2, 3, 4] ``` Notes * Think about how to handle cases where the maximum element to flip is already in the correct position. * Ensure you test your function with arrays of various lengths, including single-element arrays and already sorted arrays.","solution":"from typing import List def pancake_sort(arr: List[int]) -> List[int]: def flip(sub_arr, k): start = 0 while start < k: sub_arr[start], sub_arr[k] = sub_arr[k], sub_arr[start] start += 1 k -= 1 # Perform the pancake sort algorithm n = len(arr) for size in range(n, 1, -1): # Find the maximum element in arr[0..size-1] max_index = max(range(size), key=lambda i: arr[i]) # Move the maximum element to the end of the current sub-array if max_index != size - 1: # Flip it to the front if it\'s not already there if max_index != 0: flip(arr, max_index) # Then flip it to the end of the current sub-array flip(arr, size - 1) return arr"},{"question":"You are given a positive integer `number`, and your task is to determine the minimum number of perfect square numbers (e.g., 1, 4, 9, 16, ...) that sum to `number`. # Function Signature ```python def min_perfect_squares(number: int) -> int: pass ``` # Input - An integer `number (1 ≤ number ≤ 10^4)`. # Output - An integer representing the minimum number of perfect squares that sum to `number`. # Constraints - You must use an efficient algorithm with time complexity better than O(N^2). # Example 1. Input: `12` Output: `3` Explanation: `12 = 4 + 4 + 4` (i.e., 2^2+ 2^2 + 2^2) 2. Input: `13` Output: `2` Explanation: `13 = 4 + 9` (i.e., 2^2 + 3^2) # Detailed Description Your algorithm should work as follows: 1. Check if the number is a perfect square. If so, return `1`. 2. Reduce the number by eliminating factors of `4`. 3. Check if the number is reduced to the form `(8b+7)`. If so, return `4`. 4. Check for sums of two perfect squares. 5. Return `3` by default if no other smaller sum decompositions exist. The function should be efficient enough to handle the input constraints.","solution":"import math def min_perfect_squares(number: int) -> int: Returns the minimum number of perfect square numbers which sum up to `number`. # Check if the number is a perfect square. if int(math.sqrt(number))**2 == number: return 1 # Reduce number by removing any factors of 4 (Lagrange\'s Four Square Theorem) while number % 4 == 0: number //= 4 # If number in the form of 8b + 7 (Legendre\'s Three Square Theorem) if number % 8 == 7: return 4 # Check if the number can be expressed as the sum of two squares for i in range(1, int(math.sqrt(number)) + 1): if int(math.sqrt(number - i*i))**2 == number - i*i: return 2 # If none of the above conditions are met, the result is 3 return 3"},{"question":"**Scenario:** You are working on optimizing cryptographic algorithms, specifically the RSA encryption algorithm, which relies on Euler\'s Totient function. Efficient computation of this function is crucial for secure and fast encryption/decryption processes. **Task:** Write a function `optimized_totient(n: int) -> int` that computes the Euler\'s Totient function ϕ(n) for a given integer n. Your function must handle inputs efficiently and return the number of integers between 1 and n inclusive that are coprime with n. **Input:** * An integer `n` such that 1 ≤ n ≤ 10^6. **Output:** * An integer which represents ϕ(n). **Constraints:** * 1 ≤ n ≤ 10^6 * You are required to maintain a time complexity of O(√n). **Examples:** ```python >>> optimized_totient(1) 1 >>> optimized_totient(5) 4 >>> optimized_totient(10) 4 ``` **Notes:** 1. Ensure your solution handles edge cases appropriately, including very small values of n. 2. Consider using efficient prime factor detection to maintain the required time complexity. 3. Document your code to explain the core operational steps and logic. 4. Handle errors or invalid inputs gracefully (e.g., non-positive integers should throw an appropriate error or return a specified result).","solution":"def optimized_totient(n): Computes Euler\'s Totient function ϕ(n) efficiently using reduced time complexity. Parameters: n (int): The integer for which the totient function is to be computed. Returns: int: Value of ϕ(n). if n < 1: raise ValueError(\\"Input must be a positive integer\\") # Initial result is set to n result = n # Check for factors from 2 to sqrt(n) p = 2 while p * p <= n: # Check if p is a factor of n if n % p == 0: # If it is, divide n by p as much as possible while n % p == 0: n //= p # Update result to include contribution of the prime factor p result -= result // p p += 1 # If n is still greater than 1, then it must be prime if n > 1: result -= result // n return result"},{"question":"# Word Squares Generation Given a list of words (without duplicates), you need to find all the possible word squares that can be formed. A valid word square is a sequence of words where the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns). # Definitions: - A word square is an array of strings arranged so that the ith row and ith column read the same. - Each word contains only lowercase English letters. Example: Input: ``` [\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"] ``` Output: ```json [ [\\"wall\\", \\"area\\", \\"lead\\", \\"lady\\"], [\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"] ] ``` *Both arrangements read same strings across rows and columns.* # Function Signature: ```python def find_word_squares(words): # your implementation here ``` # Input: - `words`: A list of strings [w1, w2, ..., wn], where 1 <= n <= 1000. - All words have the same length, and the length of any word is between 1 and 5. # Output: - Return a list of lists, where each inner list is a valid word square formed by the given words. # Constraints: 1. All words in the input list are of the same length. 2. The length of each word is between 1 to 5. # Requirements: - Only unique and valid word squares should be included in the result. - The order of word squares in the output does not matter. - Efficient performance ensuring Trie or prefix-based searching to limit iterations. Implement the `find_word_squares(words)` function based on the above specifications.","solution":"from collections import defaultdict def build_prefix_dict(words): prefix_dict = defaultdict(list) for word in words: for i in range(len(word)): prefix_dict[word[:i+1]].append(word) return prefix_dict def backtrack(step, word_len, solution, results, prefix_dict): if step == word_len: results.append(solution[:]) return prefix = \'\'.join([word[step] for word in solution]) for candidate in prefix_dict[prefix]: solution.append(candidate) backtrack(step + 1, word_len, solution, results, prefix_dict) solution.pop() def find_word_squares(words): if not words: return [] word_len = len(words[0]) prefix_dict = build_prefix_dict(words) results = [] for word in words: backtrack(1, word_len, [word], results, prefix_dict) return results"},{"question":"# Scenario You are working as a software engineer at a company that deals with processing large datasets. For one of your tasks, you need an efficient way to sort data. The built-in sorting functions are not suitable due to constraints on space and the need for consistent time complexity. You decide to implement your own heap sort algorithm. # Task Implement the `fixed_heap_sort` function which will take an array and a boolean flag specifying the heap type (`max`, `min`) to perform an in-place heap sort. Ensure that your function maintains O(n log(n)) time complexity. Your implementation should account for all edge cases and avoid any out-of-bound errors. # Function Definition ```python def fixed_heap_sort(arr, heap_type=\\"max\\", simulation=False): Sort the array in ascending order using either max-heap or min-heap sort. Parameters: arr (List[int]): The array to be sorted. heap_type (str): The type of heap to use (\'max\' or \'min\'). Default is \'max\'. simulation (bool): If True, prints the state of the array at each significant step. Returns: List[int]: Sorted array. pass ``` # Input * `arr`: A list of integers to sort. * `heap_type`: A string that specifies whether to use \'max\' or \'min\' heap sort. * `simulation`: A boolean flag, which, if `True`, prints the state of the array at each significant iteration for debugging and educational purposes. # Output * Returns the sorted array in ascending order. # Constraints * The array can contain up to 10^5 elements. * Each element in the array is an integer in the range [-10^9, 10^9]. * The input array may be empty or contain unique/repeated elements. # Example ```python print(fixed_heap_sort([4, 10, 3, 5, 1], \'max\')) # Output: [1, 3, 4, 5, 10] print(fixed_heap_sort([4, 10, 3, 5, 1], \'min\')) # Output: [1, 3, 4, 5, 10] print(fixed_heap_sort([], \'max\')) # Output: [] ``` # Notes * Consider how you will manage the heap property within your function. * Avoid redundant operations to maintain both performance and correctness. * Provide meaningful output if `simulation` is set to `True`.","solution":"def fixed_heap_sort(arr, heap_type=\\"max\\", simulation=False): Sort the array in ascending order using either max-heap or min-heap sort. Parameters: arr (List[int]): The array to be sorted. heap_type (str): The type of heap to use (\'max\' or \'min\'). Default is \'max\'. simulation (bool): If True, prints the state of the array at each significant step. Returns: List[int]: Sorted array. def heapify(arr, n, i, max_heap=True): if simulation: print(f\\"Heapifying at index {i}: {arr}\\") largest_or_smallest = i left = 2 * i + 1 right = 2 * i + 2 if max_heap: if left < n and arr[i] < arr[left]: largest_or_smallest = left if right < n and arr[largest_or_smallest] < arr[right]: largest_or_smallest = right else: if left < n and arr[i] > arr[left]: largest_or_smallest = left if right < n and arr[largest_or_smallest] > arr[right]: largest_or_smallest = right if largest_or_smallest != i: arr[i], arr[largest_or_smallest] = arr[largest_or_smallest], arr[i] heapify(arr, n, largest_or_smallest, max_heap) n = len(arr) max_heap = heap_type == \\"max\\" for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, max_heap) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, max_heap) if not max_heap: arr.reverse() return arr"},{"question":"# Stuttering a Stack Problem Statement: You are given a stack of integers. Your task is to write a function `stutter` that transforms this stack such that every integer element is duplicated in place within the stack. You should implement this function using either a single auxiliary stack or a single auxiliary queue, but not both. Function Signature: ```python def stutter(stack): # Implement your code here pass ``` Input: * A list of integers, representing the stack with the bottom most element at the start and the top most element at the end. Output: * The same list with each element duplicated in place. Example: * `stutter([3, 7, 1, 14, 9])` should return `[3, 3, 7, 7, 1, 1, 14, 14, 9, 9]`. Constraints: * The input stack can have up to (10^5) elements. * Elements in the stack are integer values. Guidelines: * Do not modify the input list directly; if necessary, work on a copy of the input. * Ensure the coding solution handles edge cases such as an empty stack or a single-element stack. * Optimize for time and space where feasible, keeping in mind the constraints provided. Write the function `stutter` below: ```python def stutter(stack): # Your code here pass ```","solution":"def stutter(stack): Given a stack, this function returns a new stack with each element duplicated in place. Parameters: stack (list): A list of integers representing the stack. Returns: list: A list of integers with each element duplicated in place. def insert_at_bottom(stack, item): if not stack: stack.append(item) else: top = stack.pop() insert_at_bottom(stack, item) stack.append(top) if not stack: return stack aux_stack = [] # Transfer elements from the original stack to the auxiliary stack while stack: aux_stack.append(stack.pop()) # Transfer elements back to the original stack with duplication while aux_stack: item = aux_stack.pop() stack.append(item) # first instance of the item stack.append(item) # duplicate instance of the item # Reverse the stack to maintain original order aux_stack = [] while stack: aux_stack.append(stack.pop()) while aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"You are required to implement a Binary Search Tree (BST) and ensure it adheres to fundamental properties. The tree should support the following operations: 1. `insert(data)`: Insert a new node with the specified data ensuring no duplicates are inserted. 2. `search(data)`: Search for the specified data in the tree and return `True` if found, else `False`. 3. `size()`: Return the count of nodes in the tree. 4. `preorder(root)`, `inorder(root)`, and `postorder(root)`: Implement these traversal methods which should print the nodes in respective traversal orders. # Input Format 1. `insert(data)` accepts an integer `data` to insert into the tree. 2. `search(data)` accepts an integer `data` to search in the tree. 3. `size()` does not require any input. 4. Traversal methods accept a `root` node of the tree. # Output Format * `insert(data)`: Does not return anything. Inserts a new node. * `search(data)`: Returns `True` if data is found, `False` otherwise. * `size()`: Returns the total number of nodes in the tree. * Traversal methods should print the nodes in the specified order. # Constraints * `0 <= data <= 10^4` * Perform at least 1000 operations without reaching recursion limits. # Performance Requirements * Operations should be efficient in terms of time complexity. * Handling large datasets and deep recursion should not exceed standard stack limits in most environments. # Example ```python # Creating the tree bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) # Searching print(bst.search(24)) # Output: True print(bst.search(50)) # Output: False # Size print(bst.size()) # Output: 11 # Preorder traversal bst.preorder(bst.get_root()) # Output: 10 6 4 9 7 15 12 24 20 18 30 # Inorder traversal bst.inorder(bst.get_root()) # Output: 4 6 7 9 10 12 15 18 20 24 30 # Postorder traversal bst.postorder(bst.get_root()) # Output: 4 7 9 6 12 18 20 30 24 15 10 ``` Write the function implementations and the necessary methods for the `BST` class as described.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def get_root(self): return self.root def insert(self, data): if not self.root: self.root = Node(data) self.node_count += 1 else: self._insert(self.root, data) def _insert(self, current_node, data): if data < current_node.data: if current_node.left: self._insert(current_node.left, data) else: current_node.left = Node(data) self.node_count += 1 elif data > current_node.data: if current_node.right: self._insert(current_node.right, data) else: current_node.right = Node(data) self.node_count += 1 # If data is equal, we do nothing (no duplicates allowed) def search(self, data): return self._search(self.root, data) def _search(self, current_node, data): if not current_node: return False if current_node.data == data: return True elif data < current_node.data: return self._search(current_node.left, data) else: # data > current_node.data return self._search(current_node.right, data) def size(self): return self.node_count def preorder(self, root): if root: print(root.data, end=\\" \\") self.preorder(root.left) self.preorder(root.right) def inorder(self, root): if root: self.inorder(root.left) print(root.data, end=\\" \\") self.inorder(root.right) def postorder(self, root): if root: self.postorder(root.left) self.postorder(root.right) print(root.data, end=\\" \\") # Example usage (uncomment to test) # bst = BST() # bst.insert(10) # bst.insert(15) # bst.insert(6) # bst.insert(4) # bst.insert(9) # bst.insert(12) # bst.insert(24) # bst.insert(7) # bst.insert(20) # bst.insert(30) # bst.insert(18) # bst.preorder(bst.get_root()) # Output: 10 6 4 9 7 15 12 24 20 18 30 # bst.inorder(bst.get_root()) # Output: 4 6 7 9 10 12 15 18 20 24 30 # bst.postorder(bst.get_root()) # Output: 4 7 9 6 12 18 20 30 24 15 10"},{"question":"Background You are tasked with augmenting the capabilities of a word dictionary that allows adding words and performing searches. The search function should support literal word matches and pattern matches where \'.\' can match any character. Problem Statement Create a class `EnhancedWordDictionary` that implements two main functionalities: 1. `add_word(word: str) -> None`: Adds a word to the dictionary. 2. `search(word: str) -> bool`: Searches for an exact match of the word or matches pattern containing \'.\'. Your implementation should leverage advanced data structures to handle both functionalities efficiently. Input and Output Formats - `add_word(word: str) -> None`: Takes a non-empty string `word` containing only lowercase alphabets. - `search(word: str) -> bool`: Takes a non-empty string `word` and returns `True` if it exists in the dictionary or matches the given pattern. Otherwise, returns `False`. Constraints - All words are lowercased. - Words will not exceed 1000 characters. - Words and patterns will only contain lowercase letters and \'.\'. Example ```python dictionary = EnhancedWordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True ``` Requirements - Ensure your implementation can manage performance efficiently for both addition and search operations. - Handle edge cases such as searching an empty string, very long words, and patterns with multiple \'.\'. **Note**: You can choose to implement this using either a Trie data structure or HashMap (as demonstrated previously), but ensure the solution does not compromise on efficiency.","solution":"class EnhancedWordDictionary: def __init__(self): self.trie = {} def add_word(self, word): node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word): return self._search_in_node(word, self.trie) def _search_in_node(self, word, node): for i, char in enumerate(word): if char not in node: if char == \'.\': for x in node: if x != \'#\' and self._search_in_node(word[i+1:], node[x]): return True return False else: node = node[char] return \'#\' in node"},{"question":"**Bucket Sort Implementation** # Task Implement the `enhanced_bucket_sort(arr, num_buckets)` function that performs the bucket sort using a more efficient sorting algorithm (e.g., mergesort) for sorting within each bucket. # Input - `arr`: a list of non-negative integers to be sorted. - `num_buckets`: an integer representing the number of buckets to be used for this sort. This parameter should be optional with a default value of 10. # Output - Returns a sorted list of integers. # Constraints 1. The elements in the array `arr` are non-negative integers. 2. The number of buckets should be a positive integer. # Performance Requirements - The solution should aim for average-case linear time complexity O(n + k) while optimizing the worst-case scenario. - Space complexity should be linear O(n + k). # Scenario Consider you have been given a large dataset representing grades of students. To efficiently sort and manage these grades, you need to implement an enhanced version of bucket sort that can handle large diverse distributions effectively. # Example ```python # Example Usage: arr = [29, 25, 3, 49, 9, 37, 21, 43] sorted_arr = enhanced_bucket_sort(arr) print(sorted_arr) # Output: [3, 9, 21, 25, 29, 37, 43, 49] ```","solution":"def enhanced_bucket_sort(arr, num_buckets=10): Perform bucket sort using optimized sorting within each bucket. :param arr: List of non-negative integers to be sorted. :param num_buckets: Number of buckets to be used for sorting. :return: Sorted list of integers. if len(arr) <= 1: return arr # Find the maximum value in the array max_value = max(arr) # Create buckets and distribute the elements buckets = [[] for _ in range(num_buckets)] for num in arr: index = num * num_buckets // (max_value + 1) buckets[index].append(num) # Sort each bucket using a more efficient sorting algorithm, for example, merge sort sorted_arr = [] for bucket in buckets: sorted_arr.extend(merge_sort(bucket)) return sorted_arr def merge_sort(arr): Perform merge sort on an array. :param arr: List of integers to be sorted. :return: Sorted list of integers. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): Merge two sorted arrays into a single sorted array. :param left: Sorted left half. :param right: Sorted right half. :return: Merged sorted list of integers. sorted_list = [] i = j = 0 # Merge the two halves while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append remaining elements if any sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"# RSA Key Generation and Encryption/Decryption You are tasked with building an encryption and decryption system based on the RSA algorithm. The provided implementation details for the RSA key generation algorithm, encryption, and decryption have been shared. Your task is to implement these following the guidelines below. Objective Implement a function `rsa_key_gen_and_crypto` which will: 1. Generate RSA keys of a specified bit length. 2. Encrypt a given data using the generated public key. 3. Decrypt the encrypted data using the generated private key. 4. Verify that the decrypted data matches the original data. Function Signature ```python def rsa_key_gen_and_crypto(k: int, data: int, seed: int = None) -> tuple: pass ``` Input - `k` (int): The number of bits in the modulus `n`. - `data` (int): The integer data to be encrypted and decrypted. - `seed` (int, optional): Seed for random number generation to ensure reproducibility. Default is `None`. Output - Returns a tuple `(n, e, d, encrypted_data, decrypted_data)` where: - `n` (int): The modulus. - `e` (int): The public exponent. - `d` (int): The private exponent. - `encrypted_data` (int): The result of encrypting `data` using `(n, e)`. - `decrypted_data` (int): The result of decrypting `encrypted_data` using `(n, d)`. Constraints - `k` should be at least 16. - `data` should be a non-negative integer less than `n`. Requirements 1. **Key Generation**: Implement the function to generate RSA keys. 2. **Encryption and Decryption**: Implement the functions to perform encryption and decryption. 3. **Validation**: Ensure that the decrypted data matches the original data. Example ```python result = rsa_key_gen_and_crypto(16, 20) n, e, d, encrypted_data, decrypted_data = result print(f\\"n: {n}, e: {e}, d: {d}, encrypted data: {encrypted_data}, decrypted data: {decrypted_data}\\") assert decrypted_data == 20 ``` Hints 1. Make use of the provided `generate_key`, `encrypt`, and `decrypt` functions. 2. Validate the edge cases where `e` and λ(n) are not coprime. 3. Ensure data constraints are properly checked and handled.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(bits): Generate an odd integer randomly p = random.getrandbits(bits) while p % 2 == 0: p = random.getrandbits(bits) return p def generate_prime_number(bits): Generate a prime number of bit length bits p = generate_prime_candidate(bits) while not isprime(p): p = generate_prime_candidate(bits) return p def generate_key(bits): Generate RSA key pairs with the prime numbers of bit length bits e = 65537 # This is a commonly used prime number for e # Generate two distinct prime numbers p and q p = generate_prime_number(bits // 2) q = generate_prime_number(bits // 2) while q == p: q = generate_prime_number(bits // 2) n = p * q lambda_n = (p - 1) * (q - 1) # Ensure gcd(e, lambda_n) = 1 d = mod_inverse(e, lambda_n) return (n, e, d) def encrypt(data, n, e): Encrypt the data with the given public key return pow(data, e, n) def decrypt(encrypted_data, n, d): Decrypt the data with the given private key return pow(encrypted_data, d, n) def rsa_key_gen_and_crypto(k, data, seed=None): if seed is not None: random.seed(seed) if k < 16: raise ValueError(\\"The number of bits in the modulus must be at least 16\\") (n, e, d) = generate_key(k) if data < 0 or data >= n: raise ValueError(\\"Data must be a non-negative integer less than n\\") encrypted_data = encrypt(data, n, e) decrypted_data = decrypt(encrypted_data, n, d) return (n, e, d, encrypted_data, decrypted_data)"},{"question":"# Question: You are tasked with implementing a function that simulates the text input on an old mobile phone keypad. Each digit on the keypad corresponds to a set of letters (as described below). Write a function that takes a digit string as input and returns all possible letter combinations that the number could represent. **Digits to Letters Mapping**: * 2: \\"abc\\" * 3: \\"def\\" * 4: \\"ghi\\" * 5: \\"jkl\\" * 6: \\"mno\\" * 7: \\"pqrs\\" * 8: \\"tuv\\" * 9: \\"wxyz\\" **Function Signature**: ```python def letter_combinations(digits: str) -> List[str]: ``` # Input: * A string `digits` containing only digits from \'2\' to \'9\'. * Length of `digits` ranges from 0 to 4. # Output: * A list of strings, where each string represents a possible combination of letters corresponding to the input digit string. # Constraints: * If the input `digits` is an empty string, return an empty list. * Ensure your solution is efficient enough to handle the maximum input size. # Examples: 1. Input: `\\"23\\"` Output: `[\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]` 2. Input: `\\"\\"` Output: `[]` 3. Input: `\\"9\\"` Output: `[\\"w\\", \\"x\\", \\"y\\", \\"z\\"]` # Scenario: You are developing a feature for a text input system on a digital device that uses a classic mobile phone keypad approach. Your function should accurately generate all possible text sequences that correspond to a given set of digit buttons pressed.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from \'2\' to \'9\', return all possible letter combinations that the number could represent. if not digits: return [] phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(combination, next_digits): # If there is no more digits to check if not next_digits: # The combination is done output.append(combination) else: # Iterate over all letters which map the next available digit for letter in phone_map[next_digits[0]]: # Append the current letter to the combination and proceed # to the next digits backtrack(combination + letter, next_digits[1:]) output = [] backtrack(\\"\\", digits) return output"},{"question":"Your task is to implement a sorting algorithm based on the concept of **bucket sort**. You will need to distribute the elements of an array into separate \\"buckets\\", sort each bucket, and then concatenate these buckets to produce the final sorted array. For the purpose of sorting the individual buckets, you will use the insertion sort algorithm. Please ensure your implementation can handle edge cases and performs efficiently for uniformly distributed data. Function Signature ```python def bucket_sort(arr: List[float]) -> List[float]: pass ``` Input * `arr` : List of float numbers ( len(arr) leq 10^6 ) Output * Returns a sorted list of float numbers. Constraints * Assume all elements are in the range [0, 1). * The input list can be empty, and your function should handle this appropriately by returning an empty list. Examples ```python >>> bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]) [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] >>> bucket_sort([0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51]) [0.23, 0.25, 0.32, 0.42, 0.47, 0.51, 0.52] >>> bucket_sort([]) [] ``` Additional Information The performance should be considered based on the average-case time complexity of O(n + k), where n is the number of elements and k is the number of buckets. Assume the input list size does not exceed (10^6).","solution":"from typing import List def insertion_sort(arr: List[float]) -> List[float]: A simple implementation of insertion sort. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def bucket_sort(arr: List[float]) -> List[float]: Sorts a list of float numbers in the range [0, 1) using bucket sort. if not arr: return [] # Create buckets bucket_count = len(arr) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: # Using int(bucket_count * num) as index ensures every number falls within 0 and bucket_count-1 index = int(bucket_count * num) buckets[index].append(num) # Sort individual buckets using insertion sort sorted_arr = [] for bucket in buckets: insertion_sort(bucket) sorted_arr.extend(bucket) # Concatenate sorted buckets return sorted_arr"},{"question":"Scenario Imagine you are developing an application to help students understand sorting algorithms through visualization. One of your tasks is to implement a simplified but efficient version of the Bubble Sort algorithm that stops early when the array is already sorted partway through the process. Task Implement the function `optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]` that sorts an array of integers in ascending order using an optimized version of Bubble Sort. This version should minimize the number of iterations by detecting when no swaps have occurred, indicating that the array is already sorted. Additionally, if the parameter `simulation` is set to `True`, the function should print the array after each complete pass through the array to visualize the sorting process. # Input * `arr`: A list of integers to be sorted. * `simulation`: A boolean flag indicating whether to print the array state after each iteration (default is `False`). # Output * A sorted list of integers in ascending order. # Constraints * The length of `arr` will not exceed 10^4. * Elements of `arr` are integers. # Example ```python arr = [5, 1, 4, 2, 8] sorted_arr = optimized_bubble_sort(arr, True) # Expected print output if simulation is True: # iteration 0: 5 1 4 2 8 # iteration 1: 1 4 2 5 8 # iteration 2: 1 2 4 5 8 # iteration 3: 1 2 4 5 8 # Expected return value: # [1, 2, 4, 5, 8] ``` # Performance Requirements * Ensure the function handles arrays up to the length of 10^4 efficiently. * The function should be a stable sort maintaining the relative order of equal elements. # Notes * Utilize early termination to reduce unnecessary iterations when the array is already sorted. * Carefully handle edge cases such as an already sorted array or an array with identical elements.","solution":"from typing import List def optimized_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array of integers in ascending order using an optimized version of Bubble Sort. If `simulation` is True, prints the array after each complete pass through the array. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"You are to implement a Deterministic Finite Automaton (DFA) function to determine if given strings are accepted by a predefined DFA. The function should carefully handle transitions and final states. Function Signature ```python def DFA(transitions: dict, start: int, final: list, string: str) -> bool: ``` Input - `transitions`: A dictionary representing the state transition table of the DFA, where the keys are current states and the values are dictionaries that map input characters to the next state. - `start`: An integer representing the start state. - `final`: A list of integers representing the final (accepting) states. - `string`: A string to be evaluated by the DFA. Output - Returns `True` if the DFA accepts the string, `False` otherwise. Constraints - The `transitions` dictionary will have valid, non-empty mappings for current states and transitions. - The `string` will be a non-empty sequence of input characters. - The input strings will only have characters defined in the DFA transitions. Example ```python transitions = { 0: {\'a\': 1, \'b\': None}, 1: {\'a\': 1, \'b\': 2}, 2: {\'a\': None, \'b\': None} } start = 0 final = [2] string = \\"ab\\" print(DFA(transitions, start, final, string)) # Output: True string = \\"aa\\" print(DFA(transitions, start, final, string)) # Output: False ``` # Points To Consider 1. Ensure that the function handles characters that are not present in the transition dictionary gracefully. 2. Validate your function against a series of edge cases and typical scenarios such as empty strings or unfinished transitions. 3. Optimize for time complexity, considering that the DFA should process each character in constant time.","solution":"def DFA(transitions: dict, start: int, final: list, string: str) -> bool: Determines if a given string is accepted by a predefined DFA. Parameters: transitions (dict): The state transition table. start (int): The start state. final (list): The list of final (accepting) states. string (str): The string to be evaluated by the DFA. Returns: bool: True if the DFA accepts the string, False otherwise. current_state = start for char in string: if char in transitions[current_state]: next_state = transitions[current_state][char] if next_state is not None: current_state = next_state else: return False else: return False return current_state in final"},{"question":"Path Existence in a Directed Graph You are tasked with determining if there is a path between two nodes in a directed graph. Implement the necessary methods to perform this check. Input 1. An integer `vertex_count`, representing the number of vertices in the graph. 2. A list of tuples `edges`, where each tuple `(source, target)` represents a directed edge from `source` to `target`. 3. Two integers, `source` and `target`, representing the nodes you need to check the path between. Output - A boolean value `True` if there is a path from `source` to `target`. - A boolean value `False` otherwise. Function Signature ```python def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` Constraints - `0 <= source, target < vertex_count` - `0 <= vertex_count <= 10,000` - `0 <= len(edges) <= 50,000` Example ```python # Example 1 vertex_count = 4 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] source = 1 target = 3 # Output: True (There is a path 1 -> 2 -> 3) # Example 2 vertex_count = 3 edges = [(0, 1), (1, 2)] source = 0 target = 2 # Output: True (There is a path 0 -> 1 -> 2) # Example 3 vertex_count = 3 edges = [(0, 1), (1, 0)] source = 0 target = 2 # Output: False (There is no path from 0 to 2) ```","solution":"from typing import List, Tuple def is_path_exists(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: from collections import defaultdict, deque # Build adjacency list graph = defaultdict(list) for src, tgt in edges: graph[src].append(tgt) # BFS to find path from source to target visited = set() queue = deque([source]) while queue: current = queue.popleft() if current == target: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"Problem: Longest Increasing Subsequence (LIS) with No Duplicates # Context: You\'re given an unsorted array of `n` unique integers. You need to determine the length of the longest increasing subsequence (LIS). # Task: Implement a function that computes the length of the LIS using an efficient algorithm with a near log-linear time complexity for larger sets of data. # Function Signature: ```python def find_lis_length(sequence: List[int]) -> int: ``` # Input: - `sequence`: A list of unique integers representing the sequence to analyze. (1 ≤ len(sequence) ≤ 10^5) # Output: - An integer representing the length of the longest increasing subsequence in the given sequence. # Constraints: - The function must handle input sequences quickly. Aim for a time complexity of O(n log n). # Example: ```python sequence = [10, 9, 2, 5, 3, 7, 101, 18] print(find_lis_length(sequence)) # Output: 4 ``` In this example, the length of the longest increasing subsequence [2, 3, 7, 101] is 4. # Additional Information: - Ensure that the function is efficient in both time and space. - Consider edge cases such as sequences with one element (output should be 1). - Verify correctness in different scenarios with varying sequence lengths and values.","solution":"from typing import List import bisect def find_lis_length(sequence: List[int]) -> int: if not sequence: return 0 lis = [] for number in sequence: pos = bisect.bisect_left(lis, number) if pos == len(lis): lis.append(number) else: lis[pos] = number return len(lis)"},{"question":"# Decoding Ways Problem You are given an encoded string containing digits corresponding to letters A-Z per the following mapping: - \'A\' -> 1 - \'B\' -> 2 - ... - \'Z\' -> 26 Your task is to write a function `num_decodings` that determines the total number of ways to decode a given encoded message `enc_mes`. Function Signature ```python def num_decodings(enc_mes: str) -> int: pass ``` Input - `enc_mes` (string): A string of length n (1 <= n <= 100) containing only digits \'0\'-\'9\'. Output - Return an integer representing the total number of ways to decode the message. Constraints - A \'0\' character cannot stand alone and must be part of either \\"10\\" or \\"20\\". - If the encoded message starts with \'0\' or contains any invalid substring like \'30\', \'40\', etc., return 0. - All inputs will be non-empty strings. Example ```python assert num_decodings(\\"12\\") == 2 # \\"12\\" can be decoded as \\"AB\\" or \\"L\\" assert num_decodings(\\"226\\") == 3 # \\"226\\" can be decoded as \\"BZ\\", \\"VF\\", or \\"BBF\\" assert num_decodings(\\"06\\") == 0 # Leading \'0\' invalidates the decoding ``` Implement your function to solve the problem efficiently by handling all edge cases and ensuring O(n) time complexity.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if enc_mes[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(enc_mes[i - 1]) two_digits = int(enc_mes[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"You are required to implement the Quick Sort algorithm from scratch. The function should sort an array of integers in ascending order using the Quick Sort algorithm, and return the sorted array. Performance goals are essential, so ensure your implementation wisely handles the selection of pivot points to avoid worst-case performance where possible. # Input: - A list of integers `arr` which can have up to (10^5) elements. # Output: - The list `arr` sorted in ascending order. # Function Signature: ```python def quick_sort(arr: List[int]) -> List[int]: pass ``` # Constraints: - The elements in the list ( arr ) can be in the range ([-10^6, 10^6]). - The length of the list ( n ) will be (0 leq n leq 10^5). # Example: Example 1: ```python Input: [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] ``` Example 2: ```python Input: [1, -2, 10, -5, 0] Output: [-5, -2, 0, 1, 10] ``` # Additional Notes: 1. If the input list is empty, the function should return an empty list. 2. It is recommended to handle the selection of pivots in a randomized manner to avoid the worst-case time complexity. # Performance Considerations: Your algorithm should have an average time complexity of (O(n log n)). Make sure to consider edge cases like arrays with all the same values or already sorted arrays. You may assume that all built-in functions used during sorting must also follow constraints to prevent exacerbating time complexities.","solution":"from typing import List import random def quick_sort(arr: List[int]) -> List[int]: Implements the Quick Sort algorithm to sort an array of integers in ascending order. if len(arr) <= 1: return arr pivot = arr[random.randint(0, len(arr) - 1)] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Bogo Sorting Challenge **Context**: You have been assigned to demonstrate the inefficiencies of certain theoretical sorting algorithms. One such example is Bogo Sort, a highly inefficient and impractical sorting algorithm. # Problem Statement Implement the function `bogo_sort` that sorts an array of integers using the Bogo Sort algorithm. Your task is to demonstrate the practicalities of this algorithm by sorting various inputs and implementing an optional simulation mode to visualize the sorting process step by step. # Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers to be sorted. - `simulation` (optional): A boolean flag; if `True`, print the array at each iteration of shuffling. # Output - A sorted list of integers. # Constraints - The length of the list `arr` will be no more than 10 to avoid indefinitely long execution times. - The allowed values in `arr` range between -100 and 100. # Example Usage ```python bogo_sort([3, 2, 4]) # Output: [2, 3, 4] bogo_sort([3, 2, 4], simulation=True) # Output: # iteration 0 : 3 2 4 # iteration 1 : 3 4 2 # ... # [2, 3, 4] ``` # Performance Expectations While realizing that Bogo Sort is highly inefficient by design, your implementation should: - Correctly shuffle the array and check for a sorted condition. - Optionally display intermediate states if `simulation=True`. # Ensure Correct Implementation Be sure to handle edge cases such as: - Empty arrays. - Single-element arrays. - Arrays that are already sorted. Your code should terminate eventually with sorted output even if it takes a theoretically infinite number of shuffles.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts an array of integers using the highly inefficient Bogo Sort algorithm. If \'simulation\' is True, prints the array at each iteration. :param arr: List[int] - The list of integers to sort :param simulation: bool - If True, simulates the sorting process by printing each iteration :return: List[int] - The sorted list if len(arr) <= 1: return arr # An array of length 0 or 1 is already sorted iterations = 0 while not is_sorted(arr): iterations += 1 if simulation: print(f\\"iteration {iterations}: {\' \'.join(map(str, arr))}\\") random.shuffle(arr) if simulation: print(f\\"Sorted array: {arr}\\") return arr"},{"question":"# Question: Reverse a Singly Linked List Given the head of a singly linked list, write two functions to reverse the list: one using an iterative approach and another using a recursive approach. Both functions must handle edge cases like empty lists and single-node lists. Function Signature: * `def reverse_list(head: ListNode) -> ListNode:` * `def reverse_list_recursive(head: ListNode) -> ListNode:` Input: * `head`: The head node of a singly linked list. Each node has two attributes: * `val` (int): The value of the node. * `next` (ListNode): A reference to the next node in the list (or `None` if it is the last node). Output: * The new head of the reversed singly linked list. Constraints: * The number of nodes in the list is in the range [0, 5000]. * The range of node values is [-5000, 5000]. Example: Consider the singly linked list: ``` 1 -> 2 -> 3 -> 4 -> None ``` After reversing, it should become: ``` 4 -> 3 -> 2 -> 1 -> None ``` Implementation Requirements: Implement two functions to reverse the linked list: 1. An iterative approach with constant space complexity. 2. A recursive approach with the use of call stack space. Good luck!","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp return prev def reverse_list_recursive(head: ListNode) -> ListNode: if not head or not head.next: return head p = reverse_list_recursive(head.next) head.next.next = head head.next = None return p"},{"question":"# Question: Implement Enhanced Bitonic Sort # Problem Statement You are tasked with implementing an enhanced version of the Bitonic Sort algorithm. The Bitonic Sort algorithm can sort an array whose size is a power of two, in both increasing and decreasing order based on the specified flag. You need to implement a function that takes an array and sorts it in place. # Specifications: Function ```python def enhanced_bitonic_sort(arr, reverse=False): Sorts the input array using Bitonic Sort algorithm with enhancements for better readability and error handling. :param arr: List[int] - The array of integers to be sorted :param reverse: bool - If set to True, sorts the array in increasing order, else in decreasing order :return: List[int] - The sorted array ``` Input * `arr` - A list of integers where the length of the array is a power of two. * `reverse` - A boolean where if True, the array is sorted in increasing order, else in decreasing order. Output * Returns the sorted array (or modifies it in place). # Constraints * The length of `arr` should be a power of two, otherwise, return a ValueError. * The value of integers in `arr` can range between -10^6 and 10^6. # Example Input: ```python arr = [3, 7, 2, 8, 1, 6, 4, 5] enhanced_bitonic_sort(arr) ``` Output: ```python [1, 2, 3, 4, 5, 6, 7, 8] ``` # Notes * You must ensure your function provides adequate error handling for cases where the input length is not a power of two. * You may assume that the input list is non-empty.","solution":"def enhanced_bitonic_sort(arr, reverse=False): Sorts the input array using Bitonic Sort algorithm with enhancements for better readability and error handling. :param arr: List[int] - The array of integers to be sorted :param reverse: bool - If set to True, sorts the array in increasing order, else in decreasing order :return: List[int] - The sorted array def bitonic_compare(arr, low, cnt, dir): dist = cnt // 2 for i in range(low, low + dist): if (arr[i] > arr[i + dist]) == dir: arr[i], arr[i + dist] = arr[i + dist], arr[i] def bitonic_merge(arr, low, cnt, dir): if cnt > 1: mid = cnt // 2 bitonic_compare(arr, low, cnt, dir) bitonic_merge(arr, low, mid, dir) bitonic_merge(arr, low + mid, mid, dir) def bitonic_sort_rec(arr, low, cnt, dir): if cnt > 1: mid = cnt // 2 bitonic_sort_rec(arr, low, mid, True) bitonic_sort_rec(arr, low + mid, mid, False) bitonic_merge(arr, low, cnt, dir) if not (len(arr) != 0 and (len(arr) & (len(arr) - 1)) == 0): raise ValueError(\\"The length of the array must be a power of two.\\") bitonic_sort_rec(arr, 0, len(arr), reverse) return arr"},{"question":"You have been given the task to implement a function that sorts an array of non-negative integers using a non-comparative radix sorting algorithm. # Function Signature ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of non-negative integers. * `simulation`: A boolean flag indicating whether to print the array at each significant digit iteration (default is `False`). # Output * A list of integers sorted in ascending order. # Example ```python input: [170, 45, 75, 90, 802, 24, 2, 66] output: [2, 24, 45, 66, 75, 90, 170, 802] input: [1, 10, 1000, 100, 10000] output: [1, 10, 100, 1000, 10000] ``` # Constraints * Assume that all integers provided are non-negative. * If `simulation` is `True`, print the array at each digit iteration step. # Performance Requirements * The solution should be optimized to run in O(nk) complexity where `n` is the number of items, and `k` is the number of digits in the largest number. # Guidelines * Handle edge cases like empty arrays and single-element arrays. * Maintain the integrity of relative ordering for integers with the same digit values (stability). * Consider potential performance improvements in your implementation.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool) -> None: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 for i in range(len(arr)): arr[i] = output[i] if simulation: print(f\'After sorting on exp={exp}: {arr}\') def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Question: ZigZag Iterator Generalized You are required to implement a generalized ZigZag Iterator that supports an arbitrary number of input lists and retrieves their elements in a round-robin fashion. Function Signature: ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here with a list of lists. :type lists: List[List[int]] pass def next(self) -> int: Retrieve the next element in the zigzag order. :rtype: int pass def has_next(self) -> bool: Check if there are more elements to retrieve. :rtype: bool pass ``` Requirements: * **Initialization**: On initializing the class with a list of lists, the iterator should be prepared for iteration. * **next**: This method should return the next element in the zigzag order. * **has_next**: This method should return `True` if there are more elements to be retrieved, otherwise `False`. Example: ```python # Given input: lists = [ [1, 2], [3, 4, 5, 6], [7, 8, 9] ] # Using the ZigZagIterator: iterator = ZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) # Expected Output: # result should be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Constraints: * The input `lists` will contain between 1 and 100 lists. * Each inner list will have between 0 and 100 elements. * Elements of each list will be integers. * You should not use any third-party libraries.","solution":"from typing import List, Any class ZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here with a list of lists. self.queue = [] self.lists = lists for i, lst in enumerate(lists): if lst: self.queue.append((i, 0)) def next(self) -> Any: Retrieve the next element in the zigzag order. if not self.has_next(): raise Exception(\\"No more elements\\") i, idx = self.queue.pop(0) result = self.lists[i][idx] if idx + 1 < len(self.lists[i]): self.queue.append((i, idx + 1)) return result def has_next(self) -> bool: Check if there are more elements to retrieve. return len(self.queue) > 0"},{"question":"# Question You are given two binary trees `s` and `t`. Implement a function `is_subtree(s, t)` to check if `t` is a subtree of `s`. A subtree of a tree `t` is a tree consisting of a node in `t` and all of its descendants in `t`. # Function Signature ```python def is_subtree(big, small): pass ``` # Expected Input and Output * **Input**: Two binary trees `s` (big) and `t` (small) represented using nodes. Each node contains an integer `val` and pointers to left and right children. * **Output**: Boolean value, `True` if `t` is a subtree of `s`, `False` otherwise. # Constraints 1. The number of nodes in both trees will be in the range [1, 2000]. 2. Node values are integers and can be positive or negative, but each node is unique in its respective tree. # Performance Requirements - Ensure the implementation is efficient and can handle the given constraints without significant performance degradation. # Scenario Imagine you are implementing a system to check if a certain configuration (tree `t`) fits into a larger configuration (tree `s`). For example, in configuration management or hierarchical data comparisons, determining if a tree structure is exactly fitting within another is essential. # Example ```python # Tree s # 3 # / # 4 5 # / # 1 2 # Tree t # 4 # / # 1 2 print(is_subtree(s, t)) # Output: True # Tree s # 3 # / # 4 5 # / # 1 2 # / # 0 # Tree t # 3 # / # 4 # / # 1 2 print(is_subtree(s, t)) # Output: False ``` # Notes - You may assume the function `comp(p, q)` is correctly implemented for comparing two trees for structural and value equality. - Handle edge cases where one or both of the trees are `None`. - Assume the node values are integers, and the nodes are part of a binary tree with potentially `None` children.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): if not small: return True if not big: return False if are_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small) def are_identical(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False if t1.val != t2.val: return False return are_identical(t1.left, t2.left) and are_identical(t1.right, t2.right)"},{"question":"# Scenario: You are tasked with implementing a mini-database that utilizes a self-balancing tree to efficiently manage a series of operations. Your goal is to implement an auxiliary function that calculates the number of nodes within a specified range [low, high] inclusive, in a Red-Black Tree (RBTree). This function should be used for processing range queries which are common in database systems. # Requirements: - Implement the function `count_in_range(self, low: int, high: int) -> int` in the class `RBTree` provided. - The function should count the number of nodes in the tree that have values in the range [low, high] inclusive. - You must ensure that the function adheres to the Red-Black Tree properties during operations if any nodes are accessed or modified. # Input/Output: - **Input**: Two integers `low` and `high` representing the range [low, high]. - **Output**: An integer representing the count of nodes in the given range. # Constraints: - `-10^9 <= low <= high <= 10^9` - The tree may contain up to 10^5 nodes. # Function Signature: ```python class RBTree: ... def count_in_range(self, low: int, high: int) -> int: # Your code goes here ``` # Example: Assume a tree constructed with the following values `[11, 2, 14, 1, 7, 15, 5, 8, 4]`: ```python rb = RBTree() values = [11, 2, 14, 1, 7, 15, 5, 8, 4] for val in values: rb.insert(RBNode(val, 1)) print(rb.count_in_range(4, 10)) # Output should be 4 (since values 4, 5, 7, 8 are in this range) ``` # Notes: - You may assume the Red-Black Tree implementation from the provided code snippet is accurate and functional. - Focus on leveraging tree properties for efficient querying. --- # Solution Outline: 1. Implement a helper function that performs an in-order traversal to count nodes within the given range [low, high]. 2. Ensure that the traversal skips unnecessary branches to maintain efficiency. 3. The traversal can start from the root and count relevant nodes while pruning subtrees that are out of range. Reference the properties and use cases as provided in the algorithm analysis to justify the Red-Black Tree selections and enhance solution efficiency.","solution":"class RBTreeNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # Red = 1, Black = 0 self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.NULL_LEAF = RBTreeNode(0, 0) self.root = self.NULL_LEAF def insert(self, key): new_node = RBTreeNode(key, 1, self.NULL_LEAF, self.NULL_LEAF) if self.root is self.NULL_LEAF: self.root = new_node self.root.color = 0 else: self._insert(self.root, new_node) self._fix_insert(new_node) # Implement node insertion with balancing def _insert(self, root, node): if node.key < root.key: if root.left is self.NULL_LEAF: root.left = node node.parent = root else: self._insert(root.left, node) else: if root.right is self.NULL_LEAF: root.right = node node.parent = root else: self._insert(root.right, node) def _fix_insert(self, node): # Implement Red-Black Tree fix insert logic pass # Count nodes in the range [low, high] def count_in_range(self, low: int, high: int) -> int: def count_nodes(node, low, high): if node is self.NULL_LEAF: return 0 if node.key < low: return count_nodes(node.right, low, high) elif node.key > high: return count_nodes(node.left, low, high) else: return (1 + count_nodes(node.left, low, high) + count_nodes(node.right, low, high)) return count_nodes(self.root, low, high)"},{"question":"# Question: Tree Structure Printer You are given a data structure represented as a nested dictionary where the keys are strings and the values can either be strings, integers, or further nested dictionaries. Your task is to write a function that prints this structure in a readable tree-like format. **Function Signature:** ```python def tree_print(tree: dict) -> None: pass ``` # Input - **tree**: A dictionary representing the nested tree structure. Each key is a string, and its corresponding value can be: - a string, which signifies a leaf node. - an integer, which signifies a leaf node with a quantity. - another dictionary, signifying further nesting. # Output - The function should print the tree structure using `print()` statements. - The printing should start with the key at the root level, followed by indented keys for any nested dictionaries or values. # Constraints - The dictionary can be empty. - The depth of nesting can be arbitrary but consistent. # Example Here is an example input and the expected printed output: ```python tree = { \'a\': { \'Adam\': { \'Book\': 4 } }, \'b\': { \'Bill\': { \'Computer\': 5, \'TV\': 6 }, \'Jill\': { \'Sports\': 1 } }, \'c\': { \'Bill\': { \'Sports\': 3 } }, \'d\': { \'Adam\': { \'Computer\': 3 }, \'Quin\': { \'Computer\': 3 } }, \'e\': { \'Quin\': { \'Book\': 5, \'TV\': 2 } }, \'f\': { \'Adam\': { \'Computer\': 7 } } } ``` **Expected Printed Output:** ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Handle the indentation and formatting accurately to reflect the nested structure.","solution":"def tree_print(tree: dict, indent: str = \\"\\"): Prints the tree structure in a readable, indented format. for k, v in tree.items(): if isinstance(v, dict): print(f\\"{indent}{k} ->\\") tree_print(v, indent + \\" \\") else: print(f\\"{indent}{k} -> {v}\\") # Example tree for demonstration example_tree = { \'a\': { \'Adam\': { \'Book\': 4 } }, \'b\': { \'Bill\': { \'Computer\': 5, \'TV\': 6 }, \'Jill\': { \'Sports\': 1 } }, \'c\': { \'Bill\': { \'Sports\': 3 } }, \'d\': { \'Adam\': { \'Computer\': 3 }, \'Quin\': { \'Computer\': 3 } }, \'e\': { \'Quin\': { \'Book\': 5, \'TV\': 2 } }, \'f\': { \'Adam\': { \'Computer\': 7 } } } # Uncomment to demo the function # tree_print(example_tree)"},{"question":"You are given two tasks to verify your understanding of matrix multiplication and matrix exponentiation using the provided code snippets. 1. **Matrix Chain Multiplication**: Writing a function to determine the minimum number of scalar multiplications needed to multiply a chain of matrices. 2. **Matrix Power Modulus**: Writing a function to compute the power of a square matrix modulo a given integer. Task 1: Matrix Chain Multiplication **Function Signature**: ```python def matrix_chain_order(p: list) -> int: Calculates the minimum number of multiplications needed to multiply a given chain of matrices. Parameters: p (List[int]): A list of integers such that the ith matrix has dimensions p[i-1] x p[i]. Returns: int: Minimum number of scalar multiplications needed. ``` **Input**: - `p`: A list of integers where the ith matrix A[i] has dimensions p[i-1] x p[i]. **Output**: - Return the minimum number of scalar multiplications needed to multiply the chain. Task 2: Matrix Power Modulus **Function Signature**: ```python def matrix_power_modulo(mat: list, n: int, mod: int) -> list: Raises a square matrix mat to the power n modulo mod. Parameters: mat (List[List[int]]): A square matrix. n (int): The exponent. mod (int): The modulus. Returns: List[List[int]]: The resultant matrix after raising to the power n and taking modulo mod. ``` **Input**: - `mat`: A list of lists representing a square matrix. - `n`: A non-negative integer representing the exponent. - `mod`: A positive integer for the modulus operation. **Output**: - Return the resultant matrix after raising the input matrix to power `n` and taking `mod`. **Constraints**: - For `matrix_chain_order`: 2 ≤ length of p ≤ 100. - For `matrix_power_modulo`: 1 ≤ len(mat) ≤ 100, 1 ≤ n, mod ≤ 10^9, all elements of mat are integers between 0 and 10^9. **Example**: ```python # Example 1 p1 = [1, 2, 3, 4] print(matrix_chain_order(p1)) # Output: 18 # Example 2 mat = [[1, 1], [1, 0]] n = 5 mod = 100 print(matrix_power_modulo(mat, n, mod)) # Output: [[8, 5], [5, 3]] ``` **Note**: - Your implementation should focus on efficiency. - Consider the best use of dynamic programming and matrix properties in your solutions.","solution":"def matrix_chain_order(p): Calculates the minimum number of multiplications needed to multiply a given chain of matrices. Parameters: p (List[int]): A list of integers such that the ith matrix has dimensions p[i-1] x p[i]. Returns: int: Minimum number of scalar multiplications needed. n = len(p) - 1 # m[i][j] is the minimum number of scalar multiplications needed # to compute the matrix A[i]A[i+1]...A[j] = A[i..j] # The cost is zero when multiplying one matrix m = [[0 for x in range(n)] for x in range(n)] # L is the chain length for L in range(2, n + 1): for i in range(0, n - L + 1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): # q = cost/scalar multiplications q = m[i][k] + m[k+1][j] + p[i] * p[k+1] * p[j+1] if q < m[i][j]: m[i][j] = q return m[0][n-1] def matrix_power_modulo(mat, n, mod): Raises a square matrix mat to the power n modulo mod. Parameters: mat (List[List[int]]): A square matrix. n (int): The exponent. mod (int): The modulus. Returns: List[List[int]]: The resultant matrix after raising to the power n and taking modulo mod. size = len(mat) def matrix_mult(A, B, mod): return [[sum(A[i][k] * B[k][j] for k in range(size)) % mod for j in range(size)] for i in range(size)] def matrix_pow(mat, exp, mod): result = [[1 if i == j else 0 for j in range(size)] for i in range(size)] base = mat while exp > 0: if exp % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) exp //= 2 return result return matrix_pow(mat, n, mod)"},{"question":"# Coding Assessment Problem Statement You are given two strings `s1` and `s2`. The string `s2` contains all distinct characters. Your task is to write a function to find the length of the longest common contiguous substring of characters in `s1` and `s2`. Function Signature ```python def max_common_sub_string_length(s1: str, s2: str) -> int: # implementation here ``` Inputs * `s1`: A string containing characters (0 <= len(s1) <= 10^5) * `s2`: A string containing distinct characters (0 <= len(s2) <= 10^5) Output * Return an integer representing the length of the longest common contiguous substring of characters in `s1` and `s2`. Constraints * The strings `s1` and `s2` will consist of printable ASCII characters. Performance Requirements * The solution should aim for an optimal time complexity, focusing on O(n * log(m)) if possible, where `n` is the length of `s1` and `m` is the length of `s2`. Example ```python assert max_common_sub_string_length(\\"abcdef\\", \\"bcd\\") == 3 assert max_common_sub_string_length(\\"xyz\\", \\"abc\\") == 0 assert max_common_sub_string_length(\\"axbxcxdx\\", \\"abcd\\") == 1 assert max_common_sub_string_length(\\"pqrstuv\\", \\"rst\\") == 3 ``` Notes * Your solution should handle edge cases gracefully, including but not limited to empty strings and no common substrings. * Ensure your implementation is optimized to handle large inputs within reasonable execution time.","solution":"def max_common_sub_string_length(s1: str, s2: str) -> int: def is_substring_common(length: int) -> bool: substring_set = set() for i in range(len(s1) - length + 1): substring_set.add(s1[i:i + length]) for j in range(len(s2) - length + 1): if s2[j:j + length] in substring_set: return True return False left, right = 0, min(len(s1), len(s2)) max_length = 0 while left <= right: mid = (left + right) // 2 if is_substring_common(mid): max_length = mid left = mid + 1 else: right = mid - 1 return max_length"},{"question":"# Shell Sort Implementation Challenge You are provided with a partially sorted array, and your task is to implement an efficient sorting algorithm known as **Shell Sort**. Shell Sort allows you to sort the array by comparing and moving elements that are far apart, and progressively reducing the gap between elements to achieve the final sorted order. # Objective Write a function `improved_shell_sort(arr)` that sorts the input array `arr` using the Shell Sort algorithm. You may use any appropriate gap sequence to enhance the efficiency of the sorting process. # Function Signature ```python def improved_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input - The function accepts one parameter: - `arr`: A list of integers, which needs to be sorted. The length of the list can be between 0 and 100,000. # Output - The function should return the sorted list of integers. # Constraints - The list can be empty. - The list can contain duplicate elements. - The elements in the list can be positive or negative integers. # Performance Requirements - Your implementation should aim for a time complexity better than (O(n^2)) in practical scenarios. - Ensure the space complexity remains (O(1)). # Example ```python assert improved_shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert improved_shell_sort([1, 4, 3, -2, 0]) == [-2, 0, 1, 3, 4] assert improved_shell_sort([]) == [] assert improved_shell_sort([3, 3, 2, 1]) == [1, 2, 3, 3] ``` # Notes - Consider various gap sequences to fine-tune the performance. - Focus on writing clean, readable, and efficient code. - Think about and handle edge cases appropriately.","solution":"def improved_shell_sort(arr): Shell sort algorithm implementation. This function sorts an input list using the Shell Sort algorithm with the Knuth sequence for gap sizes. n = len(arr) gap = 1 # Using the Knuth\'s sequence (1, 4, 13, 40, 121, ...) while gap < n // 3: gap = 3 * gap + 1 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"**Set Cover Problem** You will implement two solutions to the Set Cover Problem: one using an optimal algorithm (brute-force) and the other using a greedy heuristic algorithm. These algorithms will select subsets from a given set of subsets to cover all elements in the universe set at minimum cost. # Optimal Algorithm Implement the function `optimal_set_cover(universe, subsets, costs)`: - **Input**: - `universe`: A set containing the universe of elements. - `subsets`: A dictionary where each key is a subset identifier and the value is a set containing the elements of that subset. - `costs`: A dictionary where each key is a subset identifier and the value is the cost associated with that subset. - **Output**: - The subset identifiers forming the optimal set cover. If multiple solutions exist with the same cost, return any one of them. # Greedy Algorithm Implement the function `greedy_set_cover(universe, subsets, costs)`: - **Input**: - `universe`: A set containing the universe of elements. - `subsets`: A dictionary where each key is a subset identifier and the value is a set containing the elements of that subset. - `costs`: A dictionary where each key is a subset identifier and the value is the cost associated with that subset. - **Output**: - The subset identifiers forming a greedy set cover. If multiple solutions exist with the same cost, return any one of them. # Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(universe, subsets, costs) greedy_cover = greedy_set_cover(universe, subsets, costs) print(\'Optimal Set Cover:\', optimal_cover) print(\'Greedy Set Cover:\', greedy_cover) ``` # Constraints - Each subset identifier is unique and maps to a non-empty set within the universe set. - Costs are non-negative integers. - The universe set is non-empty. You are expected to handle edge cases appropriately, e.g., non-coverable universe or empty subsets. Analyze the performance of both algorithms and discuss the possible use cases where one might prefer the greedy approach over the optimal.","solution":"from itertools import combinations def optimal_set_cover(universe, subsets, costs): Optimal algorithm for the set cover problem using brute-force. all_subsets = list(subsets.keys()) min_cost = float(\'inf\') best_combination = None for r in range(1, len(all_subsets) + 1): for combination in combinations(all_subsets, r): covered = set() total_cost = 0 for subset_id in combination: covered.update(subsets[subset_id]) total_cost += costs[subset_id] if covered == universe and total_cost < min_cost: min_cost = total_cost best_combination = combination return best_combination def greedy_set_cover(universe, subsets, costs): Greedy algorithm for the set cover problem. uncovered = universe.copy() chosen_subsets = set() while uncovered: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_id, elements in subsets.items(): if subset_id in chosen_subsets: continue coverage = len(uncovered & elements) if coverage == 0: continue cost_effectiveness = costs[subset_id] / coverage if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_id if not best_subset: raise ValueError(\\"The universe cannot be covered by given subsets.\\") chosen_subsets.add(best_subset) uncovered -= subsets[best_subset] return chosen_subsets"},{"question":"You are given an array consisting of `n` elements, where each element is either `0`, `1`, or `2`. This array needs to be sorted in a single pass such that all `0`s appear first, followed by all `1`s, and finally all `2`s. This is a representation of the Dutch National Flag problem. Write a function `sort_colors(nums)` that takes in a list called `nums` and sorts it in-place according to the described order. You are not allowed to use any sort function from the standard library. # Input - A list of integers `nums` where `0 <= nums[i] <= 2`. # Output - The input list sorted in-place. The function should return `None`. # Constraints - The solution should have a time complexity of O(n) and space complexity of O(1). - `0 <= len(nums) <= 2 * 10^4` # Example ```python # Example 1: nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2: nums = [2, 2, 2, 0, 0, 1, 1] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 3: nums = [1, 2, 0, 1, 2, 0, 0, 1, 1, 0, 2, 1, 2] sort_colors(nums) print(nums) # Output: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2] ``` # Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` # Notes - Ensure your solution handles edge cases like empty arrays or arrays with all identical elements. - Your solution should meet both the time and space complexity requirements mentioned.","solution":"def sort_colors(nums): Sorts the array such that all 0s come first, followed by all 1s, and then all 2s. This is done in-place with O(n) time complexity and O(1) space complexity. low = 0 mid = 0 high = len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Binary Tree Depth Calculation and Traversal You are tasked with implementing functions to calculate the minimum depth of a binary tree and perform pre-order traversal of the binary tree. Write the following functions: 1. `min_depth_recursive`: This function should take in the root of the binary tree and return the minimum depth using recursion. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 2. `min_depth_iterative`: This function should take in the root of the binary tree and return the minimum depth using an iterative approach (BFS). 3. `pre_order_traversal`: This function should take in the root of the binary tree and print the value of each node following the pre-order traversal method (Root -> Left -> Right). # Input - `min_depth_recursive` and `min_depth_iterative`: * `root`: The root node of the binary tree (TreeNode). - `pre_order_traversal`: * `root`: The root node of the binary tree (TreeNode). # Output - `min_depth_recursive` and `min_depth_iterative`: * An integer representing the minimum depth of the binary tree. - `pre_order_traversal`: * Print the values of nodes in pre-order traversal order. # Constraints - The number of nodes in the tree is in the range [0, 10^4]. - Node values are within the range [-10^9, 10^9]. **Example** Assume the `TreeNode` class and the tree structure are defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(min_depth_recursive(root)) # Output: 2 print(min_depth_iterative(root)) # Output: 2 pre_order_traversal(root) # Output: 1, 2, 4, 5, 3 ``` Implement the `min_depth_recursive`, `min_depth_iterative`, and `pre_order_traversal` functions to pass the tests described above.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth_recursive(root): if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth_recursive(root.right) + 1 if not root.right: return min_depth_recursive(root.left) + 1 return min(min_depth_recursive(root.left), min_depth_recursive(root.right)) + 1 def min_depth_iterative(root): if not root: return 0 queue = deque([(root, 1)]) # (node, depth) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def pre_order_traversal(root): if root: print(root.val, end=\' \') pre_order_traversal(root.left) pre_order_traversal(root.right)"},{"question":"**Problem Statement**: Interpolation search is an algorithm used for searching for a key in a sorted array. It improves the binary search by estimating where the value might be based on the key value and the values at the boundaries of the array. Given a sorted array `array` of `n` integers in increasing order, implement the `interpolation_search` function to find the position of the search key `search_key` in the array. # Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: ``` # Input 1. `array`: A list of integers sorted in increasing order. Length of the list, `n`, where `1 <= n <= 10^6`. 2. `search_key`: An integer value to be searched in the array. # Output Returns the index of `search_key` in `array` if found, otherwise returns `-1`. # Requirements * The algorithm must execute with a time complexity of O(log log n) in the average case. * Handle edge cases where `search_key` might be outside the bounds of the array. # Constraints * The array is assumed to be sorted in non-decreasing order. * Integers in the array and search key will be within the range [-10^9, 10^9]. # Example ```python print(interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 print(interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) # Output: -1 ``` # Explanation * In the first example, `-1` is found at index `2`. * In the second example, `55` is not present in the array, hence it returns `-1`. * In the third example, `-5` is not present in the array, hence it returns `-1`. # Additional Notes To achieve the best possible performance, make sure to handle non-uniform distributions gracefully and check the bounds to avoid any potential division by zero errors in the calculation. Good luck and happy coding!","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted array. Parameters: array (List[int]): A sorted list of integers. search_key (int): The integer value to search in the array. Returns: int: The index of search_key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[high] == array[low]. if array[high] == array[low]: if array[low] == search_key: return low else: return -1 # Estimate the position of the search_key pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Check if search_key is found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part elif array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 # If the search_key is not found return -1"},{"question":"In the context of cryptographic computations, you have been assigned the task of implementing a modular exponentiation function. This function is crucial for efficient handling of large powers under a modulo operation. Implement a function `mod_expo` that computes `(base ^ exponent) % mod`, inspired by the given algorithm snippet. Your function should handle non-negative exponent inputs and should be optimized to work efficiently even with very large exponents. You need to account for the following specifics: 1. **Function Signature**: ```python def mod_expo(base: int, exponent: int, mod: int) -> int: ``` 2. **Input**: - `base` (1 <= base <= 10^9): The base number. - `exponent` (0 <= exponent <= 10^9): The exponent value. - `mod` (1 <= mod <= 10^9): The modulus value. 3. **Output**: - integer representing `(base ^ exponent) % mod`. 4. **Constraints**: - The function should handle cases where the exponent is zero. - Handling of negative exponent cases will result in raising a `ValueError` with an appropriate message (\\"Exponent must be positive.\\"). 5. **Performance**: - Your solution should be efficient, running in O(log n) time complexity where n is the exponent. # Examples 1. **Example 1:** ```python assert mod_expo(2, 10, 1000) == 24 ``` Explanation: (2^{10} mod 1000 = 1024mod 1000 = 24). 2. **Example 2:** ```python assert mod_expo(2, 0, 1000) == 1 ``` Explanation: Any number to the power of zero is 1. 3. **Example 3:** ```python assert mod_expo(100, 1000000000, 13) == 9 ``` Explanation: (100^{1000000000} mod 13 = 9), since this requires efficient exponentiation.","solution":"def mod_expo(base: int, exponent: int, mod: int) -> int: if exponent < 0: raise ValueError(\\"Exponent must be positive.\\") result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Objective Write a function to concatenate multiple parts of a file path or URL while ensuring there\'s exactly one slash between each part. This function should handle edge cases and adhere to given constraints. # Requirements * The function should take multiple string arguments and join them into a valid file path or URL. * There should be exactly one slash between concatenated parts, regardless of whether a part originally ends or begins with a slash. * Empty parts should be ignored. * Input constraints: Each part will be a non-null string where each string length is up to 1000 characters. * The combined string length should not exceed 10000 characters. # Input & Output * **Input**: * `parts`: A list of non-empty string parts to be joined. * **Output**: * A single string representing the concatenated path or URL. # Example ```python assert join_parts([\\"path\\", \\"to\\", \\"dir\\"]) == \\"path/to/dir\\" assert join_parts([\\"http://site.com/\\", \\"/path/\\", \\"/page\\"]) == \\"http://site.com/path/page\\" assert join_parts([\\"\\", \\"section\\", \\"\\"]) == \\"section\\" assert join_parts([\\"dir\\", \\"\\", \\"file\\"]) == \\"dir/file\\" ``` # Function Signature ```python def join_parts(parts: List[str]) -> str: pass ``` # Notes * You can\'t assume the input will have a fixed number of parts. * The function should gracefully handle possible edge cases such as being provided with only empty strings or strings with varying leading/trailing slashes.","solution":"from typing import List def join_parts(parts: List[str]) -> str: Joins multiple parts of a file path or URL ensuring there is exactly one slash between each part, ignoring empty parts. # Strip leading and trailing slashes from all parts and filter out empty parts cleaned_parts = [part.strip(\'/\') for part in parts if part] # Join the cleaned parts with exactly one slash return \'/\'.join(cleaned_parts)"},{"question":"Postorder Traversal of a Binary Tree Context: You are working with binary trees for various applications such as expression evaluation and tree deletions. Implementing tree traversal algorithms effectively is crucial for these operations. Task: Write a function for postorder traversal of a binary tree using both iterative and recursive approaches. Given the root of a binary tree, return an array containing the values of the nodes visited in postorder sequence. # Function Signature: ```python def postorder_traversal_iterative(root: Node) -> List[int]: Perform postorder traversal in an iterative manner and return the values in postorder sequence. :param root: Root node of the binary tree. :return: List of values in postorder. pass def postorder_traversal_recursive(root: Node) -> List[int]: Perform postorder traversal in a recursive manner and return the values in postorder sequence. :param root: Root node of the binary tree. :return: List of values in postorder. pass ``` # Example: ```python # Construct the following binary tree # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) # Using postorder traversal, the expected output is [4, 5, 2, 3, 1] print(postorder_traversal_iterative(root)) # Output: [4, 5, 2, 3, 1] print(postorder_traversal_recursive(root)) # Output: [4, 5, 2, 3, 1] ``` # Constraints: - Number of nodes in the tree: 0 ≤ n ≤ 10^4 - Node values are unique integers. # Notes: - Ensure the function handles edge cases, such as an empty tree and single-node tree, correctly. - Implement both the iterative and recursive versions to demonstrate a thorough understanding of tree traversal techniques.","solution":"from typing import List, Optional class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def postorder_traversal_iterative(root: Node) -> List[int]: Perform postorder traversal in an iterative manner and return the values in postorder sequence. :param root: Root node of the binary tree. :return: List of values in postorder. if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_traversal_recursive(root: Node) -> List[int]: Perform postorder traversal in a recursive manner and return the values in postorder sequence. :param root: Root node of the binary tree. :return: List of values in postorder. def helper(node: Optional[Node], result: List[int]): if node: helper(node.left, result) helper(node.right, result) result.append(node.value) result = [] helper(root, result) return result"},{"question":"# Question Implement a hash table that supports efficient insertion, deletion, and search operations. Additionally, design the hash table to dynamically resize itself when it meets certain load thresholds to maintain performance. Implement the following methods in the `DynamicResizableHashTable` class: 1. **put(key, value)**: Inserts or updates the key-value pair in the hash table. 2. **get(key)**: Retrieves the value associated with the key in the hash table. Returns `None` if the key is not found. 3. **del_(key)**: Deletes the key-value pair from the hash table if the key is present. 4. **resize()**: Resizes the hash table to maintain performance when the load factor exceeds a threshold. **Constraints:** - `key` can be any integer. - `value` can be any object. - Perform the resize operation when the number of entries is at least 75% of the table\'s capacity. **Input & Output:** - The input will include a series of operations and their corresponding arguments. - The output should be the result of the get operations in the same order as they appear in the input. **Example:** ```python ht = DynamicResizableHashTable() ht.put(1, \\"one\\") ht.put(2, \\"two\\") print(ht.get(1)) # Expected output: \\"one\\" ht.del_(1) print(ht.get(1)) # Expected output: None ht.put(3, \\"three\\") ht.put(4, \\"four\\") ht.put(5, \\"five\\") # Assuming table resizes, all values should still be retrievable print(ht.get(3)) # Expected output: \\"three\\" ``` **Implementation Skeleton:** ```python class DynamicResizableHashTable(object): # Constants for status of table slots _empty = object() _deleted = object() def __init__(self, size=8): self.size = size self._len = 0 self._keys = [self._empty] * size self._values = [self._empty] * size def hash(self, key): return key % self.size def _rehash(self, old_hash): return (old_hash + 1) % self.size def put(self, key, value): # Your implementation here pass def get(self, key): # Your implementation here pass def del_(self, key): # Your implementation here pass def resize(self): # Your implementation here pass ```","solution":"class DynamicResizableHashTable(object): # Constants for status of table slots _empty = object() _deleted = object() def __init__(self, size=8): self.size = size self._len = 0 self._keys = [self._empty] * size self._values = [self._empty] * size def hash(self, key): return key % self.size def _rehash(self, old_hash): return (old_hash + 1) % self.size def put(self, key, value): if self._len >= self.size * 0.75: self.resize() hash_index = self.hash(key) while self._keys[hash_index] not in {self._empty, self._deleted} and self._keys[hash_index] != key: hash_index = self._rehash(hash_index) if self._keys[hash_index] in {self._empty, self._deleted}: self._len += 1 self._keys[hash_index] = key self._values[hash_index] = value def get(self, key): hash_index = self.hash(key) while self._keys[hash_index] != self._empty: if self._keys[hash_index] == key: return self._values[hash_index] hash_index = self._rehash(hash_index) return None def del_(self, key): hash_index = self.hash(key) while self._keys[hash_index] != self._empty: if self._keys[hash_index] == key: self._keys[hash_index] = self._deleted self._values[hash_index] = self._deleted self._len -= 1 return hash_index = self._rehash(hash_index) def resize(self): old_keys = self._keys old_values = self._values new_size = self.size * 2 self.size = new_size self._keys = [self._empty] * new_size self._values = [self._empty] * new_size self._len = 0 for i in range(len(old_keys)): if old_keys[i] not in {self._empty, self._deleted}: self.put(old_keys[i], old_values[i])"},{"question":"You are given a function signature that you need to implement. The function `last_occurrence(array, query)` should return the index of the last occurrence of the specified number in a sorted (non-decreasing) array. If the number is not present, return -1. # Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: pass ``` # Input - `array`: A list of integers sorted in non-decreasing order (1 ≤ len(array) ≤ 10^5). - `query`: An integer to find in the array (-10^9 ≤ query ≤ 10^9). # Output - The integer index of the last occurrence of `query` in the array. If not found, return -1. # Constraints - You must use a logarithmic approach (O(log n)) to solve this problem efficiently. - You cannot use built-in functions like `index` or `find`. # Example ```python assert last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 3 assert last_occurrence([1, 1, 2, 2, 3, 4, 5], 1) == 1 assert last_occurrence([1, 2, 3, 4, 5], 6) == -1 assert last_occurrence([1, 2, 2, 2, 2, 2, 2, 3], 2) == 6 ``` # Explanation 1. In `[1, 2, 2, 2, 3, 4, 5]` for the query `2`, the last occurrence is at index 3. 2. In `[1, 1, 2, 2, 3, 4, 5]` for the query `1`, the last occurrence is at index 1. 3. In `[1, 2, 3, 4, 5]` for the query `6`, it is not present, so return -1. 4. In `[1, 2, 2, 2, 2, 2, 2, 3]` for the query `2`, the last occurrence is at index 6.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # Continue searching in right half elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"Context You are tasked with designing a more efficient insertion sort algorithm by utilizing binary search to find the insertion point quickly. This improvement helps reduce the time complexity of finding the insertion point from O(n) to O(log n) for each insertion, achieving overall better performance. Problem Statement Given an unsorted array of integers, implement a function to sort the array using an optimized insertion sort algorithm. This requires using the `search_insert` function provided to determine the index at which an element needs to be inserted in the already sorted portion of the array. Function Signature ```python def optimized_insertion_sort(array: List[int]) -> List[int]: pass ``` Input * **array** (`List[int]`): A list of integers to be sorted. Output * **sorted_array** (`List[int]`): The input list sorted in ascending order. Constraints * The input list can have a length of up to 1000 elements. * The elements of the list are integers in the range `[-10^5, 10^5]`. Example ```python # Example 1 input_array = [4, 3, 2, 10, 12, 1, 5, 6] # Explanation: After sorting, the array becomes [1, 2, 3, 4, 5, 6, 10, 12] # Example 2 input_array = [1, 3, 5, 7, 9, 2, 4, 6, 8] # Explanation: After sorting, the array becomes [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Instructions 1. Implement the `optimized_insertion_sort` function using the provided `search_insert` function. 2. Your solution should have an efficient approach for finding the insertion point and for inserting elements accordingly. 3. Ensure to handle edge cases where the array is empty or contains repeated elements. Evaluation Criterion * Correctness: The sorted array must be in ascending order. * Efficiency: The optimized approach using binary search for finding insertion points will be evaluated. * Edge Cases: Handling of diverse edge cases such as empty arrays or arrays with large values. * Code quality: Use clear, concise, and well-commented code where necessary. ```python # Defining the provided helper function for reference def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def optimized_insertion_sort(array: List[int]) -> List[int]: # Your code here pass ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Find the index where `val` should be inserted to maintain sorted order. Uses binary search to determine the insertion point. low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def optimized_insertion_sort(array: List[int]) -> List[int]: Sorts the array using an optimized insertion sort that leverages binary search to find the correct insertion points, improving efficiency. for i in range(1, len(array)): key = array[i] # Find the index where the key should be inserted j = search_insert(array[:i], key) # Move all elements after index j up by one array = array[:j] + [key] + array[j:i] + array[i+1:] return array"},{"question":"# Scenario You are asked to build a simple backup mechanism for texts where you frequently encounter repeated sequences. To achieve this, you\'ll use the Run-Length Encoding (RLE) algorithm to compress and decompress textual data. # Task Implement two functions `encode_rle` and `decode_rle` to perform compression and decompression using the Run-Length Encoding (RLE) algorithm. # Function 1: Encode **Function Signature**: ```python def encode_rle(input: str) -> str: ``` **Input**: A string `input` to be encoded. * The string may contain any printable characters. * Constraints: (0 leq text{len(input)} leq 10^5) **Output**: Returns the encoded string using the RLE algorithm. # Function 2: Decode **Function Signature**: ```python def decode_rle(input: str) -> str: ``` **Input**: A string `input` to be decoded. * The string will strictly follow the RLE format where numbers are always followed by characters (e.g., \\"3a2b4c\\"). **Output**: Returns the decoded string via RLE decoding. # Examples ```python # Encoding example assert encode_rle(\\"aaaabbbccdaa\\") == \\"4a3b2c1d2a\\" # Decoding example assert decode_rle(\\"4a3b2c1d2a\\") == \\"aaaabbbccdaa\\" # Edge cases assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" assert encode_rle(\\"a\\") == \\"1a\\" assert decode_rle(\\"1a\\") == \\"a\\" assert encode_rle(\\"aaaaaaaaaa\\") == \\"10a\\" assert decode_rle(\\"10a\\") == \\"aaaaaaaaaa\\" ``` # Guidelines * Ensure to handle edge cases like empty inputs, single characters, and large sequences of the same character. * Aim for efficient implementations due to the potential length of input data.","solution":"def encode_rle(input: str) -> str: Encode the input string using Run-Length Encoding (RLE) algorithm. if not input: return \\"\\" encoded_string = [] current_char = input[0] count = 0 for char in input: if char == current_char: count += 1 else: encoded_string.append(f\\"{count}{current_char}\\") current_char = char count = 1 # Append the last sequence encoded_string.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_string) def decode_rle(input: str) -> str: Decode the input string which is encoded using Run-Length Encoding (RLE) algorithm. if not input: return \\"\\" decoded_string = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_string.append(char * int(count)) count = \\"\\" return \'\'.join(decoded_string)"},{"question":"# Question You are given a Binary Search Tree (BST) and your task is to implement an iterator over its elements such that they can be iteratively accessed in ascending order. The iterator should be designed to utilize O(h) space, where h is the tree height. **Function to Implement:** ```python class BSTIterator: def __init__(self, root): Initialize the iterator with the root node of the BST. pass def has_next(self) -> bool: Returns True if there are further elements to visit in the BST, False otherwise. pass def next(self) -> int: Returns the next smallest element in the BST. pass ``` **Input and Output Formats:** * `__init__(root)`: Initializes the iterator with the root node of the BST. * `has_next() -> bool`: Returns True if there is a next smallest number available, otherwise False. * `next() -> int`: Returns the next smallest number in the BST. **Constraints:** * Nodes\' values are unique integers. * `next()` and `has_next()` should run in average O(1) time and use O(h) memory. **Scenario:** Imagine you have a large binary search tree that you need to process in sorted order, but due to memory constraints, you cannot afford to store all elements in an array. You need to design an iterator that will go through the BST in ascending order, retrieving one element at a time as needed. **Example:** ```plaintext Input: 7 / 3 15 / 9 20 Operations: BSTIterator iterator = new BSTIterator(root) iterator.next() // returns 3 iterator.next() // returns 7 iterator.has_next() // returns True iterator.next() // returns 9 iterator.has_next() // returns True iterator.next() // returns 15 iterator.has_next() // returns True iterator.next() // returns 20 iterator.has_next() // returns False ``` **Edge Cases to Consider:** * Empty tree (e.g., `root` is None). * Tree with only one node. * Trees where every node only has a left or right child.","solution":"class BSTIterator: def __init__(self, root): Initialize the iterator with the root node of the BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): # Add all elements to the stack from root to the leftmost leaf while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Returns True if there are further elements to visit in the BST, False otherwise. # If stack is empty, there are no more elements return len(self.stack) > 0 def next(self) -> int: Returns the next smallest element in the BST. # The topmost element of the stack will be the next smallest element topmost_node = self.stack.pop() # If the node has a right child, add the right child and all its leftmost children if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"**Context**: You have been hired to help develop a simple recommendation system for a small online retailer. This retailer assigns a feature vector to each product based on user reviews and other metrics. Each feature vector is stored in a dictionary where the key is the tuple representing the feature vector and the value is the product ID. Your job is to implement a function that recommends the product most similar to a given feature vector input. This recommendation system will use the nearest neighbor algorithm to find the closest matching product. **Task**: Implement the function `recommend_product` that takes in a feature vector and a dictionary of product feature vectors, and returns the product ID of the nearest neighbor. You may use the helper function `distance` provided below to compute the Euclidean distance between two vectors. **Input Format**: - A tuple `x` representing the feature vector to find the most similar product to. - A dictionary `feature_vectors` where keys are tuples representing the product feature vectors and values are product IDs (strings). **Output Format**: - A string representing the product ID of the nearest product. **Constraints**: - All vectors are of the same dimensionality. - The dictionary `feature_vectors` is not empty. **Function Signature**: ```python def recommend_product(x: tuple, feature_vectors: dict) -> str: pass # Helper function import math def distance(x, y): assert len(x) == len(y), \\"The vectors must have the same length\\" sum = 0 for i in range(len(x)): sum += (x[i] - y[i]) ** 2 return math.sqrt(sum) ``` **Example**: ```python feature_vectors = { (1.0, 2.0): \\"Product1\\", (2.5, 4.0): \\"Product2\\", (1.5, 1.8): \\"Product3\\" } x = (1.6, 2.1) print(recommend_product(x, feature_vectors)) # Expected Output: \\"Product3\\" ```","solution":"import math def distance(x, y): assert len(x) == len(y), \\"The vectors must have the same length\\" sum = 0 for i in range(len(x)): sum += (x[i] - y[i]) ** 2 return math.sqrt(sum) def recommend_product(x: tuple, feature_vectors: dict) -> str: min_distance = float(\'inf\') recommended_product = None for fv, product_id in feature_vectors.items(): d = distance(x, fv) if d < min_distance: min_distance = d recommended_product = product_id return recommended_product"},{"question":"# Subset Sum Problem Consider a variation of the subset generation problem where instead of generating all subsets, you only need to return subsets whose elements sum up to a given target value. Input: - A list of distinct integers `nums`. - An integer `target` representing the desired sum of elements of each returned subset. Output: - A list of all subsets of `nums` that sum up to `target`. Example: ```python nums = [2, 3, 5, 7] target = 7 ``` Expected output: ```python [ [2, 5], [7] ] ``` Constraints: - All elements in the input list `nums` are distinct. - The elements in a subset must be in non-decreasing order. - The solution should handle edge cases efficiently, such as an empty input list or no subsets summing up to the target. Requirements: 1. Implement a function `subset_sum(nums: List[int], target: int) -> List[List[int]]` that fulfills the problem requirements. 2. Ensure the function is designed to handle input sizes efficiently, given the exponential nature of subset generation. Hints: - Consider utilizing a backtracking approach similar to the one provided in the example but include additional logic to keep track of the sum of elements. - Use early termination in the recursion if the current sum exceeds the target to optimize performance.","solution":"from typing import List def subset_sum(nums: List[int], target: int) -> List[List[int]]: Returns all subsets of `nums` that sum up to `target`. def backtrack(start, current_subset, current_sum): if current_sum == target: result.append(list(current_subset)) return if current_sum > target: return for i in range(start, len(nums)): current_subset.append(nums[i]) backtrack(i + 1, current_subset, current_sum + nums[i]) current_subset.pop() result = [] nums.sort() backtrack(0, [], 0) return result"},{"question":"Task You are tasked with implementing a word dictionary that supports adding words and searching for words with the possibility of wildcard characters. The dictionary should be efficient in supporting both exact matches and pattern matches where the wildcard character \'.\' can be interpreted as any letter. Implementation Requirements - **Class**: `WordDictionary` - **Methods**: - `addWord(word: str) -> None`: To add a word to the dictionary. - `search(word: str) -> bool`: To search for a word in the dictionary. This word may contain \'.\' representing any letter. Input and Output Formats 1. **addWord()**: - **Input**: A non-empty string word containing only lowercase letters (1 <= word.length <= 500). - **Output**: None. 2. **search()**: - **Input**: A string word containing only lowercase letters and/or \'.\' characters, with length ranging from 1 to 500. - **Output**: A boolean value indicating if the word (or pattern) exists in the dictionary. Sample Usage ```python wordDictionary = WordDictionary() wordDictionary.addWord(\\"bad\\") wordDictionary.addWord(\\"dad\\") wordDictionary.addWord(\\"mad\\") print(wordDictionary.search(\\"pad\\")) # Output: False print(wordDictionary.search(\\"bad\\")) # Output: True print(wordDictionary.search(\\".ad\\")) # Output: True print(wordDictionary.search(\\"b..\\")) # Output: True ``` Constraints - Your solution should be optimized for both the addition and search operations. - Focus particularly on handling search patterns efficiently, including those with multiple wildcards. **Note**: Consider various edge cases such as searching for very short or very long patterns, and patterns with multiple consecutive wildcards.","solution":"class WordDictionary: def __init__(self): self.trie = {} def addWord(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = \'#\' def search(self, word: str) -> bool: return self._search_in_node(word, self.trie) def _search_in_node(self, word: str, node: dict) -> bool: for i, char in enumerate(word): if char == \'.\': for key in node: if key != \'#\' and self._search_in_node(word[i+1:], node[key]): return True return False if char not in node: return False node = node[char] return \'#\' in node"},{"question":"# Ternary Search Problem **Problem Description:** You are provided with a sorted array and a target value. Your task is to implement the ternary search algorithm, which will efficiently find the index of the target value in the array. If the target value is not present in the array, the algorithm should return -1. **Function Signature:** ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Find the given value (key) in an array sorted in ascending order. ``` **Input:** * `left` (int) - The starting index of the array segment currently being considered (initially 0). * `right` (int) - The ending index of the array segment currently being considered (initially len(arr) - 1). * `key` (int) - The target value you are searching for in the array. * `arr` (List[int]) - The sorted array in which the search will be conducted. **Output:** * Return the index (int) of the value if found, and -1 otherwise. **Constraints:** * The array `arr` will contain at most 10^6 elements. * All elements in the array and key will be integers between -10^9 and 10^9 (inclusive). **Performance Requirements:** * The solution must have a time complexity of O(log₃(N)) and a space complexity of O(1). **Example Scenario:** Consider an array `arr` containing [1, 4, 7, 9, 11, 13, 15, 18, 21, 25, 29, 33]. To find the key `13`, a ternary search would proceed as follows: 1. Select initial bounds [0, 11]. 2. Compute mid-points: mid1 = 3, mid2 = 7. 3. Check values at mid1 and mid2: arr[3] = 9, arr[7] = 18. 4. The key, 13, lies between mid1 and mid2. Update bounds to [4, 6]. 5. Recompute mid-points: mid1 = 5, mid2 = 6. 6. Check values at mid1 and mid2: arr[5] = 13. 7. The key is found at index 5, so return 5. **Edge Cases:** 1. When the array is empty. 2. When the target value is not within the min and max bounds of the array. 3. When the target value appears multiple times in the array. **Task:** Implement the ternary search algorithm in Python as described in the function signature. Ensure your solution handles edge cases effectively and adheres to the provided constraints and performance requirements.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Task You are given a binary array and need to determine the index at which a zero can be replaced with a one to form the longest contiguous subarray of ones. In the event that there are no zeros in the array, the function should return -1. # Function Signature ```python def max_ones_index(arr: List[int]) -> int: pass ``` # Input - `arr` (List[int]): A list of binary integers (0s and 1s). # Output - The function should return an integer representing the index of the zero that can be replaced to achieve the longest contiguous sequence of ones. If the array does not contain any zeros, return -1. # Constraints - The input array will have at least one element. - The input array will only contain binary values (0 and 1). # Examples 1. **Example 1:** - Input: `[1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]` - Output: `3` 2. **Example 2:** - Input: `[1, 1, 1, 1]` - Output: `-1` 3. **Example 3:** - Input: `[0, 0, 0, 0]` - Output: `0` (Any zero can be replaced since they are all the same) 4. **Example 4:** - Input: `[1, 0, 1, 0, 1]` - Output: `1` or `3` (Both result in segments of the same length) # Performance Requirements - The solution should have a time complexity of O(n) and space complexity of O(1).","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: max_len = 0 max_index = -1 last_zero_index = -1 current_start_index = 0 for i in range(len(arr)): if arr[i] == 0: current_len = i - current_start_index if current_len > max_len: max_len = current_len max_index = last_zero_index current_start_index = last_zero_index + 1 last_zero_index = i # Check the last segment current_len = len(arr) - current_start_index if current_len > max_len: max_index = last_zero_index return max_index"},{"question":"# Interpolation Search Extension **Context**: You\'ve learned about the efficient Interpolation Search algorithm suitable for uniformly distributed data. Now, you will implement an extended version of Interpolation Search that works even if the input array is not completely uniform. This version should default to linear search when entering a section of the array that does not seemingly conform to the uniform pattern. **Task**: Implement the function `efficient_search` that extends the interpolation search algorithm with the following additional conditions: 1. If the calculated position is outside the bounds of the current search interval, return -1. 2. If the array segment between `low` and `high` is not uniformly distributed based on a configurable threshold of uniformity deviation, revert to linear search in that segment. 3. The linear search should start from the `low` index to the `high` index only when the initially calculated position seems unreliable. **Input/Output**: ```python def efficient_search(array: List[int], search_key: int) -> int: :param array: The array to be searched, sorted in increasing order. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. Examples: >>> efficient_search([5, 10, 12, 14, 17, 20, 21], 14) 3 >>> efficient_search([5, 10, 12, 14, 17, 20, 21], 25) -1 >>> efficient_search([1, 1, 1, 1, 1, 1, 1], 1) 0 Constraints: - The input array is sorted in increasing order. - Consider handling array indices carefully to avoid out-of-bound errors. pass ``` **Constraints**: 1. The array will be sorted in non-decreasing order. 2. Try to ensure the space complexity does not exceed O(1). **Performance Requirements**: 1. The new `efficient_search` should perform efficiently on large arrays. 2. It should fall back to a linear search only when absolutely necessary based on a threshold condition to be evaluated. Note: You need not worry about handling non-integer values in the array. Focus on integer arrays only.","solution":"from typing import List def efficient_search(array: List[int], search_key: int) -> int: This function extends the interpolation search algorithm with fallback logic to a linear search in sections of the array that are not uniformly distributed. :param array: The array to be searched, sorted in increasing order. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. def is_uniform(segment: List[int], threshold: float) -> bool: Helper function to determine if a segment of the array is uniformly distributed based on threshold deviation. if len(segment) < 2: return True avg_diff = (segment[-1] - segment[0]) / (len(segment) - 1) for i in range(1, len(segment)): if abs(segment[i] - segment[i-1] - avg_diff) > threshold: return False return True threshold = 0.1 # Deviation threshold for the uniformity check low, high = 0, len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: if low == high: if array[low] == search_key: return low else: return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low]) if array[high] != array[low] else 0) if pos < low or pos > high: return -1 # If the position is out of array\'s bounds if array[pos] == search_key: return pos elif array[pos] < search_key: # Check if segment is uniform, otherwise revert to linear search if is_uniform(array[low:pos+1], threshold): low = pos + 1 else: for i in range(low, high + 1): if array[i] == search_key: return i return -1 else: # Check if segment is uniform, otherwise revert to linear search if is_uniform(array[pos:high+1], threshold): high = pos - 1 else: for i in range(low, high + 1): if array[i] == search_key: return i return -1 return -1"},{"question":"# Coding Challenge: Print Nested Tree Structure Scenario You have a dictionary representing a hierarchical structure of categories and subcategories. Each key is a category, and the value is a list of subcategories, which may include subcategory names or further nested categories. Your task is to write a function to print this dictionary in a structured, hierarchical format. Input A dictionary `tree` where each key is a string category and its associated value is a list containing: - Strings (subcategory names) - Dictionaries (representing further nested categories) Output Print the dictionary such that each key is followed by its subcategories, and nested subcategories are further indented to show the hierarchy. # Function Specifications - **Function Name:** `tree_print` - **Parameters:** * `tree` (dict): The hierarchical structure to be printed. - **Returns:** None. You only need to print the hierarchical structure. # Constraints 1. The tree dictionary will not contain circular references. 2. There will be at most 10 levels of nesting. 3. Each list associated with a key can have up to 20 elements. # Performance Your solution should efficiently handle the edge cases and should be able to print the structure with a clear indentation to represent deeper levels. # Example ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": { \\"Bill\\": [\\"Computer\\", 5, \\"TV\\", 6], \\"Jill\\": [\\"Sports\\", 1] }, \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": { \\"Adam\\": [\\"Computer\\", 3], \\"Quin\\": [\\"Computer\\", 3] }, \\"e\\": { \\"Quin\\": [\\"Book\\", 5, \\"TV\\", 2] }, \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } tree_print(tree) ``` Expected Output ``` a -> Adam -> Book -> 4 b Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d Adam -> Computer -> 3 Quin -> Computer -> 3 e Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Remember to maintain readability and handle various edge cases effectively.","solution":"def tree_print(tree, indent=0): Prints the hierarchical structure of a dictionary representing a tree. :param tree: dict, hierarchical structure of categories and subcategories :param indent: int, current indentation level for key, value in tree.items(): print(\' \' * indent + str(key)) if isinstance(value, dict): tree_print(value, indent + 2) else: if isinstance(value, list): for item in value: if isinstance(item, dict): tree_print(item, indent + 2) else: print(\' \' * (indent + 2) + str(item))"},{"question":"# Your Task You are given the root of a binary tree. Your task is to write a function that returns all the paths from the root to the leaf nodes in the form of strings where each string represents the path concatenated with \'->\' between node values. Function Signature ```python def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: pass ``` Input - The function takes a single argument: - `root` (Optional[TreeNode]): The root node of a binary tree. Output - The function should return a list of strings, where each string represents a unique path from the root to a leaf node. Constraints - The number of nodes in the tree can be up to (10^4). - The value of each node is between (-1000) and (1000). Performance Requirement - Your solution should have a time complexity of O(N) and space complexity of O(N), where N is the number of nodes in the tree. Example ```python # Example 1 # Input: # 1 # / # 2 3 # # 5 # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 # Input: # 3 # / # 9 # Output: [\\"3->9\\"] ``` # Constraints to Note - You should not use any libraries or functions that trivialize the problem (such as using `itertools` to generate permutations directly).","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def construct_paths(node, path): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' # extend the current path construct_paths(node.left, path) construct_paths(node.right, path) paths = [] construct_paths(root, \\"\\") return paths"},{"question":"# Question: Checking Sorted Order in a Linked List Problem Statement You are given a singly linked list. Your task is to determine if this linked list is sorted in non-decreasing (increasing) order. Function Signature ```python def is_sorted(head: ListNode) -> bool: pass ``` Input * A singly linked list\'s head node, `head`. Output * Return `True` if the list is sorted in non-decreasing order, `False` otherwise. Constraints * The linked list nodes contain integer values. * The linked list may be empty. * Do not assume the maximum size of the linked list but typical sizes are expected to fit into memory. Example ```plaintext Example 1: Input: head = 1 -> 2 -> 3 -> 4 Output: True Example 2: Input: head = 1 -> 2 -> 1 Output: False Example 3: Input: head = None Output: True ``` Explanation * In Example 1, the linked list is 1 -> 2 -> 3 -> 4, which is sorted in increasing order. Hence, the output is True. * In Example 2, the linked list is 1 -> 2 -> 1, which is not sorted because 2 > 1. Hence, the output is False. * In Example 3, the input is an empty list which is considered sorted by definition. Hence, the output is True.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_sorted(head: ListNode) -> bool: Determines if the singly linked list is sorted in non-decreasing order. :param head: ListNode, the head of the linked list :return: bool, True if the list is sorted in non-decreasing order, False otherwise # An empty list or a single element list is considered sorted if not head or not head.next: return True # Traverse the list and check if current node\'s value is greater than next node\'s value current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Coding Challenge: Optimized Bucket Sort with User-defined Constraints You are required to implement an optimized version of the bucket sort algorithm. The current implementation uses insertion sort for sorting individual buckets, which may not be efficient for large datasets. Your task is to replace the insertion sort with a more efficient sorting algorithm, and implement a more robust bucket index calculation to handle a wider range of input values. **Function Signature:** ```python def optimized_bucket_sort(arr: List[float]) -> List[float]: pass ``` # Input: - A list of floating-point numbers `arr` with `0 <= arr[i] < 1` for each `i`. # Output: - Return a list of `arr` sorted in ascending order. # Constraints: - Length of `arr` is between `0` and `10^5`. - You are not allowed to use built-in sorting functions for the complete array sorting. - Implement your bucket sort which utilises an efficient sorting algorithm for sorting individual buckets. # Performance Requirements: - Your implementation should aim for a time complexity close to O(n). # Edge Cases to Consider: 1. An empty array should return an empty array. 2. A single-element array should return the same single-element array. 3. Datasets with many repeated values. 4. Uniformly distributed values and clusters of very close values. # Example Input: ```python arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] ``` # Example Output: ```python [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] ``` Make sure your implementation efficiently handles large arrays and provides a more optimized solution compared to the traditional insertion sort based bucket sort.","solution":"from typing import List import math def optimized_bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] # Number of buckets n = len(arr) buckets = [[] for _ in range(n)] # Put elements into buckets for value in arr: index = math.floor(n * value) buckets[index].append(value) # Sort each bucket using Timsort (Python\'s built-in sort is Timsort which is efficient) sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"Scenario You are developing a feature for a text processing application that allows users to generate all possible unique abbreviations of a given word. This feature could be used in text compression or assisting with pattern recognition in words. Task Write a function `generate_abbreviations(word: str) -> List[str]` that generates all possible abbreviations of a given word. Function Signature ```python from typing import List def generate_abbreviations(word: str) -> List[str]: pass ``` Expected Input and Output - **Input**: A single string `word`. (1 <= len(word) <= 20) - **Output**: A list of strings representing all unique abbreviated forms of `word`. Constraints 1. Each character in the word can be either kept as is or abbreviated. 2. You need to include the count of abbreviated characters when compressing. Example ```python assert generate_abbreviations(\'word\') == [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` Performance Requirements The function should efficiently handle words up to the length of 20 with a consideration for both time and space complexity, given the constraints of exponential growth in possible abbreviations.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: result = [] def backtrack(index: int, current: str, count: int): if index == len(word): if count > 0: current += str(count) result.append(current) else: # Option 1: Abbreviate this character backtrack(index + 1, current, count + 1) # Option 2: Keep this character, abbreviate previous characters (if any) if count > 0: current += str(count) backtrack(index + 1, current + word[index], 0) backtrack(0, \\"\\", 0) return result"},{"question":"# Scenario You are given various performance metrics of a system over time, captured in arrays of numbers. To analyze the performance, you need to find the maximum metric in every sub-array of a fixed length `k`. # Task Write a function `max_sliding_window(arr: List[int], k: int) -> List[int]` that returns an array of the maximum values of each sub-array of length `k`. # Input - `arr`: A list of integers representing performance metrics. - `k`: An integer representing the size of the window. # Output - A list of integers representing the maximum values of each sub-array of length `k`. # Constraints - `1 <= len(arr) <= 10^5` - `0 <= arr[i] <= 10^9` - `1 <= k <= len(arr)` # Example ```python assert max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7] assert max_sliding_window([1], 1) == [1] assert max_sliding_window([9, 11, 8, 5, 7, 10], 2) == [11, 11, 8, 7, 10] assert max_sliding_window([4, 3, 2, 1], 1) == [4, 3, 2, 1] ```","solution":"from collections import deque from typing import List def max_sliding_window(arr: List[int], k: int) -> List[int]: Returns a list of the maximum values of each sub-array of length k. if not arr or k == 0: return [] dq = deque() max_values = [] for i in range(len(arr)): # Remove indices that are out of the current window if dq and dq[0] == i - k: dq.popleft() # Remove elements from the deque that are less than the current element while dq and arr[dq[-1]] < arr[i]: dq.pop() dq.append(i) # Start adding maximums to the result from the index k-1 if i >= k - 1: max_values.append(arr[dq[0]]) return max_values"},{"question":"# Print Hierarchical Tree Data Context You are given hierarchical data representing different people\'s interests and the number of items they own within those interests. This data is represented as a series of nested dictionaries. Your task is to implement a function that prints this data in a structured and readable format. Function Signature ```python def structured_tree_print(tree: dict) -> None: pass ``` # Input The input is a dictionary where: * The key is a string representing a person. * The value is a dictionary where: * The key is an interest (a string). * The value is either an integer or another dictionary representing sub-interests. # Output The output should be a printed hierarchical representation of the tree. For every person (root key), print their interests (sub-keys) indented, and if an interest has sub-interests, indent those further. Each leaf node (integer) should be printed at the corresponding indentation level. # Example Input Tree: ```python { \\"Adam\\": {\\"Book\\": 4, \\"Computer\\": 7}, \\"Bill\\": {\\"Computer\\": 5, \\"TV\\": 6, \\"Sports\\": {\\"Jill\\": 1}}, \\"Quin\\": {\\"Computer\\": 3, \\"Book\\": 5, \\"TV\\": 2} } ``` Expected Output: ``` Adam -> Book -> 4 -> Computer -> 7 Bill -> Computer -> 5 -> TV -> 6 -> Sports -> Jill -> 1 Quin -> Computer -> 3 -> Book -> 5 -> TV -> 2 ``` # Constraints * The depth of the tree will not exceed 10 levels. * The tree will always be a valid dictionary structure with string keys. * Leaf nodes will be positive integers. # Requirements * Write the function `structured_tree_print(tree: dict) -> None` * The function should handle arbitrary tree depths properly with correct indentation. * Ensure readability and usability for any hierarchical input data.","solution":"def structured_tree_print(tree: dict, indent: int = 0) -> None: for key, value in tree.items(): print(\\" \\" * indent + \\"-> \\" + str(key)) if isinstance(value, dict): structured_tree_print(value, indent + 2) else: print(\\" \\" * (indent + 2) + \\"-> \\" + str(value)) # Example usage if __name__ == \\"__main__\\": example_tree = { \\"Adam\\": {\\"Book\\": 4, \\"Computer\\": 7}, \\"Bill\\": {\\"Computer\\": 5, \\"TV\\": 6, \\"Sports\\": {\\"Jill\\": 1}}, \\"Quin\\": {\\"Computer\\": 3, \\"Book\\": 5, \\"TV\\": 2} } structured_tree_print(example_tree)"},{"question":"# Binary Search Extension Question Problem Description You have been provided with a sorted array of integers. Your task is to implement a function that finds the first occurrence of a given target value using binary search. If the target value is not present, the function should return `-1`. Objectives * Validate understanding of binary search. * Implement optimizations for handling duplicates. * Manage boundary conditions appropriately. Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: Find the first occurrence of the target value in a sorted array. Args: - array: List[int], a list of sorted integers (ascending order). - target: int, the value to search for. Returns: - The index of the first occurrence of the target, or -1 if the target is not in the array. pass ``` Input and Output * **Input**: * A list of sorted integers `array`. * An integer `target`. * **Output**: * The index of the first occurrence of `target` in `array`. * Return `-1` if `target` is not found. Example ```python assert find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert find_first_occurrence([1, 2, 3, 4, 5, 6, 7], 4) == 3 assert find_first_occurrence([1, 1, 1, 1, 1, 1, 1], 1) == 0 assert find_first_occurrence([1, 2, 3, 3, 3, 4, 5], 6) == -1 ``` Constraints * The length of `array` will be in the range [0, 10^5]. * The values of `target` will be in the range [-10^5, 10^5]. * Try to solve the problem with a time complexity of O(log n). Note Ensure that your solution efficiently handles edge cases, such as: * Empty array. * Target value not in the array. * Multiple occurrences of the target value.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: Find the first occurrence of the target value in a sorted array. Args: - array: List[int], a list of sorted integers (ascending order). - target: int, the value to search for. Returns: - The index of the first occurrence of the target, or -1 if the target is not in the array. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: # Check if it\'s the first occurrence if mid == 0 or array[mid - 1] != target: return mid # Otherwise keep looking to the left right = mid - 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Find Shortest Path in a Maze Using DFS Given a 2D grid representing a maze, find the length of the shortest path from the top-left cell to the bottom-right cell, where only cells with value `1` can be stepped on. If there\'s no possible path, return `-1`. The path cannot include the initial step from the top-left cell, the count starts from the first valid step. The traversal can move in four possible directions: left, right, up, or down. Input: * A 2D list `maze` containing integers `0` and `1`. - `1` represents a walkable cell. - `0` represents a blocked cell. Output: * An integer representing the length of the shortest path or `-1` if no such path exists. Function Signature: ```python def find_shortest_path(maze: List[List[int]]) -> int: ``` Constraints: * `1 <= len(maze), len(maze[0]) <= 100` Example: ```python maze1 = [ [1,0,1,1,1,1], [1,0,1,0,1,0], [1,0,1,0,1,1], [1,1,1,0,1,1] ] print(find_shortest_path(maze1)) # Output: 14 maze2 = [ [1,0,0], [0,1,1], [0,1,1] ] print(find_shortest_path(maze2)) # Output: -1 ``` When writing this function, consider: - Validating input to ensure it\'s within the given constraints. - Handling all possible edge cases, such as mazes with no walkable cells or single path mazes. - Efficiently managing recursion or using an iterative approach to avoid deep recursion depth.","solution":"from typing import List def find_shortest_path(maze: List[List[int]]) -> int: from collections import deque rows, cols = len(maze), len(maze[0]) if maze[0][0] == 0 or maze[rows-1][cols-1] == 0: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 1 queue = deque([(0, 0, 1)]) # (x, y, distance) maze[0][0] = 0 # mark as visited while queue: x, y, dist = queue.popleft() if x == rows - 1 and y == cols - 1: return dist - 1 for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): maze[nx][ny] = 0 # mark as visited queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Question: Problem Statement You are tasked with implementing a function named `solve_diophantine(a, b, c)` that takes three integers `a`, `b`, and `c` as inputs, and returns a tuple `(x, y, gcd)` such that `a * x + b * y = gcd` where `gcd` is the greatest common divisor of `a` and `b`. Additionally, ensure that `(x, y)` is one particular solution to the equation `a * x + b * y = c`. Input: - Three integers `a`, `b`, and `c` where `-10^9 ≤ a, b, c ≤ 10^9`. Output: - A tuple `(x, y, gcd)` where `x` and `y` are integers for which the given linear Diophantine equation has one particular solution. `gcd` is the greatest common divisor of `a` and `b`. Constraints: - Ensure that `a` and `b` are non-zero. - The value of `c` should be a multiple of `gcd` to ensure solutions exist. Performance Requirements: - Your algorithm should run in `O(log(min(a, b)))` time complexity and `O(1)` space complexity. # Example: ```python assert solve_diophantine(30, 20, 10) == (1, -1, 10) assert solve_diophantine(35, 15, 5) == (1, -2, 5) ``` # Hints: - Use the `extended_gcd` function to calculate the initial values. - Scale the solution appropriately to ensure `a * x + b * y = c`. Note: - Ensure to handle negative coefficients properly. - If `x` and `y` are not unique, provide one possible valid pair.","solution":"def extended_gcd(a, b): Apply the extended Euclidean algorithm to find x, y such that: a * x + b * y = gcd(a, b) Returns a tuple (gcd, x, y) where gcd is the greatest common divisor of a and b, and x, y are the coefficients such that a * x + b * y = gcd. if b == 0: return a, 1, 0 else: g, x1, y1 = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return g, x, y def solve_diophantine(a, b, c): Returns a tuple (x, y, gcd) such that a * x + b * y = gcd(a, b) and (x, y) is a particular solution to the equation a * x + b * y = c g, x, y = extended_gcd(abs(a), abs(b)) if c % g != 0: raise ValueError(\'No solution exists because c is not a multiple of gcd(a, b)\') x *= c // g y *= c // g if a < 0: x = -x if b < 0: y = -y return x, y, g"},{"question":"# Question: Given a binary array (an array containing only 0s and 1s), write a function `longest_ones_after_replacement(arr)` that returns the index of the 0 that, if replaced with a 1, will result in the longest contiguous sequence of 1s. If there are multiple possible indices, return any one of them. If there are no 0s in the array, return -1. Input: * `arr` - A list of integers where each element is either 0 or 1. Output: * An integer representing the index of the 0 that, when replaced with 1, results in the longest sequence of 1s. If no 0 is present, return -1. Constraints: * The length of the array will be between 1 and (10^5). Example: ```python # Example 1: arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] print(longest_ones_after_replacement(arr)) # Expected output: 3 # Example 2: arr = [1, 1, 1, 1, 1] print(longest_ones_after_replacement(arr)) # Expected output: -1 # Example 3: arr = [0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0] print(longest_ones_after_replacement(arr)) # Expected output: 5 (or another valid position) ``` You must implement the following function: ```python def longest_ones_after_replacement(arr): # your code here ```","solution":"def longest_ones_after_replacement(arr): Returns the index of the 0 that, if replaced with a 1, will result in the longest contiguous sequence of 1s. max_length = 0 best_index = -1 left = 0 zero_count = 0 for right in range(len(arr)): if arr[right] == 0: zero_count += 1 while zero_count > 1: if arr[left] == 0: zero_count -= 1 left += 1 if zero_count == 1: if (right - left + 1) > max_length: max_length = right - left + 1 best_index = arr.index(0, left, right + 1) if best_index == -1 and 0 in arr: best_index = arr.index(0) return best_index"},{"question":"# Context You are given functions that switch successive pairs of elements in a stack from the bottom to the top. If the number of elements in the stack is odd, the last element remains in place. The first function utilizes another stack as auxiliary storage whereas the second function uses a queue. # Task Implement a new function `optimized_switch_pairs(stack)`, which improves upon the provided implementations to: 1. Minimize time and space complexity where possible. 2. Handle edge cases correctly and efficiently. The function should take a list `stack` representing a stack with numbers and modify it by switching successive pairs of elements from the bottom. The modified stack should reflect the changes: - **Input**: A list of integers, where the list represents a stack with the end of the list being the top of the stack. - **Output**: The same list modified in-place. # Constraints 1. Do not use any additional data structures such as another stack or queue if possible, or minimize their use. 2. Ensure the function works efficiently for larger datasets of up to (10^5) elements. # Examples Example 1: Input: `[3, 8, 17, 9, 1, 10]` Output: `[8, 3, 9, 17, 10, 1]` Example 2: Input: `[3, 8, 17, 9, 1]` Output: `[8, 3, 9, 17, 1]` # Notes Tips for implementation: - Consider if iterating with two pointers might help in reducing auxiliary storage needs. - Ensure edge cases like empty stack and single element stack are handled correctly.","solution":"def optimized_switch_pairs(stack): Switch successive pairs of elements in the stack from the bottom to the top. Args: stack (list): List of integers where the end of the list is the top of the stack. Returns: None: Modifies the stack in-place. n = len(stack) # Iterate through the stack with step size of 2 for i in range(0, n - 1, 2): # Swap the pairs stack[i], stack[i + 1] = stack[i + 1], stack[i] # Example usage: # stack = [3, 8, 17, 9, 1, 10] # optimized_switch_pairs(stack) # print(stack) # Output should be [8, 3, 9, 17, 10, 1]"},{"question":"# Problem Description You are tasked with writing a function that filters words based on their ability to be typed using letters from only one row on an American keyboard. This exercise will test your understanding of set operations and efficient coding practices. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input * A list of strings, `words`, where each string represents a word. * (1 leq text{len(words)} leq 100) and (1 leq text{len(word)} leq 100). Output * Returns a list of strings containing words from the input that can be typed using letters from only one row on an American keyboard. Constraints * The words only contain alphabetic characters. * Case-insensitivity should be ensured. Example 1. **Example 1**: * Input: `[\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]` * Output: `[\\"Alaska\\", \\"Dad\\"]` 2. **Example 2**: * Input: `[\\"ABcD\\", \\"qWeRtY\\", \\"ZxCvbNm\\"]` * Output: `[\\"qWeRtY\\", \\"ZxCvbNm\\"]` Additional Details * All three keyboard rows are: * First row: `[\\"qwertyuiop\\"]` * Second row: `[\\"asdfghjkl\\"]` * Third row: `[\\"zxcvbnm\\"]` * Ensure your solution is efficient and can handle the upper limits of input size.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Define the sets for each keyboard row row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: # Convert word to lowercase to handle case insensitivity lower_word = set(word.lower()) # Check if the whole word fits into any of the keyboard rows if lower_word <= row1 or lower_word <= row2 or lower_word <= row3: result.append(word) return result"},{"question":"You are tasked with implementing a sorting function using Cycle Sort, a unique in-place sorting algorithm that minimizes the number of writes. Given an unsorted list of integers, your function should return the list sorted in ascending order. This function must use Cycle Sort to achieve the sorting. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. # Output - The function should return a list of integers sorted in ascending order. # Examples ```python assert cycle_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert cycle_sort([9, 5, 3, 3, 4]) == [3, 3, 4, 5, 9] assert cycle_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Constraints - The function must implement Cycle Sort. - Ensure that the function handles edge cases efficiently, including: - An already sorted array. - An array with duplicate values. - A large array within the input constraints. # Performance Requirements - The algorithm should operate with an average and worst-case time complexity of O(N^2). - The space complexity should remain O(1), utilizing in-place sorting. # Detailed Explanation You must implement the `cycle_sort` function. Here\'s a step-by-step breakdown: 1. Iterate through the array to identify cycles. 2. Within each cycle, determine the correct position of each element. 3. Swap elements to their correct positions, while ensuring minimal write operations. 4. Continue until the entire array is sorted. By doing so, you achieve a sorted array by making the minimum number of element swaps. Good luck!","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: writes = 0 # Loop through the array to find cycles to rotate for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Task You are tasked to enhance the implementation of the provided Separate Chaining Hash Table by adding a method to handle rehashing. This should maintain or improve performance as more elements are added to the hash table. # Context The existing implementation of the hash table provides basic operations but lacks the ability to dynamically resize. As the number of elements increases, the performance could degrade due to long linked lists in the overflow buckets. To mitigate this, implement a rehashing mechanism that doubles the table size when the load factor exceeds a given threshold. # Function Implementation Implement the method `rehash` in the `SeparateChainingHashTable` class to dynamically resize the table and redistribute the existing elements. Update the insertion method to automatically call `rehash` when necessary. # Expected Input and Output * **Input**: * Current hash table structure with its size and elements. * New element to be inserted that triggers the rehash operation. * **Output**: * Resized hash table with all elements correctly placed in their respective new buckets. * **Constraints**: * Use a load factor of 0.7 for triggering rehash. * Ensure no elements are lost during rehashing. * **Performance Requirements**: * Rehashing should be performed in O(n) time where n is the number of elements. # Provided Method to Implement Add the following methods to your class: ```python class SeparateChainingHashTable(object): # Existing methods... def rehash(self): Function to rehash the table when the load factor exceeds the threshold. # Implement this method. def put(self, key, value): Modify this method to call rehash when necessary. # Implement this modification. ``` # Example ```python # Insert elements to reach the load factor threshold table = SeparateChainingHashTable(size=5) table.put(\\"apple\\", 1) table.put(\\"banana\\", 2) table.put(\\"cherry\\", 3) table.put(\\"date\\", 4) table.put(\\"elderberry\\", 5) # At this point, rehashing should be triggered and all elements should be redistributed. assert table.size > 5 # Table size should be increased assert table.get(\\"cherry\\") == 3 # Ensure elements are correctly placed ```","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(size)] self.num_elements = 0 self.load_factor_threshold = 0.7 def hash_function(self, key): return hash(key) % self.size def rehash(self): Function to rehash the table when the load factor exceeds the threshold. old_table = self.table new_size = self.size * 2 self.table = [[] for _ in range(new_size)] self.size = new_size self.num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def put(self, key, value): Insert or update the value with the given key, and rehash if necessary. if (self.num_elements + 1) / self.size > self.load_factor_threshold: self.rehash() index = self.hash_function(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.num_elements += 1 def get(self, key): index = self.hash_function(key) bucket = self.table[index] for k, v in bucket: if k == key: return v return None def remove(self, key): index = self.hash_function(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.num_elements -= 1 return def __str__(self): return str(self.table)"},{"question":"# Climbing Stairs - Variation You are a professional rock climber and have devised a new way to climb a rock wall. Similar to a staircase, you can take 1 or 2 steps to progress each time. However, now the rock wall has some \\"jumping points\\" which let you take 3 steps at once. You want to find out the number of distinct ways you can reach the top of the rock wall, given the different step options. # Problem Statement Implement a function `rock_wall_climb(n: int) -> int` that calculates the number of distinct ways to reach the top of a rock wall of height `n`. Each time you can climb either 1 step, 2 steps, or use a jumping point to take 3 steps at once. * **Input Format**: A positive integer `n` representing the height of the rock wall. * **Output Format**: An integer representing the number of distinct ways to reach the top. # Constraints * `1 <= n <= 1000` # Example * Example 1: - **Input**: `rock_wall_climb(2)` - **Output**: `2` (There are 2 ways: (1,1) and (2)) * Example 2: - **Input**: `rock_wall_climb(3)` - **Output**: `4` (There are 4 ways: (1,1,1), (1,2), (2,1), (3)) * Example 3: - **Input**: `rock_wall_climb(4)` - **Output**: `7` (There are 7 ways: (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2), (1,3), (3,1)) # Performance Requirements * The function should run efficiently for large values of `n` (up to 1000). # Function Signature ```python def rock_wall_climb(n: int) -> int: # Your code here ``` # Notes * Explore using dynamic programming approaches to derive the number of ways effectively. * Consider edge cases where `n` is very small to ensure your base cases are correctly handled.","solution":"def rock_wall_climb(n: int) -> int: Returns the number of distinct ways to reach the top of a rock wall of height n using 1, 2, or 3 steps at a time. if n == 0: return 1 if n == 1: return 1 if n == 2: return 2 # Initialize ways to climb for the first three steps dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 # Use dynamic programming to fill in the array for i in range(3, n + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[n]"},{"question":"# Question: Preorder Traversal on Binary Search Tree with Constraints Check You are given a binary tree that represents a Binary Search Tree (BST). Write a function to perform a preorder traversal on this tree. Additionally, ensure that the tree maintains the BST property, where every node follows `left <= root < right`. Function Signature ```python def preorder_bst(root: Optional[Node]) -> List[int]: ``` Input * `root` (Node): The root of the BST. * The tree nodes contain integer values. * `Node` class structure is already defined: ```python class Node: This is a class of Node def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * List of integers representing the preorder traversal of the BST. Constraints * All node values are integers. * The number of nodes in the tree is at most `10^4`. Example ```python # Given BST: # 10 # / # 5 15 # / # 3 7 20 # Initially, calling the function as: root = Node(10, Node(5, Node(3), Node(7)), Node(15, None, Node(20))) print(preorder_bst(root)) # Output: [10, 5, 3, 7, 15, 20] ``` Explanation - The input tree is traversed in a root-left-right order, and the result is `[10, 5, 3, 7, 15, 20]`. - The output list must represent the correct preorder traversal of the BST.","solution":"from typing import Optional, List class Node: This is a class of Node def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_bst(root: Optional[Node]) -> List[int]: Function to perform a preorder traversal on a BST. if root is None: return [] # Preorder traversal is root, left, right result = [root.val] result.extend(preorder_bst(root.left)) result.extend(preorder_bst(root.right)) return result"},{"question":"You are tasked with implementing an optimized sorting algorithm suitable for an array where the elements are integers and may include negative numbers. Your implementation should ensure a linear time complexity when the range of numbers is not significantly larger than the number of elements. The algorithm should maintain the relative order of equal elements (stable sort). # Function Signature ```python def optimized_counting_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers, where `1 <= len(arr) <= 10^6`, and the elements can range from (-10^6) to (10^6). # Output * Returns a sorted list of integers. # Constraints * The function should sort the array with a time complexity of (O(n + k)), where (n) is the number of elements in the array and (k) is the range of the input elements. * You should efficiently handle negative integers. * The space complexity should remain within practical limits for the given constraints. # Example ```python # Example 1 arr = [-5, -10, 0, -3, 8, 5, -1, 10] print(optimized_counting_sort(arr)) # Output: [-10, -5, -3, -1, 0, 5, 8, 10] # Example 2 arr = [1, 4, 1, 2, 7, 5, 2] print(optimized_counting_sort(arr)) # Output: [1, 1, 2, 2, 4, 5, 7] ``` # Edge Cases to Consider * Arrays with all elements the same. * Arrays containing both positive and negative numbers. * Very large arrays with a small range of elements.","solution":"def optimized_counting_sort(arr): Performs a counting sort on an array of integers, including negative numbers, ensuring linear time complexity when the range of numbers is not significantly larger than the number of elements. if not arr: return [] # Finding the range of values in the array min_val = min(arr) max_val = max(arr) # The range of the numbers range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements # Initialize output (result) array output = [0] * len(arr) # Step 1: Store the count of each element for num in arr: count[num - min_val] += 1 # Step 2: Modify count array such that it now contains the actual position of this element in the output array for i in range(1, len(count)): count[i] += count[i - 1] # Step 3: Build the output array by placing elements at their correct positions # We go through the original array backwards to maintain stability for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Fibonacci Sequence Calculation: Advanced Methods Context: The Fibonacci sequence is a fundamental concept in both mathematics and computer science. It serves as an excellent example to explore different algorithmic approaches, such as recursion, iterative solutions, and dynamic programming. Your task involves implementing and enhancing these methods to improve performance and efficiency. In this coding assessment, you will be required to implement two functions: 1. A matrix exponentiation method to compute the n-th Fibonacci number in O(log n) time. 2. An optimized dynamic programming method that minimizes space complexity. Task: 1. **Matrix Exponentiation Method**: * Implement a function `fib_matrix(n)`. * This function should compute the n-th Fibonacci number using matrix exponentiation. * Expected time complexity: O(log n). * Expected space complexity: O(1) (not considering the recursion stack). * Handle input constraints: 0 ≤ n ≤ 10^18. 2. **Optimized Dynamic Programming Method**: * Implement a function `fib_optimized_dp(n)`. * This function should compute the n-th Fibonacci number using a dynamic programming approach that optimizes space usage. * Expected time complexity: O(n). * Expected space complexity: O(1). * Handle input constraints: 0 ≤ n ≤ 10^6. Input: * An integer `n` representing which Fibonacci number to compute. Output: * The n-th Fibonacci number. Function Signature: ```python def fib_matrix(n: int) -> int: pass def fib_optimized_dp(n: int) -> int: pass ``` Constraints: * ` 0 ≤ n ≤ 10^18` for `fib_matrix`. * ` 0 ≤ n ≤ 10^6` for `fib_optimized_dp`. Hint: For `fib_matrix`, use the property of matrix multiplication to achieve the reduction in time complexity.","solution":"def fib_matrix(n: int) -> int: if n == 0: return 0 if n == 1: return 1 def multiply_matrices(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_power(matrix, power): if power == 1: return matrix if power % 2 == 0: half_power = matrix_power(matrix, power // 2) return multiply_matrices(half_power, half_power) else: return multiply_matrices(matrix, matrix_power(matrix, power - 1)) F = [[1, 1], [1, 0]] result_matrix = matrix_power(F, n - 1) return result_matrix[0][0] def fib_optimized_dp(n: int) -> int: if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are required to extend the functionality of the `ZigZagIterator` class to support more than two lists. You need to create a new class `MultiZigZagIterator` that can handle a variable number of input lists and iterate over them in a zigzag fashion. # Function Signature The function signatures you need to implement are: - `def __init__(self, lists: List[List[int]]) -> None` - `def next(self) -> int` - `def has_next(self) -> bool` # Input - An array of `k` lists, `lists`, where each list contains integers. - Each list is independent and non-empty. # Output The output should come from calling methods: - `next()` which retrieves and returns the next element in the zigzag order. - `has_next()` which returns `True` if there are more elements to yield, otherwise `False`. # Constraints - The total number of integers across all lists will be at most `10^4`. - The number of lists `lists` will be at most `10^4`. - Each integer is in the range `-10^9` to `10^9`. # Example ```python lists = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ] iterator = MultiZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output would be: [1, 4, 6, 2, 5, 7, 3, 8, 9] ``` # Implementation Notes 1. Initialize the iterator with a variable number of input lists. 2. Ensure that `next` alternates between the lists effectively even as they become drained of elements. 3. After calling `next` until `has_next` returns `False`, `next` should eventually exhaust all lists in a zigzag manner. # Special Considerations - Consider performance in terms of time complexity, given the potentially large number of lists and elements. - Include edge cases such as all lists except one being empty or lists being the exact same length.","solution":"from typing import List import collections class MultiZigZagIterator: def __init__(self, lists: List[List[int]]) -> None: self.queue = collections.deque([(lst, 0) for lst in lists if lst]) self.total_elements = sum(len(lst) for lst in lists) self.num_elements_returned = 0 def next(self) -> int: if not self.has_next(): raise Exception(\\"No more elements\\") lst, index = self.queue.popleft() value = lst[index] if index + 1 < len(lst): self.queue.append((lst, index + 1)) self.num_elements_returned += 1 return value def has_next(self) -> bool: return self.num_elements_returned < self.total_elements"},{"question":"# Unique Number Finder Context: You are given an array containing `n` integers where every element appears exactly three times except for one, which appears exactly once. Your task is to find that single unique number. Task: Implement a function `find_unique_number(nums: List[int]) -> int` that finds and returns the unique integer. *Input*: - `nums`: A list of integers `[a1, a2, ..., an]` where (1 le n le 10^4) and every element in `nums` appears exactly three times except for one element which appears exactly once. *Output*: - Return the integer that appears exactly once. *Constraints*: - Your solution should have a linear runtime complexity O(n). - You should not use additional data structures like arrays, hash maps, etc., implying constant space usage O(1). Examples: Example 1: ```python nums = [2, 2, 3, 2] find_unique_number(nums) # Output: 3 ``` Example 2: ```python nums = [0, 1, 0, 1, 0, 1, 99] find_unique_number(nums) # Output: 99 ``` *Note:* Make sure your solution adheres to the constraints and optimally uses bit manipulation to solve the problem efficiently.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Finds and returns the single unique number in the list where each number except one appears exactly three times. ones, twos = 0, 0 for num in nums: # `ones` becomes those bits of `num` which have appeared once, except those bits which have now appeared twice. ones = (ones ^ num) & ~twos # `twos` becomes those bits of `num` which have appeared twice, except those bits which have now appeared in fours. twos = (twos ^ num) & ~ones return ones"},{"question":"# Context: You are a software developer working on a navigation system that needs to process graph data. The system needs to efficiently handle queries for finding paths between locations represented as nodes in a graph. # Problem Statement: Write an optimized function to find the shortest path between two nodes in an unweighted graph using an iterative approach to avoid deep recursion issues. The function should be more efficient than the given recursive solution. # Function Signature: ```python def find_optimized_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: pass ``` # Input: - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes. - `start`: An integer representing the starting node. - `end`: An integer representing the ending node. # Output: - A list of integers representing the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. # Constraints: - The graph is unweighted. - The graph is represented in an adjacency list format. - There are no negative cycles. - Consider the graph to be potentially large, so avoid deep recursion and inefficient methods. # Example: ```python graph = { 1: [2, 3], 2: [4, 5], 3: [5], 4: [6], 5: [6], 6: [] } start = 1 end = 6 assert find_optimized_shortest_path(graph, start, end) == [1, 3, 5, 6] ``` # Notes: - Focus on using an iterative approach (e.g., Breadth-First Search) which is well-suited for unweighted graphs to ensure optimized performance. - Handle any edge cases like disconnected nodes or isolated sections of the graph gracefully.","solution":"from collections import deque from typing import Dict, List def find_optimized_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]: if start == end: return [start] queue = deque([(start, [start])]) # stores tuples of (current_node, path_taken_to_current_node) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == end: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Question Given a directed graph implemented in Python using the provided Graph class, write a method to determine if a given node is a part of any Strongly Connected Component (SCC). This method should leverage the existing utility methods in the Graph class. Function Signature ```python def is_node_in_SCC(self, node: int) -> bool: pass ``` Input - `node (int)`: The index of the node to test, where 0 ≤ node < vertex_count. Output - Return `True` if the node is part of any SCC, otherwise return `False`. Example ```python graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(3, 4) # Node 0 is part of an SCC containing [0, 1, 2] # Node 3 is not in any SCC (4 does not connect back to 3) print(graph.is_node_in_SCC(0)) # Output: True print(graph.is_node_in_SCC(3)) # Output: False ``` Constraints - The graph will not have more than (10^4) vertices. - There will be no negative edge weights. - Node indices are zero-based. Notes - Leverage the existing Graph class methods such as `dfs`, `reverse_graph`, and `is_strongly_connected`. - Ensure to handle edge cases such as empty graphs, single vertex, and disconnected components.","solution":"class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] def add_edge(self, u, v): self.adj_list[u].append(v) def dfs(self, v, visited, stack=None): visited[v] = True for neighbour in self.adj_list[v]: if not visited[neighbour]: self.dfs(neighbour, visited, stack) if stack is not None: stack.append(v) def reverse_graph(self): reversed_graph = Graph(self.vertex_count) for v in range(self.vertex_count): for neighbour in self.adj_list[v]: reversed_graph.add_edge(neighbour, v) return reversed_graph def get_sccs(self): stack = [] visited = [False] * self.vertex_count for i in range(self.vertex_count): if not visited[i]: self.dfs(i, visited, stack) reversed_graph = self.reverse_graph() visited = [False] * self.vertex_count sccs = [] while stack: node = stack.pop() if not visited[node]: scc = [] reversed_graph.dfs(node, visited, scc) sccs.append(scc) return sccs def is_node_in_SCC(self, node): sccs = self.get_sccs() for scc in sccs: if node in scc and len(scc) > 1: # Ensure SCC has more than 1 node to be strongly connected return True return False"},{"question":"# Question: Array Rotation Problem Statement Given an array of integers, rotate the array to the right by `k` steps. Do this in-place using O(1) extra space. The rotation should be performed as efficiently as possible. Function Signature ```python def rotate_array(nums: List[int], k: int) -> None: # Your implementation here ``` Input * `nums`: A list of integers where (0 leq text{len(nums)} leq 10^5) * `k`: A non-negative integer value where (0 leq k leq 10^5) Output * The function should not return anything. The array should be modified in-place. Constraints * You must perform the rotation in-place with O(1) extra space. * The time complexity of your solution should be O(n). Example ```python >>> nums = [1, 2, 3, 4, 5, 6, 7] >>> k = 3 >>> rotate_array(nums, k) >>> print(nums) [5, 6, 7, 1, 2, 3, 4] >>> nums = [-1, -100, 3, 99] >>> k = 2 >>> rotate_array(nums, k) >>> print(nums) [3, 99, -1, -100] ``` Explanation 1. The first example rotates [1, 2, 3, 4, 5, 6, 7] to the right by 3 steps to get [5, 6, 7, 1, 2, 3, 4]. 2. The second example rotates [-1, -100, 3, 99] to the right by 2 steps to get [3, 99, -1, -100]. Hints * Think about how reversing only parts of the array might help you accomplish the right shift. * Ensure your solution handles the edge cases efficiently, especially when `k` is larger than the length of the array.","solution":"def rotate_array(nums, k): Rotates the array nums to the right by k steps in-place. n = len(nums) if n == 0 or k % n == 0: return k = k % n def reverse(start, end): while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 reverse(0, n - 1) reverse(0, k - 1) reverse(k, n - 1)"},{"question":"# Question: Remove Duplicates from a Singly Linked List Problem Statement Given the head of a singly linked list, write a function to remove all duplicate values from the list. You should implement two versions of the function: one that uses additional data structures (a set) and one that does not. Requirements 1. First function: `remove_dups(head)`. * **Input**: Head node of a singly linked list. * **Output**: The list should be modified in-place to remove duplicates. * **Complexity Requirements**: O(N) time complexity, O(N) space complexity. 2. Second function: `remove_dups_without_set(head)`. * **Input**: Head node of a singly linked list. * **Output**: The list should be modified in-place to remove duplicates. * **Complexity Requirements**: O(N^2) time complexity, O(1) space complexity. Example ```python # Linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) print_linked_list(a1) # Output: A -> B -> C -> D -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups_without_set(a1) print_linked_list(a1) # Output: A -> B -> C -> D -> F -> G ``` Constraints * Node values are always non-null and can be any hashable object. * The list can be empty. * Duplicates can appear anywhere in the list.","solution":"class Node: def __init__(self, val=None, next=None): self.val = val self.next = next def remove_dups(head): Remove duplicates using a set for O(N) space complexity if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head): Remove duplicates without using additional data structures if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head def print_linked_list(head): Helper function to print the linked list result = [] current = head while current: result.append(current.val) current = current.next return \' -> \'.join(result)"},{"question":"# ZigZag Iterator for Multiple Lists You are given multiple lists of integers. Implement a ZigZag Iterator that alternates between the elements of these lists. When one list gets exhausted, continue with the remaining elements from the non-exhausted lists. **Function Signature**: ```python class ZigZagIterator: def __init__(self, *lists: List[int]): Initialize your data structure here. :type lists: List[int] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` **Input Format**: * The constructor `__init__` receives an arbitrary number of lists of integers. * The `next` method returns the next integer in zigzag order. * The `has_next` method returns `True` if there are still elements to return and `False` otherwise. **Example**: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIterator(l1, l2, l3) output = [] while it.has_next(): output.append(it.next()) print(output) # Expected output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` **Constraints**: * The total number of elements in all lists combined does not exceed 10000. * All elements are integers. Ensure that your implementation can handle an arbitrary number of lists with an unknown number of elements in each list. Optimize your solution to avoid unnecessary operations.","solution":"from typing import List class ZigZagIterator: def __init__(self, *lists: List[int]): Initialize the data structure with multiple lists. self.queue = [] for i, lst in enumerate(lists): if lst: self.queue.append((i, lst)) def next(self) -> int: Return the next element in zigzag order. if not self.queue: raise Exception(\\"No more elements to return.\\") i, lst = self.queue.pop(0) value = lst.pop(0) if lst: self.queue.append((i, lst)) return value def has_next(self) -> bool: Return True if there are still elements to return, False otherwise. return len(self.queue) > 0"},{"question":"Design an Optimized Circular Array Queue **Context:** You are to implement an optimized version of the `ArrayQueue` provided using a circular array to prevent frequent resizing operations when the array reaches capacity. This will enhance the performance of the queue, making it more efficient for use in high-performance scenarios such as I/O buffering or task scheduling. **Requirements:** 1. **enqueue(item)**: Adds an item to the queue. Automatically expands the array if it is at full capacity by doubling its size. 2. **dequeue()**: Removes and returns the front item from the queue. If the queue is empty, an `IndexError` should be raised. 3. **peek()**: Returns the front item without removing it. Raises an `IndexError` if the queue is empty. 4. **is_empty()**: Returns `True` if the queue is empty, `False` otherwise. 5. **size()**: Returns the number of items in the queue. 6. **__iter__()**: Provides an iterator to traverse through the queue elements in FIFO order. **Input Format:** - The methods will be called on an instance of the `CircularArrayQueue` class. - Method parameters and return types as specified in the descriptions above. **Constraints:** - You are not allowed to use Python\'s built-in `list` dynamic resizing behavior. - Simulate a circular array by managing front and rear indices correctly. **Example:** ```python cq = CircularArrayQueue(capacity=3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) assert cq.dequeue() == 1 assert cq.peek() == 2 cq.enqueue(4) assert len(cq) == 3 assert list(cq) == [2, 3, 4] ``` **Implementation Prompt:** ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): Initialize the circular array queue with the given capacity super().__init__() self._array = [None] * capacity self._front = 0 self._rear = 0 def enqueue(self, value): Add an item to the queue raise NotImplementedError def dequeue(self): Remove and return the front item from the queue raise NotImplementedError def peek(self): Get the front item without removing it raise NotImplementedError def __iter__(self): probe = self._front count = 0 while count < self._size: yield self._array[probe] probe = (probe + 1) % len(self._array) count += 1 ``` **Note:** Make sure to handle the wrapping around the end of the array correctly to avoid index errors and to maintain the circular nature.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self._array = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 def enqueue(self, item): if self._size == len(self._array): # Full capacity, resize new_capacity = len(self._array) * 2 new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[(self._front + i) % len(self._array)] self._array = new_array self._front = 0 self._rear = self._size self._array[self._rear] = item self._rear = (self._rear + 1) % len(self._array) self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") item = self._array[self._front] self._array[self._front] = None # Clear the slot self._front = (self._front + 1) % len(self._array) self._size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self._array[self._front] def is_empty(self): return self._size == 0 def size(self): return self._size def __iter__(self): probe = self._front count = 0 while count < self._size: yield self._array[probe] probe = (probe + 1) % len(self._array) count += 1 def __len__(self): return self._size"},{"question":"# Question: **Objective:** Implement the Cycle Sort algorithm with attention to edge cases and correct placements. # Problem Statement: **Context:** You have been hired by a tech company to optimize sort routines for their embedded systems. Given the constraints on memory writes for Flash storage, you are looking to implement a sorting mechanism that minimizes write operations. Cycle Sort is an ideal candidate for this challenge. **Task:** Write a function `cycle_sort(arr)` that takes a list of integers `arr` and sorts the list in-place using the Cycle Sort algorithm. **Input Format:** * A list `arr` of integers where 1 <= len(arr) <= 10^5 and elements are in the range 1 <= arr[i] <= 10^6. **Output Format:** * Return the sorted list `arr` after performing the Cycle Sort. **Constraints:** * Optimize for fewer write operations. * Handle edge cases such as arrays with duplicate elements and ensure correctness. **Function Signature:** ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` # Example: Example 1: * Input: [3, 1, 2, 5, 4] * Output: [1, 2, 3, 4, 5] Example 2: * Input: [4, 2, 2, 8, 3, 3, 1] * Output: [1, 2, 2, 3, 3, 4, 8] # Additional Notes: * Ensure that your function runs efficiently within given constraints. Extra attention should be given to minimizing write operations.","solution":"def cycle_sort(arr): Applies the Cycle Sort algorithm to sort the list in-place with minimal writes. n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Problem Context You are working on a mathematics library for calculating combinatorial values. One important function you need to implement is for computing the binomial coefficient, also known as \\"n choose k\\", which represents the number of ways to choose k elements from a set of n elements. Objective: Implement an optimized recursive function to compute the binomial coefficient C(n, k) efficiently. Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k). :param n: Non-negative integer, represents the number of elements in the set. :param k: Non-negative integer, represents the number of elements to choose. :return: The binomial coefficient C(n, k). :raises ValueError: If n < k. pass ``` Input and Output * The function will take two integer inputs, n and k, where ( n geq k geq 0 ). * The function returns an integer representing the binomial coefficient ( C(n, k) ). Constraints * ( 0 leq k leq n leq 1000 ) * Handle large integers efficiently. Example ```python binomial_coefficient(5, 0) # returns 1 binomial_coefficient(8, 2) # returns 28 binomial_coefficient(500, 300) # returns the result for such large values ``` Performance Requirements * Your implementation should be efficient regarding both time and space complexity. * Consider using memoization for optimizing the recursion.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k). :param n: Non-negative integer, represents the number of elements in the set. :param k: Non-negative integer, represents the number of elements to choose. :return: The binomial coefficient C(n, k). :raises ValueError: If n < k. if k < 0 or n < k: raise ValueError(\\"Invalid values for n and k. Ensure that 0 <= k <= n.\\") # Memoization to store previously calculated values memo = [[-1 for _ in range(k+1)] for _ in range(n+1)] def _binomial_coeff(n, k): if k == 0 or k == n: return 1 if memo[n][k] != -1: return memo[n][k] memo[n][k] = _binomial_coeff(n-1, k-1) + _binomial_coeff(n-1, k) return memo[n][k] return _binomial_coeff(n, k)"},{"question":"Scenario: You are working at a robotic startup, where you\'ve been tasked to program a robot that has to reach the top of a staircase. The robot can either take one step or two steps at a time. The robot operates in real-time, meaning you need to ensure that the computation is both time-efficient and space-efficient. Task: Implement a function that calculates the number of distinct ways the robot can reach the top of the staircase given a certain number of steps `n`. Function Signature: ```python def robot_climb_ways(n: int) -> int: :param n: Number of steps to reach the top (positive integer). :return: Number of distinct ways to reach the top. ``` Input: - `n`: A positive integer representing the number of steps to reach the top. Output: - Return an integer representing the number of distinct ways to reach the top of the staircase. Constraints: - Ensure your solution optimizes for space and time. - Handle cases where `n` is very large up to 10,000. Performance Requirements: - Time Complexity: O(n) - Space Complexity: O(1) Examples: 1. `robot_climb_ways(2)` should return `2` 2. `robot_climb_ways(3)` should return `3` 3. `robot_climb_ways(4)` should return `5` These examples show the problem\'s typical behavior where small values of `n` yield rapidly increasing numbers of combinations due to the robot having two choices at each step.","solution":"def robot_climb_ways(n: int) -> int: Returns the number of distinct ways the robot can reach the top of a staircase with n steps. :param n: Number of steps to reach the top (positive integer). :return: Number of distinct ways to reach the top. if n <= 1: return 1 one_step_before = 1 two_steps_before = 1 all_ways = 0 for i in range(2, n+1): all_ways = one_step_before + two_steps_before two_steps_before = one_step_before one_step_before = all_ways return all_ways"},{"question":"# Coding Challenge: Implement a Stable In-Place Sorting Algorithm You are required to write a function that takes a list of integers and sorts it using Gnome Sort, a simple and efficient sorting algorithm for small or nearly sorted datasets. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers to be sorted. Output - The function should return a list of integers sorted in non-decreasing order. Example ```python assert gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort([]) == [] ``` Constraints 1. Do not use any built-in sorting functions. 2. Your implementation should maintain the relative order of elements with equal keys (stable sort). 3. The solution must sort the array in place, i.e., without using additional space than needed for a constant number of variables. Performance Although Gnome Sort is not the most efficient for large datasets, it is important to write clean, correct, and maintainable code. Scenario You are tasked with sorting a small array of integers which may be nearly sorted. The Gnome Sort algorithm is chosen to demonstrate the importance of algorithm selection based on dataset characteristics. Despite its quadratic time complexity in the worst case, Gnome Sort can be surprisingly efficient for specific input scenarios. Implement the `gnome_sort` function as specified to validate your understanding of sorting algorithms and their applications.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Gnome Sort algorithm. Gnome Sort is a simple sorting algorithm inspired by the way a garden gnome sorts a line of flower pots. The gnome looks at the current pot and the previous one; if they are in the right order he steps forward, otherwise he swaps them and steps backward. Args: arr: A list of integers to be sorted. Returns: A list of integers sorted in non-decreasing order. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"**Problem Statement**: You are given two sorted singly linked lists. Your task is to merge these two linked lists into one sorted linked list and return the head of the newly formed list. You should implement both iterative and recursive methods for merging these lists. Your functions should adhere to the following specifications: # Function Definitions: 1. `merge_two_lists_iterative(l1: Node, l2: Node) -> Node` 2. `merge_two_lists_recursive(l1: Node, l2: Node) -> Node` # Input: - `l1` and `l2`: The heads of the two sorted linked lists. # Output: - The head of the merged sorted linked list. # Constraints: - The lists may have different lengths. - The lists are sorted in non-decreasing order. - Either `l1` or `l2`, or both can be empty. # Example: ``` Input: l1: 1 -> 2 -> 4 l2: 1 -> 3 -> 4 Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Implementation Requirements: - Pay attention to edge cases such as one or both input lists being empty. - Optimize for time complexity O(n + m) and handle memory efficiently. - Clearly separate iterative and recursive implementations. Write both `merge_two_lists_iterative` and `merge_two_lists_recursive` functions which meet the above specifications.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists_iterative(l1: Node, l2: Node) -> Node: dummy = Node() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 if l2: current.next = l2 return dummy.next def merge_two_lists_recursive(l1: Node, l2: Node) -> Node: if not l1: return l2 if not l2: return l1 if l1.val < l2.val: l1.next = merge_two_lists_recursive(l1.next, l2) return l1 else: l2.next = merge_two_lists_recursive(l1, l2.next) return l2"},{"question":"Binary Tree Level Order Traversal You are given a Binary Tree and you need to write a function that performs a level order traversal of this tree. The level order traversal is also known as Breadth-First Search (BFS) for a tree and visits nodes level by level from left to right. Function Signature ```python def level_order_traversal(root: Node) -> List[List[int]]: pass ``` # Input * `root`: A `Node` object which is the root of the binary tree. # Output * A list of lists, where each list contains the values of the nodes on that level from left to right. # Constraints * The number of nodes in the tree will be in the range [0, 10^4]. * Node values are integers that can be positive, negative, or zero. # Example ```python n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 assert level_order_traversal(n1) == [[1], [2, 3], [4, 5]] ``` # Requirements * Your solution should handle trees with multiple levels efficiently. * Aim for optimal performance in terms of time and space complexity (Hint: O(n) time and O(n) space). * Consider and handle edge cases such as empty trees. # Notes * Make sure to manage memory efficiently and effectively. * Pay attention to providing detailed comments within your code to explain your logic.","solution":"from typing import List, Optional from collections import deque class Node: def __init__(self, value: int, left: Optional[\\"Node\\"] = None, right: Optional[\\"Node\\"] = None): self.value = value self.left = left self.right = right def level_order_traversal(root: Optional[Node]) -> List[List[int]]: Perform level order traversal (breadth-first) on a binary tree, returning a list of lists where each sublist contains values for one level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Bipartite Graph Checker **Context**: In your work as a network analyst, you often need to determine if the network structure (modeled as a graph) can be colored using two colors such that no two adjacent nodes (vertices) share the same color. This property is crucial for certain matchmaking and scheduling applications. **Task**: Write a function `is_bipartite_graph` that determines if the given undirected graph is bipartite. **Function Signature**: ```python def is_bipartite_graph(num_vertices: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Input * `num_vertices` (int): The number of vertices in the graph, labeled from 0 to `num_vertices - 1`. * `edges` (List[Tuple[int, int]]): The list of edges in the graph, where `edges[i] = (u, v)` represents an undirected edge between vertices `u` and `v`. # Output * Returns `True` if the graph is bipartite, otherwise `False`. # Constraints * (1 leq text{num_vertices} leq 10^5) * (0 leq u, v < text{num_vertices}) * There are no duplicate edges in the input. # Example ```python # Example 1: num_vertices = 4 edges = [(0, 1), (0, 3), (1, 2), (2, 3)] assert is_bipartite_graph(num_vertices, edges) == True # Example 2: num_vertices = 3 edges = [(0, 1), (1, 2), (2, 0)] assert is_bipartite_graph(num_vertices, edges) == False ``` # Explanation * In **Example 1**, the graph can be divided into two sets: {0, 2} and {1, 3}, thus the function should return `True`. * In **Example 2**, the presence of a cycle of odd length (3 vertices all connected) prevents the graph from being bipartite, thus the function should return `False`. **Additional Considerations**: * Ensure your solution works efficiently within the given constraints. * Consider edge cases such as disconnected graphs or graphs with no edges.","solution":"from typing import List, Tuple from collections import deque def is_bipartite_graph(num_vertices: int, edges: List[Tuple[int, int]]) -> bool: Determines if the given undirected graph is bipartite. # Create adjacency list graph = [[] for _ in range(num_vertices)] for u, v in edges: graph[u].append(v) graph[v].append(u) # Initialize color array with -1 (indicating uncolored) color = [-1] * num_vertices # Function to perform BFS def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Check all components of the graph for v in range(num_vertices): if color[v] == -1: if not bfs(v): return False return True"},{"question":"# Graph Connectivity Check Problem Description Given a graph represented as an adjacency list, write functions that utilize Depth-First Search (DFS) and Breadth-First Search (BFS) to determine if the graph is fully connected. A graph is considered fully connected if there is a path between any two nodes in the graph. Function Signature ```python def is_connected_dfs(graph: dict) -> bool: pass def is_connected_bfs(graph: dict) -> bool: pass ``` Input * `graph`: A dictionary where the keys are node identifiers (integers or strings) and the values are lists of nodes representing edges. Output * Return a boolean `True` if the graph is fully connected, otherwise return `False`. Constraints * The graph may contain up to `10^3` nodes. * Graph may be directed or undirected. Example ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\', \'D\'], \'D\': [\'B\', \'C\'] } # The graph is fully connected. assert is_connected_dfs(graph1) == True assert is_connected_bfs(graph1) == True graph2 = { \'A\': [\'B\'], \'B\': [\'A\'], \'C\': [\'D\'], \'D\': [\'C\'] } # The graph is not fully connected. assert is_connected_dfs(graph2) == False assert is_connected_bfs(graph2) == False ``` # Guidelines * Consider the graph to be undirected even if the input might not explicitly show bidirectional edges. * Ensure that disconnected graphs are handled correctly by checking if all nodes are visited starting from any node. * Optimize graph search to handle larger graphs efficiently within given constraints.","solution":"def is_connected_dfs(graph: dict) -> bool: Determine if the graph is fully connected using DFS. def dfs(node, visited): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(graph[current]) if not graph: return True visited = set() nodes = list(graph.keys()) dfs(nodes[0], visited) return len(visited) == len(nodes) def is_connected_bfs(graph: dict) -> bool: Determine if the graph is fully connected using BFS. from collections import deque def bfs(node, visited): queue = deque([node]) while queue: current = queue.popleft() if current not in visited: visited.add(current) queue.extend(graph[current]) if not graph: return True visited = set() nodes = list(graph.keys()) bfs(nodes[0], visited) return len(visited) == len(nodes)"},{"question":"# Minimum Delete Operation for Equalizing Strings **Context**: Suppose you are building a text comparison tool that needs to determine how similar two given words are. One measure of similarity is to find out the minimum number of deletion operations required to make the two words identical. Implement the following function to accomplish this: **Function Signature**: ```python def min_distance(word1: str, word2: str) -> int: Given two words word1 and word2, return the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. ``` **Input Format**: - `word1`: A string consisting of lower-case English letters, with length `m`. - `word2`: A string consisting of lower-case English letters, with length `n`. **Output Format**: - Returns an integer representing the minimum number of steps required to make `word1` and `word2` identical. **Constraints**: - The lengths of `word1` and `word2` range from 0 to 500 (i.e., 0 <= m, n <= 500). **Examples**: ```python # Example 1 word1 = \\"sea\\" word2 = \\"eat\\" print(min_distance(word1, word2)) # Output: 2 # Example 2 word1 = \\"leetcode\\" word2 = \\"etco\\" print(min_distance(word1, word2)) # Output: 4 ``` **Performance Requirement**: The implemented function should have a time complexity of O(m * n) and a space complexity of O(m * n), with possible optimizations discussed in the analysis. **Additional Notes**: - Be mindful of edge cases, such as empty strings. - Efficiency in both time and space will be critical for handling the upper bounds of input sizes.","solution":"def min_distance(word1: str, word2: str) -> int: Given two words word1 and word2, return the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. m = len(word1) n = len(word2) # Create a DP table where dp[i][j] represents the minimum number of deletions # needed to make word1[0:i] and word2[0:j] the same. dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize DP table for i in range(m + 1): dp[i][0] = i # Deleting all characters from word1 to match empty word2 for j in range(n + 1): dp[0][j] = j # Deleting all characters from word2 to match empty word1 # Compute the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) # The answer will be in dp[m][n] return dp[m][n]"},{"question":"# FizzBuzz Enhanced: Fizz, Buzz, and Extensions **Problem Statement**: Write a function that takes two parameters, `n` and `rules`. The function should return an array from 1 to `n`, applying transformations based on the provided rules. Each rule is a tuple containing a string and a corresponding divisor. If a number is divisible by more than one divisor, concatenate the corresponding strings in the order they were provided in the rule list. **Example**: Given `rules = [(\\"Fizz\\", 3), (\\"Buzz\\", 5), (\\"Bazz\\", 7)]` and `n = 15`, the function should return: ``` [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', \'Bazz\', 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, \'Bazz\', \'FizzBuzz\'] ``` **Function Signature**: ```python def enhanced_fizzbuzz(n: int, rules: list) -> list: pass ``` **Constraints**: * `n` will always be a positive integer (greater than or equal to 1). * `rules` is a list of tuples, where each tuple contains a string and a positive integer divisor. **Detailed Requirements**: 1. **Input**: * An integer `n` (>=1). * A list `rules` of tuples with each tuple containing a string and a positive integer ([(str, int), ...]). 2. **Output**: * A list of length `n` where numbers are replaced based on the rules provided. 3. **Transformations**: * If the number `i` is divisible by a divisor in the rules, replace it with the corresponding string from the tuple. * If the number `i` is divisible by multiple divisors, concatenate the corresponding strings. **Example Scenarios**: * `enhanced_fizzbuzz(3, [(\\"Hi\\", 2)])` should return `[1, \\"Hi\\", 3]`. * `enhanced_fizzbuzz(5, [(\\"X\\", 2), (\\"Y\\", 3)])` should return `[1, \\"X\\", \\"Y\\", \\"X\\", 5]`.","solution":"def enhanced_fizzbuzz(n: int, rules: list) -> list: Generates a list of numbers from 1 to n with transformations based on rules. Args: n (int): The upper limit of the list, inclusive. rules (list): A list of tuples with each tuple containing a string and a positive integer divisor. Returns: list: A list of length n with numbers replaced based on the rules. result = [] for i in range(1, n + 1): transformed = \\"\\" for word, divisor in rules: if i % divisor == 0: transformed += word result.append(transformed or i) return result"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Validation algorithm. * **Complexity**: * Time Complexity: O(n), where n is the length of the string, due to parsing and validation processes. * Space Complexity: O(1), since only a few variables are used for storage. * **Principles**: * Parse the input string. * Validate each part (latitude and longitude) separately. * Check the format using general parsing and regular expressions. # Characteristics & Applications * **Properties**: Ensures that input strings conform to the format rules of geographical coordinates. * **Common Use Cases**: * Validating user input for geographical points in applications involving maps. * Preprocessing data for systems that manage spatial data like GPS tracking. * **Strengths/Limitations**: * Strengths: * Clearly specifies rules and constraints for input validation. * Can be implemented in multiple ways, providing flexibility. * Limitations: * Regular expression might become hard to maintain. * Parsing methods can be less reliable if input strings deviate from expected patterns. # Implementation Challenges * **Edge Cases**: * Invalid characters in the input string. * Incorrect placements of commas, spaces, or digits. * **Performance Bottlenecks**: Not significant in this context due to limited input size. However, excessive function calls for parsing can lead to slight inefficiencies. * **Error Scenarios**: * Input does not split correctly. * One of the parts cannot be converted to a float. * Numbers exceeding the allowed latitude and longitude ranges. * **Optimization Points**: * Utilize regular expressions for a concise validation process. * Avoid multiple traversals of the input string. <|Analysis End|> <|Question Begin|> # Coding Assessment Question: **Geographical Coordinates Validator** You are tasked with developing a function that validates if given parameters are valid geographical coordinates. The coordinates should be in the format `\\"latitude, longitude\\"` and adhere to specific rules: 1. Latitude must be a float between -90 and 90. 2. Longitude must be a float between -180 and 180. 3. Both latitude and longitude must contain only digits, or one of the following symbols (including the space after comma): `-`, `.`. 4. There should be no space between the minus `\\"-\\"` sign and the digit after it. Below are some examples: Valid coordinates: ``` -23, 25 43.91343345, 143 4, -3 ``` Invalid coordinates: ``` 23.234, - 23.4234 N23.43345, E32.6457 6.325624, 43.34345.345 0, 1,2 ``` # Function Signature ```python def is_valid_coordinates(coordinates: str) -> bool: pass ``` # Input * `coordinates`: A string containing the latitude and longitude separated by a comma. # Output * Returns `True` if the coordinates are valid, `False` otherwise. # Constraints * The input string will only contain characters representing valid or invalid geographical coordinates. * You cannot use any external libraries for validation (only in-built python functionality). * Performance matters for large batches of inputs. # Example ```python assert is_valid_coordinates(\\"-23, 25\\") == True assert is_valid_coordinates(\\"43.91343345, 143\\") == True assert is_valid_coordinates(\\"6.325624, 43.34345.345\\") == False assert is_valid_coordinates(\\"23.234, - 23.4234\\") == False ``` Write the function to complete the task using efficient parsing and validation techniques.","solution":"def is_valid_coordinates(coordinates: str) -> bool: try: lat_str, long_str = coordinates.split(\\", \\") # Ensure that latitude and longitude can be converted to floats lat = float(lat_str) lng = float(long_str) # Check latitude and longitude bounds if not (-90 <= lat <= 90 and -180 <= lng <= 180): return False return True except ValueError: return False except IndexError: return False"},{"question":"# Binary Tree Operations: Minimum Depth and Printing As a software developer, you have been tasked with developing operations for binary trees. You\'re provided with a node structure and need to implement two essential functions: one for calculating the minimum depth of a binary tree and another for printing the tree pre-order. **TreeNode Class Definition**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Function Goals:** 1. **Calculate Minimum Depth (Iteratively)** Implement a function `calculate_min_depth` to determine the minimum depth of a binary tree using an iterative approach. - **Input**: `root` (TreeNode) – The root node of the binary tree. - **Output**: `int` – The minimum depth of the tree. 2. **Print Tree in Pre-order** Implement a function `print_pre_order` to print the nodes of the tree using pre-order traversal. - **Input**: `root` (TreeNode) – The root node of the binary tree. - **Output**: None – Should print node values in pre-order. # Constraints: - The binary tree can consist of 0 to 10^4 nodes. - Node values are integers. # Example: ```python # Example tree construction root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Calculate minimum depth and print tree print(calculate_min_depth(root)) # Expected output: 2 print_pre_order(root) # Expected output: 1 2 4 5 3 ``` # Performance Requirements: - Must handle large trees efficiently. - Aim for O(N) time complexity where possible. Implement the function as follows: ```python def calculate_min_depth(root): if root is None: return 0 height = 0 level = [root] while level: height += 1 new_level = [] for node in level: if node.left is None and node.right is None: return height if node.left is not None: new_level.append(node.left) if node.right is not None: new_level.append(node.right) level = new_level return height def print_pre_order(root): if root is not None: print(root.val, end=\' \') print_pre_order(root.left) print_pre_order(root.right) ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_min_depth(root): if not root: return 0 queue = [(root, 1)] while queue: node, depth = queue.pop(0) if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_pre_order(root): if root: print(root.val, end=\' \') print_pre_order(root.left) print_pre_order(root.right)"},{"question":"Context You have a web service that receives and processes URLs with query parameters. Often these URLs contain redundant parameters, and sometimes, certain parameters should be removed for privacy reasons or to prevent redundant data transmission. Your task is to write a function that can clean up these URLs by removing any duplicate query parameters and optionally removing specified parameters. Task Implement a function `strip_url_params(url: str, strip: List[str] = []) -> str:` that does the following: 1. Removes any duplicate query string parameters from the URL, keeping the first occurrence. 2. Removes any query string parameters specified within the `strip` list. Input * `url`: A string representing the URL. * `strip`: An optional list of strings representing the parameters to be removed from the URL. Defaults to an empty list. Output * Returns a new string representing the cleaned URL. Constraints * The URL will be a valid HTTP/HTTPS URL. * Query parameters will be alphanumeric and may consist of digits and letters only. * If there are no parameters to remove or strip, the function should return the URL as is. * If the URL has no query parameters, return it as is. Examples ```python assert strip_url_params(\'https://example.com?a=1&b=2&a=2\') == \'https://example.com?a=1&b=2\' assert strip_url_params(\'https://example.com?a=1&b=2&a=2\', [\'b\']) == \'https://example.com?a=1\' assert strip_url_params(\'https://example.com\', [\'b\']) == \'https://example.com\' assert strip_url_params(\'https://example.com?a=1&b=2&c=3\', [\'a\', \'b\']) == \'https://example.com?c=3\' assert strip_url_params(\'https://example.com?a=1&b=2&b=3&a=2\', [\'b\']) == \'https://example.com?a=1\' ``` Guidelines * Use Python\'s built-in libraries and ensure the solution is efficient and readable. * Handle edge cases as discussed (no parameters, duplicate parameters, specified removal). * Ensure the function is robust and can handle URLs with different scenarios mentioned in the examples.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def strip_url_params(url: str, strip: list = []) -> str: Cleans up the URL by removing duplicate query parameters and optionally specified parameters. :param url: A string representing the URL. :param strip: An optional list of strings representing the parameters to be removed. :return: A new string representing the cleaned URL. parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query) # Track seen parameters to keep the first occurrence only seen_params = {} for key, value in query_params: if key not in seen_params and key not in strip: seen_params[key] = value cleaned_query = urlencode(seen_params) cleaned_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, cleaned_query, parsed_url.fragment)) return cleaned_url"},{"question":"# Scenario You are given a sorted list of integers that may contain duplicate values. Your task is to implement a function that finds the index of the first occurrence of a specified target value. If the value is not present in the list, the function should return -1. # Function Signature ```python def find_first_occurrence(array: List[int], target: int) -> int: pass ``` # Input * `array`: A list of sorted integers. The list is guaranteed to be sorted in non-decreasing order. (0 <= len(array) <= 10^5, -10^9 <= array[i] <= 10^9) * `target`: An integer representing the value to be searched for. (-10^9 <= target <= 10^9) # Output * Return the index of the first occurrence of the target value in the array. * If the target is not found, return -1. # Constraints * The array is sorted. * The algorithm should run in O(log n) time complexity. # Example ```python >>> find_first_occurrence([1, 2, 2, 2, 3, 4], 2) 1 >>> find_first_occurrence([1, 2, 3, 4], 5) -1 >>> find_first_occurrence([], 1) -1 >>> find_first_occurrence([1, 1, 1, 1, 1], 1) 0 ``` # Notes Make sure to handle edge cases such as an empty array or the target not being present in the array.","solution":"from typing import List def find_first_occurrence(array: List[int], target: int) -> int: Find the index of the first occurrence of a target value in a sorted list. If the target is not found, return -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == target: result = mid right = mid - 1 # Continue searching in the left half elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Context You are working on optimizing the performance of a simple auto-sorting tool that organizes user data after initial input. The data is described by numbers, and it needs to be sorted to enhance user interface performance. # Problem Statement Implement an insertion sort function to sort an array of integers in ascending order. Your function should take an optional parameter to simulate the sorting process step-by-step for educational purposes. Function Signature ```python def insertion_sort(arr: list, simulation: bool=False) -> list: Sorts an array of integers using the insertion sort algorithm. Args: arr (list): A list of integers to be sorted. simulation (bool, optional): A flag for printing array states at each iteration. Defaults to False. Returns: list: The sorted list of integers. pass ``` Input - `arr`: A list of integers `[-10^5 <= arr[i] <= 10^5]` - `simulation`: A boolean flag to control debugging output. Output - A list of integers sorted in ascending order. Constraints * You should not use any built-in sort functions. * Performance should be acceptable for arrays up to 1000 elements. # Examples ```python print(insertion_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] print(insertion_sort([1, 2, 3, 4])) # Output: [1, 2, 3, 4] print(insertion_sort([3, -1, 4], simulation=True)) # Output: # iteration 0 : 3 -1 4 # iteration 1 : -1 3 4 # iteration 2 : -1 3 4 # returns [-1, 3, 4] ``` Edge Cases * Sorting an empty array should return an empty array. * An array with one element should return itself. # Testing Please test your implementation with arrays of varying lengths and types to ensure robustness and correctness.","solution":"def insertion_sort(arr, simulation=False): Sorts an array of integers using the insertion sort algorithm. Args: arr (list): A list of integers to be sorted. simulation (bool, optional): A flag for printing array states at each iteration. Defaults to False. Returns: list: The sorted list of integers. # If the array is empty or contains a single element, return it as-is if len(arr) <= 1: return arr # Traverse from 1 to len(arr) for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"Background Finding the right combination of items to match a specific condition is a common problem in algorithm design. It has pivotal applications in fields like cryptography, resource allocation, and combinatorial optimization. In this task, we explore one such case. Task Write a function `unique_array_sum_combinations()` that finds all unique combinations of one element from each of three given arrays `A`, `B`, and `C` that sum up to a given target value `target`. # Input - Three lists of integers `A`, `B`, and `C`. - An integer `target`. Output - A list of unique lists, where each inner list contains exactly three integers (one from `A`, one from `B`, one from `C`), and their sum is equal to `target`. # Constraints - Each list contains at most 100 elements. - Each element in the list is a non-negative integer. - The target is a non-negative integer. # Example ```python A = [1, 2, 3, 3] B = [2, 3, 3, 4] C = [2, 3, 3, 4] target = 7 Result: [[1, 2, 4], [1, 3, 3], [1, 4, 2], [2, 2, 3], [2, 3, 2], [3, 2, 2]] ``` # Guidelines - Ensure your solution is efficient and handles large lists within acceptable time limits. - Consider edge cases such as arrays with repeated numbers or very small arrays. - Avoid duplicate combinations in the output. # Performance Requirements - Aim for a time complexity of O(n^3). - Ensure you consider optimization points such as sorting arrays before processing and using sets to manage unique combinations. Implement the `unique_array_sum_combinations()` function in Python.","solution":"def unique_array_sum_combinations(A, B, C, target): Finds all unique combinations of one element from each of three given arrays A, B, and C that sum up to the given target value. Args: A (list of int): First list of integers. B (list of int): Second list of integers. C (list of int): Third list of integers. target (int): The target sum value. Returns: list of list of int: A list of unique combinations that sum to target. result = set() A.sort() B.sort() C.sort() for a in A: for b in B: for c in C: if a + b + c == target: result.add((a, b, c)) return [list(combination) for combination in result]"},{"question":"# Tree Subtree Check **Problem Statement**: You are provided with two binary trees represented in the form of class definitions below. Your task is to implement a function `is_subtree(s, t)` that returns `True` if tree `t` is a subtree of tree `s` and `False` otherwise. A subtree of tree `s` is a tree that consists of a node in `s` and all of that node\'s descendants in `t`. # Input and Output Formats: - Class Definitions: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - Function Signature: ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: pass ``` - Constraints: - The number of nodes in `s` and `t` is between 1 and 10000. - The value of each node is unique and between -100000 to 100000. # Performance Requirement: - Your solution should handle the worst-case scenario where tree `s` has up to 10000 nodes efficiently within a reasonable time frame. # Example: 1. Given `s`: ``` 3 / 4 5 / 1 2 ``` And `t`: ``` 4 / 1 2 ``` Return `True`, because `t` is a subtree of `s`. 2. Given `s`: ``` 3 / 4 5 / 1 2 / 0 ``` And `t`: ``` 4 / 1 2 ``` Return `False`, because `t` is not a subtree of `s`. # Explanation: 1. **BFS Traversal**: Use BFS to iterate through tree `s` to find nodes matching the root of `t`. 2. **Recursive Comparison**: Once a candidate matching node is found, validate the subtree via recursive comparison of the entire structure starting from these nodes. Implement the function `is_subtree(s: TreeNode, t: TreeNode) -> bool` according to the described algorithm.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: def is_same_tree(s, t): if not s and not t: return True if s and t and s.val == t.val: return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) return False def traverse(s, t): if not s: return False if is_same_tree(s, t): return True return traverse(s.left, t) or traverse(s.right, t) return traverse(s, t)"},{"question":"# Question: Find Maximal Cliques in an Undirected Graph Given an undirected graph represented by an adjacency list, write a function `find_maximal_cliques(graph: dict) -> List[List[int]]` to identify all maximal cliques in the graph. The graph is represented as a dictionary where keys are vertex identifiers (integers), and values are sets containing the identifiers of adjacent vertices. Input: - `graph` (dict): The adjacency list representation of the graph where each key(int) corresponds to a vertex and its value is a set(int) of adjacent vertices. Output: - A list of lists, where each sublist represents a maximal clique containing the vertices in that clique. Constraints: - The graph will contain up to 100 vertices. - The vertices are labelled with integers from 0 to 99. Example: ```python graph = { 0: {1, 2}, 1: {0, 2, 3}, 2: {0, 1}, 3: {1} } ``` The function should return possible maximal cliques, an example output could be: ```python [[0, 1, 2], [1, 3]] ``` Requirements: - Solution should find all maximal cliques. - The function should handle different sizes of graphs efficiently. Write the implementation of the function `find_maximal_cliques(graph: dict) -> List[List[int]]`.","solution":"from typing import List, Dict, Set from itertools import combinations def is_clique(graph: Dict[int, Set[int]], vertices: List[int]) -> bool: Helper function to check if a given set of vertices forms a clique. for u, v in combinations(vertices, 2): if v not in graph[u]: return False return True def find_maximal_cliques(graph: Dict[int, Set[int]]) -> List[List[int]]: Finds all maximal cliques in the graph. def bron_kerbosch(R, P, X): if not P and not X: cliques.append(R) return while P: v = P.pop() newR = R.union([v]) newP = P.intersection(graph[v]) newX = X.intersection(graph[v]) bron_kerbosch(newR, newP, newX) X.add(v) cliques = [] bron_kerbosch(set(), set(graph.keys()), set()) return [list(clique) for clique in cliques]"},{"question":"# Advanced Problem: Balancing and Traversing a Binary Search Tree You are going to enhance the basic implementation of a Binary Search Tree by adding functionalities to make it self-balancing. Additionally, you\'ll implement an additional traversal method - Level Order Traversal (BFS). # Objective: 1. Modify the given Binary Search Tree (BST) implementation to ensure that it remains balanced (e.g., by implementing an AVL tree or Red-Black tree). 2. Implement a Level Order Traversal that returns nodes in a level-by-level order as a list of lists. # Requirements: Step 1: Self-Balancing Tree * **Insert Method**: Update the `insert` method such that the tree remains balanced after every insertion. * **Assure**: Each `insert` maintains a balance (e.g., balance factors for AVL). You could use rotations as necessary. * **Balancing**: Ensure the balancing mechanism is efficient - maintaining O(log N) insertion. Step 2: Level Order Traversal * **Function Signature**: `def level_order_traversal(self) -> List[List[int]]` * **Output**: Return a list of lists where each sub-list represents values at that level in BFS order. # Constraints: * All values to be inserted will be unique integers. * Inputs should ensure that the tree remains within a reasonable size where algorithmic scaling matters. # Example: ```python # Binary Search Tree with Balancing bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.insert(4) bst.insert(9) bst.insert(12) bst.insert(24) bst.insert(7) bst.insert(20) bst.insert(30) bst.insert(18) # Level Order Traversal print(bst.level_order_traversal()) # Expected Output: [[10], [6, 15], [4, 9, 12, 24], [7, 20, 30], [18]] ``` Provide the implementation for the `BST` class with the updates for a self-balancing tree and the `level_order_traversal` method. Use appropriate data structures and encapsulation principles.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 # Height attribute is needed for AVL balancing class AVLTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return Node(key) if key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) balance = self._get_balance(root) # Perform rotations if necessary # Left Left Case if balance > 1 and key < root.left.key: return self._right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self._left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self._left_rotate(root.left) return self._right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, root): if not root: return 0 return root.height def _get_balance(self, root): if not root: return 0 return self._get_height(root.left) - self._get_height(root.right) def level_order_traversal(self): if not self.root: return [] queue = [self.root] res = [] while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.pop(0) current_level.append(node.key) if node.left: queue.append(node.left) if node.right: queue.append(node.right) res.append(current_level) return res"},{"question":"# Question You are given an array of integers, and you need to write a function to rotate the array elements to the right by `k` positions. Provide three different implementations to solve this problem. Your implementations should handle edge cases and be optimized for performance. Function Signature ```python def rotate_v1(array: List[int], k: int) -> List[int]: pass def rotate_v2(array: List[int], k: int) -> List[int]: pass def rotate_v3(array: List[int], k: int) -> List[int]: pass ``` Input * `array`: a list of integers * `k`: an integer indicating the number of positions to rotate the array to the right Output * Return the array rotated to the right by `k` positions # Requirements 1. **rotate_v1**: Must rotate the array using repeated shifts 2. **rotate_v2**: Must rotate the array using the reversal technique 3. **rotate_v3**: Must rotate the array by creating a new array # Constraints * 1 <= len(array) <= 10^5 * 0 <= k <= 10^5 * The array contains only integers. # Example ```python array = [1,2,3,4,5,6,7] k = 3 rotate_v1(array, k) -> [5,6,7,1,2,3,4] rotate_v2(array, k) -> [5,6,7,1,2,3,4] rotate_v3(array, k) -> [5,6,7,1,2,3,4] ``` # Note - Ensure that all of your implementations are thoroughly tested with different inputs. - Each function should handle cases where `k` is larger than the array length by using `k % len(array)`. - Address edge cases such as empty arrays or arrays with a single element.","solution":"from typing import List def rotate_v1(array: List[int], k: int) -> List[int]: Rotate the array using repeated shifts. n = len(array) if n == 0: return array k = k % n for _ in range(k): array.insert(0, array.pop()) return array def rotate_v2(array: List[int], k: int) -> List[int]: Rotate the array using the reversal technique. def reverse(lst, start, end): while start < end: lst[start], lst[end] = lst[end], lst[start] start, end = start + 1, end - 1 n = len(array) if n == 0: return array k = k % n reverse(array, 0, n - 1) reverse(array, 0, k - 1) reverse(array, k, n - 1) return array def rotate_v3(array: List[int], k: int) -> List[int]: Rotate the array by creating a new array. n = len(array) if n == 0: return array k = k % n return array[-k:] + array[:-k]"},{"question":"# Context You are managing a ticketing system where attendees join a digital queue to grab tickets for various events. Implement a queue that efficiently handles a large number of attendees joining and leaving the queue. # Task You need to implement a Circular Buffer-based queue to optimize the ArrayQueue implementation. This CircularBufferQueue should wrap around when the rear reaches the end of the array, thus avoiding frequent resizing. # Function Specification Implement the CircularBufferQueue class with the following methods: - `enqueue(item)` - Adds an item to the end of the queue. - `dequeue()` - Removes an item from the front of the queue. - `peek()` - Returns the front item of the queue without removing it. - `is_empty()` - Checks if the queue is empty. - `__len__()` - Returns the number of items in the queue. # Requirements - Your implementation should not require resizing of the array. - Use circular buffering to ensure that the space is utilized efficiently. - The length of the queue should accommodate growth up to its initial capacity. # Constraints - Methods should operate with time complexity of O(1), except during exceptional resizing situations if implemented. - Raise `IndexError` when attempting to `dequeue` or `peek` from an empty queue. # Example ```python cq = CircularBufferQueue(5) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.dequeue()) # Output: 1 print(cq.peek()) # Output: 2 print(len(cq)) # Output: 2 ```","solution":"class CircularBufferQueue: def __init__(self, capacity): self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = -1 self.size = 0 def enqueue(self, item): if self.size == self.capacity: raise IndexError(\\"Queue is full\\") self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = item self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size"},{"question":"You are given an array of unique positive integers `nums` and a positive integer `target`. Write a function `find_combination_sum(nums: List[int], target: int) -> int` that returns the number of distinct ordered combinations that sum up to `target`. Different sequences of the same combination are considered distinct. Example ```python nums = [1, 2, 3] target = 4 find_combination_sum(nums, target) ``` The output should be `7` as the possible combinations are: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) Constraints - All integers in `nums` are unique and positive. - The `target` is a positive integer. - Utilize Dynamic Programming techniques. - Optimize the solution to work efficiently for high values of `target`. Follow-Up Question How would you modify your solution if `nums` includes negative numbers? What changes need to be introduced to handle such scenarios safely without causing infinite loops? Implementation Implement both top-down and bottom-up approaches for comparison: 1. Top-Down with Memoization 2. Bottom-Up Iterative DP Provide a thorough testing approach to ensure the correctness of your implementations.","solution":"from typing import List def find_combination_sum(nums: List[int], target: int) -> int: Returns the number of distinct ordered combinations of nums that sum up to target. # Dynamic Programming - Bottom-Up Approach dp = [0] * (target + 1) # There is one way to get zero sum, that is using no elements dp[0] = 1 for total in range(1, target + 1): for num in nums: if total >= num: dp[total] += dp[total - num] return dp[target] def find_combination_sum_top_down(nums: List[int], target: int) -> int: Returns the number of distinct ordered combinations of nums that sum up to target using Top-Down DP with memoization. memo = {} def dfs(remaining): if remaining == 0: return 1 if remaining in memo: return memo[remaining] count = 0 for num in nums: if remaining >= num: count += dfs(remaining - num) memo[remaining] = count return count return dfs(target)"},{"question":"# Question: Optimal Network Wiring with Minimum Spanning Tree You are tasked with designing the most cost-effective way to lay down electrical wires to connect a set of buildings. The connections between buildings are represented as a weighted, undirected graph where nodes represent buildings and edges represent possible connections with associated costs. # Problem Statement Given an undirected graph with `n` nodes and `m` weighted edges, implement a function to compute the Minimum Spanning Tree (MST) of the graph using Kruskal\'s Algorithm. The function should return the sum of the weights of the edges in the MST. # Function Signature ```python def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: ``` # Input - `n` (1 ≤ n ≤ 1000): The number of buildings (nodes) in the graph. - `edges`: A list of tuples, each representing an edge `(u, v, w)` where `u` and `v` are the 0-indexed nodes connected by the edge, and `w` is the cost (weight) of that edge. The number of edges `m` satisfies (0 leq m leq frac{n(n-1)}{2}). # Output - Return the sum of the weights of the edges in the MST. # Constraints - If the graph is disconnected, return `-1` to indicate it is impossible to connect all buildings. - Ensure efficient handling of input sizes up to the given constraints. # Example ```python edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)] n = 4 print(minimum_spanning_tree(n, edges)) # Output: 19 ``` # Description: To solve this problem, use the provided Kruskal\'s algorithm. Sort the edges by weight, utilize a disjoint set to keep track of connected components, and iteratively add the smallest edge to the MST, ensuring no cycles are formed. # Edge Cases: - Ensure to handle cases where the input graph is disconnected and returning the appropriate value. - Ensure that your implementation can handle the upper limits of the input size.","solution":"from typing import List, Tuple def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]]) -> int: edges.sort(key=lambda e: e[2]) parent = list(range(n)) rank = [0] * n mst_weight = 0 mst_edges = 0 for u, v, weight in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += weight mst_edges += 1 if mst_edges == n - 1: break if mst_edges != n - 1: return -1 return mst_weight"},{"question":"You are given an array of positive integers `nums` and a target sum `target`. Your task is to write a function that calculates the number of distinct combinations of elements in `nums` that add up to `target`. Each number in `nums` can be used an unlimited number of times and the order of numbers in combinations matters. **Function Signature** ```python def combination_sum(nums: List[int], target: int) -> int: # Implementation goes here ``` **Input** * `nums: List[int]`: A list of unique positive integers. * `target: int`: A positive integer representing the target sum. **Output** * Returns an integer representing the total number of different ordered combinations that add up to `target`. **Constraints** * 1 <= len(nums) <= 200 * 1 <= target <= 1000 * All elements in `nums` are positive integers. **Example** ```python nums = [1, 2, 3] target = 4 combination_sum(nums, target) ``` **Output**: 7 Explanation: The possible combinations are [1,1,1,1], [1,1,2], [1,2,1], [1,3], [2,1,1], [2,2] and [3,1]. **Follow-up Questions** 1. How would the problem change if negative numbers are allowed in `nums`? What kind of limitations need to be added to handle this case? 2. Compare the top-down and bottom-up approaches provided. Which do you think is more efficient in terms of implementation and why?","solution":"from typing import List def combination_sum(nums: List[int], target: int) -> int: Returns the number of distinct combinations of elements in nums that add up to target. Each number in nums can be used an unlimited number of times and the order of numbers in combinations matters. # Dynamic programming array to store the number of ways to reach each sum from 0 to target dp = [0] * (target + 1) # There\'s exactly one way to make the sum 0, which is using no elements at all dp[0] = 1 # Fill the dp array for i in range(1, target + 1): for num in nums: if i - num >= 0: dp[i] += dp[i - num] return dp[target]"},{"question":"# Question: Verifying Strong Connection in a Directed Graph You are tasked with creating a function to verify if a given directed graph is strongly connected. A graph is strongly connected if there is a path from any node to any other node in the graph and vice-versa. Implement the following function: ```python def is_graph_strongly_connected(vertex_count, edges): Determines if the directed graph is strongly connected. Parameters: - vertex_count (int): The number of vertices in the graph. - edges (list of tuples): A list of tuples where each tuple represents an edge from source to target. Returns: - bool: True if the graph is strongly connected, False otherwise. pass ``` Input * `vertex_count` - an integer (2 ≤ vertex_count ≤ 1000). * `edges` - a list of tuples where each tuple represents an edge (source, target) in the graph (0 ≤ source, target < vertex_count). Output * Return `True` if the graph is strongly connected, `False` otherwise. # Example: # Example 1: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 0), (0, 3), (3, 0)] print(is_graph_strongly_connected(vertex_count, edges)) # Output: True ``` # Example 2: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 0), (0, 3)] print(is_graph_strongly_connected(vertex_count, edges)) # Output: False ``` # Constraints: * The graph may contain self-loops and multi-edges. * Ensure your function efficiently handles cases up to given constraints. * Consider edge cases as discussed.","solution":"def is_graph_strongly_connected(vertex_count, edges): from collections import defaultdict, deque def bfs(start, graph): visited = [False] * vertex_count queue = deque([start]) while queue: vertex = queue.popleft() if not visited[vertex]: visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: queue.append(neighbor) return all(visited) # Convert edge list to adjacency list representation graph = defaultdict(list) reverse_graph = defaultdict(list) for src, dest in edges: graph[src].append(dest) reverse_graph[dest].append(src) # Check if all vertices are reachable from vertex 0 if not bfs(0, graph): return False # Check if all vertices are reachable to vertex 0 (using the reverse graph) if not bfs(0, reverse_graph): return False return True"},{"question":"# Scenario You are tasked with designing a resilient and efficient storage system for keyword-based lookup of contextual information in a large-scale search engine. Performance and flexible scaling are crucial. Implementing a robust hash table with dynamic resizing is essential. # Problem Statement You are given a class `ResizableHashTable`, an extension to `HashTable`. While it resizes dynamically by doubling the size when two-thirds full, its hash function is minimal and resizing isn\'t optimal beyond doubling. # Tasks 1. **Enhance the provided `ResizableHashTable` class** with the following modifications: * Implement a more sophisticated hash function that minimizes collisions. The new hash function should distribute keys uniformly across the table. * Implement `resize` functionality to allow for flexible resizing strategies, not just doubling. Your implementation should allow custom size increments or decrements. * Optimize the collision handling mechanism by implementing **quadratic probing** instead of linear probing. # Function Signatures ```python class ResizableHashTable(HashTable): def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): rv = super().put(key, value) if len(self) >= (self.size * 2) / 3: self.resize() def resize(self, new_size=None): # Implement resizing with the possibility of custom new size pass def hash(self, key): # Improve this hashing function pass def _rehash(self, old_hash): # Implement quadratic probing in place of linear probing pass ``` # Constraints * Assume all `key` inputs are integers, non-negative, and unique. * Design your hashing function to work within the integer range in Python. * Ensure `resize` function is efficient and handles large-scale resizing smoothly. # Performance Requirements * Average case O(1) for `put`, `get`, and `del` operations. * Resizing operation should remain O(n) where n is the number of elements in the table.","solution":"class ResizableHashTable: MIN_SIZE = 8 def __init__(self): self.size = self.MIN_SIZE self.table = [None] * self.size self.count = 0 def __len__(self): return self.count def put(self, key, value): if self.count >= (self.size * 2) // 3: self.resize() idx = self.hash(key) original_idx = idx i = 1 while self.table[idx] is not None and self.table[idx][0] != key: idx = (original_idx + i ** 2) % self.size i += 1 if self.table[idx] is None: self.count += 1 self.table[idx] = (key, value) def get(self, key): idx = self.hash(key) original_idx = idx i = 1 while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (original_idx + i ** 2) % self.size i += 1 return None def delete(self, key): idx = self.hash(key) original_idx = idx i = 1 while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 return idx = (original_idx + i ** 2) % self.size i += 1 def resize(self, new_size=None): old_table = self.table if new_size is None: new_size = self.size * 2 self.size = new_size self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(*entry) def hash(self, key): A = (5 ** 0.5 - 1) / 2 # Knuth\'s multiplicative constant hash_value = int(self.size * ((key * A) % 1)) return hash_value def _rehash(self, old_hash, step): return (old_hash + step ** 2) % self.size"},{"question":"# Subtree Check Algorithm Question You have been given two binary trees, `s` and `t`. Your task is to determine whether the binary tree `t` is a subtree of the binary tree `s`. A subtree of `s` is a tree consisting of a node in `s` and all of its descendants in `s`. The tree `s` could be significantly larger than `t`. Function Signature ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: ``` Input * `s` and `t` are the roots of binary trees, represented as instances of the class `TreeNode`. Output * Return `True` if `t` is a subtree of `s`, otherwise return `False`. Constraints * The number of nodes in `s` and `t` will be at most 10000. * Node values will be in the range `[0, 10000]`. Example # Example 1 ```plaintext Input: s: 3 / 4 5 / 1 2 t: 4 / 1 2 Output: True ``` # Example 2 ```plaintext Input: s: 3 / 4 5 / 1 2 / 0 t: 4 / 1 2 Output: False ``` Instructions 1. Implement the `is_subtree` function to determine if `t` is a subtree of `s`. 2. Use a helper function `comp` to compare the subtrees. 3. Consider edge cases where either tree may be empty or trees with various node configurations. 4. Aim for an efficient solution to handle larger tree sizes within constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True if not s: return False # Helper function to compare two trees def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False return s.val == t.val and is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) # Running recursive check if t is equal to current node, or a subtree of either child return is_same_tree(s, t) or is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"# Bogo Sort Implementation and Analysis Problem Statement You are tasked to implement the Bogo Sort algorithm as described in the analysis above. The Bogo Sort algorithm checks if the given array is sorted, and if not, it shuffles the array randomly until it is sorted. Your implementation must use the following function signature: ```python def bogo_sort(arr, simulation=False) -> list ``` Input - `arr`: A list of integers to be sorted. - `simulation`: A boolean indicating whether to print each iteration of the sorting process. Default value is `False`. When set to `True`, print the array after each shuffle attempt. Output - A sorted list of integers. Constraints - The array may be of size (0 leq n leq 10^3). However, remember that Bogo Sort is slow and impractical for larger cases. - The integers in the array can be negative or positive, with a range of (-10^4 leq a_i leq 10^4). Performance Requirements * You should be aware of the impracticality of using Bogo Sort for large arrays due to its factorial time complexity. Example Given input: ```python arr = [3, 1, 2] simulation = True ``` Expected output: ``` iteration 0 : 3 1 2 iteration 1 : 3 2 1 iteration 2 : 2 1 3 iteration 3 : 2 3 1 iteration N : 1 2 3 ... ``` Depending on the random shuffling, the printed array may vary. Your task is to: 1. Implement the function as described. 2. Make sure that under the `simulation=True` mode, the process of shuffling tries is printed, including the iteration count. **Note**: Since Bogo Sort can be inefficient, you may want to test with smaller arrays for practical purposes.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr, simulation=False): Function to sort the array using Bogo Sort. iteration = 0 while not is_sorted(arr): if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") random.shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# 1-Sparse Recovery Algorithm Implementation You are provided with a series of integer tuples, each consisting of a non-negative integer and an accompanying sign (\'+\' or \'-\'). Your task is to implement the 1-sparse recovery algorithm to identify a unique number that remains after all cancellation operations. If multiple numbers remain or none remain, the output should be `None`. The algorithm should follow these steps: 1. Track the sum of values adjusted by their signs. 2. Maintain a separate bitwise sum of all values adjusted by their signs. 3. At the end of the stream, check if the bitsum array allows for identifying a unique value that satisfies the sum condition. **Function Signature:** ```python def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: Parameters: array (List[Tuple[int, str]]): A stream of tuples where each tuple contains a number and a sign (\'+\' or \'-\'). Returns: Optional[int]: The unique number if the stream is 1-sparse, otherwise None. ``` **Input:** * A list of tuples, where each tuple contains: * A non-negative integer `val` (0 ≤ val ≤ 10^9). * A sign `sign` (\'+\' or \'-\') indicating whether to add or subtract the value. **Output:** * Return the unique non-canceled integer if the stream is 1-sparse. * Return `None` if the stream is not 1-sparse. **Constraints:** * The length of the list will be in the range [1, 10^6]. **Examples:** 1. Input: `[(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')]` Output: `4` 2. Input: `[(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')]` Output: `2` 3. Input: `[(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')]` Output: `None` **Notes:** * Ensure to handle edge cases such as completely balanced operations or very large number inputs without performance degradation.","solution":"from typing import List, Tuple, Optional def one_sparse(array: List[Tuple[int, str]]) -> Optional[int]: value_sum = 0 bit_sum = 0 for val, sign in array: signed_val = val if sign == \'+\' else -val value_sum += signed_val bit_sum += signed_val * val if value_sum == 0: return None unique_value = bit_sum // value_sum # Verify if unique_value is valid by confirming its count from the array expected_sum = unique_value * value_sum if bit_sum != expected_sum: return None return unique_value"},{"question":"You are working as a flood analyst and have been given a geographical map in the form of a matrix. The matrix contains non-negative integers where each integer represents the height of the unit cell in a continent. The Pacific ocean touches the left and top edges of the matrix, and the Atlantic ocean touches the right and bottom edges. Your task is to write a Python function `pacific_atlantic` that returns the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean. Input: - A 2D list `matrix` of integers, where `matrix[i][j]` represents the height of unit cell `(i, j)`, with 0 <= `matrix[i][j]` <= 10^7. - The matrix dimensions are m x n with 1 <= m, n <= 150. Output: - A list of lists, where each list represents the coordinates `[i, j]` of a unit cell. Constraints: - Water can flow from a cell to another cell if and only if the height of the destination cell is equal or lower than the height of the current cell. - Water can move in the four cardinal directions: up, down, left, or right. - You should ensure the returned coordinates list does not contain duplicates. Example: Given the following 5x5 matrix: ``` Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * Atlantic ``` Return the following list: ``` [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` These coordinates are the positions where water can flow to both the Pacific and Atlantic ocean. **Implementation Details:** Define and implement the function as follows: ```python def pacific_atlantic(matrix): :type matrix: List[List[int]] :rtype: List[List[int]] # Your implementation here ``` Ensure your function handles edge cases like empty matrices, matrices with all equal heights, and appropriately updates the visited states to avoid redundant checks.","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) pacific_reachable = [[False for _ in range(n)] for _ in range(m)] atlantic_reachable = [[False for _ in range(n)] for _ in range(m)] def dfs(matrix, reachable, i, j): reachable[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dir_x, dir_y in directions: x, y = i + dir_x, j + dir_y if 0 <= x < m and 0 <= y < n and not reachable[x][y] and matrix[x][y] >= matrix[i][j]: dfs(matrix, reachable, x, y) for i in range(m): dfs(matrix, pacific_reachable, i, 0) dfs(matrix, atlantic_reachable, i, n - 1) for j in range(n): dfs(matrix, pacific_reachable, 0, j) dfs(matrix, atlantic_reachable, m - 1, j) result = [] for i in range(m): for j in range(n): if pacific_reachable[i][j] and atlantic_reachable[i][j]: result.append([i, j]) return result"},{"question":"# Hash Table Operations You are required to implement a variant of a hash table that supports dynamic resizing and allows users to check for the existence of keys efficiently. Your implementation should include a method to check for key existence and modify how deletions are handled to make the table more resilient to collisions. Specifications: * Class: `ResizableHashTable` (as derived from the provided HashTable class) * Methods: * `exists(key)`: Checks if the given key exists in the table. * Modify the `del_` method to improve resilience against collisions, potentially through marking or tombstones. Expected Input and Output: * The `exists` method should return a boolean value. * Deleting a key should appropriately handle the removal with better management of collision chains. --- **Implement your solution**: 1. Modify the `ResizableHashTable` class provided: * Add the `exists` method. * Improve the `del_` method. ```python # Implement your solution here class ResizableHashTable(HashTable): MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): rv = super().put(key, value) # Increase size *2 if filled >= 2/3 if len(self) >= (self.size * 2) / 3: self.__resize() def __resize(self): keys, values = self._keys, self._values self.size *= 2 # New size self._len = 0 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size for key, value in zip(keys, values): if key is not self._empty and key is not self._deleted: self.put(key, value) def exists(self, key): # Implement the exists method initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty: return False elif self._keys[hash_] == key: return True hash_ = self._rehash(hash_) if initial_hash == hash_: return False def del_(self, key): # Improve del_ method initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty: # Key was never assigned return None elif self._keys[hash_] == key: # Key found, mark as deleted self._keys[hash_] = self._deleted self._values[hash_] = self._deleted self._len -= 1 return hash_ = self._rehash(hash_) if initial_hash == hash_: # Table is full and wrapped around return None ``` Constraints: * Key and Value should be integers. * Assume only positive integers for keys. * The initial size of the hash table should be 8.","solution":"class HashTable: _empty = object() _deleted = object() def __init__(self, size=8): self.size = size self._len = 0 self._keys = [self._empty] * size self._values = [self._empty] * size def __len__(self): return self._len def hash(self, key): return key % self.size def _rehash(self, old_hash): return (old_hash + 1) % self.size def put(self, key, value): hash_ = self.hash(key) while self._keys[hash_] not in (self._empty, self._deleted): if self._keys[hash_] == key: self._values[hash_] = value return hash_ = self._rehash(hash_) self._keys[hash_] = key self._values[hash_] = value self._len += 1 def get(self, key): hash_ = self.hash(key) initial_hash = hash_ while self._keys[hash_] is not self._empty: if self._keys[hash_] == key: return self._values[hash_] hash_ = self._rehash(hash_) if hash_ == initial_hash: break return None class ResizableHashTable(HashTable): def __init__(self): super().__init__(8) def put(self, key, value): super().put(key, value) if len(self) >= (self.size * 2) // 3: self.__resize() def __resize(self): old_keys = self._keys old_values = self._values self.size *= 2 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._len = 0 for k, v in zip(old_keys, old_values): if k is not self._empty and k is not self._deleted: self.put(k, v) def exists(self, key): hash_ = self.hash(key) initial_hash = hash_ while self._keys[hash_] is not self._empty: if self._keys[hash_] == key: return True hash_ = self._rehash(hash_) if hash_ == initial_hash: break return False def del_(self, key): hash_ = self.hash(key) initial_hash = hash_ while self._keys[hash_] is not self._empty: if self._keys[hash_] == key: self._keys[hash_] = self._deleted self._values[hash_] = self._deleted self._len -= 1 return hash_ = self._rehash(hash_) if hash_ == initial_hash: break"},{"question":"Context You\'re working on a software project that involves manipulation of hierarchical data structures. One of the tasks frequently required is the inversion of binary trees to analyze symmetry and structure. Problem Statement Implement a function `invert_tree` that receives the root of a binary tree and inverts the tree. Inverting a binary tree means swapping the left and right children of all nodes in the tree. # Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Input * `root` - A TreeNode representing the root of the binary tree. The TreeNode class is defined as: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Output * Return the root of the inverted binary tree. # Constraints * The number of nodes in the binary tree is between 0 and 1000. * The value of each node is between -1000 and 1000. # Example ```python # Given the following binary tree: # 4 # / # 2 7 # / / # 1 3 6 9 # After inversion, it becomes: # 4 # / # 7 2 # / / # 9 6 3 1 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) inverted_root = invert_tree(root) assert inverted_root.left.value == 7 assert inverted_root.right.value == 2 assert inverted_root.left.left.value == 9 assert inverted_root.left.right.value == 6 assert inverted_root.right.left.value == 3 assert inverted_root.right.right.value == 1 ``` * Consider edge cases such as an empty tree or a tree with a single node. * Optimize for both time and space complexity where possible.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively call invert_tree on the children invert_tree(root.left) invert_tree(root.right) return root"},{"question":"Coding Assessment Question # Scenario You are tasked with designing software for a company\'s file version control system. The system saves snapshots of different versions of the entire file directory tree structure. You need to implement a function that efficiently determines whether a saved snapshot (subtree) is present as a subtree within the current directory tree structure. # Task Write a function, `is_subtree(s: TreeNode, t: TreeNode) -> bool`, that takes in two binary trees, `s` (the larger tree representing the current directory structure) and `t` (the subtree representing a snapshot), and returns `True` if `t` is a subtree of `s`, or `False` otherwise. Input * `s`: A TreeNode object representing the root of the larger binary tree. * `t`: A TreeNode object representing the root of the subtree. Output * `True` if `t` is a subtree of `s`, otherwise `False`. Constraints * You may assume `TreeNode` class is already defined with: * `TreeNode.val` (integer representing the node\'s value), * `TreeNode.left` (pointer to the left child), * `TreeNode.right` (pointer to the right child). # Example ```python # Example 1: # Input: # Tree s: 3 # / # 4 5 # / # 1 2 # Tree t: 4 # / # 1 2 # Output: True # Example 2: # Input: # Tree s: 3 # / # 4 5 # / # 1 2 # / # 0 # Tree t: 4 # / # 1 2 # Output: False ``` # Performance Requirements * Your solution should have a time complexity better than O(n * m), where n is the number of nodes in the larger tree, and m is the number of nodes in the smaller tree, if possible. # Follow-Up * Discuss how you would handle the case where one tree is significantly larger than the other in your solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t) def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"# Question: Implement and Test Radix Sort Algorithm Scenario You are given a list of non-negative integers that need to be sorted efficiently. Your task is to write a function `radix_sort` that sorts this list using the Radix Sort algorithm. The function should also have a simulation mode to output the intermediate sorting steps. Function Signature ```python def radix_sort(arr: list, simulation: bool = False) -> list: ``` Input * **arr**: List of non-negative integers (0 to 1,000,000). * **simulation**: Boolean flag. If `True`, print the list at each iteration step of the sorting process. Output * Returns the sorted list of integers. Example **Input**: ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] simulation = True ``` **Output**: ``` iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 2 802 24 45 75 66 iteration 2 : 2 24 45 66 75 170 802 90 iteration 3 : 2 24 45 66 75 90 170 802 [2, 24, 45, 66, 75, 90, 170, 802] ``` Constraints * The list may contain up to 100,000 integers. * Each integer is non-negative and has at most 6 digits. Requirements 1. Implement the `radix_sort` function to handle the sorting as described. 2. Ensure proper handling of edge cases like empty list and single-element list. 3. Output intermediate steps only if the simulation flag is set to `True`.","solution":"def counting_sort(arr, exp, simulation, iteration): n = len(arr) output = [0] * n # output array count = [0] * 10 # count array for digits 0-9 for i in range(n): index = arr[i] // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n-1, -1, -1): index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") def radix_sort(arr, simulation=False): max1 = max(arr) if arr else 0 exp = 1 iteration = 0 while max1 // exp > 0: counting_sort(arr, exp, simulation, iteration) exp *= 10 iteration += 1 return arr"},{"question":"Scenario Given a large dataset of unsigned integers, you need to analyze each number\'s Hamming weight efficiently to optimize storage needs in a customized memory module. Task Write a function that efficiently determines the number of 1 bits in the binary representation of each number in a list of unsigned integers. Your implementation should take advantage of bit manipulation for the most efficient count, adhering to time and space efficiency principles. Function Signature ```python def count_hamming_weights(numbers: List[int]) -> List[int]: ``` Input - `numbers`: A list of `unsigned integers`. `1 <= len(numbers) <= 10^6`, and all elements are within the range of 32-bit unsigned integers. Output - Return a list of integers where each integer is the Hamming weight of the corresponding number in the input list. Constraints - You must use bit manipulation methods. - Recursive solutions should handle recursion depth properly. - The solution should be optimized for both time and space. Example ```python assert count_hamming_weights([0, 11, 128, 4294967295]) == [0, 3, 1, 32] ``` Hints - Consider iterating over each integer and using a bit manipulation method individually. - Prefer iterative methods to handle large inputs efficiently. Performance Requirements - Your solution must handle a list with up to `10^6` items efficiently. - Focus on minimizing both time and space usage.","solution":"from typing import List def count_hamming_weights(numbers: List[int]) -> List[int]: Returns a list of Hamming weights for each number in the input list. def hamming_weight(n: int) -> int: count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count return [hamming_weight(num) for num in numbers]"},{"question":"Given an array of integers, you are required to implement a sorting function using the Bogo Sort algorithm. The function should reorder the array such that its elements are in non-decreasing order. Given the inefficiency of Bogo Sort, your task integrates learning with a practical twist to encourage understanding of algorithm efficiency. # Function Signature ```python def bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` # Input * `arr` (list[int]): A list of integers to be sorted. * `simulation` (bool): Optional flag to simulate and print each shuffle step. Defaults to False. # Output * Returns the sorted list of integers. # Constraints * 0 ≤ len(arr) ≤ 5 * Each integer in arr will be between -1000 and 1000. # Performance Requirements * The function must correctly sort the array irrespective of its inefficiency. * The simulation flag, when set to True, should output each intermediate state of the array during the sorting process. # Example ```python # Example 1: arr = [3, 2, 1] print(bogo_sort(arr)) # Output could be: [1, 2, 3] (output may vary due to randomness) # Example 2: arr = [1, 1, 1] print(bogo_sort(arr)) # Output: [1, 1, 1] # Example 3: arr = [0] print(bogo_sort(arr)) # Output: [0] # Example 4: arr = [] print(bogo_sort(arr)) # Output: [] # Example 5: arr = [3, 2, 1] print(bogo_sort(arr, simulation=True)) # Outputs simulated steps showing each shuffle, eventually resulting in [1, 2, 3]. ``` # Context You are implementing this function for educational purposes to demonstrate the inefficiencies and impracticalities of Bogo Sort. It is critical to highlight why more advanced sorting algorithms should be learned and used.","solution":"import random def bogo_sort(arr: list[int], simulation: bool = False) -> list[int]: def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): if simulation: print(arr) random.shuffle(arr) return arr"},{"question":"# Question **Scenario**: You have been tasked with implementing a simplified filesystem where directories are represented using a B-Tree to manage their contents efficiently. Each directory can contain numerous files, and the directory structure needs to support fast search, insert, and delete operations. **Task**: Implement a simplified B-Tree class that supports inserting, searching, deleting, and traversing files. **Requirements**: 1. **Insert File**: - Function: `insert_file(self, file_name: str) -> None` - Insert a file with a given name into the B-Tree. If the file already exists, ignore the insertion. 2. **Search File**: - Function: `search_file(self, file_name: str) -> bool` - Return `True` if the file is found in the B-Tree, `False` otherwise. 3. **Delete File**: - Function: `delete_file(self, file_name: str) -> None` - Remove the file with the given name from the B-Tree. If the file does not exist, do nothing. 4. **List Files**: - Function: `list_files(self) -> List[str]` - Return a list of all file names in the B-Tree in sorted order. # Constraints 1. File names are unique strings containing only lowercase alphabets (`a-z`). 2. There will be at most `10^5` file names. # Performance Requirements - All operations (insertion, searching, deletion, listing) should be efficient with an average time complexity of O(log n). # Example ```python # Example usage: btree = BTree(t_val=3) # Create a B-Tree with minimum degree 3 btree.insert_file(\\"file1\\") btree.insert_file(\\"file2\\") btree.insert_file(\\"file3\\") print(btree.search_file(\\"file1\\")) # Outputs: True print(btree.search_file(\\"file4\\")) # Outputs: False btree.delete_file(\\"file2\\") print(btree.list_files()) # Outputs: [\'file1\', \'file3\'] ```","solution":"class BTreeNode: def __init__(self, t_val, leaf=False): self.t_val = t_val # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in this node self.children = [] # List of children BTreeNode class BTree: def __init__(self, t_val): self.t_val = t_val # Minimum degree self.root = BTreeNode(t_val, leaf=True) def traverse(self, node=None, vals=None): if node is None: node = self.root if vals is None: vals = [] for i in range(len(node.keys)): if not node.leaf: self.traverse(node.children[i], vals) vals.append(node.keys[i]) if not node.leaf: self.traverse(node.children[len(node.keys)], vals) return vals def list_files(self): return self.traverse() def search_file(self, key, node=None): if node is None: node = self.root i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and key == node.keys[i]: return True if node.leaf: return False return self.search_file(key, node.children[i]) def insert_file(self, k): root = self.root if len(root.keys) == 2 * self.t_val - 1: s = BTreeNode(self.t_val, leaf=False) self.root = s s.children.insert(0, root) self.split_child(s, 0) self._insert_non_full(s, k) else: self._insert_non_full(root, k) def split_child(self, x, i): t_val = self.t_val y = x.children[i] z = BTreeNode(t_val, leaf=y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t_val - 1]) z.keys = y.keys[t_val: (2 * t_val) - 1] y.keys = y.keys[0: t_val - 1] if not y.leaf: z.children = y.children[t_val: 2 * t_val] y.children = y.children[0: t_val] def _insert_non_full(self, x, k): i = len(x.keys) - 1 if x.leaf: x.keys.append(None) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == 2 * self.t_val - 1: self.split_child(x, i) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def delete_file(self, key): self._delete(self.root, key) if self.root.keys == []: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None def _delete(self, node, key): t_val = self.t_val i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == key: if node.leaf: node.keys.pop(i) else: self._delete_internal_node(node, key, i) elif not node.leaf: if len(node.children[i].keys) >= t_val: self._delete(node.children[i], key) else: self._delete_merge(node, i) if len(node.keys) < i: self._delete(node.children[i - 1], key) else: self._delete(node.children[i], key) def _delete_internal_node(self, node, key, i): t_val = self.t_val if len(node.children[i].keys) >= t_val: pred_key = self._get_predecessor(node, i) node.keys[i] = pred_key self._delete(node.children[i], pred_key) elif len(node.children[i + 1].keys) >= t_val: succ_key = self._get_successor(node, i) node.keys[i] = succ_key self._delete(node.children[i + 1], succ_key) else: self._delete_merge(node, i) self._delete(node.children[i], key) def _delete_merge(self, node, i): t_val = self.t_val child = node.children[i] sibling = node.children[i + 1] child.keys.append(node.keys[i]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.keys.pop(i) node.children.pop(i + 1) def _get_predecessor(self, node, i): cur = node.children[i] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_successor(self, node, i): cur = node.children[i + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0]"},{"question":"# Question Title: Flatten Multi-Dimensional Arrays # Description You are given a multi-dimensional array (an array that may contain arrays as its elements). Your task is to write two functions: one that returns a flattened list and another that generates a flattened sequence. Both should convert the multi-dimensional array into a single-dimensional array. 1. **Function 1**: `flatten(input_list: List[Any]) -> List[Any]` - This function takes a multi-dimensional list `input_list` as input and returns a single-dimensional list. 2. **Function 2**: `flatten_yield(input_iterable: Iterable) -> Iterator[Any]` - This function takes a multi-dimensional iterable `input_iterable` as input and returns an iterator that yields elements in a flattened manner. # Input Format - For `flatten`: - `input_list` is a list which can contain elements of type `int`, `float`, `str`, or other lists of similar composition. - For `flatten_yield`: - `input_iterable` is an iterable which can contain elements of any iterable type (not just lists). # Output Format - For `flatten`: - Returns a single-dimensional list with all the elements in the same order. - For `flatten_yield`: - Yields elements in a flattened single-dimensional sequence. # Constraints - You should handle deeply nested structures. - The input will not necessarily be a list; it might contain other iterable types. - Ensure to handle large inputs efficiently. # Example ```python # Example Usage: # For flatten print(flatten([1, [2, [3, 4]], 5])) # Output: [1, 2, 3, 4, 5] # For flatten_yield print(list(flatten_yield([1, [2, [3, [\'a\', \'b\']]], 5]))) # Output: [1, 2, 3, \'a\', \'b\', 5] ``` # Additional Notes - You should use recursion for handling nested structures. - Use type checks to differentiate between an iterable and a non-iterable object. - Consider memory efficiency when dealing with large inputs.","solution":"from typing import List, Any, Iterable, Iterator def flatten(input_list: List[Any]) -> List[Any]: Flattens a multi-dimensional list into a single-dimensional list. Args: input_list : List[Any] : A list which can contain nested lists. Returns: List[Any] : A single-dimensional list. result = [] for element in input_list: if isinstance(element, list): result.extend(flatten(element)) # Recursively flatten the nested list else: result.append(element) return result def flatten_yield(input_iterable: Iterable) -> Iterator[Any]: Flattens a multi-dimensional iterable into a single-dimensional iterator. Args: input_iterable : Iterable : An iterable which can contain nested iterables. Returns: Iterator[Any] : An iterator yielding single-dimensional elements. for element in input_iterable: if hasattr(element, \'__iter__\') and not isinstance(element, (str, bytes)): yield from flatten_yield(element) # Recursively flatten the nested iterable else: yield element"},{"question":"# Encode and Decode Strings You are tasked with implementing two functions, `encode` and `decode`, to convert lists of strings into a single encoded string and back, respectively. This task simulates the scenario where these strings are sent over a network and need to be reconstructed accurately at the destination. Function Specifications 1. **encode** * **Input**: `List[str]` - A list of strings to encode. * **Output**: `str` - A single encoded string representation of the input list. 2. **decode** * **Input**: `str` - A single encoded string. * **Output**: `List[str]`- The original list of strings before encoding. Encoding and Decoding Format - Each string is encoded by prefixing it with its length followed by a delimiter `:` then the string itself. - For example, encoding `[\\"Hello\\", \\"World\\"]` results in `\\"5:Hello5:World\\"`. - Decoding follows the reverse process, extracting each string using the length prefix. Constraints - Strings consist of standard ASCII characters. - You can assume the length of the list and strings are within reasonable limits to avoid performance issues. Example ```python # Example original_list = [\\"Exam\\", \\"ple\\", \\"Strings\\"] encoded_string = encode(original_list) # \\"4:Exam3:ple7:Strings\\" decoded_list = decode(encoded_string) # [\\"Exam\\", \\"ple\\", \\"Strings\\"] ``` Implement the `encode` and `decode` functions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs ``` Ensure your implementations are efficient and handle edge cases gracefully.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str res = \'\' for string in strs: res += str(len(string)) + \\":\\" + string return res def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs = [] i = 0 while i < len(s): index = s.find(\\":\\", i) size = int(s[i:index]) strs.append(s[index+1: index+1+size]) i = index+1+size return strs"},{"question":"# Question: Detecting the First Node of a Cycle in a Linked List Given a linked list, your task is to implement a function `first_cyclic_node` that detects the first node of a cycle, if there is any cycle in the linked list. # Input - The input will be the head of a singly linked list. # Output - The output should be the node where the cycle begins. If there is no cycle, return `None`. # Constraints - The linked list can have any number of nodes (0 to N, where N can be large). - Nodes contain values which are unique for each node. - The linked list might not contain a cycle. # Performance Requirements - The solution must run in O(n) time complexity. - The solution must use O(1) space complexity. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): # your implementation goes here # Example to test your solution if __name__ == \'__main__\': # Creating a linked list: A -> B -> C -> D -> E -> C (cycle) head = Node(\'A\') head.next = Node(\'B\') cyclic_node = Node(\'C\') head.next.next = cyclic_node head.next.next.next = Node(\'D\') head.next.next.next.next = Node(\'E\') head.next.next.next.next.next = cyclic_node # Expected output: Node with value \'C\' print(first_cyclic_node(head).val) # Creating a linked list with no cycle: A -> B -> C -> D -> E head = Node(\'A\') head.next = Node(\'B\') head.next.next = Node(\'C\') head.next.next.next = Node(\'D\') head.next.next.next.next = Node(\'E\') # Expected output: None print(first_cyclic_node(head)) ``` # Additional Information - Consider handling edge cases like an empty linked list or a linked list with only one node. - Ensure your implementation does not modify the existing linked list structure.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head): Detects the first node of the cycle in the linked list if it exists. Returns the node where the cycle begins or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # Detect if a cycle exists using Floyd\'s cycle-finding algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle if not fast or not fast.next: return None # Find the entry point of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Objective You are tasked with implementing a secure Diffie-Hellman key exchange protocol. Specifically, you need to write functions to generate private keys, compute public keys and shared secrets, and verify the key exchange process. Function Signature You need to implement the following functions: 1. **generate_private_key(p: int) -> int**: Generates a private key in the range (1, p-1). 2. **generate_public_key(private_key: int, g: int, p: int) -> int**: Computes the public key using the private key, a primitive root g, and a prime number p. 3. **compute_shared_secret(public_key: int, private_key: int, p: int) -> int**: Computes the shared secret using the other party’s public key and own private key. Input/Output Format 1. **Function**: `generate_private_key` * **Input**: Single integer `p`, a large prime number. * **Output**: Integer `private_key` in the range (1, p-1). 2. **Function**: `generate_public_key` * **Input**: Three integers - `private_key`, `g`, and `p` (primitive root and prime). * **Output**: Integer `public_key`. 3. **Function**: `compute_shared_secret` * **Input**: Three integers - `public_key`, `private_key`, and `p`. * **Output**: Integer `shared_secret`. Constraints * (2 le p le 10^9) * (1 < g < p) * (1 < private_key < p) Performance Requirements * The prime number check should be efficient, i.e., within reasonable limits for p up to (10^9). * Use efficient computation techniques to handle large integers. Example Consider the parameters: * `p = 23` (a prime number) * `g = 5` (a primitive root of 23) # Steps: 1. Alice generates a private key using `generate_private_key(p)`, yielding `6`. 2. Alice computes her public key using `generate_public_key(6, 5, 23)`, yielding `8`. 3. Bob generates a private key using `generate_private_key(p)`, yielding `15`. 4. Bob computes his public key using `generate_public_key(15, 5, 23)`, yielding `19`. 5. Alice computes the shared secret using `compute_shared_secret(19, 6, 23)`, yielding `2`. 6. Bob computes the shared secret using `compute_shared_secret(8, 15, 23)`, yielding `2`. Both parties have computed the same shared secret, ensuring successful key exchange.","solution":"import random def generate_private_key(p: int) -> int: Generates a private key in the range (1, p-1). return random.randint(2, p-2) def generate_public_key(private_key: int, g: int, p: int) -> int: Computes the public key using the private key, a primitive root g, and a prime number p. return pow(g, private_key, p) def compute_shared_secret(public_key: int, private_key: int, p: int) -> int: Computes the shared secret using the other party’s public key and own private key. return pow(public_key, private_key, p)"},{"question":"# Coding Challenge: Advanced Word Dictionary You are tasked to implement an advanced word dictionary that supports adding words and searching for words, including literal words and words with a wildcard character `.` which can match any single letter. Objective Implement a class `WordDictionary` with the following methods: 1. `add_word(word: str) -> None`: Adds a word into the data structure. 2. `search(word: str) -> bool`: Searches for a word in the data structure, where the word can contain the `.` character to represent any one letter. Constraints * The word length will be between 1 and 500. * The total number of words in the dictionary will be between 1 and (10^4). Guidelines * Your solution should efficiently handle both addition and search operations even with the upper limit of constraints. * Consider edge cases such as searching for an empty string or strings with only wildcard characters. Expected Input and Output * `add_word(\\"hello\\")`: Adds the word \\"hello\\" to the dictionary. * `search(\\"hello\\")`: Returns `True`. * `search(\\"h.llo\\")`: Returns `True`. * `search(\\"he..o\\")`: Returns `True`. * `search(\\"helloo\\")`: Returns `False`. * `search(\\".\\")`: Returns `False` if no such single character word is added. Performance Requirement * Your solution should aim to be optimal in terms of both time and space complexity. * Explain any specific optimizations you\'ve applied to handle common performance bottlenecks. Example ```python word_dict = WordDictionary() word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") print(word_dict.search(\\"pad\\")) # Output: False print(word_dict.search(\\"bad\\")) # Output: True print(word_dict.search(\\".ad\\")) # Output: True print(word_dict.search(\\"b..\\")) # Output: True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: Adds a word into the data structure. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Searches for a word in the data structure. A word could contain the dot character \'.\' to represent any one letter. return self._search_recursive(word, 0, self.root) def _search_recursive(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_recursive(word, index + 1, child): return True return False else: if char not in node.children: return False return self._search_recursive(word, index + 1, node.children[char])"},{"question":"In this coding assessment, you will write two functions for Run-Length Encoding and Decoding. Your task is to implement the `encode_rle` and `decode_rle` functions that manage data compression and decompression using the run-length encoding algorithm. # Function Specifications - **Function 1**: `encode_rle(input_string: str) -> str` - **Input**: A string `input_string` to be encoded. - **Output**: The run-length encoded string. - **Constraints**: - The input string consists of ASCII characters. - The length of `input_string` is between 0 and 10^6. - **Example**: ```python encode_rle(\\"aaaabbbcc\\") # should return \\"4a3b2c\\" encode_rle(\\"abc\\") # should return \\"1a1b1c\\" encode_rle(\\"\\") # should return \\"\\" ``` - **Function 2**: `decode_rle(encoded_string: str) -> str` - **Input**: A string `encoded_string` which is run-length encoded. - **Output**: The original decoded string. - **Constraints**: - The `encoded_string` consists of characters where digits (1-9) specify counts followed by their corresponding characters. - The length of `encoded_string` is between 0 and 2*10^6, such that decompression results at most 10^6 characters. - **Example**: ```python decode_rle(\\"4a3b2c\\") # should return \\"aaaabbbcc\\" decode_rle(\\"1a1b1c\\") # should return \\"abc\\" decode_rle(\\"\\") # should return \\"\\" ``` # Requirements Ensure your implementation handles edge cases, such as empty strings or strings without repeating characters. The functions should be efficient to handle large inputs.","solution":"def encode_rle(input_string: str) -> str: Encodes the given string using Run-Length Encoding. if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_string.append(f\\"{count}{current_char}\\") return \\"\\".join(encoded_string) def decode_rle(encoded_string: str) -> str: Decodes the given Run-Length Encoded string to its original form. if not encoded_string: return \\"\\" decoded_string = [] count = 0 for char in encoded_string: if char.isdigit(): count = count * 10 + int(char) # in case of multi-digit counts else: decoded_string.append(char * count) count = 0 return \\"\\".join(decoded_string)"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure:** * **Name**: Decode String * **Type**: String Manipulation Algorithm, specifically a decoding algorithm using a stack. * **Purpose**: The purpose of this algorithm is to decode a string that has been encoded with a specific rule: k[encoded_string], where k is a positive integer representing the repeat count for the enclosed encoded string. **Complexity:** * **Time Complexity**: O(n), where n is the length of the input string. This is because we iterate through the input string once. * **Space Complexity**: O(m), where m is the number of encoded segments in the string. This accounts for the stack space utilized during the decoding process. **Principles:** * This algorithm uses a stack to keep track of characters and repeat counts. * It iterates through the string, pushing onto the stack when encountering an open bracket \'[\' and popping from the stack when encountering a close bracket \']\'. * The stack is used to construct the resulting decoded string by handling nested encoded segments. **Properties:** * **Decoding mechanism**: Handles nested encoded segments correctly. * **Stack-based approach**: Utilizes stack data structure to manage the nested encoded patterns. **Common Use Cases:** * Parsing nested repeat patterns in strings. * Decoding messages or data that have been compressed using repeated segments. **Strengths/Limitations:** * **Strengths**: Handles nested patterns effectively. The use of a stack provides a clean way to manage nested or hierarchical structures. * **Limitations**: The algorithm assumes that the input string is always well-formed and does not contain invalid patterns. **Implementation Challenges:** * **Edge Cases**: Handling deeply nested patterns, ensuring the stack is correctly managed with balanced brackets. * **Performance Bottlenecks**: If the input string is extremely long with complex nesting, performance could degrade due to memory usage. * **Error Scenarios**: Incorrect results if input does not strictly follow the pattern k[encoded_string]. * **Optimization Points**: Pre-processing the string to detect any immediate errors or invalid patterns before processing through the decoding stack. <|Analysis End|> <|Question Begin|> # Decoding Nested Encoded Strings Background: You are provided with an encoded string where the encoding rule is: `k[encoded_string]`. Here, `encoded_string` is being repeated exactly `k` times. You need to write a function that decodes this string according to the given rule. Input Format: * A single string `s` consisting of lowercase English letters, digits, and square brackets. The string is formatted correctly according to the encoding rules. Output Format: * A single string which is the decoded result of the input string. Function Signature: ```python def decode_string(s: str) -> str: ``` Constraints: * The input string `s` will always be well-formed. * Digits are only used to represent repeat numbers and are always positive integers. * The original data does not contain any digits, only for the repeat counts. Example: ```python Input: s = \\"3[a]2[bc]\\" Output: \\"aaabcbc\\" Input: s = \\"3[a2[c]]\\" Output: \\"accaccacc\\" Input: s = \\"2[abc]3[cd]ef\\" Output: \\"abcabccdcdcdef\\" ``` Requirements: 1. Implement a function that can handle large and complex strings efficiently. 2. Properly manage nested segments to ensure correct decoding. 3. Optimize for both time and space complexity. Good luck!","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_string) stack.append(current_num) current_string = \\"\\" current_num = 0 elif char == \']\': num = stack.pop() previous_string = stack.pop() current_string = previous_string + num * current_string else: current_string += char return current_string"},{"question":"You are given a non-empty string. Write a function `is_repeat_pattern(s: str) -> bool` to determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Signature: ```python def is_repeat_pattern(s: str) -> bool: pass ``` # Input * A single string `s` containing only lowercase English letters. * `1 <= len(s) <= 10^4` # Output * Return a boolean value `True` if the input string can be formed by repeating a substring of it, otherwise return `False`. # Examples ```python assert is_repeat_pattern(\\"abab\\") == True # \\"ab\\" + \\"ab\\" assert is_repeat_pattern(\\"aba\\") == False # No repeated pattern that constructs \\"aba\\" assert is_repeat_pattern(\\"abcabcabcabc\\") == True # \\"abc\\" + \\"abc\\" + \\"abc\\" + \\"abc\\" ``` # Constraints * You should strive to achieve a time complexity of O(n) and a space complexity of O(n). * Consider edge cases such as strings with only one character and strings with no repeating patterns. # Hints * Consider manipulating the string to assist in pattern detection without nested loops. * A helpful trick is to use the properties of string manipulation and re-evaluation in compact space. # Note Do not use built-in functions or third-party libraries that directly solve the problem as this task evaluates your fundamental understanding of string algorithms.","solution":"def is_repeat_pattern(s: str) -> bool: Determine if the string can be constructed by repeating a substring. # Ensure the string is not empty if not s: return False # Concatenate the string with itself and remove the first and last character doubled_s = (s + s)[1:-1] # If the original string is found in this new string, it means that # the original string is composed of repeating substrings of itself. return s in doubled_s"},{"question":"# Anagram Validation Given two strings `s` and `t`, write a function `is_anagram(s: str, t: str) -> bool` to determine if `t` is an anagram of `s`. Input/Output: - **Input**: - `s`: a string containing only lowercase alphabets. - `t`: a string containing only lowercase alphabets. - **Output**: - Return `True` if `t` is an anagram of `s`, `False` otherwise. Constraints: - The strings contain only lowercase alphabets (`a-z`). - You may assume the string length does not exceed 10^5 characters. Performance requirements: - The solution should run in linear time with respect to the length of strings (`O(n)`). Examples: **Example 1**: ```python Input: s = \\"anagram\\", t = \\"nagaram\\" Output: True ``` **Example 2**: ```python Input: s = \\"rat\\", t = \\"car\\" Output: False ``` Scenario: Consider that we are developing a system for a game where players need to check if the words they formed have the same character frequencies as the given word. Implement this function to aid the system in checking the validity of player submissions. **Function Signature**: ```python def is_anagram(s: str, t: str) -> bool: pass ```","solution":"def is_anagram(s: str, t: str) -> bool: Determines if t is an anagram of s. Args: s (str): The original string. t (str): The string to check if it is an anagram of s. Returns: bool: True if t is an anagram of s, False otherwise. from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Path Finding in Graphs Scenario **Scenario**: You have been tasked with implementing a navigation system that finds paths within a city\'s transportation network, represented as a graph. Your system needs to support three operations: locating any path from one place to another, finding all possible travel routes, and identifying the shortest path between two destinations. **Instructions**: You will be provided with a directed graph representing the city\'s transportation routes. Implement three functions to fulfill these requirements: 1. **`find_path(graph, start, end)`**: - **Input**: - `graph`: A dictionary where keys are node values and values are lists of adjacent nodes. - `start`: The start node. - `end`: The destination node. - **Output**: A list representing one valid path from `start` to `end`. Return None if no path exists. 2. **`find_all_path(graph, start, end)`**: - **Input**: - `graph`: A dictionary where keys are node values and values are lists of adjacent nodes. - `start`: The start node. - `end`: The destination node. - **Output**: A list of lists, each containing a valid path from `start` to `end`. Return an empty list if no paths exist. 3. **`find_shortest_path(graph, start, end)`**: - **Input**: - `graph`: A dictionary where keys are node values and values are lists of adjacent nodes. - `start`: The start node. - `end`: The destination node. - **Output**: A list representing the shortest path from `start` to `end`. Return None if no path exists. **Constraints**: - The graph will have no more than 10^3 nodes. - There may be cycles in the graph. - You can assume that node values are unique. Implement these functions and ensure they handle edge cases, such as disconnected nodes or graphs, single-node paths, and cycles.","solution":"from collections import deque def find_path(graph, start, end, path=None): Finds any path from start node to end node in the graph. if path is None: path = [] path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=None): Finds all paths from start node to end node in the graph. if path is None: path = [] path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end): Finds the shortest path from start node to end node in the graph. queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next in set(graph.get(vertex, [])) - set(path): if next == end: return path + [next] else: queue.append((next, path + [next])) return None"},{"question":"# Scenario You are hired by a software company to optimize sorting processes within their various applications. You decide to integrate Comb Sort for situations where a balance between simplicity and performance is necessary. You are assigned a task to implement Comb Sort with specific constraints to ensure reliability and performance. # Task Write a Python function `comb_sort(arr: List[int]) -> List[int]` that sorts a list of integers using the Comb Sort algorithm. # Specification * **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. * **Output**: A new list of integers sorted in non-decreasing order. # Example **Input**: `[5, 4, 3, 2, 1]` **Output**: `[1, 2, 3, 4, 5]` **Input**: `[10, -2, 33, 42, 0, -17, 6]` **Output**: `[-17, -2, 0, 6, 10, 33, 42]` # Constraints * Ensure that the function handles empty arrays correctly. * You may use any shrinking factor, but it must be above 1. * The function should have optimal performance for the provided input size. # Edge Cases to Consider * Duplicate elements * Single-element arrays * Already sorted arrays * Arrays with negative and positive integers Write your function without any additional imports and ensure it runs efficiently within the provided constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question: Advanced Greatest Common Divisor Calculation Context In number theory and various applications of computing, finding the greatest common divisor (GCD) and least common multiple (LCM) of two integer numbers is a frequent operation. These operations are fundamental in simplifying fractions, solving Diophantine equations, and in cryptographic algorithms. Task Given two non-negative integers `a` and `b`, implement three functions: 1. `gcd_bitwise(a, b)`: Computes the GCD using bitwise operations and handles errors gracefully. 2. `lcm(a, b)`: Computes the least common multiple of `a` and `b` ensuring the result is an integer and handles zero inputs properly. 3. `optimized_trailing_zero(x)`: Computes the number of trailing zeros in the binary representation of `x` ensuring the function handles edge cases effectively. Input and Output - **Function `gcd_bitwise(a, b)`**: * Input: Two non-negative integers `a` and `b`. * Output: A single integer representing the greatest common divisor. - **Function `lcm(a, b)`**: * Input: Two non-negative integers `a` and `b`. * Output: A single integer representing the least common multiple. - **Function `optimized_trailing_zero(x)`**: * Input: A non-negative integer `x`. * Output: A single integer representing the number of trailing zeros in the binary representation. Constraints * Both `a` and `b` will be in the range [0, 10^9]. * For `optimized_trailing_zero(x)` function, `x` will be in the range [0, 10^9]. Examples ```python # Example 1 print(gcd_bitwise(48, 18)) # Output: 6 print(lcm(48, 18)) # Output: 144 print(optimized_trailing_zero(40)) # Output: 3 # Example 2 print(gcd_bitwise(0, 6)) # Output: 6 print(lcm(0, 6)) # Output: 0 print(optimized_trailing_zero(17)) # Output: 0 ``` Additional Requirements * Ensure that the `gcd_bitwise` function raises a `ValueError` if both inputs are zero. * Ensure that the `optimized_trailing_zero` function correctly handles the edge case where the input is zero.","solution":"def gcd_bitwise(a, b): Compute the greatest common divisor (GCD) using bitwise operations. Args: a (int): First non-negative integer. b (int): Second non-negative integer. Returns: int: The GCD of a and b. Raises: ValueError: If both a and b are zero. if a == 0 and b == 0: raise ValueError(\\"GCD is not defined for both a and b being zero\\") if a == 0: return b if b == 0: return a # Finding common factors of 2 shift = 0 while (((a | b) & 1) == 0): a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm(a, b): Compute the least common multiple (LCM) of two integers. Args: a (int): First non-negative integer. b (int): Second non-negative integer. Returns: int: The LCM of a and b. if a == 0 or b == 0: return 0 gcd = gcd_bitwise(a, b) return abs(a * b) // gcd def optimized_trailing_zero(x): Compute the number of trailing zeros in the binary representation of x. Args: x (int): Non-negative integer. Returns: int: The number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: count += 1 x >>= 1 return count"},{"question":"You are tasked with designing and implementing an advanced and efficient Separate Chaining Hash Table capable of supporting the following operations with enhanced functionalities: 1. Insert a key-value pair. 2. Retrieve the value for a given key. 3. Remove a key-value pair. 4. Dynamically resize the hash table when the load factor exceeds a threshold. Requirements: 1. **Function Definitions**: - `def put(self, key, value):` - Insert a key-value pair into the hash table. - `def get(self, key):` - Retrieve the value for a given key. - `def del_(self, key):` - Remove the key-value pair for a given key. - `def resize(self, new_size):` - Change the size of the hash table and rehash all elements. 2. **Input and Output**: - `put(key, value)`: - Input: `key` (string), `value` (any data type) - Output: None - `get(key)`: - Input: `key` (string) - Output: Value associated with the key, or `None` if the key does not exist. - `del_(key)`: - Input: `key` (string) - Output: None - `resize(new_size)`: - Input: `new_size` (integer) - Output: None 3. **Constraints**: - Implement resizing when the load factor exceeds 0.75. - The hash table should start with a default size of 11. 4. **Performance**: - Maintain average O(1) operations for `put`, `get`, and `del_` under load factor constraints. - Ensure no performance degradation due to poor hash distribution by choosing an efficient hash function. # Example Usage: ```python table = SeparateChainingHashTable() table.put(\'a\', \'apple\') table.put(\'b\', \'banana\') print(table.get(\'a\')) # Output should be \'apple\' table.del_(\'a\') print(table.get(\'a\')) # Output should be None for i in range(20): table.put(str(i), i) # Verify resizing has taken place print(table.size > 11) # Output should be True, indicating table resize ``` Implement the `SeparateChainingHashTable` class with the described enhancements and functionalities. Ensure to handle edge cases, optimize hash function choice, and manage memory efficiently.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11): self.size = initial_size self.table = [[] for _ in range(self.size)] self.count = 0 self.load_factor_threshold = 0.75 def put(self, key, value): if self.count / self.size > self.load_factor_threshold: self.resize(self.size * 2) index = self._hash(key) bucket = self.table[index] for kvp in bucket: if kvp[0] == key: kvp[1] = value return bucket.append([key, value]) self.count += 1 def get(self, key): index = self._hash(key) bucket = self.table[index] for kvp in bucket: if kvp[0] == key: return kvp[1] return None def del_(self, key): index = self._hash(key) bucket = self.table[index] for i, kvp in enumerate(bucket): if kvp[0] == key: del bucket[i] self.count -= 1 return def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(self.size)] self.count = 0 for bucket in old_table: for kvp in bucket: self.put(kvp[0], kvp[1]) def _hash(self, key): return hash(key) % self.size"},{"question":"# Binary Search Implementation Description Given a sorted array of integers in non-decreasing order, implement a function to find the index of a given target value using an iterative approach. If the target value is not present, return -1. Your implementation should efficiently handle large datasets and edge cases described. Function Signature ```python def binary_search_iterative(array: List[int], target: int) -> int: :param array: List[int] - A sorted array of integers. :param target: int - The integer value to search for in the array. :return: int - The index of the target value in the array if present, otherwise -1. ``` Input * `array` (List[int]): A sorted list of integers. * `target` (int): The integer value to search for. Output * `int`: The index of the target value if it exists, otherwise -1. Constraints * The length of `array` (n) will be in the range [0, 10^6]. * Each element in `array` will be in the range [-10^9, 10^9]. * `array` is sorted in non-decreasing order. * The `target` value will also be in the range [-10^9, 10^9]. Performance Requirements * The solution must have a time complexity of O(log(n)). Example ```python # Example 1 array = [1, 2, 3, 4, 5, 6, 7] target = 4 assert binary_search_iterative(array, target) == 3 # Example 2 array = [1, 2, 3, 4, 5, 6, 7] target = 10 assert binary_search_iterative(array, target) == -1 ``` Note * Think about edge cases such as an empty array, an array with one element, or when the target is not present in the array.","solution":"def binary_search_iterative(array, target): Performs an iterative binary search on a sorted array to find the target. :param array: List[int] - A sorted array of integers. :param target: int - The integer value to search for in the array. :return: int - The index of the target value in the array if present, otherwise -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Longest Substring Without Repeating Characters Scenario You are developing a text editor that helps users identify and highlight the longest block of unique characters from any given text. For instance, the editor might help writers identify the longest segment of unique characters in a paragraph to help analyze and refine their writing style. Task Write a function named `get_longest_unique_substring` that takes a single string input and returns the longest substring within that string that contains all unique characters. Function Signature ```python def get_longest_unique_substring(string: str) -> Tuple[int, str]: pass ``` Input * `string`: A string `s` which may include uppercase and lowercase letters, digits, and special characters. The length of the string will be in the range `[0, 10^5]`. Output * The function should return a tuple (`max_len`, `substring`) where: * `max_len` is the length of the longest substring with all unique characters. * `substring` is the longest substring with all unique characters. Example ```python assert get_longest_unique_substring(\\"abcabcbb\\") == (3, \\"abc\\") assert get_longest_unique_substring(\\"bbbbb\\") == (1, \\"b\\") assert get_longest_unique_substring(\\"pwwkew\\") == (3, \\"wke\\") assert get_longest_unique_substring(\\"\\") == (0, \\"\\") assert get_longest_unique_substring(\\"abcdef\\") == (6, \\"abcdef\\") ``` Constraints * Your algorithm must run in O(n) time complexity. * Use only O(min(n, m)) additional space, where `n` is the length of the string and `m` is the size of the character set. Note Be sure to consider edge cases such as: * Empty string (`\\"\\"`). * Strings where all characters in the string are the same. * Strings where each character in the string is unique. # Additional Information You can use dictionaries, sets, or any other data structure of your choice to achieve the desired functionality, but ensure that the solution is optimal and runs within the given constraints.","solution":"from typing import Tuple def get_longest_unique_substring(string: str) -> Tuple[int, str]: char_index_map = {} start, max_len, longest_substr = 0, 0, \\"\\" for i, char in enumerate(string): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len longest_substr = string[start:i+1] return max_len, longest_substr"},{"question":"Problem Statement You are tasked to implement two functions for converting numbers between various bases. Your functions should handle both positive and negative integers for conversion from integer to base, and handle both uppercase and lowercase letters in the input string for conversion from base to integer. 1. `int_to_base(num: int, base: int) -> str`: Converts an integer `num` to its base `base` string representation. 2. `base_to_int(str_to_convert: str, base: int) -> int`: Converts a string `str_to_convert` representing a number in base `base` to its integer form. Input and Output Format 1. `int_to_base(num: int, base: int) -> str` - **Input**: - `num`: An integer (`-10^6 <= num <= 10^6`). - `base`: An integer indicating the base (`2 <= base <= 36`). - **Output**: A string representing the number in the specified base. 2. `base_to_int(str_to_convert: str, base: int) -> int` - **Input**: - `str_to_convert`: A string representing the number in the specified base. - `base`: An integer indicating the base (`2 <= base <= 36`). - **Output**: An integer representation of the base number. Constraints * The input `num` will be within the range `-10^6 <= num <= 10^6`. * The input `base` will be within the range `2 <= base <= 36`. * The string `str_to_convert` will only contain valid characters for the given base. * Perform the conversion with the smallest space and time complexity possible. Example 1. `int_to_base(5, 2)` returns `\'101\'` 2. `int_to_base(-10, 16)` returns `\'-A\'` 3. `base_to_int(\'F\', 16)` returns `15` 4. `base_to_int(\'101\', 2)` returns `5` 5. `base_to_int(\'aB\', 16)` returns `171` (case insensitive) Additional Notes * For conversion functions, the character set includes digits `0-9` and letters `A-Z` (uppercase). * For handling negative numbers, a `-` should be prepended in the result string for `int_to_base`. * You must consider both uppercase and lowercase letters for `base_to_int`. Ready to test your understanding and implementation skills in base conversion? Go ahead and write the functions `int_to_base` and `base_to_int` carefully handling the edge cases and constraints!","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer `num` to its base `base` string representation. if num == 0: return \'0\' negative = num < 0 num = abs(num) digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" while num > 0: remainder = num % base result = digits[remainder] + result num = num // base if negative: result = \'-\' + result return result def base_to_int(str_to_convert: str, base: int) -> int: Converts a string `str_to_convert` representing a number in base `base` to its integer form. str_to_convert = str_to_convert.upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {ch: idx for idx, ch in enumerate(digits)} negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: result = result * base + digit_map[char] if negative: result = -result return result"},{"question":"# Ternary Search Implementation Challenge Problem Statement: You are given a sorted array of integers and a target value (key). Your task is to implement the ternary search algorithm to find the index of the target value in the array. The function should have the following signature: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` Input: * `left` (int): Starting index of the search range (usually 0). * `right` (int): Ending index of the search range (usually n-1, where n is the size of the array). * `key` (int): The target integer value to search for. * `arr` (List[int]): A list of integers sorted in ascending order. Output: * (int): The index of the target value if found; otherwise, return -1. Constraints: * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i], key <= 10^9, for any valid i. Scenario: Imagine you are building an efficient search engine component that needs to locate specific entries in very large datasets. Implementing a fast search algorithm such as ternary search can significantly improve the search performance. Example: ```python assert ternary_search(0, 6, 23, [1, 4, 5, 8, 10, 19, 23]) == 6 assert ternary_search(0, 6, 7, [1, 4, 5, 8, 10, 19, 23]) == -1 assert ternary_search(0, 0, 1, [1]) == 0 assert ternary_search(0, 4, 10, [-10, -5, 0, 5, 10]) == 4 ``` Notes: * Ensure optimized performance for large inputs. * Consider edge cases where the array might be empty or contain just one element. * Optimize mid-point calculations to avoid inefficiencies. Good luck and happy coding!","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on a sorted list of integers. Parameters: left (int): Starting index of the search range. right (int): Ending index of the search range. key (int): The target integer value to search for. arr (List[int]): A list of integers sorted in ascending order. Returns: int: The index of the target value if found; otherwise, return -1. while left <= right: third1 = left + (right - left) // 3 third2 = right - (right - left) // 3 if arr[third1] == key: return third1 if arr[third2] == key: return third2 if key < arr[third1]: right = third1 - 1 elif key > arr[third2]: left = third2 + 1 else: left = third1 + 1 right = third2 - 1 return -1"},{"question":"# Combinatorial Calculation with Memoization You are given the task of computing the number of ways to choose `r` items from `n` items, often written as `nCr`. This combinatorial number is defined as: [ C(n, r) = frac{n!}{r! times (n - r)!} ] However, your challenge is to implement this using recursive methods and memoization to optimize the calculations. # Task Implement the function `combination_memo(n, r)` that computes `nCr` using the principles of Pascal\'s Triangle and memoization. Your function should be optimized to handle larger values efficiently. # Function Signature ```python def combination_memo(n: int, r: int) -> int: # implementation here ``` # Input - **`n`** (integer): A non-negative integer representing the total number of items. - **`r`** (integer): A non-negative integer representing the number of items to choose. # Output - **integer**: The number of combinations (`nCr`). # Constraints - Assume `0 <= r <= n <= 50` for practicality in recursion depth and dictionary size. # Examples 1. `combination_memo(5, 2)` should return `10`. 2. `combination_memo(6, 3)` should return `20`. 3. `combination_memo(10, 0)` should return `1`. # Notes - Consider edge cases like when `r` is `0` or equal to `n`. - Avoid deep recursion inefficiencies using memoization. - Think of potential ways to optimize storage if facing limits of memory. # Scenario Imagine you\'re designing a combinatorial game where players need to calculate various combination possibilities quickly. Your function will be part of the core logic to ensure quick and efficient game computations.","solution":"def combination_memo(n, r, memo={}): Compute nCr using recursion and memoization. :param n: Total number of items :param r: Number of items to choose :param memo: Dictionary to store computed values :return: Integer representing nCr # Base cases if r == 0 or r == n: return 1 if r == 1: return n # Check if value is already computed if (n, r) in memo: return memo[(n, r)] # Compute value using Pascal\'s triangle identity memo[(n, r)] = combination_memo(n - 1, r - 1, memo) + combination_memo(n - 1, r, memo) return memo[(n, r)]"},{"question":"# Coding Challenge You are provided with a binary tree node class `TreeNode` and two functions `serialize` and `deserialize`. 1. **TreeNode class**: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ``` 2. **serialize function**: ```python def serialize(root): def build_string(node): if node: vals.append(str(node.val)) build_string(node.left) build_string(node.right) else: vals.append(\\"#\\") vals = [] build_string(root) return \\" \\".join(vals) ``` 3. **deserialize function**: ```python def deserialize(data): def build_tree(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree() ``` # Your Task Given the above implementations of `serialize` and `deserialize`, you need to implement an additional function to validate the integrity of the serialization and deserialization process. Write a function `is_serialization_correct(root)` that: - Takes as input the root of a binary tree. - Serializes the tree. - Deserializes the resulting string back to a binary tree. - Checks if the newly deserialized tree is structurally identical to the original tree. - Returns `True` if the trees are identical, `False` otherwise. # Function Signature ```python def is_serialization_correct(root: TreeNode) -> bool: ``` # Input - `root`: A `TreeNode` which is the root of a binary tree. # Output - A boolean (`True` or `False`). # Constraints - The number of nodes in the binary tree is between `0` and `10^4`. - Each node\'s value is an integer between `-10^9` and `10^9`. # Example ```python # Example binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Validate serialization and deserialization result = is_serialization_correct(root) print(result) # Output: True ``` # Note When implementing `is_serialization_correct`, consider edge cases such as trees with only one node, fully balanced trees, and highly unbalanced trees. Make sure your implementation checks the structural integrity of both trees thoroughly.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): def build_string(node): if node: vals.append(str(node.val)) build_string(node.left) build_string(node.right) else: vals.append(\\"#\\") vals = [] build_string(root) return \\" \\".join(vals) def deserialize(data): def build_tree(): val = next(vals) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree() node.right = build_tree() return node vals = iter(data.split()) return build_tree() def is_serialization_correct(root): def is_same_tree(node1, node2): if not node1 and not node2: return True if node1 and node2: return (node1.val == node2.val and is_same_tree(node1.left, node2.left) and is_same_tree(node1.right, node2.right)) return False serialized = serialize(root) deserialized = deserialize(serialized) return is_same_tree(root, deserialized)"},{"question":"Scenario You are required to develop a customized data structure for a game that requires managing a dynamic set of players where players can join, leave, and a random player can be selected at any given moment for a special event. The goal is to make sure that all operations (add, remove, and pick random) occur in average O(1) time. Task Implement a `PlayerSet` class that supports the following operations: 1. `add_player(player_id)` - Adds a player to the set if not already present. 2. `remove_player(player_id)` - Removes a player from the set if present. 3. `select_random_player()` - Returns a random player\'s ID from the current set. Each player should have the same probability of being chosen. Input/Output Format * **Input**: * For `add_player(player_id)`: `player_id` (int) - A unique identifier for a player. * For `remove_player(player_id)`: `player_id` (int) - The unique identifier of the player to be removed. * **Output**: * For `select_random_player()`: `player_id` (int) - The unique identifier of the randomly chosen player. Constraints * Player ID (player_id) is a non-negative integer. * There will be at least one player in the set when `select_random_player` is called. Example ```python pset = PlayerSet() pset.add_player(1) pset.add_player(2) pset.add_player(3) pset.remove_player(2) print(pset.select_random_player()) # Possible outputs: 1 or 3 ``` Requirements 1. Implement the `PlayerSet` class with the specified methods. 2. Ensure that all operations achieve average O(1) time complexity. 3. Handle edge cases such as re-adding an existing player or attempting to remove a non-existing player.","solution":"import random class PlayerSet: def __init__(self): self.players = [] self.player_map = {} def add_player(self, player_id): if player_id not in self.player_map: self.players.append(player_id) self.player_map[player_id] = len(self.players) - 1 def remove_player(self, player_id): if player_id in self.player_map: last_player_id = self.players[-1] idx_to_remove = self.player_map[player_id] self.players[idx_to_remove] = last_player_id self.player_map[last_player_id] = idx_to_remove self.players.pop() del self.player_map[player_id] def select_random_player(self): return random.choice(self.players)"},{"question":"Scenario You are given the task of developing a feature for a search engine to quickly find articles that are closest in relevance score to a given search score. For simplicity, relevance scores are stored in a balanced Binary Search Tree (BST) where each node holds a relevance score. Your goal is to find the relevance score in the BST that is closest to the given search score. Problem Statement Given a non-empty Binary Search Tree (BST) and a target float value representing the search score, write a function `closest_value` that returns the value in the BST that is closest to the target. Your solution should efficiently utilize the properties of BSTs to minimize the search time. Function Signature ```python def closest_value(root: TreeNode, target: float) -> int: # Implement your solution here ``` Input * `root` (TreeNode): The root node of a non-empty BST where each node contains an integer value representing the relevance score. * `target` (float): The target relevance score. Output * Returns the integer value in the BST that is closest to the target value. Constraints * The BST is guaranteed to be non-empty. * Each relevance score is unique. * The target is a floating-point number. Examples ```python # Example 1: # Input: root = [4, 2, 5, 1, 3], target = 3.714286 # 4 # / # 2 5 # / # 1 3 # Output: 4 # Example 2: # Input: root = [1], target = 4.428571 # 1 # Output: 1 ``` Edge Cases * A single-node tree. * Target value much smaller than the smallest node or much larger than the largest node. * Target value exactly matching a node value in the tree. Hints * Leverage the properties of the BST to avoid unnecessary comparisons. * Think about whether an iterative approach may be more beneficial to handle larger trees. Good luck and happy coding!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: closest = root.val current = root while current: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left else: current = current.right return closest"},{"question":"# Square Root Approximation Function Background You are tasked with creating a function which computes the square root of a positive integer (N) with a maximum absolute error of (P) using the Newton-Raphson method. The method uses iterative approximations to refine the guess closer to the actual square root. The Newton-Raphson formula for updating the guess is given by: [ text{guess} = frac{text{guess} + frac{N}{text{guess}}}{2} ] Task Write a function `approximate_sqrt(n: int, p: float) -> float` that computes and returns the approximate square root of (N) with an error not exceeding (P). Parameters - **n (int)**: A positive integer (N) whose square root needs to be approximated. - **p (float)**: A float (P) denoting the maximum acceptable error in the approximation. Output - **float**: The approximate square root of (N) with an error not exceeding (P). Constraints - (1 leq n leq 10^9) - (0 < p leq 0.1) Performance Requirements The solution should be efficient and converge quickly even for large values of (N). Example ```python approximate_sqrt(2, 0.001) -> A value between 1.413 and 1.415 approximate_sqrt(10, 0.01) -> A value between 3.14 and 3.16 ``` Notes - Ensure to handle the edge case where (N = 0) separately. - Consider an initial guess carefully to optimize convergence speed. Implement the function `approximate_sqrt`.","solution":"def approximate_sqrt(n: int, p: float) -> float: Computes and returns the approximate square root of n with an error not exceeding p using the Newton-Raphson method. if n == 0: return 0.0 guess = n / 2.0 # Initial guess can be n / 2 while True: next_guess = (guess + n / guess) / 2.0 if abs(guess - next_guess) < p: return next_guess guess = next_guess"},{"question":"You are working on a project that requires frequent conversion of numbers between different numeral systems. To ensure your system can handle these conversions efficiently, you need to implement the following functions: 1. **int_to_base**: This function converts a given integer from base 10 (decimal) to another specified base (between 2 and 36). 2. **base_to_int**: This function converts a number from a specified base (between 2 and 36) to base 10 (decimal). Function Requirements: 1. **int_to_base(num, base)**: - **Input**: - `num` (int): The number in base 10 to convert. - `base` (int): The base to convert the number to (between 2 and 36). - **Output**: - (str): The string representation of `num` in the specified base. - **Examples**: - `int_to_base(5, 2)` returns `\'101\'`. - `int_to_base(-8, 16)` returns `\'-8\'`. 2. **base_to_int(str_to_convert, base)**: - **Input**: - `str_to_convert` (str): The string representation of the number to convert. - `base` (int): The base of the input string (between 2 and 36). - **Output**: - (int): The integer value of the input string in base 10. - **Examples**: - `base_to_int(\'F\', 16)` returns `15`. - `base_to_int(\'-101\', 2)` returns `-5`. Constraints: - The base `b` is always in the range [2, 36]. - The input number for `int_to_base` is an integer (which can be negative). - The input string for `base_to_int` consists of valid characters in the given base, but can include a negative sign for negative numbers. Provide efficient implementations for both functions while considering edge cases and performance.","solution":"def int_to_base(num, base): Convert an integer from base 10 to a specified base (between 2 and 36). if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' negative = num < 0 num = abs(num) digits = \'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\' result = \'\' while num > 0: result = digits[num % base] + result num //= base if negative: result = \'-\' + result return result def base_to_int(str_to_convert, base): Convert a number from a specified base (between 2 and 36) to base 10. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") return int(str_to_convert, base)"},{"question":"# Question: Implement and Analyze Enhanced Stooge Sort You are tasked with implementing a modified (or enhanced) version of the Stooge Sort algorithm. The enhancement should improve its performance over the original while maintaining its recursive nature. You are required to demonstrate your understanding of both the Stooge Sort and the enhancements you choose to implement. Requirements: 1. Implement the initial Stooge Sort algorithm as described. 2. Propose and implement at least one enhancement to improve the performance of the standard Stooge Sort. 3. Analyze the performance of both the original and the enhanced versions in terms of time complexity. 4. Ensure proper error and edge case handling. Input and Output: - **Input**: A list of integers `arr` and two integer indices `l` and `h` (`0 <= l <= h < len(arr)`). - **Output**: A sorted list of integers. Constraints: - The input indices should always lie within the bounds of the list. - You should aim to minimize the number of comparisons and recursive calls. Performance: - Provide a brief analysis of the performance improvements achieved with your enhancement. # Example: ```python # Original Stooge Sort def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h-t) stoogesort(arr, l+t, h) stoogesort(arr, l, h-t) # Enhanced Stooge Sort - Example Enhancement Included for Reference def enhanced_stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h-t) enhanced_stoogesort(arr, l+t, h) enhanced_stoogesort(arr, l, h-t) # Example array arr = [1, 3, 64, 5, 7, 8] n = len(arr) # Original Stooge Sort stoogesort(arr, 0, n-1) print(arr) # Sorted array # Enhanced Stooge Sort enhanced_stoogesort(arr, 0, n-1) print(arr) # Sorted array ``` Write your implementation for both original Stooge Sort and the enhanced version with the analysis of performance improvement.","solution":"def stoogesort(arr, l, h): Original Stooge Sort algorithm. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) def enhanced_stoogesort(arr, l, h): Enhanced Stooge Sort algorithm with reduced recursion. while l < h: if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h - t) l = l + t else: break"},{"question":"# OrderedStack Implementation and Usage Context You have been provided with an `OrderedStack` class designed to maintain its elements in an ordered fashion, such that the highest value is at the top and the lowest is at the bottom. Your task is to complete and utilize this class and then extend its functionality. Task 1. Implement the function `get_min()` in the `OrderedStack` class, which returns the smallest element in the stack without modifying it. 2. Write a function `sort_stack_descending(stack)`, which takes an `OrderedStack` instance and returns a new `OrderedStack` with elements sorted in descending order (from highest at the bottom to lowest at the top). Function Specifications * **Function 1**: `get_min(self)` * **Input**: None (this is a method of the `OrderedStack` class). * **Output**: Returns the smallest element in the stack. * **Function 2**: `sort_stack_descending(stack)` * **Input**: An instance of `OrderedStack`. * **Output**: A new instance of `OrderedStack` with elements sorted in descending order. Constraints * The stack will contain integers. * You may assume the stack will not contain duplicate elements for this task. * You must not use any additional external data structures except the ones implemented within the methods. Examples ```python # Example for `get_min()` stack = OrderedStack() stack.push(3) stack.push(1) stack.push(2) print(stack.get_min()) # Output: 1 # Example for `sort_stack_descending(stack)` stack = OrderedStack() stack.push(10) stack.push(5) stack.push(20) sorted_desc_stack = sort_stack_descending(stack) print(sorted_desc_stack.pop()) # Output: 5 print(sorted_desc_stack.pop()) # Output: 10 print(sorted_desc_stack.pop()) # Output: 20 ``` Write the functions and ensure they are thoroughly tested against various edge cases.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.stack: return None return self.stack.pop() def peek(self): if not self.stack: return None return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def get_min(self): Returns the smallest element in the stack without modifying it. if self.is_empty(): return None return min(self.stack) def sort_stack_descending(stack): Returns a new OrderedStack instance with elements sorted in descending order (highest at the bottom, lowest at the top). temp_stack = OrderedStack() temp_stack.stack = sorted(stack.stack, reverse=True) return temp_stack"},{"question":"# Separate Chaining Hash Table Extensions You have recently studied the implementation of a hash table using separate chaining to handle collisions. Now, extend this hash table to handle the following new requirements: 1. **Rehashing**: Implement automatic resizing of the hash table when the load factor surpasses a given threshold. 2. **Load Factor Calculation**: Implement a method to calculate and return the current load factor of the hash table. 3. **Iterators for keys and values**: Provide methods to iterate over all keys and values in the hash table. Input/Output Formats Implement the following additional methods in the `SeparateChainingHashTable` class: 1. **resize(self, new_size)**: Method to resize the underlying array to `new_size`. Rehash all current keys. 2. **load_factor(self)**: Method to return the current load factor, calculated as the number of key-value pairs divided by the size of the hash table. 3. **keys(self)**: Method to return an iterator over all keys in the hash table. 4. **values(self)**: Method to return an iterator over all values in the hash table. Constraints * Start with a hash table size of 11. * Resize the hash table to twice its current size when the load factor exceeds 0.75. * The hash function used can remain the same. # Example: ```python table = SeparateChainingHashTable() table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') table.put(\'key3\', \'value3\') ... table.resize(23) # Ensure all keys are rehashed and transferred to a larger table. lf = table.load_factor() # Returns the load factor. keys = list(table.keys()) # Returns a list of all current keys. values = list(table.values()) # Returns a list of all current values. ``` Performance Requirements * Ensure that rehashing and resizing are handled efficiently. * Ensure that retrieving the load factor, keys, and values operates in O(n) time complexity. Implement these methods in your hash table implementation and ensure your class passes all the provided unittests.","solution":"class SeparateChainingHashTable: def __init__(self, initial_size=11): self.size = initial_size self.buckets = [[] for _ in range(self.size)] self.num_elements = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): hash_index = self._hash(key) for pair in self.buckets[hash_index]: if pair[0] == key: pair[1] = value return self.buckets[hash_index].append([key, value]) self.num_elements += 1 if self.load_factor() > 0.75: self.resize(self.size * 2) def get(self, key): hash_index = self._hash(key) for pair in self.buckets[hash_index]: if pair[0] == key: return pair[1] def remove(self, key): hash_index = self._hash(key) for i, pair in enumerate(self.buckets[hash_index]): if pair[0] == key: self.num_elements -= 1 return self.buckets[hash_index].pop(i) def resize(self, new_size): old_buckets = self.buckets self.size = new_size self.buckets = [[] for _ in range(self.size)] self.num_elements = 0 for bucket in old_buckets: for pair in bucket: self.put(pair[0], pair[1]) def load_factor(self): return self.num_elements / self.size def keys(self): for bucket in self.buckets: for pair in bucket: yield pair[0] def values(self): for bucket in self.buckets: for pair in bucket: yield pair[1]"},{"question":"# Task Write a Python function `custom_exchange_sort` that sorts a list of tuples based on the second element of each tuple. If the second elements are the same, the tuples should be sorted based on the first element. Test your function with various edge cases. # Function Signature ```python def custom_exchange_sort(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ``` # Input * `tuples_list` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers. # Output * Returns a list of tuples sorted based on the criteria mentioned above. # Constraints * The input list will have at most 10^3 tuples. * Each integer in the tuples will be between -10^6 and 10^6. # Example ```python custom_exchange_sort([(1, 2), (3, 1), (4, 2), (2, 3)]) # Output: [(3, 1), (1, 2), (4, 2), (2, 3)] custom_exchange_sort([(7, 1), (3, 0), (3, 1), (0, 2)]) # Output: [(3, 0), (3, 1), (7, 1), (0, 2)] custom_exchange_sort([(1, 2), (2, 2), (3, 2)]) # Output: [(1, 2), (2, 2), (3, 2)] ``` # Scenario You are tasked with creating a custom sorting function for a logistics company where the tuples represent (ID, priority). The company wants to sort their operations based on priority, and in case of the same priority, by the ID to ensure a consistent schedule.","solution":"from typing import List, Tuple def custom_exchange_sort(tuples_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts a list of tuples based on the second element of each tuple. If the second elements are the same, the tuples are sorted based on the first element. Args: tuples_list: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers. Returns: List[Tuple[int, int]]: A list of tuples sorted based on the criteria mentioned above. return sorted(tuples_list, key=lambda x: (x[1], x[0]))"},{"question":"Balanced Binary Tree Check Objective Implement a function to determine if a given binary tree is height-balanced. The tree is height-balanced if the depth of the two subtrees of every node never differs by more than one. Function Signature ```python def is_balanced(root): pass ``` Input * `root` (TreeNode): The root node of the binary tree. Output * Return `True` if the tree is height-balanced, otherwise return `False`. Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * -10^5 <= Node.val <= 10^5 Examples 1. Given the binary tree: ``` 3 / 9 20 / 15 7 ``` The function should return `True`. 2. Given the binary tree: ``` 1 / 2 / 3 / 4 / 5 ``` The function should return `False`. Notes * You should ensure your solution has a time complexity of O(N), where N is the number of nodes in the tree. * Be mindful of edge cases such as an empty tree or skewed trees. * You do not need to handle input parsing (assume TreeNode class is predefined). Scenario In a system maintaining AVL trees or any balanced binary search tree, it is crucial to quickly ascertain the tree\'s balance status to enforce balanced property maintenance. Implementing this efficient algorithm ensures operational efficiency in such systems.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if a binary tree is height-balanced. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is height-balanced, False otherwise. def check_height(node): if not node: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, result = check_height(root) return result"},{"question":"# Context: You have been recruited by a cryptography firm to develop a primality testing function. This is crucial for generating large prime numbers, which are foundational in cryptographic algorithms. Your task is to implement the probabilistic Rabin-Miller Primality Test to determine whether a given number is \\"probably prime.\\" # Task: Write a function `rabin_miller_prime(n: int, k: int) -> bool` that implements the Rabin-Miller algorithm as described below. # Parameters: - **n** (int): The number to test for primality. - **k** (int): The number of rounds to test; higher `k` means a more accurate result but increased time complexity. # Returns: - **bool**: Returns `True` if `n` is probably prime with a high degree of confidence, `False` if `n` is definitely composite. # Constraints: - `n` >= 2 - `1 <= k <= 100` # Requirements: - Handle small values of `n` correctly (e.g., `n` < 5). - Ensure random bases are chosen well within the specified range. - Avoid obvious performance bottlenecks. # Example: ```python print(rabin_miller_prime(31, 5)) # Expected: True, 31 is a prime number. print(rabin_miller_prime(18, 5)) # Expected: False, 18 is a composite number. ``` # Note: - Ensure your function handles edge cases effectively. - Optimize your code for performance, especially for large values of `n`.","solution":"import random def rabin_miller_prime(n: int, k: int) -> bool: Rabin-Miller primality test. Parameters: - n (int): The number to test for primality. - k (int): The number of rounds to test; higher k means more accurate result. Returns: - bool: True if n is probably prime, False if n is definitely composite. if n == 2 or n == 3: return True if n % 2 == 0 or n < 2: return False # Write n-1 as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"You are tasked with implementing a function that efficiently finds the maximum elements of each sub-array of a specified length (k) from a given list of integers. Your solution should leverage the sliding window technique and a deque (double-ended queue) for optimal performance. # Function Signature ```python def max_sliding_window(nums: List[int], k: int) -> List[int]: ``` # Input - `nums`: A list of integers `nums` with (n) elements where (1 leq n leq 10^5) - `k`: An integer, the size of the sliding window where (1 leq k leq n) # Output - A list of integers representing the maximum elements of each sliding window of length (k). # Constraints - Ensure that your solution can handle the maximum constraint efficiently. - Consider edge cases such as when `nums` is empty or `k` is larger than the length of the list. # Example ```python # Example 1 nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 max_sliding_window(nums, k) # Output: [3, 3, 5, 5, 6, 7] # Example 2 nums = [9, 11] k = 2 max_sliding_window(nums, k) # Output: [11] # Example 3 nums = [4, -2] k = 2 max_sliding_window(nums, k) # Output: [4] ``` # Explanation - In Example 1, the sliding windows are: `[1, 3, -1]`, `[3, -1, -3]`, `[ -1, -3, 5]`, `[ -3, 5, 3]`, `[5, 3, 6]`, `[3, 6, 7]`. The maximums are `[3, 3, 5, 5, 6, 7]` respectively. - In Example 2, the sliding window `[9, 11]` has a maximum of `11`. - In Example 3, the sliding window `[4, -2]` has a maximum of `4`. # Requirements - The function implementation should be efficient with a time complexity of (O(n)). # Implementation Notes - Utilize a deque to keep track of element indices. - Ensure elements in the deque are within the current window range and are in decreasing order.","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Find the maximum value in each sliding window of size k in the list nums. if not nums or k <= 0: return [] n = len(nums) if k > n: return [] result = [] dq = deque() for i in range(n): # Remove elements not in the sliding window if dq and dq[0] < i - k + 1: dq.popleft() # Remove elements smaller than the current element from the queue while dq and nums[dq[-1]] < nums[i]: dq.pop() # Add current element at the end of the deque dq.append(i) # Append the result: the front of the deque is the largest element for the window if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"# Question: You are given two non-empty singly linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Merge the two lists in such a manner that the resulting list is sorted in non-decreasing order. Design a function `merge_two_numbers(l1, l2)` that takes two linked-list nodes `l1` and `l2` as input and returns the head node of the sorted, merged linked list. Function Signature: ```python def merge_two_numbers(l1: Node, l2: Node) -> Node: pass ``` Input: - Two linked lists `l1` and `l2` such that each linked list represents a non-negative number with its digits stored in reverse order. Output: - A single linked list representing the merged, sorted non-negative number in reverse order. Constraints: - Each linked list will not have more than 1000 nodes. - The values of the nodes will only be non-negative integers. Examples: 1. **Example 1**: - Input: `l1`: 2 -> 4 -> 3, `l2`: 5 -> 6 -> 4 - Output: `7 -> 0 -> 8` - Explanation: The number represented by `l1` is 342, and `l2` is 465. The merged number 342 + 465 = 807, and the result is stored in reverse order as 7->0->8. 2. **Example 2**: - Input: `l1`: 1 -> 3, `l2`: 9 - Output: `0 -> 4` - Explanation: The number represented by `l1` is 31, and `l2` is 9. The merged number 31 + 9 = 40 (in reverse 0->4). # Notes: - Pay special attention to edge cases where one list is significantly longer than the other. - Ensure the function correctly handles lists of different lengths and merged results have the correct order.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_numbers(l1: ListNode, l2: ListNode) -> ListNode: dummy_head = ListNode() current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next"},{"question":"# Flatten Nested Arrays Given an array that may contain nested arrays, implement a function `flatten_array` that produces a single resultant array with all the elements of the nested arrays in their original order. Write a function: ```python def flatten_array(input_list): pass ``` # Input - `input_list` is a list that may contain nested lists. Each element of `input_list` can be an integer, float, string, or a nested list of those types. # Output - Returns a single flattened list containing all the elements of the nested lists in their original order. # Constraints - You must not use any built-in utility that can flatten the list (like itertools or sum). - The solution should handle deeply nested lists efficiently and avoid excessive memory usage. - Aim for a time complexity of ( O(n) ) and space complexity of ( O(n) ) where ( n ) is the number of elements in the nested lists. # Example ```python print(flatten_array([1, [2, [3, 4], 5], [6, 7], 8])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] print(flatten_array([[[\'a\']], \'b\', [[[\'c\', \'d\']]], \'e\', [[[[[\'f\']]]]]])) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] print(flatten_array([])) # Output: [] ``` # Notes - Handle edge cases such as empty lists and deeply nested structures. - Careful consideration should be given to ensure that strings are not split into individual characters. - The solution should be efficient and should demonstrate clear understanding of recursion or iterative approach to flattening nested structures.","solution":"def flatten_array(input_list): Flattens a nested list into a single list of elements. Args: input_list (list): A list which may contain nested lists. Returns: list: A flattened list. result = [] def flatten(sublist): for element in sublist: if isinstance(element, list): flatten(element) else: result.append(element) flatten(input_list) return result"},{"question":"# Remove Duplicates from Sorted Linked List In the provided coding snippets, you have seen how to remove duplicates from an unsorted linked list. Now, we want to test your understanding further by asking you to remove duplicates from a sorted linked list. Problem Description Given a sorted linked list, write a function `remove_duplicates_sorted(head)` that removes all duplicates such that each element appears only once. The relative order of the elements should stay the same. Function Signature ```python def remove_duplicates_sorted(head: Optional[Node]) -> Optional[Node]: pass ``` Input - `head` (Node): The head node of the sorted linked list. Each Node contains an integer value and a `next` pointer to the next node in the list. Output - Returns the head of the linked list with duplicates removed. Example ```python # Input: 1 -> 1 -> 2 -> 3 -> 3 # Output: 1 -> 2 -> 3 # Input: 1 -> 1 -> 1 # Output: 1 ``` Constraints - The linked list is sorted in non-decreasing order. - The values of the nodes are integers. - The length of the linked list is `0 <= length <= 10^4`. Requirements * You should focus on writing an efficient solution considering the sorted nature of the list. * Avoid using additional data structures beyond O(1) space.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_sorted(head: Node) -> Node: current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"# Question: Implement Ternary Search with Edge Case Handling Scenario: You are a software engineer working on a data retrieval system. One of your subsystems needs to use a search algorithm that can efficiently search through large continuously updated datasets. Although binary search is an option, due to some specific design requirements, you need to implement the ternary search algorithm. Task: Implement a function `ternary_search(left: int, right: int, key: int, arr: List[int]) -> int` in Python. The function should perform a ternary search on a sorted array of integers and return the index of the key if found, otherwise return -1. Requirements: * **Input**: * An integer `left` representing the starting index of the search range. * An integer `right` representing the ending index of the search range. * An integer `key` representing the value to search for. * A list of integers `arr` which is sorted in ascending order. * **Output**: * Return the index of `key` if it is present in `arr`. * Return -1 if `key` is not present or if the range is invalid. Constraints: * The array should be non-empty and sorted in non-decreasing order. * The value for `left` should be `>= 0` and `<= right`. * The value for `right` should be `< len(arr)`. Performance Requirements: * Optimize the function to have a time complexity of (O(log_3(N))) and a space complexity of (O(1)). Function Signature: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` **Examples:** 1. For `arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]`, `left = 0`, `right = 8`, `key = 4`, the output should be `3` because `4` is at index `3`. 2. For `arr = [1, 3, 5, 7, 9]`, `left = 0`, `right = 4`, `key = 6`, the output should be `-1` as `6` is not present in the array.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on the sorted array \'arr\' to find the index of \'key\'. Arguments: left -- the starting index of the search range right -- the ending index of the search range key -- the value to search for arr -- the list of sorted integers Returns: The index of \'key\' in \'arr\' if present, otherwise -1. while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are given a list of `n` people numbered from `1` to `n`, standing in a circle. Starting from the first person, you count `k` people clockwise and remove the k-th person from the circle. The counting starts again immediately from the next person. This process repeats until only one person is left. Your task is to implement the function `josephus_problem` that takes the list of people and the counting number `k`, and returns the order in which the people are removed and the last person remaining. # Function Signature ```python def josephus_problem(people: List[int], k: int) -> Tuple[List[int], int]: ``` # Input * `people`: A list of integers representing the people standing in the circle. * `k`: An integer representing the step count. # Output * A tuple where: * The first element is a list of integers representing the order in which the people are removed. * The second element is the integer representing the last person remaining in the circle. # Constraints * `1 <= len(people) <= 10^6` * `1 <= k <= len(people)` # Examples Example 1 ```python people = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 3 josephus_problem(people, k) ``` Output: ```python ([3, 6, 9, 4, 8, 5, 2, 7], 1) ``` Example 2 ```python people = [1, 2, 3, 4] k = 2 josephus_problem(people, k) ``` Output: ```python ([2, 4, 3], 1) ``` # Performance Requirements Your solution should be optimized to handle large inputs efficiently. Consider using a more appropriate data structure that handles removals efficiently.","solution":"from typing import List, Tuple def josephus_problem(people: List[int], k: int) -> Tuple[List[int], int]: Solves the Josephus problem and returns the order of elimination and the last person remaining. order_of_removal = [] index = 0 while len(people) > 1: index = (index + k - 1) % len(people) order_of_removal.append(people.pop(index)) return order_of_removal, people[0]"},{"question":"# Phone Number Letter Combinations You are provided with a string representing a sequence of digits. Each digit (2-9) corresponds to a group of letters as shown in the table below: - 2: \\"abc\\" - 3: \\"def\\" - 4: \\"ghi\\" - 5: \\"jkl\\" - 6: \\"mno\\" - 7: \\"pqrs\\" - 8: \\"tuv\\" - 9: \\"wxyz\\" Your task is to write a function that returns all possible letter combinations that the number could represent. You need to consider the following: - If the input string is empty, the function should return an empty list. - The digits input will only contain digits 2-9. Function Signature ```python def letter_combinations(digits: str) -> list: ``` Input * **digits** (str): A string containing digits from 2 to 9. Output * **List of str**: A list of all possible letter combinations represented by the input digit string. Constraints * The length of `digits` will be in the range [0, 4]. * The given digit string will never be empty. Example ```python digits = \\"23\\" assert letter_combinations(digits) == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] digits = \\"\\" assert letter_combinations(digits) == [] digits = \\"7\\" assert letter_combinations(digits) == [\\"p\\", \\"q\\", \\"r\\", \\"s\\"] ``` Performance Requirements Your solution must handle up to 10^3 digit string combinations efficiently.","solution":"def letter_combinations(digits: str) -> list: if not digits: return [] phone_map = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"Problem: Optimized Matrix Multiplier You\'re tasked with implementing an optimized matrix multiplication function that reduces time complexity compared to the traditional matrix multiplication algorithm. Given two matrices, return their product using an efficient algorithm. Your implementation should handle large matrices efficiently. # Input * Two 2D lists (matrices) `A` and `B` where: - Each element of the matrices is an integer. - The dimensions conform (i.e., the number of columns in `A` should match the number of rows in `B`). # Output * A 2D list representing the product of the matrices `A` and `B`. # Constraints * Both matrices `A` and `B` have dimensions up to 500 x 500. * You must achieve better performance than the traditional O(n^3) matrix multiplication method. # Assumptions: * Matrix elements are integer values, and the resulting matrix will also contain integer values. # Example ```plaintext Input: A = [[1, 2], [3, 4]] B = [[5, 6], [7, 8]] Output: [[19, 22], [43, 50]] Input: A = [[2, 3]] B = [[4], [5]] Output: [[23]] ``` # Implementation Requirements * Implement the `optimized_multiply(A, B)` function. * Ensure your solution has better performance than O(n^3). # Notes Handling large matrices efficiently is key. Consider leveraging advanced techniques or supporting libraries to improve performance.","solution":"import numpy as np def optimized_multiply(A, B): Multiplies two matrices A and B using numpy for optimized performance. Parameters: A (list of list of ints): The first matrix B (list of list of ints): The second matrix Returns: list of list of ints: The matrix product of A and B A_np = np.array(A) B_np = np.array(B) result_np = np.dot(A_np, B_np) return result_np.tolist()"},{"question":"# Question: Optimized Bubble Sort Algorithm You are tasked with implementing an optimized version of the bubble sort algorithm. This optimization should reduce the number of comparisons in each pass through the list by noting that the last `n - x` elements are already sorted. Your function should also handle specific edge cases and constraints accordingly. **Function Signature**: ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers where the length of the list is in the range [0, 1000]. **Output**: - Return the sorted list of integers in ascending order. **Constraints**: - Ensure the solution efficiently handles the provided constraints. - Consider edge cases such as empty lists and lists with a single element. **Example**: ```python assert optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([5]) == [5] ``` **Notes**: - You must ensure that the algorithm remains stable. - Optimize the approach to make it as efficient as possible within the provided constraints.","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: Perform an optimized bubble sort on a list of integers. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr"},{"question":"A tactful commander in a battle needs an efficient system to handle commands for his troops. Commands have different priorities, and the commander wants to always execute the highest priority command available at the moment. Your task is to implement an efficient **PriorityQueue** class for this purpose. You will implement a class called `PriorityQueue`, where each command can be inserted along with a priority, and the highest-priority command can be extracted. Expected Function Implementations: 1. `__init__(self, items=None, priorities=None)`: Initializes the priority queue. 2. `push(self, item, priority)`: Inserts a new item with the given priority into the queue. 3. `pop(self)`: Removes and returns the item with the highest priority from the queue. 4. `size(self)`: Returns the number of elements in the queue. Input and Output Formats: - `push(item, priority)`: `item` is a string represents the command, `priority` is an integer. - `pop() -> str`: Returns the highest-priority command (string). - `size() -> int`: Returns the size of the queue. Constraints: - Strings for commands no longer than 100 characters. - Priorities are integers and can range from -10^6 to 10^6. - The number of commands (N) will not exceed 10^4. Example Usage: ```python commands = [\\"attack\\", \\"defend\\", \\"retreat\\"] priorities = [10, 20, 5] pq = PriorityQueue(commands, priorities) print(pq.size()) # Output: 3 print(pq.pop()) # Output: \\"defend\\" pq.push(\\"advance\\", 15) print(pq.pop()) # Output: \\"advance\\" ``` Performance Requirements: - The `push` method should work in O(n) in the worst case. - The `pop` method should work in O(1). Implement the class `PriorityQueue` with the specified methods.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (-priority, item)) def push(self, item, priority): heapq.heappush(self.heap, (-priority, item)) def pop(self): if self.heap: return heapq.heappop(self.heap)[1] else: raise IndexError(\\"pop from an empty priority queue\\") def size(self): return len(self.heap)"},{"question":"***Segment Tree Range Minimum Query*** You are tasked with implementing a segment tree that supports range minimum queries on an integer array. The segment tree should allow querying the minimum value within any given range of the array efficiently. # Function Specifications * __Input__: * `SegmentTree(intArray, func)`: Constructor accepting an integer array and a function `func` for segment combination. * `query(left, right)`: Method to query the minimum value between the given range `[left, right]`. # Constraints * You can assume the integer array will have a length between 1 and 10^6. * The values in the array may be negative, zero, or positive. * The query range will always be valid within the array bounds (e.g., `0 <= left <= right < length of array`). # Example ```python # Initializing the SegmentTree with the array and minimum function mytree = SegmentTree([2, 4, 5, 3, 4], min) # Querying range minimum between indices 1 and 3 print(mytree.query(1, 3)) # Output should be 3 # Querying range minimum between indices 0 and 4 print(mytree.query(0, 4)) # Output should be 2 ``` # Implementation Hints * Remember to handle the indexing properly since Python lists are zero-indexed. * Think about the recursive tree building mechanism and how nodes should be merged using the minimum function. * Ensure your segment combination function (`func`) is correctly handled during tree construction and query. Replace any instance of `None` handling in the original code with appropriate default behaviors suggested by min function requirements (if needed). The solution should be implemented with efficient time and space considerations.","solution":"class SegmentTree: def __init__(self, intArray, func): self.n = len(intArray) self.tree = [None] * (2 * self.n) self.func = func # Initialize the leaves of the tree for i in range(self.n): self.tree[self.n + i] = intArray[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, left, right): # Shift the indices to the leaf level left += self.n right += self.n + 1 result = None while left < right: if left % 2 == 1: result = self.tree[left] if result is None else self.func(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = self.tree[right] if result is None else self.func(result, self.tree[right]) left //= 2 right //= 2 return result"},{"question":"**Scenario:** You are tasked to develop a function that helps in data management by removing particular bits from binary encoded data. This operation is frequently used in data compression algorithms and error correction codes. **Objective:** Write a function `remove_bit(num, i)` to remove the bit at the `i`-th position (0-based indexing) from the binary representation of the integer `num`. **Function Signature:** ```python def remove_bit(num: int, i: int) -> int: pass ``` # Input: - `num` (int): A non-negative integer. - `i` (int): A non-negative integer representing the bit position to remove. # Output: - (int): The integer resulting from removing the `i`-th bit from `num`. # Constraints: - `0 <= num <= 10^9` - `0 <= i < 31` (since we generally deal with 32-bit integers) # Example: ```python assert remove_bit(21, 2) == 9 # 21 is 10101 in binary, removing 2nd bit results in 1001 which is 9 assert remove_bit(21, 4) == 5 # 21 is 10101 in binary, removing 4th bit results in 0101 which is 5 assert remove_bit(21, 0) == 10 # 21 is 10101 in binary, removing 0th bit results in 1010 which is 10 ``` # Edge Cases: - Removing the 0-th position bit (rightmost bit). - Removing bits when `num` is 0 (only considering valid `i` positions). - Handling the case where `i` is out of bounds for the given number. # Note: - You should not rely on any built-in functions that directly manipulate bit positions or strings.","solution":"def remove_bit(num, i): Removes the bit at the i-th position (0-based indexing) from the binary representation of the integer num. # Shift the part before the i-th bit left_part = num >> (i + 1) # Shift the part after the i-th bit back into place right_part = num & ((1 << i) - 1) return (left_part << i) | right_part"},{"question":"You are given an encoded string, and you need to implement a function `decode_string(s)` that returns the decoded version of the string. # Description The encoding rule is: `k[encoded_string]`, where the encoded string inside the square brackets is repeated exactly `k` times. You may assume that the input string is always valid and contains no extra white spaces or malformed brackets. Digits are guaranteed to be positive integers for the repeat counts. # Input - A single string `s` that represents the encoded string. # Output - Return the decoded string. # Constraints - The input string `s` will not exceed 10000 characters. - The encoded string will always be well-formed. # Examples ```python s = \\"3[a]2[bc]\\" # Expected output: \\"aaabcbc\\" s = \\"3[a2[c]]\\" # Expected output: \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" # Expected output: \\"abcabccdcdcdef\\" ``` # Implementation Write the function `decode_string(s)` using the stack-based approach demonstrated in the snippet. Ensure your function handles nested encodings and multiple encoded sections within the same string. ```python def decode_string(s): # Your implementation here pass # Test cases print(decode_string(\\"3[a]2[bc]\\")) # Output: \\"aaabcbc\\" print(decode_string(\\"3[a2[c]]\\")) # Output: \\"accaccacc\\" print(decode_string(\\"2[abc]3[cd]ef\\")) # Output: \\"abcabccdcdcdef\\" ```","solution":"def decode_string(s): stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string, current_num = \\"\\", 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Problem You are given a square matrix `A`. Your task is to implement a function `crout_matrix_decomposition(A)` that performs the Crout matrix decomposition. The matrix `A` should be decomposed into two triangular matrices `L` (lower triangular matrix) and `U` (upper triangular matrix) such that `L * U = A`. # Requirements - The input matrix `A` is a nested list of floats/integer values (n x n). - The output must be two matrices `L` and `U`, both are nested lists of floats. # Constraints - The matrix `A` is always a square matrix. - The size of matrix `A`, i.e., `n`, will be `1 ≤ n ≤ 100`. # Performance - Aim for a time complexity of O(n^3). - Aim for a space complexity of O(n^2). # Example Input ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] ``` # Example Output ```python L = [ [1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0] ] U = [ [1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0] ] ``` # Explanation The given function should be able to return matrices `L` and `U` such that when multiplied, `L * U` yields the original matrix `A`. # Function Signature ```python def crout_matrix_decomposition(A): # Your code here ```","solution":"def crout_matrix_decomposition(A): Perform the Crout matrix decomposition of a square matrix A. Returns two matrices L and U such that L * U = A. n = len(A) L = [[0.0 for _ in range(n)] for _ in range(n)] U = [[0.0 if i != j else 1.0 for j in range(n)] for i in range(n)] for j in range(n): for i in range(j, n): sum = 0.0 for k in range(j): sum += L[i][k] * U[k][j] L[i][j] = A[i][j] - sum for i in range(j + 1, n): sum = 0.0 for k in range(j): sum += L[j][k] * U[k][i] U[j][i] = (A[j][i] - sum) / L[j][j] return L, U"},{"question":"# Problem: Custom Gnome Sort with Constraints You are provided with the implementation of the Gnome Sort algorithm. Your task is to extend this sorting algorithm to sort an array in descending order while ensuring that any occurrence of the number `0` is shifted to the end of the array. Additionally, you must implement optimizations to minimize the number of swaps performed during sorting. Function Signature ```python def custom_gnome_sort(arr: List[int]) -> List[int]: # Implement the function as per the given requirements pass ``` Input * A list of integers, `arr` (0 <= len(arr) <= 10^5). Output * The list sorted in descending order with all `0`s moved to the end of the list. Constraints * The function should efficiently handle the input list length up to 100,000 elements. * Utilization of additional memory should be minimized. # Examples 1. **Input**: [3, 0, 2, 5, 4, 0, 1] **Output**: [5, 4, 3, 2, 1, 0, 0] 2. **Input**: [0, 0, 0] **Output**: [0, 0, 0] 3. **Input**: [7, 3, 3, 5, 1, 0] **Output**: [7, 5, 3, 3, 1, 0] # Notes * Focus on the efficiency of your solution in terms of both time and space complexity while still achieving the desired functionality. * Ensure that any `0`s in the array are placed at the end without changing their initial sequence.","solution":"def custom_gnome_sort(arr): # Separate non-zero and zero elements non_zero_elems = [x for x in arr if x != 0] zero_elems = [x for x in arr if x == 0] # Apply gnome sort to non-zero elements in descending order i = 0 n = len(non_zero_elems) while i < n: if i == 0 or non_zero_elems[i] <= non_zero_elems[i-1]: i += 1 else: non_zero_elems[i], non_zero_elems[i-1] = non_zero_elems[i-1], non_zero_elems[i] i -= 1 # Combine the sorted non-zero elements with the zeros at the end sorted_arr = non_zero_elems + zero_elems return sorted_arr"},{"question":"Problem Statement You are required to implement a function that generates a sequence of numbers from 1 to N according to the following rules: 1. For numbers which are multiples of 3, return \\"Fizz\\" instead of the number. 2. For numbers which are multiples of 5, return \\"Buzz\\" instead of the number. 3. For numbers which are multiples of both 3 and 5, return \\"FizzBuzz\\" instead of the number. 4. Otherwise, return the number itself. Your function should raise a `ValueError` if `N` is less than 1, and a `TypeError` if `N` is not an integer. # Input Format - A single integer N (1 ≤ N ≤ 10^6) # Output Format - A list of strings and/or integers from 1 to N, with appropriate substitutions. # Example ```python fizzbuzz(15) # Returns: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] fizzbuzz(0) # Raises ValueError: N cannot be less than one fizzbuzz(\'15\') # Raises TypeError: N must be an integer ``` # Constraints - N must be greater than or equal to 1. - N must be an integer. Write the function according to the specified requirements. Ensure to handle invalid inputs as described.","solution":"def fizzbuzz(N): Generate a sequence of numbers from 1 to N with substitutions: - \'Fizz\' for multiples of 3 - \'Buzz\' for multiples of 5 - \'FizzBuzz\' for multiples of both 3 and 5 Args: - N (int): The upper limit of the sequence. Returns: - List: The sequence with appropriate substitutions. Raises: - ValueError: If N is less than 1. - TypeError: If N is not an integer. if not isinstance(N, int): raise TypeError(\\"N must be an integer\\") if N < 1: raise ValueError(\\"N cannot be less than one\\") result = [] for i in range(1, N + 1): if i % 15 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Maximum Flow Problem: Augmenting Path Algorithm Using BFS # Background: You are given a network of pipelines that transport water between interconnected reservoirs. Each connection can be represented as an edge with a specific capacity. You need to determine the maximum amount of water that can flow from the initial reservoir (source) to the final reservoir (sink) through this network. # Problem: Write a function `maximum_flow_bfs(adjacency_matrix)` that computes the maximum flow from the source (first node) to the sink (last node) in a given network represented by an `n x n` adjacency matrix, where `adjacency_matrix[i][j]` denotes the capacity of the edge from node `i` to node `j`. # Input: - An `n x n` matrix `adjacency_matrix` (2<=n<=100), representing the network\'s capacities. - The value `adjacency_matrix[i][j]` is a non-negative integer representing the capacity from node `i` to node `j`. # Output: - An integer representing the maximum flow from the source to the sink. # Constraints: - The graph is connected, directed, and with non-negative capacities. - Nodes are zero-based indexed, with the first node (`0`) being the source and the last node (`n-1`) being the sink. # Examples: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(maximum_flow_bfs(graph)) # Output should be 23 ``` # Note: - Ensure to handle edge cases, like when no path exists from the source to the sink. - Emphasize readability and efficiency in your implementation. - Optimize where necessary to handle the upper limits of the input size.","solution":"from collections import deque def bfs_find_augmenting_path(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow_bfs(adjacency_matrix): source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [row[:] for row in adjacency_matrix] parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs_find_augmenting_path(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] return max_flow"},{"question":"**Scenario**: You\'re developing a resource allocation tool for a small logistics company. They have a set of containers with given capacities in which items need to be packed to maximize the total value without exceeding the capacity limit. You\'re tasked to design a robust algorithm that can compute the maximum value of items that can be packed inside a single container of a specified capacity. **Function Requirement**: Write a function `max_knapsack_value` which computes the maximum summarized value that can be packed in a knapsack of given capacity. **Function Signature**: ```python def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` Where: * `items`: A list of tuples, each tuple `(value, weight)` represents the value and weight of an item. * `capacity`: An integer indicating the maximum weight capacity of the knapsack. **Constraints**: * All values and weights are non-negative integers. * Capacity is a non-negative integer. * The number of items, `n`, is in the range `[1, 1000]`. * The knapsack capacity `m` is in the range `[0, 10000]`. **Input**: * A list of items as tuples of integers `value` and `weight`. * An integer capacity. **Output**: * An integer representing the maximum value that can be obtained by packing items within the given capacity. **Example**: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert max_knapsack_value(items, capacity) == 80 # Choose items with values 50 and 30 ``` **Performance Requirement**: Your function should efficiently compute the results within acceptable time limits for the given constraints. **Notes**: Make sure to consider edge cases such as no items or zero capacity, and ensure your solution is optimized for performance.","solution":"from typing import List, Tuple def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: n = len(items) dp = [0] * (capacity + 1) for value, weight in items: for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"Background: You are developing a script that performs batch file processing on paths provided by users. To ensure that your script functions correctly across different operating systems and user environments, it is crucial to convert all provided file paths to their corresponding absolute paths uniformly. This ensures that the file operations are performed on the correct files regardless of the initial form of the path provided by the user. Task: Write a function called `get_absolute_path` that takes a single argument `file_path` (string) containing the path to a file. The function should return the absolute path of the file after expanding any user directory references (e.g., \'~\' or \'~username\') and resolving any relative path components. Function Signature: ```python def get_absolute_path(file_path: str) -> str: ``` Input: * `file_path` (str): A string representing the file path which may be relative and contain user directory references. Output: * Returns a string representing the absolute path of the provided file. Constraints: * The input path may be empty or contain multiple levels of relative references (e.g., \'../\'). * The path resolution should work across different operating systems (consider typical behavior on UNIX-like and Windows systems). * You should assume the function is part of a larger system that will handle file existence verification separately. Example Usage: ```python print(get_absolute_path(\\"~/documents/report.txt\\")) # Output: \\"/home/username/documents/report.txt\\" on UNIX-like systems # Or \\"C:Usersusernamedocumentsreport.txt\\" on Windows systems print(get_absolute_path(\\"../project/code.py\\")) # Output: \\"/current/working/directory/project/code.py\\" ``` Requirements: * **Efficiency**: The function should run efficiently, even for long file paths. * **Correctness**: The function must correctly handle edge cases such as empty input, redundant separators, and nested relative references. Note: Do not rely on external libraries other than the built-in `os` module to accomplish this task.","solution":"import os def get_absolute_path(file_path: str) -> str: Converts a file path to its absolute path, expanding user directories and resolving any relative path components. :param file_path: A string representing the file path. :return: A string representing the absolute path. # Expand user directory and normalize path expanded_path = os.path.expanduser(file_path) absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"As an aspiring programmer, you need to implement a function `enhanced_bubble_sort` that improves the traditional bubble sort algorithm. Your objective is to incorporate a few enhancements that make the algorithm more efficient on nearly sorted arrays. # Enhancements 1. **Optimization by Early Termination**: Modify the traditional bubble sort to terminate early if no swaps were made during a pass, indicating that the list is already sorted. 2. **Reverse Order Detection**: Implement an additional check in the first pass to detect if the list is initially sorted in descending order. If detected, reverse the list to convert it to ascending order in O(N) time. # Function Signature ```python def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input - `arr`: A list of integers that need to be sorted. - `simulation` (optional): A boolean flag that when set to `True`, prints each iteration of the sorting process. # Output - A sorted list in ascending order. # Constraints - You can assume all elements in the list are integers. - The list may contain negative numbers and duplicates. - Solve the problem with a time complexity of O(N^2) for the worst case and O(N) for the best case. # Example ```python arr = [64, 34, 25, 12, 22, 11, 90] print(enhanced_bubble_sort(arr, True)) # Expected Output: [11, 12, 22, 25, 34, 64, 90] arr = [1, 2, 3, 4, 5] print(enhanced_bubble_sort(arr)) # Expected Output: [1, 2, 3, 4, 5] arr = [10, 9, 8, 7, 6, 5] print(enhanced_bubble_sort(arr)) # Expected Output: [5, 6, 7, 8, 9, 10] ``` # Notes - Performance: Aim to achieve the enhancements without compromising the overall simplicity of the algorithm. - Your implementation should not use built-in sorting functions like `sort()` or `sorted()`. Good luck!","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) # Check if the list is in reverse order is_reverse_sorted = True for i in range(1, n): if arr[i] > arr[i - 1]: is_reverse_sorted = False break if is_reverse_sorted: arr.reverse() if simulation: print(\\"Reversed array: \\", arr) return arr # Standard Bubble Sort with early termination for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\\"Iteration {i}-{j}: {arr}\\") if simulation: print(f\\"End of pass {i}: {arr}\\") # If no elements were swapped in the inner loop, then the array is sorted if not swapped: break return arr"},{"question":"# Question **Merge Sort with In-Place Merge** You are required to implement the Merge Sort algorithm but with an in-place merge operation to reduce auxiliary space usage. Requirements: - Implement the `inplace_merge_sort` function, which sorts an array in ascending order. - The sorting function should leverage the divide-and-conquer strategy used in Merge Sort but should do so by sorting in place during the merging phase. - Assume the input array `arr` contains unique integers. Function Signature: ```python def inplace_merge_sort(arr): Sorts an array in ascending order using in-place merge sort. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. ``` Input: - A list `arr` containing `n` unique integers where `1 <= n <= 10^5`. Output: - The function should return a sorted list of integers. Constraints: 1. The function should work in O(n log(n)) time. 2. The space complexity should be minimized with in-place operations as much as possible. Example: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6] sorted_arr = inplace_merge_sort(arr) print(sorted_arr) # Output: [1, 1, 2, 3, 4, 5, 6, 9] ``` **Notes**: - Be mindful of indexing and ensure no out-of-bound errors occur. - Consider edge cases like empty arrays and already sorted arrays carefully.","solution":"def inplace_merge(arr, start, mid, end): Merges two sorted subarrays of arr in place. start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def inplace_merge_sort_helper(arr, l, r): if l < r: m = l + (r - l) // 2 inplace_merge_sort_helper(arr, l, m) inplace_merge_sort_helper(arr, m + 1, r) inplace_merge(arr, l, m, r) def inplace_merge_sort(arr): Sorts an array in ascending order using in-place merge sort algorithm. if not arr: return arr inplace_merge_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Nearest Neighbor Classification You are working on a pattern recognition system that uses the nearest neighbor algorithm to classify points in a two-dimensional space. You need to implement the `nearest_neighbor` function that will classify the new point based on the closest point in the training set. Input: * A tuple `x` representing the coordinates of the point to classify, e.g., `(2, 3)`. * A dictionary `tSet` where keys are tuples representing coordinates of points in the training set, and values are their corresponding labels, e.g., `{(1, 2): \'A\', (3, 4): \'B\', (2, 3): \'A\'}`. Output: * A scalar value that is the label associated with the nearest neighbor to the query point `x` from the training set `tSet`. Constraints: * All input vectors will be of equal length (either provided in the assert statements or problem assumption). * The training set will have at least one vector. Performance: * Aim for optimal use of space and clarity of the search procedure. * You can assume that the training set size will not exceed 10^5 entries. # Task: 1. Implement the `distance` function that calculates the Euclidean distance between two vectors `x` and `y`. 2. Implement the `nearest_neighbor` function that returns the label of the nearest neighbor for a given point `x` in the training set `tSet`. # Function Signature: ```python import math def distance(x, y): # Your code here def nearest_neighbor(x, tSet): # Your code here ``` # Examples: ```python # Example 1: # Given a point (2, 3) and a training set containing points {(1, 1): \'B\', (4, 5): \'A\', (2, 2): \'B\'} # The nearest neighbor to (2, 3) is (2, 2) with label \'B\' x = (2, 3) tSet = {(1, 1): \'B\', (4, 5): \'A\', (2, 2): \'B\'} print(nearest_neighbor(x, tSet)) # Output: \'B\' # Example 2: # Given a point (0, 0) and a training set containing points {(1, 2): \'X\', (3, 4): \'Y\', (0, 1): \'X\'} # The nearest neighbor to (0, 0) is (0, 1) with label \'X\' x = (0, 0) tSet = {(1, 2): \'X\', (3, 4): \'Y\', (0, 1): \'X\'} print(nearest_neighbor(x, tSet)) # Output: \'X\' ``` Write your solution in the provided function templates.","solution":"import math def distance(x, y): Computes the Euclidean distance between two points x and y. return math.sqrt(sum((xi - yi) ** 2 for xi, yi in zip(x, y))) def nearest_neighbor(x, tSet): Finds the label of the nearest neighbor for a given point x in the training set tSet. nearest_point = min(tSet.keys(), key=lambda point: distance(x, point)) return tSet[nearest_point]"},{"question":"You are tasked with implementing a function to calculate the factorial of a non-negative integer using an optimized approach that avoids large intermediate values directly during computation, particularly under modulus. Your function should be optimized for handling inputs where `n` and `mod` are significantly large. # Requirements: 1. Implement two separate functions: - `optimized_factorial(n: int, mod: int) -> int`: Uses efficient modular arithmetic to avoid overflow. - `compare_factorials(n: int, mod: int) -> bool`: Compares the results of optimized and traditional factorial functions to ensure they match. 2. The `optimized_factorial` function should: - Accept a non-negative integer `n` and a positive integer `mod`. - Return `(n! % mod)` using an optimized approach. 3. The `compare_factorials` function should: - Check if the output of `optimized_factorial` matches the output of either `factorial` or `factorial_recur` under the same conditions. - Return `True` if they match, otherwise `False`. # Constraints: - `0 <= n <= 10^5` - `1 <= mod <= 10^9` # Performance: - Ensure efficient computation under large values for `n` to avoid overflow and stack overflow errors in recursive implementations. # Example: ```python assert optimized_factorial(5, 13) == 3 # 5! % 13 is 120 % 13 == 3 assert optimized_factorial(100, 1000000007) == 437918130 assert compare_factorials(10, 12) == True assert compare_factorials(20, 13) == True ``` **Note**: Direct calculation methods may not be efficient at high `n`. Look into advanced modular arithmetic techniques for your implementation.","solution":"def optimized_factorial(n, mod): Returns n! % mod using an optimized approach. result = 1 for i in range(2, n + 1): result = (result * i) % mod return result def factorial_traditional(n): Returns n! using the traditional recursive approach. if n == 0 or n == 1: return 1 return n * factorial_traditional(n - 1) def compare_factorials(n, mod): Compares the results of optimized and traditional factorial functions to ensure they match. return optimized_factorial(n, mod) == (factorial_traditional(n) % mod)"},{"question":"# Regular Expression Matching with `.` and `*` You are required to implement a function that performs regular expression matching with support for `.` and `*`. * `.` matches any single character. * `*` matches zero or more of the preceding element. The matching should cover the entire input string (not partial). **Function Prototype**: ```python def is_match(s: str, p: str) -> bool: # your code here ``` **Parameters**: * `s`: A string to be matched against the pattern. * `p`: A pattern string containing regular characters, `.` and `*`. **Returns**: * `True` if `s` matches the pattern `p` according to the above rules. * `False` otherwise. **Examples**: * `is_match(\\"aa\\",\\"a\\") → False` * `is_match(\\"aa\\",\\"aa\\") → True` * `is_match(\\"aaa\\",\\"aa\\") → False` * `is_match(\\"aa\\", \\"a*\\") → True` * `is_match(\\"aa\\", \\".*\\") → True` * `is_match(\\"ab\\", \\".*\\") → True` * `is_match(\\"aab\\", \\"c*a*b\\") → True` **Constraints**: * Do not use any in-built regular expression libraries like `re` module in Python. * The lengths of input string `s` and pattern `p` will not exceed 20 characters. **Edge Cases to Consider**: * Both `s` and `p` are empty. * `s` is empty and `p` contains only `*`. * `s` has repeating characters and `p` includes using `*` on those characters.","solution":"def is_match(s: str, p: str) -> bool: def dp(i, j): if j == len(p): return i == len(s) first_match = i < len(s) and p[j] in {s[i], \'.\'} if j + 1 < len(p) and p[j+1] == \'*\': return dp(i, j+2) or (first_match and dp(i+1, j)) else: return first_match and dp(i+1, j+1) return dp(0, 0)"},{"question":"Atbash Cipher Implementation You are provided with a basic understanding of the Atbash cipher, an ancient encryption technique where each letter of a given text is mapped to its reverse counterpart in the alphabet. Your task is to implement the Atbash cipher in Python. Requirements: 1. **Input**: A single string `s` of length `1 <= len(s) <= 1000`. 2. **Output**: The encrypted (or decrypted) string using the Atbash cipher. The Atbash cipher works as follows: - Each letter in the string (both uppercase and lowercase) is replaced by its \'mirrored\' letter from the opposite end of the alphabet. - Non-alphabetic characters remain unchanged. For instance, if the input string is \\"Attack at dawn\\", the output should be \\"Zggzxp zg wzdm\\". Constraints: - The string may contain spaces, digits, and punctuation, which should not be changed. - The function must run within O(n) time complexity where n is the length of the string. Function Signature: ```python def atbash(s: str) -> str: pass ``` Examples: ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash(\\"xyzABC123.\\") == \\"cbaZYX123.\\" ``` Write your function below considering the above requirements and constraints.","solution":"def atbash(s: str) -> str: Encrypts or decrypts the input string using the Atbash cipher. Parameters: s (str): The input string to be encrypted or decrypted. Returns: str: The transformed string using the Atbash cipher. result = [] for char in s: if char.isalpha(): if char.islower(): result.append(chr(219 - ord(char))) # \'a\' -> \'z\', \'b\' -> \'y\', etc. elif char.isupper(): result.append(chr(155 - ord(char))) # \'A\' -> \'Z\', \'B\' -> \'Y\', etc. else: result.append(char) return \'\'.join(result)"},{"question":"# String Reversal Deep Dive Given the following functions for reversing a string using various techniques, you are tasked with creating an optimized implementation capable of handling very large strings efficiently. Functions: ```python def recursive(s): l = len(s) if l < 2: return s return recursive(s[l//2:]) + recursive(s[:l//2]) def iterative(s): r = list(s) i, j = 0, len(s) - 1 while i < j: r[i], r[j] = r[j], r[i] i += 1 j -= 1 return \\"\\".join(r) def pythonic(s): r = list(reversed(s)) return \\"\\".join(r) def ultra_pythonic(s): return s[::-1] ``` # Your Task 1. **Analyze** the given string reversal techniques in terms of time complexity, space complexity, and potential issues. 2. **Implement** a new string reversal function, `optimized_reverse`, that: - Is capable of reversing strings containing up to (10^6) characters efficiently. - Handles edge cases reliably. - Meets time and space complexity constraints optimally. # Requirements * **Input**: A single string `s` of length up to (10^6) characters. * **Output**: The reversed string. * **Constraints**: Optimize for both time and space complexity. Your solution should handle very large strings efficiently. ```python def optimized_reverse(s): # Your implementation here pass ``` # Example ```python # Example usage: print(optimized_reverse(\\"hello world\\")) # Output: \\"dlrow olleh\\" print(optimized_reverse(\\"racecar\\")) # Output: \\"racecar\\" (same as input because it\'s a palindrome) ```","solution":"def optimized_reverse(s): Reverses the given string s using an optimized approach. This implementation makes use of Python\'s slicing for an efficient solution. return s[::-1]"},{"question":"# Scenario You are developing a high-performance application that relies heavily on search operations within large datasets. These datasets are known to have uniformly distributed integer values. To optimize search speed, you have decided to implement the interpolation search algorithm. # Task Implement the `optimized_interpolation_search` function that will perform an interpolation search on an array of uniformly distributed integers. Your implementation should handle the following specifications: Function Signature ```python def optimized_interpolation_search(array: List[int], search_key: int) -> int: ``` Input - `array` (List[int]): A list of integers sorted in increasing order. - `search_key` (int): The integer value to be located within the array. Output - Returns the index of `search_key` in the array if found, otherwise returns `-1`. # Constraints - The function should efficiently handle arrays of varying sizes up to 10^6 elements. - The function should run within O(log(log n)) time complexity on average for uniformly distributed datasets. - Avoid using Python\'s built-in search functions or libraries for the actual search part. # Example ```python >>> optimized_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> optimized_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 ``` # Notes - Consider edge cases such as the presence of duplicates within the array, array bounds, and major datatype inconsistencies. - Implement any necessary checks to ensure the array is uniformly distributed before performing the search.","solution":"def optimized_interpolation_search(array, search_key): Perform an interpolation search on a sorted array of integers. :param array: List[int] - sorted list of uniformly distributed integers :param search_key: int - value to search in the array :return: int - index of search_key in array if found, otherwise -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low)) // (array[high] - array[low]) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Context: You are working on a navigation system that computes routes in a road network graph. A road network is represented as an undirected graph where nodes represent intersections and edges represent roads connecting them. Given the implementations for DFS and BFS traversal, your task is to implement a shortest path finder for unweighted graphs using BFS. # Task: Implement a function to find the shortest path between two nodes in an unweighted graph using BFS. # Function Signature: ```python def shortest_path(graph: dict, start: int, goal: int) -> list: ``` # Input: - `graph`: A dictionary where keys represent node IDs (integers) and values are lists of adjacent node IDs. - `start`: An integer representing the starting node ID. - `goal`: An integer representing the target node ID. # Output: - A list of integers representing the shortest path from `start` to `goal`. If no path exists, return an empty list. # Constraints: - The graph is undirected and unweighted. - Nodes are represented as integers within a valid range given by the problem. - There can be cycles in the graph. - The graph may be disconnected. # Example: ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } start = 0 goal = 4 print(shortest_path(graph, start, goal)) # Expected Output: [0, 2, 3, 4] or [0, 1, 3, 4] as both are shortest paths. ``` # Performance Requirements: - The algorithm should run in O(V + E) time complexity. - Space complexity should be O(V) in the worst case. # Edge Cases: - Start and goal are the same. - No path exists between start and goal. - The graph is empty or contains only isolated nodes.","solution":"from collections import deque def shortest_path(graph, start, goal): Finds the shortest path between start and goal nodes in an unweighted graph using BFS. Parameters: - graph: dict, a dictionary where keys are node IDs and values are lists of adjacent node IDs. - start: int, the starting node ID. - goal: int, the target node ID. Returns: - list of ints, representing the shortest path from start to goal, or an empty list if no path exists. if start == goal: return [start] queue = deque([start]) visited = {start: None} while queue: current = queue.popleft() for neighbor in graph.get(current, []): if neighbor not in visited: visited[neighbor] = current queue.append(neighbor) if neighbor == goal: path = [] while neighbor is not None: path.append(neighbor) neighbor = visited[neighbor] return path[::-1] return []"},{"question":"# Problem Description You have been given a 2D grid of size `m x n` where initially each cell is ocean. You are provided with a list of positions where you are to place an island (each position update transforms the cell at the given position from ocean to island). Task: Implement the function `num_islands(m, n, positions)` which, after each addition of a new island, returns the count of islands. An island is formed by adjacent lands connected horizontally or vertically. # Function Signature ```python def num_islands(m: int, n: int, positions: List[List[int]]) -> List[int]: ``` # Input * `m` (int): The number of rows in the grid. * `n` (int): The number of columns in the grid. * `positions` (List[List[int]]): A list of positions where islands are added. # Output * List[int]: List of counts of islands after each position update. # Constraints * 1 <= m, n <= 1000 * Positions list length <= `m * n` * Positions are within the grid dimensions `[0, 0]` to `[m-1, n-1]` * Updates in positions are unique. # Example ```python # Example 1: m = 3 n = 3 positions = [[0, 0], [0, 1], [1, 2], [2, 1]] print(num_islands(m, n, positions)) # Output: [1, 1, 2, 3] # Example 2: m = 4 n = 4 positions = [[0, 0], [1, 1], [2, 2], [1, 2], [0, 1]] print(num_islands(m, n, positions)) # Output: [1, 2, 3, 2, 1] ```","solution":"from typing import List class UnionFind: def __init__(self, total_nodes): self.parent = list(range(total_nodes)) self.rank = [0] * total_nodes self.count = 0 def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.count -= 1 def add(self, u): self.count += 1 def get_count(self): return self.count def num_islands(m: int, n: int, positions: List[List[int]]) -> List[int]: if not m or not n: return [] uf = UnionFind(m * n) grid = [[0] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] island_count_changes = [] for x, y in positions: if grid[x][y] == 1: island_count_changes.append(uf.get_count()) continue grid[x][y] = 1 uf.add(x * n + y) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: uf.union(x * n + y, nx * n + ny) island_count_changes.append(uf.get_count()) return island_count_changes"},{"question":"**Problem Description**: Implement a function that returns all possible unique subsets from a collection of integers that might contain duplicates. ```python def subsets_unique(nums): Given a collection of integers that might contain duplicates, return all possible unique subsets. Args: nums (List[int]): A list of integers, might contain duplicates. Returns: List[List[int]]: The solution set containing all unique subsets. pass ``` **Input**: - A list of integers `nums` (not necessarily sorted, might contain duplicates). **Output**: - A list of lists, where each list represents a unique subset of the input list satisfying the constraints. **Constraints**: - The function must return unique subsets. - The elements within each subset can appear in any order. - The order of subsets in the output does not matter. **Performance Requirements**: - The solution should handle input lists of moderate length (up to 16 items) efficiently. **Example**: ```python assert sorted(subsets_unique([1,2,2])) == sorted([ [2], [1], [1,2,2], [2,2], [1,2], [] ]) ``` **Scenario/Context**: Imagine you are working on a system that needs to evaluate all possible configurations or selections from a set of items where some items may be repeated. It\'s crucial to ensure that each configuration is unique, disregarding the order in which items are selected or repeated within the result set. This problem is typical in areas like combinatorial optimization and search problems in AI. Your task is to implement this function ensuring it adheres to the constraints and scenarios described.","solution":"def subsets_unique(nums): Given a collection of integers that might contain duplicates, return all possible unique subsets. Args: nums (List[int]): A list of integers, might contain duplicates. Returns: List[List[int]]: The solution set containing all unique subsets. nums.sort() result = [] def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return result"},{"question":"# Coding Problem: Implement a Bottom-Up Merge Sort Problem Description You have been tasked with implementing a bottom-up (iterative) version of the Merge Sort algorithm. Bottom-up merge sort does not use recursion; instead, it iteratively handles subarrays of increasing size to sort the entire array. Core Task Write a function `bottom_up_merge_sort(arr)` that takes an unsorted array `arr` as its input and returns the sorted version. Your implementation should avoid using recursive methods and should maintain the stability property of merge sort. Requirements: 1. **Input**: A list `arr` containing n integers (1 ≤ n ≤ 10^6). 2. **Output**: A sorted list containing the elements of `arr` in non-decreasing order. 3. **Constraints**: * Time expectancy should be O(n log(n)). * Space complexity must remain O(n). Example: ```python # Example 1 arr = [4, 2, 5, 1, 6, 3] print(bottom_up_merge_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] # Example 2 arr = [10, 8, 12, 3, 7, 15] print(bottom_up_merge_sort(arr)) # Output: [3, 7, 8, 10, 12, 15] ``` Notes: * Ensure proper handling of edge cases, such as empty lists and single-element lists. * Consider possible ways to optimize memory usage while maintaining clarity. * Explain your implementation strategy briefly in the code comments.","solution":"def bottom_up_merge_sort(arr): Sorts the array using the bottom-up merge sort algorithm. if not arr or len(arr) == 1: return arr n = len(arr) # Temporary array for merging temp_arr = [0]*n # Size represents the size of the subarrays to be merged size = 1 while size < n: # Iterate over the array combining subarrays of size `size` for left_start in range(0, n, 2*size): mid = min(left_start + size - 1, n - 1) right_end = min(left_start + 2*size - 1, n - 1) merge(arr, temp_arr, left_start, mid, right_end) size *= 2 return arr def merge(arr, temp_arr, left_start, mid, right_end): Merges two sorted halves of the array. i = left_start j = mid + 1 k = left_start # While both subarrays have elements left while i <= mid and j <= right_end: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right_end: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the merged subarray into the original array for i in range(left_start, right_end + 1): arr[i] = temp_arr[i]"},{"question":"# Pancake Sort Implementation Scenario You\'re working as a software engineer at a company that manages a large database of unsorted numerical records. For educational purposes, you\'re tasked to write a sorting algorithm that physically simulates the process of sorting sliding pancakes with a spatula, commonly known as Pancake Sort. Your goal is to sort an array of integers using the Pancake Sort algorithm. Task Implement a function `pancake_sort` that sorts a given list of integers in ascending order using the Pancake Sort technique. The array must be sorted in place. Function Signature ```python def pancake_sort(arr: [int]) -> [int]: Sort the given list of integers using Pancake Sort. :param arr: List of integers to be sorted. :return: The sorted list of integers. ``` # Input * A list of integers, `arr`, where `1 <= len(arr) <= 1000` and each integer `-10^6 <= arr[i] <= 10^6`. # Output * A list of integers sorted in non-decreasing order. Example ```python assert pancake_sort([3, 6, 2, 10, 5]) == [2, 3, 5, 6, 10] assert pancake_sort([0, 1, 0, 2]) == [0, 0, 1, 2] ``` # Constraints * Do not use any built-in sorting functions. * The solution should be implemented using the Pancake Sort algorithm. * Ensure the algorithm has an expected time complexity of O(N^2) and space complexity of O(1). Notes 1. Consider all edge cases, including arrays that are already sorted or contain duplicate values. 2. Pay attention to the reversal process and its correctness, as this is key to the Pancake Sort algorithm.","solution":"def pancake_sort(arr): Sort the given list of integers using Pancake Sort. :param arr: List of integers to be sorted. :return: The sorted list of integers. def flip(arr, k): Helper function to flip the first k elements of the array. left = 0 right = k while left < right: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 def find_max_index(arr, n): Helper function to find the index of the maximum value in the first n elements. max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index n = len(arr) for curr_size in range(n, 1, -1): max_index = find_max_index(arr, curr_size) if max_index != curr_size - 1: # Flip the max element to the first position flip(arr, max_index) # Flip it to its correct position flip(arr, curr_size - 1) return arr"},{"question":"You are provided with a directed graph data structure. Your task is to implement a method to find the shortest path from a given source node to a destination node using Dijkstra\'s algorithm. # Function Signature ```python def shortest_path(graph: DirectedGraph, start: str, end: str) -> List[str]: pass ``` # Input - `graph`: An instance of `DirectedGraph` - The directed graph in which the search is to be performed. - `start`: A string - The name of the start node. - `end`: A string - The name of the end node. # Output - List of node names representing the shortest path from the start to the end node. If no path is found, return an empty list. # Constraints - Assume all edges have equal weight. - Nodes in `graph` are represented by unique string names. - The graph can have disconnected components. # Example ```python # Graph Construction graph_dict = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } graph = DirectedGraph(graph_dict) # Example Function Call print(shortest_path(graph, \'A\', \'E\')) # Output: [\'A\', \'B\', \'D\', \'E\'] or [\'A\', \'C\', \'D\', \'E\'] print(shortest_path(graph, \'A\', \'F\')) # Output: [] ``` # Note Ensure your implementation efficiently handles the graph\'s nodes and edges. Consider edge cases such as: - Non-existent nodes for start or end. - Nodes that have no outward edges. - Disconnected subgraphs within the directed graph. **Hint:** Use a priority queue to help with the Dijkstra\'s algorithm.","solution":"import heapq from typing import List, Dict class DirectedGraph: def __init__(self, graph_dict: Dict[str, List[str]]): self.graph_dict = graph_dict def get_neighbors(self, node: str) -> List[str]: return self.graph_dict.get(node, []) def shortest_path(graph: DirectedGraph, start: str, end: str) -> List[str]: Finds the shortest path from start node to end node using Dijkstra\'s algorithm. # Priority queue to select the node with the minimum distance queue = [(0, start, [])] visited = set() while queue: (dist, current, path) = heapq.heappop(queue) if current in visited: continue path = path + [current] if current == end: return path visited.add(current) for neighbor in graph.get_neighbors(current): if neighbor not in visited: heapq.heappush(queue, (dist + 1, neighbor, path)) return []"},{"question":"# Question You have been given a positive integer `n`. Your task is to implement a function `count_partitions(n)` that calculates the number of ways to partition the integer `n` into non-negative integers. This problem is often referred to as \\"integer partitioning\\". # Function Signature ```python def count_partitions(n: int) -> int: ``` # Input * `n`: A positive integer (1 ≤ n ≤ 100) # Output * The function should return an integer representing the number of ways to partition `n`. # Example ```python count_partitions(4) # Output: 5 count_partitions(7) # Output: 15 ``` # Explanation For n=4: * 4 can be partitioned as: [4], [3+1], [2+2], [2+1+1], [1+1+1+1] - total 5 partitions. For n=7: * 7 can be partitioned as: [7], [6+1], [5+2], [5+1+1], [4+3], [4+2+1], [4+1+1+1], [3+3+1], [3+2+2], [3+2+1+1], [3+1+1+1+1], [2+2+2+1], [2+2+1+1+1], [2+1+1+1+1+1], [1+1+1+1+1+1+1] - total 15 partitions. **Constraints**: 1. Efficiency and optimal memory usage should be considered. 2. You need to handle and initialize the base cases properly to avoid incorrect results. # Notes * Utilize dynamic programming to fill up a table that captures the number of ways to partition integers up to `n` using integers up to `m`. * Avoid redundant calculations by using the results from previously solved subproblems. # Performance Requirements Ensure the solution runs within reasonable time limits for large values up to (n = 100). The use of efficient space management techniques is encouraged.","solution":"def count_partitions(n: int) -> int: Returns the number of ways to partition the integer n. # Create a 2D list to store solutions to subproblems dp = [[0] * (n + 1) for _ in range(n + 1)] # Base case: There\'s always one way to partition 0 (use no numbers) for i in range(n + 1): dp[i][0] = 1 # Fill the table using bottom-up dynamic programming approach for num in range(1, n + 1): for sum_value in range(1, n + 1): if sum_value >= num: dp[num][sum_value] = dp[num - 1][sum_value] + dp[num][sum_value - num] else: dp[num][sum_value] = dp[num - 1][sum_value] return dp[n][n]"},{"question":"You are tasked with enhancing an existing `RandomizedSet` data structure that supports efficient insertions, deletions, and uniform random retrieval of elements. **Enhancements**: 1. Include a new method `get_random_k(k)` that returns `k` unique random elements from the set. The elements should be uniformly random. 2. Introduce error handling for edge cases, such as when attempting to retrieve more elements than present in the set. **Function Signatures**: ```python class RandomizedSet: def __init__(self): # Initialize your data structures here. def insert(self, val: int) -> bool: # Inserts a value to the set if it is not present. # Return true if the item was not present, false otherwise. def remove(self, val: int) -> bool: # Removes a value from the set if it is present. # Return true if the item was present, false otherwise. def get_random(self) -> int: # Get a random element from the set. def get_random_k(self, k: int) -> List[int]: # Get k unique random elements from the set. # Raise an exception if k is greater than the number of elements in the set. ``` **Input/Output Format**: - `insert(val: int) -> bool` - Inserts `val` and returns `True` if the insertion is successful (i.e., `val` was not present). - Returns `False` if `val` is already present. - `remove(val: int) -> bool` - Removes `val` and returns `True` if the removal is successful (i.e., `val` was present). - Returns `False` if `val` is not present. - `get_random() -> int` - Returns a random element currently in the set. - `get_random_k(k: int) -> List[int]` - Returns a list of `k` unique random elements. - Raises a `ValueError` if `k` is greater than the number of elements. **Constraints**: - All values are integers. - Operations should handle large datasets efficiently. - Methods should work in average O(1) time complexity except for `get_random_k(k)`, which should be optimized to handle large `k`. **Scenario**: Suppose you are developing a game needing to frequently update and randomly access items in an inventory: - Items are added or removed during gameplay. - Certain game mechanics require selecting random items from the current inventory. - Some special events demand selecting a fixed number of random items. Implement the `RandomizedSet` class to manage these operations efficiently.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structures here. self.dict = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set if it is not present. Returns true if the item was not present, false otherwise. if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes a value from the set if it is present. Returns true if the item was present, false otherwise. if val not in self.dict: return False last_element = self.list[-1] idx_to_replace = self.dict[val] self.list[idx_to_replace] = last_element self.dict[last_element] = idx_to_replace self.list.pop() del self.dict[val] return True def get_random(self) -> int: Get a random element from the set. return random.choice(self.list) def get_random_k(self, k: int) -> list: Get k unique random elements from the set. Raise an exception if k is greater than the number of elements in the set. if k > len(self.list): raise ValueError(\\"k cannot be greater than the number of elements in the set\\") return random.sample(self.list, k)"},{"question":"You are required to implement a `ResizeableSeparateChainingHashTable` class that extends the `SeparateChainingHashTable` class provided. This new class should automatically resize the underlying array when the load factor exceeds 0.75 or falls below 0.2 after any insertion or deletion operation. # Detailed Requirements 1. **Resizing Logic**: * Double the size of the underlying array when the load factor exceeds 0.75. * Halve the size of the underlying array when the load factor falls below 0.2, but ensure the minimum size is `11`. 2. **Rehashing**: * When resizing, rehash all existing keys to the new underlying array size. 3. **Methods to Implement**: * `__init__(self, size=11)`: Initialize with a given size, default is `11`. * `resize(self, new_size)`: Helper method to resize and rehash. * Override `put` and `del_` methods to use resizing logic. # Function Signature ```python class ResizeableSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): pass def resize(self, new_size): pass def put(self, key, value): pass def del_(self, key): pass ``` # Constraints * You may assume that the `hash` function and `Node` class from the base implementation are unchanged. * The underlying array size should always be a prime number to ensure better distribution of keys. # Example ```python # Example Usage: table = ResizeableSeparateChainingHashTable() table.put(\\"key1\\", \\"value1\\") table.put(\\"key2\\", \\"value2\\") # Adding more keys to trigger resize for i in range(20): table.put(f\\"key{i}\\", f\\"value{i}\\") print(len(table)) # Outputs the current number of elements print(table.get(\\"key1\\")) # Outputs \\"value1\\" table.del_(\\"key1\\") print(table.get(\\"key1\\")) # Outputs None ``` # Assessment Your implementation will be tested on various scenarios: * Insertion and deletion of keys. * Correct resizing when load factor boundaries are crossed. * Correctness of the hashmap after resizing (all elements must still be accessible).","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.table = [None] * size self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self._hash(key) head = self.table[idx] while head is not None: if head.key == key: head.value = value return head = head.next new_node = Node(key, value) new_node.next = self.table[idx] self.table[idx] = new_node self.count += 1 def get(self, key): idx = self._hash(key) head = self.table[idx] while head is not None: if head.key == key: return head.value head = head.next return None def del_(self, key): idx = self._hash(key) head = self.table[idx] prev = None while head is not None: if head.key == key: if prev is None: self.table[idx] = head.next else: prev.next = head.next self.count -= 1 return True prev = head head = head.next return False class ResizeableSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def _next_prime(self, n): def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n def resize(self, new_size): old_table = self.table new_size = self._next_prime(new_size) self.size = new_size self.table = [None] * new_size self.count = 0 for node in old_table: while node: self.put(node.key, node.value) node = node.next def put(self, key, value): super().put(key, value) load_factor = self.count / self.size if load_factor > 0.75: self.resize(self.size * 2) def del_(self, key): if super().del_(key): load_factor = self.count / self.size if load_factor < 0.2 and self.size > 11: new_size = max(self.size // 2, 11) self.resize(new_size)"},{"question":"# Secure Key Exchange with Diffie-Hellman Algorithm In this task, you are required to implement a simplified version of the Diffie-Hellman Key Exchange algorithm to securely exchange a secret key between two parties. Your task involves checking the necessary conditions and performing the key exchange steps involving the calculation of private keys, public keys, and the shared secret key. Function Signature: ```python def perform_diffie_hellman(a: int, p: int) -> int: ... ``` # Input - `a` (int): A primitive root modulo `p`. - `p` (int): A large prime number. # Output - An integer representing the shared secret key if the exchange is successful, otherwise `-1` to indicate failure. # Requirements 1. The function should first validate if `p` is a prime number. 2. The function should ensure that `a` is a primitive root modulo `p`. 3. If the conditions are met, simulate the Diffie-Hellman key exchange and return the shared secret key. 4. If any condition is not met, return `-1`. # Constraints - `2 <= a < p <= 10^9` - The inputs will be within this range. # Example ```python result = perform_diffie_hellman(2, 11) print(result) # Expected output: shared secret key (specific value will depend on random private keys) result = perform_diffie_hellman(4, 11) print(result) # Expected output: -1 (since 4 is not a primitive root of 11) ``` **Note:** - Use helper functions provided to verify primality, find the order, and Euler\'s totient function as needed. - Generate private keys randomly within the valid range. - Handle any edge cases appropriately to ensure robustness.","solution":"import random def is_prime(n): Basic check to verify if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find a primitive root modulo p, if it exists. if p == 2: return 1 phi = p - 1 factors = prime_factors(phi) for r in range(2, p): primitive = True for factor in factors: if pow(r, phi // factor, p) == 1: primitive = False break if primitive: return r return -1 def prime_factors(n): Return the prime factors of n. factors = set() while n % 2 == 0: factors.add(2) n //= 2 for i in range(3, int(n**0.5)+1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors def perform_diffie_hellman(a: int, p: int) -> int: if not is_prime(p): return -1 if find_primitive_root(p) != a: return -1 private_key_A = random.randint(2, p-2) private_key_B = random.randint(2, p-2) public_key_A = pow(a, private_key_A, p) public_key_B = pow(a, private_key_B, p) shared_secret_A = pow(public_key_B, private_key_A, p) shared_secret_B = pow(public_key_A, private_key_B, p) if shared_secret_A == shared_secret_B: return shared_secret_A else: return -1"},{"question":"# Problem: Consecutive Stack Checker You are given a stack of integers which follows the Last In First Out (LIFO) principle. You need to implement a function `is_consecutive` which takes this stack and returns a boolean indicating whether the stack contains a sequence of consecutive integers starting from the bottom of the stack. To solve the problem, you need to simulate the behavior of auxiliary data structures (stack or queue) to temporarily hold values while you check if the stack contains consecutive integers. # Constraints: - You may assume that the stack does not contain any duplicate numbers. - The stack does not include any non-integer values. - The maximum size of the stack is `10^5`. # Input: - A stack `s` of integers `s` which is represented as a list. The bottom of the stack is the first element of the list, and the top of the stack is the last element of the list. # Output: - Return `True` if the stack contains a sequence of consecutive integers starting from the bottom, otherwise return `False`. # Example: ```python # Example 1: s = [3, 4, 5, 6, 7] print(is_consecutive(s)) # Output: True # Example 2: s = [3, 4, 6, 7] print(is_consecutive(s)) # Output: False # Example 3: s = [3, 2, 1] print(is_consecutive(s)) # Output: False ``` **Additional Notes**: - You are allowed to use either stack or queue for auxiliary storage within your implementation. # Function Signature: ```python def is_consecutive(stack: List[int]) -> bool: pass ``` Write the `is_consecutive` function based on the constraints and explanation provided.","solution":"def is_consecutive(stack): Check if the stack contains a sequence of consecutive integers starting from the bottom. Args: stack (List[int]): The input stack represented as a list. Returns: bool: Returns True if the stack contains consecutive integers starting from the bottom, otherwise False. if len(stack) < 2: return True # A stack with 0 or 1 elements is trivially consecutive prev = stack[0] for i in range(1, len(stack)): if stack[i] != prev + 1: return False prev = stack[i] return True"},{"question":"# Question: Validate Robot Movements to Return to Origin You are given a sequence of moves for a robot starting at position (0, 0) on a 2D plane. The moves are represented as a string of characters, where: * \'R\' means the robot moves one unit right, * \'L\' means the robot moves one unit left, * \'U\' means the robot moves one unit up, * \'D\' means the robot moves one unit down. Write a function `validate_robot_movements(moves: str) -> bool` that determines if the robot returns to the original position (0, 0) after executing the sequence of moves. # Input * A string `moves` which represents the sequence of moves. The string length can be up to 10,000 characters. * The string contains only characters \'R\', \'L\', \'U\', \'D\'. # Output * Return `True` if the robot returns to the original position after all moves are executed; otherwise, return `False`. # Constraints * The string only includes the characters \'R\', \'L\', \'U\', \'D\'. * The length of the string is up to 10,000. # Performance Requirements * The function should run in O(n) time, where n is the length of the input string, and use O(1) additional space. # Example ```python # Example 1: # Input: moves = \\"UD\\" # Output: True # Example 2: # Input: moves = \\"LL\\" # Output: False # Example 3: # Input: moves = \\"RRDDLUUL\\" # Output: True ``` # Notes 1. Consider edge cases such as empty strings or strings with no net movement. 2. Ensure your solution handles incorrect inputs gracefully within the given constraints.","solution":"def validate_robot_movements(moves: str) -> bool: Determines if the robot returns to the original position (0, 0) after executing the sequence of moves. Parameters: moves (str): A string of characters representing the robot\'s moves. \'R\' means move right, \'L\' means move left, \'U\' means move up, and \'D\' means move down. Returns: bool: True if the robot returns to (0, 0), False otherwise. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Cycle Sort Implementation As an experienced software engineer, you are tasked with implementing an in-place sorting algorithm called Cycle Sort. Cycle Sort is unique because it decomposes the elements to be sorted into separate cycles and rotates them individually to achieve a sorted order. While its time complexity is O(N^2), it uses minimal space, making it an interesting algorithm for educational purposes. Task: Implement the function `cycle_sort(arr)` that sorts an input array of integers using Cycle Sort. Input: - `arr` (List[int]): A list of integers to be sorted. Output: - The function should return the sorted array of integers. Constraints: - The input list can have duplicate integer values. - The input list can be of any length from 0 to 1000. - You should strive to achieve an in-place sort to maintain O(1) space complexity. Example: ```python >>> cycle_sort([5, 2, 9, 3, 8, 5, 3]) [2, 3, 3, 5, 5, 8, 9] >>> cycle_sort([1, 2, 3]) [1, 2, 3] >>> cycle_sort([]) [] ``` # Notes: - Consider edge cases such as empty arrays and arrays with all elements the same. - Avoid using built-in sort functions, as the purpose is to understand and apply the Cycle Sort algorithm.","solution":"def cycle_sort(arr): Sorts an array in place using the Cycle Sort algorithm. # Loop through the array to find cycles for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item in the correct position, or right after any duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate other elements in the current cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Next Greater Permutation Your task is to implement a function that finds the next greater permutation of an input number using its digits. If no such permutation exists, the function should return -1. Function Signature ```python def next_bigger(num: int) -> int: ``` Input - `num`: an integer where 1 ≤ num ≤ 10^10. Output - Returns an integer which is the next greater permutation of `num` if it exists; otherwise, returns -1. Examples ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(1) == -1 ``` Constraints - Do not use built-in permutation functions or brute-force approaches that generate all permutations. - The implementation must be efficient with a time complexity of O(n) where n is the number of digits in the input number. Notes - Make sure to handle input validation particularly for edge cases like single digit numbers or numbers where all digits are the same. - Think carefully about the process of identifying the break point and the swap point correctly.","solution":"def next_bigger(num: int) -> int: Finds the next greater permutation of the given number using its digits. If no such permutation exists, returns -1. digits = list(str(num)) n = len(digits) # Step 1: Find the largest index k such that digits[k] < digits[k + 1] k = -1 for i in range(n-1): if digits[i] < digits[i + 1]: k = i # If no such k is found, the digits are in descending order if k == -1: return -1 # Step 2: Find the largest index l greater than k such that digits[k] < digits[l] l = -1 for i in range(k+1, n): if digits[k] < digits[i]: l = i # Step 3: Swap the value of digits[k] with that of digits[l] digits[k], digits[l] = digits[l], digits[k] # Step 4: Reverse the subsequence from k+1 to end digits = digits[:k+1] + digits[k+1:][::-1] # Convert list back to integer return int(\'\'.join(digits))"},{"question":"# Problem: Scenario: You are developing a string validation utility for a text processing system. One of the tasks involves checking repeated patterns in text strings to ensure data consistency. Write a function `repeat_substring(s)` that determines if a given string `s` can be constructed by taking a substring and appending multiple copies of this substring together. Specifications: * The function accepts a single parameter: - `s` (string): A non-empty string consisting of lowercase alphabetic characters. * The function returns a boolean value: - `True` if the string can be formed by repeating a substring. - `False` otherwise. Input * `s` (1 <= len(s) <= 10000): The input string containing only lowercase alphabetic characters (\'a\' to \'z\'). Output * Returns `True` or `False` based on the described criteria. Example **Example 1:** ```python Input: \\"abab\\" Output: True Explanation: It\'s the substring \\"ab\\" twice. ``` **Example 2:** ```python Input: \\"aba\\" Output: False Explanation: No repeating pattern can form \\"aba\\". ``` **Example 3:** ```python Input: \\"abcabcabcabc\\" Output: True Explanation: It\'s the substring \\"abc\\" four times. ``` Use the provided code snippet only for reference and ensure your code is optimal. Constraints * You must solve this problem efficiently as the maximum string length is 10000 characters.","solution":"def repeat_substring(s): Determines if the string can be formed by repeating a substring. Parameters: s (str): The input string consisting of lowercase alphabetic characters. Returns: bool: True if the string can be formed by repeating a substring, False otherwise. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"Scenario You are tasked with designing a simple communication protocol where a list of strings needs to be serialized into a single string for network transmission, and subsequently deserialized back into a list. Your solution should handle various edge cases and ensure accurate transmission and retrieval of data. Task Implement two functions: `encode` and `decode` to handle the serialization and deserialization of the list of strings. # Function Signature ```python def encode(strs: List[str]) -> str: pass def decode(s: str) -> List[str]: pass ``` # Input - `encode`: A list of strings `strs` (0 <= len(strs) <= 10^5, sum of lengths of strings in strs <= 10^5). - `decode`: A single string `s` which is an encoded representation of a list of strings. # Output - `encode`: A single string representing the encoded list. - `decode`: A list of strings decoded from the input string. # Constraints - Consider edge cases like empty strings, strings containing numbers, special characters, and maximum input sizes. # Example: ```python # Example 1: input_strs = [\\"hello\\", \\"world\\"] encoded_str = encode(input_strs) # Example output: \\"5:hello5:world\\" decoded_strs = decode(encoded_str) # Example output: [\\"hello\\", \\"world\\"] # Example 2: input_strs = [\\"\\", \\"abc\\", \\"123\\"] encoded_str = encode(input_strs) # Example output: \\"0:3:abc3:123\\" decoded_strs = decode(encoded_str) # Example output: [\\"\\", \\"abc\\", \\"123\\"] ``` # Requirements - Ensure both `encode` and `decode` are efficient and handle edge cases appropriately. - The solution must correctly encode and decode even if strings contain numbers or special characters.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \\"\\" for s in strs: len_str = str(len(s)) encoded_str += len_str + \\":\\" + s return encoded_str def decode(s): Decodes a single string to a list of strings. decoded_strs = [] i = 0 while i < len(s): # Find the next colon j = s.find(\\":\\", i) # The number before the colon is the length of the next string length = int(s[i:j]) # Extract the string decoded_strs.append(s[j+1:j+1+length]) # Move to the next string i = j + 1 + length return decoded_strs"},{"question":"# Problem: Efficient Sorting with Constraints You have been given the task to sort a list of integers using the merge sort algorithm. Since this list can be very large, you need to ensure that your implementation is as efficient as possible in terms of space and time. **Function Signature** ```python def efficient_merge_sort(arr: List[int]) -> List[int]: pass ``` **Input** - `arr` (List[int]): A list of integers `arr` with size `n` (0 ≤ n ≤ 10^6). **Output** - Returns a new list of integers sorted in ascending order. **Constraints** - You must ensure that your solution is efficient for large datasets. - Optimize for the space complexity as much as possible while maintaining O(n log(n)) time complexity. **Example** ```python arr = [38, 27, 43, 3, 9, 82, 10] output = efficient_merge_sort(arr) print(output) # [3, 9, 10, 27, 38, 43, 82] ``` **Explanation** The provided list `[38, 27, 43, 3, 9, 82, 10]` is divided recursively into smaller sublists until each sublist contains only one element. The sublists are then merged together in sorted order to form the final sorted list `[3, 9, 10, 27, 38, 43, 82]`. **Edge Cases to Consider** - Empty array should return an empty array. - Arrays with one element should return the same array. - Arrays with duplicate numbers should maintain the relative order of these elements. Your task is to implement the `efficient_merge_sort` function ensuring it passes all tests efficiently even for large input sizes.","solution":"from typing import List def efficient_merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = efficient_merge_sort(arr[:mid]) right_half = efficient_merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Gnome Sieve: Sorting Algorithm Task Objective You are hired to implement and understand various sorting algorithms. Your task is to examine, implement, test and improve the Gnome Sort algorithm given below. This exercise will help you grasp sorting mechanisms and measure computational efficiency across different scenarios. ```python Below is the given Gnome Sort implementation. You can use it to understand the sorting logic and compare it against your modifications. def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr # Example Usage # arr = [34, 2, 10, -9] # sorted_arr = gnome_sort(arr) # print(sorted_arr) # Output: [-9, 2, 10, 34] ``` Task Statement 1. **Understanding**: Analyze the given Gnome Sort implementation above. 2. **Implementation**: Write a function `optimized_gnome_sort(arr: list) -> list` that optimizes the Gnome Sort algorithm for better performance. 3. **Edge Case Handling**: Ensure your function covers edge cases such as empty arrays and arrays with duplicate elements. 4. **Testing**: Write a second function `test_gnome_sort()` that tests both `gnome_sort` and `optimized_gnome_sort` against: - Empty arrays - Arrays with one element - Already sorted arrays - Reversely sorted arrays - Large random arrays 5. **Comparison**: Evaluate and document the performance difference between the original and optimized implementations using different test scenarios. **Function Signature**: ```python def optimized_gnome_sort(arr: list) -> list: # Your implementation here def test_gnome_sort(): # Your implementation here ``` **Constraints**: - `arr` contains `0 <= len(arr) <= 10^4` elements. - Elements in `arr` can range from `-10^6` to `10^6`. Submission Requirements: - Complete function implementation for `optimized_gnome_sort`. - Complete function implementation for `test_gnome_sort`. - Performance evaluation documentation.","solution":"def gnome_sort(arr): n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index-1]: index = index + 1 else: arr[index], arr[index-1] = arr[index-1], arr[index] index = index - 1 return arr # Optimized Gnome Sort implementation def optimized_gnome_sort(arr): pos = 0 while pos < len(arr): if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr"},{"question":"# String Decoding using Stack You are given an encoded string `s` that follows the encoding rule: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly `k` times. The value of `k` is always a positive integer. Your task is to write a function `decode_string` that decodes the given encoded string `s` and returns the decoded string. Function Signature ```python def decode_string(s: str) -> str: ``` Input - `s` (string): A valid encoded string. Output - Returns the fully decoded string. Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` Constraints - `1 <= len(s) <= 100` - You may assume no invalid input, i.e., no extra whitespaces, and well-formed square brackets. Performance Requirements - Time complexity should be O(n), where n is the length of the input string `s`. - Space complexity should be O(n), considering the usage of the stack for nested structures. **Scenario**: You come across a text format that uses a unique encoding technique to compress repeated phrases. As part of the decoding team, your job is to decode such strings accurately to restore the original text.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, repeat_num = stack.pop() current_string = last_string + current_string * repeat_num else: current_string += char return current_string"},{"question":"# Programming Question: Implement B-Tree Deletion Operations Given the implementation of a B-Tree data structure as described above, your task is to enhance its functionality by adding the following method: Function to Implement ```python def remove_key(self, key): Removes a key from the B-Tree. If the key exists, it deletes it and adjusts the tree accordingly to maintain B-Tree properties. If the key does not exist, it does nothing. Input: - key: the key to remove from the B-Tree. Output: - None ``` # Expected Input and Output * **Input**: Integer key to remove from the B-Tree. * **Output**: None (The function modifies the tree in place). # Constraints 1. The B-Tree class supports integers only. 2. Key removal should handle all necessary tree rebalancing operations including: * Removing from leaf nodes. * Removing from internal nodes with rebalancing (rotations and merges when necessary). # Additional Context You must handle edge cases where: * The node becomes underflown i.e., has fewer than t-1 keys. * The key is not present in the B-Tree. * The B-Tree has only one key and must be removed (root change). This exercise is designed to test your understanding of advanced data structures, specifically B-Trees, and your ability to handle complex operations like deletions that maintain tree properties. # Example ```python # Create BTree of minimum degree 2 (2-3 Trees) btree = BTree(t_val=2) keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys_to_insert: btree.insert_key(key) print(\\"Initial B-Tree:\\") btree.traverse_tree() # Expected Output: [5] [6, 7] [10, 12, 17, 20, 30] btree.remove_key(6) print(\\"nB-Tree after removing key 6:\\") btree.traverse_tree() # Expected output should adjust based on B-Tree properties. btree.remove_key(10) print(\\"nB-Tree after removing key 10:\\") btree.traverse_tree() # Ensure B-Tree properties are maintained. ```","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf self.keys = [] self.children = [] class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t # Function to remove a key from the subtree rooted with this node def remove_key(self, key): if not self.root: print(\\"The tree is empty\\") return self._remove_key(self.root, key) if len(self.root.keys) == 0: # If the root node has no keys if self.root.leaf: self.root = None else: self.root = self.root.children[0] def _remove_key(self, node, key): t = node.t idx = self._find_key(node, key) # If the key is in this node if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: # Case 1: Key is in a leaf node node.keys.pop(idx) else: # Case 2: Key is in an internal node self._remove_internal_node(node, key, idx) else: # If the node is a leaf, the tree does not contain the key if node.leaf: print(\\"The key {} is not in the tree\\".format(key)) return # If the node is an internal node child = node.children[idx] if len(child.keys) >= t: self._remove_key(child, key) else: self._fill(node, idx) if idx < len(node.keys) and node.keys[idx] != key: child = node.children[idx] self._remove_key(child, key) def _remove_internal_node(self, node, key, idx): t = node.t if len(node.children[idx].keys) >= t: predecessor = self._get_predecessor(node, idx) node.keys[idx] = predecessor self._remove_key(node.children[idx], predecessor) elif len(node.children[idx+1].keys) >= t: successor = self._get_successor(node, idx) node.keys[idx] = successor self._remove_key(node.children[idx+1], successor) else: self._merge(node, idx) self._remove_key(node.children[idx], key) def _get_predecessor(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_successor(self, node, idx): cur = node.children[idx+1] while not cur.leaf: cur = cur.children[0] return cur.keys[0] def _fill(self, node, idx): t = node.t if idx != 0 and len(node.children[idx-1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx+1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx-1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx-1] child.keys.insert(0, node.keys[idx-1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx-1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx+1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): t = node.t child = node.children[idx] sibling = node.children[idx+1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx+1) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and key > node.keys[idx]: idx += 1 return idx def traverse_tree(self): if self.root: self._traverse_tree(self.root) def _traverse_tree(self, node): for i in range(len(node.keys)): if not node.leaf: self._traverse_tree(node.children[i]) print(\\"{}\\".format(node.keys[i]), end=\\" \\") if not node.leaf: self._traverse_tree(node.children[-1]) def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: new_node = BTreeNode(self.t, False) new_node.children.append(self.root) self._split_child(new_node, 0, self.root) self.root = new_node self._insert_non_full(new_node, key) else: self._insert_non_full(root, key) def _insert_non_full(self, node, key): if node.leaf: idx = len(node.keys) - 1 node.keys.append(0) while idx >= 0 and key < node.keys[idx]: node.keys[idx + 1] = node.keys[idx] idx -= 1 node.keys[idx + 1] = key else: idx = len(node.keys) - 1 while idx >= 0 and key < node.keys[idx]: idx -= 1 idx += 1 if len(node.children[idx].keys) == 2 * self.t - 1: self._split_child(node, idx, node.children[idx]) if key > node.keys[idx]: idx += 1 self._insert_non_full(node.children[idx], key) def _split_child(self, parent, i, child): t = self.t new_child = BTreeNode(t, child.leaf) parent.keys.insert(i, child.keys[t - 1]) parent.children.insert(i + 1, new_child) new_child.keys = child.keys[t:(2*t - 1)] del child.keys[t - 1:] if not child.leaf: new_child.children = child.children[t:(2*t)] del child.children[t:(2*t)]"},{"question":"# Binary Tree Path Enumeration You are given the root of a binary tree. Your task is to enumerate all root-to-leaf paths in this tree. A root-to-leaf path is defined as a sequence starting from the root node and ending at any leaf node, with each consecutive pair of nodes in the sequence being connected by a direct edge in the tree. Write a function `enumerate_paths` that takes the root of a binary tree and returns a list of strings, with each string representing a root-to-leaf path. Each path should be recorded in the format `Node1->Node2->...->Leaf`. Function Signature ```python def enumerate_paths(root: Optional[TreeNode]) -> List[str]: ``` Input * `root` (TreeNode): The root node of the binary tree. It contains an integer value and references to left and right child nodes. Our TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * (List[str]): A list of strings representing all root-to-leaf paths in the binary tree. Constraints * The values of the nodes will be in the range `-100 <= Node.val <= 100`. Example ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(enumerate_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 root = TreeNode(1) print(enumerate_paths(root)) # Output: [\\"1\\"] # Example 3 root = None print(enumerate_paths(root)) # Output: [] ``` Performance * **Time Complexity** should be O(N) where N is the number of nodes in the binary tree. * **Space Complexity** should be O(H) where H is the height of the binary tree due to recursion.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def enumerate_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: # leaf paths.append(path) return if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Prime Number Check You are asked to implement a function to check if a number is prime using efficient trial division. Your function should handle edge cases and optimize for large input values. Function Signature ```python def prime_check(n): Return True if n is a prime number; otherwise, return False. :param n: Integer to check for primality :type n: int :return: Boolean indicating if n is prime :rtype: bool ``` Input * An integer ( n ) where (-10^6 leq n leq 10^6). Output * Return `True` if ( n ) is a prime number, otherwise return `False`. Constraints * You should handle the execution within a reasonable time for large values of ( n ). Example ```python print(prime_check(29)) # Output: True print(prime_check(15)) # Output: False print(prime_check(2)) # Output: True print(prime_check(-5)) # Output: False print(prime_check(0)) # Output: False ``` Scenario You are working on a cryptography project and need an efficient prime check function to generate prime keys for securing communication.","solution":"def prime_check(n): Return True if n is a prime number; otherwise, return False. :param n: Integer to check for primality :type n: int :return: Boolean indicating if n is prime :rtype: bool if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Scenario Your task is to implement and analyze the Interpolation Search algorithm for a sorted array. This algorithm works similarly to binary search but estimates the probable position of the target value directly based on its distribution in the array. Implementing this will test your understanding of search algorithms and handling of edge cases. # Task Write a function `interpolation_search` to find the index of a given search key in a sorted array using the Interpolation Search technique. # Function Signature ```python def interpolation_search(array: List[int], search_key: int) -> int: Given a sorted array and a search key, return the index of the search_key if it is present in the array, else return -1. :param array: List of integers, sorted in ascending order. :param search_key: An integer value to search for. :return: Index of search_key if found, else -1. Constraints: * The array will have a maximum length of 10^5. * Values in the array will be unique integers. Examples: >>> interpolation_search([1, 3, 5, 7, 9], 3) 1 >>> interpolation_search([1, 3, 5, 7, 9], 8) -1 >>> interpolation_search([-10, -5, 0, 5, 10, 15, 20], -5) 1 Considerations: * Ensure your implementation handles edge cases such as empty arrays and search keys outside the array bounds. * Avoid unnecessary computations to maintain performance. ``` # Performance Requirements Your implementation should work efficiently within the given constraints and handle the average case in O(log log n) time complexity. # Tips * Use appropriate error checking to handle edge cases. * Ensure that your implementation does not cause out-of-bound errors. * Utilize the `doctest` module to validate your function with provided test cases. Good luck!","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Given a sorted array and a search key, return the index of the search_key if it is present in the array, else return -1. :param array: List of integers, sorted in ascending order. :param search_key: An integer value to search for. :return: Index of search_key if found, else -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Estimating the probable position of search_key pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Maximum Flow Problem **Context**: You are working for a logistics company. They need to determine the maximum possible flow through their delivery network to optimize the routes taken by their trucks. The network is represented as a graph where each node is a distribution center, and each edge has a capacity indicating the maximum number of trucks that can pass through that route per unit time. Implement the function `max_flow(adjacency_matrix)` that calculates the maximum flow from the source node (first node) to the sink node (last node) in a directed graph represented by an adjacency matrix. **Function Signature**: ```python def max_flow(adjacency_matrix): \'\'\' :param adjacency_matrix: List[List[int]] : An n x n adjacency matrix representing the capacities of edges in the graph :return: int : The maximum flow from source to sink \'\'\' ``` **Input**: - `adjacency_matrix` (List[List[int]]): A square matrix of size `n x n` (2 ≤ n ≤ 100) where `adjacency_matrix[i][j]` is the capacity of the edge from node `i` to node `j`. **Output**: - Returns an integer, the maximum flow from the source node (0) to the sink node (n-1). **Constraints**: - All elements in `adjacency_matrix` are non-negative integers (0 ≤ adjacency_matrix[i][j] ≤ 1000). - There will be at least one path from the source to the sink. **Example**: Given adjacency matrix: ```python graph = [[0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0]] ``` The function should return `23`, which is the maximum flow from the source to the sink. **Notes**: - Carefully consider and handle edge cases, such as zero-capacity edges and disconnected nodes. - Ensure your implementation is efficient in both time and space to handle graphs of size up to 100x100.","solution":"def bfs(residual_graph, source, sink, parent): A utility function to perform BFS on the residual graph. Returns True if there is a path from source to sink in the residual graph. Additionally, fills parent to store the path. visited = [False] * len(residual_graph) queue = [] queue.append(source) visited[source] = True while queue: u = queue.pop(0) for v in range(len(residual_graph)): if visited[v] == False and residual_graph[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_flow(adjacency_matrix): Implements Ford-Fulkerson method to calculate maximum flow in a graph. source = 0 sink = len(adjacency_matrix) - 1 residual_graph = [row[:] for row in adjacency_matrix] parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Bogo Sort Simulation and Optimization You are given a theoretical and inefficient sorting algorithm named **Bogo Sort**. This algorithm randomly shuffles the elements of the array until it happens to be sorted. While this algorithm is impractical for general use, it provides an interesting case to study randomness and algorithmic efficiency. Task Your task is to implement an optimized version of Bogo Sort that, for the sake of this exercise, attempts to reduce its inefficiency through the following requirements: 1. Implement a function called `optimized_bogo_sort` which takes an array of integers as input and sorts it using a modified bogo sort method. 2. Introduce a limit to the number of shuffles. If the array is not sorted within provided shuffle attempts, use a deterministic method to finish sorting it. 3. Your function should also provide a way to simulate and display each shuffle (similar to the simulation option in the provided code). Input * An array of integers `arr` to be sorted. * An integer `limit` representing the maximum number of shuffles allowed before switching to a deterministic sort. Output * The sorted array. Constraints 1. 1 ≤ len(arr) ≤ 50 2. -10^3 ≤ arr[i] ≤ 10^3 3. 1 ≤ limit ≤ 10^5 Example ```python arr = [3, 2, 1, 4] limit = 1000 optimized_bogo_sort(arr, limit) # Output might be: [1, 2, 3, 4] showing the process within 1000 shuffles or switching to a deterministic sort. ``` Implement the function with the following signature: ```python def optimized_bogo_sort(arr: List[int], limit: int) -> List[int]: # Your code here ```","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def shuffle_array(arr: List[int]) -> None: Helper function to randomly shuffle the array in place random.shuffle(arr) def optimized_bogo_sort(arr: List[int], limit: int) -> List[int]: Sorts the array using an optimized bogo sort method. Parameters: arr (List[int]): The array of integers to be sorted. limit (int): Maximum number of shuffles before switching to deterministic sort. Returns: List[int]: The sorted array. shuffle_attempts = 0 while shuffle_attempts < limit: if is_sorted(arr): return arr shuffle_array(arr) shuffle_attempts += 1 # If limit reached, perform deterministic sort (fallback) return sorted(arr)"},{"question":"# Bubble Sort with Even Travel Objective To assess your understanding of the Bubble Sort algorithm and enhance it to handle additional constraints. Problem Statement You are given an array of integers. You need to sort the array in ascending order using an enhanced version of Bubble Sort. The twist is that during each pass from left to right, you should: - *Instead of only adjacent elements*, swap elements that are _evenly divisible_ by the given integer `k`. Implement a function `enhanced_bubble_sort(arr, k)` that takes in: - an array `arr` of integers, and - an integer `k`. Your function should return the sorted array in ascending order following the enhanced Bubble Sort logic described. Input: - `arr`: List of integers (1 ≤ len(arr) ≤ 1000; -10^5 ≤ arr[i] ≤ 10^5 for any valid integer `i`) - `k`: Integer (2 ≤ k ≤ 100) Output: - List of integers sorted in ascending order. Constraints: - The algorithm should run within a reasonable time frame for the input sizes given. Example: ```python arr = [12, 15, 6, 18, 9] k = 3 print(enhanced_bubble_sort(arr, k)) # Expected Output: [6, 9, 12, 15, 18] arr = [22, 5, 18, 3, 2] k = 2 print(enhanced_bubble_sort(arr, k)) # Expected Output: [2, 3, 5, 18, 22] ``` Additional Notes * Ensure the function maintains the basic properties of Bubble Sort. * Handle edge cases like arrays with a single element or already sorted arrays. * Optimize unnecessary passes where no swaps occur.","solution":"def enhanced_bubble_sort(arr, k): Sorts the array \'arr\' using an enhanced version of Bubble Sort, where during each pass, elements that are evenly divisible by \'k\' can be swapped. Parameters: arr (List[int]): The input array of integers. k (int): The integer for checking even divisibility. Returns: List[int]: The sorted array in ascending order. n = len(arr) for _ in range(n): swapped = False for i in range(1, n): # Check if the elements are both divisible by k if arr[i-1] % k == 0 and arr[i] % k == 0: if arr[i-1] > arr[i]: # Swap the elements as per the enhanced Bubble Sort logic arr[i-1], arr[i] = arr[i], arr[i-1] swapped = True if not swapped: break return sorted(arr)"},{"question":"You are given a number. Your task is to find the next higher number which has the exact same set of digits as the original number. If no such number exists (i.e., the digits are in descending order), return -1. # Function Signature ```python def next_bigger(num: int) -> int: ``` # Input - `num` (int): A positive integer fitting within the typical range of practical integer limits in Python. # Output - Returns an integer that represents the next higher number having the same set of digits as `num`. If such a number does not exist, returns -1. # Constraints - The input number will be a positive integer. - The solution should aim for O(n) time complexity, where n is the number of digits of the number. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(99999) == -1 ``` # Notes - The function should handle edge cases, such as inputs where no higher permutation exists or very short numbers like single digits. Your task is to implement the function `next_bigger` according to the given specifications.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit. i = n - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: return -1 # Step 2: Find the smallest digit on right side of (i\'th digit) which is greater than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after i digits = digits[:i+1] + digits[i+1:][::-1] return int(\'\'.join(digits))"},{"question":"# Matrix Manipulation in Scientific Computation In scientific computing, matrix operations are paramount, especially matrix multiplication, which is foundational for numerous fields like computer graphics, machine learning, and more. Given two matrices, your task is to implement a function that accurately multiplies them, ensuring their dimensions are compatible. **Function Specification**: Implement the function `matrix_multiply(multiplicand: list, multiplier: list) -> list`. * The function should take two matrices (2D lists) as input: * `multiplicand` - a 2D list where each element is a list of integers, representing the multiplicand matrix. * `multiplier` - a 2D list where each element is a list of integers, representing the multiplier matrix. * The function should return a 2D list representing the result of multiplying the two input matrices. **Requirements**: 1. Validate that the number of columns in the `multiplicand` matrix is equal to the number of rows in the `multiplier` matrix. If not, raise an `Exception` with the message `\\"Incompatible matrix dimensions.\\"`. 2. The input matrices can have varied dimensions but will always contain integer values. 3. Optimize for readability and correctness. The time complexity should remain O(n^3). **Performance Constraints**: * Given the cubic time complexity, be aware that for very large matrices (greater than 1000x1000), performance might degrade significantly. **Example**: ```python # Example 1 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] result = matrix_multiply(multiplicand, multiplier) # Expected output: [[19, 22], [43, 50]] # Example 2 multiplicand = [ [2, 3, 4], [1, 0, 0] ] multiplier = [ [0, 1000], [1, 100], [0, 10] ] result = matrix_multiply(multiplicand, multiplier) # Expected output: [[3, 2340], [0, 1000]] ```","solution":"def matrix_multiply(multiplicand, multiplier): Multiplies two matrices (2D lists) if their dimensions are compatible. Parameters: multiplicand (list of list of int): The matrix to be multiplied. multiplier (list of list of int): The matrix to multiply by. Returns: list of list of int: The resulting matrix after multiplication. Raises: Exception: If matrix dimensions are incompatible. # Validate dimensions if len(multiplicand[0]) != len(multiplier): raise Exception(\\"Incompatible matrix dimensions.\\") # Dimensions of the resulting matrix result_rows = len(multiplicand) result_cols = len(multiplier[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(result_cols)] for _ in range(result_rows)] # Perform matrix multiplication for i in range(result_rows): for j in range(result_cols): for k in range(len(multiplicand[0])): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Given an array of `words` and an array of `symbols`, implement a function that replaces the longest matching symbol in each word with the symbol wrapped in square brackets. If a word matches multiple symbols, the symbol with the longest length should be chosen. If no symbols match, the word should remain unchanged. Your solution should be optimized for efficiency. # Function Signature ```python def bracket_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Input - `words`: A list of strings where each string is a word (1 ≤ length of each word ≤ 100). - `symbols`: A list of strings where each string is a symbol (1 ≤ length of each symbol ≤ 50). # Output - A list of strings where each string is a word with the longest matching symbol replaced by its bracketed version. # Constraints - Mutations or replacement should only affect the first found occurrence of the longest matching symbol. - Symbols and words consist only of lowercase and uppercase alphabets. # Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Notes - Ensure to follow the performance guidelines to handle large inputs efficiently. - Carefully handle cases where words have no matching symbols without causing any errors. - Your trie-based solution should minimize both time and space complexity compared to a naive approach. # Hints 1. Construct a Trie for efficient symbol searching. 2. Traverse each word to find the longest matching symbol and replace it.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_symbol = False self.symbol = \\"\\" class Trie: def __init__(self): self.root = TrieNode() def insert(self, symbol: str): node = self.root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_symbol = True node.symbol = symbol def search_longest_symbol(self, word: str): node = self.root longest_symbol = \\"\\" i = 0 while i < len(word): if word[i] not in node.children: break node = node.children[word[i]] if node.is_end_of_symbol: longest_symbol = node.symbol i += 1 return longest_symbol def bracket_words(words: List[str], symbols: List[str]) -> List[str]: trie = Trie() for symbol in symbols: trie.insert(symbol) def replace_with_bracket(word: str) -> str: longest_symbol = \\"\\" for i in range(len(word)): current_symbol = trie.search_longest_symbol(word[i:]) if len(current_symbol) > len(longest_symbol): longest_symbol = current_symbol if longest_symbol: index = word.find(longest_symbol) return word[:index] + \'[\' + longest_symbol + \']\' + word[index + len(longest_symbol):] return word return [replace_with_bracket(word) for word in words]"},{"question":"# B-Tree Operations Implementation Scenario The B-tree is a powerful data structure used extensively in databases and filesystems due to its balanced nature and efficient operation times. To ensure that students understand both the implementation and potential challenges of using B-trees, we\'ll focus on implementing key functions: `insert`, `search`, and `delete` and their auxiliary methods, simulating a small-scale database. Task You are provided with a B-tree implementation partially. Your task is to: 1. **Complete the `insert_key` method**: This method should make sure the key is inserted correctly into the B-tree, maintaining its properties. 2. **Complete the `search` method**: This method should check whether a given key is present in the B-tree. 3. **Implement the `remove_key` method**: Ensure the key is deleted without violating the B-tree properties. Input and Output 1. **`insert_key` method**: - Input: An integer key to be inserted. - Output: The B-tree is updated with the new key inserted. 2. **`search` method**: - Input: An integer key to be searched. - Output: Boolean value (`True` if the key is found, otherwise `False`). 3. **`remove_key` method**: - Input: An integer key to be deleted. - Output: The B-tree is updated with the key removed. Constraints * Assume all keys are positive integers. * The B-tree has a minimum degree `t` of 2. Requirements - Ensure operations are performed in logarithmic time relative to the number of keys. - Handle edge cases such as inserting into a full root or deleting the only key in a tree with root merger. Example ```python bt = BTree(t_val=2) bt.insert_key(10) bt.insert_key(20) bt.insert_key(5) bt.insert_key(6) bt.insert_key(12) bt.insert_key(30) bt.insert_key(7) bt.insert_key(17) print(bt.search(6)) # True print(bt.search(15)) # False bt.remove_key(6) print(bt.search(6)) # False bt.remove_key(17) bt.traverse_tree() ``` Expected Output: ```plaintext True False False [5, 7] 10 [12] 20 [30] ```","solution":"class BTreeNode: def __init__(self, is_leaf=False): self.is_leaf = is_leaf self.keys = [] self.children = [] class BTree: def __init__(self, t_val): self.root = BTreeNode(is_leaf=True) self.t = t_val def traverse_tree(self): Traverse the B-tree starting from the root. self.__traverse(self.root) def __traverse(self, node): Recursively traverse the B-tree and print the keys in each node. if node is not None: i = 0 for i in range(len(node.keys)): if not node.is_leaf: self.__traverse(node.children[i]) print(f\\"{node.keys[i]} \\", end=\\"\\") if not node.is_leaf: self.__traverse(node.children[i + 1]) def search(self, k): Search for a key in the B-tree. return self.__search(self.root, k) def __search(self, node, k): Recursively search for a key in the B-tree. i = 0 while i < len(node.keys) and k > node.keys[i]: i += 1 if i < len(node.keys) and k == node.keys[i]: return True if node.is_leaf: return False return self.__search(node.children[i], k) def insert_key(self, k): Insert a key into the B-tree. root = self.root if len(root.keys) == 2 * self.t - 1: new_root = BTreeNode() new_root.is_leaf = False new_root.children.append(self.root) self.__split_child(new_root, 0) self.root = new_root self.__insert_non_full(self.root, k) def __split_child(self, parent, i): Split the child of a parent node. t = self.t y = parent.children[i] z = BTreeNode(is_leaf=y.is_leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2 * t - 1)] y.keys = y.keys[0: t - 1] if not y.is_leaf: z.children = y.children[t: (2 * t)] y.children = y.children[0: t] def __insert_non_full(self, node, k): Insert a key into a non-full node. i = len(node.keys) - 1 if node.is_leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self.__split_child(node, i) if k > node.keys[i]: i += 1 self.__insert_non_full(node.children[i], k) def remove_key(self, k): Remove a key from the B-tree. self.__remove_key(self.root, k) def __remove_key(self, node, k): t = self.t def merge(node, idx): child = node.children[idx] sibling = node.children[idx + 1] # Pull key from parent down into the child child.keys.append(node.keys[idx]) # Add keys from sibling to child for key in sibling.keys: child.keys.append(key) # Add child references from sibling to child if not sibling.is_leaf: for child in sibling.children: child.children.append(child) # Remove the key from parent node.keys.pop(idx) node.children.pop(idx + 1) def borrow_from_prev(node, idx): child = node.children[idx] sibling = node.children[idx - 1] # Shift all keys and children in child to make space child.keys.insert(0, node.keys[idx - 1]) if not child.is_leaf: child.children.insert(0, sibling.children.pop()) # Move key from sibling to parent node.keys[idx - 1] = sibling.keys.pop() def borrow_from_next(node, idx): child = node.children[idx] sibling = node.children[idx + 1] # Append to child child.keys.append(node.keys[idx]) if not child.is_leaf: child.children.append(sibling.children.pop(0)) # Move key from sibling to parent node.keys[idx] = sibling.keys.pop(0) def remove_from_leaf(node, idx): node.keys.pop(idx) def remove_from_non_leaf(node, idx): k = node.keys[idx] if len(node.children[idx].keys) >= t: pred = self.get_predecessor(node, idx) node.keys[idx] = pred self.__remove_key(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self.get_successor(node, idx) node.keys[idx] = succ self.__remove_key(node.children[idx + 1], succ) else: merge(node, idx) self.__remove_key(node.children[idx], k) if not node: return idx = 0 while idx < len(node.keys) and node.keys[idx] < k: idx += 1 if idx < len(node.keys) and node.keys[idx] == k: if node.is_leaf: remove_from_leaf(node, idx) else: remove_from_non_leaf(node, idx) elif node.is_leaf: return else: flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: if idx != 0 and len(node.children[idx - 1].keys) >= t: borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: borrow_from_next(node, idx) else: if idx != len(node.keys): merge(node, idx) else: merge(node, idx - 1) if flag and idx > len(node.keys): self.__remove_key(node.children[idx - 1], k) else: self.__remove_key(node.children[idx], k) def get_predecessor(self, node, idx): cur = node.children[idx] while not cur.is_leaf: cur = cur.children[-1] return cur.keys[-1] def get_successor(self, node, idx): cur = node.children[idx + 1] while not cur.is_leaf: cur = cur.children[0] return cur.keys[0]"},{"question":"# Question: Binomial Coefficient Calculation with Memoization You are required to implement a function that calculates the binomial coefficient, ( C(n, k) ), efficiently. The binomial coefficient is a common combinatorial function used to count the number of ways to choose ( k ) items from ( n ) items without consideration of their order. Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` Input * `n` (integer): The number of items to choose from. * `k` (integer): The number of items to select. Output * `int`: The binomial coefficient ( C(n, k) ). Constraints * ( n geq k geq 0 ) * ( 0 leq n leq 10^3 ) Performance Requirements * Utilize memoization to optimize the computation and minimize the recursion depth. Example ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(10, 5) == 252 assert binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Scenario Imagine you are part of a team developing a scientific calculator software. One of the functionalities of this software is to perform combinatorial calculations effectively. Implement the `binomial_coefficient` function with memoization to achieve optimal performance and accuracy.","solution":"def binomial_coefficient(n, k, memo=None): if memo is None: memo = {} # Base cases if k == 0 or k == n: return 1 if (n, k) in memo: return memo[(n, k)] # Recursive call with memoization memo[(n, k)] = binomial_coefficient(n-1, k-1, memo) + binomial_coefficient(n-1, k, memo) return memo[(n, k)]"},{"question":"Fibonacci Sequence Programming Challenge # Objective Compute the n-th Fibonacci number using various methods and analyze their performance. # Problem Description The Fibonacci sequence is a series of numbers where each number is obtained by adding the two preceding ones. The sequence starts with `0` and `1`. Given an integer `n`, your task is to write three functions to compute the n-th Fibonacci number using: 1. **Recursive Approach** 2. **Dynamic Programming Approach (using a list)** 3. **Iterative Approach** # Function Signatures ```python def fibonacci_recursive(n: int) -> int: pass def fibonacci_dynamic(n: int) -> int: pass def fibonacci_iterative(n: int) -> int: pass ``` # Input - `n`: A non-negative integer representing the position in the Fibonacci sequence. # Output - An integer representing the n-th Fibonacci number. # Constraints - ( 0 leq n leq 100 ) # Examples ```plaintext Input: n = 0 Output: 0 Input: n = 1 Output: 1 Input: n = 10 Output: 55 Input: n = 50 Output: 12586269025 ``` # Requirements 1. **Recursive Approach**: Implement a function `fibonacci_recursive` that computes the n-th Fibonacci number using a recursive approach. - Time Complexity should be ( O(2^n) ). 2. **Dynamic Programming Approach (using a list)**: Implement a function `fibonacci_dynamic` that uses dynamic programming to compute the n-th Fibonacci number. - Space Complexity and Time Complexity should both be ( O(n) ). 3. **Iterative Approach**: Implement a function `fibonacci_iterative` that computes the n-th Fibonacci number using an iterative approach. - Time Complexity should be ( O(n) ). # Edge Cases - Test the functions with `n = 0` and `n = 1` to ensure they handle the base cases properly. - Test the performance of each function for large values of `n` like `n = 100`. # Performance Analysis Analyze the performance of each approach in terms of time and space complexity. Discuss scenarios where each approach might be more suitable and any potential improvements.","solution":"def fibonacci_recursive(n): Returns the n-th Fibonacci number using a recursive approach. if n <= 1: return n return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2) def fibonacci_dynamic(n): Returns the n-th Fibonacci number using a dynamic programming approach. if n <= 1: return n fib = [0, 1] for i in range(2, n + 1): fib.append(fib[i - 1] + fib[i - 2]) return fib[n] def fibonacci_iterative(n): Returns the n-th Fibonacci number using an iterative approach. if n <= 1: return n a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are tasked with designing a simulation system that tracks islands forming in a 2D grid of water as you add land. Each operation consists of turning a water cell into land, and you are to determine the number of islands at each step. An island is defined as a group of contiguous land cells connected horizontally or vertically. # Union-Find Requirement Implement the Union-Find (or Disjoint Set) data structure to efficiently manage and merge sets of land cells as they are added. # Function Implementation Write a function `num_islands` that takes in a list of positions to operate and outputs the number of islands after each operation. The grid is surrounded by water and the initial state consists entirely of water. ```python def num_islands(positions): Given a list of positions to operate on, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. :param positions: List[List[int]] - A list of positions to operate. :return: List[int] - A list with the count of islands after each operation. pass ``` # Example Given a 3x3 grid and positions = [[0,0], [0,1], [1,2], [2,1]]: ```python 0 0 0 0 0 0 0 0 0 ``` * Add (0, 0), the grid becomes: ```python 1 0 0 0 0 0 0 0 0 ``` Number of islands = 1. * Add (0, 1), the grid becomes: ```python 1 1 0 0 0 0 0 0 0 ``` Number of islands = 1. * Add (1, 2), the grid becomes: ```python 1 1 0 0 0 1 0 0 0 ``` Number of islands = 2. * Add (2, 1), the grid becomes: ```python 1 1 0 0 0 1 0 1 0 ``` Number of islands = 3. # Constraints * You can assume the grid is infinite. * The input list `positions` is non-empty. * Each position is unique and consists of valid coordinates. # Note Use the Union-Find data structure to manage merging of sets and tracking isolated components (islands) efficiently.","solution":"class UnionFind: def __init__(self): self.parent = {} self.rank = {} self.count = 0 # Number of disjoint sets def add(self, p): if p not in self.parent: self.parent[p] = p self.rank[p] = 0 self.count += 1 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def num_islands(positions): uf = UnionFind() results = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for position in positions: r, c = position if (r, c) in uf.parent: # Skip if the land is already added results.append(uf.count) continue uf.add((r, c)) for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in uf.parent: uf.union((r, c), (nr, nc)) results.append(uf.count) return results"},{"question":"# String Matching in Large Database Logs You are working as a developer at a cybersecurity firm. One of your tasks is to detect specific attack patterns within massive logs of server activity. These logs are stored as large continuous text files. To efficiently search for a specified pattern within these logs, you’ve decided to use the Rabin-Karp algorithm. Write a function `find_pattern_in_logs(pattern, logs)` that takes two parameters: * `pattern`: A non-empty string representing the attack pattern to search for. * `logs`: A non-empty string representing the server logs. Your task is to implement the Rabin-Karp algorithm to find the first occurrence of the `pattern` in the `logs`. If the `pattern` is found, return its starting index in the logs; otherwise, return `None`. Constraints: * The length of `logs` can be very large (up to 1,000,000 characters). * The `pattern` should be non-empty and should not be larger than `logs`. Performance Requirements: * Ensure efficient hashing and minimal computation to handle large-sized logs. * Account for hash collision by verifying the actual substring when a match in hash values is found. Example: ```python pattern = \\"attack\\" logs = \\"jqlpdaattackjdqwlpdsflattack\\" result = find_pattern_in_logs(pattern, logs) print(result) # Output: 5 logs = \\"jglksjdfklsjfdkl\\" result = find_pattern_in_logs(pattern, logs) print(result) # Output: None logs = \\"aaattackaa\\" result = find_pattern_in_logs(\\"attack\\", logs) print(result) # Output: 2 ``` Note: * Be mindful of edge cases where `pattern` might occur multiple times. * Handle scenarios where the `pattern` might occur at the end of the `logs`. Implement the function `find_pattern_in_logs` below: ```python class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\")+1)*(26**(size_word - i - 1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\")+1)*26**(self.size_word-1) self.hash *= 26 self.hash += ord(self.text[self.window_end])- ord(\\"a\\")+1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def find_pattern_in_logs(pattern, logs): if not pattern or not logs or len(pattern) > len(logs): return None pattern_hash = RollingHash(pattern, len(pattern)) log_hash = RollingHash(logs, len(pattern)) for i in range(len(logs) - len(pattern) + 1): if log_hash.hash == pattern_hash.hash: if log_hash.window_text() == pattern: return i log_hash.move_window() return None ```","solution":"class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\")+1)*(26**(size_word - i - 1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\")+1)*26**(self.size_word-1) self.hash *= 26 self.hash += ord(self.text[self.window_end])- ord(\\"a\\")+1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def find_pattern_in_logs(pattern, logs): if not pattern or not logs or len(pattern) > len(logs): return None pattern_hash = RollingHash(pattern, len(pattern)) log_hash = RollingHash(logs, len(pattern)) for i in range(len(logs) - len(pattern) + 1): if log_hash.hash == pattern_hash.hash: if log_hash.window_text() == pattern: return i log_hash.move_window() return None"},{"question":"# Shell Sort Coding Assessment Question Context You have been given a list of integers that represent the number of views on various online articles. Your task is to sort the list in ascending order to display them in a report. To tackle this, you need to implement the Shell Sort algorithm which is known for its simplicity and adaptability for different types of data sequences. Function Signature You need to implement the function `shell_sort` which sorts a list of integers using the Shell Sort algorithm. ```python def shell_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers `arr` (0 ≤ len(arr) ≤ 10^5). Output * The sorted list of integers in ascending order. Constraints * Use an in-place sorting approach. * Consider edge cases, such as an empty list or a list with only one element. * Aim for an efficient sorting mechanism focusing on both time and space complexity. Example ```python shell_sort([23, 12, 1, 8, 34, 54, 2, 3]) # Returns: [1, 2, 3, 8, 12, 23, 34, 54] shell_sort([1, 2, 3]) # Returns: [1, 2, 3] shell_sort([5,9,1,3,4,6,6,3,2]) # Returns: [1, 2, 3, 3, 4, 5, 6, 6, 9] ``` Ensure your implementation handles the decrement of the gap value correctly and maintains efficient sorting even for large datasets. Additionally, test your implementation with multiple edge cases to validate correctness and performance.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"You are given a list of integers where every element appears exactly twice except for one, which appears once. Write a function to find this single number. This function should run in linear time and use constant space. # Function Signature ```python def find_single_number(nums: List[int]) -> int: pass ``` # Input - `nums` (List[int]): A list of integers where each element appears exactly twice except for one. # Output - `int`: The single number that appears only once. # Constraints - The length of the array will be in the range [1, 3 * 10^4]. - Each integer in the array will be within the range [-3 * 10^4, 3 * 10^4]. # Example ```python assert find_single_number([4,1,2,1,2]) == 4 assert find_single_number([2,2,1]) == 1 ``` # Explanation In the first example, the input array is [4,1,2,1,2]. Every element appears twice except for 4, which appears once. Thus, the output should be 4. In the second example, the input array is [2,2,1]. Every element appears twice except for 1, which appears once. Thus, the output should be 1. # Notes - Use the properties of the XOR operation to find the unique element. - Ensure that your solution runs in linear time with constant space complexity.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number that appears only once in a list where every other number appears exactly twice. Args: nums (List[int]): A list of integers where each element appears exactly twice except for one. Returns: int: The single number that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Counting Sort Implementation with Edge Cases Given an array of integers, implement the Counting Sort algorithm to sort the array in ascending order. Your implementation should be able to handle negative numbers as well as positive numbers, and should preserve the relative order of elements with the same value (i.e., it should be stable). Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers `List[int]` where -10^6 ≤ arr[i] ≤ 10^6. * Assume the size of the list does not exceed 10^6. # Output * The function should return a new list of integers `List[int]` sorted in ascending order. # Examples Example 1 ```python arr = [4, -2, -3, 3, 4, -1] expected_output = [-3, -2, -1, 3, 4, 4] assert counting_sort(arr) == expected_output ``` Example 2 ```python arr = [0, 0, 0, 0, 0] expected_output = [0, 0, 0, 0, 0] assert counting_sort(arr) == expected_output ``` Example 3 ```python arr = [] expected_output = [] assert counting_sort(arr) == expected_output ``` # Constraints * The solution must handle both positive and negative integers. * The space complexity should be considered and optimized where possible. # Performance Requirements * The solution should have a time complexity of O(n + k) and a space complexity of O(k).","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Sort an array of integers using the Counting Sort algorithm. This implementation handles both positive and negative numbers. if not arr: return [] # Determine the range of the input min_val = min(arr) max_val = max(arr) # Compute the range of the input numbers range_of_values = max_val - min_val + 1 # Initialize the count array count_arr = [0] * range_of_values # Populate the count array for num in arr: count_arr[num - min_val] += 1 # Transform the count array to store the cumulative sum for i in range(1, range_of_values): count_arr[i] += count_arr[i - 1] # Initialize the output (sorted) array output_arr = [0] * len(arr) # Build the output array using the count array (stable sorting) for num in reversed(arr): index = count_arr[num - min_val] - 1 output_arr[index] = num count_arr[num - min_val] -= 1 return output_arr"},{"question":"**Title**: Implement the Efficient Nearest Neighbor Algorithm with KD-Tree **Context**: You are working on a machine learning project that involves classifying input vectors based on a training set. The training set can be very large and includes high-dimensional data. Using a brute-force nearest neighbor search can be quite slow, so you need to implement a more efficient approach using a KD-Tree. **Problem Statement**: Write a Python function `kd_tree_nearest_neighbor` that efficiently finds the nearest neighbor of a given input vector using a KD-Tree. You will build the KD-Tree from the training set and then use it to find the nearest neighbor. **Input**: - An input vector `x` (a tuple of floats). - A training set `tSet` (a dictionary where keys are tuples representing vectors and values are labels). **Output**: - The label of the nearest neighbor to the input vector `x`. **Constraints**: - The input vector `x` and all keys in `tSet` will have the same dimension. - `tSet` is non-empty. **Function Signature**: ```python def kd_tree_nearest_neighbor(x: tuple, tSet: dict) -> any: pass ``` **Example**: ```python x = (2.5, 3.5) tSet = { (1.0, 2.0): \'A\', (3.5, 4.5): \'B\', (5.0, 1.0): \'C\', (2.0, 3.0): \'A\' } print(kd_tree_nearest_neighbor(x, tSet)) # Output might be \'A\' or \'B\' depending on the closest point ``` **Requirements**: - Your solution must include construction of the KD-Tree and the nearest neighbor search. - Ensure that the neighbor search handles edge cases appropriately and performs efficiently for large datasets. - Provide time complexity analysis. **Hints**: 1. A KD-Tree is a binary tree where each node represents a k-dimensional point; the tree\'s depth decides which dimension to split. 2. During the search, you do not need to fully explore both subtrees at every step.","solution":"from scipy.spatial import KDTree def kd_tree_nearest_neighbor(x, tSet): Finds the nearest neighbor of the input vector x using a KD-Tree built from the training set tSet. Parameters: - x: a tuple of floats representing the input vector. - tSet: a dictionary where keys are tuples representing vectors and values are labels. Returns: - The label of the nearest neighbor to the input vector x. # Extracting points and their labels from the training set points = list(tSet.keys()) labels = list(tSet.values()) # Constructing the KD-Tree kd_tree = KDTree(points) # Querying the nearest neighbor of x distance, index = kd_tree.query(x) # Returning the label of the nearest neighbor return labels[index]"},{"question":"# Missing Number Finder **Objective**: Write a function `missing_number(nums: List[int]) -> int` which returns the missing number from a sequence of unique integers in the range [0..n]. The difference between consecutive integers cannot be more than 1. If the sequence is already complete, the function should return the next integer in the sequence. **Function Signature**: ```python def missing_number(nums: List[int]) -> int: pass ``` **Input**: - `nums`: A list of unique integers (0 <= nums[i] <= n) representing the sequence. **Output**: - An integer representing the missing number. **Constraints**: - The length of the input list `nums` will be 0 <= len(nums) <= 10^6. - The numbers will be unique and within the range [0, n]. **Examples**: 1. Input: `nums = [4, 1, 3, 0, 6, 5, 2]` Output: `7` 2. Input: `nums = [0, 1, 2, 4, 5, 6]` Output: `3` 3. Input: `nums = [0, 1, 2, 3]` Output: `4` **Notes**: - The solution must operate within O(n) time complexity. - Consider implementing both the XOR-based and sum-based approaches and discuss which one you prefer and why.","solution":"from typing import List def missing_number(nums: List[int]) -> int: Returns the missing number from a sequence of unique integers in the range [0..n]. If no number is missing, returns the next integer in the sequence. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Radix Sort Implementation and Edge Case Handling You are tasked with implementing a radix sort algorithm in Python to sort an array of non-negative integers. Your function should handle the following edge cases and constraints: 1. Arrays of varying lengths, including empty arrays. 2. Large numbers up to 1,000,000. 3. The input array may contain duplicate values. Your task is to: 1. Write a function `radix_sort(arr: List[int]) -> List[int]` that takes a list of non-negative integers and returns a list of sorted integers. 2. Ensure that your implementation is efficient in terms of time and space complexity. 3. Include necessary checks and comments to handle common edge cases such as empty arrays. 4. Avoid unnecessary use of extra space. **Function Signature**: ```python from typing import List def radix_sort(arr: List[int]) -> List[int]: # Your implementation here ``` **Input**: - `arr`: List of integers (0 <= arr[i] <= 1,000,000) **Output**: - List of integers sorted in ascending order. **Example**: ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([]) == [] assert radix_sort([5]) == [5] assert radix_sort([1, 1, 1, 1]) == [1, 1, 1, 1] ```","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 # Change count[i] so it contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 i -= 1 for i in range(n): arr[i] = output[i] return arr def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr max1 = max(arr) exp = 1 while max1 // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Binary Tree Minimum Depth Finder Background In computer science, a binary tree is a data structure in which each node has at most two children, referred to as the left child and the right child. The minimum depth of a binary tree is the number of nodes along the shortest path from the root node down to the nearest leaf node. Problem Statement You are provided with a binary tree data structure. Your task is to implement two different methods to find the minimum depth of this binary tree: 1. A recursive method `recursive_min_depth(root: TreeNode) -> int` that uses depth-first search (DFS) principles. 2. An iterative method `iterative_min_depth(root: TreeNode) -> int` that uses breadth-first search (BFS) principles. Requirements 1. **Input**: Each function will receive the root node of the binary tree. The node is represented by the `TreeNode` class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 2. **Output**: Each function should return an integer representing the minimum depth of the tree. 3. **Constraints**: * The number of nodes in the tree is in the range [0, 10⁴]. * -1000 ≤ Node.val ≤ 1000 4. **Performance**: Aim for O(N) time complexity and O(N) space complexity in the worst case. Example ```python # Example Tree # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20) tree.right.left = TreeNode(15) tree.right.right = TreeNode(7) print(recursive_min_depth(tree)) # Output: 2 print(iterative_min_depth(tree)) # Output: 2 ``` Additional Notes * Consider edge cases such as an empty tree and a tree with only one node. * Handle scenarios where subtrees have uneven depths. Provide your implementations below: ```python def recursive_min_depth(root: TreeNode) -> int: # Implement the recursive solution here pass def iterative_min_depth(root: TreeNode) -> int: # Implement the iterative solution here pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def recursive_min_depth(root: TreeNode) -> int: if not root: return 0 if not root.left and not root.right: return 1 left_depth = float(\'inf\') if not root.left else recursive_min_depth(root.left) right_depth = float(\'inf\') if not root.right else recursive_min_depth(root.right) return min(left_depth, right_depth) + 1 def iterative_min_depth(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Question: Swap Adjacent Bits in an Integer Objective: Write a function `swap_pair(num: int) -> int` that swaps every pair of adjacent bits in the given integer number `num`. The function should leverage the techniques of bit manipulation to achieve this. Detailed Steps: 1. Mask all odd bits using `0xAAAAAAAA` and shift them right by 1 bit. 2. Mask all even bits using `0x55555555` and shift them left by 1 bit. 3. Combine the results of the previous steps using the OR (`|`) operation to get the final result. Input: - An integer `num` (0 <= num <= 2^32 - 1), representing a 32-bit unsigned number. Output: - An integer representing the number after swapping adjacent bits. Example: 1. `swap_pair(22)` should return `41` - Binary of 22: `010110` - Swap adjacent bits: `101001` (binary of 41) 2. `swap_pair(10)` should return `5` - Binary of 10: `1010` - Swap adjacent bits: `0101` (binary of 5) Constraints: - The integer input is strictly within the range of a 32-bit unsigned integer. - Consider testing edge cases such as 0 and 2^32-1 to ensure robust handling of the given constraints. Notes: - Do not use any libraries or functions that directly perform the swap bit operation. - The solution should prioritize efficiency, aiming for O(1) time complexity.","solution":"def swap_pair(num: int) -> int: Swap every pair of adjacent bits in a given 32-bit unsigned integer. Args: num (int): A 32-bit unsigned integer. Returns: int: The integer after swapping adjacent bits. # Mask odd bits odd_bits = (num & 0xAAAAAAAA) >> 1 # Mask even bits even_bits = (num & 0x55555555) << 1 # Combine the results return odd_bits | even_bits"},{"question":"# Coding Challenge **Context**: You are tasked with simulating a digital counter where each digit is represented as an element within an array. Imagine the counter reads a number stored as an array of its digits and you need to increment this number by one, similar to how mechanical counters operate. Your task is to implement a function that increments the number represented by an array of its digits by one. **Function Signature**: ```python def increment_number(digits: List[int]) -> List[int]: ``` # Input: * `digits` (List[int]): A list of integers where each element is a digit (0-9), and the most significant digit is at the head of the list. # Output: * List[int]: A list representing the incremented number. # Constraints: * The input list will not be empty. * Each element in the list will be in the range of [0, 9]. * The function should handle large numbers that do not fit into standard integer ranges. # Example: ```python assert increment_number([1, 2, 3]) == [1, 2, 4] assert increment_number([1, 2, 9]) == [1, 3, 0] assert increment_number([9, 9, 9]) == [1, 0, 0, 0] ``` # Requirements: * Optimize for both time (O(n)) and space (O(1)) where possible. * Ensure correct handling of leading digit carry (e.g., [9, 9] should become [1, 0, 0]). **Explanation**: The first example shows a standard increment with no carry-over. The second example demonstrates carry-over with no leading digit change, and the final example shows carry-over that results in a new leading digit. # Additional Notes: To complete this task, avoid using built-in functions that convert the digits to an integer type directly. This restriction ensures you manipulate the digits array manually as would be necessary in systems where integer size is constrained or the working environment requires digit-level control.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increment the number represented by the digits list by one. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we are here, it means we had a carry all way to the leftmost digit. return [1] + digits"},{"question":"**Food Order System** Imagine a restaurant wants to avoid repeating orders for the same dish in their system. Develop a function to filter out duplicate dishes from a list of orders. **Task**: Write a function `filter_unique_dishes(orders)` that takes a single argument: * `orders` (list of strings): A list of dish names (e.g., `\\"Spaghetti\\"`, `\\"Burger\\"`). Your function should return a new list containing only the first occurrence of each dish. The order of dishes in the output list should be the same as their first appearance in the input list. **Input**: * A list of up to `10^5` dish names, where each name is a string of up to `100` characters. **Output**: * A list of strings with each dish appearing exactly once, in the order they first appeared in the input list. **Constraints**: * The function should run in linear time, O(n), where n is the number of dishes in the list. * The space complexity should also be O(n). **Example**: ```python orders = [\\"Burger\\", \\"Pizza\\", \\"Burger\\", \\"Salad\\", \\"Pizza\\"] print(filter_unique_dishes(orders)) # Output: [\\"Burger\\", \\"Pizza\\", \\"Salad\\"] orders = [\\"Pasta\\", \\"Taco\\", \\"Burger\\", \\"Pasta\\", \\"Taco\\", \\"Salad\\"] print(filter_unique_dishes(orders)) # Output: [\\"Pasta\\", \\"Taco\\", \\"Burger\\", \\"Salad\\"] ``` **Explanation**: In the first example, the function removes the second occurrence of `\\"Burger\\"` and `\\"Pizza\\"`, resulting in a list without duplicates where `\\"Burger\\"`, `\\"Pizza\\"`, and `\\"Salad\\"` each appears only once. In the second example, `\\"Pasta\\"` and `\\"Taco\\"` each appear twice in the original list, but only their first occurrences are included in the returned list.","solution":"def filter_unique_dishes(orders): Filters out duplicate dishes from the list `orders` and returns a new list containing only the first occurrence of each dish. Parameters: orders (list of str): A list of dish names Returns: list of str: A list of unique dish names in the order of their first appearance. seen = set() unique_orders = [] for dish in orders: if dish not in seen: seen.add(dish) unique_orders.append(dish) return unique_orders"},{"question":"# Path Detection in a Directed Graph Context You are tasked with using a Depth-First Search (DFS) algorithm to determine if there is a path from a source node to a target node in a directed graph. Your graph consists of various vertices with directed edges connecting them. Problem Statement Implement a method to determine whether there exists a path from a given source vertex to a target vertex in a directed graph. Specifications * Implement the method: `def is_reachable(self, source: int, target: int) -> bool` * **Input**: Two integers (`source` and `target`), representing the source and target vertices. * **Output**: A boolean value (`True` if there is a path from the source to the target, `False` otherwise). Requirements 1. Utilize a depth-first search (DFS) traversal to explore the potential paths from the source vertex. 2. Ensure the use of a visited list to mark vertices that have already been explored to avoid redundant traversals. 3. Assume the graph\'s vertices are labeled from `0` to `N-1` where `N` is the number of vertices. 4. Handle edge cases like cyclic graphs, disconnected graphs, and graphs with only one node. Example ```python # Create a graph instance with 4 vertices graph = Graph(4) # Add edges to form the following graph: # 0 -> 1 # 1 -> 2 # 2 -> 3 graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) # Determine if there is a path from node 0 to node 3 assert graph.is_reachable(0, 3) == True # Determine if there is a path from node 3 to node 0 assert graph.is_reachable(3, 0) == False ``` Constraints * The number of vertices `N` in the graph is `1 <= N <= 1000`. * The number of edges `E` in the graph is `0 <= E <= 5000`. * The source and target nodes will always be valid nodes in the graph. Hint: Ensure that your traversal avoids infinite recursion by keeping track of visited nodes and appropriately handling direct and indirect paths to the target.","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def is_reachable(self, source, target): visited = [False] * self.vertices return self.dfs(source, target, visited) def dfs(self, current, target, visited): if current == target: return True visited[current] = True for neighbor in self.graph[current]: if not visited[neighbor]: if self.dfs(neighbor, target, visited): return True return False"},{"question":"# Question: Implement Custom Substring Search You are required to implement a function `find_substring` that searches for the first occurrence of a substring (needle) within a larger string (haystack). The function should return the index of the first occurrence of the needle in the haystack. If the needle is not part of the haystack, return `-1`. # Input Format: - `haystack`: A string within which the search is to be performed. - `needle`: The substring that needs to be found within the haystack. # Output Format: - Return an integer indicating the index of the first occurrence of the needle in the haystack. - If the needle is not found, return `-1`. # Constraints: - `0 <= len(haystack), len(needle) <= 10^5` - Both `haystack` and `needle` consist of only lowercase English characters. # Example 1: Input: ```text haystack = \\"hello\\" needle = \\"ll\\" ``` Output: ```text 2 ``` Explanation: The substring \\"ll\\" is found at index 2 of \\"hello\\". # Example 2: Input: ```text haystack = \\"aaaaa\\" needle = \\"bba\\" ``` Output: ```text -1 ``` Explanation: The substring \\"bba\\" is not found in \\"aaaaa\\". # Example 3: Input: ```text haystack = \\"\\" needle = \\"\\" ``` Output: ```text 0 ``` Explanation: When both haystack and needle are empty strings, return 0. # Performance Requirements: - Aim for a solution that works efficiently within the provided constraints. # Additional Context: Consider edge cases like empty strings and ensure that your solution handles them appropriately. Implement the solution without using any built-in substring search functions to demonstrate your understanding of string manipulation algorithms.","solution":"def find_substring(haystack, needle): Searches for the first occurrence of the substring needle in the haystack. Returns the index of the first occurrence or -1 if not found. if needle == \\"\\": return 0 needle_len = len(needle) haystack_len = len(haystack) if needle_len > haystack_len: return -1 for i in range(haystack_len - needle_len + 1): if haystack[i:i + needle_len] == needle: return i return -1"},{"question":"# Question You are given a class `Graph` which represents a directed graph using adjacency list representation. Your task is to implement the function `strongly_connected_components_count` that takes an instance of `Graph` and returns the number of strongly connected components (SCCs) in the graph. A strongly connected component is a maximal subgraph where every vertex is reachable from every other vertex in the subgraph. # Function Signature ```python def strongly_connected_components_count(graph: Graph) -> int: pass ``` # Input * `graph`: An instance of `Graph`. # Output * An integer representing the number of strongly connected components in the graph. # Requirements 1. The function should have a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. 2. Correctly count SCCs in any directed graph configuration, including disconnected graphs and graphs with isolated nodes. # Constraints * The number of vertices (V) will be in the range [1, 10^4]. * The number of edges (E) will be in the range [0, 10^5]. # Example ```python # Example Usage graph = Graph(5) graph.add_edge(1, 0) graph.add_edge(0, 2) graph.add_edge(2, 1) graph.add_edge(0, 3) graph.add_edge(3, 4) print(strongly_connected_components_count(graph)) # Output: 3 ``` In this example, the SCCs are: * [0, 1, 2] * [3] * [4] Thus, the function should return 3.","solution":"from collections import defaultdict, deque class Graph: def __init__(self, vertices): self.V = vertices self.graph = defaultdict(list) def add_edge(self, u, v): self.graph[u].append(v) def strongly_connected_components_count(graph): def fill_order(v, visited, stack): visited[v] = True for i in graph.graph[v]: if not visited[i]: fill_order(i, visited, stack) stack.append(v) def dfs(v, visited, transposed_graph): visited[v] = True for i in transposed_graph[v]: if not visited[i]: dfs(i, visited, transposed_graph) stack = [] visited = [False] * graph.V for i in range(graph.V): if not visited[i]: fill_order(i, visited, stack) transposed_graph = defaultdict(list) for i in range(graph.V): for j in graph.graph[i]: transposed_graph[j].append(i) visited = [False] * graph.V count_of_scc = 0 while stack: i = stack.pop() if not visited[i]: dfs(i, visited, transposed_graph) count_of_scc += 1 return count_of_scc"},{"question":"# Coding Challenge: Flatten Nested Iterables Scenario You are developing software that processes large datasets. In many real-world scenarios, data comes nested in complex structures such as JSON objects or multidimensional arrays. To simplify data manipulation, you need a utility that can flatten these nested structures into a single list, regardless of the levels of nesting. Task Implement a function `flatten` that takes a possibly-nested structure of iterables and returns a flat list of all the elements. Additionally, implement a generator function `flatten_iter` that does the same, but yields each element one by one without constructing the entire list at once. Function Signatures ```python def flatten(input_arr: Iterable) -> list: pass def flatten_iter(input_arr: Iterable) -> Iterable: pass ``` Input - `input_arr` (Iterable): A nested iterable (e.g., list of lists, tuple containing lists, etc.) Output - `flatten`: returns a single list containing all elements from the nested structure. - `flatten_iter`: yields elements from the nested structure one by one. Examples ```python # Example Input input_arr = [1, [2, [3, 4]], 5] # Example output for flatten [1, 2, 3, 4, 5] # Example Input input_arr = (1, [2, (3, 4)], 5) # Example output for flatten_iter # The generator should yield: 1, 2, 3, 4, 5 in sequence. ``` Constraints - Do not consider string types as iterables to be flattened. - The input can have deeply nested structures but should not exceed Python\'s recursion limit. - Input can include different types of iterables within the same structure. Performance - Your solution should efficiently handle large datasets with moderate levels of nesting. - Optimized memory usage is crucial for `flatten_iter`. Implement these functions guided by the analysis of the provided snippet and ensure it adheres to the described input/output formats.","solution":"from collections.abc import Iterable def flatten(input_arr): Flattens a nested iterable into a single list. Parameters: input_arr (Iterable): A nested iterable Returns: list: A flat list containing all elements from the nested structure flat_list = [] def _flatten(element): if isinstance(element, Iterable) and not isinstance(element, (str, bytes)): for item in element: _flatten(item) else: flat_list.append(element) _flatten(input_arr) return flat_list def flatten_iter(input_arr): A generator function that flattens a nested iterable and yields elements one by one. Parameters: input_arr (Iterable): A nested iterable Yields: Elements from the nested structure one by one. if isinstance(input_arr, Iterable) and not isinstance(input_arr, (str, bytes)): for item in input_arr: yield from flatten_iter(item) else: yield input_arr"},{"question":"Merge and Reverse Sorted Linked Lists Scenario: You are given two sorted linked lists. Your task is to merge these two linked lists into a new sorted linked list and then reverse the final linked list. Problem: Write a function `merge_and_reverse_lists(l1: Node, l2: Node) -> Node` that merges two sorted linked lists and then reverses the merged list. Requirements: 1. **Input Format**: Two heads of sorted linked lists, `l1` and `l2`. 2. **Output Format**: Head of the new linked list which is the reverse of the merged sorted linked list. 3. You should maintain the original order of duplicates in the merged list before reversing it. 4. **Constraints**: - Both linked lists will have at least one node. - Values in the nodes are integers and can be negative. Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_and_reverse_lists(l1: Node, l2: Node) -> Node: # Your implementation here ``` Example: ```python # Example of creating nodes and lists # List1: 1 -> 2 -> 4 l1 = Node(1) l1.next = Node(2) l1.next.next = Node(4) # List2: 1 -> 3 -> 4 l2 = Node(1) l2.next = Node(3) l2.next.next = Node(4) # Expected merged list before reversing: 1->1->2->3->4->4 # Expected final result after reversing: 4->4->3->2->1->1 result = merge_and_reverse_lists(l1, l2) # Output verification code can traverse the list and print it current = result while current: print(current.val, end=\\"->\\") current = current.next # Output should print: 4->4->3->2->1->1-> ``` Notes: * Ensure that your solution handles all edge cases appropriately. * Aim for an optimal implementation.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def merge_and_reverse_lists(l1: Node, l2: Node) -> Node: def merge(l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next def reverse(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # First merge the lists merged_list = merge(l1, l2) # Then reverse the merged list reversed_list = reverse(merged_list) return reversed_list"},{"question":"# Scenario You\'re working on a software project that involves processing a large dataset stored in binary search trees (BSTs). Efficiently traversing these trees to extract data in ascending order without loading the entire tree into memory is crucial. Your team has decided to implement a BST iterator to achieve this. # Task Implement a `BSTIterator` class that represents an iterator over a binary search tree (BST). The iterator should allow for in-order traversal (ascending order traversal) of the BST nodes. # Requirements 1. Implement the `BSTIterator` class with the following functions: * **`__init__(self, root)`**: Initialize the iterator with the root node of the BST. * **`has_next(self)`**: Return `True` if there are more nodes to visit, otherwise return `False`. * **`next(self)`**: Return the next smallest value in the BST. # Input and Output * **Input**: The `BSTIterator` initializer will be given a binary search tree\'s root node. * **Output**: Iterator methods will return booleans and integers as specified. # Constraints 1. Nodes in the BST will have unique integer values. 2. Node count ( n leq 10^4 ). # Example ```python # Example usage: # Construct the following BST # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15, TreeNode(9), TreeNode(20)) iterator = BSTIterator(root) print(iterator.next()) # Output: 3 print(iterator.next()) # Output: 7 print(iterator.has_next()) # Output: True print(iterator.next()) # Output: 9 print(iterator.has_next()) # Output: True print(iterator.next()) # Output: 15 print(iterator.has_next()) # Output: True print(iterator.next()) # Output: 20 print(iterator.has_next()) # Output: False ``` # Notes * Ensure your iterator handles skewed trees efficiently. * Pay attention to edge cases where the tree is empty or has only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): self.stack = [] self._push_left(root) def _push_left(self, node): while node: self.stack.append(node) node = node.left def has_next(self): return len(self.stack) > 0 def next(self): next_node = self.stack.pop() if next_node.right: self._push_left(next_node.right) return next_node.val"},{"question":"Context You are given a string `s` and two other strings `part1` and `part2`. Your task is to determine if the string `s` can be formed by merging `part1` and `part2`, maintaining the order of characters in both parts. Problem Statement Write a function named `is_merge(s: str, part1: str, part2: str) -> bool` that returns `True` if the string `s` can be formed by merging `part1` and `part2`, otherwise returns `False`. The merging must maintain the order of characters as they appear in `part1` and `part2`. Input * `s` (1 <= len(s) <= 100): Target string to be checked. * `part1` and `part2` (0 <= len(part1), len(part2) <= 100): Strings that are to be merged to form `s`. Output * Returns a boolean value: `True` if `s` can be formed by merging `part1` and `part2`, otherwise `False`. Constraints * Characters in `part1` and `part2` must appear in the same order in `s`. * Both `part1` and `part2` can be empty, but `s` cannot exceed the combined length of `part1` and `part2`. Examples ```python assert is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") == True assert is_merge(\\"codewars\\", \\"code\\", \\"wars\\") == True assert is_merge(\\"codewars\\", \\"cdw\\", \\"ezoars\\") == False assert is_merge(\\"abc\\", \\"\\", \\"abc\\") == True assert is_merge(\\"abc\\", \\"abc\\", \\"\\") == True assert is_merge(\\"abc\\", \\"a\\", \\"bc\\") == True assert is_merge(\\"abc\\", \\"ab\\", \\"c\\") == True assert is_merge(\\"aabcc\\", \\"abc\\", \\"abc\\") == False assert is_merge(\\"aabcc\\", \\"aab\\", \\"cc\\") == True ``` Additional Task Optimize the base algorithm using dynamic programming to ensure a reasonable time complexity. Provide an time and space complexity analysis of your optimized solution. Starter Code ```python def is_merge(s: str, part1: str, part2: str) -> bool: # Implement your solution here. pass # Write your tests below this line to validate your function. ```","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: m, n, o = len(s), len(part1), len(part2) if m != n + o: return False dp = [[False] * (n + 1) for _ in range(o + 1)] dp[0][0] = True for i in range(1, o + 1): dp[i][0] = dp[i - 1][0] and part2[i - 1] == s[i - 1] for j in range(1, n + 1): dp[0][j] = dp[0][j - 1] and part1[j - 1] == s[j - 1] for i in range(1, o + 1): for j in range(1, n + 1): dp[i][j] = (dp[i - 1][j] and part2[i - 1] == s[i + j - 1]) or (dp[i][j - 1] and part1[j - 1] == s[i + j - 1]) return dp[o][n]"},{"question":"# Scenario You are working on a program that requires duplication of elements in a stack for a particular processing sequence. In this task, you will implement a function that duplicates each element of a given stack. You have the flexibility to use either an additional stack or a queue for your implementation. # Task Write a function `stutter_stack(stack: List[int]) -> List[int]` that takes a stack represented as a list of integers and returns a new stack where each element is duplicated. # Constraints * The input stack will not exceed `10^6` elements. * You should aim for O(n) time complexity and O(n) space complexity. # Example * Suppose the stack stores these values: ```python stack = [3, 7, 1, 14, 9] ``` * After calling `stutter_stack(stack)`, the stack should store these values: ```python stack = [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Input A list of integers representing the stack, with the end of the list being the top of the stack. For example, `[3, 7, 1, 14, 9]` represents the stack `bottom [3, 7, 1, 14, 9] top`. # Output A list of integers representing the modified stack, where each value is duplicated. # Example ```python # Initial stack stack = [3, 7, 1, 14, 9] # After stuttering new_stack = stutter_stack(stack) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] print(new_stack) ``` # Additional Notes You are not allowed to change the order of elements in the stack other than duplicating them. Your implementation should ensure the original order is preserved after duplication.","solution":"def stutter_stack(stack): Given a stack represented as a list of integers, returns a new stack where each element is duplicated. result_stack = [] for element in stack: result_stack.append(element) result_stack.append(element) return result_stack"},{"question":"Range Minimum Query with Updates using Segment Tree You are asked to implement a Segment Tree to efficiently handle range minimum queries and updates for a dynamic array of integers. Specifically, you will build a segment tree to answer the minimum element in a range and update the value at a specific position. Function Signature: ```python class SegmentTree: def __init__(self, arr: List[int]): pass def update(self, p: int, v: int) -> None: pass def query(self, l: int, r: int) -> int: pass ``` Task: 1. **Initialization** (`__init__`): Initialize the Segment Tree with the given integer array `arr`. * **Input**: A list of integers `arr` representing the initial array. * **Output**: None 2. **Update** (`update`): Update the value at index `p` to `v`. * **Input**: integers `p` (index to update) and `v` (new value). * **Output**: None 3. **Query** (`query`): Return the minimum value in the subarray ranging from index `l` to `r`. * **Input**: integers `l` (left index) and `r` (right index). * **Output**: integer representing the minimum value in the specified range. Example: ```python # Initializing with array [1, 3, 2, 7, 9, 11] segment_tree = SegmentTree([1, 3, 2, 7, 9, 11]) # Querying the range [1, 3] print(segment_tree.query(1, 3)) # Output: 2 (minimum from [3, 2, 7]) # Updating index 3 to value 0 segment_tree.update(3, 0) # Querying the range [1, 3] again print(segment_tree.query(1, 3)) # Output: 0 (minimum from [3, 2, 0]) ``` Constraints: * 1 ≤ arr.length ≤ 10^5 * 0 ≤ arr[i] ≤ 10^6 * 0 ≤ p < arr.length * 0 ≤ l ≤ r < arr.length Your implementation should efficiently handle multiple queries and updates with a time complexity of O(log N).","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): # Set value at position p p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = min(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Range query minimum value l += self.n r += self.n + 1 res = float(\'inf\') while l < r: if l % 2: res = min(res, self.tree[l]) l += 1 if r % 2: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"Scenario You are tasked with creating a monitoring system for a logistics company where packages are processed using a stack data structure. Before processing, the company wants to ensure that the package IDs stored in a stack are in ascending order (smallest ID at the bottom). To help with this, you need to write a function that checks if the elements in the stack are sorted in increasing order. Task Write a function `is_stack_sorted` that accepts a stack (represented as a list) as its parameter and returns a boolean indicating whether the stack is sorted in ascending order from bottom to top. # Implementation Details - **Input**: A list `stack` representing the stack, where `stack[0]` is the bottom element and `stack[-1]` is the top element. - **Output**: A boolean `True` if the stack is sorted in ascending order, `False` otherwise. - **Constraints**: - The stack can be empty. An empty stack should be considered sorted. - The stack will only contain integers. # Example ```python # Example 1: stack = [1, 2, 3, 4, 5, 6] print(is_stack_sorted(stack)) # Output: True # Example 2: stack = [6, 3, 5, 1, 2, 4] print(is_stack_sorted(stack)) # Output: False # Example 3: stack = [] print(is_stack_sorted(stack)) # Output: True # Example 4: stack = [10] print(is_stack_sorted(stack)) # Output: True ``` Requirements 1. Ensure the original order of elements in the stack is preserved after the function executes. 2. The function should handle edge cases effectively, including empty stacks and stacks with only one element. 3. Aim to write an efficient solution that minimizes unnecessary space usage.","solution":"def is_stack_sorted(stack): Checks if the stack is sorted in ascending order from bottom to top. Parameters: stack (list): A list representing the stack, where stack[0] is the bottom element and stack[-1] is the top element. Returns: bool: True if the stack is sorted in ascending order, False otherwise. # Edge case: an empty stack or a stack with one element is considered sorted if len(stack) <= 1: return True # Check if each element is less than or equal to the next element for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"Objective: Implement a function using the Interpolation Search algorithm to find the index of a target value in a given sorted array. Your implementation should handle edge cases and ensure optimal performance for uniformly distributed arrays. Problem Statement: You are tasked to write a function `find_target_index` that takes a sorted array of integers and a target integer as inputs and returns the index of the target integer in the array. If the target integer is not present in the array, return `-1`. Function Signature: ```python def find_target_index(array: List[int], target: int) -> int: pass ``` Input: * `array` (List[int]): A sorted array of integers. * `target` (int): The integer value you need to find in the array. Output: * `int`: The index of the target integer if found, otherwise `-1`. Constraints: 1. The array is sorted in non-decreasing order. 2. The array can contain both positive and negative integers. 3. Array length can vary from `0` to `10^5`. 4. The array elements and the target can range from `-10^9` to `10^9`. Performance Requirement: * The solution should ideally work within O(log(log n)) time complexity for uniformly distributed arrays. * Ensure handle edge cases effectively to avoid performance bottlenecks. Examples: ```python print(find_target_index([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 print(find_target_index([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(find_target_index([], 5)) # Output: -1 print(find_target_index([1, 2, 3, 4, 5], 1)) # Output: 0 ``` Additional Instructions: - Do not use built-in functions like `index` or `find` to directly solve the problem. - Handle edge cases such as empty arrays and elements out of bounds of the array. - Ensure your code runs efficiently for large input sizes within the constraints.","solution":"from typing import List def find_target_index(array: List[int], target: int) -> int: Applies interpolation search algorithm to find the index of a target value in a sorted array. Parameters: array (List[int]): A sorted list of integers. target (int): The integer value to be searched in the array. Returns: int: The index of the target integer if found, otherwise -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and target >= array[low] and target <= array[high]: if low == high: if array[low] == target: return low return -1 # Estimation using interpolation formula pos = low + ((target - array[low]) * (high - low) // (array[high] - array[low])) # Bound check for pos within valid index range in the array if pos < low or pos > high: return -1 if array[pos] == target: return pos if array[pos] < target: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Context You are working on a low-level graphics processing application where it is required to manipulate colors represented in binary format. An essential task involves swapping every pair of bits in binary representations of integer values to modify the color patterns efficiently. Problem Statement Implement a function named `swap_pair` that swaps the odd and even bits of a given 32-bit unsigned integer. The function should perform this operation with as few instructions as possible to ensure maximum efficiency. The function signature is: ```python def swap_pair(num: int) -> int: ``` Input * A single integer `num`, where `0 <= num <= 2^32 - 1`. Output * Return an integer result where all pairs of bits in the input are swapped. Constraints * You must use bitwise operations to achieve the result. * Avoid using loops or recursion. * Aim for an O(1) solution in time complexity. Example *Example 1*: ```python swap_pair(22) # Expected output: 41 ``` Explanation: `22` in binary is `010110`. After swapping pairs the result is `101001` which is `41` in decimal. *Example 2*: ```python swap_pair(10) # Expected output: 5 ``` Explanation: `10` in binary is `1010`. After swapping pairs the result is `0101` which is `5` in decimal.","solution":"def swap_pair(num: int) -> int: Swap odd and even bits in a 32-bit unsigned integer. # Mask for even bits (0xAAAAAAAA is 10101010101010101010101010101010 in binary) even_bits = num & 0xAAAAAAAA # Mask for odd bits (0x55555555 is 01010101010101010101010101010101 in binary) odd_bits = num & 0x55555555 # Right shift even bits even_bits >>= 1 # Left shift odd bits odd_bits <<= 1 # Combine the shifted bits return even_bits | odd_bits"},{"question":"**Scenario**: You\'re assisting the production team in validating the sorted batches of products lined up for quality inspection. Each batch is represented as a stack of product IDs. Your task is to implement a function that verifies if any given stack of IDs is sorted in ascending order from the bottom to top. **Function to Implement**: ```python def is_sorted(stack): Determines if the given stack\'s elements are in ascending order from bottom to top. Parameters: stack (list): A list of integers representing the stack (with the first element as the bottom). Returns: bool: True if the stack is sorted in ascending order from bottom to top, False otherwise. pass ``` **Input Format**: - `stack`: A list of integers representing product IDs in a stack format where the first element is at the bottom and the last element is at the top. **Output Format**: - Returns a boolean `True` if the stack is ordered from bottom to top in ascending order, otherwise `False`. **Constraints**: - The list can contain negative and positive integers. - The list size can range from 0 to 10^6. **Performance Requirements**: - The solution should aim for an O(n) time complexity. - Space usage should be kept minimal but a trade-off with time complexity is acceptable within O(n) auxiliary space. **Example**: ```python # Example 1: stack = [1, 2, 3, 4, 5, 6] assert is_sorted(stack) == True # Example 2: stack = [6, 3, 5, 1, 2, 4] assert is_sorted(stack) == False # Example 3: stack = [] assert is_sorted(stack) == True # Example 4: stack = [3] assert is_sorted(stack) == True ```","solution":"def is_sorted(stack): Determines if the given stack\'s elements are in ascending order from bottom to top. Parameters: stack (list): A list of integers representing the stack (with the first element as the bottom). Returns: bool: True if the stack is sorted in ascending order from bottom to top, False otherwise. for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"A non-profit fundraising event is ongoing, and you are tasked with finding all possible ways to sum up to a specific donation goal using different donation amounts. Given a list of possible donation amounts (candidates) and a target donation goal, write a function to find all unique combinations of donations that sum up to exactly the target amount. Each possible donation can be used multiple times. Your task is to implement the function `donation_combinations(candidates: List[int], target: int) -> List[List[int]]`. # Function Signature ```python from typing import List def donation_combinations(candidates: List[int], target: int) -> List[List[int]]: pass ``` # Input and Output Format - **Input**: - `candidates`: A list of positive integers representing the possible donation amounts. No duplicates are present in this list. - `target`: A positive integer representing the desired sum of donations. - **Output**: - A list of lists, where each inner list represents a unique combination of donation amounts that sum to the target. # Constraints - All candidate numbers and the target will be positive integers. - No duplicate combinations should be returned. - The candidate list and target will always be valid and will fit into memory. # Example ```python candidates = [2, 3, 6, 7] target = 7 # Possible combinations summing to 7 are: # [7], [2, 2, 3] assert donation_combinations(candidates, target) == [[7], [2, 2, 3]] ``` # Explanation - In the above example, we can achieve the target sum of 7 by either using one 7 or two 2s and one 3. - The solution must include all unique combinations of candidates that sum up to the target. # Performance Requirements - The solution should efficiently handle larger lists of candidates and higher target values, with optimal use of recursion and backtracking.","solution":"from typing import List def donation_combinations(candidates: List[int], target: int) -> List[List[int]]: def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() candidates.sort() result = [] backtrack(target, [], 0) return result"},{"question":"# Digit Counter Function Context You have been tasked with writing a function that determines the number of digits in an integer. This function is crucial for an application that needs to process and summarize various numerical statistics quickly and efficiently. Task Write a function named `num_digits` that takes an integer `n` as input and returns the number of digits in `n`. Your function should handle both negative and positive integers correctly as well as zero. Function Signature ```python def num_digits(n: int) -> int: pass ``` Input * An integer `n` (|n| <= 10^18) Output * An integer representing the number of digits in `n`. Example ```python assert num_digits(12345) == 5 assert num_digits(-98765) == 5 assert num_digits(0) == 1 ``` Constraints * The function should be efficient, running in constant time regardless of the size of `n`. * The function should be able to handle negative numbers by considering the absolute value during computation.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the integer n. Handles both positive and negative numbers as well as zero. return len(str(abs(n)))"},{"question":"You are given two sorted singly linked lists. Your task is to write a function that merges these two lists into a new sorted linked list and returns the head of this new list. The function should demonstrate an understanding of managing multiple sorted data sources and efficiently combining them. # Function Signature: ```python def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: pass ``` # Input: * `l1`: The head of the first sorted linked list. * `l2`: The head of the second sorted linked list. # Output: * The head of the new merged sorted linked list. # Constraints: 1. The input linked lists are sorted in non-decreasing order. 2. The number of nodes in both lists combined is at most 10^4. 3. Each node contains an integer value. # Example: ```text Input: List1: 1 -> 2 -> 4 List2: 1 -> 3 -> 4 Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 ``` # Notes: * Solve the problem using both iterative and recursive methods. * Ensure handling of edge cases where one or both lists might be empty. * Discuss and comment on the time and space complexity of your solution. # Hint: * Pay close attention to edge scenarios such as null or significantly imbalanced lists. * Consider writing tests for both very small and very large input lists to validate your solution\'s performance and correctness.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_two_sorted_lists(l1: Node, l2: Node) -> Node: dummy = Node() current = dummy # Merge the two lists iteratively while l1 is not None and l2 is not None: if l1.value <= l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Handle the remaining nodes in l1 or l2 if l1 is not None: current.next = l1 elif l2 is not None: current.next = l2 return dummy.next"},{"question":"# Question You are given a partially implemented `PriorityQueue` class using a linear array as provided above. Your task is to extend this class to include an additional method named `merge` that merges another priority queue into the existing one while maintaining the priority order. Requirements - Implement a method `merge` that takes another `PriorityQueue` as an argument. - The method should merge all elements of the provided priority queue into the current priority queue while ensuring that the merged priority queue maintains the correct priority order. Method Signature ```python def merge(self, other_queue: \'PriorityQueue\'): Merges another priority queue into the current priority queue. Parameters: other_queue (PriorityQueue): The priority queue to be merged into the current one. Returns: None ``` Example ```python pq1 = PriorityQueue(items=[3, 1, 4], priorities=[30, 10, 40]) pq2 = PriorityQueue(items=[2, 5], priorities=[20, 50]) pq1.merge(pq2) print(pq1) # PriorityQueue([5: 50, 4: 40, 3: 30, 2: 20, 1: 10]) ``` Constraints - Ensure correct merging of elements without using additional sorting utilities. - Aim to maintain the original O(n) insertion complexity as much as possible. Edge Cases - Merging with an empty queue should not affect the original queue. - The original queue being empty should result in containing all elements of the other queue post-merge. Performance The method should efficiently handle merging and maintain an ordered list ensuring the overall functionality of the `PriorityQueue`.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): if items is None: self.items = [] else: self.items = items if priorities is None: self.priorities = [] else: self.priorities = priorities # Ensure priorities and items are sorted based on priority self._sort_by_priority() def _sort_by_priority(self): combined = sorted(zip(self.priorities, self.items), reverse=True) if combined: # valid and has elements self.priorities, self.items = zip(*combined) self.priorities = list(self.priorities) self.items = list(self.items) else: self.priorities = [] self.items = [] def merge(self, other_queue): Merges another priority queue into the current priority queue. Parameters: other_queue (PriorityQueue): The priority queue to be merged into the current one. Returns: None self.priorities.extend(other_queue.priorities) self.items.extend(other_queue.items) # Ensure the merged queue is properly sorted by priority self._sort_by_priority() def __str__(self): return \\"PriorityQueue([\\" + \\", \\".join(f\\"{item}: {priority}\\" for item, priority in zip(self.items, self.priorities)) + \\"])\\" # Example usage if __name__ == \\"__main__\\": pq1 = PriorityQueue(items=[3, 1, 4], priorities=[30, 10, 40]) pq2 = PriorityQueue(items=[2, 5], priorities=[20, 50]) pq1.merge(pq2) print(pq1) # PriorityQueue([5: 50, 4: 40, 3: 30, 2: 20, 1: 10])"},{"question":"# Graph Transitive Closure You are given a directed graph represented using adjacency lists. Your task is to find the transitive closure of this graph. The transitive closure of a graph is a reachability matrix where `closure[i][j]` is `True` if there is a path from vertex `i` to vertex `j`, otherwise it is `False`. Input * An integer `n` denoting the number of vertices `0 to n-1`. * A list of edges where each edge is represented by a tuple `(u, v)` indicating a directed edge from vertex `u` to vertex `v`. Output * A matrix representing the transitive closure of the graph. The matrix should be `n x n` where `matrix[i][j]` is `True` if there is a path from vertex `i` to vertex `j`, otherwise `False`. Function Signature ```python def transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[bool]]: pass ``` # Constraints * (1 leq n leq 100) * (0 leq u, v leq n-1) * There are no duplicate edges. # Example Input ```plaintext n = 4 edges = [ (0, 1), (1, 2), (2, 3) ] ``` Output ```plaintext [ [True, True, True, True], [False, True, True, True], [False, False, True, True], [False, False, False, True] ] ``` # Notes * This problem involves writing the main function and ensuring it correctly integrates the structure and concepts mentioned in the analysis. * Edge cases such as graphs with no edges or isolated vertices must be handled appropriately.","solution":"from typing import List, Tuple def transitive_closure(n: int, edges: List[Tuple[int, int]]) -> List[List[bool]]: # Initialize a matrix with False values closure = [[False] * n for _ in range(n)] # Each vertex is reachable from itself for i in range(n): closure[i][i] = True # Mark the given edges in the closure matrix for u, v in edges: closure[u][v] = True # Apply the Floyd-Warshall algorithm to find the transitive closure for k in range(n): for i in range(n): for j in range(n): if closure[i][k] and closure[k][j]: closure[i][j] = True return closure"},{"question":"Context You are given two strings `str1` and `str2`. The goal is to determine the minimum number of operations needed to make the two strings equal by only deleting characters. An operation consists of deleting one character from either string. Task Write a function `min_deletion_operations(str1: str, str2: str) -> int` that computes the minimum number of steps required to make these strings equal. Input - `str1` (0 <= len(str1) <= 1000): A string consisting of lowercase English letters. - `str2` (0 <= len(str2) <= 1000): A string consisting of lowercase English letters. Output - An integer representing the minimum number of steps required to make the two strings equal by only deleting characters. Performance Requirements - The solution should have a time complexity of O(n*m) and space complexity of O(n*m), where n and m are the lengths of `str1` and `str2`, respectively. Examples 1. **Example 1**: - Input: `str1 = \\"sea\\"`, `str2 = \\"eat\\"` - Output: `2` - Explanation: Delete \'s\' from \\"sea\\" to get \\"ea\\" and delete \'t\' from \\"eat\\" to get \\"ea\\". 2. **Example 2**: - Input: `str1 = \\"leetcode\\"`, `str2 = \\"etco\\"` - Output: `4` - Explanation: Delete \'l\', \'e\', \'d\', \'e\' from \\"leetcode\\" to get \\"etco\\". Constraints - Both strings consist of lowercase English letters only. - You need to handle edge cases where one or both strings can be empty. Function Signature ```python def min_deletion_operations(str1: str, str2: str) -> int: # Your implementation here pass ```","solution":"def min_deletion_operations(str1: str, str2: str) -> int: Returns the minimum number of operations needed to make the two strings equal by only deleting characters. # Compute the length of the longest common subsequence (LCS) n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[n][m] # Minimum deletions needed return (n - lcs_length) + (m - lcs_length)"},{"question":"Scenario You are part of an AI research team working on optimizing search operations on huge datasets categorized in multi-dimensional formats. One of your tasks is to implement an efficient search algorithm over matrices where each row and each column is sorted in non-decreasing order. Your team needs this for quick lookups to enhance the performance of data-intensive applications. Problem Statement Implement a function `find_key(matrix: List[List[int]], key: int) -> Tuple[int, int]` that searches for a given key in an m x n matrix (where m is the number of rows and n is the number of columns). The rows and columns of the matrix are sorted in non-decreasing order. If the key is found, return a tuple (row_index, col_index) indicating the row and column indices of the key. If the key is not found, return (-1, -1). Function Signature ```python from typing import List, Tuple def find_key(matrix: List[List[int]], key: int) -> Tuple[int, int]: # Your code here ``` Input * `matrix`: A list of lists of integers, where each row and column is sorted in non-decreasing order. You can assume the number of rows and columns will be at least 1. * `key`: An integer to find in the matrix. Output * Return a tuple (row_index, col_index) for the found key. * If the key is not found, return (-1, -1). Constraints * 1 <= Number of rows <= 1000 * 1 <= Number of columns <= 1000 * -10^9 <= Elements in matrix <= 10^9 * -10^9 <= key <= 10^9 Performance Requirements * The algorithm must run in O(m + n) time complexity. Example ```python matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] key = 5 assert find_key(matrix, key) == (1, 1) assert find_key(matrix, 20) == (-1, -1) ```","solution":"from typing import List, Tuple def find_key(matrix: List[List[int]], key: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"You are tasked with modifying an existing AVL tree data structure to support efficient bulk insertion. The following code snippet defines an AVL Tree including methods for insertion and rebalancing. Your task is to implement a `bulk_insert` method that accepts a list of integers and inserts them into the AVL tree while maintaining its balanced property. # Instructions 1. Implement the `bulk_insert` method in the `AvlTree` class. 2. Your solution should efficiently insert each integer while maintaining the AVL tree properties. 3. After each insertion, the tree should be rebalanced if necessary. # Function Signature ```python def bulk_insert(self, keys): # keys: List[int] - A list of integers to be inserted into the AVL tree pass ``` # Input/Output * **Input**: A list `keys` with integers to be inserted. * **Output**: No explicit return. The AVL tree should be updated in-place. # Example Scenario ```python tree = AvlTree() tree.bulk_insert([10, 20, 30, 40, 50, 25]) print(tree.in_order_traverse()) # Expected output: [10, 20, 25, 30, 40, 50] ``` # Constraints * The number of keys to be inserted: 1 <= len(keys) <= 10^5 * Values in the list: -10^6 <= values <= 10^6 # Performance Requirements * Ensure the method performs efficiently even for the upper limits of the constraints provided. You can assume that the `TreeNode` class and the rest of the `AvlTree` class are already implemented and provided, as shown in the original code snippet.","solution":"class TreeNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self.insert(node.left, key) else: node.right = self.insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.right_rotate(node) if balance < -1 and key > node.right.key: return self.left_rotate(node) if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def in_order_traverse(self, node, result): if node: self.in_order_traverse(node.left, result) result.append(node.key) self.in_order_traverse(node.right, result) def bulk_insert(self, keys): for key in keys: self.root = self.insert(self.root, key) def get_in_order(self): result = [] self.in_order_traverse(self.root, result) return result"},{"question":"Implement and Optimize Comb Sort Comb sort is an optimization of Bubble Sort that attempts to eliminate small values at the far end of the list faster by using a larger gap between compared elements. The goal is to reduce the total number of swaps needed. Implement the Comb sort algorithm and further optimize it for better performance. Instructions: 1. **Function Signature**: `def optimized_comb_sort(arr: List[int]) -> List[int]:` 2. Your implementation should work correctly for both small and large input arrays. 3. **Input**: A list of integers, `arr`. 4. **Output**: A new list of integers that is the sorted version of `arr`. 5. **Performance Requirements**: Aim for the average case time complexity close to O(N log N) and best case time complexity of O(N). 6. You need to implement your own version of the Comb Sort algorithm and may introduce any optimizations that maintain its correctness and efficiency. # Constraints: * The length of the array, `n`, will be between 1 and 10^5. * Each integer in the input array can be between -10^5 and 10^5. # Example: ```python input = [5, 4, 3, 2, 1] output = [1, 2, 3, 4, 5] input = [3, -1, 2, 1, 0] output = [-1, 0, 1, 2, 3] ``` # Additional Information: Consider the edge cases, such as: - An already sorted array. - An array with all identical elements. - An empty array or an array with a single element. You may also comment on the rationale behind any optimizations you decide to implement.","solution":"def optimized_comb_sort(arr): Perform an optimized version of Comb Sort on the input list. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. def get_next_gap(gap): # Shrink gap by a shrink factor of 1.3 new_gap = int(gap / 1.3) if new_gap < 1: return 1 return new_gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Matrix Multiplication Function Implementation **Scenario**: You are a software engineer working on a scientific computing library. One of the most fundamental tasks you need to implement is matrix multiplication, which will be crucial for various applications in the library. **Task**: Write a function to multiply two compatible two-dimensional matrices and return the resulting product. **Function Signature**: ```python def matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: pass ``` **Input**: * `matrix_a`: A list of lists where each sublist represents a row of integers. * `matrix_b`: A list of lists where each sublist represents a row of integers. **Output**: * The function should return a list of lists representing the product of the two matrices. **Constraints**: * The number of columns in `matrix_a` must be equal to the number of rows in `matrix_b`. * Elements of matrices can be any integer. * Matrices can have different dimensions but must still adhere to the above constraint. **Performance Requirement**: * Optimize for matrices where n can be very large (n > 1000). **Examples**: ``` Example 1: matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [2, 0], [1, 2] ] Output: [ [4, 4], [10, 8] ] Example 2: matrix_a = [ [2, 3, 4], [1, 0, 0] ] matrix_b = [ [0, 1000], [1, 100], [0, 10] ] Output: [ [3, 2340], [0, 1000] ] ``` Implement the `matrix_multiply` function such that it accurately computes the matrix product as described.","solution":"def matrix_multiply(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: Multiplies two matrices, matrix_a and matrix_b. :param matrix_a: A list of lists representing the first matrix. :param matrix_b: A list of lists representing the second matrix. The number of columns in matrix_a must be equal to the number of rows in matrix_b. :return: A new matrix that is the product of matrix_a and matrix_b. rows_a = len(matrix_a) cols_a = len(matrix_a[0]) rows_b = len(matrix_b) cols_b = len(matrix_b[0]) # The number of columns in matrix_a must be equal to the number of rows in matrix_b if cols_a != rows_b: raise ValueError(\\"The number of columns in matrix_a must be equal to the number of rows in matrix_b.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Anagram Detection Objective You are provided with a function to determine if two strings are anagrams – strings which can be rearranged to form each other. Utilize your understanding of efficient character counting to implement this function. Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if strings are anagrams, False otherwise pass ``` Input * `s1` (string): First input string with length in the range [1, 1000]. * `s2` (string): Second input string with length in the range [1, 1000]. Output * Return `True` if `s1` and `s2` are anagrams. * Return `False` otherwise. Constraints * `s1` and `s2` contain only lowercase alphabetic characters (\'a\'-\'z\'). Examples * \\"listen\\", \\"silent\\" -> `True` * \\"triangle\\", \\"integral\\" -> `True` * \\"apple\\", \\"pale\\" -> `False` Notes 1. The algorithm must maintain a linear time complexity, ideally O(n), where `n` is the length of the strings. 2. The implementation should be done carefully considering edge cases such as strings of different lengths or those with non-alphabet characters.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if strings are anagrams, False otherwise # If the lengths of the two strings are not equal, they can\'t be anagrams if len(s1) != len(s2): return False # Count the frequency of each character in both strings counter_s1 = {} counter_s2 = {} for char in s1: counter_s1[char] = counter_s1.get(char, 0) + 1 for char in s2: counter_s2[char] = counter_s2.get(char, 0) + 1 # If both dictionaries are equal, the strings are anagrams return counter_s1 == counter_s2"},{"question":"# Question: Topological Sort Validation with Cycle Detection Context You are working as a developer in a project management tool where tasks must be completed in a specific sequence due to prerequisites. The tasks and their dependencies are represented as a directed acyclic graph (DAG). You need to develop a function to determine the correct task execution order. Additionally, if there is a cycle, the function should detect and clearly report it. Task Using the principles of topological sorting via Depth-First Search (DFS), implement a function `detect_cycle_and_top_sort` that performs topological sorting if the input graph is a DAG. If the graph contains a cycle, the function should raise a `ValueError` exception with an appropriate message indicating a cycle is detected. Function Signature ```python def detect_cycle_and_top_sort(graph: dict) -> list: Given a directed acyclic graph (DAG), return its topological ordering. If the graph contains a cycle, raise a ValueError indicating the cycle. Args: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. Returns: list: A list of nodes representing the topological order. Raises: ValueError: If the graph contains a cycle. pass ``` Input - `graph`: A dictionary where each key is a node and the corresponding value is a list of nodes it points to (representing directed edges). Output - A list of nodes representing the topological order. Constraints - The graph will have at most 1000 nodes. Example ```python graph = { \\"A\\": [\\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"F\\"], \\"E\\": [\\"H\\", \\"F\\"], \\"F\\": [\\"G\\"], \\"G\\": [], \\"H\\": [] } print(detect_cycle_and_top_sort(graph)) # Output: A valid topological order, e.g., [\'B\', \'A\', \'C\', \'E\', \'H\', \'D\', \'F\', \'G\'] # Graph with cycle graph_with_cycle = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } try: detect_cycle_and_top_sort(graph_with_cycle) except ValueError as e: print(e) # Output: \\"cycle\\" ``` Notes - You are not allowed to use any external libraries for the graph traversal. - Thoroughly test your function with graphs containing various edge cases, such as nodes with no outgoing edges, disconnected nodes, and edge cases mentioned above.","solution":"def detect_cycle_and_top_sort(graph: dict) -> list: Given a directed acyclic graph (DAG), return its topological ordering. If the graph contains a cycle, raise a ValueError indicating the cycle. Args: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of adjacent nodes. Returns: list: A list of nodes representing the topological order. Raises: ValueError: If the graph contains a cycle. visited = set() temp_mark = set() # Temporarily mark during DFS result = [] # Topological sorting result def visit(node): if node in temp_mark: raise ValueError(\\"cycle\\") if node not in visited: temp_mark.add(node) for neighbor in graph.get(node, []): visit(neighbor) temp_mark.remove(node) visited.add(node) result.append(node) for node in graph: if node not in visited: visit(node) result.reverse() # Reverse to get correct topological order return result"},{"question":"You have been given the task to implement an efficient matrix multiplication program. Your function should take two compatible 2D matrices and return their product. # Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]], a m x n matrix :param multiplier: List[List[int]], a n x p matrix :return: List[List[int]], a m x p matrix ``` # Input - `multiplicand`: A list of list of integers where each sublist represents a row of the matrix. Its size is `m x n`. - `multiplier`: A list of list of integers where each sublist represents a row of the matrix. Its size is `n x p`. # Output - Return a list of list of integers where each sublist represents a row of the resultant matrix. The returned matrix\' size should be `m x p`. # Constraints - 1 <= m, n, p <= 100 - -100 <= elements of matrices <= 100 # Guidelines 1. **Edge Cases:** - Ensure that you handle the case where the dimensions of the matrices are not compatible and raise an appropriate exception. - Consider the possibility of null and empty matrices. 2. **Efficiency:** - Aim for an O(n^3) time complexity solution. - Think of potential ways to make your code more efficient within these constraints. # Example ```python # Example 1 multiplicand = [ [1, 2], [3, 4], [5, 6] ] multiplier = [ [7, 8, 9], [10, 11, 12] ] # The result should be: # [ # [27, 30, 33], # [61, 68, 75], # [95, 106, 117] # ] print(multiply(multiplicand, multiplier)) # Example 2 - Dimension Mismatch multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [1, 2], [3, 4] ] # This should raise an exception # Multiplicand and multiplier matrices are not compatible. try: multiply(multiplicand, multiplier) except Exception as e: print(e) ``` Demonstrate your understanding and implement a working function that can handle the cases described above.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the result. :param multiplicand: List[List[int]], a m x n matrix :param multiplier: List[List[int]], a n x p matrix :return: List[List[int]], a m x p matrix # Get the dimensions of the matrices m = len(multiplicand) n = len(multiplicand[0]) if multiplicand else 0 n2 = len(multiplier) p = len(multiplier[0]) if multiplier else 0 # Check if matrices are compatible for multiplication if n != n2: raise ValueError(\\"Multiplicand and multiplier matrices are not compatible.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Scenario You are developing a software application where one of the features involves analyzing numerical inputs for specific properties. One such property is to check if the number is strobogrammatic—i.e., it looks the same when rotated 180 degrees. Problem Statement Write a function `find_all_strobogrammatic` that determines which numbers in a given list are strobogrammatic. The numbers are represented as strings. The function should return a list of booleans indicating whether each corresponding number is strobogrammatic. The strobogrammatic numbers are: - Numbers that look the same when flipped 180 degrees: \\"0\\", \\"1\\", \\"8\\" - Numbers that turn into each other when flipped: \\"6\\" becomes \\"9\\" and vice versa Expected Input and Output Formats **Function Signature:** ```python def find_all_strobogrammatic(nums: List[str]) -> List[bool]: :param nums: List of numbers represented as strings :return: List of booleans indicating if each number is strobogrammatic ``` **Example:** ```python find_all_strobogrammatic([\\"69\\", \\"88\\", \\"818\\", \\"126\\", \\"962\\"]) # Output: [True, True, True, False, True] ``` Constraints - The input list length will be in the range [1, 10^4]. - Each number in the input list will be a non-empty string containing only numeric characters. - Use linear time complexity O(n), where n is the total number of characters across all strings, to ensure your solution is efficient. Additional Notes - Consider optimizing for edge cases such as numbers with odd lengths and ensure characters are correctly mapped. - Pay attention to the input constraints to handle large inputs gracefully.","solution":"def find_all_strobogrammatic(nums): Returns a list of booleans indicating if each number in the input list is strobogrammatic. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'8\': \'8\', \'6\': \'9\', \'9\': \'6\'} def is_strobogrammatic(num): Determines if a given number is strobogrammatic. i, j = 0, len(num) - 1 while i <= j: if num[i] not in strobogrammatic_pairs or strobogrammatic_pairs[num[i]] != num[j]: return False i += 1 j -= 1 return True return [is_strobogrammatic(num) for num in nums]"},{"question":"You are given two singly linked lists that intersect at some point. Your task is to write a function that identifies the intersecting node of the two lists. Input: * Two head nodes `h1` and `h2` representing the start of the two singly linked lists. Output: * The intersecting node. If no intersection exists, return `None`. # Constraints: 1. The lists may have different lengths. 2. The intersection is defined by reference, not by value. 3. No additional data structures (like arrays or hash tables) are allowed; you must solve this in O(1) extra space. 4. The provided linked list nodes have the following structure: ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None ``` # Example: ```python # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2).val == 7 ``` You need to implement the function `intersection(h1, h2)`, which should return the intersecting `Node` if it exists, or `None` otherwise. ```python class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(h1, h2): # Your code here import unittest class TestSuite(unittest.TestCase): def test_intersection(self): # create linked list as described above a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(7, intersection(a1, a2).val) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node(object): def __init__(self, val=None): self.val = val self.next = None def intersection(h1, h2): # Find lengths of both linked lists len1, len2 = 0, 0 temp1, temp2 = h1, h2 while temp1: len1 += 1 temp1 = temp1.next while temp2: len2 += 1 temp2 = temp2.next # Adjust starting points to be the same distance from the end temp1, temp2 = h1, h2 if len1 > len2: for _ in range(len1 - len2): temp1 = temp1.next else: for _ in range(len2 - len1): temp2 = temp2.next # Traverse both lists in unison to find intersection while temp1 and temp2: if temp1 is temp2: return temp1 temp1 = temp1.next temp2 = temp2.next return None"},{"question":"Given a list of strings, implement an algorithm to encode this list into a single string so it can be easily transmitted over a network. Subsequently, implement a decoding algorithm to convert the encoded string back to the original list of strings. # Input - `strs`: A list of n strings, where `0 <= n <= 10^5` and the total number of characters across all strings combined does not exceed 10^6. # Output - `encode`: A single string representation of the original list. - `decode`: The original list of strings extracted from the encoded string. # Constraints - The length of each string is a non-negative integer ≤ 10^6. - All characters in the strings are valid printable ASCII characters. # Performance Requirements - Both `encode` and `decode` functions should run in O(N) time complexity where N is the total number of characters in the list of strings. # Example ```python # Example input strings = [\\"hello\\", \\"world\\", \\"!\\", \\"an example\\"] # Encoding the list of strings encoded_str = encode(strings) print(encoded_str) # Output could be \\"5:hello5:world1:!10:an example\\" # Decoding the encoded string decoded_list = decode(encoded_str) print(decoded_list) # Output should be [\\"hello\\", \\"world\\", \\"!\\", \\"an example\\"] ``` # Implementation Implement the `encode` and `decode` methods in Python.","solution":"def encode(strs): Encodes a list of strings to a single string. The encoding scheme uses the length of each string followed by a colon character and then the string itself. Args: strs (list of str): The list of strings to encode. Returns: str: The encoded single string representing the list of strings. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string back into a list of strings. Args: s (str): The string to decode. Returns: list of str: The list of strings decoded from the single string. res = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) string = s[j+1:j+1+length] res.append(string) i = j + 1 + length return res # Example usage strings = [\\"hello\\", \\"world\\", \\"!\\", \\"an example\\"] encoded_str = encode(strings) print(encoded_str) decoded_list = decode(encoded_str) print(decoded_list)"},{"question":"You are tasked with creating a function that merges a list of base paths with corresponding suffixes. This function must ensure paths are correctly joined with a single slash (\'/\'), regardless of trailing or leading slashes. # Function Signature ```python def merge_paths(bases: List[str], suffixes: List[str]) -> List[str]: pass ``` # Input * `bases` - A list of base paths (strings) of length `n`. * `suffixes` - A corresponding list of suffix paths (strings) of length `n`. # Output * A list containing `n` merged paths (strings). # Constraints * `n` (number of paths) <= 10^4 * The length of any path string <= 10^3 * Each path consists of printable ASCII characters. # Requirements * Ensure that each base path and suffix is joined correctly, even with varying slashes. * Handle edge cases where the bases and suffixes might have or lack slashes appropriately. * Aim for an efficient solution in both time and space. # Example ```python bases = [\\"http://example.com\\", \\"path/to/dir/\\", \\"/\\", \\"usr/\\"] suffixes = [\\"api/v1\\", \\"file.txt\\", \\"home\\", \\"local/bin\\"] result = merge_paths(bases, suffixes) print(result) # Expected: [\'http://example.com/api/v1\', \'path/to/dir/file.txt\', \'/home\', \'usr/local/bin\'] ``` # Detailed Explanation 1. Remove any trailing slashes from each base. 2. Remove any leading slashes from each suffix. 3. Concatenate the base and suffix with a single slash between them. 4. Return the new list of merged paths. **Note:** Make sure to handle multiple edge cases (base with slash or no slash, suffix with leading slashes, and empty values).","solution":"from typing import List def merge_paths(bases: List[str], suffixes: List[str]) -> List[str]: merged_paths = [] for base, suffix in zip(bases, suffixes): # Remove trailing slash from base if exists if base.endswith(\'/\'): base = base[:-1] # Remove leading slash from suffix if exists if suffix.startswith(\'/\'): suffix = suffix[1:] # Join the base and suffix with a single slash merged_path = f\\"{base}/{suffix}\\" merged_paths.append(merged_path) return merged_paths"},{"question":"**Cycle Sort Modification and Implementation** **Problem Statement**: You are tasked with enhancing and implementing a modified version of the Cycle Sort algorithm that can sort an array containing both positive and negative integers. Cyclomatic complexity is important, so your solution should aim to be as efficient as possible given the constraints. **Function Signature**: ```python def enhanced_cycle_sort(arr: List[int]) -> List[int]: ``` **Input**: - An unsorted list of integers, which may contain both positive and negative numbers. - Each integer in the list will be in the range [-10^6, 10^6]. - The length of the list will be between 1 and 10^4. **Output**: - A list of integers sorted in non-decreasing order. **Requirements**: 1. Implement Cycle Sort to handle both positive and negative integers efficiently. 2. Ensure your function performs in O(N^2) time complexity considering worst-case scenario. 3. Only use O(1) additional space for sorting (i.e., in-place sorting). **Example**: ```python input = [3, -1, 4, -3, 0] output = [-3, -1, 0, 3, 4] input = [6, 3, -5, 2, 1, -4] output = [-5, -4, 1, 2, 3, 6] ``` **Constraints**: 1. Ensure you handle the edge cases, like arrays with all identical elements, single element arrays, empty arrays, and large arrays up to the given limit effectively. 2. Pay attention to minimizing write operations wherever possible while maintaining the original benefits of Cycle Sort. **Performance Conditions**: - Your function should be capable of handling the largest possible inputs within a reasonable time frame (~2 seconds).","solution":"def enhanced_cycle_sort(arr): Function to sort an array using the cycle sort algorithm modified to handle negative integer values as well. This sort is in-place and has a time complexity of O(N^2) in the worst case. writes = 0 for cycleStart in range(0, len(arr) - 1): item = arr[cycleStart] pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 if pos == cycleStart: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycleStart: pos = cycleStart for i in range(cycleStart + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Given an array of integers and a target value, implement a function that returns the index of the target value in the array using linear search. If the target value is not found, return -1. Additionally, you need to handle an optional parameter `all_occurrences` which, when set to True, returns a list of all indices where the target value occurs. By default, `all_occurrences` should be False. # Function Signature ```python def search_array(array: List[int], target: int, all_occurrences: bool = False) -> Union[int, List[int]]: # Your code here ``` # Input * `array` (List[int]): A list of integers. * `target` (int): The target value to search for. * `all_occurrences` (bool, optional): If True, return all indices of the target value. # Output * int: The index of the first occurrence of the target value if `all_occurrences` is False. * List[int]: A list of indices where the target value occurs if `all_occurrences` is True. # Constraints * The array can be empty. * The array elements are integers and can be positive, negative, or zero. * The target value is an integer. # Performance Requirements * The solution should have a time complexity of O(n). # Example ```python # Example 1: array = [4, 2, 3, 2, 1] target = 2 print(search_array(array, target)) # Output: 1 # Example 2: array = [4, 2, 3, 2, 1] target = 2 print(search_array(array, target, all_occurrences=True)) # Output: [1, 3] # Example 3: array = [] target = 1 print(search_array(array, target)) # Output: -1 ``` # Explanation * In the first example, the function finds the first occurrence of 2 at index 1. * In the second example, the function finds all occurrences of 2 at indices 1 and 3. * In the third example, the function returns -1 since the array is empty and the target cannot be found.","solution":"from typing import List, Union def search_array(array: List[int], target: int, all_occurrences: bool = False) -> Union[int, List[int]]: Searches for the target value in the given array. If all_occurrences is False, returns the index of the first occurrence of the target value. If all_occurrences is True, returns a list of indices of all occurrences of the target value. If the target value is not found, returns -1 if all_occurrences is False, or an empty list if all_occurrences is True. if all_occurrences: indices = [i for i, x in enumerate(array) if x == target] return indices for i, x in enumerate(array): if x == target: return i return -1"},{"question":"# Question: Find the Range of a Target Value in a Sorted Array Given an array of integers `nums` sorted in ascending order, write a function to find the starting and ending position of a given target value. If the target is not found in the array, return `[-1, -1]`. Function Signature ```python def search_range(nums: List[int], target: int) -> List[int]: ``` # Input - `nums` (List[int]): A list of integers sorted in ascending order. - `target` (int): The target value to find in the array. # Output - (List[int]): A list with two integers representing the starting and ending positions of the target value. If the target is not found, return `[-1, -1]`. # Constraints - `1 <= len(nums) <= 10^5` - `-10^9 <= nums[i], target <= 10^9` # Performance Requirements - The algorithm should run in O(log n) time complexity due to the constraint of efficiently handling large datasets. # Example ```python # Example 1 nums = [5, 7, 7, 8, 8, 8, 10] target = 8 # Output: [3, 5] # Example 2 nums = [5, 7, 7, 8, 8, 8, 10] target = 11 # Output: [-1, -1] ``` Scenario Imagine you are developing a search engine feature where you need to identify all the occurrences of a keyword within a sorted list of indices. The indices determine positions in a database of sorted entries. Your task is to efficiently find the starting and ending index for a given keyword. --- # Implementation Instructions 1. Initialize two variables to capture the range indices. 2. Apply binary search to determine the starting position. 3. Apply binary search to determine the ending position. 4. Return the indices as a list structure. Remember to handle the edge cases, such as when the target is not present or when dealing with arrays of varying lengths and identical elements. ```python def search_range(nums, target): # Your efficient implementation here. pass ```","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_left_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) if left_index <= right_index and right_index < len(nums) and nums[left_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"# Josephus Problem Implementation Scenario In a hypothetical scenario, people are sitting in a circular arrangement. The aim is to simulate the systematically removing of every third person until no one is left. This exercise will help understand operations with circular lists and efficient handling of removal operations. Problem Statement Implement the function `josephus(int_list, skip)` that simulates the Josephus problem. The function takes in an integer list `int_list` representing people and an integer `skip` representing the count after which a person is removed. The function will return a list showing the order in which people are removed. Input * `int_list`: A list of integers representing people (1-indexed). * `skip`: An integer representing the count after which a person is removed (1-indexed). Output * A list of integers showing the order in which people are removed. Constraints * 1 <= len(int_list) <= 10^3 * 1 <= int(element) <= 10^3 * 1 <= skip <= len(int_list) Example ```python assert josephus([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == [3, 6, 9, 4, 8, 5, 2, 7, 1] assert josephus([1, 2, 3], 2) == [2, 1, 3] ``` Guidelines * Ensure your function efficiently handles the removal everyday third member. * Consider edge cases like empty input list or single element.","solution":"def josephus(int_list, skip): Simulates the Josephus problem. Parameters: int_list (list): A list of integers representing people. skip (int): The count after which a person is removed. Returns: list: The order in which people are removed. result = [] index = 0 while len(int_list) > 0: index = (index + skip - 1) % len(int_list) result.append(int_list.pop(index)) return result"},{"question":"# Caesar Cipher with Enhanced Features You are tasked with implementing an enhanced version of Caesar Cipher that includes additional functionalities such as decrypting the encrypted text and handling customized shift values securely. Your solution should maintain efficiency and readability. Function 1: Encrypt Implement the function `caesar_encrypt(s: str, k: int) -> str` that encrypts the input string `s` by shifting each letter by `k` positions. Function 2: Decrypt Implement the function `caesar_decrypt(s: str, k: int) -> str` that decrypts the previously encrypted string `s` back to its original form by reversing the shift. # Input * A string `s` containing alphabetic and non-alphabetic characters. The length of `s` will be (1 leq |s| leq 10^5). * An integer shift value `k` where (-10^9 leq k leq 10^9). # Output * The encrypted string when using `caesar_encrypt`. * The original string when using `caesar_decrypt`. # Constraints * Ensure that the shift value `k` is effectively reduced using modulo operation to handle very large or very small values. * Preserve the case of the letters in the string and leave non-alphabetic characters unchanged. # Scenario Alice needs to send a secret message to Bob. She uses your `caesar_encrypt` function to encode her message and `caesar_decrypt` to decode messages received from Bob. Help Alice securely encrypt and decrypt her messages even when the shift value is extremely large or negative. # Example ```python encrypted = caesar_encrypt(\\"Hello, World!\\", 3) # Output: \\"Khoor, Zruog!\\" decrypted = caesar_decrypt(\\"Khoor, Zruog!\\", 3) # Output: \\"Hello, World!\\" ``` # Implementation Guidelines 1. Use the modulo operator to reduce large shift values within the range of [0, 26). 2. Handle both uppercase and lowercase letters appropriately. 3. Ensure non-alphabetic characters remain unchanged. 4. Provide a clear and efficient solution.","solution":"def caesar_encrypt(s: str, k: int) -> str: Encrypts the input string s by shifting each letter by k positions. Non-alphabetic characters remain unchanged. def shift_char(c, k): if c.islower(): return chr(((ord(c) - ord(\'a\') + k) % 26) + ord(\'a\')) elif c.isupper(): return chr(((ord(c) - ord(\'A\') + k) % 26) + ord(\'A\')) return c # Normalize the shift value to be within 0-25 k = k % 26 encrypted_text = \'\'.join(shift_char(c, k) for c in s) return encrypted_text def caesar_decrypt(s: str, k: int) -> str: Decrypts the previously encrypted string s by reversing the shift by k positions. Non-alphabetic characters remain unchanged. # Decryption is simply encryption with the negative of the shift value return caesar_encrypt(s, -k)"},{"question":"# Question Problem Statement: Write a Python function to solve the Matrix Chain Multiplication problem using dynamic programming. Your function should take an array of integers representing the dimensions of matrices and return an integer denoting the minimum number of multiplications needed to multiply the given sequence of matrices. Additionally, write a function to retrieve the optimal order of matrix multiplication and print it. Input Format: * An array of integers `dims` where `dims[i-1] * dims[i]` represents the dimensions of the `i-th` matrix. Output Format: * An integer representing the minimum number of multiplications needed. * The function should print the sequence of matrix multiplications in the optimal order. Constraints: * The length of the input array `n` will be in the range `[2, 100]`. * The dimension values in the array will be positive integers. Example: Input: ```python dims = [40, 20, 30, 10, 30] ``` Output: ```python 26000 (A1 (A2 A3) (A4 A5)) ``` Notes: - You need to define two functions: 1. `min_matrix_multiplications(dims: List[int]) -> int`: * Finds the minimum number of multiplications needed to multiply the chain of matrices. 2. `print_optimal_schedule(optimal_solution: List[List[int]], i: int, j: int)`: * Prints the optimal order of matrix multiplications.","solution":"def min_matrix_multiplications(dims): n = len(dims) - 1 m = [[0 for x in range(n)] for y in range(n)] s = [[0 for x in range(n)] for y in range(n)] for L in range(2, n+1): for i in range(n-L+1): j = i + L - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i] * dims[k+1] * dims[j+1] if q < m[i][j]: m[i][j] = q s[i][j] = k min_ops = m[0][n-1] print_optimal_schedule(s, 0, n-1) return min_ops def print_optimal_schedule(s, i, j): if i == j: print(f\\"A{i+1}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_schedule(s, i, s[i][j]) print_optimal_schedule(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"Context You are working as a software developer and you have been asked to implement several sorting algorithms for comparison in a small-scale sorting library. Currently, only selection sort is implemented, and you need to enhance this library by adding another sorting algorithm. Task Your goal is to implement an optimized **Insertion Sort** algorithm. Specifications * Write a function `insertion_sort(arr, simulation=False)` that sorts an array of integers in ascending order using the insertion sort algorithm. * **Input**: * `arr`: List of integers to be sorted. * `simulation`: Boolean flag. If `True`, print the list after each iteration showing the state of the list as it gets sorted. * **Output**: A sorted list of integers. * **Constraints**: * The list can contain up to 1000 elements. * Each integer in the list can range from -10^6 to 10^6. * **Performance**: Aim for O(n^2) time complexity and O(1) space complexity as this is an in-place sorting algorithm. Example ```python # Example Use Case arr = [64, 25, 12, 22, 11] sorted_arr = insertion_sort(arr, simulation=True) print(sorted_arr) # Output should be [11, 12, 22, 25, 64] ``` Requirements 1. Your implementation should handle edge cases such as an empty list or a list with one element. 2. Ensure that if the `simulation` flag is true, the internal state of the array is printed after each iteration.","solution":"def insertion_sort(arr, simulation=False): Sorts the list using the insertion sort algorithm. Args: arr (list): List of integers to be sorted simulation (bool): If true, prints the array after each iteration Returns: list: Sorted list of integers for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(arr) return arr"},{"question":"**Context**: You are creating a navigation system for a new type of circular racetrack. The racetrack is divided into segments that form an increasing sequence, which is then rotated at some unknown point to determine the starting segment. Given the segment numbers and a target segment number you wish to search, your task is to identify if the target segment exists in the circular racetrack configuration. **Task**: Implement a function `find_segment` to determine the index of the target segment in the given racetrack configuration. If the target is found, return its index; otherwise, return -1. Your algorithm must have a runtime complexity of O(log n). Function Signature ```python def find_segment(segments: List[int], target: int) -> int: ``` Input - `segments`: List[int] - A list of integers representing the racetrack segments, sorted in ascending order, and then rotated at an unknown pivot. - `target`: int - The target segment number that you need to locate. Output - int - The index of the target segment in the list if found, otherwise -1. Constraints - All values in `segments` are unique. - 1 <= len(segments) <= 10^4 - -10^4 <= segments[i], target <= 10^4 Example ```python segments = [40, 45, 50, 5, 10, 20, 30] target = 10 print(find_segment(segments, target)) # Output: 4 segments = [40, 45, 50, 5, 10, 20, 30] target = 35 print(find_segment(segments, target)) # Output: -1 ``` Explanation In the first example, the target `10` is found at index `4`. In the second example, the target `35` is not found in the array, so the function returns `-1`. **Note**: Ensure your implementation efficiently narrows down the search space by determining which part of the array is normally ordered and should be further searched.","solution":"from typing import List def find_segment(segments: List[int], target: int) -> int: Find the index of the target segment in the given rotated sorted array. Parameters: segments (List[int]): List of integers representing the racetrack segments, sorted in ascending order and rotated. target (int): The target segment number to find. Returns: int: The index of the target segment if found, otherwise -1. left, right = 0, len(segments) - 1 while left <= right: mid = (left + right) // 2 if segments[mid] == target: return mid if segments[left] <= segments[mid]: # Left part is sorted if segments[left] <= target < segments[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if segments[mid] < target <= segments[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Maximum Non-Adjacent Sum **Scenario**: You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. However, the security system in each house will notify the police if two adjacent houses are robbed on the same night. Hence, you cannot rob two adjacent houses. You need to develop a function to calculate the maximum amount of money you can rob without triggering the alarm. **Function Signature**: ```python def maximum_non_adjacent_sum(houses: List[int]) -> int: ``` **Input**: * `houses` (List[int]): A list representing the amount of money stored in each house. Each element is a non-negative integer. **Output**: * Returns an integer representing the maximum amount of money that can be robbed without alerting the police. **Constraints**: * `0 <= len(houses) <= 10^4` * `0 <= houses[i] <= 10^4` **Example**: ```python # Example 1 houses = [2, 7, 9, 3, 1] print(maximum_non_adjacent_sum(houses)) # Output: 12 # Explanation: Rob house 1 (money = 2), then house 3 (money = 9), then house 5 (money = 1). # Total amount = 2 + 9 + 1 = 12. # Example 2 houses = [2, 1, 1, 2] print(maximum_non_adjacent_sum(houses)) # Output: 4 # Explanation: Rob house 1 (money = 2) and house 4 (money = 2). # Total amount = 2 + 2 = 4. ``` **Additional Instructions**: Consider the following edge cases: - An empty list of houses. - A list with one house. - A list with two houses. Write a function that meets these specifications and handle all these scenarios appropriately.","solution":"from typing import List def maximum_non_adjacent_sum(houses: List[int]) -> int: if not houses: # No houses to rob return 0 if len(houses) == 1: # Only one house to rob return houses[0] if len(houses) == 2: # Two houses to rob, take the maximum one return max(houses) # Initialize dp array dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], houses[i] + dp[i-2]) return dp[-1]"},{"question":"# Scenario You\'re working on a system that regularly requires shifting data entries within a singly linked list. As part of this system, you need a function to rotate the list to the right. Given the importance of the process, it\'s crucial that you implement an efficient algorithm to handle this rotation. # Problem Statement Write a function `rotate_right` that rotates a given singly linked list to the right by `k` places. # Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: :type head: ListNode :type k: int :rtype: ListNode ``` # Input * `head` (ListNode): A reference to the head of a singly linked list. * `k` (int): A non-negative integer indicating the number of places to rotate the list. # Output * Return the `ListNode` reference to the head of the rotated list. # Constraints * The number of nodes in the list is in the range `[0, 500]`. * `-100 <= Node.val <= 100` * `0 <= k <= 2 * 10^9` # Example ```python # Example 1: # Input: head = [1, 2, 3, 4, 5], k = 2 # Output: [4, 5, 1, 2, 3] # Example 2: # Input: head = [0, 1, 2], k = 4 # Output: [2, 0, 1] ``` # Notes * Ensure to handle lists of various lengths including edge cases like empty lists and single-node lists. * Consider optimizing the algorithm for large values of `k`.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Compute the length of the list and get the last node length = 1 last_node = head while last_node.next: last_node = last_node.next length += 1 # Make the list circular last_node.next = head # Calculate the new head position k = k % length steps_to_new_head = length - k # Find the new head and the new tail new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Problem Description You are tasked with implementing a function to calculate combinations (nCr) efficiently, using the principles of recursion with memoization to optimize performance. The function should handle a variety of edge cases and constraints effectively. # Function Signature ```python def calc_combinations(n: int, r: int) -> int: pass ``` # Input * `n` (int): Represents the total number of items. (0 ≤ n ≤ 1000) * `r` (int): Represents the number of items to choose. (0 ≤ r ≤ n) # Output * (int): Returns the value of nCr, i.e., the number of ways to choose r items from n items. # Constraints 1. If `r > n`, return 0 as it is not possible to choose more items than available. 2. The function should handle large values of n and r efficiently. # Examples ```python print(calc_combinations(5, 2)) # Expected output: 10 print(calc_combinations(10, 0)) # Expected output: 1 print(calc_combinations(6, 6)) # Expected output: 1 print(calc_combinations(20, 10)) # Expected output: 184756 ``` # Constraints & Performance Note: * Implementing this with simple recursion without memoization will lead to inefficient performance for large inputs. * Aim for a solution with time complexity (O(n times r)) and use a memoization approach to store intermediate results.","solution":"def calc_combinations(n: int, r: int) -> int: Calculate the number of combinations (nCr) using memoization. if r > n: return 0 if r == 0 or r == n: return 1 memo = [[-1 for _ in range(r + 1)] for _ in range(n + 1)] def nCr(n, r): if r == 0 or r == n: return 1 if memo[n][r] != -1: return memo[n][r] memo[n][r] = nCr(n - 1, r - 1) + nCr(n - 1, r) return memo[n][r] return nCr(n, r)"},{"question":"Scenario You are tasked with enhancing a code base to support efficient data retrieval. One crucial improvement is being able to find the in-order successor of any given node in a Binary Search Tree (BST). An in-order successor of a given node in a BST is the node with the smallest key greater than the key of the specified node. Task Write a function `find_inorder_successor(root, p)` that accepts the root of a BST and a node `p`, and returns the in-order successor of `p`. If the given node `p` has no in-order successor, return `None`. Input - `root` (TreeNode): The root of the BST. - `p` (TreeNode): The node for which the in-order successor is to be found. Output - `TreeNode`: Returns the in-order successor of node `p`. If no successor exists, return `None`. Constraints - The BST is implemented with the BST properties. - Both `root` and `p` are valid `TreeNode` instances. Function Signature ```python def find_inorder_successor(root: TreeNode, p: TreeNode) -> Optional[TreeNode]: Finds the in-order successor of a given node in a binary search tree. :param root: The root node of the BST. :param p: The node for which the in-order successor is to be found. :return: The in-order successor node, or None if no successor exists. pass ``` Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example 1 root = TreeNode(20) root.left = TreeNode(15) root.right = TreeNode(25) root.left.left = TreeNode(10) root.left.right = TreeNode(17) root.right.right = TreeNode(27) p = root.left # Node with value 15 assert find_inorder_successor(root, p).val == 17 # Example 2 p = root.right.right # Node with value 27 assert find_inorder_successor(root, p) == None ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_inorder_successor(root: TreeNode, p: TreeNode) -> TreeNode: successor = None while root: if p.val < root.val: successor = root root = root.left else: root = root.right return successor"},{"question":"# Coding Challenge: Bipartite Graph Validator **Context**: In a computer network with multiple nodes, two types of nodes (servers and clients) are connected such that no server directly connects to another server, and no client directly connects to another client. A graph can represent this network, where the vertices represent the nodes and the edges represent the connections between them. To ensure the network\'s proper functionality, it is crucial to determine if the given network graph is bipartite. **Task**: Write a function `is_bipartite_graph(adj_matrix)` that determines if a given graph, represented as an adjacency matrix, is bipartite. **Input**: - `adj_matrix`: An NxN adjacency matrix (a list of N lists, each containing N values), where `adj_matrix[i][j] = 1` indicates an edge between vertices `i` and `j`, and `adj_matrix[i][j] = 0` indicates no edge. **Output**: - Return `True` if the graph is bipartite, otherwise `False`. **Examples**: ```python # Example 1 adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] assert is_bipartite_graph(adj_matrix) == True # Example 2 adj_matrix = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert is_bipartite_graph(adj_matrix) == True # Example 3 adj_matrix = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert is_bipartite_graph(adj_matrix) == False ``` **Constraints**: - `N` will be an integer between 1 and 1000 (inclusive). - The adjacency matrix will be symmetric. **Notes**: - Handle disconnected graphs by checking all components. - Ensure the function is optimized for large graphs within the given constraints.","solution":"def is_bipartite_graph(adj_matrix): Determine if the given graph is bipartite. :param adj_matrix: List[List[int]] - an adjacency matrix representation of the graph. :return: bool - True if the graph is bipartite, False otherwise. n = len(adj_matrix) colors = [-1] * n # -1 indicates uncolored def bfs(start): queue = [start] colors[start] = 0 # Start coloring with 0 while queue: node = queue.pop(0) for neighbor in range(n): if adj_matrix[node][neighbor] == 1: # There\'s an edge if colors[neighbor] == -1: # Not colored yet colors[neighbor] = 1 - colors[node] # Alternate color queue.append(neighbor) elif colors[neighbor] == colors[node]: return False return True for start in range(n): if colors[start] == -1: # Not processed yet if not bfs(start): return False return True"},{"question":"# Flatten Nested Arrays **Problem Statement:** You are given a nested list (or any iterable) structure, which can contain any combination of integers and other nested lists. Your task is to write a function that converts this nested structure into a single flattened list of integers. **Function Signature:** ```python def flatten_nested(iterable: Iterable) -> List[int]: ``` **Input:** - The function takes an iterable `iterable` which can be a nested structure containing other iterables or integers. **Output:** - The function returns a single flattened list of integers. **Example:** ```python flatten_nested([1, [2, 3, [4, 5]], [6, [7, 8], 9], 10]) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` **Constraints:** 1. Elements within the structure can be either integers or lists containing integers (and other lists, recursively). 2. Lists can be deeply nested with an arbitrary level of depth. 3. Non-integer elements (if present) should be skipped. **Edge Cases to Consider:** - Empty lists. - Nested empty lists at multiple levels. - Handling elements that are mistakenly iterables (like strings), skipping them. **Performance Requirements:** - The function should be efficient both in time and space complexity. - Avoid reaching recursion depth limit for deeply nested structures. --- **Implementation:** You need to implement the `flatten_nested` function ensuring that: - You handle recursion efficiently. - You account for edge cases such as empty lists and non-integer elements. **Hint:** - Consider using a helper function to manage recursion and flatten the structure step by step. - Ensure type-checking for iterables versus non-iterables to prevent incorrect splits.","solution":"from typing import Iterable, List def flatten_nested(iterable: Iterable) -> List[int]: Flattens a nested iterable structure into a single list of integers. Args: - iterable (Iterable): A nested structure containing integers and other nested iterables. Returns: - list: A flattened list of integers. flattened_list = [] def _flatten(iterable): for item in iterable: if isinstance(item, int): flattened_list.append(item) elif isinstance(item, Iterable) and not isinstance(item, (str, bytes)): _flatten(item) _flatten(iterable) return flattened_list"},{"question":"# Scenario: You have been hired by a logistics company to optimize the transport routes within a new city-wide delivery network. The network is represented as a directed graph where nodes are intersections and edges are roads with certain capacities (the maximum number of delivery vans that can pass per time unit). # Task: Write a function `optimal_delivery_flow` to determine the optimal maximum flow of delivery vans from the main warehouse (source node) to the central delivery hub (sink node) based on the route capacities provided in the city\'s route adjacency matrix. You need to implement the function using the Edmonds-Karp algorithm. # Function Signature: ```python def optimal_delivery_flow(route_matrix): Determines the maximum flow of delivery vans from the main warehouse (first node, index 0) to the central delivery hub (last node, index n-1) in a given city\'s route network. Parameters: route_matrix (List[List[int]]): A square matrix where route_matrix[i][j] represents the capacity of the directed edge from node i to j. Returns: int: The maximum number of delivery vans that can be sent from the main warehouse to the central delivery hub. ``` # Input Format: - `route_matrix`: a 2D list (n x n) representing the adjacency matrix of the capacity network. Here, (1 leq n leq 100). # Output Format: - Return a single integer representing the maximum flow. # Constraints: - All capacities (values in `route_matrix`) are non-negative integers. - It\'s guaranteed that the source (index 0) and the sink (index n-1) are connected directly or indirectly. # Example: ```python route_matrix = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(optimal_delivery_flow(route_matrix)) # Output should be 23 ``` # Additional Notes: - Focus on handling large capacity networks efficiently. - Consider edge cases like no available path from source to sink and handling large matrices gracefully.","solution":"from collections import deque def bfs(capacity, source, sink, parent): visited = [False] * len(capacity) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for i, cap in enumerate(capacity[node]): if not visited[i] and cap > 0: queue.append(i) visited[i] = True parent[i] = node if i == sink: return True return False def optimal_delivery_flow(route_matrix): n = len(route_matrix) source, sink = 0, n - 1 parent = [-1] * n max_flow = 0 while bfs(route_matrix, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, route_matrix[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] route_matrix[u][v] -= path_flow route_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are given the implementation of a priority queue using a linear array. To test your understanding of priority queues and data structures, your task is to enhance the existing priority queue by implementing the following functionalities: 1. `peek`: a method to return the item with the lowest priority without removing it from the queue. 2. `change_priority`: a method to change the priority of a specified item in the queue. # Requirements: Function Signatures: ```python def peek(self): Return the item with the lowest priority without removing it. If the queue is empty, return None. def change_priority(self, item, new_priority): Change the priority of the specified item to new_priority. If the item is not found in the queue, raise a ValueError. ``` # Input/Output: Input: 1. `peek`: No input parameters besides `self`. 2. `change_priority`: * `item` (any type): The element whose priority needs to be changed. * `new_priority` (numeric): The new priority value. Output: 1. `peek`: * Return the item with the lowest priority if the queue is not empty. * If the queue is empty, return `None`. 2. `change_priority`: * Modify the priority of the given item if it exists in the queue. # Constraints: * The items in the list are unique. * `new_priority` for `change_priority` can be any numeric value (positive or negative). * Your implementation should strive for efficient operations with minimal additional memory usage. # Performance Requirements: * `peek` should operate in O(1) time complexity. * `change_priority` should operate in O(n) time complexity. # Example: ```python # Sample Usage pq = PriorityQueue(items=[4, 3, 5], priorities=[1, 2, 3]) print(pq.peek()) # Output: 4 pq.change_priority(4, 5) print(pq.peek()) # Output: 3 pq.push(2, 0) print(pq.peek()) # Output: 2 pq.pop() # Output: 2 print(pq.peek()) # Output: 3 ``` Implement the `peek` and `change_priority` methods to enhance the priority queue.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: self.queue = list(zip(items, priorities)) def push(self, item, priority): self.queue.append((item, priority)) def pop(self): if not self.queue: return None min_item = min(self.queue, key=lambda x: x[1]) self.queue.remove(min_item) return min_item[0] def peek(self): Return the item with the lowest priority without removing it. If the queue is empty, return None. if not self.queue: return None return min(self.queue, key=lambda x: x[1])[0] def change_priority(self, item, new_priority): Change the priority of the specified item to new_priority. If the item is not found in the queue, raise a ValueError. for index, (itm, _) in enumerate(self.queue): if itm == item: self.queue[index] = (item, new_priority) return raise ValueError(f\\"Item {item} not found in the queue\\")"},{"question":"**Problem Statement**: You are given a binary tree. Your task is to write a function that will return all root-to-leaf paths in the tree. Each path should be represented as a string in the format `root->node1->node2->...->leaf`. **Function Signature**: ```python def find_all_paths(root: TreeNode) -> List[str]: ``` **Input**: * `root`: A reference to the root node of a binary tree. Each node is an instance of `TreeNode` with the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: * A list of strings, where each string represents a root-to-leaf path. **Constraints**: * The number of nodes in the tree is in the range [0, 1000]. * `-100 <= Node.val <= 100` **Performance Requirements**: * Your solution should be efficient, ideally with a time complexity of O(N) where N is the number of nodes in the tree, and a space complexity of O(H) where H is the height of the tree. **Example**: Consider the following binary tree: ``` 1 / 2 3 5 ``` For the above tree, `find_all_paths(root)` should return: ```python [\\"1->2->5\\", \\"1->3\\"] ``` **Scenario**: You work for a company that visualizes signal pathways in biological networks. Given the hierarchical nature of these pathways, you need to ensure that each path from the source (root) to the terminal point (leaf) is captured accurately. Implementing this function efficiently is crucial for the visual rendering process. **Edge Cases to Consider**: * An empty tree should result in an empty list. * The function should work for both balanced and unbalanced trees. **Note**: Do not assume any built-in utility to directly flatten or traverse the tree; your solution must implement the traversal logic explicitly.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_all_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node: TreeNode, current_path: str): if not node.left and not node.right: paths.append(current_path) if node.left: dfs(node.left, current_path + f\\"->{node.left.val}\\") if node.right: dfs(node.right, current_path + f\\"->{node.right.val}\\") paths = [] dfs(root, str(root.val)) return paths"},{"question":"# Coding Challenge: Implement a Range Update and Query Mechanism using Fenwick Tree Scenario You are tasked with implementing a data structure that can efficiently handle both point updates and range sum queries for a large dataset. To achieve this, you will use the Fenwick Tree (also known as Binary Indexed Tree). Your Task Write a Python class `FenwickTree` that encapsulates the functionality of a Fenwick Tree. Your class should provide methods to: 1. **Initialize** the Fenwick Tree with a given list of integers. 2. **Update** a given index in the list with a new value. 3. **Query** the sum of elements for a given range `[0, i]`. Input and Output Formats - **Initialization**: The constructor will take a list `arr` of integers to initialize the tree. - **Update Method**: `update(index, value)`, where `index` is the position in the array to update, and `value` is the new value to set at that index. - **Query Method**: `range_sum(index)`, which returns the sum of elements from index `0` to `index` inclusive. Constraints 1. 1 ≤ n ≤ 10^5 (Where `n` is the length of `arr`) 2. 0 ≤ arr[i], value ≤ 10^6 3. 0 ≤ index < n Example Usage ```python # Initialize the Fenwick Tree with a frequency list arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(arr) # Query the sum of the first 5 elements print(fenwick_tree.range_sum(4)) # Output should be 15 # Update the value at index 3 fenwick_tree.update(3, 10) # Query again after the update print(fenwick_tree.range_sum(4)) # Output should be updated accordingly ``` # Implementation Details 1. Implement the `__init__` method to construct and initialize the Fenwick Tree. 2. Implement the `range_sum(self, index)` method to get the sum from start to the given index. 3. Implement the `update(self, index, value)` method to update the value at the given index. Good luck, and may your code run in O(log n) time!","solution":"class FenwickTree: def __init__(self, arr): n = len(arr) self.size = n self.tree = [0] * (n + 1) for idx, value in enumerate(arr): self._add(idx + 1, value) def _add(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def update(self, index, value): original_value = self.range_sum(index) - self.range_sum(index - 1) delta = value - original_value index += 1 self._add(index, delta) def range_sum(self, index): index += 1 sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum"},{"question":"Implement Optimized Exchange Sort Scenario You have been hired by a data analytics company that processes small datasets. Due to the simplicity of our data needs, they rely on Exchange Sort for its simplicity and ease of understanding. However, they realize that the performance of their current implementation can be improved by reducing unnecessary comparisons and swaps. Task You need to implement a modified version of Exchange Sort. Your task is to: 1. Implement a version of the Exchange Sort algorithm that stops early if it finds the array is already sorted during a pass. 2. Ensure your algorithm handles edge cases correctly, such as an empty array or an array with only one element. Input and Output * The input will be an array of integers. * The output should be the same array sorted in non-decreasing order. * You may not use any built-in sorting functions. Constraints * The array may contain up to 10,000 integers. * Each integer can range from -10^9 to 10^9. Example ```python Input: [64, 25, 12, 22, 11] Output: [11, 12, 22, 25, 64] Input: [3, 2, 1, 5, 4] Output: [1, 2, 3, 4, 5] ``` Performance Requirements * Your solution should have a worst-case time complexity of O(n^2) but aim to reduce the number of comparisons when possible.","solution":"def optimized_exchange_sort(arr): An optimized Exchange Sort algorithm that stops early if the array is already sorted. n = len(arr) for i in range(n-1): swapped = False for j in range(i+1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: break return arr"},{"question":"You are required to implement a Binary Search Tree (BST) with the following functionalities: 1. **Insert**: Insert a new node in the BST. 2. **Search**: Search for a value in the BST. 3. **Size**: Return the size (number of nodes) of the BST. 4. **Traversal**: Perform Preorder, Inorder, and Postorder traversals of the BST. Additionally, you need to implement a function to find the height of the BST. The height of a tree is the number of edges in the longest path from the root to a leaf node. # Function Signatures ```python class BST: def __init__(self): # Initialize the tree. pass def insert(self, data): # Inserts a value into the BST. pass def search(self, data): # Searches for a value in the BST. pass def size(self): # Returns the size of the BST. pass def preorder(self): # Preorder traversal of the BST. pass def inorder(self): # Inorder traversal of the BST. pass def postorder(self): # Postorder traversal of the BST. pass def height(self): # Returns the height of the BST. pass ``` # Input and Output Formats - **Insert Function**: - Input: A single integer value. - Output: None. - **Search Function**: - Input: A single integer value. - Output: Boolean indicating whether the value exists in the BST. - **Size Function**: - Input: None. - Output: An integer representing the number of nodes in the BST. - **Traversal Functions**: - Input: None. - Output: List of integers representing the traversal order. - **Height Function**: - Input: None. - Output: An integer representing the height of the BST. # Constraints - Assume all values are distinct. - The values to be inserted are positive integers. - The BST should handle up to 10^4 nodes efficiently. # Example Usage ```python bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) print(bst.search(5)) # Output: True print(bst.search(20)) # Output: False print(bst.size()) # Output: 4 print(bst.inorder()) # Output: [3, 5, 10, 15] print(bst.preorder()) # Output: [10, 5, 3, 15] print(bst.postorder()) # Output: [3, 5, 15, 10] print(bst.height()) # Output: 2 ``` # Notes Make sure your solution handles edge cases gracefully, such as inserting into an empty tree or traversing an empty tree. Efficiency in both time and space should be considered in your implementation.","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None self._size = 0 def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert_rec(self.root, data) self._size += 1 def _insert_rec(self, node, data): if data < node.data: if node.left: self._insert_rec(node.left, data) else: node.left = Node(data) else: if node.right: self._insert_rec(node.right, data) else: node.right = Node(data) def search(self, data): return self._search_rec(self.root, data) def _search_rec(self, node, data): if not node: return False if node.data == data: return True elif data < node.data: return self._search_rec(node.left, data) else: return self._search_rec(node.right, data) def size(self): return self._size def preorder(self): result = [] self._preorder_rec(self.root, result) return result def _preorder_rec(self, node, result): if node: result.append(node.data) self._preorder_rec(node.left, result) self._preorder_rec(node.right, result) def inorder(self): result = [] self._inorder_rec(self.root, result) return result def _inorder_rec(self, node, result): if node: self._inorder_rec(node.left, result) result.append(node.data) self._inorder_rec(node.right, result) def postorder(self): result = [] self._postorder_rec(self.root, result) return result def _postorder_rec(self, node, result): if node: self._postorder_rec(node.left, result) self._postorder_rec(node.right, result) result.append(node.data) def height(self): return self._height_rec(self.root) def _height_rec(self, node): if not node: return -1 left_height = self._height_rec(node.left) right_height = self._height_rec(node.right) return 1 + max(left_height, right_height)"},{"question":"# Randomized Set Implementation Context You are required to implement a data structure that simulates a set supporting constant average time complexity operations for insertion, deletion, and retrieval of a random element. The provided operations need to handle random uniformity and must avoid duplicate entries. Objective Implement the `RandomizedSet` class to support the following functionalities: - **insert(val)**: Inserts an item val to the set if not already present. - **remove(val)**: Removes an item val from the set if present. - **random_element()**: Returns a random element from current set of elements. Each element must have the same probability of being returned. Input and Output Specifications * The `insert(val)` function should take an integer `val` and return a boolean indicating whether the insertion was successful. * The `remove(val)` function should take an integer `val` and return a boolean indicating whether the removal was successful. * The `random_element()` function should return an integer which is a random element from the set. * **Constraints**: - The integers used as input elements are within the range `[-10^6, 10^6]`. - Calls to `random_element` should guarantee uniform randomness. - The number of possible calls to the function will not exceed `10^5`. Example ```python # Example usage: random_set = RandomizedSet() # Inserting values assert random_set.insert(1) == True # returns True as 1 is inserted assert random_set.insert(1) == False # returns False as 1 is already present # Removing values assert random_set.remove(1) == True # returns True as 1 is removed assert random_set.remove(2) == False # returns False as 2 is not present # Random element (uniform random distribution) random_set.insert(2) random_set.insert(3) # should return randomly 2 or 3 random_element = random_set.random_element() print(random_element in [2, 3]) ``` Implement the `RandomizedSet` class and ensure efficiency and correctness of the operations in the face of edge cases and large inputs.","solution":"import random class RandomizedSet: def __init__(self): self.val_to_index = {} self.values = [] def insert(self, val): if val in self.val_to_index: return False else: self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val): if val in self.val_to_index: index = self.val_to_index[val] last_element = self.values[-1] # Move the last element to the place of the element to remove self.values[index] = last_element self.val_to_index[last_element] = index # Remove the last element self.values.pop() del self.val_to_index[val] return True else: return False def random_element(self): return random.choice(self.values)"},{"question":"Spiral Matrix Reconstruction **Problem Statement:** Given a matrix of m x n elements (m rows, n columns), write a function `spiral_traversal(matrix)` that returns all elements of the matrix in spiral order. **Input:** - A 2D list `matrix` where `matrix[i][j]` represents the element at the ith row and jth column of the matrix. **Output:** - A list of integers representing the elements of the matrix in spiral order. **Constraints:** - 0 <= m, n <= 1000 - The elements of the matrix are integers within the range [-1000, 1000]. - The dimensions of the matrix might not be uniform. **Examples:** 1. Input: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` Output: `[1, 2, 3, 6, 9, 8, 7, 4, 5]` 2. Input: `[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]` Output: `[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]` **Functional Requirements:** - The function should handle edge cases like empty matrices. - Performance should be optimal for larger matrices up to the specified constraints. - Ensure that the function adheres to the input-output format strictly.","solution":"def spiral_traversal(matrix): Returns all elements of the matrix in spiral order. if not matrix: return [] result = [] while matrix: # take the first row result += matrix.pop(0) if not matrix or not matrix[0]: break # take the last element of each remaining row for row in matrix: result.append(row.pop()) if not matrix: break # take the last row in reverse order result += matrix.pop()[::-1] if not matrix or not matrix[0]: break # take the first element of each remaining row (from bottom to top) for row in matrix[::-1]: result.append(row.pop(0)) return result"},{"question":"# Question: Word Segmentation You are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature ```python def can_segment(s: str, wordDict: List[str]) -> bool: pass ``` # Input * `s` - A non-empty string (1 ≤ len(s) ≤ 300). * `wordDict` - A list of non-empty strings (words are unique, each word length is between 1 and 20, and the list size ≤ 1000). # Output * Return `True` if the string can be segmented; otherwise, return `False`. # Constraints * You may assume the dictionary does not contain duplicate words. * The solution must be efficient in terms of both time and space complexity. # Example ```python s = \\"applepenapple\\" wordDict = [\\"apple\\", \\"pen\\"] Output: True Explanation: \\"applepenapple\\" can be segmented as \\"apple pen apple\\". ``` # Scenario Imagine you are developing a text editor that has an auto-completion feature. One of the features should be checking if a sequence of characters typed by the user can be split into known words from a dictionary. This function will help in determining if the current input can be segmented into valid words. # Edge Cases * Should handle cases where no segmentation is possible. * Should handle larger strings efficiently within given constraints. Implement the function `can_segment` to solve the problem described above.","solution":"from typing import List def can_segment(s: str, wordDict: List[str]) -> bool: word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"# Primality Checker Enhancement You are asked to enhance the existing prime-check algorithm by implementing an additional function that not only checks for primality but also returns a list of prime factors for non-prime numbers. Your task is to write a Python function called `prime_factors_or_prime_check` that takes an integer as its input. **Function Signature**: ```python def prime_factors_or_prime_check(n: int) -> Union[bool, List[int]]: ``` **Input**: - `n` (integer): The number to check for primality. **Output**: - If `n` is a prime number, the function should return `True`. - If `n` is not a prime number, the function should return a list of prime factors of `n`. **Constraints**: - `n` will be in the range [0, 10^6]. **Examples**: ```python prime_factors_or_prime_check(7) # Output: True prime_factors_or_prime_check(10) # Output: [2, 5] prime_factors_or_prime_check(20) # Output: [2, 2, 5] prime_factors_or_prime_check(1) # Output: False prime_factors_or_prime_check(0) # Output: False ``` **Notes**: - A prime factor is a factor that is a prime number. - The numbers 0 and 1 are not considered prime. - Ensure the solution handles large numbers efficiently.","solution":"from typing import Union, List def prime_factors_or_prime_check(n: int) -> Union[bool, List[int]]: Returns True if n is a prime number, otherwise returns a list of prime factors of n. if n <= 1: return False prime_factors = [] i = 2 # Checking for smallest factors i.e starting with 2 and moving upward while i * i <= n: while (n % i) == 0: prime_factors.append(i) n //= i i += 1 # If n is a prime number greater than 2, then add it to the list if n > 1: prime_factors.append(n) # If no prime factors were found, n is a prime number. if len(prime_factors) == 1 and prime_factors[0] == n: return True else: return prime_factors"},{"question":"# RSA Encryption and Decryption Implementation You are required to implement a secure communication system based on the RSA encryption algorithm. RSA is a widely-used public-key cryptosystem that facilitates the encryption and decryption of data. You need to generate a public-private keypair, encrypt a message with the public key, and decrypt it with the private key. # Function Specifications You need to implement the following functions: 1. **generate_key(bits, seed)** Generates a RSA keypair. - **Input**: `bits` (int) - The size of the key in bits. `seed` (int) - Seed for random prime generation (optional). - **Output**: Returns a tuple of three integers: (n, e, d). 2. **encrypt(data, e, n)** Encrypts the given data using the public key (e, n). - **Input**: `data` (int) - The data to encrypt. `e` (int) - The public exponent. `n` (int) - The modulus. - **Output**: Returns an integer representing the encrypted data. 3. **decrypt(data, d, n)** Decrypts the given data using the private key (d, n). - **Input**: `data` (int) - The data to decrypt. `d` (int) - The private exponent. `n` (int) - The modulus. - **Output**: Returns an integer representing the decrypted data. # Constraints - The input sizes for keys should be practical (example: between 16 and 1024 bits for testing purposes). - Ensure that the prime numbers generated are sufficiently random and large enough to suit the specified key size. - The system should correctly handle generation, encryption, and decryption within a reasonable time frame. # Example Usage ```python n, e, d = generate_key(16) message = 20 encrypted_message = encrypt(message, e, n) decrypted_message = decrypt(encrypted_message, d, n) assert decrypted_message == message ``` # Notes Ensure that your implementation considers edge cases such as the correct generation of prime numbers and the mathematical properties required for RSA encryption. Approaches should be efficient and use optimal algorithms for the various mathematical operations involved.","solution":"import random from sympy import isprime, mod_inverse, nextprime def generate_prime(bits, seed=None): if seed is not None: random.seed(seed) prime_candidate = random.getrandbits(bits) while not isprime(prime_candidate): prime_candidate = nextprime(prime_candidate) return prime_candidate def generate_key(bits, seed=None): Generates RSA keypair of size `bits`. p = generate_prime(bits // 2, seed) q = generate_prime(bits // 2, seed + 1 if seed is not None else None) n = p * q phi = (p - 1) * (q - 1) e = 65537 # common choice for e d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): Encrypts the given data using public key (e, n). return pow(data, e, n) def decrypt(data, d, n): Decrypts the given data using private key (d, n). return pow(data, d, n)"},{"question":"You are working on a predictive text entry system for a modern touch-screen device. Given a string of digits, your task is to write a function that returns all possible letter combinations the digits could represent. The mapping of digits to letters is similar to that used on traditional telephone keypads: ``` 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" ``` # Function Signature ```python def letter_combinations(digits: str) -> List[str]: ``` # Input * A string `digits` consisting of characters \'2\'-\'9\'. * The length of `digits` will be in the range [0, 4]. # Output * Return a list of all possible letter combinations. # Examples ```python assert letter_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert letter_combinations(\\"2\\") == [\\"a\\", \\"b\\", \\"c\\"] assert letter_combinations(\\"\\") == [] assert letter_combinations(\\"7\\") == [\\"p\\", \\"q\\", \\"r\\", \\"s\\"] ``` # Constraints * Ensure that the time complexity of your solution does not exceed O(4^N), where N is the length of the input string. * Handle edge cases like empty input efficiently. # Additional Notes * Avoid using recursion due to potential stack overflow issues for larger ranges in extended versions of the problem. * Consider the efficiency of your solution in terms of both time and space to handle the upper bounds of constraints effectively.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if len(path) == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Segment Tree Problem You have been provided with a Segment Tree implementation that supports range queries and updates. Your task is to extend this Segment Tree to support the following additional functionality: 1. **Range Update**: Update all elements in a specified range. The new value should be applied to all the elements in the specified range. 2. **Range Minimum Query with Lazy Propagation**: Implement a new type of query that finds the minimum value in a specified range using lazy propagation to ensure efficient subsequent range updates. You must implement the following additional methods in the `SegmentTree` class: ```python def range_update(self, l: int, r: int, value): Apply the \'value\' to all elements in the range [l, r]. Parameters: l (int): Start index of the range (inclusive). r (int): End index of the range (inclusive). value: The value to update the elements with. pass def range_min_query(self, l: int, r: int) -> int: Find the minimum value in the range [l, r] using lazy propagation. Parameters: l (int): Start index of the range (inclusive). r (int): End index of the range (inclusive). Returns: int: The minimum value in the specified range. pass ``` # Input and Output Formats * The SegmentTree class constructor takes two parameters: an array and a commutative function. * The `range_update` method takes two integers `l` and `r` representing the start and end indices of the range (both inclusive), and the value to update elements within that range. * The `range_min_query` method takes two integers `l` and `r` representing the start and end indices of the range (both inclusive), and returns an integer representing the minimum value in that range. # Constraints - Assume all values in the array are integers. - The function provided will always be commutative and work correctly with the given array elements. - The indices provided in methods will always be valid (0 <= l <= r < size of the array). # Performance Requirements Both methods should efficiently handle updates and queries to ensure a time complexity of O(log N) for both range updates and range minimum queries. # Example With the provided SegmentTree class, an example sequence of operation would be: ```python # Initialize the Segment Tree with an array mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], min) # Update the range [1, 3] with the value 1 mytree.range_update(1, 3, 1) # Query for the minimum value in the range [0, 6] print(mytree.range_min_query(0, 6)) # Output should reflect the updated values ``` This question requires implementing both the `range_update` and `range_min_query` methods with lazy propagation to ensure that both operations are optimized.","solution":"class SegmentTree: def __init__(self, arr, func): self.n = len(arr) self.tree = [0] * (2 * self.n) self.lazy = [None] * (2 * self.n) self.func = func self.build(arr) def build(self, arr): for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): \'\'\' Single element update \'\'\' pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_update(self, l, r, value): \'\'\' Apply \'value\' to all elements in the range [l, r] \'\'\' self._range_update(1, 0, self.n - 1, l, r, value) def _range_update(self, node, node_l, node_r, l, r, value): if self.lazy[node] is not None: self.tree[node] = self.lazy[node] if node_l != node_r: self.lazy[node * 2] = self.lazy[node] self.lazy[node * 2 + 1] = self.lazy[node] self.lazy[node] = None if node_l > node_r or node_l > r or node_r < l: return if node_l >= l and node_r <= r: self.tree[node] = value if node_l != node_r: self.lazy[node * 2] = value self.lazy[node * 2 + 1] = value return mid = (node_l + node_r) // 2 self._range_update(node * 2, node_l, mid, l, r, value) self._range_update(node * 2 + 1, mid + 1, node_r, l, r, value) self.tree[node] = self.func(self.tree[node * 2], self.tree[node * 2 + 1]) def range_min_query(self, l, r): \'\'\' Find the minimum value in the range [l, r] using lazy propagation \'\'\' return self._range_min_query(1, 0, self.n - 1, l, r) def _range_min_query(self, node, node_l, node_r, l, r): if self.lazy[node] is not None: self.tree[node] = self.lazy[node] if node_l != node_r: self.lazy[node * 2] = self.lazy[node] self.lazy[node * 2 + 1] = self.lazy[node] self.lazy[node] = None if node_l > node_r or node_l > r or node_r < l: return float(\'inf\') if node_l >= l and node_r <= r: return self.tree[node] mid = (node_l + node_r) // 2 left_min = self._range_min_query(node * 2, node_l, mid, l, r) right_min = self._range_min_query(node * 2 + 1, mid + 1, node_r, l, r) return self.func(left_min, right_min)"},{"question":"# Question Problem Statement You are required to implement the Gnome Sort algorithm that sorts an array of integers in non-decreasing order. Gnome Sort is a simple sorting algorithm that works by comparing elements similar to the way a gnome sorts flower pots. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers, `arr`, where: - (1 leq text{len(arr)} leq 10^5) - (-10^9 leq text{arr[i]} leq 10^9) Output - Returns a list of integers that is the sorted version of `arr`. Constraints - You must implement the Gnome Sort algorithm. - Optimize for readability and maintainability of your code. Example ```python print(gnome_sort([34, 2, 10, -9])) # Output: [-9, 2, 10, 34] print(gnome_sort([5, 3, 2, 4])) # Output: [2, 3, 4, 5] print(gnome_sort([1])) # Output: [1] print(gnome_sort([])) # Output: [] ``` Performance Requirements - Your solution should handle cases up to the maximum constraints efficiently where applicable. Scenario Imagine you are participating in a hackathon where you are given diverse datasets, some of which are almost sorted, and some are randomly ordered. You decide to use Gnome Sort for its simplicity and because it can sort nearly sorted lists efficiently.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Gnome Sort algorithm. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Permutations Problem You are given a list of distinct integers. Your task is to generate all possible permutations for this list. Permutations are the different ways in which a set of items can be ordered. Implement a function that efficiently generates these permutations. **Function Signature:** ```python def generate_permutations(elements: List[int]) -> List[List[int]]: pass ``` # Input * `elements` - A list of distinct integers `n` (0 <= n <= 8) indicating the set whose permutations we need to generate. # Output * A list of lists, where each inner list is a permutation of the input list. # Constraints * The length of the input list will not exceed 8. # Performance Requirements * Consider both time and space complexity and ensure the function executes efficiently within the given constraints. # Scenario A combinatorial problem involves generating all different ways of arranging a set of unique items. Such problems often appear in game design, solving puzzles, and in various algorithmic challenges. For instance, given the list of numbers [1,2,3], the function should return the following permutations: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Example ```python assert generate_permutations([1, 2, 3]) == [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert generate_permutations([0, 1]) == [ [0, 1], [1, 0] ] ``` # Notes * An efficient solution is expected. * Properly handle edge cases. * Make sure to account for potential performance bottlenecks with large input sizes within the provided constraints.","solution":"from typing import List from itertools import permutations def generate_permutations(elements: List[int]) -> List[List[int]]: Generate all possible permutations of the given list of distinct integers. Args: elements (List[int]): A list of distinct integers. Returns: List[List[int]]: A list of lists, where each inner list is a permutation of the input list. return [list(p) for p in permutations(elements)]"},{"question":"# Question: Implement Doubly Linked List with Tail Pointer You are required to design and implement a doubly linked list that has a `tail` pointer for efficient insertions at the end. The doubly linked list should support the following operations efficiently: 1. `add_to_head(value)` - Adds a new node with the given value to the beginning of the list. 2. `add_to_tail(value)` - Adds a new node with the given value to the end of the list. 3. `remove_from_head()` - Removes the node at the beginning of the list and returns its value. 4. `remove_from_tail()` - Removes the node at the end of the list and returns its value. 5. `find(value)` - Searches for the node with the given value and returns its position (0-based index) in the list, or -1 if not found. 6. `size()` - Returns the number of elements in the list. Input/Output Formats The functions should be implemented as methods of a `DoublyLinkedList` class. - `add_to_head(value)`: This method does not return anything. - `add_to_tail(value)`: This method does not return anything. - `remove_from_head() -> value`: Returns the value of the removed node, or `None` if the list is empty. - `remove_from_tail() -> value`: Returns the value of the removed node, or `None` if the list is empty. - `find(value) -> index`: Returns the 0-based index of the node with the given value, or `-1` if not found. - `size() -> int`: Returns the number of elements in the list. Constraints * The list should be able to handle up to 10^5 operations efficiently. * Values in the nodes will be integers. # Example Usage: ```python dll = DoublyLinkedList() dll.add_to_head(10) dll.add_to_tail(20) print(dll.remove_from_head()) # Output: 10 print(dll.size()) # Output: 1 dll.add_to_tail(30) dll.add_to_tail(40) print(dll.find(30)) # Output: 1 print(dll.remove_from_tail()) # Output: 40 ``` Make sure to consider edge cases such as operations on an empty list and operations when the list contains only one element.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self._size = 0 def add_to_head(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node self._size += 1 def add_to_tail(self, value): new_node = Node(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node self._size += 1 def remove_from_head(self): if not self.head: return None value = self.head.value if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None self._size -= 1 return value def remove_from_tail(self): if not self.tail: return None value = self.tail.value if self.head == self.tail: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None self._size -= 1 return value def find(self, value): current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def size(self): return self._size"},{"question":"# Question: Find the Intersection Node of Two Singly Linked Lists Objective Implement a function to find the intersection node between two singly linked lists. The intersection is defined by reference, not by value. Problem Statement Two linked lists intersect if they share some nodes. The intersection node should be identified and returned by reference. If there is no intersection, return `None`. Function Signature ```python def intersection(h1: Node, h2: Node) -> Optional[Node]: Find the intersection node between two singly linked lists defined by reference. :param h1: Node - The head of the first linked list. :param h2: Node - The head of the second linked list. :return: Optional[Node] - The intersecting node if any, otherwise None. ``` Input/Output Format * **Input**: * `h1`: Head node of the first linked list. * `h2`: Head node of the second linked list. * **Output**: * The intersecting node if the linked lists intersect, otherwise None. Constraints * Both linked lists should not contain cycles. * The maximum length of a singly linked list can be 10<sup>5</sup>. Example Consider the below two linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` For these lists, the intersection node should be `7`. ```python # Test case a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) e = Node(9) f = Node(11) a2 = Node(2) b2 = Node(4) c2 = Node(6) a1.next = b1 b1.next = c1 c1.next = d d.next = e e.next = f a2.next = b2 b2.next = c2 c2.next = d result = intersection(a1, a2) assert result is not None and result.val == 7 ``` Performance Your solution should have a time complexity of O(N + M) and space complexity of O(1). Notes Your implementation should ensure the solution is correct even when the lists are empty or there are no intersections.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def get_length(head: Node) -> int: length = 0 current = head while current: length += 1 current = current.next return length def intersection(h1: Node, h2: Node) -> Node: if not h1 or not h2: return None len1 = get_length(h1) len2 = get_length(h2) # Adjust the starting point of the longer list while len1 > len2: h1 = h1.next len1 -= 1 while len2 > len1: h2 = h2.next len2 -= 1 # Traverse both lists together to find the intersection while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"You are provided with a disjoint set (or Union-Find) data structure implementation. Your task is to extend this functionality to solve a specific problem. # Problem Statement Consider a 2D grid where cells represent either land (1) or water (0). You need to determine the number of islands in the grid after each land addition. An island is defined as a group of adjacent lands (horizontally or vertically but not diagonally). Implement the function `num_islands_after_operations(grid_size, positions)` that takes the following arguments: - `grid_size` (tuple of two integers): The dimensions of the grid `(rows, cols)`. - `positions` (list of tuples): Each tuple `(r, c)` represents a position in the grid to turn from water to land. The function should return a list of integers, where each integer represents the number of islands after each land addition. # Constraints - The grid will have at most 10,000 cells. - Each position in `positions` is unique and valid within the grid dimensions. - The maximum number of `positions` is 10,000. # Function Signature ```python def num_islands_after_operations(grid_size, positions): pass ``` # Example ```python grid_size = (3, 3) positions = [(0, 0), (0, 1), (1, 2), (2, 1)] assert num_islands_after_operations(grid_size, positions) == [1, 1, 2, 3] ``` # Detailed Explanation 1. Start with a 3x3 grid filled with water: ``` 0 0 0 0 0 0 0 0 0 ``` 2. Turn `(0, 0)` to land: ``` 1 0 0 0 0 0 0 0 0 Number of islands = 1 ``` 3. Turn `(0, 1)` to land: ``` 1 1 0 0 0 0 0 0 0 Number of islands = 1 ``` 4. Turn `(1, 2)` to land: ``` 1 1 0 0 0 1 0 0 0 Number of islands = 2 ``` 5. Turn `(2, 1)` to land: ``` 1 1 0 0 0 1 0 1 0 Number of islands = 3 ```","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add_count(self): self.count += 1 def num_islands_after_operations(grid_size, positions): rows, cols = grid_size total_cells = rows * cols uf = UnionFind(total_cells) grid = [[0] * cols for _ in range(rows)] result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: if grid[r][c] == 0: grid[r][c] = 1 index = r * cols + c uf.add_count() for dr, dc in directions: rr, cc = r + dr, c + dc if 0 <= rr < rows and 0 <= cc < cols and grid[rr][cc] == 1: uf.union(index, rr * cols + cc) result.append(uf.count) return result"},{"question":"# Question You are given a sorted array of integers and an integer key. Implement the ternary search algorithm in Python to find the index of the key. If the key is not present in the array, return -1. Ensure that your implementation handles edge cases and perform the search in O(log3(N)) time complexity. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` **Input**: * `left`: An integer representing the left index of the search range (initially 0). * `right`: An integer representing the right index of the search range (initially len(arr) - 1). * `key`: An integer representing the value to search for. * `arr`: A list of integers, sorted in ascending order. **Output**: * Return the index of the key if found, otherwise return -1. **Constraints**: * The length of the array will be in the range [1, 10^6]. * The integer values in the array and the key will be in the range [-10^9, 10^9]. **Example**: ```python assert ternary_search(0, 6, 15, [1, 2, 8, 10, 15, 21, 35]) == 4 assert ternary_search(0, 6, 9, [1, 2, 8, 10, 15, 21, 35]) == -1 assert ternary_search(0, 5, 1, [1, 2, 3, 4, 5, 6]) == 0 assert ternary_search(0, 0, 10, [10]) == 0 assert ternary_search(0, 0, 20, [10]) == -1 ``` **Special Notes**: * If the array contains duplicate values, return the index of any one occurrence of the key.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform ternary search on a sorted array. while right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Question: Next Greater Permutation** Given a non-negative integer, write a function `next_bigger(num: int) -> int` that returns the next greater number with the same set of digits. If no such number exists, return -1. # Carefully consider the following: 1. The function should handle edge cases like digits being in descending order or all digits being the same. 2. Optimize for both time and space complexity where possible. 3. Ensure the solution works efficiently for larger inputs while maintaining clarity and correctness. **Function Signature:** ```python def next_bigger(num: int) -> int: pass ``` # Input * `num (1 <= num <= 10^18)`: a non-negative integer representing the input number. # Output * An integer representing the next greater number with the same set of digits. Return -1 if no such number exists. # Constraints 1. The input number may have up to 18 digits. 2. The processing time must be within reasonable limits for large numbers. 3. No use of additional libraries beyond basic Python standard library functions. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 ``` # Explanation 1. For 38276, the next permutation larger than the number is 38627. 2. For 12345, it is 12354. 3. For 54321, no greater permutation exists in lexicographical order, so return -1.","solution":"def next_bigger(num: int) -> int: num_str = list(str(num)) length = len(num_str) # Step 1: Find the rightmost character which is smaller than its next character. i = length - 2 while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 if i == -1: # If no such character is found, return -1 return -1 # Step 2: Find the rightmost character to the right of i that is greater than num_str[i] j = length - 1 while num_str[j] <= num_str[i]: j -= 1 # Step 3: Swap the characters at i and j num_str[i], num_str[j] = num_str[j], num_str[i] # Step 4: Reverse the sequence after i num_str = num_str[:i+1] + sorted(num_str[i+1:]) return int(\'\'.join(num_str))"},{"question":"# ZigZag Iterator for Multiple Lists **Scenario**: Suppose you have `n` lists and you need to iterate through these lists in a round-robin fashion, fetching elements from each list in sequential order. When one list is exhausted, it should be skipped until all elements from the lists are retrieved. **Task**: Implement a `ZigZagIterator` class that can handle an arbitrary number of lists. **Function Signature**: ```python class ZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` **Input**: * `__init__(self, lists: List[List[int]])`: * `lists`: A list of integer lists. Each list can have different lengths, including potentially being empty. * `next(self) -> int`: * Fetches and returns the next element in round-robin order across the lists. * `has_next(self) -> bool`: * Returns `True` if there are more elements to iterate, `False` otherwise. **Output**: * `next(self) -> int`: The next integer in the round-robin iteration. * `has_next(self) -> bool`: Boolean indicating if there are more elements to iterate. **Constraints**: * `0 <= lengths of lists[i] <= 1000` * The total number of elements from all lists combined will not exceed 10000. **Example**: ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] iterator = ZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` **Performance Note**: * Ensure the implementation efficiently handles round-robin access even if lists have significantly different lengths. * Optimize both `next()` and `has_next()` to avoid unnecessary computation delays.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque((lst, 0) for lst in lists if lst) def next(self) -> int: :rtype: int if self.queue: lst, index = self.queue.popleft() result = lst[index] if index + 1 < len(lst): self.queue.append((lst, index + 1)) return result raise Exception(\\"No more elements\\") def has_next(self) -> bool: :rtype: bool return len(self.queue) > 0"},{"question":"# Scenario: You are working as a software engineer at a transportation company. Your team is developing a navigation system that calculates the shortest route for delivery trucks between various warehouses in a city. You need to implement an algorithm that finds the shortest path from a starting warehouse to all other warehouses, considering the road distances (non-negative weights). # Task: Implement the function `shortest_paths(v: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]` where: - `v` is the number of vertices (warehouses). - `edges` is a list of tuples `(u, w, d)`, representing edge `u -> w` with distance `d`. - `src` is the starting warehouse. The function should return a list of shortest distances from the start warehouse to all other warehouses. # Constraints: 1. 1 <= v <= 1000 2. 0 <= d <= INT_MAX 3. edges are bidirectional. # Performance Requirements: Your solution should strive for an efficient approach, ideally with a time complexity better than O(V^2) if possible. # Example: ```python v = 5 edges = [(0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (4, 1, 3), (4, 3, 2), (4, 2, 9)] src = 0 assert shortest_paths(v, edges, src) == [0, 8, 9, 7, 5] ```","solution":"import heapq from typing import List, Tuple def shortest_paths(v: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Computes the shortest paths from the source vertex to all other vertices in a graph with non-negative weights using Dijkstra\'s algorithm. :param v: Number of vertices. :param edges: List of edges where each edge is represented as a tuple (u, w, d) indicating an edge from u to w with weight d. :param src: Source vertex. :return: List of shortest distances from the source vertex to all other vertices. # Initialize distance array with infinity dist = [float(\'inf\')] * v dist[src] = 0 # Create an adjacency list adj = [[] for _ in range(v)] for u, w, d in edges: adj[u].append((w, d)) adj[w].append((u, d)) # Since the edges are bidirectional # Priority queue to store the next vertex to explore (distance, vertex) pq = [(0, src)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for neighbor, weight in adj[u]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist"},{"question":"# Pigeonhole Sort Implementation Challenge Background Pigeonhole sort is an efficient sorting algorithm when there is a finite range within which all elements of an array fall. The algorithm distributes the elements into \\"pigeonholes\\" which correspond to all possible values within that range, counts occurrences, and then reconstructs the sorted array. Challenge Implement the pigeonhole sort algorithm for a given array of integers ensuring the algorithm handles various edge cases efficiently and correctly. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers, where the length of the list and the range of values are both potentially large. Constraints: - `0 <= len(arr) <= 10^6` - The values in `arr` can be between `-10^6` and `10^6` inclusive. Output - Return a new list of integers which represents the sorted order of the input list. Performance Requirements - The solution should aim for O(n + Range) complexity where n is the number of elements and Range is the difference between the maximum and minimum values. Example ```python assert pigeonhole_sort([8, 3, -1, 1, 0, 7, 3, 3, 2]) == [-1, 0, 1, 2, 3, 3, 3, 7, 8] assert pigeonhole_sort([5, 4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4, 5] assert pigeonhole_sort([1, 4, 2, 2, 3, 3, 3, 4, 4, 2]) == [1, 2, 2, 2, 3, 3, 3, 4, 4, 4] assert pigeonhole_sort([]) == [] ``` Additional Considerations - Ensure your implementation can handle very large ranges efficiently without running into memory issues. - Consider edge cases such as the empty array, single-element arrays, and arrays with duplicate values.","solution":"def pigeonhole_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_values = max_val - min_val + 1 # Create pigeonholes pigeonholes = [0] * range_of_values # Populate the pigeonholes for number in arr: pigeonholes[number - min_val] += 1 sorted_arr = [] for i in range(range_of_values): while pigeonholes[i] > 0: sorted_arr.append(i + min_val) pigeonholes[i] -= 1 return sorted_arr"},{"question":"Problem Statement You are given a sorted (in increasing order) array of integers `arr` and an integer `x`. Your task is to implement a function `first_occurrence(arr, x)` which returns the index of the first occurrence of `x` in the array. If `x` does not exist in the array, return `-1`. Function Signature ```python def first_occurrence(arr: List[int], x: int) -> int: pass ``` Input * `arr`: A list of integers of length `n` where `1 <= n <= 10^6` and `-10^9 <= arr[i] <= 10^9`. The array is sorted in increasing order. * `x`: An integer `-10^9 <= x <= 10^9`. Output * Return the index of the first occurrence of `x` in `arr`. If `x` is not present in `arr`, return `-1`. Constraints * Your solution should have a time complexity of O(log n) and a space complexity of O(1). Example ```python # Example 1 arr = [1, 2, 2, 2, 3, 4, 5] x = 2 # Output: 1 # Example 2 arr = [1, 1, 1, 1, 1, 1, 1] x = 1 # Output: 0 # Example 3 arr = [1, 3, 5, 7, 9, 11, 13] x = 4 # Output: -1 ``` Note * You must use binary search to achieve the desired time complexity. * Carefully consider edge cases, such as when `arr` is empty or when `x` is at the extreme ends of the array.","solution":"from typing import List def first_occurrence(arr: List[int], x: int) -> int: Returns the index of the first occurrence of x in the sorted array arr. If x is not present in arr, returns -1. left, right = 0, len(arr) - 1 first_index = -1 while left <= right: mid = (left + right) // 2 if arr[mid] == x: first_index = mid right = mid - 1 # Continue searching on the left side elif arr[mid] < x: left = mid + 1 else: right = mid - 1 return first_index"},{"question":"Bit Manipulation Context You are working on a project that requires efficient bit manipulation for performance-critical tasks. One part of the project involves writing a function that swaps each pair of adjacent bits in a 32-bit integer. For example, bit 0 with bit 1, bit 2 with bit 3, and so on. Task Implement a function `swap_pair(num: int) -> int` that takes a 32-bit integer `num` and returns a new integer with each pair of adjacent bits swapped. Input and Output Formats - **Input**: An integer `num` (0 <= num < 2^32) - **Output**: An integer that represents the result of swapping adjacent bits of the input integer. Constraints - The input integer is non-negative and fits within 32 bits. - Minimize the number of operations to achieve the result. Example ```python assert swap_pair(22) == 41 # 22 (010110 in binary) -> 41 (101001 in binary) assert swap_pair(10) == 5 # 10 (1010 in binary) -> 5 (0101 in binary) ``` Requirements 1. **Efficiency**: Your solution must run in constant time O(1). 2. **Bitwise Operations**: Use bitwise operations to achieve the task. Implementation Skeleton ```python def swap_pair(num: int) -> int: Function to swap odd and even bits in a 32-bit integer. :param num: A 32-bit non-negative integer :return: Integer with swapped odd and even bits # odd bits right shift 1 bit odd = (num & int(\'AAAAAAAA\', 16)) >> 1 # even bits left shift 1 bit even = (num & int(\'55555555\', 16)) << 1 return odd | even ``` **Hint**: Use the provided binary masks to separate odd and even bits (`0xAAAAAAAA` for odd and `0x55555555` for even) and then shift them appropriately before combining.","solution":"def swap_pair(num: int) -> int: Function to swap odd and even bits in a 32-bit integer. :param num: A 32-bit non-negative integer :return: Integer with swapped odd and even bits # odd bits right shift 1 bit odd = (num & 0xAAAAAAAA) >> 1 # even bits left shift 1 bit even = (num & 0x55555555) << 1 return odd | even"},{"question":"Implement Efficient String Search You\'re given two strings `haystack` and `needle`. Your task is to write a function `find_string_index(haystack, needle)` that returns an index representing the first position where `needle` is found in `haystack`. If `needle` is not found in `haystack`, return -1. If `needle` is an empty string, return 0. The aim of this problem is to assess your understanding of advanced string matching algorithms. Implement an efficient algorithm that improves upon the naive approach provided above. # Input/Output Specification - **Input**: * `haystack` - a string of length `N` (1 ≤ `N` ≤ 10^6) * `needle` - a string of length `M` (0 ≤ `M` ≤ `N`) - **Output**: * An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. * 0 if `needle` is an empty string. # Constraints * Handle edge cases effectively. * Optimize the time complexity to less than O((N-M+1)*M) if possible. * Python\'s built-in methods like `str.index()` or `str.find()` should not be used. # Example 1. **Example 1**: - Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` - Output: 2 2. **Example 2**: - Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` - Output: -1 # Performance Requirements Your function should run efficiently on large inputs, with `N` and `M` up to 10^6.","solution":"def find_string_index(haystack, needle): Finds the index of the first occurrence of needle in haystack. If needle is not found, returns -1. If needle is an empty string, returns 0. def kmp_prefix_function(pattern): Computes the prefix function (partial match table) for KMP algorithm prefix_table = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j return prefix_table if not needle: return 0 m, n = len(haystack), len(needle) prefix_table = kmp_prefix_function(needle) j = 0 # index for needle for i in range(m): # index for haystack while j > 0 and haystack[i] != needle[j]: j = prefix_table[j - 1] if haystack[i] == needle[j]: j += 1 if j == n: return i - n + 1 return -1"},{"question":"# Bogo Sort Analysis and Enhancement Scenario You have come across an inefficient sorting algorithm called Bogo Sort which randomly shuffles the array until it becomes sorted. Your task is to understand its inefficiencies and then write a more practical approach. Task 1. **Analysis**: - Explain why Bogo Sort is inherently inefficient and impractical for sorting large datasets. 2. **Implementation**: - Implement a more efficient sorting algorithm (e.g., Merge Sort) which offers better complexity guarantees. 3. **Comparative Output**: - Write a function `compare_sorts(arr)` which demonstrates the difference in time taken by Bogo Sort and your chosen efficient sort on the same input array `arr`. Function Signature ```python def compare_sorts(arr): # Your implementation here pass ``` Input & Output Format * **Input**: - An array `arr` of integers to be sorted. * **Output**: - Returns a tuple of two sorted arrays: the first being sorted by Bogo Sort, the second by the chosen efficient sorting algorithm, alongside respective computational times. Constraints * Ensure your code handles arrays of varying sizes efficiently for the chosen algorithm. * For Bogo Sort, you may limit iterations to 10,000 to prevent excessive execution time. Example ```python import time def bogo_sort(arr): import random def is_sorted(arr): return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) while not is_sorted(arr): random.shuffle(arr) return arr def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def compare_sorts(arr): import copy start_time = time.time() bogo_sorted_arr = bogo_sort(copy.deepcopy(arr)) bogo_time = time.time() - start_time start_time = time.time() efficient_sorted_arr = merge_sort(copy.deepcopy(arr)) efficient_time = time.time() - start_time return (bogo_sorted_arr, efficient_sorted_arr, bogo_time, efficient_time) # Example usage arr = [3, 2, 1] print(compare_sorts(arr)) ```","solution":"import random import time import copy def bogo_sort(arr): def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) attempts = 0 while not is_sorted(arr) and attempts < 10000: random.shuffle(arr) attempts += 1 return arr def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr def compare_sorts(arr): start_time = time.time() bogo_sorted_arr = bogo_sort(copy.deepcopy(arr)) bogo_time = time.time() - start_time start_time = time.time() efficient_sorted_arr = merge_sort(copy.deepcopy(arr)) efficient_time = time.time() - start_time return (bogo_sorted_arr, efficient_sorted_arr, bogo_time, efficient_time)"},{"question":"First Occurrence of a Number in a Sorted Array You are given a sorted array of integers in increasing order and a target integer. Your task is to write a function `first_occurrence(array, query)` that finds the first occurrence of the target integer in the array using binary search. Function Signature: ```python def first_occurrence(array: list[int], query: int) -> int: ``` Input: - `array` (list[int]): A sorted list of integers in increasing order. - `query` (int): The target integer to find in the array. Output: - `int`: The index of the first occurrence of the target integer in the array. If the target integer is not present in the array, return `-1`. Constraints: - The array will have at least 1 and at most 10^5 elements. - The integers in the array and the target integer can be between -10^6 and 10^6. # Example: Example 1: ```python first_occurrence([1, 2, 2, 4, 5], 2) ``` Output: ``` 1 ``` Example 2: ```python first_occurrence([1, 3, 5, 7, 9], 4) ``` Output: ``` -1 ``` # Explanation: 1. In the first example, the first occurrence of the number `2` is at index `1`. 2. In the second example, the number `4` is not present in the array, so the function returns `-1`. # Note: - Ensure that the function handles edge cases such as when the element is not present, or if all the elements are the same. Sample Run: ```python print(first_occurrence([1, 1, 2, 2, 2, 3, 4], 2)) # Should return 2 print(first_occurrence([1, 1, 1, 1, 1], 1)) # Should return 0 print(first_occurrence([1, 2, 3, 4], 5)) # Should return -1 ```","solution":"def first_occurrence(array: list[int], query: int) -> int: This function uses binary search to find the first occurrence of the target integer in a sorted array. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid high = mid - 1 elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Coding Challenge: Array Range Filter Context: You have been given a large dataset of numerical values, and you need to process this data by filtering out only those values that fall within a given range. This operation could be crucial for data pre-processing before any deeper analysis or machine learning tasks. Task: Write a function `limit(arr, min_lim=None, max_lim=None)` that filters an array of numbers such that only elements between the provided `min_lim` and `max_lim` are retained. Function Signature: ```python def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input: - `arr`: A list of integers. (1 <= len(arr) <= 10^5) - `min_lim`: An optional integer representing the minimum limit. Default is None, which means the lower bound is unbounded. - `max_lim`: An optional integer representing the maximum limit. Default is None, which means the upper bound is unbounded. Output: - A list of integers that are within the specified range [min_lim, max_lim]. Constraints: - You may assume that all elements in the list are unique. - Try to achieve a linear time complexity for this operation. Examples: ```python assert limit([1,2,3,4,5], None, 3) == [1, 2, 3] assert limit([5,10,15,20,25], 10, 20) == [10, 15, 20] assert limit([1,2,3,4,5], 3, None) == [3, 4, 5] assert limit([1,2,3,4,5], 2, 4) == [2, 3, 4] ``` Notes: - If both `min_lim` and `max_lim` are None, the function should return the original array. - Ensure to handle edge cases such as empty input arrays, or when `min_lim` and `max_lim` are both set to values that exclude all elements.","solution":"from typing import List, Optional def limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters an array such that only elements within the specified range [min_lim, max_lim] are retained. Parameters: arr (List[int]): A list of integers to filter. min_lim (Optional[int]): The minimum limit of the range. Default is None. max_lim (Optional[int]): The maximum limit of the range. Default is None. Returns: List[int]: A list of integers that fall within the specified range. if min_lim is None and max_lim is None: return arr if min_lim is None: return [x for x in arr if x <= max_lim] if max_lim is None: return [x for x in arr if x >= min_lim] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# String Reversal Challenge You have been tasked with implementing a function that reverses a given string. To demonstrate your proficiency with algorithm design and understanding of different approaches, you will implement two versions: one using recursion and one using an iterative approach. Function Specifications: **Recursive:** ```python def reverse_recursive(s: str) -> str: pass ``` **Iterative:** ```python def reverse_iterative(s: str) -> str: pass ``` Input: * A single string `s` with a maximum length of `100000`. Output: * A single string that is the reverse of the input. Constraints: * The input string may include uppercase and lowercase letters, digits, spaces, and special characters. Performance Requirements: * Both functions should execute within acceptable time and space limits for large input strings. Example: ```python assert reverse_recursive(\\"hello\\") == \\"olleh\\" assert reverse_iterative(\\"world\\") == \\"dlrow\\" ``` Task: 1. Implement the function `reverse_recursive(s)` using a recursive approach. 2. Implement the function `reverse_iterative(s)` using an iterative approach.","solution":"def reverse_recursive(s: str) -> str: Returns the reverse of the string s using a recursive approach. if len(s) == 0: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s: str) -> str: Returns the reverse of the string s using an iterative approach. reversed_string = [] for char in s: reversed_string.insert(0, char) return \'\'.join(reversed_string)"},{"question":"You are tasked with implementing a function `reverse_string` that takes a string `s` and returns its reverse. This problem will test your understanding of different approaches to string manipulation, including recursive, iterative, and utilizing built-in Python functionalities. Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Requirements: 1. **Input**: - A single string `s` where `0 <= len(s) <= 10^5`. 2. **Output**: - Return the reversed string. # Constraints: - You must implement the function without using Python\'s built-in `reversed()` or slicing shortcuts (`[::-1]`). # Performance Requirements: - Your solution should handle the input efficiently, aiming for an O(n) time complexity. # Edge Cases to Handle: - Empty strings (`\\"\\"`). - Single character strings. - Strings with all identical characters. # Example: ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"racecar\\") == \\"racecar\\" assert reverse_string(\\"123456\\") == \\"654321\\" ``` # Scenario You are developing a text-based application that requires reversing user input strings efficiently. Please write an implementation of `reverse_string` that reliably handles varying sizes of strings without using built-in shortcuts. *Your solution should emphasize educational value by not relying on Python\'s slicing tricks or the `reversed()` function.*","solution":"def reverse_string(s: str) -> str: Reverses given string s without using slicing shortcuts or built-in reversed function. # Using a list to accumulate the characters in reverse order. reversed_chars = [] # Traverse the string from end to start. for i in range(len(s) - 1, -1, -1): reversed_chars.append(s[i]) # Join the list of characters into a string. return \'\'.join(reversed_chars)"},{"question":"# Two Sum Challenge Context: You are given a list of integers that is sorted in ascending order and a target integer. Your task is to find the indices of the two numbers in the sorted list that add up to the target integer. These indices should be such that the first index is less than the second index and both indices are one-based (i.e., they start from 1). Function Signature: ```python def find_two_sum(numbers: List[int], target: int) -> List[int]: ``` Input: 1. `numbers` (List[int]): A list of integers sorted in ascending order. The length of the list will be in the range [2, 10^4]. 2. `target` (int): An integer representing the target sum. The value will be in the range [-10^5, 10^5]. Output: Return a list containing the indices of the two numbers such that they add up to the target. The indices should comply with the following conditions: - Must be one-based (start from 1). - The first index should be less than the second index. Constraints: - You may assume that each input would have exactly one solution. - You may not use the same element twice. Examples: ```python assert find_two_sum([2, 7, 11, 15], 9) == [1, 2] assert find_two_sum([1, 2, 3, 4, 4, 9], 8) == [3, 4] assert find_two_sum([-1, 0, 3, 6], 5) == [1, 4] ``` Notes: - Focus on writing the most efficient solution in terms of time complexity. - Think about which of the three approaches (`two_sum`, `two_sum1`, `two_sum2`) might be the best optimized for the given constraints. - Validate your implementation with edge cases such as minimum and maximum length arrays or large integers close to the boundary limits.","solution":"from typing import List def find_two_sum(numbers: List[int], target: int) -> List[int]: Finds the indices of two numbers that add up to the target. The input list is assumed to be sorted in ascending order. The function returns 1-based indices. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # If we don\'t find any pair (though problem guarantees there\'s one solution) return []"},{"question":"Context: You have been given an array that may contain zeros, integers, booleans, and other types of elements. The requirement is to move all zero elements to the end of the array while keeping the order of non-zero elements intact. Your task is to achieve this in-place to optimize space complexity. Objective: Write a function `move_zeros_in_place(array)` that takes a list `array` as input and moves all zero elements to the end of the list in-place, preserving the order of the other elements. Input: - `array`: A list of elements of mixed types (length n). Output: - The function modifies the input list in-place and does not return any value. Constraints: - Do not use extra space proportional to the input size (i.e., no auxiliary arrays/lists for storing results). - Ensure the solution works in O(n) time complexity. Example Usage: ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` Notes: - Be mindful of the difference between the integer 0 and boolean `False`. - You can assume the input list will contain at most up to 10^6 elements.","solution":"def move_zeros_in_place(array): Moves all zeros in the array to the end while preserving the order of non-zero elements. This function modifies the list in-place. :param array: List of elements with mixed types non_zero_index = 0 # Pointer to place the next non-zero element for i in range(len(array)): if array[i] != 0 or isinstance(array[i], bool): # Move non-zero (including False) to the next position in array array[non_zero_index] = array[i] non_zero_index += 1 # Fill the rest of the array with zeros for i in range(non_zero_index, len(array)): array[i] = 0"},{"question":"Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Write a function `multiply_two_numbers(left: Node, right: Node) -> Node` that multiplies the two numbers and returns the result as a linked list. Both numbers do not contain any leading zero, except the number 0 itself. Example: ``` Input: (3 -> 4 -> 2) represents 243 and (4 -> 6 -> 5) represents 564 Output: 5 -> 7 -> 2 -> 1 -> 3 represents 137052 ``` Constraints: - The input linked lists representing the numbers will be non-empty, positive integers and follow the structure provided in the code snippets. Function Signature: ```python def multiply_two_numbers(left: Node, right: Node) -> Node: ... ``` Requirements: 1. **Input Format**: - Two linked lists, `left` and `right`, where each node of the linked list contains a single digit. 2. **Output Format**: - A linked list representing the product of two input numbers. 3. **Performance**: - Your implementation should manage input sizes up to 50 digits efficiently. 4. **Additional Constraints**: - You are not allowed to use any direct integer to string or string to integer conversion functions. Testing: You should write test cases to verify the correctness of your implemented function. Use the provided conversion utilities (`convert_to_list` and `convert_to_str`) for testing.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def multiply_two_numbers(left: Node, right: Node) -> Node: def list_to_int(node): num = 0 place = 1 while node: num += node.val * place place *= 10 node = node.next return num def int_to_list(num): if num == 0: return Node(0) head = None current = None while num > 0: digit = num % 10 if head is None: head = Node(digit) current = head else: current.next = Node(digit) current = current.next num //= 10 return head left_num = list_to_int(left) right_num = list_to_int(right) product = left_num * right_num return int_to_list(product)"},{"question":"Given two sequences, `text` and `pattern`, your task is to find all the starting indexes in `text` where `pattern` occurs as a substring. You must implement the Knuth-Morris-Pratt (KMP) algorithm to achieve this. You should return these starting indexes in a list. # Function Definition: ```python from typing import Sequence, List def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]: pass ``` # Input: - `text` (Sequence[str]): The text string in which to search for the pattern. - `pattern` (Sequence[str]): The pattern string to search within the text. # Output: - The function should return a list of integers representing all the starting indexes where the pattern matches in the text. If the pattern is not found, return an empty list. # Constraints: - 1 ≤ len(text) ≤ 10^5 - 1 ≤ len(pattern) ≤ 10^5 - `text` and `pattern` will consist of lowercase English letters. # Example: ```python assert knuth_morris_pratt(\'hello there hero!\', \'he\') == [0, 7, 12] assert knuth_morris_pratt(\'abcdefg\', \'hij\') == [] ``` # Notes: - You do not need to handle a situation where both `text` and `pattern` are empty as both are guaranteed to have at least one character based on constraints. - Ensure the function handles edge cases such as pattern length greater than text length and repeated characters efficiently.","solution":"from typing import Sequence, List def knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: # Helper function to construct the partial match table (LPS - Longest Prefix Suffix Array) def build_lps(pattern): m = len(pattern) lps = [0] * m length = 0 i = 1 while i < m: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) lps = build_lps(pattern) result = [] i = 0 j = 0 while i < n: if text[i] == pattern[j]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and text[i] != pattern[j]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Question: You are required to implement a **self-balancing Binary Search Tree (BST)**, specifically an **AVL Tree**. An AVL Tree is a BST with the additional property of maintaining a balance factor between -1 and 1 for every node, ensuring that the tree remains approximately balanced for optimal operation efficiency. # Tasks: 1. Implement the AVL Tree with the following methods: - `insert(data)`: Inserts a new `data` element into the tree. - `search(data)`: Searches for the presence of `data` in the tree. - `delete(data)`: Deletes an element with the specified `data` from the tree. - `size()`: Returns the total number of nodes in the tree. - `inorder()`: Performs an in-order traversal and returns a list of elements. - `preorder()`: Performs a pre-order traversal and returns a list of elements. - `postorder()`: Performs a post-order traversal and returns a list of elements. # Requirements: * Your AVL Tree should maintain self-balance by performing rotations during insertions and deletions. * You need to ensure the height difference between the left and right subtrees (balance factor) does not exceed 1 for any node. * Follow the AVL Tree properties to maintain balance. * Each method should efficiently perform its task according to AVL tree properties. # Constraints: * Assume all data inputs for `insert` and `delete` are unique integers. # Example: ```python # Initialize the AVL Tree avl_tree = AVLTree() # Insert elements avl_tree.insert(10) avl_tree.insert(20) avl_tree.insert(30) avl_tree.insert(40) avl_tree.insert(50) # Perform searches print(avl_tree.search(20)) # Output: True print(avl_tree.search(25)) # Output: False # Check size print(avl_tree.size()) # Output: 5 # Perform traversals print(avl_tree.inorder()) # Output: [10, 20, 30, 40, 50] print(avl_tree.preorder()) # Output: [30, 20, 10, 40, 50] print(avl_tree.postorder()) # Output: [10, 20, 50, 40, 30] # Delete an element avl_tree.delete(50) print(avl_tree.size()) # Output: 4 ``` # Note: - Ensure your implementation is efficient and adheres to the properties of AVL Trees. - It is recommended to include thorough unit tests to validate the functionality of each method. Good luck!","solution":"class Node: def __init__(self, data): self.data = data self.height = 1 self.left = None self.right = None class AVLTree: def __init__(self): self.root = None def _get_height(self, node): if not node: return 0 return node.height def _update_height(self, node): if node: node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 self._update_height(z) self._update_height(y) return y def _right_rotate(self, y): z = y.left T3 = z.right z.right = y y.left = T3 self._update_height(y) self._update_height(z) return z def insert(self, data): if not self.root: self.root = Node(data) else: self.root = self._insert(self.root, data) def _insert(self, node, data): if not node: return Node(data) elif data < node.data: node.left = self._insert(node.left, data) else: node.right = self._insert(node.right, data) self._update_height(node) return self._balance(node) def _balance(self, node): balance_factor = self._get_balance(node) if balance_factor > 1: if self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance_factor < -1: if self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, data): return self._search(self.root, data) def _search(self, node, data): if not node: return False if data == node.data: return True elif data < node.data: return self._search(node.left, data) else: return self._search(node.right, data) def size(self): return self._size(self.root) def _size(self, node): if not node: return 0 return 1 + self._size(node.left) + self._size(node.right) def inorder(self): result = [] self._inorder(self.root, result) return result def _inorder(self, node, result): if node: self._inorder(node.left, result) result.append(node.data) self._inorder(node.right, result) def preorder(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node: result.append(node.data) self._preorder(node.left, result) self._preorder(node.right, result) def postorder(self): result = [] self._postorder(self.root, result) return result def _postorder(self, node, result): if node: self._postorder(node.left, result) self._postorder(node.right, result) result.append(node.data) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if not node: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.data = temp.data node.right = self._delete(node.right, temp.data) self._update_height(node) return self._balance(node) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"**Problem Description** You are given two implementations of the stack abstract data type (ADT): an array-based stack (`ArrayStack`) and a linked list-based stack (`LinkedListStack`). Both implementations provide the following operations: `push(item)`, `pop()`, `peek()`, and `is_empty()`. Your task is to extend these classes to include a new method called `delete(value)` which removes all instances of the given value from the stack. This method should maintain the LIFO order of the remaining elements in the stack. **Function Signature** ```python class ArrayStack(AbstractStack): def delete(self, value): # Your implementation goes here class LinkedListStack(AbstractStack): def delete(self, value): # Your implementation goes here ``` **Input/Output** * Input: An instance of `ArrayStack` or `LinkedListStack` and a value to be deleted. * Output: The stack with all instances of the specified value removed. **Constraints** 1. The stack can contain integers, strings, or any data type. 2. The value to be deleted may or may not be present in the stack. 3. Modifying the inbuilt data structures or attributes apart from the defined methods is not allowed. **Example** ```python array_stack = ArrayStack() array_stack.push(1) array_stack.push(2) array_stack.push(1) array_stack.push(3) array_stack.delete(1) assert array_stack.pop() == 3 assert array_stack.pop() == 2 assert array_stack.is_empty() linked_list_stack = LinkedListStack() linked_list_stack.push(4) linked_list_stack.push(5) linked_list_stack.push(4) linked_list_stack.push(6) linked_list_stack.delete(4) assert linked_list_stack.pop() == 6 assert linked_list_stack.pop() == 5 assert linked_list_stack.is_empty() ``` **Evaluation Criteria** * Correctness: The implementation correctly removes all instances of the given value from the stack. * Efficiency: The solution should maintain the O(1) time complexity for other stack operations as much as possible. * Edge Cases: The implementation should handle operations on an empty stack and other corner cases gracefully. * Readability: Code should be clean and well-documented.","solution":"class AbstractStack: def push(self, item): raise NotImplementedError def pop(self): raise NotImplementedError def peek(self): raise NotImplementedError def is_empty(self): raise NotImplementedError class ArrayStack(AbstractStack): def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def delete(self, value): temp_stack = [] while not self.is_empty(): temp_item = self.pop() if temp_item != value: temp_stack.append(temp_item) while temp_stack: self.push(temp_stack.pop()) class Node: def __init__(self, value=None): self.value = value self.next = None class LinkedListStack(AbstractStack): def __init__(self): self.head = None def push(self, item): new_node = Node(item) new_node.next = self.head self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") popped_value = self.head.value self.head = self.head.next return popped_value def peek(self): if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None def delete(self, value): temp_stack = [] while not self.is_empty(): temp_item = self.pop() if temp_item != value: temp_stack.append(temp_item) while temp_stack: self.push(temp_stack.pop())"},{"question":"**Ternary Search Algorithm Implementation** # Objective Implement the ternary search algorithm in Python to determine if a given element (key) exists in a sorted array, and if so, return its index. The array is guaranteed to be sorted in ascending order. # Function Signature ```python def ternary_search(arr, left, right, key): Searches for key in arr[left..right] Parameters: - arr (List[int]): A list of integers sorted in ascending order. - left (int): The starting index of the segment to be searched. - right (int): The ending index of the segment to be searched. - key (int): The value to search for. Returns: - int: The index of the key in the array if found, otherwise -1. ``` # Input and Output Formats * **Input**: * `arr`: List of integers sorted in ascending order, e.g., `[1, 2, 3, 4, 5, 6, 7, 8, 9]`. * `left`: Starting index of the search interval, a non-negative integer. * `right`: Ending index of the search interval, a non-negative integer. * `key`: An integer value to search for in the array. * **Output**: * An integer representing the index of the key if it is present in the array. If the key is not present, return -1. # Example ```python # Sample inputs arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] left = 0 right = len(arr) - 1 key = 5 # Expected output result = ternary_search(arr, left, right, key) print(result) # Output: 4 ``` # Constraints 1. The array will have at least one element. 2. The array elements and key are within the range [-10^6, 10^6]. 3. The indices `left` and `right` satisfy (0 leq text{left} leq text{right} < text{len(arr)}). # Notes * Handle edge cases where the array might have only one element, or the key is not found. * Ensure that the implementation is efficient and aligns with the expected time complexity of (O(log_3 n)).","solution":"def ternary_search(arr, left, right, key): Searches for key in arr[left..right] Parameters: - arr (List[int]): A list of integers sorted in ascending order. - left (int): The starting index of the segment to be searched. - right (int): The ending index of the segment to be searched. - key (int): The value to search for. Returns: - int: The index of the key in the array if found, otherwise -1. while left <= right: third_part = (right - left) // 3 mid1 = left + third_part mid2 = right - third_part if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Linked List: Rotate Right Problem Statement: Given a singly linked list, rotate the list to the right by k places, where k is a non-negative integer. A rotation involves moving elements from the end of the list to the front of the list in sequence. Detailed Explanation: - Given a linked list: 1 -> 2 -> 3 -> 4 -> 5 -> NULL - For k = 2, the resulting linked list should be: 4 -> 5 -> 1 -> 2 -> 3 -> NULL The number of rotations is determined by k, such that if k is larger than the length of the list, it wraps around using the modulo operation (k = k % length). Task: Implement the function `rotate_right` that: - **Input**: - `head`: Head of the singly linked list. - `k`: An integer number of positions to rotate. - **Output**: - Head of the rotated linked list. Constraints: - The number of nodes in the list is in the range `[0, 500]`. - `-100 <= Node.val <= 100` - `0 <= k <= 2 * 10^9` # Function Signature: ```python # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` Example: ```python # Example 1: # Input: head = [1, 2, 3, 4, 5], k = 2 # Output: [4, 5, 1, 2, 3] # Example 2: # Input: head = [0, 1, 2], k = 4 # Output: [2, 0, 1] ``` Notes: - Ensure your solution handles edge cases, such as when the list is empty, or when k is larger than the length of the list. - Consider the efficiency when k is extremely large. - The function should return the new head of the rotated linked list.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Compute the length of the list length = 1 current = head while current.next: length += 1 current = current.next # Link the tail to the head to create a circular list current.next = head # Find the point to break the circle k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"# Question You are given a linked list implementation where each node contains an integer value and a reference to the next node. The linked list may or may not contain a cycle. Your task is to write a function to detect if a cycle is present in the linked list and, if so, return the value of the first node of the cycle. If no cycle is present, the function should return `None`. Implement the function: ```python def first_cyclic_node(head: Node) -> Node: pass ``` # Input - `head`: The head node of the linked list (type: Node | None; `head` is either a Node object representing the starting node of the linked list or None if the list is empty). # Output - The function should return the node (type: Node) representing the first node in the cycle or `None` if no cycle is present. # Constraints - The given linked list can be empty (head is None) or can contain up to 10^4 elements. - Nodes can contain any integer value. - No modifications to the input list are allowed. # Example ```python class Node: def __init__(self, x): self.value = x self.next = None # Example 1: # List: 3 -> 2 -> 0 -> -4 # ^ | # |_________ head1 = Node(3) head1.next = Node(2) head1.next.next = Node(0) head1.next.next.next = Node(-4) head1.next.next.next.next = head1.next # Creating the cycle here assert first_cyclic_node(head1).value == 2 # Example 2: # List: 1 -> 2 # ^ | # |----| head2 = Node(1) head2.next = Node(2) head2.next.next = head2 # Creating the cycle here assert first_cyclic_node(head2).value == 1 # Example 3: # List: 1 head3 = Node(1) assert first_cyclic_node(head3) is None ``` # Note Your solution should use Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare) to detect the cycle and find its starting node efficiently in O(n) time and O(1) space.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def first_cyclic_node(head: Node) -> Node: if not head or not head.next: return None slow, fast = head, head # Detect cycle using Floyd\'s Cycle-Finding Algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Exchange Sort Analysis and Implementation Enhancement **Scenario**: You have been hired as a software engineer for a startup. Your first task is to analyze a basic sorting algorithm and then enhance its performance as much as possible. The startup\'s product includes sorting customer transactions, so sorting performance is a key factor. **Requirements**: 1. Implement the basic Exchange Sort algorithm as analyzed. 2. Enhance the implementation to reduce unnecessary operations and improve its performance. 3. Make sure your implementation handles all common edge cases effectively. **Function Signature**: ```python def enhanced_exchange_sort(arr): Sorts a list using an optimized version of Exchange Sort Parameters: arr (list): List of comparable elements to be sorted in ascending order Returns: list: Sorted list in ascending order pass ``` **Input/Output**: * Input: List of integers `arr` (1 ≤ len(arr) ≤ 10^3, -10^3 ≤ arr[i] ≤ 10^3) * Output: Sorted list `arr` in ascending order **Constraints**: - The algorithm should be optimized but still retain a similar conceptual approach to Exchange Sort. - You cannot use other built-in sort functions or libraries (e.g., `sorted()`). **Performance Requirement**: - While the worst-case time complexity remains O(n^2), try to minimize the number of comparisons and swaps. **Edge Cases to Test**: - Empty list. - Single element list. - List already sorted. - List sorted in reverse order. - List with multiple duplicate elements. **Example**: ```python assert enhanced_exchange_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert enhanced_exchange_sort([]) == [] assert enhanced_exchange_sort([5]) == [5] assert enhanced_exchange_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert enhanced_exchange_sort([3, 3, 3, 1, 1, 1, 2, 2, 2]) == [1, 1, 1, 2, 2, 2, 3, 3, 3] ``` Provide a detailed implementation in the function `enhanced_exchange_sort` that ensures optimized performance while maintaining the core concepts of the original Exchange Sort algorithm.","solution":"def enhanced_exchange_sort(arr): Sorts a list using an optimized version of Exchange Sort Parameters: arr (list): List of comparable elements to be sorted in ascending order Returns: list: Sorted list in ascending order n = len(arr) if n < 2: return arr for i in range(n - 1): swapped = False for j in range(i + 1, n): if arr[i] > arr[j]: # Swap elements arr[i], arr[j] = arr[j], arr[i] swapped = True if not swapped: # No swaps made means the list is already sorted break return arr"},{"question":"**Problem Statement: Modified Counting Sort** Counting Sort is an efficient algorithm for sorting integers when the range of input is relatively small. However, the algorithm can struggle with negative numbers and large variances in the input range. You are tasked to implement a modified version of the counting sort algorithm that can handle negative numbers and efficiently utilizes memory. # Function Signature ```python def modified_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where `-10^6 <= arr[i] <= 10^6` (1 ≤ len(arr) ≤ 10^6). # Output - A list of integers sorted in non-decreasing order matching the sorted order of the input list `arr`. # Constraints 1. The function should handle negative numbers efficiently. 2. The memory usage should remain as limited as possible, even for large input sizes. # Performance Requirements - The sorting process should ideally have a linear time complexity O(n). # Example ```python assert modified_counting_sort([3, -1, 2, 3, -2, 1, 0]) == [-2, -1, 0, 1, 2, 3, 3] assert modified_counting_sort([0, 0, 0, 0]) == [0, 0, 0, 0] assert modified_counting_sort([-3, -5, -10, 1]) == [-10, -5, -3, 1] ``` # Key Points - Consider updating your approach to handle the fixed range constraint efficiently. - Ensure the function works correctly for edge cases like empty arrays or arrays with all identical elements.","solution":"def modified_counting_sort(arr): Modified Counting Sort that handles negative numbers. if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create a counting array of the given range from min_val to max_val range_size = max_val - min_val + 1 count = [0] * range_size # Fill the counting array for num in arr: count[num - min_val] += 1 # Reconstruct the sorted array sorted_arr = [] for i in range(range_size): sorted_arr.extend([min_val + i] * count[i]) return sorted_arr"},{"question":"You are provided with an alphanumeric string `key` and an integer `k`. Your task is to reformat the string such that every `k` characters, counting from the end, are separated by a dash (`\'-\'`). Dashes already present in the input string should be ignored. The formatted string should preserve the order of characters except for the added dashes. # Function Signature: ```python def license_number(key: str, k: int) -> str: ``` # Input: * `key` (string): A string of length `n` (0 ≤ n ≤ 10^4), consisting of alphanumeric characters and dashes. * `k` (integer): A positive integer (1 ≤ k ≤ 10^4) # Output: * Returns a string, which is the newly formatted license number. # Constraints: * The string `key` can contain both uppercase and lowercase letters and digits. * The integer `k` is guaranteed to be at least 1 and at most 10^4. # Example: ```python print(license_number(\\"2-4A0r7-4k\\", 4)) # Output: \\"24A0-R74K\\" print(license_number(\\"2-4A0r7-4k\\", 3)) # Output: \\"24-A0R-74K\\" print(license_number(\\"--a-a-a-a--\\", 2)) # Output: \\"AA-AA\\" ``` # Explanation: - In the first example, after removing dashes, the alphanumeric characters are \\"24A0r74k\\". Grouped from the end in segments of 4, it becomes \\"24A0-R74K\\". - In the second example, the same string grouped in segments of 3 becomes \\"24-A0R-74K\\". - The third example removes all dashes, leaving \\"aaaa\\", which groups as \\"AA-AA\\" for `k=2`. **Note**: - The function should be robust to handle edge cases like empty strings, strings without dashes, or values of `k` that are larger than the length of the alphanumeric characters in the input.","solution":"def license_number(key: str, k: int) -> str: Reformats the input alphanumeric string `key` such that every `k` characters, counting from the end, are separated by a dash (\'-\'). Dashes already present in the input string are ignored. # Remove existing dashes and convert all letters to uppercase key = key.replace(\'-\', \'\').upper() # Determine the length of the new formatted string n = len(key) # Initialize the parts list parts = [] # Iterate over the string from the end and collect parts of size `k` for i in range(n, 0, -k): parts.append(key[max(i-k, 0):i]) # Join the parts with dashes return \'-\'.join(parts[::-1])"},{"question":"You are tasked to implement a function that runs a nearest neighbor search algorithm. This function takes a high-dimensional query point and a training set, then returns the label of the nearest neighbor. The training set will be provided as a dictionary where the keys are high-dimensional points (tuples) and the values are their associated labels. # Function Signature ```python def find_nearest_neighbor(query_point: tuple, training_set: dict) -> any: pass ``` # Input * `query_point`: A tuple of integers or floats representing the high-dimensional query point. * `training_set`: A dictionary where the keys are tuples of integers or floats (each representing a high-dimensional point) and the values are any types representing labels. # Output * The label of the nearest neighbor point from the training set. # Constraints * The `query_point` and the keys of `training_set` must have the same dimensions. * There will be at least one point in the `training_set`. # Performance Requirements * The solution must work efficiently, ideally within O(m*n) time complexity where m is the number of points in the training set and n is the dimension of the point. # Example ```python query_point = (1, 2) training_set = { (2, 3): \'A\', (5, 6): \'B\', (1, 4): \'C\' } print(find_nearest_neighbor(query_point, training_set)) # Output should be \'A\' ``` # Notes * You can use the provided `distance` function to calculate the Euclidean distance. * Consider edge cases such as multiple points being equidistant from the query point.","solution":"import math def euclidean_distance(point1, point2): Calculate the Euclidean distance between two high-dimensional points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def find_nearest_neighbor(query_point, training_set): Find the nearest neighbor for the given query point from the training set. Params: query_point: A tuple of integers or floats representing the high-dimensional query point. training_set: A dictionary where the keys are tuples of integers or floats (each representing a high-dimensional point) and the values are any types representing labels. Returns: The label of the nearest neighbor point from the training set. nearest_neighbor = None min_distance = float(\'inf\') for point in training_set: dist = euclidean_distance(query_point, point) if dist < min_distance: min_distance = dist nearest_neighbor = training_set[point] return nearest_neighbor"},{"question":"# Deep Copy of a Linked List with Random Pointers You are given a linked list where each node contains an additional `random` pointer that could point to any node in the list or be null. Your task is to write a function that returns a deep copy of this linked list. Function Signature ```python def copy_random_list(head: Optional[RandomListNode]) -> Optional[RandomListNode]: pass ``` Input and Output Formats * **Input**: * `head` (Optional[RandomListNode]): The head of the complex linked list. If the list is empty, head will be `None`. * **Output**: * Return the head of the deeply copied linked list. If the input list is empty, return `None`. Constraints * The number of nodes in the list is in the range `[0, 1000]`. * Each node’s `random` pointer might point to any node, including itself or be null. Example 1. **Input**: ```plaintext head = Node { label: 1, next: Node { label: 2, next: None, random: Node { label: 1, ... } }, random: Node { label: 2, ... } } ``` **Output**: ```plaintext copied_head = Node { label: 1, next: Node { label: 2, next: None, random: Node { label: 1, ...} }, random: Node { label: 2, ...} } ``` Scenario Imagine you are developing a tool for cloning complex data structures. A user inputs a linked list where each node has an additional random pointer to any other node or null. You need to ensure that a completely independent clone of this structure is made, preserving the relationships. Your task is to implement the `copy_random_list` function following these requirements.","solution":"class RandomListNode: def __init__(self, x: int, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = x self.next = next self.random = random def copy_random_list(head: \'RandomListNode\') -> \'RandomListNode\': if not head: return None # Step 1: Create new nodes and interweave them with the original nodes. current = head while current: new_node = RandomListNode(current.label) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers to the new nodes. current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the new nodes to form the deep copy. new_head = head.next current_old = head current_new = new_head while current_old: current_old.next = current_old.next.next if current_new.next: current_new.next = current_new.next.next current_old = current_old.next current_new = current_new.next return new_head"},{"question":"You are given a singly linked list where each node contains a string value. Write a Python function to remove all duplicate values from the linked list. You must implement two versions of the function: 1. `remove_dups` which removes duplicates using additional space (hash set). 2. `remove_dups_in_place` which removes duplicates without using any additional space for data structure. # Function Signature ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: pass def remove_dups_in_place(head: Node) -> None: pass ``` # Input The function `remove_dups` and `remove_dups_in_place` both take a single argument: * `head` - The head node of a singly linked list where each node contains a string value. # Output Both functions should not return anything. They modify the linked list in place to remove duplicates. # Example ```python # Constructing the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Removing duplicates using both methods remove_dups(a1) # The linked list should now be A -> B -> C -> D -> F -> G remove_dups_in_place(a1) # The linked list should remain A -> B -> C -> D -> F -> G ``` # Constraints * The number of nodes in the linked list is in the range `[0, 10^4]`. * Each node\'s string value is in the range of length `[1, 100]` and consists of uppercase alphabets. # Performance Requirements * The `remove_dups` function should aim for O(N) time complexity. * The `remove_dups_in_place` function should operate in O(1) additional space while striving to be as efficient as possible in time complexity. # Additional Information - Ensure your code handles edge cases such as empty lists and lists with no duplicates. - Maintain the order of elements as they first appear in the list.","solution":"class Node(): def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if not head: return seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next def remove_dups_in_place(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Topological Sorting with Dependency Count You are given a directed graph representing a set of tasks and their dependencies. Implement a function `topological_sort_with_dependencies(graph)`, which returns a list of tasks in a valid topological order, while also providing the number of direct dependencies each task had at the start. The input `graph` is represented as an adjacency list, with tasks being the keys and lists of subsequent tasks being the values: ```python graph = { \'task1\': [\'task2\', \'task3\'], \'task2\': [\'task4\'], \'task3\': [\'task4\', \'task5\'], \'task4\': [\'task6\'], \'task5\': [], \'task6\': [] } ``` The output should be a list of tuples, where each tuple contains a task and the count of its original dependencies: ```python output = [(\'task1\', 0), (\'task2\', 1), (\'task3\', 1), (\'task4\', 2), (\'task5\', 1), (\'task6\', 2)] ``` Constraints: - The graph is a Directed Acyclic Graph (DAG). - Each task name is a string. - No task will appear more than once as a key in the graph. - Duplicate or invalid tasks should not appear in the result. - The graph can be empty. Additional Information: - Ensure your implementation detects and reports cycles by raising a `ValueError` with the message `\\"cycle detected\\"`. - Aim for a time complexity of O(V + E) and a space complexity of O(V). Function Signature: ```python def topological_sort_with_dependencies(graph: dict) -> list: pass ``` Complete the function considering the above constraints and requirements.","solution":"from collections import deque, defaultdict def topological_sort_with_dependencies(graph): Returns a list of tasks in a valid topological order along with the number of direct dependencies each task had at the start. # Dictionary to store the count of incoming edges for each node in_degree = defaultdict(int) # Dictionary to store the original count of direct dependencies for each task original_dependencies = defaultdict(int) # Initialize in_degree and original_dependencies for node in graph: if node not in in_degree: in_degree[node] = 0 for dependent in graph[node]: in_degree[dependent] += 1 original_dependencies[dependent] = original_dependencies.get(dependent, 0) + 1 # Initialize the queue with all nodes having in-degree of 0 zero_in_degree_queue = deque([node for node in graph if in_degree[node] == 0]) # List to store the sorted elements topological_order = [] while zero_in_degree_queue: current_node = zero_in_degree_queue.popleft() topological_order.append((current_node, original_dependencies.get(current_node, 0))) for neighbor in graph[current_node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological_order contains exactly the number of nodes in the graph, we have processed # all the nodes properly if len(topological_order) == len(graph): return topological_order else: raise ValueError(\\"cycle detected\\")"},{"question":"# AVL Tree Coding Assessment As a part of our assessment of your ability to work with advanced data structures, you are required to implement an AVL Tree with specific functionalities. The AVL Tree is a self-balancing binary search tree where the height difference between left and right subtrees (balance factor) of any node is at most 1. Function Definitions: 1. **Insert Function**: Implement the `insert` function to add a key to the AVL Tree while maintaining the balance of the tree. 2. **In-order Traversal Function**: Implement the `in_order_traverse` function that returns a list of keys in the tree in ascending order. 3. **Balance Checking Function**: Implement a function `is_balanced` to verify that the AVL Tree property (balance factor between -1 and 1) is maintained throughout the tree. ```python class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): Insert new key into the AVL tree. Args: key (int): The key to insert. Returns: None # Your Implementation Here def in_order_traverse(self): Perform in-order traversal of the tree. Returns: List[int]: A list of keys in ascending order. # Your Implementation Here def is_balanced(self): Check if the AVL Tree is balanced. Returns: bool: True if balanced, False otherwise. # Your Implementation Here # Example Usage # Initialize the AVL Tree avl = AvlTree() # Insert elements into the AVL Tree avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(15) # Perform in-order traversal print(avl.in_order_traverse()) # Should output a sorted list of keys # Check if the tree is balanced print(avl.is_balanced()) # Should output True if the tree is balanced ``` Constraints: - Keys are distinct integers. - The tree should maintain AVL Tree properties after every insertion. - You must handle both left and right rotations to ensure the tree remains balanced. Your implementation will be evaluated on correctness, efficiency, and adherence to AVL Tree properties. Ensure your code handles various edge cases, such as inserting into an empty tree or maintaining balance after multiple insertions.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): Insert new key into the AVL tree. Args: key (int): The key to insert. Returns: None self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): Perform in-order traversal of the tree. Returns: List[int]: A list of keys in ascending order. result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result) def is_balanced(self): Check if the AVL Tree is balanced. Returns: bool: True if balanced, False otherwise. return self._is_balanced(self.root) def _is_balanced(self, node): if not node: return True left_height = self._get_height(node.left) right_height = self._get_height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"You are given an array of integers representing the size of a dataset, and you want to sort this data to analyze it more effectively. Your task is to implement the Selection Sort algorithm that not only sorts the array but also provides a step-by-step simulation of the sorting process. # Function Signature ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of integers `List[int]` that needs to be sorted. * `simulation`: A boolean `bool` optional parameter (default is `False`). When set to `True`, the function should print the array after each iteration of the outer loop. # Output * Returns the sorted list of integers. # Constraints * `0 <= len(arr) <= 10^3` * `-10^3 <= arr[i] <= 10^3` # Performance Requirements * The solution should have a time complexity of O(n^2) due to the nature of the selection sort algorithm. * The function should sort the array in place with a space complexity of O(1). # Example 1. **Input**: `arr = [64, 25, 12, 22, 11], simulation = True` **Output**: `iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64]` 2. **Input**: `arr = [], simulation = False` **Output**: `[]` 3. **Input**: `arr = [5], simulation = False` **Output**: `[5]` # Additional Notes * Ensure your implementation handles edge cases such as an empty array or a single-element array. * Even though selection sort is not optimal for large datasets, ensure the function can process the upper limit efficiently within its constraints.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element arr[i], arr[min_index] = arr[min_index], arr[i] # Print the array after each iteration if simulation is True if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# Scenario: You have been hired to optimize the storage of a list of mixed types where zeros often represent unused or default slots. Your task is to write a function that rearranges the list so that all zeros come at the end while preserving the order of the other elements. # Problem Statement: Write a function `move_zeros_in_place(array)` that takes an array and moves all zeros to the end of the array, preserving the order of the other elements. Your solution should optimize space usage by modifying the input array in place. # Input: - An array `array` of length `n`, where `1 <= n <= 10^6`. The array can contain integers, booleans, strings, etc. # Output: - The input array rearranged in place with all zeros moved to the end. # Constraints: - Do not use extra space proportional to the size of the array. - `False` should not be treated as `0`. # Example: ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` # Function Signature: ```python def move_zeros_in_place(array: list) -> None: pass ``` # Additional Notes: - Ensure that the function modifies the input array in place and does not return anything. - Think about edge cases such as arrays without zeros, with some `False` values, or with only zeros.","solution":"def move_zeros_in_place(array): Rearranges the array in place so that all zeros are moved to the end, preserving the order of the other elements. non_zero_index = 0 for i in range(len(array)): if array[i] != 0 or type(array[i]) is bool: array[non_zero_index] = array[i] non_zero_index += 1 for i in range(non_zero_index, len(array)): array[i] = 0"},{"question":"Context You are given a large array of floating-point numbers, where the values range between 0 and 1. The goal is to efficiently sort this array. Implement the optimized Bucket Sort algorithm with a suitable number of buckets to achieve this goal. Task Write a function `optimized_bucket_sort(arr: List[float]) -> List[float]` to sort an array of floating-point numbers using the bucket sort algorithm. Function Signature ```python def optimized_bucket_sort(arr: List[float]) -> List[float]: pass ``` Input - `arr`: List of `n` floating-point numbers (0 <= `arr[i]` < 1). Output - Returns a list of the elements in `arr` sorted in ascending order. Constraints - The input list can be of any size from `1` to `10^6` - All elements in the array are unique. Performance Requirements - Optimize the algorithm to handle up to 10^6 elements efficiently. Example ```python # Example 1 arr = [0.45, 0.12, 0.24, 0.83, 0.39] assert optimized_bucket_sort(arr) == [0.12, 0.24, 0.39, 0.45, 0.83] # Example 2 arr = [0.99, 0.05, 0.64, 0.78, 0.13] assert optimized_bucket_sort(arr) == [0.05, 0.13, 0.64, 0.78, 0.99] ``` Constraints to Consider - Make sure to handle cases where the input list is empty or contains one element gracefully. - Consider the uniform distribution properties to determine optimal bucket count and size.","solution":"from typing import List def optimized_bucket_sort(arr: List[float]) -> List[float]: Sorts an array of floating-point numbers using the bucket sort algorithm. n = len(arr) if n <= 1: return arr # Create n empty buckets buckets = [[] for _ in range(n)] # Place each element in a bucket for value in arr: index = int(value * n) buckets[index].append(value) # Sort individual buckets and concatenate the result sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"Given a sorted list of integers in increasing order, an algorithm \'Interpolation Search\' is to be implemented to find the position of a given target value within the list efficiently. The function should be designed to optimize the search process, especially for uniformly distributed arrays. Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. ``` Input: - A sorted list of integers `array` (where `1 <= len(array) <= 10^5`). - An integer `search_key` (where `-10^9 <= search_key <= 10^9`). Output: - The function should return the index of `search_key` in `array` if found; otherwise, it should return `-1`. Constraints: - The array is sorted in increasing order. - You need to handle large datasets efficiently. - The list can contain negative integers. - Implement error handling for edge cases. Performance Requirements: - Average case time complexity: O(log(log n)). - Worst case time complexity: O(n). **Examples**: ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` # Scenario: Imagine you are managing a database where records are indexed by uniformly distributed numerical values. To quickly locate a specific record, you decide to implement the Interpolation Search algorithm. Your task is to write this algorithm in Python and ensure it handles various edge cases and performance considerations.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: :param array: The array to be searched. :param search_key: The key to be searched in the array. :returns: Index of search_key in array if found, else -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Estimate the position of the search_key position = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Check if we found the search_key if array[position] == search_key: return position # If search_key is larger, search in the upper part if array[position] < search_key: low = position + 1 # If search_key is smaller, search in the lower part else: high = position - 1 return -1"},{"question":"# Scenario You are tasked with cloning a large undirected graph used in a networking software to mimic routing configurations without affecting the original setup. Since the graph can contain cycles and self-loops, the algorithm must correctly handle such scenarios. # Problem Statement You need to implement a function that clones an undirected graph. The function should handle possible cyclic structures and self-loops within the graph. You are to provide an implementation using a recursive depth-first search algorithm. # Function Signature ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # Implementation here ``` # Expected Input and Output * **Input**: A single `UndirectedGraphNode` which serves as an entry point to an undirected graph. - Each node has a `label` (unique integer) and `neighbors` (list of adjacent nodes). * **Output**: The entry node of the cloned graph which is a deep copy of the original graph. # Constraints 1. The provided node labels will be unique integers. 2. Consider all the edge cases mentioned (empty graph, cycles, self-loops). 3. Performance requirements: O(N + E) time complexity and O(N) space complexity. # Example ```python # For the graph visualization provided in the code snippet: # Input: Node `0`, representing the example graph. # Output: A new node that signifies the entry point of the cloned graph # which has identical structure and connections. # Specifically, given the graph serialization {0,1,2#1,2#2,2}, # Cloning must maintain connections in resulting graph visualization: # 1 # / # / # 0 --- 2 # / # _/ ``` # Required Development 1. Implement the `clone_graph` function using a recursive depth-first search (DFS) approach. 2. Ensure to handle all edge cases appropriately. 3. Write helper functions if necessary to support the main function logic.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if node is None: return None old_to_new = {} def clone(node): if node in old_to_new: return old_to_new[node] copy = UndirectedGraphNode(node.label) old_to_new[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor)) return copy return clone(node)"},{"question":"# Coding Challenge: Cycle Sort for a Custom Object Array Scenario: You are developing a warehouse inventory system where each item is represented by a custom object with attributes `id` (integer), `name` (string), and `quantity` (integer). The warehouse needs to sort items based on the `quantity` using Cycle Sort to minimize write operations due to constraints in the system\'s storage devices. Task: Implement a function `cycle_sort_objects(items)` that sorts an array of item objects based on the `quantity` attribute. You must use the Cycle Sort algorithm provided in the analysis. Input: - An array of objects, where each object has the following structure: ```python class Item: def __init__(self, id, name, quantity): self.id = id self.name = name self.quantity = quantity ``` ```python items = [ Item(1, \'item A\', 15), Item(2, \'item B\', 20), Item(3, \'item C\', 10), Item(4, \'item D\', 30), Item(5, \'item E\', 25) ] ``` Output: - Return the sorted list of items based on the `quantity` attribute. Constraints: - The list can have up to 10^3 items. - Each item object has valid integer `quantity` values. - The quantity values are non-negative integers. Example: ```python items = [ Item(1, \'item A\', 15), Item(2, \'item B\', 20), Item(3, \'item C\', 10), Item(4, \'item D\', 30), Item(5, \'item E\', 25) ] # After sorting by quantity sorted_items = cycle_sort_objects(items) # sorted_items should now be sorted based on the quantity attribute. ``` Hints: - You need to adapt the existing Cycle Sort algorithm to work with the `quantity` attribute of the item objects. - Pay attention to handling duplicate quantity values.","solution":"class Item: def __init__(self, id, name, quantity): self.id = id self.name = name self.quantity = quantity def __repr__(self): return f\\"Item(id={self.id}, name={self.name}, quantity={self.quantity})\\" def cycle_sort_objects(items): writes = 0 # Traverse the array to find cycles to rotate. for cycleStart in range(0, len(items) - 1): item = items[cycleStart] pos = cycleStart # Count the number of items that are less than the item. for i in range(cycleStart + 1, len(items)): if items[i].quantity < item.quantity: pos += 1 # If the item is already in the correct position if pos == cycleStart: continue # Skip duplicates while item.quantity == items[pos].quantity: pos += 1 # Put item to the right position items[pos], item = item, items[pos] writes += 1 # Rotate the rest of the cycle. while pos != cycleStart: pos = cycleStart # Find the position where we put the element for i in range(cycleStart + 1, len(items)): if items[i].quantity < item.quantity: pos += 1 # Skip duplicates while item.quantity == items[pos].quantity: pos += 1 # Put the item to the right position items[pos], item = item, items[pos] writes += 1 return items # Example usage: items = [ Item(1, \'item A\', 15), Item(2, \'item B\', 20), Item(3, \'item C\', 10), Item(4, \'item D\', 30), Item(5, \'item E\', 25) ] sorted_items = cycle_sort_objects(items) print(sorted_items)"},{"question":"Problem Statement You are provided with a probabilistic algorithm, the Rabin-Miller Primality Test, which helps determine if a number is probably prime. Your task is to implement a function that leverages this algorithm to generate prime numbers of a specified bit length. # Function Signature ```python def generate_prime(bit_length: int, k: int = 40) -> int: Generates a prime number of the given bit length. Parameters: bit_length (int): The bit length of the prime number to be generated. k (int): The number of iterations for the Rabin-Miller primality test to confirm primality. Returns: int: A prime number of the specified bit length. ``` # Input - `bit_length`: An integer, 1 <= bit_length <= 1024, representing the bit length of the prime number. - `k`: An integer, 1 <= k <= 100, number of iterations for the primality test (default: 40). # Output - Returns an integer which is a prime number of the specified bit length. # Constraints - The function should generate a prime number randomly meeting the bit length requirement. - Ensure the generated number passes the Rabin-Miller test with at least the accuracy provided by k iterations. - Use the provided Rabin-Miller algorithm for checking the primality. # Example Usage ```python prime = generate_prime(16) print(prime) # Output could be a prime number like 32771, 65537, etc. ``` # Implementation Hints - Use randomness to generate candidate primes. - Ensure the generated number has the correct bit length (e.g., leading bit is set to 1). - Iterate until a prime candidate passes the Rabin-Miller test.","solution":"import random def is_probably_prime(n, k): Rabin-Miller primality test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n - 1) as 2^r * d r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def check_composite(a, d, n, r): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if check_composite(a, d, n, r): return False return True def generate_prime(bit_length, k=40): Generates a prime number of the given bit length. assert 1 <= bit_length <= 1024, \\"bit_length must be between 1 and 1024\\" assert 1 <= k <= 100, \\"k must be between 1 and 100\\" while True: # Generate a random number of the specified bit length candidate = random.getrandbits(bit_length) # Ensure the candidate is odd and has the correct bit length candidate |= (1 << (bit_length - 1)) | 1 if is_probably_prime(candidate, k): return candidate"},{"question":"You are given a non-negative number represented as a list of digits, where the most significant digit is at the head of the list. Write a function `plus_one(digits)` that increments the number by one. The digits are ordered in big-endian format, meaning the digit at the head of the list is the most significant. The function should return the resulting list of digits after the increment. **Input**: - A list of non-negative integers `digits` where each integer ranges from 0 to 9. The input list can be empty, representing the number `0`. **Output**: - A list of non-negative integers representing the incremented number in the same big-endian format. **Examples**: 1. `Input: [1, 2, 3]` `Output: [1, 2, 4]` 2. `Input: [9, 9, 9]` `Output: [1, 0, 0, 0]` 3. `Input: []` `Output: [1]` **Constraints**: - You must handle carry correctly throughout the digit list. - The solution should aim for an optimal time complexity of O(n) and a space complexity of O(1) (modifying the list in place if possible). **Scenario**: Imagine you are working on a digital clock application where you need to continuously increment the time by one second. The time is represented as an array of digits. Your task is to accurately and efficiently implement this incrementation to ensure the correct time is displayed. **Edge Cases**: - Handling carry-over when the digits are all nines. - Handling an empty list representing zero. **Function Signature**: ```python def plus_one(digits: List[int]) -> List[int]: pass ``` Complete this function to fulfill the requirements stated above.","solution":"def plus_one(digits): Increment the number represented by the list of digits by one. if not digits: return [1] carry = 1 for i in range(len(digits) - 1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit carry = 0 break if carry == 1: digits.insert(0, 1) return digits"},{"question":"You are given an unweighted, directed graph represented as an adjacency list. Your task is to implement three functions to find paths between two given nodes: 1. `find_path(graph, start, end)`: This function returns one path (doesn\'t matter which one) between the `start` and `end` nodes if such a path exists, otherwise returns `None`. 2. `find_all_paths(graph, start, end)`: This function returns a list of all possible paths between the `start` and `end` nodes. Each path should be represented as a list of nodes. If no paths exist, return an empty list. 3. `find_shortest_path(graph, start, end)`: This function returns the shortest path between the `start` and `end` nodes if such a path exists, otherwise returns `None`. # Input: - `graph`: A dictionary where the keys are node identifiers and the values are lists of neighboring node identifiers. - `start`: The node identifier where the path starts. - `end`: The node identifier where the path ends. # Output: - For `find_path`, return a list of nodes representing one path or `None` if no path exists. - For `find_all_paths`, return a list of lists where each nested list represents a path. - For `find_shortest_path`, return a list of nodes representing the shortest path or `None` if no path exists. # Constraints: - The graph may contain cycles. - Assume node identifiers are unique and represented as strings. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } # Expected outputs print(find_path(graph, \'A\', \'D\')) # Output: [\'A\', \'B\', \'C\', \'D\'] or any other valid path print(find_all_paths(graph, \'A\', \'D\')) # Output: [[\'A\', \'B\', \'C\', \'D\'], [\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_path(graph, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] ``` # Notes: - Clearly handle cases where the start or end node does not exist in the graph. - Consider performance implications due to recursion and depth of traversal to ensure solutions are optimal for reasonable graph sizes.","solution":"def find_path(graph, start, end, path=[]): Return one path from start to end. path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: new_path = find_path(graph, node, end, path) if new_path: return new_path return None def find_all_paths(graph, start, end, path=[]): Return all paths from start to end. path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: new_paths = find_all_paths(graph, node, end, path) for new_path in new_paths: paths.append(new_path) return paths def find_shortest_path(graph, start, end): Return the shortest path from start to end. from collections import deque queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next_node in graph.get(vertex, []): if next_node in path: continue if next_node == end: return path + [next_node] else: queue.append((next_node, path + [next_node])) return None"},{"question":"# Question **Scenario**: You are working on implementing a fast algorithm to check for prime numbers, essential for cryptographic systems. Given the requirements for efficiency and high probability of correctness, you\'ve decided to use the Rabin-Miller Primality Test. # Task Write a function `rabin_miller_prime(n: int, k: int) -> bool` which uses the Rabin-Miller Primality Test to determine if `n` is a prime number. # Function Signature ```python def rabin_miller_prime(n: int, k: int) -> bool: ``` # Input * `n` (int): The number to be tested for primality (1 <= n <= 10^18). * `k` (int): The number of accuracy iterations (1 <= k <= 100). # Output * Returns `True` if the number `n` is probably prime (with a 4^-k chance of being wrong). * Returns `False` if the number `n` is guaranteed to be composite. # Constraints * Handle small values of `n` (< 5) appropriately. * Ensure that the function runs efficiently for large values of `n` up to 10^18. # Example ```python assert rabin_miller_prime(5, 20) == True # 5 is a prime number assert rabin_miller_prime(15, 20) == False # 15 is not a prime number assert rabin_miller_prime(1, 20) == False # 1 is not a prime number assert rabin_miller_prime(2, 20) == True # 2 is a prime number ``` # Notes * Assume the provided `pow` function in your language performs efficient modular exponentiation. * Carefully consider edge cases such as very small numbers and ensure correct outputs for them.","solution":"import random def rabin_miller_prime(n: int, k: int) -> bool: Uses the Rabin-Miller Primality Test to determine if n is a prime number. :param n: The number to be tested for primality. :param k: The number of accuracy iterations. :return: True if n is probably prime, False if n is composite. if n in (2, 3): return True if n == 1 or n % 2 == 0: return False # Write n-1 as 2^r * d with d odd by factoring powers of 2 from n-1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): Check if a is a composite witness. x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randrange(2, n - 1) if is_composite(a): return False return True"},{"question":"You are given an integer `n` representing the number of pairs of parentheses. Your task is to write a function `generate_parentheses(n)` that generates all combinations of `n` pairs of well-formed parentheses. # Input - An integer `n` (0 ≤ n ≤ 10), which represents the number of pairs of parentheses. # Output - A list of strings, where each string represents a valid combination of `n` pairs of well-formed parentheses. # Constraints - The maximum value for `n` is 10 to ensure the solution is efficient within reasonable time limits given the exponential growth of combinations. - Each string in the output should be unique and valid, with properly balanced parentheses. # Performance Requirements Your function should be optimized to handle the maximum value of `n` efficiently. Aim for a solution with a time complexity of approximately O(4^n/√n) and a space complexity of O(n). # Example Input ``` n = 3 ``` Output ``` [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ``` # Scenario As a programmer developing a text editor with code assistance features, you need to generate valid parentheses sequences for auto-completion. Implement the function `generate_parentheses(n)` to support this feature, ensuring it works efficiently even for the maximum input size.","solution":"def generate_parentheses(n): Generate all valid combinations of n pairs of parentheses. def backtrack(current, open_count, close_count, n, result): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count, n, result) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1, n, result) result = [] backtrack(\\"\\", 0, 0, n, result) return result"},{"question":"# Coding Challenge: Secure Messaging System using Diffie-Hellman Key Exchange **Scenario**: You have been hired to implement a secure messaging system where two parties, Alice and Bob, can securely exchange messages over an insecure network. To achieve this, they will use the Diffie-Hellman key exchange method to establish a shared secret key. This shared secret will be used for encrypting and decrypting the messages using a simple symmetric encryption algorithm (you can implement your own or use a basic algorithm such as XOR encryption). # Task Write a Python program that: 1. Performs the Diffie-Hellman key exchange to establish a shared secret key between Alice and Bob. 2. Uses the established shared key to encrypt a message from Alice to Bob. 3. Decrypts the received encrypted message on Bob\'s end to verify the secret key is properly used. # Function Specifications: 1. **diffie_hellman_key_exchange(a, p)** - **Input**: Two integers `a` (primitive root) and `p` (prime number). - **Output**: The shared secret key established using Diffie-Hellman key exchange. 2. **encrypt_message(shared_key, message)** - **Input**: An integer `shared_key` and a string `message`. - **Output**: The encrypted message as a string. 3. **decrypt_message(shared_key, encrypted_message)** - **Input**: An integer `shared_key` and a string `encrypted_message`. - **Output**: The decrypted message as a string. # Constraints 1. `2 <= p <= 10^6` 2. `message` will only contain ASCII characters. 3. The same encryption function should work for symmetric encryption and decryption. # Example Usage: ```python a = 2 p = 11 message = \\"Hello\\" # Establish shared key using Diffie-Hellman key exchange shared_key = diffie_hellman_key_exchange(a, p) # Encrypt the message using the shared key encrypted_message = encrypt_message(shared_key, message) print(f\\"Encrypted Message: {encrypted_message}\\") # Decrypt the received message using the shared key decrypted_message = decrypt_message(shared_key, encrypted_message) print(f\\"Decrypted Message: {decrypted_message}\\") ``` **Expected Output**: ``` Encrypted Message: some_encrypted_string Decrypted Message: Hello ``` # Notes: - You are allowed to use helper functions to break down the problem. - Ensure you validate the input parameters for their correctness. - The objective is to understand the underlying principles of secure key exchange and apply symmetric encryption effectively.","solution":"import random def diffie_hellman_key_exchange(a, p): Perform the Diffie-Hellman key exchange to establish a shared secret key. Params: a (int): primitive root p (int): prime number Returns: int: Shared secret key # Private keys for Alice and Bob (these would normally be kept secret) private_key_a = random.randint(1, p-2) private_key_b = random.randint(1, p-2) # Public keys public_key_a = pow(a, private_key_a, p) public_key_b = pow(a, private_key_b, p) # Shared secret key shared_key_a = pow(public_key_b, private_key_a, p) shared_key_b = pow(public_key_a, private_key_b, p) assert shared_key_a == shared_key_b, \\"Shared keys do not match.\\" return shared_key_a def encrypt_decrypt_message(shared_key, message): Encrypt/Decrypt a message using XOR symmetric encryption. Params: shared_key (int): Shared key for encryption/decryption message (str): The message to encrypt/decrypt Returns: str: The encrypted/decrypted message key_stream = str(shared_key) # Convert shared_key to string to use as key stream encrypted_message = \'\'.join(chr(ord(c) ^ ord(key_stream[i % len(key_stream)])) for i, c in enumerate(message)) return encrypted_message"},{"question":"# Question: Are Two Binary Trees Equal? Given two binary trees, write a function `is_same_tree` to determine if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. Function Signature: ```python def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]) -> bool: ``` Input: - `tree_p`: Reference to the root `TreeNode` of the first binary tree. Can be `None`. - `tree_q`: Reference to the root `TreeNode` of the second binary tree. Can be `None`. Output: - Return a boolean value `True` if the two binary trees are equal, `False` otherwise. Constraints: - The number of nodes in both trees is in the range `[0, 1000]`. - Node values are integers in the range `[-10^4, 10^4]`. Scenario: Imagine you are working with a version control system for configurations stored as binary trees. You need to verify if two version snapshots are exactly the same in terms of structure and values. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Trees # Tree 1 (tree_p): # 1 # / # 2 3 # # Tree 2 (tree_q): # 1 # / # 2 3 tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) assert is_same_tree(tree_p, tree_q) == True # Should return True as trees are identical. ```","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p: Optional[TreeNode], tree_q: Optional[TreeNode]) -> bool: Determine whether two binary trees are equal. Two trees are considered equal if they are structurally identical and the nodes have the same value. if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Coding Challenge: Implement Huffman Encoding and Decoding Scenario Imagine you are working on a software project that requires efficient storage and transfer of data files. To achieve this, you decide to implement Huffman Coding, a popular compression algorithm. Your task is to develop functions that can encode and decode files using Huffman Coding. Task Implement the following two functions in Python: 1. `huffman_encode(input_file, output_file)` 2. `huffman_decode(input_file, output_file)` # Function Specifications **huffman_encode(input_file, output_file)** * **Input**: * `input_file`: Path to the input file containing data to be compressed (binary format). * `output_file`: Path to the output file where the compressed data will be stored (binary format). * **Output**: The compressed data should be written to `output_file`. The function does not return any value. * **Constraints**: Handle any file size; assume input symbols are byte values (0-255). **huffman_decode(input_file, output_file)** * **Input**: * `input_file`: Path to the input file containing Huffman encoded data (binary format). * `output_file`: Path to the output file where the decompressed data will be stored (binary format). * **Output**: The decompressed data should be written to `output_file`. The function does not return any value. * **Constraints**: The encoding and decoding should maintain data integrity; the output of `huffman_decode` should be identical to the input of `huffman_encode` given same files. Performance Requirements * The implementation should handle typical data file sizes efficiently both in terms of time and space. # Example Given a file `input.txt` containing the text \\"this is an example for huffman encoding\\", the encoded file `encoded.bin` should thus compress the content. Decoding `encoded.bin` should correctly reconstruct the original text into a file `decoded.txt`. Testing * Write code to test your implementations using various input files covering edge cases such as: * Small files with few characters. * Large files with many repetitive sequences. * Files with all unique characters. * Empty files. # Notes * Ensure robust error handling for file operations. * You can use helper classes and functions as needed from the provided code snippets to complete the main tasks.","solution":"import heapq import os from collections import defaultdict class HuffmanNode: def __init__(self, symbol=None, freq=0, left=None, right=None): self.symbol = symbol self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq def build_frequency_table(data): frequency = defaultdict(int) for byte in data: frequency[byte] += 1 return frequency def build_huffman_tree(frequency): heap = [HuffmanNode(symbol=symbol, freq=freq) for symbol, freq in frequency.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = HuffmanNode(freq=node1.freq + node2.freq, left=node1, right=node2) heapq.heappush(heap, merged) return heap[0] def build_codes_table(root): codes = {} def _build_codes_table(node, code): if not node: return if node.symbol is not None: codes[node.symbol] = code return _build_codes_table(node.left, code + \\"0\\") _build_codes_table(node.right, code + \\"1\\") _build_codes_table(root, \\"\\") return codes def huffman_encode(input_file, output_file): with open(input_file, \'rb\') as f: data = f.read() if not data: with open(output_file, \'wb\') as f: f.write(b\'\') return frequency = build_frequency_table(data) huffman_tree = build_huffman_tree(frequency) codes = build_codes_table(huffman_tree) encoded_data = \\"\\".join(codes[byte] for byte in data) padding = 8 - len(encoded_data) % 8 encoded_data = f\\"{padding:08b}\\" + encoded_data + \\"0\\" * padding b = bytearray() for i in range(0, len(encoded_data), 8): b.append(int(encoded_data[i:i + 8], 2)) with open(output_file, \'wb\') as f: f.write(len(codes).to_bytes(1, \'big\')) for symbol, code in codes.items(): f.write(symbol.to_bytes(1, \'big\')) code_length = len(code) f.write(code_length.to_bytes(1, \'big\')) f.write(int(code, 2).to_bytes((code_length + 7) // 8, \'big\')) f.write(bytes(b)) def decode_huffman_codes(file): number_of_codes = int.from_bytes(file.read(1), \'big\') codes = {} for _ in range(number_of_codes): symbol = file.read(1)[0] code_length = int.from_bytes(file.read(1), \'big\') code = bin(int.from_bytes(file.read((code_length + 7) // 8), \'big\'))[2:].zfill(code_length) codes[code] = symbol return codes def huffman_decode(input_file, output_file): with open(input_file, \'rb\') as f: codes = decode_huffman_codes(f) encoded_data = f.read() if not encoded_data: with open(output_file, \'wb\') as f: f.write(b\'\') return bitstring = \\"\\".join(f\\"{byte:08b}\\" for byte in encoded_data) padding = int(bitstring[:8], 2) bitstring = bitstring[8:-padding] decoded_data = bytearray() code = \\"\\" for bit in bitstring: code += bit if code in codes: decoded_data.append(codes[code]) code = \\"\\" with open(output_file, \'wb\') as f: f.write(decoded_data)"},{"question":"# Question: Implement Enhanced Selection Sort Given an array of integers, modify the classic Selection Sort algorithm to perform the sorting in a non-descending order. Your function should additionally handle large inputs efficiently by avoiding unnecessary operations through early exits. Your task is to implement the function `enhanced_selection_sort(arr)` that sorts the array using the optimized approach: Function Signature ```python def enhanced_selection_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers `arr` where `1 <= len(arr) <= 10^6` and each element is `-10^6 <= arr[i] <= 10^6`. Output * A list of integers sorted in non-descending order. Constraints * Sorting must be performed in-place; no additional space for another array should be used. * Early exit optimizations can be implemented to reduce the number of unnecessary operations if the list becomes fully sorted before completing all iterations. Example ```python arr = [64, 25, 12, 22, 11] print(enhanced_selection_sort(arr)) # Output: [11, 12, 22, 25, 64] arr = [1, 2, 3, 4, 5] print(enhanced_selection_sort(arr)) # Output: [1, 2, 3, 4, 5] arr = [5, 4, 3, 2, 1] print(enhanced_selection_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` Requirements * Your implementation should be able to handle up to 10^6 elements efficiently. * The solution should be optimized to avoid excess and redundant operations if the array is already sorted before completion. * Ensure to account for edge cases such as duplicates and already sorted arrays.","solution":"from typing import List def enhanced_selection_sort(arr: List[int]) -> List[int]: Performs an optimized selection sort on the given list of integers. The algorithm sorts the list in non-descending order and quits early if the list becomes sorted before all iterations are complete. n = len(arr) for i in range(n - 1): min_idx = i sorted_flag = True for j in range(i + 1, n): if arr[j] < arr[min_idx]: min_idx = j sorted_flag = False # Swap only if a new minimum was found if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] # Break early if the remaining is already sorted if sorted_flag: break return arr"},{"question":"# Question As an employee working for a library management system, you are required to implement a \\"Catalogue\\" that allows for efficient lookup, insertion, and deletion of book records. Your manager has provided you with a basic Hash Table implementation but has asked you to enhance it by adding an LRU (Least Recently Used) cache mechanism to it. # Requirements - Implement an LRU cache for the above Hash Table that supports the following operations: - Adding a book record (given as key-value pair). - Retrieving a book record by key. - Deleting a book record by key. - Ensuring that the cache can hold a maximum of `N` records, and evicts the least recently used record when it exceeds this size. # Specifications 1. **Class Definition**: ```python class LRUCache: def __init__(self, capacity: int): # Initialize the cache with given capacity. def put(self, key: int, value: str) -> None: # Store key-value pair. If the cache exceeds the capacity, evict the least recently used item. def get(self, key: int) -> str: # Retrieve the value associated with the key. If the key does not exist, return None. def del_(self, key: int) -> None: # Remove the key-value pair from the cache. ``` 2. **Input and Output**: - `capacity`: Positive integer representing the maximum number of records the cache can hold. - `put`: Takes an integer `key` and a string `value`. - `get`: Takes an integer `key` and returns the corresponding `value` if the key exists, otherwise returns `None`. - `del_`: Takes an integer `key` and removes the corresponding record. # Constraints - The cache must maintain the order of usage and evict the least recently used record when necessary. - Operations `put`, `get`, and `del_` should all execute in constant time on average. # Example ```python cache = LRUCache(3) cache.put(1, \\"Book1\\") cache.put(2, \\"Book2\\") cache.put(3, \\"Book3\\") print(cache.get(1)) # Outputs: \\"Book1\\" cache.put(4, \\"Book4\\") # Evicts Book2 print(cache.get(2)) # Outputs: None, as Book2 was evicted cache.del_(3) # Removes Book3 print(cache.get(3)) # Outputs: None, as Book3 was deleted ``` # Additional Information - Ensure that your implementation handles key collisions gracefully. - Consider using any existing data structures (like doubly linked list for LRU ordering) if necessary for the LRU mechanism.","solution":"class Node: def __init__(self, key: int = None, value: str = None): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def _remove_node(self, node: Node) -> None: Internal method to remove a node from the doubly linked list. prev = node.prev next = node.next prev.next = next next.prev = prev def _add_node_to_front(self, node: Node) -> None: Internal method to add a new node right after the head. node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _move_to_front(self, node: Node) -> None: Internal method to move an existing node to the front. self._remove_node(node) self._add_node_to_front(node) def put(self, key: int, value: str) -> None: node = self.cache.get(key) if node: node.value = value self._move_to_front(node) else: new_node = Node(key, value) self.cache[key] = new_node self._add_node_to_front(new_node) if len(self.cache) > self.capacity: # Evict the least recently used item. lru_node = self.tail.prev self._remove_node(lru_node) del self.cache[lru_node.key] def get(self, key: int) -> str: node = self.cache.get(key) if not node: return None self._move_to_front(node) return node.value def del_(self, key: int) -> None: node = self.cache.pop(key, None) if node: self._remove_node(node)"},{"question":"# Task Description You are given a class `ResizableHashTable` implementing a hash table with dynamic resizing using linear probing for collision resolution. Your task is to extend this data structure to include an additional method that retrieves all keys mapped to a given value. # Requirements * Implement a method `get_keys_by_value(value)` that returns a list of all keys associated with the specified value in the hash table. * If the value is not found, the method should return an empty list. # Constraints * You should not modify existing methods or the structure of `ResizableHashTable`. * Efficiently handle the retrieval operation to leverage the properties of hash tables. # Function Signature ```python class ResizableHashTable(HashTable): def __init__(self): super().__init__() def put(self, key, value): pass def get_keys_by_value(self, value): pass ``` # Example ```python # Initialize hash table and add some key-value pairs ht = ResizableHashTable() ht.put(10, \'apple\') ht.put(22, \'banana\') ht.put(31, \'apple\') ht.put(4, \'date\') # Retrieve keys by value print(ht.get_keys_by_value(\'apple\')) # Output: [10, 31] print(ht.get_keys_by_value(\'banana\')) # Output: [22] print(ht.get_keys_by_value(\'cherry\')) # Output: [] ``` # Explanation The class `ResizableHashTable` should be extended with a new method: - `get_keys_by_value(value)`: Iterates through the hash table, collects all keys that are associated with the given value, and returns them as a list.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.count = 0 self.table = [None] * self.size def _hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self._hash(key) initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size if initial_idx == idx: raise Exception(\\"HashTable is full, resize needed\\") self.table[idx] = (key, value) self.count += 1 if self.count / self.size > 0.7: self._resize() def get_keys_by_value(self, value): keys = [] for entry in self.table: if entry is not None and entry[1] == value: keys.append(entry[0]) return keys def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1])"},{"question":"# Flatten Nested Arrays **Context**: You are working on a data preprocessing task where you need to flatten nested arrays. Given an array that may contain nested arrays of arbitrary depth, produce a single resultant array containing all the elements in a flat structure. **Task**: Write a function `flatten_array` that takes a nested list as input and returns a flat list with all the elements in a one-dimensional structure. # Function Signature ```python def flatten_array(nested_list: list) -> list: pass ``` # Input * `nested_list` (list): A list that may contain nested lists, integers, floats, strings, and other data types. # Output * (list): A flat list containing all the elements from the input nested list. # Constraints * Elements of type `str` should not be split or flattened. * `nested_list` may contain other nested lists or non-iterable elements. * The depth of nesting can be any arbitrary number. * Your solution should be able to handle large and deeply nested structures without exceeding Python\'s default recursion limit. # Example ```python # Example 1: flatten_array([1, [2, 3], [4, [5, 6, [7]]], 8]) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: flatten_array([[\'a\'], \'b\', [1, 2, [3, \'c\']], []]) # Output: [\'a\', \'b\', 1, 2, 3, \'c\'] ``` # Note Large inputs with deeply nested structures should be handled efficiently without exceeding memory limits.","solution":"def flatten_array(nested_list: list) -> list: Flattens a nested list into a single list containing all elements in a one-dimensional structure. flattened_list = [] def flatten(sub_list): for item in sub_list: if isinstance(item, list): flatten(item) else: flattened_list.append(item) flatten(nested_list) return flattened_list"},{"question":"# Problem Description Write a function `multiply_bitwise_operator` that multiplies two non-negative integers using bitwise operations. This function should not use the `*` operator. Instead, leverage the properties of bitwise operations. Below is the expected behavior of your function: **Input**: - `a` (non-negative integer): The first number to be multiplied (0 ≤ a ≤ 10^9). - `b` (non-negative integer): The second number to be multiplied (0 ≤ b ≤ 10^9). **Output**: - An integer representing the product of `a` and `b`. # Function Signature ```python def multiply_bitwise_operator(a: int, b: int) -> int: pass ``` # Examples ```python assert multiply_bitwise_operator(3, 4) == 12 assert multiply_bitwise_operator(7, 6) == 42 assert multiply_bitwise_operator(0, 10) == 0 ``` # Constraints - Your solution should have a time complexity of O(log(min(a, b))) for the bitwise manipulation. - You may assume inputs are non-negative integers. - The implementation should efficiently handle potential large values up to the maximum constraint. # Additional Instructions - Share edge cases and test cases you believe are important for validating the correctness of your solution. - Include comments explaining the main steps of your code to make it clear how bitwise operations are applied for multiplication.","solution":"def multiply_bitwise_operator(a: int, b: int) -> int: Multiply two non-negative integers using bitwise operations. result = 0 while b > 0: # If the least significant bit of b is set, add `a` to the result if (b & 1) != 0: result = add_bitwise(result, a) # Left shift `a` and right shift `b` for the next bit a <<= 1 b >>= 1 return result def add_bitwise(x: int, y: int) -> int: Add two non-negative integers using bitwise operations. while y != 0: # Carry now contains common set bits of x and y carry = x & y # Sum of bits of x and y where at least one of the bits is not set x = x ^ y # Carry is shifted by one so that adding it to x gives the required sum y = carry << 1 return x"},{"question":"# Maximum Flow Problem **Problem Statement**: You are provided with a directed graph represented as an adjacency matrix (`capacity`). You need to compute the maximum flow from a given source vertex (`source`) to a sink vertex (`sink`). Implement the functions for the following maximum flow algorithms: 1. Ford-Fulkerson Algorithm using Depth First Search (DFS) 2. Edmonds-Karp Algorithm using Breadth First Search (BFS) 3. Dinic\'s Algorithm **Input**: * `capacity`: A 2D list (or matrix) where `capacity[i][j]` represents the capacity of the edge from vertex i to vertex j. If there is no edge from i to j, the capacity should be zero. * `source`: An integer representing the source vertex. * `sink`: An integer representing the sink vertex. **Output**: * Return the maximum flow from `source` to `sink`. **Constraints**: 1. `capacity` is a square matrix (V x V), where 1 ≤ V ≤ 100 and 0 ≤ capacity[i][j] ≤ 10^6. 2. `source` and `sink` are valid indices within the range of the matrix. 3. Graph may be sparse, meaning not every pair of nodes are connected. **Implementation Requirements**: * Implement three separate functions: `ford_fulkerson(capacity, source, sink)`, `edmonds_karp(capacity, source, sink)`, and `dinic(capacity, source, sink)` that compute the maximum flow from `source` to `sink`. **Performance Requirements**: * Ensure that your implementations are efficient and can handle the upper constraints efficiently. **Example**: ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 # Expected Output: 23 for all three algorithms ``` **Your Tasks**: 1. Implement the `ford_fulkerson(capacity, source, sink)` function. 2. Implement the `edmonds_karp(capacity, source, sink)` function. 3. Implement the `dinic(capacity, source, sink)` function. 4. Test your implementations to ensure correctness and efficiency for the provided example and potential edge cases.","solution":"def ford_fulkerson(capacity, source, sink): Ford-Fulkerson algorithm using DFS to find max flow. n = len(capacity) residual_capacity = [row[:] for row in capacity] max_flow = 0 def dfs(s, t, flow): if s == t: return flow visited[s] = True for v in range(n): if not visited[v] and residual_capacity[s][v] > 0: min_flow = min(flow, residual_capacity[s][v]) flow_path = dfs(v, t, min_flow) if flow_path > 0: residual_capacity[s][v] -= flow_path residual_capacity[v][s] += flow_path return flow_path return 0 while True: visited = [False] * n flow = dfs(source, sink, float(\'Inf\')) if flow == 0: break max_flow += flow return max_flow from collections import deque def edmonds_karp(capacity, source, sink): Edmonds-Karp algorithm using BFS to find max flow. n = len(capacity) residual_capacity = [row[:] for row in capacity] max_flow = 0 def bfs(s, t, parent): visited = [False] * n queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v in range(n): if not visited[v] and residual_capacity[u][v] > 0: parent[v] = u queue.append(v) visited[v] = True if v == t: return True return False parent = [-1] * n while bfs(source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] return max_flow def dinic(capacity, source, sink): Dinic\'s algorithm to find max flow. n = len(capacity) residual_capacity = [row[:] for row in capacity] level = [0] * n def bfs_level_graph(): for i in range(n): level[i] = -1 queue = deque([source]) level[source] = 0 while queue: u = queue.popleft() for v in range(n): if level[v] < 0 and residual_capacity[u][v] > 0: level[v] = level[u] + 1 queue.append(v) return level[sink] != -1 def dfs_flow(u, flow): if u == sink: return flow for v in range(start[u], n): if residual_capacity[u][v] > 0 and level[v] == level[u] + 1: min_flow = min(flow, residual_capacity[u][v]) flow_path = dfs_flow(v, min_flow) if flow_path > 0: residual_capacity[u][v] -= flow_path residual_capacity[v][u] += flow_path return flow_path start[u] += 1 return 0 max_flow = 0 while bfs_level_graph(): start = [0] * n while True: flow = dfs_flow(source, float(\'Inf\')) if flow == 0: break max_flow += flow return max_flow"},{"question":"You are working on a text processing application, and one of the core features is the ability to find all instances of a specific search term (pattern) within a large document. You decide to use the Knuth-Morris-Pratt (KMP) algorithm for its efficiency. The function `knuth_morris_pratt` has already been provided. Your task is to complete the function `optimize_knuth_morris_pratt` to handle additional edge cases and optimize the implementation further. Function Signature ```python def optimize_knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: pass ``` Input - `text`: A sequence of characters (string) where the search is performed. - `pattern`: A sequence of characters (string) that needs to be found in `text`. Output - A list of starting indices where the pattern is found in the text. Constraints - The length of `text` (N) can be up to 10^6. - The length of `pattern` (M) is at most 10^5. - If `text` is empty, the output should be an empty list. - If `pattern` is an empty string, the output should be an empty list. - Ensure the implementation handles edge cases efficiently. Example ```python assert optimize_knuth_morris_pratt(\'hello there hero!\', \'he\') == [0, 7, 12] assert optimize_knuth_morris_pratt(\'abcdef\', \'gh\') == [] assert optimize_knuth_morris_pratt(\'\', \'pattern\') == [] assert optimize_knuth_morris_pratt(\'pattern\', \'\') == [] ``` Requirements - Optimize the KMP algorithm provided, handling edge cases, improving memory usage, or enhancing performance where applicable. - Avoid any unnecessary recomputations and ensure the function runs efficiently for large inputs.","solution":"from typing import List, Sequence def build_lps(pattern: Sequence[str]) -> List[int]: Function to build the longest proper prefix which is also suffix (lps) array lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def optimize_knuth_morris_pratt(text: Sequence[str], pattern: Sequence[str]) -> List[int]: Function that uses the Knuth-Morris-Pratt algorithm to find all occurrences of a pattern in a text if not text or not pattern: return [] n = len(text) m = len(pattern) lps = build_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Run-Length Encoding Enhancement Run-length Encoding (RLE) is a simple data compression algorithm that encodes consecutive characters as a single count and character pair. You are required to implement an enhanced version of RLE encoding and decoding methods. Enhanced Requirements: 1. **Upper Limit**: If the input stream contains any character repeated more than 9 times consecutively, split it into multiple groups such that no count exceeds 9. - For instance, `AAAAAAAAAAAA` should be encoded as `9A3A` instead of `12A`. 2. **Character Encoding**: Alter the encoding function to include both alphanumeric and non-alphanumeric characters correctly. 3. **Edge Cases**: Ensure to handle empty strings and inputs with no repeating characters appropriately. # Task: 1. Implement the `enhanced_encode_rle` function. 2. Implement the `enhanced_decode_rle` function. # Input: - `enhanced_encode_rle`: * A string `input` containing the data to be encoded. - `enhanced_decode_rle`: * A string `input` containing the encoded data. # Output: - The `enhanced_encode_rle` function should return a string representing the encoded data. - The `enhanced_decode_rle` function should return the original string after decoding. # Constraints: - Input string length for both functions should be 0 <= len(input) <= 10^5. - Each encoded count will always be between 1-9 inclusive. # Example: ```python # Example implementation inputs and outputs: assert enhanced_encode_rle(\\"AAAABBBCCDAA\\") == \\"4A3B2C1D2A\\" assert enhanced_decode_rle(\\"4A3B2C1D2A\\") == \\"AAAABBBCCDAA\\" assert enhanced_encode_rle(\\"AAAAAAAAAAAA\\") == \\"9A3A\\" assert enhanced_decode_rle(\\"9A3A\\") == \\"AAAAAAAAAAAA\\" assert enhanced_encode_rle(\\"\\") == \\"\\" assert enhanced_decode_rle(\\"\\") == \\"\\" ``` # Implementation Levels: 1. Basic compression and decompression (mandatory). 2. Handle inputs up to the specified length efficiently (mandatory). 3. Additional comprehensive test cases to validate edge scenarios (optional but recommended).","solution":"def enhanced_encode_rle(input): if not input: return \\"\\" encoded_str = [] count = 1 previous_char = input[0] for i in range(1, len(input)): current_char = input[i] if current_char == previous_char: count += 1 if count == 10: encoded_str.append(\'9\' + previous_char) count = 1 # reset count for new segment else: encoded_str.append(str(count) + previous_char) previous_char = current_char count = 1 # Append the final group encoded_str.append(str(count) + previous_char) return \'\'.join(encoded_str) def enhanced_decode_rle(input): if not input: return \\"\\" decoded_str = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# B-tree Implementation and Operations You are provided with the detailed implementation of a B-tree data structure. As you have learned, a B-tree is used extensively in applications that involve large amounts of data stored on disks. Your objective is to fully understand and ensure the correctness of the B-tree operations (insert, delete, search, and traversal). Your task is to implement the method `find_min()` for the B-tree class provided. This method should find and return the minimum key in the B-tree. Additionally, you must demonstrate the correctness of this method by writing tests that verify the method\'s functionality using various B-tree operations. # Requirements 1. **Method Implementation**: - Implement the method `find_min` which should traverse the B-tree to find the smallest key. 2. **Tests**: - Write tests to validate the correctness of the `find_min` method. These tests should cover: - Finding the minimum key in an empty B-tree. - Finding the minimum key after several insertions. - Finding the minimum key after various deletions. # Constraints * You may assume that all keys are unique integers. * Your implementation should not modify the structure of the B-tree except as needed for the specific B-tree operations (insert, delete). # Input Format Your implementation does not need to handle any specific input formats; instead, you will be defining and using instances of the B-tree class and calling methods on them. # Output Format The `find_min` method should return the minimum key found in the B-tree. # Example ```python # Example setup and method call btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) min_key = btree.find_min() print(min_key) # Output should be 5 ``` # Note Make sure to handle edge cases such as: * Finding the minimum key in an empty B-tree. * Finding the minimum key in a B-tree with a single element.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child BTreeNode instances def find_min(self): current = self while not current.leaf: current = current.children[0] return current.keys[0] class BTree: def __init__(self, t_val): self.root = None self.t_val = t_val def find_min(self): if self.root is None: return None return self.root.find_min() def insert_key(self, k): if self.root is None: self.root = BTreeNode(self.t_val, True) self.root.keys = [k] else: if len(self.root.keys) == (2 * self.t_val) - 1: s = BTreeNode(self.t_val, False) s.children.append(self.root) self._split_child(s, 0) i = 0 if s.keys[0] < k: i += 1 self._insert_non_full(s.children[i], k) self.root = s else: self._insert_non_full(self.root, k) def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i+1] = node.keys[i] i -= 1 node.keys[i+1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t_val) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, parent, i): t = self.t_val y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i+1, z) parent.keys.insert(i, y.keys[t-1]) z.keys = y.keys[t:(2*t)-1] y.keys = y.keys[0:t-1] if not y.leaf: z.children = y.children[t:(2*t)] y.children = y.children[0:t-1]"},{"question":"Background: You are building a predictive text feature for a new messaging application. The feature should allow users to get word suggestions as they type the beginning of a word. You will use a Trie data structure to implement this feature for efficient storage and retrieval. Problem Statement: Implement a `PredictiveText` class with the following methods: 1. **insert(word: str) -> None**: Inserts a word into the Trie. 2. **search(word: str) -> bool**: Returns True if the word is in the Trie else False. 3. **starts_with(prefix: str) -> bool**: Returns True if there is any word in the Trie that starts with the given prefix. 4. **suggest(prefix: str) -> List[str]**: Returns a list of all words in the Trie that start with the given prefix. Requirements: * All inputs are composed of lowercase English letters (a-z). * The `suggest` method must return words in any order. Constraints: * Words inserted into the Trie will have a maximum length of 100. * The total number of words inserted will not exceed 10,000. Here is your `PredictiveText` class template: ```python import collections from typing import List class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class PredictiveText: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix: str) -> bool: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True def suggest(self, prefix: str) -> List[str]: # Your implementation here pass ``` Example: ```python # Sample usage pt = PredictiveText() pt.insert(\\"apple\\") pt.insert(\\"app\\") pt.insert(\\"application\\") print(pt.search(\\"app\\")) # Output: True print(pt.search(\\"appl\\")) # Output: False print(pt.starts_with(\\"appl\\")) # Output: True print(pt.suggest(\\"app\\")) # Output: [\\"apple\\", \\"app\\", \\"application\\"] ``` Complete the implementation of the `suggest` method.","solution":"import collections from typing import List class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class PredictiveText: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for letter in word: current = current.children[letter] current.is_word = True def search(self, word: str) -> bool: current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_word def starts_with(self, prefix: str) -> bool: current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True def suggest(self, prefix: str) -> List[str]: def dfs(node, path, results): if node.is_word: results.append(\\"\\".join(path)) for letter, child_node in node.children.items(): path.append(letter) dfs(child_node, path, results) path.pop() current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return [] results = [] dfs(current, list(prefix), results) return results"},{"question":"# Question Binary String Addition You are tasked with implementing a function to add two binary strings and return their sum as a binary string. # Function Signature ```python def add_binary(a: str, b: str) -> str: Adds two binary strings and returns their sum as a binary string. Parameters: a (str): A binary string. b (str): Another binary string. Returns: str: The sum of the binary strings as a binary string. ``` Input - `a` (length n): A binary string consisting of characters \'0\' and \'1\'. - `b` (length m): A binary string consisting of characters \'0\' and \'1\'. Output - A binary string representing the sum of input binary strings `a` and `b`. Constraints - The input strings are non-empty and contain only the characters \'0\' and \'1\'. - The returned binary string should not contain leading zeros unless it is the string \\"0\\". Examples ```python # Example 1 add_binary(\\"11\\", \\"1\\") # Output: \\"100\\" # Example 2 add_binary(\\"1010\\", \\"1011\\") # Output: \\"10101\\" # Example 3 add_binary(\\"0\\", \\"0\\") # Output: \\"0\\" # Example 4 add_binary(\\"1101\\", \\"1011\\") # Output: \\"11000\\" ``` Scenario You are developing a calculator to handle binary arithmetic operations. Your task is to handle the addition operation correctly and efficiently. Ensure your implementation adheres to the constraints and performs well even with larger input sizes. Performance Requirements The solution should efficiently handle input sizes up to `10^5` for both binary strings.","solution":"def add_binary(a: str, b: str) -> str: Adds two binary strings and returns their sum as a binary string. Parameters: a (str): A binary string. b (str): Another binary string. Returns: str: The sum of the binary strings as a binary string. # Initialize variables result = [] carry = 0 max_len = max(len(a), len(b)) # Pad the shorter string with zeros a = a.zfill(max_len) b = b.zfill(max_len) # Iterate from the least significant bit to the most significant bit for i in range(max_len - 1, -1, -1): digit_sum = carry digit_sum += int(a[i]) digit_sum += int(b[i]) # Calculate the current bit and update the carry result.append(str(digit_sum % 2)) carry = digit_sum // 2 # If we have a carry left, add it to the result if carry: result.append(\'1\') # Join the result and reverse it since we computed it backwards return \'\'.join(reversed(result))"},{"question":"# Scenario You are working as a software developer and have been tasked with developing a sorting function for an application that processes visual data. The application needs to sort various elements by their colors for better visualization and processing. The colors are represented by integers 0, 1, and 2 corresponding to red, white, and blue. You are to implement a function that sorts this color-coded array in such a way that all elements of the same color are adjacent and the colors are in the order of red, white, and blue. You are not allowed to use any built-in sort functions. # Problem Statement Write a function `sort_colors(nums)` that sorts an array of integers where each integer is 0, 1, or 2. The sorted array should have all 0\'s (red) first, followed by all 1\'s (white), and then all 2\'s (blue). Function Signature ```python def sort_colors(nums: List[int]) -> None: pass ``` Input * A list of integers `nums` where each integer can be 0, 1, or 2. Output * The function should modify the input list in place to sort it. Constraints * Do not return anything, modify `nums` in-place instead. * You must solve this problem without using the library’s sort function. Example ```python nums = [0, 1, 2, 1, 0, 2, 1, 0] sort_colors(nums) print(nums) # Output should be: [0, 0, 0, 1, 1, 1, 2, 2] ``` # Additional Notes - Consider edge cases such as an empty array, arrays with only one type of element, and minimally populated arrays. - Think about how you can efficiently manage the three segments (for red, white, and blue) during the sorting process.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts an array of integers where each integer is either 0, 1, or 2 in-place such that all 0\'s come first, followed by all 1\'s, and then all 2\'s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"# Path Finding in Graphs Problem Statement You are given a graph represented as an adjacency list, and your task is to implement a function `longest_simple_path` that finds the longest simple path between two nodes. A simple path is a path that does not revisit any node. The function signature is provided below: ```python def longest_simple_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: pass ``` Input Format - `graph`: Dictionary where keys are node labels (strings) and values are lists of nodes (strings) the key is connected to. - `start`: A string representing the starting node. - `end`: A string representing the destination node. Output Format - Returns a list of nodes (strings) representing the longest simple path from `start` to `end`. If no path exists, return an empty list. Constraints and Assumptions - The graph is assumed to be finite and small enough to explore exhaustively. - Nodes in the graph are represented as unique strings. - The graph may contain cycles, but the path returned should not revisit any node. - The length of the path is defined by the number of edges. - Paths are not weighted. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } print(longest_simple_path(graph, \'A\', \'D\')) # Expected Output: [\'A\', \'B\', \'C\', \'D\'] ``` Performance Requirements - Implement the function to efficiently explore paths. While larger graphs will naturally take more time, ensure your solution minimizes unnecessary computations.","solution":"def longest_simple_path(graph, start, end): def dfs(node, current_path): # If we reached the end node, return the current path if node == end: return current_path # Mark the node as visited visited.add(node) max_path = [] # Explore each neighbor for neighbor in graph.get(node, []): if neighbor not in visited: candidate_path = dfs(neighbor, current_path + [neighbor]) if len(candidate_path) > len(max_path): max_path = candidate_path # Unmark the node as visited for other paths visited.remove(node) return max_path visited = set() return dfs(start, [start])"},{"question":"You are given a list of integers `nums` where exactly two elements appear only once and all the other elements appear exactly twice. Your task is to implement a function `find_single_numbers` that identifies and returns the two unique elements. Your implemented solution must adhere to the following constraints: * Time Complexity: O(N) * Space Complexity: O(1) # Function Signature ```python def find_single_numbers(nums: List[int]) -> List[int]: pass ``` # Input * `nums` (List[int]): A list of integers, where exactly two numbers appear once and all other numbers appear twice. The length of `nums` is at least `2` and at most `10^7`. # Output * List[int]: A list containing the two unique numbers. The order of the numbers in the output does not matter. # Examples ```python find_single_numbers([1, 2, 1, 3, 2, 5]) # Output: [3, 5] or [5, 3] find_single_numbers([4, 1, 2, 1, 2, 4, 3, 6]) # Output: [3, 6] or [6, 3] find_single_numbers([7, 3, 5, 4, 5, 3, 2, 7]) # Output: [4, 2] or [2, 4] ``` # Constraints 1. The function must execute in O(N) time complexity. 2. The function must use O(1) extra space. **Note**: Given the constraints, traditional approaches using hashmaps/dictionaries for extra space are not allowed. Use bitwise operations to achieve the desired performance. # Detailed Explanation The solution should leverage the XOR operation to isolate the two unique numbers from the array. Follow these steps: 1. XOR all numbers in the array, resulting in `a ^ b` (where `a` and `b` are the two unique numbers). 2. Find a right-most bit where `a` and `b` differ. 3. Split the numbers into two groups based on the bit found. 4. XOR the numbers in each group separately to isolate `a` and `b`. Implement the function `find_single_numbers` according to the outlined approach above.","solution":"from typing import List def find_single_numbers(nums: List[int]) -> List[int]: # Step 1: XOR all the elements to get a XOR b xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a bit that is set in xor_result (i.e., where a and b differ) diff_bit = xor_result & -xor_result # This gets the rightmost set bit # Step 3: We will now separate nums into two groups and find the unique numbers a, b = 0, 0 for num in nums: if num & diff_bit: # Grouping based on the set bit a ^= num else: b ^= num return [a, b]"},{"question":"# Josephus Problem with a Twist You are tasked to solve a variation of the Josephus problem using Python. This problem involves a group of people standing in a circle. Every third person will be eliminated from the circle, and this process continues until all people are eliminated in that order. For simulation, consider an input list of integers representing people standing in a circle. Your task is to write a function that returns the order in which people are eliminated. # Function Signature ```python def josephus_elimination(people: List[int], k: int) -> List[int]: ``` # Input 1. `people` (List[int]): A list of integers representing people in a circle. 2. `k` (int): An integer representing the step count for elimination (Here, k is always 3). # Output - Returns a list of integers representing the order of elimination. # Constraints - Assume the list `people` always contains at least one person. - No duplicate integers in the list `people`. - The integer `k` is constant (3 in this problem\'s context). # Example ```python people = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 3 josephus_elimination(people, k) ``` Expected Output ```python [3, 6, 9, 4, 8, 5, 2, 7, 1] ``` # Explanation In this example, the order of removal is: 1. 3 (eliminated first) 2. 6 (next after 4 removes 3) 3. 9 4. 4 5. 8 6. 5 7. 2 8. 7 9. 1 (last) Implement the function `josephus_elimination` such that it efficiently computes the order of elimination.","solution":"def josephus_elimination(people, k=3): Takes a list of people and an integer k (3 by default) and returns the order in which people are eliminated. index = 0 elimination_order = [] while people: index = (index + k - 1) % len(people) elimination_order.append(people.pop(index)) return elimination_order"},{"question":"You have been tasked with implementing matrix transformation functions that perform different types of rotations and inversions on a given 2D matrix. The transformations include rotating 90 degrees clockwise, 90 degrees counterclockwise, and inverting along the top-left to bottom-right and bottom-left to top-right diagonals. # Requirements 1. Implement four functions: - `rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]` - `rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]` - `top_left_invert(matrix: List[List[int]]) -> List[List[int]]` - `bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]` 2. Each function should take a 2D list of integers as input and return a new 2D list of integers with the respective transformation applied. # Input and Output Formats - **Input**: A 2D list of integers `matrix`, e.g., `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` - **Output**: A new 2D list of integers resulting from the transformation. # Constraints 1. The input matrix will have dimensions `M x N` where `1 <= M, N <= 1000`. 2. All elements in the matrix are integers in the range `-10^9` to `10^9`. 3. The matrix may not always be square (i.e., M may not equal N). # Sample Cases Example 1 **Input**: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` **Output for rotate_clockwise**: `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` **Output for rotate_counterclockwise**: `[[3, 6, 9], [2, 5, 8], [1, 4, 7]]` **Output for top_left_invert**: `[[1, 4, 7], [2, 5, 8], [3, 6, 9]]` **Output for bottom_left_invert**: `[[9, 6, 3], [8, 5, 2], [7, 4, 1]]` # Instructions 1. Carefully read the input format and expected output for each function. 2. Ensure your functions handle edge cases such as empty matrices, single-row matrices, and single-column matrices. 3. Optimize your function for large input sizes up to `1000 x 1000`. 4. Do not modify the input matrix in place; each function must return a new matrix. # Note - Make sure your solution is efficient and you handle invalid index accesses gracefully. - Consider using error handling where applicable to catch common mistakes. Your solution will be evaluated based on correctness, efficiency, and code quality.","solution":"def rotate_clockwise(matrix): Rotates the matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Inverts the matrix along the top-left to bottom-right diagonal. rows, cols = len(matrix), len(matrix[0]) return [[matrix[j][i] for j in range(rows)] for i in range(cols)] def bottom_left_invert(matrix): Inverts the matrix along the bottom-left to top-right diagonal. rows, cols = len(matrix), len(matrix[0]) return [[matrix[rows - j - 1][cols - i - 1] for j in range(rows)] for i in range(cols)]"},{"question":"Given a set of distinct integers, implement a function to return all possible subsets (the power set) of that set. Ensure that the solution set does not contain duplicate subsets. # Function Signature ```python def subsets(nums: List[int]) -> Set[Tuple[int]]: :param nums: List[int] :return: Set[Tuple[int]] ``` # Input * `nums`: A list of distinct integers. (1 <= len(nums) <= 10) # Output * A set of tuples, where each tuple represents a subset of `nums`. # Constraints * The elements within each subset should be arranged in the same order as they appear in `nums`. # Examples Example 1 ```python Input: nums = [1, 2, 3] Output: {(2,), (1, 2), (1, 3), (), (1, 2, 3), (1,), (2, 3), (3,)} ``` Example 2 ```python Input: nums = [] Output: {()} ``` # Context Consider you are helping a researcher who needs to analyze all possible combinations of features from a given set of data attributes. She requests a function that can generate all possible combinations (subsets) of the data attributes from a list she provides. # Requirements 1. Implement the function `subsets` as specified above. 2. Ensure that the solution handles edge cases effectively, such as empty input sets. 3. Optimize the implementation for clarity and performance considering the constraints.","solution":"from typing import List, Set, Tuple def subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets of a list of distinct integers. :param nums: List of distinct integers. :return: Set containing all possible subsets as tuples. from itertools import chain, combinations # Helper function to generate all combinations of any length def all_combinations(s): return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1)) # Generate all subsets and store them in a set return set(all_combinations(nums))"},{"question":"# Question You are provided with a function and a test case that calculates the height of a Binary Search Tree (BST). The height of a tree is defined as the number of levels from the root node to the furthest leaf node. Your task is to implement a modified function `calculate_height_and_opposite_leaf_nodes` that not only calculates the height but also returns the value of nodes that are farthest left and farthest right from the root node at the lowest level. # Function Signature ```python def calculate_height_and_opposite_leaf_nodes(root): # your code here ``` # Input * `root` (Node): The root node of the BST. # Output * Returns a tuple containing: - The height (integer) of the BST. - The value of the leftmost leaf node at the maximum height. - The value of the rightmost leaf node at the maximum height. # Constraints * The tree will have at most 1000 nodes. * Node values are distinct integers. * Each node has the following attributes: - `val` (int): The value of the node. - `left` (Node): The left child node. - `right` (Node): The right child node. # Example Consider the tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` *Input*: root (Node pointing to the root of above tree) *Output*: (4, 7, 18) # Context This question will evaluate your understanding of tree data structures, specifically traversing and evaluating the properties of a BST. It will test your ability to manipulate tree nodes, handle edge cases and consider efficiency for potentially large trees. Note: Please make sure your implementation passes the provided example and consider additional edge cases in your code.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_height_and_opposite_leaf_nodes(root): if not root: return (0, None, None) from collections import deque queue = deque([(root, 1)]) max_height = 0 leftmost_value = None rightmost_value = None while queue: node, height = queue.popleft() if height > max_height: max_height = height leftmost_value = node.val rightmost_value = node.val elif height == max_height: rightmost_value = node.val if node.left: queue.append((node.left, height + 1)) if node.right: queue.append((node.right, height + 1)) return (max_height, leftmost_value, rightmost_value)"},{"question":"# Magic Number Validation Using Summing Digits Context In this task, you are required to implement a function that checks if a given number is a \\"Magic Number\\". A number is considered a magic number if repeatedly summing its digits results in a single-digit number equal to 1. Function Signature ```python def is_magic_number(num: int) -> bool: Determines if the given number is a Magic Number. Parameters: num (int): The input number to be checked. Returns: bool: True if the number is a Magic Number, False otherwise. pass ``` Input * An integer `num` (0 ≤ num ≤ 10^9). Output * Return `True` if the number is a magic number, otherwise return `False`. Examples ```python assert is_magic_number(50113) == True # 5+0+1+1+3=10 => 1+0=1 assert is_magic_number(1234) == True # 1+2+3+4=10 => 1+0=1 assert is_magic_number(199) == True # 1+9+9=19 => 1+9=10 => 1+0=1 assert is_magic_number(111) == False # 1+1+1=3 (Not a Magic Number) assert is_magic_number(1) == True # Single digit 1 is a Magic Number assert is_magic_number(0) == False # Single digit 0 is not a Magic Number ``` Constraints * Assume that the input number is always an integer between 0 and 10^9. * You should handle edge cases like very large input values and numbers with multiple zeros efficiently. Notes * Do not use any built-in functions like `sum()`, `divmod()` etc., to achieve the sum of digits in the number. * Optimize your function to handle the upper limits of the input range efficiently.","solution":"def is_magic_number(num: int) -> bool: Determines if the given number is a Magic Number. A Magic Number is one where repeatedly summing its digits results in a single-digit number equal to 1. Parameters: num (int): The input number to be checked. Returns: bool: True if the number is a Magic Number, False otherwise. def sum_of_digits(n): total = 0 while n > 0: total += n % 10 n = n // 10 return total while num > 9: num = sum_of_digits(num) return num == 1"},{"question":"You are tasked with finding a single unique integer in a list, where every other integer appears exactly twice. This problem can be effectively solved using an optimal algorithm that leverages the properties of the XOR operation. # Objective: Write a function `find_single_number` that takes a list of integers as input and returns the unique integer that appears only once. The rest of the integers in the list appear exactly twice. # Function Signature: ```python def find_single_number(nums: List[int]) -> int: ``` # Input: - `nums`: a list of integers where every element appears exactly twice except for one element which appears once. (1 <= len(nums) <= 10^4) # Output: - An integer representing the element that appears only once in the list. # Constraints: - You must implement the solution with a linear runtime complexity, i.e., O(n). - The solution must not use more than constant extra space, i.e., O(1) additional memory. # Examples: 1. Input: `[2, 2, 1]` Output: `1` 2. Input: `[4, 1, 2, 1, 2]` Output: `4` 3. Input: `[1]` Output: `1` 4. Input: `[7, 3, 5, 4, 5, 3, 4]` Output: `7` # Edge Cases to Consider: - The list containing only one element should return that element. - Ensure the list length is within the given bounds. Write the function to provide the correct output as per the specifications above.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number in the list where every other number appears twice. Uses XOR bitwise operation to achieve this with linear runtime and constant space. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Coin Change Problem You are given a set of `coins` of different denominations and a `value`. Your task is to write a function `count_ways_to_make_change(coins, value)` that computes the number of distinct ways to make up the `value` using the given `coins`. The order of coins in combinations does not matter, and you have an infinite supply of each type of coin. Input: * `coins`: A list of integers representing the different denominations (e.g., [1, 2, 3]). * `value`: An integer representing the value you need to make change for (e.g., 4). Output: * An integer representing the number of ways to make change for the given value using the provided coins. Constraints: * All elements of `coins` are positive integers. * 1 <= value <= 10^6 * 1 <= len(coins) <= 50 * 1 <= coin denominations <= 10^3 Performance Requirements: * Expected time complexity: O(n * m) where `n` is the value and `m` is the number of coins. * Expected space complexity: O(n) where `n` is the value. Example: ```python assert count_ways_to_make_change([1, 2, 3], 4) == 4 # [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] assert count_ways_to_make_change([2, 5, 3, 6], 10) == 5 # [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` Write your function `count_ways_to_make_change(coins, value)` below: ```python def count_ways_to_make_change(coins, value): # initialize dp array and set base case as 1 dp_array = [1] + [0] * value # fill dp in a bottom up manner for coin in coins: for i in range(coin, value + 1): dp_array[i] += dp_array[i - coin] return dp_array[value] ```","solution":"def count_ways_to_make_change(coins, value): Returns the number of distinct ways to make up the specified value using the given coins. # Initialize dp array and set base case as 1 way to make 0 value dp_array = [1] + [0] * value # Fill dp array in a bottom-up manner for coin in coins: for i in range(coin, value + 1): dp_array[i] += dp_array[i - coin] return dp_array[value]"},{"question":"# Question: You are tasked with implementing a simplified version of RSA encryption and decryption. The RSA algorithm involves creating a pair of keys: a public key (used for encryption) and a private key (used for decryption). For this task, you will need to: 1. Write a function to generate the RSA keys. 2. Implement functions to encrypt and decrypt data using these keys. Function Specifications: **Function 1: `generate_key(k, seed=None)`** - Input: - `k` - an integer representing the key size in bits. - `seed` - an optional integer seed for randomness (default is None). - Output: A tuple `(n, e, d)` where: - `n` is the modulus. - `e` is the encryption exponent. - `d` is the decryption exponent. **Function 2: `encrypt(data, e, n)`** - Input: - `data` - an integer representing the data to be encrypted. - `e` - the encryption exponent. - `n` - the modulus. - Output: An integer representing the encrypted data. **Function 3: `decrypt(data, d, n)`** - Input: - `data` - an integer representing the encrypted data. - `d` - the decryption exponent. - `n` - the modulus. - Output: An integer representing the decrypted data. Example Usage: ```python # Key generation n, e, d = generate_key(16) data = 20 # Encryption encrypted = encrypt(data, e, n) print(f\\"Encrypted Data: {encrypted}\\") # Decryption decrypted = decrypt(encrypted, d, n) print(f\\"Decrypted Data: {decrypted}\\") # Verify correctness assert decrypted == data ``` Constraints and Performance: - The key size `k` should be an integer >= 16. - Assume that `data` is a non-negative integer < `n`. - Efficiency in time complexity for encryption and decryption is critical. - Your implementation should handle edge cases and provide correct results without errors.","solution":"import random from sympy import isprime, mod_inverse from sympy.ntheory.generate import randprime def generate_key(k, seed=None): Generate RSA keys. Parameters: k (int): The key size in bits. seed (int): Optional seed for randomness (default is None). Returns: tuple: (n, e, d) where `n` is the modulus, `e` is the encryption exponent, and `d` is the decryption exponent. if seed is not None: random.seed(seed) # Ensure that the primes are of roughly equal size p = randprime(2**(k//2 - 1), 2**(k//2)) q = randprime(2**(k//2 - 1), 2**(k//2)) while p == q: q = randprime(2**(k//2 - 1), 2**(k//2)) n = p * q phi = (p - 1) * (q - 1) # Common choice for e is 65537 e = 65537 d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA encryption. Parameters: data (int): The data to be encrypted. e (int): The encryption exponent. n (int): The modulus. Returns: int: The encrypted data. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA decryption. Parameters: data (int): The encrypted data. d (int): The decryption exponent. n (int): The modulus. Returns: int: The decrypted data. return pow(data, d, n)"},{"question":"You are given an array `nums` that has been sorted in ascending order and then rotated at an unknown pivot. You are also given a target value `target`. Your task is to implement a function that searches for `target` in `nums`. If `target` is found, return its index. Otherwise, return -1. Your algorithm\'s runtime complexity must be in the order of `O(log n)`. # Function Signature ```python def search_in_rotated_array(nums: List[int], target: int) -> int: pass ``` # Input - `nums`: a list of integers, sorted in ascending order and then rotated. The list will have at least one element and no duplicates. `1 <= len(nums) <= 10^4`. - `target`: an integer value to search for in `nums`. # Output - Return the index of `target` if it is present in `nums`; otherwise, return -1. # Constraints - Your solution should have a time complexity of O(log n). - No duplicates exist in the array. # Example ```python assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == 4 assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == -1 assert search_in_rotated_array([1], 0) == -1 assert search_in_rotated_array([1, 3], 3) == 1 ``` # Explanation 1. In the first example: The array [4, 5, 6, 7, 0, 1, 2] is searched for the target value 0. The target is found at index 4. 2. In the second example, the target value 3 is not found in the array, so the function returns -1. 3. In the third example, the single element array [1] doesn\'t contain the target value 0, so the function returns -1. 4. In the fourth example, the array [1, 3] contains the target value 3 at index 1. # Notes - Focus on the efficient traversal of the array using a binary search modification to account for the rotation.","solution":"from typing import List def search_in_rotated_array(nums: List[int], target: int) -> int: Search for a target value in a rotated sorted array. Parameters: nums (List[int]): The rotated sorted array. target (int): The target value to search for. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine which part is sorted if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# AVL Tree Insertion and Balancing You have learned about AVL Trees, which are self-balancing binary search trees. Your task is to demonstrate your understanding by implementing the AVL Tree insertion function along with an in-order traversal function for testing purposes. Requirements: 1. **Insertion Function**: - Implement a method to insert a key into the AVL Tree. - Ensure the tree remains balanced after each insertion using rotations if necessary. 2. **In-order Traversal**: - Implement the in-order traversal method that returns the nodes\' keys in sorted order. Expected Input and Output Formats: * **Insert Function**: - **Input**: `insert(key: int)` where `key` is the integer to be inserted. * **In-order Traversal Function**: - **Output**: `in_order_traverse() -> List[int]` returns a list of node keys in sorted order. Constraints: - You need to handle edge cases such as inserting into an empty tree or rebalancing during insertion. - Assume there will be no duplicate keys inserted. Performance Requirements: - Ensure your implementation maintains the time complexity of O(log n) for insertion and guarantees in-order traversal of O(n). Sample Scenario: ```python # Sample usage avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) print(avl.in_order_traverse()) # Outputs: [10, 20, 30, 40, 50] ``` Your solution should reflect correct implementation of insertions involving necessary rotations to maintain AVL properties.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): # Perform the normal BST insertion if not root: return TreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) # Update the height of this ancestor node root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) # Get the balance factor balance = self.get_balance(root) # If the node becomes unbalanced, then there are four cases # Left Left Case if balance > 1 and key < root.left.key: return self.right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return self.left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) # return the (unchanged) node pointer return root def right_rotate(self, z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) # Return the new root return y def left_rotate(self, z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) # Return the new root return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def in_order_traverse(self, root): result = [] def traverse(node): if node: traverse(node.left) result.append(node.key) traverse(node.right) traverse(root) return result # Initialize the AvlTree class tree = AvlTree() root = None # Insert elements to the tree keys = [10, 20, 30, 40, 50] for key in keys: root = tree.insert(root, key)"},{"question":"# Topological Sort Implementation **Scenario**: You are working on a project management tool that helps plan and schedule tasks. Each task may depend on other tasks to be completed first. You need to determine a valid order to complete the tasks based on these dependencies. However, if there is a cyclic dependency (where a task indirectly depends on itself), it should be detected and flagged. **Task**: Implement a function `tasks_order` that takes a dictionary representing a directed acyclic graph (DAG) of tasks and their dependencies, and returns a list of tasks in a valid topological order. If a cycle is detected, your function should return `None`. **Function Signature**: ```python def tasks_order(graph: Dict[str, List[str]]) -> List[str]: ``` **Input**: * `graph`: a dictionary where each key is a string representing a task, and the corresponding value is a list of strings representing the tasks it depends on. **Output**: * A list of strings representing a valid topological order of tasks. * Return `None` if a cycle is detected. **Constraints**: * Node labels are unique. * The input graph does not necessarily have to include all tasks as keys if they do not have any dependencies. **Examples**: 1. Example 1: ```python graph = { \'A\': [\'C\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } Output: [\'D\', \'C\', \'A\', \'B\'] # Or any valid topological order ``` 2. Example 2: ```python graph = { \'A\': [\'C\'], \'B\': [\'C\'], \'C\': [\'A\'] } Output: None # Cycle detected ``` 3. Example 3: ```python graph = { \'A\': [], \'B\': [\'A\'], \'C\': [\'B\'], \'D\': [\'A\', \'C\'] } Output: [\'A\', \'B\', \'C\', \'D\'] # Or any valid topological order ``` Implementation of the function should utilize either the recursive or iterative DFS approach as provided in the analysis. Ensure correctness and handle all specified edge cases.","solution":"def tasks_order(graph): Returns a list of tasks in a valid topological order, or None if a cycle is detected. from collections import defaultdict, deque # Prepare a reverse (incoming edge count) graph incoming_edges = defaultdict(int) outgoing_edges = defaultdict(list) all_nodes = set(graph.keys()) for node, dependencies in graph.items(): for dep in dependencies: outgoing_edges[dep].append(node) incoming_edges[node] += 1 all_nodes.add(dep) # Queue for nodes with no incoming edges queue = deque([node for node in all_nodes if incoming_edges[node] == 0]) topological_order = [] while queue: current = queue.popleft() topological_order.append(current) for neighbor in outgoing_edges[current]: incoming_edges[neighbor] -= 1 if incoming_edges[neighbor] == 0: queue.append(neighbor) if len(topological_order) == len(all_nodes): return topological_order else: return None"},{"question":"# Cycle Sort Implementation and Analysis Cycle Sort is a permutation-based sorting algorithm that works by detecting and correcting cycles. Your task is to implement the Cycle Sort algorithm and ensure that it handles various edge cases effectively. The function to implement: ```python def cycle_sort(arr): Sorts an array in place using the Cycle Sort algorithm. Parameters: arr (list): A list of comparable elements. Returns: list: The sorted list. pass ``` # Explanation: 1. **Sorting Principle**: Each element is put directly into its correct position by calculating how many other elements should appear before it. 2. **Cycle Detection**: The elements are shifted until the cycle is fixed. 3. **Edge Cases**: Handle arrays with all identical elements, partial sorts, and reverse order. Input Format: - A single list `arr` consisting of integers. Each integer in `arr` is distinct. Output Format: - A list of integers sorted in ascending order. Example: ```python # Example 1 input: [3, 1, 4, 1, 5, 9] output: [1, 1, 3, 4, 5, 9] # Example 2 input: [10, 5, 3, 7, 8] output: [3, 5, 7, 8, 10] ``` # Constraints: - `1 <= len(arr) <= 1000` - The elements in the list will be a mix of positive and negative integers or zero. # Performance Requirements: - The solution must exhibit O(N^2) time complexity in its worst scenario regarding elements and cycles. - Operate in O(1) auxiliary space, modifying the input list in place. Implement the given function `cycle_sort(arr)` to execute the above requirements and properly integrate edge cases, performance guarantees, and correct the sorting cycles.","solution":"def cycle_sort(arr): Sorts an array in place using the Cycle Sort algorithm. Parameters: arr (list): A list of comparable elements. Returns: list: The sorted list. n = len(arr) for cycle_start in range(n - 1): item = arr[cycle_start] # Find where to place the item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue # To deal with duplicate elements while item == arr[pos]: pos += 1 # Swap the item to the right position arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Implement Stooge Sort You are tasked with implementing the Stooge Sort algorithm. Stooge Sort is a recursive sorting algorithm known for its inefficiency. Your goal is to complete the `stoogesort` function which sorts an input list in non-decreasing order using the principles of Stooge Sort. # Function Signature ```python def stoogesort(arr: list, l: int, h: int) -> None: ``` # Input and Output Formats * The function takes three arguments: * `arr`: a list of integers that needs to be sorted. * `l`: the starting index of the segment to be sorted. * `h`: the ending index of the segment to be sorted. * The function does not return anything; it should sort the list in place. # Constraints * `0 <= l <= h < len(arr) <= 1000` * The values in `arr` will be in the range `-10^6` to `10^6`. # Example ```python array = [5, 3, 2, 4, 1] n = len(array) stoogesort(array, 0, n-1) print(array) ``` Output: ``` [1, 2, 3, 4, 5] ``` # Performance Requirement While Stooge Sort has poor time complexity, ensure that your implementation adheres to the principles and works for the given constraints without running indefinitely. You can use the following template to get started: ```python def stoogesort(arr: list, l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) if __name__ == \\"__main__\\": array = [5, 3, 2, 4, 1] n = len(array) stoogesort(array, 0, n-1) print(array) ```","solution":"def stoogesort(arr: list, l: int, h: int) -> None: if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) if __name__ == \\"__main__\\": array = [5, 3, 2, 4, 1] n = len(array) stoogesort(array, 0, n-1) print(array)"},{"question":"# Word Break Sentence Count Challenge You are given a string `s` and a dictionary of words. Your task is to write a function that counts how many ways you can split the string into sequences of dictionary words. Function Signature ```python def count_sentences(s: str, dictionary: set) -> int: pass ``` Input - **s**: A non-empty string (1 ≤ `len(s)` ≤ 1000). - **dictionary**: A non-empty set of words (1 ≤ `len(dictionary)` ≤ 300). Output - Return an integer representing the number of ways to split the string into sequences of dictionary words. Example ```python assert count_sentences(\\"applet\\", {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"}) == 3 assert count_sentences(\\"thing\\", {\\"thing\\"}) == 1 assert count_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\"}) == 1 ``` Constraints - Assume all words in the dictionary and the string are lowercase. Performance Requirements - Your solution should aim to handle all situations efficiently, including the upper bounds of the input sizes.","solution":"def count_sentences(s: str, dictionary: set) -> int: n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i): if s[j:i] in dictionary: dp[i] += dp[j] return dp[n]"},{"question":"Given a list of distinct integers `nums`, write a function `generate_subsets(nums: List[int]) -> Set[Tuple[int]]` that returns all possible subsets of the list. The solution should not contain duplicate subsets, and the output format should be a set of tuples, each tuple representing a subset. # Input Format * A list of distinct integers, `nums`. # Output Format * A set of tuples, where each tuple represents a subset of `nums`. # Constraints * `0 <= len(nums) <= 20` * The integers in `nums` are unique. # Performance Requirements * The solution must generate all subsets and have a time complexity of O(n * 2^n). # Example ```python Input: nums = [1,2,3] Output: {(), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,)} ``` Hints: 1. Think about using bitwise operations to represent the inclusion or exclusion of an element. 2. Explore how you can represent each subset as a binary number where each bit signifies whether to include an element or not. Write your implementation in the following function: ```python def generate_subsets(nums): # Your code here ```","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generate all possible subsets of a list of distinct integers. Args: nums (List[int]): A list of distinct integers. Returns: Set[Tuple[int]]: A set containing all possible subsets as tuples. subsets = set() n = len(nums) for i in range(2**n): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(subset)) return subsets"},{"question":"# Matrix Rotation Coding Question You are given an `n x n` 2D matrix `mat` representing an image. Your task is to write a function `rotate_in_place(mat)` that rotates the image by 90 degrees clockwise in-place. Ensure that your solution is efficient both in terms of time and space complexity. Input * `mat`: An `n x n` list of lists where each sublist represents a row of the matrix. Output The function should modify the input matrix to rotate it by 90 degrees clockwise. No value should be returned. Constraints * The function must operate in-place, modifying the input matrix directly. * You may assume that `mat` is a square matrix (i.e., the number of rows and columns are the same). Example ```python # Example Input mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_in_place(mat) # Example Output # The matrix after rotation should look like: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Note: - Make sure to handle edge cases, such as an empty matrix or a 1x1 matrix. - Consider the performance of your solution in terms of time and space complexity.","solution":"def rotate_in_place(mat): Rotates an n x n matrix 90 degrees clockwise in place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"Scenario You are working at a company that handles a lot of encrypted messages. Due to the nature of some encryption algorithms, it is necessary to determine if one encrypted message is just a rotation of another original message. This step is crucial to ensure the integrity of the encryption process. Problem Given two strings `original` and `encrypted`, write a function `is_rotated_version(original, encrypted)` that determines if `encrypted` is a rotated version of `original`. Function Signature ```python def is_rotated_version(original: str, encrypted: str) -> bool: pass ``` Input * `original` (string): The original string. * `encrypted` (string): The string that might be a rotated version of `original`. Output * Return `True` if `encrypted` is a rotated version of `original`, otherwise return `False`. Constraints * The lengths of the strings are always non-negative integers. * Assume that the strings will contain only lowercase letters and may include empty strings. Performance Requirements * The solution should have a time complexity of O(N), where N is the length of the strings. Examples 1. `is_rotated_version(\\"hello\\", \\"llohe\\")` should return `True`. 2. `is_rotated_version(\\"hello\\", \\"helol\\")` should return `False`. 3. `is_rotated_version(\\"abc\\", \\"cab\\")` should return `True`. 4. `is_rotated_version(\\"abc\\", \\"acb\\")` should return `False`. 5. `is_rotated_version(\\"\\", \\"\\")` should return `True`. 6. `is_rotated_version(\\"a\\", \\"a\\")` should return `True`. Note The function must handle edge cases effectively, such as when the strings are of different lengths or empty. Efficient string manipulation techniques should be employed to meet the performance requirements.","solution":"def is_rotated_version(original: str, encrypted: str) -> bool: Determines if \'encrypted\' is a rotated version of \'original\'. Args: original (str): The original string. encrypted (str): The string that might be a rotated version of \'original\'. Returns: bool: True if \'encrypted\' is a rotated version of \'original\', False otherwise. if len(original) != len(encrypted): return False # Concatenate the original string with itself doubled_original = original + original return encrypted in doubled_original"},{"question":"Context A software company needs an efficient system to manage task priorities in the order they should be executed. They have decided to use a Min Heap to implement their priority queue. Problem Statement Implement a Min Heap data structure with the following functionalities: 1. **Insert** a new priority into the heap. 2. **RemoveMin** to extract the minimum priority from the heap. 3. Provide methods to get the current minimum without removing it, and to check if the heap is empty. Task Create a class named `MinHeap` with the following methods: 1. `__init__(self)`: Initialize the heap with an empty list. 2. `insert(self, val: int) -> None`: Insert a new integer value `val` into the heap. 3. `remove_min(self) -> int`: Remove and return the minimum value from the heap. If the heap is empty, return `None`. 4. `get_min(self) -> int`: Return the minimum value without removing it. If the heap is empty, return `None`. 5. `is_empty(self) -> bool`: Return `True` if the heap is empty, otherwise `False`. Input/Output Formats * **insert(val: int)**: * **Input**: An integer `val` to insert. * **Output**: None. * **remove_min()**: * **Input**: None. * **Output**: The minimum value from the heap or `None` if the heap is empty. * **get_min()**: * **Input**: None. * **Output**: The minimum value without removing it or `None` if the heap is empty. * **is_empty()**: * **Input**: None. * **Output**: `True` if the heap is empty, otherwise `False`. Constraints * Ensure time complexity of O(log N) for both `insert` and `remove_min` operations. * Handle edge cases such as inserting into an empty heap and removing the last element. # Implementation ```python class MinHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] # Initialize heap with a placeholder - heap index starts at 1. def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i//2] = self.heap[i//2], self.heap[i] i = i // 2 def insert(self, val: int) -> None: self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_down(self, i): while 2 * i <= self.current_size: min_child = self.min_child(i) if self.heap[min_child] < self.heap[i]: self.heap[min_child], self.heap[i] = self.heap[i], self.heap[min_child] i = min_child def min_child(self, i): if 2 * i + 1 > self.current_size: return 2 * i if self.heap[2 * i] > self.heap[2 * i + 1]: return 2 * i + 1 else: return 2 * i def remove_min(self) -> int: if self.is_empty(): return None min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val def get_min(self) -> int: if self.is_empty(): return None return self.heap[1] def is_empty(self) -> bool: return self.current_size == 0 # You can use below sample testcase to validate the implementation # heap = MinHeap() # heap.insert(10) # heap.insert(5) # print(heap.get_min()) # Should return 5 # print(heap.remove_min()) # Should return 5 # print(heap.remove_min()) # Should return 10 # print(heap.remove_min()) # Should return None ```","solution":"class MinHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] # Placeholder to ensure 1-based index. def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val: int) -> None: self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def perc_down(self, i): while i * 2 <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def remove_min(self) -> int: if self.is_empty(): return None root = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return root def get_min(self) -> int: if self.is_empty(): return None return self.heap[1] def is_empty(self) -> bool: return self.current_size == 0"},{"question":"Given an array of integers `nums`, where every element appears exactly three times except for one element which appears exactly once, write a function `find_single_element` to identify that single element. Input Format - An array of integers, `nums`, with at least 4 elements (the smallest possible valid input will have 4 elements: three being the same and one unique). Output Format - Return the single integer that appears exactly once. Constraints - You must achieve an O(n) time complexity. - You should not use extra memory beyond O(1) additional variables. Function Signature ```python def find_single_element(nums: List[int]) -> int: pass ``` # Example ```python assert find_single_element([2, 2, 3, 2]) == 3 assert find_single_element([0, 1, 0, 1, 0, 1, 99]) == 99 assert find_single_element([-2, -2, 1, -2]) == 1 ``` # Explanation - In the first example, the number `3` is the only number that does not appear thrice. - In the second example, `99` is unique. - In the third example, `1` appears once while `-2` appears three times. Implement the function in a way that efficiently uses bitwise operations without using extra space.","solution":"from typing import List def find_single_element(nums: List[int]) -> int: Given an array of integers `nums`, where every element appears exactly three times except for one element which appears exactly once, this function finds that single element. ones = twos = 0 for num in nums: # `twos` holds those numbers which have appeared twice so far twos |= ones & num # `ones` holds those numbers which have appeared once so far ones ^= num # The common_mask holds those numbers which have appeared three times common_mask = ~(ones & twos) # If `num` has appeared three times, remove it from `ones` and `twos` ones &= common_mask twos &= common_mask return ones"},{"question":"You\'re given a stack containing integers. Your task is to write a function `remove_min` that removes the smallest element from the stack while maintaining the order of the remaining elements. **Function Signature**: `def remove_min(stack: List[int]) -> List[int]:` Input - A list named `stack` representing the stack, where the first element corresponds to the bottom of the stack, and the last element corresponds to the top. Output - The function should return the stack with the smallest element removed. Constraints - The given list will only contain integers. - If multiple elements have the same minimum value, only remove one instance of that value. - If the input stack is empty, the function should return the stack as is. Scenario Consider you are working on an optimization task within a game environment where the player’s stack of scores needs frequent removal of the lowest score. Your task is to implement this function efficiently to ensure that the game continues to perform optimally. # Example: ```python # Example: # Input: stack = [2, 8, 3, -6, 7, 3] # Output: [2, 8, 3, 7, 3] # Example: # Input: stack = [5, 1, 4, 1, 2] # Output: [5, 4, 1, 2] ``` **Note**: - The function should preserve the order of the remaining elements. **Performance note**: - Aim to achieve a solution with O(n) time complexity and O(n) space complexity. Good luck and happy coding!","solution":"from typing import List def remove_min(stack: List[int]) -> List[int]: if not stack: return stack min_value = min(stack) min_index = stack.index(min_value) # Remove the element at min_index return stack[:min_index] + stack[min_index + 1:]"},{"question":"# Topological Sorting with a Twist Suppose you are working on a project management software that needs to schedule tasks based on their dependencies. You need to implement a function that takes a directed graph of tasks (represented as a dictionary) and returns a viable order of tasks such that all dependencies are met. # Context You are given a directed acyclic graph (DAG) `tasks` where each key is a task, and the value is a list of tasks it depends on. Your goal is to write a function that returns one of the possible valid orderings of tasks. If the graph contains a cycle, return an empty list. # Function Signature ```python def order_tasks(tasks: Dict[Any, List[Any]]) -> List[Any]: pass ``` # Input and Output - **Input**: * `tasks`: A dictionary representing the directed acyclic graph. The keys are tasks (which can be any hashable type), and the values are lists of tasks it depends on. - **Output**: * A list representing a valid topological sort of the tasks. If a cycle is detected, return an empty list. # Constraints - The graph has at least one node. - If a task has no dependencies, its value will be an empty list. - All tasks and dependencies are unique. - The number of tasks will not exceed 10^4. # Example ```python tasks = { \'a\': [\'b\', \'c\'], \'b\': [\'d\'], \'c\': [\'d\'], \'d\': [] } print(order_tasks(tasks)) # Output could be [\'d\', \'b\', \'c\', \'a\'] or [\'d\', \'c\', \'b\', \'a\'] ``` # Performance Requirements - The solution should run in O(V + E) time complexity. # Hints * You may utilize depth-first search to detect cycles and determine the order of tasks. * Use a stack or an additional data structure to keep track of the current path of DFS to detect cycles.","solution":"def order_tasks(tasks): Returns a valid topological order of tasks based on their dependencies. If there is a cycle, returns an empty list. from collections import defaultdict, deque # Step 1: Create a graph and calculate in-degrees of each node graph = defaultdict(list) in_degree = defaultdict(int) for task, dependencies in tasks.items(): if task not in in_degree: in_degree[task] = 0 for dep in dependencies: graph[dep].append(task) in_degree[task] += 1 # Step 2: Initialize queue with nodes that have zero in-degree queue = deque([task for task in in_degree if in_degree[task] == 0]) # Step 3: Kahn\'s algorithm for topological sorting order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Step 4: Check if topological sort is possible (no cycles) if len(order) != len(tasks): return [] return order"},{"question":"# Scenario: You are working on optimizing a system that requires frequent evaluation of the number of \'1\' bits in binary representations of numbers. This is crucial for tasks such as cryptographic compute units and error-checking routines. To test your understanding of Brian Kernighan\'s algorithm, you need to implement a function that counts the number of set bits (Hamming weight) in an integer. # Task: Implement a function that takes an unsigned integer and returns the number of \'1\' bits in its binary representation using Brian Kernighan\'s Algorithm. # Function Signature: ```python def hamming_weight(n: int) -> int: pass ``` # Input: * An unsigned integer `n` (0 ≤ n ≤ 2^31 - 1). # Output: * An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints: * Your solution should have a time complexity of O(k) where k is the number of \'1\'s in the binary representation of the input integer. * Your solution should aim to be efficient in both time and space. # Example: ```python hamming_weight(11) # returns 3 hamming_weight(128) # returns 1 hamming_weight(0) # returns 0 ``` # Note: - For the input `11`, the binary representation is `1011`, which has three `1` bits. # Requirements: - Implement both the iterative and recursive approach to count the number of set bits. - Validate the performance of both approaches through test cases, especially evaluating the handling of edge cases like `0` and maximum possible integer.","solution":"def hamming_weight(n: int) -> int: Returns the number of \'1\' bits (Hamming weight) in the binary representation of n. Uses Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Context You are given a dataset that needs to be sorted for further processing. Using your understanding of basic sorting algorithms, you need to implement a simple sorting technique. # Task Implement a function `exchange_sort()` that sorts an array of integers in ascending order using the exchange sort algorithm. Requirements - Your implementation should return a sorted list in ascending order. - You are expected to handle edge cases such as empty arrays and arrays with duplicate elements. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` # Input - A single list of integers `arr` (0 ≤ length of arr ≤ 1000, -10^6 ≤ elements of arr ≤ 10^6) # Output - A list containing the sorted integers in ascending order. # Examples 1. Input: `[34, 7, 23, 32, 5, 62]` Output: `[5, 7, 23, 32, 34, 62]` 2. Input: `[3, 3, 2, 1, 1]` Output: `[1, 1, 2, 3, 3]` 3. Input: `[]` Output: `[]` 4. Input: `[10, -1, 0, 100, 99]` Output: `[-1, 0, 10, 99, 100]` **Constraints/Limitations**: Use only the exchange sort technique to solve this problem. Consider edge cases and optimize where possible given the constraints.","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Perform exchange sort on the input list of integers. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Scenario In computational problems that require checking if certain resources are power-of-two sized, an efficient check can significantly reduce overhead. This is particularly useful in graphics programming and memory allocation where power-of-two constraints are common. # Problem Description Write a function to determine if a given integer is a power of two. Your implementation should efficiently check this condition using bitwise operations. # Function Signature ```python def is_power_of_two(n: int) -> bool: :param n: An integer to check :return: True if \'n\' is a power of two, otherwise False. ``` # Input - A single integer `n`. # Output - Return `True` if `n` is a power of two, otherwise return `False`. # Constraints - You must use bitwise operations. - Performance: The solution should run in O(1) time complexity. # Example ```plaintext Input: 16 Output: True Input: 18 Output: False Input: 1 Output: True Input: 0 Output: False ``` # Note - Powers of two include numbers like 1, 2, 4, 8, 16, 32, etc. - Negative numbers and zero should return `False`.","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer is a power of two. :param n: An integer to check. :return: True if \'n\' is a power of two, otherwise False. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"Context: Shell Sort is a classic comparison-based sorting algorithm derived from insertion sort by extending the gap between compared elements. In this task, you\'re required to implement a modified version of Shell Sort with a Sedgewick gap sequence, which is known to enhance its performance. Task: Implement a function `sedgewick_shell_sort(arr: List[int]) -> List[int]` in Python that sorts an array of integers using Shell Sort with the Sedgewick gap sequence. Gap Sequence: Use the Sedgewick gap sequence defined as: * h(i) = 4^i + 3*2^(i-1) + 1 where **i** is the iteration index. * Generate the gap sequence until the gaps are smaller than the length of the array. Input: A list of integers `arr` containing up to 10^6 elements. Output: A sorted list of integers. Constraints: 1. The elements of the array are within the range of [-10^6, 10^6]. 2. Optimize for time and space efficiency. Example: ```python assert sedgewick_shell_sort([23, 12, 1, 8, 34, 15, 26]) == [1, 8, 12, 15, 23, 26, 34] assert sedgewick_shell_sort([]) == [] assert sedgewick_shell_sort([5, -3, 5, 10, 0, 8, -5]) == [-5, -3, 0, 5, 5, 8, 10] ```","solution":"def sedgewick_shell_sort(arr): def generate_sedgewick_gaps(n): gaps = [] k = 0 while True: gap = 4**k + 3 * 2**(k - 1) + 1 if k > 0 else 1 if gap > n: break gaps.append(gap) k += 1 gaps.reverse() return gaps n = len(arr) gaps = generate_sedgewick_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Question: Implement and Analyze Exchange Sort # Context You are given the task to sort student scores stored in an array to determine the rank of each student. While modern systems use optimized sorting algorithms, for educational purposes, you are to implement a simpler and more intuitive method called Exchange Sort. # Task Write a function `exchange_sort` that takes an array of integers and sorts it in ascending order using the Exchange Sort algorithm. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: # Your implementation here ``` # Input - An array of integers `arr` where `1 <= len(arr) <= 10^3` and `-10^3 <= arr[i] <= 10^3`. # Output - The input array sorted in ascending order. # Constraints - You must implement the Exchange Sort algorithm as described. - Do not use Python\'s built-in sorting functions. # Performance - The function should run with a time complexity of O(n^2) and space complexity of O(1). # Example Example 1 **Input**: ```python arr = [64, 34, 25, 12, 22, 11, 90] ``` **Output**: ```python [11, 12, 22, 25, 34, 64, 90] ``` Example 2 **Input**: ```python arr = [3, -2, -1, 5, 0] ``` **Output**: ```python [-2, -1, 0, 3, 5] ``` # Edge Cases 1. An already sorted array. 2. Arrays with negative numbers. 3. Arrays with all identical elements. 4. Empty array or an array with a single element. # Note - Pay special attention to edge cases to ensure your function handles all possible scenarios. - Comments explaining your logic are appreciated for better understanding. Happy coding!","solution":"def exchange_sort(arr): Sorts an array of integers in ascending order using Exchange Sort algorithm. :param arr: List of integers :return: Sorted list of integers n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Implement a function for ternary search that locates the index of a target element within a given sorted array of integers. The function should also handle typical edge cases robustly and conform to optimal space and time complexities as expected. # Function Signature: ```python def ternary_search(arr: List[int], key: int) -> int: pass ``` # Input: - `arr`: A List of integers (1 ≤ length of arr ≤ 10^6), sorted in non-decreasing order. - `key`: An integer value to be searched in the array. # Output: - An integer representing the index of the `key` in the array if it exists; otherwise, return `-1`. # Constraints: - The array `arr` is non-empty and sorted. - Invalid or edge inputs should be handled gracefully and incorporated into your testing. # Requirements: 1. Do not use any built-in search functions. 2. Ensure O(log3(N)) time complexity with O(1) space complexity. # Example: ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 5 # Should return 4: because arr[4] == 5 print(ternary_search(arr, key)) # Example 2 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] key = 10 # Should return -1: because 10 is not in the list print(ternary_search(arr, key)) # Example 3 arr = [2, 4, 6, 8, 10, 12, 14] key = 14 # Should return 6: because arr[6] == 14 print(ternary_search(arr, key)) ``` # Notes: - You should consider explicit and implicit constraints especially if arr size is large. - Ensure to handle duplicate elements by returning the first occurrence if duplicates exist.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: def search(l, r, key): if l > r: return -1 third = (r - l) // 3 mid1 = l + third mid2 = r - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return search(l, mid1 - 1, key) elif key > arr[mid2]: return search(mid2 + 1, r, key) else: return search(mid1 + 1, mid2 - 1, key) return search(0, len(arr) - 1, key)"},{"question":"You are given a list of integers that you need to sort in non-decreasing order using the selection sort algorithm. Your task is to implement the sorting function, and you are also required to simulate and print the array after each iteration of the outer loop. The function should have the following signature: ```python def selection_sort(arr): # arr: List[int] -> The list of integers to be sorted. # Returns: List[int] -> The sorted list. ``` # Input/Output Format * **Input**: A list of integers, `arr`. * **Output**: The sorted list of integers, printed step-by-step during the sorting process. # Constraints * `0 <= len(arr) <= 1000` * `-10^6 <= arr[i] <= 10^6` for each `0 <= i < len(arr)` # Example ```python # Input arr = [64, 25, 12, 22, 11] # Expected Output: # iteration 0 : 64 25 12 22 11 # iteration 1 : 11 25 12 22 64 # iteration 2 : 11 12 25 22 64 # iteration 3 : 11 12 22 25 64 # iteration 4 : 11 12 22 25 64 # Final output: [11, 12, 22, 25, 64] ``` # Guidelines 1. You must use the selection sort algorithm. 2. Print the array after each full pass of the outer loop. 3. Your implementation should be efficient in terms of space usage and utilize an in-place sorting mechanism. # Note You do not need to handle input/output via standard I/O functions; just ensure the function processes the input as specified and returns the output correctly.","solution":"def selection_sort(arr): Sorts a list of integers in non-decreasing order using the selection sort algorithm. Prints the array after each iteration of the outer loop. :param arr: List[int] -> The list of integers to be sorted. :return: List[int] -> The sorted list. n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] # Print current state of array after each iteration of the outer loop print(f\\"iteration {i} :\\", \' \'.join(map(str, arr))) return arr"},{"question":"# Question You have been assigned to optimize the substring search within a larger string. Your task is to implement a function that efficiently searches for the first occurrence of a substring (needle) within another string (haystack). You are required to use an optimized algorithm such as Knuth-Morris-Pratt (KMP) or Boyer-Moore to achieve this. Requirements * **Function Name**: `optimized_strStr` * **Input**: * `haystack` : A string, the larger string in which to search for the substring. * `needle` : A string, the substring to search for within the haystack. * **Output**: An integer representing the index of the first occurrence of the needle in the haystack, or -1 if the needle is not part of the haystack. * **Constraints**: * `0 <= haystack.length, needle.length <= 10^4` * `needle` can be an empty string, which should return 0. Performance Requirements * Your solution should aim for time complexity better than O(n*m) and should ideally approach O(n + m). # Example ```plaintext Example 1: Input: haystack = \\"hello\\", needle = \\"ll\\" Output: 2 Example 2: Input: haystack = \\"aaaaa\\", needle = \\"bba\\" Output: -1 Example 3: Input: haystack = \\"mississippi\\", needle = \\"issip\\" Output: 4 Example 4: Input: haystack = \\"\\", needle = \\"\\" Output: 0 Example 5: Input: haystack = \\"a\\", needle = \\"\\" Output: 0 ``` Additional Information - Implement the function using KMP or Boyer-Moore algorithm for optimal efficiency. - Ensure your solution handles all edge cases appropriately. ```python def optimized_strStr(haystack, needle): # Implementation of KMP or Boyer-Moore algorithm here pass ```","solution":"def optimized_strStr(haystack, needle): Implements the Knuth-Morris-Pratt (KMP) algorithm to search for the first occurrence of a substring (needle) within another string (haystack). def compute_lps(needle): Compute the longest prefix which is also suffix array (LPS array) for the needle. lps = [0] * len(needle) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(needle): if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not needle: return 0 if not haystack or len(needle) > len(haystack): return -1 lps = compute_lps(needle) i = j = 0 # indexes for haystack and needle while i < len(haystack): if haystack[i] == needle[j]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and haystack[i] != needle[j]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"# Scenario Tom is developing a logistics application that deals with scheduling and task prioritization. To optimize the task execution order, he needs to implement a sorting system using the heap sort algorithm. Tom has access to both max-heap and min-heap sort versions, but he needs a function that determines the kth smallest element in an unsorted array using heap sort principles. # Objective Your task is to write a function `find_kth_smallest` that uses heap sort to find the kth smallest element in an unsorted array. # Function Signature ```python def find_kth_smallest(arr: List[int], k: int) -> int: ``` # Inputs * `arr` (List[int]): The list of integers to be sorted. * `k` (int): The index of the smallest element to find (1-based index). # Outputs * Returns the kth smallest element in the list. # Constraints * 1 ≤ len(arr) ≤ 10^5 * -10^9 ≤ arr[i] ≤ 10^9 * 1 ≤ k ≤ len(arr) # Performance Requirements * The function should run in O(n log n) time complexity. # Example ```python assert find_kth_smallest([3, 2, 1, 5, 6, 4], 2) == 2 assert find_kth_smallest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 3 ``` _hint: Utilize the min-heap sort provided in the code snippets as part of your solution._","solution":"import heapq from typing import List def find_kth_smallest(arr: List[int], k: int) -> int: Returns the kth smallest element in an array using heap sort principles. # Convert the array into a min-heap heapq.heapify(arr) # Extract the smallest element k-1 times for _ in range(k - 1): heapq.heappop(arr) # The k-th smallest element will be at the root of the heap return heapq.heappop(arr)"},{"question":"# Question: Letter Combinations of a Phone Number **Concept**: Combination Generation using iterative backtracking approach. Context: You have a telephone keypad which can be used to type messages, as seen on classic mobile phones. Each digit corresponds to certain characters as shown below: | Digit | Characters | |-------|-------------| | 2 | `abc` | | 3 | `def` | | 4 | `ghi` | | 5 | `jkl` | | 6 | `mno` | | 7 | `pqrs` | | 8 | `tuv` | | 9 | `wxyz` | Given a string containing digits from `2` to `9`, return all possible letter combinations that the number could represent. Input and Output: * **Input**: A string `digits`, consisting of numerical characters between `2` and `9`. * **Output**: A list of all possible letter combinations. Constraints: * The input string will have a length between 0 and 4. * The \'digits\' string contains only digits from 2 to 9. Example: ```plaintext Input: \\"23\\" Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` # Task: Implement the function `letter_combinations(digits)` that receives the `digits` string and returns all the corresponding letter combinations. ```python def letter_combinations(digits): # implementation here # Example Usage print(letter_combinations(\\"23\\")) # should print [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` Requirements and Notes: * Avoid using external libraries. * Ensure to handle edge cases, for example when the input is empty. * Aim to achieve optimal runtime and manage memory efficiently. * Test thoroughly with various input scenarios.","solution":"def letter_combinations(digits): Given a string containing digits from `2` to `9`, return all possible letter combinations that the number could represent as indicated by a classic mobile phone keypad. if not digits: return [] phone_map = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = phone_map[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations # Example usage print(letter_combinations(\\"23\\")) # should print [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"]"},{"question":"You are tasked with implementing an `Interval` class and additional functionality to handle merging a list of numerical intervals. Intervals are defined as having a start and an end point, representing an inclusive range of numbers. The intervals may contain overlapping sections, and your goal is to merge these sections to produce a list of non-overlapping intervals. Additionally, you need to provide utility methods to check if a specific number lies within any given interval and to represent intervals as lists. Requirements: 1. **Interval Class Implementation**: - Implement the `Interval` class with attributes `start` and `end`. - Provide methods: - `__repr__()`: Returns string representation. - `__iter__()`: Enables iteration over the range. - `__getitem__()`: Accesses specific elements in the interval. - `__len__()`: Returns the length of the interval. - `__contains__()`: Checks if a number is within the interval. - `__eq__()`: Checks equality between two intervals. - `as_list()`: Converts interval to a list. 2. **Static Methods for Merging**: - `merge(intervals: List[Interval]) -> List[Interval]`: Merges a list of `Interval` objects into non-overlapping intervals. - `print_intervals(intervals: List[Interval])`: Prints out string representations of intervals. 3. **Inline Function**: - `merge_intervals(intervals: List[List[int]]) -> List[List[int]]`: Merges a list of interval lists into non-overlapping intervals and returns as a list of interval lists. Input: - A list of intervals provided as a list of `Interval` objects or a list of interval lists. Output: - Merged non-overlapping intervals as a list of `Interval` objects or a list of interval lists, respectively. Constraints: - `-10^6 <= start, end <= 10^6` - The number of intervals `n` does not exceed `10^5`. # Example: ```python intervals_list = [[1, 3], [2, 6], [8, 10], [15, 18]] merged = merge_intervals(intervals_list) print(merged) # Output: [[1, 6], [8, 10], [15, 18]] interval_objs = [Interval(1, 3), Interval(2, 6), Interval(8, 10), Interval(15, 18)] merged_intervals = Interval.merge(interval_objs) Interval.print_intervals(merged_intervals) # Output: Interval (1, 6), Interval (8, 10), Interval (15, 18) ``` Create an interval merging solution based on the above criteria and ensure efficient time complexity with correct handling of edge cases.","solution":"from typing import List class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def __repr__(self): return f\'Interval({self.start}, {self.end})\' def __iter__(self): return iter(range(self.start, self.end + 1)) def __getitem__(self, idx): if idx < 0 or idx >= len(self): raise IndexError(\\"Index out of range\\") return self.start + idx def __len__(self): return self.end - self.start + 1 def __contains__(self, item): return self.start <= item <= self.end def __eq__(self, other): return self.start == other.start and self.end == other.end def as_list(self): return list(self) @staticmethod def merge(intervals: List[\'Interval\']) -> List[\'Interval\']: if not intervals: return [] # Sort intervals by start time intervals.sort(key=lambda x: x.start) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current.start <= last_merged.end: # Overlapping intervals, merge them last_merged.end = max(last_merged.end, current.end) else: merged.append(current) return merged @staticmethod def print_intervals(intervals: List[\'Interval\']): for interval in intervals: print(interval) def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: if not intervals: return [] # Convert list of lists to list of Interval objects interval_objs = [Interval(start, end) for start, end in intervals] # Merge the intervals using the Interval class method merged_objs = Interval.merge(interval_objs) # Convert back the merged Interval objects to list of lists return [[interval.start, interval.end] for interval in merged_objs]"},{"question":"# Problem: Transforming Strings You are given two strings, `original` and `target`. Your task is to write a function `min_operations` that computes the minimum number of operations required to transform the string `original` into the string `target`. The allowable operations are insertion, deletion, and substitution of characters. # Function Signature ```python def min_operations(original: str, target: str) -> int: pass ``` # Input * `original` (str): The original string of length `m` (1 <= m <= 1000). * `target` (str): The target string of length `n` (1 <= n <= 1000). # Output * `int`: The minimum number of operations required to transform `original` into `target`. # Constraints * The function must run in O(m * n) time complexity. * The function should have a space complexity of O(m * n). # Example ```python # Example 1 original = \\"intention\\" target = \\"execution\\" assert min_operations(original, target) == 5 # Example 2 original = \\"kitten\\" target = \\"sitting\\" assert min_operations(original, target) == 3 ``` # Hints 1. Use a 2D array to store the minimum operations needed for each substring comparison. 2. Initialize the first row and column based on the cost of inserting and deleting characters to reach an empty substring. 3. Use dynamic programming to fill in the rest of the table, choosing the minimum operation among insertion, deletion, and substitution for each step.","solution":"def min_operations(original: str, target: str) -> int: m = len(original) n = len(target) # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, the only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, the only option is to # remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore last char # and recur for the remaining substring elif original[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character are different, consider all # possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"Scenario: You have been hired as a network engineer for a telecommunications company. Your task is to analyze the current network to determine how efficiently data flows from the data center (source) to the main server hub (sink) using the given graph. Problem Statement: Write a function `maximum_flow` to compute the maximum flow in a given flow network using the adjacency matrix representation. The flow network is represented as a 2D list where `graph[u][v]` indicates the capacity from node `u` to node `v`. Function Signature: ```python def maximum_flow(graph: List[List[int]]) -> int: ``` Input: * `graph`: A 2D list of integers representing the flow network. `graph[i][j]` is the capacity from node `i` to node `j`. The graph will contain `n` nodes where `1 <= n <= 100`. Output: * Returns an integer representing the maximum flow from the source node (index 0) to the sink node (index n-1). Constraints: * The capacities are non-negative integers. * The graph is connected, meaning there\'s at least one path from the source to the sink. Example: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow(graph) == 23 ``` Guidelines: * You must use the BFS approach to find augmenting paths. * Handle edge cases such as graphs with no path from source to sink. * Maintain clarity and efficiency in your solution. Ensure your code is well-documented.","solution":"from typing import List from collections import deque def bfs(residual_graph: List[List[int]], source: int, sink: int, parent: List[int]) -> bool: BFS to find a path from source to sink in the residual graph. Updates parent[] to store the path. Returns True if there is a path from source to sink, False otherwise. visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(residual_graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def maximum_flow(graph: List[List[int]]) -> int: Computes the maximum flow in the given flow network. n = len(graph) source = 0 sink = n - 1 residual_graph = [row[:] for row in graph] parent = [-1] * n max_flow = 0 while bfs(residual_graph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # Update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Scenario Alice and Bob wish to establish a secure communication channel using the Diffie-Hellman key exchange. You will write Python functions to automate this process. # Objective Implement the complete Diffie-Hellman key exchange algorithm, ensuring all aspects such as primality checks and primitive root verification are correctly handled. # Requirements 1. **Function 1: `is_prime(n: int) -> bool`** - Input: An integer `n` - Output: Returns `True` if `n` is prime, otherwise `False` 2. **Function 2: `find_primitive_root(n: int) -> list`** - Input: An integer `n` - Output: Returns a list of all primitive roots of `n` 3. **Function 3: `diffie_hellman_key_exchange(a: int, p: int) -> bool`** - Input: Two integers `a` (primitive root) and `p` (prime number) - Output: Prints the public and private keys of Alice and Bob and their shared key. Returns `True` if keys match, and `False` otherwise. # Input Constraints - `1 <= a < p` - `a` should be a primitive root of `p` - `p` should be a prime number # Example ```python assert is_prime(23) == True assert find_primitive_root(23) == [5, 7, 10, 11, 14, 15, 17, 19, 20, 21] assert diffie_hellman_key_exchange(5, 23) == True ``` # Notes - Handle invalid inputs appropriately by raising errors or returning specific false values as detailed in the original function implementations. - Ensure the functions are efficient given the constraints on prime number size.","solution":"from math import gcd def is_prime(n): Check if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): Find all primitive roots of a prime p. if not is_prime(p): raise ValueError(f\\"{p} is not a prime number\\") required_set = {num for num in range(1, p) if gcd(num, p) == 1} roots = [] for g in range(1, p): actual_set = {pow(g, powers, p) for powers in range(1, p)} if required_set == actual_set: roots.append(g) return roots def diffie_hellman_key_exchange(a, p): Perform the Diffie-Hellman key exchange algorithm. from random import randint if not is_prime(p): raise ValueError(f\\"{p} is not prime\\") if a not in find_primitive_root(p): raise ValueError(f\\"{a} is not a primitive root of {p}\\") # Alice\'s private key alice_private = randint(1, p-2) alice_public = pow(a, alice_private, p) # Bob\'s private key bob_private = randint(1, p-2) bob_public = pow(a, bob_private, p) # Shared secret key alice_shared = pow(bob_public, alice_private, p) bob_shared = pow(alice_public, bob_private, p) print(f\\"Alice\'s Public Key: {alice_public}\\") print(f\\"Bob\'s Public Key: {bob_public}\\") print(f\\"Alice\'s Shared Key: {alice_shared}\\") print(f\\"Bob\'s Shared Key: {bob_shared}\\") return alice_shared == bob_shared"},{"question":"Unique Binary Search Trees Scenario You are developing a module for an educational platform that helps students understand the number of ways binary search trees can be structured given a set of distinct values. Your task is to implement a function that calculates the number of unique binary search trees that can be created using values from 1 to n. Task Write a function `num_trees(n: int) -> int` that calculates the number of structurally unique binary search trees (BSTs) that can be constructed using the values from 1 to n. Input - An integer `n` (0 ≤ n ≤ 19). Output - An integer representing the number of unique BSTs that can be constructed with values from 1 to n. Constraints - The value of n should be within the range 0 to 19 inclusive. - Focus on optimizing both time and space complexities. Example ```python assert num_trees(3) == 5 # Explanation: # Given n = 3, there are a total of 5 unique BST\'s formed with the values [1, 2, 3]. ``` Hints - Consider dynamic programming to store and reuse intermediate results. - Recall the formula for counting unique BSTs based on Catalan numbers: [ F(n) = sum_{i=0}^{n-1} F(i) times F(n-1-i) ]","solution":"def num_trees(n: int) -> int: This function calculates the number of unique binary search trees (BSTs) that can be constructed with values from 1 to n. :param n: int, the number of distinct values :return: int, the number of unique BSTs if n == 0: return 1 # Create a list to store the results of subproblems dp = [0] * (n + 1) # Initialize base cases dp[0] = 1 dp[1] = 1 # Fill the dp array using the catalan number relationship for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - 1 - j] return dp[n]"},{"question":"# Question: Find kth Smallest Element in a Binary Search Tree Given a Binary Search Tree (BST) and an integer k, write a function to find the kth smallest element in the BST. A BST is a binary tree where each node has at most two children (left and right) and for every node, the value of all nodes in the left subtree is less than its own value, and the value of all nodes in the right subtree is greater than its own value. You need to implement an iterative method in-order traversal to achieve this and optimize your solution to handle large inputs efficiently. # Input Format - A binary tree `root` which is an instance of the `Node` class. - An integer `k` representing the position of the smallest element to find (1-indexed). # Output Format - An integer representing the kth smallest element in the BST. # Constraints - The number of nodes in the tree is in the range [1, 10^4]. - 1 <= Node.val <= 10^4. - All Node.val are unique. - 1 <= k <= number of nodes in BST. # Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Example of a tree construction n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 # Function to implement def kth_smallest(root, k): stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: break root = root.right return root.val # Test case print(kth_smallest(n1, 3)) # Output should be 75 ``` Implement the function `kth_smallest(root, k)` to solve this problem.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Finds the kth smallest element in a BST. :param root: The root node of the BST :param k: The position of the smallest element to find (1-indexed) :return: The kth smallest element in the BST stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right # Example of a tree construction n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7"},{"question":"# Question: Implement Enhanced Exchange Sort The given code implements a basic Exchange Sort algorithm with a time complexity of O(n^2). Your task is to improve this sorting algorithm while adhering to its fundamental principles. Below is a comprehensive set of objectives you must achieve: * Implement an optimized Exchange Sort that minimizes unnecessary comparisons. * Ensure that your algorithm handles edge cases effectively, such as empty arrays and arrays with duplicate elements. * Your implementation must remain in-place (i.e., space complexity of O(1)). Function Signature: ```python def enhanced_exchange_sort(arr: list) -> list: Sorts input array using an optimized version of exchange sort. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. pass ``` # Input and Output Formats **Input:** * A list of integers with a length between 0 and 10^3. **Output:** * A sorted list of integers. # Constraints * The list can contain duplicate elements. * Time complexity should be optimized yet retain an O(n^2) nature. # Example Example 1 **Input:** [4, 2, 8, 0, 3] **Output:** [0, 2, 3, 4, 8] **Explanation:** The list is sorted in ascending order using the enhanced exchange sort. Example 2 **Input:** [1, 1, 1, 1] **Output:** [1, 1, 1, 1] **Explanation:** The list contains all identical elements, and the sorted output remains the same. Example 3 **Input:** [] **Output:** [] **Explanation:** The input is an empty list, and therefore the output is also an empty list. # Guidelines 1. Avoid redundant comparisons by keeping track of already sorted elements. 2. Maintain the in-place sorting characteristic. 3. Handle possible edge cases robustly.","solution":"def enhanced_exchange_sort(arr: list) -> list: Sorts input array using an optimized version of exchange sort. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list of integers. n = len(arr) if n < 2: return arr # No need to sort if array has 0 or 1 elements for i in range(n - 1): swapped = False for j in range(n - 1 - i): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: # If no two elements were swapped in the inner loop, then break break return arr"},{"question":"You are given two strings and need to determine whether they are anagrams of each other. An anagram of a string is another string that contains the same characters, only the order of characters can be different. Write a function `is_anagram(s1: str, s2: str) -> bool` that returns `True` if the given strings are anagrams, and `False` otherwise. Input: - `s1` and `s2`: Two strings of up to `1000` characters each. These strings may contain lowercase and uppercase English letters, digits, spaces, and punctuation marks. Output: - Return `True` if `s1` and `s2` are anagrams, otherwise return `False`. Constraints: - Any characters beyond alphanumeric (a-z, A-Z, 0-9) and punctuation should not affect the result. This means `\\"apple!\\"` and `\\"!pleap\\"` are anagrams. - The function should be case insensitive, meaning `\\"Apple\\"` and `\\"ppleA\\"` are considered anagrams. Examples: 1. `is_anagram(\\"Apple\\", \\"ppleA\\") -> True` 2. `is_anagram(\\"Apple\\", \\"ppleA!\\") -> True` 3. `is_anagram(\\"Hello, World!\\", \\"world hello\\") -> False` # Additional Notes: - Focus on handling all cases including symbols and spaces effectively. - Consider the constraints in terms of input size within practical execution limits. - Ensure your algorithm is optimized to handle the worst-case scenarios.","solution":"def is_anagram(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, False otherwise. This function ignores case and non-alphanumeric characters. import re from collections import Counter # Define a regular expression to filter alphanumeric characters filter_pattern = re.compile(r\'[^a-zA-Z0-9]\') # Normalize both strings: convert to lowercase and remove non-alphanumeric characters normalized_s1 = filter_pattern.sub(\'\', s1).lower() normalized_s2 = filter_pattern.sub(\'\', s2).lower() # Compare the character counts of the normalized strings return Counter(normalized_s1) == Counter(normalized_s2)"},{"question":"# Question: Implementing Tarjan\'s Algorithm for Strongly Connected Components Context You are tasked with implementing Tarjan\'s Algorithm to identify all strongly connected components in a directed graph. The algorithm should systematically explore the graph via Depth-First Search (DFS) and yield identifiable clusters of nodes with mutual reachability. Problem Statement Given a directed graph `G` represented as an adjacency list, implement the function `tarjan_scc(graph)`. The function should return all SCCs in the graph, where each SCC is a list of vertices in the current connected component. Function Signature ```python def tarjan_scc(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` Input * `graph`: A dictionary where the keys are vertex identifiers (integers) and the values are lists of integers representing directed edges from the key vertex. Output * A list of lists, with each inner list representing a strongly connected component. Each component should be a sorted list of vertices and the list of components should also be sorted in lexicographical (numerical) order. Constraints * Each vertex identifier and edge is a non-negative integer. * The graph may contain cycles. Example Input: ```python graph = {0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3]} ``` Output: ```python [[0, 1, 2], [3, 4, 5]] ``` Performance Requirements * Time Complexity: O(V + E) * Space Complexity: O(V) Instructions * Implement the function `tarjan_scc` following the specified input and output format. * Ensure your function handles edge cases such as single vertex graphs and cyclic graphs. * Utilize appropriate data structures to facilitate efficient graph traversal and component grouping. Good luck, and happy coding!","solution":"def tarjan_scc(graph): Tarjan\'s Algorithm to find all Strongly Connected Components (SCCs) in a directed graph. index = [0] # A single-element list to act as a mutable integer for indexing stack = [] indices = {} low_links = {} on_stack = set() sccs = [] def strong_connect(node): indices[node] = index[0] low_links[node] = index[0] index[0] += 1 stack.append(node) on_stack.add(node) # Consider successors of the node for successor in graph.get(node, []): if successor not in indices: # Successor has not yet been visited; recurse on it strong_connect(successor) low_links[node] = min(low_links[node], low_links[successor]) elif successor in on_stack: # Successor is in the stack and hence in the current SCC low_links[node] = min(low_links[node], indices[successor]) # If node is a root node, pop the stack and generate an SCC if low_links[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == node: break sccs.append(sorted(scc)) for node in graph: if node not in indices: strong_connect(node) sccs.sort() return sccs # Example usage graph = {0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3]} print(tarjan_scc(graph)) # [[0, 1, 2], [3, 4, 5]]"},{"question":"**Problem Statement:** Given a sorted (in non-decreasing order) array of integers and an integer `query`, write a function `last_occurrence(array, query)` to find the index of the last occurrence of `query` in the array. If the `query` is not found in the array, return -1. # Function Signature: ```python def last_occurrence(array: List[int], query: int) -> int: ``` # Input: * `array` (List[int]): A list of integers sorted in non-decreasing order. * `query` (int): The integer value to find in the array. # Output: * Returns the index (int) of the last occurrence of `query` in the array, or -1 if `query` is not present. # Constraints: * The length of `array` between 0 and 10^6. * The elements in `array` can be between -10^9 to 10^9. * The `query` value can be between -10^9 to 10^9. # Examples: ```python assert last_occurrence([1, 2, 2, 4, 4, 4, 7, 9, 9], 4) == 5 assert last_occurrence([1, 2, 3, 4, 5], 3) == 2 assert last_occurrence([1, 1, 1, 1, 1], 1) == 4 assert last_occurrence([], 1) == -1 ``` # Scenario: You are a software engineer at a tech company. One of your team\'s tasks involves interpreting logs containing timestamps. The logs are sorted by time. To efficiently count the occurrences and spot trends, you need to write a highly efficient function to pinpoint the last occurrence of a timestamp quickly. # Explanation to Approach: 1. Use binary search to split the array at each step. 2. Check if the mid-element is the target `query`, and if it\'s the last occurrence. 3. If the mid-element is less than or equal to `query`, continue searching in the right half, otherwise search in the left half. 4. Ensure edge cases are correctly handled, such as empty arrays or non-existent target elements. Implement the function ensuring it passes all constraints and edge cases.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Find the last occurrence of `query` in the sorted array `array`. Args: array (List[int]): A list of integers sorted in non-decreasing order. query (int): An integer to find in the array. Returns: int: The index of the last occurrence of `query` in the array, or -1 if `query` is not present. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid # Update result to the current found index left = mid + 1 # Move to the right half to find the last occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"You are given an array of integers `nums` sorted in ascending order but rotated at an unknown pivot. Implement a function to search a target value in the array. Return the index if the target is found; otherwise, return `-1`. The array does not contain duplicates, and your solution should run in O(log n) time. # Function Signature: ```python def search(nums: List[int], target: int) -> int: ``` # Input: - `nums`: List of integers sorted in ascending order and then rotated (Size `n`, where `1 <= n <= 10^4`). - `target`: Integer to search for in `nums`. # Output: - Returns the index of `target` in `nums` if it exists; otherwise, returns `-1`. # Constraints: - You must implement this function with O(log n) time complexity. # Example: ```python >>> search([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search([4, 5, 6, 7, 0, 1, 2], 3) -1 >>> search([1], 0) -1 ``` # Notes: - The algorithm should effectively determine the point of inflection (pivot) and use modified binary search methodology. - Consider both iterative and recursive approaches, but the iterative approach typically uses less stack space.","solution":"from typing import List def search(nums: List[int], target: int) -> int: Search for a target value in a rotated sorted array. Returns the index of the target if found, otherwise returns -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine which side is properly sorted if nums[left] <= nums[mid]: # Left side is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right side is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: One Edit Distance Check **Scenario**: In a text editing software, it\'s crucial to suggest corrections or identify versions of documents that differ by only one edit. An \\"edit\\" can be an insertion, deletion, or substitution of a single character in a document. You are tasked with implementing a function that determines if two strings (representing document versions) are exactly one edit distance apart. **Task**: Write a function `is_one_edit_distance` that accepts two strings `s` and `t`, and returns `True` if they are exactly one edit distance apart, otherwise returns `False`. **Function Signature**: ```python def is_one_edit_distance(s: str, t: str) -> bool: pass ``` **Inputs**: - `s` and `t`: Two strings consisting of lowercase English letters (0 <= length of s, t <= 10^4). **Outputs**: - A boolean value, `True` if the strings are one edit distance apart, `False` otherwise. **Constraints**: - Consider edge cases such as one or both strings being empty. - Focus on ensuring your solution has a time complexity of O(n), where n is the length of the shorter string. **Examples**: 1. `is_one_edit_distance(\\"abc\\", \\"ab\\")` should return `True` (one delete: \\"c\\"). 2. `is_one_edit_distance(\\"abc\\", \\"adc\\")` should return `True` (one substitute: \\"b\\" -> \\"d\\"). 3. `is_one_edit_distance(\\"abc\\", \\"abcd\\")` should return `True` (one insert: \\"d\\"). 4. `is_one_edit_distance(\\"abc\\", \\"abcde\\")` should return `False` (length difference more than 1). 5. `is_one_edit_distance(\\"\\", \\"a\\")` should return `True` (one insert). **Notes**: - Pay attention to efficiently handling strings of differing lengths and the various types of edits (insertion, deletion, substitution). - Ensure your function is optimized for performance, keeping the time complexity within O(n).","solution":"def is_one_edit_distance(s: str, t: str) -> bool: len_s, len_t = len(s), len(t) # If the length difference is greater than 1, they can\'t be one edit distance apart if abs(len_s - len_t) > 1: return False # When s is longer than t, swap them so that s is always the shorter string (or equal in length) if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s # If lengths are the same, check for one substitution if len_s == len_t: found_difference = False for i in range(len_s): if s[i] != t[i]: if found_difference: return False found_difference = True return found_difference # If lengths differ by 1, check for one insertion in t found_difference = False i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return False found_difference = True j += 1 # Increment only the longer string\'s index else: i += 1 j += 1 return True"},{"question":"Multi-Source Shortest Path in Grid Problem Statement: You are given an m x n 2D grid initialized with these three possible values: - **-1**: A wall or an obstacle. - **0**: A gate. - **INF**: Infinity, meaning an empty room. Use the value `2^31 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`. Write a function `update_distances(grid: List[List[int]]) -> None` that takes as input this 2D grid and modifies it in-place such that each empty room is updated with the distance to its nearest gate. If it is impossible to reach a gate, it should remain as `INF`. Expected Input and Output Formats: * **Input**: - `grid`: A list of lists of integers representing the 2D grid where `-1` represents a wall, `0` represents a gate, and `INF` represents an empty room. * **Output**: - The function should modify the `grid` in-place with updated distances to nearest gates. Example: ```python grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] update_distances(grid) # Resulting grid should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Constraints: - The size of the grid will be at most `10^4`. Notes: - Be mindful of performance and memory usage. Optimize for both. - Think about edge cases such as no gates, grid filled with walls, or a single row/column grid. - Avoid deep recursion to prevent potential stack overflow issues. Solution Template: ```python from typing import List from collections import deque def update_distances(grid: List[List[int]]) -> None: INF = 2147483647 rows, cols = len(grid), len(grid[0]) queue = deque() for i in range(rows): for j in range(cols): if grid[i][j] == 0: queue.append((i, j)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == INF: grid[nx][ny] = grid[x][y] + 1 queue.append((nx, ny)) ```","solution":"from typing import List from collections import deque def update_distances(grid: List[List[int]]) -> None: INF = 2147483647 if not grid or not grid[0]: return rows, cols = len(grid), len(grid[0]) queue = deque() for i in range(rows): for j in range(cols): if grid[i][j] == 0: queue.append((i, j)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == INF: grid[nx][ny] = grid[x][y] + 1 queue.append((nx, ny))"},{"question":"DFA Implementation and Utilization Context You are building a lexical analyzer and need to implement a Deterministic Finite Automaton (DFA) that verifies whether input strings belong to a specific language. The DFA is described by its states, alphabet transitions, start state, and accepting states. Task Write a function `DFA(transitions, start, final, string)` that simulates a DFA and determines if the input string is accepted. # Function Definition ```python def DFA(transitions, start, final, string): Parameters: transitions (dict): A dictionary where keys are states and values are dictionaries of transitions. The nested dictionaries have keys as characters and values as resulting states. start (str): The start state of the DFA. final (list): A list of accepting states. string (str): The input string to be verified. Returns: bool: True if the string is accepted by the DFA, False otherwise. # Your implementation here ``` # Example ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': None}, \'q1\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q2\': {\'a\': None, \'b\': None} } start = \'q0\' final = [\'q2\'] string = \\"aab\\" assert DFA(transitions, start, final, string) == True assert DFA(transitions, start, final, \\"aa\\") == False assert DFA(transitions, start, final, \\"aabb\\") == False ``` # Constraints * The transition table is a dictionary of dictionaries where the outer keys are state names, and the inner keys are character transitions. * The transition values are either another state name (indicating the next state) or `None` (indicating no valid transition). * The start state is always a valid state in the transition table. * The final states are a list of valid states in the transition table. * The input string contains only characters present in the transition table dictionaries. # Requirements * The function must run in linear time, O(n), where n is the length of the input string. * Handle edge cases such as empty strings, transitions to `None`, and strings with no valid transitions gracefully.","solution":"def DFA(transitions, start, final, string): Parameters: transitions (dict): A dictionary where keys are states and values are dictionaries of transitions. The nested dictionaries have keys as characters and values as resulting states. start (str): The start state of the DFA. final (list): A list of accepting states. string (str): The input string to be verified. Returns: bool: True if the string is accepted by the DFA, False otherwise. current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] if current_state is None: return False else: return False return current_state in final"},{"question":"**Scenario**: You are working on a text analysis tool and need to identify unique characters within strings efficiently. A frequent task is to find the first non-repeating character in a given string and return its index. Users have reported that your current implementation with large input is slow and sometimes incorrect. You need to optimize this function. **Problem**: Write a function `first_unique_char` that finds the first non-repeating character in a given string `s` and returns its index. If it doesn’t exist, return -1. **Input and Output Specifications**: * The input is a single string `s` (1 <= len(s) <= 10^5) containing only alpha characters (both lower and upper case). * The output is a single integer representing the index of the first unique (non-repeating) character, or -1 if no such character exists. **Constraints**: * Optimize the solution to have O(n) time complexity and O(1) additional space complexity (apart from the input string\'s length). **Example**: ```python s = \\"leetcode\\" # returns 0, because \'l\' is the first non-repeating character s = \\"loveleetcode\\" # returns 2, because \'v\' is the first non-repeating character s = \\"aabb\\" # returns -1, because there is no non-repeating character ``` **Function Signature**: ```python def first_unique_char(s: str) -> int: pass ``` **Note**: Your implementation should handle large inputs efficiently and correctly handle all specified edge cases.","solution":"def first_unique_char(s: str) -> int: Finds the index of the first non-repeating character in a string. Returns -1 if there is no non-repeating character. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Iterate through the string to find the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"You are given a template for two types of linked lists, Singly Linked List (SLL) and Doubly Linked List (DLL). Implement two separate classes, `SinglyLinkedList` and `DoublyLinkedList`, with the following functionalities: SinglyLinkedList: 1. **append(value)**: Inserts a node with `value` at the end of the list. 2. **prepend(value)**: Inserts a node with `value` at the beginning of the list. 3. **find(value)**: Returns the first node with the specified `value`. Returns `None` if the value is not found. 4. **remove(value)**: Removes the first node with the specified `value`. Throws an error if the value is not found. 5. **traverse()**: Displays all values in the list from head to tail. DoublyLinkedList: 1. **append(value)**: Inserts a node with `value` at the end of the list. 2. **prepend(value)**: Inserts a node with `value` at the beginning of the list. 3. **find(value)**: Returns the first node with the specified `value`. Returns `None` if the value is not found. 4. **remove(value)**: Removes the first node with the specified `value`. Throws an error if the value is not found. 5. **traverse_forward()**: Displays all values in the list from head to tail. 6. **traverse_backward()**: Displays all values in the list from tail to head. Additionally, handle the following edge cases in both linked lists: 1. Operations on an empty list. 2. Inserting and removing the head and tail elements. 3. Handling invalid operations gracefully (e.g., removing a node that doesn\'t exist). Constraints: * Assume all values will be positive integers. * Perform operations efficiently to ensure optimal performance. # Input and Output Format * **Input**: Sequences of operations to be performed on the linked lists. * **Output**: Results of `find`, `traverse`, `traverse_forward`, and `traverse_backward` operations. # Example of Function Signatures ```python class SinglyLinkedList: def __init__(self): # initialize your SLL here def append(self, value): # code to append a value def prepend(self, value): # code to prepend a value def find(self, value): # code to find a value def remove(self, value): # code to remove a value def traverse(self): # code to traverse the list print all elements class DoublyLinkedList: def __init__(self): # initialize your DLL here def append(self, value): # code to append a value def prepend(self, value): # code to prepend a value def find(self, value): # code to find a value def remove(self, value): # code to remove a value def traverse_forward(self): # code to traverse the list in forward direction and print all elements def traverse_backward(self): # code to traverse the list in backward direction and print all elements ```","solution":"# Singly Linked List (SLL) Node class SLLNode: def __init__(self, value): self.value = value self.next = None # Singly Linked List class SinglyLinkedList: def __init__(self): self.head = None def append(self, value): new_node = SLLNode(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def prepend(self, value): new_node = SLLNode(value) new_node.next = self.head self.head = new_node def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def remove(self, value): if not self.head: raise ValueError(\\"List is empty\\") if self.head.value == value: self.head = self.head.next return prev = self.head current = self.head.next while current: if current.value == value: prev.next = current.next return prev = current current = current.next raise ValueError(\\"Value not found in the list\\") def traverse(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values # Doubly Linked List (DLL) Node class DLLNode: def __init__(self, value): self.value = value self.next = None self.prev = None # Doubly Linked List class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DLLNode(value) if not self.tail: self.head = self.tail = new_node return self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DLLNode(value) if not self.head: self.head = self.tail = new_node return new_node.next = self.head self.head.prev = new_node self.head = new_node def find(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def remove(self, value): if not self.head: raise ValueError(\\"List is empty\\") if self.head.value == value: self.head = self.head.next if self.head: self.head.prev = None else: self.tail = None return current = self.head while current: if current.value == value: if current.next: current.next.prev = current.prev if current.prev: current.prev.next = current.next if current == self.tail: self.tail = current.prev return current = current.next raise ValueError(\\"Value not found in the list\\") def traverse_forward(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values def traverse_backward(self): values = [] current = self.tail while current: values.append(current.value) current = current.prev return values"},{"question":"Problem Statement Write a function to determine the minimal number of bits you would need to flip to convert integer A to integer B. Input * An integer `a` (0 ≤ a ≤ 10^9) * An integer `b` (0 ≤ b ≤ 10^9) Output * An integer representing the minimal number of bits that need to be flipped to convert `a` to `b`. Constraints 1. Consider only non-negative integers within the given range. 2. The function should run efficiently even for the largest possible inputs. Example ```plaintext Input: a = 29, b = 15 Output: 2 Explanation: 29 in binary is 11101 15 in binary is 01111 To convert 11101 to 01111, you need to flip the first and fifth bits. ``` Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` Additional Context Consider the practical applications of determining bit differences in fields such as error detection, digital communication, and data transmission, where such algorithms are critical for efficiency and accuracy.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bits needed to flip to convert integer a to integer b. Parameters: a (int): The initial integer. b (int): The integer to convert to. Returns: int: The number of bits that need to be flipped. xor_result = a ^ b return bin(xor_result).count(\'1\')"},{"question":"You are given a sequence of movements for a robot within a 2D grid. The initial position of the robot is (0, 0). The movements are represented by a string where each character indicates a move: * \'U\' - move Up * \'D\' - move Down * \'R\' - move Right * \'L\' - move Left Your task is to determine if after executing all the moves the robot returns to the origin (0, 0). # Function Signature ```python def does_robot_return_to_origin(moves: str) -> bool: # Your code here ``` # Input * `moves` (string): A string representing the sequence of robot moves. The string will only contain \'U\', \'D\', \'R\', \'L\', and its length will not exceed 10000. # Output * `bool`: Returns `True` if after all the movements the robot returns to (0, 0), otherwise `False`. # Constraints * The moves string will contain only the characters \'U\', \'D\', \'R\', \'L\'. * The length of the moves string will not exceed 10000. # Examples ```python assert does_robot_return_to_origin(\\"UD\\") == True assert does_robot_return_to_origin(\\"LL\\") == False assert does_robot_return_to_origin(\\"RRDD\\") == False assert does_robot_return_to_origin(\\"UUDDLLRR\\") == True assert does_robot_return_to_origin(\\"\\") == True ``` # Description - Focus on implementing the function `does_robot_return_to_origin`. - Iterate through each move and keep track of the vertical and horizontal position of the robot. - Return `True` if the robot returns to its original position, otherwise return `False`.","solution":"def does_robot_return_to_origin(moves: str) -> bool: Determine if robot returns to origin after the given sequence of moves. Parameters: moves (str): A string containing the moves \'U\', \'D\', \'L\', \'R\'. Returns: bool: True if robot returns to origin, False otherwise. x = y = 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'R\': x += 1 elif move == \'L\': x -= 1 return x == 0 and y == 0"},{"question":"Scenario Imagine you are given a dataset of integers representing the priority scores of tasks in a project management tool. In certain situations, you need to ensure that these tasks are sorted based on their priority scores. To achieve this, you decide to employ a sorting algorithm that optimally handles cases where the tasks might already be nearly sorted. Task You are required to implement the Cocktail Shaker Sort algorithm to sort an array of integers representing task priority scores. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr` (List[int]): A list of integers representing the priority scores of tasks. The length of the list, `N`, will satisfy `0 <= N <= 1000`. Output * Returns a sorted list in ascending order of priority scores. Constraints * Use the Cocktail Shaker Sort algorithm for sorting. * The maximum length of the array will not exceed 1000 elements. * Aim to optimize within the given constraints for better performance in nearly sorted scenarios. Example ```python # Input arr = [5, 2, 9, 1, 5, 6] # Expected Output [1, 2, 5, 5, 6, 9] # Input arr = [3, 3, 2, 1] # Expected Output [1, 2, 3, 3] # Input arr = [] # Expected Output [] ``` Notes 1. You must handle edge cases such as empty arrays, already sorted arrays, and arrays with identical elements appropriately. 2. Ensure that your function performs efficiently and adheres to the constraints provided.","solution":"def cocktail_shaker_sort(arr): Sorts an array of integers using the Cocktail Shaker Sort algorithm. Parameters: arr (List[int]): A list of integers representing priority scores. Returns: List[int]: The sorted list in ascending order. if not arr: return [] n = len(arr) is_sorted = False start = 0 end = n - 1 while not is_sorted: is_sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False # If no elements were swapped, the array is sorted if is_sorted: break is_sorted = True end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False start += 1 return arr"},{"question":"# Radix Sort Implementation Challenge You are tasked with implementing a radix sort algorithm that efficiently sorts non-negative integers. Your goal is to ensure the function sorts the input array correctly and demonstrates an understanding of the radix sort\'s steps and mechanisms. Implement a function `enhanced_radix_sort(arr, simulation=False)` that sorts an array of non-negative integers using radix sort. The function should have the capability to optionally display the sorting process after each digit iteration when `simulation` is set to `True`. Function Signature ```python def enhanced_radix_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` Input - `arr (list[int])`: A list of non-negative integers to be sorted. - `simulation (bool)`: A boolean flag indicating if the function should print the array after each digit iteration for visualization. Default value is `False`. Output - Returns a sorted list of integers in ascending order. Example ```python # Example 1 print(enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Expected Output: [2, 24, 45, 66, 75, 90, 170, 802] # Example 2 (Simulation) enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) # Expected Output: # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 170 802 2 24 45 66 75 90 # iteration 2 : 2 24 45 66 75 90 170 802 ``` Constraints - The function should handle lists containing up to `10^5` integers. - The values in `arr` should range from `0` to `10^9`. Performance Requirements - Ensure the algorithm runs efficiently with the given constraints. **Note**: You MUST handle edge cases such as empty lists or lists with a single element effectively. Scenario Imagine you are developing a component for a larger software system that processes and sorts large amounts of numerical data. This component needs to ensure data is sorted correctly for subsequent processing steps. Proper implementation of radix sort will contribute to the overall efficiency and reliability of the system.","solution":"def enhanced_radix_sort(arr, simulation=False): if not arr: return arr # Get maximum number to figure out the number of digits max_num = max(arr) exp = 1 iteration = 0 while max_num // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {iteration} :\\", \' \'.join(map(str, arr))) exp *= 10 iteration += 1 return arr def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = arr[i] // exp count[index % 10] += 1 # Change count[i] so that count[i] contains the actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = arr[i] // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 i -= 1 # Copy the output array to arr[] for i in range(n): arr[i] = output[i]"},{"question":"# Regular Expression Matching Context: You are building a regex engine with a simplified syntax to help validate certain patterns in strings. Your engine should support the following rules: - `.` (dot) matches any single character. - `*` (asterisk) matches zero or more of the preceding element. Implement a function `is_match(s: str, p: str) -> bool` that returns whether the input string `s` matches the pattern `p`. Function Signature: ```python def is_match(s: str, p: str) -> bool: ``` Input & Output: - Input: A string `s` and a pattern `p`. - `s` can be any sequence of characters. - `p` can include letters, `.` and `*`. - Both `s` and `p` have a length of at most 1000 characters. - Output: A boolean value `True` if the string matches the pattern, `False` otherwise. Constraints: - The pattern `p` only contains lowercase letters, \'.\', and \'*\'. - Pattern characters are interpreted as follows: - `.` matches any single character. - `*` matches zero or more of the preceding element. Example: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True assert is_match(\\"\\", \\".*\\") == True assert is_match(\\"\\", \\"\\") == True assert is_match(\\"a\\", \\"\\") == False assert is_match(\\"\\", \\"a*\\") == True ``` Task: Write the implementation of the `is_match` function using dynamic programming or any robust method that ensures the solution considers all edge cases and runs efficiently within the constraints provided.","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) # dp[i][j] will be True if s[:i] matches p[:j], else False dp = [[False] * (n + 1) for _ in range(m + 1)] # An empty string matches an empty pattern dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(1, n + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Populate the dp table for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == s[i - 1] or p[j - 1] == \'.\': dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or ((p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j]) return dp[m][n]"}]'),O={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},C={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(n(!0),i(b,null,v(a.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const B=c(O,[["render",j],["__scopeId","data-v-0c53308e"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/45.md","filePath":"guide/45.md"}'),P={name:"guide/45.md"},H=Object.assign(P,{setup(r){return(e,l)=>(n(),i("div",null,[x(B)]))}});export{M as __pageData,H as default};
