import{_ as m,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as y,p as v,e as x,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function S(i,e,u,_,r,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const R=m(q,[["render",S],["__scopeId","data-v-140d550b"]]),A=JSON.parse(`[{"question":"def is_valid_route(M, N, x, y, movements): Determine if the route for the truck is valid based on the given conditions. Args: M : int : number of streets (grid rows) N : int : number of avenues (grid columns) x : int : starting x-coordinate y : int : starting y-coordinate movements : str : movement directions as string consisting of 'U', 'D', 'L', 'R' Returns: str : \\"Valid\\" if the route does not exceed grid boundaries or revisit intersections, else \\"Invalid\\" >>> is_valid_route(5, 5, 2, 2, 'UURRDDL') \\"Valid\\" >>> is_valid_route(5, 5, 1, 1, 'RRUULL') \\"Invalid\\" pass def determine_routes(test_cases): Determine if the routes for multiple test cases are valid. Args: test_cases : List of tuples, each containing: M : int : number of streets (grid rows) N : int : number of avenues (grid columns) routes : List of tuples, each containing: x : int : starting x-coordinate y : int : starting y-coordinate movements : str : movement directions as string consisting of 'U', 'D', 'L', 'R' Returns: List[str] : \\"Valid\\" or \\"Invalid\\" for each route >>> determine_routes([(5, 5, [(2, 2, 'UURRDDL'), (1, 1, 'RRUULL')])]) [\\"Valid\\", \\"Invalid\\"] pass def process_input(input_data): Parse input data to extract test cases. Args: input_data : str : raw input data as string Returns: List[tuple] : parsed test cases >>> input_data = \\"1n5 5n2n3 3 UURRDDLn2 2 RRUULLn\\" >>> process_input(input_data) [(5, 5, [(2, 2, 'UURRDDL'), (1, 1, 'RRUULL')])] pass","solution":"def is_valid_route(M, N, x, y, movements): visited = set() visited.add((x, y)) for move in movements: if move == 'U': x -= 1 elif move == 'D': x += 1 elif move == 'L': y -= 1 elif move == 'R': y += 1 if x < 0 or x >= M or y < 0 or y >= N or (x, y) in visited: return \\"Invalid\\" visited.add((x, y)) return \\"Valid\\" def determine_routes(test_cases): results = [] for M, N, routes in test_cases: for x, y, movements in routes: results.append(is_valid_route(M, N, x, y, movements)) return results # Function to read input data def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0].strip()) index = 1 test_cases = [] for _ in range(T): M, N = map(int, input_lines[index].strip().split()) K = int(input_lines[index+1].strip()) routes = [] for i in range(K): x, y, movements = input_lines[index + 2 + i].strip().split(maxsplit=2) x = int(x) - 1 y = int(y) - 1 routes.append((x, y, movements)) test_cases.append((M, N, routes)) index += 2 + K return test_cases"},{"question":"def sum_of_subarray_minimums(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: John loves programming and enjoys solving mathematical problems. One day, he encountered a challenge where he needs to calculate the sum of all subarray minimums for a given array. John seeks your help to solve this problem efficiently. Given an array A of N integers, find the sum of the minimum value of every subarray of A. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing an integer N and a list of N integers representing the array. Returns: List[int]: For each test case, the sum of the minimum values of every subarray of A modulo 10^9 + 7. Example: >>> sum_of_subarray_minimums(2, [(3, [1, 2, 3]), (4, [4, 3, 2, 1])]) [10, 20] >>> sum_of_subarray_minimums(1, [(4, [2, 4, 3, 1])]) [20] pass","solution":"def sum_of_subarray_minimums(T, test_cases): MOD = 10**9 + 7 def calculate_subarray_mins(arr): n = len(arr) left = [0] * n right = [0] * n stack = [] # Finding previous less element for i in range(n): while stack and arr[stack[-1]] >= arr[i]: stack.pop() if stack: left[i] = stack[-1] else: left[i] = -1 stack.append(i) stack = [] # Finding next less element for i in range(n - 1, -1, -1): while stack and arr[stack[-1]] > arr[i]: stack.pop() if stack: right[i] = stack[-1] else: right[i] = n stack.append(i) result = 0 for i in range(n): result += arr[i] * (i - left[i]) * (right[i] - i) result %= MOD return result results = [] for t in range(T): N = test_cases[t][0] A = test_cases[t][1] results.append(calculate_subarray_mins(A)) return results"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines whether an input string of parentheses is valid. A string is considered valid if: 1. Every open parenthesis '(' has a corresponding close parenthesis ')'. 2. Open parentheses must be closed in the correct order. Args: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is valid, False otherwise. Examples: >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"(()())()\\") True >>> is_valid_parentheses(\\")(\\") False >>> is_valid_parentheses(\\"())\\") False >>> is_valid_parentheses(\\"()(\\") False >>> is_valid_parentheses(\\"(\\") False >>> is_valid_parentheses(\\")\\") False >>> is_valid_parentheses(\\"\\") True","solution":"def is_valid_parentheses(s): Determines whether an input string of parentheses is valid. Args: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is valid, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def smallest_string_by_reversing_substring(t: int, test_cases: List[str]) -> List[str]: For each input string, return the lexicographically smallest string by reversing exactly one substring. Parameters: t (int): number of test cases. test_cases (list of str): list of strings to process. Returns: list of str: list of results for each test case. >>> smallest_string_by_reversing_substring(3, [\\"acb\\", \\"aab\\", \\"bab\\"]) [\\"abc\\", \\"aab\\", \\"abb\\"] >>> smallest_string_by_reversing_substring(1, [\\"aaa\\"]) [\\"aaa\\"]","solution":"def smallest_string_by_reversing_substring(t, test_cases): For each input string, return the lexicographically smallest string by reversing exactly one substring. Parameters: t (int): number of test cases. test_cases (list of str): list of strings to process. Returns: list of str: list of results for each test case. results = [] for s in test_cases: n = len(s) smallest = s for i in range(n): for j in range(i+1, n+1): reversed_substring = s[:i] + s[i:j][::-1] + s[j:] if reversed_substring < smallest: smallest = reversed_substring results.append(smallest) return results"},{"question":"def min_cut_palindrome(s: str) -> int: Given a string s, returns the minimum number of cuts needed such that every substring after the cut is a palindrome. >>> min_cut_palindrome(\\"abac\\") == 1 >>> min_cut_palindrome(\\"aab\\") == 1 >>> min_cut_palindrome(\\"a\\") == 0 >>> min_cut_palindrome(\\"ababbbabbababa\\") == 3 >>> min_cut_palindrome(\\"noonabbad\\") == 2 >>> min_cut_palindrome(\\"racecar\\") == 0 >>> min_cut_palindrome(\\"aaaa\\") == 0 >>> min_cut_palindrome(\\"abcde\\") == 4 >>> min_cut_palindrome(\\"abcba\\") == 0 >>> min_cut_palindrome(\\"madam\\") == 0 >>> min_cut_palindrome(\\"banana\\") == 1 >>> min_cut_palindrome(\\"abbab\\") == 1","solution":"def min_cut_palindrome(s): Given a string s, returns the minimum number of cuts needed such that every substring after the cut is a palindrome. n = len(s) # is_palindrome[i][j] will be True if s[i:j+1] is a palindrome is_palindrome = [[False] * n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: is_palindrome[i][j] = s[i] == s[j] else: is_palindrome[i][j] = (s[i] == s[j]) and is_palindrome[i+1][j-1] cuts = [float('inf')] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 else: for j in range(i): if is_palindrome[j+1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"def sumOfPrimes(N: int) -> int: Given an integer N, compute the sum of the first N prime numbers. >>> sumOfPrimes(5) 28 >>> sumOfPrimes(7) 58","solution":"def is_prime(num): if num <= 1: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sumOfPrimes(N): count = 0 num = 2 prime_sum = 0 while count < N: if is_prime(num): prime_sum += num count += 1 num += 1 return prime_sum"},{"question":"def min_operations_to_valid_string(s: str) -> int: Given a string containing only digits, find out the minimum number of operations required to convert the given string into a valid string where no two consecutive characters are the same. An operation is defined as changing any single digit to any other digit. >>> min_operations_to_valid_string(\\"1234567890\\") == 0 >>> min_operations_to_valid_string(\\"12121212\\") == 0 >>> min_operations_to_valid_string(\\"1221\\") == 1 >>> min_operations_to_valid_string(\\"1111\\") == 3","solution":"def min_operations_to_valid_string(s): Returns the minimum number of operations required to convert the string s into a valid string where no two consecutive characters are the same. operations = 0 for i in range(1, len(s)): if s[i] == s[i-1]: operations += 1 return operations"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root: TreeNode) -> list: Given a binary tree, return the level order traversal of its nodes' values from bottom to top. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrderBottom(root) [[15, 7], [9, 20], [3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> levelOrderBottom(root) [[4, 5], [2, 3], [1]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.insert(0, level_nodes) return result"},{"question":"def divideString(s: str, n: int) -> List[str]: Divide the string s into n equal parts. If the string cannot be divided into exactly n parts, return an empty array. Otherwise, return an array containing the n parts in the order they appear in the string. >>> divideString(\\"abcdefghij\\", 5) [\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\", \\"ij\\"] >>> divideString(\\"abcde\\", 3) [] >>> divideString(\\"abcabcab\\", 4) [\\"ab\\", \\"ca\\", \\"bc\\", \\"ab\\"]","solution":"def divideString(s, n): Divides the string s into n equal parts. If the string cannot be divided into exactly n parts, return an empty array. length = len(s) if length % n != 0: return [] part_length = length // n return [s[i * part_length:(i + 1) * part_length] for i in range(n)]"},{"question":"def encode_message(message: str, shift: int) -> str: Encode a message using a Caesar cipher with the given shift value. >>> encode_message(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" >>> encode_message(\\"abcXYZ\\", 1) == \\"bcdYZA\\" >>> encode_message(\\"Attack at dawn!\\", 5) == \\"Fyyfhp fy ifbs!\\"","solution":"def encode_message(message: str, shift: int) -> str: def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in message)"},{"question":"def partition_scores(scores: List[int], k: int) -> int: Partition scores into k groups such that the maximum possible sum among all groups is minimized. >>> partition_scores([10, 20, 30, 40, 50], 3) 60 >>> partition_scores([10, 20, 30, 40, 50], 2) 90 >>> partition_scores([10, 20, 30, 40, 50], 1) 150 >>> partition_scores([5, 7, 2, 3], 4) 7 >>> partition_scores([5, 7, 2, 3, 9, 14, 1], 3) 15 >>> partition_scores([10, 10, 10, 10], 2) 20","solution":"def partition_scores(scores, k): def can_partition(max_sum, k): current_sum = 0 required_groups = 1 for score in scores: if current_sum + score > max_sum: required_groups += 1 current_sum = score if required_groups > k: return False else: current_sum += score return True if k == 1: return sum(scores) left, right = max(scores), sum(scores) while left < right: mid = (left + right) // 2 if can_partition(mid, k): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def groupShiftedStrings(strings: List[str]) -> List[List[str]]: Group all the words that belong to the same GroupShift. >>> groupShiftedStrings([\\"abc\\", \\"bcd\\", \\"acef\\", \\"xyz\\", \\"az\\", \\"ba\\", \\"a\\", \\"z\\"]) [[\\"abc\\", \\"bcd\\", \\"xyz\\"], [\\"acef\\"], [\\"az\\", \\"ba\\"], [\\"a\\", \\"z\\"]] >>> groupShiftedStrings([\\"a\\", \\"b\\", \\"c\\"]) [[\\"a\\", \\"b\\", \\"c\\"]]","solution":"from collections import defaultdict from typing import List def groupShiftedStrings(strings: List[str]) -> List[List[str]]: def get_shift_key(word: str) -> str: if len(word) == 1: return 'single_letter' shifts = [] for i in range(1, len(word)): shift = (ord(word[i]) - ord(word[i-1])) % 26 shifts.append(shift) return tuple(shifts) shift_groups = defaultdict(list) for word in strings: key = get_shift_key(word) shift_groups[key].append(word) return list(shift_groups.values())"},{"question":"def arrange_participants(test_cases): Determine if it's possible to arrange participants such that the difference in energy levels between any two consecutive participants is at least a certain value k. Args: test_cases: A list of tuples, each containing: - an integer n: the number of participants - an integer k: the minimum required difference in energy levels - a list of integers representing the energy levels of the participants Returns: results: A list of strings, where each string is either \\"POSSIBLE\\" followed by the rearranged array of energy levels or \\"IMPOSSIBLE\\" >>> arrange_participants([(3, 2, [4, 1, 7])]) ['POSSIBLEn1 4 7'] >>> arrange_participants([(4, 3, [10, 4, 1, 7])]) ['POSSIBLEn1 4 7 10'] >>> arrange_participants([(2, 6, [5, 11])]) ['POSSIBLEn5 11'] pass def process_input(input_data): Process the input data for the test cases. pass def main(input_data): Main function to determine if it's possible to arrange participants. pass","solution":"def arrange_participants(test_cases): results = [] for t in test_cases: n, k, energy_levels = t energy_levels.sort() possible = True for i in range(1, n): if energy_levels[i] - energy_levels[i-1] < k: possible = False break if possible: results.append(f\\"POSSIBLEn{' '.join(map(str, energy_levels))}\\") else: results.append(\\"IMPOSSIBLE\\") return results def process_input(input_data): input_lines = input_data.split(\\"n\\") t = int(input_lines[0]) test_cases = [] line = 1 for _ in range(t): n, k = map(int, input_lines[line].split()) energy_levels = list(map(int, input_lines[line + 1].split())) test_cases.append((n, k, energy_levels)) line += 2 return test_cases def main(input_data): test_cases = process_input(input_data) return arrange_participants(test_cases)"},{"question":"def filter_divisibility(arr, d): Returns a new array consisting of only the elements in \`arr\` that are divisible by \`d\`. Parameters: arr (list): List of integers d (int): Divisor Returns: list: A list of elements from \`arr\` that are divisible by \`d\`","solution":"def filter_divisibility(arr, d): Returns a new array consisting of only the elements in \`arr\` that are divisible by \`d\`. Parameters: arr (list): List of integers d (int): Divisor Returns: list: A list of elements from \`arr\` that are divisible by \`d\` return [x for x in arr if x % d == 0]"},{"question":"def count_harmonious_pairs(n: int, k: int, power_levels: List[int]) -> int: Returns the number of distinct pairs of wizards forming a harmonious team. Args: n (int): The number of wizards. k (int): The magical number. power_levels (List[int]): List of power levels of the wizards. Returns: int: The number of distinct harmonious pairs. Examples: >>> count_harmonious_pairs(5, 7, [1, 2, 3, 4, 6]) 2 >>> count_harmonious_pairs(4, 10, [5, 5, 5, 5]) 0 >>> count_harmonious_pairs(3, 3, [1, 2, 4]) 1","solution":"def count_harmonious_pairs(n, k, power_levels): Returns the number of distinct pairs of wizards forming a harmonious team. power_set = set(power_levels) count = 0 for power in power_levels: if (k - power) in power_set and (k - power) != power: count += 1 power_set.remove(power) power_set.remove(k - power) return count"},{"question":"def transform_list(nums): Given a list of integers, returns a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. >>> transform_list([1, 2, 3, 4]) [24, 12, 8, 6] >>> transform_list([5, 0, 2, 1, 3]) [0, 30, 0, 0, 0] >>> transform_list([1]) [0] >>> transform_list([2, 3]) [3, 2] >>> transform_list([0, 0, 2]) [0, 0, 0] >>> transform_list([1, -1, 2]) [-2, 2, -1] >>> transform_list([-1000, 2, 3, 4]) [24, -12000, -8000, -6000]","solution":"def transform_list(nums): Given a list of integers, returns a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. n = len(nums) if n == 1: return [0] # If there's only one number, the product of all other numbers is zero # Initialize arrays to store the prefix and suffix products prefix_products = [1] * n suffix_products = [1] * n # Calculate prefix products for i in range(1, n): prefix_products[i] = prefix_products[i - 1] * nums[i - 1] # Calculate suffix products for i in range(n - 2, -1, -1): suffix_products[i] = suffix_products[i + 1] * nums[i + 1] # Calculate the result by multiplying the prefix and suffix products result = [prefix_products[i] * suffix_products[i] for i in range(n)] return result"},{"question":"def check_message_integrity(message: str, checksum: int) -> str: Check if the sum of ASCII values of characters in the message matches the given checksum. Args: message (str): The input message, which contains between 1 and 100 characters. checksum (int): The checksum value to compare against, between 0 and 10,000. Returns: str: \\"Valid\\" if the checksum matches, otherwise \\"Invalid\\". Examples: >>> check_message_integrity(\\"hello\\", 532) 'Valid' >>> check_message_integrity(\\"world\\", 560) 'Invalid' pass # Test cases def test_check_message_integrity_valid(): assert check_message_integrity(\\"hello\\", 532) == \\"Valid\\", \\"Test case 'hello' failed\\" assert check_message_integrity(\\"!\\", 33) == \\"Valid\\", \\"Test case '!' failed\\" assert check_message_integrity(\\"A\\", 65) == \\"Valid\\", \\"Test case 'A' failed\\" def test_check_message_integrity_invalid(): assert check_message_integrity(\\"hello\\", 531) == \\"Invalid\\", \\"Test case 'hello' with 531 failed\\" assert check_message_integrity(\\"world\\", 560) == \\"Invalid\\", \\"Test case 'world' failed\\" assert check_message_integrity(\\"!\\", 34) == \\"Invalid\\", \\"Test case '!' with 34 failed\\" def test_check_message_integrity_empty_message(): assert check_message_integrity(\\"\\", 0) == \\"Valid\\", \\"Test case empty string failed\\" def test_check_message_integrity_boundary_cases(): assert check_message_integrity(\\"z\\"*100, 12200) == \\"Valid\\", \\"Boundary test case with 'z'*100 failed\\" assert check_message_integrity(\\"a\\"*100, 9700) == \\"Valid\\", \\"Boundary test case with 'a'*100 failed\\"","solution":"def check_message_integrity(message, checksum): Check if the sum of ASCII values of characters in the message matches the given checksum. Args: message (str): The input message. checksum (int): The checksum value to compare against. Returns: str: \\"Valid\\" if the checksum matches, otherwise \\"Invalid\\". computed_checksum = sum(ord(char) for char in message) return \\"Valid\\" if computed_checksum == checksum else \\"Invalid\\""},{"question":"from typing import List, Tuple def process_queries(queries: List[Tuple[int, int]], limit: int = 10**6) -> List[int]: Compute the sums of magic numbers for all given ranges. Each range is provided as a tuple (l, r), and this function returns a list with the sum of unique prime factors for each range [l, r]. Args: queries (List[Tuple[int, int]]): List of query tuples, each representing a range (l, r). limit (int): Maximum index for books range. Returns: List[int]: List of sums of magic numbers for each range. >>> process_queries([(1, 1), (2, 4), (10, 15), (1000, 1002)]) [0, 3, 10, 8] pass","solution":"def count_unique_prime_factors(n): Returns the number of unique prime factors of n. count = 0 i = 2 if n % i == 0: count += 1 while n % i == 0: n //= i for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: count += 1 while n % i == 0: n //= i if n > 2: count += 1 return count def preprocess_magic_numbers(limit): Preprocess and return an array of magic numbers up to the given limit. magic_numbers = [0] * (limit + 1) for i in range(2, limit + 1): if magic_numbers[i] == 0: # i is a prime number for multiple in range(i, limit + 1, i): magic_numbers[multiple] += 1 return magic_numbers def preprocess_sum_magic_numbers(magic_numbers): Preprocess and return the prefix sum array of the magic numbers. n = len(magic_numbers) sum_magic_numbers = [0] * n for i in range(1, n): sum_magic_numbers[i] = sum_magic_numbers[i - 1] + magic_numbers[i] return sum_magic_numbers def sum_magic_numbers(l, r, sum_magic_numbers): Returns the sum of magic numbers in the range [l, r]. return sum_magic_numbers[r] - sum_magic_numbers[l - 1] # Main function to process queries def process_queries(queries, limit=10**6): magic_numbers = preprocess_magic_numbers(limit) sum_magic_numbers_arr = preprocess_sum_magic_numbers(magic_numbers) results = [] for l, r in queries: results.append(sum_magic_numbers(l, r, sum_magic_numbers_arr)) return results"},{"question":"from typing import List, Tuple, Union from datetime import datetime def find_relevant_events(T: int, K: int, events: List[Tuple[datetime, int]]) -> List[Union[str, None]]: This function identifies the most relevant events within a specified time window from a list of recorded events. :param T: Number of different event types :param K: Time window size in seconds :param events: List of tuples containing event timestamp and type :return: List of the most recent event timestamps for each type within the time window. >>> T = 2 >>> K = 30 >>> events = [ ... (datetime(2023, 10, 1, 8, 0, 0), 1), ... (datetime(2023, 10, 1, 8, 0, 35), 2), ... (datetime(2023, 10, 1, 8, 1, 0), 1), ... (datetime(2023, 10, 1, 8, 1, 30), 2) ... ] >>> find_relevant_events(T, K, events) ['2023-10-01 08:01:00', '2023-10-01 08:01:30'] >>> T = 2 >>> K = 5 >>> events = [ ... (datetime(2023, 10, 1, 12, 0, 0), 1), ... (datetime(2023, 10, 1, 12, 0, 10), 2), ... (datetime(2023, 10, 1, 12, 0, 20), 1) ... ] >>> find_relevant_events(T, K, events) ['2023-10-01 12:00:20', 'None']","solution":"from datetime import datetime, timedelta def find_relevant_events(T, K, events): This function identifies the most relevant events within a specified time window from a list of recorded events. :param T: Number of different event types :param K: Time window size in seconds :param events: List of tuples containing event timestamp and type :return: List of the most recent event timestamps for each type within the time window. # Initialize the latest event timestamps for each type as None latest_events = {event_type: None for event_type in range(1, T+1)} # Sort events by timestamp events = sorted(events, key=lambda x: x[0]) # Process each event to find the most recent within the time window for current_event in events: current_time, current_type = current_event # Calculate the time window's start time start_time = current_time - timedelta(seconds=K) for type_key in latest_events.keys(): if type_key == current_type: latest_events[type_key] = current_time elif latest_events[type_key] and latest_events[type_key] < start_time: latest_events[type_key] = None # Form the output as required result = [] for i in range(1, T+1): if latest_events[i] is None: result.append(\\"None\\") else: result.append(latest_events[i].strftime(\\"%Y-%m-%d %H:%M:%S\\")) return result # Read input - This would usually go outside the function in a script or main block def main(): import sys input = sys.stdin.read data = input().strip().split('n') T, K = map(int, data[0].split()) N = int(data[1]) events = [] for i in range(2, 2 + N): timestamp_str, event_type = data[i].rsplit(' ', 1) timestamp = datetime.strptime(timestamp_str, \\"%Y-%m-%d %H:%M:%S\\") events.append((timestamp, int(event_type))) results = find_relevant_events(T, K, events) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def placeRooks(n: int) -> int: Returns the maximum number of non-attacking rooks that can be placed on an n x n chessboard. Args: n (int): The size of the chessboard Returns: int: The maximum number of non-attacking rooks >>> placeRooks(1) 1 >>> placeRooks(2) 2 >>> placeRooks(4) 4","solution":"def placeRooks(n): Returns the maximum number of non-attacking rooks that can be placed on an n x n chessboard. Args: n (int): The size of the chessboard Returns: int: The maximum number of non-attacking rooks return n"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Determine the length of the longest increasing path in the matrix. From each cell, you can move in four directions: left, right, up, or down. You cannot move diagonally or outside the boundary of the matrix. >>> longest_increasing_path([[9, 9, 4], [6, 6, 8], [2, 1, 1]]) 4 >>> longest_increasing_path([[1]]) 1 >>> longest_increasing_path([[7, 7], [7, 7]]) 1 >>> longest_increasing_path([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) 9 >>> longest_increasing_path([[3, 4, 5], [3, 2, 6], [2, 2, 1]]) 4","solution":"def longest_increasing_path(matrix): Returns the length of the longest increasing path in the matrix. if not matrix or not matrix[0]: return 0 def dfs(x, y): if memo[x][y]: return memo[x][y] length = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] > matrix[x][y]: length = max(length, 1 + dfs(nx, ny)) memo[x][y] = length return length memo = [[0] * len(matrix[0]) for _ in range(len(matrix))] return max(dfs(x, y) for x in range(len(matrix)) for y in range(len(matrix[0])))"},{"question":"def kConsecutiveOdds(arr, k): Determines if there are k consecutive odd numbers in the array. :param arr: List[int] - The input array. :param k: int - The number of consecutive odd numbers to check for. :return: bool - True if there are k consecutive odd numbers, else False. Example: >>> kConsecutiveOdds([1, 2, 3, 4, 5], 3) False >>> kConsecutiveOdds([1, 3, 5, 7, 9], 3) True >>> kConsecutiveOdds([1, 3, 5, 7, 9], 5) True >>> kConsecutiveOdds([2, 4, 6, 8, 10], 1) False >>> kConsecutiveOdds([2, 4, 6, 1, 3, 5], 3) True","solution":"def kConsecutiveOdds(arr, k): Determines if there are k consecutive odd numbers in the array. :param arr: List[int] - The input array. :param k: int - The number of consecutive odd numbers to check for. :return: bool - True if there are k consecutive odd numbers, else False. count = 0 for num in arr: if num % 2 != 0: count += 1 if count == k: return True else: count = 0 return False"},{"question":"def can_convert_to_substring(q: int, queries: List[str]) -> List[str]: Determine whether you can convert string t into a substring of string s using any number of operations. >>> can_convert_to_substring(4, [\\"abacaba\\", \\"cab\\", \\"mississippi\\", \\"sip\\", \\"abcdefgh\\", \\"xyz\\", \\"applepie\\", \\"ppi\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> can_convert_to_substring(1, [\\"hello\\", \\"llo\\"]) [\\"YES\\"] results = [] for i in range(q): s = queries[2 * i] t = queries[2 * i + 1] # Insert the logic to check if t can be converted to a substring of s return results import pytest def test_can_convert_to_substring(): q = 4 queries = [\\"abacaba\\", \\"cab\\", \\"mississippi\\", \\"sip\\", \\"abcdefgh\\", \\"xyz\\", \\"applepie\\", \\"ppi\\"] expected_results = [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] assert can_convert_to_substring(q, queries) == expected_results def test_case_s_is_smaller_than_t(): q = 1 queries = [\\"abc\\", \\"abcd\\"] expected_results = [\\"NO\\"] assert can_convert_to_substring(q, queries) == expected_results def test_case_exact_match(): q = 1 queries = [\\"hello\\", \\"llo\\"] expected_results = [\\"YES\\"] assert can_convert_to_substring(q, queries) == expected_results def test_case_no_possible_match(): q = 1 queries = [\\"abcdef\\", \\"xyz\\"] expected_results = [\\"NO\\"] assert can_convert_to_substring(q, queries) == expected_results def test_case_multiple_possible_matches(): q = 1 queries = [\\"aaaaa\\", \\"aa\\"] expected_results = [\\"YES\\"] assert can_convert_to_substring(q, queries) == expected_results @pytest.mark.parametrize(\\"s, t, expected\\", [ (\\"a\\", \\"a\\", \\"YES\\"), (\\"a\\", \\"b\\", \\"NO\\"), (\\"abc\\", \\"cba\\", \\"NO\\"), (\\"abacada\\", \\"aca\\", \\"YES\\"), ]) def test_multiple_cases(s, t, expected): q = 1 queries = [s, t] assert can_convert_to_substring(q, queries) == [expected] if __name__ == \\"__main__\\": pytest.main()","solution":"def can_convert_to_substring(q, queries): results = [] for i in range(q): s = queries[2 * i] t = queries[2 * i + 1] # Check lengths if len(t) > len(s): results.append(\\"NO\\") continue found = False n, m = len(s), len(t) for j in range(n - m + 1): all_match = True for k in range(m): if s[j + k] == t[k] or t[k] == '?': continue all_match = False break if all_match: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def decode_scroll(t: int, test_cases: list, query) -> list: Deciphers the encoded digits from the scroll for given number of test cases. Parameters: - t: int, number of test cases - test_cases: list of int, for each test case the length of string containing distinct digits - query: callable, function that takes an integer input (0 to 9) and returns the position of the digit in the string or -1 if not found Returns: - result: list of str, sorted sequence of digits for each test case Example: >>> decode_scroll(2, [4, 3], lambda d: [ -1, 3, -1, 2, -1, -1, -1, 0, -1, 1, 0, 1, -1, 0, 1][d]) ['1379', '789'] pass def query_func_factory(strings: list) -> callable: Factory to create query functions for test cases. Parameters: - strings: list of str, encoded strings for each test case Returns: - query: callable function Example: >>> query = query_func_factory([\\"9731\\", \\"789\\"]) >>> query.test_case_index = 0 >>> query(7) 0 >>> query(4) -1 pass","solution":"def decode_scroll(t, test_cases, query): Deciphers the encoded digits from the scroll for given number of test cases. Parameters: - t: int, number of test cases - test_cases: list of int, for each test case the length of string containing distinct digits - query: callable, function that takes an integer input (0 to 9) and returns the position of the digit in the string or -1 if not found Returns: - result: list of str, sorted sequence of digits for each test case result = [] for n in test_cases: digits = [] for d in range(10): position = query(d) if position != -1: digits.append(d) result.append(''.join(map(str, sorted(digits)))) return result def query_func_factory(strings): Factory to create query functions for test cases. Parameters: - strings: list of str, encoded strings for each test case Returns: - query: callable function def query(d): current_string = strings[query.test_case_index] try: return current_string.index(str(d)) except ValueError: return -1 query.test_case_index = 0 return query"},{"question":"def maxSubArraySum(arr: List[int], n: int) -> int: Write a function to find the maximum subarray sum for a given array of integers, using the Divide and Conquer technique. Example 1: >>> maxSubArraySum([2, 3, 4, 5, 7], 5) 21 Example 2: >>> maxSubArraySum([-2, -3, 4, -1, -2, 1, 5, -3], 8) 7","solution":"def maxCrossingSum(arr, low, mid, high): # Include elements on the left of mid. left_sum = float('-inf') sum_now = 0 for i in range(mid, low - 1, -1): sum_now += arr[i] if sum_now > left_sum: left_sum = sum_now # Include elements on the right of mid right_sum = float('-inf') sum_now = 0 for i in range(mid + 1, high + 1): sum_now += arr[i] if sum_now > right_sum: right_sum = sum_now # Return sum of elements on left and right of mid return left_sum + right_sum def maxSubArraySumUtil(arr, low, high): # Base Case: Only one element if low == high: return arr[low] # Find middle point mid = (low + high) // 2 # Return maximum of following three possible cases # a) Maximum subarray sum in left half # b) Maximum subarray sum in right half # c) Maximum subarray sum such that the subarray crosses the midpoint return max(maxSubArraySumUtil(arr, low, mid), maxSubArraySumUtil(arr, mid + 1, high), maxCrossingSum(arr, low, mid, high)) def maxSubArraySum(arr, n): return maxSubArraySumUtil(arr, 0, n - 1)"},{"question":"def count_primes(N: int) -> int: Returns the number of prime numbers less than or equal to N. Parameters: N (int): The upper limit to check for primes (inclusive). Returns: int: The count of prime numbers ≤ N. >>> count_primes(10) 4 >>> count_primes(100) 25 >>> count_primes(1) 0","solution":"def count_primes(N): Returns the number of prime numbers less than or equal to N. Parameters: N (int): The upper limit to check for primes (inclusive). Returns: int: The count of prime numbers ≤ N. if N < 2: return 0 # Initialize a list to track prime status of numbers is_prime = [True] * (N + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers # Implementing Sieve of Eratosthenes p = 2 while p * p <= N: if is_prime[p]: for i in range(p * p, N + 1, p): is_prime[i] = False p += 1 # Count prime numbers return sum(is_prime)"},{"question":"def is_happy_number(n: int) -> bool: Determines whether a given number is a happy number. Args: n (int): A positive integer. Returns: bool: True if the number is happy, False otherwise. >>> is_happy_number(7) True >>> is_happy_number(4) False >>> is_happy_number(19) True >>> is_happy_number(2) False","solution":"def is_happy_number(n): Determines whether a given number is a happy number. Args: n (int): A positive integer. Returns: bool: True if the number is happy, False otherwise. def sum_of_squares(num): return sum(int(digit) ** 2 for digit in str(num)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares(n) return n == 1"},{"question":"def sections_to_water(T, test_cases): Rosie is a digital garden enthusiast who wants to automate her garden's water-sprinkling system. The system uses data from soil moisture sensors, which return a sequence of integers representing the moisture levels of different sections of the garden. Rosie wants the system to activate sprinklers in sections where the moisture level is below a certain threshold. Write a program that processes this data and outputs the sections that need watering. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, each containing: - an integer N (number of sections) - an integer M (moisture level threshold) - a list of N integers representing the moisture levels of different sections. Returns: list: A list of strings where each string represents the section indices that need watering for the respective test case. Example: >>> sections_to_water(2, [(5, 30, [40, 20, 35, 25, 45]), (4, 50, [55, 60, 45, 50])]) ['1 3', '2'] >>> sections_to_water(1, [(4, 40, [45, 50, 55, 60])]) ['None']","solution":"def sections_to_water(T, test_cases): This function takes the number of test cases and a list of test cases. Each test case is a tuple with the number of sections, moisture level threshold, and the list of moisture levels in those sections. It returns a list of strings where each string represents the section indices that need watering for the respective test case. results = [] for case in test_cases: N, M, moisture_levels = case sections = [str(i) for i, level in enumerate(moisture_levels) if level < M] results.append(\\" \\".join(sections) if sections else \\"None\\") return results"},{"question":"def longest_beautiful_subsequence(n: int, sequence: List[int]) -> int: Find the length of the longest beautiful subsequence in the given sequence. A \\"beautiful subsequence\\" is defined as a subsequence where no two adjacent elements in the original sequence are the same number. Args: n (int): The length of the sequence. sequence (List[int]): The list of integers representing the sequence. Returns: int: The length of the longest beautiful subsequence. Examples; >>> longest_beautiful_subsequence(5, [1, 2, 2, 3, 1]) 4 >>> longest_beautiful_subsequence(7, [4, 4, 4, 4, 4, 4, 4]) 1 >>> longest_beautiful_subsequence(6, [1, 3, 5, 3, 1, 5]) 6","solution":"def longest_beautiful_subsequence(n, sequence): if n == 0: return 0 # Initialize the length of the longest beautiful subsequence. max_length = 1 # Iterate through the sequence to find the longest beautiful subsequence. for i in range(1, n): if sequence[i] != sequence[i - 1]: max_length += 1 return max_length"},{"question":"def remove_duplicates(arr: List[int]) -> List[int]: Returns a new list with all duplicate elements removed from the input list, preserving the original order. >>> remove_duplicates([1, 2, 3, 2, 4, 1]) [1, 2, 3, 4] >>> remove_duplicates([6, 5, 6, 7]) [6, 5, 7] >>> remove_duplicates([1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([42]) [42] >>> remove_duplicates([i for i in range(1000)] * 2) [i for i in range(1000)]","solution":"def remove_duplicates(arr): Returns a new list with duplicates removed from the input list, preserving the original order. seen = set() result = [] for item in arr: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def final_elevator_floor(n, m, commands): Determines the final floor of the elevator after executing a series of movement commands. Parameters: n (int): The number of floors in the building. m (int): The number of movement commands. commands (list of str): The list of commands in the format \\"UP X\\" or \\"DOWN X\\". Returns: int: The final floor of the elevator. >>> final_elevator_floor(10, 3, [\\"UP 3\\", \\"DOWN 1\\", \\"UP 5\\"]) 8 >>> final_elevator_floor(5, 4, [\\"UP 2\\", \\"UP 3\\", \\"DOWN 4\\", \\"DOWN 1\\"]) 1","solution":"def final_elevator_floor(n, m, commands): Determines the final floor of the elevator after executing a series of movement commands. Parameters: n (int): The number of floors in the building. m (int): The number of movement commands. commands (list of str): The list of commands in the format \\"UP X\\" or \\"DOWN X\\". Returns: int: The final floor of the elevator. current_floor = 1 for command in commands: direction, floors = command.split() floors = int(floors) if direction == \\"UP\\": current_floor = min(n, current_floor + floors) elif direction == \\"DOWN\\": current_floor = max(1, current_floor - floors) return current_floor"},{"question":"from typing import List, Tuple def process_treasure_queries(n: int, m: int, q: int, treasure_grid: List[List[Tuple[int, int]]], queries: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Process treasure queries on a grid and return the sum of gold and number of items in specified sub-grids. >>> n, m, q = 3, 3, 2 >>> treasure_grid = [ ... [(1, 5), (2, 3), (3, 7)], ... [(4, 2), (5, 1), (6, 4)], ... [(7, 3), (8, 2), (9, 5)] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (2, 2, 3, 3) ... ] >>> process_treasure_queries(n, m, q, treasure_grid, queries) [(12, 11), (28, 12)]","solution":"def preprocess(grid, n, m): gold_prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] items_prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): gold_prefix_sum[i][j] = gold_prefix_sum[i - 1][j] + gold_prefix_sum[i][j - 1] - gold_prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1][0] items_prefix_sum[i][j] = items_prefix_sum[i - 1][j] + items_prefix_sum[i][j - 1] - items_prefix_sum[i - 1][j - 1] + grid[i - 1][j - 1][1] return gold_prefix_sum, items_prefix_sum def query_sums(gold_prefix_sum, items_prefix_sum, r1, c1, r2, c2): gold_sum = gold_prefix_sum[r2][c2] - gold_prefix_sum[r1 - 1][c2] - gold_prefix_sum[r2][c1 - 1] + gold_prefix_sum[r1 - 1][c1 - 1] items_sum = items_prefix_sum[r2][c2] - items_prefix_sum[r1 - 1][c2] - items_prefix_sum[r2][c1 - 1] + items_prefix_sum[r1 - 1][c1 - 1] return gold_sum, items_sum def process_treasure_queries(n, m, q, treasure_grid, queries): gold_prefix_sum, items_prefix_sum = preprocess(treasure_grid, n, m) results = [] for query in queries: r1, c1, r2, c2 = query gold_sum, items_sum = query_sums(gold_prefix_sum, items_prefix_sum, r1, c1, r2, c2) results.append((gold_sum, items_sum)) return results"},{"question":"def is_palindrome_number(s): Checks if the given string s is a palindrome number. Parameters: s (str): A string representing a number. Returns: str: \\"YES\\" if the string is a palindrome number, otherwise \\"NO\\". >>> is_palindrome_number(\\"121\\") \\"YES\\" >>> is_palindrome_number(\\"123001321\\") \\"NO\\"","solution":"def is_palindrome_number(s): Checks if the given string s is a palindrome number. Parameters: s (str): A string representing a number. Returns: str: \\"YES\\" if the string is a palindrome number, otherwise \\"NO\\". return \\"YES\\" if s == s[::-1] else \\"NO\\""},{"question":"from typing import List def max_consecutive_sum(lst: List[int], C: int) -> int: Finds the maximum sum of C consecutive integers in the list. If the list has fewer than C elements, return -1. >>> max_consecutive_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) 34 >>> max_consecutive_sum([1, 2, 3], 4) -1 >>> max_consecutive_sum([5], 1) 5 >>> max_consecutive_sum([4, 4, 4, 4], 2) 8 >>> max_consecutive_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_consecutive_sum([i for i in range(1, 100001)], 100000) 5000050000 >>> max_consecutive_sum([5, -2, 2, -3, 7], 3) 6","solution":"def max_consecutive_sum(lst, C): Finds the maximum sum of C consecutive integers in the list. If the list has fewer than C elements, return -1. if len(lst) < C: return -1 # Calculate the sum of the first C elements max_sum = sum(lst[:C]) current_sum = max_sum # Use sliding window technique to find maximum sum of C consecutive numbers for i in range(C, len(lst)): current_sum = current_sum + lst[i] - lst[i - C] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_operations_to_sort_books(n: int, heights: List[int]) -> int: Returns the minimum number of operations needed to sort the books in non-decreasing order. >>> min_operations_to_sort_books(5, [3, 2, 1, 4, 5]) == 1 >>> min_operations_to_sort_books(6, [4, 3, 1, 2, 5, 6]) == 2 >>> min_operations_to_sort_books(4, [1, 2, 3, 4]) == 0","solution":"def min_operations_to_sort_books(n, heights): Returns the minimum number of operations needed to sort the books in non-decreasing order. sorted_heights = sorted(heights) if heights == sorted_heights: return 0 # Identify the segments that are out of order start, end = 0, n - 1 while start < n and heights[start] == sorted_heights[start]: start += 1 while end >= 0 and heights[end] == sorted_heights[end]: end -= 1 if heights[start:end + 1] == sorted_heights[start:end + 1][::-1]: return 1 return 2"},{"question":"def max_visitors(durations): Returns the maximum number of visitors present in the park at the same time. :param durations: List of tuples containing entry and exit times in HH:MM format. :return: Maximum number of visitors present at the same time. >>> max_visitors([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"11:00\\"), (\\"10:15\\", \\"11:30\\")]) == 2 >>> max_visitors([(\\"08:00\\", \\"08:30\\"), (\\"08:15\\", \\"09:00\\"), (\\"08:45\\", \\"09:30\\"), (\\"09:00\\", \\"09:45\\")]) == 3 pass def parse_input(input_str): Parse the input string to extract test cases. :param input_str: Input string in the specified format. :return: List of results for each test case. >>> parse_input(\\"2n3n09:00 10:00n09:30 11:00n10:15 11:30n4n08:00 08:30n08:15 09:00n08:45 09:30n09:00 09:45\\") == [2, 3] >>> parse_input(\\"1n1n00:00 23:59\\") == [1] pass","solution":"def max_visitors(durations): Returns the maximum number of visitors present in the park at the same time. :param durations: List of tuples containing entry and exit times in HH:MM format. :return: Maximum number of visitors present at the same time. events = [] for entry, exit in durations: events.append((entry, 'entry')) events.append((exit, 'exit')) events.sort() current_visitors = 0 max_visitors = 0 for time, event_type in events: if event_type == 'entry': current_visitors += 1 if current_visitors > max_visitors: max_visitors = current_visitors else: current_visitors -= 1 return max_visitors def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 results = [] for _ in range(T): M = int(lines[idx]) idx += 1 durations = [] for _ in range(M): entry, exit = lines[idx].split() durations.append((entry, exit)) idx += 1 results.append(max_visitors(durations)) return results"},{"question":"def transformArray(nums): Given an array of integers nums, replace each element in the array with the product of all other elements in the array without using the division operation. >>> transformArray([1, 2, 3, 4]) [24, 12, 8, 6] >>> transformArray([3, 5]) [5, 3] >>> transformArray([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> transformArray([100, 200, 300]) [60000, 30000, 20000]","solution":"def transformArray(nums): Transforms the array such that each element is replaced with the product of all other elements. length = len(nums) left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def tsp(cities): Find the length of the shortest Hamiltonian cycle which visits all cities exactly once. Args: cities (List[List[int]]): A 2D list containing distances between cities. Returns: int: The length of the shortest Hamiltonian cycle. >>> tsp([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> tsp([ ... [0, 29, 20], ... [29, 0, 15], ... [20, 15, 0] ... ]) 64","solution":"def tsp(cities): n = len(cities) memo = [[None] * (1 << n) for _ in range(n)] def dp(city, mask): if mask == (1 << n) - 1: return cities[city][0] if memo[city][mask] is not None: return memo[city][mask] ans = float('inf') for next_city in range(n): if mask & (1 << next_city) == 0: new_mask = mask | (1 << next_city) ans = min(ans, cities[city][next_city] + dp(next_city, new_mask)) memo[city][mask] = ans return ans return dp(0, 1) # Example usage: # n = 4 # cities = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(tsp(cities)) # Output: 80 # n = 3 # cities = [ # [0, 29, 20], # [29, 0, 15], # [20, 15, 0] # ] # print(tsp(cities)) # Output: 64"},{"question":"def min_replacements_to_palindrome(t: int, test_cases: List[Union[int, str]]) -> List[int]: Determine the minimum number of replacements required to make each sequence a palindrome. Args: t : int : The number of test cases. test_cases : List[Union[int, str]] : The list of sequences lengths and sequences strings. Returns: List[int] : A list of minimum replacements required for each sequence. >>> min_replacements_to_palindrome(4, [5, 'HELLO', 3, 'ABC', 6, 'XYZZYX', 7, 'ABCDEFG']) [2, 1, 0, 3] >>> min_replacements_to_palindrome(2, [4, 'ABBA', 2, 'AB']) [0, 1] >>> min_replacements_to_palindrome(1, [1, 'A']) [0] >>> min_replacements_to_palindrome(1, [2, 'AA']) [0] >>> min_replacements_to_palindrome(3, [3, 'ABA', 3, 'XYZ', 5, 'MOTEM']) [0, 1, 1]","solution":"def min_replacements_to_palindrome(t, test_cases): results = [] for i in range(t): n = test_cases[i * 2] s = test_cases[i * 2 + 1] count = 0 for j in range(n // 2): if s[j] != s[n - j - 1]: count += 1 results.append(count) return results"},{"question":"def min_operations_to_convert(n: int, s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t or -1 if it is impossible. >>> min_operations_to_convert(4, \\"abcd\\", \\"dcba\\") 2 >>> min_operations_to_convert(5, \\"aabbc\\", \\"ababc\\") 1 >>> min_operations_to_convert(3, \\"abc\\", \\"def\\") -1 pass","solution":"def min_operations_to_convert(n, s, t): Returns the minimum number of operations required to convert string s into string t or -1 if it is impossible. # Check if s can be converted to t by comparing sorted versions if sorted(s) != sorted(t): return -1 # Count mismatch positions mismatch_positions = [] for i in range(n): if s[i] != t[i]: mismatch_positions.append(i) # Return half of the number of mismatch positions since each swap fixes two positions return len(mismatch_positions) // 2"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluates a given RPN (Reverse-Polish Notation) expression and returns the result. :param expression: A string containing the RPN expression :return: The integer result of evaluating the RPN expression >>> evaluate_rpn(\\"3 4 +\\") 7 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_rpn(\\"10 2 / 4 * 3 -\\") 17 >>> evaluate_rpn(\\"-3 -4 +\\") -7 >>> evaluate_rpn(\\"3 -4 *\\") -12","solution":"def evaluate_rpn(expression): Evaluates a given RPN (Reverse-Polish Notation) expression and returns the result. :param expression: A string containing the RPN expression :return: The integer result of evaluating the RPN expression stack = [] tokens = expression.split() for token in tokens: if token in \\"+-*/\\": operand2 = stack.pop() operand1 = stack.pop() if token == '+': result = operand1 + operand2 elif token == '-': result = operand1 - operand2 elif token == '*': result = operand1 * operand2 else: # token == '/' result = int(operand1 / operand2) # Integer division preserving the sign stack.append(result) else: stack.append(int(token)) return stack[0]"},{"question":"def interleave_sequences(list1: List[int], list2: List[int]) -> List[int]: Returns a new list where the elements of list1 and list2 are interleaved. If one list is longer than the other, the remaining elements of the longer list are appended to the end of the interleaved list. >>> interleave_sequences([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> interleave_sequences([1, 3, 5], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 8, 10] >>> interleave_sequences([10, 20, 30, 40], [1, 2]) [10, 1, 20, 2, 30, 40]","solution":"def interleave_sequences(list1, list2): Returns a new list where the elements of list1 and list2 are interleaved. If one list is longer than the other, the remaining elements of the longer list are appended to the end of the interleaved list. min_len = min(len(list1), len(list2)) interleaved = [] for i in range(min_len): interleaved.append(list1[i]) interleaved.append(list2[i]) # Append remaining elements of the longer list if len(list1) > len(list2): interleaved.extend(list1[min_len:]) else: interleaved.extend(list2[min_len:]) return interleaved"},{"question":"def check_sticker_collection(stickers: str) -> str: Checks if the collection contains at least one of each type of the five distinct stickers. Args: stickers: A string containing the list of animal names separated by spaces. Returns: \\"WIN\\" if collection contains all five types of stickers, otherwise \\"LOSE\\". >>> check_sticker_collection(\\"tiger elephant rabbit lion giraffe rabbit tiger\\") 'WIN' >>> check_sticker_collection(\\"tiger elephant rabbit lion rabbit tiger\\") 'LOSE'","solution":"def check_sticker_collection(stickers): Checks if the collection contains at least one of each type of the five distinct stickers. Args: stickers: A string containing the list of animal names separated by spaces. Returns: \\"WIN\\" if collection contains all five types of stickers, otherwise \\"LOSE\\". required_stickers = {\\"tiger\\", \\"elephant\\", \\"rabbit\\", \\"lion\\", \\"giraffe\\"} collected_stickers = set(stickers.split()) if required_stickers.issubset(collected_stickers): return \\"WIN\\" else: return \\"LOSE\\""},{"question":"def check_license_compliance(n, license_list): Determine if any license string is a substring of any other license string. Parameters: n (int): Number of license strings. license_list (list): List containing license strings. Returns: str: \\"YES\\" if any license string is a substring of any other license string, \\"NO\\" otherwise. pass # Example usage: # N = 4 # license_list = [\\"abcd\\", \\"efgh\\", \\"ab\\", \\"ef\\"] # print(check_license_compliance(N, license_list)) # Output should be \\"YES\\"","solution":"def check_license_compliance(n, license_list): Determine if any license string is a substring of any other license string. Parameters: n (int): Number of license strings. license_list (list): List containing license strings. Returns: str: \\"YES\\" if any license string is a substring of any other license string, \\"NO\\" otherwise. for i in range(n): for j in range(n): if i != j and license_list[i] in license_list[j]: return \\"YES\\" return \\"NO\\" # Example usage: # N = 4 # license_list = [\\"abcd\\", \\"efgh\\", \\"ab\\", \\"ef\\"] # print(check_license_compliance(N, license_list)) # Output should be \\"YES\\""},{"question":"def determine_winner(X): Determines the winner of the game given X. Player 1 is represented by 1 and Player 2 is represented by 2. >>> determine_winner(1) 2 >>> determine_winner(5) 1 pass def game_winner(T, test_cases): Determines the winner for each test case. T: Number of test cases. test_cases: List of integers representing each test case. Returns a list of winners for each test case. >>> game_winner(1, [1]) [2] >>> game_winner(2, [5, 10]) [1, 1] pass","solution":"def determine_winner(X): Determines the winner of the game given X. Player 1 is represented by 1 and Player 2 is represented by 2. if X == 1: return 2 else: return 1 def game_winner(T, test_cases): Determines the winner for each test case. T: Number of test cases. test_cases: List of integers representing each test case. Returns a list of winners for each test case. results = [] for X in test_cases: results.append(determine_winner(X)) return results # Example usage: T = 2 test_cases = [5, 10] print(game_winner(T, test_cases)) # Output: [1, 1]"},{"question":"def minimal_new_items(n: int, k: int, items: List[int]) -> int: Returns the minimum number of new items Maria needs to add to her collection to have exactly k unique items. Parameters: n (int): The number of items currently in Maria's collection. k (int): The desired number of unique items in Maria's collection. items (List[int]): The items currently in Maria's collection. Returns: int: The minimum number of new items required. >>> minimal_new_items(5, 3, [1, 2, 2, 3, 1]) 0 >>> minimal_new_items(4, 6, [1, 2, 3, 4]) 2 >>> minimal_new_items(3, 2, [5, 5, 5]) 1","solution":"def minimal_new_items(n, k, items): Returns the minimum number of new items Maria needs to add to her collection to have exactly k unique items. Parameters: n (int): The number of items currently in Maria's collection. k (int): The desired number of unique items in Maria's collection. items (list of int): The items currently in Maria's collection. Returns: int: The minimum number of new items required. unique_items = set(items) # Get the set of unique items current_unique_count = len(unique_items) if current_unique_count >= k: return 0 else: return k - current_unique_count"},{"question":"def replicate_tree(initial_value: int, levels: int, threshold: int) -> list: Simulates the growth of a replicating tree. Args: initial_value (int): The initial value of the root node. levels (int): The number of levels to grow the tree. threshold (int): The maximum value a node is allowed to have. Returns: list of lists: A list where each inner list represents a level of the tree. Example: >>> replicate_tree(1, 3, 50) [[1], [2, 3], [4, 5, 6, 7]] >>> replicate_tree(10, 1, 50) [[10]] >>> replicate_tree(1, 3, 6) [[1], [2, 3], [4, 5, 6]] >>> replicate_tree(2, 4, 100) [[2], [4, 5], [8, 9, 10, 11], [16, 17, 18, 19, 20, 21, 22, 23]] >>> replicate_tree(51, 3, 50) [[51]]","solution":"def replicate_tree(initial_value, levels, threshold): Simulates the growth of a replicating tree. Args: initial_value (int): The initial value of the root node. levels (int): The number of levels to grow the tree. threshold (int): The maximum value a node is allowed to have. Returns: list of lists: A list where each inner list represents a level of the tree. result = [[initial_value]] for level in range(1, levels): previous_level = result[level - 1] current_level = [] for value in previous_level: new_value1 = value + value new_value2 = value + (value + 1) if new_value1 <= threshold: current_level.append(new_value1) if new_value2 <= threshold: current_level.append(new_value2) if not current_level: break result.append(current_level) return result"},{"question":"def find_max_difference(arr): Finds the maximum difference between two elements in the array where the smaller element appears before the larger element. :param arr: List[int] - List of integers :return: int - Maximum difference >>> find_max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> find_max_difference([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 0 >>> find_max_difference([1, 2, 3, 4, 5, 6]) 5 from typing import List","solution":"def find_max_difference(arr): Finds the maximum difference between two elements in the array where the smaller element appears before the larger element. :param arr: List[int] - List of integers :return: int - Maximum difference if not arr or len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for value in arr[1:]: max_diff = max(max_diff, value - min_element) min_element = min(min_element, value) return max_diff"},{"question":"def max_requests(requests, capacity): Determine the maximum number of requests that can be handled without exceeding the capacity. Args: requests (list): List of request sizes. capacity (int): Maximum total size the server can handle. Returns: int: Maximum number of requests that can be handled. >>> max_requests([4, 8, 5, 9], 20) == 3 >>> max_requests([4, 4, 4, 4, 4], 20) == 5 >>> max_requests([6, 7, 8, 9, 10], 15) == 2 >>> max_requests([10], 10) == 1 >>> max_requests([1, 2, 3], 0) == 0 >>> max_requests([], 10) == 0 >>> max_requests([1, 2, 1, 2], 50) == 4 >>> max_requests([5, 15, 10, 5], 20) == 3 >>> max_requests([19, 1, 2, 5, 10], 20) == 4","solution":"def max_requests(requests, capacity): Determine the maximum number of requests that can be handled without exceeding the capacity. Args: requests (list): List of request sizes. capacity (int): Maximum total size the server can handle. Returns: int: Maximum number of requests that can be handled. requests.sort() total_size = 0 count = 0 for req in requests: if total_size + req <= capacity: total_size += req count += 1 else: break return count"},{"question":"import itertools from typing import List def lexicographical_permutations(s: str) -> List[str]: Generates all permutations of the string in lexicographical order. Args: s (str): The input string Returns: List[str]: A list of all permutations in lexicographical order >>> lexicographical_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> lexicographical_permutations(\\"baa\\") [\\"aab\\", \\"aba\\", \\"baa\\"]","solution":"import itertools def lexicographical_permutations(s): Generates all permutations of the string in lexicographical order. Args: s (string): The input string Returns: list: A list of all permutations in lexicographical order permutations = sorted(set(''.join(p) for p in itertools.permutations(s))) return permutations"},{"question":"class Library: A simple library management system to keep track of books and their availability. Methods: - add_book: Adds a new book with the given title. - borrow_book: Borrows a book if it is available. - return_book: Returns a book if it was borrowed. - list_books: Lists all books with their status (available or borrowed). Example usage: library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"War and Peace\\") # List books library.list_books() # Output: [('The Great Gatsby', 'available'), ('War and Peace', 'available')] # Borrow a book library.borrow_book(\\"The Great Gatsby\\") # Output: \\"You've borrowed 'The Great Gatsby'\\" # Try to borrow it again library.borrow_book(\\"The Great Gatsby\\") # Output: \\"'The Great Gatsby' is already borrowed.\\" # Return it library.return_book(\\"The Great Gatsby\\") # Output: \\"You've returned 'The Great Gatsby'\\" # List books again library.list_books() # Output: [('The Great Gatsby', 'available'), ('War and Peace', 'available')] def __init__(self): self.books = {} def add_book(self, title: str): Adds a new book with the given title. Args: title (str): The title of the book to be added. pass def borrow_book(self, title: str): Borrows a book if it is available. Args: title (str): The title of the book to be borrowed. Returns: str: A message indicating the result of the operation. pass def return_book(self, title: str): Returns a book if it was borrowed. Args: title (str): The title of the book to be returned. Returns: str: A message indicating the result of the operation. pass def list_books(self): Lists all books with their status ('available' or 'borrowed'). Returns: List[Tuple[str, str]]: A list of tuples where each tuple contains the title of the book and its status. pass","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title): self.books[title] = \\"available\\" def borrow_book(self, title): if title not in self.books: return f\\"'{title}' does not exist in the library.\\" if self.books[title] == \\"borrowed\\": return f\\"'{title}' is already borrowed.\\" self.books[title] = \\"borrowed\\" return f\\"You've borrowed '{title}'\\" def return_book(self, title): if title not in self.books: return f\\"'{title}' does not exist in the library.\\" if self.books[title] == \\"available\\": return f\\"'{title}' was not borrowed.\\" self.books[title] = \\"available\\" return f\\"You've returned '{title}'\\" def list_books(self): return [(title, status) for title, status in self.books.items()] # Example usage library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"War and Peace\\") # List books print(library.list_books()) # Output: [('The Great Gatsby', 'available'), ('War and Peace', 'available')] # Borrow a book print(library.borrow_book(\\"The Great Gatsby\\")) # Output: \\"You've borrowed 'The Great Gatsby'\\" # Try to borrow it again print(library.borrow_book(\\"The Great Gatsby\\")) # Output: \\"'The Great Gatsby' is already borrowed.\\" # Return it print(library.return_book(\\"The Great Gatsby\\")) # Output: \\"You've returned 'The Great Gatsby'\\" # List books again print(library.list_books()) # Output: [('The Great Gatsby', 'available'), ('War and Peace', 'available')]"},{"question":"def outage_probability(n: int, h: List[int]) -> float: Calculate the probability that the next minute will be an outage. Parameters: n (int): The number of minutes in the history. h (list of int): The history of outages, where 0 means no outage and 1 means outage. Returns: float: The probability that the next minute will be an outage. Examples: >>> outage_probability(5, [0, 1, 0, 1, 1]) 0.600000 >>> outage_probability(3, [1, 0, 0]) 0.333333 >>> outage_probability(4, [0, 0, 0, 0]) 0.000000","solution":"def outage_probability(n, h): Calculate the probability that the next minute will be an outage. Parameters: n (int): The number of minutes in the history. h (list of int): The history of outages, where 0 means no outage and 1 means outage. Returns: float: The probability that the next minute will be an outage. outage_count = sum(h) if n == 0: return 0.0 return outage_count / n"},{"question":"def max_fertile_area(m: int, n: int, field: List[str]) -> int: Returns the area of the largest contiguous rectangular block of fertile cells. >>> max_fertile_area(4, 4, [ ... \\"FFFF\\", ... \\"FFBF\\", ... \\"FFFF\\", ... \\"FBFF\\" ... ]) 6 >>> max_fertile_area(5, 6, [ ... \\"FFFFFF\\", ... \\"FFFFBF\\", ... \\"FFBBFF\\", ... \\"FFFFFF\\", ... \\"BBFFFF\\" ... ]) 8 >>> max_fertile_area(3, 3, [ ... \\"FBF\\", ... \\"BFB\\", ... \\"FBF\\" ... ]) 1 >>> max_fertile_area(2, 3, [ ... \\"FFF\\", ... \\"FFF\\" ... ]) 6 >>> max_fertile_area(3, 4, [ ... \\"BBBB\\", ... \\"BBBB\\", ... \\"BBBB\\" ... ]) 0 >>> max_fertile_area(1, 1, [ ... \\"F\\" ... ]) 1 >>> max_fertile_area(1, 1, [ ... \\"B\\" ... ]) 0","solution":"def max_fertile_area(m, n, field): Returns the area of the largest contiguous rectangular block of fertile cells. # Create a height array to store the height of 'F' (fertile) cells. height = [0] * n max_area = 0 for i in range(m): for j in range(n): if field[i][j] == 'F': height[j] += 1 else: height[j] = 0 # Now calculate the max area for the histogram formed by the heights max_area = max(max_area, largest_rectangle_area(height)) return max_area def largest_rectangle_area(heights): Helper function to find the largest rectangle area in a histogram. stack = [] max_area = 0 heights.append(0) # Sentinel value to pop all elements from stack at the end for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() # Remove the sentinel return max_area"},{"question":"def min_subarray_len(n: int, s: int, nums: List[int]) -> int: Returns the minimum length of a contiguous subarray of which the sum is at least s. If there is no such subarray, returns 0. >>> min_subarray_len(10, 15, [5, 1, 3, 5, 10, 7, 4, 9, 2, 8]) == 2 >>> min_subarray_len(5, 100, [1, 2, 3, 4, 5]) == 0","solution":"def min_subarray_len(n, s, nums): Returns the minimum length of a contiguous subarray of which the sum is at least s. If there is no such subarray, returns 0. left = 0 curr_sum = 0 min_len = n + 1 for right in range(n): curr_sum += nums[right] while curr_sum >= s: min_len = min(min_len, right - left + 1) curr_sum -= nums[left] left += 1 if min_len == n + 1: return 0 else: return min_len"},{"question":"def min_difference_barn_cows(N: int, cows: List[int]) -> int: Compute the minimum possible difference between the sum of cows in the first half of the barns and the sum in the second half after zero or more swap operations. :param N: Number of barns :param cows: List of cow counts in each barn :return: Minimum possible difference pass from solution import min_difference_barn_cows def test_case_1(): assert min_difference_barn_cows(6, [1, 2, 3, 4, 5, 6]) == 1 def test_case_2(): assert min_difference_barn_cows(5, [10, 20, 30, 40, 50]) == 10 def test_case_3(): assert min_difference_barn_cows(4, [1, 1, 1, 1]) == 0 def test_case_4(): assert min_difference_barn_cows(3, [7, 10, 5]) == 2 def test_case_5(): assert min_difference_barn_cows(8, [1, 1, 1, 1, 1, 1, 1, 1]) == 0 def test_case_6(): assert min_difference_barn_cows(1, [100]) == 100 def test_case_7(): assert min_difference_barn_cows(6, [100, 200, 300, 400, 500, 600]) == 100","solution":"def min_difference_barn_cows(N, cows): Compute the minimum possible difference between the sum of cows in the first half of the barns and the sum in the second half after zero or more swap operations. :param N: Number of barns :param cows: List of cow counts in each barn :return: Minimum possible difference total_sum = sum(cows) target = total_sum // 2 # Using Dynamic Programming to solve the Partition Problem to find the closest sum to target dp = [0] * (target + 1) for cow in cows: for j in range(target, cow - 1, -1): dp[j] = max(dp[j], dp[j - cow] + cow) sum1 = dp[target] sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def max_profit(prices): Returns the maximum profit from a single buy and sell of stock. If no profit can be achieved, returns 0. :param prices: List of stock prices at different times in chronological order. :return: Maximum possible profit. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit from a single buy and sell of stock. If no profit can be achieved, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"from typing import List from collections import defaultdict def group_anagrams(arr: List[str]) -> List[List[str]]: Given an array of strings, group the anagrams together. An anagram is a word formed by rearranging the letters of another, such as \\"listen\\" and \\"silent\\". Examples: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]] Returns: A list of lists, where each list contains strings which are anagrams of each other.","solution":"from collections import defaultdict def group_anagrams(arr): Groups anagrams together. :param arr: List of strings :return: List of lists, where each sublist contains anagrams anagrams = defaultdict(list) for word in arr: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def can_form_palindrome(s: str) -> str: Checks if the given string can be rearranged to form a palindrome. Args: s (str): input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"aabbcc\\") \\"YES\\" >>> can_form_palindrome(\\"aabbccc\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"def can_form_palindrome(s): Checks if the given string can be rearranged to form a palindrome. Args: s (str): input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each character count = Counter(s) # Count the number of characters with odd frequency odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def printDiamond(n): Prints a diamond pattern of asterisks with the given integer n. >>> printDiamond(3) * *** * >>> printDiamond(5) * *** ***** *** * pass from solution import printDiamond import io import sys def capture_output(func, *args, **kwargs): captured_output = io.StringIO() sys.stdout = captured_output func(*args, **kwargs) sys.stdout = sys.__stdout__ return captured_output.getvalue() def test_diamond_3(): output = capture_output(printDiamond, 3) expected_output = \\" *n***n *n\\" assert output == expected_output def test_diamond_5(): output = capture_output(printDiamond, 5) expected_output = \\" *n ***n*****n ***n *n\\" assert output == expected_output def test_diamond_7(): output = capture_output(printDiamond, 7) expected_output = \\" *n ***n *****n*******n *****n ***n *n\\" assert output == expected_output def test_diamond_invalid_even(): output = printDiamond(4) assert output == \\"n must be an odd number\\"","solution":"def printDiamond(n): Prints a diamond pattern of asterisks with the given integer n. if n % 2 == 0: return \\"n must be an odd number\\" mid = n // 2 # Generate the upper part of the diamond for i in range(mid + 1): stars = '*' * (2 * i + 1) spaces = ' ' * (mid - i) print(spaces + stars) # Generate the lower part of the diamond for i in range(mid - 1, -1, -1): stars = '*' * (2 * i + 1) spaces = ' ' * (mid - i) print(spaces + stars)"},{"question":"def find_unique_number(n: int, sequence: List[int]) -> int: Finds the unique number in the sequence where every other number appears exactly twice. Parameters: n (int): Length of the sequence. sequence (list): List of integers containing exactly one unique number. Returns: int: The unique number in the sequence. >>> find_unique_number(5, [2, 3, 4, 3, 2]) 4 >>> find_unique_number(7, [5, 1, 2, 1, 5, 3, 2]) 3 >>> find_unique_number(3, [0, 1, 1]) 0 pass","solution":"def find_unique_number(n, sequence): Finds the unique number in the sequence where every other number appears exactly twice. Parameters: n (int): Length of the sequence. sequence (list): List of integers containing exactly one unique number. Returns: int: The unique number in the sequence. unique = 0 for num in sequence: unique ^= num return unique"},{"question":"def sum_large_decimals(a: str, b: str) -> str: Returns the sum of two large decimal numbers represented as strings. >>> sum_large_decimals(\\"1234.56789\\", \\"9876.54321\\") \\"11111.1111\\" >>> sum_large_decimals(\\"-12345.6789\\", \\"12345.6789\\") \\"0.0\\" >>> sum_large_decimals(\\"0.1234\\", \\"0.8766\\") \\"1.0\\" >>> sum_large_decimals(\\"-999.99999\\", \\"-0.00001\\") \\"-1000.0\\"","solution":"def sum_large_decimals(a, b): Returns the sum of two large decimal numbers represented as strings. return str(float(a) + float(b)) # Example usage: # A = \\"1234.56789\\" # B = \\"9876.54321\\" # result = sum_large_decimals(A, B) # print(result) # Output should be \\"11111.1111\\""},{"question":"def intersection(nums1: List[int], nums2: List[int]) -> List[int]: Find the intersection of two sorted arrays and return the result in sorted order without duplicates. >>> intersection([1,2,2,1], [2,2]) [2] >>> intersection([4,9,5], [9,4,9,8,4]) [4, 9]","solution":"def intersection(nums1, nums2): Find the intersection of two sorted arrays and return the result in sorted order without duplicates. # Convert both lists to sets to remove duplicates and find the intersection set1 = set(nums1) set2 = set(nums2) # Find the intersection result = list(set1 & set2) # Sort the result result.sort() return result"},{"question":"def calculate_magic_values(N: int, A: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the sum of magic values for each query in the forest. Parameters: N (int): Number of unique types of fruits. A (List[int]): The array representing the magic values of the fruits. queries (List[Tuple[int, int]]): Each tuple contains two integers (Li, Ri) representing a query. Returns: List[int]: The sum of magic values for each query. Example: >>> calculate_magic_values(5, [5, 3, 8, 6, 7], [(1, 3), (2, 5), (1, 5)]) [16, 24, 29] >>> calculate_magic_values(1, [100], [(1, 1)]) [100] >>> calculate_magic_values(4, [5, 5, 5, 5], [(1, 2), (2, 3), (1, 4)]) [10, 10, 20] >>> calculate_magic_values(7, [1, 3, 5, 7, 9, 11, 13], [(1, 7), (1, 3), (4, 7)]) [49, 9, 40] >>> calculate_magic_values(2, [1, 2], [(1, 1), (2, 2)]) [1, 2]","solution":"def calculate_magic_values(N, A, queries): Calculate the sum of magic values for each query in the forest. N: int - Number of unique types of fruits. A: list of int - The array representing the magic values of the fruits. queries: list of tuple - Each tuple contains two integers (Li, Ri) representing a query. Returns a list of integers - The sum of magic values for each query. # Precompute prefix sum arrays from collections import defaultdict # Initialize prefix sums and counts prefix_sum = [0] * (N + 1) prefix_count = defaultdict(lambda: [0] * (N + 1)) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] for k, v in prefix_count.items(): prefix_count[k][i] = prefix_count[k][i - 1] prefix_count[A[i - 1]][i] += 1 results = [] for Li, Ri in queries: sum_magic_value = 0 for k, v in prefix_count.items(): count_in_range = v[Ri] - v[Li - 1] if count_in_range > 0: sum_magic_value += k * count_in_range results.append(sum_magic_value) return results # Example usage N = 5 A = [5, 3, 8, 6, 7] queries = [(1, 3), (2, 5), (1, 5)] print(calculate_magic_values(N, A, queries)) # Output should be [16, 24, 29]"},{"question":"def min_total_expense(n, c, widths, costs): Calculate the minimum possible total expense the farmer can achieve if they must plow at least one field and can decide the range of fields to be plowed in a single sequence. :param n: int, number of fields :param c: int, fixed overhead cost per sequence :param widths: list of ints, widths of the fields :param costs: list of ints, costs of plowing the fields :return: int, minimum possible total expense >>> min_total_expense(4, 10, [3, 1, 4, 2], [5, 2, 7, 3]) 12 >>> min_total_expense(1, 10, [5], [10]) 20 >>> min_total_expense(5, 5, [1, 1, 1, 1, 1], [2, 2, 2, 2, 2]) 7 >>> min_total_expense(4, 5, [1, 2, 3, 4], [1, 2, 3, 4]) 6 >>> min_total_expense(4, 5, [2, 2, 2, 2], [2, 5, 2, 5]) 7 >>> min_total_expense(3, 1000000000, [1, 2, 3], [4, 5, 6]) 1000000004","solution":"def min_total_expense(n, c, widths, costs): Calculate the minimum possible total expense the farmer can achieve if they must plow at least one field and can decide the range of fields to be plowed in a single sequence. :param n: int, number of fields :param c: int, fixed overhead cost per sequence :param widths: list of ints, widths of the fields :param costs: list of ints, costs of plowing the fields :return: int, minimum possible total expense min_expense = float('inf') current_sum = 0 for i in range(n): if i == 0: current_sum = costs[i] + c else: current_sum = min(current_sum + costs[i], costs[i] + c) min_expense = min(min_expense, current_sum) return min_expense"},{"question":"def track_package(n, checkpoints, expected_checkpoints): Tracks the package's journey through a given list of checkpoints and determines the total travel time and missing checkpoints. >>> track_package(3, [(\\"Start\\", 5), (\\"Midway\\", 25), (\\"End\\", 45)], [\\"Start\\", \\"Midway\\", \\"End\\"]) (40, \\"All checkpoints accounted for\\") >>> track_package(5, [(\\"Warehouse\\", 10), (\\"Checkpoint_1\\", 30), (\\"Checkpoint_3\\", 50), (\\"Checkpoint_4\\", 70), (\\"Destination\\", 100)], [\\"Warehouse\\", \\"Checkpoint_1\\", \\"Checkpoint_2\\", \\"Checkpoint_3\\", \\"Checkpoint_4\\", \\"Destination\\"]) (90, \\"Checkpoint_2\\") import sys def main(): input = sys.stdin.read data = input().splitlines() n = int(data[0]) checkpoints = [] for i in range(1, n + 1): loc, time = data[i].split() checkpoints.append((loc, int(time))) expected_checkpoints = data[n + 1].split() result_time, result_missing = track_package(n, checkpoints, expected_checkpoints) print(result_time) print(result_missing) if __name__ == \\"__main__\\": main()","solution":"def track_package(n, checkpoints, expected_checkpoints): recorded_locations = {loc: timestamp for loc, timestamp in checkpoints} total_travel_time = checkpoints[-1][1] - checkpoints[0][1] missing_checkpoints = [loc for loc in expected_checkpoints if loc not in recorded_locations] result_time = total_travel_time result_missing = \\"All checkpoints accounted for\\" if not missing_checkpoints else ' '.join(missing_checkpoints) return result_time, result_missing def main(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) checkpoints = [] for i in range(1, n + 1): loc, time = data[i].split() checkpoints.append((loc, int(time))) expected_checkpoints = data[n + 1].split() result_time, result_missing = track_package(n, checkpoints, expected_checkpoints) print(result_time) print(result_missing)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestString(root: TreeNode) -> str: Return the largest string that can be formed from root to any leaf node, lexicographically. >>> root = TreeNode('b') >>> root.left = TreeNode('a') >>> root.right = TreeNode('d') >>> root.left.left = TreeNode('c') >>> root.right.left = TreeNode('e') >>> root.right.right = TreeNode('f') >>> findLargestString(root) 'bdf'","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLargestString(root: TreeNode) -> str: def dfs(node, path): if not node: return [] path.append(node.val) if not node.left and not node.right: # It's a leaf node, return the current path (as a string) res = ''.join(path) path.pop() return [res] # Recursively visit both subtrees and concatenate results left_paths = dfs(node.left, path) right_paths = dfs(node.right, path) path.pop() return left_paths + right_paths if not root: return \\"\\" # Start DFS from the root node all_paths = dfs(root, []) # Find the lexicographically largest string return max(all_paths)"},{"question":"def containsNearbyDuplicate(nums: List[int], k: int) -> bool: Determine whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Parameters: nums (List[int]): An array of integers k (int): The maximum allowed absolute difference between the indices of duplicate integers Returns: bool: True if such elements exist, otherwise False Examples: >>> containsNearbyDuplicate([1, 2, 3, 1], 3) True >>> containsNearbyDuplicate([1, 0, 1, 1], 1) True >>> containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 2) False >>> containsNearbyDuplicate([10, 20, 30, 40], 2) False >>> containsNearbyDuplicate([1], 1) False","solution":"def containsNearbyDuplicate(nums, k): Determines if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. Parameters: nums (List[int]): An array of integers k (int): The maximum allowed absolute difference between the indices of duplicate integers Returns: bool: True if such elements exist, otherwise False index_map = {} for i, num in enumerate(nums): if num in index_map and i - index_map[num] <= k: return True index_map[num] = i return False"},{"question":"def max_subarray_sum(arr): Returns the maximum subarray sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([0]) 0 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([1, 2, -1, 2, 3, -5, 4]) 7 >>> max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]) 7","solution":"def max_subarray_sum(arr): Returns the maximum subarray sum. # Initialize variables max_sum = arr[0] current_sum = arr[0] # Iterate through the array starting from the second element for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:1 + N])) print(max_subarray_sum(arr))"},{"question":"def calculateDiscount(originalPrice: float, discountPercentage: float) -> float: Calculate the final price after applying a discount to the original price. If the discount percentage is invalid (less than 0 or greater than 100), return -1. Params: originalPrice (float): The original price of the item before any discount. discountPercentage (float): The discount percentage to be applied. Returns: float: The final price after the discount is applied, or -1 for invalid discount. Examples: >>> calculateDiscount(100.0, 20.0) 80.0 >>> calculateDiscount(50.0, 0.0) 50.0 >>> calculateDiscount(200.0, -10.0) -1 >>> calculateDiscount(250.0, 110.0) -1 >>> calculateDiscount(150.0, 50.0) 75.0","solution":"def calculateDiscount(originalPrice, discountPercentage): Returns the final price after applying the discount. If the discountPercentage is invalid (less than 0 or greater than 100), returns -1. Params: originalPrice (float): The original price of the item. discountPercentage (float): The discount percentage to be applied. Returns: float: The final price after the discount is applied, or -1 for invalid discount. if discountPercentage < 0 or discountPercentage > 100: return -1 discountAmount = (discountPercentage / 100) * originalPrice finalPrice = originalPrice - discountAmount return finalPrice"},{"question":"def smallestSubsequence(s: str) -> str: Returns the lexicographically smallest subsequence of \`s\` that contains all the distinct characters of \`s\` exactly once. >>> smallestSubsequence(\\"bcabc\\") == \\"abc\\" >>> smallestSubsequence(\\"cbacdcbc\\") == \\"acdb\\"","solution":"def smallestSubsequence(s): Returns the lexicographically smallest subsequence of \`s\` that contains all the distinct characters of \`s\` exactly once. stack = [] seen = set() last_occurrence = {char: i for i, char in enumerate(s)} for i, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)"},{"question":"def minimum_spanning_tree(): Find the sum of the weights of the edges that form the Minimum Spanning Tree (MST) of the graph. If the MST does not exist, output -1. Input is given from Standard Input in the following format: N M u_1 v_1 w_1 u_2 v_2 w_2 : u_M v_M w_M Where each (u_i, v_i, w_i) represents an edge between nodes u_i and v_i with weight w_i. Constraints: 2 ≤ N ≤ 10^5 1 ≤ M ≤ 2×10^5 1 ≤ weight of each edge ≤ 10^6 Example: Input: 4 5 1 2 3 1 3 4 4 2 6 4 3 5 2 3 2 Output: 9","solution":"def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootx = find(parent, x) rooty = find(parent, y) if rootx != rooty: if rank[rootx] > rank[rooty]: parent[rooty] = rootx elif rank[rootx] < rank[rooty]: parent[rootx] = rooty else: parent[rooty] = rootx rank[rootx] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 edges_in_mst = 0 for u, v, weight in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_weight += weight union(parent, rank, root_u, root_v) edges_in_mst += 1 if edges_in_mst == n - 1: return mst_weight return -1 def calculate_mst_weight(n, m, edges): if n == 0 or m == 0: return -1 return kruskal_mst(n, edges) def minimum_spanning_tree(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 weight = int(data[index + 2]) index += 3 edges.append((u, v, weight)) result = calculate_mst_weight(n, m, edges) print(result)"},{"question":"def car_fuel_status(fuel, distance, fuel_capacity): Determines the fuel status of a car given the current fuel level, distance to the next gas station, and the car's fuel capacity. Parameters: - fuel (int): The current fuel level in the car. - distance (int): The distance to the next gas station. - fuel_capacity (int): The maximum capacity of the car's fuel tank. Returns: - str: \\"Can reach\\", \\"Needs refill\\", or \\"Cannot reach\\" based on the conditions described. >>> car_fuel_status(10, 15, 20) 'Can reach' >>> car_fuel_status(0, 10, 10) 'Needs refill' >>> car_fuel_status(5, 100, 40) 'Cannot reach'","solution":"def car_fuel_status(fuel, distance, fuel_capacity): Determines the fuel status of a car given the current fuel level, distance to the next gas station, and the car's fuel capacity. Parameters: - fuel (int): The current fuel level in the car. - distance (int): The distance to the next gas station. - fuel_capacity (int): The maximum capacity of the car's fuel tank. Returns: - str: \\"Can reach\\", \\"Needs refill\\", or \\"Cannot reach\\" based on the conditions described. if distance > 2 * fuel_capacity: return \\"Cannot reach\\" if fuel <= 0 or fuel < distance: return \\"Needs refill\\" return \\"Can reach\\""},{"question":"def create_harvest_sequence(n: int): Create a unique sequence of numbers from 1 to n to celebrate the harvest festival without any two consecutive numbers having a difference of 1. >>> create_harvest_sequence(1) [1] >>> create_harvest_sequence(2) -1 >>> create_harvest_sequence(3) [3, 2, 1] >>> create_harvest_sequence(4) [2, 4, 1, 3] pass def solve(T: int, cases: list): Solve multiple test cases to create unique sequences as per traditional rules. >>> solve(3, [2, 3, 4]) [\\"-1\\", \\"3 2 1\\", \\"2 4 1 3\\"] >>> solve(1, [1]) [\\"1\\"] >>> solve(2, [5, 6]) [\\"5 4 3 2 1\\", \\"2 4 6 1 3 5\\"] pass","solution":"def create_harvest_sequence(n): if n == 1: return [1] if n == 2: return -1 if n % 2 == 1: # For odd n >= 3, we can always construct a valid sequence return [i for i in range(n, 0, -1)] else: # For even n, [2, 4, 6, ..., n, 1, 3, 5, ...] sequence should work return [i for i in range(2, n+1, 2)] + [i for i in range(1, n+1, 2)] def solve(T, cases): results = [] for n in cases: result = create_harvest_sequence(n) if result == -1: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, result))) return results"},{"question":"def final_position(m, n, grid, start_x, start_y, directions, max_moves): Determine the final position of Ash after executing the moves within the given constraints. >>> final_position(3, 3, [\\"...\\", \\".#.\\", \\"...\\"], 0, 0, \\"RRDD\\", 4) (2, 2) >>> final_position(3, 3, [\\"...\\", \\".#.\\", \\"...\\"], 0, 0, \\"RRDD\\", 2) (0, 2) >>> final_position(3, 3, [\\".#.\\", \\".#.\\", \\"...\\"], 2, 0, \\"UUUU\\", 5) (0, 0)","solution":"def final_position(m, n, grid, start_x, start_y, directions, max_moves): x, y = start_x, start_y moves = 0 for direction in directions: if moves >= max_moves: break if direction == 'U' and x > 0 and grid[x-1][y] != '#': x -= 1 elif direction == 'D' and x < m - 1 and grid[x+1][y] != '#': x += 1 elif direction == 'L' and y > 0 and grid[x][y-1] != '#': y -= 1 elif direction == 'R' and y < n - 1 and grid[x][y+1] != '#': y += 1 moves += 1 return x, y"},{"question":"def max_subarray_len(nums, k): Given an array of integers nums and an integer k, return the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. :param nums: List of integers :param k: Integer target sum :return: The maximum length of a subarray that sums to k Examples: >>> max_subarray_len([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_len([-2, -1, 2, 1], 1) 2 >>> max_subarray_len([1, 2, 3], 6) 3","solution":"def max_subarray_len(nums, k): Returns the maximum length of a subarray that sums to k. If there isn't one, returns 0. sum_indices = {} total_sum = 0 max_len = 0 for i, num in enumerate(nums): total_sum += num if total_sum == k: max_len = i + 1 elif (total_sum - k) in sum_indices: max_len = max(max_len, i - sum_indices[total_sum - k]) if total_sum not in sum_indices: sum_indices[total_sum] = i return max_len"},{"question":"import math def countPerfectSquares(lst): Counts the number of perfect squares in the given list of integers. Parameters: lst (list): List of positive integers Returns: int: Count of perfect squares in the list Examples: >>> countPerfectSquares([1, 4, 6, 9, 16]) 4 >>> countPerfectSquares([2, 3, 5, 8, 10]) 0 >>> countPerfectSquares([25, 36, 49, 100]) 4 >>> countPerfectSquares([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 3","solution":"import math def countPerfectSquares(lst): Counts the number of perfect squares in the given list of integers. Parameters: lst (list): List of positive integers Returns: int: Count of perfect squares in the list count = 0 for num in lst: if math.isqrt(num) ** 2 == num: count += 1 return count"},{"question":"def classify_reviews(positive_keywords: str, negative_keywords: str, reviews: List[str]) -> List[str]: Classifies each review as 'positive' or 'negative' based on the presence of positive and negative keywords. Args: positive_keywords (str): A space-separated string of positive keywords. negative_keywords (str): A space-separated string of negative keywords. reviews (List[str]): A list of product reviews. Returns: List[str]: A list containing 'positive' or 'negative' for each review. Example: >>> positive_keywords = \\"good excellent amazing\\" >>> negative_keywords = \\"bad terrible\\" >>> reviews = [\\"this product is good and amazing\\", \\"the quality is terrible\\", \\"excellent choice for everyone\\"] >>> classify_reviews(positive_keywords, negative_keywords, reviews) ['positive', 'negative', 'positive']","solution":"def classify_reviews(positive_keywords, negative_keywords, reviews): pos_set = set(positive_keywords.split()) neg_set = set(negative_keywords.split()) results = [] for review in reviews: review_words = set(review.split()) if any(word in review_words for word in pos_set) and not any(word in review_words for word in neg_set): results.append('positive') else: results.append('negative') return results"},{"question":"def custom_zip(*iterables): Custom implementation of the zip function which returns an iterator of tuples. Each tuple contains elements from the corresponding position of the input iterables. The iteration stops when the shortest input iterable is exhausted. >>> list(custom_zip([1, 2, 3], ['a', 'b', 'c'], [True, False, None])) [(1, 'a', True), (2, 'b', False), (3, 'c', None)] >>> list(custom_zip([1, 2], ['a', 'b', 'c'], [True])) [(1, 'a', True)] >>> list(custom_zip([], ['a', 'b', 'c'], [True, False, None])) [] >>> list(custom_zip([1, 2, 3])) [(1,), (2,), (3,)] >>> list(custom_zip(\\"abc\\", \\"123\\")) [('a', '1'), ('b', '2'), ('c', '3')] >>> list(custom_zip()) [] # Your implementation here pass","solution":"def custom_zip(*iterables): Custom implementation of the zip function which returns an iterator of tuples. Each tuple contains elements from the corresponding position of the input iterables. The iteration stops when the shortest input iterable is exhausted. if not iterables: return iter([]) # Return an empty iterator if no iterables are provided # Get the minimum length among all the iterables min_length = min(len(it) for it in iterables) # Yield tuples of elements from each iterable for the minimum length for i in range(min_length): yield tuple(it[i] for it in iterables)"},{"question":"def max_books_on_shelf(n: int, w: int, book_widths: List[int]) -> int: Find the maximum number of books Sarah can place on the shelf without placing two books with the same width next to each other, and without exceeding the maximum width the shelf can accommodate. Parameters: n (int): The number of books. w (int): The maximum width the shelf can accommodate. book_widths (list): A list of integers representing the widths of the books in Sarah's collection. Returns: int: The maximum number of books that can be arranged on the shelf. >>> max_books_on_shelf(5, 10, [1, 2, 3, 4, 5]) 5 >>> max_books_on_shelf(7, 4, [5, 5, 5, 2, 2, 2, 3]) 3 from solution import max_books_on_shelf def test_max_books_on_shelf(): assert max_books_on_shelf(5, 10, [1, 2, 3, 4, 5]) == 5 def test_max_books_on_shelf_with_duplicates(): assert max_books_on_shelf(7, 4, [5, 5, 5, 2, 2, 2, 3]) == 2 def test_max_books_on_shelf_all_same_width(): assert max_books_on_shelf(5, 10, [1, 1, 1, 1, 1]) == 1 def test_max_books_on_shelf_exceeding_max_width(): assert max_books_on_shelf(6, 10, [12, 15, 10, 8, 6, 7]) == 4 def test_max_books_on_shelf_single_book(): assert max_books_on_shelf(1, 5, [3]) == 1 def test_max_books_on_shelf_no_valid_books(): assert max_books_on_shelf(5, 3, [4, 5, 6, 7, 8]) == 0","solution":"def max_books_on_shelf(n, w, book_widths): Finds the maximum number of books that can be placed on the shelf such that no two books next to each other have the same width. Parameters: n (int): The number of books. w (int): The maximum width the shelf can accommodate. book_widths (list of int): Widths of the books. Returns: int: The maximum number of books that can be arranged on the shelf. # Using a set to track the unique widths that can be accommodated unique_widths = set() # Iterate through book widths, adding unique widths to the set for width in book_widths: if width <= w: unique_widths.add(width) return len(unique_widths)"},{"question":"def maxSubsetSum(arr): Calculate the maximum sum of non-adjacent elements in the array. >>> maxSubsetSum([3, 2, 5, 10, 7, 1]) 15 >>> maxSubsetSum([3, 2, 7, 10]) 13 >>> maxSubsetSum([3, 2, 5, 10, 7]) 15 >>> maxSubsetSum([3]) 3 >>> maxSubsetSum([3, 2]) 3 >>> maxSubsetSum([]) 0 >>> maxSubsetSum([3, 1, 2, 5, 4]) 9 >>> maxSubsetSum([3, 7, 4, 6, 5]) 13 >>> maxSubsetSum([2, 1, 4, 9, 1]) 11","solution":"def maxSubsetSum(arr): Function to calculate the maximum sum of non-adjacent elements in the array. if not arr: return 0 n = len(arr) if n == 1: return arr[0] # Initialize an array to store the maximum sum until each index max_sums = [0] * n max_sums[0] = arr[0] max_sums[1] = max(arr[0], arr[1]) for i in range(2, n): max_sums[i] = max(max_sums[i - 1], arr[i] + max_sums[i - 2]) return max_sums[n - 1]"},{"question":"import math from typing import List, Tuple def gcd_of_subarray(array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the GCD (Greatest Common Divisor) of the elements in the subarray from index L to R (inclusive). >>> gcd_of_subarray([12, 15, 18, 24, 30], [(1, 3), (2, 4), (1, 5)]) [3, 3, 3] >>> gcd_of_subarray([7, 11, 13, 17, 19], [(1, 1), (2, 2), (3, 3)]) [7, 11, 13] >>> gcd_of_subarray([12, 15, 24, 30], [(1, 4)]) [3] >>> gcd_of_subarray([5, 5, 5, 5, 5], [(1, 5), (2, 4)]) [5, 5] >>> gcd_of_subarray([2, 4, 6, 8, 10], [(1, 3), (2, 5), (1, 5)]) [2, 2, 2]","solution":"import math def gcd_of_subarray(array, queries): result = [] for L, R in queries: subarray = array[L-1:R] gcd_result = subarray[0] for num in subarray[1:]: gcd_result = math.gcd(gcd_result, num) if gcd_result == 1: # Early stopping if GCD is 1 break result.append(gcd_result) return result"},{"question":"def check_xor_relationship(a, b, c): Check if there exists a non-negative integer x such that: (a xor x) is less than (b xor x) and at the same time greater than (c xor x) Parameters: a (int): The first integer b (int): The second integer c (int): The third integer Returns: str: \\"Yes\\" if such an x exists, otherwise \\"No\\". >>> check_xor_relationship(5, 9, 2) \\"Yes\\" >>> check_xor_relationship(5, 5, 5) \\"No\\"","solution":"def check_xor_relationship(a, b, c): Check if there exists a non-negative integer x such that: (a xor x) < (b xor x) and (a xor x) > (c xor x) Parameters: a (int): The first integer b (int): The second integer c (int): The third integer Returns: str: \\"Yes\\" if such an x exists, otherwise \\"No\\". # since x can be any non-negative integer, we need to check all bits in a, b, c for i in range(31, -1, -1): a_bit = (a >> i) & 1 b_bit = (b >> i) & 1 c_bit = (c >> i) & 1 if a_bit == b_bit and a_bit == c_bit: continue if a_bit == b_bit: return \\"No\\" if a_bit == c_bit: return \\"Yes\\" return \\"No\\""},{"question":"from collections import Counter def most_frequent_fruit_count(T: int, fruit_counts: List[int]) -> int: Given the number of trees T and the fruit counts for each tree type, determine the number of fruits produced by the most frequently occurring tree type. If there is a tie in frequency, choose the tree type with the smallest fruit count. >>> most_frequent_fruit_count(7, [3, 1, 2, 1, 2, 3, 3]) 3 >>> most_frequent_fruit_count(5, [5, 5, 5, 5, 5]) 5 >>> most_frequent_fruit_count(4, [1, 1, 2, 2]) 1","solution":"def most_frequent_fruit_count(T, fruit_counts): Given the number of trees T and the fruit counts for each tree type, determine the number of fruits produced by the most frequently occurring tree type. If there is a tie in frequency, choose the tree type with the smallest fruit count. from collections import Counter count_frequency = Counter(fruit_counts) max_frequency = max(count_frequency.values()) candidates = [fruit_count for fruit_count, frequency in count_frequency.items() if frequency == max_frequency] return min(candidates)"},{"question":"def flatten_dictionary(d: dict) -> dict: Flattens a dictionary, where the keys can be nested arbitrarily deep. >>> flatten_dictionary({ ... \\"key1\\": { ... \\"keyA\\": 1, ... \\"keyB\\": 2, ... \\"keyC\\": { ... \\"keyD\\": 3 ... } ... }, ... \\"key2\\": 4 ... }) { \\"key1.keyA\\": 1, \\"key1.keyB\\": 2, \\"key1.keyC.keyD\\": 3, \\"key2\\": 4 } >>> flatten_dictionary({ ... \\"key1\\": { ... \\"keyA\\": { ... \\"keyB\\": { ... \\"keyC\\": 1 ... } ... } ... } ... }) { \\"key1.keyA.keyB.keyC\\": 1 } >>> flatten_dictionary({}) {}","solution":"def flatten_dictionary(d, parent_key=''): Flattens a dictionary, where the keys can be nested arbitrarily deep. items = [] for k, v in d.items(): new_key = parent_key + '.' + k if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def find_minimum_x(test_cases): This function finds the smallest integer X such that the sum of the absolute differences between each element of the array and X is minimized for each test case. Parameters: test_cases (list of tuples): Each element is a tuple where the first element is the integer N (size of array) and the second element is the list of integers A. Returns: list of int: Each element is the value of X that minimizes the sum of absolute differences for the corresponding test case. # Unit Test def test_single_test_case_1(): test_cases = [(4, [1, 2, 3, 4])] assert find_minimum_x(test_cases) == [2] def test_single_test_case_2(): test_cases = [(3, [5, 10, 14])] assert find_minimum_x(test_cases) == [10] def test_multiple_test_cases(): test_cases = [(4, [1, 2, 3, 4]), (3, [5, 10, 14])] assert find_minimum_x(test_cases) == [2, 10] def test_large_numbers(): test_cases = [(4, [1000000000, 1000000000, 1000000000, 1000000001])] assert find_minimum_x(test_cases) == [1000000000] def test_single_element(): test_cases = [(1, [42])] assert find_minimum_x(test_cases) == [42]","solution":"def find_minimum_x(test_cases): This function finds the smallest integer X such that the sum of the absolute differences between each element of the array and X is minimized for each test case. Parameters: test_cases (list of tuples): Each element is a tuple where the first element is the integer N (size of array) and the second element is the list of integers A. Returns: list of int: Each element is the value of X that minimizes the sum of absolute differences for the corresponding test case. results = [] for n, array in test_cases: array.sort() # The minimum sum of absolute differences is achieved at the median median = array[(n - 1) // 2] # zero-based index results.append(median) return results"},{"question":"from typing import List, Tuple def order_monkeys(n: int, t: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: Determine the order in which the monkeys should learn their tricks so that all given constraints are satisfied. Args: n (int): the number of monkeys t (List[int]): list representing the time it takes for each monkey to learn their trick dependencies (List[Tuple[int, int]]): list of dependencies where each tuple (u, v) means monkey u needs to finish learning before monkey v can start learning Returns: List[int]: the order in which monkeys should learn their tricks Examples: >>> order_monkeys(4, [1, 2, 3, 4], [(1, 2), (3, 4)]) [1, 3, 2, 4] >>> order_monkeys(5, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)]) [1, 2, 3, 4, 5]","solution":"from collections import deque def order_monkeys(n, t, dependencies): # Create a graph and in-degree tracker for topological sorting graph = {i: [] for i in range(1, n+1)} in_degree = {i: 0 for i in range(1, n+1)} # Build the graph and the in-degree list for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Perform topological sorting using Kahn's algorithm queue = deque([i for i in range(1, n+1) if in_degree[i] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return result # Example usage: # n = 4 # t = [1, 2, 3, 4] # dependencies = [(1, 2), (3, 4)] # print(order_monkeys(n, t, dependencies)) # Output: [1, 3, 2, 4]"},{"question":"from typing import List, Union def rearrange_array(arr: List[int]) -> Union[List[int], str]: Rearranges the given array so that no two consecutive elements are the same. If not possible, returns \\"Not possible\\". >>> rearrange_array([1, 1, 2, 2]) in [[1, 2, 1, 2], [2, 1, 2, 1]] True >>> rearrange_array([1, 1, 1]) 'Not possible' pass def process_test_cases(input_data: List[str]) -> List[Union[List[int], str]]: Processes the test case input and returns the results for each test case. pass","solution":"from collections import Counter import heapq def rearrange_array(arr): Rearranges the given array so that no two consecutive elements are the same. If not possible, returns \\"Not possible\\". counter = Counter(arr) max_heap = [(-count, num) for num, count in counter.items()] heapq.heapify(max_heap) prev_count, prev_num = 0, None result = [] while max_heap: count, num = heapq.heappop(max_heap) result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) prev_count = count + 1 prev_num = num if len(result) == len(arr): return result else: return \\"Not possible\\" def process_test_cases(input_data): Processes the test case input and returns the results for each test case. output = [] T = int(input_data[0]) index = 1 for _ in range(T): N = int(input_data[index]) arr = list(map(int, input_data[index + 1].split())) rearranged = rearrange_array(arr) output.append(rearranged) index += 2 return output"},{"question":"def minimize_max_element(q: int, queries: List[Tuple[int, int, List[int]]]) -> List[int]: Given a number of queries, each with a sequence of integers and a number of operations, minimize the maximum element in the sequence after performing the operations. Parameters: q (int): Number of queries. queries (List[Tuple[int, int, List[int]]]): List of queries where each query is a tuple containing the length of the sequence, number of operations, and the sequence itself. Returns: List[int]: List of minimum possible values of the maximum element in the sequence after performing the operations. Example: >>> minimize_max_element(2, [(3, 2, [5, 3, 8]), (4, 3, [10, 8, 5, 7])]) [5, 4]","solution":"def minimize_max_element(q, queries): results = [] for query in queries: n, k, v = query v.sort() while k > 0 and v[0] < v[-1]: large = v.pop() # the largest element small = v.pop(0) # the smallest element new_large = large - small v.append(new_large) v.sort() # keep sorted for next operation k -= 1 results.append(max(v)) return results"},{"question":"def longest_even_sum_subsequence_length(N: int, A: List[int]) -> int: Find the length of the longest subsequence with an even sum and non-decreasing order. >>> longest_even_sum_subsequence_length(6, [1, 2, 3, 4, 5, 6]) 3 >>> longest_even_sum_subsequence_length(5, [5, 7, 9, 10, 12]) 2","solution":"def longest_even_sum_subsequence_length(N, A): # Sort the array to ensure non-decreasing order A.sort() # Filter out only those numbers which are even even_numbers = [x for x in A if x % 2 == 0] return len(even_numbers)"},{"question":"def reorder_string(s: str) -> str: Reorders the given string such that all letters come first, followed by all the digits. The relative ordering of letters and digits is preserved. >>> reorder_string(\\"a1b2c3\\") \\"abc123\\" >>> reorder_string(\\"B4A3C2\\") \\"BAC432\\" >>> reorder_string(\\"123abc\\") \\"abc123\\" >>> reorder_string(\\"abcd\\") \\"abcd\\" >>> reorder_string(\\"1234\\") \\"1234\\"","solution":"def reorder_string(s): Reorders the given string such that all letters come first, followed by all the digits. The relative ordering of letters and digits is preserved. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a string containing digits from '2' to '9', this function returns all possible letter combinations that the number could represent. >>> letter_combinations('23') ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations('7') ['p', 'q', 'r', 's'] >>> letter_combinations('') [] >>> letter_combinations('27') ['ap', 'aq', 'ar', 'as', 'bp', 'bq', 'br', 'bs', 'cp', 'cq', 'cr', 'cs'] >>> letter_combinations('234') ['adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi']","solution":"from itertools import product def letter_combinations(digits): Given a string containing digits from '2' to '9', this function returns all possible letter combinations that the number could represent. if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } # Generate lists of characters for each digit in the input char_lists = [digit_to_char[digit] for digit in digits] # Use itertools.product to create combinations of letters combinations = [''.join(chars) for chars in product(*char_lists)] return combinations"},{"question":"def are_isomorphic(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are isomorphic. >>> are_isomorphic('egg', 'add') True >>> are_isomorphic('foo', 'bar') False >>> are_isomorphic('paper', 'title') True","solution":"def are_isomorphic(s1, s2): Determines if two strings s1 and s2 are isomorphic. if len(s1) != len(s2): return False map_s1_to_s2 = {} map_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in map_s1_to_s2: if map_s1_to_s2[char1] != char2: return False if char2 in map_s2_to_s1: if map_s2_to_s1[char2] != char1: return False map_s1_to_s2[char1] = char2 map_s2_to_s1[char2] = char1 return True"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Removes duplicate consecutive characters from a string. >>> remove_consecutive_duplicates('aabbcc') 'abc' >>> remove_consecutive_duplicates('aaabbbccc') 'abc' >>> remove_consecutive_duplicates('ababab') 'ababab' >>> remove_consecutive_duplicates('abcd') 'abcd' >>> remove_consecutive_duplicates('aaaabaaa') 'aba' >>> remove_consecutive_duplicates('helloo...world!') 'helo.world!'","solution":"def remove_consecutive_duplicates(s): Removes duplicate consecutive characters from a string. if not s: return s result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"def sort_photos(photos): Organizes a collection of photos by their metadata. Sorts the photos in ascending order based on their timestamp. If two photos have the same timestamp, they are ordered lexicographically by their IDs. Args: photos (list): A list of dictionaries, where each dictionary represents a photo with the keys 'id', 'description', and 'timestamp'. Returns: list: A new list of dictionaries sorted by timestamp, and by id lexicographically if the timestamps are the same. Example: >>> photos = [ ... {\\"id\\": \\"photo1\\", \\"description\\": \\"A photo of a cat\\", \\"timestamp\\": 1630447330}, ... {\\"id\\": \\"photo2\\", \\"description\\": \\"A photo of a dog\\", \\"timestamp\\": 1630447330}, ... {\\"id\\": \\"photo3\\", \\"description\\": \\"A photo of a tree\\", \\"timestamp\\": 1630447200} ... ] >>> sort_photos(photos) [ {\\"id\\": \\"photo3\\", \\"description\\": \\"A photo of a tree\\", \\"timestamp\\": 1630447200}, {\\"id\\": \\"photo1\\", \\"description\\": \\"A photo of a cat\\", \\"timestamp\\": 1630447330}, {\\"id\\": \\"photo2\\", \\"description\\": \\"A photo of a dog\\", \\"timestamp\\": 1630447330} ] pass","solution":"def sort_photos(photos): Returns the list of photos sorted by timestamp. If two photos have the same timestamp, they are ordered lexicographically by their IDs. return sorted(photos, key=lambda photo: (photo['timestamp'], photo['id']))"},{"question":"def get_reminder_email(N: int) -> str: Returns the appropriate reminder email text based on the number of books checked out. Parameters: N (int): The number of books checked out by the user. Returns: str: The reminder email text. pass # Test Cases def test_no_books_checked_out(): assert get_reminder_email(0) == \\"You have no books checked out. Check out our new arrivals!\\" def test_less_than_3_books_checked_out(): assert get_reminder_email(1) == \\"Don't forget to return your books on time!\\" assert get_reminder_email(2) == \\"Don't forget to return your books on time!\\" def test_3_or_more_books_checked_out(): assert get_reminder_email(3) == \\"You have checked out a lot of books. Consider returning some.\\" assert get_reminder_email(4) == \\"You have checked out a lot of books. Consider returning some.\\" assert get_reminder_email(100) == \\"You have checked out a lot of books. Consider returning some.\\" def test_invalid_number_of_books(): try: get_reminder_email(-1) except ValueError as e: assert str(e) == \\"The number of books must be between 0 and 100 inclusive.\\" try: get_reminder_email(101) except ValueError as e: assert str(e) == \\"The number of books must be between 0 and 100 inclusive.\\"","solution":"def get_reminder_email(N): Returns the appropriate reminder email text based on the number of books checked out. Parameters: N (int): The number of books checked out by the user. Returns: str: The reminder email text. if N < 0 or N > 100: raise ValueError(\\"The number of books must be between 0 and 100 inclusive.\\") if N == 0: return \\"You have no books checked out. Check out our new arrivals!\\" elif N < 3: return \\"Don't forget to return your books on time!\\" else: return \\"You have checked out a lot of books. Consider returning some.\\""},{"question":"from typing import List def sort_even_odd(arr: List[int]) -> List[int]: Sorts an array such that all even numbers appear before all odd numbers, while maintaining the relative order of even and odd numbers. >>> sort_even_odd([1, 2, 4, 3, 5, 6]) [2, 4, 6, 1, 3, 5] >>> sort_even_odd([9, 3, 4, 2, 7, 8]) [4, 2, 8, 9, 3, 7] >>> sort_even_odd([5, 3, 1]) [5, 3, 1] >>> sort_even_odd([4, 2, 8, 6]) [4, 2, 8, 6] >>> sort_even_odd([]) [] >>> sort_even_odd([2, 2, 1, 1]) [2, 2, 1, 1] >>> sort_even_odd([1000000000, -1000000000, 500, 499]) [1000000000, -1000000000, 500, 499]","solution":"from typing import List def sort_even_odd(arr: List[int]) -> List[int]: even_numbers = [x for x in arr if x % 2 == 0] odd_numbers = [x for x in arr if x % 2 != 0] return even_numbers + odd_numbers"},{"question":"def is_well_formed(s: str) -> bool: Determines if the input string s is well-formed with regards to brackets. :param s: A string consisting of '(', ')', '{', '}', '[' and ']' :return: True if the string is well-formed, False otherwise >>> is_well_formed(\\"()\\") True >>> is_well_formed(\\"()[]{}\\") True >>> is_well_formed(\\"{[]}\\") True >>> is_well_formed(\\"(]\\") False >>> is_well_formed(\\"([)]\\") False","solution":"def is_well_formed(s): Determines if the input string s is well-formed with regards to brackets. :param s: A string consisting of '(', ')', '{', '}', '[' and ']' :return: True if the string is well-formed, False otherwise stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def longest_prime_subsequence(arr: List[int]) -> int: Find the longest subsequence of prime numbers in a list. >>> longest_prime_subsequence([2, 6, 4, 7]) 1 >>> longest_prime_subsequence([1, 3, 5, 8, 9]) 2 pass def find_longest_prime_subsequence(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the longest prime subsequence for each test case. >>> test_cases = [(4, [2, 6, 4, 7]), (5, [1, 3, 5, 8, 9]), (6, [10, 15, 16, 17, 18, 19])] >>> find_longest_prime_subsequence(test_cases) [1, 2, 1] pass def test_is_prime(): assert is_prime(2) assert is_prime(3) assert not is_prime(1) assert not is_prime(4) assert is_prime(17) assert not is_prime(100) def test_longest_prime_subsequence(): assert longest_prime_subsequence([2, 6, 4, 7]) == 1 assert longest_prime_subsequence([1, 3, 5, 8, 9]) == 2 assert longest_prime_subsequence([10, 15, 16, 17, 18, 19]) == 1 assert longest_prime_subsequence([2, 3, 5, 7, 11, 13]) == 6 assert longest_prime_subsequence([4, 6, 8, 10, 12]) == 0 def test_find_longest_prime_subsequence(): test_cases = [(4, [2, 6, 4, 7]), (5, [1, 3, 5, 8, 9]), (6, [10, 15, 16, 17, 18, 19])] expected = [1, 2, 1] assert find_longest_prime_subsequence(test_cases) == expected test_cases = [(4, [2, 3, 5, 7]), (5, [11, 5, 6, 8, 7]), (5, [1, 2, 3, 4, 5])] expected = [4, 2, 2] assert find_longest_prime_subsequence(test_cases) == expected","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_prime_subsequence(arr): prime_length = 0 max_length = 0 for num in arr: if is_prime(num): prime_length += 1 max_length = max(max_length, prime_length) else: prime_length = 0 return max_length def find_longest_prime_subsequence(test_cases): results = [] for n, sequence in test_cases: results.append(longest_prime_subsequence(sequence)) return results"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels in the input string \`s\`. Vowels considered are 'a', 'e', 'i', 'o', and 'u'. >>> count_vowels(\\"hello\\") 2 >>> count_vowels(\\"encyclopedia\\") 5","solution":"def count_vowels(s: str) -> int: Returns the number of vowels in the input string \`s\`. Vowels considered are 'a', 'e', 'i', 'o', and 'u'. vowels = set(\\"aeiou\\") return sum(1 for char in s if char in vowels)"},{"question":"class Library: def __init__(self): self.borrowed_books = set() def borrow(self, x): self.borrowed_books.add(x) def return_book(self, x): self.borrowed_books.discard(x) def check(self, x): return \\"Borrowed\\" if x in self.borrowed_books else \\"Available\\" def library_manager(operations): Handle the checkout and return of books, as well as queries about their availability. Args: operations: List of operations as strings. Each operation can either be \\"borrow x\\", \\"return x\\", or \\"check x\\" where x is the book ID. Returns: List of results of \\"check\\" operations. Example: >>> operations = [ ... \\"borrow 123\\", ... \\"check 123\\", ... \\"return 123\\", ... \\"check 123\\", ... \\"borrow 456\\", ... \\"check 456\\", ... \\"borrow 123\\", ... \\"check 123\\"] >>> library_manager(operations) [\\"Borrowed\\", \\"Available\\", \\"Borrowed\\", \\"Borrowed\\"] library = Library() output = [] for operation in operations: command, x = operation.split() x = int(x) if command == \\"borrow\\": library.borrow(x) elif command == \\"return\\": library.return_book(x) elif command == \\"check\\": result = library.check(x) output.append(result) return output","solution":"class Library: def __init__(self): self.borrowed_books = set() def borrow(self, x): self.borrowed_books.add(x) def return_book(self, x): self.borrowed_books.discard(x) def check(self, x): return \\"Borrowed\\" if x in self.borrowed_books else \\"Available\\" def library_manager(operations): library = Library() output = [] for operation in operations: command, x = operation.split() x = int(x) if command == \\"borrow\\": library.borrow(x) elif command == \\"return\\": library.return_book(x) elif command == \\"check\\": result = library.check(x) output.append(result) return output"},{"question":"def calculate_total_water(T: int, cases: List[Tuple[int, int]]) -> List[int]: Calculate the total amount of water in liters that Alice has for her parties. Args: T : int : the number of test cases cases : List[Tuple[int, int]] : a list of tuples each containing two integers M and N Returns: List[int] : a list of integers representing the total amount of water for each test case. Example: >>> calculate_total_water(3, [(4, 6), (2, 10), (0, 8)]) [42, 56, 40] >>> calculate_total_water(1, [(0, 0)]) [0] >>> calculate_total_water(2, [(1, 1), (2, 2)]) [8, 16] Test cases: >>> calculate_total_water(3, [(4, 6), (2, 10), (0, 8)]) == [42, 56, 40] >>> calculate_total_water(1, [(0, 0)]) == [0] >>> calculate_total_water(2, [(1, 1), (2, 2)]) == [8, 16] >>> calculate_total_water(3, [(10, 0), (0, 20), (5, 5)]) == [30, 100, 40] >>> calculate_total_water(1, [(100, 100)]) == [800] >>> calculate_total_water(1, [(0, 0)]) == [0] >>> calculate_total_water(1, [(100, 0)]) == [300] >>> calculate_total_water(1, [(0, 100)]) == [500] >>> calculate_total_water(1, [(50, 50)]) == [400]","solution":"def calculate_total_water(T, cases): This function calculates the total amount of water for each test case. :param T: int, number of test cases :param cases: list of tuples, each containing two integers M and N :return: list of integers, total amount of water for each test case results = [] for case in cases: M, N = case total_water = M * 3 + N * 5 results.append(total_water) return results # Example usage: # T = 3 # cases = [(4, 6), (2, 10), (0, 8)] # print(calculate_total_water(T, cases)) # Output: [42, 56, 40]"},{"question":"def twoSum(arr, target): Given an array of integers and a target value, find two indices such that the sum of the elements at those indices equals the target value. Parameters: arr (list): List of integers target (int): Target sum Returns: list: Indices of the two elements whose sum equals the target or an empty list if no such elements exist. >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([1, 2, 3, 4], 8) [] >>> twoSum([3, 3], 6) [0, 1] >>> twoSum([1, 2, 3, 4, 5], 6) [1, 3] >>> twoSum([-1, -2, -3, -4, -5], -8) [2, 4]","solution":"def twoSum(arr, target): Given an array of integers and a target value, find two indices such that the sum of the elements at those indices equals the target value. Parameters: arr (list): List of integers target (int): Target sum Returns: list: Indices of the two elements whose sum equals the target or an empty list if no such elements exist. lookup = {} for i, num in enumerate(arr): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return []"},{"question":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings given a list of pairs (start, end) times. Examples: >>> can_attend_all_meetings([[7, 10], [2, 4]]) True >>> can_attend_all_meetings([[0, 30], [5, 10], [15, 20]]) False","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings given a list of pairs (start, end) times. # Sort the intervals by start time intervals.sort(key=lambda x: x[0]) # Compare each meeting's end time with the next meeting's start time for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"def can_be_sorted_by_rotating(nums): Determine if the array can be sorted in non-decreasing order by rotating the array. >>> can_be_sorted_by_rotating([3, 4, 5, 6, 1, 2]) # True >>> can_be_sorted_by_rotating([4, 3, 2, 1]) # False","solution":"def can_be_sorted_by_rotating(nums): Determine if the array can be sorted in non-decreasing order by rotating the array. count_inversions = 0 n = len(nums) for i in range(n): if nums[i] > nums[(i+1) % n]: count_inversions += 1 return count_inversions <= 1"},{"question":"def minDistance(word1: str, word2: str) -> int: Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. >>> minDistance(\\"sea\\", \\"eat\\") 2 >>> minDistance(\\"leetcode\\", \\"etco\\") 4","solution":"def minDistance(word1, word2): Returns the minimum number of steps required to make word1 and word2 the same by deleting characters. m, n = len(word1), len(word2) # Create a DP table where dp[i][j] represents the length of longest common subsequence of word1[:i] and word2[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of the longest common subsequence lcs = dp[m][n] # The minimum number of deletions required return (m - lcs) + (n - lcs)"},{"question":"def maxCount(m: int, n: int, operations: List[List[int]]) -> int: Returns the number of cells containing the maximum integer in the grid after performing the given operations. >>> maxCount(3, 3, [[2, 2], [3, 3]]) # returns: 4 >>> maxCount(4, 4, [[3, 3], [2, 2]]) # returns: 4 >>> maxCount(2, 2, []) # returns: 4","solution":"def maxCount(m, n, ops): Returns the number of cells containing the maximum integer in the grid after performing the given operations. if not ops: return m * n # Find the minimum values of rows and columns from the operations min_row = min(op[0] for op in ops) min_col = min(op[1] for op in ops) # The number of cells with the maximum integer return min_row * min_col"},{"question":"def min_shelves(books, shelf_height): Returns the minimum number of shelves required to arrange the books with the given shelf height limit. >>> min_shelves([5, 8, 7, 3, 5, 2], 10) 4 >>> min_shelves([1, 2, 3, 5, 6], 8) 3","solution":"def min_shelves(books, shelf_height): Returns the minimum number of shelves required to arrange the books with the given shelf height limit. current_height = 0 shelf_count = 1 for book in books: if current_height + book <= shelf_height: current_height += book else: shelf_count += 1 current_height = book return shelf_count"},{"question":"from typing import List, Tuple def find_best_edge(trees: List[Tuple[int, List[Tuple[int, int]]]]) -> List[Tuple[int, int]]: Finds the best edge to remove to partition the tree into two trees with the closest possible number of nodes. Args: trees: List of tuples, each containing an integer N (number of nodes) and a list of edges represented by tuples (u, v). Returns: List of tuples, each containing two integers representing the nodes defining the edge to be removed. >>> find_best_edge([(3, [(1, 2), (1, 3)]), (4, [(1, 2), (1, 3), (3, 4)])]) == [(1, 2), (1, 3)] >>> find_best_edge([(2, [(1, 2)])]) == [(1, 2)] >>> find_best_edge([(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)])]) == [(1, 2)] >>> find_best_edge([(5, [(1, 2), (2, 3), (3, 4), (4, 5)])]) == [(2, 3)] >>> find_best_edge([(6, [(1, 2), (1, 3), (2, 4), (4, 5), (4, 6)])]) == [(2, 4)]","solution":"def find_best_edge(trees): results = [] def dfs(node, parent): subtree_size = 1 node_depth = depths[node] for neighbor in tree[node]: if neighbor != parent: depths[neighbor] = node_depth + 1 neighbor_size = dfs(neighbor, node) subtree_size += neighbor_size # Check if this edge provides a better partition abs_diff = abs(total_nodes - 2 * neighbor_size) if abs_diff < min_diff[0] or (abs_diff == min_diff[0] and node_depth < min_diff[1]): min_diff[0] = abs_diff min_diff[1] = node_depth best_edge[0] = (node, neighbor) return subtree_size for tree_edges in trees: N = tree_edges[0] edges = tree_edges[1] # Initialize the tree structure as an adjacency list tree = [[] for _ in range(N + 1)] for u, v in edges: tree[u].append(v) tree[v].append(u) total_nodes = N min_diff = [float('inf'), float('inf')] # [min_diff, depth] best_edge = [None] depths = [-1] * (N + 1) depths[1] = 0 # root node has depth 0 # Perform DFS from node 1 (root) dfs(1, -1) # Ensure the edge is in correct order (parent, child) if depths[best_edge[0][0]] > depths[best_edge[0][1]]: best_edge[0] = (best_edge[0][1], best_edge[0][0]) results.append(best_edge[0]) return results"},{"question":"def sort_letters_and_digits(input_str: str) -> str: Given a string containing a mix of letters and digits, returns a new string with the letters sorted in alphabetical order and the digits sorted in ascending order, while maintaining their original relative positions of letters and digits. >>> sort_letters_and_digits(\\"a1b2c3\\") \\"a1b2c3\\" >>> sort_letters_and_digits(\\"f4e3d2c1b0a9\\") \\"a0b1c2d3e4f9\\" >>> sort_letters_and_digits(\\"dcba\\") \\"abcd\\" >>> sort_letters_and_digits(\\"3210\\") \\"0123\\" >>> sort_letters_and_digits(\\"\\") \\"\\" >>> sort_letters_and_digits(\\"a\\") \\"a\\" >>> sort_letters_and_digits(\\"1\\") \\"1\\" >>> sort_letters_and_digits(\\"a1c3b2\\") \\"a1b2c3\\" >>> sort_letters_and_digits(\\"m8n7x2y1z9\\") \\"m1n2x7y8z9\\"","solution":"def sort_letters_and_digits(input_str): Given a string containing a mix of letters and digits, returns a new string with the letters sorted in alphabetical order and the digits sorted in ascending order, while maintaining their original relative positions of letters and digits. letters = sorted([char for char in input_str if char.isalpha()]) digits = sorted([char for char in input_str if char.isdigit()]) letter_index = 0 digit_index = 0 result = [] for char in input_str: if char.isalpha(): result.append(letters[letter_index]) letter_index += 1 elif char.isdigit(): result.append(digits[digit_index]) digit_index += 1 return ''.join(result)"},{"question":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs of integers in the array whose sum is equal to k. >>> count_pairs_with_sum([1, 5, 7, -1], 6) 2 >>> count_pairs_with_sum([1, 1, 1, 1, 1], 2) 10 def process_test_cases(num_cases, test_cases): Process multiple test cases and return a list of results for each test case. Args: num_cases: Integer number of test cases test_cases: List of tuples. Each tuple contains (N, arr, k) Returns: List of integer results for each test case >>> process_test_cases(2, [(4, [1, 5, 7, -1], 6), (5, [1, 1, 1, 1, 1], 2)]) [2, 10]","solution":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs whose sum is equal to k. Args: arr: List of integers k: Integer sum value Returns: Integer count of such pairs count = 0 seen = {} for num in arr: complement = k - num if complement in seen: count += seen[complement] if num in seen: seen[num] += 1 else: seen[num] = 1 return count def process_test_cases(num_cases, test_cases): Process multiple test cases. Args: num_cases: Integer number of test cases test_cases: List of tuples. Each tuple contains (N, arr, k) Returns: List of integer results for each test case results = [] for N, arr, k in test_cases: results.append(count_pairs_with_sum(arr, k)) return results"},{"question":"def max_birds_in_subarrays(n: int, K: int, observations: List[int]) -> List[int]: Returns the maximum number of birds observed in each subarray of length K. >>> max_birds_in_subarrays(7, 3, [1, 3, 5, 7, 9, 2, 6]) [5, 7, 9, 9, 9] >>> max_birds_in_subarrays(5, 2, [4, 8, 1, 2, 6]) [8, 8, 2, 6] >>> max_birds_in_subarrays(1, 1, [10]) [10] >>> max_birds_in_subarrays(6, 2, [1, 2, 3, 4, 5, 6]) [2, 3, 4, 5, 6] >>> max_birds_in_subarrays(6, 3, [6, 5, 4, 3, 2, 1]) [6, 5, 4, 3] def process_datasets(datasets: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Process multiple datasets and returns the maximum number of birds for each subarray of length K. >>> datasets = [((7, 3), [1, 3, 5, 7, 9, 2, 6]), ((5, 2), [4, 8, 1, 2, 6]), ((0, 0), [])] >>> process_datasets(datasets) [[5, 7, 9, 9, 9], [8, 8, 2, 6]]","solution":"def max_birds_in_subarrays(n, K, observations): Returns the maximum number of birds observed in each subarray of length K. if n == 0 or K == 0: return [] max_counts = [] for i in range(n - K + 1): max_counts.append(max(observations[i:i+K])) return max_counts def process_datasets(datasets): results = [] for data in datasets: n, K = data[0] if n == 0 and K == 0: break observations = data[1] results.append(max_birds_in_subarrays(n, K, observations)) return results"},{"question":"def solve_workshop(N: int, interest_levels: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Perform a series of QUERY and UPDATE operations on a list of interest levels for workshop participants. - QUERY X Y : Return the sum of interest levels from the X-th to the Y-th participants (1-based index). - UPDATE X V : Update the interest level of the X-th participant to V. Args: N (int): The number of participants. interest_levels (List[int]): The list of initial interest levels of participants. operations (List[Tuple[str, int, int]]): A list of operations to perform, either 'QUERY' or 'UPDATE'. Returns: List[int]: The results of the QUERY operations in the order they were performed. Example: >>> solve_workshop(5, [3, 1, 4, 1, 5], [('QUERY', 1, 3), ('UPDATE', 2, 6), ('QUERY', 2, 5)]) [8, 16] >>> solve_workshop(4, [1, 2, 3, 4], [('QUERY', 1, 4), ('QUERY', 1, 2), ('QUERY', 3, 4)]) [10, 3, 7] >>> solve_workshop(3, [2, 2, 2], [('UPDATE', 1, 3), ('UPDATE', 2, 5), ('UPDATE', 3, 4), ('QUERY', 1, 3)]) [12] >>> solve_workshop(1, [100000], [('QUERY', 1, 1), ('UPDATE', 1, 50000), ('QUERY', 1, 1)]) [100000, 50000]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) # Fenwick Tree is 1-based indexed def update(self, index, delta): # Increase the value at \`index\` by \`delta\` while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): # Query the prefix sum up to and including \`index\` sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def range_query(self, left, right): # Query the sum from \`left\` to \`right\` return self.query(right) - self.query(left - 1) def solve_workshop(N, interest_levels, operations): fenwick_tree = FenwickTree(N) current_levels = [0] * (N + 1) # Initialize the Fenwick Tree with initial interest levels for i in range(1, N + 1): current_levels[i] = interest_levels[i - 1] fenwick_tree.update(i, interest_levels[i - 1]) results = [] for operation in operations: if operation[0] == 'QUERY': X, Y = operation[1], operation[2] results.append(fenwick_tree.range_query(X, Y)) elif operation[0] == 'UPDATE': X, V = operation[1], operation[2] delta = V - current_levels[X] fenwick_tree.update(X, delta) current_levels[X] = V return results"},{"question":"def min_distinct_characters(S: str) -> int: Determine the minimum possible number of distinct characters in the final string after performing the swap operation any number of times. >>> min_distinct_characters(\\"aabcc\\") # 2 >>> min_distinct_characters(\\"aaaaa\\") # 1 >>> min_distinct_characters(\\"abcde\\") # 2 >>> min_distinct_characters(\\"ababababab\\") # 2 >>> min_distinct_characters(\\"z\\") # 1 >>> min_distinct_characters(\\"mm\\") # 1 >>> min_distinct_characters(\\"aabbccdd\\") # 2 # Write your code here","solution":"def min_distinct_characters(S): Returns the minimum possible number of distinct characters in S. char_set = set(S) return min(len(char_set), 2) # Example usage # S = \\"aabcc\\" # print(min_distinct_characters(S)) # Output: 2"},{"question":"def decrypt_ascii_messages(n: int, messages: List[str]) -> List[str]: Decrypts a list of ASCII encoded messages. Parameters: n (int): The number of messages messages (list of str): List of strings where each string contains space-separated ASCII values Returns: list of str: List of decrypted messages >>> decrypt_ascii_messages(1, [\\"72 101 108 108 111 32 87 111 114 108 100\\"]) == [\\"Hello World\\"] >>> decrypt_ascii_messages(2, [\\"72 101 108 108 111 32 87 111 114 108 100\\", \\"84 101 99 104 32 83 117 114 103 101\\"]) == [\\"Hello World\\", \\"Tech Surge\\"] # Your implementation here","solution":"def decrypt_ascii_messages(n, messages): Decrypts a list of ASCII encoded messages. Parameters: n (int): The number of messages messages (list of str): List of strings where each string contains space-separated ASCII values Returns: list of str: List of decrypted messages decrypted_messages = [] for message in messages: ascii_values = message.split() decrypted_message = ''.join(chr(int(value)) for value in ascii_values) decrypted_messages.append(decrypted_message) return decrypted_messages"},{"question":"class Bookstore: def __init__(self): self.books = {} def add_book(self, isbn, title): Adds a new book with the given ISBN and title to the bookstore. def update_sales(self, isbn, sales): Updates the sales record for the book with the given ISBN, adding the specified number of sales. def query_sales(self, isbn): Returns the total number of sales for the book with the given ISBN. def process_actions(actions): Processes a list of actions performed in the bookstore and returns the results of sales queries. >>> actions = [ \\"ADD 9780131103627 \\"The C Programming Language\\"\\", \\"ADD 9780131101630 \\"The UNIX Programming Environment\\"\\", \\"UPDATE 9780131103627 100\\", \\"UPDATE 9780131101630 50\\", \\"QUERY 9780131103627\\", \\"QUERY 9780131101630\\" ] >>> process_actions(actions) [100, 50] >>> actions = [ \\"ADD 9780321751041 \\"Programming in Python 3\\"\\", \\"UPDATE 9780321751041 200\\", \\"QUERY 9780321751041\\", \\"UPDATE 9780321751041 300\\", \\"QUERY 9780321751041\\" ] >>> process_actions(actions) [200, 500]","solution":"class Bookstore: def __init__(self): self.books = {} def add_book(self, isbn, title): self.books[isbn] = {'title': title, 'sales': 0} def update_sales(self, isbn, sales): if isbn in self.books: self.books[isbn]['sales'] += sales def query_sales(self, isbn): if isbn in self.books: return self.books[isbn]['sales'] return 0 def process_actions(actions): bookstore = Bookstore() result = [] for action in actions: parts = action.split(maxsplit=2) command = parts[0] isbn = parts[1] if command == \\"ADD\\": title = parts[2].strip('\\"') bookstore.add_book(isbn, title) elif command == \\"UPDATE\\": sales = int(parts[2]) bookstore.update_sales(isbn, sales) elif command == \\"QUERY\\": result.append(bookstore.query_sales(isbn)) return result"},{"question":"from typing import List, Tuple def sum_and_product(arr: List[int]) -> Tuple[int, int]: Returns a tuple with the sum of all even numbers and the product of all odd numbers in the array. If there are no odd numbers, the product is 1. >>> sum_and_product([1, 2, 3, 4, 5]) (6, 15) >>> sum_and_product([2, 4, 6, 8]) (20, 1) >>> sum_and_product([1, 3, 5, 7]) (0, 105)","solution":"from typing import List, Tuple def sum_and_product(arr: List[int]) -> Tuple[int, int]: Returns a tuple with the sum of all even numbers and the product of all odd numbers in the array. If there are no odd numbers, the product is 1. even_sum = 0 odd_product = 1 has_odd = False for num in arr: if num % 2 == 0: even_sum += num else: odd_product *= num has_odd = True if not has_odd: odd_product = 1 return (even_sum, odd_product)"},{"question":"def solve(nums: List[int], target: int) -> Tuple[int, int]: Returns the indices of the two numbers that add up to the target. >>> solve([2, 7, 11, 15], 9) (0, 1) >>> solve([3, 2, 4], 6) (1, 2) >>> solve([3, 3], 6) (0, 1) >>> solve([1000000000, -1000000000, 3, 0], 0) (0, 1) >>> solve([-3, 4, 3, 90], 0) (0, 2) >>> solve([8, 2, 4, 6], 14) (0, 3)","solution":"def solve(nums, target): Returns the indices of the two numbers that add up to target. :param nums: List of integers. :param target: The target integer. :return: Tuple of two integer indices. num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return (num_dict[complement], i) num_dict[num] = i"},{"question":"def isCycle(n, m, edges): Given an undirected graph represented by an adjacency list g of n vertices and m edges, complete the function isCycle which returns a boolean indicating if the graph contains any cycle. Parameters: n (int): number of vertices m (int): number of edges edges (List[Tuple[int, int]]): list of edges, each represented as a tuple (u, v) Returns: bool: True if there is at least one cycle in the graph; otherwise, False Example: >>> isCycle(3, 3, [(1, 2), (2, 3), (3, 1)]) True >>> isCycle(4, 3, [(1, 2), (2, 3), (3, 4)]) False pass def handle_multiple_cases(T, cases): Function to handle multiple test cases. Parameters: T (int): number of test cases cases (List[Dict]): list of test cases, where each test case is a dictionary with keys 'n', 'm', and 'edges' Returns: List[bool]: list of results for each test case Example: >>> T = 2 >>> cases = [ {'n': 3, 'm': 3, 'edges': [(1, 2), (2, 3), (3, 1)]}, {'n': 4, 'm': 3, 'edges': [(1, 2), (2, 3), (3, 4)]} ] >>> handle_multiple_cases(T, cases) [True, False] pass","solution":"def isCycle(n, m, edges): from collections import defaultdict # To detect cycle in an undirected graph using DFS def detect_cycle(v, visited, parent): visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: if detect_cycle(neighbor, visited, v): return True elif neighbor != parent: return True return False # Create adjacency list representation of the graph adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # visited array to keep track of visited vertices visited = [False] * (n + 1) # Check for cycle in different DFS trees for i in range(1, n + 1): if not visited[i]: if detect_cycle(i, visited, -1): return True return False def handle_multiple_cases(T, cases): results = [] for case in cases: n, m, edges = case['n'], case['m'], case['edges'] results.append(isCycle(n, m, edges)) return results"},{"question":"def game_winner(x: int, y: int) -> str: Determine the winner of the game given the initial number of stones in both piles. >>> game_winner(4, 6) \\"Alice\\" >>> game_winner(8, 3) \\"Bob\\"","solution":"def game_winner(x, y): if x % 2 == 0 or y % 2 == 0: return \\"Alice\\" else: return \\"Bob\\""},{"question":"from typing import List, Tuple def find_min_cost_to_all_intersections(n: int, m: int, edges: List[Tuple[int, int, int]], start: int) -> List[int]: Determine the minimum cost required to travel from the start intersection to every other intersection in the town. >>> find_min_cost_to_all_intersections(5, 6, [(0, 1, 2), (0, 2, 4), (1, 2, 1), (1, 3, 7), (2, 4, 3), (3, 4, 1)], 0) [0, 2, 3, 9, 6] >>> find_min_cost_to_all_intersections(4, 3, [(0, 1, 5), (1, 2, 10), (2, 3, 2)], 1) [-1, 0, 10, 12]","solution":"import heapq def dijkstra(n, edges, start): graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((w, v)) dist = [float('inf')] * n dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, node = heapq.heappop(priority_queue) if current_dist > dist[node]: continue for weight, neighbor in graph[node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [d if d != float('inf') else -1 for d in dist] def find_min_cost_to_all_intersections(n, m, edges, start): return dijkstra(n, edges, start)"},{"question":"from typing import List, Tuple def can_make_identical(m: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if it is possible to make the arrays 'a' and 'b' identical using a sequence of operations. Parameters: m (int): Number of test cases test_cases (List[Tuple[int, List[int], List[int]]]): List of test cases where each test case is a tuple containing: - an integer n: the number of elements in arrays a and b - a list of n integers: the elements of array a - a list of n integers: the elements of array b Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> can_make_identical(3, [(4, [1, 2, 3, 4], [1, 2, 3, 4]), (3, [1, 0, 1], [0, 1, 0]), (5, [2, 4, 6, 1, 3], [6, 4, 2, 3, 1])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_make_identical(1, [(6, [1, 3, 5, 7, 9, 11], [11, 9, 7, 5, 3, 1])]) [\\"YES\\"]","solution":"def can_make_identical(m, test_cases): results = [] for i in range(m): n, a, b = test_cases[i] if sorted(a) == sorted(b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimum_missiles_needed(t: int, cases: List[Tuple[int, int, int, int, List[int]]]) -> List[int]: Plan the attack strategy to use the minimum number of missiles to eliminate all enemies. Args: t (int): The number of test cases. cases (List[Tuple[int, int, int, int, List[int]]]): A list of tuples representing the test cases. Each tuple contains: - n (int): The number of enemies. - f (int): The number of Fire missiles. - w (int): The number of Water missiles. - e (int): The number of Earth missiles. - enemies (List[int]): The list of enemies represented by integers (1: Dragon, 2: Mermaid, 3: Elf, 4: Troll). Returns: List[int]: A list of integers representing the minimum number of missiles needed for each test case, with -1 indicating it is impossible to eliminate all enemies. >>> minimum_missiles_needed(3, [(4, 2, 1, 1, [1, 2, 3, 4]), (3, 1, 1, 1, [1, 2, 3]), (5, 3, 2, 1, [4, 4, 4, 4, 4])]) [4, 3, -1] >>> minimum_missiles_needed(1, [(0, 0, 0, 0, [])]) [0] >>> minimum_missiles_needed(1, [(5, 5, 0, 0, [1, 1, 1, 1, 1])]) [5]","solution":"def minimum_missiles_needed(t, cases): results = [] for case in cases: n, f, w, e, enemies = case dragon_count = enemies.count(1) mermaid_count = enemies.count(2) elf_count = enemies.count(3) troll_count = enemies.count(4) # Fire missiles can take care of dragon and trolls # Water missiles can take care of mermaids and elves # Earth missiles can take care of trolls and elves total_needed = 0 # Handling Dragons (1) - Only Fire missiles if dragon_count > f: results.append(-1) continue f -= dragon_count total_needed += dragon_count # Handling Mermaids (2) - Only Water missiles if mermaid_count > w: results.append(-1) continue w -= mermaid_count total_needed += mermaid_count # Handling Elves (3) - Either Water or Earth missiles if elf_count > w + e: results.append(-1) continue total_needed += elf_count elf_count -= min(elf_count, w) w -= min(elf_count, w) if elf_count > 0: e -= elf_count # Handling Trolls (4) - Either Fire or Earth missiles if troll_count > f + e: results.append(-1) continue total_needed += troll_count troll_count -= min(troll_count, f) f -= min(troll_count, f) if troll_count > 0: e -= troll_count results.append(total_needed) return results"},{"question":"from typing import List def min_distance(grid: List[List[int]]) -> int: Returns the minimum distance from the top-left corner to the bottom-right corner in a 2D grid, or -1 if no valid path exists. Args: grid (List[List[int]]): a 2D Grid where 0 represents a passable cell and -1 represents an obstacle. Returns: int: The minimum distance from top-left to bottom-right corner or -1 if path does not exist. >>> min_distance([[0, 0, 0], [0, -1, 0], [0, 0, 0]]) == 4 >>> min_distance([[0, -1], [-1, 0]]) == -1 >>> min_distance([[-1, 0, 0], [0, 0, 0], [0, 0, 0]]) == -1 >>> min_distance([[0, 0, 0], [0, 0, 0], [0, 0, -1]]) == -1 >>> min_distance([[0, 0], [0, 0]]) == 2 >>> min_distance([[0]]) == 0 >>> min_distance([[0, 0, 0, 0, 0], [0, -1, -1, -1, 0], [0, 0, 0, 0, 0], [0, -1, 0, -1, 0], [0, 0, 0, 0, 0]]) == 8","solution":"from collections import deque def min_distance(grid): Returns the minimum distance from the top-left corner to the bottom-right corner in a 2D grid, or -1 if no valid path exists. rows, cols = len(grid), len(grid[0]) if grid[0][0] == -1 or grid[rows-1][cols-1] == -1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows-1 and c == cols-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != -1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 # Example usage: # grid = [[0, 0, 0], [0, -1, 0], [0, 0, 0]] # print(min_distance(grid)) # Output: 4"},{"question":"def sort_positive_numbers_with_maintained_order(lst): Returns a new list where the positive numbers are sorted in ascending order, while the relative positions of negative numbers and zero are maintained. >>> sort_positive_numbers_with_maintained_order([3, -2, -1, 5, 0, -4, 2, 8, -3]) == [2, -2, -1, 3, 0, -4, 5, 8, -3] >>> sort_positive_numbers_with_maintained_order([-3, -2, 0, -1, -4, 0]) == [-3, -2, 0, -1, -4, 0] >>> sort_positive_numbers_with_maintained_order([4, 2, 5, 1, 3]) == [1, 2, 3, 4, 5] >>> sort_positive_numbers_with_maintained_order([-1, 3, 2, 0, 0, -2, 5, 1]) == [-1, 1, 2, 0, 0, -2, 3, 5] >>> sort_positive_numbers_with_maintained_order([]) == [] >>> sort_positive_numbers_with_maintained_order([4]) == [4] >>> sort_positive_numbers_with_maintained_order([-4]) == [-4] >>> sort_positive_numbers_with_maintained_order([0, 0, 0, 0]) == [0, 0, 0, 0] >>> sort_positive_numbers_with_maintained_order([0, -1, 3, -4, 1, 0, 2, -3, 5]) == [0, -1, 1, -4, 2, 0, 3, -3, 5]","solution":"def sort_positive_numbers_with_maintained_order(lst): Returns a new list where the positive numbers are sorted in ascending order, while the relative positions of negative numbers and zero are maintained. # Extract positive numbers and sort them positive_numbers = sorted([num for num in lst if num > 0]) # Use an iterator to replace positive numbers in the original list with the sorted ones pos_iter = iter(positive_numbers) result = [next(pos_iter) if num > 0 else num for num in lst] return result"},{"question":"def unique_paths(N: int, M: int, K: int, blocked: List[Tuple[int, int]]) -> int: Find the number of unique paths from (0, 0) to (N, M) avoiding all construction zones. >>> unique_paths(3, 3, 2, [(1, 2), (2, 1)]) 2 >>> unique_paths(3, 3, 0, []) 20 >>> unique_paths(0, 0, 0, []) 1 >>> unique_paths(3, 3, 1, [(3, 3)]) 0 >>> unique_paths(2, 2, 3, [(1, 0), (1, 1), (1, 2)]) 0 >>> unique_paths(3, 3, 1, [(0, 0)]) 0","solution":"def unique_paths(N, M, K, blocked): grid = [[0] * (M + 1) for _ in range(N + 1)] for b in blocked: grid[b[0]][b[1]] = -1 if grid[0][0] == -1 or grid[N][M] == -1: return 0 grid[0][0] = 1 for i in range(N + 1): for j in range(M + 1): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[N][M]"},{"question":"def sum_of_digits(s): Returns the sum of all digits in the input string s. For example: >>> sum_of_digits(\\"a1b2c3\\") 6 >>> sum_of_digits(\\"abc123\\") 6 >>> sum_of_digits(\\"12x34y56\\") 21","solution":"def sum_of_digits(s): Returns the sum of all digits in the input string s. return sum(int(char) for char in s if char.isdigit())"},{"question":"def max_gold_coins(n: int, matrix: List[List[int]], coins: List[int]) -> int: Find the maximum total value of gold coins that can be collected from any connected group of rooms in the mansion. >>> max_gold_coins(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], [10, 20, 30, 40]) == 60 >>> max_gold_coins(3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]], [5, 10, 15]) == 30 >>> max_gold_coins(2, [[0, 0], [0, 0]], [100, 200]) == 200 >>> max_gold_coins(3, [[0, 1, 1], [1, 0, 1], [1, 1, 0]], [10, 20, 30]) == 60 >>> max_gold_coins(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [5, 10, 15]) == 15 >>> max_gold_coins(4, [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], [10, 20, 30, 40]) == 70 >>> max_gold_coins(5, [[0, 1, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 0, 1, 0], [1, 0, 1, 0, 1], [0, 0, 0, 1, 0]], [10, 10, 10, 10, 10]) == 50","solution":"def max_gold_coins(n, matrix, coins): def dfs(room, visited): visited.add(room) total = coins[room] for next_room in range(n): if matrix[room][next_room] == 1 and next_room not in visited: total += dfs(next_room, visited) return total max_gold = 0 visited = set() for i in range(n): if i not in visited: max_gold = max(max_gold, dfs(i, visited)) return max_gold"},{"question":"from typing import List, Tuple def allocate_drivers(customers: List[Tuple[int, int]], drivers: List[Tuple[int, int]]) -> List[int]: Find the closest driver to each customer using Euclidean distance. >>> allocate_drivers([(0, 0), (2, 3), (4, 5)], [(1, 1), (3, 2), (5, 5)]) == [0, 1, 2] >>> allocate_drivers([(3, 3)], [(1, 1)]) == [0] >>> allocate_drivers([(5, 5)], [(10, 10)]) == [0] >>> allocate_drivers([(3, 3), (3, 3)], [(1, 1), (2, 2), (3, 3)]) == [2, 2] >>> allocate_drivers([(0, 0), (1, 1)], [(1, 1), (0, 0)]) == [1, 0] >>> allocate_drivers([(0, 0)], [(1, 1), (1, 1)]) == [0] >>> allocate_drivers([(10000, 10000), (-10000, -10000)], [(9999, 9999), (-9999, -9999)]) == [0, 1]","solution":"def euclidean_distance(c1, c2): Calculate the Euclidean distance between two points c1 and c2. c1, c2 are given as (x, y) tuples. return ((c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2) ** 0.5 def allocate_drivers(customers, drivers): Finds the closest driver to each customer using Euclidean distance. Returns a list of indices representing the closest driver to each customer. closest_driver_indices = [] for cust in customers: min_distance = float('inf') min_index = -1 for i, driv in enumerate(drivers): dist = euclidean_distance(cust, driv) if dist < min_distance: min_distance = dist min_index = i closest_driver_indices.append(min_index) return closest_driver_indices"},{"question":"def optimize_actions(n, actions): Optimizes a list of actions based on specific rules. Args: n (int): The number of actions. actions (list): The list of actions. Returns: list: The optimized list of actions. pass from solution import optimize_actions def test_optimize_actions_with_all_rules(): actions = [\\"start\\", \\"start\\", \\"stop\\", \\"stop\\", \\"restart\\", \\"start\\", \\"stop\\"] expected = [\\"start\\", \\"stop\\", \\"start\\", \\"stop\\"] assert optimize_actions(7, actions) == expected def test_optimize_actions_with_restarts_and_stops(): actions = [\\"restart\\", \\"start\\", \\"restart\\", \\"stop\\", \\"stop\\"] expected = [\\"start\\", \\"restart\\", \\"stop\\"] assert optimize_actions(5, actions) == expected def test_optimize_actions_with_single_start(): actions = [\\"start\\"] expected = [\\"start\\"] assert optimize_actions(1, actions) == expected def test_optimize_actions_with_mixed_actions(): actions = [\\"start\\", \\"stop\\", \\"start\\", \\"restart\\", \\"start\\", \\"stop\\", \\"stop\\"] expected = [\\"start\\", \\"stop\\", \\"start\\", \\"start\\", \\"stop\\"] assert optimize_actions(7, actions) == expected def test_optimize_actions_with_no_actions(): actions = [] expected = [] assert optimize_actions(0, actions) == expected def test_optimize_actions_with_consecutive_stops(): actions = [\\"stop\\", \\"stop\\", \\"stop\\"] expected = [\\"stop\\"] assert optimize_actions(3, actions) == expected def test_optimize_actions_with_consecutive_starts(): actions = [\\"start\\", \\"start\\", \\"start\\"] expected = [\\"start\\"] assert optimize_actions(3, actions) == expected","solution":"def optimize_actions(n, actions): Optimizes a list of actions based on specific rules. Args: n (int): The number of actions. actions (list): The list of actions. Returns: list: The optimized list of actions. if n == 0: return [] optimized_actions = [actions[0]] for i in range(1, n): current_action = actions[i] last_action = optimized_actions[-1] if last_action == \\"stop\\" and current_action == \\"stop\\": continue elif last_action == \\"restart\\" and current_action == \\"start\\": optimized_actions.pop() optimized_actions.append(\\"start\\") elif last_action == \\"start\\" and current_action == \\"start\\": continue else: optimized_actions.append(current_action) return optimized_actions # Example usage: # n = 7 # actions = [\\"start\\", \\"start\\", \\"stop\\", \\"stop\\", \\"restart\\", \\"start\\", \\"stop\\"] # print(optimize_actions(n, actions)) # Output: # ['start', 'stop', 'start', 'stop']"},{"question":"def identify_hand(cards: List[str]) -> str: Identify if the given hand of cards forms a flush or a straight flush. Args: cards (List[str]): A list of strings representing the cards, where each string contains a rank and a suit (e.g., '2H' for the 2 of Hearts, 'QD' for the Queen of Diamonds). Returns: str: 'SF' followed by the highest rank if the hand is a straight flush, 'F' if the hand is a flush, 'N' if the hand is neither a flush nor a straight flush. Examples: >>> identify_hand([\\"2H\\", \\"3H\\", \\"4H\\", \\"5H\\", \\"6H\\"]) \\"6SF\\" >>> identify_hand([\\"2H\\", \\"4H\\", \\"6H\\", \\"8H\\", \\"10H\\"]) \\"F\\" >>> identify_hand([\\"2H\\", \\"3D\\", \\"4H\\", \\"5S\\", \\"6H\\"]) \\"N\\"","solution":"def card_rank_value(rank): rank_order = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14} return rank_order[rank] def is_consecutive(values): values.sort() for i in range(len(values) - 1): if values[i+1] - values[i] != 1: return False return True def identify_hand(cards): suits = [card[-1] for card in cards] ranks = [card[:-1] for card in cards] if len(set(suits)) != 1: return \\"N\\" # Not a flush, since suits are different values = [card_rank_value(rank) for rank in ranks] if is_consecutive(values): return f\\"{ranks[values.index(max(values))]}SF\\" # Straight Flush return \\"F\\" # Just a flush"},{"question":"def game_outcome(m: int, n: int) -> str: Determines the outcome of the game by the dimensions of the field. >>> game_outcome(2, 2) \\"Draw\\" >>> game_outcome(3, 3) \\"Dasha\\" >>> game_outcome(3, 2) \\"Masha\\"","solution":"def game_outcome(m, n): Determines the outcome of the game by the dimensions of the field. Returns: \\"Dasha\\" if Dasha has a winning strategy. \\"Masha\\" if Masha has a winning strategy. \\"Draw\\" if the game ends in a draw with optimal play from both sides. if m % 2 == 1 and n % 2 == 1: return \\"Dasha\\" elif m % 2 == 0 and n % 2 == 0: return \\"Draw\\" else: return \\"Masha\\""},{"question":"def transform(S: str, T: str) -> int: Determine the minimum number of swaps required to convert string S into string T. >>> transform(\\"mango\\", \\"gonam\\") 3 >>> transform(\\"abc\\", \\"abc\\") 0 >>> transform(\\"abcd\\", \\"dcba\\") 2 >>> transform(\\"abcd\\", \\"efgh\\") -1 >>> transform(\\"abcdefghij\\", \\"jihgfedcba\\") 5 >>> transform(\\"a\\", \\"a\\") 0","solution":"def transform(S, T): Returns the minimum number of swaps required to transform string S into string T. def min_swaps_to_sort(array): n = len(array) pos = list(enumerate(array)) pos.sort(key=lambda it: it[1]) visited = {k: False for k in range(n)} answer = 0 for i in range(n): if visited[i] or pos[i][0] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = pos[x][0] cycle_size += 1 if cycle_size > 0: answer += (cycle_size - 1) return answer if sorted(S) != sorted(T): return -1 return min_swaps_to_sort([S.index(char) for char in T])"},{"question":"def arePasswordsSimilar(s1: str, s2: str) -> bool: Determines if one string can become another by deleting some characters without changing the order of the remaining characters. >>> arePasswordsSimilar(\\"abcde\\", \\"ace\\") True >>> arePasswordsSimilar(\\"abc\\", \\"abc\\") True >>> arePasswordsSimilar(\\"abc\\", \\"def\\") False >>> arePasswordsSimilar(\\"abcdef\\", \\"azce\\") False >>> arePasswordsSimilar(\\"abc\\", \\"\\") True","solution":"def arePasswordsSimilar(s1: str, s2: str) -> bool: Determines if one string can become another by deleting some characters without changing the order of the remaining characters. i, j = 0, 0 while i < len(s1) and j < len(s2): if s1[i] == s2[j]: j += 1 i += 1 return j == len(s2)"},{"question":"def find_missing_letter(chars: List[str]) -> str: Given an array of consecutive (increasing) letters, find the missing letter. The array will always contain letters in only one case. >>> find_missing_letter(['a', 'b', 'c', 'd', 'f']) 'e' >>> find_missing_letter(['O', 'Q', 'R', 'S']) 'P' >>> find_missing_letter(['m', 'o']) 'n' >>> find_missing_letter(['x', 'z']) 'y'","solution":"def find_missing_letter(chars): Given an array of consecutive (increasing) letters, find the missing letter. The array will always contain letters in only one case. for i in range(len(chars) - 1): if ord(chars[i+1]) != ord(chars[i]) + 1: return chr(ord(chars[i]) + 1) raise ValueError(\\"No missing letter found\\")"},{"question":"def min_knight_moves(N: int, M: int, sx: int, sy: int, tx: int, ty: int) -> int: Determines the minimum number of moves a knight needs to reach from (sx, sy) to (tx, ty) on an N x M chessboard. Returns -1 if it is impossible. >>> min_knight_moves(5, 5, 1, 1, 5, 5) 4 >>> min_knight_moves(8, 8, 1, 1, 8, 8) 6 >>> min_knight_moves(1, 1, 1, 1, 1, 1) 0 >>> min_knight_moves(3, 3, 1, 1, 2, 2) -1","solution":"from collections import deque def min_knight_moves(N, M, sx, sy, tx, ty): Determines the minimum number of moves a knight needs to reach from (sx, sy) to (tx, ty) on an N x M chessboard. Returns -1 if it is impossible. # The possible moves for a knight in chess moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] # Check if the starting and target positions are the same if (sx, sy) == (tx, ty): return 0 # Set up a queue for BFS and add the starting position queue = deque([(sx, sy, 0)]) # (current_x, current_y, distance) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() for move in moves: new_x, new_y = x + move[0], y + move[1] # Check if the new position is within bounds and not visited if 1 <= new_x <= N and 1 <= new_y <= M and (new_x, new_y) not in visited: # If the new position is the target position if (new_x, new_y) == (tx, ty): return dist + 1 # Mark the new position as visited and add it to the queue visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) # If we exit the loop, then it was not possible to reach the target return -1"},{"question":"from typing import List, Tuple def road_trip_snacks(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]: This function returns the maximum number of different snacks David can bring without exceeding the total calorie limit and the minimum total calories used to select that maximum number of snacks. >>> road_trip_snacks(1, [(5, 10, [1, 2, 3, 4, 5])]) [(4, 10)] >>> road_trip_snacks(1, [(3, 3, [4, 5, 6])]) [(0, 0)] >>> road_trip_snacks(2, [(5, 10, [1, 2, 3, 4, 5]), (3, 3, [4, 5, 6])]) [(4, 10), (0, 0)] >>> road_trip_snacks(1, [(3, 10**9, [1, 2, 3])]) [(3, 6)] >>> road_trip_snacks(1, [(2, 5, [2, 5])]) [(1, 2)] >>> road_trip_snacks(1, [(4, 7, [8, 9, 10, 11])]) [(0, 0)]","solution":"def road_trip_snacks(T, cases): results = [] for i in range(T): N, C = cases[i][:2] snacks = cases[i][2] # Sort the snacks by calorie count snacks.sort() total_calories = 0 count_snacks = 0 for calorie in snacks: if total_calories + calorie <= C: total_calories += calorie count_snacks += 1 else: break results.append((count_snacks, total_calories)) return results"},{"question":"def max_points_in_grid(n, m, k, grid, special_cells): Compute the maximum points Alyssa can accumulate moving from the top-left corner to the bottom-right corner considering normal moves and at most one special move. Parameters: n (int): the number of rows in the grid m (int): the number of columns in the grid k (int): the number of special cells grid (List[List[int]]): the point values of each cell in the grid special_cells (List[Tuple[int, int]]): the row and column indices of the special cells Returns: int: the maximum points Alyssa can accumulate Example: >>> max_points_in_grid(4, 4, 2, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], [(2, 2), (3, 3)]) 73","solution":"def max_points_in_grid(n, m, k, grid, special_cells): def max_points_when_no_teleport(): dp = [[0]*m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp dp_no_teleport = max_points_when_no_teleport() max_score = dp_no_teleport[n-1][m-1] for sr, sc in special_cells: sr, sc = sr - 1, sc - 1 # adjust for 0-indexing if sr == 0 and sc == 0: continue temp_dp = max_points_when_no_teleport() for i in range(n): for j in range(m): temp_dp[i][j] = max(temp_dp[i][j], dp_no_teleport[sr][sc] + grid[i][j]) max_score = max(max_score, temp_dp[n-1][m-1]) return max_score"},{"question":"MOD = 10**9 + 7 def countEvenDistributions(n: int) -> int: Given a number n, find the number of ways to distribute 2n candies to n children such that each child gets an even number of candies. Return the answer modulo 10^9 + 7. >>> countEvenDistributions(1) 2 >>> countEvenDistributions(2) 6 >>> countEvenDistributions(3) 20 from math import comb def test_countEvenDistributions(): assert countEvenDistributions(1) == 2 assert countEvenDistributions(2) == 6 assert countEvenDistributions(3) == 20 assert countEvenDistributions(4) == 70 assert countEvenDistributions(5) == 252 def test_large_input(): assert countEvenDistributions(50000) # Ensure the function runs for large input def test_small_input(): assert countEvenDistributions(1) == 2 def test_moderate_input(): assert countEvenDistributions(7) == 3432 if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"MOD = 10**9 + 7 def countEvenDistributions(n): Returns the number of ways to distribute 2n candies to n children such that each child gets an even number of candies, modulo 10^9 + 7. def binomial_coefficient(n, k, p): if k > n: return 0 if k == 0 or k == n: return 1 numerator = 1 denominator = 1 for i in range(k): numerator = (numerator * (n - i)) % p denominator = (denominator * (i + 1)) % p inverse_denominator = pow(denominator, p - 2, p) return (numerator * inverse_denominator) % p return binomial_coefficient(2 * n, n, MOD)"},{"question":"def query_delivery_times(times, queries): Given the delivery times for each house, computes the total time required to deliver gifts for specified ranges of houses. Parameters: times (list of int): A list of times for each house. queries (list of list of int): A list of queries where each query is [start, end]. Returns: list of int: A list containing the total delivery times for each query range. >>> times = [5, 3, 8, 6, 2, 7] >>> queries = [[0, 2], [1, 4], [3, 5]] >>> query_delivery_times(times, queries) [16, 19, 15] >>> times = [5, 3, 8, 6, 2, 7] >>> queries = [[0, 0], [2, 2], [5, 5]] >>> query_delivery_times(times, queries) [5, 8, 7] >>> times = [5, 3, 8, 6, 2, 7] >>> queries = [[0, 5]] >>> query_delivery_times(times, queries) [31] >>> times = [1] * 10000 >>> queries = [[0, 9999], [5000, 9999]] >>> query_delivery_times(times, queries) [10000, 5000] >>> times = [5, 3, 8, 6, 2, 7, 4, 9, 1, 10] >>> queries = [[1, 3], [4, 6], [0, 9]] >>> query_delivery_times(times, queries) [17, 13, 55]","solution":"def query_delivery_times(times, queries): Given the delivery times for each house, computes the total time required to deliver gifts for specified ranges of houses. Parameters: times (list of int): A list of times for each house. queries (list of list of int): A list of queries where each query is [start, end]. Returns: list of int: A list containing the total delivery times for each query range. results = [] for start, end in queries: results.append(sum(times[start:end+1])) return results"},{"question":"def find_missing_numbers(n: int, arr: List[int]) -> List[int]: Given an array \`arr\` of \`n\` integers where each element is between \`1\` and \`n\` (inclusive), find all the elements of \`[1, n]\` inclusive that do not appear in \`arr\`. >>> find_missing_numbers(8, [4, 3, 2, 7, 8, 2, 3, 1]) [5, 6] >>> find_missing_numbers(6, [1, 1, 2, 2, 3, 3]) [4, 5, 6]","solution":"def find_missing_numbers(n, arr): Returns the list of numbers from 1 to n that are not present in the array arr. # Create a set from 1 to n all_numbers_set = set(range(1, n + 1)) # Remove the numbers that are in arr from the set arr_set = set(arr) missing_numbers = list(all_numbers_set - arr_set) return sorted(missing_numbers) # Return sorted list for consistency"},{"question":"def first_missing_positive(nums): Given an unsorted integer array nums, return the smallest missing positive integer. Args: nums (List[int]): List of integers which might include negative numbers and zeros. Returns: int: The smallest positive integer missing from the list. Examples: >>> first_missing_positive([1, 2, 0, -1, 3]) 4 >>> first_missing_positive([3, 4, -1, 1, 1, 1, 1, 1, 5, 6]) 2","solution":"def first_missing_positive(nums): Given an unsorted integer array nums, return the smallest missing positive integer. n = len(nums) # We use the indices of the array itself for marking purposes # First move every positive integer <= n to its corresponding index (1-based) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # After rearranging, the first index i which does not have the number i+1 is the answer for i in range(n): if nums[i] != i + 1: return i + 1 # If all numbers are in their correct place, the missing number is n+1 return n + 1"},{"question":"def has_path_with_sum(matrix, target, m, n): Determine if there is a path from the top-left corner of the matrix to the bottom-right corner that adds up to the given target value. >>> matrix = [[5, 4, 2], [1, 2, 1], [7, 3, 4]] >>> has_path_with_sum(matrix, 15, 3, 3) True >>> matrix = [[1, 2], [3, 4]] >>> has_path_with_sum(matrix, 10, 2, 2) False >>> matrix = [[7]] >>> has_path_with_sum(matrix, 7, 1, 1) True >>> matrix = [[5]] >>> has_path_with_sum(matrix, 10, 1, 1) False >>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> has_path_with_sum(matrix, 45, 3, 3) False","solution":"def has_path_with_sum(matrix, target, m, n): def check_path(x, y, current_sum): if x == m-1 and y == n-1: # If we've reached the bottom-right corner return current_sum == target if current_sum > target: return False down = right = False if x+1 < m: # Can move down down = check_path(x+1, y, current_sum + matrix[x+1][y]) if y+1 < n: # Can move right right = check_path(x, y+1, current_sum + matrix[x][y+1]) return down or right return check_path(0, 0, matrix[0][0]) # Example usage: matrix = [ [5, 4, 2], [1, 2, 1], [7, 3, 4] ] target = 15 m, n = 3, 3 print(has_path_with_sum(matrix, target, m, n)) # Output should be True"},{"question":"def max_compatible_spells(spell_count: int, spells: List[str]) -> int: Given a list of spells, find the maximum number of compatible spells that can be cast together simultaneously. A spell is represented by a string of characters. Two spells are considered compatible if they do not share any common character. Args: spell_count (int): The number of spells. spells (List[str]): List of spells. Returns: int: Maximum number of compatible spells. >>> max_compatible_spells(4, [\\"abc\\", \\"def\\", \\"gh\\", \\"cz\\"]) 3 >>> max_compatible_spells(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) 1 >>> max_compatible_spells(5, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 5 from typing import List # You can add more test cases to verify your solution def test_max_compatible_spells(): assert max_compatible_spells(4, [\\"abc\\", \\"def\\", \\"gh\\", \\"cz\\"]) == 3 assert max_compatible_spells(3, [\\"abc\\", \\"bca\\", \\"cab\\"]) == 1 assert max_compatible_spells(5, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) == 5 assert max_compatible_spells(3, [\\"abc\\", \\"bcd\\", \\"cde\\"]) == 1 assert max_compatible_spells(3, [\\"ab\\", \\"cd\\", \\"ef\\"]) == 3 assert max_compatible_spells(1, [\\"a\\"]) == 1 assert max_compatible_spells(6, [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"ac\\", \\"bc\\"]) == 3","solution":"def max_compatible_spells(spell_count, spells): def are_compatible(spell1, spell2): return not set(spell1) & set(spell2) max_count = 0 for i in range(1 << spell_count): selected_spells = [spells[j] for j in range(spell_count) if i & (1 << j)] if all(are_compatible(spell1, spell2) for k, spell1 in enumerate(selected_spells) for spell2 in selected_spells[k+1:]): max_count = max(max_count, len(selected_spells)) return max_count"},{"question":"def max_reliability(n: int, m: int, k: int, edges: List[Tuple[int, int, float]], queries: List[Tuple[int, int]]) -> List[float]: Calculate the maximum reliability of a packet's successful transmission from the source node to the destination node. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. k (int): Number of queries. edges (List[Tuple[int, int, float]]): List of tuples containing edges with their reliability probabilities. queries (List[Tuple[int, int]]): List of queries to determine the maximum reliability between nodes. Returns: List[float]: List of maximum reliability probabilities for each query. Example: >>> max_reliability(4, 4, 2, [(1, 2, 0.5), (2, 3, 0.5), (3, 4, 0.5), (4, 1, 0.5)], [(1, 3), (1, 4)]) [0.25, 0.125] >>> max_reliability(2, 1, 1, [(1, 2, 0.9)], [(1, 2)]) [0.9]","solution":"import heapq def max_reliability(n, m, k, edges, queries): # Create adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, p in edges: graph[u].append((v, p)) def dijkstra(source, target): # Max heap with initial node having reliability 1 priority_queue = [(-1.0, source)] # Distances dict to store max reliability to reach each node max_reliability = {i: 0 for i in graph} max_reliability[source] = 1.0 while priority_queue: current_reliability, u = heapq.heappop(priority_queue) current_reliability = -current_reliability if u == target: return current_reliability for v, reliability in graph[u]: new_reliability = current_reliability * reliability if new_reliability > max_reliability[v]: max_reliability[v] = new_reliability heapq.heappush(priority_queue, (-new_reliability, v)) return 0 results = [] for s, t in queries: result = dijkstra(s, t) results.append(result) return results"},{"question":"def rearrange_string(s: str) -> Tuple[str, Optional[str]]: Rearrange a string such that no two adjacent characters are the same. Return \\"YES\\" and the rearranged string if possible, otherwise return \\"NO\\". >>> rearrange_string(\\"abac\\") (\\"YES\\", \\"abac\\") >>> rearrange_string(\\"aaaa\\") (\\"NO\\", None) >>> rearrange_string(\\"abc\\") (\\"YES\\", \\"abc\\") pass def process_test_cases(T: int, strings: List[str]) -> List[str]: Process multiple test cases to determine if rearrangement is possible for each string. Return a list of results for each test case. >>> process_test_cases(3, [\\"abac\\", \\"aaaa\\", \\"abc\\"]) [\\"YESnabac\\", \\"NO\\", \\"YESnabc\\"] >>> process_test_cases(2, [\\"aaa\\", \\"b\\"]) [\\"NO\\", \\"YESnb\\"] pass def test_rearrange_string_yes(): assert rearrange_string(\\"abac\\")[0] == \\"YES\\" assert rearrange_string(\\"abc\\")[0] == \\"YES\\" assert rearrange_string(\\"aabbcc\\")[0] == \\"YES\\" def test_rearrange_string_no(): assert rearrange_string(\\"aaaa\\")[0] == \\"NO\\" assert rearrange_string(\\"aa\\")[0] == \\"NO\\" def test_process_test_cases(): assert process_test_cases(3, [\\"abac\\", \\"aaaa\\", \\"abc\\"]) == [\\"YESnabac\\", \\"NO\\", \\"YESnabc\\"] assert process_test_cases(2, [\\"aaa\\", \\"b\\"]) == [\\"NO\\", \\"YESnb\\"] def test_edge_cases(): assert rearrange_string(\\"a\\")[0] == \\"YES\\" assert rearrange_string(\\"b\\")[0] == \\"YES\\" assert rearrange_string(\\"c\\")[0] == \\"YES\\" if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange string such that no two adjacent characters are the same. Return \\"YES\\" and the rearranged string, or \\"NO\\" if not possible. counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) result.append(char) count += 1 if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count, char rearranged_str = ''.join(result) if len(rearranged_str) == len(s): return \\"YES\\", rearranged_str else: return \\"NO\\", None def process_test_cases(T, strings): results = [] for i in range(T): s = strings[i] result = rearrange_string(s) if result[0] == \\"YES\\": results.append(f\\"YESn{result[1]}\\") else: results.append(\\"NO\\") return results # Handle input and output def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) strings = data[1:] results = process_test_cases(T, strings) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Process a sequence of operations on an integer sequence and return the sum after each operation. Operations: - \\"ADD X\\": Adds the integer X to the sequence - \\"REMOVE X\\": Removes the integer X from the sequence if it exists - \\"REPLACE X Y\\": Replaces the first occurrence of X with Y in the sequence if X exists >>> process_operations(5, [\\"ADD 5\\", \\"ADD 3\\", \\"REMOVE 5\\", \\"ADD 10\\", \\"REPLACE 3 7\\"]) [5, 8, 3, 13, 17] >>> process_operations(1, [\\"ADD 5\\"]) [5]","solution":"def process_operations(n, operations): sequence = [] current_sum = 0 results = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"ADD\\": x = int(parts[1]) sequence.append(x) current_sum += x elif cmd == \\"REMOVE\\": x = int(parts[1]) if x in sequence: sequence.remove(x) current_sum -= x elif cmd == \\"REPLACE\\": x = int(parts[1]) y = int(parts[2]) if x in sequence: index = sequence.index(x) sequence[index] = y current_sum = current_sum - x + y results.append(current_sum) return results # Example input # n = 5 # operations = [\\"ADD 5\\", \\"ADD 3\\", \\"REMOVE 5\\", \\"ADD 10\\", \\"REPLACE 3 7\\"] # print(process_operations(n, operations))"},{"question":"def find_top_k_participants(n: int, k: int, participant_scores: List[Tuple[str, int]]) -> List[str]: Compute the total scores of all participants and return the IDs of the top \`k\` participants in descending order of their total scores. If participants have the same scores, order them by their participant IDs in ascending order. >>> find_top_k_participants(6, 3, [('alice', 50), ('bob', 80), ('alice', 20), ('charlie', 30), ('bob', 40), ('charlie', 70)]) ['bob', 'charlie', 'alice'] >>> find_top_k_participants(4, 2, [('alice', 50), ('bob', 50), ('carol', 50), ('dave', 50)]) ['alice', 'bob'] >>> find_top_k_participants(3, 2, [('alice', 30), ('bob', 30), ('charlie', 30)]) ['alice', 'bob'] >>> find_top_k_participants(1, 1, [('alice', 50)]) ['alice'] >>> find_top_k_participants(2, 3, [('alice', 30), ('bob', 40)]) ['bob', 'alice']","solution":"def find_top_k_participants(n, k, participant_scores): from collections import defaultdict scores = defaultdict(int) for pid, score in participant_scores: scores[pid] += score sorted_participants = sorted(scores.items(), key=lambda x: (-x[1], x[0])) top_k_participants = [pid for pid, score in sorted_participants[:k]] return top_k_participants"},{"question":"from typing import List def maxSubarraySum(arr: List[int]) -> int: Finds the contiguous subarray with the largest sum and returns the sum. Implements Kadane's Algorithm. :param arr: List of integers :return: Maximum sum of the contiguous subarray Examples: >>> maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> maxSubarraySum([1, 2, 3, -2, 5]) == 9 >>> maxSubarraySum([-3, -2, -1, -4]) == -1 >>> maxSubarraySum([1, 2, 3, 4, 5]) == 15 >>> maxSubarraySum([]) == 0 def test_maxSubarraySum_standard_case(): assert maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_maxSubarraySum_all_negative(): assert maxSubarraySum([-3, -2, -1, -4]) == -1 def test_maxSubarraySum_mixed_numbers(): assert maxSubarraySum([1, 2, 3, -2, 5]) == 9 def test_maxSubarraySum_single_element(): assert maxSubarraySum([5]) == 5 assert maxSubarraySum([-5]) == -5 def test_maxSubarraySum_all_positive(): assert maxSubarraySum([1, 2, 3, 4, 5]) == 15 def test_maxSubarraySum_empty_array(): assert maxSubarraySum([]) == 0","solution":"from typing import List def maxSubarraySum(arr: List[int]) -> int: Finds the contiguous subarray with the largest sum and returns the sum. Implements Kadane's Algorithm. :param arr: List of integers :return: Maximum sum of the contiguous subarray if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def find_palindromic_substrings(s: str) -> List[str]: Returns a list of all distinct palindromic substrings in the input string, sorted in ascending lexicographical order. >>> find_palindromic_substrings(\\"abaaa\\") ['a', 'aa', 'aaa', 'aba', 'b'] >>> find_palindromic_substrings(\\"abc\\") ['a', 'b', 'c'] >>> find_palindromic_substrings(\\"racecar\\") ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar'] >>> find_palindromic_substrings(\\"abcdef\\") ['a', 'b', 'c', 'd', 'e', 'f']","solution":"def find_palindromic_substrings(s): Returns a list of all distinct palindromic substrings in the input string, sorted in ascending lexicographical order. def is_palindrome(sub): Checks if a given substring is a palindrome. return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i, len(s)): sub = s[i:j + 1] if is_palindrome(sub): palindromic_substrings.add(sub) return sorted(palindromic_substrings) # Example usage: # s = \\"abaaa\\" # print(find_palindromic_substrings(s)) # Output: ['a', 'aa', 'aaa', 'aba', 'b']"},{"question":"def min_subset_diff(arr): Compute the minimum possible difference of sums between two non-empty subsequences of the given list of integers. >>> min_subset_diff([1, 6, 11, 5]) 1 >>> min_subset_diff([10, 20, 15]) 5 >>> min_subset_diff([3, 1, 4, 2, 2]) 0 # Your code here def process_input(T, test_cases): Process the input, solve the problem for each test case and return the results. def main(input_data): Parses the input data, calls the appropriate functions to solve the problem, and returns the formatted output.","solution":"def min_subset_diff(arr): Helper function to compute the minimum possible difference of sums between two non-empty subsequences of the given list of integers. n = len(arr) total_sum = sum(arr) # Initialize a dp array dp = [False] * (total_sum + 1) dp[0] = True # Populate the dp array for num in arr: for j in range(total_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] # Find the minimum difference min_diff = float('inf') for s in range(total_sum // 2 + 1): if dp[s]: min_diff = min(min_diff, abs(total_sum - 2 * s)) return min_diff def process_input(T, test_cases): Function to process the input, solve the problem for each test case and return the results. results = [] for i in range(T): n, arr = test_cases[i] results.append(min_subset_diff(arr)) return results def main(input_data): Parses the input data, calls the appropriate functions to solve the problem, and returns the formatted output. lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): n = int(lines[line_index]) arr = list(map(int, lines[line_index + 1].split())) test_cases.append((n, arr)) line_index += 2 results = process_input(T, test_cases) return \\"n\\".join(map(str, results))"},{"question":"def min_new_bridges(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: Determine the minimum number of new bridges that need to be built so that all islands are connected. >>> min_new_bridges(4, 2, [(1, 2), (3, 4)]) 1 >>> min_new_bridges(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> min_new_bridges(5, 0, []) 4 >>> min_new_bridges(7, 3, [(1, 2), (2, 3), (5, 6)]) 3 >>> min_new_bridges(3, 1, [(1, 2)]) 1","solution":"def min_new_bridges(n, m, bridges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v in bridges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i) components += 1 # To connect 'c' components, we need at least 'c - 1' bridges return components - 1"},{"question":"def can_partition(arr: List[int]) -> str: Determine if the array can be partitioned into two subsets with equal sum. Args: arr (list): The list of integers to partition. Returns: str: \\"YES\\" if the partition is possible, \\"NO\\" otherwise. Examples: >>> can_partition([1, 5, 11, 5]) \\"YES\\" >>> can_partition([1, 2, 3, 5]) \\"NO\\"","solution":"def can_partition(arr): Determine if the array can be partitioned into two subsets with equal sum. Args: arr (list): The list of integers to partition. Returns: str: \\"YES\\" if the partition is possible, \\"NO\\" otherwise. total_sum = sum(arr) # If the total sum is odd, it's not possible to partition into equal subsets if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(arr) # DP array to store if a sum is possible with the subset of given array dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Returns the maximum depth of the binary tree. >>> maxDepth(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))) == 3 >>> maxDepth(TreeNode(1)) == 1 >>> maxDepth(None) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root: TreeNode) -> int: Returns the maximum depth of the binary tree. if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"import heapq def shortestPath(graph, n, m, source, destination): Find the length of the shortest path in a weighted, directed graph represented by an adjacency matrix. Args: graph (List[List[int]]): Adjacency matrix representing the graph. n (int): Number of vertices in the graph. m (int): Number of edges in the graph. source (int): The source vertex. destination (int): The destination vertex. Returns: int: Length of the shortest path from source to destination. Returns -1 if no path exists. Examples: >>> INF = float('inf') >>> graph1 = [[0, 3, INF, 7], [INF, 0, 2, INF], [INF, INF, 0, 1], [INF, INF, INF, 0]] >>> shortestPath(graph1, 4, 4, 0, 3) 6 >>> graph2 = [[0, 1, 4], [INF, 0, 2], [INF, INF, 0]] >>> shortestPath(graph2, 3, 3, 0, 2) 3 >>> graph3 = [[0, INF, INF], [INF, 0, INF], [INF, INF, 0]] >>> shortestPath(graph3, 3, 0, 0, 2) -1","solution":"import heapq INF = float('inf') def shortestPath(graph, n, m, source, destination): # Dijkstra's algorithm to find the shortest path in directed, weighted graph distances = [INF] * n distances[source] = 0 min_heap = [(0, source)] while min_heap: curr_distance, curr_vertex = heapq.heappop(min_heap) if curr_distance > distances[curr_vertex]: continue for next_vertex in range(n): if graph[curr_vertex][next_vertex] != INF: distance = curr_distance + graph[curr_vertex][next_vertex] if distance < distances[next_vertex]: distances[next_vertex] = distance heapq.heappush(min_heap, (distance, next_vertex)) return distances[destination] if distances[destination] != INF else -1"},{"question":"def minimum_preparation_time(dishes, dependencies): Determine the minimum total time required to prepare all the dishes considering the dependencies. >>> minimum_preparation_time([('A', 3), ('B', 2), ('C', 1), ('D', 4)], [('A', 'B'), ('B', 'C'), ('A', 'C'), ('C', 'D')]) 10 >>> minimum_preparation_time([('A', 2), ('B', 2), ('C', 2)], [('A', 'B'), ('B', 'C')]) 6 >>> minimum_preparation_time([('A', 1), ('B', 1), ('C', 1)], []) 1 >>> minimum_preparation_time([('A', 3)], []) 3 >>> minimum_preparation_time([('A', 1), ('B', 2), ('C', 3), ('D', 4)], [('A', 'B'), ('B', 'C'), ('C', 'D')]) 10","solution":"from collections import defaultdict, deque def minimum_preparation_time(dishes, dependencies): # Build graph graph = defaultdict(list) indegree = {dish[0]: 0 for dish in dishes} preparation_time = {dish[0]: dish[1] for dish in dishes} for dep in dependencies: a, b = dep graph[a].append(b) indegree[b] += 1 # Topological sorting using Kahn's algorithm queue = deque([dish for dish in indegree if indegree[dish] == 0]) total_time = 0 max_times = {dish[0]: 0 for dish in dishes} while queue: dish = queue.popleft() max_times[dish] += preparation_time[dish] total_time = max(total_time, max_times[dish]) for neighbor in graph[dish]: indegree[neighbor] -= 1 max_times[neighbor] = max(max_times[neighbor], max_times[dish]) if indegree[neighbor] == 0: queue.append(neighbor) return total_time"},{"question":"def max_book_value(N: int, L: int, books: List[Tuple[int, int]]) -> int: Calculates the maximum possible sum of values of a subset of books without exceeding the thickness limit. :param N: number of books :param L: thickness limit :param books: list of tuples, each containing the thickness and value of a book :return: maximum sum of values without exceeding the thickness limit >>> max_book_value(4, 7, [(1, 4), (3, 2), (4, 5), (2, 3)]) 12 >>> max_book_value(1, 5, [(3, 10)]) 10 >>> max_book_value(4, 10, [(1, 1), (2, 2), (3, 3), (4, 4)]) 10 >>> max_book_value(3, 4, [(5, 10), (6, 15), (7, 20)]) 0 >>> max_book_value(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90","solution":"def max_book_value(N, L, books): Calculates the maximum possible sum of values of a subset of books without exceeding the thickness limit. :param N: int, number of books :param L: int, thickness limit :param books: list of tuples, where each tuple contains (thickness, value) of a book :return: int, maximum sum of values without exceeding the thickness limit # Initialize dp array where dp[i] represents the maximum value that can be achieved with a thickness limit of i dp = [0] * (L + 1) # Loop through each book for thickness, value in books: # In reverse order for proper dynamic programming update for j in range(L, thickness - 1, -1): dp[j] = max(dp[j], dp[j - thickness] + value) # The answer will be the maximum value we can get with thickness limit L return max(dp) # Example usage if __name__ == \\"__main__\\": books = [(1, 4), (3, 2), (4, 5), (2, 3)] N = 4 L = 7 print(max_book_value(N, L, books)) # Output: 12"},{"question":"def top_k_frequent_queries(queries: List[str], k: int) -> List[str]: Return the top 'k' most frequent search queries in descending order of their frequency. If two queries have the same frequency, they can be returned in any order. PARAMETERS: queries : List[str] : List of search queries k : int : number of top frequent queries to return RETURNS: List[str] : List of 'k' most frequent queries >>> top_k_frequent_queries([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2) ['apple', 'banana'] >>> top_k_frequent_queries([\\"query1\\", \\"query2\\", \\"query1\\", \\"query1\\", \\"query3\\", \\"query2\\", \\"query2\\", \\"query4\\"], 3) ['query1', 'query2', 'query3'] pass def process_test_cases(test_cases: List[Tuple[List[str], int]]) -> List[str]: Process multiple test cases to find the top 'k' frequent search queries for each test case. PARAMETERS: test_cases : List[Tuple[List[str], int]] : List of tuples where each tuple contains a list of search queries and an integer 'k' RETURNS: List[str] : List of strings representing the most frequent search queries for each test case, space-separated >>> process_test_cases([ ... ([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"], 2), ... ([\\"query1\\", \\"query2\\", \\"query1\\", \\"query1\\", \\"query3\\", \\"query2\\", \\"query2\\", \\"query4\\"], 3) ... ]) ['apple banana', 'query1 query2 query3'] pass","solution":"from collections import Counter import heapq def top_k_frequent_queries(queries, k): count = Counter(queries) # Get the k most common elements with their counts most_common = heapq.nlargest(k, count.items(), key=lambda item: item[1]) # Extract the queries from the most common elements result = [query for query, freq in most_common] return result def process_test_cases(test_cases): results = [] for queries, k in test_cases: top_queries = top_k_frequent_queries(queries, k) results.append(\\" \\".join(top_queries)) return results"},{"question":"def find_minimal_rotations(s: str) -> int: Given a string containing only lowercase alphabets, find the minimum number of adjacent character swaps necessary to make the string sorted in non-decreasing order. Parameters: s (str): Input string consisting of lowercase alphabets. Returns: int: The minimum number of swaps required to sort the string. Examples: >>> find_minimal_rotations(\\"dcba\\") 6 >>> find_minimal_rotations(\\"dabc\\") 3 >>> find_minimal_rotations(\\"ab\\") 0 >>> find_minimal_rotations(\\"cba\\") 3","solution":"def find_minimal_rotations(s: str) -> int: Returns the minimum number of adjacent swaps required to sort the string in non-decreasing order. def merge_count_split_inv(arr, temp_arr, left, mid, right): # This function merges two halves of array and counts inversions i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because left subarray and right subarray are sorted, # and every element of left subarray (arr[i] to arr[mid]) is greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): # This function recursively sorts the array and counts inversions inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count # Main function starts here n = len(s) arr = list(s) # Create a temporary array temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"def smallest_segment_length(resources: str) -> int: Returns the length of the smallest segment that contains at least one 'G', one 'S', and one 'C'. If no such segment exists, return 0. >>> smallest_segment_length(\\"GSCCGSG\\") 3 >>> smallest_segment_length(\\"CCCGGSS\\") 4 >>> smallest_segment_length(\\"GGGGGGGG\\") 0 >>> smallest_segment_length(\\"CCCCCCCC\\") 0 >>> smallest_segment_length(\\"SSSSSSSS\\") 0 >>> smallest_segment_length(\\"G\\") 0 >>> smallest_segment_length(\\"S\\") 0 >>> smallest_segment_length(\\"C\\") 0 >>> smallest_segment_length(\\"GS\\") 0 >>> smallest_segment_length(\\"GC\\") 0 >>> smallest_segment_length(\\"SC\\") 0 >>> smallest_segment_length(\\"GGGGGGSC\\") 3 >>> smallest_segment_length(\\"GSCGGGGG\\") 3 >>> smallest_segment_length(\\"GGGSCGG\\") 3 >>> smallest_segment_length(\\"GSGCGSS\\") 3 >>> smallest_segment_length(\\"GSC\\") 3 >>> smallest_segment_length(\\"CGS\\") 3 >>> smallest_segment_length(\\"SGC\\") 3","solution":"def smallest_segment_length(resources): Returns the length of the smallest segment that contains at least one 'G', one 'S', and one 'C'. If no such segment exists, return 0. n = len(resources) if n < 3: return 0 min_length = float('inf') left = 0 count = {'G': 0, 'S': 0, 'C': 0} distinct_count = 0 for right in range(n): if resources[right] in count: if count[resources[right]] == 0: distinct_count += 1 count[resources[right]] += 1 while distinct_count == 3: min_length = min(min_length, right - left + 1) if resources[left] in count: count[resources[left]] -= 1 if count[resources[left]] == 0: distinct_count -= 1 left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def minimum_swaps(books: List[str]) -> int: Return the minimum number of adjacent swaps needed to sort the book titles in alphabetical order. >>> minimum_swaps([\\"zebra\\", \\"monkey\\", \\"apple\\"]) 3 >>> minimum_swaps([\\"banana\\", \\"apple\\", \\"cherry\\"]) 1","solution":"def minimum_swaps(books): Return the minimum number of adjacent swaps needed to sort the book titles in alphabetical order. n = len(books) swaps = 0 arr = books[:] # Bubble sort algorithm to count swaps for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swaps += 1 return swaps"},{"question":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Given a list of unique integers, generate all possible subsets of the list. The subsets should not contain any duplicate subsets, and they should be returned in ascending order based on their length. If two subsets have the same length, they should be sorted in ascending order based on their integer values. >>> generate_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_subsets([4, 1, 0]) [[], [0], [1], [4], [0, 1], [0, 4], [1, 4], [0, 1, 4]]","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): res.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() res = [] backtrack(0, []) res.sort(key=lambda x: (len(x), x)) return res"},{"question":"def can_reach_target(n, m, grid, sr, sc, tr, tc): Determines if it is possible to move from the starting cell (sr, sc) to the target cell (tr, tc) in the given grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of list of int): n x m grid with 0s and 1s (0: passable, 1: impassable). sr (int): starting row. sc (int): starting column. tr (int): target row. tc (int): target column. Returns: str: \\"YES\\" if the character can reach the target cell, otherwise \\"NO\\". pass def test_grid1(): n = 5 m = 7 grid = [ [0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0] ] sr, sc, tr, tc = 1, 1, 5, 7 assert can_reach_target(n, m, grid, sr, sc, tr, tc) == \\"YES\\" def test_grid2(): n = 3 m = 3 grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] sr, sc, tr, tc = 1, 1, 3, 3 assert can_reach_target(n, m, grid, sr, sc, tr, tc) == \\"NO\\" def test_start_impassable(): n = 3 m = 3 grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] sr, sc, tr, tc = 1, 1, 3, 3 assert can_reach_target(n, m, grid, sr, sc, tr, tc) == \\"NO\\" def test_target_impassable(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 1] ] sr, sc, tr, tc = 1, 1, 3, 3 assert can_reach_target(n, m, grid, sr, sc, tr, tc) == \\"NO\\" def test_single_cell(): n = 1 m = 1 grid = [[0]] sr, sc, tr, tc = 1, 1, 1, 1 assert can_reach_target(n, m, grid, sr, sc, tr, tc) == \\"YES\\"","solution":"def can_reach_target(n, m, grid, sr, sc, tr, tc): Determines if it is possible to move from the starting cell (sr, sc) to the target cell (tr, tc) in the given grid. Parameters: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (list of list of int): n x m grid with 0s and 1s (0: passable, 1: impassable). sr (int): starting row. sc (int): starting column. tr (int): target row. tc (int): target column. Returns: str: \\"YES\\" if the character can reach the target cell, otherwise \\"NO\\". from collections import deque # Convert input positions to 0-based index sr, sc, tr, tc = sr - 1, sc - 1, tr - 1, tc - 1 # Directions array for moving in 4 possible directions: up, down, left, right. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or target cell is impassable if grid[sr][sc] == 1 or grid[tr][tc] == 1: return \\"NO\\" # Queue for BFS queue = deque([(sr, sc)]) # Set to keep track of visited cells visited = set((sr, sc)) while queue: current_r, current_c = queue.popleft() # If we are at the target cell, return \\"YES\\" if current_r == tr and current_c == tc: return \\"YES\\" # Explore all 4 possible directions for dr, dc in directions: new_r, new_c = current_r + dr, current_c + dc # Check if the new position is within bounds and is passable and not visited yet if 0 <= new_r < n and 0 <= new_c < m and (new_r, new_c) not in visited and grid[new_r][new_c] == 0: queue.append((new_r, new_c)) visited.add((new_r, new_c)) return \\"NO\\""},{"question":"def encrypt_string(s: str) -> str: Encrypts the input string by substituting each letter with its corresponding letter in the reversed alphabet. Non-letter characters are left unchanged. >>> encrypt_string(\\"hello world!\\") == \\"svool dliow!\\" >>> encrypt_string(\\"Code123!\\") == \\"Xlwv123!\\" >>> encrypt_string(\\"abcXYZ\\") == \\"zyxCBA\\" >>> encrypt_string(\\"12345!@#%\\") == \\"12345!@#%\\" >>> encrypt_string(\\"a\\") == \\"z\\" >>> encrypt_string(\\"A\\") == \\"Z\\" >>> encrypt_string(\\"1\\") == \\"1\\"","solution":"def encrypt_string(s): Encrypts the input string by substituting each letter with its corresponding letter in the reversed alphabet. Non-letter characters are left unchanged. result = [] for char in s: if 'a' <= char <= 'z': result.append(chr(ord('z') - (ord(char) - ord('a')))) elif 'A' <= char <= 'Z': result.append(chr(ord('Z') - (ord(char) - ord('A')))) else: result.append(char) return \\"\\".join(result)"},{"question":"def minInsertionsToMakeKPalindrome(s: str, k: int) -> int: Determine the minimum number of characters to be inserted to make the string a k-palindrome. A string is called a k-palindrome if it can be transformed into a palindrome by removing at most k characters. Args: s (str): Input string k (int): Number of characters that can be removed Returns: int: Minimum number of insertions required Examples: >>> minInsertionsToMakeKPalindrome(\\"abacd\\", 1) 1 >>> minInsertionsToMakeKPalindrome(\\"abcdeca\\", 2) 0 # Your implementation here from solution import minInsertionsToMakeKPalindrome def test_example_1(): assert minInsertionsToMakeKPalindrome(\\"abacd\\", 1) == 1 def test_example_2(): assert minInsertionsToMakeKPalindrome(\\"abcdeca\\", 2) == 0 def test_single_char(): assert minInsertionsToMakeKPalindrome(\\"a\\", 0) == 0 assert minInsertionsToMakeKPalindrome(\\"a\\", 1) == 0 def test_two_char(): assert minInsertionsToMakeKPalindrome(\\"ab\\", 0) == 1 assert minInsertionsToMakeKPalindrome(\\"ab\\", 1) == 0 def test_no_insertions_needed(): assert minInsertionsToMakeKPalindrome(\\"aba\\", 0) == 0 assert minInsertionsToMakeKPalindrome(\\"abba\\", 1) == 0 def test_complete_reversal(): assert minInsertionsToMakeKPalindrome(\\"abc\\", 2) == 0 assert minInsertionsToMakeKPalindrome(\\"abc\\", 0) == 2 def test_edge_case(): assert minInsertionsToMakeKPalindrome(\\"abcdefgh\\", 100) == 0","solution":"def minInsertionsToMakeKPalindrome(s, k): n = len(s) # Create a DP table for the length of the longest palindromic subsequence. dp = [[0] * (n + 1) for _ in range(n + 1)] # Fill the dp table for i in range(1, n + 1): for j in range(1, n + 1): if s[i - 1] == s[n - j]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Calculate the minimum insertions needed lps = dp[n][n] # length of the longest palindromic subsequence min_insertions_needed = n - lps # Check if the string can be a k-palindrome if min_insertions_needed <= k: return 0 else: return min_insertions_needed - k"},{"question":"def find_element_between_odd_and_even(nums: List[int]) -> int: Given a list of integers, return the first element that appears after the first odd number and before the first even number. If no such element exists, return -1. >>> find_element_between_odd_and_even([1, 3, 2, 4]) == 3 >>> find_element_between_odd_and_even([1, 2, 4]) == 1 >>> find_element_between_odd_and_even([1, 3, 5, 7]) == -1 >>> find_element_between_odd_and_even([2, 4, 6, 8]) == -1 >>> find_element_between_odd_and_even([1, 3, 5, 6, 7, 8, 9]) == 5 >>> find_element_between_odd_and_even([1, 2, 3, 4]) == 1 >>> find_element_between_odd_and_even([101, 303, 100, 202, 303]) == 303","solution":"def find_element_between_odd_and_even(nums): Given a list of integers, returns the first element that appears after the first odd number and before the first even number. If no such element exists, returns -1. found_odd = False for i, num in enumerate(nums): if num % 2 != 0: found_odd = True elif num % 2 == 0 and found_odd: if i - 1 >= 0: return nums[i-1] break return -1"},{"question":"from typing import List def shortest_path(m: int, n: int, grid: List[str]) -> None: Helper function to find the shortest path in an m x n grid with obstacles. The function reads m, n and grid as input, representing the number of rows, number of columns, and grid configuration respectively. The grid contains only two types of cells: empty ('.') and obstacle ('#'). Constraints: 1 ≤ m, n ≤ 100 0 ≤ obstacles_in_grid ≤ m * n If the shortest path exists, print the shortest path length followed by the number of cells in the path and their positions. If no path exists, print -1. >>> shortest_path(3, 3, [ ... \\".#.\\", ... \\".#.\\", ... \\"...\\" ...]) 4 5 1 1 2 1 3 1 3 2 3 3 >>> shortest_path(4, 4, [ ... \\"....\\", ... \\"..\\", ... \\"..\\", ... \\"....\\" ...]) 6 7 1 1 2 1 3 1 4 1 4 2 4 3 4 4 >>> shortest_path(2, 2, [ ... \\".#\\", ... \\"#.\\" ...]) -1","solution":"from collections import deque def shortest_path(m, n, grid): def in_bounds(r, c): return 0 <= r < m and 0 <= c < n def neighbors(r, c): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if in_bounds(nr, nc) and grid[nr][nc] != '#': yield nr, nc queue = deque([(0, 0, 0, [])]) # (row, column, distance, path) visited = set((0, 0)) while queue: r, c, dist, path = queue.popleft() # Append the current cell to the path new_path = path + [(r + 1, c + 1)] # Check if we reached the bottom-right corner if (r, c) == (m - 1, n - 1): print(dist) print(len(new_path)) for cell in new_path: print(cell[0], cell[1]) return for nr, nc in neighbors(r, c): if (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1, new_path)) # If no path is found print(-1)"},{"question":"def min_cost_painting_houses(costs): Returns the minimum cost to paint all houses such that no two adjacent houses have the same color. >>> min_cost_painting_houses([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> min_cost_painting_houses([[1, 10, 100]]) 1 >>> min_cost_painting_houses([[1, 10, 100], [100, 1, 10]]) 2 >>> min_cost_painting_houses([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) 15 >>> min_cost_painting_houses([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def min_cost_painting_houses(costs): Returns the minimum cost to paint all houses such that no two adjacent houses have the same color. if not costs: return 0 n = len(costs) for i in range(1, n): costs[i][0] += min(costs[i-1][1], costs[i-1][2]) costs[i][1] += min(costs[i-1][0], costs[i-1][2]) costs[i][2] += min(costs[i-1][0], costs[i-1][1]) return min(costs[-1]) # Example on how to use the function: # costs = [ # [17, 2, 17], # [16, 16, 5], # [14, 3, 19] # ] # print(min_cost_painting_houses(costs)) # Output: 10"},{"question":"def maxGold(N, Gold): Determine the maximum amount of gold Philip can collect from N gold mines, given the constraint that he cannot mine from any adjacent mines. Args: N (int): Number of gold mines Gold (List[int]): List of amounts of gold in each mine Returns: int: Maximum amount of gold that can be collected >>> maxGold(4, [1, 2, 3, 1]) 4 >>> maxGold(6, [2, 7, 9, 3, 1, 5]) 16 >>> maxGold(1, [4]) 4 >>> maxGold(2, [3, 5]) 5 >>> maxGold(5, [3, 2, 5, 10, 7]) 15 >>> maxGold(5, [0, 0, 0, 0, 0]) 0 >>> maxGold(5, [0, 0, 5, 0, 0]) 5","solution":"def maxGold(N, Gold): if N == 0: return 0 elif N == 1: return Gold[0] dp = [0] * N dp[0] = Gold[0] dp[1] = max(Gold[0], Gold[1]) for i in range(2, N): dp[i] = max(Gold[i] + dp[i-2], dp[i-1]) return dp[N-1]"},{"question":"def highest_product_of_three(nums: List[int]) -> int: Returns the highest product that can be achieved by multiplying exactly three distinct integers from the list. >>> highest_product_of_three([1, 2, 3, 4]) 24 >>> highest_product_of_three([-10, -10, 5, 2]) 500 >>> highest_product_of_three([-10, -9, -1, 0, 2, 3]) 270 >>> highest_product_of_three([1, -4, 3, -6, 5, 7]) 168 >>> highest_product_of_three([-1, -2, -3, -4]) -6 >>> highest_product_of_three([10, 10, 10]) 1000 >>> highest_product_of_three([-10, -10, -10]) -1000 pass","solution":"def highest_product_of_three(nums): Returns the highest product that can be achieved by multiplying exactly three distinct integers from the list. nums.sort() # The highest product of three numbers could either come from # - the product of the three largest numbers # - the product of the two smallest (most negative) numbers and the largest number product1 = nums[-1] * nums[-2] * nums[-3] product2 = nums[0] * nums[1] * nums[-1] return max(product1, product2)"},{"question":"def canFormPalindrome(s: str) -> bool: Determines whether any permutation of the given string can form a palindrome. Parameters: s (str): The input string Returns: bool: True if a permutation of the string can form a palindrome, False otherwise. Examples: >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"cara\\") False","solution":"def canFormPalindrome(s): Determines whether any permutation of the given string can form a palindrome. Parameters: s (str): The input string Returns: bool: True if a permutation of the string can form a palindrome, False otherwise. # Normalizing input to lowercase to ensure case insensitivity s = s.lower() char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check for the number of characters with odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be able to form a palindrome, # there must be at most one character with an odd count return odd_count <= 1"},{"question":"def find_pair_with_sum(arr: List[int], target: int) -> Union[Tuple[int, int], int]: Finds two distinct numbers in the array that add up to the target sum and returns their indices. If no such pair exists, returns -1. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4], 8) -1 >>> find_pair_with_sum([1, 2, 3, 4, 5, 6], 7) (0, 5) or (1, 4) or (2, 3) >>> find_pair_with_sum([-3, 4, 3, 90], 0) (0, 2) >>> find_pair_with_sum([], 5) -1 >>> find_pair_with_sum([1], 1) -1 >>> find_pair_with_sum([3, 3], 6) (0, 1)","solution":"def find_pair_with_sum(arr, target): Finds two distinct numbers in the array that add up to the target sum and returns their indices. If no such pair exists, returns -1. # Create a dictionary to store the indices of the elements indices = {} for i, number in enumerate(arr): # Calculate the complement complement = target - number # Check if the complement exists in the dictionary if complement in indices: return indices[complement], i # Store the index of the number in the dictionary indices[number] = i return -1"},{"question":"def find_known_by_all(n: int, relations: List[str]) -> int: Determines if there exists a scientist known by all other scientists. Args: n : int : number of scientists relations : list of str : list of strings representing who knows whom Returns: int : 1-based index of the scientist known by all others, or -1 if no such scientist exists Examples: >>> find_known_by_all(4, ['0111', '0011', '0001', '0000']) 4 >>> find_known_by_all(3, ['010', '001', '100']) -1","solution":"def find_known_by_all(n, relations): Determines if there exists a scientist known by all other scientists. Args: n : int : number of scientists relations : list of str : list of strings representing who knows whom Returns: int : 1-based index of the scientist known by all others, or -1 if no such scientist exists for j in range(n): all_known = True for i in range(n): if i != j and relations[i][j] == '0': all_known = False break if all_known: return j + 1 return -1"},{"question":"def is_pangram(s: str) -> bool: Determines if the input string is a pangram (contains every letter of the alphabet at least once). Args: s (str): Input string of mixed-case alphabetical characters. Returns: bool: True if the string is a pangram, False otherwise. >>> is_pangram(\\"The quick brown fox jumps over a lazy dog\\") True >>> is_pangram(\\"Hello World\\") False >>> is_pangram(\\"Pack my box with five dozen liquor jugs\\") True >>> is_pangram(\\"ThE QuIcK BrOwN FoX JuMpS OvEr A LaZy DoG\\") True >>> is_pangram(\\"ThiS iS A TeSt\\") False >>> is_pangram(\\"\\") False >>> is_pangram(\\"The quick! brown; fox? jumps: over, a lazy dog.\\") True >>> is_pangram(\\"The quick brown fox jumps over 345 the lazy dog!\\") True","solution":"def is_pangram(s): Determines if the input string is a pangram (contains every letter of the alphabet at least once). Args: s (str): Input string of mixed-case alphabetical characters. Returns: bool: True if the string is a pangram, False otherwise. alphabet = set('abcdefghijklmnopqrstuvwxyz') return alphabet.issubset(set(s.lower()))"},{"question":"def find_longest_subarray_with_equal_ones_zeros(arr): Finds the length of the longest contiguous subarray with equal number of 1's and 0's. >>> find_longest_subarray_with_equal_ones_zeros([1, 0, 1, 1, 0, 1]) 4 >>> find_longest_subarray_with_equal_ones_zeros([1, 1, 1, 1]) 0 >>> find_longest_subarray_with_equal_ones_zeros([0, 0, 1, 1, 0, 1, 0]) 6 pass def process_input(test_cases): Process multiple test cases and return the results for the length of the longest contiguous subarray with equal number of 1's and 0's. pass","solution":"def find_longest_subarray_with_equal_ones_zeros(arr): Finds the length of the longest contiguous subarray with equal number of 1's and 0's. count_map = {} count = 0 max_length = 0 # Initialize the map with count 0 at index -1 to take care of cases where subarray starts from index 0. count_map[0] = -1 for index, num in enumerate(arr): # Increment/decrement the count based on the value of num if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, index - count_map[count]) else: count_map[count] = index return max_length def process_input(test_cases): results = [] for test_case in test_cases: binary_array = list(map(int, test_case.split())) results.append(find_longest_subarray_with_equal_ones_zeros(binary_array)) return results"},{"question":"def is_prime(X: int) -> str: Determine if the given number X is a prime number. Args: X : int : the input number Returns: str : \\"Prime\\" if X is a prime number, otherwise \\"Not Prime\\" >>> is_prime(7) 'Prime' >>> is_prime(10) 'Not Prime'","solution":"def is_prime(X): Determine if the given number X is a prime number. Args: X : int : the input number Returns: str : \\"Prime\\" if X is a prime number, otherwise \\"Not Prime\\" if X <= 1: return \\"Not Prime\\" for i in range(2, int(X**0.5) + 1): if X % i == 0: return \\"Not Prime\\" return \\"Prime\\""},{"question":"def replaceElements(arr): Given an array of integers, replace every element with the greatest element on its right side, and replace the last element with -1. Args: arr (list): List of integers. Returns: list: The modified list with replaced elements. Example: >>> replaceElements([16, 17, 4, 3, 5, 2]) [17, 5, 5, 5, 2, -1] >>> replaceElements([4, 3, 2, 1]) [3, 2, 1, -1] >>> replaceElements([5]) [-1]","solution":"def replaceElements(arr): Replaces each element in the array with the greatest element to its right side and replaces the last element with -1. Args: arr (list): List of integers. Returns: list: The modified list with replaced elements. n = len(arr) if n == 0: return [] max_from_right = -1 # Traverse the array from the end for i in range(n - 1, -1, -1): # Replace current element with the max from the right new_val = max_from_right if arr[i] > max_from_right: max_from_right = arr[i] arr[i] = new_val return arr"},{"question":"def filter_even(numbers): Returns a list of only the even numbers from the given list of integers. Args: numbers (list of int): A list of integers. Returns: list of int: A list of even integers. >>> filter_even([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even([1, 3, 5, 7, 9]) [] >>> filter_even([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> filter_even([]) [] >>> filter_even([0, 1, 2, 3]) [0, 2]","solution":"def filter_even(numbers): Returns a list of only the even numbers from the given list of integers. Args: numbers (list of int): A list of integers. Returns: list of int: A list of even integers. return [num for num in numbers if num % 2 == 0]"},{"question":"def can_be_palindrome_with_one_change(S: str) -> str: Returns \\"YES\\" if the string S can be transformed into a palindrome with at most one change. Otherwise, returns \\"NO\\". >>> can_be_palindrome_with_one_change(\\"ABABA\\") \\"YES\\" >>> can_be_palindrome_with_one_change(\\"AAABB\\") \\"NO\\"","solution":"def can_be_palindrome_with_one_change(S): Returns \\"YES\\" if the string S can be transformed into a palindrome with at most one change. Otherwise, returns \\"NO\\". n = len(S) mismatches = 0 for i in range(n // 2): if S[i] != S[n - i - 1]: mismatches += 1 if mismatches > 1: return \\"NO\\" # If there are 0 or 1 mismatches, it's possible with at most one change return \\"YES\\" if mismatches <= 1 else \\"NO\\""},{"question":"def largest_possible_integer(N: int, K: int, digits: str) -> str: Removes K digits from the digit string to form the largest possible integer. >>> largest_possible_integer(9, 3, '123456789') '456789' >>> largest_possible_integer(5, 2, '54321') '543'","solution":"def largest_possible_integer(N, K, digits): Removes K digits from the digit string to form the largest possible integer. stack = [] for digit in digits: while K > 0 and stack and stack[-1] < digit: stack.pop() K -= 1 stack.append(digit) # If there's remaining k, pop the last k elements if K > 0: stack = stack[:-K] return ''.join(stack) # Example Usage N = 9 K = 3 digits = '123456789' print(largest_possible_integer(N, K, digits)) # Outputs: 456789"},{"question":"def can_partition_books(N: int) -> bool: Determines if a list of books numbered from 1 to N can be split into two parts with equal sum. >>> can_partition_books(4) == True >>> can_partition_books(5) == False >>> can_partition_books(999999996) == True >>> can_partition_books(999999997) == False >>> can_partition_books(1) == False >>> can_partition_books(3) == True >>> can_partition_books(100000000) == True def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): N = int(data[i]) if can_partition_books(N): results.append(\\"YES\\") else: results.append(\\"NO\\") for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def can_partition_books(N): Determines if a list of books numbered from 1 to N can be split into two parts with equal sum. return (N * (N + 1)) % 4 == 0 def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) results = [] for i in range(1, T + 1): N = int(data[i]) if can_partition_books(N): results.append(\\"YES\\") else: results.append(\\"NO\\") for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def transformation_operations(T: int, test_cases: List[Tuple[str, str]]) -> List[int]: Transform the initial sequence into the target sequence using the minimum number of operations. Args: T (int): The number of test cases. test_cases (List[Tuple[str, str]]): List containing tuples of initial and target sequences. Returns: List[int]: Minimum number of operations needed for each test case, or -1 if not possible. Example: >>> transformation_operations(2, [(\\"1 2 3 4\\", \\"4 3 2 1\\"), (\\"1 2 3 4\\", \\"3 4 1 2\\")]) [1, 2]","solution":"from collections import deque def min_operations(initial, target): Returns the minimum number of operations needed to transform the initial sequence into the target sequence, or -1 if it is not possible. initial = tuple(initial) target = tuple(target) if initial == target: return 0 def get_neighbors(seq): n = len(seq) neighbors = [] # Swap any two elements for i in range(n): for j in range(i + 1, n): new_seq = list(seq) new_seq[i], new_seq[j] = new_seq[j], new_seq[i] neighbors.append(tuple(new_seq)) # Reverse any subsequence for i in range(n): for j in range(i + 1, n + 1): new_seq = list(seq) new_seq[i:j] = reversed(new_seq[i:j]) neighbors.append(tuple(new_seq)) # Rotate entire sequence to the right by one position new_seq = deque(seq) new_seq.rotate(1) neighbors.append(tuple(new_seq)) return neighbors visited = set() queue = deque([(initial, 0)]) visited.add(initial) while queue: current, steps = queue.popleft() for neighbor in get_neighbors(current): if neighbor == target: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return -1 def transformation_operations(T, test_cases): results = [] for i in range(T): initial_seq = list(map(int, test_cases[i][0].split())) target_seq = list(map(int, test_cases[i][1].split())) results.append(min_operations(initial_seq, target_seq)) return results"},{"question":"def largest_square_subgrid_with_equal_row_sums(m: int, n: int, grid: List[List[int]]) -> int: Determine the side length of the largest square subgrid where each row within the subgrid has the same sum. >>> largest_square_subgrid_with_equal_row_sums(4, 5, [ ... [1, 2, 3, 4, 5], ... [5, 1, 2, 1, 3], ... [1, 0, 4, -1, 7], ... [3, 2, 1, 5, 1] ... ]) 2 >>> largest_square_subgrid_with_equal_row_sums(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 1 >>> largest_square_subgrid_with_equal_row_sums(2, 2, [ ... [1, 2], ... [3, 4] ... ]) 1 >>> largest_square_subgrid_with_equal_row_sums(1, 1, [ ... [42] ... ]) 1 >>> largest_square_subgrid_with_equal_row_sums(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 3 >>> largest_square_subgrid_with_equal_row_sums(3, 4, [ ... [1, 2, 3, 4], ... [5, 5, 5, 5], ... [5, 5, 5, 5] ... ]) 2","solution":"def largest_square_subgrid_with_equal_row_sums(m, n, grid): def row_sum_matches(grid, top, left, size): row_sum = sum(grid[top][left:left+size]) for r in range(top + 1, top + size): if sum(grid[r][left:left+size]) != row_sum: return False return True max_possible_size = min(m, n) for size in range(max_possible_size, 0, -1): for top in range(m - size + 1): for left in range(n - size + 1): if row_sum_matches(grid, top, left, size): return size return -1 # Example usage: # m, n = 4, 5 # grid = [ # [1, 2, 3, 4, 5], # [5, 1, 2, 1, 3], # [1, 0, 4, -1, 7], # [3, 2, 1, 5, 1] # ] # print(largest_square_subgrid_with_equal_row_sums(m, n, grid)) # Output: 2"},{"question":"from typing import List, Tuple def longest_simple_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the length of the longest simple path in the road network. >>> longest_simple_path(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> longest_simple_path(3, 3, [(1, 2), (2, 3), (1, 3)]) 2 >>> longest_simple_path(2, 1, [(1, 2)]) 1 >>> longest_simple_path(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> longest_simple_path(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 3 >>> longest_simple_path(4, 2, [(1, 2), (3, 4)]) 1","solution":"from collections import defaultdict def longest_simple_path(n, m, edges): def dfs(node, length): nonlocal max_length max_length = max(max_length, length) visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, length + 1) visited[node] = False # Create the adjacency list representation of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_length = 0 for start in range(1, n + 1): visited = [False] * (n + 1) dfs(start, 0) return max_length"},{"question":"from typing import List, Tuple def can_form_consecutive_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if each array in the test cases can be rearranged to form a consecutive sequence. :param t: Number of test cases :param test_cases: A list of tuples where each tuple contains the number of elements and the array of integers for that test case. :return: List of strings \\"YES\\" or \\"NO\\" for each test case. pass # Example Usage: # >>> can_form_consecutive_sequence(3, [(5, [4, 2, 1, 3, 5]), (4, [1, 2, 4, 5]), (3, [8, 7, 9])]) # [\\"YES\\", \\"NO\\", \\"YES\\"] # >>> can_form_consecutive_sequence(2, [(6, [10, 11, 12, 13, 14, 15]), (5, [1, 3, 5, 7, 9])]) # [\\"YES\\", \\"NO\\"] # >>> can_form_consecutive_sequence(1, [(3, [1, 2, 3])]) # [\\"YES\\"] import pytest def test_can_form_consecutive_sequence(): assert can_form_consecutive_sequence(3, [ (5, [4, 2, 1, 3, 5]), (4, [1, 2, 4, 5]), (3, [8, 7, 9]) ]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert can_form_consecutive_sequence(2, [ (6, [10, 11, 12, 13, 14, 15]), (5, [1, 3, 5, 7, 9]) ]) == [\\"YES\\", \\"NO\\"] assert can_form_consecutive_sequence(1, [ (3, [1, 2, 3]) ]) == [\\"YES\\"] assert can_form_consecutive_sequence(1, [ (3, [1, 3, 2]) ]) == [\\"YES\\"] assert can_form_consecutive_sequence(1, [ (3, [1, 1, 2]) ]) == [\\"NO\\"] assert can_form_consecutive_sequence(1, [ (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]) ]) == [\\"NO\\"] assert can_form_consecutive_sequence(1, [ (0, []) ]) == [\\"YES\\"] # An empty array trivially forms a consecutive sequence # Run the unit tests pytest.main()","solution":"def can_form_consecutive_sequence(t, test_cases): Determines if each array in the test cases can be rearranged to form a consecutive sequence. :param t: Number of test cases :param test_cases: A list of tuples where each tuple contains the number of elements and the array of integers for that test case. :return: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for i in range(t): n, array = test_cases[i] sorted_array = sorted(array) is_consecutive = True for j in range(1, n): if sorted_array[j] != sorted_array[j-1] + 1: is_consecutive = False break results.append(\\"YES\\" if is_consecutive else \\"NO\\") return results"},{"question":"def largest1Square(matrix: List[List[int]]) -> int: Determine the size of the largest '1'-square sub-matrix present in the matrix. >>> N = 5 >>> matrix = [ ... [0, 1, 1, 0, 1], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 1, 1, 0, 1] ... ] >>> largest1Square(matrix) 3 >>> N = 4 >>> matrix = [ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0] ... ] >>> largest1Square(matrix) 2 # Your implementation here","solution":"def largest1Square(matrix): if not matrix or not matrix[0]: return 0 N = len(matrix) dp = [[0] * N for _ in range(N)] max_len = 0 for i in range(N): for j in range(N): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_len = max(max_len, dp[i][j]) return max_len"},{"question":"def calculate_average_score(data): Process a list of data to calculate average performance scores for employees. Args: data (list of str): List of input strings where each string contains the employee identification number, number of periods, and the scores for each period. Returns: list of str: Each string contains the employee ID and their average score rounded to one decimal place. from solution import calculate_average_score def test_single_period(): assert calculate_average_score([\\"102 1 75\\"]) == [\\"102 75.0\\"] def test_two_periods(): assert calculate_average_score([\\"103 2 20 40\\"]) == [\\"103 30.0\\"] def test_multiple_periods(): assert calculate_average_score([\\"101 5 10 20 30 40 50\\"]) == [\\"101 30.0\\"] def test_mixed_cases(): data = [\\"101 5 10 20 30 40 50\\", \\"102 1 75\\", \\"103 2 20 40\\"] expected_output = [\\"101 30.0\\", \\"102 75.0\\", \\"103 30.0\\"] assert calculate_average_score(data) == expected_output def test_zero_line_end(): data = [\\"101 5 10 20 30 40 50\\", \\"0\\"] expected_output = [\\"101 30.0\\"] assert calculate_average_score(data[:-1]) == expected_output","solution":"def calculate_average_score(data): Process a list of data to calculate average performance scores for employees. Args: data (list of str): List of input strings where each string contains the employee identification number, number of periods, and the scores for each period. Returns: list of str: Each string contains the employee ID and their average score rounded to one decimal place. results = [] for line in data: parts = line.split() employee_id = int(parts[0]) periods = int(parts[1]) scores = [int(score) for score in parts[2:]] if periods == 1: avg_score = float(scores[0]) elif periods == 2: avg_score = sum(scores) / 2.0 else: sorted_scores = sorted(scores) avg_score = sum(sorted_scores[1:-1]) / (periods - 2) results.append(f\\"{employee_id} {avg_score:.1f}\\") return results"},{"question":"def has_all_unique_characters(s: str) -> bool: Determines if a string has all unique characters. Assumes the string only contains lowercase alphabetic characters. Args: s (str): The input string. Returns: bool: True if all characters in the string are unique, False otherwise. >>> has_all_unique_characters(\\"algorithm\\") True >>> has_all_unique_characters(\\"programming\\") False >>> has_all_unique_characters(\\"a\\") True >>> has_all_unique_characters(\\"\\") True >>> has_all_unique_characters(\\"aaaaa\\") False >>> has_all_unique_characters(\\"abcdefg\\") True >>> has_all_unique_characters(\\"abcdefgha\\") False","solution":"def has_all_unique_characters(s): Determines if a string has all unique characters. Assumes the string only contains lowercase alphabetic characters. Args: s (str): The input string. Returns: bool: True if all characters in the string are unique, False otherwise. for i in range(len(s)): for j in range(i + 1, len(s)): if s[i] == s[j]: return False return True"},{"question":"def max_contiguous_subarray_sum(csv_numbers: str) -> int: Returns the maximum sum of any contiguous subarray within the sequence. >>> max_contiguous_subarray_sum(\\"1,2,-3,4,5\\") 9 >>> max_contiguous_subarray_sum(\\"-2,-3,-1\\") -1 >>> max_contiguous_subarray_sum(\\"4,-1,2,1,-5,4\\") 6","solution":"def max_contiguous_subarray_sum(csv_numbers): Returns the maximum sum of any contiguous subarray within the sequence. Args: csv_numbers (str): A string of comma-separated integers. Returns: int: Maximum sum of any contiguous subarray. # Converting the comma-separated string into a list of integers nums = list(map(int, csv_numbers.split(','))) # Initialization of Kadane's Algorithm max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def min_time_to_complete_tasks(n: int, dependencies: List[Tuple[int, int]]) -> int: Determines the minimum time required to complete all tasks with given dependencies. Args: n : int : number of tasks dependencies : list : list of tuples representing dependencies (a, b) where task a must be completed before task b Returns: int : Minimum time required to complete all tasks or -1 if there is a circular dependency Examples: >>> min_time_to_complete_tasks(4, [(1, 2), (2, 3), (3, 4)]) 4 >>> min_time_to_complete_tasks(6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6)]) 4 >>> min_time_to_complete_tasks(3, [(1, 2), (2, 3), (3, 1)]) -1","solution":"from collections import deque, defaultdict def min_time_to_complete_tasks(n, dependencies): Determines the minimum time required to complete all tasks with given dependencies. Args: n : int : number of tasks dependencies : list : list of tuples representing dependencies (a, b) where task a must be completed before task b Returns: int : Minimum time required to complete all tasks or -1 if there is a circular dependency # Create a graph and in-degree count graph = defaultdict(list) in_degree = [0] * (n + 1) # Build graph and in-degree count for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Initialize queue with tasks having zero in-degree queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) # Initialize completed tasks count and time completed = 0 time = 0 # Process tasks while queue: # Process all tasks at the current level for _ in range(len(queue)): node = queue.popleft() completed += 1 for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Increment time after processing all tasks at the current level time += 1 # Check for circular dependency if completed == n: return time else: return -1"},{"question":"def min_watering_distance(n: int, water_needs: List[int]) -> int: Calculate the minimum total distance Maria needs to walk in order to water all the trees in her garden. >>> min_watering_distance(5, [1, 0, 0, 0, 1]) 4 >>> min_watering_distance(4, [1, 0, 1, 0]) 2 from typing import List def test_example_1(): assert min_watering_distance(5, [1, 0, 0, 0, 1]) == 4 def test_example_2(): assert min_watering_distance(4, [1, 0, 1, 0]) == 2 def test_single_tree(): assert min_watering_distance(1, [1]) == 0 def test_all_trees_need_watering(): assert min_watering_distance(4, [1, 1, 1, 1]) == 3 def test_no_tree_needs_watering(): assert min_watering_distance(3, [0, 0, 0]) == 0 def test_trees_at_intervals(): assert min_watering_distance(7, [1, 0, 0, 1, 0, 0, 1]) == 6","solution":"def min_watering_distance(n, water_needs): indices = [i for i, water in enumerate(water_needs) if water > 0] total_distance = 0 for i in range(1, len(indices)): total_distance += indices[i] - indices[i - 1] return total_distance # Example usage # n = 5 # water_needs = [1, 0, 0, 0, 1] # print(min_watering_distance(n, water_needs)) # Output: 4"},{"question":"def simulate_lift_operations(N, M, commands): Simulates a series of lift commands and returns the final position of the lift. Args: - N (int): Number of floors in the building. - M (int): Number of commands. - commands (list of str): List of commands to execute. Returns: - int: Final position of the lift. Example: >>> simulate_lift_operations(5, 6, [\\"U 2\\", \\"D 1\\", \\"S 4\\", \\"W\\", \\"D 3\\", \\"U 1\\"]) 2 >>> simulate_lift_operations(3, 4, [\\"U 1\\", \\"D 1\\", \\"U 2\\", \\"D 3\\"]) 0","solution":"def simulate_lift_operations(N, M, commands): Simulates a series of lift commands and returns the final position of the lift. Args: - N (int): Number of floors in the building. - M (int): Number of commands. - commands (list of str): List of commands to execute. Returns: - int: Final position of the lift. current_floor = 0 for command in commands: parts = command.split() action = parts[0] if action == \\"U\\": X = int(parts[1]) current_floor = min(current_floor + X, N - 1) elif action == \\"D\\": X = int(parts[1]) current_floor = max(current_floor - X, 0) elif action == \\"S\\": X = int(parts[1]) current_floor = min(max(X, 0), N - 1) elif action == \\"W\\": continue return current_floor"},{"question":"def find_new_player_rank(scores, new_score): Returns the rank of the new player's score among the given scores. >>> find_new_player_rank([100, 200, 150, 120, 180], 130) 4 >>> find_new_player_rank([100, 200, 150, 120, 180], 90) 6 >>> find_new_player_rank([100, 200, 150, 120, 180], 210) 1 >>> find_new_player_rank([50, 60, 70, 80, 90], 75) 3 >>> find_new_player_rank([60, 70, 80, 90], 10) 5 >>> find_new_player_rank([100], 50) 2 >>> find_new_player_rank([100], 150) 1 def main(): n = int(input().strip()) scores = list(map(int, input().strip().split())) new_score = int(input().strip()) print(find_new_player_rank(scores, new_score)) if __name__ == \\"__main__\\": main()","solution":"def find_new_player_rank(scores, new_score): Returns the rank of the new player's score among the given scores. scores.append(new_score) scores.sort(reverse=True) return scores.index(new_score) + 1 def main(): n = int(input().strip()) scores = list(map(int, input().strip().split())) new_score = int(input().strip()) print(find_new_player_rank(scores, new_score)) if __name__ == \\"__main__\\": main()"},{"question":"def min_tables(n: int, minGuests: int, maxGuests: int, guests: List[str]) -> int: Given the total number of guests 'n', the minimum number of guests per table 'minGuests', and the maximum number of guests per table 'maxGuests', determine the minimum number of tables required to seat all guests. Args: n (int): The total number of guests. minGuests (int): The minimum number of guests per table. maxGuests (int): The maximum number of guests per table. guests (List[str]): A list of guest names. Returns: int: The minimum number of tables required. Examples: >>> min_tables(10, 2, 5, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\", \\"Grace\\", \\"Heidi\\", \\"Ivan\\", \\"Judy\\"]) 2 >>> min_tables(7, 3, 4, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\", \\"Grace\\"]) 2 >>> min_tables(8, 1, 8, [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\", \\"Grace\\", \\"Heidi\\"]) 1","solution":"def min_tables(n, minGuests, maxGuests, guests): This function takes the total number of guests 'n', the minimum number of guests per table 'minGuests', the maximum number of guests per table 'maxGuests', and a list of guest names 'guests', and returns the minimum number of tables required to seat all guests. # Initialize the result count for the number of tables. tables = 0 # Start arranging the tables by initially allocating maxGuests to each table while n > 0: # Decrease the number of guests by the maximum number each table can hold n -= maxGuests # Count this as a table used tables += 1 return tables"},{"question":"def remove_duplicates_and_sort(n, numbers): Given a list of integers, remove duplicates and return the list of unique numbers sorted in non-descending order. :param n: Number of elements in the list :param numbers: List of integers containing n numbers :return: List of unique numbers sorted in non-descending order Examples: >>> remove_duplicates_and_sort(5, [4, 5, 6, 6, 4]) [4, 5, 6] >>> remove_duplicates_and_sort(7, [10, 20, 20, 10, 30, 40, 50]) [10, 20, 30, 40, 50] pass def format_output(numbers): Format the list of numbers into a space-separated string :param numbers: List of integers :return: String of space-separated integers Example: >>> format_output([4, 5, 6]) \\"4 5 6\\" pass","solution":"def remove_duplicates_and_sort(n, numbers): Given a list of integers, remove duplicates and return the list of unique numbers sorted in non-descending order. :param n: Number of elements in the list :param numbers: List of integers containing n numbers :return: List of unique numbers sorted in non-descending order unique_numbers = list(set(numbers)) unique_numbers.sort() return unique_numbers def format_output(numbers): Format the list of numbers into a space-separated string :param numbers: List of integers :return: String of space-separated integers return ' '.join(map(str, numbers))"},{"question":"def longest_palindrome_with_leftovers(s: str, n: int) -> int: Determine the length of the longest palindrome that can be created using the given characters and an additional number of leftover characters. Parameters: s (str): A string with each character occurring exactly twice (1 ≤ |s| ≤ 200). n (int): The number of leftover characters allowed (0 ≤ n ≤ 100). Returns: int: The length of the longest possible palindrome. >>> longest_palindrome_with_leftovers(\\"aabbcc\\", 3) 9 >>> longest_palindrome_with_leftovers(\\"aabbcc\\", 0) 6 >>> longest_palindrome_with_leftovers(\\"aaa\\", 1) 4 >>> longest_palindrome_with_leftovers(\\"abcabc\\", 0) 6 >>> longest_palindrome_with_leftovers(\\"aabbcc\\", 100) 106","solution":"def longest_palindrome_with_leftovers(s, n): Determine the length of the longest palindrome that can be created with the given characters and an additional number of leftover characters. Parameters: s (str): A string with each character occurring exactly twice. n (int): The number of leftover characters allowed. Returns: int: The length of the longest possible palindrome. # Finding unique characters in the string unique_chars = set(s) # Length of the palindrome that can be created initially palindrome_length_without_leftovers = len(s) # Account for the use of leftover characters to extend the palindrome length max_length_with_leftovers = palindrome_length_without_leftovers + n return max_length_with_leftovers"},{"question":"def smallest_playlist_duration(N: int, M: int, songs: List[Tuple[str, int]], K: int, operations: List[Tuple[str, str, int]]) -> int: Determine the smallest possible duration of Alice's playlist that meets or exceeds M minutes. Args: N (int): Number of different songs. M (int): Minimum required duration of the playlist. songs (List[Tuple[str, int]]): List of songs, each represented by a tuple with title and duration. K (int): Number of operations available to merge songs. operations (List[Tuple[str, str, int]]): List of operations to merge songs, each represented by a tuple with two song titles and the new duration. Returns: int: The smallest possible duration of the playlist that is at least M minutes, or -1 if it's impossible. >>> smallest_playlist_duration(3, 10, [(\\"hiphop\\", 3), (\\"rap\\", 2), (\\"blues\\", 1)], 1, [(\\"hiphop\\", \\"rap\\", 4)]) -1 >>> smallest_playlist_duration(4, 15, [(\\"rock\\", 4), (\\"jazz\\", 5), (\\"pop\\", 6), (\\"classic\\", 7)], 2, [(\\"rock\\", \\"jazz\\", 9), (\\"pop\\", \\"classic\\", 12)]) 15 from typing import List, Tuple # You can add code here for preprocessing, or utility functions","solution":"def smallest_playlist_duration(N, M, songs, K, operations): from itertools import combinations def merge_songs(existing_songs, op_a, op_b, new_duration): new_songs = existing_songs.copy() if op_a in new_songs and op_b in new_songs: new_songs[op_a] = new_duration del new_songs[op_b] return new_songs song_dict = {title: duration for title, duration in songs} initial_durations = list(song_dict.values()) if sum(initial_durations) < M: return -1 viable_durations = [] for r in range(1, N + 1): for combination in combinations(initial_durations, r): if sum(combination) >= M: viable_durations.append(sum(combination)) for op_a, op_b, new_duration in operations: merged_dict = merge_songs(song_dict, op_a, op_b, new_duration) merged_durations = list(merged_dict.values()) for r in range(1, len(merged_durations) + 1): for combination in combinations(merged_durations, r): if sum(combination) >= M: viable_durations.append(sum(combination)) if viable_durations: return min(viable_durations) else: return -1 N, M = 3, 10 songs = [(\\"hiphop\\", 3), (\\"rap\\", 2), (\\"blues\\", 1)] K = 1 operations = [(\\"hiphop\\", \\"rap\\", 4)] print(smallest_playlist_duration(N, M, songs, K, operations)) # -1 N, M = 4, 15 songs = [(\\"rock\\", 4), (\\"jazz\\", 5), (\\"pop\\", 6), (\\"classic\\", 7)] K = 2 operations = [(\\"rock\\", \\"jazz\\", 9), (\\"pop\\", \\"classic\\", 12)] print(smallest_playlist_duration(N, M, songs, K, operations)) # 15"},{"question":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string \`s\`. A word is defined as a maximal substring consisting of non-space characters only. >>> length_of_last_word(\\"Hello World\\") 5 >>> length_of_last_word(\\" fly me to the moon \\") 4 >>> length_of_last_word(\\"luffy is still joyboy\\") 6 >>> length_of_last_word(\\"luffy\\") 5 >>> length_of_last_word(\\" \\") 0 >>> length_of_last_word(\\"a\\") 1 >>> length_of_last_word(\\"a \\") 1 >>> length_of_last_word(\\"word another word\\") 4 >>> length_of_last_word(\\"lastword\\") 8 >>> length_of_last_word(\\" word \\") 4 >>> length_of_last_word(\\"\\") 0","solution":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string \`s\`. A word is defined as a maximal substring consisting of non-space characters only. # Strip trailing spaces and split the string into words words = s.strip().split() # Return the length of the last word return len(words[-1]) if words else 0"},{"question":"def longest_subsequence(n: int, d: int, arr: List[int]) -> int: Returns the length of the longest subsequence where the difference between consecutive elements is equal to d. >>> longest_subsequence(6, 2, [1, 3, 5, 8, 6, 4]) 3 >>> longest_subsequence(5, -1, [4, 3, 2, 1, 0]) 5 def solve(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Solves multiple test cases of the longest subsequence problem. >>> T = 2 >>> test_cases = [ ... {'n': 6, 'd': 2, 'arr': [1, 3, 5, 8, 6, 4]}, ... {'n': 5, 'd': -1, 'arr': [4, 3, 2, 1, 0]} ... ] >>> solve(T, test_cases) [3, 5]","solution":"def longest_subsequence(n, d, arr): Returns the length of the longest subsequence where the difference between consecutive elements is equal to d. length = {} max_length = 1 for num in arr: if num - d in length: length[num] = length[num - d] + 1 else: length[num] = 1 max_length = max(max_length, length[num]) return max_length def solve(T, test_cases): results = [] for i in range(T): n, d = test_cases[i]['n'], test_cases[i]['d'] arr = test_cases[i]['arr'] results.append(longest_subsequence(n, d, arr)) return results"},{"question":"def max_difference(n: int, elements: List[int]) -> int: This function takes in an integer \`n\` and a list of \`n\` integers, and returns the maximum difference between any two elements in the list. >>> max_difference(5, [1, 9, 3, 4, 5]) 8 >>> max_difference(3, [10, 20, 15]) 10 >>> max_difference(1, [100]) 0 >>> max_difference(2, [2, 2]) 0 >>> max_difference(2, [1, 1000]) 999 >>> max_difference(4, [7, 7, 7, 7]) 0 >>> max_difference(5, [5, 4, 3, 2, 1]) 4 # Your code goes here","solution":"def max_difference(n, elements): This function takes in an integer \`n\` and a list of \`n\` integers, and returns the maximum difference between any two elements in the list. if n <= 1: return 0 min_element = min(elements) max_element = max(elements) return max_element - min_element"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Given a grid of size n x m consisting of non-negative integers, find the maximum sum from the top-left corner to the bottom-right corner of the grid, moving only right or down at each step. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_path_sum([ ... [1, 2, 3, 4, 5] ... ]) 15 >>> max_path_sum([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_path_sum([ ... [10] ... ]) 10 >>> max_path_sum([ ... [1, 3, 1, 1], ... [1, 5, 1, 1], ... [4, 2, 1, 2] ... ]) 14 >>> max_path_sum([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"def max_path_sum(grid): Given a grid of size n x m consisting of non-negative integers, find the maximum sum from the top-left corner to the bottom-right corner of the grid, moving only right or down at each step. n = len(grid) m = len(grid[0]) # Create a 2D DP array to store the maximum sum up to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the rest of the DP array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] # Example input grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_path_sum(grid)) # should print 29"},{"question":"from typing import List, Tuple def max_crops_in_line(grid: List[str]) -> int: Find the maximum number of crops that can be collected in a single straight line in the given grid. >>> max_crops_in_line([\\"CECE\\", \\"CCEC\\", \\"EECC\\", \\"ECCE\\"]) == 3 >>> max_crops_in_line([\\"EEC\\", \\"CCE\\", \\"ECE\\"]) == 2 >>> max_crops_in_line([\\"CCC\\", \\"CCC\\", \\"CCC\\"]) == 3 >>> max_crops_in_line([\\"EEE\\", \\"EEE\\", \\"EEE\\"]) == 0 >>> max_crops_in_line([\\"C\\"]) == 1 pass # Implement this function def max_crops_collected(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Find the maximum number of crops that can be collected in a single straight line for multiple test cases. >>> t = 2 >>> test_cases = [(4, [\\"CECE\\", \\"CCEC\\", \\"EECC\\", \\"ECCE\\"]), (3, [\\"EEC\\", \\"CCE\\", \\"ECE\\"])] >>> max_crops_collected(t, test_cases) == [3, 2] >>> t = 1 >>> test_cases = [(1, [\\"C\\"])] >>> max_crops_collected(t, test_cases) == [1] >>> t = 3 >>> test_cases = [(4, [\\"CCCC\\", \\"EEEE\\", \\"CCCC\\", \\"EEEE\\"]), (4, [\\"CCCC\\", \\"CCCC\\", \\"CCCC\\", \\"CCCC\\"]), (4, [\\"CCCC\\", \\"ECCC\\", \\"EECC\\", \\"EEECC\\"])] >>> max_crops_collected(t, test_cases) == [4, 4, 4] pass # Implement this function","solution":"def max_crops_in_line(grid): n = len(grid) max_crops = 0 # check rows and columns for i in range(n): row_count = 0 col_count = 0 for j in range(n): if grid[i][j] == 'C': row_count += 1 max_crops = max(max_crops, row_count) else: row_count = 0 if grid[j][i] == 'C': col_count += 1 max_crops = max(max_crops, col_count) else: col_count = 0 # check diagonals for d in range(-n + 1, n): main_diag_count = 0 anti_diag_count = 0 for i in range(n): if 0 <= i + d < n: if grid[i][i + d] == 'C': main_diag_count += 1 max_crops = max(max_crops, main_diag_count) else: main_diag_count = 0 if grid[i][n - 1 - (i + d)] == 'C': anti_diag_count += 1 max_crops = max(max_crops, anti_diag_count) else: anti_diag_count = 0 return max_crops def max_crops_collected(t, test_cases): results = [] for i in range(t): n, grid = test_cases[i] result = max_crops_in_line(grid) results.append(result) return results"},{"question":"def is_composite(x: int) -> bool: Determine if x is a composite number. >>> is_composite(4) True >>> is_composite(6) True >>> is_composite(7) False pass def longest_composite_subarray(arr: List[int]) -> int: Find the length of the longest contiguous subarray consisting of only composite numbers. >>> longest_composite_subarray([4, 6, 8, 7, 9, 10]) 3 >>> longest_composite_subarray([17, 19, 23, 29, 31]) 0 >>> longest_composite_subarray([6, 10, 15, 21, 14, 22, 33, 35]) 8 pass","solution":"def is_composite(x): Determine if x is a composite number. if x <= 1: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return True return False def longest_composite_subarray(arr): Find the length of the longest contiguous subarray consisting of only composite numbers. max_length = 0 current_length = 0 for num in arr: if is_composite(num): current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length # Example usage # print(longest_composite_subarray([4, 6, 8, 7, 9, 10])) # Output: 3 # print(longest_composite_subarray([17, 19, 23, 29, 31])) # Output: 0 # print(longest_composite_subarray([6, 10, 15, 21, 14, 22, 33, 35])) # Output: 8"},{"question":"from typing import List, Tuple def is_resilient(n: int, edges: List[Tuple[int, int, int]]) -> str: Determine if the network of highways remains connected after removing any single road. Args: n: The number of cities. edges: A list of tuples, where each tuple represents a highway with three integers: the first city \`u\`, the second city \`v\`, and the weight \`w\` of the highway. Returns: A string \\"The highway system is resilient.\\" if the network remains connected upon the removal of any single highway. Otherwise, return \\"The highway system is vulnerable.\\" Examples: >>> is_resilient(5, [(0, 1, 10), (0, 2, 20), (1, 2, 30), (2, 3, 40), (3, 4, 50), (2, 4, 60)]) \\"The highway system is resilient.\\" >>> is_resilient(4, [(0, 1, 10), (1, 2, 20), (2, 3, 30)]) \\"The highway system is vulnerable.\\"","solution":"from collections import defaultdict def is_connected(graph, n): visited = [False] * n stack = [0] count = 0 visited[0] = True while stack: node = stack.pop() count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) return count == n def is_resilient(n, edges): for u, v, w in edges: graph = defaultdict(list) for x, y, z in edges: if (x, y, z) != (u, v, w): graph[x].append(y) graph[y].append(x) if not is_connected(graph, n): return \\"The highway system is vulnerable.\\" return \\"The highway system is resilient.\\" # Example to ease unit test development def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] for i in range(m): u = int(data[2 + 3 * i]) - 1 # Adjust city index to zero-based v = int(data[3 + 3 * i]) - 1 # Adjust city index to zero-based w = int(data[4 + 3 * i]) edges.append((u, v, w)) print(is_resilient(n, edges)) # Uncomment the following lines to run the program with a sample input # if __name__ == \\"__main__\\": # main()"},{"question":"def min_operations_to_zero(grid): Returns the minimum number of operations needed to make all the digits in the grid equal to 0. pass # Test cases if __name__ == \\"__main__\\": grid = [ \\"123\\", \\"456\\", \\"789\\" ] assert min_operations_to_zero(grid) == 9 grid = [ \\"111\\", \\"111\\", \\"111\\" ] assert min_operations_to_zero(grid) == 1 grid = [ \\"984\\", \\"635\\", \\"772\\" ] assert min_operations_to_zero(grid) == 9 grid = [ \\"1234\\", \\"5678\\", \\"4321\\" ] assert min_operations_to_zero(grid) == 8 grid = [ \\"1\\" ] assert min_operations_to_zero(grid) == 1 grid = [ \\"99\\", \\"99\\" ] assert min_operations_to_zero(grid) == 9","solution":"def min_operations_to_zero(grid): Returns the minimum number of operations needed to make all the digits in the grid equal to 0. max_digit = 0 for row in grid: for digit in row: max_digit = max(max_digit, int(digit)) return max_digit # Inputs for testing purpose if __name__ == \\"__main__\\": N, M = map(int, input().split()) grid = [input().strip() for _ in range(N)] print(min_operations_to_zero(grid))"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects if a linked list has a cycle. >>> nodes = ListNode(3, ListNode(7, ListNode(8, ListNode(10)))) >>> nodes.next.next.next.next = nodes.next >>> detect_cycle(nodes) \\"Cycle Detected\\" >>> nodes = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> detect_cycle(nodes) \\"No Cycle\\" >>> nodes = ListNode(5, ListNode(10, ListNode(20))) >>> nodes.next.next.next = nodes >>> detect_cycle(nodes) \\"Cycle Detected\\" >>> detect_cycle(None) \\"No Cycle\\"","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head): Detects if a linked list has a cycle. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return \\"Cycle Detected\\" return \\"No Cycle\\""},{"question":"def smallestNumWithProduct(m: int) -> int: Write a function that takes a positive integer \`m\` and returns the smallest number whose digits multiply to \`m\`. If no such number exists, the function should return -1. Example 1: >>> smallestNumWithProduct(36) 49 Example 2: >>> smallestNumWithProduct(19) -1 Args: m : int : a positive integer Returns: int : the smallest number whose digits multiply to \`m\`, or -1 if no such number exists def test_smallestNumWithProduct_factorable(): assert smallestNumWithProduct(36) == 49 # 4 * 9 = 36 assert smallestNumWithProduct(100) == 455 # 4 * 5 * 5 = 100 assert smallestNumWithProduct(72) == 89 # 8 * 9 = 72 assert smallestNumWithProduct(1) == 1 # 1 * 1 = 1 def test_smallestNumWithProduct_prime(): assert smallestNumWithProduct(19) == -1 # No single digits product = 19 assert smallestNumWithProduct(13) == -1 # No single digits product = 13 def test_smallestNumWithProduct_non_factorable(): assert smallestNumWithProduct(11) == -1 # No single digits product = 11 assert smallestNumWithProduct(17) == -1 # No single digits product = 17 def test_smallestNumWithProduct_small_numbers(): assert smallestNumWithProduct(9) == 9 # 9 assert smallestNumWithProduct(6) == 6 # 6 assert smallestNumWithProduct(7) == 7 # 7 def test_smallestNumWithProduct_large_number(): assert smallestNumWithProduct(64) == 88 # 8 * 8 = 64","solution":"def smallestNumWithProduct(m): if m == 1: return 1 # 1 is the smallest number that multiplies to 1 # Find factors for numbers between 2 and 9 factors = [] for i in range(9, 1, -1): while m % i == 0: factors.append(i) m //= i if m > 1: return -1 # If m is still greater than 1, it means it had a prime factor > 9 # Convert the factors into a number factors.sort() smallest_number = int(''.join(map(str, factors))) return smallest_number"},{"question":"def check_schedules(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: A company is evaluating a new scheduling system for its employees. The system operates based on a string of characters where each character can represent one of three statuses: - 'A' for available, - 'U' for unavailable, and - 'M' for meeting. Each day is represented by a string of length 24, with each character representing the status for one hour in the 24-hour period. As part of the system evaluation, the company wants to ensure that employees have a required amount of available time for meetings each day. Specifically, each employee should have at least \`k\` contiguous available hours ('A') within any given day. >>> check_schedules(4, [(3, \\"AAAAAAAAAAAAAAAAAAAAAAAA\\"), (5, \\"UUUUUMMMMMMUUUUUMMMMMMAAA\\"), (2, \\"UUUUUMMMMMMUUAAAAUUMMMMMM\\"), (4, \\"AAAAAUMMMMMUMMMMMUMMMMMMM\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def check_schedules(t, test_cases): results = [] for i in range(t): k, schedule = test_cases[i] target = 'A' * k if target in schedule: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple, Union from collections import defaultdict, deque def find_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine the order of module completion based on dependencies. Args: n (int): Total number of modules. m (int): Number of dependencies. dependencies (List[Tuple[int, int]]): List of tuples where each tuple (a, b) means module \`a\` must be completed before module \`b\`. Returns: Union[List[int], str]: A valid order of modules or \\"IMPOSSIBLE\\" if no valid order exists. >>> find_order(4, 4, [(1, 2), (1, 3), (3, 4), (2, 4)]) [1, 3, 2, 4] >>> find_order(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" >>> find_order(3, 0, []) [1, 2, 3] >>> find_order(1, 0, []) [1] >>> find_order(6, 6, [(1, 2), (1, 3), (3, 4), (2, 4), (4, 5), (5, 6)]) [1, 2, 3, 4, 5, 6]","solution":"from collections import defaultdict, deque def find_order(n, m, dependencies): graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 queue = deque() for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) order = [] while queue: module = queue.popleft() order.append(module) for neighbor in graph[module]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return \\"IMPOSSIBLE\\""},{"question":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array without using any additional data structures. Example: >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([1, 3], [2, 4, 6, 8]) [1, 2, 3, 4, 6, 8] >>> merge_sorted_arrays([], [2, 4, 6, 8]) [2, 4, 6, 8] >>> merge_sorted_arrays([1, 3, 5, 7], []) [1, 3, 5, 7] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([], []) []","solution":"def merge_sorted_arrays(arr1, arr2): Merge two sorted arrays into one sorted array without using any additional data structures. i, j = 0, 0 merged_array = [] # Traverse both arrays and append smaller element to merged_array while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements of arr1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements of arr2 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def most_frequent_char(s: str) -> str: Return the most frequent character in the string s. If there is a tie, return the lexicographically smallest character. >>> most_frequent_char(\\"aabbbcc\\") 'b' >>> most_frequent_char(\\"xyzzyxx\\") 'x' >>> most_frequent_char(\\"abcdabcdabcd\\") 'a' >>> most_frequent_char(\\"uuvvwuuw\\") 'u' >>> most_frequent_char(\\"a\\") 'a'","solution":"def most_frequent_char(s): Returns the most frequent character in the string s. If there is a tie, returns the lexicographically smallest character. if not s: return None char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 max_char = None max_count = 0 for char, count in char_count.items(): if count > max_count or (count == max_count and (max_char is None or char < max_char)): max_count = count max_char = char return max_char"},{"question":"def find_shelf_and_position(Q: int, queries: List[int]) -> List[str]: Find the position and the shelf ID of any given book in the library. >>> find_shelf_and_position(3, [1, 15, 25]) [\\"1-1\\", \\"2-5\\", \\"3-5\\"] >>> find_shelf_and_position(4, [10, 11, 100, 101]) [\\"1-10\\", \\"2-1\\", \\"10-10\\", \\"11-1\\"]","solution":"def find_shelf_and_position(Q, queries): results = [] for B in queries: shelf_id = (B - 1) // 10 + 1 position = (B - 1) % 10 + 1 results.append(f\\"{shelf_id}-{position}\\") return results"},{"question":"def can_reach_destination(n: int, k: int, obstacles: List[Tuple[int, int]]) -> str: Determines whether it is possible for the drone to reach (n, n) from (1, 1) without hitting any obstacle >>> can_reach_destination(4, 3, [(2, 2), (3, 3), (4, 2)]) \\"YES\\" >>> can_reach_destination(3, 3, [(2, 1), (2, 2), (2, 3)]) \\"NO\\" >>> can_reach_destination(3, 1, [(3, 2)]) \\"YES\\"","solution":"def can_reach_destination(n, k, obstacles): from collections import deque # Initialize the grid grid = [[True] * n for _ in range(n)] for x, y in obstacles: grid[x - 1][y - 1] = False # BFS to find path from (1,1) to (n,n) directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) visited = set([(0, 0)]) while queue: x, y = queue.popleft() if (x, y) == (n - 1, n - 1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\" # Example Usage # n = 3, k = 3 # obstacles = [(2, 1), (2, 2), (2, 3)] # print(can_reach_destination(n, k, obstacles)) # Should return \\"NO\\""},{"question":"def calculate_speeds(T: int, test_cases: List[Tuple[int, List[float], int, List[float]]]) -> List[List[float]]: Calculates the speeds of objects when they hit the ground for given gravitational forces and times. Args: T : int : Number of test cases. test_cases : List[Tuple[int, List[float], int, List[float]]] : List of test cases, where each test consists of (G, gravities, H, times). Returns: List[List[float]] : List of lists with the speeds for each test case. >>> T = 2 >>> test_cases = [ >>> (2, [9.8, 3.7], 100, [4.5, 8.2]), >>> (3, [9.8, 3.7, 1.6], 50, [3.2, 6.1, 8.9]), >>> ] >>> calculate_speeds(T, test_cases) [[44.1, 30.34], [31.36, 22.57, 14.24]] >>> T = 1 >>> test_cases = [ >>> (1, [1.0], 1, [1.0]) >>> ] >>> calculate_speeds(T, test_cases) [[1.0]]","solution":"def calculate_speeds(T, test_cases): Calculates the speeds of objects when they hit the ground for given gravitational forces and times. Args: T : int : Number of test cases. test_cases : list : List of test cases, where each test consists of (G, gravities, H, times). Returns: list : List of lists with the speeds for each test case. results = [] for case in test_cases: G, gravities, H, times = case speeds = [round(g * t, 2) for g, t in zip(gravities, times)] results.append(speeds) return results"},{"question":"def is_mountain_sequence(array): Determines if the given array forms a mountain sequence. >>> is_mountain_sequence([2, 5, 7, 3, 1]) True >>> is_mountain_sequence([1, 2, 3, 4, 5]) False >>> is_mountain_sequence([0, 3, 2, 1, 2, 1]) False >>> is_mountain_sequence([0, 1, 0]) True","solution":"def is_mountain_sequence(array): Determines if the given array forms a mountain sequence. n = len(array) if n < 3: return False # Find the peak at index i i = 0 while i + 1 < n and array[i] < array[i + 1]: i += 1 # Check if there's no peak or peak is at the start or end if i == 0 or i == n - 1: return False # Check if descending part is valid while i + 1 < n and array[i] > array[i + 1]: i += 1 return i == n - 1"},{"question":"def sanitize_message(message: str) -> str: Sanitize user input by removing disallowed characters. Allowed characters: a-z, A-Z, 0-9, space (' '), and punctuation marks (.,!?) >>> sanitize_message(\\"Hello, World! How's everything going @ your side?\\") \\"Hello, World! Hows everything going your side\\" >>> sanitize_message(\\"Hi there #@&*!, Welcome.\\") \\"Hi there !, Welcome.\\" >>> sanitize_message(\\"Testing 1, 2, 3... Done!\\") \\"Testing 1, 2, 3... Done!\\"","solution":"def sanitize_message(message: str) -> str: allowed_chars = set(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?\\") sanitized_message = ''.join(char for char in message if char in allowed_chars) return sanitized_message"},{"question":"def final_position(n: int, commands: str) -> tuple[int, int]: Determine the robot's final coordinates after executing the sequence of commands. >>> final_position(5, 'UUDLR') (0, 1) >>> final_position(10, 'UUUDDDLLRR') (0, 0) >>> final_position(3, 'RRD') (2, -1)","solution":"def final_position(n, commands): x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y"},{"question":"class RangeManipulation: def __init__(self, array: List[int]): Initialize the RangeManipulation object with the initial array pass def update(self, l: int, r: int, x: int): Add a given integer x to every element in the list from index l to index r (inclusive). pass def query(self, l: int, r: int) -> int: Compute and return the sum of the elements from index l to index r (inclusive). pass def process_operations(n: int, q: int, array: List[int], operations: List[str]) -> List[int]: Process a list of update and query operations on an array of integers. Args: n (int): The size of the array. q (int): The number of operations. array (List[int]): The initial list of integers. operations (List[str]): The list of operations. Returns: List[int]: The results of the query operations. >>> process_operations(5, 3, [1, 2, 3, 4, 5], [\\"1 1 3 2\\", \\"2 2 5\\", \\"2 1 4\\"]) [18, 16] pass","solution":"class RangeManipulation: def __init__(self, array): self.array = array self.n = len(array) def update(self, l, r, x): for i in range(l - 1, r): self.array[i] += x def query(self, l, r): return sum(self.array[l - 1:r]) def process_operations(n, q, array, operations): rm = RangeManipulation(array) results = [] for operation in operations: op = operation.split() if op[0] == '1': _, l, r, x = map(int, op) rm.update(l, r, x) elif op[0] == '2': _, l, r = map(int, op) results.append(rm.query(l, r)) return results"},{"question":"def longest_substring_two_distinct(s: str) -> str: Given a string of text, find the longest substring which contains at most two distinct characters. >>> longest_substring_two_distinct(\\"abbcccdddaaa\\") \\"cccddd\\" >>> longest_substring_two_distinct(\\"a\\") \\"a\\" >>> longest_substring_two_distinct(\\"aa\\") \\"aa\\" >>> longest_substring_two_distinct(\\"ab\\") \\"ab\\" >>> longest_substring_two_distinct(\\"abababacccc\\") in [\\"abababa\\", \\"bab\\", \\"ccc\\"] >>> longest_substring_two_distinct(\\"aaaaaaaaaa\\") \\"aaaaaaaaaa\\" >>> longest_substring_two_distinct(\\"ababababab\\") \\"ababababab\\" >>> longest_substring_two_distinct(\\"\\") \\"\\"","solution":"def longest_substring_two_distinct(s): Returns the longest substring which contains at most two distinct characters. if len(s) == 0: return \\"\\" start, max_len, max_substr = 0, 0, \\"\\" char_count = {} for end in range(len(s)): if s[end] in char_count: char_count[s[end]] += 1 else: char_count[s[end]] = 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:end + 1] return max_substr"},{"question":"def checkPairSum(array: List[int], target: int) -> bool: Determines if there are two distinct integers in the array that add up to the target. Parameters: array (list of int): The list of integers. target (int): The target sum to check for. Returns: bool: True if such a pair exists, False otherwise. >>> checkPairSum([2, 7, 11, 15], 9) True >>> checkPairSum([1, 2, 3, 4], 8) False","solution":"def checkPairSum(array, target): Determines if there are two distinct integers in the array that add up to the target. Parameters: array (list of int): The list of integers. target (int): The target sum to check for. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in array: if target - num in seen: return True seen.add(num) return False"},{"question":"def max_sum_subarray(arr, K): Create a function that takes a list of integers and an integer K, and returns the maximum sum of a subarray with exactly K elements. If the list has fewer than K elements, return None. The subarray should be contiguous and the function needs to be efficient in terms of time complexity. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 4) == 11 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 7) == None >>> max_sum_subarray([1, 2, 3, 4, 5], 2) == 9 >>> max_sum_subarray([], 1) == None >>> max_sum_subarray([1], 1) == 1 >>> max_sum_subarray([-1, -2, -3, -4, -5], 3) == -6 >>> max_sum_subarray([5, 5, 5, 5, 5], 5) == 25","solution":"def max_sum_subarray(arr, K): Returns the maximum sum of a subarray with exactly K elements. If the list has fewer than K elements, return None. n = len(arr) if n < K: return None # Compute the sum of the first window of size K max_sum = current_sum = sum(arr[:K]) # Slide the window from start + 1 to end for i in range(K, n): current_sum += arr[i] - arr[i - K] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_fit(photo_size, frame_size): Determines if a photo can fit inside a frame without any part being cropped. :param tuple photo_size: A tuple (photo_width, photo_height) representing the dimensions of the photo. :param tuple frame_size: A tuple (frame_width, frame_height) representing the dimensions of the frame. :return: True if the photo can fit inside the frame, False otherwise. >>> can_fit((16, 20), (20, 25)) True >>> can_fit((25, 30), (20, 25)) False # Example usage: # should return True print(can_fit((16, 20), (20, 25))) # should return False print(can_fit((25, 30), (20, 25)))","solution":"def can_fit(photo_size, frame_size): Determines if a photo can fit inside a frame without any part being cropped. :param tuple photo_size: A tuple (photo_width, photo_height) representing the dimensions of the photo. :param tuple frame_size: A tuple (frame_width, frame_height) representing the dimensions of the frame. :return: True if the photo can fit inside the frame, False otherwise. photo_width, photo_height = photo_size frame_width, frame_height = frame_size return photo_width <= frame_width and photo_height <= frame_height # Example usage: # should return True print(can_fit((16, 20), (20, 25))) # should return False print(can_fit((25, 30), (20, 25)))"},{"question":"from typing import List def digit_root(n: int) -> int: Calculate the digit root of a number. >>> digit_root(56) 2 >>> digit_root(1234) 1 pass def is_digit_root_palindrome(number: int) -> bool: Determine if the digit root of a number is a palindrome. >>> is_digit_root_palindrome(56) True >>> is_digit_root_palindrome(1234) True pass def process_input(numbers: List[int]) -> List[str]: Process a list of numbers and return a list of \\"Yes\\" or \\"No\\" for each number based on whether it is a digit root palindrome or not. >>> process_input([56, 1234, 98765, 1010101, 0]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> process_input([34567, 89, 1234567890, 1000, 0]) [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"Yes\\"] pass","solution":"def digit_root(n): Calculate the digit root of a number. while n >= 10: n = sum(int(digit) for digit in str(n)) return n def is_digit_root_palindrome(number): Determine if the digit root of a number is a palindrome. root = digit_root(number) return str(root) == str(root)[::-1] def process_input(numbers): Process a list of numbers and return a list of \\"Yes\\" or \\"No\\" for each number based on whether it is a digit root palindrome or not. results = [] for number in numbers: if number == 0: break results.append(\\"Yes\\" if is_digit_root_palindrome(number) else \\"No\\") return results"},{"question":"def min_removals_to_avoid_consecutive_chars(S: str) -> int: Returns the minimum number of characters that need to be removed to ensure that no two identical consecutive characters remain in the string S. >>> min_removals_to_avoid_consecutive_chars(\\"abbab\\") 1 >>> min_removals_to_avoid_consecutive_chars(\\"aabb\\") 2 >>> min_removals_to_avoid_consecutive_chars(\\"abcde\\") 0 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: For each test case, returns the minimum number of characters that need to be removed to ensure that no two identical consecutive characters remain in the string S. >>> process_test_cases(3, [\\"abbab\\", \\"aabb\\", \\"abcde\\"]) [1, 2, 0] >>> process_test_cases(2, [\\"aaaa\\", \\"abacadae\\"]) [3, 0] >>> process_test_cases(1, [\\"abbbbba\\"]) [4] >>> process_test_cases(2, [\\"a\\", \\"\\"]) [0, 0]","solution":"def min_removals_to_avoid_consecutive_chars(S): Returns the minimum number of characters that need to be removed to ensure that no two identical consecutive characters remain in the string S. removals = 0 previous_char = '' for char in S: if char == previous_char: removals += 1 else: previous_char = char return removals def process_test_cases(T, test_cases): results = [] for i in range(T): results.append(min_removals_to_avoid_consecutive_chars(test_cases[i])) return results"},{"question":"def calculate_subtree_values(t: int, test_cases: List[Dict[str, Any]]) -> List[List[int]]: Given multiple test cases, each with a tree structure and node values, calculate the value of the subtree rooted at each node in every test case. Args: t (int): The number of test cases test_cases (List[Dict[str, Any]]): A list of test cases, each test case is represented as a dictionary with three keys: - 'n': The number of nodes in the tree (int) - 'values': A list of integers representing the intrinsic value of each node - 'edges': A list of tuples representing the edges between nodes Returns: List[List[int]]: A list of lists, each inner list representing the value of the subtrees for a test case Example: >>> calculate_subtree_values(1, [{'n': 5, 'values': [1, 2, 3, 4, 5], 'edges': [(1, 2), (1, 3), (3, 4), (3, 5)]}]) [[15, 2, 12, 4, 5]]","solution":"def calculate_subtree_values(t, test_cases): def dfs(node, parent): # Initialize the total value as the value of the current node total_value[node] = values[node - 1] for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) total_value[node] += total_value[neighbor] results = [] for idx in range(t): n = test_cases[idx]['n'] values = test_cases[idx]['values'] edges = test_cases[idx]['edges'] # Build the tree as an adjacency list tree = {i: [] for i in range(1, n + 1)} for u, v in edges: tree[u].append(v) tree[v].append(u) total_value = [0] * (n + 1) # Perform DFS from the root node, considered as node 1 dfs(1, -1) # Collect the results for this test case results.append(total_value[1:]) return results"},{"question":"def checkBalance(s: str) -> int: Function to check if a given alphanumeric string contains equal counts of digits and letters. Arguments: s -- input string Returns: 1 if the string has equal counts of digits and letters, 0 otherwise. >>> checkBalance(\\"a1b2\\") 1 >>> checkBalance(\\"ab12c\\") 0","solution":"def checkBalance(s): Function to check if a given alphanumeric string contains equal counts of digits and letters. Arguments: s -- input string Returns: 1 if the string has equal counts of digits and letters, 0 otherwise. count_letters = 0 count_digits = 0 for char in s: if char.isdigit(): count_digits += 1 elif char.isalpha(): count_letters += 1 return 1 if count_letters == count_digits else 0"},{"question":"def is_valid_triangle(a, b, c): Check if three given side lengths can form a valid triangle. >>> is_valid_triangle(3, 4, 5) == True >>> is_valid_triangle(1, 1, 3) == False def calculate_area(a, b, c): Calculate the area of a triangle using Heron's formula if the given sides form a valid triangle. If not valid, return \\"Invalid\\". >>> calculate_area(3, 4, 5) == 6.0 >>> calculate_area(1, 1, 3) == \\"Invalid\\" # Test cases def test_is_valid_triangle(): assert is_valid_triangle(3, 4, 5) == True assert is_valid_triangle(1, 1, 3) == False assert is_valid_triangle(5, 5, 5) == True assert is_valid_triangle(10, 20, 30) == False assert is_valid_triangle(7, 10, 5) == True def test_calculate_area(): assert calculate_area(3, 4, 5) == 6.0 assert calculate_area(1, 1, 3) == \\"Invalid\\" assert calculate_area(2, 2, 3) == 1.98 assert calculate_area(7, 10, 5) == 16.25 assert calculate_area(6, 8, 10) == 24.0","solution":"import math def is_valid_triangle(a, b, c): # Check if sum of any two sides is greater than the third side if a + b > c and a + c > b and b + c > a: return True else: return False def calculate_area(a, b, c): if is_valid_triangle(a, b, c): # Using Heron's formula to calculate the area of the triangle s = (a + b + c) / 2 area = math.sqrt(s * (s - a) * (s - b) * (s - c)) return round(area, 2) else: return \\"Invalid\\""},{"question":"def longestConsecutive(nums): Find the length of the longest consecutive sequence in the given list of integers. Parameters: nums (List[int]): The input list of integers. Returns: int: The length of the longest consecutive sequence. pass def test_longestConsecutive_example1(): assert longestConsecutive([100, 4, 200, 1, 3, 2]) == 4 def test_longestConsecutive_example2(): assert longestConsecutive([0, 0, -1]) == 2 def test_longestConsecutive_single_element(): assert longestConsecutive([1]) == 1 def test_longestConsecutive_empty(): assert longestConsecutive([]) == 0 def test_longestConsecutive_no_consecutive(): assert longestConsecutive([5, 10, 15]) == 1 def test_longestConsecutive_all_negative(): assert longestConsecutive([-3, -2, -1, -4]) == 4 def test_longestConsecutive_mixed(): assert longestConsecutive([-1, 0, 1, 2, 3, 4, 5]) == 7 def test_longestConsecutive_large_numbers(): assert longestConsecutive([10**9, 10**9-1, 10**9-2]) == 3","solution":"def longestConsecutive(nums): Find the length of the longest consecutive sequence in the given list of integers. Parameters: nums (List[int]): The input list of integers. Returns: int: The length of the longest consecutive sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def submatrixSum(matrix, top_left, bottom_right): Returns the sum of the elements inside a given submatrix. :param matrix: List of lists where each sublist is a list of integers. :param top_left: Tuple containing the coordinates of the top-left corner of the submatrix. :param bottom_right: Tuple containing the coordinates of the bottom-right corner of the submatrix. :return: Integer sum of the elements inside the specified submatrix. pass # Example usage: # matrix1 = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(submatrixSum(matrix1, (1, 1), (2, 2))) # Output: 28 # # matrix2 = [ # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1], # [1, 1, 1, 1] # ] # print(submatrixSum(matrix2, (0, 0), (3, 3))) # Output: 16","solution":"def submatrixSum(matrix, top_left, bottom_right): Returns the sum of the elements inside a given submatrix. :param matrix: List of lists where each sublist is a list of integers. :param top_left: Tuple containing the coordinates of the top-left corner of the submatrix. :param bottom_right: Tuple containing the coordinates of the bottom-right corner of the submatrix. :return: Integer sum of the elements inside the specified submatrix. top_row, left_col = top_left bottom_row, right_col = bottom_right submatrix_sum = 0 for i in range(top_row, bottom_row + 1): for j in range(left_col, right_col + 1): submatrix_sum += matrix[i][j] return submatrix_sum"},{"question":"def total_weight(test_cases): Calculate the total weight of balls in each test case. Parameters: test_cases (list of tuples): List of test cases where each tuple contains (N, M). Returns: list: List of total weights for each test case. def test_total_weight(): # Test case 1: 1 red ball, 2 blue balls -> 1*1 + 2*2 = 1 + 4 = 5 test_cases = [(1, 2)] assert total_weight(test_cases) == [5] # Test case 2: 0 red balls, 3 blue balls -> 0*1 + 3*2 = 0 + 6 = 6 test_cases = [(0, 3)] assert total_weight(test_cases) == [6] # Test case 3: 5 red balls, 1 blue ball -> 5*1 + 1*2 = 5 + 2 = 7 test_cases = [(5, 1)] assert total_weight(test_cases) == [7] # Multiple test cases test_cases = [ (1, 2), # -> 5 (0, 3), # -> 6 (5, 1) # -> 7 ] assert total_weight(test_cases) == [5, 6, 7] # Edge cases test_cases = [ (0, 0), # No balls -> 0 (100, 0), # 100 red balls -> 100 (0, 100), # 100 blue balls -> 200 (100, 100) # 100 red and 100 blue balls -> 100*1 + 100*2 = 100 + 200 = 300 ] assert total_weight(test_cases) == [0, 100, 200, 300]","solution":"def total_weight(test_cases): Calculate the total weight of balls in each test case. Parameters: test_cases (list of tuples): List of test cases where each tuple contains (N, M). Returns: list: List of total weights for each test case. results = [] for N, M in test_cases: total_weight = N * 1 + M * 2 results.append(total_weight) return results"},{"question":"from collections import deque from typing import List, Tuple def min_transfers(n: int, m: int, edges: List[Tuple[int, int]], s: int, t: int) -> int: Returns the minimum number of cargo transfers required to move goods from warehouse s to t. If there is no path from s to t, returns -1. >>> min_transfers(5, 6, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5)], 1, 5) 3 >>> min_transfers(4, 2, [(1, 2), (3, 4)], 1, 3) -1","solution":"from collections import deque def min_transfers(n, m, edges, s, t): Returns the minimum number of cargo transfers required to move goods from warehouse s to t. If there is no path from s to t, returns -1. graph = {i: [] for i in range(1, n+1)} # Build the graph for u, v in edges: graph[u].append(v) graph[v].append(u) # BFS to find the shortest path queue = deque([(s, 0)]) visited = set([s]) while queue: current_node, transfers = queue.popleft() if current_node == t: return transfers for neighbor in graph[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, transfers + 1)) return -1"},{"question":"def max_dishes(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Calculate the maximum number of dishes a participant can cook with the ingredients they have. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]): A list where each element is a tuple containing the initial number of ingredients and the number of dishes, followed by a list of tuples containing the number of ingredients used to cook a dish and the number of ingredients gained after cooking the dish. Returns: List[int]: A list where each element represents the maximum number of dishes that can be cooked for each test case. Example: >>> max_dishes(2, [ ... [(10, 2), [(8, 0), (4, 2)]], ... [(5, 1), [(10, 0)]] ... ]) [2, 0]","solution":"def max_dishes(T, test_cases): results = [] for i in range(T): initial_ingredients, number_of_dishes = test_cases[i][0] dishes = test_cases[i][1] dishes.sort(key=lambda x: x[0] - x[1]) count = 0 ingredients_left = initial_ingredients for ingredients_used, ingredients_gained in dishes: if ingredients_left >= ingredients_used: count += 1 ingredients_left -= (ingredients_used - ingredients_gained) results.append(count) return results # Example input parsing and function call T = 2 test_cases = [ [(10, 2), [(8, 0), (4, 2)]], [(5, 1), [(10, 0)]] ] print(max_dishes(T, test_cases)) # Expected output: [2, 0]"},{"question":"from typing import List def optimizeArray(arr: List[int]) -> List[int]: Optimize the array such that each element is modified to be the length of the longest increasing subsequence ending at that element. >>> optimizeArray([10, 22, 9, 33, 21, 50]) [1, 2, 1, 3, 2, 4] >>> optimizeArray([1]) [1] >>> optimizeArray([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> optimizeArray([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> optimizeArray([1, 2, 2, 3, 4, 2, 5]) [1, 2, 2, 3, 4, 2, 5] >>> optimizeArray([3, 1, 8, 2, 5]) [1, 1, 2, 2, 3] >>> optimizeArray([10000, 10001, 9999, 10002, 9998, 10003]) [1, 2, 1, 3, 1, 4] >>> optimizeArray([10, 20, 10, 30, 20, 50]) [1, 2, 1, 3, 2, 4]","solution":"def optimizeArray(arr): n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return lis"},{"question":"def sort_digits(s: str) -> str: Write a function that takes a string containing only digits and returns a new string with the digits sorted in ascending order. If the input string is empty, the function should return an empty string. >>> sort_digits(\\"3141592653\\") \\"1123345569\\" >>> sort_digits(\\"9876543210\\") \\"0123456789\\" >>> sort_digits(\\"\\") \\"\\" >>> sort_digits(\\"1234567890\\") \\"0123456789\\" >>> sort_digits(\\"111222333\\") \\"111222333\\" >>> sort_digits(\\"000987654321\\") \\"000123456789\\" >>> sort_digits(\\"1\\") \\"1\\" >>> sort_digits(\\"00\\") \\"00\\" >>> sort_digits(\\"2\\") \\"2\\"","solution":"def sort_digits(s): Returns a new string with the digits sorted in ascending order. Parameters: s (str): A string containing only digits. Returns: str: A new string with the digits sorted in ascending order. return ''.join(sorted(s))"},{"question":"from typing import List, Tuple def distribute_chemicals(T: int, test_cases: List[Tuple[int, int, List[int], int]]) -> List[List[int]]: Distribute chemicals to departments ensuring the total distribution is exactly Q and no department gets more than U units above their requirement. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], int]]): List of test cases, each represented by a tuple containing: - M (int): Number of departments. - U (int): Maximum extra units any department can get. - q (List[int]): List of required quantities for each department. - Q (int): Total quantity to distribute. Returns: List[List[int]]: Distribution of chemicals for each test case. >>> distribute_chemicals(2, [(3, 2, [1, 2, 3], 9), (4, 5, [0, 1, 0, 1], 3)]) [[2, 3, 4], [0, 1, 2, 0]] pass","solution":"def distribute_chemicals(T, test_cases): results = [] for t in range(T): M, U = test_cases[t][:2] q = test_cases[t][2] Q = test_cases[t][3] distributed = q[:] total_required = sum(q) remaining_quantity = Q - total_required i = 0 while remaining_quantity > 0: add_amount = min(U, remaining_quantity) distributed[i] += add_amount remaining_quantity -= add_amount i += 1 if i >= M: i = 0 results.append(distributed) return results"},{"question":"def allocate_resources(total_resources, sub_teams, min_resources_per_team): Allocates resources to sub-teams if possible, following minimum requirement per team. Parameters: total_resources (int): Total number of resources available. sub_teams (int) : Number of sub-teams in project. min_resources_per_team (int) : Minimum number of resources that each sub-team should get. Returns: list : List of resources allocated to each sub-team, or \\"Insufficient resources!\\" if allocation is not possible. >>> allocate_resources(100, 5, 15) == [20, 20, 20, 20, 20] >>> allocate_resources(80, 4, 25) == \\"Insufficient resources!\\" >>> allocate_resources(75, 5, 15) == [15, 15, 15, 15, 15] >>> allocate_resources(180, 6, 30) == [30, 30, 30, 30, 30, 30] >>> allocate_resources(30, 3, 10) == [10, 10, 10] >>> allocate_resources(60, 5, 10) == [12, 12, 12, 12, 12]","solution":"def allocate_resources(total_resources, sub_teams, min_resources_per_team): Allocates resources to sub-teams if possible, following minimum requirement per team. Parameters: total_resources (int): Total number of resources available. sub_teams (int) : Number of sub-teams in project. min_resources_per_team (int) : Minimum number of resources that each sub-team should get. Returns: list : List of resources allocated to each sub-team, or \\"Insufficient resources!\\" if allocation is not possible. max_possible_per_team = total_resources // sub_teams if max_possible_per_team < min_resources_per_team: return \\"Insufficient resources!\\" resources_per_team = total_resources // sub_teams allocation = [resources_per_team] * sub_teams return allocation"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Given a string s and a list of words dict, find all starting indices of substring(s) in s that are a concatenation of each word in dict exactly once without any intervening characters. The words in dict can be used in any order. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\",\\"bar\\"]) [0,9] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) []","solution":"def findSubstring(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) word_count = len(words) total_len = word_len * word_count s_len = len(s) words_counter = Counter(words) result = [] for i in range(word_len): left = i right = i current_counter = Counter() while right + word_len <= s_len: word = s[right:right + word_len] right += word_len if word in words_counter: current_counter[word] += 1 while current_counter[word] > words_counter[word]: left_word = s[left:left + word_len] current_counter[left_word] -= 1 left += word_len if right - left == total_len: result.append(left) else: current_counter.clear() left = right return result"},{"question":"from datetime import datetime, timedelta from typing import List def compute_average_duration(events: List[str]) -> str: Computes the average duration between consecutive events and returns it as a string in \\"HH:MM:SS\\" format. Parameters: events (list of str): List of event timestamps in \\"HH:MM:SS\\" format. Returns: str: Average duration between consecutive events in \\"HH:MM:SS\\" format. >>> compute_average_duration([ ... \\"12:34:56\\", ... \\"12:35:56\\", ... \\"12:36:00\\", ... \\"13:00:00\\", ... \\"13:01:00\\" ... ]) '00:06:31' >>> compute_average_duration([ ... \\"12:00:00\\", ... \\"12:01:00\\" ... ]) '00:01:00' >>> compute_average_duration([ ... \\"14:00:00\\", ... \\"14:00:00\\", ... \\"14:00:00\\" ... ]) '00:00:00' >>> compute_average_duration([ ... \\"13:00:00\\", ... \\"15:00:00\\", ... \\"17:00:00\\" ... ]) '02:00:00' >>> compute_average_duration([ ... \\"11:59:55\\", ... \\"12:00:05\\", ... \\"12:00:15\\", ... \\"12:00:25\\" ... ]) '00:00:10'","solution":"from datetime import datetime, timedelta def compute_average_duration(events): Computes the average duration between consecutive events and returns it as a string in \\"HH:MM:SS\\" format. Parameters: events (list of str): List of event timestamps in \\"HH:MM:SS\\" format. Returns: str: Average duration between consecutive events in \\"HH:MM:SS\\" format. total_seconds = 0 time_format = \\"%H:%M:%S\\" for i in range(1, len(events)): t1 = datetime.strptime(events[i-1], time_format) t2 = datetime.strptime(events[i], time_format) duration = (t2 - t1).total_seconds() total_seconds += duration average_seconds = total_seconds // (len(events) - 1) average_duration = str(timedelta(seconds=average_seconds)) # Ensure the average duration is in HH:MM:SS format hours, minutes, seconds = map(int, average_duration.split(':')) return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"def calculate_running_stats(distances, elevations): Calculate the total distance run and check if the total elevation change is non-negative. Args: distances (list of int): The distance Tom plans to run each day. elevations (list of int): The elevation change for each day. Returns: tuple: A tuple containing the total distance run and a boolean indicating if the total elevation change is non-negative. Examples: >>> calculate_running_stats([10, 20, 15, 25, 30], [10, -5, 20, -10, 5]) (100, True) >>> calculate_running_stats([5, 10, 15], [5, -20, 10]) (30, False) >>> calculate_running_stats([8, 16, 24, 8], [-5, -5, -5, 15]) (56, True)","solution":"def calculate_running_stats(distances, elevations): Calculate the total distance run and check if the total elevation change is non-negative. Args: distances (list of int): The distance Tom plans to run each day. elevations (list of int): The elevation change for each day. Returns: tuple: A tuple containing the total distance run and a boolean indicating if the total elevation change is non-negative. total_distance = sum(distances) total_elevation = sum(elevations) return total_distance, total_elevation >= 0 # Example usage: # distances = [10, 20, 15, 25, 30] # elevations = [10, -5, 20, -10, 5] # print(calculate_running_stats(distances, elevations)) # (100, True)"},{"question":"def max_non_overlapping_workshops(t, cases): Given multiple test cases, determine the maximum number of non-overlapping workshops that can be attended by any single attendee. Args: t (int): number of test cases cases (list): list of tuples where each tuple contains an integer n (number of workshops) and a list of tuples (s_i, e_i) representing the start and end times of the workshops Returns: list: a list of integers where each integer represents the maximum number of non-overlapping workshops for the corresponding test case Examples: >>> max_non_overlapping_workshops(3, [(3, [(1, 4), (2, 5), (3, 6)]), (4, [(1, 3), (2, 4), (3, 5), (4, 6)]), (2, [(1, 2), (2, 3)])]) [1, 2, 2] >>> max_non_overlapping_workshops(1, [(3, [(1, 5), (2, 6), (3, 7)])]) [1]","solution":"def max_non_overlapping_workshops(t, cases): results = [] for i in range(t): n, intervals = cases[i] intervals.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in intervals: if start >= end_time: count += 1 end_time = end results.append(count) return results"},{"question":"def can_reach_bottom_right(grid): Determine if a path exists from top-left to bottom-right of the grid. >>> can_reach_bottom_right([['.', '#', '.', '.'], ['.', '.', '#', '.'], ['#', '.', '.', '.'], ['.', '#', '.', '.']]) == \\"YES\\" >>> can_reach_bottom_right([['.']]) == \\"YES\\" >>> can_reach_bottom_right([['.', '#', '.', '.'], ['.', '#', '#', '.'], ['#', '.', '.', '.'], ['.', '#', '.', '#']]) == \\"NO\\" >>> can_reach_bottom_right([['.', '.'], ['.', '#']]) == \\"NO\\" >>> can_reach_bottom_right([['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.']]) == \\"YES\\"","solution":"def can_reach_bottom_right(grid): Determine if a path exists from top-left to bottom-right of the grid. N = len(grid) M = len(grid[0]) def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' from collections import deque queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) directions = [(0, 1), (1, 0)] # Right, Down while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def fill_canvas(n: int, m: int, k: int) -> List[List[int]]: Return the color pattern for a n x m canvas using k colors such that no two adjacent squares share the same color. Args: n (int): the number of rows of the canvas. m (int): the number of columns of the canvas. k (int): the number of colors available. Returns: List[List[int]]: a 2D list representing the color pattern of the canvas. pass # Example usage: # n, m, k = 3, 4, 3 # result = fill_canvas(n, m, k) # for row in result: # print(' '.join(map(str, row))) from solution import fill_canvas def test_fill_canvas_3x4_3colors(): result = fill_canvas(3, 4, 3) for i in range(3): for j in range(4): if i > 0: assert result[i][j] != result[i-1][j] if j > 0: assert result[i][j] != result[i][j-1] def test_fill_canvas_2x2_2colors(): result = fill_canvas(2, 2, 2) for i in range(2): for j in range(2): if i > 0: assert result[i][j] != result[i-1][j] if j > 0: assert result[i][j] != result[i][j-1] def test_fill_canvas_4x4_4colors(): result = fill_canvas(4, 4, 4) for i in range(4): for j in range(4): if i > 0: assert result[i][j] != result[i-1][j] if j > 0: assert result[i][j] != result[i][j-1] def test_fill_canvas_1x1_1color(): result = fill_canvas(1, 1, 1) assert result == [[1]] def test_fill_canvas_1x5_2colors(): result = fill_canvas(1, 5, 2) for j in range(1, 5): assert result[0][j] != result[0][j-1]","solution":"def fill_canvas(n, m, k): Return the color pattern for a n x m canvas using k colors such that no two adjacent squares share the same color. canvas = [[0] * m for _ in range(n)] # A function to determine the valid color for a cell def find_color(used_colors): for color in range(1, k + 1): if color not in used_colors: return color for i in range(n): for j in range(m): # Collect used colors from adjacent cells used_colors = set() if i > 0: used_colors.add(canvas[i-1][j]) if j > 0: used_colors.add(canvas[i][j-1]) canvas[i][j] = find_color(used_colors) return canvas # Example usage: # n, m, k = 3, 4, 3 # result = fill_canvas(n, m, k) # for row in result: # print(' '.join(map(str, row)))"},{"question":"def findMissingPositive(arr: List[int]) -> int: Given a list of integers, find the smallest missing positive integer. The task must be performed with a time complexity of O(n) and using constant space. Assume the list may contain duplicate values and negative numbers. :param arr: List[int] - List of integers :return: int - Smallest missing positive integer Examples: >>> findMissingPositive([1, 2, 0]) 3 >>> findMissingPositive([3, 4, -1, 1]) 2 >>> findMissingPositive([7, 8, 9, 11, 12]) 1","solution":"def findMissingPositive(arr): n = len(arr) # Step 1: Segregate positive numbers from non-positive numbers for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Step 2: Identify the smallest missing positive integer for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def can_sort_sequence(n: int, sequence: List[int]) -> str: Determines if Kevin can sort a sequence of n numbered cards. Kevin can sort the sequence using any number of reversals of any subsequence. >>> can_sort_sequence(5, [3, 1, 2, 4, 5]) \\"YES\\" >>> can_sort_sequence(3, [3, 2, 1]) \\"YES\\" >>> can_sort_sequence(4, [4, 3, 2, 1]) \\"YES\\" >>> can_sort_sequence(6, [6, 1, 2, 3, 4, 5]) \\"YES\\"","solution":"def can_sort_sequence(n, sequence): Returns \\"YES\\" if the sequence can be sorted using any number of reverse subsequence operations, otherwise returns \\"NO\\". return \\"YES\\""},{"question":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two elements in the array. >>> smallest_absolute_difference([3, 8, -10, 23, 19]) == 4 >>> smallest_absolute_difference([1, 2, 3, 4]) == 1 >>> smallest_absolute_difference([-1, -2, -3, -4]) == 1 >>> smallest_absolute_difference([100, 300, 200, 150]) == 50 >>> smallest_absolute_difference([-10, 5, 3, -7, 2]) == 1 >>> smallest_absolute_difference([1, 1, 1, 1]) == 0 >>> smallest_absolute_difference([2, 2, 5, 5]) == 0 >>> smallest_absolute_difference([10**6, -10**6, 0, 500000]) == 500000","solution":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two elements in the array. arr.sort() # Sort the array first min_difference = float('inf') # Iterate through sorted array and find the minimum difference for i in range(len(arr) - 1): difference = abs(arr[i] - arr[i + 1]) if difference < min_difference: min_difference = difference return min_difference"},{"question":"def has_pair_with_sum(arr: List[int], target_sum: int) -> str: Given an array of integers and a target sum, determine if there exists two distinct elements in the array that add up to the target sum. If such a pair exists, return \\"YES\\", otherwise return \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> has_pair_with_sum([1, 1, 1, 1], 3) \\"NO\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) \\"YES\\" >>> has_pair_with_sum([-1, 2, 4, -2, 3, -7], 1) \\"YES\\" >>> has_pair_with_sum([10**9, -(10**9), 3, 7], 0) \\"YES\\" >>> has_pair_with_sum([5, -2, -7, 3], 1) \\"YES\\"","solution":"def has_pair_with_sum(arr, target_sum): seen = set() for num in arr: complement = target_sum - num if complement in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def min_operations_to_palindrome(t: int, cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of operations required to make the string S a palindrome or determine that it is impossible. Args: t (int): Number of test cases. cases (List[Tuple[int, str]]): A list of tuples containing the length of the string and the string itself for each test case. Returns: List[int]: A list of integers where each integer represents the minimum number of operations needed to make the string S a palindrome or -1 if it is not possible. Example: >>> min_operations_to_palindrome(4, [(3, 'abc'), (4, 'abba'), (5, 'aabaa'), (6, 'abccba')]) [1, 0, 0, 0] >>> min_operations_to_palindrome(2, [(4, 'abca'), (5, 'abcde')]) [1, 2]","solution":"def min_operations_to_palindrome(t, cases): results = [] for i in range(t): n, s = cases[i] if s == s[::-1]: results.append(0) continue left = 0 right = n - 1 operations = 0 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 results.append(operations) return results"},{"question":"def longest_palindromic_substring_after_k_changes(k: int, S: str) -> int: Find the length of the longest palindromic substring after making at most k changes. >>> longest_palindromic_substring_after_k_changes(2, 'abca') 4 >>> longest_palindromic_substring_after_k_changes(1, 'abcdef') 3 >>> longest_palindromic_substring_after_k_changes(0, 'racecar') 7 def process_test_cases(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Process multiple test cases and return results. >>> process_test_cases(3, [(2, 'abca'), (1, 'abcdef'), (0, 'racecar')]) [4, 3, 7] def test_example_cases(): assert process_test_cases(3, [(2, 'abca'), (1, 'abcdef'), (0, 'racecar')]) == [4, 3, 7] def test_no_changes_possible(): assert process_test_cases(1, [(0, 'abc')]) == [1] assert process_test_cases(1, [(0, 'a')]) == [1] def test_max_changes_possible(): assert process_test_cases(1, [(100, 'abcdefghij')]) == [10] assert process_test_cases(1, [(5, 'abcdefedcba')]) == [11] def test_single_character_string(): assert process_test_cases(1, [(0, 'z')]) == [1] assert process_test_cases(1, [(1, 'z')]) == [1] def test_string_with_all_same_characters(): assert process_test_cases(1, [(0, 'aaaaa')]) == [5] assert process_test_cases(1, [(2, 'aaaaa')]) == [5]","solution":"def longest_palindromic_substring_after_k_changes(k, S): def longest_palindrome(l, r, k, S): changes = 0 left_char_count = [0] * 26 right_char_count = [0] * 26 for i in range((r - l + 1) // 2): left_char_count[ord(S[l + i]) - ord('a')] += 1 right_char_count[ord(S[r - i]) - ord('a')] += 1 for i in range(26): changes += abs(left_char_count[i] - right_char_count[i]) return r - l + 1 if changes // 2 <= k else 0 n = len(S) max_len = 0 for l in range(n): for r in range(l, n): max_len = max(max_len, longest_palindrome(l, r, k, S)) return max_len def process_test_cases(T, test_cases): results = [] for k, S in test_cases: results.append(longest_palindromic_substring_after_k_changes(k, S)) return results"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than or equal to n. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(7) [2, 3, 5, 7] >>> sieve_of_eratosthenes(0) [] >>> sieve_of_eratosthenes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than or equal to n. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] # Example usage: # result = sieve_of_eratosthenes(20) # print(result) # Output: [2, 3, 5, 7, 11, 13, 17, 19]"},{"question":"def find_pair_with_sum(n: int, array: List[int], target: int) -> Tuple[int, int]: Determines if there are two distinct integers in the array whose sum equals the target value. Returns the tuple of such pair if exists, else returns an empty tuple. >>> find_pair_with_sum(5, [2, 7, 11, 15, -2], 9) (2, 7) >>> find_pair_with_sum(6, [1, 5, 3, -4, 8, 10], 6) (1, 5) >>> find_pair_with_sum(4, [3, 6, -7, 2], 10) ()","solution":"def find_pair_with_sum(n, array, target): Determines if there are two distinct integers in the array whose sum equals the target value. Returns the tuple of such pair if exists, else returns an empty tuple. seen = {} for number in array: complement = target - number if complement in seen: return (complement, number) seen[number] = True return ()"},{"question":"def max_books_on_shelf(w: int, books: List[Tuple[int, int, int]]) -> int: Returns the maximum number of books that can be placed on the shelf based on the width constraint. :param w: Width of the shelf. :param books: List of tuples, where each tuple contains (width, height, thickness) of a book. :return: Maximum number of books that can be placed on the shelf. # Implement the logic to find the maximum number of books that can be placed on the shelf # Unit Test from solution import max_books_on_shelf def test_example_case_1(): w = 100 books = [(10, 200, 50), (20, 150, 70), (30, 100, 90), (40, 50, 110), (50, 30, 130)] assert max_books_on_shelf(w, books) == 4 def test_example_case_2(): w = 200 books = [(50, 100, 10), (60, 80, 20), (70, 60, 30), (80, 40, 40), (90, 20, 50), (100, 10, 60)] assert max_books_on_shelf(w, books) == 6 def test_single_book_fits(): w = 10 books = [(10, 200, 50)] assert max_books_on_shelf(w, books) == 1 def test_single_book_does_not_fit(): w = 5 books = [(10, 200, 50)] assert max_books_on_shelf(w, books) == 0 def test_multiple_books_same_width(): w = 30 books = [(10, 100, 20), (10, 150, 30), (10, 200, 40)] assert max_books_on_shelf(w, books) == 3 def test_no_books(): w = 50 books = [] assert max_books_on_shelf(w, books) == 0","solution":"def max_books_on_shelf(w, books): Returns the maximum number of books that can be placed on the shelf based on the width constraint. :param w: Width of the shelf. :param books: List of tuples, where each tuple contains (width, height, thickness) of a book. :return: Maximum number of books that can be placed on the shelf. sorted_books = sorted(books, key=lambda x: x[0]) # Sort books by their width. current_width = 0 count = 0 for book in sorted_books: if current_width + book[0] <= w: current_width += book[0] count += 1 else: break return count"},{"question":"def largest_palindrome_product(n: int) -> int: Find the largest numerical palindrome that can be obtained by multiplying two n-digit numbers. >>> largest_palindrome_product(1) 9 >>> largest_palindrome_product(2) 9009 >>> largest_palindrome_product(3) 906609","solution":"def is_palindrome(num): Check if a number is a palindrome. return str(num) == str(num)[::-1] def largest_palindrome_product(n): Find the largest palindrome product of two n-digit numbers. max_num = 10**n - 1 min_num = 10**(n-1) max_palindrome = 0 for i in range(max_num, min_num - 1, -1): for j in range(i, min_num - 1, -1): product = i * j if is_palindrome(product) and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"from typing import List, Tuple MOD = 10**9 + 7 def count_arrays_with_k_inversions(N: int, K: int) -> int: Calculate the number of arrays of length N that have exactly K inversions. >>> count_arrays_with_k_inversions(3, 2) 2 >>> count_arrays_with_k_inversions(4, 3) 6 dp = [[0 for _ in range(K+1)] for _ in range(N+1)] dp[0][0] = 1 for n in range(1, N + 1): for k in range(K + 1): dp[n][k] = dp[n-1][k] if k > 0: dp[n][k] += dp[n][k-1] if k >= n: dp[n][k] -= dp[n-1][k-n] dp[n][k] %= MOD return dp[N][K] def solve(test_cases: List[Tuple[int, int]]) -> List[int]: results = [] for n, k in test_cases: results.append(count_arrays_with_k_inversions(n, k)) return results def main(inputs: List[str]) -> List[int]: T = int(inputs[0]) test_cases = [tuple(map(int, inputs[i].split())) for i in range(1, T + 1)] return solve(test_cases)","solution":"MOD = 10**9 + 7 def count_arrays_with_k_inversions(N, K): dp = [[0 for _ in range(K+1)] for _ in range(N+1)] dp[0][0] = 1 for n in range(1, N + 1): for k in range(K + 1): dp[n][k] = dp[n-1][k] if k > 0: dp[n][k] += dp[n][k-1] if k >= n: dp[n][k] -= dp[n-1][k-n] dp[n][k] %= MOD return dp[N][K] def solve(test_cases): results = [] for n, k in test_cases: results.append(count_arrays_with_k_inversions(n, k)) return results def main(inputs): T = int(inputs[0]) test_cases = [tuple(map(int, inputs[i].split())) for i in range(1, T + 1)] return solve(test_cases)"},{"question":"from typing import List, Tuple def find_suspicious_ips(log_entries: List[Tuple[str, str]], K: int, T: int) -> List[str]: Identify IP addresses that made more than a given number of failed login attempts within the specified time window. Parameters: log_entries (List[Tuple[str, str]]): The list of log entries with each entry containing timestamp and IP address. K (int): The threshold for the number of failed login attempts. T (int): The time window in seconds. Returns: List[str]: The list of IP addresses that made more than K failed login attempts within any T-second window. >>> find_suspicious_ips([ >>> (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), >>> (\\"2023-01-01 00:00:05\\", \\"192.168.1.2\\"), >>> (\\"2023-01-01 00:00:10\\", \\"192.168.1.1\\"), >>> (\\"2023-01-01 00:00:15\\", \\"192.168.1.3\\"), >>> (\\"2023-01-01 00:00:21\\", \\"192.168.1.1\\"), >>> (\\"2023-01-01 00:00:30\\", \\"192.168.1.2\\"), >>> (\\"2023-01-01 00:00:35\\", \\"192.168.1.1\\"), >>> ], 3, 60) == [\\"192.168.1.1\\"] >>> find_suspicious_ips([ >>> (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), >>> (\\"2023-01-01 00:00:20\\", \\"192.168.1.2\\"), >>> (\\"2023-01-01 00:00:21\\", \\"192.168.1.1\\"), >>> (\\"2023-01-01 00:00:45\\", \\"192.168.1.3\\"), >>> (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\"), >>> ], 2, 30) == [\\"No suspicious IPs\\"] def process_input(logs: List[Tuple[str, str]], K: int, T: int) -> List[str]: Process the input log information to find the suspicious IPs. Parameters: logs (List[Tuple[str, str]]): The list of log entries with each entry containing timestamp and IP address. K (int): The threshold for the number of failed login attempts. T (int): The time window in seconds. Returns: List[str]: The list of IP addresses that made more than K failed login attempts within any T-second window. # Test cases if __name__ == \\"__main__\\": from datetime import datetime def test_sample_input_1(): logs = [ (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:05\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:10\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:15\\", \\"192.168.1.3\\"), (\\"2023-01-01 00:00:21\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:30\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:35\\", \\"192.168.1.1\\"), ] K = 3 T = 60 assert find_suspicious_ips(logs, K, T) == [\\"192.168.1.1\\"] def test_sample_input_2(): logs = [ (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:20\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:21\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:45\\", \\"192.168.1.3\\"), (\\"2023-01-01 00:01:00\\", \\"192.168.1.1\\"), ] K = 2 T = 30 assert find_suspicious_ips(logs, K, T) == [\\"No suspicious IPs\\"] def test_sample_input_3(): logs = [ (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:02\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:03\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:04\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:08\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:09\\", \\"192.168.1.1\\"), ] K = 2 T = 10 assert find_suspicious_ips(logs, K, T) == [\\"192.168.1.1\\"] def test_no_suspicious_ips(): logs = [ (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:01:01\\", \\"192.168.1.2\\"), ] K = 3 T = 60 assert find_suspicious_ips(logs, K, T) == [\\"No suspicious IPs\\"] def test_multiple_suspicious_ips(): logs = [ (\\"2023-01-01 00:00:01\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:05\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:09\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:15\\", \\"192.168.1.3\\"), (\\"2023-01-01 00:00:19\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:23\\", \\"192.168.1.2\\"), (\\"2023-01-01 00:00:25\\", \\"192.168.1.1\\"), (\\"2023-01-01 00:00:29\\", \\"192.168.1.2\\"), ] K = 2 T = 30 assert find_suspicious_ips(logs, K, T) == [\\"192.168.1.1\\", \\"192.168.1.2\\"]","solution":"from datetime import datetime def find_suspicious_ips(log_entries, K, T): log_dict = {} suspicious_ips = set() for timestamp, ip in log_entries: time_object = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S') if ip not in log_dict: log_dict[ip] = [] log_dict[ip].append(time_object) while log_dict[ip] and (time_object - log_dict[ip][0]).total_seconds() > T: log_dict[ip].pop(0) if len(log_dict[ip]) > K: suspicious_ips.add(ip) if suspicious_ips: return sorted(suspicious_ips, key=lambda ip: log_dict[ip][K-1]) else: return [\\"No suspicious IPs\\"] # Function to process the input and output the result def process_input(logs, K, T): log_entries = [(log[0] + \\" \\" + log[1], log[2]) for log in logs] result = find_suspicious_ips(log_entries, K, T) return result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().splitlines() N, K, T = map(int, data[0].split()) logs = [line.split(' ', 2) for line in data[1:]] results = process_input(logs, K, T) for res in results: print(res)"},{"question":"def max_bouquet_length(test_cases: List[List[int]]) -> List[int]: This function calculates the length of the longest bouquet Alice can create for each test case. >>> max_bouquet_length([[1, 2, 2, 3, 3], [4, 4, 4, 4], [1, 2, 3, 4, 5, 6, 7, 8]]) [2, 4, 1] >>> max_bouquet_length([[1]]) [1] >>> max_bouquet_length([[6, 6, 6, 6, 6]]) [5] >>> max_bouquet_length([[1, 2, 3, 4, 5, 6]]) [1] >>> max_bouquet_length([[1, 1, 1, 2, 2, 3, 3, 3, 3], [5, 5, 4, 4, 4], [7, 7, 7, 7, 7, 7]]) [4, 3, 6] >>> max_bouquet_length([[1, 2, 2, 2, 3, 4, 4, 5]]) [3] >>> max_bouquet_length([[1, 2, 1, 2, 1, 2, 1, 2]]) [1]","solution":"def max_bouquet_length(test_cases): This function calculates the length of the longest bouquet Alice can create for each test case. Parameters: test_cases (list of list): A list where each element is a list containing species of flowers. Returns: list: A list of integers where each integer represents the length of the longest bouquet for the corresponding test case. results = [] for flowers in test_cases: max_length = 0 current_length = 1 for i in range(1, len(flowers)): if flowers[i] == flowers[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # Final check at the end of the list results.append(max_length) return results"},{"question":"def findSingleElement(nums): Finds the single distinct element in a list where every element appears twice except for one which appears exactly once. Parameters: nums (list): A list of integers where each integer, except one, appears twice. Returns: int: The single distinct element. Example: >>> findSingleElement([4, 1, 2, 1, 2]) 4 >>> findSingleElement([2, 2, 3, 2, 2]) 3 >>> findSingleElement([0, 0, 1, 1, 99]) 99","solution":"def findSingleElement(nums): Finds the single distinct element in a list where every element appears twice except for one which appears exactly once. This solution uses the XOR approach to achieve linear time complexity and constant space complexity. Parameters: nums (list): A list of integers where each integer, except one, appears twice. Returns: int: The single distinct element. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"def can_plant_seeds(n: int, m: int, constraints: List[Tuple[int, int]]) -> str: Determine if it is possible to plant each seed in the fields satisfying all the constraints. Args: n (int): Number of seed types. m (int): Number of constraints. constraints (List[Tuple[int, int]]): List of constraints where each tuple (a_i, b_i) means seed type a_i cannot be planted in field b_i. Returns: str: \\"YES\\" if it is possible to plant seeds according to all constraints, otherwise \\"NO\\". Examples: >>> can_plant_seeds(3, 2, [(1, 2), (3, 1)]) \\"YES\\" >>> can_plant_seeds(2, 2, [(1, 1), (2, 2)]) \\"NO\\" pass","solution":"def can_plant_seeds(n, m, constraints): # Create a list to track which fields are restricted for each seed type restricted_fields = [set() for _ in range(n+1)] # Fill the restricted fields for each seed type based on constraints for a, b in constraints: restricted_fields[a].add(b) # Check each possible arrangement of seed types in the fields for start_field in range(1, n+1): possible = True for seed in range(1, n+1): if start_field in restricted_fields[seed]: possible = False break if possible: return \\"YES\\" return \\"NO\\""},{"question":"def nthSmithNumber(n: int) -> int: Given an integer \`n\`, find the \`nth\` Smith Number. >>> nthSmithNumber(1) 4 >>> nthSmithNumber(2) 22 >>> nthSmithNumber(3) 27 >>> nthSmithNumber(4) 58 >>> nthSmithNumber(5) 85","solution":"def prime_factors(n): Helper function to return prime factors of a number i = 2 factors = [] while i * i <= n: while n % i == 0: factors.append(i) n //= i i += 1 if n > 1: factors.append(n) return factors def sum_of_digits(n): Helper function to return sum of digits of a number return sum(int(digit) for digit in str(n)) def is_smith_number(num): Check if a number is a Smith number if num < 2: return False factors = prime_factors(num) if len(factors) == 1: # num is prime return False sum_digits_num = sum_of_digits(num) sum_digits_factors = sum(sum_of_digits(factor) for factor in factors) return sum_digits_num == sum_digits_factors def nthSmithNumber(n): Function to find the nth Smith number count = 0 current_number = 4 # First Smith number while count < n: if is_smith_number(current_number): count += 1 if count == n: return current_number current_number += 1"},{"question":"def can_rotate_to_avoid_uniform_k_subarray(N: int, K: int, A: List[int]) -> str: Determines if there exists a rotation of the sequence such that the resulting sequence does not contain any subarray of length K that has all elements equal. Parameters: N : int : the length of the sequence K : int : the length of the subarray A : list of int : the sequence Returns: str : \\"Yes\\" if such a rotation exists, otherwise \\"No\\" >>> can_rotate_to_avoid_uniform_k_subarray(5, 3, [1, 2, 3, 1, 2]) 'Yes' >>> can_rotate_to_avoid_uniform_k_subarray(6, 2, [1, 1, 2, 2, 3, 3]) 'No' >>> can_rotate_to_avoid_uniform_k_subarray(7, 3, [1, 1, 1, 1, 1, 1, 1]) 'No' >>> can_rotate_to_avoid_uniform_k_subarray(4, 4, [1, 2, 3, 4]) 'Yes' >>> can_rotate_to_avoid_uniform_k_subarray(5, 5, [2, 2, 2, 2, 2]) 'No'","solution":"def can_rotate_to_avoid_uniform_k_subarray(N, K, A): Determines if there exists a rotation of the sequence such that the resulting sequence does not contain any subarray of length K that has all elements equal. Parameters: N : int : the length of the sequence K : int : the length of the subarray A : list of int : the sequence Returns: str : \\"Yes\\" if such a rotation exists, otherwise \\"No\\" # If K == 1, we can always find a solution because single elements are always unique if K == 1: return \\"Yes\\" # Check if there is a segment of length K in the original array with all elements equal for i in range(N - K + 1): if all(x == A[i] for x in A[i:i+K]): return \\"No\\" return \\"Yes\\""},{"question":"def findLongestSubstring(s: str) -> str: Returns the longest substring with all unique characters. >>> findLongestSubstring(\\"abcabcbb\\") \\"abc\\" >>> findLongestSubstring(\\"bbbbb\\") \\"b\\" >>> findLongestSubstring(\\"pwwkew\\") \\"wke\\" >>> findLongestSubstring(\\"\\") \\"\\" >>> findLongestSubstring(\\" \\") \\" \\" >>> findLongestSubstring(\\"au\\") \\"au\\" >>> findLongestSubstring(\\"dvdf\\") \\"vdf\\" >>> findLongestSubstring(\\"a\\") \\"a\\" >>> findLongestSubstring(\\"aaaa\\") \\"a\\" >>> findLongestSubstring(\\"abcdefg\\") \\"abcdefg\\" >>> findLongestSubstring(\\"aaaaaaa\\") \\"a\\" >>> findLongestSubstring(\\"aAaA\\") \\"aA\\" >>> findLongestSubstring(\\"AaBbCc\\") \\"AaBbCc\\" >>> findLongestSubstring(\\"a1b2c3\\") \\"a1b2c3\\" >>> findLongestSubstring(\\"112233\\") \\"12\\"","solution":"def findLongestSubstring(s): Returns the longest substring with all unique characters. max_length = 0 start = 0 longest_substring = \\"\\" seen_chars = {} for end in range(len(s)): if s[end] in seen_chars: start = max(start, seen_chars[s[end]] + 1) seen_chars[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length longest_substring = s[start:end+1] return longest_substring"},{"question":"def solve_magic_square(grid: List[List[int]]) -> List[List[int]]: Solves the 5x5 magic square puzzle. Fill the grid to form a Magic Square while adhering to the constraints of unique numbers from 1 to 25 and ensuring each row, column, and diagonal sums to 65. >>> input_grid = [ ... [17, 24, 1, 8, 15], ... [23, 5, 7, 14, 0], ... [4, 6, 13, 20, 22], ... [10, 12, 19, 0, 0], ... [11, 18, 0, 0, 0] ... ] >>> solve_magic_square(input_grid) == [ ... [17, 24, 1, 8, 15], ... [23, 5, 7, 14, 16], ... [4, 6, 13, 20, 22], ... [10, 12, 19, 21, 3], ... [11, 18, 25, 2, 9] ... ] >>> input_grid = [ ... [11, 24, 7, 20, 3], ... [4, 12, 25, 8, 16], ... [17, 5, 13, 21, 9], ... [10, 18, 1, 14, 22], ... [23, 6, 19, 2, 0] ... ] >>> solve_magic_square(input_grid) == [ ... [11, 24, 7, 20, 3], ... [4, 12, 25, 8, 16], ... [17, 5, 13, 21, 9], ... [10, 18, 1, 14, 22], ... [23, 6, 19, 2, 15] ... ]","solution":"def solve_magic_square(grid): Solves the 5x5 magic square puzzle. from itertools import permutations def is_magic_square(magic_square): target = 65 # Check rows and columns for i in range(5): if sum(magic_square[i]) != target or sum(magic_square[j][i] for j in range(5)) != target: return False # Check diagonals if sum(magic_square[i][i] for i in range(5)) != target or sum(magic_square[i][4 - i] for i in range(5)) != target: return False return True def fill_square(square, remaining): for perm in permutations(remaining): idx = 0 for i in range(5): for j in range(5): if square[i][j] == 0: square[i][j] = perm[idx] idx += 1 if is_magic_square(square): return square for i in range(5): for j in range(5): if square[i][j] in perm: square[i][j] = 0 return None used_numbers = {num for row in grid for num in row if num != 0} remaining_numbers = [i for i in range(1, 26) if i not in used_numbers] return fill_square([row[:] for row in grid], remaining_numbers)"},{"question":"def max_unique_words_in_phrases(test_cases): This function accepts a list of test cases. Each test case is a list of phrases. It returns a list of integers representing the maximum number of unique words that can be formed into a single sentence for each test case. from solution import max_unique_words_in_phrases def test_single_test_case_multiple_phrases(): test_cases = [ [\\"hello world\\", \\"world is beautiful\\", \\"beautiful day\\"] ] assert max_unique_words_in_phrases(test_cases) == [5] def test_single_test_case_with_repeated_words(): test_cases = [ [\\"good morning\\", \\"good night\\"] ] assert max_unique_words_in_phrases(test_cases) == [3] def test_multiple_test_cases(): test_cases = [ [\\"hello world\\", \\"world is beautiful\\", \\"beautiful day\\"], [\\"good morning\\", \\"good night\\"] ] assert max_unique_words_in_phrases(test_cases) == [5, 3] def test_no_phrases(): test_cases = [ [] ] assert max_unique_words_in_phrases(test_cases) == [0] def test_all_single_word_phrases(): test_cases = [ [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] ] assert max_unique_words_in_phrases(test_cases) == [4] def test_all_repeated_single_word_phrases(): test_cases = [ [\\"a\\", \\"a\\", \\"a\\", \\"a\\"] ] assert max_unique_words_in_phrases(test_cases) == [1]","solution":"def max_unique_words_in_phrases(test_cases): This function accepts a list of test cases. Each test case is a list of phrases. It returns a list of integers representing the maximum number of unique words that can be formed into a single sentence for each test case. results = [] for phrases in test_cases: unique_words = set() for phrase in phrases: words = phrase.split() unique_words.update(words) results.append(len(unique_words)) return results"},{"question":"def can_collect_all_items(grid: List[List[int]]) -> str: Given a MxN grid, determine if it is possible for the player to collect all items. The grid has the following values: - 0: an empty cell - 1: a wall - 2: the player’s current position - 3: an item to collect The player can move up, down, left, or right, but cannot move into or through cells with walls. The goal is to return \\"YES\\" if all items can be collected, otherwise return \\"NO\\". >>> can_collect_all_items([ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 1, 2, 1, 0], ... [0, 1, 0, 1, 3], ... [0, 0, 3, 0, 0] ... ]) \\"YES\\" >>> can_collect_all_items([ ... [0, 1, 0, 3, 0], ... [1, 1, 1, 1, 1], ... [2, 1, 0, 1, 3], ... [0, 1, 3, 1, 0], ... [0, 1, 0, 0, 0] ... ]) \\"NO\\" from typing import List def test_can_collect_all_items(): grid1 = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 0, 1, 3], [0, 0, 3, 0, 0] ] assert can_collect_all_items(grid1) == \\"YES\\" grid2 = [ [0, 1, 0, 3, 0], [1, 1, 1, 1, 1], [2, 1, 0, 1, 3], [0, 1, 3, 1, 0], [0, 1, 0, 0, 0] ] assert can_collect_all_items(grid2) == \\"NO\\" grid3 = [ [2, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 3], [0, 0, 0, 0] ] assert can_collect_all_items(grid3) == \\"YES\\" grid4 = [ [2, 1], [3, 0] ] assert can_collect_all_items(grid4) == \\"YES\\" grid5 = [ [2, 1], [1, 3] ] assert can_collect_all_items(grid5) == \\"NO\\"","solution":"def can_collect_all_items(grid): M, N = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Find the player's starting position start = None items_to_collect = 0 for i in range(M): for j in range(N): if grid[i][j] == 2: start = (i, j) elif grid[i][j] == 3: items_to_collect += 1 if not start: return \\"NO\\" # BFS to collect items from collections import deque queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited: if grid[nx][ny] != 1: if grid[nx][ny] == 3: items_to_collect -= 1 visited.add((nx, ny)) queue.append((nx, ny)) return \\"YES\\" if items_to_collect == 0 else \\"NO\\""},{"question":"def is_square_free(n: int) -> str: Determines if a number n is square-free. A number is square-free if it is not divisible by any perfect square other than 1. :param n: integer to check (1 ≤ n ≤ 10^6) :return: \\"YES\\" if the number is square-free, \\"NO\\" otherwise. >>> is_square_free(10) == \\"YES\\" >>> is_square_free(18) == \\"NO\\" >>> is_square_free(25) == \\"NO\\"","solution":"def is_square_free(n): Determines if a number n is square-free. A number is square-free if it is not divisible by any perfect square other than 1. :param n: integer to check (1 ≤ n ≤ 10^6) :return: \\"YES\\" if the number is square-free, \\"NO\\" otherwise. i = 2 while i * i <= n: if n % (i * i) == 0: return \\"NO\\" i += 1 return \\"YES\\""},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, return a list that for each day tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 for that day. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 30, 30, 30]) [0, 0, 0, 0] >>> daily_temperatures([30, 20, 10, 40, 50, 60]) [3, 2, 1, 1, 1, 0] >>> daily_temperatures([50, 40, 30, 20]) [0, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Given a list of daily temperatures, return a list that for each day tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 for that day. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"def path_finder(m: List[List[int]], a: int, b: int, n: int) -> List[List[int]]: Finds and returns all paths from node \`a\` to node \`b\` in a directed graph. The directed graph is represented as a 2D list \`m\` of size n x n where m[i][j] is 1 if there is a directed edge from node \`i\` to node \`j\`, and 0 otherwise. Args: m: 2D list representing the adjacency matrix of the graph a: The starting node b: The destination node n: The number of nodes in the graph Returns: A list of lists, each sub-list representing a valid path from node \`a\` to node \`b\`. Examples: >>> m = [[0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0]] >>> path_finder(m, 0, 3, 4) [[0, 1, 2, 3]] >>> m = [[0, 1, 1, 0], ... [0, 0, 1, 1], ... [0, 0, 0, 1], ... [0, 0, 0, 0]] >>> path_finder(m, 0, 3, 4) [[0, 1, 2, 3], [0, 2, 3], [0, 1, 3]]","solution":"def path_finder(m, a, b, n): Finds all paths from node \`a\` to node \`b\` in a directed graph. :param m: 2D list representing the adjacency matrix of the graph :param a: The starting node :param b: The destination node :param n: The number of nodes in the graph :return: A list of lists, each representing a unique path from \`a\` to \`b\` all_paths = [] def dfs(current, path): if current == b: all_paths.append(path) return for next_node in range(n): if m[current][next_node] == 1 and next_node not in path: dfs(next_node, path + [next_node]) dfs(a, [a]) return all_paths"},{"question":"def find_task_order(N, M, dependencies): Determine the order of tasks based on dependencies. Args: N (int): The number of tasks. M (int): The number of dependencies. dependencies (List[Tuple[int, int]]): A list of dependencies where each dependency is a tuple (u, v) meaning task u must be completed before v. Returns: List[int]: The tasks ordered by their required completion order, or \\"IMPOSSIBLE\\" if no valid order exists. pass def manage_tasks(T, test_cases): Manage multiple test cases for task ordering. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases where each test case is a tuple containing the number of tasks, number of dependencies, and the list of dependencies. Returns: List[Union[List[int], str]]: A list of results for each test case. Each result is a list of ordered tasks or \\"IMPOSSIBLE\\" if no valid order exists. pass # Example usage for running the function manually def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 dependencies = [] for _ in range(M): u = int(data[index]) v = int(data[index + 1]) dependencies.append((u, v)) index += 2 test_cases.append((N, M, dependencies)) results = manage_tasks(T, test_cases) for result in results: if result == \\"IMPOSSIBLE\\": print(\\"IMPOSSIBLE\\") else: print(\\" \\".join(map(str, result)))","solution":"from collections import deque, defaultdict def find_task_order(N, M, dependencies): # Build graph and indegree array: Graph as adjacency list and tracking indegree of nodes graph = defaultdict(list) indegree = [0] * (N + 1) for u, v in dependencies: graph[u].append(v) indegree[v] += 1 # Initialize queue with nodes having 0 indegree queue = deque([node for node in range(1, N + 1) if indegree[node] == 0]) task_order = [] while queue: current = queue.popleft() task_order.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(task_order) == N: return task_order else: return \\"IMPOSSIBLE\\" def manage_tasks(T, test_cases): results = [] for i in range(T): N, M, dependencies = test_cases[i] results.append(find_task_order(N, M, dependencies)) return results # Example usage for running the function manually def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 dependencies = [] for _ in range(M): u = int(data[index]) v = int(data[index + 1]) dependencies.append((u, v)) index += 2 test_cases.append((N, M, dependencies)) results = manage_tasks(T, test_cases) for result in results: if result == \\"IMPOSSIBLE\\": print(\\"IMPOSSIBLE\\") else: print(\\" \\".join(map(str, result)))"},{"question":"def max_wealth(n: int, k: int, wealth: List[int]) -> int: Returns the maximum amount of wealth that can be robbed without robbing two adjacent houses and without robbing more than k houses. >>> max_wealth(6, 2, [5, 1, 1, 5, 10, 2]) 15 >>> max_wealth(5, 3, [4, 3, 5, 1, 6]) 15 >>> max_wealth(4, 1, [4, 3, 2, 1]) 4","solution":"def max_wealth(n, k, wealth): Returns the maximum amount of wealth that can be robbed without robbing two adjacent houses and without robbing more than k houses. if k == 1: return max(wealth) dp = [[0 for _ in range(k+1)] for _ in range(n+1)] for i in range(1, n+1): for j in range(1, k+1): dp[i][j] = max(dp[i-1][j], wealth[i-1] + (dp[i-2][j-1] if i > 1 else 0)) return dp[n][k]"},{"question":"from typing import List, Tuple def sum_of_products(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: For each test case, calculate the sum of the products of all combinations of length K from the given list of integers. :param test_cases: List of tuples, each containing (N, K, list of integers) :return: List of sums of products for each test case >>> sum_of_products([(4, 2, [1, 2, 3, 4]), (3, 3, [5, 6, 7])]) [35, 210] >>> sum_of_products([(3, 1, [1, 5, 7])]) [13] >>> sum_of_products([(4, 4, [1, 2, 3, 4])]) [24] >>> sum_of_products([(4, 2, [1, 2, 3, 4]), (2, 1, [7, 8]), (5, 3, [1, 1, 1, 1, 1])]) [35, 15, 10]","solution":"from itertools import combinations from functools import reduce from operator import mul def sum_of_products(test_cases): For each test case, calculate the sum of the products of all combinations of length K from the given list of integers. :param test_cases: List of tuples, each containing (N, K, list of integers) :return: List of sums of products for each test case results = [] for case in test_cases: N, K, numbers = case comb = combinations(numbers, K) total_sum = sum(reduce(mul, combo) for combo in comb) results.append(total_sum) return results"},{"question":"def subtree_sums(n, values, edges, queries): Calculate the sum of the values of nodes in the subtree rooted at a given node u. Args: n (int): The number of nodes in the tree. values (List[int]): The values associated with each node. edges (List[Tuple[int, int]]): The edges between the nodes. queries (List[int]): The queries representing the roots of the subtrees. Returns: List[int]: The sum of values of nodes in the subtrees for each query. >>> subtree_sums(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)], [2, 3, 1]) [11, 3, 15] >>> subtree_sums(1, [10], [], [1]) [10] >>> subtree_sums(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)], [2, 3]) [9, 7] >>> subtree_sums(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (1, 4), (1, 5)], [1, 4]) [15, 4]","solution":"def subtree_sums(n, values, edges, queries): from collections import defaultdict, deque # Create the adjacency list for the tree tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Result array to store the sum of subtree values for each node subtree_sum = [0] * (n + 1) visited = [False] * (n + 1) # Function to calculate subtree sums using DFS def dfs(node): visited[node] = True current_sum = values[node - 1] # convert 1-index to 0-index for neighbor in tree[node]: if not visited[neighbor]: current_sum += dfs(neighbor) subtree_sum[node] = current_sum return current_sum # Compute the subtree sums starting from root node 1 dfs(1) # Process each query, converting results to required format result = [subtree_sum[u] for u in queries] return result"},{"question":"def max_checkpoints(N: int, M: int, B: int, paths: List[Tuple[int, int, int]]) -> int: Determine the maximum number of checkpoints a team can visit within the given budget. >>> max_checkpoints(3, 3, 10, [(0, 1, 5), (1, 2, 5), (0, 2, 10)]) 3 >>> max_checkpoints(4, 4, 7, [(0, 1, 3), (1, 2, 4), (1, 3, 6), (2, 3, 2)]) 3","solution":"from heapq import heappush, heappop def max_checkpoints(N, M, B, paths): from collections import defaultdict import heapq # Create a graph from the paths graph = defaultdict(list) for a, b, c in paths: graph[a].append((b, c)) graph[b].append((a, c)) # Use a priority queue to perform a modified Dijkstra's algorithm pq = [(0, 0)] # (cost, node) visited = set() max_checkpoints = 0 effort = {i: float('inf') for i in range(N)} effort[0] = 0 while pq: cur_cost, node = heapq.heappop(pq) if node in visited: continue visited.add(node) max_checkpoints += 1 for neighbor, cost in graph[node]: new_cost = cur_cost + cost if new_cost <= B and new_cost < effort[neighbor]: effort[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return max_checkpoints"},{"question":"def has_contiguous_subsequence_divisible_by_k_d(length_of_sequence, integers_in_sequence, K, D): Determines if there is a contiguous subsequence of length K in the given sequence of integers whose sum is divisible by D. Parameters: - length_of_sequence (int): The length of the sequence - integers_in_sequence (list of int): The sequence of integers - K (int): The length of the subsequence - D (int): The divisor Returns: - str: \\"YES\\" if such a subsequence exists, \\"NO\\" otherwise Examples: >>> has_contiguous_subsequence_divisible_by_k_d(6, [2, 7, 5, 3, 1, 9], 3, 2) \\"YES\\" >>> has_contiguous_subsequence_divisible_by_k_d(5, [1, 2, 3, 4, 5], 2, 4) \\"NO\\"","solution":"def has_contiguous_subsequence_divisible_by_k_d(length_of_sequence, integers_in_sequence, K, D): Determines if there is a contiguous subsequence of length K in the given sequence of integers whose sum is divisible by D. Parameters: - length_of_sequence (int): The length of the sequence - integers_in_sequence (list of int): The sequence of integers - K (int): The length of the subsequence - D (int): The divisor Returns: - str: \\"YES\\" if such a subsequence exists, \\"NO\\" otherwise for i in range(length_of_sequence - K + 1): subsequence_sum = sum(integers_in_sequence[i:i+K]) if subsequence_sum % D == 0: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def generateCombinations(t: List[int], k: int) -> List[List[int]]: Generates all possible combinations of k distinct toppings from the given list. >>> generateCombinations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> generateCombinations([4, 5, 6, 7], 3) [[4, 5, 6], [4, 5, 7], [4, 6, 7], [5, 6, 7]]","solution":"from itertools import combinations from typing import List def generateCombinations(t: List[int], k: int) -> List[List[int]]: Generates all possible combinations of k distinct toppings from the given list. Args: t (List[int]): List of unique toppings. k (int): Number of toppings to choose. Returns: List[List[int]]: List of all possible combinations of k toppings. t.sort() # Ensure the toppings are in lexicographical order return list(map(list, combinations(t, k)))"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determines if any permutation of the specified string s could form a palindrome. :param s: Input string :return: True if any permutation of the input string can form a palindrome, False otherwise Examples: >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Hello\\") False >>> is_palindrome_permutation(\\"A man a plan a canal Panama\\") True >>> is_palindrome_permutation(\\"racecar\\") True >>> is_palindrome_permutation(\\"abcde\\") False # Your code here pass","solution":"def is_palindrome_permutation(s: str) -> bool: Determines if any permutation of the specified string s could form a palindrome. :param s: Input string :return: True if any permutation of the input string can form a palindrome, False otherwise # Normalize the string: ignore spaces and case differences s = ''.join(s.lower().split()) # Count the frequency of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the frequency counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True"},{"question":"def is_prime(num): Check if a number is prime. pass def sum_of_unique_primes(test_cases): Calculate the sum of unique prime numbers in each list of test cases. >>> sum_of_unique_primes([(5, [2, 3, 4, 5, 6])]) == [10] >>> sum_of_unique_primes([(4, [8, 9, 10, 11])]) == [11] >>> sum_of_unique_primes([(6, [13, 14, 15, 16, 17, 18])]) == [30] >>> sum_of_unique_primes([(5, [7, 7, 7, 7, 7])]) == [7] >>> sum_of_unique_primes([(3, [10, 15, 20])]) == [0] pass def process_input(t, input_data): Process the input and return the results for each test case. >>> process_input(3, [\\"5\\", \\"2 3 4 5 6\\", \\"4\\", \\"8 9 10 11\\", \\"6\\", \\"13 14 15 16 17 18\\"]) == [10, 11, 30] >>> process_input(1, [\\"3\\", \\"10 15 20\\"]) == [0] pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def sum_of_unique_primes(test_cases): Calculate the sum of unique prime numbers in each list of test cases. results = [] for case in test_cases: n, elements = case unique_primes = set() for element in elements: if is_prime(element): unique_primes.add(element) results.append(sum(unique_primes)) return results # Function to parse inputs and output results def process_input(t, input_data): test_cases = [] for i in range(t): n = input_data[i * 2] elements = list(map(int, input_data[i * 2 + 1].split())) test_cases.append((n, elements)) return sum_of_unique_primes(test_cases)"},{"question":"from typing import List, Tuple def max_subarray_sum(arr: List[int]) -> int: Function to find the maximum sum of a contiguous subarray. Implements Kadane's Algorithm. >>> max_subarray_sum([1, -2, 3, 4, -5]) 7 >>> max_subarray_sum([-1, -2, -3, -4]) -1 def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to process multiple test cases and return the maximum sum of contiguous subarray for each test case.","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray. Implements Kadane's Algorithm. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_subarray_sum(arr)) return results"},{"question":"def calculate_batches(n: int, m: int, messages: List[int]) -> List[int]: Calculate the number of batches created for delivering messages each day. Parameters: n (int): Number of days of sending messages m (int): Maximum number of messages a single batch can handle messages (List[int]): List containing number of messages sent each day Returns: List[int]: List containing number of batches created each day Examples: >>> calculate_batches(3, 5, [3, 7, 9]) [1, 2, 2] >>> calculate_batches(4, 20, [10, 9, 19, 2]) [1, 1, 1, 1] >>> calculate_batches(1, 100, [99]) [1]","solution":"def calculate_batches(n, m, messages): This function calculates the number of batches required to send messages each day, considering the constraint that each batch can handle up to m messages. :param n: Number of days of sending messages :param m: Maximum number of messages a single batch can handle :param messages: List containing number of messages sent each day :return: List containing number of batches created each day batches = [] for msg in messages: batches.append((msg + m - 1) // m) return batches"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def addNode(self, value): Add a node to the binary tree. Parameters: value (int): The value to be added to the tree. if self.root is None: self.root = TreeNode(value) else: self._addNodeHelper(self.root, value) def _addNodeHelper(self, node, value): Helper function to add a node to the binary tree. Parameters: node (TreeNode): The current node. value (int): The value to be added to the tree. if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._addNodeHelper(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._addNodeHelper(node.right, value) def treeDepth(self): Determine the maximum depth (or height) of the binary tree. Returns: int: The depth of the tree. >>> tree = BinaryTree() >>> tree.addNode(10) >>> tree.treeDepth() 1 >>> tree.addNode(5) >>> tree.addNode(15) >>> tree.treeDepth() 2 def leafCount(self): Count the number of leaf nodes in the binary tree. Returns: int: The number of leaf nodes. >>> tree = BinaryTree() >>> tree.addNode(10) >>> tree.leafCount() 1 >>> tree.addNode(5) >>> tree.addNode(15) >>> tree.leafCount() 2","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def addNode(self, value): if self.root is None: self.root = TreeNode(value) else: self._addNodeHelper(self.root, value) def _addNodeHelper(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._addNodeHelper(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._addNodeHelper(node.right, value) def treeDepth(self): def _depth(node): if node is None: return 0 return 1 + max(_depth(node.left), _depth(node.right)) return _depth(self.root) def leafCount(self): def _countLeafs(node): if node is None: return 0 if node.left is None and node.right is None: return 1 return _countLeafs(node.left) + _countLeafs(node.right) return _countLeafs(self.root)"},{"question":"def convert_minutes(N: int) -> str: Converts total minutes to hours and remaining minutes. Args: N: an integer representing the number of minutes (0 <= N <= 10^4) Returns: A string in the format \\"hours:minutes\\" Examples: >>> convert_minutes(123) '2:3' >>> convert_minutes(60) '1:0' >>> convert_minutes(150) '2:30' >>> convert_minutes(0) '0:0'","solution":"def convert_minutes(N): Converts total minutes to hours and remaining minutes. Args: N: an integer representing the number of minutes (0 <= N <= 10^4) Returns: A string in the format \\"hours:minutes\\" hours = N // 60 minutes = N % 60 return f\\"{hours}:{minutes}\\""},{"question":"def find_shortest_cycle(n: int, walkways: List[Tuple[int, int, int]]) -> int: Finds the length of the shortest cycle in a circular park with n landmarks connected in a circular manner. :param n: Number of landmarks. :param walkways: List of tuples where each tuple contains three integers (a, b, c) indicating a walkway between landmark a and landmark b with length c. :return: The length of the shortest cycle. >>> find_shortest_cycle(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1), (5, 1, 6)]) 16 >>> find_shortest_cycle(4, [(1, 2, 5), (2, 3, 10), (3, 4, 4), (4, 1, 6)]) 25","solution":"def find_shortest_cycle(n, walkways): Finds the length of the shortest cycle in a circular park with n landmarks connected in a circular manner. :param n: Number of landmarks. :param walkways: List of tuples where each tuple contains three integers (a, b, c) indicating a walkway between landmark a and landmark b with length c. :return: The length of the shortest cycle. import networkx as nx G = nx.Graph() for a, b, c in walkways: G.add_edge(a, b, weight=c) # Since all landmarks form a single cycle, we perform a simple sum of all walkway lengths. shortest_cycle_length = sum(c for _, _, c in G.edges(data='weight')) return shortest_cycle_length # Example usage: # print(find_shortest_cycle(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1), (5, 1, 6)])) # Output: 10 # print(find_shortest_cycle(4, [(1, 2, 5), (2, 3, 10), (3, 4, 4), (4, 1, 6)])) # Output: 25"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a list where each element is the product of all elements in the original list except the one at the index of that element. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4]) [12, 8, 6] def process_test_cases(T: int, test_cases: List[tuple]) -> List[str]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases(2, [(4, [1, 2, 3, 4]), (3, [2, 3, 4])]) ['24 12 8 6', '12 8 6'] def test_product_except_self_basic(): nums = [1, 2, 3, 4] expected = [24, 12, 8, 6] assert product_except_self(nums) == expected def test_product_except_self_with_zeros(): nums = [1, 0, 3, 4] expected = [0, 12, 0, 0] assert product_except_self(nums) == expected def test_product_except_self_single_element(): nums = [2] expected = [1] # Not a typical case as per the problem's constraints assert product_except_self(nums) == expected def test_process_test_cases(): T = 2 test_cases = [ (4, [1, 2, 3, 4]), (3, [2, 3, 4]) ] expected = [\\"24 12 8 6\\", \\"12 8 6\\"] assert process_test_cases(T, test_cases) == expected def test_product_except_self_large_numbers(): nums = [100, 200, 300, 400, 500] expected = [12000000000, 6000000000, 4000000000, 3000000000, 2400000000] assert product_except_self(nums) == expected","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all elements in the original list except the one at the index of that element. n = len(nums) if n == 0: return [] left = [1] * n right = [1] * n result = [1] * n for i in range(1, n): left[i] = left[i - 1] * nums[i - 1] for j in range(n - 2, -1, -1): right[j] = right[j + 1] * nums[j + 1] for k in range(n): result[k] = left[k] * right[k] return result def process_test_cases(T, test_cases): result = [] for i in range(T): n, array = test_cases[i] result.append(\\" \\".join(map(str, product_except_self(array)))) return result"},{"question":"def min_distinct_stones(n, powers): Determines the minimum number of distinct types of stones after performing any number of merge operations. Parameters: n (int): the number of different types of magical stones initially present. powers (list of int): the magical powers of the stones. Returns: int: the minimum number of distinct types of stones. pass def find_gcd(a, b): Computes the greatest common divisor (GCD) of two integers using Euclid's algorithm. Parameters: a (int): The first integer. b (int): The second integer. Returns: int: The GCD of a and b. pass # Unit Tests def test_single_stone(): assert min_distinct_stones(1, [7]) == 1 def test_multiple_stones_case_1(): assert min_distinct_stones(3, [5, 9, 12]) == 1 def test_multiple_stones_case_2(): assert min_distinct_stones(4, [8, 16, 24, 32]) == 1 def test_multiple_stones_case_3(): assert min_distinct_stones(5, [1, 3, 5, 7, 9]) == 1 def test_gcd_based_case(): assert min_distinct_stones(4, [2, 3, 5, 7]) == 1 def test_large_numbers_case(): assert min_distinct_stones(2, [1000000000, 500000000]) == 1 def test_no_common_factors_case(): assert min_distinct_stones(2, [15, 28]) == 1","solution":"def min_distinct_stones(n, powers): Determines the minimum number of distinct types of stones after performing any number of merge operations. Parameters: n (int): the number of different types of magical stones initially present. powers (list of int): the magical powers of the stones. Returns: int: the minimum number of distinct types of stones. if n == 1: return 1 gcd = powers[0] for power in powers[1:]: gcd = find_gcd(gcd, power) return min(1, gcd) def find_gcd(a, b): Computes the greatest common divisor (GCD) of two integers using Euclid's algorithm. Parameters: a (int): The first integer. b (int): The second integer. Returns: int: The GCD of a and b. while b: a, b = b, a % b return a"},{"question":"def can_choose_three_items(n: int, k: int, costs: List[int]) -> str: Determines if it is possible to select exactly three different items such that their costs sum up to a multiple of k. :param n: int - the number of items :param k: int - the divisor :param costs: List[int] - the costs of items :return: str - \\"YES\\" if possible, otherwise \\"NO\\" >>> can_choose_three_items(5, 6, [1, 5, 3, 2, 4]) \\"YES\\" >>> can_choose_three_items(4, 10, [1, 2, 3, 4]) \\"NO\\" from solution import can_choose_three_items def test_example1(): assert can_choose_three_items(5, 6, [1, 5, 3, 2, 4]) == \\"YES\\" def test_example2(): assert can_choose_three_items(4, 10, [1, 2, 3, 4]) == \\"NO\\" def test_no_combination_possible(): assert can_choose_three_items(3, 7, [2, 5, 11]) == \\"NO\\" def test_all_combinations_possible(): assert can_choose_three_items(3, 1, [1, 2, 3]) == \\"YES\\" def test_large_k(): assert can_choose_three_items(4, 100, [25, 50, 75, 100]) == \\"YES\\" def test_large_numbers(): costs = [10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3, 10**9 - 4] assert can_choose_three_items(5, 10**9, costs) == \\"NO\\"","solution":"def can_choose_three_items(n, k, costs): Returns \\"YES\\" if it is possible to select exactly three different items such that their costs sum up to a multiple of k, otherwise \\"NO\\". :param n: int :param k: int :param costs: List[int] :return: str (\\"YES\\" or \\"NO\\") from itertools import combinations # Generate all combinations of 3 different items for combo in combinations(costs, 3): if sum(combo) % k == 0: return \\"YES\\" return \\"NO\\""},{"question":"def max_sum_subarray(arr, l, r): Given an array 'arr' and a subrange [l, r], return the maximum sum of a subarray within that subrange. >>> max_sum_subarray([1, -2, 3, 4, -5], 1, 3) 7 >>> max_sum_subarray([1, -2, 3, 4, -5], 0, 4) 7 >>> max_sum_subarray([1, -2, 3, 4, -5], 2, 2) 3 >>> max_sum_subarray([-1, -2, -3], 0, 2) -1 >>> max_sum_subarray([5, -1, 6, -2, 3, 1], 0, 5) 12 pass def process_queries(n, q, array, queries): Process multiple queries to find the maximum sum of subarrays within specified subranges of 'array'. Returns a list of results for each query. >>> process_queries(5, 3, [1, -2, 3, 4, -5], [(1, 3), (0, 4), (2, 2)]) [7, 7, 3] >>> process_queries(3, 1, [-1, -2, -3], [(0, 2)]) [-1] >>> process_queries(6, 2, [5, -1, 6, -2, 3, 1], [(0, 5), (1, 4)]) [12, 7] pass","solution":"def max_sum_subarray(arr, l, r): Given an array 'arr' and a subrange [l, r], return the maximum sum of a subarray within that subrange. max_ending_here = arr[l] max_so_far = arr[l] for i in range(l + 1, r + 1): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_queries(n, q, array, queries): Process multiple queries to find the maximum sum of subarrays within specified subranges of 'array'. Returns a list of results for each query. results = [] for l, r in queries: results.append(max_sum_subarray(array, l, r)) return results"},{"question":"def subtree_sum_at_level(n, values, edges, queries): Calculate the sum of the values of all vertices in the subtree of V that are exactly L levels below V. Parameters: - n (int): The number of vertices in the tree - values (List[int]): A list of initial values of the vertices - edges (List[Tuple[int, int]]): A list of tuples representing the edges of the tree - queries (List[Tuple[int, int]]): A list of tuples containing V and L as described above Returns: - List[int]: A list of integers representing the results of each query >>> subtree_sum_at_level( ... 5, ... [10, 20, 30, 40, 50], ... [(1, 2), (1, 3), (3, 4), (3, 5)], ... [(1, 2), (3, 1), (2, 0)] ... ) [90, 90, 20] >>> subtree_sum_at_level( ... 5, ... [10, 10, 10, 10, 10], ... [(1, 2), (1, 3), (2, 4), (2, 5)], ... [(1, 1), (2, 1), (1, 0)] ... ) [20, 20, 10] >>> subtree_sum_at_level( ... 3, ... [1, 2, 3], ... [(1, 2), (1, 3)], ... [(1, 1), (2, 0), (1, 0)] ... ) [5, 2, 1] >>> subtree_sum_at_level( ... 7, ... [5, 3, 6, 2, 1, 9, 7], ... [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], ... [(1, 2), (2, 1), (3, 1), (4, 0)] ... ) [19, 3, 16, 2] >>> subtree_sum_at_level( ... 6, ... [1, 3, 5, 7, 9, 11], ... [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], ... [(1, 0), (1, 1), (2, 1), (3, 1)] ... ) [1, 8, 16, 11]","solution":"from collections import defaultdict, deque def subtree_sum_at_level(n, values, edges, queries): # Parse input tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to calculate levels and parents level = [-1] * (n + 1) level[1] = 0 parent = [-1] * (n + 1) q = deque([1]) while q: u = q.popleft() for v in tree[u]: if level[v] == -1: level[v] = level[u] + 1 parent[v] = u q.append(v) # Precompute the sum of values at each level for each node def get_subtree_sums(node, parent_node): current_level = level[node] subtree_sums[current_level][node] = values[node-1] for neighbor in tree[node]: if neighbor == parent_node: continue get_subtree_sums(neighbor, node) for lv in subtree_sums: subtree_sums[lv][node] += subtree_sums[lv].get(neighbor, 0) subtree_sums = defaultdict(lambda: defaultdict(int)) get_subtree_sums(1, -1) results = [] for v, l in queries: target_level = level[v] + l if target_level in subtree_sums: results.append(subtree_sums[target_level].get(v, 0)) else: results.append(0) return results"},{"question":"def summarize_reading(logs): Summarizes the reading habits from the logs. Args: logs (list): List of dictionaries with each dictionary containing 'book' (str), 'pages' (int), and 'time' (float). Returns: dict: A dictionary with summary of total books, total pages, total time, and average speed. >>> summarize_reading([ ... {'book': 'Book A', 'pages': 150, 'time': 2.5}, ... {'book': 'Book B', 'pages': 200, 'time': 3.0}, ... {'book': 'Book A', 'pages': 100, 'time': 1.5}, ... {'book': 'Book C', 'pages': 300, 'time': 5.0} ... ]) == { ... 'total_books': 3, ... 'total_pages': 750, ... 'total_time': 12.0, ... 'avg_speed': 62.5 ... } >>> summarize_reading([]) == { ... 'total_books': 0, ... 'total_pages': 0, ... 'total_time': 0.0, ... 'avg_speed': 0.0 ... }","solution":"def summarize_reading(logs): Summarizes the reading habits from the logs. Args: logs (list): List of dictionaries with each dictionary containing 'book' (str), 'pages' (int), and 'time' (float). Returns: dict: A dictionary with summary of total books, total pages, total time, and average speed. if not logs: return { 'total_books': 0, 'total_pages': 0, 'total_time': 0.0, 'avg_speed': 0.0 } unique_books = set() total_pages = 0 total_time = 0.0 for log in logs: unique_books.add(log['book']) total_pages += log['pages'] total_time += log['time'] total_books = len(unique_books) avg_speed = total_pages / total_time if total_time > 0 else 0 return { 'total_books': total_books, 'total_pages': total_pages, 'total_time': round(total_time, 1), 'avg_speed': round(avg_speed, 1) }"},{"question":"from typing import List def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determine if it is possible to partition the array into k non-empty subsets whose sums are all equal. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1], 1) True >>> canPartitionKSubsets([1, 2, 3, 4], 2) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False >>> canPartitionKSubsets([2, 2, 2, 2, 2, 2], 3) True >>> canPartitionKSubsets([10, 10, 10, 10, 10, 10, 10, 10], 4) True","solution":"from typing import List def canPartitionKSubsets(arr: List[int], k: int) -> bool: total_sum = sum(arr) # If the total sum is not divisible by k, we cannot partition into k equal subsets if total_sum % k != 0: return False target_sum = total_sum // k used = [False] * len(arr) def backtrack(start_index, number_of_subsets, current_sum): if number_of_subsets == 0: return True if current_sum == target_sum: return backtrack(0, number_of_subsets - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i + 1, number_of_subsets, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"def maximize_sum(N: int, K: int, A: List[int]) -> int: Maximizes the sum of the array after performing exactly K operations. Args: N (int): The number of elements in the array. K (int): The number of operations to perform. A (list of int): The array of integers. Returns: int: The maximum possible sum of the array. Example: >>> maximize_sum(4, 1, [1, 2, 3, 4]) 14 >>> maximize_sum(3, 2, [-1, 7, 8]) 30","solution":"def maximize_sum(N, K, A): Maximizes the sum of the array after performing exactly K operations. Args: N (int): The number of elements in the array. K (int): The number of operations to perform. A (list of int): The array of integers. Returns: int: The maximum possible sum of the array. total_sum = sum(A) max_element = max(A) # The maximum sum after K operations can be achieved by adding the maximum element to the # sum K times if K > 0, since adding the maximum element to any other element maximizes the increase. if K > 0: total_sum += max_element * K return total_sum"},{"question":"def minimum_total_energy(n: int, temperatures: list[int]) -> int: Given an array of temperatures required for baking each cake in the oven, find the minimum total energy required to bake all the cakes, with one cake being baked at a time. Args: n : int: Number of cakes. temperatures : List[int]: List of required temperatures for each cake. Returns: int: Minimum total energy required to bake all cakes. >>> minimum_total_energy(4, [2, 3, 5, 7]) 17 >>> minimum_total_energy(3, [1, 10, 20]) 31 >>> minimum_total_energy(1, [5]) 5 >>> minimum_total_energy(0, []) 0 >>> minimum_total_energy(5, [2, 2, 2, 2, 2]) 10 >>> minimum_total_energy(3, [1000000000, 2000000000, 3000000000]) 6000000000","solution":"def minimum_total_energy(n, temperatures): Given an array of temperatures required for baking each cake in the oven, find the minimum total energy required to bake all the cakes, with one cake being baked at a time. Args: n : int: Number of cakes. temperatures : List[int]: List of required temperatures for each cake. Returns: int: Minimum total energy required to bake all cakes. # If no cakes, no energy is needed if n == 0: return 0 # Since temperatures are sorted in ascending order, the total energy used is the sum of all temperatures total_energy = sum(temperatures) return total_energy"},{"question":"from typing import List, Tuple def shortest_path_to_exit(n: int, m: int, e: int, s: int, corridors: List[Tuple[int, int]]) -> int: Finds the shortest path from the start room to the exit room in a maze. :param n: Number of rooms. :param m: Number of corridors. :param e: Exit room's id. :param s: Starting room's id. :param corridors: List of tuples, each representing a corridor between two rooms. :return: Minimum number of corridor traversals required to reach the exit room from the starting room. >>> shortest_path_to_exit(6, 7, 5, 1, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5), (4, 6), (3, 4)]) 2 >>> shortest_path_to_exit(4, 2, 3, 1, [(1, 2), (2, 4)]) -1 >>> shortest_path_to_exit(5, 3, 3, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> shortest_path_to_exit(3, 3, 3, 1, [(1, 2), (2, 3), (1, 3)]) 1 >>> shortest_path_to_exit(6, 3, 6, 1, [(1, 2), (2, 3), (3, 4)]) -1","solution":"from collections import deque, defaultdict def shortest_path_to_exit(n, m, e, s, corridors): Finds the shortest path from the start room to the exit room in a maze. :param n: Number of rooms. :param m: Number of corridors. :param e: Exit room's id. :param s: Starting room's id. :param corridors: List of tuples, each representing a corridor between two rooms. :return: Minimum number of corridor traversals required to reach the exit room from the starting room. if s == e: return 0 graph = defaultdict(list) for u, v in corridors: graph[u].append(v) graph[v].append(u) queue = deque([(s, 0)]) visited = set([s]) while queue: current_room, distance = queue.popleft() for neighbor in graph[current_room]: if neighbor == e: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1"},{"question":"def containsCycle(V, E, edges): Function to check if the undirected graph contains a cycle. Arguments: V -- Number of vertices E -- Number of edges edges -- List of edges where each edge is a tuple (u, v) Returns: bool -- True if there is a cycle in the graph, False otherwise Example: >>> containsCycle(5, 5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 1)]) True >>> containsCycle(3, 2, [(0, 1), (1, 2)]) False pass from solution import containsCycle def test_cycle_exists(): V, E = 5, 5 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 1)] assert containsCycle(V, E, edges) == True def test_no_cycle(): V, E = 3, 2 edges = [(0, 1), (1, 2)] assert containsCycle(V, E, edges) == False def test_single_vertex_no_edges(): V, E = 1, 0 edges = [] assert containsCycle(V, E, edges) == False def test_two_vertices_one_edge(): V, E = 2, 1 edges = [(0, 1)] assert containsCycle(V, E, edges) == False def test_three_vertices_cycle(): V, E = 3, 3 edges = [(0, 1), (1, 2), (2, 0)] assert containsCycle(V, E, edges) == True def test_complete_graph_four_vertices(): V, E = 4, 6 edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] assert containsCycle(V, E, edges) == True def test_disconnected_graph(): V, E = 4, 2 edges = [(0, 1), (2, 3)] assert containsCycle(V, E, edges) == False","solution":"def containsCycle(V, E, edges): Function to check if the undirected graph contains a cycle. :param V: Number of vertices :param E: Number of edges :param edges: List of edges where each edge is a tuple (u, v) :return: True if there is a cycle in the graph, False otherwise # Create an adjacency list for the graph adj_list = [[] for _ in range(V)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Helper function for DFS traversal def dfs(v, visited, parent): visited[v] = True for neighbour in adj_list[v]: if not visited[neighbour]: # If the neighbour has not been visited if dfs(neighbour, visited, v): return True elif parent != neighbour: # If the neighbour is visited and not parent of current vertex return True return False # Initialize visited array visited = [False] * V # Perform DFS from each vertex for i in range(V): if not visited[i]: if dfs(i, visited, -1): return True return False"},{"question":"def min_weights(weights, target): Determine the minimum number of weights required to cumulatively measure up to a target weight. This function uses a greedy approach. Parameters: weights (list of int): List of weights available. target (int): The target weight to be measured. Returns: int: The minimum number of weights required to measure the target weight. # Your code here from solution import min_weights def test_min_weights_basic(): assert min_weights([1, 2, 3], 5) == 2 def test_min_weights_exact_match(): assert min_weights([1, 1, 3], 4) == 2 def test_min_weights_impossible(): assert min_weights([1, 2, 5], 7) == 2 def test_min_weights_large_target(): assert min_weights([1, 2, 3, 4, 5, 10], 40) == 4 def test_min_weights_no_solution(): assert min_weights([2, 5, 10], 1) == float('inf') def test_min_weights_zero_target(): assert min_weights([1, 2, 3], 0) == 0","solution":"def min_weights(weights, target): Determine the minimum number of weights required to cumulatively measure up to a target weight. This function uses a greedy approach. Parameters: weights (list of int): List of weights available. target (int): The target weight to be measured. Returns: int: The minimum number of weights required to measure the target weight. weights.sort(reverse=True) num_weights = 0 current_sum = 0 for weight in weights: while current_sum + weight <= target: current_sum += weight num_weights += 1 if current_sum == target: return num_weights if current_sum != target: return float('inf') # target weight cannot be measured with given weights return num_weights"},{"question":"def minimum_barriers(test_cases): Determine the minimum number of barriers needed to block all invading intervals. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of test cases. Each test case is a tuple where the first element is the integer N (number of sections), the second element is the integer M (number of intervals), and the third element is a list of M tuples (L, R) representing the intervals. Returns: List[int]: A list of integers where each integer represents the minimum number of barriers needed for the corresponding test case. >>> test_cases = [(5, 3, [(1, 2), (2, 3), (3, 5)]), (7, 4, [(1, 4), (3, 5), (4, 7), (6, 7)])] >>> minimum_barriers(test_cases) [2, 2] pass def process_input(input_data): Process the input data into a format suitable for the minimum_barriers function. Args: input_data (str): A string of raw input data. Returns: List[Tuple[int, int, List[Tuple[int, int]]]]: A list of test cases parsed from the input data. >>> input_data = \\"2n5 3n1 2n2 3n3 5n7 4n1 4n3 5n4 7n6 7n\\" >>> process_input(input_data) [(5, 3, [(1, 2), (2, 3), (3, 5)]), (7, 4, [(1, 4), (3, 5), (4, 7), (6, 7)])] pass def parse_output(output_data): Parse the output data into a list of integers. Args: output_data (str): A string of raw output data. Returns: List[int]: A list of integers parsed from the output data. >>> output_data = \\"2n2n\\" >>> parse_output(output_data) [2, 2] pass import pytest def test_minimum_barriers(): input_data = \\"2n5 3n1 2n2 3n3 5n7 4n1 4n3 5n4 7n6 7n\\" expected_output = \\"2n2n\\" test_cases = process_input(input_data) results = minimum_barriers(test_cases) expected_results = parse_output(expected_output) assert results == expected_results def test_single_interval(): input_data = \\"1n10 1n5 6n\\" expected_output = \\"1n\\" test_cases = process_input(input_data) results = minimum_barriers(test_cases) expected_results = parse_output(expected_output) assert results == expected_results def test_non_overlapping_intervals(): input_data = \\"1n10 2n1 2n3 4n\\" expected_output = \\"2n\\" test_cases = process_input(input_data) results = minimum_barriers(test_cases) expected_results = parse_output(expected_output) assert results == expected_results def test_fully_overlapping_intervals(): input_data = \\"1n10 3n1 10n2 9n3 8n\\" expected_output = \\"1n\\" test_cases = process_input(input_data) results = minimum_barriers(test_cases) expected_results = parse_output(expected_output) assert results == expected_results def test_large_intervals(): input_data = \\"1n1000000000 2n1 1000000000n500000000 750000000n\\" expected_output = \\"1n\\" test_cases = process_input(input_data) results = minimum_barriers(test_cases) expected_results = parse_output(expected_output) assert results == expected_results","solution":"def minimum_barriers(test_cases): results = [] for case in test_cases: N, M, intervals = case intervals.sort(key=lambda x: x[1]) # Sort intervals by their end point barriers = [] last_barrier = -1 for interval in intervals: L, R = interval if L > last_barrier: barriers.append(R) last_barrier = R results.append(len(barriers)) return results def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 intervals = [] for _ in range(M): L, R = map(int, input_lines[index].split()) intervals.append((L, R)) index += 1 test_cases.append((N, M, intervals)) return test_cases def parse_output(output_data): return list(map(int, output_data.strip().split('n')))"},{"question":"def digit_sum(x: int) -> int: Returns the sum of the digits of the number x. pass def max_digit_sum(L: int, R: int) -> int: Returns the number within the range [L, R] with the maximum digit sum. If multiple numbers have the same digit sum, returns the smallest one. >>> max_digit_sum(10, 20) 19 >>> max_digit_sum(1, 100) 99 from solution import digit_sum, max_digit_sum def test_digit_sum(): assert digit_sum(123) == 6 assert digit_sum(0) == 0 assert digit_sum(999) == 27 def test_max_digit_sum(): assert max_digit_sum(10, 20) == 19 assert max_digit_sum(1, 100) == 99 assert max_digit_sum(50, 60) == 59 assert max_digit_sum(1, 10) == 9 assert max_digit_sum(100, 200) == 199 assert max_digit_sum(1234, 1240) == 1239 def test_max_digit_sum_large_range(): assert max_digit_sum(1, 1000000) == 999999","solution":"def digit_sum(x): Returns the sum of the digits of the number x. return sum(int(digit) for digit in str(x)) def max_digit_sum(L, R): Returns the number within the range [L, R] with the maximum digit sum. If multiple numbers have the same digit sum, returns the smallest one. max_sum = -1 max_number = None for number in range(L, R + 1): current_sum = digit_sum(number) if current_sum > max_sum or (current_sum == max_sum and (max_number is None or number < max_number)): max_sum = current_sum max_number = number return max_number"},{"question":"from typing import List def optimize_delivery(n: int, delivery_times: List[int]) -> List[List[int]]: Distributes orders to delivery persons to minimize the maximum delivery time for each person. Args: n (int): Number of delivery persons. delivery_times (List[int]): List of delivery times for each order. Returns: List[List[int]]: Nested list where each sublist contains the assigned delivery times for each delivery person. Examples: >>> optimize_delivery(3, [5, 2, 8, 3, 7, 4]) [[8, 2], [7, 3], [5, 4]] >>> optimize_delivery(1, [1, 2, 3, 4, 5]) [[5, 4, 3, 2, 1]] >>> optimize_delivery(5, [1, 2, 3]) [[], [], [3], [2], [1]] from solution import optimize_delivery def test_basic_case(): assert optimize_delivery(3, [5, 2, 8, 3, 7, 4]) == [ [8, 2], [7, 3], [5, 4] ] def test_all_equal_delivery_times(): assert optimize_delivery(2, [5, 5, 5, 5]) == [ [5, 5], [5, 5] ] def test_large_delivery_times(): assert optimize_delivery(2, [10, 10, 10, 10]) == [ [10, 10], [10, 10] ] def test_single_delivery_person(): assert optimize_delivery(1, [1, 2, 3, 4, 5]) == [ [5, 4, 3, 2, 1] ] def test_more_delivery_persons_than_orders(): assert optimize_delivery(5, [1, 2, 3]) == [ [3], [2], [1], [], [] ]","solution":"from heapq import heappop, heappush def optimize_delivery(n, delivery_times): Distributes delivery times among delivery persons to minimize the maximum delivery time. Args: n (int): Number of delivery persons. delivery_times (list of int): List of delivery times for each order. Returns: list of list of int: Nested list where each sublist contains the assigned delivery times for each delivery person. # Sort delivery times in descending order delivery_times = sorted(delivery_times, reverse=True) # Initialize min-heap to keep track of the total delivery time of each delivery person delivery_persons = [(0, i) for i in range(n)] # Each delivery person starts with an empty list of delivery times assignments = [[] for _ in range(n)] for time in delivery_times: # Get the delivery person with the smallest total delivery time current_time, person = heappop(delivery_persons) # Assign the order to this delivery person assignments[person].append(time) # Update the total delivery time for this person and push back to the heap heappush(delivery_persons, (current_time + time, person)) return assignments"},{"question":"from collections import defaultdict from typing import List, Tuple def max_distance_between_cities(n: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of cities and the list of roads, calculate the maximum distance between any two cities. >>> max_distance_between_cities(4, [(1, 2, 4), (2, 3, 3), (3, 4, 5)]) 12 >>> max_distance_between_cities(5, [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 5, 3)]) 10 >>> max_distance_between_cities(3, [(1, 2, 1), (2, 3, 1)]) 2","solution":"from collections import defaultdict, deque def max_distance_between_cities(n, roads): def bfs(start): visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True farthest_city = start while queue: city = queue.popleft() for neighbor, dist in graph[city]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[city] + dist queue.append(neighbor) if distance[neighbor] > distance[farthest_city]: farthest_city = neighbor return farthest_city, distance[farthest_city] # Create the graph graph = defaultdict(list) for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) # Perform BFS to find the farthest city from any city (start at city 1) farthest_city, _ = bfs(1) # Perform BFS again from the farthest city found to find the maximum distance _, max_distance = bfs(farthest_city) return max_distance"},{"question":"def process_operations(N: int, operations: List[str]) -> List[int]: Processes the given operations on an NxN grid initially filled with zeros. Parameters: N (int): The size of the grid. operations (list): A list of operation strings. Returns: list: A list of results from \\"SUM\\" operations.","solution":"def process_operations(N, operations): Processes the given operations on an NxN grid initially filled with zeros. Parameters: N (int): The size of the grid. operations (list): A list of operation strings. Returns: list: A list of results from \\"SUM\\" operations. grid = [[0]*N for _ in range(N)] results = [] for operation in operations: parts = operation.split() if parts[0] == \\"SET\\": x, y, val = int(parts[1]), int(parts[2]), int(parts[3]) grid[x][y] = val elif parts[0] == \\"SUM\\": x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += grid[i][j] results.append(total_sum) return results"},{"question":"def second_largest(nums: List[int]) -> int: Returns the second largest number from a list of integers. If there are not enough distinct numbers, returns None. >>> second_largest([4, 6, 2, 1, 9, 9, 63, 566]) == 63 >>> second_largest([3, 3, 3, 3, 3]) == None >>> second_largest([1, 5, 5, 5, 4, 0, 0, 0, -1, -3]) == 4 >>> second_largest([10, 20, 20, 10, 30, 40, 40, 50, 50]) == 40","solution":"def second_largest(nums): Returns the second largest number from a list of integers. If there are not enough distinct numbers, returns None. unique_nums = list(set(nums)) # Remove duplicates unique_nums.sort(reverse=True) # Sort in descending order if len(unique_nums) < 2: return None else: return unique_nums[1]"},{"question":"def find_nth_prime(n: int) -> str: Finds the \`n\`-th prime number and returns a string composed of the first \`n\` characters of the string representation of that prime number. >>> find_nth_prime(1) \\"2\\" >>> find_nth_prime(5) \\"11\\" >>> find_nth_prime(10) \\"29\\" >>> find_nth_prime(9) \\"23\\" >>> find_nth_prime(15) \\"47\\" >>> find_nth_prime(3) \\"5\\"","solution":"def find_nth_prime(n): Finds the \`n\`-th prime number and returns a string composed of first \`n\` characters of the string representation of that prime number. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True count, candidate = 0, 1 while count < n: candidate += 1 if is_prime(candidate): count += 1 prime_str = str(candidate) return prime_str[:n] if n <= len(prime_str) else prime_str"},{"question":"from typing import List, Tuple def max_water_depth(L: int, W: int, V: int) -> float: Calculate the maximum depth of water that can be achieved if the sub-area is adjusted optimally. Parameters: L (int): Length of the field. W (int): Width of the field. V (int): Volume of water to be used for irrigation. Returns: float: Maximum depth of water achievable with precision up to 6 decimal places. >>> max_water_depth(10, 5, 50) 1.000000 >>> max_water_depth(20, 10, 5000) 25.000000 # Your code here def process_datasets(datasets: List[Tuple[int, int, int]]) -> List[float]: Process multiple datasets to calculate the maximum water depth for each dataset. Parameters: datasets (list of tuple): List of tuples, where each tuple contains (L, W, V). Returns: list of float: List of maximum water depths for each dataset. # Your code here # Uncomment the code below for testing your implementation # datasets = [(10, 5, 50), (20, 10, 5000), (0, 0, 0)] # print(process_datasets(datasets))","solution":"def max_water_depth(L, W, V): Calculate the maximum depth of water that can be achieved if the sub-area is adjusted optimally. Parameters: L (int): Length of the field. W (int): Width of the field. V (int): Volume of water to be used for irrigation. Returns: float: Maximum depth of water achievable with precision up to 6 decimal places. return round(V / (L * W), 6) def process_datasets(datasets): Process multiple datasets to calculate the maximum water depth for each dataset. Parameters: datasets (list of tuple): List of tuples, where each tuple contains (L, W, V). Returns: list of float: List of maximum water depths for each dataset. results = [] for L, W, V in datasets: if L == 0 and W == 0 and V == 0: break results.append(max_water_depth(L, W, V)) return results"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, m: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Implementation of Dijkstra's algorithm to find the shortest path in a graph. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): Each tuple (u, v, w) represents a directed edge from node u to node v with weight w. s (int): The starting node. Returns: list[int]: List of minimum time delays to get from the starting node to each other node. If a node is unreachable, the time delay for that node is -1. >>> dijkstra(5, 7, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 2, 3), (2, 4, 1), (3, 4, 9), (4, 5, 4)], 1) [0, 8, 5, 9, 13] >>> dijkstra(4, 4, [(1, 2, 5), (1, 3, 10), (2, 4, 2), (3, 4, 1)], 1) [0, 5, 10, 7]","solution":"import heapq def dijkstra(n, m, edges, s): Implementation of Dijkstra's algorithm to find the shortest path in a graph. Parameters: n (int): Number of nodes. m (int): Number of edges. edges (list of tuples): Each tuple (u, v, w) represents a directed edge from node u to node v with weight w. s (int): The starting node. Returns: list[int]: List of minimum time delays to get from the starting node to each other node. If a node is unreachable, the time delay for that node is -1. # Create adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distances and priority queue distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Convert distances to the required format result = [] for i in range(1, n + 1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def min_operations_to_sort_books(n: int, books: List[int]) -> int: Determine the minimum number of operations required to arrange books in sections to achieve a non-increasing order. Operations: - Swap all books in section i with all books in section j. - Move m books from section i to section j if section i has at least m books. Args: n (int): Number of sections on the shelf. books (List[int]): List of integers representing the number of books in each section. Returns: int: The minimum number of operations required to sort the books in non-increasing order. Examples: >>> min_operations_to_sort_books(5, [4, 3, 5, 2, 1]) 2 >>> min_operations_to_sort_books(3, [10, 20, 30]) 1 >>> min_operations_to_sort_books(6, [6, 5, 4, 3, 2, 1]) 0","solution":"def min_operations_to_sort_books(n, books): Returns the minimum number of operations required to sort the books in non-increasing order. Operations: - Swap all books in section i with all books in section j. - Move m books from section i to section j if section i has at least m books. sorted_books = sorted(books, reverse=True) count = 0 for i in range(n): if books[i] != sorted_books[i]: target_index = books.index(sorted_books[i]) books[i], books[target_index] = books[target_index], books[i] count += 1 return count"},{"question":"def compute_remaining_inventory(n: int, initial_inventory: List[Tuple[str, int]], m: int, sales: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Compute the remaining inventory for each product after the sales transactions. Args: n (int): Number of products in the store. initial_inventory (List[Tuple[str, int]]): List of product names and their initial quantities. m (int): Number of sales transactions. sales (List[Tuple[str, int]]): List of product names and quantities sold. Returns: List[Tuple[str, int]]: Remaining inventory of each product in alphabetical order. >>> compute_remaining_inventory(4, [(\\"apple\\", 100), (\\"banana\\", 150), (\\"orange\\", 120), (\\"pear\\", 90)], 5, [(\\"apple\\", 30), (\\"banana\\", 50), (\\"orange\\", 30), (\\"pear\\", 40), (\\"banana\\", 20)]) [(\\"apple\\", 70), (\\"banana\\", 80), (\\"orange\\", 90), (\\"pear\\", 50)] >>> compute_remaining_inventory(3, [(\\"bread\\", 50), (\\"milk\\", 30), (\\"cheese\\", 20)], 0, []) [(\\"bread\\", 50), (\\"cheese\\", 20), (\\"milk\\", 30)]","solution":"def compute_remaining_inventory(n, initial_inventory, m, sales): inventory = {} # Initialize the inventory for product, quantity in initial_inventory: inventory[product] = quantity # Process the sales for product, quantity in sales: inventory[product] -= quantity # Create a sorted list of products sorted_products = sorted(inventory.keys()) # Generate the output result = [] for product in sorted_products: result.append((product, inventory[product])) return result"},{"question":"def isSpecialPalindrome(S: str) -> int: Check if the string is a \\"Special Palindrome\\". A Special Palindrome is a string that reads the same backwards and forwards and has an even length. >>> isSpecialPalindrome(\\"abba\\") == 1 >>> isSpecialPalindrome(\\"racecar\\") == 0","solution":"def isSpecialPalindrome(S): Returns 1 if the string S is a special palindrome, otherwise returns 0. A special palindrome is defined as a string that reads the same forwards and backwards and has an even length. # Check if the string length is even if len(S) % 2 != 0: return 0 # Check if the string reads the same forwards and backwards if S == S[::-1]: return 1 return 0"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes): Builds a binary tree from list of nodes if not nodes: return None node_dict = {v: TreeNode(v) for v, l, r in nodes} for v, l, r in nodes: node = node_dict[v] if l != 0: node.left = node_dict[l] if r != 0: node.right = node_dict[r] return node_dict[nodes[0][0]] def is_balanced(root): Check if a tree is balanced def check(node): if node is None: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) current_height = 1 + max(left_height, right_height) if abs(left_height - right_height) > 1: return current_height, False return current_height, left_balanced and right_balanced _, balanced = check(root) return balanced def can_transform_to_balanced_tree(n, nodes): Determine if the provided tree can be transformed into a balanced tree using the spell. Args: n : int : the number of nodes in the tree nodes : List[Tuple[int, int, int]] : list of nodes represented as tuples of (value, left child value, right child value) Returns: str : \\"YES\\" if the tree can be transformed into a balanced tree, \\"NO\\" otherwise. >>> can_transform_to_balanced_tree(3, [(1, 2, 3), (2, 0, 0), (3, 0, 0)]) \\"YES\\" >>> can_transform_to_balanced_tree(3, [(1, 0, 2), (2, 0, 3), (3, 0, 0)]) \\"NO\\" def test_case_1(): n = 3 nodes = [(1, 2, 3), (2, 0, 0), (3, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"YES\\" def test_case_2(): n = 3 nodes = [(1, 0, 2), (2, 0, 3), (3, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"NO\\" def test_case_3(): n = 1 nodes = [(1, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"YES\\" def test_case_4(): n = 4 nodes = [(1, 2, 3), (2, 0, 4), (3, 0, 0), (4, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"YES\\" def test_case_5(): n = 5 nodes = [(1, 2, 3), (2, 4, 5), (3, 0, 0), (4, 0, 0), (5, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"YES\\" def test_case_6(): n = 6 nodes = [(1, 0, 2), (2, 3, 0), (3, 0, 4), (4, 5, 0), (5, 0, 6), (6, 0, 0)] assert can_transform_to_balanced_tree(n, nodes) == \\"NO\\"","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(nodes): if not nodes: return None node_dict = {v: TreeNode(v) for v, l, r in nodes} for v, l, r in nodes: node = node_dict[v] if l != 0: node.left = node_dict[l] if r != 0: node.right = node_dict[r] return node_dict[nodes[0][0]] def is_balanced(root): def check(node): if node is None: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) current_height = 1 + max(left_height, right_height) if abs(left_height - right_height) > 1: return current_height, False return current_height, left_balanced and right_balanced _, balanced = check(root) return balanced def can_transform_to_balanced_tree(n, nodes): root = build_tree(nodes) return \\"YES\\" if is_balanced(root) else \\"NO\\""},{"question":"def balance_teams(n: int, k: int, scores: List[int]) -> List[List[int]]: Divides employees into teams of specified size k such that the difference between the highest and lowest score in each team is minimized. >>> balance_teams(6, 2, [10, 20, 30, 40, 50, 60]) [[10, 20], [30, 40], [50, 60]] >>> balance_teams(9, 3, [70, 80, 90, 100, 110, 120, 130, 140, 150]) [[70, 80, 90], [100, 110, 120], [130, 140, 150]] pass def process_datasets(datasets: List[List[int]]) -> List[List[List[int]]]: Processes multiple datasets to balance teams and output the result. >>> process_datasets([[6, 2, 10, 20, 30, 40, 50, 60], [9, 3, 70, 80, 90, 100, 110, 120, 130, 140, 150], [0]]) [[[10, 20], [30, 40], [50, 60]], [[70, 80, 90], [100, 110, 120], [130, 140, 150]]] pass def format_output(results: List[List[List[int]]]) -> List[str]: Formats the output for the balanced teams as required. >>> format_output([[[10, 20], [30, 40], [50, 60]], [[70, 80, 90], [100, 110, 120], [130, 140, 150]]]) [\\"Team 1: 10 20\\", \\"Team 2: 30 40\\", \\"Team 3: 50 60\\", \\"Team 1: 70 80 90\\", \\"Team 2: 100 110 120\\", \\"Team 3: 130 140 150\\"] pass","solution":"def balance_teams(n, k, scores): Divides employees into teams of specified size k such that the difference between the highest and lowest score in each team is minimized. scores.sort() teams = [] for i in range(0, len(scores), k): if len(scores[i:i + k]) == k: teams.append(scores[i:i + k]) return teams def process_datasets(datasets): Processes multiple datasets to balance teams and output the result. results = [] for dataset in datasets: if dataset[0] == 0: break n, k = dataset[0], dataset[1] scores = dataset[2:] teams = balance_teams(n, k, scores) results.append(teams) return results def format_output(results): Formats the output for the balanced teams as required. output = [] for result in results: for idx, team in enumerate(result): output.append(f\\"Team {idx + 1}: \\" + \\" \\".join(map(str, team))) return output"},{"question":"def is_toeplitz(matrix: List[List[int]]) -> str: Determines if the given matrix is a Toeplitz matrix. >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2]]) 'YES' >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 9, 3], [6, 5, 1, 2]]) 'NO'","solution":"def is_toeplitz(matrix): Determines if the given matrix is a Toeplitz matrix. M = len(matrix) N = len(matrix[0]) for i in range(M): for j in range(N): if i > 0 and j > 0 and matrix[i][j] != matrix[i-1][j-1]: return \\"NO\\" return \\"YES\\""},{"question":"def longest_consecutive(nums): Finds the length of the longest consecutive elements sequence in an unsorted array. :param nums: List[int] - the list of unsorted integers :return: int - the length of the longest consecutive elements sequence >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive([]) 0 >>> longest_consecutive([1, 2, 0, 1]) 3 >>> longest_consecutive([1, 3, 5, 2, 4]) 5 >>> longest_consecutive([-2, 0, -3, 2, -1, -1, 1]) 6 >>> longest_consecutive([50, 45, 55, 48, 47, 46]) 4 >>> longest_consecutive([1]) 1 >>> longest_consecutive([10, 30, 20]) 1","solution":"def longest_consecutive(nums): Finds the length of the longest consecutive elements sequence in an unsorted array. :param nums: List[int] - the list of unsorted integers :return: int - the length of the longest consecutive elements sequence if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def switch_row(matrix, row): Switch all the values (flip 0s to 1s and 1s to 0s) in the specified row of the matrix. >>> matrix = [[1, 0, 1], [0, 1, 0], [1, 1, 1]] >>> switch_row(matrix, 1) >>> matrix [[1, 0, 1], [1, 0, 1], [1, 1, 1]] def count_ones_in_row(matrix, row): Count the number of 1s in the specified row of the matrix. >>> matrix = [[1, 0, 1], [0, 1, 0], [1, 1, 1]] >>> count_ones_in_row(matrix, 0) 2 >>> count_ones_in_row(matrix, 1) 1 >>> count_ones_in_row(matrix, 2) 3 def process_queries(matrix, queries): Process the given list of queries on the matrix and return the results for the \\"Count ones in row i\\" queries. >>> matrix = [[1, 0, 1], [0, 1, 0], [1, 1, 1]] >>> queries = [ ... \\"Count ones in row 1\\", ... \\"Switch row 2\\", ... \\"Count ones in row 2\\", ... \\"Switch row 3\\", ... \\"Count ones in row 3\\" ... ] >>> process_queries(matrix, queries) [2, 2, 0]","solution":"def switch_row(matrix, row): Switch all the values (flip 0s to 1s and 1s to 0s) in the specified row of the matrix. matrix[row] = [1 - x for x in matrix[row]] def count_ones_in_row(matrix, row): Count the number of 1s in the specified row of the matrix. return sum(matrix[row]) def process_queries(matrix, queries): Process the given list of queries on the matrix and return the results for the \\"Count ones in row i\\" queries. results = [] for query in queries: parts = query.split() operation = parts[0] row = int(parts[-1]) - 1 # convert to 0-based index if operation == \\"Switch\\": switch_row(matrix, row) elif operation == \\"Count\\": results.append(count_ones_in_row(matrix, row)) return results"},{"question":"def longest_contiguous_subarray(arr: List[int]) -> List[int]: Create a function that takes a list of integers and returns the longest contiguous subarray whose elements are all equal. >>> longest_contiguous_subarray([1, 2, 2, 2, 1, 1, 1, 3, 3, 3, 3]) [3, 3, 3, 3] >>> longest_contiguous_subarray([5, 5, 5, 1, 5, 5]) [5, 5, 5] pass def test_empty_list(): assert longest_contiguous_subarray([]) == [] def test_single_element_list(): assert longest_contiguous_subarray([7]) == [7] assert longest_contiguous_subarray([1]) == [1] def test_all_elements_equal(): assert longest_contiguous_subarray([3, 3, 3, 3]) == [3, 3, 3, 3] def test_varied_elements(): assert longest_contiguous_subarray([1, 2, 2, 2, 1, 1, 1, 3, 3, 3, 3]) == [3, 3, 3, 3] assert longest_contiguous_subarray([5, 5, 5, 1, 5, 5]) == [5, 5, 5] assert longest_contiguous_subarray([1, 1, 2, 2, 3, 3, 3]) == [3, 3, 3] def test_multiple_subarrays_same_length(): assert longest_contiguous_subarray([1, 1, 2, 2, 1, 1]) == [1, 1] def test_end_subarray_longest(): assert longest_contiguous_subarray([2, 3, 3, 3, 3, 1, 1, 1]) == [3, 3, 3, 3] def test_start_subarray_longest(): assert longest_contiguous_subarray([4, 4, 4, 2, 2, 3, 3]) == [4, 4, 4]","solution":"def longest_contiguous_subarray(arr): if not arr: return [] max_len = 1 current_len = 1 element = arr[0] start_index = 0 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len element = arr[i-1] start_index = i - current_len current_len = 1 if current_len > max_len: max_len = current_len element = arr[-1] start_index = len(arr) - current_len return arr[start_index:start_index + max_len]"},{"question":"def is_balanced_binary_tree(tree: List[Union[int, None]]) -> bool: Determine whether a given binary tree is balanced. A binary tree is balanced if, for every node in the tree, the difference in height between its left and right subtrees is at most 1. Args: tree (List[Union[int, None]]): A list representing the binary tree in level order traversal. Returns: bool: True if the tree is balanced, False otherwise. >>> is_balanced_binary_tree([3, 9, 20, None, None, 15, 7]) True >>> is_balanced_binary_tree([1, 2, 2, 3, 3, None, None, 4, 4]) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(index, tree): if index >= len(tree) or tree[index] is None: return None node = TreeNode(tree[index]) node.left = build_tree(2 * index + 1, tree) node.right = build_tree(2 * index + 2, tree) return node def isBalanced(root): def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) current_height = 1 + max(left_height, right_height) is_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) return current_height, is_balanced _, balanced = check(root) return balanced def is_balanced_binary_tree(tree): root = build_tree(0, tree) return isBalanced(root)"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Find all words in the list that match the pattern string. A word matches the pattern if there exists a permutation of letters in the pattern such that the word can be transformed into the pattern by substituting each letter independently. Note that the same letter in pattern must match to the same letter in the word. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\", \\"a\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\", \\"a\\"] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"zzz\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") [\\"abc\\", \\"def\\", \\"ghi\\"] >>> find_and_replace_pattern([\\"abcd\\", \\"effe\\", \\"ghij\\"], \\"abba\\") [\\"effe\\"]","solution":"def find_and_replace_pattern(words, pattern): def match(word): letter_map = {} used_letters = set() for w, p in zip(word, pattern): if p in letter_map: if letter_map[p] != w: return False else: if w in used_letters: return False letter_map[p] = w used_letters.add(w) return True return [word for word in words if match(word)]"},{"question":"def min_comm_range(walkie_ranges: List[int]) -> int: Finds the minimum communication range that ensures all friends stay connected. >>> min_comm_range([5, 3, 6, 2, 4]) == 6 >>> min_comm_range([5, 5, 5, 5, 5]) == 5 >>> min_comm_range([1, 100]) == 100 >>> min_comm_range([2, 3, 1, 6, 4]) == 6 >>> min_comm_range([100]) == 100 >>> min_comm_range([1, 2, 3, 4, 5]) == 5 pass def test_sample_input(): assert min_comm_range([5, 3, 6, 2, 4]) == 6 def test_all_same_range(): assert min_comm_range([5, 5, 5, 5, 5]) == 5 def test_min_max_range(): assert min_comm_range([1, 100]) == 100 def test_different_ranges(): assert min_comm_range([2, 3, 1, 6, 4]) == 6 def test_single_range(): assert min_comm_range([100]) == 100 def test_sorted_input(): assert min_comm_range([1, 2, 3, 4, 5]) == 5","solution":"def min_comm_range(walkie_ranges): Finds the minimum communication range that ensures all friends stay connected. # Sort the walkie talkie ranges walkie_ranges.sort() # The minimum range that ensures all friends are connected is the maximum range in the sorted list. return walkie_ranges[-1]"},{"question":"def special_binary_representation(n: int) -> str: Create a function that converts a given positive integer n into a special binary representation where the digits are alternately 0s and 1s, starting with 1. >>> special_binary_representation(1) '1' >>> special_binary_representation(3) '101' >>> special_binary_representation(5) '10101' >>> special_binary_representation(8) '10101010'","solution":"def special_binary_representation(n): Returns a special binary representation of length n, starting with 1 and alternating with 0s and 1s. result = \\"\\" for i in range(n): if i % 2 == 0: result += '1' else: result += '0' return result"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Determine the maximum value of goods that can be stored in the warehouse without exceeding the capacity. Args: n (int): Number of items. W (int): Capacity of the warehouse. items (list of tuple): List of tuples where each tuple contains weight and value of an item. Returns: int: Maximum total value of goods that can be stored in the warehouse. >>> knapsack(4, 50, [(10, 60), (20, 100), (30, 120), (40, 240)]) == 300 >>> knapsack(3, 0, [(10, 60), (20, 100), (30, 120)]) == 0 >>> knapsack(3, 5, [(10, 60), (20, 100), (30, 120)]) == 0 >>> knapsack(1, 50, [(10, 60)]) == 60 >>> knapsack(1, 5, [(10, 60)]) == 0 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) == 220 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 40)]) == 160","solution":"def knapsack(n, W, items): Returns the maximum total value that can be stored in the warehouse. Args: n (int): Number of items. W (int): Capacity of the warehouse. items (list of tuple): List of tuples where each tuple contains weight and value of an item. Returns: int: Maximum total value of goods that can be stored in the warehouse. dp = [[0 for _ in range(W+1)] for _ in range(n+1)] for i in range(1, n+1): weight, value = items[i-1] for w in range(W+1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][W]"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained from the given string s after performing any sequence of swaps and reversals. >>> lexicographically_smallest_string(\\"cba\\") \\"abc\\" >>> lexicographically_smallest_string(\\"xyz\\") \\"xyz\\" >>> lexicographically_smallest_string(\\"abba\\") \\"aabb\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test cases and returns the lexicographically smallest strings for each input. def parse_input(input_string: str) -> List[str]: Parses the input string into the number of test cases and the test case strings. import pytest def test_lexicographically_smallest_string(): assert lexicographically_smallest_string(\\"cba\\") == \\"abc\\" assert lexicographically_smallest_string(\\"xyz\\") == \\"xyz\\" assert lexicographically_smallest_string(\\"abba\\") == \\"aabb\\" assert lexicographically_smallest_string(\\"edcba\\") == \\"abcde\\" assert lexicographically_smallest_string(\\"a\\") == \\"a\\" assert lexicographically_smallest_string(\\"zxyabci\\") == \\"abcixyz\\" def test_process_test_cases(): test_cases = [\\"cba\\", \\"xyz\\", \\"abba\\"] expected = [\\"abc\\", \\"xyz\\", \\"aabb\\"] assert process_test_cases(test_cases) == expected def test_parse_input(): input_string = \\"3ncbanxyznabba\\" expected = [\\"cba\\", \\"xyz\\", \\"abba\\"] assert parse_input(input_string) == expected def test_integration(): input_string = \\"3ncbanxyznabba\\" test_cases = parse_input(input_string) result = process_test_cases(test_cases) expected = [\\"abc\\", \\"xyz\\", \\"aabb\\"] assert result == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def lexicographically_smallest_string(s): Returns the lexicographically smallest string that can be obtained from the given string s after performing any sequence of swaps and reversals. return ''.join(sorted(s)) def process_test_cases(test_cases): Processes a list of test cases and returns the lexicographically smallest strings for each input. return [lexicographically_smallest_string(tc) for tc in test_cases] def parse_input(input_string): Parses the input string into the number of test cases and the test case strings. lines = input_string.strip().split('n') T = int(lines[0]) test_cases = lines[1:T+1] return test_cases"},{"question":"def maximize_sequence(n: int, arr: List[int]) -> List[int]: Given a list of N integers, determine the final sequence after manipulating the list by swapping adjacent integers where the sum of the integers is even to maximize their final value according to the rule-based manipulations. >>> maximize_sequence(5, [1, 2, 3, 4, 5]) [4, 5, 2, 3, 1] >>> maximize_sequence(6, [4, 7, 2, 8, 5, 3]) [8, 7, 4, 5, 2, 3] >>> maximize_sequence(4, [8, 2, 6, 4]) [8, 6, 4, 2] >>> maximize_sequence(4, [9, 7, 11, 5]) [11, 9, 7, 5] >>> maximize_sequence(3, [10, 8, 6]) [10, 8, 6]","solution":"def maximize_sequence(n, arr): # Sort the array in descending order arr.sort(reverse=True) # Separate the even and odd numbers as we can only swap adjacent elements if their sum is even even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] # Combine alternating even and odd numbers from the highest possible, to maximize sum of adjacent swaps i, j = 0, 0 result = [] while i < len(even) and j < len(odd): result.append(even[i]) result.append(odd[j]) i += 1 j += 1 # Append remaining even or odd numbers while i < len(even): result.append(even[i]) i += 1 while j < len(odd): result.append(odd[j]) j += 1 return result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = maximize_sequence(n, arr) print(\\" \\".join(map(str, result)))"},{"question":"def sum_of_numbers_in_string(s: str) -> int: Returns the sum of all numbers in the given string. >>> sum_of_numbers_in_string(\\"abc 123 def 456\\") 579 >>> sum_of_numbers_in_string(\\"no numbers here\\") 0 >>> sum_of_numbers_in_string(\\"10 apples, 20 oranges, and 30 bananas\\") 60","solution":"def sum_of_numbers_in_string(s): Returns the sum of all numbers in the given string. # Split the string into a list of words words = s.split() # Initialize the sum total = 0 # Iterate through each word for word in words: # If the word is a number, add it to the sum if word.lstrip('-').isdigit(): total += int(word) return total"},{"question":"def lexicographically_smallest_subsequence(S: str, N: int) -> str: Returns the lexicographically smallest subsequence of length N from string S. >>> lexicographically_smallest_subsequence('abcdef', 3) 'abc' >>> lexicographically_smallest_subsequence('zyxabc', 4) 'xabc' def test_smallest_subsequence_basic(): assert smallest_subsequence('abcdef', 3) == 'abc' def test_smallest_subsequence_from_unordered(): assert lexicographically_smallest_subsequence('zyxabc', 4) == 'xabc' def test_subsequence_with_repeated_chars(): assert lexicographically_smallest_subsequence('acacacac', 4) == 'aaaa' def test_subsequence_length_equals_string_length(): assert lexicographically_smallest_subsequence('helloworld', 10) == 'helloworld' def test_single_character(): assert lexicographically_smallest_subsequence('a', 1) == 'a' def test_subsequence_from_end(): assert lexicographically_smallest_subsequence('xyzabc', 3) == 'abc'","solution":"def lexicographically_smallest_subsequence(S, N): Returns the lexicographically smallest subsequence of length N from string S. result = [] stack = [] for i, ch in enumerate(S): while stack and ch < stack[-1] and len(stack) + len(S) - i > N: stack.pop() stack.append(ch) return ''.join(stack[:N])"},{"question":"def nthTermOfSequence(n: int) -> int: Returns the nth term of the sequence defined as: a1 = 1, an = a(n-1) * n for n > 1 >>> nthTermOfSequence(3) 6 >>> nthTermOfSequence(5) 120 >>> nthTermOfSequence(1) 1","solution":"def nthTermOfSequence(n): Returns the nth term of the sequence defined as: a1 = 1, an = a(n-1) * n for n > 1 term = 1 for i in range(2, n + 1): term *= i return term"},{"question":"def min_steps(grid, N, M): Returns the minimum number of steps required to navigate from the top-left corner to the bottom-right corner. Returns -1 if it's not possible. Args: grid (List[List[str]]): The grid representation where '.' is an empty cell and '#' is an obstacle. N (int): Number of rows. M (int): Number of columns. Returns: int: The minimum number of steps to navigate to the bottom-right corner, or -1 if not possible. def solve(T, test_cases): Solves multiple test cases to find the minimum steps required for each grid. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[str]]]]): List containing test cases where each test case is a tuple containing the number of rows, the number of columns, and the grid itself. Returns: List[int]: List containing the results for each test case. Examples: >>> solve(3, [(3, 3, ['...', '.#.', '...']), ... (4, 4, ['....', '.#..', '..#.', '....']), ... (2, 2, ['.#', '#.'])]) [4, 6, -1] >>> >>> solve(1, [(1, 1, ['.'])]) [0] >>> >>> solve(1, [(1, 1, ['#'])]) [-1] >>>","solution":"from collections import deque def min_steps(grid, N, M): Returns the minimum number of steps required to navigate from the top-left corner to the bottom-right corner. Returns -1 if it's not possible. if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 # Directions for movements: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # Check if we've reached the bottom-right corner if row == N - 1 and col == M - 1: return steps # Explore neighbours for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < M and grid[new_row][new_col] == '.' and (new_row, new_col) not in visited: queue.append((new_row, new_col, steps + 1)) visited.add((new_row, new_col)) return -1 def solve(T, test_cases): results = [] for i in range(T): N, M, grid = test_cases[i] result = min_steps(grid, N, M) results.append(result) return results"},{"question":"from typing import List class HouseBeauty: def __init__(self, beautyLevels: List[int]): Initializes the object with the list of beauty levels for the houses. self.beautyLevels = beautyLevels def getMaxBeautyLevel(self) -> int: Returns the maximum beauty level that can be achieved by selecting non-adjacent houses. >>> houseBeauty1 = HouseBeauty([2, 7, 9, 3, 1]) >>> houseBeauty1.getMaxBeautyLevel() 12 >>> houseBeauty2 = HouseBeauty([3, 2, 5, 10, 7]) >>> houseBeauty2.getMaxBeautyLevel() 15","solution":"from typing import List class HouseBeauty: def __init__(self, beautyLevels: List[int]): self.beautyLevels = beautyLevels def getMaxBeautyLevel(self) -> int: n = len(self.beautyLevels) if n == 0: return 0 if n == 1: return self.beautyLevels[0] # Initialize the array to store the max sums max_beauty = [0] * n max_beauty[0] = self.beautyLevels[0] max_beauty[1] = max(self.beautyLevels[0], self.beautyLevels[1]) for i in range(2, n): max_beauty[i] = max(max_beauty[i-1], max_beauty[i-2] + self.beautyLevels[i]) return max_beauty[n-1]"},{"question":"from typing import List def count_islands(N: int, grid: List[List[str]]) -> int: Determine the number of distinct islands in an NxN grid. An island is defined as a group of connected land cells ('L') that are connected 4-directionally (vertical or horizontal). Water cells are represented by 'W'. >>> count_islands(4, [ ... [\\"L\\", \\"L\\", \\"W\\", \\"W\\"], ... [\\"L\\", \\"W\\", \\"W\\", \\"W\\"], ... [\\"W\\", \\"W\\", \\"L\\", \\"L\\"], ... [\\"W\\", \\"W\\", \\"L\\", \\"L\\"] ... ]) 2 >>> count_islands(3, [ ... [\\"L\\", \\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\", \\"L\\"], ... [\\"L\\", \\"L\\", \\"L\\"] ... ]) 1 >>> count_islands(5, [ ... [\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"], ... [\\"W\\", \\"L\\", \\"W\\", \\"L\\", \\"W\\"], ... [\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"], ... [\\"W\\", \\"L\\", \\"W\\", \\"L\\", \\"W\\"], ... [\\"L\\", \\"W\\", \\"L\\", \\"W\\", \\"L\\"] ... ]) 13","solution":"def count_islands(N, grid): def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= N or grid[x][y] != 'L': return grid[x][y] = 'V' # Mark as visited # Move in all 4 possible directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) island_count = 0 for i in range(N): for j in range(N): if grid[i][j] == 'L': island_count += 1 dfs(i, j) return island_count"},{"question":"def max_sum_subgrid(grid): Find the maximum sum of any sub-grid in the given grid. Parameters: grid (List[List[int]]): A 2D list representing the grid filled with non-negative integers. Returns: int: The maximum sum of any sub-grid in the grid. >>> max_sum_subgrid([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_sum_subgrid([ ... [1, 2, 1], ... [2, 2, 2], ... [3, 2, 1] ... ]) 16 from typing import List # Test cases to validate the solution def test_max_sum_subgrid_1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_sum_subgrid(grid) == 45 def test_max_sum_subgrid_2(): grid = [ [1, 2, 1], [2, 2, 2], [3, 2, 1] ] assert max_sum_subgrid(grid) == 16 def test_max_sum_subgrid_3(): grid = [ [0, 2, 3], [4, 5, 6], [7, 0, 9] ] assert max_sum_subgrid(grid) == 36 def test_max_sum_subgrid_4(): grid = [ [1] ] assert max_sum_subgrid(grid) == 1 def test_max_sum_subgrid_5(): grid = [ [5, 1], [2, 3] ] assert max_sum_subgrid(grid) == 11","solution":"def max_sum_subgrid(grid): Function to find the maximum sum of any sub-grid in the given grid. N = len(grid) # Number of rows M = len(grid[0]) # Number of columns # Step 1: Compute the prefix sum matrix prefix = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix[i][j] = ( grid[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] ) # Step 2: Find the maximum sum of any sub-grid max_sum = float('-inf') for r1 in range(1, N + 1): for r2 in range(r1, N + 1): for c1 in range(1, M + 1): for c2 in range(c1, M + 1): current_sum = (prefix[r2][c2] - prefix[r1 - 1][c2] - prefix[r2][c1 - 1] + prefix[r1 - 1][c1 - 1]) max_sum = max(max_sum, current_sum) return max_sum # Wrapper to read input from console if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) M = int(data[1]) grid = [] idx = 2 for i in range(N): row = list(map(int, data[idx:idx+M])) grid.append(row) idx += M print(max_sum_subgrid(grid))"},{"question":"def is_valid_sequence(movements: str) -> bool: Determines if a given sequence of commands will return RoboBuddy to the starting point (0, 0). >>> is_valid_sequence(\\"LRUD\\") == True >>> is_valid_sequence(\\"LLRR\\") == True >>> is_valid_sequence(\\"UUUU\\") == False >>> is_valid_sequence(\\"UDUDUD\\") == True >>> is_valid_sequence(\\"RLUDLR\\") == True","solution":"def is_valid_sequence(movements): Determines if a given sequence of commands will return RoboBuddy to the starting point (0, 0). :param movements: A string containing the commands for RoboBuddy. :return: True if the sequence returns RoboBuddy to the starting point, False otherwise. x, y = 0, 0 for move in movements: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return x == 0 and y == 0"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node or node.value == value: return node if value < node.value: return self._find(node.left, value) return self._find(node.right, value) def find_successor(self, value): Find the successor of a given node value in the BST. >>> bst.insert(20) >>> bst.insert(8) >>> bst.insert(22) >>> bst.insert(4) >>> bst.insert(12) >>> bst.insert(10) >>> bst.insert(14) >>> bst.find_successor(8) 10 # Your implementation here def find_successor_in_bst(n, values, target): bst = BST() for value in values: bst.insert(value) return bst.find_successor(target) def test_example_1(): assert find_successor_in_bst(7, [20, 8, 22, 4, 12, 10, 14], 8) == 10 def test_example_2(): assert find_successor_in_bst(5, [15, 10, 20, 8, 12], 15) == 20 def test_example_3(): assert find_successor_in_bst(3, [3, 2, 1], 3) == \\"null\\" def test_target_is_max(): assert find_successor_in_bst(4, [2, 3, 4, 6], 6) == \\"null\\" def test_single_node(): assert find_successor_in_bst(1, [42], 42) == \\"null\\" def test_right_child(): assert find_successor_in_bst(3, [10, 5, 15], 10) == 15 def test_complex_case(): assert find_successor_in_bst(9, [20, 9, 25, 5, 12, 15, 30, 10, 7], 10) == 12","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BST: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left: self._insert(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert(node.right, value) else: node.right = TreeNode(value) def find(self, value): return self._find(self.root, value) def _find(self, node, value): if not node or node.value == value: return node if value < node.value: return self._find(node.left, value) return self._find(node.right, value) def find_successor(self, value): node = self.find(value) if not node: return \\"null\\" if node.right: return self._minValueNode(node.right).value successor = None ancestor = self.root while ancestor != node: if node.value < ancestor.value: successor = ancestor ancestor = ancestor.left else: ancestor = ancestor.right return successor.value if successor else \\"null\\" def _minValueNode(self, node): current = node while current.left is not None: current = current.left return current def find_successor_in_bst(n, values, target): bst = BST() for value in values: bst.insert(value) return bst.find_successor(target) # Example usage: # n = 7 # values = [20, 8, 22, 4, 12, 10, 14] # target = 8 # print(find_successor_in_bst(n, values, target)) # Output: 10"},{"question":"def first_non_repeated_character(s: str) -> str: Returns the first non-repeated character in the given string. >>> first_non_repeated_character(\\"swiss\\") 'w' >>> first_non_repeated_character(\\"a\\") 'a' >>> first_non_repeated_character(\\"aabbcc\\") None >>> first_non_repeated_character(\\"stress\\") 't' >>> first_non_repeated_character(\\"\\") None >>> first_non_repeated_character(\\"abcdef\\") 'a'","solution":"def first_non_repeated_character(s): Returns the first non-repeated character in the given string. # Dictionary to keep the count of each character char_count = {} # First pass to count all characters for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char # If there's no non-repeated character return None"},{"question":"def calculate_time_durations(input: List[str]) -> List[str]: Calculate the minimum time duration encoded by the given expression in Altrunes's notation. >>> calculate_time_durations([ \\"3\\", \\"blip 5\\", \\"blink 15\\", \\"bloop 30\\", \\"blip-blink\\", \\"3\\", \\"astro 10\\", \\"flux 20\\", \\"tempo 50\\", \\"astro-flux\\", \\"2\\", \\"tick 1\\", \\"tock 2\\", \\"tick-tick-tock\\", \\"4\\", \\"quick 1\\", \\"brown 2\\", \\"fox 4\\", \\"jump 8\\", \\"quick-brown-fox\\", \\"0\\" ]) [\\"Case 1: 20\\", \\"Case 2: 30\\", \\"Case 3: 4\\", \\"Case 4: 7\\"]","solution":"def calculate_time_durations(input): result = [] case_number = 1 while input: N = int(input.pop(0)) if N == 0: break word_dict = {} for _ in range(N): w, t = input.pop(0).split() word_dict[w] = int(t) encoded_duration = input.pop(0) min_time_duration = 0 words = encoded_duration.split('-') for word in words: min_time_duration += word_dict[word] result.append(f\\"Case {case_number}: {min_time_duration}\\") case_number += 1 return result"},{"question":"def select_dishes(n, k, votes, names): Select exactly 'k' dishes that have received the maximum votes. If there are multiple sets of 'k' dishes with the same vote count, select the lexicographically smallest set. :param n: int - The number of dishes :param k: int - The number of dishes to select :param votes: List[int] - The vote counts for each dish :param names: List[str] - The names of the dishes :return: List[str] - The selected dish names in lexicographical order >>> select_dishes(5, 3, [4, 2, 3, 6, 1], [\\"pasta\\", \\"curry\\", \\"salad\\", \\"burger\\", \\"fries\\"]) [\\"burger\\", \\"pasta\\", \\"salad\\"] >>> select_dishes(4, 2, [1, 3, 3, 2], [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) [\\"banana\\", \\"cherry\\"]","solution":"def select_dishes(n, k, votes, names): Selects exactly 'k' dishes that have received the maximum votes. If there are multiple sets of 'k' dishes with the same vote count, it prefers the lexicographically smallest set. # Combine the names and votes into a list of tuples and sort by votes and then lexicographically by names dishes = sorted(zip(votes, names), key=lambda x: (-x[0], x[1])) # Extract the top k dish names selected_dishes = [dishes[i][1] for i in range(k)] # Sort the selected dishes lexicographically selected_dishes.sort() return selected_dishes"},{"question":"def flip_subrectangle(m: int, n: int, k: int, queries: List[Tuple[int, int, int, int]]) -> List[List[int]]: Flips subrectangles in a m x n grid based on given queries and outputs the final grid. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. k (int): number of queries. queries (List[Tuple[int, int, int, int]]): list of queries to flip subrectangles. Returns: List[List[int]]: the final state of the grid after performing all the queries. >>> flip_subrectangle(3, 3, 2, [(1, 2, 2, 3), (2, 1, 3, 2)]) [[0, 1, 1], [1, 0, 1], [1, 1, 0]] >>> flip_subrectangle(2, 2, 1, [(1, 1, 2, 2)]) [[1, 1], [1, 1]] pass from solution import flip_subrectangle def test_example_case(): m, n, k = 3, 3, 2 queries = [(1, 2, 2, 3), (2, 1, 3, 2)] expected_output = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert flip_subrectangle(m, n, k, queries) == expected_output def test_single_query(): m, n, k = 2, 2, 1 queries = [(1, 1, 2, 2)] expected_output = [ [1, 1], [1, 1] ] assert flip_subrectangle(m, n, k, queries) == expected_output def test_no_queries(): m, n, k = 2, 2, 0 queries = [] expected_output = [ [0, 0], [0, 0] ] assert flip_subrectangle(m, n, k, queries) == expected_output def test_flipping_same_area_twice(): m, n, k = 2, 2, 2 queries = [(1, 1, 2, 2), (1, 1, 2, 2)] expected_output = [ [0, 0], [0, 0] ] assert flip_subrectangle(m, n, k, queries) == expected_output def test_large_grid_small_flips(): m, n, k = 4, 4, 2 queries = [(1, 1, 2, 2), (3, 3, 4, 4)] expected_output = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ] assert flip_subrectangle(m, n, k, queries) == expected_output","solution":"def flip_subrectangle(m, n, k, queries): grid = [[0] * n for _ in range(m)] for query in queries: r1, c1, r2, c2 = query for i in range(r1 - 1, r2): for j in range(c1 - 1, c2): grid[i][j] = 1 - grid[i][j] return grid"},{"question":"def min_cities_to_visit(n: int, k: int, attractions: List[int]) -> int: Determine the minimum number of cities needed to visit to accumulate at least k attractions. Parameters: n (int): The number of cities. k (int): The required minimum number of attractions. attractions (list of int): List of integers where each integer represents the number of attractions in each city. Returns: int: Minimum number of cities to visit to meet or exceed the required number of attractions, or -1 if not possible. >>> min_cities_to_visit(5, 10, [4, 2, 5, 3, 6]) 2 >>> min_cities_to_visit(3, 15, [4, 6, 7]) 3 >>> min_cities_to_visit(4, 5, [1, 1, 1, 1]) -1 >>> min_cities_to_visit(1, 3, [5]) 1 >>> min_cities_to_visit(3, 7, [2, 2, 2]) -1 >>> min_cities_to_visit(5, 12, [3, 4, 5, 1, 2]) 3 >>> min_cities_to_visit(2, 9, [3, 7]) 2","solution":"def min_cities_to_visit(n, k, attractions): Determine the minimum number of cities needed to visit to accumulate at least k attractions. Parameters: n (int): The number of cities. k (int): The required minimum number of attractions. attractions (list of int): List of integers where each integer represents the number of attractions in each city. Returns: int: Minimum number of cities to visit to meet or exceed the required number of attractions, or -1 if not possible. # Sort attractions in descending order to consider cities with most attractions first attractions.sort(reverse=True) total_attractions = 0 city_count = 0 for attraction in attractions: total_attractions += attraction city_count += 1 if total_attractions >= k: return city_count # If total attractions are less than required after visiting all cities return -1"},{"question":"def evenly_spaced_watchtowers(datasets): Given a list of tuples representing (C, k) for multiple datasets, return the distances between adjacent watchtowers for each dataset. pass def parse_input(input_str): Parse the given input string of multiple datasets into a list of (C, k) tuples. pass # Unit tests from solution import evenly_spaced_watchtowers, parse_input def test_evenly_spaced_watchtowers(): input_data = \\"100 4n200 5n360 6n0n\\" datasets = parse_input(input_data) results = evenly_spaced_watchtowers(datasets) assert results == [\\"25 25 25 25\\", \\"40 40 40 40 40\\", \\"60 60 60 60 60 60\\"] def test_evenly_spaced_watchtowers_single(): input_data = \\"50 2n0n\\" datasets = parse_input(input_data) results = evenly_spaced_watchtowers(datasets) assert results == [\\"25 25\\"] def test_evenly_spaced_watchtowers_max_values(): input_data = \\"10000 100n0n\\" datasets = parse_input(input_data) results = evenly_spaced_watchtowers(datasets) assert results == [\\"100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100\\"] def test_evenly_spaced_watchtowers_irregular(): input_data = \\"9999 3n3333 4n0n\\" datasets = parse_input(input_data) results = evenly_spaced_watchtowers(datasets) assert results == [\\"3333 3333 3333\\", \\"833 833 833 833\\"] def test_parse_input(): input_str = \\"100 4n200 5n360 6n0n\\" expected_output = [(100, 4), (200, 5), (360, 6)] assert parse_input(input_str) == expected_output def test_parse_input_special_cases(): input_str = \\"0n\\" expected_output = [] assert parse_input(input_str) == expected_output","solution":"def evenly_spaced_watchtowers(datasets): Given a list of tuples representing (C, k) for multiple datasets, returns the distances between adjacent watchtowers for each dataset. results = [] for C, k in datasets: if C == 0 and k == 0: break distance = C // k results.append(' '.join([str(distance)] * k)) return results def parse_input(input_str): Parse the given input string of multiple datasets into a list of (C, k) tuples. lines = input_str.strip().split('n') datasets = [tuple(map(int, line.split())) for line in lines if line != '0'] return datasets"},{"question":"def canFinishHiking(N: int, heights: List[int], D: int) -> bool: Determines if it is possible to complete the hiking trip from the first to the last point within the given altitude threshold. :param N: The number of points on the hiking trail. :param heights: The list of altitudes of the points on the trail. :param D: The maximum allowable altitude difference between consecutive points. :return: True if it is possible to complete the hike from start to finish, False otherwise. >>> canFinishHiking(5, [1, 2, 4, 7, 10], 3) == True >>> canFinishHiking(4, [3, 8, 5, 2], 4) == False pass # Unit tests def test_canFinishHiking_example1(): assert canFinishHiking(5, [1, 2, 4, 7, 10], 3) == True def test_canFinishHiking_example2(): assert canFinishHiking(4, [3, 8, 5, 2], 4) == False def test_canFinishHiking_largeDifference(): assert canFinishHiking(5, [1, 10, 20, 30, 40], 15) == True def test_canFinishHiking_noDifference(): assert canFinishHiking(4, [5, 5, 5, 5], 0) == True def test_canFinishHiking_allEqualHeights(): assert canFinishHiking(5, [10, 10, 10, 10, 10], 1) == True def test_canFinishHiking_decreasingHeights(): assert canFinishHiking(3, [10, 7, 1], 5) == False def test_canFinishHiking_noPoints(): assert canFinishHiking(1, [5], 0) == True def test_canFinishHiking_equalToThreshold(): assert canFinishHiking(4, [1, 4, 7, 10], 3) == True def test_canFinishHiking_underThreshold(): assert canFinishHiking(4, [1, 5, 7, 9], 5) == True def test_canFinishHiking_edgeCase(): assert canFinishHiking(2, [1, 1000000000], 999999999) == True","solution":"def canFinishHiking(N, heights, D): Checks if it is possible to finish the hike from start to finish. :param N: Integer representing the number of points on the trail. :param heights: List of integers representing the altitude at each point. :param D: Integer representing the maximum allowable altitude difference between consecutive points. :return: True if it's possible to finish the hike, False otherwise. for i in range(1, N): if abs(heights[i] - heights[i-1]) > D: return False return True"},{"question":"from typing import List def combine(nums: List[int], k: int) -> List[List[int]]: Given an integer array \`nums\`, return the list of all possible \`k\`-element subsets (combinations) of the array. The solution must not contain duplicate combinations and is not required to be in sorted order. >>> combine([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> combine([1, 2, 3, 4], 3) [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]","solution":"from typing import List def combine(nums: List[int], k: int) -> List[List[int]]: def backtrack(start, path): if len(path) == k: result.append(path.copy()) return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() result = [] backtrack(0, []) return result"},{"question":"from typing import List def search_pattern(pattern: str, file_lines: List[str]) -> List[str]: This function takes a string pattern and a list of strings file_lines, and returns a list of lines from file_lines that contain the pattern, case-insensitive. >>> pattern = \\"search\\" >>> file_lines = [ >>> \\"This is a simple search example.\\", >>> \\"Just another line in the file.\\", >>> \\"Trying to test the search function.\\", >>> \\"SEARCH should be case insensitive.\\", >>> \\"No match here.\\" >>> ] >>> search_pattern(pattern, file_lines) [ \\"This is a simple search example.\\", \\"Trying to test the search function.\\", \\"SEARCH should be case insensitive.\\" ]","solution":"from typing import List def search_pattern(pattern: str, file_lines: List[str]) -> List[str]: This function takes a string pattern and a list of strings file_lines, and returns a list of lines from file_lines that contain the pattern, case-insensitive. pattern = pattern.lower() result = [line for line in file_lines if pattern in line.lower()] return result"},{"question":"def find_maximum_spanning_tree(N, M, edges): Returns the weight of the maximum spanning tree for a given graph with N nodes and M edges. Parameters: N (int): Number of nodes. M (int): Number of edges. edges (list of tuples): Each tuple contains three integers (u, v, w) denoting an edge between nodes u and v with weight w. Returns: int: Total weight of maximum spanning tree. pass def test_find_maximum_spanning_tree(): assert find_maximum_spanning_tree(4, 5, [(1, 2, 3), (1, 3, 4), (4, 2, 1), (3, 4, 2), (1, 4, 5)]) == 12 assert find_maximum_spanning_tree(3, 3, [(1, 2, 5), (1, 3, 4), (2, 3, 1)]) == 9 assert find_maximum_spanning_tree(5, 6, [(1, 2, 6), (2, 3, 6), (4, 2, 6), (3, 4, 8), (5, 4, 10), (1, 5, 5)]) == 30 assert find_maximum_spanning_tree(2, 1, [(1, 2, 10)]) == 10 assert find_maximum_spanning_tree(3, 2, [(1, 2, 4), (2, 3, 5)]) == 9 if __name__ == \\"__main__\\": test_find_maximum_spanning_tree() print(\\"All tests passed.\\")","solution":"def find_maximum_spanning_tree(N, M, edges): Returns the weight of the maximum spanning tree for a given graph with N nodes and M edges. Parameters: N (int): Number of nodes. M (int): Number of edges. edges (list of tuples): Each tuple contains three integers (u, v, w) denoting an edge between nodes u and v with weight w. Returns: int: Total weight of maximum spanning tree. # Sort edges in descending order based on weights edges.sort(key=lambda x: x[2], reverse=True) # Union-Find (Disjoint Set Union) to detect cycles parent = [i for i in range(N)] rank = [0] * N def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False max_spanning_tree_weight = 0 edges_added = 0 for u, v, w in edges: if union(u - 1, v - 1): # Adjusting for zero-based index max_spanning_tree_weight += w edges_added += 1 if edges_added == N - 1: # If we already added N-1 edges, we are done break return max_spanning_tree_weight"},{"question":"def optimal_delivery_point(n, delivery_points): Determines the optimal delivery start point to minimize total delivery time to all other delivery points, and in case of a tie, chooses the point with the smallest row number, and if still tied, the smallest column number. :param n: Number of delivery points :param delivery_points: List of tuples representing the coordinates of the delivery points :returns: Tuple representing the optimal delivery point coordinates >>> optimal_delivery_point(1, [(2, 3)]) (2, 3) >>> optimal_delivery_point(5, [(1, 2), (3, 4), (5, 6), (2, 1), (4, 3)]) (3, 4) >>> optimal_delivery_point(4, [(1, 1), (1, 2), (2, 1), (2, 2)]) (1, 1) >>> optimal_delivery_point(4, [(1, 1), (1, 1000000), (1000000, 1), (1000000, 1000000)]) (1, 1) >>> optimal_delivery_point(3, [(10, 10), (20, 30), (20, 10)]) (20, 10) >>> optimal_delivery_point(3, [(1, 1), (1, 100), (100, 1)]) (1, 1) >>> optimal_delivery_point(3, [(10, 20), (20, 30), (30, 40)]) (20, 30) pass","solution":"def optimal_delivery_point(n, delivery_points): Determines the optimal delivery start point to minimize total delivery time to all other delivery points, and in case of a tie, chooses the point with the smallest row number, and if still tied, the smallest column number. :param n: Number of delivery points :param delivery_points: List of tuples representing the coordinates of the delivery points :returns: Tuple representing the optimal delivery point coordinates if n == 1: return delivery_points[0] median_x = sorted([point[0] for point in delivery_points])[n//2] median_y = sorted([point[1] for point in delivery_points])[n//2] optimal_point = (median_x, median_y) min_total_distance = float('inf') for x, y in delivery_points: total_distance = sum(abs(x - xi) + abs(y - yi) for xi, yi in delivery_points) if (total_distance < min_total_distance or (total_distance == min_total_distance and (x < optimal_point[0] or (x == optimal_point[0] and y < optimal_point[1])))): min_total_distance = total_distance optimal_point = (x, y) return optimal_point"},{"question":"def find_top_salesperson(sales_data: List[Tuple[int, int]]) -> int: Determine which salesperson will receive a special bonus based on the highest number of distinct sales. Args: sales_data (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers: the ID of the salesperson and the ID of the product sold. Returns: int: The ID of the salesperson with the highest number of distinct sales. If there is a tie, returns the smallest ID. Example: >>> find_top_salesperson([(1, 101), (1, 102), (2, 101), (2, 103), (2, 104)]) 2 >>> find_top_salesperson([(1, 201), (2, 201), (3, 201), (3, 202), (1, 202), (2, 202), (3, 203)]) 3","solution":"def find_top_salesperson(sales_data): from collections import defaultdict # Dictionary to keep track of products each salesperson has sold salesperson_products = defaultdict(set) for salesperson_id, product_id in sales_data: salesperson_products[salesperson_id].add(product_id) # Determine the salesperson with the highest number of distinct sales max_distinct_sales = -1 top_salesperson = -1 for salesperson, products in salesperson_products.items(): distinct_sales = len(products) # Check for the highest count of distinct products # Break ties by preferring the smaller salesperson ID if distinct_sales > max_distinct_sales or (distinct_sales == max_distinct_sales and (top_salesperson == -1 or salesperson < top_salesperson)): max_distinct_sales = distinct_sales top_salesperson = salesperson return top_salesperson # Example usage: # M, sales_data = 5, [(1, 101), (1, 102), (2, 101), (2, 103), (2, 104)] # print(find_top_salesperson(sales_data)) # Output should be 2"},{"question":"def minimum_garden_dimensions(k: int) -> Tuple[int, int]: Given the number of trees, returns the minimum width and height of the garden required such that no two trees are in a straight line (horizontally, vertically, or diagonally). >>> minimum_garden_dimensions(2) (2, 2) >>> minimum_garden_dimensions(3) (3, 3) pass","solution":"def minimum_garden_dimensions(k): Given the number of trees, returns the minimum width and height of the garden required such that no two trees are in a straight line (horizontally, vertically, or diagonally). return k, k"},{"question":"def does_return_to_origin(movements: str) -> str: Determines if the player returns to the origin after completing all movements. Parameters: movements (str): The string of movements consisting of 'U', 'D', 'L', and 'R'. Returns: str: \\"Yes\\" if the player returns to the origin, otherwise \\"No\\". >>> does_return_to_origin(\\"UDLR\\") \\"Yes\\" >>> does_return_to_origin(\\"U\\") \\"No\\" >>> does_return_to_origin(\\"LLRRUUDD\\") \\"Yes\\" >>> does_return_to_origin(\\"UUUURRRR\\") \\"No\\"","solution":"def does_return_to_origin(movements): Determines if the player returns to the origin after completing all movements. Parameters: movements (str): The string of movements consisting of 'U', 'D', 'L', and 'R'. Returns: str: \\"Yes\\" if the player returns to the origin, otherwise \\"No\\". x, y = 0, 0 for move in movements: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"def is_prime(num): Returns whether a number is prime. pass def product_of_primes(N): Returns the product of all prime numbers less than or equal to N. >>> product_of_primes(5) 30 >>> product_of_primes(10) 210 pass","solution":"def is_prime(num): Returns whether a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def product_of_primes(N): Returns the product of all prime numbers less than or equal to N. product = 1 for num in range(2, N + 1): if is_prime(num): product *= num return product"},{"question":"def is_happy_number(n: int) -> bool: Determines if a number is a Happy Number. Args: n : int The integer to be checked Returns: bool Returns True if n is a Happy Number, otherwise False >>> is_happy_number(19) True >>> is_happy_number(21) False # Your code here","solution":"def is_happy_number(n: int) -> bool: Determines if a number is a Happy Number. Args: n : int The integer to be checked Returns: bool Returns True if n is a Happy Number, otherwise False def get_next(number): total_sum = 0 while number > 0: number, digit = divmod(number, 10) total_sum += digit ** 2 return total_sum seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"def two_sum(arr, target): Determines whether there are two distinct elements in the array that add up to the target sum. Returns their indices as a tuple or None if no such pair exists. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4], 8) None >>> two_sum([1, 2, 3, 7], 10) (2, 3) >>> two_sum([1, -2, 3, 7], 5) (1, 3) >>> two_sum([3, 2, 4, 4], 8) (2, 3) # or (3, 2) >>> two_sum([3, 3, 4], 6) (0, 1) >>> two_sum([], 5) None >>> two_sum([5], 5) None","solution":"def two_sum(arr, target): Determines whether there are two distinct elements in the array that add up to the target sum. Returns their indices as a tuple or None if no such pair exists. seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes(root): Returns the number of nodes in a full binary tree. :param root: TreeNode, the root of the binary tree :return: int, the number of nodes import pytest def test_single_node(): root = TreeNode(1) assert count_nodes(root) == 1 def test_full_tree_level_2(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert count_nodes(root) == 3 def test_full_tree_level_3(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert count_nodes(root) == 7 def test_full_tree_level_4(): root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8), TreeNode(9)), TreeNode(5, TreeNode(10), TreeNode(11))), TreeNode(3, TreeNode(6, TreeNode(12), TreeNode(13)), TreeNode(7, TreeNode(14), TreeNode(15))) ) assert count_nodes(root) == 15 def test_empty_tree(): assert count_nodes(None) == 0 def test_unbalanced_full_tree_level_2(): root = TreeNode(1, TreeNode(2, TreeNode(4), None), TreeNode(3)) assert count_nodes(root) == 4 if __name__ == \\"__main__\\": pytest.main()","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_nodes(root): Returns the number of nodes in a full binary tree. :param root: TreeNode, the root of the binary tree :return: int, the number of nodes if root is None: return 0 return 1 + count_nodes(root.left) + count_nodes(root.right)"},{"question":"def encode_sequence(N: int, K: int, sequence: List[int]) -> List[int]: Encodes the given sequence by dividing it into K blocks of equal length and summing each block. Args: N (int): Length of the sequence. K (int): Number of blocks. sequence (list): List of integers representing the sequence. Returns: list: Encoded sequence as a list of sums of each block, or an empty list if division is not possible. Examples: >>> encode_sequence(6, 2, [10, 20, 30, 40, 50, 60]) == [60, 150] >>> encode_sequence(7, 1, [5, 10, 15, 20, 25, 30, 35]) == [140] from solution import encode_sequence def test_encode_sequence_valid_division(): assert encode_sequence(6, 2, [10, 20, 30, 40, 50, 60]) == [60, 150] assert encode_sequence(7, 1, [5, 10, 15, 20, 25, 30, 35]) == [140] assert encode_sequence(8, 4, [1, 2, 3, 4, 5, 6, 7, 8]) == [3, 7, 11, 15] assert encode_sequence(9, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == [6, 15, 24] def test_encode_sequence_invalid_division(): assert encode_sequence(7, 3, [5, 10, 15, 20, 25, 30, 35]) == [] assert encode_sequence(8, 5, [1, 2, 3, 4, 5, 6, 7, 8]) == [] assert encode_sequence(10, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [] def test_encode_sequence_one_block(): assert encode_sequence(4, 1, [10, 20, 30, 40]) == [100] assert encode_sequence(5, 1, [1, 2, 3, 4, 5]) == [15] def test_encode_sequence_entire_elements(): assert encode_sequence(1, 1, [10]) == [10] assert encode_sequence(2, 1, [10, 20]) == [30] assert encode_sequence(3, 1, [10, 20, 30]) == [60]","solution":"def encode_sequence(N, K, sequence): Encodes the given sequence by dividing it into K blocks of equal length and summing each block. Args: N (int): Length of the sequence K (int): Number of blocks sequence (list): List of integers representing the sequence Returns: list: Encoded sequence as a list of sums of each block, or an empty list if division is not possible if N % K != 0: return [] block_size = N // K encoded_sequence = [] for i in range(0, N, block_size): block_sum = sum(sequence[i:i+block_size]) encoded_sequence.append(block_sum) return encoded_sequence"},{"question":"from typing import List def count_runners_per_city(n: int, city_ids: List[int]) -> List[int]: Determine the count of runners from each city and return the sorted list of city IDs based on the number of runners in descending order. If two cities have the same number of runners, their IDs should be sorted in ascending order. Parameters: - n (int): Number of runners. - city_ids (list of int): List of city IDs corresponding to each runner. Returns: - list of int: Sorted list of city IDs by number of runners in descending order. >>> count_runners_per_city(5, [2, 3, 2, 3, 1]) [2, 3, 1] >>> count_runners_per_city(8, [1, 2, 1, 3, 2, 1, 3, 2]) [1, 2, 3]","solution":"def count_runners_per_city(n, city_ids): Returns the list of city IDs sorted by the number of runners in descending order. Parameters: - n (int): Number of runners. - city_ids (list of int): List of city IDs corresponding to each runner. Returns: - list of int: Sorted list of city IDs by number of runners in descending order. from collections import Counter # Count the number of runners per city city_counts = Counter(city_ids) # Create a sorted list of city IDs based on the conditions sorted_city_ids = sorted(city_counts.keys(), key=lambda x: (-city_counts[x], x)) return sorted_city_ids"},{"question":"def find_longest_path(grid: List[List[str]]) -> int: You are given a grid with R rows and C columns. Some of the cells in the grid are blocked, and some cells are open. The grid is represented as a 2D array of characters, where '#' represents a blocked cell and '.' represents an open cell. Find the longest path from the top-left corner to the bottom-right corner, but you can only move right or down. In case it is not possible to reach the bottom-right corner from the top-left corner, output \`-1\`. >>> find_longest_path([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.']]) 4 >>> find_longest_path([ ... ['.', '#', '.'], ... ['#', '.', '.'], ... ['.', '.', '#']]) -1","solution":"def find_longest_path(grid): R = len(grid) C = len(grid[0]) if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 dp = [[-1 for _ in range(C)] for _ in range(R)] dp[0][0] = 0 for i in range(R): for j in range(C): if grid[i][j] == '#': continue if i > 0 and dp[i-1][j] != -1: dp[i][j] = max(dp[i][j], dp[i-1][j] + 1) if j > 0 and dp[i][j-1] != -1: dp[i][j] = max(dp[i][j], dp[i][j-1] + 1) return dp[R-1][C-1] if dp[R-1][C-1] != -1 else -1"},{"question":"def max_points(n: int, s: str) -> int: Determine the maximum number of points that can be collected by repeatedly deleting special sequences from an initial string. Args: n (int): The length of the string. s (str): The string consisting of lowercase letters. Returns: int: The maximum number of points collected. >>> max_points(6, \\"aaabba\\") 14 >>> max_points(4, \\"aaaa\\") 16","solution":"def max_points(n, s): Returns the maximum number of points by repeatedly deleting special sequences. i = 0 total_points = 0 while i < n: char = s[i] length = 0 while i < n and s[i] == char: i += 1 length += 1 total_points += length**2 return total_points"},{"question":"def is_subsequence(s: str, t: str) -> bool: Returns True if s is a subsequence of t, otherwise False. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"\\", \\"ahbgdc\\") True >>> is_subsequence(\\"abc\\", \\"\\") False","solution":"def is_subsequence(s, t): Returns True if s is a subsequence of t, otherwise False. s_len, t_len = len(s), len(t) s_idx, t_idx = 0, 0 while s_idx < s_len and t_idx < t_len: if s[s_idx] == t[t_idx]: s_idx += 1 t_idx += 1 return s_idx == s_len"},{"question":"from typing import List, Tuple def longest_itinerary(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Returns the length of the longest possible itinerary in the city graph. :param n: Number of intersections :param m: Number of roads :param roads: List of tuples where each tuple (u, v) denotes a direct road from intersection u to intersection v. :return: Length of the longest itinerary >>> longest_itinerary(2, 1, [(1, 2)]) 2 >>> longest_itinerary(4, 2, [(1, 2), (3, 4)]) 2 >>> longest_itinerary(3, 3, [(1, 2), (2, 3), (3, 1)]) -1 >>> longest_itinerary(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (3, 5), (1, 3)]) 5 >>> longest_itinerary(4, 0, []) 1 from solution import longest_itinerary def test_longest_itinerary_with_single_road(): assert longest_itinerary(2, 1, [(1, 2)]) == 2 def test_longest_itinerary_disconnected_graph(): assert longest_itinerary(4, 2, [(1, 2), (3, 4)]) == 2 def test_longest_itinerary_with_cycle(): assert longest_itinerary(3, 3, [(1, 2), (2, 3), (3, 1)]) == -1 def test_longest_itinerary_multiple_paths(): assert longest_itinerary(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (3, 5), (1, 3)]) == 5 def test_longest_itinerary_all_nodes_disconnected(): assert longest_itinerary(4, 0, []) == 1 def test_longest_itinerary_complex_case(): num_intersections = 7 roads_list = [(1, 2), (2, 3), (3, 4), (4, 7), (1, 5), (5, 6), (6, 7), (3, 7)] assert longest_itinerary(num_intersections, len(roads_list), roads_list) == 5","solution":"from collections import defaultdict, deque def longest_itinerary(n, m, roads): Returns the length of the longest possible itinerary in the city graph. :param n: Number of intersections :param m: Number of roads :param roads: List of tuples where each tuple (u, v) denotes a direct road from intersection u to intersection v. :return: Length of the longest itinerary # Create adjacency list for the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) # Perform a topological sort in_degree = {i: 0 for i in range(1, n + 1)} for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([node for node in in_degree if in_degree[node] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topo_order doesn't include all nodes, graph has a cycle or disconnected if len(topo_order) < n: return -1 # Find the longest path in the topologically sorted graph longest_path = {i: 1 for i in range(1, n + 1)} for node in topo_order: for neighbor in graph[node]: longest_path[neighbor] = max(longest_path[neighbor], longest_path[node] + 1) return max(longest_path.values())"},{"question":"from typing import List, Tuple def sort_tasks(task_list: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sorts the tasks first by due date in ascending order, then by priority in descending order for tasks with the same due date. :param task_list: List of tuples where each tuple contains (due_date, priority) :return: Sorted list of tasks pass def process_input_data(input_data: str) -> List[List[Tuple[int, int]]]: Processes the input data for multiple test cases and returns sorted tasks for each test case. :param input_data: String containing input data :return: List of lists, each containing the sorted tasks for a test case pass def test_sort_tasks_basic(): assert sort_tasks([(3, 10), (1, 5), (1, 8)]) == [(1, 8), (1, 5), (3, 10)] def test_sort_tasks_same_due_date(): assert sort_tasks([(2, 6), (2, 8), (2, 3)]) == [(2, 8), (2, 6), (2, 3)] def test_sort_tasks_mixed_due_dates(): assert sort_tasks([(4, 2), (3, 4), (2, 8), (2, 6)]) == [(2, 8), (2, 6), (3, 4), (4, 2)] def test_process_input_data(): input_data = \\"2n3n3 10n1 5n1 8n4n4 2n3 4n2 6n2 8\\" expected_output = [ [(1, 8), (1, 5), (3, 10)], [(2, 8), (2, 6), (3, 4), (4, 2)] ] assert process_input_data(input_data) == expected_output def test_process_input_data_single_test_case(): input_data = \\"1n3n1 1n1 2n1 3\\" expected_output = [ [(1, 3), (1, 2), (1, 1)] ] assert process_input_data(input_data) == expected_output","solution":"def sort_tasks(task_list): Sorts the tasks first by due date in ascending order, then by priority in descending order for tasks with the same due date. :param task_list: List of tuples where each tuple contains (due_date, priority) :return: Sorted list of tasks return sorted(task_list, key=lambda x: (x[0], -x[1])) def process_input_data(input_data): Processes the input data for multiple test cases and returns sorted tasks for each test case. :param input_data: String containing input data :return: List of lists, each containing the sorted tasks for a test case lines = input_data.strip().split('n') t = int(lines[0]) index = 1 results = [] for _ in range(t): n = int(lines[index]) tasks = [] index += 1 for _ in range(n): d, p = map(int, lines[index].split()) tasks.append((d, p)) index += 1 sorted_tasks = sort_tasks(tasks) results.append(sorted_tasks) return results"},{"question":"def smallest_sequence_with_k_swaps(n: int, k: int, arr: List[int]) -> List[int]: Returns the lexicographically smallest sequence by performing at most k adjacent swaps. >>> smallest_sequence_with_k_swaps(5, 3, [4, 3, 2, 1, 5]) [2, 3, 4, 1, 5] >>> smallest_sequence_with_k_swaps(4, 2, [4, 3, 2, 1]) [3, 2, 4, 1]","solution":"def smallest_sequence_with_k_swaps(n, k, arr): Returns the lexicographically smallest sequence by performing at most k adjacent swaps. for i in range(n): for j in range(i, 0, -1): if k <= 0: break if arr[j] < arr[j-1]: arr[j], arr[j-1] = arr[j-1], arr[j] k -= 1 else: break return arr"},{"question":"def max_sum_subgraph(N: int, M: int, K: int, V: List[int], edges: List[Tuple[int, int, int]]) -> int: Determine the maximum possible sum of values of all nodes in a connected subgraph, with the condition that the sum of the weights of edges in this subgraph does not exceed K. >>> N, M, K = 4, 4, 10 >>> V = [1, 2, 3, 4] >>> edges = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 5)] >>> max_sum_subgraph(N, M, K, V, edges) 10 >>> N, M, K = 3, 3, 5 >>> V = [1, 2, 3] >>> edges = [(1, 2, 2), (2, 3, 2), (1, 3, 6)] >>> max_sum_subgraph(N, M, K, V, edges) 6 >>> N, M, K = 5, 7, 12 >>> V = [5, 3, 2, 8, 7] >>> edges = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 5), (2, 4, 6), (1, 4, 7)] >>> max_sum_subgraph(N, M, K, V, edges) 25 >>> N, M, K = 2, 1, 1 >>> V = [1, 10] >>> edges = [(1, 2, 1)] >>> max_sum_subgraph(N, M, K, V, edges) 11 >>> N, M, K = 3, 3, 30 >>> V = [8, 7, 6] >>> edges = [(1, 2, 10), (2, 3, 15), (1, 3, 20)] >>> max_sum_subgraph(N, M, K, V, edges) 21","solution":"import heapq from collections import defaultdict def max_sum_subgraph(N, M, K, V, edges): def prim(): total_value = 0 total_weight = 0 edge_counter = 0 visited = [False] * N min_heap = [(0, 0)] while min_heap and total_weight <= K: w, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True total_value += V[u] total_weight += w edge_counter += 1 for wt, v in graph[u]: if not visited[v]: heapq.heappush(min_heap, (wt, v)) return total_value if edge_counter == N else -1 graph = defaultdict(list) for a, b, w in edges: graph[a-1].append((w, b-1)) graph[b-1].append((w, a-1)) result = prim() return result if result != -1 else 0 def parse_input(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) M = int(data[1]) K = int(data[2]) V = list(map(int, data[3:N+3])) edges = [] index = N + 3 for _ in range(M): A = int(data[index]) B = int(data[index + 1]) W = int(data[index + 2]) edges.append((A, B, W)) index += 3 return N, M, K, V, edges if __name__ == \\"__main__\\": N, M, K, V, edges = parse_input() print(max_sum_subgraph(N, M, K, V, edges))"},{"question":"def subset_xor_equals_target(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Determine if a subset of integers can achieve the target XOR value. >>> subset_xor_equals_target(1, [(3, [1, 2, 3], 0)]) [\\"YES\\"] >>> subset_xor_equals_target(1, [(4, [5, 2, 9, 1], 6)]) [\\"YES\\"] >>> subset_xor_equals_target(1, [(2, [0, 0], 1)]) [\\"NO\\"] >>> subset_xor_equals_target(3, [(3, [1, 2, 3], 0), (4, [5, 2, 9, 1], 6), (2, [0, 0], 1)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> subset_xor_equals_target(2, [(2, [3, 4], 7), (3, [1, 3, 4], 6)]) [\\"YES\\", \\"YES\\"]","solution":"def subset_xor_equals_target(t, test_cases): results = [] def can_achieve_xor(arr, x): # Using a set to keep track of possible xor results possible_xors = {0} for num in arr: new_xors = set() for p_xor in possible_xors: new_xors.add(p_xor ^ num) possible_xors.update(new_xors) return 'YES' if x in possible_xors else 'NO' for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] x = test_cases[i][2] results.append(can_achieve_xor(arr, x)) return results"},{"question":"from typing import List def findUniqueNumber(nums: List[int]) -> int: Finds the number that appears exactly once in a list where each integer appears exactly twice, except for one integer which appears exactly once. Args: nums: A list of integers where each integer appears exactly twice, except for one integer which appears exactly once. Returns: The integer that appears exactly once in the list. Example: >>> findUniqueNumber([4, 1, 2, 1, 2]) 4 >>> findUniqueNumber([6, 5, 6, 7, 7]) 5","solution":"def findUniqueNumber(nums): Finds the number that appears exactly once in a list where each integer appears exactly twice, except for one integer which appears exactly once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def pairSum(arr, target): Returns a list of pairs from arr that sum up to the target. >>> pairSum([2, 7, 11, 15], 9) [[2, 7]] >>> pairSum([1, 2, 3, 4, 5], 5) [[1, 4], [2, 3]]","solution":"def pairSum(arr, target): Returns a list of pairs from arr that sum up to the target. # A dictionary to store the number of times each element is seen seen = {} result = [] for num in arr: complement = target - num if complement in seen: result.append([complement, num]) seen[num] = True return result"},{"question":"from typing import List, Tuple def can_rearrange(s: str, k: int) -> str: Determines if it's possible to rearrange the characters in \`s\` such that every substring of length \`k\` has at least \`k-1\` distinct characters. >>> can_rearrange(\\"aabbcc\\", 3) \\"Yes\\" >>> can_rearrange(\\"aabb\\", 2) \\"Yes\\" >>> can_rearrange(\\"aaaabbbb\\", 4) \\"No\\" pass def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes the test cases for the can_rearrange function. >>> process_test_cases(3, [(3, \\"aabbcc\\"), (2, \\"aabb\\"), (4, \\"aaaabbbb\\")]) [\\"Yes\\", \\"Yes\\", \\"No\\"] pass","solution":"from collections import Counter def can_rearrange(s, k): Determines if it's possible to rearrange the characters in \`s\` such that every substring of length \`k\` has at least \`k-1\` distinct characters. if k == 1: return \\"Yes\\" freq = Counter(s) max_freq = max(freq.values()) if max_freq > len(s) - (k - 1) * max(0, max_freq - 1): return \\"No\\" return \\"Yes\\" def process_test_cases(t, test_cases): results = [] for case in test_cases: k, s = case result = can_rearrange(s, k) results.append(result) return results"},{"question":"def longest_non_decreasing_segment(n: int, elevations: List[int]) -> int: Find the length of the longest segment of the route where the elevation either stays the same or increases. Parameters: n (int): The number of meters in the route. elevations (List[int]): A list of integers representing the elevation at each meter. Returns: int: The length of the longest segment where the elevation does not decrease. Examples: >>> longest_non_decreasing_segment(8, [5, 1, 2, 3, 2, 3, 4, 5]) 4 >>> longest_non_decreasing_segment(5, [7, 7, 7, 7, 7]) 5 >>> longest_non_decreasing_segment(6, [6, 5, 4, 3, 2, 1]) 1","solution":"def longest_non_decreasing_segment(n, elevations): Returns the length of the longest segment where the elevation does not decrease. if n == 0: return 0 max_len = 1 current_len = 1 for i in range(1, n): if elevations[i] >= elevations[i-1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"from typing import List def can_form_string(s: str, words: List[str]) -> bool: Returns True if s can be formed by concatenating all the strings in words in any order, otherwise returns False. >>> can_form_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> can_form_string(\\"abcde\\", [\\"a\\", \\"abc\\", \\"de\\"]) False >>> can_form_string(\\"applepie\\", [\\"pie\\", \\"pear\\", \\"apple\\"]) False >>> can_form_string(\\"applepie\\", [\\"pie\\", \\"apple\\"]) True pass","solution":"def can_form_string(s, words): Returns True if s can be formed by concatenating all the strings in words in any order, otherwise returns False. # Count the frequencies of letters in the original string 's' from collections import Counter s_counter = Counter(s) # Count the frequencies of letters in words combined words_counter = Counter() for word in words: words_counter.update(word) # Compare the two frequency counts return s_counter == words_counter"},{"question":"from typing import List def shortest_path(N: int, M: int, grid: List[List[int]]) -> int: Find the shortest path from the top-left cell to the bottom-right cell in a grid, moving only up, down, left, or right. Args: N : int : Number of rows in the grid M : int : Number of columns in the grid grid : List[List[int]] : 2D list where 0 represents an open cell and 1 represents a blocked cell Returns: int : The length of the shortest path, or -1 if no path exists Examples: >>> grid1 = [ ... [0, 0, 0], ... [1, 1, 0], ... [1, 0, 0] ... ] >>> shortest_path(3, 3, grid1) 4 >>> grid2 = [ ... [0, 1, 0], ... [1, 1, 0], ... [1, 0, 0] ... ] >>> shortest_path(3, 3, grid2) -1 import unittest class TestShortestPath(unittest.TestCase): def test_shortest_path_simple_grid(self): grid1 = [ [0, 0, 0], [1, 1, 0], [1, 0, 0] ] self.assertEqual(shortest_path(3, 3, grid1), 4) def test_shortest_path_blocked(self): grid2 = [ [0, 1, 0], [1, 1, 0], [1, 0, 0] ] self.assertEqual(shortest_path(3, 3, grid2), -1) def test_shortest_path_large_block(self): grid3 = [ [0, 1, 0], [1, 1, 1], [0, 0, 0] ] self.assertEqual(shortest_path(3, 3, grid3), -1) def test_shortest_path_empty_grid(self): grid4 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] self.assertEqual(shortest_path(3, 3, grid4), 4) def test_shortest_path_single_cell_start_blocked(self): grid5 = [ [1] ] self.assertEqual(shortest_path(1, 1, grid5), -1) def test_shortest_path_single_cell_open(self): grid6 = [ [0] ] self.assertEqual(shortest_path(1, 1, grid6), 0) if __name__ == '__main__': unittest.main()","solution":"from collections import deque def shortest_path(N, M, grid): Find the shortest path from the top-left cell to the bottom-right cell in a grid. if grid[0][0] == 1 or grid[N-1][M-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == N-1 and col == M-1: return dist for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < N and 0 <= c < M and not visited[r][c] and grid[r][c] == 0: visited[r][c] = True queue.append((r, c, dist + 1)) return -1"},{"question":"from typing import List, Tuple def find_target_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function \`find_target_sum_pairs\` that takes a list of integers and a target sum as inputs. The function should return all unique pairs of integers from the list that add up to the target sum. Each pair should be returned as a tuple, and the pairs should be returned in a list. >>> find_target_sum_pairs([2, 4, 3, 3, 5, -1, 1], 4) [(-1, 5), (1, 3)] >>> find_target_sum_pairs([1, 1, 1, 1], 2) [(1, 1)] >>> find_target_sum_pairs([1, 2, 3], 10) [] >>> find_target_sum_pairs([-1, 1, 0, 2, -2], 0) [(-2, 2), (-1, 1)] >>> find_target_sum_pairs([1, 2, 3, 4, 5, 1, 2], 3) [(1, 2)] >>> find_target_sum_pairs([-3, -1, 0, 1, 2, 3], 0) [(-3, 3), (-1, 1)]","solution":"from typing import List, Tuple def find_target_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: pairs = set() complements = {} for num in nums: complement = target - num if complement in complements: pairs.add((min(num, complement), max(num, complement))) complements[num] = complements.get(num, 0) + 1 return sorted(list(pairs))"},{"question":"def longest_bitonic_subsequence(B): Given an array B of integers, return the length of the longest bitonic subsequence in B. A sequence is called bitonic if it is first increasing and then decreasing. >>> longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) 6 >>> longest_bitonic_subsequence([12, 11, 40, 5, 3, 1]) 5 >>> longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) 5 from solution import longest_bitonic_subsequence def test_example_1(): assert longest_bitonic_subsequence([1, 11, 2, 10, 4, 5, 2, 1]) == 6 def test_example_2(): assert longest_bitonic_subsequence([12, 11, 40, 5, 3, 1]) == 5 def test_example_3(): assert longest_bitonic_subsequence([80, 60, 30, 40, 20, 10]) == 5 def test_all_increasing(): assert longest_bitonic_subsequence([1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert longest_bitonic_subsequence([5, 4, 3, 2, 1]) == 5 def test_single_element(): assert longest_bitonic_subsequence([1]) == 1 def test_two_elements_increasing(): assert longest_bitonic_subsequence([1, 2]) == 2 def test_two_elements_decreasing(): assert longest_bitonic_subsequence([2, 1]) == 2 def test_no_bitonic_subsequence(): assert longest_bitonic_subsequence([3, 3, 3, 3, 3]) == 1","solution":"def longest_bitonic_subsequence(B): Given an array B of integers, return the length of the longest bitonic subsequence. A sequence is called bitonic if it is first increasing and then decreasing. n = len(B) # Create an array to store the length of the longest increasing subsequence ending at each index inc = [1] * n # Create an array to store the length of the longest decreasing subsequence starting at each index dec = [1] * n # Fill inc array, inc[i] will contain the length of the longest increasing subsequence ending at i for i in range(1, n): for j in range(0, i): if B[i] > B[j] and inc[i] < inc[j] + 1: inc[i] = inc[j] + 1 # Fill dec array, dec[i] will contain the length of the longest decreasing subsequence starting at i for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if B[i] > B[j] and dec[i] < dec[j] + 1: dec[i] = dec[j] + 1 # Find the maximum length of bitonic subsequence max_length = 0 for i in range(n): max_length = max(max_length, inc[i] + dec[i] - 1) return max_length"},{"question":"class FileSystem: def __init__(self): Initialize the file system. def create(self, path, value): Create a new path with the given value. Args: path (str): The path to create. value (int): The value to associate with the path. Returns: bool: True if the path was created successfully, False otherwise. def get(self, path): Retrieve the value of the given path. Args: path (str): The path to retrieve the value from. Returns: int: The value of the path or -1 if the path doesn't exist. # Function to handle multiple operations def handle_operations(operations): Handle a series of operations on the file system. Args: operations (list of str): A list of operations to perform. Returns: list of int: Results of the 'get' operations performed. import pytest def test_create_and_get(): fs = FileSystem() assert fs.create(\\"/a\\", 1) == True assert fs.create(\\"/a/b\\", 2) == True assert fs.get(\\"/a\\") == 1 assert fs.get(\\"/a/b\\") == 2 assert fs.get(\\"/c\\") == -1 assert fs.create(\\"/a\\", 10) == False assert fs.create(\\"/c/d\\", 3) == False def test_handle_operations(): operations = [ \\"create /a 1\\", \\"create /a/b 2\\", \\"get /a\\", \\"get /a/b\\", \\"get /c\\" ] assert handle_operations(operations) == [1, 2, -1] operations = [ \\"create /x 5\\", \\"get /x/y\\", \\"create /x/y 6\\", \\"create /x/y/z 7\\", \\"get /x\\", \\"get /x/y\\", \\"get /x/y/z\\" ] assert handle_operations(operations) == [-1, 5, 6, 7] def test_invalid_path_creation(): fs = FileSystem() assert fs.create(\\"/a/b\\", 2) == False assert fs.get(\\"/a/b\\") == -1 pytest.main()","solution":"class FileSystem: def __init__(self): self.paths = {} def create(self, path, value): if path in self.paths: return False parent = '/'.join(path.split('/')[:-1]) if parent and parent not in self.paths: return False self.paths[path] = value return True def get(self, path): return self.paths.get(path, -1) # Function to handle multiple operations def handle_operations(operations): fs = FileSystem() result = [] for op in operations: command = op.split() if command[0] == 'create': _, path, value = command fs.create(path, int(value)) elif command[0] == 'get': _, path = command result.append(fs.get(path)) return result"},{"question":"def minOperationsToPalindrome(S: str) -> int: Determine the minimum number of operations required to make the string S a palindrome. In one operation, you can select any character in the string and replace it with any other character. >>> minOperationsToPalindrome(\\"abca\\") 1 >>> minOperationsToPalindrome(\\"race\\") 2 >>> minOperationsToPalindrome(\\"a\\") 0 >>> minOperationsToPalindrome(\\"aa\\") 0 >>> minOperationsToPalindrome(\\"ab\\") 1 >>> minOperationsToPalindrome(\\"abcba\\") 0 >>> minOperationsToPalindrome(\\"abcd\\") 2 >>> minOperationsToPalindrome(\\"abcdefgh\\") 4","solution":"def minOperationsToPalindrome(S): Returns the minimum number of operations required to make the string S a palindrome. left, right = 0, len(S) - 1 operations = 0 while left < right: if S[left] != S[right]: operations += 1 left += 1 right -= 1 return operations"},{"question":"from typing import List def min_sprinklers(matrices: List[List[List[int]]]) -> List[int]: Calculates the minimum number of sprinklers needed for each given garden matrix such that every plant in the garden gets watered. >>> min_sprinklers([ >>> [ >>> [1, 0, 0], >>> [0, 1, 1], >>> [1, 0, 0] >>> ], >>> [ >>> [1, 1, 0], >>> [0, 0, 0], >>> [1, 0, 1] >>> ] >>> ]) == [3, 2] >>> min_sprinklers([ >>> [ >>> [0, 0, 0], >>> [0, 1, 0], >>> [0, 0, 0] >>> ] >>> ]) == [1] >>> min_sprinklers([ >>> [ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 1] >>> ] >>> ]) == [3] >>> min_sprinklers([ >>> [ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ] >>> ]) == [0] >>> min_sprinklers([ >>> [ >>> [1, 0, 1], >>> [0, 1, 0], >>> [1, 0, 1] >>> ], >>> [ >>> [0, 0, 0, 0], >>> [1, 1, 1, 1], >>> [0, 0, 0, 0], >>> [1, 1, 1, 1] >>> ] >>> ]) == [3, 2]","solution":"from typing import List def min_sprinklers(matrices: List[List[List[int]]]) -> List[int]: results = [] for matrix in matrices: m = len(matrix) n = len(matrix[0]) row_covered = [False] * m col_covered = [False] * n for i in range(m): for j in range(n): if matrix[i][j] == 1: row_covered[i] = True col_covered[j] = True # Number of rows and columns that need sprinklers row_sprinklers = sum(row_covered) col_sprinklers = sum(col_covered) # Minimum of rows or columns to cover all plants min_sprinklers_needed = min(row_sprinklers, col_sprinklers) results.append(min_sprinklers_needed) return results"},{"question":"from collections import defaultdict, Counter class WordPrediction: def __init__(self): self.chain = defaultdict(Counter) def add_sentence(self, sentence: str) -> None: Adds a sentence to the word prediction system. Parameters: sentence (str): A sentence containing words separated by spaces. >>> wp = WordPrediction() >>> wp.add_sentence(\\"i love programming\\") >>> wp.add_sentence(\\"i love coding\\") >>> wp.add_sentence(\\"i love programming because it is fun\\") pass def get_prediction(self, query: str) -> str: Given a query which is a sequence of words separated by spaces (possibly empty), return the word that most frequently follows this sequence in the previously added sentences. In case of a tie, return the lexicographically smallest word. If no such word exists, return an empty string. Parameters: query (str): A sequence of words separated by spaces. Returns: str: The most frequently occurring word that follows the given sequence, or an empty string if no such word exists. >>> wp = WordPrediction() >>> wp.add_sentence(\\"i love programming\\") >>> wp.add_sentence(\\"i love coding\\") >>> wp.add_sentence(\\"i love programming because it is fun\\") >>> wp.get_prediction(\\"i love\\") 'programming' >>> wp.get_prediction(\\"i\\") 'love' pass def process_commands(commands): Process a list of commands for the word prediction system. Parameters: commands (list): A list of commands in the format of either \\"add_sentence sentence\\" or \\"get_prediction query\\". Returns: list: A list of results for the \\"get_prediction\\" commands. >>> commands = [ \\"add_sentence i love programming\\", \\"add_sentence i love coding\\", \\"add_sentence i love programming because it is fun\\", \\"get_prediction i love\\", \\"get_prediction i\\", \\"add_sentence i love solving problems\\", \\"get_prediction i love\\" ] >>> process_commands(commands) ['programming', 'love', 'programming'] pass","solution":"from collections import defaultdict, Counter class WordPrediction: def __init__(self): self.chain = defaultdict(Counter) def add_sentence(self, sentence: str) -> None: words = sentence.split() for i in range(len(words)): if i < len(words) - 1: self.chain[' '.join(words[:i+1])][words[i+1]] += 1 def get_prediction(self, query: str) -> str: if query not in self.chain or not self.chain[query]: return \\"\\" count = self.chain[query] most_common = count.most_common() max_frequency = most_common[0][1] candidates = [word for word, freq in most_common if freq == max_frequency] return min(candidates) # Example function to run commands. def process_commands(commands): wp = WordPrediction() output = [] for command in commands: if command.startswith(\\"add_sentence\\"): wp.add_sentence(command[len(\\"add_sentence \\"):]) elif command.startswith(\\"get_prediction\\"): result = wp.get_prediction(command[len(\\"get_prediction \\"):]) output.append(result) return output"},{"question":"def sum_of_unique_elements(arr: List[int]) -> int: Returns the sum of elements that appear only once in the array. >>> sum_of_unique_elements([1, 2, 3, 2, 1]) == 3 >>> sum_of_unique_elements([4, 1, 2, 2, 3, 4]) == 4 >>> sum_of_unique_elements([7, 8, 9]) == 24 >>> sum_of_unique_elements([0, 1, 1, 0, 99]) == 99","solution":"def sum_of_unique_elements(arr): Returns the sum of elements that appear only once in the array. from collections import Counter count = Counter(arr) return sum(key for key, value in count.items() if value == 1)"},{"question":"def reduce_chemical_formula(formula: str) -> str: Reduces the chemical formula by removing redundant consecutive chemicals. >>> reduce_chemical_formula(\\"aabbcc\\") \\"abc\\" >>> reduce_chemical_formula(\\"abcdef\\") \\"abcdef\\" >>> reduce_chemical_formula(\\"aavvbbvv\\") \\"avbv\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases for the reduced chemical formula problem. >>> process_test_cases(3, [\\"aabbcc\\", \\"abcdef\\", \\"aavvbbvv\\"]) [\\"abc\\", \\"abcdef\\", \\"avbv\\"] >>> process_test_cases(1, [\\"aaaa\\"]) [\\"a\\"] pass","solution":"def reduce_chemical_formula(formula): Reduces the chemical formula by removing redundant consecutive chemicals. if not formula: return \\"\\" reduced_formula = [formula[0]] for i in range(1, len(formula)): if formula[i] != formula[i - 1]: reduced_formula.append(formula[i]) return ''.join(reduced_formula) def process_test_cases(T, test_cases): Processes multiple test cases for the reduced chemical formula problem. results = [] for case in test_cases: results.append(reduce_chemical_formula(case)) return results"},{"question":"def can_fulfill_reading_schedule(n, k, m, books_genres, reading_schedule): Determine if the reading schedule can be fulfilled with the available books. Args: n (int): Number of books. k (int): Number of genres. m (int): Length of the reading schedule. books_genres (list of int): List of genres for each book. reading_schedule (list of int): List of genres in the reading schedule. Returns: str: \\"YES\\" if the reading schedule can be fulfilled, otherwise \\"NO\\". Examples: >>> can_fulfill_reading_schedule(5, 3, 4, [1, 2, 3, 2, 1], [1, 2, 3, 2]) 'YES' >>> can_fulfill_reading_schedule(4, 3, 5, [1, 2, 1, 3], [1, 2, 3, 2, 1]) 'NO'","solution":"def can_fulfill_reading_schedule(n, k, m, books_genres, reading_schedule): Returns \\"YES\\" if the reading schedule can be fulfilled with the available books, otherwise \\"NO\\". genre_count = [0] * (k + 1) # Count the number of books in each genre for genre in books_genres: genre_count[genre] += 1 # Check if we can fulfill the reading schedule for genre in reading_schedule: if genre_count[genre] == 0: return \\"NO\\" genre_count[genre] -= 1 return \\"YES\\""},{"question":"def find_combination_sequence(ingredients, final_dish): Given a list of ingredients and the final dish sequence, find the sequence of indices (0-based) that were used to combine the ingredients to make the dish. Args: ingredients (List[str]): A list of ingredients. final_dish (List[str]): The final sequence of ingredients in the dish. Returns: List[int]: The sequence of indices used to combine the ingredients. Example: >>> find_combination_sequence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], [\\"apple\\", \\"date\\", \\"banana\\", \\"cherry\\"]) [0, 3, 1, 2] >>> find_combination_sequence([\\"tomato\\", \\"onion\\", \\"pepper\\"], [\\"tomato\\", \\"pepper\\", \\"onion\\"]) [0, 2, 1] >>> find_combination_sequence([\\"lettuce\\", \\"tomato\\", \\"cucumber\\", \\"pepper\\", \\"carrot\\"], [\\"lettuce\\", \\"carrot\\", \\"tomato\\", \\"pepper\\", \\"cucumber\\"]) [0, 4, 1, 3, 2]","solution":"def find_combination_sequence(ingredients, final_dish): n = len(ingredients) seq = [] start = 0 end = n - 1 is_start_turn = True for item in final_dish: if is_start_turn: seq.append(ingredients.index(item, start, end + 1)) start += 1 else: seq.append(ingredients.index(item, start, end + 1)) end -= 1 is_start_turn = not is_start_turn return seq"},{"question":"from typing import List def coinChange(coins: List[int], amount: int) -> int: Determines the minimum number of coins needed to make up a specific amount of money. If that amount cannot be made up by any combination of coins, returns -1. Args: coins (List[int]): List of integers representing the coin denominations. amount (int): The total amount of money. Returns: int: Minimum number of coins required to make up the specified amount or -1 if it's not possible. Examples: >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1], 0) 0 >>> coinChange([1], 2) 2 >>> coinChange([1, 4, 5], 8) 2","solution":"from typing import List def coinChange(coins: List[int], amount: int) -> int: # Create a list to store the minimum coins needed for each amount from 0 to amount. dp = [amount + 1] * (amount + 1) # Base case: 0 coins needed to make amount 0. dp[0] = 0 # Iterate through each coin and update the dp table. for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Return the result. If dp[amount] is still greater than amount, return -1 as it's not possible. return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def inventory_management(test_cases): Process multiple test cases to determine if sales exceed inventory for each test case. :param test_cases: List of test cases with each test case in the form of (deliveries, sales) :return: List of strings \\"YES\\" or \\"NO\\" for each test case. # Your code here def parse_input(input_string): Parse the input string and return the structured test cases. :param input_string: Input string describing the test cases :return: List of parsed test cases # Your code here import pytest def test_inventory_management(): input_data = \\"2n3 3n101 10n102 20n103 15n101 5n102 25n103 10n2 2n201 50n202 30n201 20n202 10\\" test_cases = parse_input(input_data) assert inventory_management(test_cases) == [\\"NO\\", \\"YES\\"] def test_inventory_management_all_valid(): input_data = \\"1n2 2n101 10n102 20n101 5n102 15\\" test_cases = parse_input(input_data) assert inventory_management(test_cases) == [\\"YES\\"] def test_inventory_management_invalid_sales(): input_data = \\"1n2 3n101 10n102 20n101 5n102 25n103 10\\" test_cases = parse_input(input_data) assert inventory_management(test_cases) == [\\"NO\\"] def test_inventory_management_edge_case_no_deliveries(): input_data = \\"1n0 1n101 5\\" test_cases = parse_input(input_data) assert inventory_management(test_cases) == [\\"NO\\"] def test_inventory_management_exact_sales(): input_data = \\"1n2 2n101 10n102 20n101 10n102 20\\" test_cases = parse_input(input_data) assert inventory_management(test_cases) == [\\"YES\\"] @pytest.fixture def large_input(): input_data = \\"1n100 100n\\" + \\"n\\".join(f\\"{i+1} 1000000\\" for i in range(100)) + \\"n\\" + \\"n\\".join(f\\"{i+1} 999999\\" for i in range(100)) return input_data def test_inventory_management_large_input(large_input): test_cases = parse_input(large_input) assert inventory_management(test_cases) == [\\"YES\\"]","solution":"def inventory_management(test_cases): Process multiple test cases to determine if sales exceed inventory for each test case. :param test_cases: List of test cases with each test case in the form of (deliveries, sales) :return: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for deliveries, sales in test_cases: inventory = {} # Process deliveries for item_id, quantity in deliveries: if item_id in inventory: inventory[item_id] += quantity else: inventory[item_id] = quantity # Process sales valid_sales = True for item_id, quantity in sales: if item_id not in inventory or inventory[item_id] < quantity: valid_sales = False break else: inventory[item_id] -= quantity if valid_sales: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): Parse the input string and return the structured test cases. :param input_string: Input string describing the test cases :return: List of parsed test cases lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) index += 1 deliveries = [] sales = [] for _ in range(N): item_id, quantity = map(int, lines[index].split()) deliveries.append((item_id, quantity)) index += 1 for _ in range(M): item_id, quantity = map(int, lines[index].split()) sales.append((item_id, quantity)) index += 1 test_cases.append((deliveries, sales)) return test_cases"},{"question":"def count_missing_pages(test_cases): Determine the total number of missing pages for each test case. Args: test_cases: A list of dictionaries, where each dictionary contains: - 'N': an integer representing the number of torn-out pages or page ranges - 'pages': a list of strings, where each string is either an individual page number or a range of page numbers Returns: A list of integers, where each integer represents the total number of missing pages for the corresponding test case. Examples: >>> count_missing_pages([{'N': 3, 'pages': ['1', '4', '6']}]) [3] >>> count_missing_pages([{'N': 4, 'pages': ['2-4', '6', '8-10', '12']}]) [8] >>> count_missing_pages([{'N': 2, 'pages': ['1-2', '2-3']}]) [3]","solution":"def count_missing_pages(test_cases): results = [] for case in test_cases: N = case['N'] pages = case['pages'] missing_pages = set() for page in pages: if '-' in page: start, end = map(int, page.split('-')) for p in range(start, end + 1): missing_pages.add(p) else: missing_pages.add(int(page)) results.append(len(missing_pages)) return results"},{"question":"from typing import List, Tuple def find_max_clique_in_network(n: int, m: int, friendships: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Find the size of the largest clique and its members in the given social network. Args: n (int): Number of individuals in the social network. m (int): Number of friendship relations. friendships (List[Tuple[int, int]]): List of friendship relations. Returns: Tuple[int, List[int]]: Size of the largest clique and list of its members. >>> find_max_clique_in_network(5, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) (4, [1, 2, 3, 4]) >>> find_max_clique_in_network(6, 7, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (5, 6)]) (4, [1, 2, 3, 4]) pass def test_sample_input_1(): n = 5 m = 6 friendships = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 4 assert set(clique) == {1, 2, 3, 4} def test_sample_input_2(): n = 6 m = 7 friendships = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (5, 6)] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 4 assert set(clique) == {1, 2, 3, 4} def test_no_friendships(): n = 4 m = 0 friendships = [] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 1 assert len(clique) == 1 assert clique[0] == 1 def test_single_friendship(): n = 2 m = 1 friendships = [(1, 2)] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 2 assert set(clique) == {1, 2} def test_disconnected_cliques(): n = 6 m = 6 friendships = [(1, 2), (1, 3), (2, 3), (4, 5), (4, 6), (5, 6)] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 3 assert set(clique) in [{1, 2, 3}, {4, 5, 6}] def test_large_complete_graph(): n = 5 m = 10 friendships = [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)] size, clique = find_max_clique_in_network(n, m, friendships) assert size == 5 assert set(clique) == {1, 2, 3, 4, 5}","solution":"import itertools def is_clique(graph, vertices): for i in range(len(vertices)): for j in range(i+1, len(vertices)): if vertices[j] not in graph[vertices[i]]: return False return True def find_maximum_cliques(n, friendships): # Create adjacency list graph = {i: [] for i in range(1, n+1)} for f1, f2 in friendships: graph[f1].append(f2) graph[f2].append(f1) max_clique = [] for size in range(n, 1, -1): for combination in itertools.combinations(range(1, n+1), size): if is_clique(graph, combination): return size, list(combination) return 1, [1] # If no cliques found, at least one person is a clique of size 1 def find_max_clique_in_network(n, m, friendships): size, clique = find_maximum_cliques(n, friendships) return size, clique"},{"question":"def can_deliver_all_letters(M, L, capacities): Determine if it is possible to deliver all L letters without exceeding the capacities of any postal box. :param M: Number of postal boxes :param L: Number of letters to be delivered :param capacities: List of integers where each integer represents the maximum capacity of a postal box :return: \\"YES\\" if it is possible to deliver all letters, else \\"NO\\" # Your code here from solution import can_deliver_all_letters def test_sample_input(): assert can_deliver_all_letters(4, 10, [3, 4, 2, 3]) == \\"YES\\" def test_insufficient_capacity(): assert can_deliver_all_letters(3, 10, [3, 3, 3]) == \\"NO\\" def test_exact_capacity(): assert can_deliver_all_letters(3, 9, [3, 3, 3]) == \\"YES\\" def test_one_box_sufficient(): assert can_deliver_all_letters(5, 20, [20, 1, 1, 1, 1]) == \\"YES\\" def test_all_boxes_with_one_letter(): assert can_deliver_all_letters(10, 10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == \\"YES\\" def test_all_boxes_with_one_letter_but_more_needed(): assert can_deliver_all_letters(10, 11, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == \\"NO\\" def test_large_input(): M = 1000 L = 100000 capacities = [100] * 1000 assert can_deliver_all_letters(M, L, capacities) == \\"YES\\" def test_zero_letters(): assert can_deliver_all_letters(10, 0, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == \\"YES\\"","solution":"def can_deliver_all_letters(M, L, capacities): Determine if it is possible to deliver all L letters without exceeding the capacities of any postal box. :param M: Number of postal boxes :param L: Number of letters to be delivered :param capacities: List of integers where each integer represents the maximum capacity of a postal box :return: \\"YES\\" if it is possible to deliver all letters, else \\"NO\\" total_capacity = sum(capacities) if total_capacity >= L: return \\"YES\\" else: return \\"NO\\""},{"question":"import math def calculate_heads_probability(N: int, results: str) -> str: Calculate the probability of getting heads in the form of an irreducible fraction. :param N: int, the number of flips (1 ≤ N ≤ 1000) :param results: str, a string of length N consisting of characters 'H' for heads and 'T' for tails :return: str, the probability in the form of an irreducible fraction «A/B» >>> calculate_heads_probability(5, \\"HHHHH\\") '1/1' >>> calculate_heads_probability(5, \\"TTTTT\\") '0/1' >>> calculate_heads_probability(10, \\"HHHTTTHHTT\\") '1/2' >>> calculate_heads_probability(3, \\"TTT\\") '0/1' >>> calculate_heads_probability(3, \\"HHH\\") '1/1' >>> calculate_heads_probability(6, \\"HHHTTT\\") '1/2' >>> calculate_heads_probability(8, \\"HHHTHHHT\\") '3/4' >>> calculate_heads_probability(1, \\"H\\") '1/1' >>> calculate_heads_probability(1, \\"T\\") '0/1'","solution":"import math def calculate_heads_probability(N, results): Calculate the probability of getting heads in the form of an irreducible fraction. :param N: int, the number of flips (1 ≤ N ≤ 1000) :param results: str, a string of length N consisting of characters 'H' for heads and 'T' for tails :return: str, the probability in the form of an irreducible fraction «A/B» heads_count = results.count('H') if heads_count == 0: return \\"0/1\\" elif heads_count == N: return \\"1/1\\" else: gcd = math.gcd(heads_count, N) numerator = heads_count // gcd denominator = N // gcd return f\\"{numerator}/{denominator}\\""},{"question":"def largestNumber(arr: List[int]) -> str: Given an array of integers, arrange them to form the largest possible concatenated number. Args: arr (list): List of non-negative integers Returns: str: String representing the largest concatenated number Example: >>> largestNumber([10, 2]) \\"210\\" >>> largestNumber([3, 30, 34, 5, 9]) \\"9534330\\"","solution":"from functools import cmp_to_key def largestNumber(arr): Given an array of integers, arrange them to form the largest possible concatenated number. Args: arr (list): List of non-negative integers Returns: str: String representing the largest concatenated number if not arr: return \\"\\" # Custom comparator to sort numbers in a way that forms largest concatenated number def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for proper comparison arr = list(map(str, arr)) # Sort array with custom comparator arr.sort(key=cmp_to_key(compare)) # Join sorted array into single string largest_num = ''.join(arr) # If the largest number starts with '0', the entire number is '0' if largest_num[0] == '0': return '0' return largest_num"},{"question":"def is_balanced(braces: str) -> bool: Check if the braces in the string are balanced. Parameters: braces (str): The string containing braces. Returns: bool: True if the braces are balanced, False otherwise. >>> is_balanced(\\"({[]})\\") True >>> is_balanced(\\"([)]\\") False >>> is_balanced(\\"()\\") True >>> is_balanced(\\")\\") False >>> is_balanced(\\"{[()]}\\") True","solution":"def is_balanced(braces: str) -> bool: Check if the braces in the string are balanced. Parameters: braces (str): The string containing braces. Returns: bool: True if the braces are balanced, False otherwise. stack = [] brace_map = {')': '(', '}': '{', ']': '['} for char in braces: if char in brace_map.values(): stack.append(char) elif char in brace_map.keys(): if stack == [] or brace_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def can_alphonso_win(n: int) -> str: Determines whether Alphonso can guarantee a win if both players play optimally. >>> can_alphonso_win(2) \\"Beatrice\\" >>> can_alphonso_win(5) \\"Alphonso\\"","solution":"def can_alphonso_win(n): Determines whether Alphonso can guarantee a win if both players play optimally. Parameters: n (int): The initial number of stones. Returns: str: \\"Alphonso\\" if Alphonso can guarantee a win, \\"Beatrice\\" otherwise. # Create a dynamic programming array to store the game's outcomes dp = [False] * (n + 1) # Base cases if n == 0: return \\"Beatrice\\" elif n == 1: return \\"Alphonso\\" # Populate the dp array for i in range(1, n + 1): if i >= 1 and not dp[i - 1]: dp[i] = True elif i >= 3 and not dp[i - 3]: dp[i] = True elif i >= 4 and not dp[i - 4]: dp[i] = True # Return the result for n stones return \\"Alphonso\\" if dp[n] else \\"Beatrice\\""},{"question":"import math from functools import reduce from typing import List def smallest_k_to_make_elements_divisible(N: int, A: List[int]) -> int: Returns the smallest positive integer k such that all elements in A can be made divisible by k by adding k to each element of the sequence exactly once. >>> smallest_k_to_make_elements_divisible(3, [2, 4, 6]) 2 >>> smallest_k_to_make_elements_divisible(4, [5, 10, 15, 25]) 5 >>> smallest_k_to_make_elements_divisible(2, [7, 13]) 6 pass from solution import smallest_k_to_make_elements_divisible def test_smallest_k_example1(): assert smallest_k_to_make_elements_divisible(3, [2, 4, 6]) == 2 def test_smallest_k_example2(): assert smallest_k_to_make_elements_divisible(4, [5, 10, 15, 25]) == 5 def test_smallest_k_example3(): assert smallest_k_to_make_elements_divisible(2, [7, 13]) == 6 def test_smallest_k_single_element(): assert smallest_k_to_make_elements_divisible(1, [10]) == 10 def test_smallest_k_all_same_elements(): assert smallest_k_to_make_elements_divisible(3, [5, 5, 5]) == 0 def test_smallest_k_large_numbers(): assert smallest_k_to_make_elements_divisible(3, [1000000000, 1000000002, 1000000004]) == 2 def test_smallest_k_mixed_elements(): assert smallest_k_to_make_elements_divisible(4, [1, 3, 5, 7]) == 2","solution":"import math from functools import reduce def smallest_k_to_make_elements_divisible(N, A): Returns the smallest positive integer k such that all elements in A can be made divisible by k by adding k to each element of the sequence exactly once. if N == 1: return A[0] # Calculate the differences between consecutive elements diffs = [A[i] - A[i-1] for i in range(1, N)] # Find the GCD of all differences gcd_of_diffs = reduce(math.gcd, diffs) return gcd_of_diffs"},{"question":"def final_recipient_of_last_text_message(n: int, messages: List[str]) -> str: Determine the final recipient of the last text message. Parameters: n (int): The number of messages. messages (list): A list of strings where each string is a message. Returns: str: The identifier of the final recipient of the last text message, or \\"No text message\\" if none exist. >>> final_recipient_of_last_text_message(5, [ >>> \\"/this is a sample text message\\", >>> \\"/to 3\\", >>> \\"Hello, how are you?\\", >>> \\"See you tomorrow!\\", >>> \\"/to 2\\" >>> ]) == \\"3\\" >>> final_recipient_of_last_text_message(3, [ >>> \\"/to 4\\", >>> \\"/to 1\\", >>> \\"/to 5\\" >>> ]) == \\"No text message\\"","solution":"def final_recipient_of_last_text_message(n, messages): Determine the final recipient of the last text message. Parameters: n (int): The number of messages. messages (list): A list of strings where each string is a message. Returns: str: The identifier of the final recipient of the last text message, or \\"No text message\\" if none exist. current_recipient = None last_recipient = \\"No text message\\" for message in messages: if message.startswith('/to '): current_recipient = message.split()[1] else: if current_recipient is not None: last_recipient = current_recipient return last_recipient # Example use: # n = 5 # messages = [ # \\"/this is a sample text message\\", # \\"/to 3\\", # \\"Hello, how are you?\\", # \\"See you tomorrow!\\", # \\"/to 2\\" # ] # print(final_recipient_of_last_text_message(n, messages)) # Output: 3"},{"question":"def rearrange_even_odd(arr): Rearrange the array so that all even numbers come before all odd numbers. >>> rearrange_even_odd([4, 3, 1, 2, 5, 8, 7, 6]) [4, 2, 8, 6, 3, 1, 5, 7] >>> rearrange_even_odd([1, 2, 3, 4, 5]) [2, 4, 1, 3, 5] >>> rearrange_even_odd([9, 7, 5, 3, 1, 2]) [2, 9, 7, 5, 3, 1]","solution":"def rearrange_even_odd(arr): even = [x for x in arr if x % 2 == 0] odd = [x for x in arr if x % 2 != 0] return even + odd"},{"question":"def can_match_target_with_three_numbers(t: int, n: int, tickets: List[int]) -> str: Determine if it's possible to match the target number of points with exactly three different integers from the list. Parameters: t (int): Target number of points. n (int): Number of tickets. tickets (list of int): List of ticket values. Returns: str: \\"YES\\" if the target can be matched, otherwise \\"NO\\". >>> can_match_target_with_three_numbers(15, 5, [1, 2, 4, 8, 9]) \\"YES\\" >>> can_match_target_with_three_numbers(10, 4, [5, 5, 5, 5]) \\"NO\\"","solution":"def can_match_target_with_three_numbers(t, n, tickets): Determine if it's possible to match the target number of points with exactly three different integers from the list. Parameters: t (int): Target number of points. n (int): Number of tickets. tickets (list of int): List of ticket values. Returns: str: \\"YES\\" if the target can be matched, otherwise \\"NO\\". # Sort the tickets for easier combination tickets.sort() # Try to find any combination of three different integers which sum up to the target for i in range(n-2): for j in range(i+1, n-1): for k in range(j+1, n): if tickets[i] + tickets[j] + tickets[k] == t: return \\"YES\\" return \\"NO\\""},{"question":"def distribute_crops(T: int, test_cases: List[Dict[str, Tuple[int, List[int]]]]) -> List[List[List[int]]]: Distribute the crops over the fields and years according to Farmer Joe's plan. >>> T = 1 >>> test_cases = [{'FM': (3, 3), 'crops': [0, 1, 2]}] >>> distribute_crops(T, test_cases) [ [ [0, 1, 2], [1, 2, 0], [2, 0, 1] ] ] >>> T = 1 >>> test_cases = [{'FM': (2, 2), 'crops': [0, 1]}] >>> distribute_crops(T, test_cases) [ [ [0, 1], [1, 0] ] ]","solution":"def distribute_crops(T, test_cases): results = [] for i in range(T): F, M = test_cases[i]['FM'] crops = test_cases[i]['crops'] # Generate the crop rotation plan field_rotations = [] for field in range(F): rotation = [] for year in range(M): rotation.append((crops[field] + year) % M) field_rotations.append(rotation) results.append(field_rotations) return results"},{"question":"def reduce_string(s: str) -> int: Determine the length of a string after repeatedly removing pairs of neighboring identical characters. Args: s (str): Input string consisting of lowercase Latin letters. Returns: int: Length of the string after all possible reductions. Examples: >>> reduce_string(\\"abbac\\") 1 >>> reduce_string(\\"aabb\\") 0 >>> reduce_string(\\"abc\\") 3 >>> reduce_string(\\"aaaa\\") 0 from solution import reduce_string def test_reduce_string_example1(): assert reduce_string(\\"abbac\\") == 1 def test_reduce_string_example2(): assert reduce_string(\\"aabb\\") == 0 def test_reduce_string_example3(): assert reduce_string(\\"abc\\") == 3 def test_reduce_string_example4(): assert reduce_string(\\"aaaa\\") == 0 def test_reduce_string_single_char(): assert reduce_string(\\"a\\") == 1 def test_reduce_string_no_reduction(): assert reduce_string(\\"abcdef\\") == 6 def test_reduce_string_nested_pairs(): assert reduce_string(\\"abbaaccaa\\") == 1 def test_reduce_string_alternating_pairs(): assert reduce_string(\\"abababab\\") == 8 def test_reduce_string_mixed_chars(): assert reduce_string(\\"abccba\\") == 0","solution":"def reduce_string(s: str) -> int: Returns the length of the string after performing reduction operations. Reduction operations involve removing pairs of neighboring identical characters. stack = [] for ch in s: if stack and stack[-1] == ch: stack.pop() else: stack.append(ch) return len(stack)"},{"question":"from typing import List, Tuple def can_route_with_sufficient_width(n: int, m: int, roads: List[Tuple[int, int, int]], s: int, t: int, p: int) -> str: Determine if there is a route with sufficient width for a given number of people to travel from a specified starting castle to a specified destination castle. Parameters: n (int): Number of castles m (int): Number of roads roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, w indicating a road between castles u and v with width w s (int): Starting castle t (int): Destination castle p (int): Number of people Returns: str: \\"YES\\" if there is a route with sufficient width for p people, \\"NO\\" otherwise. Examples: >>> can_route_with_sufficient_width(4, 5, [(1, 2, 8), (1, 3, 10), (2, 3, 5), (2, 4, 7), (3, 4, 6)], 1, 4, 7) \\"YES\\" >>> can_route_with_sufficient_width(4, 3, [(1, 2, 4), (2, 3, 5), (3, 4, 3)], 1, 4, 5) \\"NO\\" pass def test_route_possible(): assert can_route_with_sufficient_width(4, 5, [(1, 2, 8), (1, 3, 10), (2, 3, 5), (2, 4, 7), (3, 4, 6)], 1, 4, 7) == \\"YES\\" def test_route_not_possible(): assert can_route_with_sufficient_width(4, 3, [(1, 2, 4), (2, 3, 5), (3, 4, 3)], 1, 4, 5) == \\"NO\\" def test_route_possible_edge_case(): assert can_route_with_sufficient_width(2, 1, [(1, 2, 1000000000)], 1, 2, 1) == \\"YES\\" def test_route_not_possible_edge_case(): assert can_route_with_sufficient_width(2, 1, [(1, 2, 999999999)], 1, 2, 1000000000) == \\"NO\\" def test_large_route_possible(): assert can_route_with_sufficient_width(5, 6, [(1, 2, 8), (1, 3, 5), (2, 3, 10), (2, 4, 7), (3, 4, 6), (4, 5, 100)], 1, 5, 6) == \\"YES\\" def test_large_route_not_possible(): assert can_route_with_sufficient_width(5, 6, [(1, 2, 5), (1, 3, 4), (2, 3, 3), (2, 4, 7), (3, 4, 6), (4, 5, 2)], 1, 5, 5) == \\"NO\\"","solution":"from heapq import heappush, heappop from collections import defaultdict def can_route_with_sufficient_width(n, m, roads, s, t, p): def dijkstra(start): max_width = [0] * (n + 1) max_width[start] = float('inf') # Since any road width is possible initially pq = [(-float('inf'), start)] # Max-heap based on path width while pq: width, u = heappop(pq) width = -width if width < max_width[u]: continue for v, w in graph[u]: new_width = min(width, w) if new_width > max_width[v]: max_width[v] = new_width heappush(pq, (-new_width, v)) return max_width # Build the graph graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Get the maximum width paths from s to all other nodes max_width = dijkstra(s) # The maximum width path from s to t should be at least p return \\"YES\\" if max_width[t] >= p else \\"NO\\""},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. start, max_length = 0, 0 used_char = {} for i, char in enumerate(s): if char in used_char and start <= used_char[char]: start = used_char[char] + 1 else: max_length = max(max_length, i - start + 1) used_char[char] = i return max_length"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to convert the input string into a palindrome. >>> min_operations_to_palindrome(\\"abc\\") 2 >>> min_operations_to_palindrome(\\"race\\") 3 >>> min_operations_to_palindrome(\\"abbac\\") 1 from solution import min_operations_to_palindrome def test_min_operations_to_palindrome_sample1(): assert min_operations_to_palindrome('abc') == 2 def test_min_operations_to_palindrome_sample2(): assert min_operations_to_palindrome('race') == 3 def test_min_operations_to_palindrome_sample3(): assert min_operations_to_palindrome('abbac') == 1 def test_min_operations_to_palindrome_single_char(): assert min_operations_to_palindrome('a') == 0 def test_min_operations_to_palindrome_already_palindrome(): assert min_operations_to_palindrome('madam') == 0 assert min_operations_to_palindrome('racecar') == 0 def test_min_operations_to_palindrome_long_palindrome(): assert min_operations_to_palindrome('abcdedcba') == 0 def test_min_operations_to_palindrome_mixed_chars(): assert min_operations_to_palindrome('aabb') == 2 assert min_operations_to_palindrome('abca') == 1 def test_min_operations_to_palindrome_complex_case(): assert min_operations_to_palindrome('abcd') == 3 assert min_operations_to_palindrome('abccba') == 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to convert the input string into a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] # Build the table in bottom-up manner. for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l+1][r-1] else: dp[l][r] = 1 + min(dp[l+1][r], dp[l][r-1]) return dp[0][n-1]"},{"question":"def find_common_rides(k1, k2, k3, alice_rides, bob_rides, charlie_rides): Returns the list of common rides that appear in all three lists. Args: k1 (int): Number of rides in Alice's list. k2 (int): Number of rides in Bob's list. k3 (int): Number of rides in Charlie's list. alice_rides (List[int]): List of ride IDs that Alice wants to try. bob_rides (List[int]): List of ride IDs that Bob wants to try. charlie_rides (List[int]): List of ride IDs that Charlie wants to try. Returns: List[int]: First element is the count of common rides. Following elements are the ride IDs. >>> find_common_rides(4, 5, 4, [10, 30, 50, 70], [10, 20, 30, 50, 80], [10, 30, 50, 90]) [3, 10, 30, 50] >>> find_common_rides(3, 3, 3, [1, 2, 3], [4, 5, 6], [7, 8, 9]) [0] >>> find_common_rides(3, 3, 3, [1, 2, 3], [1, 2, 3], [1, 2, 3]) [3, 1, 2, 3] >>> find_common_rides(4, 5, 6, [10, 10, 30, 30], [10, 20, 30, 50, 30], [10, 30, 30, 50, 90, 10]) [2, 10, 30]","solution":"def find_common_rides(k1, k2, k3, alice_rides, bob_rides, charlie_rides): Returns the list of common rides that appear in all three lists. alice_set = set(alice_rides) bob_set = set(bob_rides) charlie_set = set(charlie_rides) common_rides = list(alice_set & bob_set & charlie_set) common_rides.sort() return [len(common_rides)] + common_rides"},{"question":"def rotateMatrix(matrix): Rotates the given square matrix by 90 degrees clockwise. Args: matrix (list of list of int): A 2D square matrix. Returns: list of list of int: The rotated matrix. Example: >>> rotateMatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotateMatrix(matrix): Rotates the given square matrix by 90 degrees clockwise. Args: matrix (list of list of int): A 2D square matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) # Create a new matrix of the same size rotated_matrix = [[0] * n for _ in range(n)] # Populate the new matrix with rotated values for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def kth_smallest(numbers, queries): Given a list of integers and queries, return the k-th smallest odd or even number for each query. Args: numbers (list of int): List of integers. queries (list of tuples): List of queries, each is a tuple with a string (\\"odd\\" or \\"even\\") and an integer k. Returns: list of int: Results for each query. Examples: >>> kth_smallest([4, 2, 7, 1, 3], [(\\"odd\\", 2), (\\"even\\", 1)]) [3, 2] >>> kth_smallest([4, 2, 7, 1, 3], [(\\"odd\\", 4), (\\"even\\", 3)]) [-1, -1] >>> kth_smallest([1, 3, 5, 7, 9], [(\\"odd\\", 3), (\\"even\\", 1)]) [5, -1] >>> kth_smallest([2, 4, 6, 8, 10], [(\\"odd\\", 1), (\\"even\\", 2)]) [-1, 4] >>> kth_smallest([], [(\\"odd\\", 1), (\\"even\\", 1)]) [-1, -1] >>> kth_smallest([2, 4, 6], [(\\"even\\", 3)]) [6]","solution":"def kth_smallest(numbers, queries): Given a list of integers and queries, return the k-th smallest odd or even number for each query. def get_kth_smallest(nums, k, parity): if parity == \\"odd\\": filtered_nums = sorted([num for num in nums if num % 2 != 0]) elif parity == \\"even\\": filtered_nums = sorted([num for num in nums if num % 2 == 0]) if len(filtered_nums) < k: return -1 else: return filtered_nums[k - 1] results = [] for parity, k in queries: result = get_kth_smallest(numbers, k, parity) results.append(result) return results"},{"question":"def can_complete_tasks(n: int, m: int, t: List[int], d: List[Tuple[int, int]]) -> str: Determine if it is possible to reorder tasks to meet all dependencies. :param n: Integer - Number of tasks :param m: Integer - Number of dependencies :param t: List of integers - Times to complete each task :param d: List of tuples - Dependencies (a, b) indicating task b depends on task a :return: String - \\"Yes\\" if possible to complete all tasks, \\"No\\" otherwise >>> can_complete_tasks(5, 0, [3, 2, 1, 4, 5], []) \\"Yes\\" >>> can_complete_tasks(5, 4, [3, 2, 1, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"Yes\\" >>> can_complete_tasks(5, 5, [3, 2, 1, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"No\\" >>> can_complete_tasks(4, 4, [3, 2, 1, 4], [(1, 2), (2, 4), (1, 3), (3, 4)]) \\"Yes\\" >>> can_complete_tasks(1, 0, [1], []) \\"Yes\\" >>> can_complete_tasks(1, 1, [1], [(1, 1)]) \\"No\\"","solution":"def can_complete_tasks(n, m, t, d): Determine if it is possible to reorder tasks to meet all dependencies. :param n: Integer - Number of tasks :param m: Integer - Number of dependencies :param t: List of integers - Times to complete each task :param d: List of tuples - Dependencies (a, b) indicating task b depends on task a :return: String - \\"Yes\\" if possible to complete all tasks, \\"No\\" otherwise from collections import defaultdict, deque # Create adjacency list and in-degree array for tasks adj_list = defaultdict(list) in_degree = [0] * n # Build the graph for a, b in d: adj_list[a-1].append(b-1) # converting to 0-based indexing in_degree[b-1] += 1 # Use a queue for nodes with no dependencies queue = deque([i for i in range(n) if in_degree[i] == 0]) completed_tasks = 0 # Number of tasks that can be completed in order # Process tasks using Kahn's Algorithm for Topological Sorting while queue: task = queue.popleft() completed_tasks += 1 for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If number of completed tasks equals the number of tasks, return \\"Yes\\" return \\"Yes\\" if completed_tasks == n else \\"No\\""},{"question":"def can_mark_palindromic_subsequence(s: str) -> str: Determine if it's possible to mark at least one valid contiguous subsequence according to the rules. Args: s (str): input string consisting of lowercase English letters Returns: str: 'YES' if it's possible to mark at least one valid subsequence, 'NO' otherwise >>> can_mark_palindromic_subsequence(\\"ababa\\") 'YES' >>> can_mark_palindromic_subsequence(\\"abcdef\\") 'NO' >>> can_mark_palindromic_subsequence(\\"cacbacbacacb\\") 'YES' >>> can_mark_palindromic_subsequence(\\"ghijkl\\") 'NO'","solution":"def can_mark_palindromic_subsequence(s): Determine if it's possible to mark at least one valid contiguous subsequence according to the given rules. Args: s (str): input string consisting of lowercase English letters Returns: str: 'YES' if it's possible to mark at least one valid subsequence, 'NO' otherwise n = len(s) for i in range(n): for j in range(i + 1, n): if s[i] == s[j]: substring = s[i:j+1] if substring == substring[::-1]: return \\"YES\\" return \\"NO\\""},{"question":"def min_time_to_reach(X: int, Y: int) -> int: Returns the minimum time required to reach the point (X, Y) from (0, 0). Each move to an adjacent point (including diagonals) takes 1 second. >>> min_time_to_reach(3, 4) 4 >>> min_time_to_reach(-1, -3) 3 >>> min_time_to_reach(5, 5) 5 >>> min_time_to_reach(0, 0) 0 >>> min_time_to_reach(7, -8) 8 >>> min_time_to_reach(-10, -10) 10 def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Returns a list of minimum times required for each test case. >>> solve([(3, 4), (-1, -3), (5, 5)]) [4, 3, 5] >>> solve([(0, 0), (7, -8), (-10, -10)]) [0, 8, 10] >>> solve([(1, 1), (-1, -1), (0, 8), (10, -5)]) [1, 1, 8, 10]","solution":"def min_time_to_reach(X, Y): Returns the minimum time required to reach the point (X, Y) from (0, 0). Each move to an adjacent point (including diagonals) takes 1 second. return max(abs(X), abs(Y)) def solve(test_cases): results = [] for x, y in test_cases: results.append(min_time_to_reach(x, y)) return results"},{"question":"def is_prime(n: int) -> bool: Determine if a given number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(29) True >>> is_prime(30) False def is_sum_of_t_primes(k: int, t: int) -> bool: Determine if it's possible to express K as a sum of exactly T prime numbers. >>> is_sum_of_t_primes(10, 2) True >>> is_sum_of_t_primes(11, 2) True >>> is_sum_of_t_primes(12, 2) True >>> is_sum_of_t_primes(4, 2) True >>> is_sum_of_t_primes(6, 2) True >>> is_sum_of_t_primes(8, 2) True >>> is_sum_of_t_primes(9, 5) False >>> is_sum_of_t_primes(15, 3) True >>> is_sum_of_t_primes(1, 1) False >>> is_sum_of_t_primes(5, 1) True def main(): import sys input = sys.stdin.read k, t = map(int, input().strip().split()) if is_sum_of_t_primes(k, t): print(\\"Yes\\") else: print(\\"No\\")","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_sum_of_t_primes(k, t): if t == 1: return is_prime(k) if t * 2 > k: return False if t == 2: return True for i in range(2, k + 1): if is_prime(i) and is_sum_of_t_primes(k - i, t - 1): return True return False def main(): import sys input = sys.stdin.read k, t = map(int, input().strip().split()) if is_sum_of_t_primes(k, t): print(\\"Yes\\") else: print(\\"No\\")"},{"question":"from typing import List, Dict, Union def merge_user_entries(user_entries: List[Dict[str, Union[str, Dict[str, str]]]]) -> List[Dict[str, Union[str, Dict[str, str]]]]: Merge duplicate user entries by combining their fields dictionaries and return the cleaned-up list of user entries sorted by email in ascending order. Args: user_entries: List[Dict[str, Union[str, Dict[str, str]]]]: A list of user entries where each entry is represented as a dictionary containing user's email and fields. Returns: List[Dict[str, Union[str, Dict[str, str]]]]: A list of merged user entries, sorted by email in ascending order. Example: >>> user_entries = [ ... {\\"email\\": \\"john.doe@example.com\\", \\"fields\\": {\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\"}}, ... {\\"email\\": \\"jane.smith@example.com\\", \\"fields\\": {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\"}}, ... {\\"email\\": \\"john.doe@example.com\\", \\"fields\\": {\\"age\\": \\"30\\", \\"city\\": \\"New York\\"}}, ... {\\"email\\": \\"john.doe@example.com\\", \\"fields\\": {\\"city\\": \\"San Francisco\\"}} ... ] >>> merge_user_entries(user_entries) [ {\\"email\\": \\"jane.smith@example.com\\", \\"fields\\": {\\"first_name\\": \\"Jane\\", \\"last_name\\": \\"Smith\\"}}, {\\"email\\": \\"john.doe@example.com\\", \\"fields\\": {\\"first_name\\": \\"John\\", \\"last_name\\": \\"Doe\\", \\"age\\": \\"30\\", \\"city\\": \\"New York, San Francisco\\"}} ]","solution":"from typing import List, Dict, Union def merge_user_entries(user_entries: List[Dict[str, Union[str, Dict[str, str]]]]) -> List[Dict[str, Union[str, Dict[str, str]]]]: merged_users = {} for entry in user_entries: email = entry['email'] fields = entry['fields'] if email not in merged_users: merged_users[email] = {} for key, value in fields.items(): if key in merged_users[email]: merged_users[email][key] += f\\", {value}\\" else: merged_users[email][key] = value result = [] for email, fields in merged_users.items(): result.append({\\"email\\": email, \\"fields\\": fields}) return sorted(result, key=lambda x: x['email'])"},{"question":"from typing import List, Tuple def max_discount_days(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, find the maximum number of discount days where a discount day is always sandwiched between two days with higher prices. A day \`i\` is a discount day if prices[i-1] > prices[i] < prices[i+1]. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer and a list of integers representing the prices on the days. Returns: List[int]: A list of integers representing the maximum number of discount days for each test case. Examples: >>> max_discount_days(3, [(5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (7, [12, 11, 10, 9, 10, 11, 12])]) [1, 0, 1] >>> max_discount_days(1, [(3, [1, 2, 3])]) [0]","solution":"def max_discount_days(T, test_cases): results = [] for i in range(T): N, prices = test_cases[i] discount_days = 0 for j in range(1, N-1): if prices[j-1] > prices[j] < prices[j+1]: discount_days += 1 results.append(discount_days) return results"},{"question":"def can_rearrange_books(N: int, books: List[int]) -> str: Determine if it is possible to rearrange the books such that the sum of the number of books in odd positions and the number of books in even positions on the shelf are equal. Args: N (int): The number of books. books (List[int]): List of integers representing the number of books at each position. Returns: str: \\"YES\\" if it's possible to rearrange the books to follow the rule, otherwise \\"NO\\". >>> can_rearrange_books(5, [3, 1, 4, 2, 8]) 'YES' >>> can_rearrange_books(4, [1, 2, 5, 9]) 'NO' # Your code here...","solution":"def can_rearrange_books(N, books): total_books = sum(books) if total_books % 2 != 0: return \\"NO\\" possible_half_sum = total_books // 2 # Use of a set to track possible sums of subsets possible_sums = {0} for book in books: new_sums = set() for ps in possible_sums: new_sums.add(ps + book) possible_sums.update(new_sums) if possible_half_sum in possible_sums: return \\"YES\\" return \\"NO\\""},{"question":"def has_subarray_sum(arr: List[int], target: int) -> bool: Returns True if there exists a subarray with sum equal to target, otherwise False. >>> has_subarray_sum([1, 2, 3, 4, 5], 9) True >>> has_subarray_sum([1, 2, 3], 6) True >>> has_subarray_sum([-1, -2, -3, -4, -5], -9) True >>> has_subarray_sum([1, 2, 3, 4, 5], 20) False","solution":"def has_subarray_sum(arr, target): Returns True if there exists a subarray with sum equal to target, otherwise False. current_sum = 0 seen_sums = set() for num in arr: current_sum += num if current_sum == target: return True if (current_sum - target) in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"def transform_grid(n, m, initial_grid, target_grid): Transforms the initial grid into the target grid with the minimum number of add operations. Returns the number of operations required and the operations themselves. Parameters: n (int): number of rows m (int): number of columns initial_grid (List[List[int]]): the initial grid configuration target_grid (List[List[int]]): the target grid configuration Returns: int: number of operations required List[str]: list of operations in the format \\"ADD row x value\\" or \\"ADD column y value\\" >>> transform_grid(2, 2, [[1, 2], [3, 4]], [[2, 3], [4, 5]]) (2, [\\"ADD row 0 1\\", \\"ADD row 1 1\\"]) >>> transform_grid(3, 3, [[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]]) (3, [\\"ADD row 0 3\\", \\"ADD row 1 3\\", \\"ADD row 2 3\\"]) def test_transform_grid_1(): n, m = 2, 2 initial_grid = [ [1, 2], [3, 4] ] target_grid = [ [2, 3], [4, 5] ] expected_operations = [ \\"ADD row 0 1\\", \\"ADD row 1 1\\" ] k, operations = transform_grid(n, m, initial_grid, target_grid) assert k == len(expected_operations) assert operations == expected_operations def test_transform_grid_2(): n, m = 3, 3 initial_grid = [ [1, 1, 1], [2, 2, 2], [3, 3, 3] ] target_grid = [ [4, 4, 4], [5, 5, 5], [6, 6, 6] ] expected_operations = [ \\"ADD row 0 3\\", \\"ADD row 1 3\\", \\"ADD row 2 3\\" ] k, operations = transform_grid(n, m, initial_grid, target_grid) assert k == len(expected_operations) assert operations == expected_operations def test_transform_grid_3(): n, m = 2, 3 initial_grid = [ [1, 2, 3], [4, 5, 6] ] target_grid = [ [2, 3, 4], [5, 6, 7] ] expected_operations = [ \\"ADD row 0 1\\", \\"ADD row 1 1\\" ] k, operations = transform_grid(n, m, initial_grid, target_grid) assert k == len(expected_operations) assert operations == expected_operations def test_transform_grid_4(): n, m = 3, 2 initial_grid = [ [1, 2], [3, 4], [5, 6] ] target_grid = [ [3, 4], [5, 6], [7, 8] ] expected_operations = [ \\"ADD row 0 2\\", \\"ADD row 1 2\\", \\"ADD row 2 2\\" ] k, operations = transform_grid(n, m, initial_grid, target_grid) assert k == len(expected_operations) assert operations == expected_operations","solution":"def transform_grid(n, m, initial_grid, target_grid): Transforms the initial grid into the target grid with the minimum number of add operations. Returns the number of operations required and the operations themselves. operations = [] # Calculate row differences and handle row operations for row in range(n): difference = target_grid[row][0] - initial_grid[row][0] if difference != 0: operations.append(f\\"ADD row {row} {difference}\\") for col in range(m): initial_grid[row][col] += difference # Calculate column differences and handle column operations for col in range(m): difference = target_grid[0][col] - initial_grid[0][col] if difference != 0: operations.append(f\\"ADD column {col} {difference}\\") for row in range(n): initial_grid[row][col] += difference return len(operations), operations"},{"question":"from typing import List, Tuple def shortest_delivery_time(n: int, m: int, roads: List[Tuple[int, int, int]], weather: str) -> List[int]: Computes the shortest delivery times from the post office (house 1) to all other houses using Dijkstra's algorithm. If the weather is rainy, travel times are doubled. Parameters: n (int): Number of houses m (int): Number of roads roads (list): List of tuples where each tuple contains (u, v, t), indicating a road between house u and house v with travel time t on a sunny day weather (str): 'sunny' or 'rainy' indicating the weather condition Returns: list: Shortest delivery time to each house from house 1. If the house is not reachable, return -1 for that house. >>> shortest_delivery_time(4, 4, [(1, 2, 5), (1, 3, 10), (2, 4, 5), (3, 4, 5)], \\"sunny\\") [5, 10, 10] >>> shortest_delivery_time(4, 4, [(1, 2, 5), (1, 3, 10), (2, 4, 5), (3, 4, 5)], \\"rainy\\") [10, 20, 20]","solution":"import heapq def shortest_delivery_time(n, m, roads, weather): Computes the shortest delivery times from the post office (house 1) to all other houses using Dijkstra's algorithm. If the weather is rainy, travel times are doubled. Parameters: n (int): Number of houses m (int): Number of roads roads (list): List of tuples where each tuple contains (u, v, t), indicating a road between house u and house v with travel time t on a sunny day weather (str): 'sunny' or 'rainy' indicating the weather condition Returns: list: Shortest delivery time to each house from house 1. If the house is not reachable, return -1 for that house. graph = {i: [] for i in range(1, n+1)} for u, v, t in roads: travel_time = t if weather == \\"sunny\\" else 2 * t graph[u].append((travel_time, v)) graph[v].append((travel_time, u)) def dijkstra(source): dist = {i: float('inf') for i in range(1, n+1)} dist[source] = 0 min_heap = [(0, source)] visited = set() while min_heap: current_dist, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) for travel_time, v in graph[u]: if v not in visited: old_cost = dist[v] new_cost = current_dist + travel_time if new_cost < old_cost: dist[v] = new_cost heapq.heappush(min_heap, (new_cost, v)) return dist distances = dijkstra(1) result = [] for i in range(2, n+1): result.append(distances[i] if distances[i] != float('inf') else -1) return result"},{"question":"from typing import List def maximum_product(nums: List[int]) -> int: Given an integer array nums, find three numbers whose product is maximum and return the maximum product. Examples: >>> maximum_product([1, 2, 3]) == 6 >>> maximum_product([1, 2, 3, 4]) == 24 >>> maximum_product([-1, -2, -3]) == -6 >>> maximum_product([-100, -98, -1, 2, 3, 4]) == 39200","solution":"from typing import List def maximum_product(nums: List[int]) -> int: Returns the maximum product of any three numbers in the list nums. # Sort the array in non-decreasing order nums.sort() # The maximum product can be either: # 1. The product of the three largest numbers at the end of the list product1 = nums[-1] * nums[-2] * nums[-3] # 2. The product of the two smallest numbers (which could be negative) and the largest number product2 = nums[0] * nums[1] * nums[-1] return max(product1, product2)"},{"question":"from typing import List from collections import defaultdict, deque class Graph: def __init__(self, n: int, values: List[int], edges: List[List[int]]): Initialize the graph with n nodes, their values, and the edges. def query1(self, u: int, x: int) -> None: Given a node 'u', update the value of this node to 'x'. def query2(self, u: int, d: int) -> int: Given a node 'u' and a distance 'd', return the sum of the values of all nodes that are at a distance 'd' from the node 'u'. import pytest def test_query_updates_and_sums(): n = 5 values = [1, 2, 3, 4, 5] edges = [[1, 2], [1, 3], [2, 4], [2, 5]] g = Graph(n, values, edges) assert g.query2(1, 1) == 5 # Nodes at distance 1 from 1: [2(2), 3(3)] => 2 + 3 = 5 g.query1(2, 10) assert g.query2(1, 1) == 13 # Nodes at distance 1 from 1: [2(10), 3(3)] => 10 + 3 = 13 def test_query_distances(): n = 4 values = [5, 5, 5, 5] edges = [[1, 2], [1, 3], [1, 4]] g = Graph(n, values, edges) assert g.query2(1, 1) == 15 # Nodes at distance 1 from 1: [2(5), 3(5), 4(5)] => 5 + 5 + 5 = 15 g.query1(3, 10) assert g.query2(1, 1) == 20 # Nodes at distance 1 from 1: [2(5), 3(10), 4(5)] => 5 + 10 + 5 = 20 def test_no_nodes_at_given_distance(): n = 3 values = [1, 2, 3] edges = [[1, 2], [2, 3]] g = Graph(n, values, edges) assert g.query2(1, 2) == 3 # Only node 3 is at distance 2 from 1 (1 -> 2 -> 3) assert g.query2(1, 3) == 0 # No node is at distance 3 pytest.main()","solution":"from collections import deque, defaultdict class Graph: def __init__(self, n, values, edges): self.n = n self.values = values self.adj_list = defaultdict(list) for u, v in edges: self.adj_list[u].append(v) self.adj_list[v].append(u) def query1(self, u, x): self.values[u - 1] = x def query2(self, u, d): # Breadth-First Search to determine distances queue = deque([(u, 0)]) visited = [False] * (self.n + 1) visited[u] = True result_sum = 0 while queue: current_node, current_distance = queue.popleft() if current_distance == d: result_sum += self.values[current_node - 1] if current_distance < d: for neighbor in self.adj_list[current_node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, current_distance + 1)) return result_sum"},{"question":"def min_moves_to_transform(words, target): Returns the minimum number of moves required to transform the array of words into the target string. Each move changes one character in one word. :param words: List of strings, where each string is the same length as the target string. :param target: Target string that we want each word to be transformed to. :return: Minimum number of moves required. pass # Test cases def test_min_moves_to_transform_example(): assert min_moves_to_transform([\\"abc\\", \\"acb\\", \\"bac\\"], \\"bca\\") == 7 def test_min_moves_to_transform_identical_words(): assert min_moves_to_transform([\\"abc\\", \\"abc\\", \\"abc\\"], \\"abc\\") == 0 def test_min_moves_to_transform_single_char_words(): assert min_moves_to_transform([\\"a\\", \\"b\\", \\"c\\"], \\"d\\") == 3 def test_min_moves_to_transform_partially_different(): assert min_moves_to_transform([\\"aaa\\", \\"aab\\", \\"abb\\"], \\"abc\\") == 5 def test_min_moves_to_transform_longer_words(): assert min_moves_to_transform([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"mnop\\") == 12","solution":"def min_moves_to_transform(words, target): Returns the minimum number of moves required to transform the array of words into the target string. Each move changes one character in one word. :param words: List of strings, where each string is the same length as the target string. :param target: Target string that we want each word to be transformed to. :return: Minimum number of moves required. moves = 0 for word in words: for i in range(len(word)): if word[i] != target[i]: moves += 1 return moves"},{"question":"def can_make_identical(n, S, T): Determines if two strings S and T of equal length n can be made identical by reversing any non-empty substring of them any number of times. Args: n (int): The length of the strings S and T. S (str): The first string. T (str): The second string. Returns: str: \\"YES\\" if the strings can be made identical, \\"NO\\" otherwise. Examples: >>> can_make_identical(5, \\"abcdef\\", \\"fedcba\\") \\"YES\\" >>> can_make_identical(3, \\"xyz\\", \\"axz\\") \\"NO\\" >>> can_make_identical(4, \\"abba\\", \\"abab\\") \\"YES\\"","solution":"def can_make_identical(n, S, T): Determines if two strings S and T of equal length n can be made identical by reversing any non-empty substring of them any number of times. Args: n (int): The length of the strings S and T. S (str): The first string. T (str): The second string. Returns: str: \\"YES\\" if the strings can be made identical, \\"NO\\" otherwise. return \\"YES\\" if sorted(S) == sorted(T) else \\"NO\\""},{"question":"def minimum_total_distance(n, distances): Calculates the minimum total distance for the race such that each student runs at least their minimum distance. Args: n (int): The number of students. distances (List[int]): The minimum distances each student must cover. Returns: int: The minimum total distance for the race. >>> minimum_total_distance(3, [5, 10, 8]) 23 >>> minimum_total_distance(4, [3, 7, 2, 6]) 18 pass def process_input(input_data): Parses the input data and returns a list of results for each dataset. Args: input_data (str): The input data as a string. Returns: List[int]: A list of results for each dataset. >>> process_input(\\"3n5 10 8n4n3 7 2 6n0n\\") [23, 18] >>> process_input(\\"1n100n0n\\") [100] pass","solution":"def minimum_total_distance(n, distances): Calculates the minimum total distance for the race such that each student runs at least their minimum distance. return sum(distances) def process_input(input_data): Parses the input data and returns a list of results for each dataset. results = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): if lines[i] == '0': break n = int(lines[i]) distances = list(map(int, lines[i+1].split())) results.append(minimum_total_distance(n, distances)) i += 2 return results"},{"question":"def find_largest_group(Q: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Find the largest group of students with the same score and the corresponding score of that group. In case of ties, select the highest score among them. Args: Q (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer N (number of students) and a list S of length N representing the scores of the students. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers: the size of the largest group and the score of that group. >>> find_largest_group(3, [(6, [70, 80, 90, 90, 80, 70]), (10, [1, 1, 1, 2, 2, 2, 3, 3, 3, 4]), ... (5, [50, 50, 50, 50, 50])]) [(2, 90), (3, 3), (5, 50)]","solution":"def find_largest_group(Q, test_cases): results = [] for i in range(Q): N = test_cases[i][0] scores = test_cases[i][1] # Creating a frequency dictionary to count occurrences of each score score_counts = {} for score in scores: if score in score_counts: score_counts[score] += 1 else: score_counts[score] = 1 # Finding the largest group and its score max_size = 0 max_score = 0 for score, count in score_counts.items(): if count > max_size or (count == max_size and score > max_score): max_size = count max_score = score results.append((max_size, max_score)) return results"},{"question":"def number_of_moves_to_blow_out_candles(n: int, heights: List[int]) -> int: Returns the number of moves required to blow out all the candles by repeatedly blowing out the tallest candles. :param n: the number of candles, an integer :param heights: a list of integers representing the heights of the candles :return: an integer, the number of moves required to blow out all the candles >>> number_of_moves_to_blow_out_candles(5, [2, 3, 1, 3, 2]) 3 >>> number_of_moves_to_blow_out_candles(4, [4, 4, 4, 4]) 1 >>> number_of_moves_to_blow_out_candles(1, [1]) 1 >>> number_of_moves_to_blow_out_candles(6, [2, 2, 2, 2, 3, 4]) 3 pass","solution":"def number_of_moves_to_blow_out_candles(n, heights): Returns the number of moves required to blow out all the candles by repeatedly blowing out the tallest candles. :param n: the number of candles, an integer :param heights: a list of integers representing the heights of the candles :return: an integer, the number of moves required to blow out all the candles moves = 0 while any(heights): max_height = max(heights) heights = [height if height != max_height else 0 for height in heights] moves += 1 return moves"},{"question":"def max_sum_under_k(N, K, card_values): Finds the maximum sum of a contiguous sequence of card values such that the sum does not exceed K. Parameters: N (int): Number of cards K (int): Maximum allowed sum for any sequence card_values (list[int]): List of integers representing card power values Returns: int: Maximum sum of any valid contiguous sequence of card values >>> max_sum_under_k(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_sum_under_k(3, 5, [2, 2, 2]) 4 >>> max_sum_under_k(1, 10, [10]) 10 >>> max_sum_under_k(1, 5, [10]) 0 >>> max_sum_under_k(4, 10, [-1, -2, -3, -4]) 0 >>> max_sum_under_k(5, 6, [1, -1, 5, 2, -2]) 6 >>> max_sum_under_k(5, 7, [1, -1, 5, 2, -2]) 7 def process_test_cases(T, test_cases): Processes multiple test cases for the card game problem. Parameters: T (int): Number of test cases test_cases (list[tuple]): A list of tuples where each tuple contains: N (int): Number of cards K (int): Maximum allowed sum card_values (list[int]): List of card power values Returns: list[int]: List of results for each test case >>> test_cases = [ ... (5, 10, [1, 2, 3, 4, 5]), ... (3, 5, [2, 2, 2]) ... ] >>> process_test_cases(2, test_cases) [10, 4]","solution":"def max_sum_under_k(N, K, card_values): Finds the maximum sum of a contiguous sequence of card values such that the sum does not exceed K. Parameters: N (int): Number of cards K (int): Maximum allowed sum for any sequence card_values (list[int]): List of integers representing card power values Returns: int: Maximum sum of any valid contiguous sequence of card values max_sum = 0 current_sum = 0 start = 0 for end in range(N): current_sum += card_values[end] while current_sum > K: current_sum -= card_values[start] start += 1 max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(T, test_cases): Processes multiple test cases for the card game problem. Parameters: T (int): Number of test cases test_cases (list[tuple]): A list of tuples where each tuple contains: N (int): Number of cards K (int): Maximum allowed sum card_values (list[int]): List of card power values Returns: list[int]: List of results for each test case results = [] for test in test_cases: N, K, card_values = test results.append(max_sum_under_k(N, K, card_values)) return results"},{"question":"def can_form_palindrome(input_string: str) -> tuple: Determine if a string can be rearranged to form a palindrome and provide one possible palindrome. >>> can_form_palindrome(\\"Tact Coa\\") (True, \\"tacocat\\") >>> can_form_palindrome(\\"Hello\\") (False, None)","solution":"def can_form_palindrome(input_string): from collections import Counter # Normalize string: remove spaces and convert to lowercase sanitized_string = ''.join(input_string.split()).lower() # Count character frequencies char_count = Counter(sanitized_string) # Count characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # More than one odd character count means it cannot form a palindrome if odd_count > 1: return (False, None) # Construct one possible palindrome left_half = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 != 0: middle_char = char left_half.extend([char] * (count // 2)) # Join left half, middle character and reverse of left half to form the palindrome palindrome = ''.join(left_half) + middle_char + ''.join(left_half[::-1]) return (True, palindrome)"},{"question":"def score_differences(m, n, scores): Given the number of students (m), number of subjects (n), and a list of scores for each student, calculates the difference between the highest and lowest scores for each student. :param m: Number of students :param n: Number of subjects :param scores: List of lists containing scores for each student :return: List of differences between highest and lowest scores for each student Example: >>> score_differences(3, 4, [[90, 85, 78, 92], [88, 77, 76, 84], [95, 88, 89, 91]]) [14, 12, 7] >>> score_differences(2, 5, [[55, 70, 67, 85, 66], [92, 88, 79, 85, 75]]) [30, 17]","solution":"def score_differences(m, n, scores): Given the number of students (m), number of subjects (n), and a list of scores for each student, calculates the difference between the highest and lowest scores for each student. :param m: Number of students :param n: Number of subjects :param scores: List of lists containing scores for each student :return: List of differences between highest and lowest scores for each student differences = [] for student_scores in scores: highest = max(student_scores) lowest = min(student_scores) differences.append(highest - lowest) return differences"},{"question":"def determine_winner(n: int, arr: List[int]) -> str: Determines the winner of the game between Alice and Bob. Parameters: n (int): Number of integers in the array arr (list): The list of integers in the array Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" otherwise Examples: >>> determine_winner(5, [1, 2, 3, 4, 5]) 'Bob' >>> determine_winner(4, [1, 2, 3, 4]) 'Alice' >>> determine_winner(3, [7, 8, 9]) 'Bob' def test_determine_winner_odd_elements(): assert determine_winner(5, [1, 2, 3, 4, 5]) == \\"Bob\\" assert determine_winner(3, [7, 8, 9]) == \\"Bob\\" def test_determine_winner_even_elements(): assert determine_winner(4, [1, 2, 3, 4]) == \\"Alice\\" assert determine_winner(2, [1, 2]) == \\"Alice\\" def test_determine_winner_single_element(): assert determine_winner(1, [1]) == \\"Bob\\" def test_determine_winner_large_input(): assert determine_winner(100000, list(range(1, 100001))) == \\"Alice\\" assert determine_winner(99999, list(range(1, 100000))) == \\"Bob\\" # Running the tests using pytest if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def determine_winner(n, arr): Determines the winner of the game between Alice and Bob. Parameters: n (int): Number of integers in the array arr (list): The list of integers in the array Returns: str: \\"Alice\\" if Alice wins the game, \\"Bob\\" otherwise # If the number of integers in the array is odd, Bob wins because Alice will be # left in the end with less than two integers to pick. if n % 2 == 1: return \\"Bob\\" else: return \\"Alice\\" # Example usage: # n = 5 # arr = [1, 2, 3, 4, 5] # determine_winner(n, arr)"},{"question":"def is_palindrome(num): Determines if the digits of the number form a palindrome. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(1234) False >>> is_palindrome(987789) True def determine_palindrome_status(numbers): For each number in the list, determine if it is a palindrome and print the result accordingly. >>> determine_palindrome_status([121, 12321, 1234, 987789]) [\\"Palindrome\\", \\"Palindrome\\", \\"Not Palindrome\\", \\"Palindrome\\"] >>> determine_palindrome_status([1, 22, 333, 4444]) [\\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\", \\"Palindrome\\"] >>> determine_palindrome_status([12345, 54321]) [\\"Not Palindrome\\", \\"Not Palindrome\\"] >>> determine_palindrome_status([678, 876]) [\\"Not Palindrome\\", \\"Not Palindrome\\"]","solution":"def is_palindrome(num): Determines if the digits of the number form a palindrome. num_str = str(num) return num_str == num_str[::-1] def determine_palindrome_status(numbers): For each number in the list, determine if it is a palindrome and print the result accordingly. results = [] for num in numbers: if is_palindrome(num): results.append(\\"Palindrome\\") else: results.append(\\"Not Palindrome\\") return results"},{"question":"def manage_appointments(appointments): Manage a hospital's appointment system by taking input describing appointments for multiple doctors and output a list of patients each doctor will see, ordered by appointment time. Args: appointments (list of str): List of strings where each string describes a single appointment in the format 'patient_name appointment_time doctor_name'. The list ends with a line containing the word 'END'. Returns: list of str: For each doctor, output the doctor’s name followed by the list of their appointments, sorted by the appointment time in ascending order. Example: >>> appointments = [ ... \\"John 10:30 DrSmith\\", ... \\"Jane 09:45 DrSmith\\", ... \\"Alice 13:00 DrJones\\", ... \\"Bob 15:30 DrSmith\\", ... \\"Charlie 12:15 DrJones\\", ... \\"END\\" ... ] >>> manage_appointments(appointments) [ \\"DrJones:\\", \\"Charlie at 12:15\\", \\"Alice at 13:00\\", \\"DrSmith:\\", \\"Jane at 09:45\\", \\"John at 10:30\\", \\"Bob at 15:30\\" ] pass def test_manage_appointments_example(): appointments = [ \\"John 10:30 DrSmith\\", \\"Jane 09:45 DrSmith\\", \\"Alice 13:00 DrJones\\", \\"Bob 15:30 DrSmith\\", \\"Charlie 12:15 DrJones\\", \\"END\\" ] expected_output = [ \\"DrJones:\\", \\"Charlie at 12:15\\", \\"Alice at 13:00\\", \\"DrSmith:\\", \\"Jane at 09:45\\", \\"John at 10:30\\", \\"Bob at 15:30\\" ] assert manage_appointments(appointments) == expected_output def test_manage_appointments_single_doctor(): appointments = [ \\"Anna 08:00 DrGreen\\", \\"Ben 10:00 DrGreen\\", \\"Claire 09:00 DrGreen\\", \\"END\\" ] expected_output = [ \\"DrGreen:\\", \\"Anna at 08:00\\", \\"Claire at 09:00\\", \\"Ben at 10:00\\" ] assert manage_appointments(appointments) == expected_output def test_manage_appointments_single_patient_each(): appointments = [ \\"Daniel 09:00 DrA\\", \\"Eve 10:00 DrB\\", \\"END\\" ] expected_output = [ \\"DrA:\\", \\"Daniel at 09:00\\", \\"DrB:\\", \\"Eve at 10:00\\" ] assert manage_appointments(appointments) == expected_output def test_manage_appointments_empty(): appointments = [ \\"END\\" ] expected_output = [] assert manage_appointments(appointments) == expected_output","solution":"def manage_appointments(appointments): from collections import defaultdict import datetime # Initialize a dictionary to hold appointments for each doctor doctor_appointments = defaultdict(list) # Parse the appointments and group them by doctor for appointment in appointments: if appointment == \\"END\\": break patient_name, appointment_time, doctor_name = appointment.split() doctor_appointments[doctor_name].append((patient_name, appointment_time)) # Output the sorted appointments for each doctor result = [] for doctor, appts in sorted(doctor_appointments.items()): result.append(f\\"{doctor}:\\") sorted_appts = sorted(appts, key=lambda x: datetime.datetime.strptime(x[1], \\"%H:%M\\")) for patient_name, appointment_time in sorted_appts: result.append(f\\"{patient_name} at {appointment_time}\\") return result"},{"question":"def is_leap_year(year): Determines if the given year is a leap year or not. >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(2004) True >>> is_leap_year(2001) False >>> is_leap_year(1996) True >>> is_leap_year(2100) False pass def leap_year_status(test_cases): For each person's birthdate, determine if they were born in a leap year. >>> test_cases = [['Alice 29/02/1988', 'Bob 15/08/1990', 'Charlie 01/01/2000'], ['Dave 12/12/1900', 'Eve 22/02/2004']] >>> leap_year_status(test_cases) ['Alice Leap', 'Bob Non-Leap', 'Charlie Leap', 'Dave Non-Leap', 'Eve Leap'] >>> test_cases = [['John 01/01/2024']] >>> leap_year_status(test_cases) ['John Leap'] >>> test_cases = [['John 01/01/2023', 'Jane 12/12/2019']] >>> leap_year_status(test_cases) ['John Non-Leap', 'Jane Non-Leap'] pass","solution":"def is_leap_year(year): Determines if the given year is a leap year or not. if year % 4 != 0: return False elif year % 100 != 0: return True elif year % 400 != 0: return False else: return True def leap_year_status(test_cases): For each person's birthdate, determine if they were born in a leap year. results = [] for case in test_cases: for person in case: name, birthdate = person.split() year = int(birthdate.split('/')[-1]) if is_leap_year(year): results.append(f\\"{name} Leap\\") else: results.append(f\\"{name} Non-Leap\\") return results"},{"question":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> findLongestSubstring(\\"abcabcbb\\") 3 >>> findLongestSubstring(\\"bbbbb\\") 1 >>> findLongestSubstring(\\"pwwkew\\") 3 >>> findLongestSubstring(\\"\\") 0 >>> findLongestSubstring(\\" \\") 1 >>> findLongestSubstring(\\"au\\") 2 >>> findLongestSubstring(\\"dvdf\\") 3 >>> findLongestSubstring(\\"anviaj\\") 5 >>> findLongestSubstring(\\"a\\") 1 >>> findLongestSubstring(\\"abcdef\\") 6 >>> findLongestSubstring(\\"tmmzuxt\\") 5 >>> findLongestSubstring(\\"aab\\") 2 >>> findLongestSubstring(\\"abba\\") 2 >>> findLongestSubstring(\\"ohvhjdml\\") 6 >>> findLongestSubstring(\\"a\\"*100000) 1 >>> findLongestSubstring(\\"abcd\\"*25000) 4 >>> findLongestSubstring(\\"a\\"*99999 + \\"b\\") 2","solution":"def findLongestSubstring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List, Tuple def shortest_route(n: int, m: int, p1: int, p2: int, d: int, paths: List[Tuple[int, int, int]]) -> int: Determine the shortest route across the mountains given the constraints on the difficulty level of the paths. :param n: Number of peaks :param m: Number of paths :param p1: Starting peak :param p2: Ending peak :param d: Maximum allowable difficulty level for the paths :param paths: List of paths where each path is represented as a tuple (x, y, t) with x and y being peak numbers and t being the difficulty level of the path :return: The shortest possible distance from peak p1 to peak p2 under the given constraints, or -1 if no such path exists. >>> shortest_route(5, 6, 1, 5, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 6), (3, 4, 2), (4, 5, 4), (3, 5, 3)]) 8 >>> shortest_route(5, 6, 1, 5, 1, [(1, 2, 2), (2, 3, 3), (1, 3, 6), (3, 4, 2), (4, 5, 4), (3, 5, 3)]) -1 >>> shortest_route(2, 1, 1, 2, 10, [(1, 2, 5)]) 5 >>> shortest_route(3, 3, 1, 3, 4, [(1, 2, 2), (2, 3, 2), (1, 3, 6)]) 4 >>> shortest_route(4, 5, 1, 4, 10000, [(1, 2, 1), (2, 3, 3), (3, 4, 1), (1, 3, 100), (2, 4, 50)]) 5","solution":"import heapq def shortest_route(n, m, p1, p2, d, paths): # Create an adjacency list for the graph graph = {i: [] for i in range(1, n+1)} for x, y, t in paths: if t <= d: graph[x].append((y, t)) graph[y].append((x, t)) # Use Dijkstra's algorithm to find the shortest path pq = [(0, p1)] # (cost, node) distances = {i: float('inf') for i in range(1, n+1)} distances[p1] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == p2: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 # If p2 is unreachable"},{"question":"from typing import List def max_coins(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum number of coins collected by both Tom and Jerry until they meet. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D grid representing the number of coins in each cell. Returns: int: The maximum number of coins collected by both until they meet. Examples: >>> max_coins(3, 4, [ ... [1, 2, 3, 0], ... [0, 0, 5, 2], ... [1, 1, 0, 2] ... ]) 17 >>> max_coins(2, 2, [ ... [1, 1], ... [2, 3] ... ]) 7","solution":"def max_coins(n, m, grid): def dp(x1, y1, x2, y2, memo): if x1 >= n or y1 >= m or x2 >= n or y2 >= m: return 0 if x1 == n-1 and y1 == m-1 and x2 == n-1 and y2 == m-1: return grid[x1][y1] if memo[x1][y1][x2][y2] != -1: return memo[x1][y1][x2][y2] res = grid[x1][y1] if x1 != x2 or y1 != y2: res += grid[x2][y2] res += max( dp(x1+1, y1, x2+1, y2, memo), dp(x1+1, y1, x2, y2+1, memo), dp(x1, y1+1, x2+1, y2, memo), dp(x1, y1+1, x2, y2+1, memo) ) memo[x1][y1][x2][y2] = res return res memo = [[[[ -1 for _ in range(m)] for _ in range(n)] for _ in range(m)] for _ in range(n)] return dp(0, 0, 0, 0, memo)"},{"question":"def min_max_diff(n: int, years: List[int]) -> int: This function returns the minimum possible maximum difference between consecutive years in the optimal sequence. Arguments: n -- integer, the number of coins years -- list of integers, the years the coins were minted Returns: integer -- the minimum possible maximum difference between consecutive years >>> min_max_diff(5, [1990, 2003, 1985, 2010, 1995]) == 7 >>> min_max_diff(3, [1000, 2000, 3000]) == 1000 >>> min_max_diff(4, [1980, 1981, 1982, 1983]) == 1 >>> min_max_diff(2, [9999, 1000]) == 8999 >>> min_max_diff(6, [1910, 1920, 1900, 1930, 1940, 1950]) == 10","solution":"def min_max_diff(n, years): This function returns the minimum possible maximum difference between consecutive years in the optimal sequence. Arguments: n -- integer, the number of coins years -- list of integers, the years the coins were minted Returns: integer -- the minimum possible maximum difference between consecutive years years.sort() min_max_diff = float('inf') for i in range(1, n): min_max_diff = min(min_max_diff, years[i] - years[i - 1]) return min_max_diff"},{"question":"def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determines if array can be partitioned into k subsets with equal sum. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False","solution":"def canPartitionKSubsets(arr, k): Determines if array can be partitioned into k subsets with equal sum. total_sum = sum(arr) if total_sum % k != 0: return False target = total_sum // k arr.sort(reverse=True) buckets = [0] * k def backtrack(index): if index == len(arr): return all(b == target for b in buckets) for i in range(k): if buckets[i] + arr[index] <= target: buckets[i] += arr[index] if backtrack(index + 1): return True buckets[i] -= arr[index] if buckets[i] == 0: break return False return backtrack(0)"},{"question":"from typing import List def max_rectangle_area(heights: List[int]) -> int: Calculate the maximum area of a rectangle formed by consecutive buildings in the row. >>> max_rectangle_area([7, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([5, 5, 5, 5, 5]) 25 >>> max_rectangle_area([10]) 10 >>> max_rectangle_area([1, 2, 3, 4, 5]) 9 >>> max_rectangle_area([5, 4, 3, 2, 1]) 9 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10","solution":"def max_rectangle_area(heights): Calculate the maximum area of a rectangle formed by consecutive buildings in the row. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_reach_coordinate(X: int, Y: int, Z: int) -> str: Determines if a frog can reach coordinate Z starting from position 0 with jumps of X meters forward or Y meters backward. >>> can_reach_coordinate(3, 2, 1) == \\"Yes\\" >>> can_reach_coordinate(2, 4, 7) == \\"No\\" >>> can_reach_coordinate(4, 6, 10) == \\"Yes\\" >>> can_reach_coordinate(5, 10, 14) == \\"No\\"","solution":"def can_reach_coordinate(X, Y, Z): Determines if a frog can reach coordinate Z starting from position 0 with jumps of X meters forward or Y meters backward. from math import gcd # Finding the greatest common divisor of X and Y because the achievable # positions are multiples of the gcd. common_divisor = gcd(X, Y) # Z must be a multiple of the gcd of X and Y to be reachable. if Z % common_divisor == 0: return \\"Yes\\" else: return \\"No\\" # Example usage: # print(can_reach_coordinate(3, 2, 1)) # Should print \\"Yes\\" # print(can_reach_coordinate(2, 4, 7)) # Should print \\"No\\""},{"question":"def count_primes(n: int) -> int: Returns the number of prime numbers less than or equal to n. >>> count_primes(10) 4 >>> count_primes(30) 10 >>> count_primes(1) 0 >>> count_primes(100) 25","solution":"def count_primes(n): Returns the number of prime numbers less than or equal to n. if n < 2: return 0 is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i * i, n + 1, i): is_prime[j] = False return sum(is_prime)"},{"question":"def process_commands(commands: List[str]) -> List[str]: Processes multiple commands to manage and query the order log of a Waffle House branch. >>> process_commands([ ... \\"ADD 1 15 Pancakes\\", ... \\"ADD 2 10 Omelette\\", ... \\"QUERY 1\\", ... \\"UPDATE 1 20 Waffles\\", ... \\"QUERY 1\\", ... \\"DELETE 2\\", ... \\"QUERY 2\\" ... ]) ['1 15 Pancakes', '1 20 Waffles', 'NOT FOUND'] >>> process_commands([ ... \\"ADD 1 5 Coffee\\", ... \\"QUERY 1\\", ... \\"ADD 2 7 Tea\\", ... \\"DELETE 1\\", ... \\"QUERY 1\\" ... ]) ['1 5 Coffee', 'NOT FOUND'] commands = [] assert process_commands(commands) == [] commands = [ \\"ADD 1 10 Pancakes\\", \\"DELETE 1\\", \\"QUERY 1\\" ] assert process_commands(commands) == [ \\"NOT FOUND\\" ] commands = [ \\"UPDATE 1 10 Pancakes\\", \\"QUERY 1\\" ] assert process_commands(commands) == [ \\"NOT FOUND\\" ] commands = [ \\"QUERY 1\\" ] assert process_commands(commands) == [ \\"NOT FOUND\\" ] commands = [ \\"ADD 1 10 Pancakes\\", \\"UPDATE 1 15 Waffles\\", \\"UPDATE 1 20 Coffee\\", \\"QUERY 1\\" ] assert process_commands(commands) == [ \\"1 20 Coffee\\" ]","solution":"def process_commands(commands): order_log = {} output = [] for command in commands: parts = command.split(maxsplit=3) if parts[0] == \\"ADD\\": order_id = int(parts[1]) time = int(parts[2]) details = parts[3] order_log[order_id] = (time, details) elif parts[0] == \\"DELETE\\": order_id = int(parts[1]) if order_id in order_log: del order_log[order_id] elif parts[0] == \\"UPDATE\\": order_id = int(parts[1]) time = int(parts[2]) details = parts[3] if order_id in order_log: order_log[order_id] = (time, details) elif parts[0] == \\"QUERY\\": order_id = int(parts[1]) if order_id in order_log: time, details = order_log[order_id] output.append(f\\"{order_id} {time} {details}\\") else: output.append(\\"NOT FOUND\\") return output"},{"question":"def can_redistribute_marbles(n: int, marbles: List[int]) -> str: Determines if it's possible to redistribute the marbles such that each box ends up with the same number of marbles. Args: n : int Number of boxes. marbles : list of int Number of marbles in each box. Returns: str \\"YES\\" if it is possible to redistribute, otherwise \\"NO\\". >>> can_redistribute_marbles(3, [2, 4, 6]) \\"YES\\" >>> can_redistribute_marbles(3, [1, 3, 5]) \\"YES\\" >>> can_redistribute_marbles(3, [2, 3, 4]) \\"NO\\" >>> can_redistribute_marbles(4, [1, 2, 3, 4]) \\"NO\\" >>> can_redistribute_marbles(1, [5]) \\"YES\\"","solution":"def can_redistribute_marbles(n, marbles): Determines if it's possible to redistribute the marbles such that each box ends up with the same number of marbles. Args: n : int Number of boxes. marbles : list of int Number of marbles in each box. Returns: str \\"YES\\" if it is possible to redistribute, otherwise \\"NO\\". # Check the parity of each element in marbles odd_count = sum(1 for marble in marbles if marble % 2 != 0) even_count = n - odd_count # To be able to make the redistribution work, all counts must be of the same parity. if odd_count == 0 or even_count == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def find_missing_number(sequence: List[int]) -> int: Finds the missing number in a list of consecutive numbers. Args: sequence (list of int): A list of consecutive numbers with one number missing. Returns: int: The missing number in the list. pass def test_find_missing_number_basic(): assert find_missing_number([1, 2, 3, 5, 6]) == 4 def test_find_missing_number_higher_start(): assert find_missing_number([10, 11, 12, 14, 15]) == 13 def test_find_missing_number_hundred_series(): assert find_missing_number([101, 102, 103, 105]) == 104 def test_find_missing_number_unsorted(): assert find_missing_number([3, 1, 4, 5]) == 2 def test_find_missing_number_two_elements(): assert find_missing_number([2, 4, 1]) == 3 def test_find_missing_number_negative_numbers(): assert find_missing_number([-2, -3, -4, -6]) == -5 def test_find_missing_number_mixed_list(): assert find_missing_number([0, -1, -2, -4]) == -3","solution":"def find_missing_number(sequence): Finds the missing number in a list of consecutive numbers. Args: sequence (list of int): A list of consecutive numbers with one number missing. Returns: int: The missing number in the list. total = (len(sequence) + 1) * (min(sequence) + max(sequence)) // 2 return total - sum(sequence)"},{"question":"def sortedSquares(nums): Given a list of integers, return a list with each number squared and sorted in non-decreasing order. >>> sortedSquares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sortedSquares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sortedSquares(nums): Given a list of integers, return a list with each number squared and sorted in non-decreasing order. :param nums: List[int] :return: List[int] squared_nums = [x ** 2 for x in nums] return sorted(squared_nums)"},{"question":"def is_distinct_subsequence_possible(m, b): Determines if a subsequence of \`b\` with all distinct elements is possible. Parameters: m (int): Length of the sequence b. b (list of int): The sequence. Returns: str: \\"YES\\" if such a subsequence is possible, otherwise \\"NO\\". >>> is_distinct_subsequence_possible(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> is_distinct_subsequence_possible(5, [1, 2, 2, 3, 4]) \\"NO\\" >>> is_distinct_subsequence_possible(4, [4, 4, 4, 4]) \\"NO\\" def process_queries(queries): Processes multiple queries and determines if a subsequence of all distinct elements can be formed for each query. Parameters: queries (list): List of tuples, each containing the sequence length and the sequence. Returns: list: List of results for each query. >>> process_queries([(5, [1, 2, 3, 4, 5]), (5, [1, 2, 2, 3, 4]), (4, [4, 4, 4, 4])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_distinct_subsequence_possible(m, b): Determines if a subsequence of \`b\` with all distinct elements is possible. Parameters: m (int): Length of the sequence b. b (list of int): The sequence. Returns: str: \\"YES\\" if such a subsequence is possible, otherwise \\"NO\\". # Use set to track if any duplicates are found distinct_elements = set() for element in b: if element in distinct_elements: return \\"NO\\" distinct_elements.add(element) return \\"YES\\" def process_queries(queries): Processes multiple queries and determines if a subsequence of all distinct elements can be formed for each query. Parameters: queries (list): List of tuples, each containing the sequence length and the sequence. Returns: list: List of results for each query. results = [] for m, b in queries: results.append(is_distinct_subsequence_possible(m, b)) return results"},{"question":"from typing import List, Tuple def has_cycle(n: int, m: int, corridors: List[Tuple[int, int]], s: int) -> str: In a labyrinth, determine if there exists a path that leads back to the starting chamber. >>> has_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)], 1) 'YES' >>> has_cycle(3, 2, [(1, 2), (2, 3)], 1) 'NO' def test_no_cycle(): n = 3 m = 2 corridors = [(1, 2), (2, 3)] s = 1 assert has_cycle(n, m, corridors, s) == \\"NO\\" def test_with_cycle(): n = 4 m = 4 corridors = [(1, 2), (2, 3), (3, 4), (4, 2)] s = 1 assert has_cycle(n, m, corridors, s) == \\"YES\\" def test_direct_cycle(): n = 2 m = 2 corridors = [(1, 2), (2, 1)] s = 1 assert has_cycle(n, m, corridors, s) == \\"YES\\" def test_no_corridors(): n = 1 m = 0 corridors = [] s = 1 assert has_cycle(n, m, corridors, s) == \\"NO\\" def test_single_cycle(): n = 1 m = 1 corridors = [(1, 1)] s = 1 assert has_cycle(n, m, corridors, s) == \\"YES\\" def test_small_graph_no_cycle(): n = 2 m = 1 corridors = [(1, 2)] s = 1 assert has_cycle(n, m, corridors, s) == \\"NO\\"","solution":"def has_cycle(n, m, corridors, s): from collections import defaultdict, deque graph = defaultdict(list) for u, v in corridors: graph[u].append(v) # BFS to detect cycle queue = deque([s]) visited = set() while queue: node = queue.popleft() if node in visited: return \\"YES\\" visited.add(node) for neighbor in graph[node]: queue.append(neighbor) return \\"NO\\""},{"question":"def find_treasure_point(n: int, temples: List[Tuple[int, int]], keys: List[Tuple[int, int]]) -> Tuple[int, int]: Determine the coordinates of the treasure point P from given temples and keys. >>> find_treasure_point(3, [(1, 1), (2, 3), (-1, -2)], [(4, 0), (1, 1), (-3, 2)]) (5, 1) >>> find_treasure_point(1, [(0, 0)], [(1, 2)]) (1, 2) # Your code here from typing import List, Tuple def test_example_case(): n = 3 temples = [ (1, 1), (2, 3), (-1, -2) ] keys = [ (4, 0), (1, 1), (-3, 2) ] assert find_treasure_point(n, temples, keys) == (5, 1) def test_single_temple(): n = 1 temples = [ (0, 0) ] keys = [ (1, 2) ] assert find_treasure_point(n, temples, keys) == (1, 2) def test_multiple_temple_same_key(): n = 2 temples = [ (1, 1), (2, 2) ] keys = [ (1, 1), (0, 0) ] assert find_treasure_point(n, temples, keys) == (2, 2) def test_large_coordinates(): n = 2 temples = [ (10**6, 10**6), (-10**6, -10**6) ] keys = [ (-5, -5), (10**6 + 5, 10**6 + 5) ] assert find_treasure_point(n, temples, keys) == (10**6 - 5, 10**6 - 5) def test_negative_coordinates(): n = 2 temples = [ (-1, -1), (-2, -2) ] keys = [ (-1, -1), (-2, -2) ] assert find_treasure_point(n, temples, keys) == (-2, -2)","solution":"def find_treasure_point(n, temples, keys): # Since all keys lead to the same treasure point P which can be determined using any temple, # We can directly use the first temple and its key to calculate the treasure point. x1, y1 = temples[0] k1, l1 = keys[0] Px = x1 + k1 Py = y1 + l1 return Px, Py"},{"question":"def transform_array(test_cases): Rearranges the elements of the given array such that every element A[i] is transformed into the sum of elements to its right, including itself. Each element A[i] should become the sum of the subarray A[i], A[i+1], ..., A[N-1]. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of elements and the array of integers. Returns: List[List[int]]: A list of lists representing the modified arrays for each test case. Examples: >>> transform_array([(5, [1, 2, 3, 4, 5])]) [[15, 14, 12, 9, 5]] >>> transform_array([(4, [10, 20, 30, 40])]) [[100, 90, 70, 40]] def process_input(input_data): Parses the input data and prepares it for the transform_array function. Args: input_data (str): A string representation of the input data. Returns: List[List[int]]: The output from the transform_array function after processing the input data. Examples: >>> input_data = \\"1n5n1 2 3 4 5\\" >>> process_input(input_data) [[15, 14, 12, 9, 5]] >>> input_data = \\"2n5n1 2 3 4 5n4n10 20 30 40\\" >>> process_input(input_data) [[15, 14, 12, 9, 5], [100, 90, 70, 40]]","solution":"def transform_array(test_cases): result = [] for case in test_cases: N, A = case transformed = [] current_sum = 0 # Calculate the sum of A from right to left to avoid repeated summation for i in range(N-1, -1, -1): current_sum += A[i] transformed.append(current_sum) # Since we fill the transformed array from the end, we need to reverse it transformed.reverse() result.append(transformed) return result # Helper function to parse input data and invoke transform_array def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) A = list(map(int, lines[idx + 1].split())) test_cases.append((N, A)) idx += 2 return transform_array(test_cases)"},{"question":"def optimal_intermediary_point(A: int, B: int) -> Tuple[int, int]: Returns the optimal intermediary point (X, Y) that minimizes the total Manhattan Distance for the delivery route from (0, 0) to (A, B). >>> optimal_intermediary_point(5, 3) (2, 1) >>> optimal_intermediary_point(10, 10) (5, 5)","solution":"def optimal_intermediary_point(A, B): Returns the optimal intermediary point (X, Y) that minimizes the total Manhattan Distance for the delivery route from (0, 0) to (A, B). # The optimal intermediary point (X, Y) can be chosen as (A//2, B//2) X = A // 2 Y = B // 2 return X, Y"},{"question":"def closest_checkpoint_within_fuel(n, f, distances): Returns the distance of the closest checkpoint within the fuel capacity. Args: n : int : number of checkpoints f : int : fuel capacity distances : list of int : distances of the checkpoints from Earth Returns: int : distance of the closest checkpoint or -1 if no such checkpoint exists >>> closest_checkpoint_within_fuel(5, 100, [150, 300, 500, 650, 700]) -1 >>> closest_checkpoint_within_fuel(4, 600, [100, 200, 300, 500]) 100","solution":"def closest_checkpoint_within_fuel(n, f, distances): Returns the distance of the closest checkpoint within the fuel capacity. Args: n : int : number of checkpoints f : int : fuel capacity distances : list of int : distances of the checkpoints from Earth Returns: int : distance of the closest checkpoint or -1 if no such checkpoint exists # Filter out distances that are within the fuel capacity within_fuel_distances = [d for d in distances if d <= f] # If there are no such distances, return -1 if not within_fuel_distances: return -1 # Return the minimum of the filtered distances return min(within_fuel_distances) # Example usage: # Read input n, f = 5, 100 distances = [150, 300, 500, 650, 700] # Find the closest checkpoint that can be reached within fuel capacity result = closest_checkpoint_within_fuel(n, f, distances) print(result) # Should print -1"},{"question":"def simulate_traffic_system(n, m, t, waiting, initial_lights, rules): Simulate the traffic system for the given number of time steps and determine the total waiting time for cars in the city. Parameters: n (int): number of rows of the grid m (int): number of columns of the grid t (int): number of time steps waiting (List[List[int]]): initial number of cars waiting at each intersection initial_lights (List[List[str]]): initial state of each traffic light ('R' or 'G') rules (List[Tuple[int, int, int]]): traffic light switching rules Returns: int: total waiting time for cars in the city after t time steps pass def process_input(): import sys input = sys.stdin.read data = input().split() idx = 0 results = [] while True: N = int(data[idx]) M = int(data[idx + 1]) T = int(data[idx + 2]) idx += 3 if N == 0 and M == 0 and T == 0: break waiting = [] for i in range(N): waiting.append([int(data[idx + j]) for j in range(M)]) idx += M initial_lights = [] for i in range(N): initial_lights.append([data[idx + j] for j in range(M)]) idx += M rules = [] while True: a = int(data[idx]) b = int(data[idx + 1]) c = int(data[idx + 2]) idx += 3 if a == 0 and b == 0 and c == 0: break rules.append((a, b, c)) total_waiting_time = simulate_traffic_system(N, M, T, waiting, initial_lights, rules) results.append(total_waiting_time) for result in results: print(result) # Test cases def test_basic_case(): from io import StringIO import sys input_data = 2 2 3 1 2 3 4 R G G R 1 3 3 0 0 0 0 0 0 sys.stdin = StringIO(input_data) process_input() def test_advanced_case(): from io import StringIO import sys input_data = 3 3 2 1 1 1 2 2 2 3 3 3 G G R R G G G R R 2 2 2 0 0 0 0 0 0 sys.stdin = StringIO(input_data) process_input()","solution":"def simulate_traffic_system(n, m, t, waiting, initial_lights, rules): total_waiting_time = 0 # Process each time step for step in range(1, t + 1): new_lights = [row[:] for row in initial_lights] for rule in rules: a, b, c = rule if a <= step <= b: for i in range(n): for j in range(m): if waiting[i][j] >= c: new_lights[i][j] = 'G' # Calculate total waiting time at red lights for this time step for i in range(n): for j in range(m): if new_lights[i][j] == 'R': total_waiting_time += waiting[i][j] # Update the lights for the next time step initial_lights = new_lights return total_waiting_time def process_input(): import sys input = sys.stdin.read data = input().split() idx = 0 results = [] while True: N = int(data[idx]) M = int(data[idx + 1]) T = int(data[idx + 2]) idx += 3 if N == 0 and M == 0 and T == 0: break waiting = [] for i in range(N): waiting.append([int(data[idx + j]) for j in range(M)]) idx += M initial_lights = [] for i in range(N): initial_lights.append([data[idx + j] for j in range(M)]) idx += M rules = [] while True: a = int(data[idx]) b = int(data[idx + 1]) c = int(data[idx + 2]) idx += 3 if a == 0 and b == 0 and c == 0: break rules.append((a, b, c)) total_waiting_time = simulate_traffic_system(N, M, T, waiting, initial_lights, rules) results.append(total_waiting_time) for result in results: print(result) if __name__ == \\"__main__\\": process_input()"},{"question":"def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome. The check is case-insensitive and ignores spaces and punctuation. Args: s (str): The input string. Returns: bool: True if the input string is a palindrome, False otherwise. Examples: >>> is_palindrome(\\"Able, was I ere I saw Elba\\") True >>> is_palindrome(\\"Madam, in Eden, I'm Adam\\") True >>> is_palindrome(\\"Hello, World!\\") False","solution":"import re def is_palindrome(s: str) -> bool: Checks if the input string is a palindrome. The check is case-insensitive and ignores spaces and punctuation. Args: s (str): The input string. Returns: bool: True if the input string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"def is_subarray(arr1, arr2): Determines if arr2 is a subarray of arr1. Parameters: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: str: \\"YES\\" if arr2 is a subarray of arr1, otherwise \\"NO\\".","solution":"def is_subarray(arr1, arr2): Determines if arr2 is a subarray of arr1. Parameters: arr1 (list of int): The first array. arr2 (list of int): The second array. Returns: str: \\"YES\\" if arr2 is a subarray of arr1, otherwise \\"NO\\". n, m = len(arr1), len(arr2) for i in range(n - m + 1): if arr1[i:i + m] == arr2: return \\"YES\\" return \\"NO\\""},{"question":"def can_guarantee_draw(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if you can guarantee at least a draw if both you and Alex play optimally. >>> can_guarantee_draw(3, [(6, [1, 2, 3, 4, 5, 6]), (5, [1, 1, 1, 1, 1]), (4, [1, 2, 2, 1])]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_guarantee_draw(1, [(7, [1, 2, 3, 4, 4, 5, 6])]) == [\\"YES\\"] >>> can_guarantee_draw(2, [(3, [1, 2, 2]), (6, [3, 3, 3, 3, 4, 4])]) == [\\"YES\\", \\"NO\\"] >>> can_guarantee_draw(1, [(1, [1])]) == [\\"YES\\"] >>> can_guarantee_draw(1, [(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) == [\\"YES\\"]","solution":"def can_guarantee_draw(t, test_cases): results = [] for case in test_cases: n, fruits = case unique_fruits = len(set(fruits)) if unique_fruits >= (n + 1) // 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumRootToLeaf(root: TreeNode) -> int: Write a function to find the total sum of all binary numbers represented by the paths from the root to the leaves in a binary tree. Each node in the binary tree has a value of either 0 or 1. Args: root (TreeNode): The root of the binary tree. Returns: int: The total sum of all binary numbers represented by the paths. >>> root1 = TreeNode(1) >>> root1.left = TreeNode(0) >>> root1.right = TreeNode(1) >>> root1.left.left = TreeNode(0) >>> root1.left.right = TreeNode(1) >>> root1.right.left = TreeNode(0) >>> root1.right.right = TreeNode(1) >>> sumRootToLeaf(root1) 22 >>> root2 = TreeNode(1) >>> root2.left = TreeNode(0) >>> root2.left.left = TreeNode(1) >>> sumRootToLeaf(root2) 5 >>> root3 = TreeNode(1) >>> sumRootToLeaf(root3) 1 >>> root4 = TreeNode(1) >>> root4.left = TreeNode(1) >>> root4.left.left = TreeNode(1) >>> sumRootToLeaf(root4) 7 >>> root5 = TreeNode(1) >>> root5.right = TreeNode(0) >>> root5.right.right = TreeNode(1) >>> sumRootToLeaf(root5) 5 >>> sumRootToLeaf(None) 0 ...","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumRootToLeaf(root: TreeNode) -> int: def dfs(node, current_sum): if node is None: return 0 current_sum = (current_sum << 1) | node.val if node.left is None and node.right is None: # It's a leaf node return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"def two_sum(nums: List[int], target: int) -> bool: Determines if there are any two distinct integers in the list \`nums\` that sum up to \`target\`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: bool: True if there are two distinct integers that sum up to \`target\`, otherwise False. Example: >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([1, 2, 3, 4, 5], 10) False from solution import two_sum def test_two_sum_valid_pair(): assert two_sum([2, 7, 11, 15], 9) == True def test_two_sum_no_valid_pair(): assert two_sum([1, 2, 3, 4, 5], 10) == False def test_two_sum_negative_numbers(): assert two_sum([-1, -2, -3, -4, -5], -8) == True def test_two_sum_mixed_numbers(): assert two_sum([1, -2, 3, -4, 5], 1) == True def test_two_sum_empty_list(): assert two_sum([], 0) == False def test_two_sum_single_element(): assert two_sum([5], 5) == False def test_two_sum_target_zero(): assert two_sum([1, 2, 3, -3, -2, -1], 0) == True def test_two_sum_large_numbers(): assert two_sum([1000000000, 2000000000, 3000000000], 5000000000) == True assert two_sum([1000000000, 2000000000, 3000000000], 6000000000) == False","solution":"def two_sum(nums, target): Determines if there are any two distinct integers in the list \`nums\` that sum up to \`target\`. Parameters: nums (list of int): A list of integers. target (int): The target sum. Returns: bool: True if there are two distinct integers that sum up to \`target\`, otherwise False. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def count_and_say(n): Returns the nth term of the 'count and say' sequence. Given a positive integer n, return the nth term of this sequence. >>> count_and_say(1) '1' >>> count_and_say(5) '111221'","solution":"def count_and_say(n): Returns the nth term of the 'count and say' sequence. if n == 1: return \\"1\\" # Helper function to generate the next term in the sequence def next_term(s): result = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 result.append(str(count) + s[i]) i += 1 return ''.join(result) current_term = \\"1\\" for _ in range(1, n): current_term = next_term(current_term) return current_term"},{"question":"from math import gcd from typing import List, Tuple def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b. >>> lcm(5, 10) 10 >>> lcm(7, 3) 21 >>> lcm(9, 6) 18 pass # Replace this with your code def find_lcm_of_pairs(test_cases: List[Tuple[int, int]]) -> List[int]: Finds and returns the LCM for each pair of integers in the given test cases. >>> find_lcm_of_pairs([(5, 10), (7, 3), (9, 6)]) [10, 21, 18] pass # Replace this with your code","solution":"from math import gcd def lcm(a, b): Returns the least common multiple (LCM) of a and b. return abs(a * b) // gcd(a, b) def find_lcm_of_pairs(test_cases): Finds and prints the LCM for each pair of integers in the given test cases. results = [] for a, b in test_cases: results.append(lcm(a, b)) return results"},{"question":"def count_palindromic_sequences(k: int, p: int, s: int) -> int: Returns the number of k-length palindromic sequences of non-negative integers strictly less than p that sum to s. >>> count_palindromic_sequences(3, 3, 4) 2 >>> count_palindromic_sequences(4, 5, 8) 5","solution":"def count_palindromic_sequences(k, p, s): Returns the number of k-length palindromic sequences of non-negative integers strictly less than p that sum to s. def is_palindromic_sequence(seq): return seq == seq[::-1] def dfs(pos, current_sequence, current_sum): if pos == (k + 1) // 2: if is_palindromic_sequence(current_sequence) and current_sum == s: return 1 return 0 count = 0 for i in range(p): if pos <= k // 2: new_sequence = current_sequence[:] new_sequence[pos] = i if pos < k - pos - 1: new_sequence[k - pos - 1] = i count += dfs(pos + 1, new_sequence, current_sum + 2*i if pos < k - pos - 1 else current_sum + i) return count return dfs(0, [0] * k, 0)"},{"question":"from collections import deque def enqueue(queue, array): Enqueues the elements of the array into the queue. Returns the modified queue. # Implementation goes here def reverse_K_elements(queue, K): Reverses the first K elements of the queue and returns the modified queue. Returns the modified queue. # Implementation goes here import pytest def test_enqueue(): queue = deque() arr = [10, 20, 30, 40, 50] expected_result = deque([10, 20, 30, 40, 50]) assert enqueue(queue, arr) == expected_result def test_reverse_K_elements_example1(): queue = deque([10, 20, 30, 40, 50]) K = 3 expected_result = deque([30, 20, 10, 40, 50]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_example2(): queue = deque([5, 8, 12, 15]) K = 2 expected_result = deque([8, 5, 12, 15]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_full_queue(): queue = deque([1, 2, 3, 4, 5, 6]) K = 6 expected_result = deque([6, 5, 4, 3, 2, 1]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_partial_queue(): queue = deque([7, 2, 9, 4, 8]) K = 4 expected_result = deque([4, 9, 2, 7, 8]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_single_element(): queue = deque([100]) K = 1 expected_result = deque([100]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_zero_K(): queue = deque([10, 20, 30, 40, 50]) K = 0 expected_result = deque([10, 20, 30, 40, 50]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_K_greater_than_queue(): queue = deque([10, 20, 30, 40, 50]) K = 6 # K is greater than queue length, shouldn't change the queue expected_result = deque([10, 20, 30, 40, 50]) assert reverse_K_elements(queue, K) == expected_result def test_reverse_K_elements_no_elements(): queue = deque() K = 0 expected_result = deque() assert reverse_K_elements(queue, K) == expected_result","solution":"from collections import deque def enqueue(queue, array): Enqueues the elements of the array into the queue. for element in array: queue.append(element) return queue def reverse_K_elements(queue, K): Reverses the first K elements of the queue and returns the modified queue. if K > len(queue) or K <= 0: return queue stack = [] # Step 1: Push the first K elements into a stack for _ in range(K): stack.append(queue.popleft()) # Step 2: Pop from stack and enqueue back to the queue while stack: queue.append(stack.pop()) # Step 3: Move the remaining elements in the queue to the back for _ in range(len(queue) - K): queue.append(queue.popleft()) return queue"},{"question":"def is_sorted_non_decreasing(test_cases): Given a list of test cases, where each test case contains an integer indicating the number of elements in the array and the array itself, determine whether each array is sorted in non-decreasing order. Parameters: test_cases (list): A list of test cases, where each test case is represented as a tuple (m, array), with \`m\` being the number of elements in the array and \`array\` being the list of integers. Returns: list: A list of strings \\"YES\\" or \\"NO\\" indicating if each array is sorted in non-decreasing order. Examples: >>> is_sorted_non_decreasing([(5, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> is_sorted_non_decreasing([(4, [1, 3, 2, 4])]) [\\"NO\\"] >>> is_sorted_non_decreasing([(6, [10, 20, 20, 30, 40, 50])]) [\\"YES\\"] >>> is_sorted_non_decreasing([(5, [1, 2, 3, 4, 5]), (4, [1, 3, 2, 4]), (6, [10, 20, 20, 30, 40, 50])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_sorted_non_decreasing([(1, [42])]) [\\"YES\\"] >>> is_sorted_non_decreasing([(3, [7, 7, 7])]) [\\"YES\\"]","solution":"def is_sorted_non_decreasing(test_cases): Determines if each array in the test cases is sorted in non-decreasing order. Parameters: test_cases (list): A list of test cases, where each test case is a tuple with an integer (number of elements) and a list of integers (the array). Returns: list: A list of strings \\"YES\\" or \\"NO\\" indicating if each array is sorted in non-decreasing order. results = [] for m, array in test_cases: sorted_check = all(array[i] <= array[i + 1] for i in range(m - 1)) results.append(\\"YES\\" if sorted_check else \\"NO\\") return results"},{"question":"def generateSortedMatrix(n, m): Generates an n x m matrix where each cell contains unique integers from 1 to n*m and the rows and columns are sorted in increasing order. >>> generateSortedMatrix(3, 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> generateSortedMatrix(2, 4) [[1, 2, 3, 4], [5, 6, 7, 8]] >>> generateSortedMatrix(1, 5) [[1, 2, 3, 4, 5]] >>> generateSortedMatrix(4, 1) [[1], [2], [3], [4]]","solution":"def generateSortedMatrix(n, m): Generates an n x m matrix where each cell contains unique integers from 1 to n*m and the rows and columns are sorted in increasing order. matrix = [] current = 1 for i in range(n): row = [] for j in range(m): row.append(current) current += 1 matrix.append(row) return matrix"},{"question":"def calculate_run_length_encoding(input_string: str) -> str: Compress a string using run-length encoding. The function returns a compressed representation where consecutive occurrences of the same character are replaced by the character followed by the number of occurrences. >>> calculate_run_length_encoding(\\"aaabcc\\") \\"a3b1c2\\" >>> calculate_run_length_encoding(\\"wwwwaaadexxxxxxywww\\") \\"w4a3d1e1x6y1w3\\"","solution":"def calculate_run_length_encoding(input_string: str) -> str: if not input_string: return \\"\\" result = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: result.append(current_char + str(count)) current_char = char count = 1 result.append(current_char + str(count)) # append the last character and its count return ''.join(result)"},{"question":"def highest_weighted_score(test_cases): Determine the highest weighted score among the reviews for each product. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, with each test case being a list of tuples containing pairs (R_i, A_i) of rating and upvotes. Returns: List[int]: A list of the highest weighted scores for each test case. Example: >>> highest_weighted_score([ ... [(4, 10), (1, 20), (3, 15)], ... [(8, 5), (7, 9)] ... ]) [45, 63] def parse_input(input_str): Parse the input string into structured test cases. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[Tuple[int, int]]]: Structured test cases extracted from the input string. Example: >>> parse_input(\\"2n3n4 10n1 20n3 15n2n8 5n7 9n\\") [ [(4, 10), (1, 20), (3, 15)], [(8, 5), (7, 9)] ] def process_input(input_str): Process the input string and find the highest weighted score for each test case. Args: input_str (str): The input string containing multiple test cases. Returns: List[int]: The list of the highest weighted scores for each test case. Example: >>> process_input(\\"2n3n4 10n1 20n3 15n2n8 5n7 9n\\") [45, 63] import pytest from solution import * def test_sample_input_1(): input_str = \\"2n3n4 10n1 20n3 15n2n8 5n7 9n\\" output = process_input(input_str) assert output == [45, 63] def test_single_review(): input_str = \\"1n1n5 2n\\" output = process_input(input_str) assert output == [10] def test_identical_reviews(): input_str = \\"1n2n4 5n4 5n\\" output = process_input(input_str) assert output == [20] def test_max_constraints(): input_str = \\"1n50000n\\" + \\"n\\".join(\\"1 1\\" for _ in range(50000)) + \\"n\\" output = process_input(input_str) assert output == [1] def test_all_same_ratings(): input_str = \\"1n3n5 10n5 20n5 15n\\" output = process_input(input_str) assert output == [100] def test_all_same_upvotes(): input_str = \\"1n3n10 5n20 5n15 5n\\" output = process_input(input_str) assert output == [100]","solution":"def highest_weighted_score(test_cases): results = [] for reviews in test_cases: max_score = 0 for rating, upvotes in reviews: max_score = max(max_score, rating * upvotes) results.append(max_score) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) reviews = [] for i in range(1, N+1): R_i, A_i = map(int, lines[index + i].split()) reviews.append((R_i, A_i)) test_cases.append(reviews) index += N + 1 return test_cases def process_input(input_str): test_cases = parse_input(input_str) return highest_weighted_score(test_cases)"},{"question":"def process_grid_game(N: int, queries: List[str]) -> List[int]: Perform operations on an NxN grid and handle queries to set values and sum subgrids. Args: N (int): The size of the NxN grid. queries (List[str]): List of queries to perform on the grid, where each query is either: - \\"SET i j v\\": Set the element at position (i, j) to value v. - \\"SUM x1 y1 x2 y2\\": Query the sum of elements in the subgrid from (x1, y1) to (x2, y2). Returns: List[int]: A list containing the results of the sum queries. Examples: >>> process_grid_game(4, [\\"SET 1 2 5\\", \\"SUM 1 1 3 3\\"]) [5] >>> process_grid_game(4, [\\"SET 1 2 5\\", \\"SET 2 2 3\\", \\"SUM 1 1 3 3\\", \\"SET 3 3 7\\", \\"SUM 0 0 3 3\\"]) [8, 15] >>> process_grid_game(4, [\\"SET 1 1 2\\", \\"SET 1 1 3\\", \\"SUM 0 0 2 2\\"]) [3] >>> process_grid_game(1000, [\\"SET 0 0 10\\", \\"SET 999 999 20\\", \\"SET 500 500 30\\", \\"SUM 0 0 999 999\\"]) [60] >>> process_grid_game(10, [\\"SET 5 5 10000\\", \\"SUM 0 0 9 9\\"]) [10000]","solution":"class GridGame: def __init__(self, N): self.N = N self.grid = [[0] * N for _ in range(N)] def set_value(self, i, j, v): self.grid[i][j] = v def sum_subgrid(self, x1, y1, x2, y2): return sum( self.grid[i][j] for i in range(x1, x2 + 1) for j in range(y1, y2 + 1) ) def process_queries(self, queries): results = [] for query in queries: parts = query.split() if parts[0] == \\"SET\\": i, j, v = map(int, parts[1:]) self.set_value(i, j, v) elif parts[0] == \\"SUM\\": x1, y1, x2, y2 = map(int, parts[1:]) results.append(self.sum_subgrid(x1, y1, x2, y2)) return results # Function to simulate and process queries def process_grid_game(N, queries): game = GridGame(N) return game.process_queries(queries)"},{"question":"def longest_subarray_with_sum(arr: List[int], target: int) -> int: Finds the length of the longest contiguous subarray with a given sum. Parameters: arr (list): List of integers representing the array target (int): The target sum to check for in the subarray Returns: int: The length of the longest contiguous subarray that sums to target, or 0 if no such subarray exists Examples: >>> longest_subarray_with_sum([1, 2, 3, 4, -1], 5) 2 >>> longest_subarray_with_sum([1, 1, 1, 1, 1, 1, 1], 3) 3 >>> longest_subarray_with_sum([-1, -1, -1, -1, -1, -1], -2) 2","solution":"def longest_subarray_with_sum(arr, target): Finds the length of the longest contiguous subarray with a given sum. Parameters: arr (list): List of integers representing the array target (int): The target sum to check for in the subarray Returns: int: The length of the longest contiguous subarray that sums to target, or 0 if no such subarray exists prefix_sum = 0 prefix_sum_index = {0: -1} max_length = 0 for i, num in enumerate(arr): prefix_sum += num if prefix_sum - target in prefix_sum_index: max_length = max(max_length, i - prefix_sum_index[prefix_sum - target]) if prefix_sum not in prefix_sum_index: prefix_sum_index[prefix_sum] = i return max_length"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 8] >>> merge_sorted_arrays([-1, 0], [-2, 3, 4]) [-2, -1, 0, 3, 4] def handle_input(input_str): Handles the input for the merge sorted arrays function. >>> handle_input(\\"2n3n1 3 5n4n2 4 6 8n2n-1 0n3n-2 3 4n\\") [\\"1 2 3 4 5 6 8\\", \\"-2 -1 0 3 4\\"] # Few test cases for demonstration def test_merge_sorted_arrays(): assert merge_sorted_arrays([1, 3, 5], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 8] assert merge_sorted_arrays([-1, 0], [-2, 3, 4]) == [-2, -1, 0, 3, 4] def test_handle_input(): input_data = \\"2n3n1 3 5n4n2 4 6 8n2n-1 0n3n-2 3 4n\\" expected_output = [\\"1 2 3 4 5 6 8\\", \\"-2 -1 0 3 4\\"] assert handle_input(input_data) == expected_output","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array def handle_input(input_str): Handles the input for the merge sorted arrays function. inputs = input_str.strip().split('n') T = int(inputs[0]) results = [] index = 1 for _ in range(T): n = int(inputs[index]) arr1 = list(map(int, inputs[index+1].split())) m = int(inputs[index+2]) arr2 = list(map(int, inputs[index+3].split())) index += 4 merged_array = merge_sorted_arrays(arr1, arr2) results.append(\\" \\".join(map(str, merged_array))) return results"},{"question":"from typing import List def least_time_in_office(n: int, d: int, records: List[str]) -> List[str]: Calculate the total time each employee spent in the office and identify the employee(s) who spent the least time. Args: n (int): Number of employees. d (int): Number of days in the month. records (List[str]): A list of strings containing employee ID, entry time, and exit time in 24-hour format. Returns: List[str]: A list of employee ID(s) who spent the least time in the office during the month. >>> least_time_in_office(3, 4, [\\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\"]) [\\"emp2\\"]","solution":"def least_time_in_office(n, d, records): from collections import defaultdict total_times = defaultdict(int) for record in records: emp_id, entry, exit = record.split() entry_hours, entry_minutes = int(entry[:2]), int(entry[2:]) exit_hours, exit_minutes = int(exit[:2]), int(exit[2:]) entry_time_in_minutes = entry_hours * 60 + entry_minutes exit_time_in_minutes = exit_hours * 60 + exit_minutes total_times[emp_id] += (exit_time_in_minutes - entry_time_in_minutes) min_time = min(total_times.values()) smallest_time_employees = [emp_id for emp_id, time in total_times.items() if time == min_time] return smallest_time_employees # Example usage: n = 3 d = 4 records = [ \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\", \\"emp1 0900 1700\\", \\"emp2 1000 1500\\", \\"emp3 1030 1800\\" ] print(least_time_in_office(n, d, records)) # Output: ['emp2']"},{"question":"class ParkingLot: def __init__(self, capacity: int): Initialize the parking lot with the given capacity. def park(self, vehicle_id: int) -> bool: Parks a vehicle in the parking lot. Returns True if the vehicle is successfully parked, False otherwise. >>> pl = ParkingLot(2) >>> pl.park(1001) True >>> pl.park(1002) True >>> pl.park(1003) False def leave(self, vehicle_id: int) -> bool: Removes a vehicle from the parking lot. Returns True if the vehicle is successfully removed, False otherwise. >>> pl = ParkingLot(2) >>> pl.park(1001) True >>> pl.park(1002) True >>> pl.leave(1001) True >>> pl.leave(1004) False def status(self) -> str: Returns the current status of the parking lot. >>> pl = ParkingLot(2) >>> pl.park(1001) 'Vehicle 1001 is parked.' >>> pl.park(1002) 'Vehicle 1001 is parked. Vehicle 1002 is parked.' >>> pl.leave(1001) 'Vehicle 1002 is parked.' def getFreeSlots(self) -> int: Returns the number of free slots in the parking lot. >>> pl = ParkingLot(2) >>> pl.getFreeSlots() 2 >>> pl.park(1001) 1 >>> pl.park(1002) 0 >>> pl.leave(1001) 1","solution":"class ParkingLot: def __init__(self, capacity): self.capacity = capacity self.vehicles = set() def park(self, vehicle_id): if len(self.vehicles) < self.capacity: self.vehicles.add(vehicle_id) return True return False def leave(self, vehicle_id): if vehicle_id in self.vehicles: self.vehicles.remove(vehicle_id) return True return False def status(self): if self.vehicles: return \\" \\".join(f\\"Vehicle {vid} is parked.\\" for vid in self.vehicles) return \\"Parking lot is empty.\\" def getFreeSlots(self): return self.capacity - len(self.vehicles)"},{"question":"def longestUniquePath(grid: List[List[str]]) -> int: You are given a grid of size MxN consisting of various characters. Your task is to find the length of the longest path in the grid such that all the characters in the path are unique. The path can move in 4 directions (left, right, up, down) from a cell to its adjacent cells. The path should not revisit any cell in the grid more than once. Args: grid (List[List[str]]): A 2D grid consisting of uppercase English letters Returns: int: The length of the longest unique path Examples: >>> longestUniquePath([ ... ['A', 'B', 'C', 'D'], ... ['E', 'F', 'G', 'H'], ... ['I', 'J', 'K', 'L'], ... ['M', 'N', 'O', 'P'] ... ]) 16 >>> longestUniquePath([ ... ['A', 'A', 'C'], ... ['B', 'B', 'D'] ... ]) 4 from typing import List def test_longest_unique_path_all_unique(): grid = [ ['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['M', 'N', 'O', 'P'] ] assert longestUniquePath(grid) == 16 def test_longest_unique_path_some_duplicates(): grid = [ ['A', 'A', 'C'], ['B', 'B', 'D'] ] assert longestUniquePath(grid) == 4 def test_longest_unique_path_single_row(): grid = [['A', 'B', 'C', 'D']] assert longestUniquePath(grid) == 4 def test_longest_unique_path_single_column(): grid = [['A'], ['B'], ['C'], ['D']] assert longestUniquePath(grid) == 4 def test_longest_unique_path_small_grid(): grid = [['A', 'B'], ['C', 'D']] assert longestUniquePath(grid) == 4 def test_longest_unique_path_all_same(): grid = [['A', 'A'], ['A', 'A']] assert longestUniquePath(grid) == 1","solution":"def longestUniquePath(grid): def dfs(x, y, visited): # Base case: if out of bounds or character has been visited if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] in visited: return 0 visited.add(grid[x][y]) max_length = 1 # Current cell counts as length 1 # Explore all 4 directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy max_length = max(max_length, 1 + dfs(nx, ny, visited)) visited.remove(grid[x][y]) return max_length M, N = len(grid), len(grid[0]) max_path_length = 0 for i in range(M): for j in range(N): max_path_length = max(max_path_length, dfs(i, j, set())) return max_path_length"},{"question":"def minimum_possible_value(arr: List[int]) -> int: Given an array of integers, perform operations to compute the minimum possible value by summing pairs until one element is left. Parameters: arr (list of int): The input array. Returns: int: The minimum possible value of array after performing the operations. >>> minimum_possible_value([1, 2, 3]) 6 >>> minimum_possible_value([1, 1, 1, 1]) 4 >>> minimum_possible_value([2, 2, 2, 2]) 8 >>> minimum_possible_value([5, 10, 15]) 30 >>> minimum_possible_value([100, 200, 300, 400]) 1000 >>> minimum_possible_value([1]) 1 >>> minimum_possible_value([7, 8, 9, 10]) 34","solution":"def minimum_possible_value(arr): Given an array of integers, perform operations to compute the minimum possible value by summing pairs until one element is left. Parameters: arr (list of int): The input array. Returns: int: The minimum possible value of array after performing the operations. return sum(arr)"},{"question":"def can_form_bst(nodes): Returns \\"YES\\" if the given list of integers can form a valid BST. Otherwise, returns \\"NO\\". def check_bsts(cases): Takes a list of cases where each case is a tuple containing the number of nodes and a list of unique integers. Returns a list containing \\"YES\\" or \\"NO\\" for each case indicating if the nodes can form a valid BST. def test_can_form_bst_single_case(): assert can_form_bst([1, 3, 2, 4, 5]) == \\"YES\\" assert can_form_bst([2, 1, 3, 4]) == \\"YES\\" assert can_form_bst([7, 4, 6, 3, 8, 10]) == \\"NO\\" def test_check_bsts_multiple_cases(): cases = [ (5, [1, 3, 2, 4, 5]), (4, [2, 1, 3, 4]), (6, [7, 4, 6, 3, 8, 10]) ] assert check_bsts(cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_can_form_bst_empty_case(): assert can_form_bst([]) == \\"YES\\" def test_can_form_bst_only_one_node(): assert can_form_bst([1]) == \\"YES\\" def test_can_form_bst_two_nodes(): assert can_form_bst([2, 1]) == \\"YES\\" assert can_form_bst([1, 2]) == \\"YES\\" assert can_form_bst([2, 3, 1]) == \\"NO\\" if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def can_form_bst(nodes): Returns \\"YES\\" if the given list of integers can form a valid BST. Otherwise, returns \\"NO\\". def is_valid_bst(seq): if not seq: return True root = seq[0] left = [x for x in seq if x < root] right = [x for x in seq if x > root] # Check the continuity of left and right parts in the original sequence left_part = seq[1:len(left)+1] right_part = seq[len(left)+1:] if not (left == left_part and right == right_part): return False return is_valid_bst(left_part) and is_valid_bst(right_part) if is_valid_bst(nodes): return \\"YES\\" else: return \\"NO\\" def check_bsts(cases): results = [] for case in cases: n, nodes = case[0], case[1] results.append(can_form_bst(nodes)) return results"},{"question":"def hamiltonian_tour(r: int, c: int, n: int) -> str: Determine if a Hamiltonian tour is possible on an n x n grid starting from (r, c) and, if so, provide a sequence of moves (U, D, L, R). >>> hamiltonian_tour(1, 1, 1) \\"\\" >>> hamiltonian_tour(1, 1, 3) \\"impossible\\" >>> hamiltonian_tour(3, 3, 5) \\"impossible\\"","solution":"def is_hamiltonian_walk_possible(r, c, n): Checks if a Hamiltonian walk (visiting each grid cell exactly once and returning to the start point) is possible on an odd n x n grid starting from (r, c). # For the odd grid n x n when n > 2, there is no possibility to complete the tour return n == 1 def get_hamiltonian_path(r, c, n): Returns the Hamiltonian path if possible in the grid of size n x n starting from (r, c). if n == 1: return \\"\\" else: return \\"impossible\\" def hamiltonian_tour(r, c, n): if is_hamiltonian_walk_possible(r, c, n): return get_hamiltonian_path(r, c, n) else: return \\"impossible\\""},{"question":"def reverse_append_sequence(n: int, seq: List[int], m: int) -> List[int]: Repeatedly performs the reverse and append operation on the sequence until its length reaches or exceeds m. Parameters: n (int): Initial length of the sequence seq (list of int): The initial sequence m (int): The target length of the sequence Returns: list of int: The sequence after the operations, limited to the first m elements >>> reverse_append_sequence(2, [1, 2], 6) == [1, 2, 2, 1, 1, 2] >>> reverse_append_sequence(3, [1, 3, 5], 10) == [1, 3, 5, 5, 3, 1, 1, 3, 5, 5] def main(test_cases: List[Tuple[int, List[int], int]]) -> List[List[int]]: Processes multiple test cases. Parameters: test_cases (list of tuples): Each tuple contains the values for a single test case: - n (int): Initial length of the sequence - seq (list of int): The initial sequence - m (int): The target length of the sequence Returns: list of list of int: The sequences after the operations for each test case >>> main([(2, [1, 2], 6)]) == [[1, 2, 2, 1, 1, 2]] >>> main([(3, [1, 3, 5], 10)]) == [[1, 3, 5, 5, 3, 1, 1, 3, 5, 5]]","solution":"def reverse_append_sequence(n, seq, m): Repeatedly performs the reverse and append operation on the sequence until its length reaches or exceeds m. Parameters: n (int): Initial length of the sequence seq (list of int): The initial sequence m (int): The target length of the sequence Returns: list of int: The sequence after the operations, limited to the first m elements while len(seq) < m: seq = seq + seq[::-1] return seq[:m] def main(test_cases): results = [] for case in test_cases: n, seq, m = case result = reverse_append_sequence(n, seq, m) results.append(result) return results"},{"question":"def can_form_decorated_tree(test_cases): Determine if it's possible to form a decorated tree by removing some roads. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): A list of test cases, where each test case consists of the number of intersections, the number of roads, and a list of tuples representing the roads. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. Examples: >>> test_cases = [ ... (4, 5, [ ... (0, 1, 3), ... (0, 2, 5), ... (1, 2, 7), ... (1, 3, 4), ... (2, 3, 6) ... ]), ... (6, 8, [ ... (0, 1, 3), ... (0, 2, 2), ... (0, 3, 1), ... (1, 4, 4), ... (1, 5, 6), ... (2, 4, 2), ... (3, 5, 5), ... (4, 5, 3) ... ]) ... ] >>> expected_output = [\\"YES\\", \\"NO\\"] >>> assert can_form_decorated_tree(test_cases) == expected_output","solution":"def can_form_decorated_tree(test_cases): from heapq import heappop, heappush import sys def mst_kruskal(n, edges): parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 mst = [] edges.sort(key=lambda x: x[2]) for u, v, w in edges: if find(u) != find(v): union(u, v) mst.append((u, v, w)) return mst if len(mst) == n - 1 else None results = [] for n, m, roads in test_cases: mst = mst_kruskal(n, roads) if mst is None: results.append(\\"NO\\") else: mst.sort(key=lambda x: (x[2], x[0], x[1])) unique_weights = set(w for _, _, w in mst) if len(unique_weights) == len(mst): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Main function for reading input and processing def main(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) M = int(data[index + 1]) index += 2 roads = [] for _ in range(M): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) roads.append((u, v, w)) index += 3 test_cases.append((N, M, roads)) results = can_form_decorated_tree(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def merge_sorted_lists(list1, list2): Merge two sorted lists into a new sorted list. >>> merge_sorted_lists([1, 3, 5, 7, 9], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> merge_sorted_lists([1, 3, 5], [2, 4]) [1, 2, 3, 4, 5] >>> merge_sorted_lists([1, 2, 2, 3], [2, 2, 3, 4]) [1, 2, 2, 2, 2, 3, 3, 4] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([-5, -3, -1], [-4, -2, 0]) [-5, -4, -3, -2, -1, 0] >>> merge_sorted_lists([1000000000], [-1000000000]) [-1000000000, 1000000000]","solution":"def merge_sorted_lists(list1, list2): Merge two sorted lists into a new sorted list. Parameters: list1 (list of int): First sorted list. list2 (list of int): Second sorted list. Returns: list of int: Merged sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 # Merge the two lists while maintaining sorted order while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Add remaining elements from list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Add remaining elements from list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def rearrange_list(lst): Given a list of integers, rearrange the list in such a way that the even-indexed elements are sorted in ascending order and the odd-indexed elements are sorted in descending order. Args: lst (List[int]): The list of integers to be rearranged. Returns: List[int]: The rearranged list with sorted even-indexed and odd-indexed elements. Example: >>> rearrange_list([9, 4, 6, 7, 3, 8, 5, 10]) [3, 10, 5, 8, 6, 7, 9, 4] >>> rearrange_list([1]) [1]","solution":"def rearrange_list(lst): even_indexed = sorted(lst[::2]) odd_indexed = sorted(lst[1::2], reverse=True) result = [] even_iter = iter(even_indexed) odd_iter = iter(odd_indexed) for i in range(len(lst)): if i % 2 == 0: result.append(next(even_iter)) else: result.append(next(odd_iter)) return result"},{"question":"def countPalindromicPermutations(S): Returns the number of distinct palindromic permutations that can be formed from the given string S. >>> countPalindromicPermutations(\\"aabb\\") == 1 >>> countPalindromicPermutations(\\"abc\\") == 0 >>> countPalindromicPermutations(\\"aaa\\") == 1 >>> countPalindromicPermutations(\\"\\") == 1 >>> countPalindromicPermutations(\\"x\\") == 1 >>> countPalindromicPermutations(\\"aabbccdde\\") == 1 >>> countPalindromicPermutations(\\"aabbccddex\\") == 0","solution":"from collections import Counter def countPalindromicPermutations(S): Returns the number of distinct palindromic permutations that can be formed from the given string S. char_count = Counter(S) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd number of occurrences, we can't form a palindrome if odd_count > 1: return 0 # Calculate distinct palindromic permutations by factorial (only one possible for an odd count) return 1 if odd_count <= 1 else 0"},{"question":"def canFormPalindrome(s: str) -> bool: Check if the string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if, and only if, at most one character in the string has an odd count. Args: s (str): The input string consisting of lowercase Latin letters. Returns: bool: True if the input string can be rearranged to form a palindrome, otherwise False. Examples: >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False pass","solution":"def canFormPalindrome(s): from collections import Counter # Count the frequency of each character char_count = Counter(s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def singleUnique(arr: List[int]) -> int: Given an array of integers where every element appears twice except for one, find that single one. Example 1: >>> singleUnique([2,1,4,5,1,2,4]) == 5 Example 2: >>> singleUnique([6,3,3]) == 6","solution":"def singleUnique(arr): Finds the element that appears only once in an array where every other element appears twice. Uses XOR to achieve O(N) time complexity and O(1) space complexity. unique = 0 for num in arr: unique ^= num return unique"},{"question":"def process_operations(n: int, m: int, sequence: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Perform a series of operations on a sequence of integers, including updating an element and calculating the GCD of a subsequence. Args: n (int): The length of the sequence. m (int): The number of operations. sequence (List[int]): The initial sequence of integers. operations (List[Tuple[int, int, int]]): The operations to be performed. Returns: List[int]: The results of GCD queries. Examples: >>> process_operations(5, 4, [2, 4, 6, 8, 10], [(1, 1, 5), (2, 3, 12), (1, 2, 4), (1, 1, 5)]) [2, 4, 2] >>> process_operations(3, 3, [5, 10, 15], [(1, 1, 3), (2, 2, 5), (1, 1, 3)]) [5, 5] >>> process_operations(1, 2, [7], [(1, 1, 1), (2, 1, 9)]) [7] >>> process_operations(3, 3, [1000000000, 1000000000, 1000000000], [(1, 1, 3), (2, 2, 1), (1, 1, 3)]) [1000000000, 1] pass","solution":"from math import gcd from functools import reduce class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = gcd(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = gcd(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, l, r): res = 0 l += self.n r += self.n while l <= r: if l % 2 == 1: res = gcd(res, self.tree[l]) l += 1 if r % 2 == 0: res = gcd(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def process_operations(n, m, sequence, operations): # Initialize the segment tree st = SegmentTree(sequence) result = [] for op in operations: if op[0] == 1: # GCD query operation _, l, r = op result.append(st.query(l - 1, r - 1)) elif op[0] == 2: # Update operation _, i, x = op st.update(i - 1, x) return result"},{"question":"def is_balanced(s: str) -> bool: Checks if the brackets in the string are properly nested and balanced. >>> is_balanced(\\"(a + b) * [c - {d/e} + <f * g>]\\") True >>> is_balanced(\\"[{(<a + b> + c) * d}]\\") True >>> is_balanced(\\"(<a + b>\\") False >>> is_balanced(\\"{a * (b + c})\\") False >>> is_balanced(\\"a + b + c\\") True","solution":"def is_balanced(s): Checks if the brackets in the string are properly nested and balanced. stack = [] bracket_map = {')': '(', ']': '[', '}': '{', '>': '<'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"def is_zigzag_number(n: int) -> str: Determines if the given number is a Zigzag number. A number is considered a Zigzag number if for every three consecutive digits x, y, z: (x < y > z) or (x > y < z). Args: n (int): The number to be checked. Returns: str: \\"YES\\" if the given number is a Zigzag number, \\"NO\\" otherwise. >>> is_zigzag_number(123) \\"NO\\" >>> is_zigzag_number(121) \\"YES\\" >>> is_zigzag_number(132) \\"YES\\"","solution":"def is_zigzag_number(n): Determines if the given number is a Zigzag number. A number is considered a Zigzag number if for every three consecutive digits x, y, z: (x < y > z) or (x > y < z). Args: n (int): The number to be checked. Returns: str: \\"YES\\" if the given number is a Zigzag number, \\"NO\\" otherwise. s = str(n) length = len(s) if length < 3: return \\"NO\\" for i in range(1, length - 1): if not ((s[i-1] < s[i] > s[i+1]) or (s[i-1] > s[i] < s[i+1])): return \\"NO\\" return \\"YES\\""},{"question":"import bisect from typing import List def process_operations(n: int, operations: List[str]) -> List[int]: You are given a series of operations to perform on an initially empty set of integers. The operations are of two types: 1. Add a number x to the set. 2. Given a number y, find the largest number in the set that is smaller than or equal to y. If there is no such number in the set, return -1. Given n, the number of operations, and an array of operations, return the results for each operation of the second type. Args: n (int): The number of operations operations (List[str]): The list of operations in the format \\"1 x\\" or \\"2 y\\" Returns: List[int]: Results of each \\"2 y\\" operation Example: >>> process_operations(6, [\\"1 10\\", \\"1 20\\", \\"2 15\\", \\"1 25\\", \\"2 20\\", \\"2 5\\"]) [10, 20, -1]","solution":"import bisect def process_operations(n, operations): sorted_set = [] results = [] for operation in operations: op_type, value = map(int, operation.split()) if op_type == 1: # Add number x to the set if value not in sorted_set: bisect.insort(sorted_set, value) elif op_type == 2: # Find largest number in set ≤ y pos = bisect.bisect_right(sorted_set, value) if pos == 0: results.append(-1) else: results.append(sorted_set[pos - 1]) return results # Example use operations = [ \\"1 10\\", \\"1 20\\", \\"2 15\\", \\"1 25\\", \\"2 20\\", \\"2 5\\" ] print(process_operations(6, operations))"},{"question":"from typing import List def find_perfect_numbers(n: int) -> List[int]: A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Find all perfect numbers up to a given limit \`n\`. >>> find_perfect_numbers(6) [6] >>> find_perfect_numbers(30) [6, 28] >>> find_perfect_numbers(100) [6, 28] >>> find_perfect_numbers(1) [] >>> find_perfect_numbers(5) [] >>> find_perfect_numbers(500) [6, 28, 496] >>> find_perfect_numbers(29) [6, 28] pass","solution":"from typing import List def find_perfect_numbers(n: int) -> List[int]: Returns a list of all perfect numbers up to and including n. def is_perfect(number): divisors_sum = sum(i for i in range(1, number) if number % i == 0) return divisors_sum == number perfect_numbers = [] for num in range(1, n + 1): if is_perfect(num): perfect_numbers.append(num) return perfect_numbers"},{"question":"def min_stations_to_cover_path(stations): Determines the minimum number of water stations required to cover the entire path from 1 to 100,000 meters. If it's not possible, returns \\"IMPOSSIBLE\\". Parameters: stations (List[Tuple[int, int]]): List of tuples where each tuple consists of two integers representing the starting meter and ending meter that the water station can cover. Returns: int or str: The minimum number of water stations needed, or \\"IMPOSSIBLE\\" if it is not possible to cover the entire path. Examples: >>> min_stations_to_cover_path([(1, 30000), (25000, 70000), (65000, 100000)]) 3 >>> min_stations_to_cover_path([(1, 20000), (10000, 40000), (30000, 70000), (60000, 100000)]) 4 >>> min_stations_to_cover_path([(1, 50000), (45000, 75000), (70000, 100000)]) 3 >>> min_stations_to_cover_path([(1, 40000), (60000, 100000)]) \\"IMPOSSIBLE\\"","solution":"def min_stations_to_cover_path(stations): Determines the minimum number of water stations required to cover the entire path from 1 to 100,000 meters. If it's not possible, returns \\"IMPOSSIBLE\\". stations.sort(key=lambda x: (x[0], -x[1])) target = 100000 current_end = 0 max_reach = 0 index = 0 count = 0 n = len(stations) while current_end < target: while index < n and stations[index][0] <= current_end + 1: max_reach = max(max_reach, stations[index][1]) index += 1 if max_reach == current_end: return \\"IMPOSSIBLE\\" current_end = max_reach count += 1 if current_end >= target: return count return \\"IMPOSSIBLE\\""},{"question":"from typing import List, Tuple def find_valid_sequences(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Finds valid sequences of toy numbers based on comparison rules, or determines if no valid arrangement exists. >>> find_valid_sequences([(3, 2, [(1, 2), (2, 3)]), (3, 3, [(1, 2), (2, 3), (3, 1)])]) ['1 2 3', 'No valid arrangement'] >>> find_valid_sequences([(4, 2, [(1, 2), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) ['1 3 2 4', 'No valid arrangement'] >>> find_valid_sequences([(2, 1, [(2, 1)]), (1, 0, [])]) ['2 1', '1'] >>> find_valid_sequences([(3, 0, []), (2, 2, [(1, 2), (2, 1)])]) ['1 2 3', 'No valid arrangement'] >>> find_valid_sequences([(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 3)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) ['No valid arrangement', '1 2 3 4 5']","solution":"from collections import defaultdict, deque def find_toys_sequence(N, K, rules): # Create a graph to represent the constraints graph = defaultdict(list) in_degree = {i: 0 for i in range(1, N+1)} # Populate the graph and in_degree counts for X, Y in rules: graph[X].append(Y) in_degree[Y] += 1 # Queue for the nodes with no incoming edges queue = deque() for node in in_degree: if in_degree[node] == 0: queue.append(node) # Perform topological sort sorted_list = [] while queue: node = queue.popleft() sorted_list.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If sorted_list contains all nodes, we have a valid sequence if len(sorted_list) == N: return \\" \\".join(map(str, sorted_list)) else: return \\"No valid arrangement\\" def find_valid_sequences(test_cases): results = [] for N, K, rules in test_cases: results.append(find_toys_sequence(N, K, rules)) return results"},{"question":"def minimal_marathon_distance(n: int, paths: List[Tuple[int, int, int]]) -> int: Determine the minimal distance required to cover all key locations in a directed path starting at location 0 and ending at location n-1. Args: n: An integer representing the number of locations. paths: A list of tuples, each containing three integers (u, v, d) representing a directed path from location u to location v with distance d. Returns: An integer representing the minimal distance required to cover all the key locations. Examples: >>> minimal_marathon_distance(3, [(0, 1, 2), (1, 2, 3)]) 5 >>> minimal_marathon_distance(4, [(0, 1, 1), (0, 2, 4), (1, 2, 2), (2, 3, 5)]) 8 # Your implementation goes here # Unit tests def test_minimal_marathon_distance_case_1(): n = 3 paths = [ (0, 1, 2), (1, 2, 3) ] assert minimal_marathon_distance(n, paths) == 5 def test_minimal_marathon_distance_case_2(): n = 4 paths = [ (0, 1, 1), (0, 2, 4), (1, 2, 2), (2, 3, 5) ] assert minimal_marathon_distance(n, paths) == 8 def test_minimal_marathon_distance_case_3(): n = 5 paths = [ (0, 1, 3), (0, 2, 10), (1, 3, 2), (2, 3, 1), (3, 4, 4) ] assert minimal_marathon_distance(n, paths) == 9 def test_minimal_marathon_distance_single_path(): n = 2 paths = [ (0, 1, 1) ] assert minimal_marathon_distance(n, paths) == 1 def test_minimal_marathon_distance_complex_case(): n = 4 paths = [ (0, 1, 2), (0, 2, 3), (1, 3, 4), (2, 3, 2) ] assert minimal_marathon_distance(n, paths) == 5","solution":"from collections import defaultdict, deque def find_min_distance(n, paths): # Create a graph adjacency list graph = defaultdict(list) for u, v, d in paths: graph[u].append((v, d)) # Kahn's algorithm for topological sorting in_degree = [0] * n for u in graph: for v, _ in graph[u]: in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbor, _ in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Initialize distances with infinity INF = float('inf') dist = [INF] * n dist[0] = 0 # distance to the start node is 0 # Relax edges in topological order for u in topo_order: for v, d in graph[u]: if dist[u] != INF and dist[u] + d < dist[v]: dist[v] = dist[u] + d # The distance to the last node return dist[n-1] # Wrapper function to parse the given input def minimal_marathon_distance(n, path_info): return find_min_distance(n, path_info)"},{"question":"def max_sum_subgrid(grid, N, M, A, B): Find the maximum sum of a subgrid of size A x B in an N x M grid. Args: grid (List[List[int]]): A 2D list representing the grid. N (int): The number of rows in the grid. M (int): The number of columns in the grid. A (int): The number of rows in the subgrid. B (int): The number of columns in the subgrid. Returns: int: The maximum sum of a subgrid of size A x B. Example: >>> grid = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ] >>> N, M = 4, 5 >>> A, B = 2, 3 >>> max_sum_subgrid(grid, N, M, A, B) 99","solution":"def max_sum_subgrid(grid, N, M, A, B): Finds the maximum sum of a subgrid of size A x B in an N x M grid. max_sum = float('-inf') # Iterate over starting points of subgrids for i in range(N - A + 1): for j in range(M - B + 1): # Calculate the sum of the subgrid starting at (i, j) subgrid_sum = 0 for k in range(A): for l in range(B): subgrid_sum += grid[i + k][j + l] # Update max_sum if we found a larger sum if subgrid_sum > max_sum: max_sum = subgrid_sum return max_sum # Example usage: # grid = [ # [1, 2, 3, 4, 5], # [6, 7, 8, 9, 10], # [11, 12, 13, 14, 15], # [16, 17, 18, 19, 20] # ] # N, M = 4, 5 # A, B = 2, 3 # print(max_sum_subgrid(grid, N, M, A, B)) # Should output 99"},{"question":"from typing import List, Tuple def min_cost_to_make_elements_equal_to_median(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum total cost required to make all elements of an array equal to the median. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple consists of an integer n representing the number of elements in the array, and a list of n integers which are the elements of the array. Returns: List[int]: A list of integers representing the minimum total cost for each test case. Examples: >>> min_cost_to_make_elements_equal_to_median(3, [(3, [1, 2, 3]), (4, [1, 10, 2, 9]), (5, [3, 3, 1, 2, 1])]) [2, 16, 4] >>> min_cost_to_make_elements_equal_to_median(2, [(4, [4, 4, 4, 4]), (2, [1, 2])]) [0, 1] >>> min_cost_to_make_elements_equal_to_median(1, [(5, [10, 20, 30, 40, 50])]) [60] >>> min_cost_to_make_elements_equal_to_median(1, [(3, [7, 7, 7])]) [0] >>> min_cost_to_make_elements_equal_to_median(1, [(3, [5, 1, 9])]) [8]","solution":"def min_cost_to_make_elements_equal_to_median(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] a.sort() median = a[n // 2] if n % 2 != 0 else a[(n // 2) - 1] cost = sum(abs(x - median) for x in a) results.append(cost) return results"},{"question":"def min_max_difficulty_route(N: int, M: int, D: int, trails: List[Tuple[int, int, int]]) -> int: Determine the smallest possible value of the maximum difficulty level of any trail on the route from intersection 1 to intersection N which doesn't exceed D. >>> min_max_difficulty_route(4, 5, 5, [(1, 2, 4), (1, 3, 2), (2, 4, 5), (3, 4, 6), (2, 3, 3)]) == 5 >>> min_max_difficulty_route(2, 1, 10, [(1, 2, 5)]) == 5 >>> min_max_difficulty_route(3, 3, 4, [(1, 2, 5), (2, 3, 6), (3, 1, 7)]) == -1 >>> min_max_difficulty_route(5, 6, 10, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 10), (2, 5, 7)]) == 4 >>> min_max_difficulty_route(5, 7, 8, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 1), (1, 3, 8), (3, 5, 7), (2, 4, 6)]) == 5","solution":"import heapq from collections import defaultdict, deque def min_max_difficulty_route(N, M, D, trails): Determine the smallest possible value of the maximum difficulty level of any trail on the route from intersection 1 to intersection N which doesn't exceed D. # A graph dictionary using defaultdict graph = defaultdict(list) for a, b, d in trails: # only include edges with difficulty not exceeding D if d <= D: graph[a].append((b, d)) graph[b].append((a, d)) # Dijkstra's algorithm modified to find the minimum of maximum difficulties def dijkstra_max_difficulty(start): min_heap = [(0, start)] max_difficulties = {i: float('inf') for i in range(1, N+1)} max_difficulties[start] = 0 while min_heap: current_max_diff, node = heapq.heappop(min_heap) for neighbor, weight in graph[node]: new_max_diff = max(current_max_diff, weight) if new_max_diff < max_difficulties[neighbor]: max_difficulties[neighbor] = new_max_diff heapq.heappush(min_heap, (new_max_diff, neighbor)) return max_difficulties[N] result = dijkstra_max_difficulty(1) return result if result != float('inf') else -1"},{"question":"def maximum_gift_sum(t, test_cases): Returns the maximum possible sum for each test case. Arguments: t : int - Number of test cases. test_cases : List of tuples - Each tuple contains two elements (N, K, gifts) where N is the number of gifts, K is the number of gifts to select, gifts is a list of integers representing the gift values. Returns: List of integers - Maximum possible sum for each test case. pass def test_maximum_gift_sum_example(): t = 2 test_cases = [ (5, 3, [1, 2, 3, 4, 5]), (4, 2, [-1, -2, -3, -4]) ] expected_result = [12, -3] assert maximum_gift_sum(t, test_cases) == expected_result def test_maximum_gift_sum_all_negative(): t = 1 test_cases = [ (5, 3, [-5, -4, -3, -2, -1]) ] expected_result = [-6] # Sum of -1, -2, -3 assert maximum_gift_sum(t, test_cases) == expected_result def test_maximum_gift_sum_single_gift(): t = 1 test_cases = [ (1, 1, [10]) ] expected_result = [10] # Only one gift to pick assert maximum_gift_sum(t, test_cases) == expected_result def test_maximum_gift_sum_large_input(): t = 1 n = 10**5 k = 10**5 gifts = [i for i in range(1, n+1)] test_cases = [ (n, k, gifts) ] expected_result = [sum(gifts)] # Sum of first 10^5 natural numbers assert maximum_gift_sum(t, test_cases) == expected_result def test_maximum_gift_sum_mixed_values(): t = 1 test_cases = [ (6, 3, [10, -10, -20, 5, 7, -6]) ] expected_result = [22] # Sum of 10, 7, and 5 assert maximum_gift_sum(t, test_cases) == expected_result","solution":"def maximum_gift_sum(t, test_cases): Returns the maximum possible sum for each test case. Arguments: t : int - Number of test cases. test_cases : List of tuples - Each tuple contains two elements (N, K, gifts) where N is the number of gifts, K is the number of gifts to select, gifts is a list of integers representing the gift values. Returns: List of integers - Maximum possible sum for each test case. results = [] for case in test_cases: n, k, gifts = case gifts.sort(reverse=True) # Sort gifts in descending order results.append(sum(gifts[:k])) # Sum of top k gifts return results"},{"question":"def uniquePathsWithObstacles(grid): Determine the number of unique paths from the top left cell to the bottom right cell in a grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where 0 is a passable cell and 1 is an obstacle. Returns: int: The number of unique paths from the start to the end cell. >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[0, 1], [0, 0]]) 1","solution":"def uniquePathsWithObstacles(grid): m = len(grid) n = len(grid[0]) # If the start or end point is blocked, return 0 if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize a dp array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def find_kth_smallest(arr1: List[int], arr2: List[int], k: int) -> int: Finds the k-th smallest element in the sorted union of two sorted arrays. Parameters: arr1 (List[int]): First sorted list of integers. arr2 (List[int]): Second sorted list of integers. k (int): The k-th position (1-based). Returns: int: The k-th smallest element in the sorted union of arr1 and arr2. >>> find_kth_smallest([1, 3, 5, 7, 9], [2, 4, 6, 8], 5) == 5 >>> find_kth_smallest([1], [2], 1) == 1 >>> find_kth_smallest([1], [2], 2) == 2 >>> find_kth_smallest([1, 3, 5, 7, 9], [], 2) == 3 >>> find_kth_smallest([1, 4, 5, 7], [2, 3, 6, 8], 1) == 1 >>> find_kth_smallest([1, 4, 5, 7], [2, 3, 6, 8], 7) == 7 >>> find_kth_smallest([1, 2, 3, 4, 5], [6, 7, 8], 7) == 7","solution":"def find_kth_smallest(arr1, arr2, k): Finds the k-th smallest element in the sorted union of two sorted arrays. Parameters: arr1 (list): First sorted list of integers. arr2 (list): Second sorted list of integers. k (int): The k-th position (1-based). Returns: int: The k-th smallest element in the sorted union of arr1 and arr2. i = j = 0 while k > 0: if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]): i += 1 k -= 1 if k == 0: return arr1[i-1] else: j += 1 k -= 1 if k == 0: return arr2[j-1]"},{"question":"def max_books_with_bookmarks(n: int, m: int, weights: List[int], capacities: List[int]) -> int: Determines the maximum number of books that can have bookmarks placed in them without exceeding their weight capacities. Parameters: - n: Number of books (int) - m: Number of bookmarks (int) - weights: List of integers representing the weight of each book - capacities: List of integers representing the weight capacity of each bookmark Returns: - The maximum number of books that can have bookmarks placed in them (int) >>> max_books_with_bookmarks(5, 3, [2, 4, 6, 8, 10], [3, 7, 5]) 3 >>> max_books_with_bookmarks(4, 5, [1, 2, 3, 4], [1, 1, 1, 1, 1]) 1 >>> max_books_with_bookmarks(3, 3, [5, 3, 8], [4, 7, 5]) 2","solution":"def max_books_with_bookmarks(n, m, weights, capacities): Determines the maximum number of books that can have bookmarks placed in them without exceeding their weight capacities. Parameters: - n: Number of books (int) - m: Number of bookmarks (int) - weights: List of integers representing the weight of each book - capacities: List of integers representing the weight capacity of each bookmark Returns: - The maximum number of books that can have bookmarks placed in them (int) # Sort weights of books in ascending order weights.sort() # Sort capacities of bookmarks in ascending order capacities.sort() book_index, bookmark_index, count = 0, 0, 0 # Use two pointers to approach the problem while book_index < n and bookmark_index < m: if weights[book_index] <= capacities[bookmark_index]: count += 1 book_index += 1 bookmark_index += 1 return count"},{"question":"def classify_animal(animal): Classifies an animal into one of the vertebrate classes or as an invertebrate. Parameters: animal (dict): A dictionary with the following keys: - 'name' (string): The name of the animal - 'vertebral_column' (boolean): Whether the animal has a vertebral column - 'warm_blooded' (boolean): Whether the animal is warm-blooded - 'live_birth' (boolean): Whether the animal gives live birth Returns: string: The classification of the animal ('Fish', 'Amphibian', 'Reptile', 'Bird', 'Mammal', or 'Invertebrate')","solution":"def classify_animal(animal): Classifies an animal into one of the vertebrate classes or as an invertebrate. Parameters: animal (dict): A dictionary with the following keys: - 'name' (string): The name of the animal - 'vertebral_column' (boolean): Whether the animal has a vertebral column - 'warm_blooded' (boolean): Whether the animal is warm-blooded - 'live_birth' (boolean): Whether the animal gives live birth Returns: string: The classification of the animal ('Fish', 'Amphibian', 'Reptile', 'Bird', 'Mammal', or 'Invertebrate') if not animal['vertebral_column']: return 'Invertebrate' if animal['warm_blooded']: if animal['live_birth']: return 'Mammal' return 'Bird' else: if animal['live_birth']: return 'Amphibian' return 'Reptile' # If no condition matches, return 'Fish' by default return 'Fish'"},{"question":"def categorize_and_sort_books(books): Categorizes books by their genres and then sorts them by the number of pages. Parameters: books (list of tuples): Each tuple contains the genre (str), title (str) and number of pages (int). Returns: dict: A dictionary where the keys are genres and the values are lists of books (represented as dictionaries with keys 'title' and 'pages'), sorted by number of pages. from collections import defaultdict # Example test cases books_1 = [('Fiction', 'Book A', 200), ('Non-Fiction', 'Book B', 150), ('Fiction', 'Book C', 100), ('Fiction', 'Book D', 300), ('Non-Fiction', 'Book E', 100)] expected_output_1 = { 'Fiction': [{'title': 'Book C', 'pages': 100}, {'title': 'Book A', 'pages': 200}, {'title': 'Book D', 'pages': 300}], 'Non-Fiction': [{'title': 'Book E', 'pages': 100}, {'title': 'Book B', 'pages': 150}] } books_2 = [('Biography', 'Steve Jobs', 600), ('Biography', 'The Wright Brothers', 320), ('History', 'Sapiens', 430), ('History', 'Guns, Germs, and Steel', 480), ('Biography', 'Leonardo da Vinci', 500), ('Magazine', 'National Geographic', 120)] expected_output_2 = { 'Biography': [{'title': 'The Wright Brothers', 'pages': 320}, {'title': 'Leonardo da Vinci', 'pages': 500}, {'title': 'Steve Jobs', 'pages': 600}], 'History': [{'title': 'Sapiens', 'pages': 430}, {'title': 'Guns, Germs, and Steel', 'pages': 480}], 'Magazine': [{'title': 'National Geographic', 'pages': 120}] }","solution":"def categorize_and_sort_books(books): Categorizes books by their genres and then sorts them by the number of pages. Parameters: books (list of tuples): Each tuple contains the genre (str), title (str) and number of pages (int). Returns: dict: A dictionary where the keys are genres and the values are lists of books (represented as dictionaries with keys 'title' and 'pages'), sorted by number of pages. from collections import defaultdict # Create a dictionary to store books by genres genre_dict = defaultdict(list) # Fill the dictionary with books for genre, title, pages in books: genre_dict[genre].append({'title': title, 'pages': pages}) # Sort the books within each genre by the number of pages for genre in genre_dict: genre_dict[genre].sort(key=lambda x: x['pages']) return genre_dict # Test example books = [('Fiction', 'Book A', 200), ('Non-Fiction', 'Book B', 150), ('Fiction', 'Book C', 100), ('Fiction', 'Book D', 300), ('Non-Fiction', 'Book E', 100)] print(categorize_and_sort_books(books))"},{"question":"def count_substrings(strings: List[str], target: str) -> int: Returns the number of times the target string appears as a substring within the list of strings, case-insensitive. >>> count_substrings([\\"hello\\", \\"world\\", \\"HELLO\\", \\"wORLD\\"], \\"hello\\") == 2 >>> count_substrings([\\"Test\\", \\"TEst\\", \\"TESt\\"], \\"test\\") == 3 >>> count_substrings([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") == 0 >>> count_substrings([\\"hello\\", \\"hell\\", \\"heaven\\", \\"HELLO\\"], \\"hell\\") == 3 >>> count_substrings([\\"\\", \\"\\", \\"\\"], \\"anything\\") == 0 >>> count_substrings([\\"MiXeDcAsE\\", \\"MixEdCaSe\\", \\"mIXedcAsE\\"], \\"Mixed\\") == 3","solution":"def count_substrings(strings, target): Returns the number of times the target string appears as a substring within the list of strings, case-insensitive. target_lower = target.lower() count = 0 for string in strings: if target_lower in string.lower(): count += 1 return count"},{"question":"def kth_longest_string(strings, k): Sorts the list of strings by their lengths in descending order and returns the k-th longest string. If multiple strings have the same length, maintains their relative order from the input list. >>> kth_longest_string([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"watermelon\\", \\"grape\\"], 2) 'banana' >>> kth_longest_string([\\"cat\\", \\"dog\\", \\"bird\\", \\"elephant\\"], 1) 'elephant'","solution":"def kth_longest_string(strings, k): Sorts the list of strings by their lengths in descending order and returns the k-th longest string. If multiple strings have the same length, maintains their relative order from the input list. # Sort strings by their lengths in descending order; if lengths are the same, maintain original order sorted_strings = sorted(strings, key=lambda x: len(x), reverse=True) return sorted_strings[k-1]"},{"question":"def findMissingPositive(arr: List[int]) -> int: This function takes an array of integers and returns the smallest positive integer that is not present in the array. >>> findMissingPositive([1, 3, 6, 4, 1, 2]) 5 >>> findMissingPositive([1, 2, 3, 4]) 5 >>> findMissingPositive([-1, -2, -3, 4]) 1 def test_find_missing_positive(): assert findMissingPositive([1, 3, 6, 4, 1, 2]) == 5 assert findMissingPositive([1, 2, 3, 4]) == 5 assert findMissingPositive([-1, -2, -3, 4]) == 1 assert findMissingPositive([0, 10, 2, -10, 1]) == 3 assert findMissingPositive([7, 8, 9, 11, 12]) == 1 assert findMissingPositive([1]) == 2 assert findMissingPositive([]) == 1 assert findMissingPositive([2, 3, 4, 5, 6]) == 1 assert findMissingPositive([1, 2, 0, -1, 3]) == 4 test_find_missing_positive()","solution":"def findMissingPositive(arr): This function takes an array of integers and returns the smallest positive integer that is not present in the array. # Filtering the array to only positive numbers arr = [num for num in arr if num > 0] # Using a set for quick look-up of present numbers num_set = set(arr) # Start checking from 1 upwards smallest_missing_positive = 1 while smallest_missing_positive in num_set: smallest_missing_positive += 1 return smallest_missing_positive"},{"question":"class BankAccount: def __init__(self): self.balance = 0 self.history = [] def deposit(self, amount: int): self.history.append(self.balance) self.balance += amount def withdraw(self, amount: int): if self.balance >= amount: self.history.append(self.balance) self.balance -= amount def undo(self): if self.history: self.balance = self.history.pop() def get_balance(self) -> int: return self.balance def perform_operations(operations: List[str]) -> List[int]: Perform a series of operations on a basic bank account system. Args: operations (List[str]): A list of operations (deposit, withdraw, balance, undo) to be performed on the account. Returns: List[int]: A list of balances after each 'balance' operation. Example: >>> perform_operations([\\"deposit 100\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"undo\\", \\"balance\\", \\"undo\\", \\"balance\\"]) [100, 50, 100, 0] from typing import List from solution import perform_operations def test_example_case(): operations = [ \\"deposit 100\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"undo\\", \\"balance\\", \\"undo\\", \\"balance\\" ] results = perform_operations(operations) assert results == [100, 50, 100, 0] def test_only_deposits(): operations = [\\"deposit 100\\", \\"deposit 200\\", \\"balance\\"] results = perform_operations(operations) assert results == [300] def test_only_withdraw(): operations = [\\"deposit 100\\", \\"withdraw 50\\", \\"balance\\"] results = perform_operations(operations) assert results == [50] def test_with_undo_operations(): operations = [\\"deposit 100\\", \\"undo\\", \\"balance\\"] results = perform_operations(operations) assert results == [0] def test_unable_to_withdraw(): operations = [\\"deposit 100\\", \\"withdraw 200\\", \\"balance\\"] results = perform_operations(operations) assert results == [100] def test_multiple_undo_operations(): operations = [ \\"deposit 100\\", \\"withdraw 50\\", \\"undo\\", \\"undo\\", \\"balance\\" ] results = perform_operations(operations) assert results == [0]","solution":"class BankAccount: def __init__(self): self.balance = 0 self.history = [] def deposit(self, amount): self.history.append(self.balance) self.balance += amount def withdraw(self, amount): if self.balance >= amount: self.history.append(self.balance) self.balance -= amount def undo(self): if self.history: self.balance = self.history.pop() def get_balance(self): return self.balance def perform_operations(operations): account = BankAccount() results = [] for operation in operations: if operation.startswith(\\"deposit\\"): amount = int(operation.split()[1]) account.deposit(amount) elif operation.startswith(\\"withdraw\\"): amount = int(operation.split()[1]) account.withdraw(amount) elif operation == \\"undo\\": account.undo() elif operation == \\"balance\\": results.append(account.get_balance()) return results"},{"question":"def min_diff_pearl_groups(n: int, pearls: List[int]) -> int: Determine the minimum possible absolute difference between the sums of the two groups. >>> min_diff_pearl_groups(4, [1, 2, 3, 4]) == 0 >>> min_diff_pearl_groups(5, [1, 3, -2, 8, -7]) == 1","solution":"def min_diff_pearl_groups(n, pearls): total_sum = sum(pearls) min_diff = float('inf') for i in range(n): current_sum = 0 for j in range(n): current_sum += pearls[(i + j) % n] other_sum = total_sum - current_sum min_diff = min(min_diff, abs(current_sum - other_sum)) return min_diff"},{"question":"def can_fill_checkerboard(t, cases): Determine if Alice and Bob can fill the checkerboard without violating the rules. Arguments: t : int : the number of test cases cases : list of tuple : dimensions of the checkerboard for each test case Returns: list of tuple : Each tuple contains \\"YES\\" or \\"NO\\" and the checkerboard configuration. >>> can_fill_checkerboard(1, [(2, 2)]) [(\\"YES\\", ['AB', 'BA'])] >>> can_fill_checkerboard(1, [(3, 3)]) [(\\"YES\\", ['ABA', 'BAB', 'ABA'])] >>> can_fill_checkerboard(1, [(4, 4)]) [(\\"YES\\", ['ABAB', 'BABA', 'ABAB', 'BABA'])] def format_output(results): Format the output for the results. Arguments: results : list of tuple : Each tuple contains \\"YES\\" or \\"NO\\" and the checkerboard configuration. Returns: str : Formatted output as a single string. >>> results = [(\\"YES\\", ['AB', 'BA']), (\\"YES\\", ['ABA', 'BAB', 'ABA'])] >>> format_output(results) \\"YESnABnBAnYESnABAnBABnABA\\"","solution":"def can_fill_checkerboard(t, cases): results = [] for case in cases: n, m = case checkerboard = [] for i in range(n): row = [] for j in range(m): if (i + j) % 2 == 0: row.append('A') else: row.append('B') checkerboard.append(''.join(row)) results.append((\\"YES\\", checkerboard)) return results def format_output(results): output = [] for result in results: output.append(result[0]) output.extend(result[1]) return 'n'.join(output)"},{"question":"from typing import List def min_problems_to_solve(n: int, M: int, scores: List[int]) -> int: Calculate the minimum number of problems a participant needs to solve to achieve a cumulative score of at least M. Args: n (int): The number of problems solved. M (int): The target score. scores (List[int]): List of scores for each problem. Returns: int: Minimum number of problems needed to reach or exceed the target score M. If impossible, return -1. Examples: >>> min_problems_to_solve(5, 15, [5, 3, 9, 7, 2]) 2 >>> min_problems_to_solve(4, 10, [2, 2, 2, 2]) -1","solution":"from typing import List def min_problems_to_solve(n: int, M: int, scores: List[int]) -> int: Returns the minimum number of problems needed to achieve at least score M. # Sort the scores in descending order scores.sort(reverse=True) current_score = 0 for i, score in enumerate(scores): current_score += score if current_score >= M: return i + 1 # Return the number of problems solved return -1 # If we cannot reach the score M with all problems"},{"question":"def min_travel_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine the minimum travel cost from the capital (town 1) to all other towns. Args: n (int): Number of towns. m (int): Number of one-way roads. roads (List[Tuple[int, int, int]]): List of roads where each road is represented as a tuple (u, v, c) indicating a one-way road from town u to town v of cost c. Returns: List[int]: A list of minimum travel costs from the capital (town 1) to each town from 2 to n. If a town cannot be reached, the cost should be -1. Examples: >>> min_travel_cost(4, 5, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (2, 4, 1), (3, 4, 1)]) [10, 15, 11] >>> min_travel_cost(3, 2, [(1, 2, 5), (3, 1, 10)]) [5, -1]","solution":"import heapq def min_travel_cost(n, m, roads): graph = {i: [] for i in range(1, n + 1)} for u, v, c in roads: graph[u].append((v, c)) def dijkstra(start): min_cost = {i: float('inf') for i in range(1, n + 1)} min_cost[start] = 0 priority_queue = [(0, start)] while priority_queue: current_cost, u = heapq.heappop(priority_queue) if current_cost > min_cost[u]: continue for v, c in graph[u]: cost = current_cost + c if cost < min_cost[v]: min_cost[v] = cost heapq.heappush(priority_queue, (cost, v)) return min_cost min_costs = dijkstra(1) result = [] for i in range(2, n+1): if min_costs[i] == float('inf'): result.append(-1) else: result.append(min_costs[i]) return result"},{"question":"def count_palindromes(numbers): Returns the count of palindrome numbers in the given list of numbers. >>> count_palindromes([121, 131, 33, 454]) == 4 >>> count_palindromes([123, 456, 789, 98765]) == 0 >>> count_palindromes([121, 123, 20, 22, 999]) == 3 >>> count_palindromes([121]) == 1 >>> count_palindromes([123]) == 0","solution":"def count_palindromes(numbers): Returns the count of palindrome numbers in the given list of numbers. def is_palindrome(num): # Convert the number to string and check if it reads the same backwards return str(num) == str(num)[::-1] palindrome_count = sum(1 for num in numbers if is_palindrome(num)) return palindrome_count"},{"question":"def process_library_data(N, M, Q, loans, queries): Process loan records and answer queries about book and user borrowing histories. Args: N (int): The number of books. M (int): The number of loans. Q (int): The number of queries. loans (list): A list of tuples where each tuple consists of two integers (B, U) indicating that book B was loaned to user U. queries (list): A list of query strings. Each query is either \\"Book B\\" or \\"User U\\". Returns: list: A list of strings where each string is the sorted list of users or books for the corresponding query. Example: >>> process_library_data(5, 6, 4, [(1, 101), (2, 102), (1, 103), (3, 101), (4, 104), (5, 105)], [\\"Book 1\\", \\"User 101\\", \\"Book 6\\", \\"User 102\\"]) [\\"101 103\\", \\"1 3\\", \\"None\\", \\"2\\"]","solution":"def process_library_data(N, M, Q, loans, queries): book_loans = {} user_loans = {} for B, U in loans: if B not in book_loans: book_loans[B] = [] if U not in user_loans: user_loans[U] = [] book_loans[B].append(U) user_loans[U].append(B) results = [] for query in queries: type_, ID = query.split() ID = int(ID) if type_ == \\"Book\\": if ID in book_loans: results.append(\\" \\".join(map(str, sorted(book_loans[ID])))) else: results.append(\\"None\\") elif type_ == \\"User\\": if ID in user_loans: results.append(\\" \\".join(map(str, sorted(user_loans[ID])))) else: results.append(\\"None\\") return results"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Determine if one string is an anagram of the other. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"hello\\", \\"world\\") \\"NO\\" >>> are_anagrams(\\"anagram\\", \\"nagaram\\") \\"YES\\" >>> are_anagrams(\\"rat\\", \\"car\\") \\"NO\\"","solution":"def are_anagrams(s1, s2): Returns \\"YES\\" if s1 is an anagram of s2, otherwise \\"NO\\". if len(s1) != len(s2): return \\"NO\\" return \\"YES\\" if sorted(s1) == sorted(s2) else \\"NO\\""},{"question":"def divide_and_product(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Given two integers A and B, determine the integer result of the division A // B and the product A * B. If the product is greater than or equal to the division result, return \\"SUCCESS\\", otherwise return \\"FAILURE\\". Args: T : int : the number of test cases test_cases : List[Tuple[int, int]] : a list of tuples containing two integers A and B Returns: List[str] : a list containing \\"SUCCESS\\" or \\"FAILURE\\" for each test case. Examples: >>> divide_and_product(2, [(8, 4), (10, 2)]) [\\"SUCCESS\\", \\"SUCCESS\\"] >>> divide_and_product(1, [(7, 4)]) [\\"SUCCESS\\"] from typing import List, Tuple def test_case_1(): assert divide_and_product(2, [(8, 4), (10, 2)]) == [\\"SUCCESS\\", \\"SUCCESS\\"] def test_case_2(): assert divide_and_product(1, [(7, 4)]) == [\\"SUCCESS\\"] def test_case_3(): assert divide_and_product(3, [(9, 3), (14, 7), (100, 10)]) == [\\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\"] def test_case_4(): assert divide_and_product(2, [(21, 5), (32, 6)]) == [\\"SUCCESS\\", \\"SUCCESS\\"] def test_case_5(): assert divide_and_product(1, [(1, 1)]) == [\\"SUCCESS\\"] def test_case_6(): assert divide_and_product(1, [(100, 1)]) == [\\"SUCCESS\\"]","solution":"def divide_and_product(T, test_cases): results = [] for A, B in test_cases: division_result = A // B product_result = A * B if product_result >= division_result: results.append(\\"SUCCESS\\") else: results.append(\\"FAILURE\\") return results # Example usage: if __name__ == \\"__main__\\": test_cases = [ (8, 4), (10, 2) ] T = len(test_cases) results = divide_and_product(T, test_cases) for result in results: print(result)"},{"question":"def minPartitionDifference(arr, n): Returns the minimized absolute difference between the sums of two subarrays. >>> minPartitionDifference([1, 6, 11, 5], 4) 1 >>> minPartitionDifference([3, 1, 4, 2, 2], 5) 0","solution":"def minPartitionDifference(arr, n): Returns the minimized absolute difference between the sums of two subarrays. total_sum = sum(arr) half_sum = total_sum // 2 # DP array to track achievable sums dp = [False] * (half_sum + 1) dp[0] = True for num in arr: for j in range(half_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] # Find the largest value j <= half_sum that can be achieved for j in range(half_sum, -1, -1): if dp[j]: sum1 = j sum2 = total_sum - sum1 return abs(sum2 - sum1)"},{"question":"def can_form_palindrome(s): Checks if a string can be rearranged to form a palindrome. A string is considered valid if the number of characters that have odd occurrences in it is no more than one. Given a string s, determine whether it can be rearranged into a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbc\\") True","solution":"def can_form_palindrome(s): Checks if a string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome, at most one character # should have an odd number of occurrences return odd_count <= 1"},{"question":"def updateYearbookSignatures(N, A): Updates the list A with the number of unique signatures each student received. Parameters: N - number of students A - an array of size N where A[i] represents the number of signatures student i initially has Returns: Updated array A with the number of unique signatures each student received. Example: >>> updateYearbookSignatures(3, [0, 0, 0]) [2, 2, 2] >>> updateYearbookSignatures(4, [1, 1, 1, 1]) [4, 4, 4, 4]","solution":"def updateYearbookSignatures(N, A): Updates the list A with the number of unique signatures each student received. Parameters: N - number of students A - an array of size N where A[i] represents the number of signatures student i initially has Returns: Updated array A with the number of unique signatures each student received. for i in range(N): # Each student gets signatures from the other N-1 students A[i] += (N - 1) return A"},{"question":"from typing import List, Tuple def total_sales(sales_data: List[Tuple[int, int]], product_id: int) -> int: Returns the total quantity sold for the specified product ID. Args: sales_data (List[Tuple[int, int]]): The list of sales records as tuples (product ID, quantity sold). product_id (int): The product ID for which the total quantity sold needs to be calculated. Returns: int: The total quantity sold for the specified product ID. Examples: >>> total_sales([(1, 5), (2, 3), (1, 2), (3, 5), (1, 3)], 1) 10 >>> total_sales([(1, 7), (2, 3), (2, 4), (3, 6), (2, 1)], 2) 8","solution":"from typing import List, Tuple def total_sales(sales_data: List[Tuple[int, int]], product_id: int) -> int: Returns the total quantity sold for the specified product ID. Parameters: sales_data (List[Tuple[int, int]]): The list of sales records as tuples (product ID, quantity sold). product_id (int): The product ID for which the total quantity sold needs to be calculated. Returns: int: The total quantity sold for the specified product ID. total_quantity = 0 for record in sales_data: if record[0] == product_id: total_quantity += record[1] return total_quantity"},{"question":"def count_distinct_pairs(n: int) -> int: Given a positive integer n, returns the total number of distinct pairs (i, j) where 1 ≤ i < j ≤ n and (i + j) is even. >>> count_distinct_pairs(1) 0 >>> count_distinct_pairs(2) 0 >>> count_distinct_pairs(3) 1 >>> count_distinct_pairs(4) 2 >>> count_distinct_pairs(5) 4 >>> count_distinct_pairs(6) 6 pass def test_count_distinct_pairs(): assert count_distinct_pairs(1) == 0 assert count_distinct_pairs(2) == 0 assert count_distinct_pairs(3) == 1 # (1, 3) assert count_distinct_pairs(4) == 2 # (1, 3) and (2, 4) assert count_distinct_pairs(5) == 4 # (1, 3), (1, 5), (2, 4), (3, 5) assert count_distinct_pairs(6) == 6 # (1, 3), (1, 5), (2, 4), (3, 5), (4, 6), (5, 6) # Additional tests assert count_distinct_pairs(10) == 20 assert count_distinct_pairs(1000) == 249500 assert count_distinct_pairs(1000000) == 249999500000 test_count_distinct_pairs()","solution":"def count_distinct_pairs(n): Returns the total number of distinct pairs (i, j) where 1 ≤ i < j ≤ n and (i + j) is even. if n <= 1: return 0 # Calculate the number of even and odd numbers from 1 to n even_count = n // 2 odd_count = (n + 1) // 2 # The number of pairs (i, j) where (i + j) is even is the sum of pairs of even numbers and pairs of odd numbers even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 return even_pairs + odd_pairs"},{"question":"def count_available_cells(R: int, C: int, blocked_cells: List[Tuple[int, int]]) -> int: Calculates the number of available cells for placing presents. Parameters: R (int): Number of rows in the grid C (int): Number of columns in the grid blocked_cells (list of tuples): List of blocked cell coordinates (r_i, c_i) Returns: int: Number of cells available for placing presents >>> count_available_cells(5, 5, [(1, 2), (3, 3), (4, 5)]) 22 >>> count_available_cells(2, 2, [(1, 1)]) 3 >>> count_available_cells(1, 1, [(1, 1)]) 0","solution":"def count_available_cells(R, C, blocked_cells): Calculates the number of available cells for placing presents. Parameters: R (int): Number of rows in the grid C (int): Number of columns in the grid blocked_cells (list of tuples): List of blocked cell coordinates (r_i, c_i) Returns: int: Number of cells available for placing presents total_cells = R * C blocked_count = len(blocked_cells) return total_cells - blocked_count"},{"question":"import math from typing import List, Tuple def largest_square_side_length(test_cases: List[Tuple[int, int]]) -> List[int]: Determine the side length of the largest possible square piece that can be cut from the board. >>> largest_square_side_length([(6, 9)]) [3] >>> largest_square_side_length([(10, 15)]) [5] >>> largest_square_side_length([(7, 5)]) [1] >>> largest_square_side_length([(12, 18)]) [6] >>> largest_square_side_length([(21, 14)]) [7] >>> largest_square_side_length([(1000000000, 500000000)]) [500000000] # Unit Tests def test_largest_square_side_length(): assert largest_square_side_length([(6, 9)]) == [3] assert largest_square_side_length([(10, 15)]) == [5] assert largest_square_side_length([(7, 5)]) == [1] assert largest_square_side_length([(12, 18)]) == [6] assert largest_square_side_length([(21, 14)]) == [7] assert largest_square_side_length([(1000000000, 500000000)]) == [500000000] def test_multiple_cases(): test_cases = [ (6, 9), (10, 15), (7, 5), (12, 18), (21, 14), (1000000000, 500000000) ] expected_results = [3, 5, 1, 6, 7, 500000000] assert largest_square_side_length(test_cases) == expected_results","solution":"import math def largest_square_side_length(test_cases): results = [] for L, W in test_cases: side_length = math.gcd(L, W) results.append(side_length) return results # To use this function, call it with a list of tuples [(L1, W1), (L2, W2), ...] # Example usage: # test_cases = [(6, 9), (10, 15), (7, 5)] # print(largest_square_side_length(test_cases)) # Output: [3, 5, 1]"},{"question":"def min_energy_path(M, N, grid): Calculates the minimum total energy required to reach the bottom-right corner of the grid. Parameters: M (int): Number of rows of the grid. N (int): Number of columns of the grid. grid (list of list of int): The grid representing energy costs. Returns: int: The minimum total energy required. >>> min_energy_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_energy_path(1, 3, [[1, 2, 3]]) == 6 >>> min_energy_path(3, 1, [[1], [2], [3]]) == 6 >>> min_energy_path(1, 1, [[0]]) == 0 >>> min_energy_path(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 >>> min_energy_path(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0","solution":"def min_energy_path(M, N, grid): Calculates the minimum total energy required to reach the bottom-right corner of the grid. Parameters: M (int): Number of rows of the grid. N (int): Number of columns of the grid. grid (list of list of int): The grid representing energy costs. Returns: int: The minimum total energy required. dp = [[0]*N for _ in range(M)] dp[0][0] = grid[0][0] # Initialize top row for j in range(1, N): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize left column for i in range(1, M): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[M - 1][N - 1] # Example usage: # M = 3 # N = 3 # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(min_energy_path(M, N, grid)) # Output: 7"},{"question":"from typing import List, Tuple def min_operations_to_non_decreasing(arr: List[int]) -> int: Returns the minimum number of operations required to make the array non-decreasing. An operation consists of increasing a single element by 1. >>> min_operations_to_non_decreasing([1, 2, 3, 2, 5]) 1 >>> min_operations_to_non_decreasing([3, 2, 1]) 3 def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results for each in a list. test_cases : list of tuples, where each tuple is (n, array) Returns a list of integers representing the minimum number of operations required for each test case. >>> solve([(5, [1, 2, 3, 2, 5]), (3, [3, 2, 1])]) [1, 3]","solution":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing. An operation consists of increasing a single element by 1. operations = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: operations += arr[i - 1] - arr[i] arr[i] = arr[i - 1] return operations def solve(test_cases): Processes multiple test cases and returns the results for each in a list. test_cases : list of tuples, where each tuple is (n, array) Returns a list of integers representing the minimum number of operations required for each test case. results = [] for n, array in test_cases: results.append(min_operations_to_non_decreasing(array)) return results"},{"question":"def count_bubble_sort_swaps(distances): Returns the number of swaps made by bubble sort to sort the distances array. >>> count_bubble_sort_swaps([3, 2, 1]) 3 >>> count_bubble_sort_swaps([4, 3, 2, 1]) 6 pass def solve_test_cases(T, test_cases): Solve multiple test cases of the bubble sort swap count problem. >>> T = 2 >>> test_cases = [(3, [3, 2, 1]), (4, [4, 3, 2, 1])] >>> solve_test_cases(T, test_cases) [3, 6] >>> T = 3 >>> test_cases = [(3, [5, 1, 7]), (2, [2, 1]), (5, [5, 4, 3, 2, 1])] >>> solve_test_cases(T, test_cases) [1, 1, 10] pass","solution":"def count_bubble_sort_swaps(distances): Returns the number of swaps made by bubble sort to sort the distances array. n = len(distances) swaps = 0 for i in range(n): for j in range(0, n-i-1): if distances[j] > distances[j+1]: distances[j], distances[j+1] = distances[j+1], distances[j] swaps += 1 return swaps def solve_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] distances = test_cases[i][1] results.append(count_bubble_sort_swaps(distances)) return results"},{"question":"def hasPairWithSum(arr: List[int], target: int) -> bool: Returns True if there are two distinct elements in the array that add up to the target integer, False otherwise. >>> hasPairWithSum([1, 2, 3, 9], 8) False >>> hasPairWithSum([1, 2, 4, 4], 8) True >>> hasPairWithSum([0, -1, 2, -3, 1], -2) True >>> hasPairWithSum([3, 2, 4], 6) True >>> hasPairWithSum([1, 2, 3, 4, 5], 10) False >>> hasPairWithSum([1], 1) False >>> hasPairWithSum([], 5) False >>> hasPairWithSum([0, 0, 0], 0) True >>> hasPairWithSum([100, 200, 300, 700], 1000) True >>> hasPairWithSum([-100, -200, -300, -700], -1000) True >>> hasPairWithSum([5, 5, 5, 5], 10) True","solution":"def hasPairWithSum(arr, target): Returns True if there are two distinct elements in the array that add up to the target integer, False otherwise. # Create a set to store the complements of the elements we have seen. seen_complements = set() # Iterate through the array. for number in arr: # Check if the current number's complement has been seen before. if (target - number) in seen_complements: return True # Add the current number to the set of seen complements. seen_complements.add(number) # If no pair is found, return False. return False"},{"question":"from typing import List def maxCoins(grid: List[List[int]], n: int, m: int) -> int: Calculate the maximum number of coins David can collect starting from any cell in the first row down to the last row. >>> maxCoins([[1, 2, 3], [6, 5, 4], [7, 8, 9]], 3, 3) 17 >>> maxCoins([[1, 10, 6], [7, 8, 2], [3, 4, 9]], 3, 3) 27 # Unit tests def test_maxCoins_example1(): grid = [[1, 2, 3], [6, 5, 4], [7, 8, 9]] assert maxCoins(grid, 3, 3) == 17 def test_maxCoins_example2(): grid = [[1, 10, 6], [7, 8, 2], [3, 4, 9]] assert maxCoins(grid, 3, 3) == 27 def test_maxCoins_all_same_values(): grid = [[1, 1, 1], [1, 1, 1], [1, 1, 1]] assert maxCoins(grid, 3, 3) == 3 def test_maxCoins_small_grid(): grid = [[1]] assert maxCoins(grid, 1, 1) == 1 def test_maxCoins_large_values(): grid = [[999, 999, 999], [999, 999, 999], [999, 999, 999]] assert maxCoins(grid, 3, 3) == 2997 def test_maxCoins_single_row(): grid = [[3, 1, 4, 1, 5]] assert maxCoins(grid, 1, 5) == 5","solution":"def maxCoins(grid, n, m): Function to calculate the maximum number of coins David can collect from the first row to the last row. Args: grid : list[list[int]] : The grid of coins. n : int : Number of rows. m : int : Number of columns. Returns: int : Maximum number of coins that can be collected. # Dynamic programming table to store the maximum coins up to each cell. dp = [[0] * m for _ in range(n)] # Initialize the first row of the dp table with the values from the grid's first row. for j in range(m): dp[0][j] = grid[0][j] # Fill the dp table with the maximum coins collected up to each cell. for i in range(1, n): for j in range(m): # Coins collected if coming from the cell directly above. dp[i][j] = dp[i-1][j] if j > 0: # Coins collected if coming from the cell diagonally left above. dp[i][j] = max(dp[i][j], dp[i-1][j-1]) if j < m - 1: # Coins collected if coming from the cell diagonally right above. dp[i][j] = max(dp[i][j], dp[i-1][j+1]) # Add the coins of the current cell. dp[i][j] += grid[i][j] # The maximum coins collected will be the maximum value in the last row of dp table. return max(dp[n-1])"},{"question":"def reverse_words(s: str) -> str: This function takes a string as input and returns the string with words in reverse order. Leading and trailing spaces are removed and there is exactly one space between words in the output. >>> reverse_words(\\"Hello World\\") 'World Hello' >>> reverse_words(\\" Coding is fun \\") 'fun is Coding' >>> reverse_words(\\"SingleWord\\") 'SingleWord' >>> reverse_words(\\"\\") ''","solution":"def reverse_words(s: str) -> str: This function takes a string \`s\` and returns the string with words in reverse order. Leading and trailing spaces are removed and there is exactly one space between words in the output. # Split the string by spaces to get words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return \\" \\".join(reversed_words)"},{"question":"def most_frequent_letter(phrases: List[str]) -> List[str]: Takes a list of phrases and returns the most frequent letter from each phrase. If there are multiple letters with the same highest frequency, the lexicographically smallest letter among them is returned. >>> most_frequent_letter([\\"abacab\\", \\"zzyyxx\\"]) ['a', 'x'] >>> most_frequent_letter([\\"a\\"]) ['a'] >>> most_frequent_letter([\\"zzzxyyy\\"]) ['y']","solution":"def most_frequent_letter(phrases): Takes a list of phrases and returns the most frequent letter from each phrase. If there are multiple letters with the same highest frequency, the lexicographically smallest letter among them is returned. results = [] for phrase in phrases: # Create a dictionary to count the frequency of each letter frequency = {} for letter in phrase: if letter in frequency: frequency[letter] += 1 else: frequency[letter] = 1 # Find the maximum frequency max_frequency = max(frequency.values()) # Identify all letters with the maximum frequency max_letters = [letter for letter in frequency if frequency[letter] == max_frequency] # Find the lexicographically smallest letter among those with the maximum frequency most_frequent = min(max_letters) results.append(most_frequent) return results"},{"question":"def max_in_subgrid(grid, queries): Returns the maximum value within the specified subgrid for each query. Args: grid: List[List[int]] - 2D List representing the grid. queries: List[Tuple[int, int, int, int]] - List of tuples representing the queries. Returns: List[int] - List of maximum values for each query. pass def solve(n, m, grid, q, queries): return max_in_subgrid(grid, queries) # Test cases def test_max_in_subgrid_single_query(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2)] assert solve(3, 3, grid, 1, queries) == [5] def test_max_in_subgrid_multiple_queries(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (2, 2, 3, 3)] assert solve(3, 3, grid, 2, queries) == [5, 9] def test_max_in_subgrid_entire_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 3, 3)] assert solve(3, 3, grid, 1, queries) == [9] def test_max_in_subgrid_overlapping_queries(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 3, 3), (1, 2, 2, 3)] assert solve(3, 3, grid, 2, queries) == [9, 6]","solution":"def max_in_subgrid(grid, queries): Returns the maximum value within the specified subgrid for each query. Args: grid: List[List[int]] - 2D List representing the grid. queries: List[Tuple[int, int, int, int]] - List of tuples representing the queries. Returns: List[int] - List of maximum values for each query. results = [] for r1, c1, r2, c2 in queries: max_val = grid[r1-1][c1-1] for i in range(r1-1, r2): for j in range(c1-1, c2): if grid[i][j] > max_val: max_val = grid[i][j] results.append(max_val) return results def solve(n, m, grid, q, queries): return max_in_subgrid(grid, queries)"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence of str1 and str2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"abcdef\\") 6 >>> longest_common_subsequence(\\"abcde\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"abcde\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"abcf\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"xfyz\\", \\"xyz\\") 3","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence of str1 and str2. m, n = len(str1), len(str2) # Create a 2D table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def max_teams_count(ranks): Returns the maximum number of teams that can be formed based on the given ranks. >>> max_teams_count([1, 2, 3, 4, 5, 6, 7]) 1 >>> max_teams_count([1, 2, 3, 4, 6, 7, 8, 9, 10, 12]) 3","solution":"def max_teams_count(ranks): Returns the maximum number of teams that can be formed based on the given ranks. ranks = sorted(set(ranks)) # Sort and remove duplicates n = len(ranks) if n == 0: return 0 teams = 0 i = 0 while i < n: teams += 1 while i < n - 1 and ranks[i] + 1 == ranks[i + 1]: i += 1 i += 1 return teams"},{"question":"def maxProfit(n, nums): Given an integer array nums representing the stock prices on different days, find the maximum profit you can achieve by buying and selling one share only. You cannot engage in multiple transactions (i.e., buy one share and then later sell it once). Parameters: n (int): Number of elements in the array nums (List[int]): Array of stock prices Returns: int: Maximum profit that can be achieved Examples: >>> maxProfit(6, [7, 1, 5, 3, 6, 4]) 5 >>> maxProfit(5, [7, 6, 4, 3, 1]) 0","solution":"def maxProfit(n, nums): Returns the maximum profit that can be achieved from a single buy and sell transaction. Parameters: n : int : Number of elements in the array nums : list : Array of stock prices Returns: int : Maximum profit that can be achieved if n <= 1: return 0 min_price = float('inf') max_profit = 0 for price in nums: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List, Tuple def max_non_overlapping_meetings(meetings: List[Tuple[int, int]]) -> int: Given a list of meetings with their start and end times, returns the maximum number of non-overlapping meetings. meetings: List of tuples, where each tuple contains two integers (start, end) representing the start and end times of a meeting. Returns: Maximum number of non-overlapping meetings. >>> max_non_overlapping_meetings([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_meetings([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_meetings([(1, 4), (2, 5), (3, 6)]) 1 >>> max_non_overlapping_meetings([(1, 2), (2, 3), (3, 4), (1, 5), (4, 5)]) 4 >>> max_non_overlapping_meetings([(1, 100)]) 1","solution":"def max_non_overlapping_meetings(meetings): Given a list of meetings with their start and end times, returns the maximum number of non-overlapping meetings. meetings: List of tuples, where each tuple contains two integers (start, end) representing the start and end times of a meeting. Returns: Maximum number of non-overlapping meetings. # Sort meetings based on their end times meetings.sort(key=lambda x: x[1]) # Initialize counters count = 0 end_time = 0 # Iterate over meetings for start, end in meetings: # If meeting does not overlap with the last attended one if start >= end_time: # Attend this meeting count += 1 end_time = end return count"},{"question":"def calculate_notifications(M, A): Calculate the number of participants who should receive the push notification. Parameters: M (int): The total number of participants. A (int): The number of participants who have updated their favorite snack in the last month. Returns: int: The number of participants to send notifications to. pass # Unit Tests def test_calculate_notifications_sample1(): assert calculate_notifications(200, 50) == 150 def test_calculate_notifications_sample2(): assert calculate_notifications(1250, 750) == 500 def test_calculate_notifications_all_updated(): assert calculate_notifications(1000, 1000) == 0 def test_calculate_notifications_none_updated(): assert calculate_notifications(500, 0) == 500 def test_calculate_notifications_edge_case(): assert calculate_notifications(1, 1) == 0","solution":"def calculate_notifications(M, A): Calculate the number of participants who should receive the push notification. Parameters: M (int): The total number of participants. A (int): The number of participants who have updated their favorite snack in the last month. Returns: int: The number of participants to send notifications to. return M - A"},{"question":"def find_amiable_numbers(low: int, high: int) -> (int, int): Verify if an amiable number exists within a given range. An amiable number is part of a pair of numbers where each number is the sum of the proper divisors of the other. Proper divisors of a number are those divisors excluding the number itself. >>> find_amiable_numbers(200, 300) == (220, 284) >>> find_amiable_numbers(1, 100) == (-1, -1) >>> find_amiable_numbers(1000, 1300) == (1184, 1210) >>> find_amiable_numbers(10, 50) == (-1, -1) pass Unit Test: from solution import find_amiable_numbers def test_amiable_in_range_200_300(): assert find_amiable_numbers(200, 300) == (220, 284) def test_no_amiable_in_range_1_100(): assert find_amiable_numbers(1, 100) == (-1, -1) def test_amiable_in_range_1000_1300(): assert find_amiable_numbers(1000, 1300) == (1184, 1210) def test_no_amiable_in_range_10_50(): assert find_amiable_numbers(10, 50) == (-1, -1) def test_amiable_entire_range_inclusion(): assert find_amiable_numbers(1184, 1210) == (1184, 1210) def test_large_range(): assert find_amiable_numbers(200, 1300) == (220, 284)","solution":"def find_amiable_numbers(low: int, high: int) -> (int, int): def sum_of_proper_divisors(num: int) -> int: divisors_sum = 1 # 1 is a proper divisor for any number > 1 for i in range(2, int(num**0.5) + 1): if num % i == 0: divisors_sum += i if i != num // i: divisors_sum += num // i return divisors_sum for a in range(low, high + 1): b = sum_of_proper_divisors(a) if a != b and low <= b <= high: if sum_of_proper_divisors(b) == a: return (a, b) return (-1, -1)"},{"question":"from typing import List, Tuple def max_landmarks_visited(n: int, m: int, k: int, routes: List[Tuple[int, int]]) -> int: Calculate the maximum number of distinct landmarks that can be visited starting and ending in the capital city, within a given number of days. Args: n (int): Number of cities. m (int): Number of two-way flight routes. k (int): Number of days available. routes (List[Tuple[int, int]]): List of tuples representing the flight routes between cities. Returns: int: The maximum number of distinct landmarks that can be visited. Examples: >>> max_landmarks_visited(4, 4, 3, [(1, 2), (1, 3), (2, 4), (3, 4)]) 3 >>> max_landmarks_visited(5, 6, 4, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)]) 4 pass","solution":"def bfs_max_landmarks(n, adj, k, start=1): from collections import deque queue = deque([(start, 0, 0)]) # (current_city, days_spent, bitmask_visited) visited = {(start, 0): 0} max_landmarks = 0 while queue: city, days, bm = queue.popleft() landmarks_visited = bin(bm).count('1') max_landmarks = max(max_landmarks, landmarks_visited) if days < k: # Stay at the current city if (city, days + 1) not in visited or visited[(city, days + 1)] < bm | (1 << (city - 1)): visited[(city, days + 1)] = bm | (1 << (city - 1)) queue.append((city, days + 1, bm | (1 << (city - 1)))) for neighbor in adj[city]: if (neighbor, days + 1) not in visited or visited[(neighbor, days + 1)] < bm | (1 << (neighbor - 1)): visited[(neighbor, days + 1)] = bm | (1 << (neighbor - 1)) queue.append((neighbor, days + 1, bm | (1 << (neighbor - 1)))) return max_landmarks def max_landmarks_visited(n, m, k, routes): from collections import defaultdict adj = defaultdict(list) for u, v in routes: adj[u].append(v) adj[v].append(u) return bfs_max_landmarks(n, adj, k) # Example usage: n = 5 m = 6 k = 4 routes = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5)] print(max_landmarks_visited(n, m, k, routes))"},{"question":"def participant_rank(n: int, m: int, scores: List[List[int]], p: int) -> int: Determines the rank of a specific participant based on their total score. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Scores of each participant for each problem. p (int): ID of the participant whose rank is to be determined. Returns: int: The rank of the participant with ID p. >>> participant_rank(5, 3, [ ... [10, 20, 30], ... [40, 50, 60], ... [70, 80, 90], ... [10, 50, 20], ... [15, 25, 35] ... ], 3) 1 >>> participant_rank(4, 2, [ ... [10, 30], ... [20, 40], ... [30, 50], ... [15, 35] ... ], 2) 2 >>> participant_rank(3, 3, [ ... [10, 10, 10], ... [20, 20, 20], ... [30, 30, 30] ... ], 1) 3","solution":"def participant_rank(n, m, scores, p): Determines the rank of a specific participant based on their total score. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Scores of each participant for each problem. p (int): ID of the participant whose rank is to be determined. Returns: int: The rank of the participant with ID p. # Calculate the total score for each participant total_scores = [(i+1, sum(scores[i])) for i in range(n)] # Sort the participants first by total score in descending order # and then by ID in ascending order total_scores.sort(key=lambda x: (-x[1], x[0])) # Find the rank of participant with ID p for rank, (participant_id, _) in enumerate(total_scores, 1): if participant_id == p: return rank"},{"question":"def generate_arrays(n: int, t: int) -> list: Generates all unique arrays of n non-negative integers that add up to t, and return them in lexicographical order. Examples: >>> generate_arrays(2, 3) == [\\"03\\", \\"12\\", \\"21\\", \\"30\\"] >>> generate_arrays(3, 4) == [\\"004\\", \\"013\\", \\"022\\", \\"031\\", \\"040\\", \\"103\\", \\"112\\", \\"121\\", \\"130\\", \\"202\\", \\"211\\", \\"220\\", \\"301\\", \\"310\\", \\"400\\"] from itertools import combinations_with_replacement, permutations def test_generate_arrays_basic(): assert generate_arrays(2, 3) == [\\"03\\", \\"12\\", \\"21\\", \\"30\\"] def test_generate_arrays_intermediate(): assert generate_arrays(3, 4) == [\\"004\\", \\"013\\", \\"022\\", \\"031\\", \\"040\\", \\"103\\", \\"112\\", \\"121\\", \\"130\\", \\"202\\", \\"211\\", \\"220\\", \\"301\\", \\"310\\", \\"400\\"] def test_generate_arrays_advanced(): result = generate_arrays(4, 5) expected_result = [ \\"0005\\", \\"0014\\", \\"0023\\", \\"0032\\", \\"0041\\", \\"0050\\", \\"0104\\", \\"0113\\", \\"0122\\", \\"0131\\", \\"0140\\", \\"0203\\", \\"0212\\", \\"0221\\", \\"0230\\", \\"0302\\", \\"0311\\", \\"0320\\", \\"0401\\", \\"0410\\", \\"0500\\", \\"1004\\", \\"1013\\", \\"1022\\", \\"1031\\", \\"1040\\", \\"1103\\", \\"1112\\", \\"1121\\", \\"1130\\", \\"1202\\", \\"1211\\", \\"1220\\", \\"1301\\", \\"1310\\", \\"1400\\", \\"2003\\", \\"2012\\", \\"2021\\", \\"2030\\", \\"2102\\", \\"2111\\", \\"2120\\", \\"2201\\", \\"2210\\", \\"2300\\", \\"3002\\", \\"3011\\", \\"3020\\", \\"3101\\", \\"3110\\", \\"3200\\", \\"4001\\", \\"4010\\", \\"4100\\", \\"5000\\" ] assert result == expected_result def test_generate_arrays_edge_cases(): assert generate_arrays(1, 0) == [\\"0\\"] assert generate_arrays(1, 1) == [\\"1\\"] assert generate_arrays(2, 0) == [\\"00\\"] assert generate_arrays(2, 1) == [\\"01\\", \\"10\\"]","solution":"from itertools import combinations_with_replacement, permutations def generate_arrays(n, t): Generates all unique arrays of n non-negative integers that add up to t, and return them in lexicographical order. def convert_tuple_to_str(tup): return ''.join(map(str, tup)) # Generate all combinations with replacement (guarantees lexicographical order) comb_with_repl = combinations_with_replacement(range(t+1), n) # Filter out combinations whose sum is not equal to t valid_combinations = [c for c in comb_with_repl if sum(c) == t] # Generate unique permutations for each valid combination all_permutations = set() for comb in valid_combinations: perms = permutations(comb) for perm in perms: all_permutations.add(perm) # Convert tuples to strings and sort them lexicographically result = sorted(map(convert_tuple_to_str, all_permutations)) return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression containing non-negative integers and operators +, -, *. The input expression is assumed to be valid. >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+2*6-5\\") == 17 >>> evaluate_expression(\\"100\\") == 100","solution":"def evaluate_expression(expression): Evaluates a given mathematical expression containing non-negative integers and operators +, -, *. The input expression is assumed to be valid. def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) def precedence(op): if op == '+' or op == '-': return 1 if op == '*': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue elif expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while (i < len(expression) and expression[i].isdigit()): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(operators) > 0 and operators[-1] != '(': apply_operator(operators, values) operators.pop() else: while (len(operators) > 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"def min_moves_to_reorder(n: int, initial: List[int], target: List[int]) -> int: Returns the minimum number of moves required to transform the initial arrangement to the target arrangement. If it is impossible, returns -1. >>> min_moves_to_reorder(5, [1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) 2 >>> min_moves_to_reorder(4, [4, 1, 2, 3], [1, 2, 3, 4]) 1 >>> min_moves_to_reorder(3, [1, 2, 3], [3, 2, 1]) -1 >>> min_moves_to_reorder(3, [1, 2, 3], [1, 2, 3]) 0 >>> min_moves_to_reorder(4, [1, 2, 3, 4], [4, 1, 2, 3]) 1 >>> min_moves_to_reorder(5, [1, 2, 3, 4, 5], [5, 1, 2, 3, 4]) 1 >>> min_moves_to_reorder(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]) 5 >>> min_moves_to_reorder(4, [1, 2, 4, 3], [1, 4, 3, 2]) -1","solution":"def min_moves_to_reorder(n, initial, target): Returns the minimum number of moves required to transform the initial arrangement to the target arrangement. If it is impossible, returns -1. # Check if the target is a rotation of the initial if sorted(initial) != sorted(target): return -1 # Try to find the rotation point for i in range(n): if initial[i:] + initial[:i] == target: return i if initial[-i:] + initial[:-i] == target: return i return -1"},{"question":"class DynamicSetManager: Class to manage a dynamic set of integers and support operations to add, remove, and find the maximum integer within a specified range. def __init__(self): self.data = set() def add(self, x): Adds an integer x to the set. self.data.add(x) def remove(self, x): Removes an integer x from the set. self.data.remove(x) def find_max_in_range(self, l, r): Finds the maximum integer in the set that lies within the inclusive range [l, r]. :param l: The lower bound of the range. :param r: The upper bound of the range. :return: The maximum integer within range [l, r] or None if no such integer exists. >>> manager = DynamicSetManager() >>> manager.add(1) >>> manager.add(10) >>> manager.find_max_in_range(1, 10) 10 pass def dynamic_set_operations(queries): Processes a list of queries to manage a dynamic set of integers. :param queries: A list of query strings. :return: A list of results from queries of the type 3 (find max in range). >>> queries = [\\"1 5\\", \\"1 10\\", \\"1 15\\", \\"3 1 10\\", \\"2 5\\", \\"3 1 10\\"] >>> dynamic_set_operations(queries) [10, 10] pass from solution import dynamic_set_operations, DynamicSetManager def test_dynamic_set_operations(): queries = [ \\"1 5\\", \\"1 10\\", \\"1 15\\", \\"3 1 10\\", \\"2 5\\", \\"3 1 10\\" ] expected_output = [10, 10] assert dynamic_set_operations(queries) == expected_output def test_add_and_remove_operations(): manager = DynamicSetManager() # Add elements manager.add(1) manager.add(2) manager.add(3) # Remove element manager.remove(2) assert manager.data == {1, 3} def test_find_max_in_range(): manager = DynamicSetManager() manager.add(1) manager.add(2) manager.add(3) manager.add(10) manager.add(20) assert manager.find_max_in_range(1, 10) == 10 assert manager.find_max_in_range(5, 15) == 10 assert manager.find_max_in_range(10, 20) == 20 assert manager.find_max_in_range(21, 30) == None","solution":"class DynamicSetManager: def __init__(self): self.data = set() def add(self, x): self.data.add(x) def remove(self, x): self.data.remove(x) def find_max_in_range(self, l, r): # Filter values in range and find max values_in_range = [val for val in self.data if l <= val <= r] return max(values_in_range) if values_in_range else None def dynamic_set_operations(queries): manager = DynamicSetManager() results = [] for query in queries: parts = query.split() operation = int(parts[0]) if operation == 1: x = int(parts[1]) manager.add(x) elif operation == 2: x = int(parts[1]) manager.remove(x) elif operation == 3: l = int(parts[1]) r = int(parts[2]) result = manager.find_max_in_range(l, r) if result is not None: results.append(result) return results"},{"question":"def evaluate_expression(expression: str, variables: dict) -> int: Evaluate the integer value of the given expression using the provided variables. Parameters: expression (str): The expression to evaluate. variables (dict): A dictionary mapping variable names to their integer values. Returns: int: The integer result of evaluating the expression. Examples: >>> evaluate_expression(\\"a + b\\", {\\"a\\": 2, \\"b\\": 3}) 5 >>> evaluate_expression(\\"(a + b) - (c - d)\\", {\\"a\\": 2, \\"b\\": 3, \\"c\\": 7, \\"d\\": 4}) 2 >>> evaluate_expression(\\"(a - (b - c)) + d\\", {\\"a\\": 5, \\"b\\": 3, \\"c\\": 1, \\"d\\": 7}) 10 >>> evaluate_expression(\\"(x1 + (x2 - x3))\\", {\\"x1\\": 4, \\"x2\\": 6, \\"x3\\": 2}) 8 >>> evaluate_expression(\\"((q + w) - (e + r))\\", {\\"q\\": 5, \\"w\\": 2, \\"e\\": 3, \\"r\\": 1}) 3 pass","solution":"def evaluate_expression(expression, variables): Evaluate the integer value of the given expression using the provided variables. Parameters: expression (str): The expression to evaluate. variables (dict): A dictionary mapping variable names to their integer values. Returns: int: The integer result of evaluating the expression. def eval_replace(expr): # Replace variables with their values from the dictionary for var, value in variables.items(): expr = expr.replace(var, str(value)) return expr def eval_expression(expr): # Evaluate the expression string safely replaced_expr = eval_replace(expr) return eval(replaced_expr) # Call the evaluation function return eval_expression(expression)"},{"question":"def maxProfit(prices: List[int]) -> int: Given an array of integers that represents stock prices on different days, return the maximum profit you can achieve by making at most two transactions. A transaction is defined as buying and then selling one share of the stock on different days. >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0 >>> maxProfit([1]) 0 # Unit tests def test_no_prices(): assert maxProfit([]) == 0 def test_single_price(): assert maxProfit([1]) == 0 def test_all_increasing_prices(): assert maxProfit([1,2,3,4,5]) == 4 def test_all_decreasing_prices(): assert maxProfit([7,6,4,3,1]) == 0 def test_example_case_1(): assert maxProfit([3,3,5,0,0,3,1,4]) == 6 def test_example_case_2(): assert maxProfit([1,2,3,4,5]) == 4 def test_example_case_3(): assert maxProfit([7,6,4,3,1]) == 0 def test_example_case_4(): assert maxProfit([1]) == 0 def test_specific_case(): assert maxProfit([3,2,6,5,0,3]) == 7","solution":"def maxProfit(prices): n = len(prices) if n == 0: return 0 # Initialize arrays to store the maximum profit profit1 = [0] * n profit2 = [0] * n # Forward pass to calculate maximum profit for the first transaction min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i-1], prices[i] - min_price) # Backward pass to calculate maximum profit for the second transaction max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i+1], max_price - prices[i]) # Calculate the maximum profit by combining the two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"def max_candies_distributed(candies: List[int], total: int) -> int: Determine the maximum number of candies that can be fairly distributed to guests. Parameters: candies (List[int]): The number of candies each guest wants. total (int): The total number of candies available. Returns: int: The maximum number of candies that can be fairly distributed. Examples: >>> max_candies_distributed([2, 3, 7, 5], 10) 10 >>> max_candies_distributed([1, 1, 1, 1], 5) 4","solution":"def max_candies_distributed(candies, total): This function determines the maximum number of candies that can be fairly distributed to guests given a list of candies each guest wants and the total number of candies available. # Sort the candies list to start distributing from those who want the least candies.sort() distributed = 0 for candy in candies: if total >= candy: distributed += candy total -= candy else: distributed += total break return distributed"},{"question":"from typing import List, Tuple def gcd_of_list(nums: List[int]) -> int: Calculate the greatest common divisor (GCD) of a list of numbers. pass def can_be_beautiful_array(n: int, arr: List[int]) -> str: Determine if an array can be transformed into a beautiful array by removing at most one element. >>> can_be_beautiful_array(3, [4, 6, 8]) \\"YES\\" >>> can_be_beautiful_array(4, [7, 5, 9, 11]) \\"NO\\" >>> can_be_beautiful_array(5, [15, 10, 5, 10, 5]) \\"YES\\" pass def process_input(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases and return the results for each case. >>> process_input(3, [(3, [4, 6, 8]), (4, [7, 5, 9, 11]), (5, [15, 10, 5, 10, 5])]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"import math from functools import reduce def gcd_of_list(nums): return reduce(math.gcd, nums) def can_be_beautiful_array(n, arr): overall_gcd = gcd_of_list(arr) if overall_gcd > 1: return \\"YES\\" for i in range(n): temp_arr = arr[:i] + arr[i+1:] if gcd_of_list(temp_arr) > 1: return \\"YES\\" return \\"NO\\" def process_input(t, cases): results = [] for case in cases: n, arr = case results.append(can_be_beautiful_array(n, arr)) return results"},{"question":"class TreeNode: def __init__(self, value: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.value = value self.left = left self.right = right from typing import List, Optional def level_sum(root: Optional[TreeNode]) -> List[int]: Computes the sum of the nodes at each level of the tree. Args: root (TreeNode): The root of the binary tree. Returns: List[int]: A list of sums where the element at index \`i\` is the sum of the nodes at level \`i\`. Example: >>> root = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3, left=TreeNode(6), right=TreeNode(7))) >>> level_sum(root) [1, 5, 22] def test_level_sum_empty_tree(): assert level_sum(None) == [] def test_level_sum_single_node(): root = TreeNode(1) assert level_sum(root) == [1] def test_level_sum_two_levels(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert level_sum(root) == [1, 5] def test_level_sum_multiple_levels(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) assert level_sum(root) == [1, 5, 22] def test_level_sum_with_negative_values(): root = TreeNode(-1, TreeNode(-2), TreeNode(-3)) assert level_sum(root) == [-1, -5] def test_level_sum_mixed_values(): root = TreeNode(10, TreeNode(-2, TreeNode(8), TreeNode(-4)), TreeNode(7, TreeNode(-6), TreeNode(5))) assert level_sum(root) == [10, 5, 3]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, value: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.value = value self.left = left self.right = right def level_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.value if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"def count_distinct_chars_on_longest_page(notebook: str) -> int: Returns the count of distinct characters on the longest page in the notebook. >>> count_distinct_chars_on_longest_page(\\"abc#dnefghinjklmn#opn\\") 7 >>> count_distinct_chars_on_longest_page(\\"a#b#c#d#e#f\\") 6 >>> count_distinct_chars_on_longest_page(\\"abc#d#nef#nghi#jn\\") 4 >>> count_distinct_chars_on_longest_page(\\"\\") 0 >>> count_distinct_chars_on_longest_page(\\"#n#n#\\") 0","solution":"def count_distinct_chars_on_longest_page(notebook): Returns the count of distinct characters on the longest page in the notebook. # Split the notebook by pages pages = notebook.split('n') # Initialize variables to track the longest page and its distinct character count max_length = 0 distinct_count = 0 # Process each page for page in pages: # Remove the noise characters clean_page = page.replace('#', '') # Check if the current page is the longest if len(clean_page) > max_length: max_length = len(clean_page) distinct_count = len(set(clean_page)) return distinct_count"},{"question":"def mystical_fibonacci(t: int) -> int: Determine the value at position t in the Mystical Fibonacci Sequence. >>> mystical_fibonacci(1) 1 >>> mystical_fibonacci(5) 35 >>> mystical_fibonacci(100000) != 0 # Check large number performance and correctness MOD = 10**9 + 7 if t == 1 or t == 2: return 1 a, b = 1, 1 for n in range(3, t + 1): c = (a + b + n * n) % MOD a, b = b, c return b","solution":"MOD = 10**9 + 7 def mystical_fibonacci(t): if t == 1 or t == 2: return 1 a, b = 1, 1 for n in range(3, t + 1): c = (a + b + n * n) % MOD a, b = b, c return b"},{"question":"def longest_balanced_subarray(arr): Returns the length of the longest subarray with an equal number of even and odd numbers. :param arr: List[int] - The array of integers. :return: int - The length of the longest balanced subarray. ... def process_test_cases(T, test_cases): Processes multiple test cases of finding the longest balanced subarray. :param T: int - The number of test cases. :param test_cases: List[Tuple[int, List[int]]] - List containing test cases with array lengths and the arrays themselves. :return: List[int] - The results for each test case. ... # Example Usage: # T = 2 # test_cases = [ # (6, [1, 2, 3, 4, 5, 6]), # (4, [1, 4, 2, 3]), # ] # print(process_test_cases(T, test_cases)) if __name__ == \\"__main__\\": # Sample Input Reading T = int(input()) test_cases = [] for _ in range(T): N = int(input()) array = list(map(int, input().split())) test_cases.append((N, array)) results = process_test_cases(T, test_cases) for result in results: print(result)","solution":"def longest_balanced_subarray(arr): Returns the length of the longest subarray with an equal number of even and odd numbers. count = 0 max_length = 0 index_map = {0: -1} # balance : index for i, num in enumerate(arr): if num % 2 == 0: count += 1 else: count -= 1 if count in index_map: max_length = max(max_length, i - index_map[count]) else: index_map[count] = i return max_length def process_test_cases(T, test_cases): results = [] for n, arr in test_cases: results.append(longest_balanced_subarray(arr)) return results # Example Usage: # T = 2 # test_cases = [ # (6, [1, 2, 3, 4, 5, 6]), # (4, [1, 4, 2, 3]), # ] # print(process_test_cases(T, test_cases))"},{"question":"class TreeNode: def __init__(self, value=0, color='red', left=None, right=None): self.value = value self.color = color self.left = left self.right = right def lcaColor(root: TreeNode, p: int, q: int) -> str: Determine the color of the lowest common ancestor (LCA) of two given nodes in a binary tree. :param root: The root node of the binary tree :param p: The value of the first node :param q: The value of the second node :return: The color of the LCA of the two nodes ('red' or 'blue') >>> root = TreeNode(1, 'red') >>> root.left = TreeNode(2, 'blue') >>> root.right = TreeNode(3, 'red') >>> root.left.left = TreeNode(4, 'blue') >>> root.left.right = TreeNode(5, 'red') >>> root.right.left = TreeNode(6, 'blue') >>> root.right.right = TreeNode(7, 'blue') >>> lcaColor(root, 4, 5) 'blue' >>> lcaColor(root, 5, 6) 'red' >>> lcaColor(root, 4, 6) 'red' >>> lcaColor(root, 3, 4) 'red' >>> lcaColor(root, 6, 7) 'red'","solution":"class TreeNode: def __init__(self, value=0, color='red', left=None, right=None): self.value = value self.color = color self.left = left self.right = right def findLCA(root, p, q): Helper function to find the lowest common ancestor of two nodes in the binary tree. if root is None: return None if root.value == p or root.value == q: return root left_lca = findLCA(root.left, p, q) right_lca = findLCA(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca else right_lca def lcaColor(root, p, q): Returns the color of the lowest common ancestor (LCA) of nodes with values p and q. lca = findLCA(root, p, q) return lca.color if lca else None"},{"question":"def nth_term_sequence(n: int) -> int: Returns the nth term of the sequence where each term is generated by doubling the previous term and adding 1, starting from 1. >>> nth_term_sequence(1) == 1 >>> nth_term_sequence(2) == 3 >>> nth_term_sequence(3) == 7 >>> nth_term_sequence(4) == 15 >>> nth_term_sequence(5) == 31 >>> nth_term_sequence(6) == 63 >>> nth_term_sequence(10) == 1023","solution":"def nth_term_sequence(n): Returns the nth term of the sequence where each term is generated by doubling the previous term and adding 1, starting from 1. if n == 1: return 1 return (2 ** n) - 1"},{"question":"def subarray_sum(nums, k): Returns the number of subarrays whose sum equals k. :param nums: List of integers :param k: Target sum :return: Number of subarrays with sum equals to k >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, -2, 3], 0) 1 >>> subarray_sum([1, -1, 1, -1], 0) 4 def process_input(t, test_cases): Processes the input and returns the results for each test case. :param t: Number of test cases :param test_cases: List of tuples containing test case information :return: List of results for each test case >>> process_input(2, [((3, 2), [1, 1, 1]), ((4, 0), [1, 2, -2, 3])]) [2, 1] def main(input_data): Main function to process input and print results for each test case. :param input_data: Multiline string containing input data","solution":"def subarray_sum(nums, k): Returns the number of subarrays whose sum equals k. count = 0 cum_sum = 0 sum_dict = {0: 1} # Dictionary to store cumulative sums and their counts for num in nums: cum_sum += num if (cum_sum - k) in sum_dict: count += sum_dict[cum_sum - k] if cum_sum in sum_dict: sum_dict[cum_sum] += 1 else: sum_dict[cum_sum] = 1 return count def process_input(t, test_cases): results = [] for case in test_cases: n, k = case[0] nums = case[1] result = subarray_sum(nums, k) results.append(result) return results def main(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, k = map(int, lines[index].split()) nums = list(map(int, lines[index + 1].split())) test_cases.append(((n, k), nums)) index += 2 results = process_input(t, test_cases) for result in results: print(result)"},{"question":"def eating_order(n, sweetness_levels): Return the sweetness levels in the order Polycarp will eat the chocolate bars. Args: n (int): Number of chocolate bars. sweetness_levels (list of int): List of sweetness levels of the chocolate bars. Returns: list of int: Sorted sweetness levels in ascending order. >>> eating_order(5, [7, 3, 2, 8, 5]) [2, 3, 5, 7, 8] >>> eating_order(3, [10, 1, 2]) [1, 2, 10]","solution":"def eating_order(n, sweetness_levels): Return the sweetness levels in the order Polycarp will eat the chocolate bars. Args: n (int): Number of chocolate bars. sweetness_levels (list of int): List of sweetness levels of the chocolate bars. Returns: list of int: Sorted sweetness levels in ascending order. return sorted(sweetness_levels)"},{"question":"def beautiful_arrangements(N: int) -> int: Returns the number of beautiful arrangements of flowers for garden length N modulo 10^9 + 7. >>> beautiful_arrangements(1) 0 >>> beautiful_arrangements(2) 2 >>> beautiful_arrangements(3) 6 >>> beautiful_arrangements(4) 24 >>> beautiful_arrangements(5) 120 >>> beautiful_arrangements(10) 3628800 >>> beautiful_arrangements(20) 146326063","solution":"def beautiful_arrangements(N): Returns the number of beautiful arrangements of flowers for garden length N modulo 10^9 + 7. MOD = 10**9 + 7 # If N is 1, it's not possible to arrange flowers aesthetically if N == 1: return 0 # If N is 2, we have 2 beautiful arrangements (1-2, 2-1) elif N == 2: return 2 else: result = 2 for i in range(3, N+1): result = (result * i) % MOD return result"},{"question":"class VersionControl: Implement a software version management system that tracks versions of a software and allows check in, check out, and restoration to previous versions. def __init__(self): Initialize the version control with an initial state. pass def commit(self, message): Save the current state of the software with a commit message. pass def checkout(self, version): Revert the software to a specific version. pass def list_versions(self): List all versions and their commit messages in chronological order. pass def log_versions(self): Print the commit history in reverse chronological order. pass # Unit tests import pytest def test_initial_version(): vc = VersionControl() assert vc.list_versions() == \\"v0 - Initial version\\" assert vc.log_versions() == \\"v0 - Initial version\\" def test_commit(): vc = VersionControl() vc.commit(\\"First\\") assert vc.list_versions() == \\"v0 - Initial versionnv1 - First\\" assert vc.log_versions() == \\"v1 - Firstnv0 - Initial version\\" vc.commit(\\"Second\\") assert vc.list_versions() == \\"v0 - Initial versionnv1 - Firstnv2 - Second\\" assert vc.log_versions() == \\"v2 - Secondnv1 - Firstnv0 - Initial version\\" def test_checkout_and_commit(): vc = VersionControl() vc.commit(\\"First\\") vc.commit(\\"Second\\") vc.checkout(\\"v1\\") assert vc.list_versions() == \\"v0 - Initial versionnv1 - First\\" vc.commit(\\"Third\\") assert vc.list_versions() == \\"v0 - Initial versionnv1 - Firstnv2 - Third\\" assert vc.log_versions() == \\"v2 - Thirdnv1 - Firstnv0 - Initial version\\" def test_checkout_nonexistent_version(): vc = VersionControl() vc.commit(\\"First\\") with pytest.raises(ValueError, match=\\"Version not found\\"): vc.checkout(\\"v3\\")","solution":"class VersionControl: def __init__(self): self.versions = [{\\"version\\": \\"v0\\", \\"message\\": \\"Initial version\\"}] self.current_version = 0 def commit(self, message): self.current_version += 1 new_version = {\\"version\\": f\\"v{self.current_version}\\", \\"message\\": message} self.versions = self.versions[:self.current_version] self.versions.append(new_version) def checkout(self, version): for i, v in enumerate(self.versions): if v['version'] == version: self.current_version = i self.versions = self.versions[:i+1] return raise ValueError(\\"Version not found\\") def list_versions(self): return 'n'.join([f\\"{v['version']} - {v['message']}\\" for v in self.versions]) def log_versions(self): return 'n'.join([f\\"{v['version']} - {v['message']}\\" for v in reversed(self.versions)])"},{"question":"def minimize_adjacent_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Rearrange the sequence of each test case to minimize the absolute difference between any two adjacent numbers. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : Each test case consists of a tuple where the first element is an integer N and the second element is a list of N integers. Returns: List[List[int]] : A list containing N space-separated integers denoting the rearranged array with minimized adjacent differences for each test case. Example: >>> minimize_adjacent_difference(1, [(5, [3, 1, 2, 4, 5])]) [[1, 2, 3, 4, 5]] >>> minimize_adjacent_difference(2, [(3, [10, 3, 5]), (4, [2, 8, 6, 4])]) [[3, 5, 10], [2, 4, 6, 8]]","solution":"def minimize_adjacent_difference(T, test_cases): Rearrange the sequence of each test case to minimize the absolute difference between any two adjacent numbers. results = [] for t in range(T): N = test_cases[t][0] array = test_cases[t][1] array.sort() # Sort the array to minimize the adjacent differences results.append(array) return results"},{"question":"def minimumManipulations(S: str) -> int: Returns the minimum number of manipulations required to make all characters of the string the same. >>> minimumManipulations(\\"aabb\\") 2 >>> minimumManipulations(\\"abcde\\") 4","solution":"def minimumManipulations(S): Returns the minimum number of manipulations required to make all characters of the string the same. from collections import Counter # Count the frequencies of each character count = Counter(S) # Find the character with the maximum frequency max_freq = max(count.values()) # The minimum manipulations needed will be the length of the string # minus the highest frequency since we can convert all other characters # to the most frequent one min_manipulations = len(S) - max_freq return min_manipulations"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are two distinct numbers in the array whose sum equals the target value. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if a pair with the target sum exists, False otherwise. Test Cases: >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([-2, -1, 0, 1, 2], 0) True >>> has_pair_with_sum([100000, 99999, -100000, -99999], 1) True >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([10], 10) False >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 3, 4, 5, 6], 7) True # Write your implementation here","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct numbers in the array whose sum equals the target value. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if a pair with the target sum exists, False otherwise. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def findUnique(arr): Function to find the unique integer in an array where every other integer is repeated twice. Parameters: arr (list): List of integers where every integer except one is repeated exactly twice Returns: int: The unique integer that is not repeated Example: >>> findUnique([4, 1, 2, 1, 2]) 4 >>> findUnique([-1, -2, 2, -1, 2]) -2","solution":"def findUnique(arr): Function to find the unique integer in an array where every other integer is repeated twice. Parameters: arr (list): List of integers Returns: int: The unique integer that is not repeated unique = 0 for num in arr: unique ^= num return unique"},{"question":"def single_number(nums: List[int]) -> int: Finds the element that appears exactly once in the list where every other element appears exactly twice. >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1, 2, 3, 1, 2]) 3 >>> single_number([-1, -2, -3, -1, -2]) -3 >>> single_number([42]) 42 >>> single_number([10, 10, 20, 30, 30, 40, 40, 50, 50]) 20","solution":"def single_number(nums): Finds the element that appears exactly once in the list where every other element appears exactly twice. :param nums: List[int] :return: int result = 0 for num in nums: result ^= num return result"},{"question":"def count_subarrays_divisible_by_k(arr: List[int], k: int) -> int: Given an integer array 'arr' and an integer 'k', find the number of subarrays whose sum is divisible by 'k'. Args: arr (List[int]): List of integers representing the array. k (int): The integer divisor. Returns: int: The number of subarrays whose sum is divisible by 'k'. Examples: >>> count_subarrays_divisible_by_k([1, 2, 3, 4, 1], 3) 4 >>> count_subarrays_divisible_by_k([4, 2, 6, -1, 1, 9], 7) 3 from solution import count_subarrays_divisible_by_k def test_example_1(): arr = [1, 2, 3, 4, 1] k = 3 assert count_subarrays_divisible_by_k(arr, k) == 4 def test_example_2(): arr = [4, 2, 6, -1, 1, 9] k = 7 assert count_subarrays_divisible_by_k(arr, k) == 3 def test_single_element_divisible(): arr = [6] k = 6 assert count_subarrays_divisible_by_k(arr, k) == 1 def test_single_element_not_divisible(): arr = [5] k = 6 assert count_subarrays_divisible_by_k(arr, k) == 0 def test_all_elements_zero(): arr = [0, 0, 0, 0, 0] k = 1 assert count_subarrays_divisible_by_k(arr, k) == 15 def test_large_k_value(): arr = [1, 2, 3, 4, 5] k = 100 assert count_subarrays_divisible_by_k(arr, k) == 0 def test_negative_numbers(): arr = [10, -10, 10, -10, 10] k = 5 assert count_subarrays_divisible_by_k(arr, k) == 15","solution":"def count_subarrays_divisible_by_k(arr, k): from collections import defaultdict # Initialize necessary variables count = 0 prefix_sum = 0 freq = defaultdict(int) freq[0] = 1 # Base case: there's one way to have sum % k == 0 initially # Traverse the array and calculate prefix sums for num in arr: prefix_sum += num modulus = prefix_sum % k # Adjust for negative values if modulus < 0: modulus += k # Count the number of times this particular remainder has appeared count += freq[modulus] # Update the frequency of this remainder freq[modulus] += 1 return count"},{"question":"def sum_fibonacci(N: int) -> int: Returns the sum of the first N Fibonacci numbers. >>> sum_fibonacci(5) 7 >>> sum_fibonacci(10) 88","solution":"def sum_fibonacci(N): Returns the sum of the first N Fibonacci numbers. if N == 0: return 0 elif N == 1: return 0 # only F(0) = 0 elif N == 2: return 1 # F(0) + F(1) = 0 + 1 = 1 fib = [0, 1] # Starting point # Building the Fibonacci sequence for i in range(2, N): fib.append(fib[i-1] + fib[i-2]) return sum(fib)"},{"question":"def longest_balanced_brackets(seq: str) -> int: Determine the longest length of balanced brackets that can be found in the sequence. >>> longest_balanced_brackets(\\"(()(\\") 2 >>> longest_balanced_brackets(\\")()())\\") 4 >>> longest_balanced_brackets(\\"((()))()\\") 8","solution":"def longest_balanced_brackets(seq): max_len = 0 stack = [] start = -1 for i, char in enumerate(seq): if char == '(': stack.append(i) else: if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: max_len = max(max_len, i - start) else: start = i return max_len"},{"question":"def average_of_top_three_unique_temperatures(temperatures): Returns the average of the top three highest unique temperatures from a given list. Args: temperatures (list of int): List of temperatures recorded. Returns: float: Average of the top three highest unique temperatures. Examples: >>> average_of_top_three_unique_temperatures([30, 30, 32, 33, 31, 29, 28]) # 32.0 >>> average_of_top_three_unique_temperatures([25, 28, 32, 29, 35, 30, 28, 31]) # 32.666666666666664 >>> average_of_top_three_unique_temperatures([-10, 20, 20, 15, 5, 10, 8]) # 15.0 >>> average_of_top_three_unique_temperatures([10, 15, 10, 15, 10, 15, 10, 15]) # 12.5 >>> average_of_top_three_unique_temperatures([35, 30, 30, 35, 35, 35, 28, 28]) # 31.0 >>> average_of_top_three_unique_temperatures([-5, -1, -2, -3, 0, -4, -6]) # -1.0","solution":"def average_of_top_three_unique_temperatures(temperatures): Returns the average of the top three highest unique temperatures from a given list. Args: temperatures (list of int): List of temperatures recorded. Returns: float: Average of the top three highest unique temperatures. unique_temperatures = list(set(temperatures)) unique_temperatures.sort(reverse=True) top_three_temperatures = unique_temperatures[:3] average = sum(top_three_temperatures) / len(top_three_temperatures) return average"},{"question":"def replace_with_ranks(numbers): Replaces each integer in the list with its rank within the list. Parameters: numbers (list of int): A list of integers to be replaced with their ranks. Returns: list of int: The list of integers replaced with their ranks. >>> replace_with_ranks([100, 50, 50, 70, 60]) [4, 1, 1, 3, 2] >>> replace_with_ranks([20, 10, 40, 30]) [2, 1, 4, 3] >>> replace_with_ranks([1, 2, 3, 2, 1, 3]) [1, 2, 3, 2, 1, 3] >>> replace_with_ranks([10]) [1] >>> replace_with_ranks([5, 5, 5, 5]) [1, 1, 1, 1] >>> replace_with_ranks([100, 1000, 10**9, 50, 50000]) [2, 3, 5, 1, 4] # Your code here","solution":"def replace_with_ranks(numbers): Replaces each integer in the list with its rank within the list. Parameters: numbers (list of int): A list of integers to be replaced with their ranks. Returns: list of int: The list of integers replaced with their ranks. sorted_unique_nums = sorted(set(numbers)) rank_map = {num: rank for rank, num in enumerate(sorted_unique_nums, start=1)} return [rank_map[num] for num in numbers]"},{"question":"def max_non_contiguous_subsequence_sum(arr): Find the maximum sum of its non-contiguous subsequence in a given array of non-negative integers. >>> max_non_contiguous_subsequence_sum([3, 2, 5, 10]) 13 >>> max_non_contiguous_subsequence_sum([3, 2, 7]) 10 def solve_max_non_contiguous_subsequence_sum(t, test_cases): Solve multiple test cases for the maximum sum of non-contiguous subsequences. >>> solve_max_non_contiguous_subsequence_sum(2, [(4, [3, 2, 5, 10]), (3, [3, 2, 7])]) [13, 10]","solution":"def max_non_contiguous_subsequence_sum(arr): incl = 0 # Max sum including the last element excl = 0 # Max sum excluding the last element for num in arr: # Current max excluding num is the max of the previous inclusive and exclusive sums new_excl = max(incl, excl) # Update incl to include the current number incl = excl + num excl = new_excl # Return the max of incl and excl return max(incl, excl) def solve_max_non_contiguous_subsequence_sum(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(max_non_contiguous_subsequence_sum(arr)) return results"},{"question":"def can_partition_monotonic(arr): Determine if the given array can be partitioned into segments where each segment is strictly increasing or strictly decreasing. Args: arr (List[int]): An array of integers. Returns: str: \\"YES\\" if it is possible to partition the array in the described way, otherwise \\"NO\\". Examples: >>> can_partition_monotonic([1, 2, 3, 2, 1]) \\"YES\\" >>> can_partition_monotonic([5, 4, 3, 2]) \\"YES\\" >>> can_partition_monotonic([1, 2, 3, 4, 3, 4]) \\"NO\\"","solution":"def can_partition_monotonic(arr): Determine if the given array can be partitioned into segments where each segment is strictly increasing or strictly decreasing. n = len(arr) if n == 1: return \\"YES\\" increasing = False decreasing = False for i in range(n - 1): if arr[i] < arr[i + 1]: if decreasing: return \\"NO\\" increasing = True elif arr[i] > arr[i + 1]: if increasing: increasing = False decreasing = True else: return \\"NO\\" # No equal elements allowed return \\"YES\\""},{"question":"from typing import List def process_test_cases(test_cases: List[str]) -> List[str]: Determine if the books can be rearranged so no two adjacent books are of the same type. If possible, return any valid rearrangement. Otherwise, return \\"Not Possible\\". Examples: >>> process_test_cases([\\"aabb\\", \\"aab\\", \\"aaabc\\"]) ['abab', 'aba', 'abaca'] >>> process_test_cases([\\"a\\", \\"aaab\\"]) ['a', 'Not Possible']","solution":"from collections import Counter import heapq def rearrange_books(s): Given a string s of lowercase English letters, rearrange it so that no two adjacent characters are the same. If it is not possible, return \\"Not Possible\\". if not s: return \\"Not Possible\\" # Count frequency of each character counter = Counter(s) # Max heap based on character frequency max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) previous_char = None previous_freq = 0 result = [] while max_heap or previous_freq: if previous_freq: if not max_heap: return \\"Not Possible\\" current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) current_freq += 1 # since current_freq is negative, incrementing adjusts frequency if previous_freq < 0: heapq.heappush(max_heap, (previous_freq, previous_char)) previous_char = current_char previous_freq = current_freq return ''.join(result) def process_test_cases(test_cases): results = [] for b in test_cases: res = rearrange_books(b) results.append(res) return results"},{"question":"def can_convert(s: str, p: str) -> str: Determine if string P can be converted to match string S by replacing question marks. Arguments: s -- the target string containing only lowercase Latin letters p -- the string containing lowercase Latin letters and question marks Returns: A string (converted P) if possible, otherwise \\"No\\". >>> can_convert(\\"abc\\", \\"a?c\\") 'abc' >>> can_convert(\\"banana\\", \\"b?n?n?\\") 'banana' >>> can_convert(\\"test\\", \\"xyz?\\") 'No' def process_test_cases(test_cases: list) -> list: Process multiple test cases and determine if each pair of strings S and P can be matched. Arguments: test_cases -- a list of tuples, each containing two strings (S, P) Returns: A list of strings, each containing the result for the corresponding test case. >>> test_cases = [(\\"abc\\", \\"a?c\\"), (\\"banana\\", \\"b?n?n?\\"), (\\"abcd\\", \\"?bcd\\")] >>> process_test_cases(test_cases) ['abc', 'banana', 'abcd'] from solution import can_convert, process_test_cases def test_can_convert(): assert can_convert(\\"abc\\", \\"a?c\\") == \\"abc\\" assert can_convert(\\"banana\\", \\"b?n?n?\\") == \\"banana\\" assert can_convert(\\"test\\", \\"t?st\\") == \\"test\\" assert can_convert(\\"test\\", \\"te?t\\") == \\"test\\" assert can_convert(\\"abcd\\", \\"a?c?\\") == \\"abcd\\" assert can_convert(\\"abcd\\", \\"?bcd\\") == \\"abcd\\" assert can_convert(\\"abcd\\", \\"abc?\\") == \\"abcd\\" assert can_convert(\\"abcd\\", \\"?bc?\\") == \\"abcd\\" assert can_convert(\\"abcd\\", \\"xyz?\\") == \\"No\\" assert can_convert(\\"abcd\\", \\"ab??\\") == \\"abcd\\" def test_process_test_cases(): test_cases = [ (\\"abc\\", \\"a?c\\"), (\\"banana\\", \\"b?n?n?\\"), (\\"abcd\\", \\"?bcd\\"), (\\"abcd\\", \\"ab?d\\"), (\\"abcdef\\", \\"a?cd?f\\"), (\\"test\\", \\"xyz?\\") ] expected_results = [ \\"abc\\", \\"banana\\", \\"abcd\\", \\"abcd\\", \\"abcdef\\", \\"No\\" ] results = process_test_cases(test_cases) assert results == expected_results","solution":"def can_convert(s, p): Determine if string P can be converted to match string S by replacing question marks. Arguments: s -- the target string containing only lowercase Latin letters p -- the string containing lowercase Latin letters and question marks Returns: A string (converted P) if possible, otherwise \\"No\\". if len(s) != len(p): return \\"No\\" result = [] for i in range(len(s)): if p[i] == '?': result.append(s[i]) elif p[i] != s[i]: return \\"No\\" else: result.append(p[i]) return ''.join(result) def process_test_cases(test_cases): results = [] for s, p in test_cases: result = can_convert(s, p) results.append(result) return results"},{"question":"def financialOutcome(workshops): Returns the overall financial outcome from all workshops combined, rounded to two decimal places. Args: workshops (List[List[int]]): A list of workshops, each containing the registration fee and the cost to organize it. Returns: float: The total financial outcome, rounded to two decimal places. >>> financialOutcome([[100, 200], [150, 180], [120, 120]]) -> -130.00 >>> financialOutcome([[200, 150], [150, 160], [220, 220]]) -> 40.00 >>> financialOutcome([[300, 300], [200, 200]]) -> 0.00 >>> financialOutcome([[120, 100], [140, 90], [80, 120]]) -> 30.00","solution":"def financialOutcome(workshops): Returns the overall financial outcome from all workshops combined, rounded to two decimal places. total_outcome = sum(fee - cost for fee, cost in workshops) return round(total_outcome, 2)"},{"question":"from typing import List def is_strong_password(password: str) -> bool: Determines whether a password is strong based on the given criteria. - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from the set: !@#%^&*()-+ >>> is_strong_password('HelloWorld1!') True >>> is_strong_password('weakpassword123') False def evaluate_passwords(passwords: List[str]) -> List[str]: Evaluates a list of passwords and returns 'Strong' or 'Weak' for each based on their strength. >>> evaluate_passwords(['HelloWorld1!', 'weakpassword123', 'AnotherPass2']) ['Strong', 'Weak', 'Strong'] >>> evaluate_passwords(['abcd1234!', 'Abcde1234', 'ABCDEF123!', 'abcde!FE']) ['Weak', 'Weak', 'Weak', 'Weak']","solution":"def is_strong_password(password): Determines whether a password is strong based on the given criteria. has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) return has_upper and has_lower and has_digit and has_special def evaluate_passwords(passwords): Evaluates each of the provided passwords and returns 'Strong' or 'Weak' for each. results = [] for password in passwords: if is_strong_password(password): results.append('Strong') else: results.append('Weak') return results"},{"question":"from typing import List, Tuple def minimum_total_maintenance_cost(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: You are given an undirected graph representing a network of servers and connections between them. Your task is to optimize the network in such a way that the total maintenance cost of the connections is minimized and the network remains fully connected. In other words, you need to find a minimum spanning tree (MST) of the graph. Args: n (int): Number of servers. m (int): Number of connections. connections (List[Tuple[int, int, int]]): Each connection is represented by a tuple (a, b, c) where \`a\` and \`b\` are the endpoints of a connection, and \`c\` is the maintenance cost of that connection. Returns: int: The minimum total maintenance cost of the network. >>> minimum_total_maintenance_cost(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 1), (2, 4, 2), (3, 4, 3)]) 4 >>> minimum_total_maintenance_cost(3, 3, [(1, 2, 3), (2, 3, 2), (1, 3, 1)]) 3","solution":"def find(parent, i): A function to find the set of an element i using path compression. if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): A function that does union of two sets of x and y using rank. rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): Main function to perform Kruskal's algorithm to find the MST of a graph. edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_cost = 0 mst_edges = 0 for edge in edges: u, v, w = edge rootU = find(parent, u) rootV = find(parent, v) if rootU != rootV: mst_cost += w mst_edges += 1 union(parent, rank, rootU, rootV) if mst_edges == n - 1: break return mst_cost def minimum_total_maintenance_cost(n, m, connections): edges = [(a-1, b-1, c) for a, b, c in connections] return kruskal(n, edges)"},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[List[str]]) -> int: Determine the minimum number of moves required for Natasha to reach the bottom-right cell, or return -1 if not possible. >>> min_moves_to_reach_end(3, 4, [list(\\"...#\\"), list(\\"..#.\\"), list(\\"#...\\")]) == 5 >>> min_moves_to_reach_end(2, 2, [list(\\".#\\"), list(\\"#.\\")]) == -1 >>> min_moves_to_reach_end(1, 1, [list(\\".\\")]) == 0 >>> min_moves_to_reach_end(1, 1, [list(\\"#\\")]) == -1 >>> min_moves_to_reach_end(4, 4, [list(\\"....\\"), list(\\"....\\"), list(\\"....\\"), list(\\"....\\")]) == 6 >>> min_moves_to_reach_end(4, 4, [list(\\"....\\"), list(\\"...#\\"), list(\\"..#.\\"), list(\\"..\\")]) == -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, moves) visited[0][0] = True while queue: row, col, moves = queue.popleft() if row == n - 1 and col == m - 1: return moves for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col] and grid[new_row][new_col] == '.': visited[new_row][new_col] = True queue.append((new_row, new_col, moves + 1)) return -1"},{"question":"def compute_list_result(T, elements): This function takes an integer T which is the number of elements in the list and a list of integers. It returns the computed sum if the list contains more even numbers or more even numbers tie with odd numbers, and it returns the computed product if the list contains more odd numbers. >>> compute_list_result(4, [1, 2, 3, 4]) 10 >>> compute_list_result(3, [1, 3, 5]) 15 >>> compute_list_result(4, [2, 4, 1, 3]) 10","solution":"def compute_list_result(T, elements): This function takes an integer T which is the number of elements in the list and a list of integers. It returns the computed sum if the list contains more even numbers or more even numbers tie with odd numbers, and it returns the computed product if the list contains more odd numbers. if T != len(elements): raise ValueError(\\"The number of elements does not match T.\\") even_count = sum(1 for x in elements if x % 2 == 0) odd_count = T - even_count if even_count >= odd_count: return sum(elements) else: product = 1 for number in elements: product *= number return product"},{"question":"def stack_operations(operations): Perform a series of stack operations and return the results of 'max' operations. Parameters: operations (list): A list of operations to perform on the stack. Returns: list: The results of all 'max' operations. pass # Unit Tests def test_stack_operations_example1(): operations = [\\"push 3\\", \\"push 2\\", \\"max\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [3, 3] def test_stack_operations_example2(): operations = [\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"max\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [3, 2] def test_stack_operations_example3(): operations = [\\"push 5\\", \\"push 1\\", \\"max\\", \\"pop\\", \\"max\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [5, 5, None] def test_stack_operations_single_max_empty(): operations = [\\"max\\"] assert stack_operations(operations) == [None] def test_stack_operations_push_pop_max(): operations = [\\"push 10\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [None] def test_stack_operations_multiple_pops(): operations = [\\"push 5\\", \\"push 6\\", \\"pop\\", \\"pop\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [None] def test_stack_operations_max_skipped_pops(): operations = [\\"push 3\\", \\"push 1\\", \\"pop\\", \\"pop\\", \\"max\\"] assert stack_operations(operations) == [None]","solution":"def stack_operations(operations): Perform a series of stack operations and return the results of 'max' operations. Parameters: operations (list): A list of operations to perform on the stack. Returns: list: The results of all 'max' operations. stack = [] max_stack = [] result = [] for operation in operations: if operation.startswith(\\"push\\"): _, value = operation.split() value = int(value) stack.append(value) if not max_stack or value >= max_stack[-1]: max_stack.append(value) elif operation == \\"pop\\": if stack: value = stack.pop() if max_stack and value == max_stack[-1]: max_stack.pop() elif operation == \\"max\\": if max_stack: result.append(max_stack[-1]) else: result.append(None) return result"},{"question":"def game_with_numbers(n: int, arr: List[int]) -> Tuple[int, int]: Determines the final score for Alice and Bob in their number-picking game. >>> game_with_numbers(6, [2, 3, 5, 8, 7, 4]) (14, 15) >>> game_with_numbers(5, [2, 4, 6, 8, 10]) (30, 0) >>> game_with_numbers(5, [1, 3, 5, 7, 9]) (0, 25) >>> game_with_numbers(4, [10, 15, 20, 25]) (30, 40) >>> game_with_numbers(6, [1, 3, 5, 7, 9, 11]) (0, 36) >>> game_with_numbers(6, [2, 4, 6, 8, 10, 12]) (42, 0) >>> game_with_numbers(1, [2]) (2, 0) >>> game_with_numbers(1, [3]) (0, 3)","solution":"def game_with_numbers(n, arr): alice_score = 0 bob_score = 0 left = 0 right = n - 1 is_alice_turn = True while left <= right: if is_alice_turn: # Alice's turn to pick if arr[left] % 2 == 0: alice_score += arr[left] left += 1 elif arr[right] % 2 == 0: alice_score += arr[right] right -= 1 else: is_alice_turn = False continue else: # Bob's turn to pick if arr[left] % 2 != 0: bob_score += arr[left] left += 1 elif arr[right] % 2 != 0: bob_score += arr[right] right -= 1 else: is_alice_turn = True continue is_alice_turn = not is_alice_turn return alice_score, bob_score"},{"question":"def min_deletions_to_make_unique(arr): This function calculates the minimum number of deletions required to make all the elements in the array unique. >>> min_deletions_to_make_unique([2, 3, 2, 2, 2]) 3 >>> min_deletions_to_make_unique([1, 2, 2]) 1 def solve(test_cases): This function takes a list of test cases and returns a list with the results for each test case >>> solve([(5, [2, 3, 2, 2, 2]), (3, [1, 2, 2])]) [3, 1] >>> solve([(4, [1, 2, 3, 4]), (3, [1, 1, 1])]) [0, 2] def main(input_data): This function processes the input data, executes the solve function, and prints results from solution import min_deletions_to_make_unique, solve def test_min_deletions_to_make_unique(): assert min_deletions_to_make_unique([2, 3, 2, 2, 2]) == 3 assert min_deletions_to_make_unique([1, 2, 2]) == 1 assert min_deletions_to_make_unique([1,1,1,1,1]) == 4 assert min_deletions_to_make_unique([4, 5, 6, 7]) == 0 assert min_deletions_to_make_unique([]) == 0 def test_solve(): assert solve([(5, [2, 3, 2, 2, 2]), (3, [1, 2, 2])]) == [3, 1] assert solve([(4, [1, 2, 3, 4]), (3, [1, 1, 1])]) == [0, 2] assert solve([(1, [1])]) == [0] assert solve([(6, [1, 1, 1, 2, 2, 2])]) == [4]","solution":"def min_deletions_to_make_unique(arr): This function calculates the minimum number of deletions required to make all the elements in the array unique. from collections import Counter elements_count = Counter(arr) deletions_required = 0 seen = set() for num, count in elements_count.items(): while count > 1: count -= 1 deletions_required += 1 return deletions_required def solve(test_cases): results = [] for n, arr in test_cases: results.append(min_deletions_to_make_unique(arr)) return results def main(input_data): data = input_data.strip().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) arr = list(map(int, data[index + 1: index + 1 + N])) test_cases.append((N, arr)) index += N + 1 results = solve(test_cases) for result in results: print(result)"},{"question":"def solve(board: List[List[str]]) -> None: Modify the \`board\` in-place to flip 'O' regions that are surrounded by 'X' to 'X'. >>> board1 = [ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> solve(board1) >>> assert board1 == [ ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'], ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> board2 = [ ... ['X', 'X', 'X'], ... ['X', 'O', 'X'], ... ['X', 'X', 'X'] ... ] >>> solve(board2) >>> assert board2 == [ ... ['X', 'X', 'X'], ... ['X', 'X', 'X'], ... ['X', 'X', 'X'] ... ] >>> board3 = [] >>> solve(board3) >>> assert board3 == [] >>> board4 = [ ... ['O', 'O'], ... ['O', 'O'] ... ] >>> solve(board4) >>> assert board4 == [ ... ['O', 'O'], ... ['O', 'O'] ... ]","solution":"def solve(board): if not board or not board[0]: return m, n = len(board), len(board[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O': return board[i][j] = 'T' dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) for i in range(m): if board[i][0] == 'O': dfs(i, 0) if board[i][n - 1] == 'O': dfs(i, n - 1) for j in range(n): if board[0][j] == 'O': dfs(0, j) if board[m - 1][j] == 'O': dfs(m - 1, j) for i in range(m): for j in range(n): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'T': board[i][j] = 'O'"},{"question":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Given a list of integers and a target sum, determine if any two distinct numbers in the list add up to the target sum. If such a pair exists, return the pair as a tuple. If no such pair exists, return None. If there are multiple pairs, return any one of them. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Optional[Tuple[int, int]]: A tuple containing the pair of numbers that add up to the target sum, or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None # Note: You can test your implementation using the following test cases def test_find_pair_with_sum_exist(): assert find_pair_with_sum([2, 7, 11, 15], 9) in [(2, 7), (7, 2)] assert find_pair_with_sum([1, 2, 3, 4, 5], 5) in [(2, 3), (3, 2)] assert find_pair_with_sum([-1, -2, -3, -4, -5], -8) in [(-3, -5), (-5, -3)] assert find_pair_with_sum([0, -1, 2, -3, 4], -1) in [(-1, 0), (0, -1), (-3, 2), (2, -3)] def test_find_pair_with_sum_no_exist(): assert find_pair_with_sum([1, 2, 3, 4, 5], 10) == None assert find_pair_with_sum([0, -1, 2, -3, 4], 8) == None assert find_pair_with_sum([1, 5, 3, 7, 9], 17) == None def test_find_pair_with_sum_edge_cases(): assert find_pair_with_sum([1, 2], 3) in [(1, 2), (2, 1)] assert find_pair_with_sum([], 0) == None assert find_pair_with_sum([5], 10) == None def test_find_pair_with_sum_same_sum_different_combinations(): assert find_pair_with_sum([1, 2, 3, 4, 2], 4) in [(1, 3), (3, 1)] assert find_pair_with_sum([1, 4, 45, 6, 10, -8], 16) in [(10, 6), (6, 10)]","solution":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a tuple of two numbers from nums that add up to target sum. If no such pair exists, return None. seen = set() for num in nums: complement = target - num if complement in seen: return (num, complement) seen.add(num) return None"},{"question":"def find_min_reversal_cost(n: int, m: int, hallways: List[Tuple[int, int]]) -> int: Find and report the smallest cost of any valid proposal for arranging the university's layout by reversing the directions of some hallways as required to produce a valid tree structure without cycles. Input: n: int - The number of classrooms m: int - The number of hallways hallways: List[Tuple[int, int]] - A list of directed hallways represented as tuples (a_i, b_i) denoting a directed hallway from classroom a_i to b_i Output: int - The minimum cost to achieve a valid proposal, or -1 if no valid proposal exists >>> find_min_reversal_cost(3, 2, [(1, 2), (2, 3)]) 0 >>> find_min_reversal_cost(3, 3, [(1, 2), (2, 3), (3, 1)]) 1 >>> find_min_reversal_cost(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 1 >>> find_min_reversal_cost(1, 0, []) 0 >>> find_min_reversal_cost(2, 0, []) -1 >>> find_min_reversal_cost(4, 2, [(1, 2), (3, 4)]) -1 >>> find_min_reversal_cost(1, 0, []) 0 >>> find_min_reversal_cost(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> find_min_reversal_cost(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 1","solution":"from itertools import combinations import networkx as nx def find_min_reversal_cost(n, m, hallways): def is_valid_proposal(graph): # A valid proposal should be a Directed Acyclic Graph (DAG) with exactly one source. in_degrees = {node: 0 for node in range(1, n+1)} for u, v in graph.edges(): in_degrees[v] += 1 # Check for cycles and exactly one source (node with in-degree 0) sources = [node for node, degree in in_degrees.items() if degree == 0] if len(sources) != 1: return False try: nx.find_cycle(graph, orientation='original') return False except nx.NetworkXNoCycle: return True G = nx.DiGraph() G.add_edges_from(hallways) if is_valid_proposal(G): return 0 min_cost = float('inf') for r in range(1, m+1): for rev_set in combinations(hallways, r): reversed_edges = [(v, u) for u, v in rev_set] G_rev = nx.DiGraph() G_rev.add_edges_from([edge for edge in hallways if edge not in rev_set] + reversed_edges) if is_valid_proposal(G_rev): min_cost = min(min_cost, r) return min_cost if min_cost != float('inf') else -1 # Parsing the input and calling the function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) hallways = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(m)] print(find_min_reversal_cost(n, m, hallways))"},{"question":"def max_beautiful_pairs(n: int, array: List[int]) -> int: Calculate the maximum number of beautiful pairs in a sequence or return -1 if not possible to rearrange without two equal elements being adjacent. >>> max_beautiful_pairs(5, [1, 2, 2, 3, 3]) 4 >>> max_beautiful_pairs(6, [1, 1, 1, 1, 1, 1]) -1","solution":"def max_beautiful_pairs(n, array): from collections import Counter if n == 0: return 0 if n == 1: return 0 counts = Counter(array) max_freq = max(counts.values()) if max_freq > (n + 1) // 2: return -1 return n - 1 # Maximum number of beautiful pairs is n-1 when no element is adjacent to itself."},{"question":"def minDistance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t using the following operations: 1. Insert a character 2. Delete a character 3. Replace a character >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"abc\\", \\"def\\") 3 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abcdefghijklmnopqrstuvwxyz\\", \\"a\\") 25 >>> minDistance(\\"hello\\", \\"world\\") 4 >>> minDistance(\\"common\\", \\"coding\\") 4","solution":"def minDistance(s, t): Returns the minimum number of operations required to convert string s into string t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, insert all characters of t. elif j == 0: dp[i][j] = i # If t is empty, remove all characters of s. elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters are the same, no operation needed. else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def max_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Determine the maximum number of overlapping tasks at any given point in time. >>> max_overlapping_tasks(5, [(1, 5), (2, 6), (8, 10), (3, 7), (5, 9)]) 3 >>> max_overlapping_tasks(3, [(1, 3), (2, 5), (4, 6)]) 2","solution":"def max_overlapping_tasks(n, tasks): events = [] for s, e in tasks: events.append((s, 1)) # Task starts events.append((e, -1)) # Task ends # Sorting events, with starting events before ending events if times are same events.sort(key=lambda x: (x[0], x[1])) max_overlap = 0 current_overlap = 0 for event in events: current_overlap += event[1] max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"def count_distinct_substrings(s: str) -> int: Calculate the total number of distinct substrings of a given string \`s\`. >>> count_distinct_substrings('a') 1 >>> count_distinct_substrings('ab') 3 >>> count_distinct_substrings('ababa') 9 >>> count_distinct_substrings('') 0","solution":"def count_distinct_substrings(s): Calculates the total number of distinct substrings of a given string \`s\`. n = len(s) substrings = set() # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) # The number of distinct substrings return len(substrings)"},{"question":"def max_values(list_of_lists: List[List[int]]) -> List[int]: Returns a list containing the maximum values from each non-empty sublist. >>> max_values([[1, 3, 5], [4, 6, 2], [], [-1, -5, -3], [10, 15, 5]]) [5, 6, -1, 15] >>> max_values([[7], [0], [2, 8], []]) [7, 0, 8]","solution":"def max_values(list_of_lists): Returns a list containing the maximum values from each non-empty sublist in list_of_lists. result = [] for sublist in list_of_lists: if sublist: # Check if sublist is not empty result.append(max(sublist)) return result"},{"question":"from collections import deque def is_path_possible(n, m, grid, start, end): Determines if there is a path for a robot to navigate from start to end in the grid. Parameters: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - grid (list of list of int): Grid representation. 0 for empty spaces, 1 for obstacles. - start (tuple): Starting cell (x1, y1). - end (tuple): Destination cell (x2, y2). Returns: - str: \\"YES\\" if path exists, \\"NO\\" otherwise. pass import pytest def test_path_exists(): n = 4 m = 5 grid = [ [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 1, 1, 0, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (3, 4) assert is_path_possible(n, m, grid, start, end) == \\"YES\\" def test_path_not_exists(): n = 3 m = 3 grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) assert is_path_possible(n, m, grid, start, end) == \\"NO\\" def test_start_is_end(): n = 2 m = 2 grid = [ [0, 0], [0, 0] ] start = (0, 0) end = (0, 0) assert is_path_possible(n, m, grid, start, end) == \\"YES\\" def test_full_obstacles(): n = 3 m = 3 grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] start = (1, 1) end = (1, 1) assert is_path_possible(n, m, grid, start, end) == \\"YES\\" def test_large_grid(): n = 5 m = 5 grid = [ [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], ] start = (0, 0) end = (4, 4) assert is_path_possible(n, m, grid, start, end) == \\"YES\\"","solution":"from collections import deque def is_path_possible(n, m, grid, start, end): Determines if there is a path for robot to navigate from start to end in the grid. Parameters: - n (int): Number of rows in grid. - m (int): Number of columns in grid. - grid (list of list of int): Grid representation. 0 for empty spaces, 1 for obstacles. - start (tuple): Starting cell (x1, y1). - end (tuple): Destination cell (x2, y2). Returns: - str: \\"YES\\" if path exists, \\"NO\\" otherwise. # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 # BFS to find path from start to end queue = deque([start]) visited = set() visited.add(start) while queue: x, y = queue.popleft() if (x, y) == end: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def single_number(nums): Given a non-empty array of integers \`nums\`, every element appears twice except for one. Find that single one. Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example: >>> single_number([2, 2, 1]) 1 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([1]) 1 Args: nums (List[int]): A list of integers where all elements appear twice except for one. Returns: int: The single number that appears only once.","solution":"def single_number(nums): Returns the single number in the list where every other number appears twice. Uses XOR to achieve O(n) complexity without extra memory. result = 0 for num in nums: result ^= num return result"},{"question":"def find_middle_date(date1, date2, date3): Returns the middle date from the given three dates. Each date is a tuple in the format (yyyy, mm, dd). >>> find_middle_date((2020, 5, 17), (2019, 11, 1), (2021, 1, 25)) (2020, 5, 17) >>> find_middle_date((1700, 6, 5), (1800, 1, 20), (1600, 12, 31)) (1700, 6, 5) >>> find_middle_date((2000, 1, 1), (1999, 12, 31), (2000, 1, 3)) (2000, 1, 1) >>> find_middle_date((1995, 4, 20), (1996, 6, 8), (1994, 3, 17)) (1995, 4, 20) >>> find_middle_date((2010, 7, 23), (2012, 8, 15), (2011, 9, 5)) (2011, 9, 5)","solution":"def find_middle_date(date1, date2, date3): Returns the middle date from the given three dates. Each date is a tuple in the format (yyyy, mm, dd). dates = [date1, date2, date3] dates.sort() return dates[1]"},{"question":"def process_queue_operations(n: int, operations: List[str]) -> str: Processes a sequence of queue operations and returns the final state of the queue. Parameters: n : int Number of operations operations : list of str List of operations, either 'enqueue X' or 'dequeue' Returns: str Final state of the queue as a space separated string, or 'Empty Queue' if the queue is empty. >>> process_queue_operations(6, [\\"enqueue 5\\", \\"enqueue 3\\", \\"dequeue\\", \\"enqueue 7\\", \\"enqueue 8\\", \\"dequeue\\"]) '7 8' >>> process_queue_operations(5, [\\"dequeue\\", \\"enqueue 4\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\"]) 'Empty Queue'","solution":"def process_queue_operations(n, operations): Processes a sequence of queue operations and returns the final state of the queue. Parameters: n : int Number of operations operations : list of str List of operations, either 'enqueue X' or 'dequeue' Returns: str Final state of the queue as a space separated string, or 'Empty Queue' if the queue is empty. queue = [] for operation in operations: if operation.startswith('enqueue'): _, x = operation.split() queue.append(int(x)) elif operation == 'dequeue': if queue: queue.pop(0) if queue: return ' '.join(map(str, queue)) else: return 'Empty Queue'"},{"question":"def max_subarray_sum(nums): Finds the sum of the contiguous subarray with the largest sum. Args: nums: List of integers representing the number of units sold each day. Returns: An integer representing the maximum sum of the contiguous subarray. pass from unittest import TestCase class TestMaxSubarraySum(TestCase): def test_single_element(self): self.assertEqual(max_subarray_sum([1]), 1) self.assertEqual(max_subarray_sum([-1]), -1) def test_all_positive(self): self.assertEqual(max_subarray_sum([2, 3, 1, 5]), 11) def test_all_negative(self): self.assertEqual(max_subarray_sum([-2, -3, -1, -5]), -1) def test_mixed_elements(self): self.assertEqual(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]), 6) self.assertEqual(max_subarray_sum([3, -1, -1, 3]), 4) def test_large_input(self): nums = [1] * 100000 self.assertEqual(max_subarray_sum(nums), 100000) nums = [-1] * 100000 self.assertEqual(max_subarray_sum(nums), -1 def test_edge_cases(self): self.assertEqual(max_subarray_sum([5]), 5) self.assertEqual(max_subarray_sum([-5]), -5)","solution":"def max_subarray_sum(nums): Finds the sum of the contiguous subarray with the largest sum. Args: nums: List of integers representing the number of units sold each day. Returns: An integer representing the maximum sum of the contiguous subarray. max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def coinChange(coins: List[int], amount: int) -> int: Compute the minimum number of coins required to make up the given amount. If that amount of money cannot be made up by any combination of the coins, return -1. >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1], 0) 0 >>> coinChange([1, 3, 4], 6) 2 >>> coinChange([1, 2, 5], 100) 20 >>> coinChange([5, 10, 25], 30) 2","solution":"def coinChange(coins, amount): Returns the minimum number of coins that you need to make up the given amount. If that amount of money cannot be made up by any combination of the coins, return -1. # Initialize the DP table to amount + 1 (Since this is higher than any possible answer) dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determines the order in which to execute tasks given their dependencies. A task cannot be executed until all of its prerequisite tasks have been completed. Args: num_tasks (int): The number of tasks. dependencies (List[Tuple[int, int]]): A list of dependencies between the tasks. Returns: Union[List[int], str]: A list of tasks in the order they should be executed if possible, otherwise \\"Cyclic dependency detected\\". Example: >>> find_task_order(5, [(0, 1), (1, 2), (2, 3), (3, 4)]) [0, 1, 2, 3, 4] >>> find_task_order(3, [(0, 1), (1, 2), (2, 0)]) \\"Cyclic dependency detected\\"","solution":"def find_task_order(num_tasks, dependencies): from collections import defaultdict, deque # Initializing graph structures adj_list = defaultdict(list) in_degree = defaultdict(int) # Building the graph for dep in dependencies: a, b = dep adj_list[a].append(b) in_degree[b] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([i for i in range(num_tasks) if in_degree[i] == 0]) topo_order = [] # Processing nodes with zero in-degree while zero_in_degree_queue: current = zero_in_degree_queue.popleft() topo_order.append(current) # Decrement in-degree for all neighbors for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Check if we were able to order all tasks if len(topo_order) == num_tasks: return topo_order else: return \\"Cyclic dependency detected\\""},{"question":"def collatz_length(n: int) -> int: Calculate the length of the Collatz sequence for a given integer n. >>> collatz_length(1) == 1 >>> collatz_length(2) == 2 >>> collatz_length(3) == 8 >>> collatz_length(4) == 3 >>> collatz_length(10) == 7 # Your code here def longest_collatz_sequence(L: int, R: int) -> int: Determine the length of the longest Collatz sequence for any integer in the range [L, R]. >>> longest_collatz_sequence(1, 10) == 20 >>> longest_collatz_sequence(100, 200) == 125 >>> longest_collatz_sequence(201, 210) == 89 >>> longest_collatz_sequence(900, 1000) == 174 >>> longest_collatz_sequence(1, 1) == 1 >>> longest_collatz_sequence(10, 20) == 21 # Your code here","solution":"def collatz_length(n): length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length def longest_collatz_sequence(L, R): max_length = 0 for i in range(L, R + 1): length = collatz_length(i) if length > max_length: max_length = length return max_length # Example usage if __name__ == \\"__main__\\": L, R = map(int, input().strip().split()) print(longest_collatz_sequence(L, R))"},{"question":"def calculate_distances(test_cases): Calculate the distance from the central city (0, 0) to each given city. :param test_cases: List of tuples where each tuple contains the coordinates (x, y) of a city. :return: List of distances from the central city to each given city. distances = [] from solution import calculate_distances def test_calculate_distances(): test_cases = [(1, 2), (-3, 4), (5, -6)] expected_output = [3, 7, 11] assert calculate_distances(test_cases) == expected_output def test_calculate_distances_with_zero(): test_cases = [(0, 0), (0, 5), (7, 0)] expected_output = [0, 5, 7] assert calculate_distances(test_cases) == expected_output def test_calculate_distances_with_negative_coords(): test_cases = [(-1, -1), (-7, -8), (-1000, 1000)] expected_output = [2, 15, 2000] assert calculate_distances(test_cases) == expected_output def test_calculate_distances_with_large_coords(): test_cases = [(10**9, 10**9), (-10**9, 10**9), (10**9, -10**9)] expected_output = [2 * 10**9, 2 * 10**9, 2 * 10**9] assert calculate_distances(test_cases) == expected_output","solution":"def calculate_distances(test_cases): Calculate the distance from the central city (0, 0) to each given city. :param test_cases: List of tuples where each tuple contains the coordinates (x, y) of a city. :return: List of distances from the central city to each given city. distances = [] for x, y in test_cases: distance = abs(x) + abs(y) distances.append(distance) return distances"},{"question":"def closest_playlist(durations: List[int], target: int) -> List[int]: Finds a subsequence of durations that is as close as possible, but does not exceed the given target duration. >>> closest_playlist([300, 180, 200, 150], 450) [300, 150] >>> closest_playlist([600, 700, 800, 900], 500) [] >>> closest_playlist([300, 150, 200, 100, 90], 450) [300, 150] >>> closest_playlist([100, 200, 300], 200) [200] >>> closest_playlist([50, 100, 150, 200, 250, 300], 500) [200, 300] >>> closest_playlist([], 100) []","solution":"def closest_playlist(durations, target): Finds a subsequence of durations that is as close as possible, but does not exceed the given target duration. from itertools import combinations # Initialize the best playlist found best_playlist = [] best_duration = 0 # Check all possible combinations for r in range(1, len(durations) + 1): for combo in combinations(durations, r): total_duration = sum(combo) if total_duration <= target and total_duration > best_duration: best_playlist = combo best_duration = total_duration return list(best_playlist)"},{"question":"def kth_smallest_element(arr: List[int], k: int) -> int: Returns the k-th smallest element in the sorted order of the array. Args: arr: List of integers. k: Integer representing the k-th position. Returns: The k-th smallest element in the array. Examples: >>> kth_smallest_element([3, 2, 1, 5, 6, 4], 2) 2 >>> kth_smallest_element([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 3 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([1], 1) 1 >>> kth_smallest_element([2, 2, 2, 2, 2], 3) 2 >>> kth_smallest_element([1, 9, 8, 7, 2, 3], 5) 8 >>> kth_smallest_element([0, -1, -2, -3, -4, 5], 2) -3","solution":"def kth_smallest_element(arr, k): Returns the k-th smallest element in the sorted order of the array. Args: arr: List of integers. k: Integer representing the k-th position. Returns: The k-th smallest element in the array. arr_sorted = sorted(arr) return arr_sorted[k-1]"},{"question":"def find_repeated_element(n, elements): Identifies the repeated element if it exists in the list, otherwise returns \\"No repetition\\". :param n: int, the number of elements in the list. :param elements: list of int, the elements in the list. :return: the repeated element or \\"No repetition\\". >>> find_repeated_element(5, [1, 2, 3, 4, 2]) 2 >>> find_repeated_element(4, [4, 1, 3, 2]) 'No repetition' >>> find_repeated_element(6, [7, 8, 9, 7, 10, 6]) 7","solution":"def find_repeated_element(n, elements): Identifies the repeated element if it exists in the list, otherwise returns \\"No repetition\\". :param n: int, the number of elements in the list. :param elements: list of int, the elements in the list. :return: the repeated element or \\"No repetition\\". element_count = {} for element in elements: if element in element_count: return element element_count[element] = 1 return \\"No repetition\\""},{"question":"def findPeakElement(nums): This function finds the index of a peak element in the input array \`nums\`. Args: nums (List[int]): The input list of integers. Returns: int: The index of a peak element. # Implementation here # Example Usage: # Input: [1, 2, 3, 1] # Output: 2 (index of the peak element which is 3) # Unit Tests from solution import findPeakElement def test_peak_element_single_element(): assert findPeakElement([1]) == 0 def test_peak_element_multiple_same_elements(): assert findPeakElement([2, 2, 2, 2]) in {0, 1, 2, 3} def test_peak_element_left_peak(): assert findPeakElement([3, 2, 1]) == 0 def test_peak_element_right_peak(): assert findPeakElement([1, 2, 3]) == 2 def test_peak_element_middle_peak(): assert findPeakElement([1, 3, 2, 1]) == 1 def test_peak_element_valley(): result = findPeakElement([1, 2, 1, 3, 5, 6, 4]) assert result in {1, 5} def test_peak_element_multiple_peaks(): assert findPeakElement([1, 3, 20, 4, 1, 7, 6]) in {2, 5}","solution":"def findPeakElement(nums): This function finds the index of a peak element in the input array \`nums\`. Args: nums (List[int]): The input list of integers. Returns: int: The index of a peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def find_cycle_with_even_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> str: Determine if there is a cycle in the graph where the sum of the weights of the edges in the cycle is even. >>> find_cycle_with_even_weight(5, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 1, 7)]) == \\"NO\\" >>> find_cycle_with_even_weight(4, 3, [(1, 2, 1), (2, 3, 3), (3, 4, 5)]) == \\"NO\\" >>> find_cycle_with_even_weight(3, 3, [(1, 2, 2), (2, 3, 2), (3, 1, 2)]) == \\"YES\\" >>> find_cycle_with_even_weight(3, 0, []) == \\"NO\\" >>> find_cycle_with_even_weight(2, 1, [(1, 2, 2)]) == \\"NO\\" >>> find_cycle_with_even_weight(6, 4, [(1, 2, 3), (2, 3, 4), (4, 5, 6), (5, 6, 1)]) == \\"NO\\" >>> find_cycle_with_even_weight(6, 7, [(1, 2, 10), (2, 3, 20), (3, 4, 10), (4, 1, 10), (5, 6, 15), (3, 5, 5), (4, 5, 25)]) == \\"YES\\"","solution":"def find_cycle_with_even_weight(n, m, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) visited = [False] * (n + 1) start = [0] * (n + 1) def dfs(node, parent, weight): visited[node] = True start[node] = weight % 2 for neighbor, edge_weight in graph[node]: if not visited[neighbor]: if dfs(neighbor, node, weight + edge_weight): return True elif neighbor != parent: if (weight + edge_weight) % 2 == 0: return True return False for i in range(1, n + 1): if not visited[i]: if dfs(i, -1, 0): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def find_triplet_sum_zero(nums: List[int]) -> List[int]: Given a list of distinct integers, find any three integers in the list such that the sum of the three integers is zero. If there are multiple solutions, return any one of them. If no such triplet exists, return an empty list. >>> find_triplet_sum_zero([-1, 0, 1, 2, -1, -4]) [-1, 0, 1] >>> find_triplet_sum_zero([1, 2, 3, 4, 5]) [] >>> find_triplet_sum_zero([0, -1, 2, -3, 1]) [0, -1, 1] pass # Unit Tests def test_example1(): result = find_triplet_sum_zero([-1, 0, 1, 2, -1, -4]) assert sorted(result) == sorted([-1, 0, 1]) or sorted(result) == sorted([-1, -1, 2]) def test_example2(): result = find_triplet_sum_zero([1, 2, 3, 4, 5]) assert result == [] def test_example3(): result = find_triplet_sum_zero([0, -1, 2, -3, 1]) assert sorted(result) == sorted([0, -1, 1]) or sorted(result) == sorted([-3, 1, 2]) def test_no_triplet(): result = find_triplet_sum_zero([1, 2, 4, 5, 6]) assert result == [] def test_all_negative(): result = find_triplet_sum_zero([-5, -4, -3, -2, -1]) assert result == [] def test_all_positive(): result = find_triplet_sum_zero([1, 2, 3, 4, 5]) assert result == [] def test_mixed_elements(): result = find_triplet_sum_zero([-3, -1, 1, 2, -2, 3]) assert sorted(result) == sorted([-3, -1, 4]) or sorted(result) == sorted([-3, 1, 2]) or sorted(result) == sorted([-2, -1, 3])","solution":"from typing import List def find_triplet_sum_zero(nums: List[int]) -> List[int]: nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: return [nums[i], nums[left], nums[right]] elif total < 0: left += 1 else: right -= 1 return []"},{"question":"def make_unique_sorted_string(s: str) -> str: Given a string s, removes duplicate characters and returns the string with unique characters in lexicographical order. >>> make_unique_sorted_string(\\"hello\\") 'ehlo' >>> make_unique_sorted_string(\\"programming\\") 'agimnopr' >>> make_unique_sorted_string(\\"abcd\\") 'abcd' def process_test_cases(test_cases: List[str]) -> List[str]: Processes a list of test case strings and returns a list of results after making each string unique and sorted. >>> process_test_cases([\\"hello\\"]) ['ehlo'] >>> process_test_cases([\\"hello\\", \\"programming\\", \\"abcd\\"]) ['ehlo', 'agimnopr', 'abcd'] >>> process_test_cases([\\"aabbcc\\", \\"zxycba\\"]) ['abc', 'abcxyz'] >>> process_test_cases([\\"abcd\\", \\"dcba\\", \\"aaaa\\"]) ['abcd', 'abcd', 'a']","solution":"def make_unique_sorted_string(s): Given a string s, removes duplicate characters and returns the string with unique characters in lexicographical order. unique_characters = ''.join(sorted(set(s))) return unique_characters def process_test_cases(test_cases): Processes a list of test case strings and returns a list of results after making each string unique and sorted. results = [] for s in test_cases: results.append(make_unique_sorted_string(s)) return results"},{"question":"def longest_substring_two_distinct_after_replacement(S: str) -> int: Given a string S, return the length of the longest substring that contains at most two distinct characters after one character replacement. >>> longest_substring_two_distinct_after_replacement(\\"eceba\\") 4 >>> longest_substring_two_distinct_after_replacement(\\"ccaabbb\\") 6 >>> longest_substring_two_distinct_after_replacement(\\"aaa\\") 3 def solve(T: int, test_cases: List[str]) -> List[int]: Solve the problem for multiple test cases. >>> solve(3, [\\"eceba\\", \\"ccaabbb\\", \\"aaa\\"]) [4, 6, 3]","solution":"def longest_substring_two_distinct_after_replacement(S): Given a string S, return the length of the longest substring that contains at most two distinct characters after one character replacement. from collections import defaultdict def at_most_k_distinct(s, k): count = defaultdict(int) left = 0 max_len = 0 distinct_count = 0 for right in range(len(s)): if count[s[right]] == 0: distinct_count += 1 count[s[right]] += 1 while distinct_count > k: count[s[left]] -= 1 if count[s[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len # First compute the longest substring with at most 2 distinct characters in current string original_length = at_most_k_distinct(S, 2) # Check if replacing each character can extend the substring max_len_with_replacement = original_length for i in range(len(S)): for replacement in range(26): new_char = chr(ord('a') + replacement) if S[i] != new_char: modified_string = S[:i] + new_char + S[i+1:] max_len_with_replacement = max(max_len_with_replacement, at_most_k_distinct(modified_string, 2)) return max_len_with_replacement def solve(T, test_cases): results = [] for case in test_cases: results.append(longest_substring_two_distinct_after_replacement(case)) return results # Function to parse the input and call the solve function def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:T + 1] results = solve(T, test_cases) for result in results: print(result)"},{"question":"def maxMarblesPerBox(N: int, A: List[int]) -> int: Returns the maximum number of marbles that can be left in each box after redistributing the marbles such that all boxes have the same number of marbles. Args: N (int): The number of boxes. A (List[int]): The number of marbles in each box. Returns: int: The maximum number of marbles per box. Examples: >>> maxMarblesPerBox(3, [6, 8, 10]) 8 >>> maxMarblesPerBox(4, [3, 3, 3, 3]) 3","solution":"def maxMarblesPerBox(N, A): Returns the maximum number of marbles that can be left in each box after redistributing the marbles such that all boxes have the same number of marbles. total_marbles = sum(A) return total_marbles // N"},{"question":"def min_steps_to_target(n, grid, sx, sy, tx, ty): Returns the minimum number of steps required to move the drone from the starting position (sx, sy) to the target position (tx, ty), avoiding obstacles. If there is no path, returns -1. Parameters: n (int): Size of the grid. grid (List[str]): n x n grid where each cell can be '.' (empty) or '#' (obstacle). sx (int): Starting x-coordinate (1-based). sy (int): Starting y-coordinate (1-based). tx (int): Target x-coordinate (1-based). ty (int): Target y-coordinate (1-based). Returns: int: Minimum number of steps required to reach the target, or -1 if there is no possible route. >>> min_steps_to_target(5, [\\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\"], 1, 1, 5, 5) 8 >>> min_steps_to_target(5, [\\".....\\", \\"..#..\\", \\".....\\", \\"..#..\\", \\".....\\"], 1, 1, 3, 3) 4 >>> min_steps_to_target(5, [\\".....\\", \\"#\\", \\".....\\", \\"#\\", \\".....\\"], 1, 1, 5, 5) -1 >>> min_steps_to_target(2, [\\"..\\", \\"..\\"], 1, 1, 2, 2) 2 >>> min_steps_to_target(3, [\\".#.\\", \\".#.\\", \\"...\\"], 1, 1, 3, 3) 4","solution":"from collections import deque def min_steps_to_target(n, grid, sx, sy, tx, ty): Returns the minimum number of steps required to move the drone from the starting position (sx, sy) to the target position (tx, ty), avoiding obstacles. If there is no path, returns -1. # Adjust for 0-based indexing as per Python's list handling sx -= 1 sy -= 1 tx -= 1 ty -= 1 # Directions for moving in 4 possible ways: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == '.' queue = deque([(sx, sy, 0)]) # The queue stores tuples of (current_x, current_y, current_steps) visited = set((sx, sy)) while queue: x, y, steps = queue.popleft() if (x, y) == (tx, ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def determine_winner(x: int) -> str: Determine the winner of the divide-subtract game if both play optimally :param x: The initial number for the game (2 ≤ x ≤ 10^9) :return: \\"Johnny\\" if Johnny wins, \\"Lisa\\" otherwise >>> determine_winner(2) \\"Johnny\\" >>> determine_winner(8) \\"Lisa\\"","solution":"def determine_winner(x): Determine the winner of the game if both play optimally :param x: initial number for the game :return: \\"Johnny\\" if Johnny wins, \\"Lisa\\" otherwise # If x is 2, Johnny wins directly by subtracting 2 if x == 2: return \\"Johnny\\" # For all x greater than 2, the winner is determined by the number of moves: # Johnny wins if the number of moves (or turns) is odd # Lisa wins if the number of moves (or turns) is even # The game reduces the problem to checking if the sequence can be kept even/odd accordingly # Trick: If x is a multiple of 2, Lisa wins by always reducing x to 2 multiple times # Else, Johnny can force the game to be multiple of 2 and take advantage if x % 2 == 0: return \\"Lisa\\" else: return \\"Johnny\\""},{"question":"def max_candies_per_employee(k: int, b: int, candy_batches: List[int]) -> int: Determines the maximum number of candies each employee can receive without any leftovers. Args: k (int): The number of employees. b (int): The number of candy batches. candy_batches (list of int): List of integers where each integer represents the number of candies in a batch. Returns: int: The maximum number of candies each employee can receive without any leftovers. Examples: >>> max_candies_per_employee(5, 4, [10, 20, 25, 30]) 17 >>> max_candies_per_employee(3, 3, [6, 9, 12]) 9","solution":"def max_candies_per_employee(k, b, candy_batches): Determines the maximum number of candies each employee can receive without any leftovers. Args: k (int): The number of employees. b (int): The number of candy batches. candy_batches (list of int): List of integers where each integer represents the number of candies in a batch. Returns: int: The maximum number of candies each employee can receive without any leftovers. total_candies = sum(candy_batches) return total_candies // k"},{"question":"from typing import List, Dict def categorize_expenses(expenses: List[str]) -> Dict[str, float]: Categorize expense transactions based on their description. Args: expenses (List[str]): List of expense strings in the format 'amount_description' Returns: Dict[str, float]: Dictionary with total amount spent per category >>> categorize_expenses([ ... \\"15.50_dinner\\", ... \\"2.75_bus\\", ... \\"8.20_grocery\\", ... \\"10_movies\\", ... \\"5.00_snack\\", ... \\"12.30_train\\", ... \\"4.50_taxi\\", ... \\"3.00_coffee\\" ...]) {'Food': 28.70, 'Transport': 19.55, 'Entertainment': 10.00, 'Misc': 3.00} >>> categorize_expenses([ ... \\"3.50_breakfast\\", ... \\"5.25_lunch\\", ... \\"7.00_dinner\\", ... \\"2.75_snack\\", ... \\"10.00_grocery\\" ...]) {'Food': 28.50, 'Transport': 0.0, 'Entertainment': 0.0, 'Misc': 0.0} >>> categorize_expenses([ ... \\"2.75_bus\\", ... \\"12.30_train\\", ... \\"4.50_taxi\\", ... \\"5.00_fuel\\" ...]) {'Food': 0.0, 'Transport': 24.55, 'Entertainment': 0.0, 'Misc': 0.0} >>> categorize_expenses([ ... \\"10.00_movies\\", ... \\"25.00_concert\\", ... \\"12.75_game\\" ...]) {'Food': 0.0, 'Transport': 0.0, 'Entertainment': 47.75, 'Misc': 0.0} >>> categorize_expenses([ ... \\"15.00_clothes\\", ... \\"20.00_utility\\", ... \\"5.00_coffee\\" ...]) {'Food': 0.0, 'Transport': 0.0, 'Entertainment': 0.0, 'Misc': 40.00}","solution":"from typing import List, Dict def categorize_expenses(expenses: List[str]) -> Dict[str, float]: # Keywords associated with each category categories = { \\"Food\\": [\\"dinner\\", \\"lunch\\", \\"breakfast\\", \\"snack\\", \\"grocery\\"], \\"Transport\\": [\\"bus\\", \\"taxi\\", \\"train\\", \\"fuel\\"], \\"Entertainment\\": [\\"movies\\", \\"concert\\", \\"game\\"], } # Initialize totals for each category totals = { \\"Food\\": 0.0, \\"Transport\\": 0.0, \\"Entertainment\\": 0.0, \\"Misc\\": 0.0, } # Helper function to find the category for a given description def find_category(description: str) -> str: for category, keywords in categories.items(): if any(keyword in description for keyword in keywords): return category return \\"Misc\\" # Process each expense for expense in expenses: amount_str, description = expense.split('_', 1) amount = float(amount_str) category = find_category(description) totals[category] += amount return totals"},{"question":"def count_duplicates(lst): Returns the count of distinct integers that appear more than once in the list. :param lst: List of integers :return: Number of distinct integers with duplicates >>> count_duplicates([1, 2, 3, 4, 5]) 0 >>> count_duplicates([1, 1, 1, 1, 1]) 1 >>> count_duplicates([1, 2, 3, 1, 2, 2]) 2 >>> count_duplicates([]) 0 >>> count_duplicates([1]) 0 >>> count_duplicates([1, 3, 3, 4, 5, 6, 7, 8, 3, 9, 5, 10, 10]) 3","solution":"def count_duplicates(lst): Returns the count of distinct integers that appear more than once in the list. :param lst: List of integers :return: Number of distinct integers with duplicates from collections import Counter count = Counter(lst) return sum(1 for value in count.values() if value > 1)"},{"question":"def calculate_ranks(participants): Returns the rank of each participant based on their points and registration time. Parameters: participants (list of tuples): Each tuple contains (ID, points, registration_time). Returns: list of tuples: Each tuple contains (ID, rank). Examples: >>> calculate_ranks([(1, 100, 5), (2, 200, 3), (3, 100, 2), (4, 200, 1)]) [(4, 1), (2, 2), (3, 3), (1, 4)] >>> calculate_ranks([(1, 150, 4), (2, 150, 7), (3, 200, 2), (4, 150, 5)]) [(3, 1), (1, 2), (4, 3), (2, 4)]","solution":"def calculate_ranks(participants): Returns the rank of each participant based on their points and registration time. Parameters: participants (list of tuples): Each tuple contains (ID, points, registration_time). Returns: list of tuples: Each tuple contains (ID, rank). # Sort participants first by points in descending order, then by registration_time in ascending order sorted_participants = sorted(participants, key=lambda x: (-x[1], x[2])) # Generate the ranks ranked_participants = [(participant[0], idx + 1) for idx, participant in enumerate(sorted_participants)] return ranked_participants"},{"question":"def sort_books(n: int, books: List[str]) -> List[str]: Sort books based on Dewey Decimal number, and alphabetically by title if numbers are the same. Args: n (int): Number of books books (list): List of strings representing books with title and Dewey Decimal number Returns: list: Sorted list of book titles >>> sort_books(3, [\\"The Great Gatsby,823.912\\", \\"To Kill a Mockingbird,813.54\\", \\"1984,823.912\\"]) [\\"1984\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] >>> sort_books(2, [\\"Introduction to Algorithms,005.1\\", \\"Artificial Intelligence: A Modern Approach,006.3\\"]) [\\"Introduction to Algorithms\\", \\"Artificial Intelligence: A Modern Approach\\"]","solution":"def sort_books(n, books): Sort books based on Dewey Decimal number, and alphabetically by title if numbers are the same. Args: n (int): Number of books books (list): List of strings representing books with title and Dewey Decimal number Returns: list: Sorted list of book titles # Define a key function to extract the sorting criteria from each book string def sorting_key(book): title, dewey_decimal = book.rsplit(',', 1) return float(dewey_decimal), title # Sort the books using the sorting key sorted_books = sorted(books, key=sorting_key) # Extract and return only the titles in sorted order return [book.rsplit(',', 1)[0] for book in sorted_books]"},{"question":"def format_rope_length(test_cases): Format the output of rope lengths to be correct up to 2 decimal places. Args: test_cases (list of tuples): A list where each element is a tuple (l, w) Returns: list of strings: The formatted length of the rope required for each parcel. >>> format_rope_length([(10.00, 5.00)]) [\\"30.00\\"] >>> format_rope_length([(10.00, 5.00), (4.20, 3.10)]) [\\"30.00\\", \\"14.60\\"] >>> format_rope_length([(10.123, 5.467)]) [\\"31.18\\"] >>> format_rope_length([(1.00, 1.00)]) [\\"4.00\\"] >>> format_rope_length([(100.00, 100.00)]) [\\"400.00\\"] >>> format_rope_length([(1.50, 2.50), (3.33, 4.44), (5.55, 6.66)]) [\\"8.00\\", \\"15.54\\", \\"24.42\\"]","solution":"def calculate_rope_length(test_cases): Calculate the required length of rope for each test case. Args: test_cases (list of tuples): A list where each element is a tuple (l, w) Returns: list of floats: The length of the rope required for each parcel in the same order as input. results = [] for l, w in test_cases: rope_length = 2 * (l + w) results.append(rope_length) return results def format_rope_length(test_cases): Format the output of rope lengths to be correct up to 2 decimal places. Args: test_cases (list of tuples): A list where each element is a tuple (l, w) Returns: list of strings: The formatted length of the rope required for each parcel. results = calculate_rope_length(test_cases) return [f\\"{result:.2f}\\" for result in results]"},{"question":"def min_hours_to_meet(n: int, a: int, e: int) -> int: Calculate the minimum number of hours required for Alice and Eve to meet at the same station. Parameters: n (int): number of stations. a (int): starting station of Alice. e (int): starting station of Eve. Returns: int: minimum number of hours required for both to meet at the same station. Examples: >>> min_hours_to_meet(5, 1, 3) 2 >>> min_hours_to_meet(6, 2, 5) 3 >>> min_hours_to_meet(7, 4, 4) 0","solution":"def min_hours_to_meet(n, a, e): Returns the minimum number of hours required for Alice and Eve to meet at the same station. Parameters: n (int): number of stations. a (int): starting station of Alice. e (int): starting station of Eve. if a == e: return 0 distance_clockwise = (e - a) % n distance_counterclockwise = (a - e) % n return min(distance_clockwise, distance_counterclockwise)"},{"question":"def sum_of_squares(n: int) -> int: Given an integer n, compute the sum of squares of the first n natural numbers. The sum of squares of the first n natural numbers can be calculated using the formula S(n) = n(n + 1)(2n + 1) / 6. >>> sum_of_squares(4) 30 >>> sum_of_squares(7) 140 >>> sum_of_squares(1) 1 >>> sum_of_squares(100) 338350","solution":"def sum_of_squares(n): Returns the sum of squares of the first n natural numbers. return n * (n + 1) * (2 * n + 1) // 6"},{"question":"from typing import List def min_operations(S1: str, S2: str) -> int: Returns the minimum number of operations required to convert S1 into S2 using insert, delete, and replace operations. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"def\\") 3 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"a\\", \\"\\") 1 >>> min_operations(\\"\\", \\"a\\") 1 pass","solution":"def min_operations(S1, S2): Returns the minimum number of operations required to convert S1 into S2 using insert, delete, and replace operations. m, n = len(S1), len(S2) # Initialize a matrix to store the minimum number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(m + 1): dp[i][0] = i # Deleting all characters from S1 for j in range(n + 1): dp[0][j] = j # Inserting all characters into S1 # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1] # Replacement ) + 1 return dp[m][n]"},{"question":"from typing import Tuple, Optional def is_prime(num: int) -> bool: Returns True if num is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(10) False >>> is_prime(11) True >>> is_prime(1) False >>> is_prime(0) False def closest_primes(n: int) -> Tuple[Optional[int], Optional[int]]: Returns the closest prime numbers less than or equal to \`n\` and greater than or equal to \`n\`. >>> closest_primes(10) (7, 11) >>> closest_primes(17) (17, 17) >>> closest_primes(1) (None, 2) >>> closest_primes(0) (None, 2) >>> closest_primes(11) (11, 11) >>> closest_primes(13) (13, 13) >>> closest_primes(20) (19, 23) def find_closest_primes(n: int): Prints the closest prime numbers less than or equal to \`n\` and greater than or equal to \`n\`. >>> find_closest_primes(10) 7 11 >>> find_closest_primes(17) 17 17 >>> find_closest_primes(1) None 2","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def closest_primes(n): Returns the closest prime numbers less than or equal to \`n\` and greater than or equal to \`n\`. lower_prime, higher_prime = None, None # Find lower prime for i in range(n, 0, -1): if is_prime(i): lower_prime = i break # Find higher prime i = n while not higher_prime: if is_prime(i): higher_prime = i break i += 1 return (lower_prime, higher_prime) def find_closest_primes(n): lower, higher = closest_primes(n) print(lower if lower is not None else \\"None\\") print(higher if higher is not None else \\"None\\")"},{"question":"from typing import List def smallest_lexicographical_order(n: int, lst: List[int]) -> List[int]: Returns the smallest lexicographical order of the list after at most one swap operation. >>> smallest_lexicographical_order(5, [3, 2, 1, 4, 5]) [1, 2, 3, 4, 5] >>> smallest_lexicographical_order(4, [4, 3, 2, 1]) [1, 3, 2, 4]","solution":"def smallest_lexicographical_order(n, lst): Returns the smallest lexicographical order of the list after at most one swap operation. sorted_lst = sorted(lst) if lst == sorted_lst: return lst for i in range(n): if lst[i] != sorted_lst[i]: break min_pos = i for j in range(i + 1, n): if lst[j] <= sorted_lst[i] and (j == n - 1 or lst[j] < sorted_lst[i + 1]): min_pos = j lst[i], lst[min_pos] = lst[min_pos], lst[i] return lst"},{"question":"def min_trucks_required(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: A warehouse manager needs to optimize a set of boxes with different weights to be loaded into trucks. Each truck has a maximum capacity, and the goal is to find the minimum number of trucks required to load all the boxes without exceeding any truck's capacity. -----Input----- - The first line contains a single integer T denoting the number of test cases. The description of T test cases follows. - The first line of each test case contains two integers N (the number of boxes) and C (the maximum capacity of each truck). - The second line contains N space-separated integers representing the weights of the boxes. -----Output----- For each test case, print a single integer, which is the minimum number of trucks required to load all the boxes. -----Example Input----- 2 5 10 1 2 3 4 5 3 8 2 3 6 -----Example Output----- 2 2 >>> min_trucks_required(2, [((5, 10), [1, 2, 3, 4, 5]), ((3, 8), [2, 3, 6])]) [2, 2] >>> min_trucks_required(1, [((1, 1), [1])]) [1]","solution":"def min_trucks_required(T, test_cases): results = [] for case in test_cases: N, C = case[0] weights = case[1] weights.sort(reverse=True) trucks = 0 while weights: current_capacity = C trucks += 1 i = 0 while i < len(weights): if weights[i] <= current_capacity: current_capacity -= weights.pop(i) else: i += 1 results.append(trucks) return results"},{"question":"def calculate_average_and_median(N: int, heights: List[int]) -> Tuple[float, float]: Computes the average and median heights from a list of heights. Args: N (int): The number of students. heights (list of int): The heights of each student. Returns: tuple: A tuple containing the average height and the median height, rounded to two decimal places. Examples: >>> calculate_average_and_median(5, [150, 160, 170, 180, 190]) (170.00, 170.00) >>> calculate_average_and_median(4, [160, 162, 171, 165]) (164.50, 163.50)","solution":"def calculate_average_and_median(N, heights): Computes the average and median heights from a list of heights. Args: N (int): The number of students. heights (list of int): The heights of each student. Returns: tuple: A tuple containing the average height and the median height, rounded to two decimal places. # Calculate average average_height = round(sum(heights) / N, 2) # Calculate median sorted_heights = sorted(heights) if N % 2 == 1: median_height = round(sorted_heights[N // 2], 2) else: median_height = round((sorted_heights[N // 2 - 1] + sorted_heights[N // 2]) / 2, 2) return average_height, median_height"},{"question":"def smallest_subarray_with_given_sum(arr, S): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to S. If no such subarray exists, return 0. >>> smallest_subarray_with_given_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == 2 >>> smallest_subarray_with_given_sum([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_with_given_sum([1, 2, 3, 4, 5], 20) == 0 pass def process_input(input_data): Process the given input data to extract the required parameters and compute the results using the \`smallest_subarray_with_given_sum\` function. >>> process_input(\\"10n15n1 2 3 4 5 6 7 8 9 10n5n11n1 2 3 4 5n0n\\") [2, 3] >>> process_input(\\"5n20n1 2 3 4 5n0n\\") [0] >>> process_input(\\"5n3n1 1 1 1 1n0n\\") [3] pass","solution":"def smallest_subarray_with_given_sum(arr, S): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to S. If no such subarray exists, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0 def process_input(input_data): results = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break i += 1 S = int(lines[i]) i += 1 arr = list(map(int, lines[i].split())) i += 1 results.append(smallest_subarray_with_given_sum(arr, S)) return results"},{"question":"def count_palindromic_substrings(S: str) -> int: Given a string \`S\`, find the number of substrings of \`S\` that are palindromes. >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"aaa\\") == 6 >>> count_palindromic_substrings(\\"racecar\\") == 10","solution":"def count_palindromic_substrings(S): n = len(S) count = 0 # Create a 2D array to store palindromic substrings. dp = [[False] * n for _ in range(n)] for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if S[i] == S[j]: if length == 1 or length == 2: dp[i][j] = True else: dp[i][j] = dp[i + 1][j - 1] if dp[i][j]: count += 1 else: dp[i][j] = False return count"},{"question":"def max_beauty(n: int, s: str) -> int: Given a string \`s\` of length \`n\`, this function returns the maximum beauty among all substrings. Beauty is defined as the number of distinct characters in a substring. >>> max_beauty(7, \\"abcabc\\") == 3 >>> max_beauty(10, \\"aaaaabbbbb\\") == 2 >>> max_beauty(3, \\"xyz\\") == 3","solution":"def max_beauty(n, s): Given a string \`s\` of length \`n\`, this function returns the maximum beauty among all substrings. Beauty is defined as the number of distinct characters in a substring. return len(set(s))"},{"question":"from typing import List, Tuple def calculate_edge_distances(n: int, m: int, weights: List[int], edges: List[Tuple[int, int]]) -> List[int]: Calculates the distance between nodes for each edge in the graph. Args: n (int): Number of nodes. m (int): Number of edges. weights (list): List of node weights. edges (list): List of edges. Returns: list: List of distances for each edge. >>> calculate_edge_distances(4, 3, [3, 2, 1, 4], [(1, 2), (1, 3), (3, 4)]) [5, 4, 5] pass def parse_input(input_string: str) -> Tuple[int, int, List[int], List[Tuple[int, int]]]: Parses the input string to extract the number of nodes, edges, node weights, and the edges. Args: input_string (str): The input string containing n, m, weights, and edges. Returns: Tuple: A tuple containing: - n (int): Number of nodes. - m (int): Number of edges. - weights (list): List of node weights. - edges (list): List of edges. >>> parse_input(\\"4 3n3 2 1 4n1 2n1 3n3 4n\\") (4, 3, [3, 2, 1, 4], [(1, 2), (1, 3), (3, 4)]) pass def main(input_string: str) -> List[int]: Main function to calculate edge distances from input string. Args: input_string (str): The input string containing n, m, weights, and edges. Returns: list: List of distances for each edge. >>> main(\\"4 3n3 2 1 4n1 2n1 3n3 4n\\") [5, 4, 5] pass","solution":"def calculate_edge_distances(n, m, weights, edges): Calculates the distance between nodes for each edge in the graph. Args: n (int): Number of nodes. m (int): Number of edges. weights (list): List of node weights. edges (list): List of edges. Returns: list: List of distances for each edge. distances = [] for edge in edges: u, v = edge distance = weights[u-1] + weights[v-1] distances.append(distance) return distances # Parse input def parse_input(input_string): lines = input_string.split('n') n, m = map(int, lines[0].split()) weights = list(map(int, lines[1].split())) edges = [tuple(map(int, line.split())) for line in lines[2:] if line] return n, m, weights, edges # Main function to be called with input def main(input_string): n, m, weights, edges = parse_input(input_string) distances = calculate_edge_distances(n, m, weights, edges) return distances"},{"question":"def count_permutations(n: int) -> int: Generate a list of all unique permutations of integers from 1 to \`n\` that do not contain three consecutive integers. >>> count_permutations(3) 4 >>> count_permutations(4) 10 >>> count_permutations(5) 13 >>> count_permutations(6) 24 >>> count_permutations(10) 274 # Unit Tests def test_count_permutations(): assert count_permutations(1) == 1 assert count_permutations(2) == 2 assert count_permutations(3) == 4 assert count_permutations(4) == 10 assert count_permutations(5) == 13 assert count_permutations(6) == 24 assert count_permutations(10) == 274 def test_modulo(): large_result = count_permutations(1000) assert large_result < 1000000007 # Running tests test_count_permutations() test_modulo()","solution":"MOD = 1000000007 def count_permutations(n): if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 # Dynamic programming table to store results dp = [0] * (n + 1) # Base cases dp[1] = 1 dp[2] = 2 dp[3] = 4 for i in range(4, n + 1): dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD return dp[n]"},{"question":"def count_arrangements(n: int) -> int: Return the number of ways to arrange n pumpkins in an n x n grid. This is simply the number of permutations of n elements, which is n!. >>> count_arrangements(1) 1 >>> count_arrangements(2) 2 >>> count_arrangements(3) 6 >>> count_arrangements(4) 24","solution":"def count_arrangements(n): Return the number of ways to arrange n pumpkins in an n x n grid. This is simply the number of permutations of n elements, which is n!. from math import factorial return factorial(n)"},{"question":"def elevator_system(current_floor: int, direction: str, requests: list, total_floors: int) -> list: Simulates the operations of an elevator in a multi-story building. Args: current_floor (int): The current floor at which the elevator is positioned. direction (str): The current moving direction of the elevator ('UP' or 'DOWN'). requests (list): A list of floor requests that the elevator has to serve. total_floors (int): The total number of floors in the building. Returns: list: A list of floors representing the order of floors the elevator will visit. Examples: >>> elevator_system(5, \\"UP\\", [1, 3, 7, 9], 10) [7, 9, 3, 1] >>> elevator_system(2, \\"DOWN\\", [8, 6, 4, 1], 10) [1, 4, 6, 8]","solution":"def elevator_system(current_floor: int, direction: str, requests: list, total_floors: int) -> list: up_requests = sorted([floor for floor in requests if floor > current_floor]) down_requests = sorted([floor for floor in requests if floor < current_floor], reverse=True) if direction == \\"UP\\": if not up_requests: return down_requests + up_requests return up_requests + down_requests else: # direction == \\"DOWN\\" if not down_requests: return up_requests + down_requests return down_requests + up_requests"},{"question":"from typing import List, Tuple class SegmentTree: def __init__(self, data): Initialize the segment tree with the given array data. self.n = len(data) self.tree = [0] * (2 * self.n) def update(self, index, value): Update the element at the specified index to the new value. pass def query(self, left, right): Query the minimum element in the subarray from index left to index right (inclusive). pass def process_operations(n: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a series of update and query operations on an array. Args: n (int): The number of elements in the array. array (List[int]): The elements of the array. operations (List[Tuple[int, int, int]]): The operations to be performed. Returns: List[int]: Results of the query operations. >>> process_operations(5, [10, 2, 5, 7, 4], [(2, 1, 3), (1, 2, 1), (2, 1, 3), (2, 0, 4)]) [2, 1, 1] >>> process_operations(3, [3, 1, 2], [(1, 0, 4)]) [] >>> process_operations(4, [1, 3, 5, 7], [(2, 0, 2)]) [1] >>> process_operations(5, [8, 7, 6, 9, 3], [(1, 2, 1), (2, 1, 3), (1, 4, 2), (2, 0, 4)]) [1, 1] >>> process_operations(1, [5], [(2, 0, 0)]) [5] >>> process_operations(2, [1, 2], [(2, 0, 1), (1, 0, 3), (2, 0, 1)]) [1, 2] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): # Update the leaf node index += self.n self.tree[index] = value # Update internal nodes while index > 1: index //= 2 self.tree[index] = min(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left, right): # Query the minimum value in the range [left, right] result = float('inf') left += self.n right += self.n + 1 while left < right: if left % 2 == 1: result = min(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = min(result, self.tree[right]) left //= 2 right //= 2 return result def process_operations(n, array, operations): seg_tree = SegmentTree(array) results = [] for operation in operations: if operation[0] == 1: # Update operation _, i, x = operation seg_tree.update(i, x) elif operation[0] == 2: # Query operation _, l, r = operation results.append(seg_tree.query(l, r)) return results # Example usage: n = 5 array = [10, 2, 5, 7, 4] operations = [(2, 1, 3), (1, 2, 1), (2, 1, 3), (2, 0, 4)] print(process_operations(n, array, operations))"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determine if the given string can be reordered to form a palindrome. A string is a palindrome if it reads the same backward as forward. Only consider alphanumeric characters and ignore cases. Args: s (str): The input string Returns: bool: True if the string can be reordered to form a palindrome, False otherwise. Examples: >>> is_palindrome_permutation(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome_permutation(\\"race a car\\") False >>> is_palindrome_permutation(\\"civic\\") True >>> is_palindrome_permutation(\\"ivicc\\") True >>> is_palindrome_permutation(\\"hello\\") False >>> is_palindrome_permutation(\\"Able was I Ere I Saw Elba\\") True","solution":"def is_palindrome_permutation(s: str) -> bool: from collections import Counter import re # Remove non-alphanumeric characters and convert to lower case filtered_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Count the frequency of each character freq = Counter(filtered_s) # A string can be permuted to a palindrome if at most one character has an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def min_hours_to_complete_tasks(n: int, hours: List[int], m: int, prerequisites: List[Tuple[int, int]]) -> int: Determine the minimum number of hours required to complete all tasks. Parameters: n (int): The number of tasks. hours (List[int]): List where the ith integer represents the number of hours required to complete the ith task. m (int): The number of prerequisites. prerequisites (List[Tuple[int, int]]): List of tuples where each tuple (u, v) means task v cannot start until task u is completed. Returns: int: The minimum number of hours required to complete all tasks. Examples: >>> min_hours_to_complete_tasks(3, [3, 2, 1], 2, [(1, 2), (2, 3)]) == 6 >>> min_hours_to_complete_tasks(4, [1, 2, 3, 2], 3, [(1, 2), (1, 3), (3, 4)]) == 6 >>> min_hours_to_complete_tasks(5, [1, 2, 3, 4, 5], 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 15 >>> min_hours_to_complete_tasks(3, [3, 2, 1], 0, []) == 3 >>> min_hours_to_complete_tasks(1, [5], 0, []) == 5 >>> min_hours_to_complete_tasks(4, [2, 3, 4, 5], 0, []) == 5","solution":"from collections import defaultdict, deque def min_hours_to_complete_tasks(n, hours, m, prerequisites): graph = defaultdict(list) in_degree = [0] * n for u, v in prerequisites: graph[u-1].append(v-1) in_degree[v-1] += 1 queue = deque() completion_time = [0] * n for i in range(n): if in_degree[i] == 0: queue.append(i) completion_time[i] = hours[i] while queue: task = queue.popleft() for neighbor in graph[task]: in_degree[neighbor] -= 1 completion_time[neighbor] = max(completion_time[neighbor], completion_time[task] + hours[neighbor]) if in_degree[neighbor] == 0: queue.append(neighbor) return max(completion_time) # Example usage if __name__ == \\"__main__\\": n = 4 hours = [1, 2, 3, 2] m = 3 prerequisites = [(1, 2), (1, 3), (3, 4)] print(min_hours_to_complete_tasks(n, hours, m, prerequisites)) # Output: 6"},{"question":"def get_unique_sorted_gifts(n: int, gifts: List[int]) -> List[int]: Given a number n and a list of gifts represented by integers, return a sorted list of unique gifts. >>> get_unique_sorted_gifts(5, [4, 1, 2, 3, 3]) [1, 2, 3, 4] >>> get_unique_sorted_gifts(6, [10, 5, 5, 5, 1, 7]) [1, 5, 7, 10]","solution":"def get_unique_sorted_gifts(n, gifts): Given a number n and a list of gifts represented by integers, return a sorted list of unique gifts. unique_gifts = sorted(set(gifts)) return unique_gifts"},{"question":"def find_lowest_point(n, m, grid): Returns the coordinates of the lowest point in the grid. Parameters: n (int): the number of rows in the grid m (int): the number of columns in the grid grid (List[List[int]]): 2D list representing the grid where each cell contains a height Returns: Tuple[int, int]: the coordinates (1-based) of the lowest point in the grid Examples: >>> find_lowest_point(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (1, 1) >>> find_lowest_point(4, 4, [[10, 20, 30, 40], [50, 5, 60, 70], [5, 80, 90, 100], [5, 110, 120, 130]]) (2, 2) >>> find_lowest_point(2, 5, [[3, 3, 3, 3, 3], [3, 3, 3, 2, 3]]) (2, 4)","solution":"def find_lowest_point(n, m, grid): Returns the coordinates of the lowest point in the grid. min_height = float('inf') min_coords = (1, 1) for i in range(n): for j in range(m): if grid[i][j] < min_height: min_height = grid[i][j] min_coords = (i + 1, j + 1) elif grid[i][j] == min_height: if (i + 1, j + 1) < min_coords: min_coords = (i + 1, j + 1) return min_coords"},{"question":"def can_alice_reach_n(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if Alice can reach position n from position 0, given the sequence of steps. Alice can move from position p to position (p + 1) if (p + 1) exists and contains a step. Alice can jump from position p to position (p + 2) if (p + 2) exists and both positions p and (p + 1) contain steps. Parameters: t (int): the number of test cases test_cases (List[Tuple[int, List[int]]]): a list of test cases, each consisting of an integer n and a list of n integers indicating the presence of steps. Returns: List[str]: \\"YES\\" if Alice can reach position n, \\"NO\\" otherwise Examples: >>> can_alice_reach_n(2, [(5, [1, 1, 0, 1, 1]), (3, [1, 0, 1])]) [\\"NO\\", \\"NO\\"] >>> can_alice_reach_n(1, [(5, [1, 1, 1, 1, 1])]) [\\"YES\\"]","solution":"def can_alice_reach_n(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] positions = test_cases[i][1] if positions[0] == 0: results.append(\\"NO\\") continue reachable = [False] * n reachable[0] = True for j in range(n - 1): if reachable[j]: if j + 1 < n and positions[j + 1] == 1: reachable[j + 1] = True if j + 2 < n and positions[j + 1] == 1 and positions[j + 2] == 1: reachable[j + 2] = True if reachable[-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_palindrome(s: str) -> str: Determine if the string is a palindrome, ignoring cases and non-alphanumeric characters. Input: s: string which only contains digits and letters (1 ≤ |s| ≤ 1000) Output: \\"YES\\" if the given string is a palindrome, and \\"NO\\" otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == \\"YES\\" >>> is_palindrome(\\"race a car\\") == \\"NO\\"","solution":"def is_palindrome(s): Determine if the string is a palindrome, ignoring cases and non-alphanumeric characters. :param s: Input string containing digits and letters. :return: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list is the same forwards and backwards if filtered_chars == filtered_chars[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def frequency_spread(N: int, A: List[int]) -> int: Compute the frequency spread of a given array A of length N. Args: N (int): The length of the array. A (List[int]): The array of integers. Returns: int: The frequency spread of the array. >>> frequency_spread(6, [4, 5, 6, 4, 6, 4]) == 2 >>> frequency_spread(5, [1, 2, 3, 4, 5]) == 0 >>> frequency_spread(4, [7, 7, 7, 7]) == 0 >>> frequency_spread(7, [1, 2, 2, 3, 3, 3, 4]) == 2 >>> frequency_spread(2, [1, 2]) == 0 from collections import Counter def test_example_case(): assert frequency_spread(6, [4, 5, 6, 4, 6, 4]) == 2 def test_all_elements_unique(): assert frequency_spread(5, [1, 2, 3, 4, 5]) == 0 def test_all_elements_same(): assert frequency_spread(4, [7, 7, 7, 7]) == 0 def test_mixed_elements(): assert frequency_spread(7, [1, 2, 2, 3, 3, 3, 4]) == 2 def test_large_input(): N = 100000 A = [i % 5 for i in range(N)] assert frequency_spread(N, A) == 0 def test_two_elements(): assert frequency_spread(2, [1, 2]) == 0","solution":"def frequency_spread(N, A): from collections import Counter # Count the frequency of each element in the array frequency = Counter(A) # Get the maximum and minimum frequency max_freq = max(frequency.values()) min_freq = min(frequency.values()) # Return the frequency spread return max_freq - min_freq"},{"question":"def can_obtain_by_rotation(s: str, t: str) -> str: Check if you can make the string \`t\` by rotating the string \`s\` any number of times. Args: s: str - The original string. t: str - The target string to obtain by rotation. Returns: str: \\"YES\\" if \`t\` can be obtained by any number of rotations on \`s\`, otherwise \\"NO\\". >>> can_obtain_by_rotation(\\"abcde\\", \\"cdeab\\") \\"YES\\" >>> can_obtain_by_rotation(\\"abcde\\", \\"abced\\") \\"NO\\" pass def process_test_cases(test_cases: list) -> list: Process multiple test cases to determine if one string can be obtained by rotating another. Args: test_cases: list of tuples - A list of tuples where each tuple contains two strings \`s\` and \`t\`. Returns: list: A list of results where each result is \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases([(\\"abcde\\", \\"cdeab\\"), (\\"abcde\\", \\"abced\\"), (\\"aa\\", \\"aa\\")]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def can_obtain_by_rotation(s, t): Checks if string \`t\` can be obtained by rotating string \`s\`. if len(s) != len(t): return \\"NO\\" # Concatenate s with itself and check if t is a substring of it doubled_s = s + s if t in doubled_s: return \\"YES\\" else: return \\"NO\\" def process_test_cases(test_cases): results = [] for s, t in test_cases: results.append(can_obtain_by_rotation(s, t)) return results"},{"question":"def ferry_loading(datasets): Determine the minimum number of trips required to transport all vehicles across the river. Args: datasets (List[Tuple[int, int, List[int]]]): A list of tuples, where each tuple contains: - L (int): the length of the ferry - N (int): the number of vehicles - vehicles (List[int]): a list of integers representing the lengths of the vehicles Returns: List[int]: A list of integers representing the minimum number of trips for each dataset >>> datasets = [ ... (10, 4, [4, 4, 4, 4]), ... (10, 5, [6, 5, 4, 3, 2]), ... (15, 3, [6, 7, 5]) ... ] >>> ferry_loading(datasets) [2, 3, 2]","solution":"def ferry_loading(datasets): results = [] for L, N, vehicles in datasets: if L == 0 and N == 0: break trips = 0 current_length = 0 for vehicle in vehicles: if current_length + vehicle > L: trips += 1 current_length = vehicle else: current_length += vehicle if current_length > 0: trips += 1 results.append(trips) return results"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Calculate the shortest path from 'S' to 'E' in the given grid. Returns the length of the path if a valid path exists, otherwise returns -1. >>> shortest_path(5, 5, ['S...#', '..#.#', '#..', '..#.E', '.....#']) 9 >>> shortest_path(5, 5, ['S#...', '#...#', '#.#.#', '.#.#E', '.....']) -1 >>> shortest_path(1, 3, ['S#E']) -1 >>> shortest_path(5, 5, ['S....', '.....', '.....', '.....', '....E']) 8 >>> shortest_path(1, 2, ['SE']) 1","solution":"from collections import deque def shortest_path(n, m, grid): Calculate the shortest path from 'S' to 'E' in the given grid. Returns the length of the path if a valid path exists, otherwise returns -1. # Directions for moving right, left, up, down directions = [(0, 1), (0, -1), (-1, 0), (1, 0)] # BFS initialization queue = deque() visited = [[False] * m for _ in range(n)] # Find the start 'S' and end 'E' positions start = end = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) if grid[i][j] == 'E': end = (i, j) # Enqueue the start position with a distance of 0 queue.append((start[0], start[1], 0)) visited[start[0]][start[1]] = True while queue: x, y, dist = queue.popleft() # If we reach the end position, return the distance if (x, y) == end: return dist # Check for all possible movements for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] != '#': queue.append((nx, ny, dist + 1)) visited[nx][ny] = True # If no path is found, return -1 return -1"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(29) True >>> is_prime(30) False def largest_prime_less_than(n: int): Find the largest prime number less than n. >>> largest_prime_less_than(10) 7 >>> largest_prime_less_than(20) 19 >>> largest_prime_less_than(2) \\"No prime number found\\" >>> largest_prime_less_than(3) 2 >>> largest_prime_less_than(1) \\"No prime number found\\" >>> largest_prime_less_than(100) 97 >>> largest_prime_less_than(101) 97","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def largest_prime_less_than(n): if n <= 2: return \\"No prime number found\\" for i in range(n - 1, 1, -1): if is_prime(i): return i return \\"No prime number found\\""},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. d: The dictionary to flatten. parent_key: The key string built so far (used for recursion). sep: The separator between key segments. >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3, \\"f\\": 4}}}) {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4} >>> flatten_dict({}) {} >>> flatten_dict({ \\"num\\": 1, \\"nest\\": { \\"str\\": \\"hello\\", \\"bool\\": True, \\"none\\": None, \\"dict\\": { \\"list\\": [1, 2, 3] } } }) { \\"num\\": 1, \\"nest.str\\": \\"hello\\", \\"nest.bool\\": True, \\"nest.none\\": None, \\"nest.dict.list\\": [1, 2, 3] } >>> flatten_dict({ \\"a\\": { \\"b\\": 1, \\"c\\": { \\"d\\": 2 } } }, sep='|') { \\"a|b\\": 1, \\"a|c|d\\": 2 } # Your code here","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. d: The dictionary to flatten. parent_key: The key string built so far (used for recursion). sep: The separator between key segments. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def max_earnings(t: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[int]: John has launched a new delivery service and he needs to manage his delivery trucks efficiently. John has N delivery trucks where each truck can carry up to W kilograms of parcels. On a particular day, there are M parcels to be delivered where each parcel weighs P kilograms. Given that John earns Q rupees for each parcel delivered, find the maximum amount he can earn on that day. >>> max_earnings(4, [(3, 50, 20, 5, 30), (2, 100, 10, 10, 50), (5, 40, 50, 8, 20), (1, 60, 9, 15, 25)]) [600, 500, 800, 100]","solution":"def max_earnings(t, test_cases): results = [] for case in test_cases: N, W, M, P, Q = case total_capacity = N * W total_parcel_weight = M * P if total_parcel_weight <= total_capacity: earnings = M * Q else: max_parcels_capacity = total_capacity // P earnings = max_parcels_capacity * Q results.append(earnings) return results"},{"question":"def can_frog_cross(stones): Determines if the frog can reach the last stone from the first stone Args: stones (List[int]): List of non-negative integers representing the maximum jump length from each stone. Returns: str: \\"Possible\\" if the frog can reach the last stone, \\"Impossible\\" otherwise. >>> can_frog_cross([2, 3, 1, 1, 4]) 'Possible' >>> can_frog_cross([3, 2, 1, 0, 4]) 'Impossible' pass def process_test_cases(test_cases): Processes multiple test cases and determines if the frog can cross for each. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of stones and the list of non-negative integers representing the max jump length from each stone. Returns: List[str]: List of results for each test case. >>> process_test_cases([(5, [2, 3, 1, 1, 4]), (6, [3, 2, 1, 0, 4, 2])]) ['Possible', 'Impossible'] pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) stones = list(map(int, data[index + 1: index + 1 + N])) index += N + 1 test_cases.append((N, stones)) results = process_test_cases(test_cases) for result in results: print(result)","solution":"def can_frog_cross(stones): Determines if the frog can reach the last stone from the first stone n = len(stones) reachable = 0 for i in range(n): if i > reachable: return \\"Impossible\\" reachable = max(reachable, i + stones[i]) if reachable >= n - 1: return \\"Possible\\" return \\"Possible\\" if reachable >= n - 1 else \\"Impossible\\" def process_test_cases(test_cases): results = [] for case in test_cases: n, stones = case result = can_frog_cross(stones) results.append(result) return results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) stones = list(map(int, data[index + 1: index + 1 + N])) index += N + 1 test_cases.append((N, stones)) results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def longest_unique_substring_length(T: str) -> int: Finds the length of the longest substring in T where no character repeats. Parameters: T (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring with no repeating characters. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"bbbbb\\") 1 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"aab\\") 2 >>> longest_unique_substring_length(\\"dvdf\\") 3 >>> longest_unique_substring_length(\\"anviaj\\") 5 >>> longest_unique_substring_length(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> longest_unique_substring_length(\\"aa\\") 1 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"aabbcc\\") 2 >>> longest_unique_substring_length(\\"\\") 0","solution":"def longest_unique_substring_length(T): Finds the length of the longest substring in T where no character repeats. Parameters: T (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring with no repeating characters. n = len(T) max_len = 0 start = 0 char_index_map = {} for end in range(n): if T[end] in char_index_map: start = max(start, char_index_map[T[end]] + 1) char_index_map[T[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there isn't any non-repeating character, returns '_'. >>> first_non_repeating_character(\\"leetcode\\") == 'l' >>> first_non_repeating_character(\\"aabb\\") == '_'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there isn't any non-repeating character, returns '_'. from collections import Counter counter = Counter(s) for char in s: if counter[char] == 1: return char return '_'"},{"question":"def process_email_requests(datasets): Processes multiple datasets of email templates and email requests. Replaces placeholders in the templates with actual values from the requests and generates list of final email subjects and bodies. >>> process_email_requests([[2, 'New Year Offer', 2, '{discount_code}', '{expiry_date}', 'Meeting Reminder', 1, '{date}', 3, 1, 'SAVE20', '31/12/2023', 1, 'DISCOUNT10', '15/01/2024', 2, '12/11/2023']]) 'New Year OffernSAVE20n31/12/2023nnNew Year OffernDISCOUNT10n15/01/2024nnMeeting Remindern12/11/2023' >>> process_email_requests([[2, 'Newsletter', 1, '{month}', 'Invitation', 2, '{event}', '{date}', 2, 1, 'July', 2, 'Meeting', '15/08/2023']]) 'NewsletternJulynnInvitationnMeetingn15/08/2023'","solution":"def process_email_requests(datasets): Processes multiple datasets of email templates and email requests. Replaces placeholders in the templates with actual values from the requests and generates list of final email subjects and bodies. result = [] for dataset in datasets: # Email templates processing template_count = dataset[0] templates = [] idx = 1 for _ in range(template_count): subject = dataset[idx] idx += 1 placeholder_count = dataset[idx] idx += 1 placeholder_list = [] for _ in range(placeholder_count): placeholder = dataset[idx] placeholder_list.append(placeholder) idx += 1 templates.append((subject, placeholder_list)) # Email requests processing request_count = dataset[idx] idx += 1 for _ in range(request_count): template_id = dataset[idx] idx += 1 values = [] for _ in range(len(templates[template_id - 1][1])): values.append(dataset[idx]) idx += 1 subject = templates[template_id - 1][0] body = \\"n\\".join(values) result.append(f\\"{subject}n{body}\\") return \\"nn\\".join(result)"},{"question":"def find_subset_sum(arr, sum_val): Finds a subset of arr that adds up to sum_val, if any exists. Returns the subset in any order, or an empty list if no such subset exists. >>> find_subset_sum([3, 34, 4, 12, 5, 2], 9) == [4, 5] >>> find_subset_sum([1, 2, 3, 7, 8], 11) == [3, 8] >>> find_subset_sum([1, 5, 3, 7], 17) == []","solution":"def find_subset_sum(arr, sum_val): Finds a subset of arr that adds up to sum_val, if any exists. Returns the subset in any order, or an empty list if no such subset exists. def subset_sum_recursive(arr, sum_val, n, current_set): if sum_val == 0: return current_set if n == 0: return [] if arr[n-1] > sum_val: return subset_sum_recursive(arr, sum_val, n-1, current_set) included = subset_sum_recursive(arr, sum_val - arr[n-1], n-1, current_set + [arr[n-1]]) if included: return included excluded = subset_sum_recursive(arr, sum_val, n-1, current_set) return excluded return subset_sum_recursive(arr, sum_val, len(arr), [])"},{"question":"def find_lonely_integers(N: int, sequence: List[int]) -> List[int]: Returns all lonely integers in ascending order. Args: N (int): the number of integers in the sequence. sequence (List[int]): a list of N integers. Returns: List[int]: a list of all lonely integers in ascending order. If there are no lonely integers, return [-1]. Example: >>> find_lonely_integers(7, [4, 3, 2, 7, 8, 3, 2]) [4, 7, 8] >>> find_lonely_integers(6, [1, 2, 2, 3, 3, 4]) [1, 4]","solution":"def find_lonely_integers(N, sequence): Returns all lonely integers in ascending order. from collections import Counter # Create a counter to count occurrences of each integer count = Counter(sequence) # Extract lonely integers lonely_integers = [num for num in count if count[num] == 1] if not lonely_integers: return [-1] # Return the sorted list of lonely integers return sorted(lonely_integers)"},{"question":"def can_form(word, s): Helper function to determine if a word can be formed by deleting some characters of string s without reordering the remaining characters. pass def longest_word(s, word_list): Given a list of words, finds and returns the longest word that can be formed by deleting some characters of the given string \`s\` without reordering the remaining characters. If there are more than one possible results, returns the one which appears first in the \`word_list\`. Returns an empty string if no words from the \`word_list\` can be formed. >>> longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" pass","solution":"def can_form(word, s): Helper function to determine if a word can be formed by deleting some characters of string s without reordering the remaining characters. it = iter(s) return all(char in it for char in word) def longest_word(s, word_list): Returns the longest word that can be formed by deleting some characters of the given string \`s\` without reordering the remaining characters. If there are multiple words with the same length, returns the one that appears first in the \`word_list\`. eligible_words = [word for word in word_list if can_form(word, s)] eligible_words.sort(key=lambda x: (-len(x), word_list.index(x))) return eligible_words[0] if eligible_words else \\"\\""},{"question":"def count_islands(N, M, grid): Count the number of distinct islands in a grid of '0's and '1's. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (list of list of str): The grid representation where '1' represents land and '0' represents water. Returns: int: The number of distinct islands. Test cases: >>> count_islands(4, 5, [list(\\"11000\\"), list(\\"11000\\"), list(\\"00100\\"), list(\\"00011\\")]) 3 >>> count_islands(3, 3, [list(\\"111\\"), list(\\"010\\"), list(\\"111\\")]) 1 >>> count_islands(3, 3, [list(\\"000\\"), list(\\"000\\"), list(\\"000\\")]) 0 >>> count_islands(3, 3, [list(\\"111\\"), list(\\"111\\"), list(\\"111\\")]) 1 >>> count_islands(3, 3, [list(\\"100\\"), list(\\"000\\"), list(\\"000\\")]) 1 >>> count_islands(3, 3, [list(\\"101\\"), list(\\"010\\"), list(\\"101\\")]) 5","solution":"def count_islands(N, M, grid): Count the number of distinct islands in a grid of '0's and '1's. def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= M or grid[x][y] == '0': return grid[x][y] = '0' # Mark the land as visited by sinking the island # Check all four directions (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) num_islands = 0 for i in range(N): for j in range(M): if grid[i][j] == '1': num_islands += 1 dfs(i, j) return num_islands"},{"question":"def check_rectangular_path(n: int, m: int, grid: List[str]) -> str: Check if there exists a rectangular path in the grid such that all cells along the path are '1's. >>> check_rectangular_path(4, 5, [ ... '11011', ... '11011', ... '11111', ... '01110' ... ]) == \\"Yes\\" >>> check_rectangular_path(3, 3, [ ... '100', ... '010', ... '001' ... ]) == \\"No\\"","solution":"def check_rectangular_path(n, m, grid): This function checks if there exists a rectangular path such that all the cells along the path are '1's. for r1 in range(n): for r2 in range(r1 + 1, n): for c1 in range(m): for c2 in range(c1 + 1, m): if grid[r1][c1] == '1' and grid[r1][c2] == '1' and grid[r2][c1] == '1' and grid[r2][c2] == '1': return \\"Yes\\" return \\"No\\""},{"question":"def min_transformations(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, determine the minimum number of transformations needed to make all elements of the array equal. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of elements and the array itself. Returns: List[int]: A list of results, where each result corresponds to the minimum number of transformations for each test case, or -1 if it is not possible. >>> min_transformations(2, [(4, [1, 2, 3, 2]), (5, [1, 3, 2, 4, 1])]) [-1, -1] >>> min_transformations(1, [(4, [2, 2, 2, 2])]) [0]","solution":"def min_transformations(T, test_cases): results = [] for test in test_cases: n, arr = test # A helper function to check if all elements are the same if len(set(arr)) == 1: results.append(0) else: possible = False for i in range(1, n-1): if arr[i] != arr[i-1] or arr[i] != arr[i+1]: possible = True break if possible: # If transformations would be possible in some scenario where neighbors are sorted around the center value. results.append(-1) else: results.append(0) return results"},{"question":"def longestConsecutiveSequence(arr: List[int]) -> int: Return the length of the longest consecutive sequence in an unsorted array. >>> longestConsecutiveSequence([100, 4, 200, 1, 3, 2]) 4 >>> longestConsecutiveSequence([0, -1, 1, 2, 3, -2, -3, -4]) 8 >>> longestConsecutiveSequence([]) 0 >>> longestConsecutiveSequence([1]) 1 >>> longestConsecutiveSequence([5, 5, 5, 5]) 1 >>> longestConsecutiveSequence([10, 30, 20, 40]) 1 >>> longestConsecutiveSequence([1, 9, 3, 10, 4, 20, 2, 5, 6, 8, 7]) 10 >>> longestConsecutiveSequence(list(range(1, 100001))) 100000 pass","solution":"def longestConsecutiveSequence(arr): Return the length of the longest consecutive sequence in an unsorted array. if not arr: return 0 nums_set = set(arr) longest_streak = 0 for num in nums_set: # Only start counting when you see the beginning of a sequence if num - 1 not in nums_set: current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def minimum_swaps_to_sort(books): Returns the minimum number of adjacent swaps required to sort the books. :param books: A list of integers representing heights of the books. :return: Integer, the minimum number of adjacent swaps required to sort the books in ascending order. >>> minimum_swaps_to_sort([3, 2, 1]) 3 >>> minimum_swaps_to_sort([4, 3, 2, 1]) 6 >>> minimum_swaps_to_sort([1, 2, 3]) 0 >>> minimum_swaps_to_sort([2, 1, 3, 4]) 1 def process_test_cases(T, test_cases): Processes multiple test cases to determine the minimum number of swaps required for each. :param T: Number of test cases. :param test_cases: List of tuples where each tuple contains the integer N and a list of books' heights. :return: List of integers, each indicating the minimum number of adjacent swaps required for the respective test case. >>> process_test_cases(2, [(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) [3, 6] >>> process_test_cases(2, [(3, [1, 2, 3]), (4, [2, 1, 3, 4])]) [0, 1] >>> process_test_cases(2, [(5, [5, 4, 3, 2, 1]), (3, [2, 3, 1])]) [10, 2]","solution":"def minimum_swaps_to_sort(books): Returns the minimum number of adjacent swaps required to sort the books. n = len(books) swaps = 0 # Using bubble sort to count the number of swaps for i in range(n): for j in range(0, n-i-1): if books[j] > books[j+1]: # Swap books[j] and books[j+1] books[j], books[j+1] = books[j+1], books[j] swaps += 1 return swaps def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] books = test_cases[i][1] results.append(minimum_swaps_to_sort(books)) return results"},{"question":"from typing import List def trapWater(heights: List[int]) -> int: Calculate the total amount of water that can be trapped after raining given a list of building heights. Args: heights (List[int]): A list of non-negative integers representing the heights of the buildings. Returns: int: The total amount of trapped water. Examples: >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trapWater([4, 2, 0, 3, 2, 5]) 9 >>> trapWater([]) 0 >>> trapWater([3, 3, 3]) 0 >>> trapWater([5]) 0 >>> trapWater([5, 5]) 0 >>> trapWater([3, 0, 2, 0, 4]) 7","solution":"from typing import List def trapWater(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def can_accommodate_groups(n: int, m: int, grid: List[List[int]], groups: List[Tuple[int, int, int, int]]) -> str: Determine if it is possible to accommodate all groups in their preferred cells without exceeding the capacity. >>> can_accommodate_groups(3, 3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]], [(1, 1, 1, 2), (2, 1, 1, 1), (3, 2, 2, 3)]) == \\"YES\\" >>> can_accommodate_groups(2, 2, [[2, 3], [3, 3]], [(1, 1, 1, 1), (2, 1, 1, 2)]) == \\"NO\\"","solution":"def can_accommodate_groups(n, m, grid, groups): # A dictionary to hold the future reservations in each cell reservations = {} for t, x, y, p in groups: if (x, y) not in reservations: reservations[(x, y)] = [] reservations[(x, y)].append((t, p)) for x in range(1, n + 1): for y in range(1, n + 1): if (x, y) in reservations: reserved_people = 0 reservations[(x, y)].sort() # Sort by time for t, p in reservations[(x, y)]: reserved_people += p if reserved_people > grid[x-1][y-1]: return \\"NO\\" return \\"YES\\" # Input reading and function execution import sys input = sys.stdin.read def main(): data = input().split() index = 0 n = int(data[index]) m = int(data[index + 1]) index += 2 grid = [] for i in range(n): grid.append([int(data[index + j]) for j in range(n)]) index += n groups = [] for i in range(m): t = int(data[index]) x = int(data[index + 1]) y = int(data[index + 2]) p = int(data[index + 3]) groups.append((t, x, y, p)) index += 4 print(can_accommodate_groups(n, m, grid, groups)) if __name__ == '__main__': main()"},{"question":"def largest_possible_difference(arr): Function to find the largest possible difference between two elements in the list where one element is greater than the other and appears after it. >>> largest_possible_difference([2, 3, 1, 7]) == 6 >>> largest_possible_difference([0, 0, 0, 1]) == 1 >>> largest_possible_difference([0, 0, 0]) == 0 >>> largest_possible_difference([5]) == 0 >>> largest_possible_difference([5, 5]) == 0 >>> largest_possible_difference([4, 3, 2, 1]) == 0 >>> largest_possible_difference([1, 1000000]) == 999999 >>> largest_possible_difference([1, 2, 1000000]) == 999999 >>> largest_possible_difference([1, 4, 7, 2, 10]) == 9","solution":"def largest_possible_difference(arr): Function to find the largest possible difference between two elements in the list where one element is greater than the other and appears after it. if not arr or len(arr) < 2: return 0 # No valid difference can be found if there are less than 2 elements min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) else: min_element = arr[i] return max_diff"},{"question":"import math from typing import List def calculate_sum_of_square_roots(arr1: List[int], arr2: List[int]) -> List[float]: Returns a new array arr3 such that for each valid index i, arr3[i] = sqrt(arr1[i]) + sqrt(arr2[i]), formatted to 4 decimal places. Parameters: - arr1: List[int] - arr2: List[int] Returns: - List[float] >>> calculate_sum_of_square_roots([1, 4, 9, 16], [1, 4, 9, 16]) [2.0000, 4.0000, 6.0000, 8.0000] >>> calculate_sum_of_square_roots([1], [4]) [3.0000] >>> calculate_sum_of_square_roots([1000000000, 500000000, 250000000], [1000000000, 500000000, 250000000]) [63245.5539, 44721.3595, 31622.7766] >>> calculate_sum_of_square_roots([2, 8, 27, 64], [5, 12, 18, 30]) [3.6503, 6.1909, 9.2342, 12.4829]","solution":"import math def calculate_sum_of_square_roots(arr1, arr2): Returns a new array arr3 such that for each valid index i, arr3[i] = sqrt(arr1[i]) + sqrt(arr2[i]), formatted to 4 decimal places. Parameters: - arr1: List[int] - arr2: List[int] Returns: - List[float] arr3 = [] for i in range(len(arr1)): sum_of_roots = math.sqrt(arr1[i]) + math.sqrt(arr2[i]) arr3.append(round(sum_of_roots, 4)) return arr3"},{"question":"def find_smallest_positive_sum(B): Given an array B consisting of M integers, find the smallest positive integer X such that there exists at least one contiguous subarray within B whose sum equals X. If no such sum exists, return \\"Not Possible\\". Args: - B (List[int]): A list of integers representing the array. Returns: - int or str: The smallest positive integer X if such X exists, otherwise \\"Not Possible\\". Examples: >>> find_smallest_positive_sum([1, 2, 3]) 1 >>> find_smallest_positive_sum([1, -2, 3, 4]) 1 >>> find_smallest_positive_sum([-1, -1, -1, -1, -1]) \\"Not Possible\\" pass def process_test_cases(Q, test_cases): Process Q test cases with arrays of integers. For each test case, determine the smallest positive integer X such that there exists a contiguous subarray in the array with sum X. Args: - Q (int): Number of test cases. - test_cases (List[List[int]]): A list of lists, where each inner list represents a test case array. Returns: - List[Union[int, str]]: A list of results for each test case. Examples: >>> Q = 3 >>> test_cases = [[1, 2, 3], [1, -2, 3, 4], [-1, -1, -1, -1, -1]] >>> process_test_cases(Q, test_cases) [1, 1, \\"Not Possible\\"] pass","solution":"def find_smallest_positive_sum(B): Returns the smallest positive integer X such that there exists at least one contiguous subarray within B whose sum equals X. If no such sum exists, returns \\"Not Possible\\". M = len(B) min_positive_sum = float('inf') possible = False # Check all subarrays for start in range(M): current_sum = 0 for end in range(start, M): current_sum += B[end] if current_sum > 0: possible = True min_positive_sum = min(min_positive_sum, current_sum) return min_positive_sum if possible else \\"Not Possible\\" def process_test_cases(Q, test_cases): Process Q test cases where each test case is a list of integers B. Returns a list of results for each test case. results = [] for i in range(Q): B = test_cases[i] result = find_smallest_positive_sum(B) results.append(result) return results"},{"question":"def max_toy_cars(wheels: int, windows: int, chassis: int) -> int: Given the quantities of wheels, windows, and chassis, determine the maximum number of toy cars that can be built. Each toy car consists of: - 4 wheels - 2 windows - 1 chassis >>> max_toy_cars(10, 8, 3) 2 >>> max_toy_cars(0, 0, 0) 0 >>> max_toy_cars(4, 0, 0) 0 >>> max_toy_cars(0, 2, 0) 0 >>> max_toy_cars(0, 0, 1) 0 >>> max_toy_cars(12, 8, 2) 2 >>> max_toy_cars(4, 6, 7) 1 >>> max_toy_cars(16, 2, 5) 1 >>> max_toy_cars(10000, 10000, 10000) 2500 >>> max_toy_cars(100000, 50000, 25000) 25000 >>> max_toy_cars(99999, 50000, 25000) 24999 >>> max_toy_cars(100, 2, 1) 1 >>> max_toy_cars(4, 20, 1) 1 >>> max_toy_cars(4, 8, 5) 1","solution":"def max_toy_cars(wheels, windows, chassis): Returns the maximum number of toy cars that can be built given the quantities of wheels, windows, and chassis. return min(wheels // 4, windows // 2, chassis) # Testing the function with an example print(max_toy_cars(10, 8, 3)) # Expected output: 2"},{"question":"def longest_subsequence(n: int, k: int, arr: List[int]) -> int: Finds the length of the longest subsequence with elements sorted in increasing order and the difference between any two consecutive elements is at least k. >>> longest_subsequence(5, 3, [1, 5, 3, 9, 7]) == 3 >>> longest_subsequence(6, 2, [10, 20, 30, 40, 50, 60]) == 6 from typing import List def test_longest_subsequence_example1(): assert longest_subsequence(5, 3, [1, 5, 3, 9, 7]) == 3 def test_longest_subsequence_example2(): assert longest_subsequence(6, 2, [10, 20, 30, 40, 50, 60]) == 6 def test_longest_subsequence_all_elements_identical(): assert longest_subsequence(4, 1, [5, 5, 5, 5]) == 1 def test_longest_subsequence_no_valid_subsequence(): assert longest_subsequence(3, 10, [1, 2, 3]) == 1 def test_longest_subsequence_single_element(): assert longest_subsequence(1, 1, [42]) == 1 def test_longest_subsequence_min_difference_zero(): assert longest_subsequence(5, 0, [1, 5, 3, 9, 7]) == 5 def test_longest_subsequence_large_difference(): assert longest_subsequence(5, 100, [1, 5, 3, 9, 7]) == 1","solution":"def longest_subsequence(n, k, arr): Finds the longest subsequence where the elements are sorted in increasing order and the difference between any two consecutive elements is at least k. # Sort the array first arr.sort() # The dp array where dp[i] represents the longest subsequence ending with arr[i] dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] - arr[j] >= k: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest subsequence return max(dp)"},{"question":"def minSteps(N: int, arr: List[int]) -> int: Returns the minimum number of steps required to make all elements of the array equal. :param N: int, number of elements in the array :param arr: list of int, the array elements :return: int, minimum number of steps required >>> minSteps(4, [1, 2, 3, 6]) 6 >>> minSteps(3, [10, 10, 10]) 0 from solution import minSteps def test_minSteps_example1(): assert minSteps(4, [1, 2, 3, 6]) == 6 def test_minSteps_example2(): assert minSteps(3, [10, 10, 10]) == 0 def test_minSteps_single_element(): assert minSteps(1, [100]) == 0 def test_minSteps_all_same(): assert minSteps(5, [5, 5, 5, 5, 5]) == 0 def test_minSteps_large_numbers(): assert minSteps(3, [-1000000, 0, 1000000]) == 2000000 def test_minSteps_negative_numbers(): assert minSteps(5, [-1, -2, -3, -4, -1]) == 5 def test_minSteps_large_array(): import random arr = [random.randint(-10**6, 10**6) for _ in range(100000)] # Since it's large, just ensure the function terminates without error assert isinstance(minSteps(100000, arr), int)","solution":"def minSteps(N, arr): Returns the minimum number of steps required to make all elements of the array equal. :param N: int, number of elements in the array :param arr: list of int, the array elements :return: int, minimum number of steps required arr.sort() median = arr[N//2] steps = sum(abs(x - median) for x in arr) return steps"},{"question":"def is_prime(n): Determines if n is a prime number. Returns True if n is prime, else False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def process_numbers(numbers): Takes a list of integers and determines if each is a prime. Prints \\"Prime\\" or \\"Not Prime\\" for each number until -1 is encountered. >>> process_numbers([11, 15, 18, 23, -1]) Prime Not Prime Not Prime Prime","solution":"def is_prime(n): Determines if n is a prime number. Returns True if n is prime, else False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def process_numbers(numbers): Takes a list of integers and determines if each is a prime. Prints \\"Prime\\" or \\"Not Prime\\" for each number until -1 is encountered. for number in numbers: if number == -1: break if is_prime(number): print(\\"Prime\\") else: print(\\"Not Prime\\")"},{"question":"from typing import List def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Count the number of unique paths that the robot can take to reach the bottom-right corner of the grid. >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles(2, 2, [[0, 1], [1, 0]]) 0 def solve(t: int, cases: List[tuple]) -> List[int]: Solve multiple test cases of the unique path problem with obstacles. >>> solve(2, [(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), (2, 2, [[0, 1], [1, 0]])]) [2, 0] def test_unique_paths_no_obstacles(): assert unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 def test_unique_paths_blocked_start(): assert unique_paths_with_obstacles(2, 2, [[1, 0], [0, 0]]) == 0 def test_unique_paths_blocked_end(): assert unique_paths_with_obstacles(2, 2, [[0, 0], [0, 1]]) == 0 def test_unique_paths_single_element_clear(): assert unique_paths_with_obstacles(1, 1, [[0]]) == 1 def test_unique_paths_single_element_blocked(): assert unique_paths_with_obstacles(1, 1, [[1]]) == 0 def test_solve_multiple_cases(): test_cases = [ (3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), (2, 2, [[0, 1], [1, 0]]) ] assert solve(2, test_cases) == [2, 0]","solution":"def unique_paths_with_obstacles(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 # Starting point for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] def solve(t, cases): results = [] for case in cases: m, n, grid = case results.append(unique_paths_with_obstacles(m, n, grid)) return results"},{"question":"def sum_of_unique_numbers(N, M, grid): Returns the sum of all unique integer values present in the N x M grid. :param N: Number of rows in the grid :param M: Number of columns in the grid :param grid: List of lists containing integers representing the grid :return: Sum of unique integers in the grid >>> sum_of_unique_numbers(3, 3, [[1, 2, 3], [4, 1, 5], [6, 7, 2]]) == 28 >>> sum_of_unique_numbers(2, 2, [[1, 2], [3, 4]]) == 10 >>> sum_of_unique_numbers(2, 2, [[1, 1], [1, 1]]) == 1 >>> sum_of_unique_numbers(3, 3, [[-1000, 500, 0], [999, -999, 250], [-500, 1000, 750]]) == 0 + 500 + 999 + -999 + 250 + -500 + 1000 + 750 - 1000 >>> sum_of_unique_numbers(1, 1, [[42]]) == 42","solution":"def sum_of_unique_numbers(N, M, grid): Returns the sum of all unique integer values present in the N x M grid. :param N: Number of rows in the grid :param M: Number of columns in the grid :param grid: List of lists containing integers representing the grid :return: Sum of unique integers in the grid unique_numbers = set() for row in grid: for num in row: unique_numbers.add(num) return sum(unique_numbers)"},{"question":"def summarize_catalog_system(T, test_cases): Create a summary of the library section based on genres and keywords. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): Each test case consists of the number of books and a list of strings that describe each book with its genre followed by keywords. Returns: List[str]: The list of genres and their associated keywords in alphabetical order, formatted as specified. Examples: >>> summarize_catalog_system(1, [(3, [\\"ScienceFiction alien spaceship future\\", \\"Fantasy magic dragon adventure\\", \\"ScienceFiction future space travel\\"])]) ['Fantasy', ' adventure dragon magic', 'ScienceFiction', ' alien future space spaceship travel'] >>> summarize_catalog_system(1, [(2, [\\"Romance love story\\", \\"Romance relationship emotion\\"])]) ['Romance', ' emotion love relationship story']","solution":"def summarize_catalog_system(T, test_cases): results = [] for case in test_cases: N, books = case genre_keywords = {} for book in books: G, *K = book.split() if G not in genre_keywords: genre_keywords[G] = set() genre_keywords[G].update(K) for genre in sorted(genre_keywords.keys()): results.append(genre) results.append(\\" \\" + \\" \\".join(sorted(genre_keywords[genre]))) return results"},{"question":"def subsets(nums): Given a list of integers, return all possible subsets of the list. Note: The solution set must not contain duplicate subsets. Return the solution in any order. Args: nums (list): List of integers. Returns: list: List of all possible subsets. Examples: >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> subsets([0]) [[], [0]] from solution import subsets def test_subsets_empty(): assert subsets([]) == [[]] def test_subsets_single_element(): assert subsets([0]) == [[], [0]] def test_subsets_two_elements(): result = subsets([1, 2]) assert len(result) == 4 assert sorted(result) == sorted([[], [1], [2], [1, 2]]) def test_subsets_three_elements(): result = subsets([1, 2, 3]) assert len(result) == 8 expected_subsets = [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert sorted(result) == sorted(expected_subsets) def test_subsets_duplicates(): result = subsets([1, 2, 2]) assert len(result) == 8 expected_subsets = [[], [1], [2], [1, 2], [2, 2], [1, 2, 2]] assert set(map(frozenset, result)) == set(map(frozenset, expected_subsets))","solution":"from itertools import combinations def subsets(nums): Given a list of integers, return all possible subsets of the list. The solution set must not contain duplicate subsets. Return the solution in any order. Args: nums (list): List of integers. Returns: list: List of all possible subsets. res = [] for i in range(len(nums) + 1): for subset in combinations(nums, i): res.append(list(subset)) return res"},{"question":"from typing import List def merge_and_remove_duplicates(n: int, list1: List[int], m: int, list2: List[int]) -> List[int]: Merges two lists and removes duplicates while preserving the order from the original lists. Args: n (int): Number of integers in the first list. list1 (List[int]): The first list of integers. m (int): Number of integers in the second list. list2 (List[int]): The second list of integers. Returns: List[int]: The merged list with duplicates removed. >>> merge_and_remove_duplicates(3, [1, 2, 3], 4, [3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_and_remove_duplicates(5, [4, 5, 6, 7, 8], 4, [5, 8, 9, 10]) [4, 5, 6, 7, 8, 9, 10] >>> merge_and_remove_duplicates(3, [1, 1, 1], 3, [1, 1, 1]) [1] >>> merge_and_remove_duplicates(3, [2, 3, 4], 3, [5, 1, 2]) [2, 3, 4, 5, 1] >>> merge_and_remove_duplicates(0, [], 3, [3, 4, 5]) [3, 4, 5] >>> merge_and_remove_duplicates(3, [1, 2, 3], 0, []) [1, 2, 3] >>> merge_and_remove_duplicates(0, [], 0, []) [] >>> merge_and_remove_duplicates(1000, list(range(1, 1001)), 1000, list(range(500, 1501))) list(range(1, 1501))","solution":"def merge_and_remove_duplicates(n, list1, m, list2): Merges two lists and removes duplicates while preserving the order from the original lists. Args: n (int): Number of integers in the first list. list1 (list of int): The first list of integers. m (int): Number of integers in the second list. list2 (list of int): The second list of integers. Returns: list of int: The merged list with duplicates removed. seen = set() merged_list = [] for num in list1 + list2: if num not in seen: seen.add(num) merged_list.append(num) return merged_list"},{"question":"def find_shortest_path(n: int, m: int, bus_lines: List[Tuple[int, int]], s: int, t: int) -> int: Determines the shortest path, in terms of the number of bus lines, between two given bus stops. >>> find_shortest_path(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5) 4 >>> find_shortest_path(4, 4, [(1, 2), (2, 3), (3, 4)], 1, 3) 2 >>> find_shortest_path(4, 2, [(1, 2), (3, 4)], 1, 3) -1 >>> find_shortest_path(4, 3, [(1, 2), (2, 3), (3, 4)], 2, 2) 0 >>> find_shortest_path(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)], 1, 5) 1 pass","solution":"from collections import deque, defaultdict def find_shortest_path(n, m, bus_lines, s, t): if s == t: return 0 # Create an adjacency list to represent the bus stops and bus lines graph = defaultdict(list) for u, v in bus_lines: graph[u].append(v) graph[v].append(u) # Perform BFS to find the shortest path queue = deque([(s, 0)]) # (current stop, bus lines taken) visited = set() visited.add(s) while queue: current_stop, distance = queue.popleft() for neighbor in graph[current_stop]: if neighbor not in visited: if neighbor == t: return distance + 1 queue.append((neighbor, distance + 1)) visited.add(neighbor) return -1"},{"question":"def sort_transactions(transactions): Sorts the transaction history by the timestamp in ascending order and by the amount in descending order within that timestamp. Args: transactions (list of tuples): A list where each tuple contains two integers, a timestamp and a transaction amount. Returns: list of tuples: The sorted list of transactions. Example: >>> transactions = [ ... (1001, 500), ... (1002, 800), ... (1001, 200), ... (1002, 400), ... (1003, 700) ... ] >>> sort_transactions(transactions) [(1001, 500), (1001, 200), (1002, 800), (1002, 400), (1003, 700)] >>> transactions = [ ... (500, 300), ... (500, 900), ... (500, 100) ... ] >>> sort_transactions(transactions) [(500, 900), (500, 300), (500, 100)]","solution":"def sort_transactions(transactions): Sorts the transaction history by the timestamp in ascending order and by the amount in descending order within that timestamp. Args: transactions (list of tuples): A list where each tuple contains two integers, a timestamp and a transaction amount. Returns: list of tuples: The sorted list of transactions. # Sorting by timestamp (ascending) and amount (descending) return sorted(transactions, key=lambda x: (x[0], -x[1])) # Example input transactions = [ (1001, 500), (1002, 800), (1001, 200), (1002, 400), (1003, 700) ] # Function call to test sorted_transactions = sort_transactions(transactions) # Output the sorted list for t in sorted_transactions: print(f\\"{t[0]} {t[1]}\\")"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given mathematical expression string in infix notation. The string will contain integers and the operators +, -, *, / as well as parentheses for nested operations. The expression will be well-formed with no spaces between characters unless they are part of the integers. >>> evaluate_expression(\\"1+2*(3+4)\\") == 15 >>> evaluate_expression(\\"(2+3)*(4+(5*6))\\") == 148 >>> evaluate_expression(\\"10/(5-3)\\") == 5 pass # Unit tests def test_simple_addition(): assert evaluate_expression(\\"1+1\\") == 2 def test_simple_subtraction(): assert evaluate_expression(\\"2-1\\") == 1 def test_simple_multiplication(): assert evaluate_expression(\\"2*3\\") == 6 def test_simple_division(): assert evaluate_expression(\\"8/2\\") == 4 def test_expression_with_parentheses(): assert evaluate_expression(\\"(1+2)*3\\") == 9 def test_expression_with_nested_parentheses(): assert evaluate_expression(\\"2*(3+(4*5))\\") == 46 def test_expression_with_multiple_operators(): assert evaluate_expression(\\"2+3*4\\") == 14 def test_expression_with_division_and_subtraction(): assert evaluate_expression(\\"10/(5-3)\\") == 5 def test_expression_with_addition_and_subtraction(): assert evaluate_expression(\\"1+2-3+4\\") == 4 def test_expression_complex(): assert evaluate_expression(\\"1+2*(3+4)-(5/(6-3))\\") == 14","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': # Integer division that truncates towards zero values.append(int(left / right)) def precedence(operator): if operator in ('+', '-'): return 1 if operator in ('*', '/'): return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operator(operators, values) operators.pop() # remove '(' else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"def min_flips(cards: str) -> int: Given a string of 'R' and 'B', this function returns the minimum number of card flips required to make all cards show the same color on top. >>> min_flips(\\"RBRB\\") 2 >>> min_flips(\\"RRBB\\") 2 >>> min_flips(\\"BBBB\\") 0 >>> min_flips(\\"RRRR\\") 0 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the list of results. >>> process_test_cases(3, [\\"RBRB\\", \\"RRBB\\", \\"BBBB\\"]) [2, 2, 0] >>> process_test_cases(3, [\\"RRRR\\", \\"BBBB\\", \\"RBRBRB\\"]) [0, 0, 3]","solution":"def min_flips(cards): Given a string of 'R' and 'B', this function returns the minimum number of card flips required to make all cards show the same color on top. # Count the occurrences of 'R' and 'B' count_R = cards.count('R') count_B = cards.count('B') # The minimum number of flips needed will be the minimum of the two counts return min(count_R, count_B) def process_test_cases(T, test_cases): Processes multiple test cases and returns the list of results. results = [] for case in test_cases: results.append(min_flips(case)) return results"},{"question":"from typing import List def count_unique_messages(s: str) -> int: Counts the number of unique valid messages that can be generated by replacing the placeholders '#' (for consonants) and '@' (for vowels) in the given string s. >>> count_unique_messages('#') == 21 >>> count_unique_messages('@') == 5 >>> count_unique_messages('') == 21 * 21 >>> count_unique_messages('@@') == 5 * 5 >>> count_unique_messages('#@') == 21 * 5 >>> count_unique_messages('@#') == 5 * 21 >>> count_unique_messages('h#ll@') == 21 * 5 >>> count_unique_messages('myst#c@rypt#') == 21 * 5 * 21 >>> count_unique_messages('a@eioujklmnpqrst#') == 5 * 21 >>> count_unique_messages('abcdefgh') == 1 >>> count_unique_messages('zyxwvut') == 1","solution":"def count_unique_messages(s): Counts the number of unique valid messages that can be generated by replacing the placeholders '#' (for consonants) and '@' (for vowels) in the given string s. consonants_count = 21 vowels_count = 5 unique_messages = 1 for char in s: if char == '#': unique_messages *= consonants_count elif char == '@': unique_messages *= vowels_count return unique_messages"},{"question":"def special_prime_sequences(T: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determines the lexicographically smallest sequence of length N containing exactly M prime numbers for each test case. If no such sequence exists, returns \\"SEQUENCE IMPOSSIBLE\\". >>> special_prime_sequences(3, [(2, 1), (4, 2), (5, 6)]) ['2 1', '2 3 1 1', 'SEQUENCE IMPOSSIBLE'] >>> special_prime_sequences(3, [(10, 0), (10, 1), (10, 10)]) ['1 1 1 1 1 1 1 1 1 1', '2 1 1 1 1 1 1 1 1 1', '2 3 5 7 11 13 17 19 23 29']","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes_up_to(n): Generate all prime numbers up to a given number n. primes = [2] candidate = 3 while candidate <= n: if is_prime(candidate): primes.append(candidate) candidate += 2 return primes def lexicographically_smallest_sequence(N, M): Generates the lexicographically smallest sequence of length N with exactly M primes. if M > N: return \\"SEQUENCE IMPOSSIBLE\\" sequence = [] primes = generate_primes_up_to(100000) # Generate a list of primes up to some large number if M > len(primes): return \\"SEQUENCE IMPOSSIBLE\\" primes_needed = primes[:M] non_primes_needed = [1] * (N - M) sequence = primes_needed + non_primes_needed return \\" \\".join(map(str, sequence)) def special_prime_sequences(T, test_cases): results = [] for N, M in test_cases: result = lexicographically_smallest_sequence(N, M) results.append(result) return results"},{"question":"import math from typing import List, Tuple def find_min_bloom_days(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of days after which all types of plants bloom simultaneously. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples where each tuple contains: - an integer N representing the number of plant types - a list of N integers representing the growth cycles of each type of plant Returns: List[int] : a list of integers where each integer represents the minimum number of days for the corresponding test case when all plants will bloom simultaneously. Example: >>> find_min_bloom_days(2, [(3, [2, 3, 4]), (2, [3, 5])]) [12, 15]","solution":"import math def lcm(a, b): return abs(a * b) // math.gcd(a, b) def find_min_bloom_days(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] cycles = test_cases[i][1] result = cycles[0] for j in range(1, N): result = lcm(result, cycles[j]) results.append(result) return results"},{"question":"def min_enclosing_circle_radius(n, r, checkpoints): Computes the minimum enclosing circle's radius that can cover all given checkpoints. Parameters: n (int): Number of checkpoints. r (int): Radius of the given circular track. checkpoints (list): List of tuples where each tuple contains coordinates (x_i, y_i) of a checkpoint. Returns: int: The radius of the minimum enclosing circle covering all checkpoints. >>> min_enclosing_circle_radius(3, 10, [(10, 0), (0, 10), (-10, 0)]) 10 >>> min_enclosing_circle_radius(2, 5, [(5, 0), (-5, 0)]) 5 >>> min_enclosing_circle_radius(4, 8, [(8, 0), (0, 8), (-8, 0), (0, -8)]) 8 >>> min_enclosing_circle_radius(1, 100, [(70, 70), (70, -70), (-70, 70), (-70, -70)]) 100 >>> min_enclosing_circle_radius(2, 1000000000, [(1000000000, 0), (-1000000000, 0)]) 1000000000","solution":"def min_enclosing_circle_radius(n, r, checkpoints): Computes the minimum enclosing circle's radius that can cover all given checkpoints. Parameters: n (int): Number of checkpoints. r (int): Radius of the given circular track. checkpoints (list): List of tuples where each tuple contains coordinates (x_i, y_i) of a checkpoint. Returns: int: The radius of the minimum enclosing circle covering all checkpoints. # All points lie on the boundary of the circle, hence # the radius of the minimum enclosing circle is simply the given radius r. return r"},{"question":"def autocomplete(dictionary_words: List[str], queries: List[str]) -> List[List[str]]: Autocompletes the queries based on the dictionary words. Returns a list of predictions for each query. :param dictionary_words: List of words in the dictionary :param queries: List of query strings :return: List of lists, where each sublist contains the matched dictionary words for a query # Your code here from solution import autocomplete def test_autocomplete_case1(): dictionary = [\\"apple\\", \\"application\\", \\"apricot\\", \\"banana\\", \\"berry\\", \\"cherry\\", \\"date\\"] queries = [\\"app\\", \\"ban\\", \\"ca\\", \\"z\\"] expected = [ [\\"apple\\", \\"application\\"], [\\"banana\\"], [], [] ] assert autocomplete(dictionary, queries) == expected def test_autocomplete_case2(): dictionary = [\\"dog\\", \\"deer\\", \\"deal\\", \\"cat\\", \\"cattle\\", \\"bat\\", \\"ball\\"] queries = [\\"de\\", \\"cat\\", \\"ba\\"] expected = [ [\\"deal\\", \\"deer\\"], [\\"cat\\", \\"cattle\\"], [\\"ball\\", \\"bat\\"] ] assert autocomplete(dictionary, queries) == expected def test_autocomplete_empty_query(): dictionary = [\\"apple\\", \\"application\\", \\"banana\\", \\"berry\\"] queries = [\\"\\"] expected = [ [\\"apple\\", \\"application\\", \\"banana\\", \\"berry\\"] ] assert autocomplete(dictionary, queries) == expected def test_autocomplete_no_match(): dictionary = [\\"alpha\\", \\"beta\\", \\"gamma\\"] queries = [\\"delta\\"] expected = [ [] ] assert autocomplete(dictionary, queries) == expected def test_autocomplete_exact_match(): dictionary = [\\"test\\", \\"testing\\", \\"tester\\"] queries = [\\"test\\"] expected = [ [\\"test\\", \\"tester\\", \\"testing\\"] ] assert autocomplete(dictionary, queries) == expected","solution":"def autocomplete(dictionary_words, queries): Autocompletes the queries based on the dictionary words. Returns a list of predictions for each query. :param dictionary_words: List of words in the dictionary :param queries: List of query strings :return: List of lists, where each sublist contains the matched dictionary words for a query # Sort the dictionary words lexicographically dictionary_words.sort() results = [] for query in queries: matched_words = [] for word in dictionary_words: if word.startswith(query): matched_words.append(word) elif word > query: break results.append(matched_words) return results"},{"question":"def solve_magic_land(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimum number of swaps required to sort the potion volumes in non-decreasing order. Args: t (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): List of test cases, each containing the number of bottles and their volumes Returns: List[int]: List of integers representing the minimum number of swaps for each test case >>> solve_magic_land(2, [(5, [4, 3, 1, 2, 5]), (3, [3, 1, 2])]) [3, 2] >>> solve_magic_land(2, [(5, [1, 2, 3, 4, 5]), (1, [1])]) [0, 0]","solution":"def min_swaps(arr): Returns the minimum number of swaps required to sort the array. n = len(arr) arrpos = [(value, i) for (i, value) in enumerate(arr)] arrpos.sort() # Sort the array by value vis = {i: False for i in range(n)} # Mark all nodes as not visited ans = 0 for i in range(n): # already in the correct place or already visited if vis[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not vis[j]: vis[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans def solve_magic_land(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(min_swaps(arr)) return results"},{"question":"def max_element_after_shifts(n: int, k: int, sequence: List[int]) -> int: Returns the largest possible value of the maximum element in the sequence after k shift operations. In one shift operation, a pair of consecutive elements in the sequence can be chosen and the left element's value added to the right element's value. Parameters: n (int): The length of the sequence. k (int): The number of shift operations to perform. sequence (List[int]): The initial list of non-negative integers. Returns: int: The maximum possible value of any element in the sequence after k shifts. >>> max_element_after_shifts(5, 3, [1, 2, 3, 4, 5]) 18 >>> max_element_after_shifts(6, 5, [1, 1, 1, 1, 1, 1]) 11 >>> max_element_after_shifts(1, 3, [5]) 8 >>> max_element_after_shifts(4, 2, [0, 0, 0, 0]) 2 >>> max_element_after_shifts(3, 1, [1000000000, 1000000000, 1000000000]) 3000000001","solution":"def max_element_after_shifts(n, k, sequence): Returns the largest possible value of the maximum element in the sequence after k shift operations. In one shift operation, a pair of consecutive elements in the sequence can be chosen and the left element's value added to the right element's value. Parameters: n (int): The length of the sequence. k (int): The number of shift operations to perform. sequence (list of int): The initial list of non-negative integers. Returns: int: The maximum possible value of any element in the sequence after k shifts. # Sum all elements in the sequence total_sum = sum(sequence) # Since we can make k shifts, the largest possible single element after k shifts # would be the sum of all elements in the sequence plus the number of shifts. result = total_sum + k return result"},{"question":"from typing import List def maximalSquare(matrix: List[List[int]]) -> int: Find the largest square containing all ones and returns its area in a given 2D grid. Args: matrix (List[List[int]]): A list of lists of integers representing the 2D grid. Returns: int: An integer representing the area of the largest square containing all ones. >>> maximalSquare([[1,0,1,1,1],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]) 9 >>> maximalSquare([[0,1],[1,0]]) 1 >>> maximalSquare([[0,0,0,1]]) 1 pass","solution":"from typing import List def maximalSquare(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] max_side = 0 for i in range(m): for j in range(n): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 # On the first row/column, the largest square ends here is the cell itself if it is 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def min_sections_to_collect_items(N: int, M: int, items: List[int]) -> int: Determine the minimum number of sections needed to collect at least M items. Parameters: N (int): The number of sections. M (int): The total number of items needed. items (list of int): The number of items in each section. Returns: int: The minimum number of sections required. >>> min_sections_to_collect_items(4, 10, [3, 8, 2, 1]) 2 >>> min_sections_to_collect_items(6, 15, [5, 5, 5, 5, 5, 5]) 3 >>> min_sections_to_collect_items(1, 1, [1]) 1 >>> min_sections_to_collect_items(3, 10, [4, 3, 2]) 3 >>> min_sections_to_collect_items(5, 10, [1, 2, 8, 9, 3]) 2 >>> min_sections_to_collect_items(5, 20, [4, 4, 4, 4, 5]) 5 >>> min_sections_to_collect_items(4, 10, [10, 1, 1, 1]) 1 pass","solution":"def min_sections_to_collect_items(N, M, items): Determine the minimum number of sections needed to collect at least M items. Parameters: N (int): The number of sections. M (int): The total number of items needed. items (list of int): The number of items in each section. Returns: int: The minimum number of sections required. # Sort sections by the number of items in descending order items.sort(reverse=True) total_items = 0 sections_count = 0 for num in items: total_items += num sections_count += 1 if total_items >= M: return sections_count return sections_count # Example usage # N, M = 4, 10 # items = [3, 8, 2, 1] # print(min_sections_to_collect_items(N, M, items)) # Output: 2"},{"question":"def reverseWords(s: str) -> str: Reverses the characters in each word within a sentence while preserving whitespace and initial word order. :param s: the input sentence :type s: str :return: the modified sentence with characters of each word reversed :rtype: str pass # Test cases def test_reverseWords(): assert reverseWords(\\"The quick brown fox\\") == \\"ehT kciuq nworb xof\\" assert reverseWords(\\"hello world\\") == \\"olleh dlrow\\" assert reverseWords(\\"\\") == \\"\\" assert reverseWords(\\"a\\") == \\"a\\" assert reverseWords(\\"ab cd ef\\") == \\"ba dc fe\\" assert reverseWords(\\"Python is fun\\") == \\"nohtyP si nuf\\" assert reverseWords(\\"A B C\\") == \\"A B C\\" assert reverseWords(\\"This is a test\\") == \\"sihT si a tset\\" assert reverseWords(\\"123 456 789\\") == \\"321 654 987\\" assert reverseWords(\\"palindrome\\") == \\"emordnilap\\"","solution":"def reverseWords(s): Reverses the characters in each word within a sentence while preserving whitespace and initial word order. :param s: the input sentence :type s: str :return: the modified sentence with characters of each word reversed :rtype: str # Split the sentence into words words = s.split() # Reverse each word and join them back with a space reversed_words = ' '.join(word[::-1] for word in words) return reversed_words"},{"question":"def game_solver(t: int, cases: List[Tuple[int, ...]]) -> List[int]: Determines the maximum possible sum that the first player can collect assuming both players play optimally. >>> game_solver(2, [(4, 1, 2, 9, 4), (3, 4, 4, 5)]) [10, 9] >>> game_solver(1, [(1, 7)]) [7] >>> game_solver(1, [(2, 5, 3)]) [5] >>> game_solver(1, [(4, 10, 10, 10, 10)]) [20] >>> game_solver(1, [(5, 1000, 1000, 1000, 1000, 1000)]) [3000] >>> game_solver(1, [(10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)]) [30]","solution":"def max_first_player_sum(test_cases): results = [] for array in test_cases: n = len(array) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = array[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(array[i] - dp[i + 1][j], array[j] - dp[i][j - 1]) first_player_sum = (sum(array) + dp[0][n - 1]) // 2 results.append(first_player_sum) return results # Helper function to parse input and return output in correct format def game_solver(t, cases): test_cases = [case[1:] for case in cases] results = max_first_player_sum(test_cases) return results"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array where each element is the product of all the elements in the input array except the element at the same index. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) [24, 0, 0, 0, 0] >>> product_except_self([-1, 1, -1, 1]) [-1, 1, -1, 1] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([5]) [1]","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the input array except the element at the same index. n = len(nums) # Initialize the output array with 1s output = [1] * n # Calculate the prefix products prefix_product = 1 for i in range(n): output[i] = prefix_product prefix_product *= nums[i] # Calculate the suffix products suffix_product = 1 for i in range(n-1, -1, -1): output[i] *= suffix_product suffix_product *= nums[i] return output"},{"question":"def check_prime_likes(n: int) -> str: Determine if the number of likes is a prime number. Parameters: n (int): The number of likes (1 ≤ n ≤ 1,000,000) Returns: str: \\"Special Mention!\\" if n is a prime number, \\"Keep Trying!\\" otherwise. Examples: >>> check_prime_likes(5) \\"Special Mention!\\" >>> check_prime_likes(10) \\"Keep Trying!\\" >>> check_prime_likes(29) \\"Special Mention!\\" >>> check_prime_likes(100) \\"Keep Trying!\\" pass from solution import check_prime_likes def test_check_prime_likes_small_numbers(): assert check_prime_likes(1) == \\"Keep Trying!\\" assert check_prime_likes(2) == \\"Special Mention!\\" assert check_prime_likes(3) == \\"Special Mention!\\" assert check_prime_likes(4) == \\"Keep Trying!\\" def test_check_prime_likes_prime_numbers(): assert check_prime_likes(5) == \\"Special Mention!\\" assert check_prime_likes(7) == \\"Special Mention!\\" assert check_prime_likes(13) == \\"Special Mention!\\" assert check_prime_likes(29) == \\"Special Mention!\\" def test_check_prime_likes_non_prime_numbers(): assert check_prime_likes(10) == \\"Keep Trying!\\" assert check_prime_likes(25) == \\"Keep Trying!\\" assert check_prime_likes(100) == \\"Keep Trying!\\" assert check_prime_likes(200) == \\"Keep Trying!\\" def test_check_prime_likes_large_prime_number(): assert check_prime_likes(999983) == \\"Special Mention!\\" # 999983 is a prime number def test_check_prime_likes_large_non_prime_number(): assert check_prime_likes(1000000) == \\"Keep Trying!\\" # 1000000 is not a prime number","solution":"def check_prime_likes(n: int) -> str: Determine if the number of likes is a prime number. Parameters: n (int): The number of likes (1 ≤ n ≤ 1,000,000) Returns: str: \\"Special Mention!\\" if n is a prime number, \\"Keep Trying!\\" otherwise. if n < 2: return \\"Keep Trying!\\" if n == 2: return \\"Special Mention!\\" if n % 2 == 0: return \\"Keep Trying!\\" sqrt_n = int(n ** 0.5) + 1 for i in range(3, sqrt_n, 2): if n % i == 0: return \\"Keep Trying!\\" return \\"Special Mention!\\""},{"question":"def process_great_wall_of_china_data(input_str: str) -> str: The Great Wall of China is one of the most iconic symbols of China’s rich history. Various sections of the wall attract vast numbers of tourists throughout the year. In order to manage the influx of visitors more effectively, the authorities need a system that can perform quick analyses based on given data. Specifically, they want to know the average number of visitors per section over a given period. Input The input consists of multiple datasets, each representing the number of visitors to various sections of the Great Wall over a series of days. Each dataset is given in the following format: d, s v11 v12 ... v1s v21 v22 ... v2s :: vd1 vd2 ... vds The first line gives two integers, d and s (1 ≤ d, s ≤ 1000), where d is the number of days and s is the number of sections. The following d lines each contain s integers, where each integer vij (0 ≤ vij ≤ 10000) represents the number of visitors to the j-th section on the i-th day. The end of the input is indicated by a single line \\"0 0\\". Output For each dataset, output s lines, where the i-th line contains the average number of visitors in the i-th section over the d days rounded to two decimal places. Example: >>> process_great_wall_of_china_data(\\"3 4n120 130 140 150n130 140 150 160n140 150 160 170n0 0\\") '130.00n140.00n150.00n160.00' >>> process_great_wall_of_china_data(\\"2 3n60 70 80n90 100 110n0 0\\") '75.00n85.00n95.00' pass","solution":"def average_visitors(data): result = [] for dataset in data: d, s = dataset[0] visitors = dataset[1:] averages = [] for section in range(s): total_visitors = sum(visitors[day][section] for day in range(d)) average = total_visitors / d averages.append(f\\"{average:.2f}\\") result.append(averages) return result def parse_input(input_str): data = [] lines = input_str.strip().split('n') idx = 0 while idx < len(lines): first_line = list(map(int, lines[idx].split())) if first_line[0] == 0 and first_line[1] == 0: break d, s = first_line dataset = [first_line] for _ in range(d): idx += 1 dataset.append(list(map(int, lines[idx].split()))) data.append(dataset) idx += 1 return data def format_output(result): return 'n'.join(['n'.join(dataset) for dataset in result]) def process_great_wall_of_china_data(input_str): data = parse_input(input_str) result = average_visitors(data) return format_output(result)"},{"question":"from typing import List def robot_path_planning(data: List[str]) -> List[int]: Determine the shortest path from the start position to the goal position in a grid world. The input consists of multiple datasets. Each dataset is represented in the following format: - The first line contains two integers N and M separated by a blank space, where 1 ≤ N, M ≤ 1000. N represents the number of rows in the grid, and M represents the number of columns. - The next N lines each contain M characters. Each character represents a cell in the grid and can be one of the following: - '.' (dot) indicates a free cell. - '#' (hash) indicates an obstacle. - 'S' indicates the start position and appears exactly once in the grid. - 'G' indicates the goal position and appears exactly once in the grid. The end of the input is represented by a line containing two zeros separated by a blank space. For each dataset, output a single integer which is the minimum number of steps required to reach the goal from the start. If no such path exists, output -1. >>> data = [ ... \\"3 4\\", ... \\"S...\\", ... \\".#..\\", ... \\"...G\\", ... \\"0 0\\" ... ] >>> robot_path_planning(data) [5] >>> data = [ ... \\"5 5\\", ... \\"S..\\", ... \\"..#.G\\", ... \\".#.\\", ... \\".....\\", ... \\".....\\", ... \\"0 0\\" ... ] >>> robot_path_planning(data) [-1]","solution":"from collections import deque def find_shortest_path(grid, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = None goal = None for r in range(n): for c in range(m): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'G': goal = (r, c) if not start or not goal: return -1 queue = deque([(start, 0)]) visited = set([start]) while queue: (current_r, current_c), steps = queue.popleft() for dr, dc in directions: new_r, new_c = current_r + dr, current_c + dc if 0 <= new_r < n and 0 <= new_c < m and (new_r, new_c) not in visited: if grid[new_r][new_c] == 'G': return steps + 1 if grid[new_r][new_c] == '.': queue.append(((new_r, new_c), steps + 1)) visited.add((new_r, new_c)) return -1 def robot_path_planning(data): results = [] i = 0 while i < len(data): n, m = map(int, data[i].split()) if n == 0 and m == 0: break grid = [] for j in range(1, n + 1): grid.append(list(data[i + j])) results.append(find_shortest_path(grid, n, m)) i += n + 1 return results"},{"question":"def min_product_equalizable_substrings(t, strings): For each string in strings, determine the minimum number of Product-Equalizable substrings it can be divided into, or -1 if not possible. >>> min_product_equalizable_substrings(3, [\\"aabb\\", \\"cdeffedc\\", \\"abcdef\\"]) == [-1, 1, -1] >>> min_product_equalizable_substrings(1, [\\"z\\"]) == [-1] >>> min_product_equalizable_substrings(1, [\\"cc\\"]) == [1] >>> min_product_equalizable_substrings(1, [\\"abcd\\"]) == [-1] >>> min_product_equalizable_substrings(4, [\\"gg\\", \\"ffggff\\", \\"mnoponm\\", \\"aaabbbccc\\"]) == [1, 1, -1, -1]","solution":"def get_prime_numbers(n): Generates a list of the first n prime numbers using the Sieve of Eratosthenes. primes = [] candidate = 2 while len(primes) < n: is_prime = all(candidate % prime != 0 for prime in primes) if is_prime: primes.append(candidate) candidate += 1 return primes def is_product_equalizable(s, prime_map): Checks if a given string s can be divided into Product-Equalizable substrings. Returns the minimum number of such substrings. n = len(s) if n % 2 != 0: return -1 # Odd length strings can't be perfectly split in the middle # Split the string into two halves first_half = s[:n//2] second_half = s[n//2:] # Calculate the products of prime values in both halves product_first_half = 1 product_second_half = 1 for char in first_half: product_first_half *= prime_map[char] for char in second_half: product_second_half *= prime_map[char] # If products are equal, it's already product-equalizable if product_first_half == product_second_half: return 1 else: return -1 def min_product_equalizable_substrings(t, strings): For each string in strings, determine the minimum number of Product-Equalizable substrings it can be divided into, or -1 if not possible. # Calculate the prime numbers for each alphabet letter primes = get_prime_numbers(26) prime_map = {chr(i + ord('a')): primes[i] for i in range(26)} results = [] for s in strings: result = is_product_equalizable(s, prime_map) results.append(result) return results # Example input T = 3 strings = [\\"aabb\\", \\"cdeffedc\\", \\"abcdef\\"] # Function call result = min_product_equalizable_substrings(T, strings) print(result) # Output: [-1, 1, -1]"},{"question":"def largest_square_with_coins(grid): Find the largest square subgrid that contains only coins. Parameters: grid (List[List[int]]): A grid of NxN cells with 1s representing coins and 0s representing empty cells. Returns: int: The size of the largest square subgrid that contains only coins. Examples: >>> largest_square_with_coins([[1, 1, 1, 0], [1, 1, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]]) 2 >>> largest_square_with_coins([[1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 1, 1, 0, 1]]) 3 pass def solve_large_square_with_coins(test_cases): Solve for multiple test cases to find the size of the largest square subgrid containing only coins. Parameters: test_cases (List[List[List[int]]]): A list of test case grids Returns: List[int]: The size of the largest square subgrid that contains only coins for each test case. pass def parse_input(input_data): Parse the input data to extract the number of test cases and their corresponding grids. Parameters: input_data (str): The input data as a single string Returns: List[List[List[int]]]: A list of test case grids pass import pytest def test_largest_square_with_coins(): input_data = \\"2n4n1 1 1 0n1 1 0 0n1 1 1 1n0 1 1 1n5n1 0 1 1 1n1 1 1 1 1n0 1 1 1 1n1 1 1 1 1n0 1 1 0 1\\" test_cases = parse_input(input_data) results = solve_large_square_with_coins(test_cases) assert results == [2, 3] def test_largest_square_with_coins_small(): input_data = \\"1n2n1 1n1 1\\" test_cases = parse_input(input_data) results = solve_large_square_with_coins(test_cases) assert results == [2] def test_largest_square_with_coins_zero(): input_data = \\"1n3n0 0 0n0 0 0n0 0 0\\" test_cases = parse_input(input_data) results = solve_large_square_with_coins(test_cases) assert results == [0] def test_largest_square_with_coins_mixed(): input_data = \\"1n3n1 0 1n0 1 0n1 0 1\\" test_cases = parse_input(input_data) results = solve_large_square_with_coins(test_cases) assert results == [1]","solution":"def largest_square_with_coins(grid): N = len(grid) dp = [[0] * N for _ in range(N)] max_side = 0 for i in range(N): for j in range(N): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side def solve_large_square_with_coins(test_cases): results = [] for grid in test_cases: results.append(largest_square_with_coins(grid)) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] curr_line = 1 for _ in range(T): N = int(lines[curr_line]) grid = [] for i in range(curr_line + 1, curr_line + 1 + N): grid.append(list(map(int, lines[i].split()))) test_cases.append(grid) curr_line += 1 + N return test_cases"},{"question":"def process_string(s: str) -> tuple: Processes the input string according to the task requirements. Parameters: s (str): The input string containing lowercase English letters and underscores. Returns: tuple: A tuple containing three integers: - Total number of words in the string. - The length of the longest word in the string. - The count of words that remain the same when reversed. Examples: >>> process_string(\\"hello_world\\") == (2, 5, 0) >>> process_string(\\"racecar_anna_civic\\") == (3, 7, 3) >>> process_string(\\"simple_string_example\\") == (3, 7, 0) >>> process_string(\\"palindrome_emordnilap\\") == (2, 10, 0) >>> process_string(\\"level\\") == (1, 5, 1) >>> process_string(\\"example\\") == (1, 7, 0) >>> process_string(\\"abc_def_ghi\\") == (3, 3, 0) >>> process_string(\\"radar_pop_madam\\") == (3, 5, 3)","solution":"def process_string(s): Processes the input string according to the task requirements. Parameters: s (str): The input string containing lowercase English letters and underscores. Returns: tuple: A tuple containing three integers: - Total number of words in the string. - The length of the longest word in the string. - The count of words that remain the same when reversed. words = s.split('_') total_words = len(words) longest_word_length = max(len(word) for word in words) palindrome_count = sum(1 for word in words if word == word[::-1]) return total_words, longest_word_length, palindrome_count"},{"question":"def calculate_final_prices(P, C, products, categories, S, sale_product_ids): Calculate the final price for each sale based on the discount provided for the category of the product. Parameters: P (int): Number of products C (int): Number of categories products (List[Tuple[int, int, float]]): List of tuples containing product_id, category_id, and price. categories (List[Tuple[int, float]]): List of tuples containing category_id and discount percentage. S (int): Number of products sold sale_product_ids (List[int]): List of product IDs representing the list of products sold. Returns: List[Tuple[int, float]]: List of tuples containing sale_id and final price after applying the discount. Prices are rounded to 2 decimal places. >>> calculate_final_prices(3, 2, [(1, 1, 100), (2, 1, 200), (3, 2, 300)], [(1, 10), (2, 20)], 2, [1, 3]) [(1, 90.00), (2, 240.00)]","solution":"def calculate_final_prices(P, C, products, categories, S, sale_product_ids): category_discounts = {} product_details = {} for category_id, discount in categories: category_discounts[category_id] = discount for product_id, category_id, price in products: product_details[product_id] = (category_id, price) final_prices = [] for sale_id, product_id in enumerate(sale_product_ids, start=1): category_id = product_details[product_id][0] price = product_details[product_id][1] discount = category_discounts[category_id] discounted_price = price * (1 - discount / 100) final_prices.append((sale_id, round(discounted_price, 2))) return final_prices"},{"question":"def detect_cycle_in_graph(num_nodes, edges): Detect if a given directed graph contains a cycle. Args: num_nodes (int): Number of nodes in the graph. edges (list): List of directed edges in the graph, each edge is represented by a tuple (u, v). Returns: str: \\"YES\\" if the directed graph contains a cycle, \\"NO\\" otherwise. from collections import defaultdict # Define the graph using adjacency list representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() rec_stack = set() # to keep track of the nodes in the current recursion stack def is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbour in graph[v]: if neighbour not in visited: if is_cyclic(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(v) return False for node in range(1, num_nodes + 1): if node not in visited: if is_cyclic(node): return \\"YES\\" return \\"NO\\" def graph_has_cycle(T, cases): Convert the input test cases, apply cycle detection and output results. Args: T (int): Number of test cases. cases (list): List of test cases, each containing nodes, edges and the edge list. Returns: list: List of results for each test case, either \\"YES\\" or \\"NO\\". >>> graph_has_cycle(2, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(1, 2), (2, 3)])]) [\\"YES\\", \\"NO\\"] >>> graph_has_cycle(1, [(2, 1, [(1, 2)])]) [\\"NO\\"] results = [] for num_nodes, num_edges, edges in cases: result = detect_cycle_in_graph(num_nodes, edges) results.append(result) return results","solution":"def detect_cycle_in_graph(num_nodes, edges): from collections import defaultdict # Create graph using adjacency list representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() rec_stack = set() # to keep track of the nodes in the current recursion stack def is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbour in graph[v]: if neighbour not in visited: if is_cyclic(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(v) return False for node in range(1, num_nodes + 1): if node not in visited: if is_cyclic(node): return \\"YES\\" return \\"NO\\" def graph_has_cycle(T, cases): results = [] for num_nodes, num_edges, edges in cases: result = detect_cycle_in_graph(num_nodes, edges) results.append(result) return results"},{"question":"import heapq from collections import defaultdict def minimum_communication_time(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Finds the minimum communication time from computer 1 to computer N. Args: N : int : number of computers (nodes) M : int : number of connections (edges) connections : list of tuples : each tuple contains (u, v, w) representing an edge from u to v with weight w Returns: int : minimum communication time or -1 if no path exists >>> minimum_communication_time(5, 6, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 2), (2, 5, 7)]) 5 >>> minimum_communication_time(4, 2, [(1, 2, 3), (2, 3, 4)]) -1 >>> minimum_communication_time(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 5)]) 3 from minimum_communication_time import minimum_communication_time def test_sample_input(): connections = [ (1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 2), (2, 5, 7) ] assert minimum_communication_time(5, 6, connections) == 5 def test_no_path(): connections = [ (1, 2, 3), (2, 3, 4) ] assert minimum_communication_time(4, 2, connections) == -1 def test_direct_connection(): connections = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 5) ] assert minimum_communication_time(4, 4, connections) == 3 def test_multiple_paths(): connections = [ (1, 2, 2), (2, 4, 4), (1, 3, 2), (3, 4, 1), (2, 3, 2) ] assert minimum_communication_time(4, 5, connections) == 3 def test_large_graph(): connections = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 5, 10) ] assert minimum_communication_time(5, 5, connections) == 4","solution":"import heapq from collections import defaultdict def minimum_communication_time(N, M, connections): Finds the minimum communication time from computer 1 to computer N. Args: N : int : number of computers (nodes) M : int : number of connections (edges) connections : list of tuples : each tuple contains (u, v, w) representing an edge from u to v with weight w Returns: int : minimum communication time or -1 if no path exists # Create adjacency list for the graph graph = defaultdict(list) for u, v, w in connections: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue for Dijkstra's algorithm pq = [(0, 1)] # (current_time, start_node) min_time = {i: float('inf') for i in range(1, N+1)} min_time[1] = 0 while pq: current_time, u = heapq.heappop(pq) if u == N: return current_time if current_time > min_time[u]: continue for v, time in graph[u]: new_time = current_time + time if new_time < min_time[v]: min_time[v] = new_time heapq.heappush(pq, (new_time, v)) return -1 if min_time[N] == float('inf') else min_time[N] # Sample Input connections = [ (1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 2), (2, 5, 7) ] print(minimum_communication_time(5, 6, connections)) # Output should be 5"},{"question":"from typing import List, Tuple def max_interest_trip(n: int, m: int, interest_values: List[int], roads: List[Tuple[int, int, int]], trips: List[Tuple[int, int]]) -> List[int]: For each trip, determine the maximum interest value of any attraction point that can be found along the shortest path between the start and destination cities, including the cities themselves at both ends of the trip. Args: n (int): The number of cities. m (int): The number of trips. interest_values (List[int]): Interest values for the attraction points in each city. roads (List[Tuple[int, int, int]]): Roads between the cities, represented as tuples of (city1, city2, distance). trips (List[Tuple[int, int]]): Trips as pairs of start and destination cities. Returns: List[int]: The maximum interest value for each trip. pass # The implementation goes here # Example usage and unit tests from solution import max_interest_trip def test_example_case(): n, m = 5, 3 interest_values = [5, 3, 6, 8, 7] roads = [(1, 2, 4), (2, 3, 1), (3, 4, 2), (4, 5, 3)] trips = [(1, 5), (2, 4), (3, 5)] expected_output = [8, 8, 8] assert max_interest_trip(n, m, interest_values, roads, trips) == expected_output def test_shortest_path_interests(): n, m = 4, 2 interest_values = [1, 3, 2, 5] roads = [(1, 2, 3), (2, 3, 4), (2, 4, 5)] trips = [(1, 3), (1, 4)] expected_output = [3, 5] assert max_interest_trip(n, m, interest_values, roads, trips) == expected_output def test_same_start_end_city(): n, m = 3, 1 interest_values = [9, 2, 4] roads = [(1, 2, 1), (2, 3, 1)] trips = [(1, 3)] expected_output = [9] assert max_interest_trip(n, m, interest_values, roads, trips) == expected_output def test_all_cities_with_equal_interest(): n, m = 4, 2 interest_values = [7, 7, 7, 7] roads = [(1, 2, 2), (2, 3, 2), (3, 4, 2)] trips = [(1, 4), (2, 3)] expected_output = [7, 7] assert max_interest_trip(n, m, interest_values, roads, trips) == expected_output def test_complex_case(): n, m = 6, 3 interest_values = [1, 4, 3, 7, 6, 5] roads = [(1, 2, 2), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 1)] trips = [(1, 6), (2, 5), (3, 4)] expected_output = [7, 7, 7] assert max_interest_trip(n, m, interest_values, roads, trips) == expected_output","solution":"import heapq from collections import defaultdict from sys import maxsize as inf def max_interest_trip(n, m, interest_values, roads, trips): # Build the graph graph = defaultdict(list) for a, b, d in roads: graph[a].append((b, d)) graph[b].append((a, d)) # Function to get the shortest path and maximum interest value along the path def find_max_interest(start, end): pq = [(0, start)] distances = {i: inf for i in range(1, n+1)} max_interest = {i: 0 for i in range(1, n+1)} distances[start] = 0 max_interest[start] = interest_values[start-1] while pq: current_dist, u = heapq.heappop(pq) if u == end: return max_interest[u] for v, weight in graph[u]: if distances[v] > current_dist + weight: distances[v] = current_dist + weight max_interest[v] = max(max_interest[u], interest_values[v-1]) heapq.heappush(pq, (distances[v], v)) elif distances[v] == current_dist + weight: if max_interest[v] < max(max_interest[u], interest_values[v-1]): max_interest[v] = max(max_interest[u], interest_values[v-1]) return max_interest[end] result = [] for start, end in trips: result.append(find_max_interest(start, end)) return result # Example usage: n, m = 5, 3 interest_values = [5, 3, 6, 8, 7] roads = [(1, 2, 4), (2, 3, 1), (3, 4, 2), (4, 5, 3)] trips = [(1, 5), (2, 4), (3, 5)] print(max_interest_trip(n, m, interest_values, roads, trips)) # [8, 8, 8]"},{"question":"import random def randomly_place_pallets(N, K, M): Randomly places M unique pallets with identifiers from 1 to M into racks with N rows and K capacity per row. pass def print_warehouse(warehouse): for row in warehouse: print(' '.join(map(str, row)).rstrip()) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N, K, M = map(int, data) warehouse = randomly_place_pallets(N, K, M) print_warehouse(warehouse) # Unit Tests def test_exact_fit(): N = 2 K = 3 M = 6 warehouse = randomly_place_pallets(N, K, M) assert len(warehouse) == 2 # 2 rows assert all(len(row) == 3 for row in warehouse) # 3 columns all_ids = set() for row in warehouse: all_ids.update(filter(lambda x: x != '', row)) assert all_ids == set(range(1, M + 1)) def test_extra_space(): N = 3 K = 4 M = 10 warehouse = randomly_place_pallets(N, K, M) assert len(warehouse) == 3 # 3 rows assert all(len(row) == 4 for row in warehouse) # 4 columns all_ids = set() for row in warehouse: all_ids.update(filter(lambda x: x != '', row)) assert all_ids == set(range(1, M + 1)) def test_less_pallets_than_capacity(): N = 5 K = 5 M = 10 warehouse = randomly_place_pallets(N, K, M) assert len(warehouse) == 5 # 5 rows assert all(len(row) == 5 for row in warehouse) # 5 columns all_ids = set() for row in warehouse: all_ids.update(filter(lambda x: x != '', row)) assert all_ids == set(range(1, M + 1)) def test_single_row(): N = 1 K = 10 M = 10 warehouse = randomly_place_pallets(N, K, M) assert len(warehouse) == 1 # 1 row assert len(warehouse[0]) == 10 # 10 columns assert set(warehouse[0]) == set(range(1, 11)) def test_single_pallet(): N = 2 K = 3 M = 1 warehouse = randomly_place_pallets(N, K, M) assert len(warehouse) == 2 # 2 rows assert all(len(row) == 3 for row in warehouse) # 3 columns all_ids = set() for row in warehouse: all_ids.update(filter(lambda x: x != '', row)) assert all_ids == {1}","solution":"import random def randomly_place_pallets(N, K, M): Randomly places M unique pallets with identifiers from 1 to M into racks with N rows and K capacity per row. pallet_ids = list(range(1, M + 1)) random.shuffle(pallet_ids) warehouse = [] index = 0 for _ in range(N): row = [] for _ in range(K): if index < M: row.append(pallet_ids[index]) index += 1 else: row.append('') warehouse.append(row) return warehouse def print_warehouse(warehouse): for row in warehouse: print(' '.join(map(str, row)).rstrip())"},{"question":"def shortest_path(n: int, m: int, grid: List[str]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of a garden grid. Return the minimum number of steps required to reach the exit or -1 if it is not possible. >>> shortest_path(5, 5, [\\"OOOOO\\", \\"OXOXO\\", \\"OOOOO\\", \\"OXOXO\\", \\"OOOOO\\"]) 8 >>> shortest_path(3, 3, [\\"OXO\\", \\"XOX\\", \\"OXO\\"]) -1 >>> shortest_path(1, 1, [\\"O\\"]) 0 >>> shortest_path(1, 1, [\\"X\\"]) -1 from collections import deque def test_shortest_path_possible(): n = 5 m = 5 grid = [ \\"OOOOO\\", \\"OXOXO\\", \\"OOOOO\\", \\"OXOXO\\", \\"OOOOO\\" ] assert shortest_path(n, m, grid) == 8 def test_shortest_path_impossible_blockage(): n = 3 m = 3 grid = [ \\"OXO\\", \\"XOX\\", \\"OXO\\" ] assert shortest_path(n, m, grid) == -1 def test_shortest_path_minimal_grid_open(): n = 1 m = 1 grid = [\\"O\\"] assert shortest_path(n, m, grid) == 0 def test_shortest_path_minimal_grid_blocked(): n = 1 m = 1 grid = [\\"X\\"] assert shortest_path(n, m, grid) == -1 def test_shortest_path_no_path_clear_end_blocked(): n = 2 m = 2 grid = [ \\"OO\\", \\"OX\\" ] assert shortest_path(n, m, grid) == -1 def test_shortest_path_no_path_start_blocked(): n = 2 m = 2 grid = [ \\"XO\\", \\"OO\\" ] assert shortest_path(n, m, grid) == -1","solution":"from collections import deque def shortest_path(n, m, grid): # Directions: Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or ending point is an obstacle if grid[0][0] == 'X' or grid[n-1][m-1] == 'X': return -1 # Initialize the queue for BFS and visited set queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() # Check if we've reached the end if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 'O': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # Example usage # n = 5 # m = 5 # grid = [ # \\"OOOOO\\", # \\"OXOXO\\", # \\"OOOOO\\", # \\"OXOXO\\", # \\"OOOOO\\" # ] # print(shortest_path(n, m, grid)) # Output: 8"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary, returning a new dictionary with no nesting. The keys in the new dictionary are the paths to the values in the original dictionary, separated by the specified separator. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key to use for all keys in the flattened dictionary. sep (str): The separator between parent keys and nested keys. Returns: dict: A new flattened dictionary. >>> flatten_dict({'name': 'John', 'details': {'email': 'john@example.com', 'address': {'city': 'New York', 'zip': '10001'}}}) {'name': 'John', 'details.email': 'john@example.com', 'details.address.city': 'New York', 'details.address.zip': '10001'} >>> flatten_dict({'key1': 'value1', 'key2': {'key2_1': 'value2_1', 'key2_2': {'key2_2_1': 'value2_2_1'}}, 'key3': 'value3'}) {'key1': 'value1', 'key2.key2_1': 'value2_1', 'key2.key2_2.key2_2_1': 'value2_2_1', 'key3': 'value3'} >>> flatten_dict({}) {} >>> flatten_dict({'a': {'b': {}}}) {}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key to use for all keys in the flattened dictionary. sep (str): The separator between parent keys and nested keys. Returns: dict: A new flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"from datetime import datetime from typing import List, Tuple def calculate_response_times(logs: List[Tuple[str, str, str]]) -> Tuple[List[Tuple[str, int]], Tuple[str, int]]: Calculates response times for emails and identifies the email with the fastest response. Parameters: logs (list of tuples): Each tuple contains (email_identifier, send_timestamp, response_timestamp) Returns: result (list of tuples): Each tuple contains (email_identifier, response_time in seconds) fastest_email (tuple): Contains (email_identifier, response_time in seconds) for the email with the fastest response >>> logs = [ >>> (\\"email1\\", \\"2022-09-15 10:34:50\\", \\"2022-09-15 10:36:50\\"), >>> (\\"email2\\", \\"2022-09-15 11:00:00\\", \\"2022-09-15 11:10:30\\"), >>> (\\"email3\\", \\"2022-09-15 12:15:45\\", \\"2022-09-15 12:15:55\\"), >>> ] >>> response_times, fastest_email = calculate_response_times(logs) >>> response_times [(\\"email1\\", 120), (\\"email2\\", 630), (\\"email3\\", 10)] >>> fastest_email (\\"email3\\", 10)","solution":"from datetime import datetime def calculate_response_times(logs): Calculates response times for emails and identifies the email with the fastest response. Parameters: logs (list of tuples): Each tuple contains (email_identifier, send_timestamp, response_timestamp) Returns: result (list of tuples): Each tuple contains (email_identifier, response_time in seconds) fastest_email (tuple): Contains (email_identifier, response_time in seconds) for the email with the fastest response response_times = [] for email_id, send_time, response_time in logs: send_dt = datetime.strptime(send_time, \\"%Y-%m-%d %H:%M:%S\\") response_dt = datetime.strptime(response_time, \\"%Y-%m-%d %H:%M:%S\\") response_duration = int((response_dt - send_dt).total_seconds()) response_times.append((email_id, response_duration)) # Identify the email with the quickest response fastest_email = min(response_times, key=lambda x: x[1]) return response_times, fastest_email # Example usage: logs = [ (\\"email1\\", \\"2022-09-15 10:34:50\\", \\"2022-09-15 10:36:50\\"), (\\"email2\\", \\"2022-09-15 11:00:00\\", \\"2022-09-15 11:10:30\\"), (\\"email3\\", \\"2022-09-15 12:15:45\\", \\"2022-09-15 12:15:55\\"), ] response_times, fastest_email = calculate_response_times(logs) for email_id, response_time in response_times: print(f\\"{email_id} {response_time}\\") print(f\\"{fastest_email[0]} {fastest_email[1]}\\")"},{"question":"from typing import List, Tuple def find_smallest_loop(n: int, m: int, relationships: List[Tuple[int, int]]) -> int: Determines the length of the smallest follow loop in the network. Args: n (int): The number of users. m (int): The number of following relationships. relationships (List[Tuple[int, int]]): A list of tuples where each tuple (ai, bi) indicates that user ai follows user bi. Returns: int: The length of the smallest follow loop in the network, or -1 if no follow loop exists. Examples: >>> find_smallest_loop(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)]) 4 >>> find_smallest_loop(4, 3, [(1, 2), (2, 3), (3, 4)]) -1 pass import pytest def test_find_smallest_loop(): assert find_smallest_loop(4, 5, [(1, 2), (2, 3), (3, 1), (1, 4), (4, 3)]) == 3 assert find_smallest_loop(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)]) == 4 assert find_smallest_loop(4, 3, [(1, 2), (2, 3), (3, 4)]) == -1 assert find_smallest_loop(3, 2, [(1, 2), (2, 3)]) == -1 assert find_smallest_loop(3, 3, [(1, 2), (2, 3), (3, 1)]) == 3 assert find_smallest_loop(5, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (1, 3)]) == 4","solution":"from collections import defaultdict, deque def find_smallest_loop(n, m, relationships): def bfs(start, graph): visited = [-1] * (n + 1) queue = deque([(start, 0)]) while queue: node, dist = queue.popleft() for neighbor in graph[node]: if neighbor == start: return dist + 1 if visited[neighbor] == -1: visited[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return float('inf') graph = defaultdict(list) for ai, bi in relationships: graph[ai].append(bi) min_loop_length = float('inf') for user in range(1, n + 1): min_loop_length = min(min_loop_length, bfs(user, graph)) return min_loop_length if min_loop_length != float('inf') else -1"},{"question":"from typing import List, Tuple def select_team(players: List[Tuple[str, int, str]]) -> List[str]: Selects a team of 11 players with the highest total skill level, while meeting specific positional requirements: 1 goalkeeper, 4 defenders, 4 midfielders, and 2 forwards. If a valid team cannot be formed, returns an empty list. >>> players = [ ... (\\"Alice\\", 85, \\"goalkeeper\\"), ... (\\"Bob\\", 90, \\"defender\\"), ... (\\"Charlie\\", 95, \\"defender\\"), ... (\\"David\\", 85, \\"defender\\"), ... (\\"Eve\\", 80, \\"defender\\"), ... (\\"Frank\\", 70, \\"midfielder\\"), ... (\\"Grace\\", 75, \\"midfielder\\"), ... (\\"Heidi\\", 85, \\"midfielder\\"), ... (\\"Ivan\\", 90, \\"midfielder\\"), ... (\\"Judy\\", 60, \\"forward\\"), ... (\\"Mallory\\", 95, \\"forward\\"), ... ] >>> select_team(players) ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank', 'Grace', 'Heidi', 'Ivan', 'Judy', 'Mallory'] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def select_team(players): # Separate players by position goalkeepers = [player for player in players if player[2] == 'goalkeeper'] defenders = [player for player in players if player[2] == 'defender'] midfielders = [player for player in players if player[2] == 'midfielder'] forwards = [player for player in players if player[2] == 'forward'] # Sort each position list by skill level in descending order goalkeepers.sort(key=lambda x: x[1], reverse=True) defenders.sort(key=lambda x: x[1], reverse=True) midfielders.sort(key=lambda x: x[1], reverse=True) forwards.sort(key=lambda x: x[1], reverse=True) # Check if there are enough players for each position if len(goalkeepers) < 1 or len(defenders) < 4 or len(midfielders) < 4 or len(forwards) < 2: return [] # Select the top-skilled players to form the team selected_team = [ goalkeepers[0], # 1 goalkeeper *defenders[:4], # 4 defenders *midfielders[:4], # 4 midfielders *forwards[:2] # 2 forwards ] # Extract and return the names of the selected players return [player[0] for player in selected_team]"},{"question":"def calculate_min_distance(n: int, positions: List[int]) -> int: Calculate the minimum additional distance necessary to cover any potential narrow gaps between spacecraft positions. >>> calculate_min_distance(5, [1, 3, 7, 10, 15]) == 2 >>> calculate_min_distance(3, [1, 2, 3]) == 1 >>> calculate_min_distance(4, [1, 100, 105, 110]) == 5 >>> calculate_min_distance(3, [5, 5, 5]) == 0 >>> calculate_min_distance(5, [10, 3, 15, 7, 1]) == 2 from typing import List def test_example(): assert calculate_min_distance(5, [1, 3, 7, 10, 15]) == 2 def test_no_gap(): assert calculate_min_distance(3, [1, 2, 3]) == 1 def test_large_gap(): assert calculate_min_distance(4, [1, 100, 105, 110]) == 5 def test_all_same(): assert calculate_min_distance(3, [5, 5, 5]) == 0 def test_unsorted_positions(): assert calculate_min_distance(5, [10, 3, 15, 7, 1]) == 2","solution":"def calculate_min_distance(n, positions): Calculate the minimum additional distance necessary to cover all narrow gaps. positions.sort() min_gap = float('inf') for i in range(1, n): gap = positions[i] - positions[i - 1] if gap < min_gap: min_gap = gap return min_gap"},{"question":"def adjustScores(n: int, students: List[int], answers: List[int]) -> None: Adjusts the scores based on the new scoring method. Parameters: n (int): Number of students students (List[int]): Hours studied by each student answers (List[int]): Initial scores of each student Modifies: answers (List[int]): List of updated scores based on the new methodology Example: >>> n = 6 >>> students = [2, 4, 6, 1, 3, 5] >>> answers = [10, 12, 14, 8, 11, 13] >>> adjustScores(n, students, answers) >>> print(answers) [10, 12, 14, 8, 11, 13] >>> n = 5 >>> students = [10, 20, 30, 40, 50] >>> answers = [40, 30, 20, 10, 50] >>> adjustScores(n, students, answers) >>> print(answers) [40, 40, 40, 40, 50]","solution":"def adjustScores(n, students, answers): Function to adjust the score of each student based on the new methodology. :param n: int, number of students :param students: list of int, hours studied by each student :param answers: list of int, scores each student received initially # Combine students and answers into a list of tuples combined = list(zip(students, answers)) # Sort the combined list based on hours studied combined.sort() # Initialize the maximum score so far max_score = -float('inf') # Traverse the sorted list and update the answers for i in range(n): max_score = max(max_score, combined[i][1]) combined[i] = (combined[i][0], max_score) # Put the adjusted scores back in the answers array in original order student_to_score = {student: score for student, score in combined} for i in range(n): answers[i] = student_to_score[students[i]] # Example usage n1 = 6 students1 = [2, 4, 6, 1, 3, 5] answers1 = [10, 12, 14, 8, 11, 13] adjustScores(n1, students1, answers1) print(answers1) # Output should be [10, 12, 14, 8, 11, 13] n2 = 5 students2 = [10, 20, 30, 40, 50] answers2 = [40, 30, 20, 10, 50] adjustScores(n2, students2, answers2) print(answers2) # Output should be [40, 40, 40, 40, 50]"},{"question":"from typing import List, Tuple def preprocess_positions(positions: List[int]) -> List[int]: Preprocess the positions to allow efficient range queries. >>> preprocess_positions([5, 2, 10, 7, 12]) [2, 5, 7, 10, 12] def count_treasures_in_range(positions: List[int], l: int, r: int) -> int: Counts the number of treasure positions within the range [l, r]. >>> positions = preprocess_positions([2, 5, 7, 10, 12]) >>> count_treasures_in_range(positions, 1, 6) 2 >>> count_treasures_in_range(positions, 5, 10) 3 >>> count_treasures_in_range(positions, 7, 15) 3 def process_test_case(test_case: dict) -> List[int]: Process a single test case. >>> test_case = {'n': 5, 'k': 3, 'positions': [2, 5, 7, 10, 12], 'queries': [(1, 6), (5, 10), (7, 15)]} >>> process_test_case(test_case) [2, 3, 3] def solve(T: int, test_cases: List[dict]) -> List[List[int]]: Solve the problem for all test cases. >>> T = 1 >>> test_cases = [{'n': 5, 'k': 3, 'positions': [2, 5, 7, 10, 12], 'queries': [(1, 6), (5, 10), (7, 15)]}] >>> solve(T, test_cases) [[2, 3, 3]] >>> T = 2 >>> test_cases = [ ... {'n': 5, 'k': 3, 'positions': [2, 5, 7, 10, 12], 'queries': [(1, 6), (5, 10), (7, 15)]}, ... {'n': 4, 'k': 2, 'positions': [3, 6, 8, 11], 'queries': [(2, 9), (8, 12)]} ... ] >>> solve(T, test_cases) [[2, 3, 3], [3, 2]]","solution":"from bisect import bisect_left, bisect_right def preprocess_positions(positions): Preprocess the positions to allow efficient range queries. return sorted(positions) def count_treasures_in_range(positions, l, r): Counts the number of treasure positions within the range [l, r]. start = bisect_left(positions, l) end = bisect_right(positions, r) return end - start def process_test_case(test_case): Process a single test case. n, k = test_case['n'], test_case['k'] positions = preprocess_positions(test_case['positions']) results = [] for query in test_case['queries']: l, r = query result = count_treasures_in_range(positions, l, r) results.append(result) return results def solve(T, test_cases): results = [] for test_case in test_cases: results.append(process_test_case(test_case)) return results"},{"question":"from bisect import insort, bisect_left class MedianDatabase: A class to manage a database of record identifiers and perform median operations. Methods: - add: Add a record identifier to the database. - remove: Remove a record identifier from the database. - median: Return the median of current record identifiers. def __init__(self): self.records = [] def add(self, x): Add a record with identifier \`x\` to the database. # your code here def remove(self, x): Remove a record with identifier \`x\` from the database if it exists. # your code here def median(self): Return the median of the current set of record identifiers. - If the median is an integer, output it as a floating point number with one decimal place. # your code here # Example Unit Tests: import pytest def test_median_database(): mdb = MedianDatabase() mdb.add(1) mdb.add(3) assert mdb.median() == 2.0 mdb.add(5) assert mdb.median() == 3.0 mdb.remove(3) assert mdb.median() == 3.0 mdb.add(2) assert mdb.median() == 2.0 def test_empty_database(): mdb = MedianDatabase() with pytest.raises(IndexError): mdb.median() def test_single_element(): mdb = MedianDatabase() mdb.add(4) assert mdb.median() == 4.0 mdb.add(6) assert mdb.median() == 5.0 mdb.remove(6) assert mdb.median() == 4.0","solution":"from bisect import insort, bisect_left class MedianDatabase: def __init__(self): self.records = [] def add(self, x): insort(self.records, x) def remove(self, x): pos = bisect_left(self.records, x) if pos != len(self.records) and self.records[pos] == x: del self.records[pos] def median(self): n = len(self.records) if n % 2 == 1: return float(self.records[n // 2]) else: mid1, mid2 = self.records[(n // 2) - 1], self.records[n // 2] return (mid1 + mid2) / 2.0"},{"question":"def trap_rainwater(heights): Calculate the amount of trapped rainwater given the heights of elevation at each unit of distance. :param heights: List of non-negative integers representing elevation heights :return: Total amount of trapped rainwater >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([0, 1, 2, 3, 4]) 0 >>> trap_rainwater([4, 3, 2, 1, 0]) 0 >>> trap_rainwater([2, 0, 2]) 2 >>> trap_rainwater([3, 0, 1, 0, 4]) 8 >>> trap_rainwater([1, 1, 1, 1]) 0 >>> trap_rainwater([0, 0, 0, 0]) 0 >>> trap_rainwater([3, 0, 0, 2, 0, 4]) 10 >>> trap_rainwater([0, 1, 0, 1, 0, 0]) 1 >>> trap_rainwater([2, 0, 0, 2, 0, 0, 2]) 8","solution":"def trap_rainwater(heights): Calculate the amount of trapped rainwater given the heights of elevation at each unit of distance. :param heights: List of non-negative integers representing elevation heights :return: Total amount of trapped rainwater if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Compute the maximum height to the left of each position left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Compute the maximum height to the right of each position right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Compute the trapped water at each position for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def longest_balanced_subsequence_length(S: str) -> int: Given a string S, find the length of the longest balanced subsequence, which contains equal number of 'a's and 'b's. >>> longest_balanced_subsequence_length(\\"abba\\") 4 >>> longest_balanced_subsequence_length(\\"aabb\\") 4 >>> longest_balanced_subsequence_length(\\"ababab\\") 6 >>> longest_balanced_subsequence_length(\\"ab\\") 2 >>> longest_balanced_subsequence_length(\\"a\\") 0 >>> longest_balanced_subsequence_length(\\"b\\") 0 >>> longest_balanced_subsequence_length(\\"\\") 0 >>> longest_balanced_subsequence_length(\\"abcabc\\") 4 >>> longest_balanced_subsequence_length(\\"aaaa\\") 0 >>> longest_balanced_subsequence_length(\\"bbbb\\") 0 ... def solve(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T, and a list of strings test_cases, determine the longest balanced subsequence length for each string. >>> solve(3, [\\"abba\\", \\"aabb\\", \\"ababab\\"]) [4, 4, 6] >>> solve(2, [\\"ab\\", \\"bba\\"]) [2, 2] >>> solve(1, [\\"abcabc\\"]) [4] >>> solve(1, [\\"\\"]) [0] >>> solve(1, [\\"aaaaa\\"]) [0] ...","solution":"def longest_balanced_subsequence_length(S): Given a string S, find the length of the longest balanced subsequence, which contains equal number of 'a's and 'b's. count_a = S.count('a') count_b = S.count('b') # The longest balanced subsequence can only be twice the number of pairs of 'a' and 'b' return 2 * min(count_a, count_b) def solve(T, test_cases): results = [] for S in test_cases: results.append(longest_balanced_subsequence_length(S)) return results"},{"question":"def max_items_collected(n: int, m: int, k: int, grid: List[List[int]]) -> int: Determine the maximum number of items the supervisor can collect starting from any cell in the grid, without exceeding k steps. >>> max_items_collected(3, 4, 5, [ ... [1, 0, 0, 1], ... [0, 1, 0, 0], ... [1, 0, 1, 1] ... ]) == 4 >>> max_items_collected(1, 1, 1, [ ... [1] ... ]) == 1 >>> max_items_collected(3, 3, 5, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> max_items_collected(3, 3, 0, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> max_items_collected(5, 5, 10, [ ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1] ... ]) == 6","solution":"def max_items_collected(n, m, k, grid): def dfs(x, y, steps, collected): if steps > k: return 0 max_collected = collected + grid[x][y] visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: max_collected = max(max_collected, dfs(nx, ny, steps + 1, collected + grid[x][y])) visited.remove((x, y)) return max_collected max_items = 0 for i in range(n): for j in range(m): visited = set() max_items = max(max_items, dfs(i, j, 0, 0)) return max_items"},{"question":"def minPalPartion(S: str) -> int: Determine the minimum number of cuts required to partition the string into substrings such that each substring is a palindrome. >>> minPalPartion(\\"aab\\") == 1 >>> minPalPartion(\\"abcde\\") == 4 >>> minPalPartion(\\"aba\\") == 0 >>> minPalPartion(\\"noonabbad\\") == 2 >>> minPalPartion(\\"banana\\") == 1 >>> minPalPartion(\\"racecar\\") == 0 >>> minPalPartion(\\"aaaa\\") == 0 >>> minPalPartion(\\"abcdefg\\") == 6 >>> minPalPartion(\\"abccbax\\") == 1 >>> minPalPartion(\\"a\\") == 0","solution":"def minPalPartion(S): n = len(S) C = [0] * n P = [[False] * n for _ in range(n)] for i in range(n): P[i][i] = True for L in range(2, n + 1): for i in range(n - L + 1): j = i + L - 1 if L == 2: P[i][j] = (S[i] == S[j]) else: P[i][j] = (S[i] == S[j]) and P[i + 1][j - 1] for i in range(n): if P[0][i] == True: C[i] = 0 else: C[i] = float('inf') for j in range(i): if P[j + 1][i] == True and 1 + C[j] < C[i]: C[i] = 1 + C[j] return C[n - 1]"},{"question":"def sum_of_unique_numbers(n, array): Returns the sum of all unique numbers in the input array. Parameters: n (int): The number of elements in the array. array (List[int]): The elements of the array. Returns: int: The sum of all unique numbers in the array. Example: >>> sum_of_unique_numbers(6, [1, 2, 2, 3, 4, 4]) 4 >>> sum_of_unique_numbers(5, [1, 2, 3, 4, 5]) 15 from collections import Counter def test_example_case(): assert sum_of_unique_numbers(6, [1, 2, 2, 3, 4, 4]) == 4 def test_all_unique_numbers(): assert sum_of_unique_numbers(5, [1, 2, 3, 4, 5]) == 15 def test_no_unique_numbers(): assert sum_of_unique_numbers(6, [1, 1, 2, 2, 3, 3]) == 0 def test_mixed_numbers(): assert sum_of_unique_numbers(8, [2, -1, 3, 2, -1, 0, 4, 4]) == 3 def test_single_element(): assert sum_of_unique_numbers(1, [10]) == 10 def test_large_range_of_numbers(): assert sum_of_unique_numbers(6, [-1000, 999, -1000, -500, 500, 500]) == 499","solution":"def sum_of_unique_numbers(n, array): Returns the sum of all unique numbers in the input array. from collections import Counter counts = Counter(array) unique_sum = sum([num for num, count in counts.items() if count == 1]) return unique_sum"},{"question":"def process_messages(test_cases): Process multiple test cases of encoding and decoding messages based on the Caesar Cipher technique. Args: - test_cases: A list of tuples where each tuple contains: - a character 'E' or 'D' indicating whether to encode or decode the message - a string, the message to encode or decode - an integer, the shift value Returns: A list of results where each result is the encoded or decoded message. Example: >>> process_messages([('E', 'HELLO', 3)]) ['KHOOR'] >>> process_messages([('D', 'KHOOR', 3)]) ['HELLO'] >>> process_messages([('E', 'ABC', 1)]) ['BCD'] >>> process_messages([( 'E', 'HELLO', 3), ( 'D', 'KHOOR', 3), ( 'E', 'ABC', 1)]) ['KHOOR', 'HELLO', 'BCD'] pass","solution":"def caesar_cipher_char(char, shift): Shift a character by the specified number of positions in the alphabet. Wraps around the alphabet if necessary. return chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) def caesar_cipher(message, shift, encode=True): Encodes or decodes a message using a Caesar Cipher with the given shift. If encode is True, it encodes the message. If False, it decodes the message. if not encode: shift = -shift return ''.join(caesar_cipher_char(char, shift) for char in message) def process_messages(test_cases): Processes multiple test cases of encoding and decoding messages. Args: - test_cases: A list of tuples where each tuple contains: - a character 'E' or 'D' indicating whether to encode or decode the message - a string, the message to encode or decode - an integer, the shift value Returns: A list of results where each result is the encoded or decoded message. results = [] for action, message, shift in test_cases: encode = (action == 'E') result = caesar_cipher(message, shift, encode) results.append(result) return results"},{"question":"def check_repeated_words(T: int, test_cases: list) -> list: This function checks if any sentence in the conversation contains a word that is repeated more than N times. Args: T : int : The number of test cases test_cases : list : A list of test cases, where each test case is a tuple (N, M, sentences) N : int : The threshold number of repetitions M : int : The number of sentences in the conversation sentences : list : A list of sentences in the conversation Returns: list : A list of results for each test case, either \\"FLAG\\" or \\"OK\\" Example: >>> T = 2 >>> test_cases = [ ... (2, 3, [ ... \\"Hello Hello world.\\", ... \\"This is a test sentence.\\", ... \\"Goodbye Goodbye Goodbye friends.\\" ... ]), ... (1, 2, [ ... \\"Hey there this is a test.\\", ... \\"Hello Hello this is a flag test.\\" ... ]) ... ] >>> check_repeated_words(T, test_cases) [\\"FLAG\\", \\"FLAG\\"] >>> T = 1 >>> test_cases = [ ... (3, 2, [ ... \\"One two three.\\", ... \\"One two three One two.\\" ... ]) ... ] >>> check_repeated_words(T, test_cases) [\\"OK\\"]","solution":"def check_repeated_words(T, test_cases): results = [] for i in range(T): N, M, sentences = test_cases[i] flag = False for sentence in sentences: words = sentence[:-1].split() # Remove the period and split words word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 if word_count[word] > N: flag = True break if flag: break if flag: results.append(\\"FLAG\\") else: results.append(\\"OK\\") return results"},{"question":"def find_nearest_empty(parking_lot): This function finds the coordinates of the nearest empty parking space from the top-left corner. It returns a tuple (row, column) of the nearest empty space. pass def park_car(parking_lot): This function parks a car in the nearest available empty space and updates the parking lot grid accordingly. pass def process_parking_lot(parking_lot, arrivals): This function processes the car arrivals and prints the parking lot state after each arrival. pass def main(): import sys input = sys.stdin.read data = input().split(\\"n\\") idx = 0 while True: n, m = map(int, data[idx].strip().split()) if n == 0 and m == 0: break idx += 1 parking_lot = [] for i in range(n): parking_lot.append(list(data[idx + i].strip())) idx += n arrivals = int(data[idx].strip()) idx += 1 process_parking_lot(parking_lot, arrivals) # Example test case if __name__ == '__main__': from io import StringIO import sys input_data = '''4 5 EEEEE ECECE EEEEE ECEEE 3 4 4 ECCE EECE EEEE EEE 2 0 0 ''' sys.stdin = StringIO(input_data) main() sys.stdin = sys.__stdin__","solution":"def find_nearest_empty(parking_lot): This function finds the coordinates of the nearest empty parking space from the top-left corner. It returns a tuple (row, column) of the nearest empty space. for i in range(len(parking_lot)): for j in range(len(parking_lot[0])): if parking_lot[i][j] == 'E': return i, j return -1, -1 def park_car(parking_lot): This function parks a car in the nearest available empty space and updates the parking lot grid accordingly. i, j = find_nearest_empty(parking_lot) if i != -1 and j != -1: parking_lot[i][j] = 'C' return parking_lot def process_parking_lot(parking_lot, arrivals): This function processes the car arrivals and prints the parking lot state after each arrival. for _ in range(arrivals): parking_lot = park_car(parking_lot) for row in parking_lot: print(\\"\\".join(row)) print() def main(): import sys input = sys.stdin.read data = input().split(\\"n\\") idx = 0 while True: n, m = map(int, data[idx].strip().split()) if n == 0 and m == 0: break idx += 1 parking_lot = [] for i in range(n): parking_lot.append(list(data[idx + i].strip())) idx += n arrivals = int(data[idx].strip()) idx += 1 process_parking_lot(parking_lot, arrivals)"},{"question":"from typing import List, Tuple def max_subarray_sum_with_min_four_elements(nums: List[int]) -> int: Find the maximum sum of a contiguous subarray with at least four elements. Args: nums (List[int]): The list of integers representing the array. Returns: int: The maximum sum of a contiguous subarray with at least four elements. >>> max_subarray_sum_with_min_four_elements([1, 2, 3, -2, 5]) 9 >>> max_subarray_sum_with_min_four_elements([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum_with_min_four_elements([-1, -2, -3, -4, -5, -6, -7, -8]) -10 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes test cases to find the maximum sum for each case. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of elements and the array. Returns: List[int]: A list of maximum sums of contiguous subarrays with at least four elements. def parse_input(input_str: str) -> List[Tuple[int, List[int]]]: Parses the input string into test cases. Args: input_str (str): The input string representing the test cases. Returns: List[Tuple[int, List[int]]]: A list of tuples where each tuple contains the number of elements and the array. def main(input_str: str) -> List[int]: Main function to parse input, process test cases, and return results. Args: input_str (str): The input string representing the test cases. Returns: List[int]: A list of maximum sums of contiguous subarrays with at least four elements.","solution":"def max_subarray_sum_with_min_four_elements(nums): n = len(nums) if n < 4: return 0 # Should not happen due to problem constraints max_sum = float('-inf') current_sum = 0 for i in range(4, n + 1): current_sum = sum(nums[:i]) max_sum = max(max_sum, current_sum) for j in range(i, n): current_sum += nums[j] - nums[j - i] max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for n, array in test_cases: results.append(max_subarray_sum_with_min_four_elements(array)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) array = list(map(int, lines[idx + 1].split())) test_cases.append((N, array)) idx += 2 return test_cases def main(input_str): test_cases = parse_input(input_str) results = process_test_cases(test_cases) return results"},{"question":"def longest_sequence_above_threshold(T, test_cases): Returns the length of the longest sequence of consecutive days where the temperature is above the given threshold for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (N, K, temperatures) where N is the number of days, K is the temperature threshold, and temperatures is a list of temperatures for each day. Returns: list: A list of integers representing the length of the longest sequence of consecutive days with temperature above the threshold for each test case. pass from solution import longest_sequence_above_threshold def test_case_1(): T = 2 test_cases = [ (7, 30, [31, 32, 33, 29, 28, 30, 31]), (5, 10, [11, 12, 9, 14, 15]) ] assert longest_sequence_above_threshold(T, test_cases) == [3, 2] def test_case_no_days_above_threshold(): T = 1 test_cases = [ (4, 90, [10, 20, 30, 40]) ] assert longest_sequence_above_threshold(T, test_cases) == [0] def test_case_all_days_above_threshold(): T = 1 test_cases = [ (5, 0, [1, 2, 3, 4, 5]) ] assert longest_sequence_above_threshold(T, test_cases) == [5] def test_case_multiple_sequences(): T = 1 test_cases = [ (8, 50, [51, 52, 30, 51, 52, 53, 10, 55]) ] assert longest_sequence_above_threshold(T, test_cases) == [3] def test_case_single_day(): T = 1 test_cases = [ (1, 5, [6]) ] assert longest_sequence_above_threshold(T, test_cases) == [1] def test_case_single_day_below_threshold(): T = 1 test_cases = [ (1, 5, [4]) ] assert longest_sequence_above_threshold(T, test_cases) == [0]","solution":"def longest_sequence_above_threshold(T, test_cases): Returns the length of the longest sequence of consecutive days where the temperature is above the given threshold for each test case. Parameters: T (int): The number of test cases. test_cases (list of tuples): Each tuple contains (N, K, temperatures) where N is the number of days, K is the temperature threshold, and temperatures is a list of temperatures for each day. Returns: list: A list of integers representing the length of the longest sequence of consecutive days with temperature above the threshold for each test case. result = [] for i in range(T): N, K, temperatures = test_cases[i] max_length = 0 current_length = 0 for temp in temperatures: if temp > K: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 result.append(max_length) return result"},{"question":"def can_form_palindrome(str: str) -> str: Determines if the characters of the string can be re-arranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabb\\") \\"YES\\"","solution":"def can_form_palindrome(s): Determines if the characters of the string can be re-arranged to form a palindrome. A palindrome can have at most one character with an odd frequency. from collections import Counter count = Counter(s) odd_count = sum(1 for char, freq in count.items() if freq % 2 != 0) if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def max_operations(s: str) -> int: Determine the maximum number of operations to remove equal 'A'-'B' subsegments. :param s: A string containing only characters 'A' and 'B' :return: The maximum number of operations >>> max_operations(\\"AABBAB\\") 2 >>> max_operations(\\"ABABAB\\") 3","solution":"def max_operations(s): Determine the maximum number of operations to remove equal 'A'-'B' subsegments. :param s: A string containing only characters 'A' and 'B' :return: The maximum number of operations countA, countB = 0, 0 operations = 0 for char in s: if char == 'A': countA += 1 elif char == 'B': countB += 1 if countA == countB: operations += 1 countA, countB = 0, 0 return operations"},{"question":"def compress(s: str) -> str: Perform run-length encoding on a given string. Replace sequences of identical consecutive characters with that character followed by the count of repetitions. Examples: >>> compress(\\"aabcccccaaa\\") # returns \\"a2bc5a3\\" >>> compress(\\"abcd\\") # returns \\"abcd\\" >>> compress(\\"wwwwwwww\\") # returns \\"w8\\" >>> compress(\\"\\") # returns \\"\\" >>> compress(\\"a\\") # returns \\"a\\" >>> compress(\\"aa\\") # returns \\"a2\\" >>> compress(\\"aabbaa\\") # returns \\"a2b2a2\\"","solution":"def compress(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: if count > 1: compressed.append(f\\"{s[i-1]}{count}\\") else: compressed.append(s[i-1]) count = 1 if count > 1: compressed.append(f\\"{s[-1]}{count}\\") else: compressed.append(s[-1]) return \\"\\".join(compressed)"},{"question":"def maxProductOfThree(nums: List[int]) -> int: Returns the highest product of any three numbers in the given list of integers. >>> maxProductOfThree([1, 10, 2, 6, 5, 3]) 300 >>> maxProductOfThree([-10, -10, 5, 2]) 500","solution":"def maxProductOfThree(nums): Returns the highest product of any three numbers in the given list of integers. nums.sort() return max(nums[-1]*nums[-2]*nums[-3], nums[0]*nums[1]*nums[-1])"},{"question":"def filter_products(products, category_characteristics): Filters products based on category characteristics. Args: - products (list of dict): List of product dictionaries. - category_characteristics (dict): Characteristics that products must match. Returns: - list of int: List of product ids that match all category characteristics. # Your code here # Unit tests def test_filter_products_exact_match(): products = [ {\\"id\\": 101, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 102, \\"color\\": \\"red\\", \\"size\\": \\"L\\", \\"brand\\": \\"BrandB\\"}, {\\"id\\": 103, \\"color\\": \\"blue\\", \\"size\\": \\"S\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 104, \\"color\\": \\"green\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandC\\"} ] category_characteristics = { \\"color\\": \\"blue\\", \\"brand\\": \\"BrandA\\" } assert filter_products(products, category_characteristics) == [101, 103] def test_filter_products_no_match(): products = [ {\\"id\\": 101, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 102, \\"color\\": \\"red\\", \\"size\\": \\"L\\", \\"brand\\": \\"BrandB\\"} ] category_characteristics = { \\"color\\": \\"green\\", \\"brand\\": \\"BrandA\\" } assert filter_products(products, category_characteristics) == [] def test_filter_products_single_characteristic(): products = [ {\\"id\\": 101, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 102, \\"color\\": \\"red\\", \\"size\\": \\"L\\", \\"brand\\": \\"BrandB\\"}, {\\"id\\": 103, \\"color\\": \\"blue\\", \\"size\\": \\"S\\", \\"brand\\": \\"BrandA\\"} ] category_characteristics = { \\"color\\": \\"blue\\" } assert filter_products(products, category_characteristics) == [101, 103] def test_filter_products_empty_characteristics(): products = [ {\\"id\\": 101, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 102, \\"color\\": \\"red\\", \\"size\\": \\"L\\", \\"brand\\": \\"BrandB\\"}, {\\"id\\": 103, \\"color\\": \\"blue\\", \\"size\\": \\"S\\", \\"brand\\": \\"BrandA\\"} ] category_characteristics = {} assert filter_products(products, category_characteristics) == [101, 102, 103] def test_filter_products_empty_products(): products = [] category_characteristics = { \\"color\\": \\"blue\\", \\"brand\\": \\"BrandA\\" } assert filter_products(products, category_characteristics) == [] def test_filter_products_partial_match(): products = [ {\\"id\\": 101, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 102, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandB\\"}, {\\"id\\": 103, \\"color\\": \\"blue\\", \\"size\\": \\"S\\", \\"brand\\": \\"BrandA\\"}, {\\"id\\": 104, \\"color\\": \\"blue\\", \\"size\\": \\"M\\", \\"brand\\": \\"BrandC\\"} ] category_characteristics = { \\"color\\": \\"blue\\", \\"size\\": \\"M\\" } assert filter_products(products, category_characteristics) == [101, 102, 104]","solution":"def filter_products(products, category_characteristics): Filters products based on category characteristics. Args: - products (list of dict): List of product dictionaries. - category_characteristics (dict): Characteristics that products must match. Returns: - list of int: List of product ids that match all category characteristics. filtered_ids = [] for product in products: match = True for key, value in category_characteristics.items(): if product.get(key) != value: match = False break if match: filtered_ids.append(product[\\"id\\"]) return filtered_ids"},{"question":"def longest_even_subarray_length(arr: List[int]) -> int: Function to find the length of the longest subarray that contains only even numbers. >>> longest_even_subarray_length([1, 2, 4, 6, 3, 8, 10, 12, 1, 2]) 3 >>> longest_even_subarray_length([1, 3, 5, 7, 9, 11]) 0","solution":"def longest_even_subarray_length(arr): Function to find the length of the longest subarray that contains only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def max_distance(n: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum distance between any two computers in the network. >>> max_distance(6, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6)]) 4 >>> max_distance(5, [(1, 2), (2, 3), (2, 4), (4, 5)]) 3","solution":"def max_distance(n, edges): from collections import defaultdict, deque def bfs(start_node): max_dist = 0 farthest_node = start_node visited = [False] * (n + 1) queue = deque([(start_node, 0)]) visited[start_node] = True while queue: node, dist = queue.popleft() for neighbor in tree[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, dist + 1)) if dist + 1 > max_dist: max_dist = dist + 1 farthest_node = neighbor return farthest_node, max_dist tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Perform BFS twice to get the maximum diameter of the tree. start_node = 1 farthest_node, _ = bfs(start_node) _, max_dist = bfs(farthest_node) return max_dist"},{"question":"def word_square(words: List[str]) -> bool: Checks if the given list of words forms a valid word square. >>> word_square([\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"]) True >>> word_square([\\"ball\\", \\"area\\", \\"lead\\", \\"lad\\"]) False >>> word_square([\\"a\\"]) True >>> word_square([]) True >>> word_square([\\"ball\\", \\"area\\", \\"lead\\", \\"la\\"]) False >>> word_square([\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\", \\"y\\"]) False >>> word_square([\\"abcd\\", \\"bnrt\\", \\"crmy\\", \\"dtye\\"]) True >>> word_square([\\"abcd\\", \\"bnrt\\", \\"crmz\\", \\"dtye\\"]) False","solution":"def word_square(words): Checks if the given list of words forms a valid word square. n = len(words) for i in range(n): # Check if the current word's length matches the expected length if len(words[i]) != n: return False for j in range(len(words[i])): if j < n and i < len(words[j]) and words[i][j] != words[j][i]: return False return True"},{"question":"def longestDigitSubstring(s: str) -> int: Given a string s consisting of alphabets and digits, find the length of the longest substring that contains only digits. >>> longestDigitSubstring(\\"abc1234xyz98765pqrs\\") 5 >>> longestDigitSubstring(\\"abcd\\") 0","solution":"def longestDigitSubstring(s): Returns the length of the longest substring with only digits. max_len = 0 current_len = 0 for char in s: if char.isdigit(): current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len"},{"question":"def max_sum_of_positive_subarray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible sum of difficulties you can achieve by selecting a contiguous subarray of puzzles such that the sum of puzzles' difficulties in the subarray is strictly positive. Arguments: T -- Number of test cases. test_cases -- A list of tuples, where each tuple contains an integer N and a list of integers representing the difficulty levels of the puzzles. Returns: A list of integers, where each integer represents the maximum sum of difficulties for any contiguous subarray that has a strictly positive sum. Examples: >>> max_sum_of_positive_subarray(3, [(5, [-1, 2, 3, -5, 4]), (6, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (3, [-4, -3, -2])]) [5, 6, 0] >>> max_sum_of_positive_subarray(1, [(5, [2, 3, 4, 5, 6])]) [20]","solution":"def max_sum_of_positive_subarray(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] difficulties = test_cases[i][1] maximum_sum = 0 current_sum = 0 for difficulty in difficulties: current_sum += difficulty if current_sum > maximum_sum: maximum_sum = current_sum if current_sum < 0: current_sum = 0 results.append(maximum_sum) return results"},{"question":"def isMatch(s: str, p: str) -> bool: Returns whether the pattern p matches the entire string s. >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"a*\\") True >>> isMatch(\\"ab\\", \\".*\\") True","solution":"def isMatch(s, p): Returns whether the pattern p matches the entire string s. m, n = len(s), len(p) # DP table where dp[i][j] will be True if the first i characters in s match the first j characters in p dp = [[False] * (n + 1) for _ in range(m + 1)] # Empty string and empty pattern are a match dp[0][0] = True # Handle patterns like a*, a*b*, a*b*c* etc. for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 2] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '.' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == '*': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] == s[i - 1] or p[j - 2] == '.' else False) return dp[m][n]"},{"question":"def minimum_even_perimeter(test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum length of the even perimeter required for each rectangular field. >>> minimum_even_perimeter([(3, 4)]) == [14] >>> minimum_even_perimeter([(5, 6)]) == [22] >>> minimum_even_perimeter([(7, 8)]) == [30] >>> minimum_even_perimeter([(1, 1)]) == [4] >>> minimum_even_perimeter([(1000, 1000)]) == [4000]","solution":"def minimum_even_perimeter(test_cases): results = [] for L, W in test_cases: perimeter = 2 * (L + W) # Ensure the perimeter is even (though it will naturally be even in this scenario) if perimeter % 2 != 0: perimeter += 1 results.append(perimeter) return results # Function to parse input, process and print output def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(T)] results = minimum_even_perimeter(test_cases) for result in results: print(result)"},{"question":"def is_valid_parentheses(s: str) -> str: Determine if the input string containing only parentheses is valid. >>> is_valid_parentheses(\\"()\\") \\"VALID\\" >>> is_valid_parentheses(\\"()[]{}\\") \\"VALID\\" >>> is_valid_parentheses(\\"(}\\") \\"INVALID\\" >>> is_valid_parentheses(\\"([)]\\") \\"INVALID\\"","solution":"def is_valid_parentheses(s): Determine if the input string containing only parentheses is valid. stack = [] matching_parentheses = {')': '(', ']': '[', '}': '{'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if stack == [] or stack.pop() != matching_parentheses[char]: return \\"INVALID\\" else: return \\"INVALID\\" return \\"VALID\\" if stack == [] else \\"INVALID\\""},{"question":"def second_largest(numbers): Returns the second largest number in the list of integers. If there is no second largest number, returns None. >>> second_largest([4, 6, 1, 7, 6, 2, 6]) == 6 >>> second_largest([4]) == None >>> second_largest([7, 7, 7]) == None >>> second_largest([1, 2]) == 1 >>> second_largest([4, -2, -2, 7, -5]) == 4 >>> second_largest([8, 8, 4, 4]) == 4 >>> second_largest([100, -100, 50]) == 50","solution":"def second_largest(numbers): Returns the second largest number in the list of integers. If there is no second largest number, returns None. if len(set(numbers)) < 2: return None unique_numbers = list(set(numbers)) unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"from typing import List def count_pairs_with_sum(arr: List[int], n: int, k: int) -> int: Given an array of integers \`arr\` of size \`n\`, and an integer \`k\`, find the number of pairs of array elements that add up to \`k\`. >>> count_pairs_with_sum([1, 5, 7, 1], 4, 6) 2 >>> count_pairs_with_sum([1, 1, 1, 1], 4, 2) 6 from solution import count_pairs_with_sum def test_example_1(): arr = [1, 5, 7, 1] k = 6 assert count_pairs_with_sum(arr, len(arr), k) == 2 def test_example_2(): arr = [1, 1, 1, 1] k = 2 assert count_pairs_with_sum(arr, len(arr), k) == 6 def test_no_pairs(): arr = [1, 2, 3, 4] k = 10 assert count_pairs_with_sum(arr, len(arr), k) == 0 def test_all_elements_same(): arr = [2, 2, 2, 2] k = 4 assert count_pairs_with_sum(arr, len(arr), k) == 6 def test_negative_numbers(): arr = [1, -1, 2, -2, 3, -3] k = 0 assert count_pairs_with_sum(arr, len(arr), k) == 3 def test_large_numbers(): arr = [100000, -100000, 50000, -50000, 0] k = 0 assert count_pairs_with_sum(arr, len(arr), k) == 2","solution":"def count_pairs_with_sum(arr, n, k): Returns the number of pairs in the array whose sum is equal to k. count = 0 freq = {} for num in arr: complement = k - num if complement in freq: count += freq[complement] if num in freq: freq[num] += 1 else: freq[num] = 1 return count"},{"question":"def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character from the string s, or '_' if all characters are repeating. Examples: >>> first_non_repeating_character(\\"leetcode\\") 'l' >>> first_non_repeating_character(\\"loveleetcode\\") 'v' >>> first_non_repeating_character(\\"aabbcc\\") '_' >>> first_non_repeating_character(\\"abcdabcd\\") '_'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character from the string s, or '_' if all characters are repeating. char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char # If all characters are repeating return '_'"},{"question":"def combination_sum(candidates, target): Returns a list of all unique combinations of candidates where the chosen numbers sum to the target. The same number may be chosen from candidates an unlimited number of times. Args: candidates: List of distinct integers. target: Target integer. Returns: List of unique combinations where the chosen numbers sum to target. Example: >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"def combination_sum(candidates, target): Returns a list of all unique combinations of candidates where the chosen numbers sum to target. The same number may be chosen from candidates an unlimited number of times. result = [] def backtrack(remain, combo, start): if remain == 0: result.append(list(combo)) return elif remain < 0: return for i in range(start, len(candidates)): combo.append(candidates[i]) backtrack(remain - candidates[i], combo, i) combo.pop() backtrack(target, [], 0) return result"},{"question":"def frequency_count(s: str) -> List[Tuple[str, int]]: Returns a list of tuples with the frequency of each character sorted by frequency in descending order. If two characters have the same frequency, they are sorted in alphabetical order. Example: >>> frequency_count(\\"aabbcc\\") [('a', 2), ('b', 2), ('c', 2)] >>> frequency_count(\\"abbccc\\") [('c', 3), ('b', 2), ('a', 1)]","solution":"def frequency_count(s): Returns a list of tuples with the frequency of each character sorted by frequency in descending order. If two characters have the same frequency, they are sorted in alphabetical order. from collections import Counter # Counting the frequency of each character freq_counter = Counter(s) # Sorting the counter by frequency first (in descending order) and then by character (in ascending order) sorted_freq = sorted(freq_counter.items(), key=lambda x: (-x[1], x[0])) return sorted_freq"},{"question":"def total_stakes_required(T: int, dimensions: List[Tuple[int, int]]) -> List[int]: Calculate the total number of stakes required for each test case. >>> total_stakes_required(3, [(3, 1), (2, 2), (4, 4)]) [8, 8, 16] >>> total_stakes_required(2, [(5, 1), (5, 5)]) [12, 20] >>> total_stakes_required(1, [(1, 1)]) [4] >>> total_stakes_required(1, [(10, 2)]) [24] >>> total_stakes_required(3, [(6, 3), (7, 1), (8, 2)]) [18, 16, 20]","solution":"def total_stakes_required(T, dimensions): results = [] for l, w in dimensions: stakes = (2 * l + 2 * w) results.append(stakes) return results"},{"question":"def is_lucky_number(n: int) -> bool: Determines whether the given integer n is a lucky number. A lucky number has all its digits and the combinations of adjacent digits unique. >>> is_lucky_number(1234) True >>> is_lucky_number(1124) False >>> is_lucky_number(13579) True >>> is_lucky_number(4321) True >>> is_lucky_number(987789) False","solution":"def is_lucky_number(n): Determines whether the given integer n is a lucky number. A lucky number has all its digits and the combinations of adjacent digits unique. str_n = str(n) seen = set() # Check each digit for digit in str_n: if digit in seen: return False seen.add(digit) # Check each pair of adjacent digits for i in range(len(str_n) - 1): adj_pair = str_n[i:i+2] if adj_pair in seen: return False seen.add(adj_pair) return True"},{"question":"def shortest_path(grid, start, end): Finds the shortest path in a 2D grid from start to end. :param grid: List of lists of \`0\` and \`1\`, where \`0\` is empty cell and \`1\` is obstacle. :param start: Tuple (start_x, start_y) representing the start coordinates. :param end: Tuple (end_x, end_y) representing the end coordinates. :return: The shortest path length or \`-1\` if no path exists. >>> shortest_path([[0, 0, 1], [0, 0, 0], [1, 0, 0]], (0, 0), (2, 2)) 4 >>> shortest_path([[0, 1, 1], [1, 1, 0], [1, 0, 0]], (0, 0), (2, 2)) -1 pass from collections import deque def test_shortest_path_exists(): grid = [ [0, 0, 1], [0, 0, 0], [1, 0, 0] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == 4 def test_no_path_exists(): grid = [ [0, 1, 1], [1, 1, 0], [1, 0, 0] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == -1 def test_no_path_when_start_is_obstacle(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == -1 def test_no_path_when_end_is_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] start = (0, 0) end = (2, 2) assert shortest_path(grid, start, end) == -1 def test_immediate_reach(): grid = [ [0, 0], [0, 0] ] start = (0, 0) end = (0, 1) assert shortest_path(grid, start, end) == 1 def test_large_grid(): grid = [ [0] * 50 for _ in range(50) ] start = (0, 0) end = (49, 49) assert shortest_path(grid, start, end) == 98","solution":"from collections import deque def shortest_path(grid, start, end): Finds the shortest path in a 2D grid from start to end. :param grid: List of lists of \`0\` and \`1\`, where \`0\` is empty cell and \`1\` is obstacle. :param start: Tuple (start_x, start_y) representing the start coordinates. :param end: Tuple (end_x, end_y) representing the end coordinates. :return: The shortest path length or \`-1\` if no path exists. if not grid or not grid[0] or grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def merge_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A merged and sorted array. Example: >>> merge_arrays([3, 5, 7], [1, 4, 6]) [1, 3, 4, 5, 6, 7] >>> merge_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_arrays([1], [2]) [1, 2]","solution":"def merge_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array. Parameters: arr1 (list): The first sorted array. arr2 (list): The second sorted array. Returns: list: A merged and sorted array. merged_array = [] i, j = 0, 0 # Use a two-pointer technique to merge the two sorted arrays while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements from arr1, if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements from arr2, if any while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def int_to_roman(num: int) -> str: Converts an integer to its Roman numeral representation. :param num: integer value to be converted to Roman numeral (1 <= num <= 3999) :type num: int :return: Roman numeral as a string :rtype: str >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV'","solution":"def int_to_roman(num): Converts an integer to its Roman numeral representation. :param num: integer value to be converted to Roman numeral (1 <= num <= 3999) :type num: int :return: Roman numeral as a string :rtype: str val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def organize_bulbs(n: int, d: int, bulbs: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines if it is possible to arrange bulbs in zones with the given constraints and returns the arrangement if possible. Args: n: An integer representing the number of zones. d: An integer representing the maximum allowed difference in the number of bulbs between two consecutive zones. bulbs: A list of integers where each integer represents the number of bulbs required for a specific zone. Returns: A tuple (\\"possible\\", List[int]) if the arrangement is possible, otherwise returns \\"impossible\\". Example: >>> organize_bulbs(5, 3, [1, 4, 5, 2, 6]) ('possible', [1, 2, 4, 5, 6]) >>> organize_bulbs(3, 0, [1, 2, 3]) 'impossible'","solution":"def organize_bulbs(n, d, bulbs): Determines if it is possible to arrange bulbs in zones with the given constraints and returns the arrangement if possible. bulbs.sort() for i in range(1, n): if bulbs[i] - bulbs[i - 1] > d: return \\"impossible\\" return \\"possible\\", bulbs"},{"question":"def printDiamond(n): Prints a diamond shape with 2n-1 rows using stars ('*'). The widest point will have 2n-1 stars. :param n: An integer representing the half-width of the diamond shape. >>> printDiamond(3) * *** ***** *** * >>> printDiamond(4) * *** ***** ******* ***** *** *","solution":"def printDiamond(n): Prints a diamond shape with 2n-1 rows using stars ('*'). The widest point will have 2n-1 stars. :param n: An integer representing the half-width of the diamond shape. if n < 1 or n > 10: raise ValueError(\\"The input n must be between 1 and 10 inclusive.\\") for i in range(n): print(' ' * (n - i - 1) + '*' * (2 * i + 1)) for i in range(n-2, -1, -1): print(' ' * (n - i - 1) + '*' * (2 * i + 1))"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findDiameter(root): Returns the diameter of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> findDiameter(root) 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findDiameter(root): Returns the diameter of the binary tree. def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth + 1) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter"},{"question":"def min_steps_to_reduce_to_zero(n: int) -> int: Calculate the minimum number of steps to reduce n to 0. In each step, if the number is even, divide by 2, else subtract 1. Args: n (int): A positive integer Returns: int: The minimum number of steps needed to reduce n to 0 Examples: >>> min_steps_to_reduce_to_zero(8) 4 >>> min_steps_to_reduce_to_zero(7) 5 >>> min_steps_to_reduce_to_zero(1) 1","solution":"def min_steps_to_reduce_to_zero(n): Function to calculate the minimum number of steps to reduce n to 0. steps = 0 while n > 0: if n % 2 == 0: n //= 2 else: n -= 1 steps += 1 return steps"},{"question":"def character_replacement(s: str, k: int) -> int: Write a function \`character_replacement\` that takes two arguments: a string \`s\` and an integer \`k\`. Your task is to return the length of the longest substring of \`s\` that can be obtained by replacing at most \`k\` characters in the original string \`s\` with any other character. >>> character_replacement(\\"AABABBA\\", 1) 4 >>> character_replacement(\\"AAAA\\", 2) 4 >>> character_replacement(\\"ABCDE\\", 1) 2 >>> character_replacement(\\"AABCDE\\", 10) 6 >>> character_replacement(\\"\\", 5) 0 >>> character_replacement(\\"A\\", 0) 1 >>> character_replacement(\\"AABBBCC\\", 0) 3 pass","solution":"def character_replacement(s: str, k: int) -> int: from collections import defaultdict max_len = 0 count = defaultdict(int) max_count = 0 start = 0 for end in range(len(s)): count[s[end]] += 1 max_count = max(max_count, count[s[end]]) if (end - start + 1) - max_count > k: count[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def find_max_window_median(array, queries): Find the maximum window median for each window size in queries. >>> find_max_window_median([2, 1, 5, 7, 2, 0, 5], [1, 2, 3]) [7, 5, 5] >>> find_max_window_median([1, 3, 4, 1, 5], [1, 4, 3, 2]) [5, 3, 4, 3] >>> find_max_window_median([1, 1, 1, 1, 1], [1, 2, 5]) [1, 1, 1] >>> find_max_window_median([5], [1]) [5] >>> find_max_window_median([9, 5, 6, 2, 7, 3, 1], [7]) [5]","solution":"def find_max_window_median(array, queries): def median(window): sorted_window = sorted(window) k = (len(sorted_window) - 1) // 2 return sorted_window[k] result = [] for w in queries: max_median = float('-inf') for i in range(len(array) - w + 1): median_value = median(array[i:i+w]) if median_value > max_median: max_median = median_value result.append(max_median) return result"},{"question":"def is_almost_equal_possible(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if an \\"almost equal\\" array exists for each test case. >>> is_almost_equal_possible(4, [(3, [1, 2, 3]), (4, [1, 1, 1, 1]), (5, [5, 5, 5, 5, 5]), (6, [1, 2, 2, 3, 3, 4])]) ['YES', 'NO', 'NO', 'YES'] >>> is_almost_equal_possible(1, [(1, [1])]) ['NO']","solution":"def is_almost_equal_possible(t, test_cases): results = [] for n, array in test_cases: array.sort() possible = False for i in range(1, n): if array[i] == array[i-1] + 1: possible = True break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_possible_popularity_sum(n: int, popularity_scores: List[int]) -> int: Returns the maximum possible sum of popularity scores of a contiguous group of participants using the same type of decoration. If all scores are negative, the result is 0. >>> max_possible_popularity_sum(5, [-1, 2, -3, 4, 5]) == 9 >>> max_possible_popularity_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_possible_popularity_sum(3, [-1, -2, -3]) == 0","solution":"def max_possible_popularity_sum(n, popularity_scores): Returns the maximum possible sum of popularity scores of a contiguous group of participants using the same type of decoration. If all scores are negative, the result is 0. max_ending_here = 0 max_so_far = 0 for score in popularity_scores: max_ending_here = max(0, max_ending_here + score) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List, Tuple def final_configuration_after_operations(test_cases: List[Tuple[List[List[int]], List[Tuple[int, int]]]]) -> List[List[List[int]]]: Determine the final configuration of shelves after performing remove operations. >>> final_configuration_after_operations([([[1], [2, 3], [4, 5, 6]], [(1, 1), (3, 2)]])) == [[[], [2, 3], [4, 6]]] >>> final_configuration_after_operations([([[1], [2, 3, 4], [5, 6, 7, 8]], [(2, 1), (2, 2), (1, 1), (3, 3)]])) == [[[], [3], [5, 6, 8]]]","solution":"def update_shelves_after_removals(shelves, removals): for i, j in removals: shelves[i-1].pop(j-1) return shelves def final_configuration_after_operations(test_cases): results = [] for shelves, removals in test_cases: updated_shelves = update_shelves_after_removals(shelves, removals) results.append(updated_shelves) return results"},{"question":"from typing import List def max_height_difference(heights: List[int]) -> int: Returns the maximum difference in height between any two students such that the taller student comes after the shorter one in the list. >>> max_height_difference([1, 2, 10, 4, 5]) 9 >>> max_height_difference([1, 1, 1, 1]) 0 >>> max_height_difference([20]) 0","solution":"from typing import List def max_height_difference(heights: List[int]) -> int: Returns the maximum difference in height between any two students such that the taller student comes after the shorter one in the list. if not heights or len(heights) < 2: return 0 min_height = heights[0] max_diff = 0 for height in heights[1:]: max_diff = max(max_diff, height - min_height) min_height = min(min_height, height) return max_diff"},{"question":"def find_substring(s: str, words: List[str]) -> List[int]: Find all starting indices of substrings in the given string that are a concatenation of each of the given words exactly once without any intervening characters. >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) []","solution":"def find_substring(s, words): Find all starting indices of substring(s) in s that are a concatenation of each word in words exactly once and without any intervening characters. if not s or not words or not words[0]: return [] word_length = len(words[0]) num_words = len(words) substring_length = word_length * num_words s_length = len(s) if s_length < substring_length: return [] words_count = {} for word in words: words_count[word] = words_count.get(word, 0) + 1 indices = [] for i in range(word_length): left = i right = i current_count = {} while right + word_length <= s_length: word = s[right:right+word_length] right += word_length if word in words_count: current_count[word] = current_count.get(word, 0) + 1 while current_count[word] > words_count[word]: left_word = s[left:left+word_length] current_count[left_word] -= 1 left += word_length if right - left == substring_length: indices.append(left) else: current_count.clear() left = right return indices"},{"question":"def find_two_sum_indices(nums, target): Returns a tuple (i, j) where i < j and nums[i] + nums[j] equals to the target. If no such pair exists, returns an empty tuple. >>> find_two_sum_indices([2, 7, 11, 15, 1], 9) (0, 1) >>> find_two_sum_indices([3, 3, 4], 6) (0, 1) >>> find_two_sum_indices([1, 2, 3, 4], 8) ()","solution":"def find_two_sum_indices(nums, target): Returns a tuple (i, j) where nums[i] + nums[j] equals to the target, and i < j. If no such pair exists, returns an empty tuple. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return ()"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Detects if there is a cycle in the linked list. :param head: ListNode, the head of the linked list :return: Boolean, True if there is a cycle, False otherwise pass # Unit tests def create_linked_list(values, pos): Helper function to create a linked list with a cycle. :param values: List of integers, the values for the linked list nodes :param pos: Integer, the position at which cycle begins (-1 for no cycle) :return: ListNode, the head of the created linked list if not values: return None nodes = [ListNode(val) for val in values] for i in range(len(values) - 1): nodes[i].next = nodes[i + 1] if pos != -1: nodes[-1].next = nodes[pos] return nodes[0] def test_hasCycle(): # Test case 1: Cycle exists head = create_linked_list([3, 2, 0, -4], 1) assert hasCycle(head) == True # Test case 2: Cycle exists head = create_linked_list([1, 2], 0) assert hasCycle(head) == True # Test case 3: No cycle head = create_linked_list([1], -1) assert hasCycle(head) == False # Test case 4: Larger cycle head = create_linked_list([1, 2, 3, 4, 5], 2) assert hasCycle(head) == True # Test case 5: No cycle with multiple nodes head = create_linked_list([1, 2, 3, 4, 5], -1) assert hasCycle(head) == False # Test case 6: Single node with cycle head = create_linked_list([1], 0) assert hasCycle(head) == True # Test case 7: Single node without cycle head = create_linked_list([1], -1) assert hasCycle(head) == False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def hasCycle(head: ListNode) -> bool: Detects if there is a cycle in the linked list. :param head: ListNode, the head of the linked list :return: Boolean, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def find_shortest_word(s: str) -> int: Returns the length of the shortest word in a string of space-separated words. Parameters: s (str): A string of space-separated words. Returns: int: The length of the shortest word in the string. Examples: >>> find_shortest_word(\\"The quick brown fox jumps over the lazy dog\\") 3 >>> find_shortest_word(\\"Silicon Valley coding challenges are really fun\\") 3 >>> find_shortest_word(\\"To be or not to be that is the question\\") 2 >>> find_shortest_word(\\"Lorem ipsum dolor sit amet consectetur adipiscing elit\\") 2","solution":"def find_shortest_word(s): Returns the length of the shortest word in a string of space-separated words. Parameters: s (str): A string of space-separated words. Returns: int: The length of the shortest word in the string. words = s.split() shortest_length = min(len(word) for word in words) return shortest_length"},{"question":"from collections import Counter def canFormPalindrome(s: str) -> bool: Determine if the string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase letters and digits. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"12321\\") True >>> canFormPalindrome(\\"122345\\") False >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"ab\\") False >>> canFormPalindrome(\\"aabbccdd\\") True >>> canFormPalindrome(\\"abcd\\") False >>> canFormPalindrome(\\"aabbccdde\\") True","solution":"from collections import Counter def canFormPalindrome(s): Determine if the string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase letters and digits. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For the string to be able to form a palindrome, at most one character can have an odd frequency return odd_count <= 1"},{"question":"import math def largest_square_plot(length: int, width: int) -> int: Determine the side length of the largest possible square plot that can evenly divide a rectangular field. Args: length (int): The length of the rectangular field. width (int): The width of the rectangular field. Returns: int: The side length of the largest possible square plot. >>> largest_square_plot(12, 15) 3 >>> largest_square_plot(10, 15) 5","solution":"import math def largest_square_plot(length, width): Returns the side length of the largest possible square plot that can evenly divide the given rectangular field. return math.gcd(length, width)"},{"question":"def non_decreasing_stock_prices(m, n, prices): This function returns the 1-based indices of companies whose stock prices do not decrease over n days. If no such company exists, returns -1. :param m: number of companies :param n: number of days :param prices: list of lists of integers, where each inner list contains stock prices of a company over n days :return: a list of 1-based indices or [-1] if no company is found >>> non_decreasing_stock_prices(3, 5, [ >>> [100, 101, 102, 102, 103], >>> [110, 109, 108, 107, 105], >>> [95, 95, 96, 96, 97]]) == [1, 3] >>> non_decreasing_stock_prices(2, 4, [ >>> [50, 49, 48, 47], >>> [60, 61, 60, 59]]) == [-1]","solution":"def non_decreasing_stock_prices(m, n, prices): This function returns the 1-based indices of companies whose stock prices do not decrease over n days. If no such company exists, returns -1. :param m: number of companies :param n: number of days :param prices: list of lists of integers, where each inner list contains stock prices of a company over n days :return: a list of 1-based indices or [-1] if no company is found non_decreasing_companies = [] for i in range(m): is_non_decreasing = True for j in range(n-1): if prices[i][j] > prices[i][j+1]: is_non_decreasing = False break if is_non_decreasing: non_decreasing_companies.append(i + 1) # Convert to 1-based index if not non_decreasing_companies: return [-1] return non_decreasing_companies"},{"question":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in the list that sum up to the target. >>> find_pairs_with_sum([4, 7, 11, -1, 4, -6, -5, 2, 8], 3) [(-5, 8), (-1, 4)] >>> find_pairs_with_sum([1, 5, 2, -2, 3, -1], 4) [(-1, 5), (1, 3)]","solution":"from typing import List, Tuple def find_pairs_with_sum(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in the list that sum up to the target. nums_sorted = sorted(nums) seen = set() pairs = set() for num in nums_sorted: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return sorted(pairs)"},{"question":"def detect_cycle(n, m, edges): Determine whether there is a cycle in the delivery route (undirected graph). Args: n (int): Number of cities (nodes). m (int): Number of direct delivery routes (edges). edges (List[Tuple[int, int]]): List of delivery routes represented as tuples of cities. Returns: str: \\"YES\\" if there is a cycle, \\"NO\\" otherwise. Examples: >>> detect_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> detect_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) 'NO' def test_detect_cycle_example1(): n = 4 m = 4 edges = [ (1, 2), (2, 3), (3, 4), (4, 1) ] assert detect_cycle(n, m, edges) == \\"YES\\" def test_detect_cycle_example2(): n = 4 m = 3 edges = [ (1, 2), (2, 3), (3, 4) ] assert detect_cycle(n, m, edges) == \\"NO\\" def test_detect_cycle_no_edges(): n = 5 m = 0 edges = [] assert detect_cycle(n, m, edges) == \\"NO\\" def test_detect_cycle_single_node(): n = 1 m = 0 edges = [] assert detect_cycle(n, m, edges) == \\"NO\\" def test_detect_cycle_self_loop(): n = 3 m = 1 edges = [ (1, 1) ] assert detect_cycle(n, m, edges) == \\"YES\\" def test_detect_cycle_large_cycle(): n = 6 m = 6 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1) ] assert detect_cycle(n, m, edges) == \\"YES\\" def test_detect_cycle_disconnected_graph(): n = 6 m = 3 edges = [ (1, 2), (3, 4), (5, 6) ] assert detect_cycle(n, m, edges) == \\"NO\\"","solution":"def detect_cycle(n, m, edges): from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\""},{"question":"def sort_even_numbers(nums: List[int]) -> List[int]: Create a function \`sort_even_numbers\` that takes a list of integers as an input and returns a new list where all the even numbers are sorted in ascending order, while the odd numbers retain their original positions. >>> sort_even_numbers([5, 3, 2, 8, 1, 4]) == [5, 3, 2, 4, 1, 8] >>> sort_even_numbers([2, 1, 2, 1, 2, 1]) == [2, 1, 2, 1, 2, 1] >>> sort_even_numbers([6, 5, 4, 3, 1, 2]) == [2, 5, 4, 3, 1, 6] pass from solution import sort_even_numbers def test_sort_even_numbers_example(): assert sort_even_numbers([5, 3, 2, 8, 1, 4]) == [5, 3, 2, 4, 1, 8] def test_sort_even_numbers_all_even(): assert sort_even_numbers([2, 4, 6, 8]) == [2, 4, 6, 8] def test_sort_even_numbers_all_odd(): assert sort_even_numbers([1, 3, 5, 7]) == [1, 3, 5, 7] def test_sort_even_numbers_mixed(): assert sort_even_numbers([2, 1, 2, 1, 2, 1]) == [2, 1, 2, 1, 2, 1] assert sort_even_numbers([6, 5, 4, 3, 1, 2]) == [2, 5, 4, 3, 1, 6] def test_sort_even_numbers_no_evens(): assert sort_even_numbers([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] def test_sort_even_numbers_no_odds(): assert sort_even_numbers([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] def test_sort_even_numbers_empty(): assert sort_even_numbers([]) == [] def test_sort_even_numbers_single_element(): assert sort_even_numbers([2]) == [2] assert sort_even_numbers([1]) == [1] def test_sort_even_numbers_same_evens(): assert sort_even_numbers([2, 8, 2]) == [2, 2, 8]","solution":"def sort_even_numbers(nums): # Extract the even numbers and sort them evens_sorted = sorted([num for num in nums if num % 2 == 0]) # Initialize an index for the sorted even numbers even_index = 0 # Create a new list to hold the results result = [] for num in nums: if num % 2 == 0: # Replace even numbers with sorted even numbers result.append(evens_sorted[even_index]) even_index += 1 else: # Keep odd numbers in their original positions result.append(num) return result"},{"question":"from typing import List def longest_unique_substring(s: str) -> str: Returns the longest substring that contains only unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"a\\") 'a' >>> longest_unique_substring(\\"au\\") 'au' >>> longest_unique_substring(\\" \\") ' ' >>> longest_unique_substring(\\"abcdefabcdefg\\") 'abcdefg' >>> longest_unique_substring(\\"dvdf\\") 'vdf' >>> longest_unique_substring(\\"anviaj\\") 'nviaj' >>> longest_unique_substring(\\"a\\" * 1000) 'a' >>> unique_chars = \\"\\".join(chr(i) for i in range(128)) >>> longest_unique_substring(unique_chars) unique_chars","solution":"def longest_unique_substring(s): Returns the longest substring that contains only unique characters. max_len = 0 max_substr = \\"\\" start = 0 char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_len = i - start + 1 if current_len > max_len: max_len = current_len max_substr = s[start:i+1] return max_substr"},{"question":"from typing import List def sum_of_unique_elements(lst: List[int]) -> int: Calculate the sum of unique elements in the list. >>> sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5]) 9 >>> sum_of_unique_elements([1, 1, 1, 1]) 0 >>> sum_of_unique_elements([10, -10, 10, -10, 20]) 20 pass","solution":"from typing import List from collections import Counter def sum_of_unique_elements(lst: List[int]) -> int: Returns the sum of unique elements in the list. count = Counter(lst) unique_sum = sum(k for k, v in count.items() if v == 1) return unique_sum"},{"question":"def calculate_elevation_changes(T, cases): Calculate the total elevation gain and loss from the data collected during the hiking trip. Args: T (int): The number of test cases. cases (list): A list of tuples where each tuple contains an integer n (the number of days) and a list of n integers (the daily changes in elevation). Returns: list: A list of tuples where each tuple contains two integers: the total elevation gain and the total elevation loss. pass def parse_input(input_str): Parse the input string into the appropriate components. Args: input_str (str): The input string. Returns: tuple: A tuple containing an integer T and a list of cases. pass def format_output(results): Format the output for the calculated results. Args: results (list): A list of tuples containing the total elevation gain and loss. Returns: str: A formatted string for the result. pass from solution import calculate_elevation_changes, parse_input, format_output def test_example_cases(): input_str = \\"2n7n100 -20 30 -10 -50 60 40n5n-10 20 -30 40 -50n\\" T, cases = parse_input(input_str) results = calculate_elevation_changes(T, cases) output_str = format_output(results) assert output_str == \\"230 -80n60 -90\\" def test_single_day_no_change(): input_str = \\"1n1n0n\\" T, cases = parse_input(input_str) results = calculate_elevation_changes(T, cases) output_str = format_output(results) assert output_str == \\"0 0\\" def test_all_gains(): input_str = \\"1n3n100 200 300n\\" T, cases = parse_input(input_str) results = calculate_elevation_changes(T, cases) output_str = format_output(results) assert output_str == \\"600 0\\" def test_all_losses(): input_str = \\"1n3n-100 -200 -300n\\" T, cases = parse_input(input_str) results = calculate_elevation_changes(T, cases) output_str = format_output(results) assert output_str == \\"0 -600\\" def test_mix_changes(): input_str = \\"1n5n50 -10 20 -40 10n\\" T, cases = parse_input(input_str) results = calculate_elevation_changes(T, cases) output_str = format_output(results) assert output_str == \\"80 -50\\"","solution":"def calculate_elevation_changes(T, cases): result = [] for i in range(T): n = cases[i][0] elevation_changes = cases[i][1] total_gain = sum(change for change in elevation_changes if change > 0) total_loss = sum(change for change in elevation_changes if change < 0) result.append((total_gain, total_loss)) return result def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) cases = [] current_line = 1 for _ in range(T): n = int(lines[current_line]) elevation_changes = list(map(int, lines[current_line + 1].split())) cases.append((n, elevation_changes)) current_line += 2 return T, cases def format_output(results): return 'n'.join(f\\"{gain} {loss}\\" for gain, loss in results)"},{"question":"from typing import List, Tuple def has_repeating_substring(S: str, K: int) -> str: Function to check if there exists a substring in S that appears at least K times. >>> has_repeating_substring(\\"abracadabra\\", 3) \\"YES\\" >>> has_repeating_substring(\\"banana\\", 2) \\"YES\\" >>> has_repeating_substring(\\"aaaaa\\", 3) \\"YES\\" >>> has_repeating_substring(\\"abcdef\\", 2) \\"NO\\" >>> has_repeating_substring(\\"aabbcc\\", 2) \\"YES\\" >>> has_repeating_substring(\\"abacabadabac\\", 3) \\"YES\\" >>> has_repeating_substring(\\"xyzxyz\\", 2) \\"YES\\" def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[str]: Function to process multiple test cases. >>> process_test_cases(3, [(\\"abracadabra\\", 3), (\\"banana\\", 2), (\\"aaaaa\\", 3)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [(\\"abcdef\\", 2), (\\"aabbcc\\", 2)]) [\\"NO\\", \\"YES\\"] >>> process_test_cases(2, [(\\"abacabadabac\\", 3), (\\"xyzxyz\\", 2)]) [\\"YES\\", \\"YES\\"]","solution":"def has_repeating_substring(S, K): Function to check if there exists a substring in S that appears at least K times. from collections import defaultdict # Frequency dictionary to store substrings' counts substr_count = defaultdict(int) # Loop to create all possible substrings and count occurrences for start in range(len(S)): for end in range(start, len(S)): substr = S[start:end + 1] substr_count[substr] += 1 if substr_count[substr] >= K: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): Function to process multiple test cases. results = [] for i in range(T): S, K = test_cases[i] result = has_repeating_substring(S, int(K)) results.append(result) return results"},{"question":"def can_modify_array(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[Tuple[str, List[int]]]: Determine if an array can be modified to become non-decreasing by changing at most k entries. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases where each test case is a tuple containing a tuple with number of elements and maximum number of changes allowed, and a list of integers representing the array. Returns: List[Tuple[str, List[int]]]: For each test case, return \\"YES\\" or \\"NO\\" and the modified array if possible. Example: >>> can_modify_array(2, [((5, 1), [5, 3, 4, 8, 2]), ((4, 0), [1, 2, 3, 4])]) [('YES', [5, 4, 4, 8, 8]), ('YES', [1, 2, 3, 4])]","solution":"def can_modify_array(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] original_arr = arr[:] arr.sort() min_change_needed = sum(1 for i in range(n) if arr[i] != original_arr[i]) if min_change_needed <= k: results.append((\\"YES\\", arr)) else: results.append((\\"NO\\", [])) return results"},{"question":"class Node: def __init__(self, val, next=None, prev=None, child=None): self.val = val self.next = next self.prev = prev self.child = child def flatten(head): Flatten the given doubly linked list so that all nodes appear in a single, depth-first traversal linked list. >>> head = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6)))))) >>> head.next.child = Node(7, Node(8, Node(9, Node(10)))) >>> head.next.child.next.child = Node(11, Node(12)) >>> list_to_array(flatten(head)) [1, 2, 7, 8, 11, 12, 9, 10, 3, 4, 5, 6] >>> head = Node(1, Node(2)) >>> head.next.child = Node(3) >>> list_to_array(flatten(head)) [1, 2, 3] pass def list_to_array(head): result = [] while head: result.append(head.val) head = head.next return result","solution":"class Node: def __init__(self, val, next=None, prev=None, child=None): self.val = val self.next = next self.prev = prev self.child = child def flatten(head): if not head: return head dummy = Node(0) dummy.next = head prev = dummy stack = [head] while stack: curr = stack.pop() prev.next = curr curr.prev = prev if curr.next: stack.append(curr.next) if curr.child: stack.append(curr.child) curr.child = None prev = curr dummy.next.prev = None return dummy.next"},{"question":"from typing import List def max_xor_subarray(arr: List[int]) -> int: Solve for the maximum XOR sum that can be obtained from any subarray of the given array. >>> max_xor_subarray([1, 2, 3]) 3 >>> max_xor_subarray([8, 1, 2, 12]) 15 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Process multiple test cases to determine the maximum XOR sum achievable for each subarray provided. >>> process_test_cases([[1, 2, 3], [8, 1, 2, 12]]) [3, 15] >>> process_test_cases([[10, 20], [1, 1, 1]]) [30, 1] pass # Sample usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) array = list(map(int, data[index + 1:index + 1 + N])) test_cases.append(array) index += 1 + N results = process_test_cases(test_cases) for result in results: print(result)","solution":"class TrieNode: def __init__(self): self.children = {} self.value = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, num): node = self.root for i in range(29, -1, -1): bit = (num >> i) & 1 if bit not in node.children: node.children[bit] = TrieNode() node = node.children[bit] node.value = num def query(self, num): if not self.root.children: return num node = self.root max_xor = 0 for i in range(29, -1, -1): bit = (num >> i) & 1 toggled_bit = 1 - bit if toggled_bit in node.children: max_xor |= (1 << i) node = node.children[toggled_bit] else: node = node.children[bit] return max_xor def max_xor_subarray(arr): trie = Trie() prefix_xor = 0 max_xor = float('-inf') trie.insert(0) for num in arr: prefix_xor ^= num trie.insert(prefix_xor) max_xor = max(max_xor, trie.query(prefix_xor)) return max_xor def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(max_xor_subarray(arr)) return results # Implementing the input/output according to the problem's requirement def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) array = list(map(int, data[index + 1:index + 1 + N])) test_cases.append(array) index += 1 + N results = process_test_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. # Implement the logic to determine if a number n is prime. def prime_sum_result(Y: int, B: int) -> str: Checks if the sum of Y and B is a prime number. If it is, returns \\"Prime\\"; otherwise \\"Not Prime\\". # Implement the logic to check if the sum of Y and B is prime. # Example usage: if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split() Y = int(input_data[0]) B = int(input_data[1]) print(prime_sum_result(Y, B))","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_sum_result(Y, B): Checks if the sum of Y and B is a prime number. If it is, returns \\"Prime\\"; otherwise \\"Not Prime\\". sum_value = Y + B if is_prime(sum_value): return \\"Prime\\" else: return \\"Not Prime\\" # Example usage: if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split() Y = int(input_data[0]) B = int(input_data[1]) print(prime_sum_result(Y, B))"},{"question":"def max_of_three(x: int, y: int, z: int) -> int: Returns the maximum value among three integers x, y, and z. >>> max_of_three(5, 12, 8) 12 >>> max_of_three(0, 5, 3) 5 >>> max_of_three(7, 7, 7) 7 >>> max_of_three(1, 99, 50) 99 >>> max_of_three(100, 99, 98) 100","solution":"def max_of_three(x, y, z): Returns the maximum of three integers x, y, and z. return max(x, y, z)"},{"question":"def sum_of_digits(N: int) -> int: Calculate and print the sum of the digits of a positive integer N. :param N: A positive integer :return: The sum of the digits of N >>> sum_of_digits(12345) 15 >>> sum_of_digits(5) 5 >>> sum_of_digits(9876543210) 45 >>> sum_of_digits(999999999999999999) 162 >>> sum_of_digits(102030) 6","solution":"def sum_of_digits(N): Returns the sum of the digits of the positive integer N. return sum(int(digit) for digit in str(N))"},{"question":"def min_total_height(N: int, books: List[Tuple[int, int]], W: int) -> int: Calculate the minimum total height of the bookshelf given the constraints. Args: N : int : the number of books books : List[Tuple[int, int]] : a list of tuples where each tuple contains the width and height of a book W : int : the maximum allowable width of each shelf Returns: int : the minimum total height of the bookshelf Examples: >>> min_total_height(4, [(1, 3), (2, 4), (3, 2), (1, 6)], 5) 10 >>> min_total_height(1, [(2, 3)], 5) 3 >>> min_total_height(3, [(1, 2), (2, 3), (2, 4)], 5) 4 >>> min_total_height(3, [(1, 2), (2, 3), (3, 1)], 6) 3 >>> min_total_height(4, [(3, 1), (3, 2), (3, 3), (3, 4)], 3) 10","solution":"def min_total_height(N, books, W): dp = [0] * (N + 1) for i in range(1, N + 1): width_sum = 0 height_max = 0 dp[i] = float('inf') for j in range(i, 0, -1): width_sum += books[j-1][0] if width_sum > W: break height_max = max(height_max, books[j-1][1]) dp[i] = min(dp[i], dp[j-1] + height_max) return dp[N]"},{"question":"def check_anagrams(secret_codes): Determines if any two secret codes in the list are anagrams. Args: secret_codes: List of strings, where each string is a secret code. Returns: \\"Anagrams found\\" if any two codes are anagrams, else \\"Unique codes\\". pass # Example usage: # N = 5 # secret_codes = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"] # print(check_anagrams(secret_codes)) # Output: Anagrams found # Unit tests: from solution import check_anagrams def test_anagrams_found(): codes = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"] assert check_anagrams(codes) == \\"Anagrams found\\" def test_unique_codes(): codes = [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"] assert check_anagrams(codes) == \\"Unique codes\\" def test_single_code(): codes = [\\"abcdef\\"] assert check_anagrams(codes) == \\"Unique codes\\" def test_repeated_codes(): codes = [\\"abc\\", \\"bca\\", \\"cab\\"] assert check_anagrams(codes) == \\"Anagrams found\\" def test_long_codes(): codes = [\\"a\\" * 99 + \\"b\\", \\"a\\" * 100, \\"c\\" * 100] assert check_anagrams(codes) == \\"Unique codes\\" def test_large_number_of_codes(): codes = [\\"\\".join(sorted([\\"aaa\\", \\"bbb\\", \\"ccc\\"][i % 3])) for i in range(100000)] assert check_anagrams(codes) == \\"Anagrams found\\"","solution":"def check_anagrams(secret_codes): Determines if any two secret codes in the list are anagrams. Args: secret_codes: List of strings, where each string is a secret code. Returns: \\"Anagrams found\\" if any two codes are anagrams, else \\"Unique codes\\". seen = set() for code in secret_codes: sorted_code = ''.join(sorted(code)) if sorted_code in seen: return \\"Anagrams found\\" seen.add(sorted_code) return \\"Unique codes\\" # Example usage: # N = 5 # secret_codes = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"hello\\", \\"world\\"] # print(check_anagrams(secret_codes)) # Output: Anagrams found"},{"question":"from typing import List, Tuple def minimum_containers(containers: List[Tuple[int, int, int, int]], items: List[Tuple[int, int, int, int]]) -> int: Determine the minimum number of containers required to ship all items. Parameters: containers (List[Tuple[int, int, int, int]]): List of tuples, each representing dimensions and weight limit of a container. items (List[Tuple[int, int, int, int]]): List of tuples, each representing dimensions and weight of an item. Returns: int: The minimum number of containers required to ship all items, or -1 if it's not possible. Example: >>> containers = [(2, 2, 2, 50), (3, 2, 2, 75)] >>> items = [(1, 1, 1, 10), (2, 1, 1, 20), (1, 2, 1, 25), (3, 2, 1, 50)] >>> minimum_containers(containers, items) 2","solution":"from typing import List, Tuple def minimum_containers(containers: List[Tuple[int, int, int, int]], items: List[Tuple[int, int, int, int]]) -> int: # Helper function to check if an item can fit in a container def can_fit(item, container): return (item[0] <= container[0] and item[1] <= container[1] and item[2] <= container[2] and item[3] <= container[3]) # Sort containers by volume (descending) and weight limit (descending) containers = sorted(containers, key=lambda x: (x[0] * x[1] * x[2], x[3]), reverse=True) # Sort items by volume (descending) and weight (descending) items = sorted(items, key=lambda x: (x[0] * x[1] * x[2], x[3]), reverse=True) # Initialize the container count container_count = 0 while items: container_found = False for i, container in enumerate(containers): total_weight = 0 volume = container[0] * container[1] * container[2] remaining_items = [] for item in items: if can_fit(item, container) and total_weight + item[3] <= container[3]: total_weight += item[3] volume -= item[0] * item[1] * item[2] else: remaining_items.append(item) if total_weight > 0: container_count += 1 items = remaining_items container_found = True break if not container_found: return -1 return container_count"},{"question":"def maximum_thrill(N: int, thrill_levels: List[int]) -> int: Determine the maximum thrill level a rider can achieve on the ride by boarding and alighting at any stations. Parameters ---------- N : int The number of stations. thrill_levels : List[int] A list of integers representing thrill levels of each station. Returns ------- int The maximum thrill level achieved. Examples -------- >>> maximum_thrill(5, [1, -2, 3, -1, 2]) 5 >>> maximum_thrill(3, [1, 2, 3]) 6 >>> maximum_thrill(3, [-1, -2, -3]) -1 >>> maximum_thrill(4, [0, 0, 0, 0]) 0 >>> maximum_thrill(5, [3, -1, -1, -1, 4]) 7 >>> maximum_thrill(4, [1, -9999, 3, 2]) 6 >>> maximum_thrill(2, [-1, 3]) 3","solution":"def maximum_thrill(N, thrill_levels): Finds the maximum thrill level that can be achieved by riding between two stations. Parameters ---------- N : int The number of stations. thrill_levels : List[int] A list of integers representing thrill levels of each station. Returns ------- int The maximum thrill level achieved. # Helper function to find max subarray sum using Kadane's algorithm def kadane(array): max_so_far = array[0] max_ending_here = array[0] for i in range(1, len(array)): max_ending_here = max(array[i], max_ending_here + array[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far # Directly get the max subarray sum for the thrill levels max_sum_kadane = kadane(thrill_levels) # Now we need to consider the circular nature of the array. total_sum = sum(thrill_levels) inverted_thrill_levels = [-x for x in thrill_levels] min_sum_kadane = kadane(inverted_thrill_levels) max_sum_circular = total_sum + min_sum_kadane # Handle the case where all elements are negative if max_sum_circular == 0: return max_sum_kadane return max(max_sum_kadane, max_sum_circular)"},{"question":"from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganizes the string so that no two adjacent characters are the same. :param s: The input string consisting of lowercase English letters. :return: A rearranged string or empty string if it's not possible. -----Examples----- >>> reorganize_string(\\"aab\\") == \\"aba\\" >>> reorganize_string(\\"aaab\\") == \\"\\" pass def test_reorganize_string_possible(): assert reorganize_string(\\"aab\\") == \\"aba\\" assert reorganize_string(\\"aaabbc\\") != \\"\\" # Any valid answer is fine assert reorganize_string(\\"aabbcc\\") != \\"\\" # Any valid answer is fine assert reorganize_string(\\"abc\\") == \\"abc\\" # Already valid def test_reorganize_string_impossible(): assert reorganize_string(\\"aaab\\") == \\"\\" assert reorganize_string(\\"aaa\\") == \\"\\" assert reorganize_string(\\"aaaaaab\\") == \\"\\" def test_reorganize_string_edge_cases(): assert reorganize_string(\\"a\\") == \\"a\\" # Single character assert reorganize_string(\\"aa\\") == \\"\\" # Impossible for two identical characters assert reorganize_string(\\"ab\\") == \\"ab\\" # Already valid","solution":"from collections import Counter import heapq def reorganize_string(s): Reorganizes the string so that no two adjacent characters are the same. :param s: The input string consisting of lowercase English letters. :return: A rearranged string or empty string if it's not possible. counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 result_string = ''.join(result) if len(result_string) != len(s): return '' # impossible to reorganize return result_string"},{"question":"def first_n_happy_numbers(n: int) -> List[int]: Generate the list of the first n happy numbers. >>> first_n_happy_numbers(5) [1, 7, 10, 13, 19] >>> first_n_happy_numbers(8) [1, 7, 10, 13, 19, 23, 28, 31] >>> first_n_happy_numbers(1) [1] >>> first_n_happy_numbers(10) [1, 7, 10, 13, 19, 23, 28, 31, 32, 44]","solution":"def is_happy(number): seen = set() while number != 1 and number not in seen: seen.add(number) number = sum(int(digit) ** 2 for digit in str(number)) return number == 1 def first_n_happy_numbers(n): happy_numbers = [] num = 1 while len(happy_numbers) < n: if is_happy(num): happy_numbers.append(num) num += 1 return happy_numbers # Example usages: # print(first_n_happy_numbers(5)) # Output: [1, 7, 10, 13, 19] # print(first_n_happy_numbers(8)) # Output: [1, 7, 10, 13, 19, 23, 28, 31]"},{"question":"def solve_competition(N, initial_problems, Q, queries): Process a series of queries for a programming competition and return the required results. Args: N (int): The number of participants. initial_problems (List[int]): The initial number of problems solved by each participant. Q (int): The number of queries. queries (List[str]): A list of queries. Each query is either \\"1 X Y\\" to update problems solved, or \\"2 K L R\\" to find the K-th smallest number of problems solved. Returns: List[int]: The results of the queries that asked for the K-th smallest number of problems solved. Examples: >>> solve_competition(5, [3, 1, 6, 4, 2], 4, [\\"2 3 1 5\\", \\"1 2 3\\", \\"2 1 2 4\\", \\"2 2 1 5\\"]) [3, 4, 3]","solution":"def solve_competition(N, initial_problems, Q, queries): problems_solved = initial_problems[:] result = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": X = int(parts[1]) Y = int(parts[2]) problems_solved[X - 1] += Y elif parts[0] == \\"2\\": K = int(parts[1]) L = int(parts[2]) R = int(parts[3]) sorted_problems = sorted(problems_solved[L - 1:R]) result.append(sorted_problems[K - 1]) return result"},{"question":"def num_paths(H, W, grid): Calculate the number of different paths from the top-left corner (1,1) to the bottom-right corner (H,W) in a grid that contains obstacles. >>> num_paths(3, 3, [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]) 2 >>> num_paths(3, 3, [ ['.', '#', '.'], ['#', '#', '.'], ['.', '#', '.'] ]) 0 >>> num_paths(1, 5, [ ['.', '.', '.', '.', '.'] ]) 1 >>> num_paths(5, 1, [ ['.'], ['.'], ['.'], ['.'], ['.'] ]) 1 >>> num_paths(3, 3, [ ['#', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]) 0 >>> num_paths(3, 3, [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '#'] ]) 0 >>> num_paths(3, 3, [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ]) 6","solution":"def num_paths(H, W, grid): # Return 0 if the start or end points are obstacles if grid[0][0] == '#' or grid[H-1][W-1] == '#': return 0 dp = [[0] * W for _ in range(H)] dp[0][0] = 1 # Start point # Fill in the dp table for i in range(H): for j in range(W): if grid[i][j] == '#': dp[i][j] = 0 elif i == 0 and j > 0: dp[i][j] = dp[i][j-1] elif i > 0 and j == 0: dp[i][j] = dp[i-1][j] elif i > 0 and j > 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[H-1][W-1]"},{"question":"from typing import List def checkSubarraySum(nums: List[int], k: int) -> bool: Returns true if the array has a continuous subarray of size at least two whose elements sum up to a multiple of k otherwise returns false. Args: nums (List[int]): The integer array. k (int): The integer value for multiple checking. Returns: bool: True if such a subarray exists, False otherwise. Examples: >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 13) False","solution":"def checkSubarraySum(nums, k): Returns true if the array has a continuous subarray of size at least two whose elements sum up to a multiple of k, otherwise returns false. prefix_sum = 0 mod_map = {0: -1} # Dictionary to store prefix sum % k for i in range(len(nums)): prefix_sum += nums[i] if k != 0: prefix_sum %= k if prefix_sum in mod_map: if i - mod_map[prefix_sum] > 1: return True else: mod_map[prefix_sum] = i return False"},{"question":"from typing import List, Tuple def minimum_boxes(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the minimum number of boxes required to meet or exceed the desired number of candies for each test case. If it is not possible to meet or exceed the exact number of candies with the given boxes, return -1. Args: T (int): Number of test cases. cases (List[Tuple[int, int, List[int]]]): List of tuples, each containing: - N (int): Number of available boxes. - M (int): Desired number of candies. - List of integers representing the number of candies in each box. Returns: List[int]: List of results where each element is the minimum number of boxes required or -1 if not possible. Examples: >>> minimum_boxes(3, [(5, 9, [1, 2, 3, 4, 5]), (4, 10, [1, 1, 1, 1]), (3, 7, [10, 20, 30])]) [2, -1, 1] >>> minimum_boxes(1, [(5, 5, [1, 1, 1, 2, 2])]) [3]","solution":"def minimum_boxes(T, cases): results = [] for case in cases: N, M, boxes = case boxes.sort(reverse=True) # Sort boxes by the number of candies in descending order total_candies = 0 count = 0 for box in boxes: total_candies += box count += 1 if total_candies >= M: results.append(count) break else: results.append(-1) return results"},{"question":"import math def count_combinations(p: int, q: int) -> int: Determine the number of different combinations in which Valeria can choose exactly p spices out of q available spices. >>> count_combinations(2, 4) 6 >>> count_combinations(3, 5) 10 >>> count_combinations(0, 0) 1 # Your code here from solution import count_combinations def test_example_case1(): assert count_combinations(2, 4) == 6 def test_example_case2(): assert count_combinations(3, 5) == 10 def test_example_case3(): assert count_combinations(0, 0) == 1 def test_example_case4(): assert count_combinations(1, 7) == 7 def test_edge_case_p_equals_q(): assert count_combinations(5, 5) == 1 def test_edge_case_p_zero(): assert count_combinations(0, 100) == 1 def test_random_case(): assert count_combinations(3, 7) == 35 def test_large_values(): assert count_combinations(50, 100) == 100891344545564193334812497256","solution":"import math def count_combinations(p, q): Returns the number of ways to choose p spices out of q available spices. This is calculated using the binomial coefficient C(q, p) = q! / (p! * (q-p)!) return math.comb(q, p)"},{"question":"def count_xor_subarrays(n: int, k: int, A: List[int]) -> int: Find the number of subarrays of A such that the XOR of every element in the subarray is exactly equal to k. >>> count_xor_subarrays(5, 4, [3, 4, 7, 3, 0]) == 3 >>> count_xor_subarrays(3, 1, [1, 2, 3]) == 2 pass","solution":"def count_xor_subarrays(n, k, A): count = 0 prefix_xor = 0 freq = {0: 1} for num in A: prefix_xor ^= num required_xor = prefix_xor ^ k if required_xor in freq: count += freq[required_xor] if prefix_xor in freq: freq[prefix_xor] += 1 else: freq[prefix_xor] = 1 return count"},{"question":"from typing import List, Tuple def find_safety_paths(N: int, bridges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the total safety of paths between multiple pairs of treehouses for a single day's configuration of safety scores. Args: N (int): the number of treehouses. bridges (List[Tuple[int, int, int]]): A list of tuples, each containing three integers U, V, and S indicating a bridge between treehouse U and treehouse V with safety score S. queries (List[Tuple[int, int]]): A list of tuples, each containing two integers A and B, indicating a query where you need to find the total safety of the path between treehouses A and B. Returns: List[int]: A list containing the total safety scores for each query. Example: >>> find_safety_paths(5, [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 1)], [(1, 4), (1, 5), (3, 4)]) [6, 5, 9] >>> find_safety_paths(3, [(1, 2, 1), (2, 3, 2)], [(1, 3), (3, 1)]) [3, 3]","solution":"from collections import defaultdict, deque def find_safety_paths(N, bridges, queries): # Build the adjacency list adj_list = defaultdict(list) for u, v, s in bridges: adj_list[u].append((v, s)) adj_list[v].append((u, s)) def bfs_find_path_safety(start, end): queue = deque([(start, 0)]) visited = set() while queue: current, safety_score = queue.popleft() if current == end: return safety_score visited.add(current) for neighbor, score in adj_list[current]: if neighbor not in visited: queue.append((neighbor, safety_score + score)) return -1 # this line should not be reached because the graph is connected results = [] for a, b in queries: results.append(bfs_find_path_safety(a, b)) return results # Example usage: # N = 5 # bridges = [(1, 2, 4), (1, 3, 3), (2, 4, 2), (2, 5, 1)] # queries = [(1, 4), (1, 5), (3, 4)] # print(find_safety_paths(N, bridges, queries)) # Output: [6, 5, 9]"},{"question":"class SegmentTree: def __init__(self, data, func, default_value): # Initialize the segment tree. def update(self, idx, value): # Update the value at index \`idx\`. def query(self, left, right): # Query the range from \`left\` to \`right\`. def process_queries(N, A, M, queries): Given an array A of length N and M queries to process, perform the specified operations and return the results. Each query is of one of the following types: 1. UPDATE i x: update the element at index i in the array to x. 2. SUM l r: output the sum of elements in the subarray starting from index l to r. 3. MIN l r: output the minimum element in the subarray starting from index l to r. >>> process_queries(8, [5, 3, 8, 6, 3, 7, 4, 2], 5, [\\"UPDATE 3 10\\", \\"SUM 2 5\\", \\"MIN 4 7\\", \\"UPDATE 6 1\\", \\"MIN 5 8\\"]) [22, 3, 1] >>> process_queries(5, [1, 2, 3, 4, 5], 3, [\\"SUM 1 5\\", \\"MIN 2 4\\", \\"UPDATE 5 1\\"]) [15, 2]","solution":"class SegmentTree: def __init__(self, data, func, default_value): self.n = len(data) self.tree = [default_value] * (2 * self.n) self.func = func self.default_value = default_value # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1]) def query(self, left, right): result = self.default_value left += self.n right += self.n while left <= right: if left % 2 == 1: result = self.func(result, self.tree[left]) left += 1 if right % 2 == 0: result = self.func(result, self.tree[right]) right -= 1 left //= 2 right //= 2 return result def process_queries(N, A, M, queries): sum_tree = SegmentTree(A, lambda x, y: x + y, 0) min_tree = SegmentTree(A, min, float('inf')) result = [] for query in queries: parts = query.split() if parts[0] == \\"UPDATE\\": idx = int(parts[1]) - 1 value = int(parts[2]) sum_tree.update(idx, value) min_tree.update(idx, value) elif parts[0] == \\"SUM\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 result.append(sum_tree.query(l, r)) elif parts[0] == \\"MIN\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 result.append(min_tree.query(l, r)) return result"},{"question":"def maximize_starting_bid(n: int, q: int, items: List[Tuple[int, int]]) -> int: Returns the total starting bid of the items that meet at least the minimum required quality score. >>> maximize_starting_bid(5, 50, [(200, 40), (300, 60), (150, 50), (400, 55), (100, 30)]) 850 >>> maximize_starting_bid(5, 50, [(200, 40), (300, 45), (150, 30), (400, 10), (100, 20)]) 0 >>> maximize_starting_bid(5, 50, [(200, 60), (300, 70), (150, 80), (400, 90), (100, 100)]) 1150 >>> maximize_starting_bid(5, 50, [(200, 60), (300, 40), (150, 55), (400, 10), (100, 95)]) 450 >>> maximize_starting_bid(5, 50, [(200, 50), (300, 50), (150, 50), (400, 50), (100, 50)]) 1150 >>> maximize_starting_bid(5, 50, [(200, 40), (300, 30), (150, 20), (400, 50), (100, 10)]) 400","solution":"def maximize_starting_bid(n, q, items): Returns the total starting bid of the items that meet at least the minimum required quality score. Parameters: n (int): number of items q (int): minimum required quality score items (list of tuples): each tuple contains (starting bid, quality score) Returns: int: total starting bid of the items that meet the quality threshold total_bid = sum(s for s, k in items if k >= q) return total_bid"},{"question":"def construct_tree(N: int) -> List[Tuple[int, int]]: Constructs a tree with N nodes such that each node has a unique integer label from 1 to N, and the depth of each node is less than or equal to 2. Parameters: N (int): The number of nodes. Returns: List[Tuple[int, int]]: A list of edges (a_i, b_i) representing the tree. >>> construct_tree(5) [(1, 2), (1, 3), (1, 4), (1, 5)] >>> construct_tree(7) [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)] >>> construct_tree(3) [(1, 2), (1, 3)] >>> construct_tree(100) [(1, i) for i in range(2, 101)] pass # Your code here from typing import List, Tuple def test_construct_tree_five_nodes(): output = construct_tree(5) expected = [(1, 2), (1, 3), (1, 4), (1, 5)] assert output == expected def test_construct_tree_seven_nodes(): output = construct_tree(7) expected = [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7)] assert output == expected def test_construct_tree_min_three_nodes(): output = construct_tree(3) expected = [(1, 2), (1, 3)] assert output == expected def test_construct_tree_max_decoder_nodes(): output = construct_tree(100) expected = [(1, i) for i in range(2, 101)] assert output == expected","solution":"def construct_tree(N): Constructs a tree with N nodes such that each node has a unique integer label from 1 to N, and the depth of each node is less than or equal to 2. Parameters: N (int): The number of nodes. Returns: List[Tuple[int, int]]: A list of edges (a_i, b_i) representing the tree. edges = [] if N <= 0: return edges # Add edges for the root node (node 1) and its children (nodes 2, 3, ..., min(N, X+1)) for i in range(2, N + 1): # Node 2 to N will be direct children of node 1 edges.append((1, i)) return edges"},{"question":"def can_assign_items_to_containers(container_weights, item_weights): Determines if items can be efficiently assigned to containers without exceeding each container's maximum weight capacity. :param container_weights: List of integers representing the maximum weight capacity of each container. :param item_weights: List of integers representing the weight of each item. :return: \\"YES\\" if items can be assigned efficiently, otherwise \\"NO\\". >>> can_assign_items_to_containers([50, 60, 70], [20, 30, 50, 10, 40]) \\"YES\\" >>> can_assign_items_to_containers([100, 150], [100, 75, 80, 90]) \\"NO\\"","solution":"def can_assign_items_to_containers(container_weights, item_weights): Determines if items can be efficiently assigned to containers without exceeding each container's maximum weight capacity. :param container_weights: List of integers representing the maximum weight capacity of each container. :param item_weights: List of integers representing the weight of each item. :return: \\"YES\\" if items can be assigned efficiently, otherwise \\"NO\\". container_weights.sort(reverse=True) item_weights.sort(reverse=True) for item in item_weights: placed = False for i in range(len(container_weights)): if container_weights[i] >= item: container_weights[i] -= item placed = True break if not placed: return \\"NO\\" return \\"YES\\" def handle_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 C = int(data[index]) index += 1 container_weights = [] for _ in range(C): container_weights.append(int(data[index])) index += 1 I = int(data[index]) index += 1 item_weights = [] for _ in range(I): item_weights.append(int(data[index])) index += 1 result = can_assign_items_to_containers(container_weights, item_weights) print(result)"},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> int: Determine the minimum number of moves required for the robot to reach the destination from the starting point in a n x m grid warehouse. The warehouse grid contains open cells('.') and blocked cells ('#'). The robot can move one cell at a time up, down, left, or right but cannot move diagonally or through blocked cells. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): A list of strings representing the grid cells. sx (int): The starting x-coordinate. sy (int): The starting y-coordinate. dx (int): The destination x-coordinate. dy (int): The destination y-coordinate. Returns: int: The minimum number of moves required to reach the destination, or -1 if no valid path exists. Example: >>> min_moves(5, 5, [\\".....\\", \\".#.#.\\", \\"..#..\\", \\".#.\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"], 0, 0, 2, 2) -1","solution":"from collections import deque def min_moves(n, m, grid, sx, sy, dx, dy): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (dx, dy): return dist for direction in directions: nx, ny = x + direction[0], y + direction[1] if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_solar_panels(N: int, K: int, E: List[int]) -> int: Returns the maximum number of solar panels that can be installed while satisfying the constraint that any two adjacent solar panels in the array must have a difference in efficiency that does not exceed K. >>> max_solar_panels(5, 3, [10, 12, 14, 9, 18]) 3 >>> max_solar_panels(4, 0, [5, 5, 5, 5]) 4 >>> max_solar_panels(3, 1, [1, 10, 20]) 1 >>> max_solar_panels(1, 10, [7]) 1 >>> max_solar_panels(3, 1000, [1, 2, 3]) 3 >>> max_solar_panels(4, 6, [10, 20, 15, 5]) 2 >>> max_solar_panels(4, 0, [1, 10, 13, 14]) 1 >>> max_solar_panels(100000, 1, [i for i in range(1, 100001)]) 2 pass","solution":"def max_solar_panels(N, K, E): Returns the maximum number of solar panels that can be installed while satisfying the constraint that any two adjacent solar panels in the array must have a difference in efficiency that does not exceed K. # Step 1: Sort the efficiencies array E.sort() # Step 2: Use a sliding window approach to find the longest subarray max_length = 1 start = 0 for end in range(1, N): while E[end] - E[start] > K: start += 1 max_length = max(max_length, end - start + 1) return max_length # Read from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) E = list(map(int, data[2:])) print(max_solar_panels(N, K, E))"},{"question":"def twoSum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers such that they add up to target. >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([3, 3], 6) [0, 1] >>> twoSum([-3, 4, 3, 90], 0) [0, 2] >>> twoSum([10**9, -10**9, 3, 4], 7) [2, 3]","solution":"def twoSum(nums, target): Returns indices of the two numbers such that they add up to target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"def calculate_largest_rectangle_area(R: int, C: int, grid: List[str]) -> int: Given a grid of cells, find the largest rectangle of contiguous filled cells and return its area. >>> calculate_largest_rectangle_area(4, 5, [\\"1 0 1 0 0\\", \\"1 0 1 1 1\\", \\"1 1 1 1 1\\", \\"1 0 0 1 0\\"]) 6 >>> calculate_largest_rectangle_area(2, 2, [\\"1 1\\", \\"1 1\\"]) 4 >>> calculate_largest_rectangle_area(3, 3, [\\"0 0 0\\", \\"1 1 1\\", \\"1 1 1\\"]) 6 >>> calculate_largest_rectangle_area(3, 4, [\\"0 0 0 0\\", \\"0 1 1 0\\", \\"0 1 1 0\\"]) 4 >>> calculate_largest_rectangle_area(1, 1, [\\"0\\"]) 0 >>> calculate_largest_rectangle_area(1, 2, [\\"1 1\\"]) 2 >>> calculate_largest_rectangle_area(0, 0, []) 0 pass","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 n = len(matrix[0]) height = [0] * (n + 1) for row in matrix: for i in range(n): height[i] = height[i] + 1 if row[i] == 1 else 0 stack = [-1] for i in range(n + 1): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] max_area = max(max_area, h * w) stack.append(i) return max_area # Parsing input def calculate_largest_rectangle_area(R, C, grid): matrix = [] for row in grid: matrix.append([int(x) for x in row.split()]) return maximalRectangle(matrix)"},{"question":"def count_sentences(text: str) -> int: Counts the number of sentences in a given text. Args: text (str): Input text containing sentences. Returns: int: The number of sentences in the text. >>> count_sentences(\\"Hello.\\") 1 >>> count_sentences(\\"Hello! How are you? I'm good.\\") 3 >>> count_sentences(\\"Hello there how are you doing\\") 0 >>> count_sentences(\\"Hello! How are you? I hope you are doing fine. Have a nice day!\\") 4 >>> count_sentences(\\"A quick!brown fox jumps. Over? the lazy dog!\\") 4 >>> count_sentences(\\"It was a bright cold day in April, and the clocks were striking thirteen. Winston Smith, his chin nuzzled into his breast in an effort to escape the vile wind, slipped quickly through the glass doors of Victory Mansions, though not quickly enough to prevent a swirl of gritty dust from entering along with him.\\") 2","solution":"def count_sentences(text): Counts the number of sentences in a given text. Args: text (str): Input text containing sentences. Returns: int: The number of sentences in the text. # Define sentence ending punctuation sentence_endings = {'.', '!', '?'} # Initialize sentence count sentence_count = 0 # Traverse through the text and count sentence endings for char in text: if char in sentence_endings: sentence_count += 1 return sentence_count"},{"question":"def rotate_array(arr: List[int], steps: int) -> List[int]: Rotates the array to the right by a given number of steps. Parameters: arr (list of int): The array of integers to be rotated. steps (int): The number of steps to rotate the array to the right. Returns: list of int: The rotated array. pass from solution import rotate_array def test_rotate_normal_case(): assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] def test_rotate_with_steps_greater_than_length(): assert rotate_array([0, -1, 2, 3], 3) == [-1, 2, 3, 0] def test_rotate_with_zero_steps(): assert rotate_array([7, 8, 9, 10], 0) == [7, 8, 9, 10] def test_rotate_with_steps_equal_to_length(): assert rotate_array([1, 2, 3], 3) == [1, 2, 3] def test_rotate_with_empty_array(): assert rotate_array([], 3) == [] def test_rotate_large_steps(): assert rotate_array([1, 2, 3, 4, 5], 12) == [4, 5, 1, 2, 3] def test_rotate_single_element(): assert rotate_array([7], 3) == [7] def test_rotate_array_of_same_elements(): assert rotate_array([5, 5, 5, 5], 2) == [5, 5, 5, 5]","solution":"def rotate_array(arr, steps): Rotates the array to the right by a given number of steps. Parameters: arr (list of int): The array of integers to be rotated. steps (int): The number of steps to rotate the array to the right. Returns: list of int: The rotated array. if not arr: return arr n = len(arr) steps = steps % n # Handle steps greater than the length of the array return arr[-steps:] + arr[:-steps]"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string s a palindrome. >>> min_operations_to_palindrome(\\"abc\\") 2 >>> min_operations_to_palindrome(\\"aebcbda\\") 2 Unit Test: from solution import min_operations_to_palindrome def test_example1(): assert min_operations_to_palindrome(\\"abc\\") == 2 def test_example2(): assert min_operations_to_palindrome(\\"aebcbda\\") == 2 def test_palindrome_string(): assert min_operations_to_palindrome(\\"racecar\\") == 0 def test_single_character(): assert min_operations_to_palindrome(\\"a\\") == 0 def test_two_characters_different(): assert min_operations_to_palindrome(\\"ab\\") == 1 def test_two_characters_same(): assert min_operations_to_palindrome(\\"aa\\") == 0 def test_complex_palindrome(): assert min_operations_to_palindrome(\\"abccba\\") == 0 def test_edge_case_empty_string(): assert min_operations_to_palindrome(\\"\\") == 0 def test_no_extra_operations_needed(): assert min_operations_to_palindrome(\\"abba\\") == 0","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string s a palindrome. def lcs(X, Y, m, n): dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][j] # Reverse the string reversed_s = s[::-1] # Find the length of the longest common subsequence lcs_length = lcs(s, reversed_s, len(s), len(s)) # Minimum operations to make the string palindrome return len(s) - lcs_length"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Determine the number of unique paths the player can take to reach the bottom-right corner of the grid, given the obstacles. >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 1, 0] ... ]) 1 >>> unique_paths_with_obstacles([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ]) 0 >>> unique_paths_with_obstacles([ ... [0, 1, 0], ... [1, 0, 0], ... [0, 1, 0] ... ]) 0","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) # Edge case: Start or end is an obstacle if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Allocate a 2D dp array dp = [[0] * n for _ in range(m)] # Initialize starting point dp[0][0] = 1 # Fill dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def sum_range(arr, l, r): Returns the sum of the elements from index l to r (inclusive). >>> sum_range([1, 2, 3, 4, 5], 1, 3) == 6 >>> sum_range([1, 2, 3, 4, 5], 2, 5) == 14 >>> sum_range([1, 2, 3, 4, 5], 1, 5) == 15 def increment(arr, x, y): Increment each element in the array from index x to index y (inclusive) by 1. >>> arr = [1, 2, 3, 4, 5] >>> increment(arr, 2, 4) >>> arr == [1, 3, 4, 5, 5] >>> increment(arr, 1, 5) >>> arr == [2, 4, 5, 6, 6] def process_queries(N, arr, queries): This function processes the queries and returns the result for sum_range queries. :param N: Size of the array :param arr: List of integers :param queries: List of queries to process :return: List of results for sum_range queries >>> N = 5 >>> arr = [1, 2, 3, 4, 5] >>> queries = [\\"sum_range 1 3\\", \\"increment 2 4\\", \\"sum_range 2 5\\", \\"increment 1 5\\", \\"sum_range 1 5\\", \\"sum_range 3 4\\"] >>> process_queries(N, arr, queries) == [6, 17, 23, 11]","solution":"def sum_range(arr, l, r): Returns the sum of the elements from index l to r (inclusive). return sum(arr[l-1:r]) def increment(arr, x, y): Increment each element in the array from index x to index y (inclusive) by 1. for i in range(x-1, y): arr[i] += 1 def process_queries(N, arr, queries): This function processes the queries and prints the result for sum_range queries. :param N: Size of the array :param arr: List of integers :param queries: List of queries to process results = [] for query in queries: parts = query.split() if parts[0] == \\"sum_range\\": l, r = int(parts[1]), int(parts[2]) results.append(sum_range(arr, l, r)) elif parts[0] == \\"increment\\": x, y = int(parts[1]), int(parts[2]) increment(arr, x, y) return results"},{"question":"import heapq def dijkstra(N, edges, start, target): Return the shortest distance from start node to target node using Dijkstra's Algorithm. If there is no path, return -1. Parameters: N (int): Number of nodes edges (list of tuples): Each tuple contains (u, v, w) representing an edge between nodes u and v with weight w. start (int): Starting node target (int): Target node Returns: int: Shortest path from start to target, or -1 if no such path exists. >>> dijkstra(5, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 8), (3, 5, 10)], 1, 5) 12 >>> dijkstra(4, [(1, 2, 4), (3, 4, 5)], 1, 4) -1 >>> dijkstra(5, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 5), (3, 4, 8), (3, 5, 10)], 1, 1) 0 >>> dijkstra(3, [(1, 2, 10), (2, 3, 5)], 1, 3) 15 >>> dijkstra(2, [(1, 2, 7)], 1, 2) 7 >>> dijkstra(1, [], 1, 1) 0","solution":"import heapq def dijkstra(N, edges, start, target): Return the shortest distance from start node to target node using Dijkstra's Algorithm. If there is no path, return -1. Parameters: N (int): Number of nodes edges (list of tuples): Each tuple contains (u, v, w) representing an edge between nodes u and v with weight w. start (int): Starting node target (int): Target node Returns: int: Shortest path from start to target, or -1 if no such path exists. graph = {i: [] for i in range(1, N + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, start)] distances = {i: float('inf') for i in range(1, N + 1)} distances[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[target] == float('inf') else distances[target]"},{"question":"def count_subsequences(text: str, pattern: str) -> int: Return the number of times \`pattern\` appears as a subsequence in \`text\`. >>> count_subsequences(\\"abcabc\\", \\"abc\\") 4 >>> count_subsequences(\\"abbab\\", \\"ab\\") 4 >>> count_subsequences(\\"xyz\\", \\"y\\") 1 def test_count_subsequences_example1(): assert count_subsequences(\\"abcabc\\", \\"abc\\") == 4 def test_count_subsequences_example2(): assert count_subsequences(\\"abbab\\", \\"ab\\") == 4 def test_count_subsequences_example3(): assert count_subsequences(\\"xyz\\", \\"y\\") == 1 def test_count_subsequences_empty_pattern(): assert count_subsequences(\\"abcdef\\", \\"\\") == 1 def test_count_subsequences_no_match(): assert count_subsequences(\\"abcdef\\", \\"z\\") == 0 def test_count_subsequences_pattern_longer_than_text(): assert count_subsequences(\\"abc\\", \\"abcd\\") == 0 def test_count_subsequences_full_match_text(): assert count_subsequences(\\"aaa\\", \\"aaa\\") == 1 def test_count_subsequences_repeated_pattern(): assert count_subsequences(\\"aaaa\\", \\"aa\\") == 6","solution":"def count_subsequences(text, pattern): Return the number of times \`pattern\` appears as a subsequence in \`text\`. len_text = len(text) len_pattern = len(pattern) # Create a DP table with (len_pattern + 1) rows and (len_text + 1) columns dp = [[0] * (len_text + 1) for _ in range(len_pattern + 1)] # Every substring can match with an empty subsequence for j in range(len_text + 1): dp[0][j] = 1 for i in range(1, len_pattern + 1): for j in range(1, len_text + 1): if pattern[i - 1] == text[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] else: dp[i][j] = dp[i][j - 1] return dp[len_pattern][len_text]"},{"question":"from typing import List def count_islands(matrix: List[List[str]]) -> int: Find the number of islands in a given matrix. An island is a group of connected '1's surrounded by '0's. Connected means either horizontally or vertically. Examples: >>> count_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) 3 >>> count_islands([ ... ['1', '1', '1'], ... ['0', '1', '0'], ... ['1', '1', '1'] ... ]) 1 >>> count_islands([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) 0 >>> count_islands([ ... ['0', '1', '0'], ... ['1', '0', '1'], ... ['0', '1', '0'] ... ]) 4 >>> count_islands([ ... ['1', '0', '1'], ... ['0', '0', '0'], ... ['1', '0', '1'] ... ]) 4","solution":"def count_islands(matrix): n = len(matrix) m = len(matrix[0]) def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or matrix[x][y] == '0': return matrix[x][y] = '0' directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x + dx, y + dy) island_count = 0 for i in range(n): for j in range(m): if matrix[i][j] == '1': dfs(i, j) island_count += 1 return island_count"},{"question":"def process_operations(n, m, k, operations): Processes the given operations on an n x m grid and returns the number of black cells and their coordinates in lexicographical order. :param int n: number of rows in the grid :param int m: number of columns in the grid :param int k: number of operations :param list operations: list of operations (each as a list of form [type, row, col]) :return: Tuple containing the number of black cells and a list of their coordinates (row, col). :rtype: (int, list of tuple) >>> process_operations(3, 3, 5, [[0, 0, 0], [0, 1, 1], [1, 0, 0], [0, 2, 2], [0, 0, 1]]) (3, [(0, 1), (1, 1), (2, 2)]) >>> process_operations(2, 2, 4, [[0, 0, 0], [0, 0, 1], [1, 0, 0], [0, 1, 1]]) (2, [(0, 1), (1, 1)])","solution":"def process_operations(n, m, k, operations): Processes the given operations on an n x m grid and returns the number of black cells and their coordinates in lexicographical order. :param int n: number of rows in the grid :param int m: number of columns in the grid :param int k: number of operations :param list operations: list of operations (each as a list of format [type, row, col]) :return: tuple of the number of black cells and list of their coordinates (row, col) :rtype: (int, list of tuple) grid = [[0 for _ in range(m)] for _ in range(n)] # Initialize all cells to white (0) for operation in operations: t, x, y = operation if t == 0: grid[x][y] = 1 # Paint cell black elif t == 1: grid[x][y] = 0 # Paint cell white # Collect coordinates of black cells black_cells = [] for i in range(n): for j in range(m): if grid[i][j] == 1: black_cells.append((i, j)) black_cells.sort() # Sort lexicographically (first by row, then by column) return len(black_cells), black_cells # Example usage: n, m, k = 3, 3, 5 operations = [ [0, 0, 0], [0, 1, 1], [1, 0, 0], [0, 2, 2], [0, 0, 1] ] # Expected output: (3, [(0, 1), (1, 1), (2, 2)]) result = process_operations(n, m, k, operations) print(result)"},{"question":"def initialize_shelves(m: int, n: int) -> List[List[int]]: Initialize the shelves with \`m\` shelves each having \`n\` positions. >>> initialize_shelves(2, 3) [[0, 0, 0], [0, 0, 0]] def add_book(shelves: List[List[int]], s: int, p: int, b: int) -> None: Adds a book with \`b\` ID to the shelf \`s\` at position \`p\`. >>> shelves = [[0, 0, 0], [0, 0, 0]] >>> add_book(shelves, 1, 2, 101) >>> shelves [[0, 101, 0], [0, 0, 0]] def get_book(shelves: List[List[int]], s: int, p: int) -> int: Gets the book ID positioned at shelf \`s\` and position \`p\`. >>> shelves = [[0, 101, 0], [0, 0, 0]] >>> get_book(shelves, 1, 2) 101 def manage_books(m: int, n: int, operations: List[Tuple[int, int, int, Optional[int]]]) -> List[int]: Manages the books in shelves by performing given operations and returns the results of get operations. >>> manage_books(2, 3, [(1, 1, 1, 101), (2, 1, 1)]) [101]","solution":"def initialize_shelves(m, n): return [[0] * n for _ in range(m)] def add_book(shelves, s, p, b): shelves[s-1][p-1] = b def get_book(shelves, s, p): return shelves[s-1][p-1] def manage_books(m, n, operations): shelves = initialize_shelves(m, n) results = [] for operation in operations: if operation[0] == 1: _, s, p, b = operation add_book(shelves, s, p, b) elif operation[0] == 2: _, s, p = operation results.append(get_book(shelves, s, p)) return results"},{"question":"def showcase_products(n, m, k, ratings): Given the total number of products n, the constraint m specifying the maximum number of consecutive products that can be bypassed, the exact number of products to display k, and the sorted list of product ratings, return the maximum possible rating score for the selected k products that satisfies the given constraints. Parameters: n (int): Total number of products. m (int): Maximum number of consecutive products to bypass. k (int): Number of products to display. ratings (list): A list of integers representing the ratings of products. Returns: int: Maximum possible rating score for the selected k products. Example: >>> showcase_products(7, 2, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> showcase_products(5, 1, 2, [2, 4, 6, 8, 10]) 18 pass from solution import showcase_products def test_sample_input_0(): assert showcase_products(7, 2, 3, [1, 2, 3, 4, 5, 6, 7]) == 18 def test_sample_input_1(): assert showcase_products(5, 1, 2, [2, 4, 6, 8, 10]) == 18 def test_case_all_positive_ratings(): assert showcase_products(4, 1, 2, [10, 20, 30, 40]) == 70 def test_case_single_product(): assert showcase_products(6, 3, 1, [5, 10, 15, 20, 25, 30]) == 30 def test_case_select_subset_via_breaks(): assert showcase_products(6, 2, 2, [7, 8, 9, 10, 11, 12]) == 23 def test_case_minimum_ratings(): assert showcase_products(3, 1, 2, [1, 1, 1]) == 2","solution":"def showcase_products(n, m, k, ratings): Return the maximum possible rating score for displaying exactly k products. Parameters: n (int): Total number of products. m (int): Maximum number of consecutive products to bypass. k (int): Number of products to display. ratings (list): A list of integers representing the ratings of products. Returns: int: Maximum possible rating score for the selected k products. # Dynamic programming table where dp[i][j] represents the max score by selecting # j products from the first i+1 products with the given constraints. dp = [[0] * (k + 1) for _ in range(n + 1)] # Initialize the first product selection possibilities for i in range(1, n + 1): dp[i][0] = 0 # Fill the dynamic programming table for i in range(1, n + 1): for j in range(1, k + 1): max_score = 0 # Check all possible previous selections considering the constraint m. for x in range(max(0, i - m), i): max_score = max(max_score, dp[x][j - 1] + ratings[i - 1]) dp[i][j] = max_score # Max value for selecting k products ending at any point max_rating_score = 0 for i in range(k, n + 1): max_rating_score = max(max_rating_score, dp[i][k]) return max_rating_score"},{"question":"def recursive_sum_of_digits(n: int) -> int: Write a recursive function that computes the sum of the digits of a given non-negative integer. The function should keep summing the digits until a single-digit number is obtained. Args: n (int): A non-negative integer. Returns: int: A single-digit number that is the sum of the digits of the input. >>> recursive_sum_of_digits(12345) 6 >>> recursive_sum_of_digits(99999) 9 >>> recursive_sum_of_digits(1001001) 3","solution":"def recursive_sum_of_digits(n): Recursively finds the sum of digits until a single-digit number is obtained. Args: n (int): A non-negative integer. Returns: int: A single-digit number that is the sum of the digits of the input. if n < 10: return n else: # Calculate the sum of digits of n sum_digits = sum(int(digit) for digit in str(n)) # Recursively sum the digits of the result return recursive_sum_of_digits(sum_digits)"},{"question":"from typing import List def count_subarrays_with_k_distinct(arr: List[int], k: int) -> int: Return the number of subarrays with exactly k distinct elements. >>> count_subarrays_with_k_distinct([1, 2, 1, 2, 3], 2) 7 >>> count_subarrays_with_k_distinct([1, 2, 1, 3, 4, 3], 3) 4 >>> count_subarrays_with_k_distinct([1, 2, 3, 4], 1) 4 pass def test_example_1(): assert count_subarrays_with_k_distinct([1, 2, 1, 2, 3], 2) == 7 def test_example_2(): assert count_subarrays_with_k_distinct([1, 2, 1, 3, 4, 3], 3) == 4 def test_example_3(): assert count_subarrays_with_k_distinct([1, 2, 3, 4], 1) == 4 def test_small_array(): assert count_subarrays_with_k_distinct([1], 1) == 1 def test_no_subarrays(): assert count_subarrays_with_k_distinct([1, 2, 3], 4) == 0 def test_large_distinct_elements(): arr = list(range(1, 101)) assert count_subarrays_with_k_distinct(arr, 10) == 91 def test_all_elements_same(): assert count_subarrays_with_k_distinct([1, 1, 1, 1], 1) == 10","solution":"def count_subarrays_with_k_distinct(arr, k): from collections import defaultdict def at_most_k_distinct(k): if k == 0: return 0 count_map = defaultdict(int) left = 0 count = 0 for right in range(len(arr)): count_map[arr[right]] += 1 while len(count_map) > k: count_map[arr[left]] -= 1 if count_map[arr[left]] == 0: del count_map[arr[left]] left += 1 count += right - left + 1 return count return at_most_k_distinct(k) - at_most_k_distinct(k - 1)"},{"question":"def max_cumulative_elevation_gain(n: int, elevation_changes: List[int]) -> int: Compute the maximum cumulative elevation gain over any contiguous sub-segment of the trail. >>> max_cumulative_elevation_gain(6, [-1, 2, 4, -3, 5, 2]) 10 >>> max_cumulative_elevation_gain(5, [-5, -2, -3, -4, -1]) 0 >>> max_cumulative_elevation_gain(4, [3, -2, 3, -1]) 4","solution":"def max_cumulative_elevation_gain(n, elevation_changes): Function to compute the maximum cumulative elevation gain over any contiguous sub-segment of the trail. max_gain = 0 current_gain = 0 for change in elevation_changes: current_gain += change if current_gain < 0: current_gain = 0 if current_gain > max_gain: max_gain = current_gain return max_gain"},{"question":"def longest_subarray_length(arr): Returns the length of the longest contiguous subarray where all elements have the same value. :param arr: List[int] - list of integers :return: int - length of the longest contiguous subarray with the same value >>> longest_subarray_length([1, 1, 1, 1]) 4 >>> longest_subarray_length([1, 2, 3, 4]) 1 >>> longest_subarray_length([1, 2, 2, 3, 3, 3, 1]) 3 >>> longest_subarray_length([1, 1, 2, 2, 3, 3]) 2 >>> longest_subarray_length([5]) 1 >>> longest_subarray_length([]) 0 >>> longest_subarray_length([1, 2, 2, 3, 3, 3, 3]) 4","solution":"def longest_subarray_length(arr): Returns the length of the longest contiguous subarray where all elements have the same value. :param arr: List[int] - list of integers :return: int - length of the longest contiguous subarray with the same value if not arr: return 0 max_len = current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 # Check for the last subarray if current_len > max_len: max_len = current_len return max_len"},{"question":"def isConnected(adjList: dict) -> bool: Returns True if the graph described by adjList is connected, otherwise False. Parameters: adjList (dict): A dictionary describing the adjacency list of the graph. Returns: bool: True if the graph is connected, False otherwise. >>> isConnected({1: [2], 2: [1, 3], 3: [2, 4], 4: [3]}) True >>> isConnected({1: [2], 2: [1], 3: [4], 4: [3]}) False >>> isConnected({1: []}) True >>> isConnected({}) True >>> isConnected({1: [2], 2: [1], 3: [4, 5], 4: [3], 5: [3]}) False >>> isConnected({1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4]}) True","solution":"def isConnected(adjList): Returns True if the graph described by adjList is connected, otherwise False. if not adjList: return True # An empty graph with no nodes is considered connected. # Function to perform DFS and mark visited nodes def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in adjList[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Start from any node start_node = next(iter(adjList)) visited = {start_node} dfs(start_node) # If visited all nodes in the graph, then graph is connected return len(visited) == len(adjList)"},{"question":"def max_chars_removed_palindrome(n: int, s: str) -> int: Returns the maximum number of characters that can be removed from the string s by repeatedly removing palindromic substrings. >>> max_chars_removed_palindrome(7, \\"abacaba\\") 7 >>> max_chars_removed_palindrome(4, \\"abba\\") 4","solution":"def max_chars_removed_palindrome(n, s): Returns the maximum number of characters that can be removed from the string s by repeatedly removing palindromic substrings. # A string is always removable entirely by removing palindromic substrings in steps return n"},{"question":"def find_warmest_city(n: int, city_data: List[Tuple[str, int]]) -> str: Determines the warmest city from given city data. Parameters: n (int): Number of cities. city_data (list of tuples): List containing tuples with city names and their respective temperatures. Returns: str: The name of the warmest city. >>> find_warmest_city(1, [(\\"CityA\\", 20)]) \\"CityA\\" >>> find_warmest_city(2, [(\\"CityA\\", 20), (\\"CityB\\", 25)]) \\"CityB\\" >>> find_warmest_city(3, [(\\"London\\", 25), (\\"Berlin\\", 30), (\\"Madrid\\", 30)]) \\"Berlin\\" >>> find_warmest_city(3, [(\\"London\\", 25), (\\"Berlin\\", 29), (\\"Madrid\\", 30)]) \\"Madrid\\" >>> find_warmest_city(3, [(\\"CityA\\", -10), (\\"CityB\\", -15), (\\"CityC\\", -5)]) \\"CityC\\" >>> find_warmest_city(4, [(\\"CityA\\", 25), (\\"CityB\\", 25), (\\"CityC\\", 25), (\\"CityD\\", 25)]) \\"CityA\\"","solution":"def find_warmest_city(n, city_data): Determines the warmest city from given city data. Parameters: n (int): Number of cities. city_data (list of tuples): List containing tuples with city names and their respective temperatures. Returns: str: The name of the warmest city. warmest_city = None max_temperature = -51 # Temperature less than the lowest possible value to ensure comparison works for city, temp in city_data: if temp > max_temperature: max_temperature = temp warmest_city = city return warmest_city # To use the function: n = 3 city_data = [(\\"London\\", 25), (\\"Berlin\\", 30), (\\"Madrid\\", 30)] print(find_warmest_city(n, city_data)) # Expected Output: Berlin"},{"question":"def max_points(total_hours: int, times: List[int], points: List[int]) -> int: Determine the maximum points that can be earned with the given hours and locations. Parameters: total_hours (int): The total hours available. times (list): List of integers where each integer represents the time required at a specific location. points (list): List of integers where each integer represents the points awarded for spending time at a specific location. Returns: int: The maximum points that can be earned. >>> max_points(5, [1, 3], [2, 5]) 10 >>> max_points(10, [2, 5], [3, 8]) 16","solution":"def max_points(total_hours, times, points): Determine the maximum points that can be earned with the given hours and locations. Parameters: total_hours (int): The total hours available. times (list): List of integers where each integer represents the time required at a specific location. points (list): List of integers where each integer represents the points awarded for spending time at a specific location. Returns: int: The maximum points that can be earned. # Create a DP array to store maximum points for each hour count dp = [0] * (total_hours + 1) # Dynamic programming to calculate the maximum points for h in range(1, total_hours + 1): for t, p in zip(times, points): if t <= h: dp[h] = max(dp[h], dp[h - t] + p) # The last element of dp array contains the maximum points for the given total hours return dp[total_hours]"},{"question":"def generate_primes(N: int) -> list: Generates a list of all prime numbers up to and including N. >>> generate_primes(10) [2, 3, 5, 7] >>> generate_primes(1) [] >>> generate_primes(7) [2, 3, 5, 7] >>> generate_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> generate_primes(0) [] >>> generate_primes(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] pass","solution":"def generate_primes(N): Generates a list of all prime numbers up to and including N. :param N: int - A positive integer :return: list - List of prime numbers up to and including N if N < 2: return [] primes = [] sieve = [True] * (N + 1) sieve[0], sieve[1] = False, False for p in range(2, N + 1): if sieve[p]: primes.append(p) for i in range(p * p, N + 1, p): sieve[i] = False return primes"},{"question":"def max_team_efficiency(n: int, skill_levels: List[int]) -> int: Returns the maximum possible efficiency for any team that can be formed. Parameters: n (int): The number of engineers skill_levels (list): A list of integers representing the skill levels of the engineers Returns: int: The maximum efficiency for any one of the teams >>> max_team_efficiency(5, [1, 2, 3, 4, 5]) 60 >>> max_team_efficiency(6, [10, 20, 30, 40, 50, 60]) 120000 >>> max_team_efficiency(4, [6, 1, 7, 3]) 126 >>> max_team_efficiency(3, [1, 2, 3]) 6 >>> max_team_efficiency(5, [5, 1, 4, 3, 2]) 60 >>> max_team_efficiency(5, [100, 200, 300, 400, 500]) 60000000","solution":"def max_team_efficiency(n, skill_levels): Returns the maximum possible efficiency for any team that can be formed. Parameters: n (int): The number of engineers skill_levels (list): A list of integers representing the skill levels of the engineers Returns: int: The maximum efficiency for any one of the teams # Sort skill levels in descending order to get the highest levels easily sorted_skill_levels = sorted(skill_levels, reverse=True) # The maximum efficiency team will be the product of the top 3 skill levels return sorted_skill_levels[0] * sorted_skill_levels[1] * sorted_skill_levels[2]"},{"question":"def longest_increasing_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest subsequence where each element is exactly one greater than the previous element. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: int: The length of the longest such subsequence. Example: >>> longest_increasing_subsequence(7, [1, 2, 3, 5, 6, 7, 8]) 4 >>> longest_increasing_subsequence(10, [1, 9, 8, 2, 3, 5, 7, 6, 4, 10]) 2","solution":"def longest_increasing_subsequence(n, sequence): Returns the length of the longest subsequence where each element is exactly one greater than the previous element. Parameters: n (int): The number of elements in the sequence. sequence (list of int): The sequence of integers. Returns: int: The length of the longest such subsequence. if not sequence: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] == sequence[i - 1] + 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def smallest(A, n): Returns the smallest element in the array A of size n. >>> smallest([3, 1, 4, 1, 5, 9], 6) 1 >>> smallest([-5, -10, 3, 2], 4) -10","solution":"def smallest(A, n): Returns the smallest element in the array A of size n. # Initialize the minimum element as the first element of the array min_element = A[0] # Iterate through the array to find the minimum element for i in range(1, n): if A[i] < min_element: min_element = A[i] return min_element"},{"question":"def check_intervals_overlap(intervals): Returns 'YES' if any two intervals overlap, otherwise 'NO'. pass def parse_input(input_string): Parses input string into a list of intervals. pass # Tests def test_no_overlap(): input_string = \\"3n1 5n6 10n5 6\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"NO\\" def test_overlap(): input_string = \\"4n1 5n2 6n8 9n5 7\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"YES\\" def test_edge_overlap(): input_string = \\"2n0 2n2 4\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"NO\\" def test_identical_intervals(): input_string = \\"2n2 5n2 5\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"YES\\" def test_contained_intervals(): input_string = \\"2n1 10n2 6\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"YES\\" def test_single_interval(): input_string = \\"1n0 1\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"NO\\" def test_intervals_sorted_desc(): input_string = \\"3n10 20n1 5n5 10\\" intervals = parse_input(input_string) assert check_intervals_overlap(intervals) == \\"NO\\"","solution":"def check_intervals_overlap(intervals): Returns 'YES' if any two intervals overlap, otherwise 'NO'. intervals.sort(key=lambda x: x[0]) for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i+1][0]: return \\"YES\\" return \\"NO\\" def parse_input(input_string): input_lines = input_string.strip().split('n') N = int(input_lines[0]) intervals = [] for i in range(1, N + 1): a, b = map(int, input_lines[i].split()) intervals.append((a, b)) return intervals"},{"question":"def dijkstra(n, edges, start, target): Finds the shortest path from start to target in a directed graph using Dijkstra's algorithm. Parameters: n (int): number of nodes edges (list): list of edges represented as tuples (u, v, w) start (int): start node target (int): target node Returns: int: shortest path length from start to target, or -1 if no path exists Example: >>> dijkstra(4, [(1, 2, 4), (1, 3, 2), (3, 2, 1), (2, 4, 7), (3, 4, 3), (2, 3, 2)], 1, 4) 5 >>> dijkstra(3, [(1, 2, 3), (2, 3, 4)], 1, 3) 7 >>> dijkstra(3, [(1, 2, 1)], 1, 3) -1 from solution import dijkstra def test_example_1(): n = 4 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (3, 2, 1), (2, 4, 7), (3, 4, 3), (2, 3, 2) ] start, target = 1, 4 assert dijkstra(n, edges, start, target) == 5 def test_example_2(): n = 3 m = 2 edges = [ (1, 2, 3), (2, 3, 4) ] start, target = 1, 3 assert dijkstra(n, edges, start, target) == 7 def test_example_3(): n = 3 m = 1 edges = [ (1, 2, 1) ] start, target = 1, 3 assert dijkstra(n, edges, start, target) == -1 def test_no_edges(): n = 2 m = 0 edges = [] start, target = 1, 2 assert dijkstra(n, edges, start, target) == -1 def test_single_node(): n = 1 m = 0 edges = [] start, target = 1, 1 assert dijkstra(n, edges, start, target) == 0 def test_direct_path(): n = 2 m = 1 edges = [ (1, 2, 10) ] start, target = 1, 2 assert dijkstra(n, edges, start, target) == 10 def test_disconnected_graph(): n = 4 m = 2 edges = [ (1, 2, 5), (3, 4, 7) ] start, target = 1, 4 assert dijkstra(n, edges, start, target) == -1","solution":"import heapq def dijkstra(n, edges, start, target): Finds the shortest path from start to target in a directed graph using Dijkstra's algorithm. Parameters: n (int): number of nodes edges (list): list of edges represented as tuples (u, v, w) start (int): start node target (int): target node Returns: int: shortest path length from start to target, or -1 if no path exists # Create an adjacency list adj = [[] for _ in range(n)] for u, v, w in edges: adj[u-1].append((v-1, w)) # Dijkstra's algorithm pq = [(0, start - 1)] # Priority queue of (distance, node) distances = [float('inf')] * n distances[start - 1] = 0 visited = [False] * n while pq: current_distance, current_node = heapq.heappop(pq) if visited[current_node]: continue visited[current_node] = True for neighbor, weight in adj[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[target - 1] if distances[target - 1] != float('inf') else -1 # Example usage n = 4 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (3, 2, 1), (2, 4, 7), (3, 4, 3), (2, 3, 2) ] start, target = 1, 4 print(dijkstra(n, edges, start, target)) # Output: 5"},{"question":"def segregate_alphabets_and_digits(strings): Takes a list of strings and segregates alphabets and digits for each string. Returns a list of tuples, each containing two strings: one with all the alphabets and the other with all the digits. >>> segregate_alphabets_and_digits([\\"a1b2c3\\"]) [('abc', '123')] >>> segregate_alphabets_and_digits([\\"abc123\\"]) [('abc', '123')] >>> segregate_alphabets_and_digits([\\"4d5e6f\\"]) [('def', '456')] >>> segregate_alphabets_and_digits([\\"a1a\\", \\"1a1\\", \\"a1b2\\", \\"123abc\\"]) [('aa', '1'), ('a', '11'), ('ab', '12'), ('abc', '123')] >>> segregate_alphabets_and_digits([\\"abcdef\\"]) [('abcdef', '')] >>> segregate_alphabets_and_digits([\\"123456\\"]) [('', '123456')] >>> segregate_alphabets_and_digits([\\"\\"]) [('', '')] >>> long_input = \\"a1\\" * 50 >>> segregate_alphabets_and_digits([long_input]) [('a' * 50, '1' * 50)]","solution":"def segregate_alphabets_and_digits(strings): Takes a list of strings and segregates alphabets and digits for each string. Returns a list of tuples, each containing two strings: one with all the alphabets and the other with all the digits. result = [] for s in strings: alphabets = \\"\\" digits = \\"\\" for char in s: if char.isalpha(): alphabets += char elif char.isdigit(): digits += char result.append((alphabets, digits)) return result"},{"question":"def uniquePaths(n, m, obstacles): Returns the number of unique paths in an n x n grid starting from (1, 1) to (n, n) avoiding obstacles. >>> uniquePaths(2, 0, []) 2 >>> uniquePaths(3, 1, [(2, 2)]) 2 >>> uniquePaths(3, 2, [(2, 2), (3, 2)]) 1 >>> uniquePaths(3, 3, [(2, 2), (3, 2), (2, 3)]) 0 def process_test_cases(test_cases): Processes multiple test cases for uniquePaths function. >>> process_test_cases([(2, 0, []), (3, 1, [(2, 2)]), (3, 2, [(2, 2), (3, 2)])]) [2, 2, 1] from solution import uniquePaths, process_test_cases def test_uniquePaths_no_obstacles(): assert uniquePaths(2, 0, []) == 2 assert uniquePaths(3, 0, []) == 6 def test_uniquePaths_with_obstacles(): assert uniquePaths(3, 1, [(2, 2)]) == 2 assert uniquePaths(3, 2, [(2, 2), (3, 2)]) == 1 assert uniquePaths(3, 3, [(2, 2), (3, 2), (2, 3)]) == 0 def test_process_test_cases(): test_cases = [ (2, 0, []), (3, 1, [(2, 2)]), (3, 2, [(2, 2), (3, 2)]) ] assert process_test_cases(test_cases) == [2, 2, 1]","solution":"def uniquePaths(n, m, obstacles): Returns the number of unique paths in an n x n grid starting from (1, 1) to (n, n) avoiding obstacles. grid = [[0] * n for _ in range(n)] if m > 0: for x, y in obstacles: grid[x - 1][y - 1] = -1 if grid[0][0] == -1 or grid[n-1][n-1] == -1: return 0 grid[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[n-1][n-1] def process_test_cases(test_cases): results = [] for case in test_cases: n, m, obstacles = case results.append(uniquePaths(n, m, obstacles)) return results"},{"question":"def min_sublists_increasing(arr): Returns the minimum number of strictly increasing contiguous sublists. >>> min_sublists_increasing([1, 2, 1, 2]) 2 >>> min_sublists_increasing([3, 2, 1]) 3 >>> min_sublists_increasing([1, 2, 3, 4, 5]) 1 >>> min_sublists_increasing([5, 4, 3, 2, 1]) 5 >>> min_sublists_increasing([1]) 1 def process_input(t, test_cases): Processes multiple test cases and returns the minimum number of strictly increasing contiguous sublists for each test case. >>> process_input(2, [[1, 2, 1, 2], [3, 2, 1]]) [2, 3] >>> process_input(1, [[1, 3, 2, 4, 3, 5]]) [3] >>> process_input(3, [[1, 2], [2, 3, 2, 4], [0, 1, 0, 1, 0, 1]]) [1, 2, 3]","solution":"def min_sublists_increasing(arr): Returns the minimum number of strictly increasing contiguous sublists. if not arr: return 0 count = 1 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: count += 1 return count def process_input(t, test_cases): results = [] for case in test_cases: results.append(min_sublists_increasing(case)) return results"},{"question":"def find_pair_with_target_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is exactly the target integer. >>> find_pair_with_target_difference([1, 5, 3, 4, 7], 2) == \\"YES\\" >>> find_pair_with_target_difference([2, 4, 6, 8], 3) == \\"NO\\" >>> find_pair_with_target_difference([1, 3, 5, 7], 2) == \\"YES\\" >>> find_pair_with_target_difference([10, 20, 30, 40], 15) == \\"NO\\" >>> find_pair_with_target_difference([1, 1, 1, 1], 0) == \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases and returns a list of results for each test case. >>> test_cases = [ ... (5, [1, 5, 3, 4, 7], 2), ... (4, [2, 4, 6, 8], 3) ... ] >>> results = process_test_cases(test_cases) >>> results == [\\"YES\\", \\"NO\\"] True >>> test_cases = [ ... (4, [2, 4, 6, 8], 4), ... (5, [9, 7, 2, 5, 4], 3) ... ] >>> results = process_test_cases(test_cases) >>> results == [\\"YES\\", \\"YES\\"] True >>> test_cases = [ ... (3, [1, 2, 3], 1), ... (5, [1, 1, 1, 1, 1], 0) ... ] >>> results = process_test_cases(test_cases) >>> results == [\\"YES\\", \\"YES\\"] True","solution":"def find_pair_with_target_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the elements at these indices is exactly the target integer. seen = set() for num in arr: if (num + target) in seen or (num - target) in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases and returns a list of results for each test case. results = [] for n, arr, target in test_cases: result = find_pair_with_target_difference(arr, target) results.append(result) return results"},{"question":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive sequence of integers in the list nums. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 >>> longest_consecutive_sequence([0, 7, 8, 1, 2, 3, 4, 5]) == 6 >>> longest_consecutive_sequence([]) == 0 >>> longest_consecutive_sequence([1, 2, 0, 1]) == 3 >>> longest_consecutive_sequence([5, 100, 101, 102, 6, 7, 103, 104, 4]) == 5 >>> longest_consecutive_sequence([1, 3, 5, 2, 4, 6, 8, 9, 10, 7]) == 10 pass def process_input(input_string): Processes the input string and returns the output as specified in the problem. >>> process_input(\\"2n100 4 200 1 3 2n0 7 8 1 2 3 4 5n\\") == \\"4n6\\" >>> process_input(\\"1n1 2 0 1n\\") == \\"3\\" >>> process_input(\\"1n5 100 101 102 6 7 103 104 4n\\") == \\"5\\" >>> process_input(\\"0n\\") == \\"\\" pass","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive sequence of integers in the list nums. if not nums: return 0 nums = set(nums) longest_streak = 0 for num in nums: # Only start counting streak if num is the beginning of a sequence if (num - 1) not in nums: current_num = num current_streak = 1 while (current_num + 1) in nums: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak def process_input(input_string): Processes the input string and returns the output as specified in the problem. input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) output_lines = [] for i in range(1, T + 1): nums = list(map(int, input_lines[i].strip().split())) result = longest_consecutive_sequence(nums) output_lines.append(str(result)) return \\"n\\".join(output_lines)"},{"question":"from typing import List, Tuple def get_cover_images(n: int, albums: List[Tuple[str, List[Tuple[int, int]]]]) -> List[int]: Returns a sorted list of photo_ids representing the cover images of the albums, sorted by the creation date of their latest photo. >>> get_cover_images(2, [ (\\"Vacation\\", [(1, 1636025600), (2, 1636112000)]), (\\"Birthday\\", [(3, 1635842800)]) ]) [2, 3] >>> get_cover_images(3, [ (\\"Holiday\\", [(5, 1636025600)]), (\\"Office\\", []), (\\"Family\\", [(6, 1636112000), (7, 1635756800)]) ]) [6, 5] >>> get_cover_images(1, [ (\\"Nature\\", [(10, 1636112000), (11, 1636025600), (12, 1636208400)]) ]) [12]","solution":"def get_cover_images(n, albums): Returns a sorted list of photo_ids representing the cover images of the albums, sorted by the creation date of their latest photo. :param n: number of albums :param albums: list of tuples where each tuple contains an album name and a list of photos :return: sorted list of photo_ids representing the cover images cover_images = [] for album in albums: album_name, photos = album if not photos: continue # Find the latest photo in the album latest_photo = max(photos, key=lambda x: x[1]) cover_images.append(latest_photo) # Sort the cover images by the creation date of their latest photo cover_images.sort(key=lambda x: x[1], reverse=True) # Extract the photo_ids for the final result result = [photo[0] for photo in cover_images] return result"},{"question":"from typing import List def isSubsetSum(n: int, m: int, s: int, arr: List[int]) -> bool: Given an integer array 'arr' of size 'n' and an integer 's', find if there exists a subset in 'arr' which sums exactly to 's'. Additionally, the subset should contain exactly 'm' elements. >>> isSubsetSum(5, 2, 10, [2, 4, 6, 8, 10]) True >>> isSubsetSum(4, 3, 25, [7, 3, 5, 12]) False","solution":"from itertools import combinations def isSubsetSum(n, m, s, arr): Determine if there exists a subset of exactly m elements in the array that sums to s. if m > n: return False for subset in combinations(arr, m): if sum(subset) == s: return True return False"},{"question":"def run_length_encode(string: str) -> str: Returns the Run-Length Encoded string for the given input string. >>> run_length_encode(\\"aaabccdddda\\") 'a3b1c2d4a1' >>> run_length_encode(\\"zzzzyyyx\\") 'z4y3x1' >>> run_length_encode(\\"aabbcc\\") 'a2b2c2' >>> run_length_encode(\\"a\\") 'a1' >>> run_length_encode(\\"ab\\") 'a1b1' >>> run_length_encode(\\"\\") '' >>> run_length_encode(\\"aaaaa\\") 'a5' >>> run_length_encode(\\"abcde\\") 'a1b1c1d1e1' pass def process_test_cases(test_cases: List[str]) -> List[str]: Process multiple test cases of run-length encoding. >>> process_test_cases([\\"aaabccdddda\\", \\"zzzzyyyx\\", \\"aabbcc\\", \\"abcde\\"]) ['a3b1c2d4a1', 'z4y3x1', 'a2b2c2', 'a1b1c1d1e1'] >>> process_test_cases([\\"\\"]) [''] pass","solution":"def run_length_encode(string): Returns the Run-Length Encoded string for the given input string. if not string: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(string)): if string[i] == string[i - 1]: count += 1 else: encoded_string.append(string[i - 1] + str(count)) count = 1 encoded_string.append(string[-1] + str(count)) # Append the last character and its count return \\"\\".join(encoded_string) def process_test_cases(test_cases): Process multiple test cases of run-length encoding. return [run_length_encode(test_case) for test_case in test_cases]"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, m: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Determine the minimum total time required to send an update from a given source warehouse to all other warehouses in the network. Args: n: An integer representing the number of warehouses. m: An integer representing the number of direct communication links. edges: A list of tuples where each tuple represents a directed edge from node u to node v with a weight of w. s: An integer representing the source warehouse. Returns: A list of integers where each integer represents the minimum time to send an update from the source warehouse to the corresponding warehouse. If a warehouse cannot be reached, the corresponding value should be -1. >>> dijkstra(5, 6, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (2, 5, 1), (3, 5, 5), (5, 4, 3)], 1) [0, 2, 4, 6, 3] >>> dijkstra(1, 0, [], 1) [0] >>> dijkstra(4, 3, [(1, 2, 5), (1, 3, 10), (3, 4, 1)], 1) [0, 5, 10, 11] >>> dijkstra(3, 2, [(1, 2, 1000), (2, 3, 1000)], 1) [0, 1000, 2000] >>> dijkstra(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], 1) [0, 1, 2, 3]","solution":"import heapq def dijkstra(n, m, edges, s): adj_list = [[] for _ in range(n + 1)] for u, v, w in edges: adj_list[u].append((v, w)) dist = [float('inf')] * (n + 1) dist[s] = 0 min_heap = [(0, s)] while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for v, weight in adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) return [0 if i == s else (dist[i] if dist[i] != float('inf') else -1) for i in range(1, n + 1)] # Example Usage: # n = 5 # m = 6 # edges = [(1, 2, 2), (1, 3, 4), (2, 4, 7), (2, 5, 1), (3, 5, 5), (5, 4, 3)] # s = 1 # print(dijkstra(n, m, edges, s)) # Output: [0, 2, 4, 6, 3]"},{"question":"def min_cost_to_provide_water(N, M, pipes): Calculate the minimum cost to connect all houses with water pipes. Return the minimal cost or -1 if it's impossible. Parameters: N (int): The number of houses M (int): The number of possible pipes pipes (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, u, v, and c representing a pipe connecting house u and house v with cost c. Returns: int: The minimum sum of the costs of the pipes needed to connect all houses or -1 if it's not possible. Examples: >>> min_cost_to_provide_water(4, 5, [(1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3), (1, 3, 5)]) 6 >>> min_cost_to_provide_water(3, 0, []) -1 >>> min_cost_to_provide_water(1, 0, []) 0","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def min_cost_to_provide_water(N, M, pipes): if N == 1: return 0 pipes.sort(key=lambda x: x[2]) parent = list(range(N + 1)) rank = [0] * (N + 1) cost = 0 edges_used = 0 for u, v, c in pipes: if find(parent, u) != find(parent, v): union(parent, rank, u, v) cost += c edges_used += 1 if edges_used == N - 1: return cost return -1 # Unable to connect all houses # Example usage: # N = 4 # M = 5 # pipes = [ # (1, 2, 1), # (2, 3, 4), # (3, 4, 2), # (4, 1, 3), # (1, 3, 5) # ] # print(min_cost_to_provide_water(N, M, pipes)) # Output: 6"},{"question":"from typing import List def findAnagrams(s: str, p: str) -> List[int]: Implement a function \`findAnagrams\` that takes in a string \`s\` and a non-empty string \`p\`, and returns a list of starting indices of \`p\`'s anagrams in \`s\`. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. >>> findAnagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAnagrams(\\"abab\\", \\"ab\\") [0, 1, 2] pass def test_findAnagrams_example1(): assert findAnagrams(\\"cbaebabacd\\", \\"abc\\") == [0, 6] def test_findAnagrams_example2(): assert findAnagrams(\\"abab\\", \\"ab\\") == [0, 1, 2] def test_findAnagrams_no_anagrams(): assert findAnagrams(\\"abcdef\\", \\"gh\\") == [] def test_findAnagrams_entire_string_is_anagram(): assert findAnagrams(\\"ab\\", \\"ab\\") == [0] def test_findAnagrams_overlapping_anagrams(): assert findAnagrams(\\"aaaaaa\\", \\"aaa\\") == [0, 1, 2, 3] def test_findAnagrams_single_characters(): assert findAnagrams(\\"a\\", \\"a\\") == [0] assert findAnagrams(\\"a\\", \\"b\\") == [] def test_findAnagrams_p_longer_than_s(): assert findAnagrams(\\"a\\", \\"ab\\") == [] def test_findAnagrams_same_characters(): assert findAnagrams(\\"a\\"*20000, \\"a\\"*5000) == list(range(15001))","solution":"from collections import Counter def findAnagrams(s, p): Finds starting indices of the anagrams of p in s. result = [] len_p = len(p) len_s = len(s) if len_p > len_s: return result # Create a frequency counter for the characters in p p_count = Counter(p) s_count = Counter(s[:len_p-1]) # Iterate through the string s using a sliding window approach for i in range(len_p-1, len_s): # Add the new character to the current window's count s_count[s[i]] += 1 # Compare window with p's character count if s_count == p_count: result.append(i - len_p + 1) # Remove the oldest character from the window start_char = s[i - len_p + 1] s_count[start_char] -= 1 if s_count[start_char] == 0: del s_count[start_char] return result"},{"question":"def count_pairs_with_difference(arr, k): Returns the number of unique pairs (i, j) such that the difference between arr[i] and arr[j] is exactly k. >>> count_pairs_with_difference([1, 5, 3, 4, 2], 3) 2 >>> count_pairs_with_difference([1, 2, 3, 4], 0) 0 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:n+2])) print(count_pairs_with_difference(arr, k)) if __name__ == \\"__main__\\": main()","solution":"def count_pairs_with_difference(arr, k): Returns the number of unique pairs (i, j) such that the difference between arr[i] and arr[j] is exactly k. count = 0 seen = set() for num in arr: if (num - k) in seen: count += 1 if (num + k) in seen: count += 1 seen.add(num) return count def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:n+2])) print(count_pairs_with_difference(arr, k)) if __name__ == \\"__main__\\": main()"},{"question":"from functools import reduce as functools_reduce class Stream: def __init__(self, iterable): self.iterator = iter(iterable) def next(self): return next(self.iterator) def take(self, n): Take n items from the stream. >>> numbers = Stream.from_iterable(range(1, 6)) >>> numbers.take(3) [1, 2, 3] result = [] try: for _ in range(n): result.append(next(self.iterator)) except StopIteration: pass return result def filter(self, predicate): Create a new Stream containing only the elements that satisfy a predicate function. >>> numbers = Stream.from_iterable(range(1, 6)) >>> evens = numbers.filter(lambda x: x % 2 == 0) >>> evens.take(2) [2, 4] return Stream(x for x in self if predicate(x)) def map(self, func): Create a new Stream where every element is the result of applying a function. >>> numbers = Stream.from_iterable(range(1, 6)) >>> squares = numbers.map(lambda x: x ** 2) >>> squares.take(3) [1, 4, 9] return Stream(func(x) for x in self) def reduce(self, func, initializer=None): Combine all elements in the stream by repeatedly applying a binary function. >>> numbers = Stream.from_iterable([1, 2, 3, 4, 5]) >>> total = numbers.reduce(lambda acc, x: acc + x, 0) >>> total 15 if initializer is None: return functools_reduce(func, self) else: return functools_reduce(func, self, initializer) def __iter__(self): return self def __next__(self): return self.next() @classmethod def from_iterable(cls, iterable): Create a Stream from any iterable. >>> numbers = Stream.from_iterable([1, 2, 3]) >>> numbers.take(2) [1, 2] return cls(iterable)","solution":"from functools import reduce as functools_reduce class Stream: def __init__(self, iterable): self.iterator = iter(iterable) def next(self): return next(self.iterator) def take(self, n): result = [] try: for _ in range(n): result.append(next(self.iterator)) except StopIteration: pass return result def filter(self, predicate): return Stream(x for x in self if predicate(x)) def map(self, func): return Stream(func(x) for x in self) def reduce(self, func, initializer=None): if initializer is None: return functools_reduce(func, self) else: return functools_reduce(func, self, initializer) def __iter__(self): return self def __next__(self): return self.next() @classmethod def from_iterable(cls, iterable): return cls(iterable)"},{"question":"def path_exists(n: int, m: int, q: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there exists a path from the start server to the end server using the available connections. Args: n (int): The number of servers. m (int): The number of direct connections. q (int): The number of queries. edges (List[Tuple[int, int]]): List of direct connections between servers. queries (List[Tuple[int, int]]): List of queries to check for the existence of a path between servers. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each query. >>> path_exists(4, 4, 3, [(1, 2), (2, 3), (3, 4), (1, 3)], [(1, 4), (4, 1), (2, 4)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> path_exists(5, 6, 4, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (1, 5)], [(1, 4), (2, 5), (3, 1), (1, 5)]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def path_exists(n, m, q, edges, queries): from collections import defaultdict, deque def bfs(start, end, graph): queue = deque([start]) visited = set() while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) for neighbor in graph[node]: queue.append(neighbor) return False # Build the graph from edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) results = [] for a, b in queries: if bfs(a, b, graph): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimal_sequence_sum(n: int) -> int: Given an integer n, generate a sequence of integers a_1, a_2, ..., a_n such that: - Each element a_i (for 1 ≤ i ≤ n) is a positive integer. - Each element a_i is greater than or equal to its 1-based index i. - The sum of the elements in the sequence is minimized. >>> minimal_sequence_sum(3) 6 >>> minimal_sequence_sum(5) 15 >>> minimal_sequence_sum(1) 1 # You need to implement this function to return the sum of the sequence","solution":"def minimal_sequence_sum(n): Returns the sum of the sequence where each element a_i is at least i and the sum is minimized. return n * (n + 1) // 2"},{"question":"from typing import List, Tuple from collections import Counter def top_frequent_elements(arr: List[int], x: int) -> List[int]: Returns the x most frequently occurring elements in descending order of their frequency. If two elements have the same frequency, returns the smaller element first. >>> top_frequent_elements([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3) [4, 3, 2] >>> top_frequent_elements([8, 8, 9, 9, 9, 6, 6, 6, 6], 2) [6, 9] def solve_top_frequent_elements(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[List[int]]: Processes multiple test cases and returns the results for each. >>> solve_top_frequent_elements(2, [(10, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3), (8, [8, 8, 9, 9, 9, 6, 6, 6, 6], 2)]) [[4, 3, 2], [6, 9]]","solution":"from collections import Counter def top_frequent_elements(arr, x): Returns the x most frequently occurring elements in descending order of their frequency. If two elements have the same frequency, returns the smaller element first. freq_counter = Counter(arr) sorted_elements = sorted(freq_counter.items(), key=lambda pair: (-pair[1], pair[0])) return [el[0] for el in sorted_elements[:x]] def solve_top_frequent_elements(T, test_cases): results = [] for i in range(T): n, arr, x = test_cases[i] results.append(top_frequent_elements(arr, x)) return results"},{"question":"def longest_subsequence_within_k(scores: List[int], K: int) -> int: Returns the length of the longest contiguous subsequence where the difference between the highest and lowest scores is less than or equal to K. >>> longest_subsequence_within_k([5, 3, 8, 6, 7, 4, 2], 4) 4 >>> longest_subsequence_within_k([1, 5, 9, 2, 4], 3) 2 >>> longest_subsequence_within_k([3, 3, 3, 3], 1) 4","solution":"def longest_subsequence_within_k(scores, K): Returns the length of the longest contiguous subsequence where the difference between the highest and lowest scores is less than or equal to K. n = len(scores) if n == 0: return 0 longest = 0 start = 0 # Maintain a list to get min and max in O(1) sorted_window = [] for end in range(n): sorted_window.append(scores[end]) sorted_window.sort() # Shrink window from start if max - min > K while sorted_window[-1] - sorted_window[0] > K: sorted_window.remove(scores[start]) sorted_window.sort() start += 1 # Calculate the current valid subsequence length longest = max(longest, end - start + 1) return longest"},{"question":"def maximizeProfit(prices: List[int]) -> int: Given a list of stock prices, find the maximum profit that can be made by buying one stock on a given day and selling it on a later day. >>> maximizeProfit([7, 1, 5, 3, 6, 4]) 5 >>> maximizeProfit([7, 6, 4, 3, 1]) 0 def processTestCases(T: int, testCases: List[Tuple[int, List[int]]]) -> List[int]: Process the given test cases and return a list of maximum profits for each. >>> processTestCases(2, [(6, [7, 1, 5, 3, 6, 4]), (5, [7, 6, 4, 3, 1])]) [5, 0] >>> processTestCases(1, [(6, [1, 2, 3, 4, 5, 6])]) [5]","solution":"def maximizeProfit(prices): Given a list of stock prices, find the maximum profit that can be made by buying one stock on a given day and selling it on a later day. if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: max_profit = max(max_profit, price - min_price) return max_profit def processTestCases(T, testCases): Process the given test cases and return a list of maximum profits for each. results = [] for i in range(T): N, prices = testCases[i] results.append(maximizeProfit(prices)) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 pass # implement the function here def find_lengths_of_longest_substrings(test_cases: List[str]) -> List[int]: Given test cases, returns a list containing the length of the longest substring with all distinct characters for each case. >>> find_lengths_of_longest_substrings([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> find_lengths_of_longest_substrings([\\"\\", \\"b\\"]) [0, 1] pass # implement the function here","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map and char_map[char] >= left: left = char_map[char] + 1 char_map[char] = right max_length = max(max_length, right - left + 1) return max_length def find_lengths_of_longest_substrings(test_cases): Given test cases, returns a list containing the length of longest substring with all distinct characters for each case. return [length_of_longest_substring(s) for s in test_cases]"},{"question":"def is_sorted(lst): Determines if the list is sorted in non-decreasing order. :param lst: List of integers. :return: \\"YES\\" if sorted, otherwise \\"NO\\". >>> is_sorted([1, 2, 2, 4, 5]) 'YES' >>> is_sorted([3, 1, 2]) 'NO' >>> is_sorted([-5, -2, 0, 3]) 'YES' >>> is_sorted([1]) 'YES' >>> is_sorted([]) 'YES' pass from solution import is_sorted def test_sorted_ascending(): assert is_sorted([1, 2, 2, 4, 5]) == \\"YES\\" def test_sorted_single_element(): assert is_sorted([1]) == \\"YES\\" def test_not_sorted(): assert is_sorted([3, 1, 2]) == \\"NO\\" def test_sorted_with_negative_numbers(): assert is_sorted([-5, -2, 0, 3]) == \\"YES\\" def test_sorted_with_duplicate_numbers(): assert is_sorted([1, 2, 2, 2, 5]) == \\"YES\\" def test_not_sorted_with_negative_and_positive(): assert is_sorted([-1, -2, 3]) == \\"NO\\" def test_empty_list(): assert is_sorted([]) == \\"YES\\"","solution":"def is_sorted(lst): Determines if the list is sorted in non-decreasing order. :param lst: List of integers. :return: \\"YES\\" if sorted, otherwise \\"NO\\". for i in range(1, len(lst)): if lst[i] < lst[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def longest_subarray_with_sum(arr, target): Finds the length of the longest contiguous subarray that sums to \`target\`. Parameters: arr (list): The list of integers. target (int): The target sum for the subarray. Returns: int: The length of the longest subarray that sums to \`target\`. If no such subarray exists, returns 0. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 >>> longest_subarray_with_sum([1, 2, 3], 6) == 3","solution":"def longest_subarray_with_sum(arr, target): Returns the length of the longest contiguous subarray that sums to \`target\`. Parameters: arr (list): The list of integers. target (int): The target sum for the subarray. Returns: int: The length of the longest subarray that sums to \`target\`. If no such subarray exists, returns 0. sum_map = {} curr_sum = 0 max_len = 0 for i in range(len(arr)): curr_sum += arr[i] # If current sum is equal to the target, update max_len if curr_sum == target: max_len = i + 1 # Check if current sum - target is seen before if (curr_sum - target) in sum_map: max_len = max(max_len, i - sum_map[curr_sum - target]) # Store current sum with index only if current sum is not present in the map if curr_sum not in sum_map: sum_map[curr_sum] = i return max_len"},{"question":"def reverse_words(s: str) -> str: Reverses the sequence of words in the given string. Parameters: s (str): A string containing multiple words separated by spaces. Returns: str: A string with the words in reverse order. >>> reverse_words(\\"hello world\\") == \\"world hello\\" >>> reverse_words(\\"coding is fun\\") == \\"fun is coding\\"","solution":"def reverse_words(s): Reverses the sequence of words in the given string. Parameters: s (str): A string containing multiple words separated by spaces. Returns: str: A string with the words in reverse order. words = s.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"import bisect class StreamProcessor: A class used to process a stream of integers and support insertion, median, and average operations. Methods ------- insert(x): Insert the integer x into the stream. findMedian(): Return the median of the current stream of integers. findAverage(): Return the average of the current stream of integers. Examples -------- >>> sp = StreamProcessor() >>> sp.insert(1) >>> sp.insert(3) >>> sp.insert(2) >>> sp.findMedian() 2.0 >>> sp.findAverage() 2.0 def __init__(self): self.nums = [] self.total_sum = 0 def insert(self, x): pass # Implement the insertion logic here. def findMedian(self): pass # Implement the logic to find and return the median. def findAverage(self): pass # Implement the logic to find and return the average. from solution import StreamProcessor def test_insert_and_find_median_odd(): sp = StreamProcessor() sp.insert(1) sp.insert(3) sp.insert(2) assert sp.findMedian() == 2.0 # Median of [1, 2, 3] is 2 def test_insert_and_find_median_even(): sp = StreamProcessor() sp.insert(1) sp.insert(2) assert sp.findMedian() == 1.5 # Median of [1, 2] is (1+2)/2 def test_find_average(): sp = StreamProcessor() sp.insert(1) sp.insert(3) sp.insert(2) assert round(sp.findAverage(), 6) == 2.000000 # Average of [1, 2, 3] is (1+2+3)/3 def test_empty_average(): sp = StreamProcessor() assert round(sp.findAverage(), 6) == 0.000000 # Average of empty list is 0.0 def test_complex_case(): sp = StreamProcessor() sp.insert(1) sp.insert(2) assert sp.findMedian() == 1.5 sp.insert(3) assert sp.findMedian() == 2.0 assert round(sp.findAverage(), 6) == 2.000000 sp.insert(4) assert round(sp.findAverage(), 6) == 2.500000","solution":"import bisect class StreamProcessor: def __init__(self): self.nums = [] self.total_sum = 0 def insert(self, x): bisect.insort(self.nums, x) self.total_sum += x def findMedian(self): n = len(self.nums) if n % 2 == 1: return float(self.nums[n // 2]) else: return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2 def findAverage(self): if len(self.nums) == 0: return 0.0 return self.total_sum / len(self.nums)"},{"question":"def reverse_each_word(sentence: str) -> str: Write a function that takes a string containing a series of space-separated words and returns a new string with each word reversed. The order of the words should remain unchanged. >>> reverse_each_word(\\"This is a test\\") \\"sihT si a tset\\" >>> reverse_each_word(\\"Python is fun\\") \\"nohtyP si nuf\\"","solution":"def reverse_each_word(sentence: str) -> str: Returns a new string with each word in the sentence reversed. The order of the words remains unchanged. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def sublist_index(main_list: List[int], sublist: List[int]) -> int: Returns the starting index of the first occurrence of sublist within main_list. If sublist does not exist within main_list, returns -1. >>> sublist_index([1, 2, 3, 4, 5], [3, 4]) # 2 >>> sublist_index([1, 2, 3, 4, 5], [6]) # -1 >>> sublist_index([1, 2, 3, 1, 2, 3], [1, 2]) # 0 >>> sublist_index([1, 2, 3, 4, 5], []) # 0 >>> sublist_index([], [1]) # -1 >>> sublist_index([], []) # 0 >>> sublist_index([1], [1]) # 0 >>> sublist_index([1, 2, 1, 2, 1], [1, 2, 1]) # 0 >>> sublist_index([1, 2, 1, 2, 1], [2, 1, 2]) # 1 >>> sublist_index([1, 2, 3], [3, 2]) # -1","solution":"def sublist_index(main_list, sublist): Returns the starting index of the first occurrence of sublist within main_list. If sublist does not exist within main_list, returns -1. len_main = len(main_list) len_sub = len(sublist) if len_sub == 0: return 0 if len_main == 0 or len_sub > len_main: return -1 for i in range(len_main - len_sub + 1): if main_list[i:i+len_sub] == sublist: return i return -1"},{"question":"from typing import List def decode_string(encoded_string: str) -> str: Decodes an encoded string where each number corresponds to a letter in the alphabet. Parameters: encoded_string (str): A string of numbers separated by spaces. Returns: str: The decoded alphanumeric string. >>> decode_string(\\"8 5 12 12 15\\") \\"hello\\" >>> decode_string(\\"23 15 18 12 4\\") \\"world\\" >>> decode_string(\\"3 15 4 5\\") \\"code\\" >>> decode_string(\\"1\\") \\"a\\" >>> decode_string(\\"26\\") \\"z\\" >>> decode_string(\\"1 2 3 4 5\\") \\"abcde\\" def decode_multiple_strings(T: int, encoded_strings: List[str]) -> List[str]: Decodes multiple encoded strings. Parameters: T (int): The number of encoded strings. encoded_strings (list of str): A list of encoded strings. Returns: list of str: A list of decoded strings. >>> decode_multiple_strings(3, [\\"8 5 12 12 15\\", \\"23 15 18 12 4\\", \\"3 15 4 5\\"]) [\\"hello\\", \\"world\\", \\"code\\"] >>> decode_multiple_strings(2, [\\"1\\", \\"26\\"]) [\\"a\\", \\"z\\"] >>> decode_multiple_strings(1, [\\"1 2 26\\"]) [\\"abz\\"]","solution":"def decode_string(encoded_string): Decodes an encoded string where each number corresponds to a letter in the alphabet. Parameters: encoded_string (str): A string of numbers separated by spaces. Returns: str: The decoded alphanumeric string. decoded_chars = [chr(int(num) + 96) for num in encoded_string.split()] return ''.join(decoded_chars) def decode_multiple_strings(T, encoded_strings): Decodes multiple encoded strings. Parameters: T (int): The number of encoded strings. encoded_strings (list of str): A list of encoded strings. Returns: list of str: A list of decoded strings. return [decode_string(encoded_string) for encoded_string in encoded_strings]"},{"question":"import heapq from typing import List, Tuple def sort_road_segments_desc(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Sort the road segments in descending order of their wear levels using a min-heap. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer N (number of road segments) and a list of integers (wear levels of segments). Returns: List[List[int]]: A list of lists where each list contains the wear levels sorted in descending order. Example: >>> test_cases = [(5, [10, 20, 15, 30, 40]), (3, [5, 4, 7])] >>> sort_road_segments_desc(test_cases) [[40, 30, 20, 15, 10], [7, 5, 4]] results = [] for case in test_cases: N, wear_levels = case min_heap = [] for wear in wear_levels: heapq.heappush(min_heap, -wear) sorted_wear_levels = [-heapq.heappop(min_heap) for _ in range(N)] results.append(sorted_wear_levels) return results def test_sort_road_segments_desc(): test_cases = [ (5, [10, 20, 15, 30, 40]), (3, [5, 4, 7]), (4, [100, 50, 75, 25]), (1, [0]), (10, [20, 30, 10, 40, 50, 70, 60, 90, 80, 100]) ] expected_results = [ [40, 30, 20, 15, 10], [7, 5, 4], [100, 75, 50, 25], [0], [100, 90, 80, 70, 60, 50, 40, 30, 20, 10] ] results = sort_road_segments_desc(test_cases) for result, expected in zip(results, expected_results): assert result == expected, f'Expected {expected}, but got {result}'","solution":"import heapq def sort_road_segments_desc(test_cases): results = [] for case in test_cases: N, wear_levels = case min_heap = [] for wear in wear_levels: heapq.heappush(min_heap, -wear) sorted_wear_levels = [-heapq.heappop(min_heap) for _ in range(N)] results.append(sorted_wear_levels) return results"},{"question":"def redistribute_books(n: int, books: List[int]) -> int: Determines if it is possible to redistribute books so each rack has the same number of books without any rack being empty. Returns the number of books on each rack after redistribution if possible, otherwise returns -1. >>> redistribute_books(5, [6, 9, 3, 6, 6]) 6 >>> redistribute_books(4, [0, 4, 4, 4]) -1 >>> redistribute_books(3, [2, 4, 6]) 4 >>> redistribute_books(1, [5]) 5 >>> redistribute_books(1, [0]) -1 >>> redistribute_books(3, [0, 0, 0]) -1 # Your code here","solution":"def redistribute_books(n, books): Determines if it is possible to redistribute books so each rack has the same number of books without any rack being empty. Returns the number of books on each rack after redistribution if possible, otherwise returns -1. total_books = sum(books) if total_books % n != 0: return -1 books_per_rack = total_books // n if any(book == 0 for book in books): return -1 return books_per_rack"},{"question":"def encrypt_string(s: str, k: int) -> str: Encrypts the input string s by shifting its characters by k positions in the alphabet. Non-alphabet characters remain unchanged. >>> encrypt_string(\\"abc\\", 1) 'bcd' >>> encrypt_string(\\"XYZ\\", 3) 'ABC' >>> encrypt_string(\\"Hello, World!\\", 5) 'Mjqqt, Btwqi!' pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases and returns their encrypted results. >>> process_test_cases([(\\"abc\\", 1), (\\"XYZ\\", 3), (\\"Hello, World!\\", 5)]) ['bcd', 'ABC', 'Mjqqt, Btwqi!'] pass","solution":"def encrypt_string(s, k): Encrypts the input string s by shifting its characters by k positions in the alphabet. Non-alphabet characters remain unchanged. :param s: The input string to be encrypted. :param k: The shift value for the encryption. :return: The encrypted string. encrypted = [] for char in s: if char.isalpha(): shift = k % 26 if char.islower(): encrypted.append(chr((ord(char) - ord('a') + shift) % 26 + ord('a'))) elif char.isupper(): encrypted.append(chr((ord(char) - ord('A') + shift) % 26 + ord('A'))) else: encrypted.append(char) return ''.join(encrypted) def process_test_cases(test_cases): Processes multiple test cases and returns their encrypted results. :param test_cases: A list of tuples, each containing a string and an integer shift value. :return: A list of encrypted strings corresponding to each test case. results = [] for s, k in test_cases: results.append(encrypt_string(s, k)) return results"},{"question":"def count_long_roads(n: int, roads: List[int]) -> int: Returns the number of \\"long roads\\", i.e., roads with length greater than or equal to the average length of all roads. Parameters: n (int): The number of roads in the city. roads (list of int): The lengths of each road. Returns: int: The number of \\"long roads\\". >>> count_long_roads(5, [100, 200, 300, 400, 500]) == 3 >>> count_long_roads(4, [100, 100, 100, 100]) == 4 pass def test_count_long_roads_basic(): assert count_long_roads(5, [100, 200, 300, 400, 500]) == 3 def test_count_long_roads_all_same_length(): assert count_long_roads(4, [100, 100, 100, 100]) == 4 def test_count_long_roads_varying_lengths(): assert count_long_roads(6, [50, 60, 70, 80, 90, 100]) == 3 def test_count_long_roads_single_road(): assert count_long_roads(1, [1000]) == 1 def test_count_long_roads_none_long(): assert count_long_roads(5, [1, 2, 2, 2, 1]) == 3 # Average is 1.6 and roads >= 1.6 are 2, 2, 2 def test_count_long_roads_mixed_lengths(): assert count_long_roads(8, [10, 20, 30, 40, 50, 60, 70, 80]) == 4 # Average is 45 and roads >= 45 are 50, 60, 70, 80","solution":"def count_long_roads(n, roads): Returns the number of \\"long roads\\", i.e., roads with length greater than or equal to the average length of all roads. Parameters: n (int): The number of roads in the city. roads (list of int): The lengths of each road. Returns: int: The number of \\"long roads\\". average_length = sum(roads) / n long_road_count = sum(1 for road in roads if road >= average_length) return long_road_count"},{"question":"def remove_duplicates(input_string: str) -> str: Removes duplicate characters from the input string while preserving the order of first occurrence. Parameters: input_string (str): The string from which to remove duplicate characters. Returns: str: A new string with duplicates removed. >>> remove_duplicates(\\"programming\\") == \\"progamin\\" >>> remove_duplicates(\\"hello\\") == \\"helo\\" >>> remove_duplicates(\\"aabbcc\\") == \\"abc\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"a\\") == \\"a\\" >>> remove_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_duplicates(\\"aaaaa\\") == \\"a\\" >>> remove_duplicates(\\"abacabad\\") == \\"abcd\\" pass","solution":"def remove_duplicates(input_string): Removes duplicate characters from the input string while preserving the order of first occurrence. Parameters: input_string (str): The string from which to remove duplicate characters. Returns: str: A new string with duplicates removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbhijkkjih\\") True","solution":"def can_form_palindrome(s: str) -> bool: Determine if a string can be rearranged to form a palindrome. from collections import Counter count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) return odd_count <= 1"},{"question":"def max_villagers(n: int, intervals: List[Tuple[int, int]]) -> int: Determine the maximum number of villagers that can fetch water from the well without conflicts. Args: n (int): The number of villagers. intervals (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers (s_i, d_i), representing the preferred start time and duration for each villager. Returns: int: The maximum number of villagers that can use the well sequentially without conflicts. Examples: >>> max_villagers(5, [(1, 3), (2, 2), (3, 1), (6, 1), (7, 2)]) 3 >>> max_villagers(3, [(1, 2), (3, 2), (5, 2)]) 3 >>> max_villagers(4, [(1, 4), (2, 3), (3, 3), (4, 2)]) 1 pass # Unit tests def test_sample_input(): assert max_villagers(5, [(1, 3), (2, 2), (3, 1), (6, 1), (7, 2)]) == 3 def test_no_overlap(): assert max_villagers(3, [(1, 2), (3, 2), (5, 2)]) == 3 def test_all_overlap(): assert max_villagers(4, [(1, 4), (2, 3), (3, 3), (4, 2)]) == 1 def test_large_gaps(): assert max_villagers(2, [(1, 1), (10, 1)]) == 2 def test_single_villager(): assert max_villagers(1, [(0, 5)]) == 1 def test_large_input(): n = 100000 intervals = [(i, 1) for i in range(n)] assert max_villagers(n, intervals) == n # All villagers have unique time slots def test_overlapping_early_starts(): assert max_villagers(3, [(0, 3), (1, 2), (2, 2)]) == 1","solution":"def max_villagers(n, intervals): # Sort intervals based on ending times intervals.sort(key=lambda x: x[0] + x[1]) count = 0 end_time = -1 for start, duration in intervals: if start >= end_time: count += 1 end_time = start + duration return count # Example usage n = 5 intervals = [(1, 3), (2, 2), (3, 1), (6, 1), (7, 2)] print(max_villagers(n, intervals)) # Output: 3"},{"question":"def process_commands(n: int, commands: List[str]) -> List[str]: Mike is working on a project where he needs to synchronize data between two systems. He is writing a script to monitor changes in a list of integers. Every time an integer in the list changes, the script should recognize the change and keep the list updated by making the necessary modifications in another system. The script needs to handle a special set of commands efficiently. Commands: - \\"add x\\" - Add the integer x to the end of the list. - \\"del x\\" - Delete the first occurrence of the integer x from the list. - \\"mod x y\\" - Replace the first occurrence of the integer x with integer y in the list. - \\"rep\\" - Output the current state of the list. Initially, the list is empty. The goal is to process each of the commands and maintain the list's integrity. Parameters: - n: int - number of commands - commands: List[str] - list of command strings Returns: - List[str] - output after each \\"rep\\" command Example: >>> process_commands(10, [\\"add 4\\", \\"add 2\\", \\"add 7\\", \\"rep\\", \\"del 2\\", \\"rep\\", \\"mod 7 3\\", \\"rep\\", \\"del 5\\", \\"rep\\"]) [\\"4 2 7\\", \\"4 7\\", \\"4 3\\", \\"4 3\\"] # Implement the function here","solution":"def process_commands(n, commands): lst = [] result_lines = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"add\\": x = int(parts[1]) lst.append(x) elif cmd == \\"del\\": x = int(parts[1]) if x in lst: lst.remove(x) elif cmd == \\"mod\\": x = int(parts[1]) y = int(parts[2]) try: index = lst.index(x) lst[index] = y except ValueError: pass # x not in list, do nothing elif cmd == \\"rep\\": result_lines.append(' '.join(map(str, lst))) return result_lines"},{"question":"def minMeetingRooms(intervals): You are given a list of integer intervals representing the busy time slots for a number of employees in a company. Each interval is a tuple of two integers, representing the start and end of a time slot [start, end]. Your objective is to identify the minimum number of meeting rooms required to accommodate all the meetings without any overlap. A meeting room can only be occupied by one meeting at a time. Overlapping meetings cannot occur in the same room. Args: intervals: List[Tuple[int, int]] - An array of tuples, where each tuple contains two integers [start, end] representing the start and end time of a busy slot. Returns: int - An integer representing the minimum number of meeting rooms required. Example: >>> minMeetingRooms([(30, 75), (0, 50), (60, 150)]) 2 >>> minMeetingRooms([(0, 30), (5, 10), (15, 20)]) 2 >>> minMeetingRooms([(1, 5), (6, 10), (11, 15)]) 1","solution":"def minMeetingRooms(intervals): if not intervals: return 0 # Initialize separate lists for start times and end times start_times = sorted([interval[0] for interval in intervals]) end_times = sorted([interval[1] for interval in intervals]) # Initialize pointers for start times and end times start_pointer = 0 end_pointer = 0 # Initialize variable to keep track of current rooms needed current_rooms = 0 max_rooms = 0 # Iterate over all the intervals while start_pointer < len(intervals): # If there is a new meeting before the meeting at the end_pointer finishes if start_times[start_pointer] < end_times[end_pointer]: current_rooms += 1 start_pointer += 1 else: current_rooms -= 1 end_pointer += 1 # Update the maximum number of rooms needed max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"def longest_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray containing at most two distinct integers. >>> longest_subarray([1, 2, 1]) 3 >>> longest_subarray([1, 2, 2, 3, 3, 4, 4, 4]) 5 pass","solution":"def longest_subarray(arr): Returns the length of the longest contiguous subarray containing at most two distinct integers. if not arr: return 0 left = 0 right = 0 max_length = 0 counts = {} while right < len(arr): if arr[right] in counts or len(counts) < 2: counts[arr[right]] = counts.get(arr[right], 0) + 1 right += 1 else: counts[arr[left]] -= 1 if counts[arr[left]] == 0: del counts[arr[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def expected_winner(skill_levels: list[int]) -> int: Returns the skill level of the expected winner of the tournament. Parameters: skill_levels (list): A list of integers representing the skill levels of players. Returns: int: The skill level of the expected winner. Example: >>> expected_winner([4, 2, 5, 3, 1]) 5 >>> expected_winner([7, 2, 9, 4, 1, 8, 6]) 9 def test_expected_winner_single_player(): assert expected_winner([1]) == 1 def test_expected_winner_sample_input1(): assert expected_winner([4, 2, 5, 3, 1]) == 5 def test_expected_winner_sample_input2(): assert expected_winner([7, 2, 9, 4, 1, 8, 6]) == 9 def test_expected_winner_all_same_except_one(): assert expected_winner([1, 1, 1, 1, 1, 10]) == 10 def test_expected_winner_increasing_order(): assert expected_winner([1, 2, 3, 4, 5]) == 5 def test_expected_winner_decreasing_order(): assert expected_winner([5, 4, 3, 2, 1]) == 5 def test_expected_winner_random_order(): assert expected_winner([15, 32, 8, 21, 5]) == 32","solution":"def expected_winner(skill_levels): Returns the skill level of the expected winner of the tournament. Parameters: skill_levels (list): A list of integers representing the skill levels of players. Returns: int: The skill level of the expected winner. return max(skill_levels)"},{"question":"def sum_queries(arr, queries): Calculate the sum of elements for each query from L to R. Parameters: arr (list): List of integers. queries (list): List of tuples where each tuple contains two integers representing L and R. Returns: list: List of integers representing the sum for each query. >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 4), (1, 5)] >>> sum_queries(arr, queries) [6, 9, 15] >>> arr = [5] >>> queries = [(1, 1)] >>> sum_queries(arr, queries) [5] >>> arr = [10, 20, 30, 40, 50] >>> queries = [(2, 2), (4, 4)] >>> sum_queries(arr, queries) [20, 40] >>> arr = [i for i in range(1, 100001)] >>> queries = [(1, 100000), (1, 50000), (50001, 100000)] >>> sum_queries(arr, queries) [5000050000, 1250025000, 3750025000] >>> arr = [1, 2, 3, 4, 5, 6] >>> queries = [(1, 6), (1, 3), (4, 6), (2, 5)] >>> sum_queries(arr, queries) [21, 6, 15, 14]","solution":"def sum_queries(arr, queries): Calculate the sum of elements for each query from L to R. Parameters: arr (list): List of integers. queries (list): List of tuples where each tuple contains two integers representing L and R. Returns: list: List of integers representing the sum for each query. # Precompute the prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] # Answer each query using prefix sums results = [] for L, R in queries: results.append(prefix_sums[R] - prefix_sums[L - 1]) return results"},{"question":"from typing import List, Tuple def min_meeting_rooms(meetings: List[Tuple[int, int]]) -> int: Given a list of meeting events each with a start and end time, determine the minimum number of meeting rooms required to host all the meetings without conflict. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(2, 10), (6, 15)]) 2 >>> min_meeting_rooms([(1, 5), (2, 6), (8, 9), (5, 9)]) 2 >>> min_meeting_rooms([(1, 5), (6, 10)]) 1 >>> min_meeting_rooms([(1, 4), (1, 4), (1, 4)]) 3 >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([(1, 4)]) 1","solution":"def min_meeting_rooms(meetings): Returns the minimum number of meeting rooms required to host all the meetings without conflict. if not meetings: return 0 # Separate out the start and end times and sort them start_times = sorted(meeting[0] for meeting in meetings) end_times = sorted(meeting[1] for meeting in meetings) start_pointer = 0 end_pointer = 0 used_rooms = 0 while start_pointer < len(meetings): # If there is a meeting that has ended before the current meeting starts if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # We do this irrespective of whether a room frees up or not. # If a room got free, then this used_rooms += 1 wouldn't have any effect. # used_rooms would remain the same in that case. used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"def max_flowers(n: int, m: int, grid: List[List[int]]) -> int: Calculate the maximum number of flowers Leia can collect while walking from the top-left corner to the bottom-right corner of the grid only moving to the right or down. >>> max_flowers(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 >>> max_flowers(2, 2, [[2, 3], [1, 4]]) == 9 >>> max_flowers(2, 3, [[1, 1000, 1], [1, 1, 1]]) == 1003 >>> max_flowers(1, 1, [[10]]) == 10 >>> max_flowers(3, 2, [[1, 2], [3, 4], [5, 6]]) == 15","solution":"def max_flowers(n, m, grid): # Initialize dp array where dp[i][j] means the maximum flowers can collect to reach cell (i, j) dp = [[0]*m for _ in range(n)] dp[0][0] = grid[0][0] # Starting point # Fill the first row of the dp array for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column of the dp array for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def split_sequence(q: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to split the sequence into subarrays as described. :param q: Number of test cases :param test_cases: List of test cases, where each test case is a tuple containing an integer m (length of sequence) and a list of integers representing the sequence :return: List of strings, \\"YES\\" if it is possible to split the sequence as described, \\"NO\\" otherwise >>> split_sequence(3, [ ... (6, [10, 3, 8, 5, 7, 2]), ... (5, [1, 2, 3, 4, 5]), ... (4, [9, 8, 7, 6]) ... ]) ['YES', 'NO', 'YES']","solution":"def split_sequence(q, test_cases): results = [] for test in test_cases: m, sequence = test subarrays = [] current_subarray = [sequence[0]] for i in range(1, m): if sequence[i] < current_subarray[-1]: current_subarray.append(sequence[i]) else: if len(current_subarray) >= 2: subarrays.append(current_subarray) current_subarray = [sequence[i]] if len(current_subarray) >= 2: subarrays.append(current_subarray) total_length = sum(len(subarray) for subarray in subarrays) if total_length >= m / 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example input q = 3 test_cases = [ (6, [10, 3, 8, 5, 7, 2]), (5, [1, 2, 3, 4, 5]), (4, [9, 8, 7, 6]) ] # Example output print(split_sequence(q, test_cases)) # Output: ['YES', 'NO', 'YES']"},{"question":"import math def simplify_fraction(numerator: int, denominator: int) -> str: Simplify a fraction provided by numerator and denominator. >>> simplify_fraction(8, 12) \\"2/3\\" >>> simplify_fraction(25, 5) \\"5/1\\" >>> simplify_fraction(14, 28) \\"1/2\\" >>> simplify_fraction(49, 21) \\"7/3\\" >>> simplify_fraction(10, 100) \\"1/10\\"","solution":"import math def simplify_fraction(numerator, denominator): Simplifies a fraction given by numerator and denominator. Returns the fraction in the form of \\"numerator/denominator\\". gcd = math.gcd(numerator, denominator) simplified_numerator = numerator // gcd simplified_denominator = denominator // gcd return f\\"{simplified_numerator}/{simplified_denominator}\\""},{"question":"def categorize_orders(orders): Categorize orders into small, medium, and large. Parameters: orders (list): A list of integers representing the quantities of the item in each order. Returns: tuple: A tuple of three integers representing the count of small orders, medium orders, and large orders respectively. >>> categorize_orders([1, 5, 10]) (3, 0, 0) >>> categorize_orders([11, 20, 50]) (0, 3, 0) >>> categorize_orders([51, 70, 100]) (0, 0, 3) >>> categorize_orders([1, 11, 51, 10, 20, 70, 5, 50, 100]) (3, 3, 3) >>> categorize_orders([5, 15, 55, 7, 25, 75, 9, 35, 95]) (3, 3, 3) >>> categorize_orders([1, 10, 11, 50, 51, 100]) (2, 2, 2) >>> categorize_orders([]) (0, 0, 0)","solution":"def categorize_orders(orders): Categorize orders into small, medium, and large. Parameters: orders (list): A list of integers representing the quantities of the item in each order. Returns: tuple: A tuple of three integers representing the count of small orders, medium orders, and large orders respectively. small = 0 medium = 0 large = 0 for order in orders: if order >= 1 and order <= 10: small += 1 elif order >= 11 and order <= 50: medium += 1 elif order >= 51 and order <= 100: large += 1 return (small, medium, large)"},{"question":"def max_total_points(points): Returns the maximum total points that can be earned by selecting the best score from each session for all chefs. Args: points (list of tuples): A list of tuples where each tuple contains two integers p_i and s_i, representing the points that the i-th chef can earn in the primary and secondary sessions respectively. Returns: int: The maximum total points. >>> max_total_points([(80, 90), (70, 85), (95, 65), (100, 60)]) 370 >>> max_total_points([(10, 20), (30, 40), (50, 60), (70, 80)]) 200","solution":"def max_total_points(points): Returns the maximum total points that can be earned by selecting the best score from each session for all chefs. Args: points (list of tuples): A list of tuples where each tuple contains two integers p_i and s_i, representing the points that the i-th chef can earn in the primary and secondary sessions respectively. Returns: int: The maximum total points. total_points = 0 for p_i, s_i in points: total_points += max(p_i, s_i) return total_points"},{"question":"def process_queries(queries): Process a list of queries and return the results based on the operations performed on string S. Queries can be of three types: 1. Insert a character c at the end of S. 2. Remove the last character from S (if S is not empty). 3. Find the k-th character in the string S (1-based index). For each type 3 query, return the k-th character or -1 if k is out of bounds. Args: queries (List[str]): List of query strings. Returns: List: List of results for type 3 queries. Examples: >>> process_queries([\\"1 a\\", \\"1 b\\", \\"1 c\\", \\"3 2\\", \\"2\\"]) ['b'] >>> process_queries([\\"1 x\\", \\"1 y\\", \\"1 z\\", \\"3 1\\", \\"3 3\\", \\"2\\", \\"3 3\\", \\"3 2\\"]) ['x', 'z', -1, 'y'] >>> process_queries([\\"1 m\\", \\"2\\", \\"1 n\\", \\"1 o\\", \\"3 2\\", \\"3 3\\"]) ['o', -1] pass def batch_process(input_string): Parse input string to extract queries, pass them to process_queries function, and return the results. Args: input_string (str): Multiline string containing number of queries and the queries. Returns: List: List of results for type 3 queries. Examples: >>> batch_process(\\"5n1 an1 bn1 cn3 2n2\\") ['b'] >>> batch_process(\\"8n1 xn1 yn1 zn3 1n3 3n2n3 3n3 2\\") ['x', 'z', -1, 'y'] >>> batch_process(\\"6n1 mn2n1 nn1 on3 2n3 3\\") ['o', -1] pass","solution":"def process_queries(queries): S = [] results = [] for query in queries: parts = query.split() if parts[0] == '1': S.append(parts[1]) elif parts[0] == '2': if S: S.pop() elif parts[0] == '3': k = int(parts[1]) if 1 <= k <= len(S): results.append(S[k-1]) else: results.append(-1) return results def batch_process(input_string): lines = input_string.strip().split('n') Q = int(lines[0]) queries = lines[1:Q+1] return process_queries(queries)"},{"question":"def longest_subarray_with_difference_one(nums: List[int]) -> int: Write a function that takes a list of integers and returns the length of the longest subarray where the difference between the maximum and minimum values is exactly 1. >>> longest_subarray_with_difference_one([1, 2, 2, 1, 3, 4, 2, 1]) == 4 >>> longest_subarray_with_difference_one([1, 3, 5, 7]) == 0 >>> longest_subarray_with_difference_one([1, 2, 3, 4, 5, 6]) == 2 >>> longest_subarray_with_difference_one([]) == 0 >>> longest_subarray_with_difference_one([1, 1, 1, 1]) == 0 >>> longest_subarray_with_difference_one([4, 5, 5, 5, 4, 3, 2, 2]) == 5 >>> longest_subarray_with_difference_one([10, 11, 12, 10, 10, 11, 11]) == 4 >>> longest_subarray_with_difference_one([0]) == 0 >>> longest_subarray_with_difference_one([1, 2]) == 2 >>> longest_subarray_with_difference_one([2, 1, 1, 2]) == 4 >>> longest_subarray_with_difference_one([7, 7, 8, 8, 8, 7]) == 6","solution":"def longest_subarray_with_difference_one(nums): if not nums: return 0 max_len = 0 count = {} left = 0 for right in range(len(nums)): count[nums[right]] = count.get(nums[right], 0) + 1 while max(count.keys()) - min(count.keys()) > 1: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 if max(count.keys()) - min(count.keys()) == 1: max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List, Tuple def minimum_subset_sum_diff(arr: List[int]) -> int: Determine the minimum difference between the sum of two non-overlapping subsets of the collection. >>> minimum_subset_sum_diff([1, 6, 11, 5]) 1 >>> minimum_subset_sum_diff([1, 2, 3]) 0 pass def solve(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, determine the minimum difference between the sum of two non-overlapping subsets. Input: - T: an integer, the number of test cases. - test_cases: a list of tuples where each tuple contains an integer and a list of integers representing the collection. Output: - A list of integers representing the minimum difference of the sums of two subsets for each test case. pass def test_example_case_1(): T = 2 test_cases = [ (4, [1, 6, 11, 5]), (3, [1, 2, 3]) ] assert solve(T, test_cases) == [1, 0] def test_single_element(): T = 1 test_cases = [ (1, [10]) ] assert solve(T, test_cases) == [10] def test_two_elements(): T = 1 test_cases = [ (2, [8, 4]) ] assert solve(T, test_cases) == [4] def test_identical_elements(): T = 1 test_cases = [ (4, [10, 10, 10, 10]) ] assert solve(T, test_cases) == [0] def test_large_elements(): T = 1 test_cases = [ (5, [1000, 1000, 1000, 1000, 1000]) ] assert solve(T, test_cases) == [1000]","solution":"def minimum_subset_sum_diff(arr): total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: subset_sum_1 = j break subset_sum_2 = total_sum - subset_sum_1 return abs(subset_sum_2 - subset_sum_1) def solve(T, test_cases): results = [] for i in range(T): N, arr = test_cases[i] results.append(minimum_subset_sum_diff(arr)) return results"},{"question":"def countPaths(n, m): Returns the number of distinct ways to go from square (0,0) to square (n, m) on an n x m grid. You can only move right or down. >>> countPaths(2, 2) == 6 >>> countPaths(3, 3) == 20 >>> countPaths(1, 1000) == 1001 >>> countPaths(1000, 1) == 1001 >>> countPaths(1, 1) == 2 >>> countPaths(0, 0) == 1 >>> countPaths(0, 1000) == 1 >>> countPaths(1000, 0) == 1","solution":"import math def countPaths(n, m): Returns the number of distinct ways to go from square (0,0) to square (n, m) on an n x m grid. You can only move right or down. return math.comb(n + m, n)"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"def min_cards_to_exchange(alice_cards: str, bob_cards: str) -> int: Calculate the minimum number of cards Alice and Bob have to exchange to ensure that both of them end up with one card from each set. Args: alice_cards (str): A string of lowercase letters representing the sets of Alice's cards. bob_cards (str): A string of lowercase letters representing the sets of Bob's cards. Returns: int: The minimum number of cards they need to exchange. Examples: >>> min_cards_to_exchange(\\"aabcc\\", \\"dbbb\\") 3 >>> min_cards_to_exchange(\\"abc\\", \\"xyz\\") 6","solution":"def min_cards_to_exchange(alice_cards: str, bob_cards: str) -> int: # Find the unique sets each one has alice_sets = set(alice_cards) bob_sets = set(bob_cards) # Calculate sets that only Alice has and Bob needs alice_unique_sets = alice_sets - bob_sets # Calculate sets that only Bob has and Alice needs bob_unique_sets = bob_sets - alice_sets # The minimum number of cards to exchange is the sum of unique sets each needs from the other return len(alice_unique_sets) + len(bob_unique_sets)"},{"question":"def find_scrambled_words(word_list: List[str], target_word: str) -> List[str]: Returns a list of valid scrambled versions of the target_word that exist in the word_list. The returned list is sorted in lexicographical order. >>> find_scrambled_words([\\"tea\\", \\"eat\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"], \\"eat\\") [\\"ate\\", \\"eat\\", \\"tea\\"] >>> find_scrambled_words([\\"cat\\", \\"dog\\", \\"bird\\", \\"fish\\"], \\"wolf\\") [\\"No valid scrambled words found\\"] >>> find_scrambled_words([\\"aaa\\", \\"aaa\\", \\"aaa\\"], \\"aaa\\") [\\"aaa\\", \\"aaa\\", \\"aaa\\"] >>> find_scrambled_words([\\"a\\", \\"b\\", \\"c\\"], \\"b\\") [\\"b\\"] >>> find_scrambled_words([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") [\\"No valid scrambled words found\\"] >>> find_scrambled_words([], \\"test\\") [\\"No valid scrambled words found\\"] pass","solution":"def find_scrambled_words(word_list, target_word): Returns a list of valid scrambled versions of the target_word that exist in the word_list. The returned list is sorted in lexicographical order. target_sorted = sorted(target_word) valid_scrambled_words = [] for word in word_list: if sorted(word) == target_sorted: valid_scrambled_words.append(word) if not valid_scrambled_words: return [\\"No valid scrambled words found\\"] return sorted(valid_scrambled_words)"},{"question":"def can_form_palindrome(s: str) -> str: Determines if characters of the string can be rearranged to form a palindrome. Args: s (str): Input string containing visible ASCII characters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. pass from solution import can_form_palindrome def test_even_length_palindromic(): assert can_form_palindrome(\\"aabbcc\\") == \\"YES\\" def test_odd_length_palindromic(): assert can_form_palindrome(\\"aabbc\\") == \\"YES\\" def test_not_palindromic(): assert can_form_palindrome(\\"aabbcd\\") == \\"NO\\" def test_single_character(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_two_different_characters(): assert can_form_palindrome(\\"ab\\") == \\"NO\\" def test_special_characters(): assert can_form_palindrome(\\"aabb@@@\\") == \\"YES\\" assert can_form_palindrome(\\"@@@@@@@\\") == \\"YES\\" def test_mixed_characters(): assert can_form_palindrome(\\"aabb123123\\") == \\"YES\\" assert can_form_palindrome(\\"aabb123124\\") == \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s): Determines if characters of the string can be rearranged to form a palindrome. Args: s (str): Input string containing visible ASCII characters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. # Count the frequency of each character char_count = Counter(s) # Check the number of characters with odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if odd_count is at most 1 if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def remove_consecutive_duplicates(s: str) -> str: Remove all consecutive duplicate characters from the input string. :param s: input string containing only lowercase alphabets :return: resulting string after removing consecutive duplicates >>> remove_consecutive_duplicates(\\"aaabccddddde\\") \\"abcde\\" >>> remove_consecutive_duplicates(\\"abccba\\") \\"abcba\\" >>> remove_consecutive_duplicates(\\"aabbcc\\") \\"abc\\" >>> remove_consecutive_duplicates(\\"abcd\\") \\"abcd\\" >>> remove_consecutive_duplicates(\\"\\") \\"\\" >>> remove_consecutive_duplicates(\\"a\\") \\"a\\" >>> remove_consecutive_duplicates(\\"aaaaaaa\\") \\"a\\" >>> remove_consecutive_duplicates(\\"abababab\\") \\"abababab\\" >>> remove_consecutive_duplicates(\\"abcabcabc\\") \\"abcabcabc\\"","solution":"def remove_consecutive_duplicates(s): Remove all consecutive duplicate characters from the input string. :param s: input string containing only lowercase alphabets :return: resulting string after removing consecutive duplicates if not s: return s result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result) # Example usage: # s = \\"aaabccddddde\\" # print(remove_consecutive_duplicates(s)) # Output: \\"abcde\\""},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"abcdefg\\") == 7 >>> length_of_longest_substring(\\"aab\\") == 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_map = {} max_length = 0 left = 0 for right in range(n): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def minimum_swaps_to_good_array(n: int, arr: List[int]) -> int: Find the minimum number of swaps to transform the array into a good array. An array is considered \\"good\\" if every element in the array is equal to its index value (1-based index). :param n: Length of the array :param arr: List of integers :return: Minimum number of swaps required Examples: >>> minimum_swaps_to_good_array(5, [3, 5, 4, 1, 2]) 3 >>> minimum_swaps_to_good_array(4, [2, 1, 4, 3]) 2 from typing import List def test_example_1(): assert minimum_swaps_to_good_array(5, [3, 5, 4, 1, 2]) == 3 def test_example_2(): assert minimum_swaps_to_good_array(4, [2, 1, 4, 3]) == 2 def test_sorted_array(): assert minimum_swaps_to_good_array(5, [1, 2, 3, 4, 5]) == 0 def test_reverse_array(): assert minimum_swaps_to_good_array(5, [5, 4, 3, 2, 1]) == 2 def test_single_element(): assert minimum_swaps_to_good_array(1, [1]) == 0 def test_two_swaps_needed(): assert minimum_swaps_to_good_array(6, [2, 1, 4, 3, 6, 5]) == 3 def test_large_array(): assert minimum_swaps_to_good_array(7, [7, 1, 2, 3, 4, 5, 6]) == 6","solution":"def minimum_swaps_to_good_array(n, arr): Find the minimum number of swaps to transform the array into a good array. A good array is defined as an array where each element is equal to its index value (1-based index). :param n: Length of the array :param arr: List of integers :return: Minimum number of swaps required # Create a list to keep track of visited elements visited = [False] * n swaps = 0 for i in range(n): if not visited[i]: cycle_length = 0 x = i while not visited[x]: visited[x] = True x = arr[x] - 1 cycle_length += 1 if cycle_length > 1: swaps += cycle_length - 1 return swaps"},{"question":"def calculate_working_hours(data): Calculate total and average working hours from a list of \\"name: hours\\" strings. >>> calculate_working_hours([ ... \\"John Doe: 40\\", ... \\"Jane Smith: 55\\", ... \\"Robert Brown: 32\\" ... ]) (127, 42) >>> calculate_working_hours([\\"John Doe: 40\\"]) (40, 40) >>> calculate_working_hours([]) (0, 0) >>> calculate_working_hours([ ... \\"John Doe: 0\\", ... \\"Jane Smith: 0\\", ... \\"Robert Brown: 0\\" ... ]) (0, 0) >>> calculate_working_hours([ ... \\"John Doe: 168\\", ... \\"Jane Smith: 168\\", ... \\"Robert Brown: 168\\" ... ]) (504, 168) >>> calculate_working_hours([ ... \\"John Doe: 10\\", ... \\"Jane Smith: 20\\", ... \\"Robert Brown: 30\\" ... ]) (60, 20)","solution":"def calculate_working_hours(data): Function to calculate total and average working hours given a list of \\"name: hours\\" strings. total_hours = 0 count = 0 for line in data: if line.strip(): name, hours = line.split(\\":\\") total_hours += int(hours.strip()) count += 1 average_hours = round(total_hours / count) if count > 0 else 0 return total_hours, average_hours"},{"question":"def transform_list(int_list): Returns a new list where each even integer is squared, and each odd integer remains unchanged. :param int_list: List of integers :return: List of transformed integers >>> transform_list([1, 2, 3, 4, 5, 6]) == [1, 4, 3, 16, 5, 36] >>> transform_list([7, 8, 9]) == [7, 64, 9] from solution import transform_list def test_transform_list_all_even(): assert transform_list([2, 4, 6]) == [4, 16, 36] def test_transform_list_all_odd(): assert transform_list([1, 3, 5]) == [1, 3, 5] def test_transform_list_mixed(): assert transform_list([1, 2, 3, 4, 5, 6]) == [1, 4, 3, 16, 5, 36] def test_transform_list_single_even(): assert transform_list([2]) == [4] def test_transform_list_single_odd(): assert transform_list([3]) == [3] def test_transform_list_empty(): assert transform_list([]) == [] def test_transform_list_negative_numbers(): assert transform_list([-1, -2, -3, -4]) == [-1, 4, -3, 16] def test_transform_list_large_numbers(): assert transform_list([100, 101, 102]) == [10000, 101, 10404]","solution":"def transform_list(int_list): Returns a new list where each even integer is squared, and each odd integer remains unchanged. :param int_list: List of integers :return: List of transformed integers result_list = [] for num in int_list: if num % 2 == 0: result_list.append(num ** 2) else: result_list.append(num) return result_list"},{"question":"def find_max_temperatures(n: int, k: int, comparisons: List[Tuple[int, int]]) -> List[int]: Determine the possible maximum temperature value for each day based on the comparisons provided. >>> find_max_temperatures(4, 3, [(1, 2), (2, 3), (3, 4)]) [4, 3, 2, 1] >>> find_max_temperatures(3, 3, [(1, 2), (2, 3), (3, 1)]) [-1] >>> find_max_temperatures(5, 0, []) [1, 2, 3, 4, 5] >>> find_max_temperatures(1, 0, []) [1] >>> find_max_temperatures(2, 1, [(1, 2)]) [2, 1]","solution":"def find_max_temperatures(n, k, comparisons): from collections import defaultdict, deque # Create adjacency list and in-degrees count adj_list = defaultdict(list) in_degrees = [0] * (n + 1) for i, j in comparisons: adj_list[i].append(j) in_degrees[j] += 1 # Topological Sort using Kahn's Algorithm queue = deque() for i in range(1, n + 1): if in_degrees[i] == 0: queue.append(i) topo_order = [] while queue: current = queue.popleft() topo_order.append(current) for neighbor in adj_list[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) # If topo_order doesn't contain all nodes, then there is a cycle if len(topo_order) != n: return [-1] # We can assign decreasing values from n to 1 based on the topological order temperatures = [0] * n for i in range(n): temperatures[topo_order[i] - 1] = n - i return temperatures"},{"question":"def find_shortest_travel_times(n: int, m: int, roads: List[Tuple[int, int, int]], q: int, destinations: List[int]) -> List[int]: Determine the shortest time required to travel from the warehouse city to multiple destination cities. n : int : number of cities m : int : number of roads roads : List[Tuple[int, int, int]] : list of m tuples representing roads (u, v, w) q : int : number of destination cities destinations : List[int] : list of destination cities :return: List[int] where each integer is the shortest travel time from the warehouse city (city 1) to the corresponding city in the destinations list. If a city is unreachable, return -1 for that city. >>> find_shortest_travel_times(5, 6, [(1, 2, 10), (1, 3, 20), (2, 3, 15), (2, 4, 25), (3, 4, 30), (4, 5, 10)], 3, [2, 4, 5]) [10, 35, 45] >>> find_shortest_travel_times(3, 2, [(1, 2, 10), (2, 3, 15)], 2, [2, 3]) [10, 25] >>> find_shortest_travel_times(4, 2, [(1, 2, 10), (3, 4, 15)], 2, [2, 4]) [10, -1]","solution":"import heapq from typing import List, Tuple, Dict def find_shortest_travel_times(n: int, m: int, roads: List[Tuple[int, int, int]], q: int, destinations: List[int]) -> List[int]: # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path from node 1 def dijkstra(start: int) -> Dict[int, int]: min_heap = [(0, start)] shortest_paths = {i: float('inf') for i in range(1, n + 1)} shortest_paths[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > shortest_paths[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return shortest_paths # Get shortest paths from the warehouse city (1) shortest_paths_from_warehouse = dijkstra(1) # Determine shortest travel times to each destination result = [] for dest in destinations: travel_time = shortest_paths_from_warehouse[dest] result.append(travel_time if travel_time != float('inf') else -1) return result"},{"question":"def max_beauty_segment(t, test_cases): Calculate the maximum beauty value of any continuous sub-segment of the flower bed for each row. Args: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n and a list of ints representing beauty values. Returns: list of int: Maximum beauty value for each test case. # Your code here def test_max_beauty_segment(): # Test case 1 t1 = 2 test_cases1 = [(5, [1, 2, -1, 2, 3]), (4, [-1, -2, -3, -4])] assert max_beauty_segment(t1, test_cases1) == [7, -1] # Test case 2: Single element positive t2 = 1 test_cases2 = [(1, [5])] assert max_beauty_segment(t2, test_cases2) == [5] # Test case 3: Single element negative t3 = 1 test_cases3 = [(1, [-5])] assert max_beauty_segment(t3, test_cases3) == [-5] # Test case 4: All positive values t4 = 1 test_cases4 = [(3, [1, 2, 3])] assert max_beauty_segment(t4, test_cases4) == [6] # Test case 5: All negative values t5 = 1 test_cases5 = [(3, [-1, -2, -3])] assert max_beauty_segment(t5, test_cases5) == [-1] # Test case 6: Mixed values t6 = 1 test_cases6 = [(5, [-1, 3, -2, 2, 1])] assert max_beauty_segment(t6, test_cases6) == [4] # Test case 7: Large array t7 = 1 test_cases7 = [(6, [1, 2, 3, -2, 5, -1])] assert max_beauty_segment(t7, test_cases7) == [9]","solution":"def max_beauty_segment(t, test_cases): Calculate the maximum beauty value of any continuous sub-segment of the flower bed for each row. Args: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n and a list of ints representing beauty values. Returns: list of int: Maximum beauty value for each test case. def max_subarray_sum(arr): Helper function to compute maximum sum of continuous sub-segment using Kadane's algorithm max_so_far = arr[0] max_ending_here = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far results = [] for i in range(t): n, flowers = test_cases[i] results.append(max_subarray_sum(flowers)) return results"},{"question":"from typing import List, Tuple def second_largest_in_list(test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function takes a list of test cases, each containing a list of integers, and returns the second largest integer from each list. If there is no second largest integer, it returns -1 for that case. >>> second_largest_in_list([(5, [2, 3, 6, 6, 5])]) [5] >>> second_largest_in_list([(3, [1, 1, 1])]) [-1] >>> second_largest_in_list([(4, [7, 7, 8, 8])]) [7] >>> second_largest_in_list([ ... (5, [2, 3, 6, 6, 5]), ... (3, [1, 1, 1]), ... (4, [7, 7, 8, 8]) ... ]) [5, -1, 7] >>> second_largest_in_list([(4, [1, 2, 3, 4])]) [3] >>> second_largest_in_list([(3, [5, 5, 5])]) [-1] >>> second_largest_in_list([(2, [99, 100])]) [99] >>> second_largest_in_list([(5, [1000, 999, 998, 1000, 999])]) [999]","solution":"def second_largest_in_list(test_cases): This function takes a list of test cases, each containing a list of integers, and returns the second largest integer from each list. If there is no second largest integer, it returns -1 for that case. results = [] for case in test_cases: N, lst = case unique_elements = list(set(lst)) if len(unique_elements) < 2: results.append(-1) else: unique_elements.sort() results.append(unique_elements[-2]) return results"},{"question":"def longest_contiguous_A_segment(s: str) -> int: Returns the length of the longest contiguous segment of 'A's in the string. Args: s: A string containing only characters 'A' and 'B'. Returns: int: The length of the longest contiguous segment of 'A's. >>> longest_contiguous_A_segment(\\"AAABBA\\") 3 >>> longest_contiguous_A_segment(\\"BBAAABB\\") 3 >>> longest_contiguous_A_segment(\\"BBBAAAAB\\") 4","solution":"def longest_contiguous_A_segment(s): Returns the length of the longest contiguous segment of 'A's in the string. Args: s: A string containing only characters 'A' and 'B'. Returns: int: The length of the longest contiguous segment of 'A's. max_count = 0 current_count = 0 for char in s: if char == 'A': current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def get_prime_factors_sum(n: int) -> int: A company wants to reward its most efficient employees with a bonus. Efficiency is defined based on a metric \`W\`, which is the sum of all prime factors of an employee's unique identification number \`ID\`. Given the \`ID\`, determine the metric \`W\`. >>> get_prime_factors_sum(12) 7 >>> get_prime_factors_sum(29) 29 >>> get_prime_factors_sum(1) 0 >>> get_prime_factors_sum(10000000000037) 10000000000037 >>> get_prime_factors_sum(30) 10","solution":"def get_prime_factors_sum(n): Returns the sum of all prime factors of n. def prime_factors(n): factors = [] d = 2 while d * d <= n: while (n % d) == 0: factors.append(d) n //= d d += 1 if n > 1: factors.append(n) return factors factors = prime_factors(n) return sum(factors) # Example usage # print(get_prime_factors_sum(12)) # Outputs 7 # print(get_prime_factors_sum(29)) # Outputs 29"},{"question":"from typing import List, Tuple def minimum_gifts(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of gifts that need to be sent so that every region receives at least one gift. :param N: int - the number of regions :param M: int - the number of roads :param roads: List[Tuple[int, int]] - list of tuples representing roads between regions :return: int - the minimum number of gifts >>> minimum_gifts(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> minimum_gifts(3, 2, [(1, 2), (1, 3)]) 2 def test_minimum_gifts_example_1(): N = 4 M = 3 roads = [(1, 2), (2, 3), (3, 4)] assert minimum_gifts(N, M, roads) == 3 def test_minimum_gifts_example_2(): N = 3 M = 2 roads = [(1, 2), (1, 3)] assert minimum_gifts(N, M, roads) == 2 def test_minimum_gifts_single_region(): N = 1 M = 0 roads = [] assert minimum_gifts(N, M, roads) == 0 def test_minimum_gifts_two_regions_and_one_road(): N = 2 M = 1 roads = [(1, 2)] assert minimum_gifts(N, M, roads) == 1 def test_minimum_gifts_multiple_regions_and_minimum_roads(): N = 5 M = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 5)] assert minimum_gifts(N, M, roads) == 4 def test_minimum_gifts_complex_case(): N = 6 M = 7 roads = [(1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 6), (4, 6)] assert minimum_gifts(N, M, roads) == 5","solution":"def minimum_gifts(N, M, roads): This function returns the minimum number of gifts that need to be sent. :param N: int - the number of regions :param M: int - the number of roads :param roads: List[Tuple[int, int]] - list of tuples representing roads between regions :return: int - the minimum number of gifts # For a connected graph, the minimal spanning tree has exactly N-1 edges return N - 1"},{"question":"def maxTeamSkill(participants: List[Tuple[str, int]]) -> int: Given a list of participants and their respective roles, find the maximum total skill level of the teams that can be formed. If no valid team can be formed, return -1. >>> maxTeamSkill([('C', 5), ('P', 3), ('P', 8), ('C', 2), ('C', 6)]) == 14 >>> maxTeamSkill([('P', 4), ('P', 5), ('P', 1)]) == -1","solution":"def maxTeamSkill(participants): # Separate participants into coaches and players coaches = [skill for role, skill in participants if role == 'C'] players = [skill for role, skill in participants if role == 'P'] # If there are no coaches or no players, we can't form a team if not coaches or not players: return -1 # Get the max skill levels max_coach_skill = max(coaches) max_player_skill = max(players) # Return the maximum total skill level by forming one team with the best coach and the best player return max_coach_skill + max_player_skill"},{"question":"def longest_non_decreasing_subsequence_length(n: int, prices: List[int]) -> int: Returns the length of the longest contiguous subsequence where stock prices stayed equal or went up. Args: n : int : number of days prices : list : stock prices over several days Returns: int : the length of the longest contiguous subsequence where the stock prices stayed equal or went up >>> longest_non_decreasing_subsequence_length(6, [1, 2, 2, 2, 3, 1]) == 5 >>> longest_non_decreasing_subsequence_length(5, [5, 4, 3, 2, 1]) == 1 >>> longest_non_decreasing_subsequence_length(1, [100]) == 1 >>> longest_non_decreasing_subsequence_length(5, [4, 4, 4, 4, 4]) == 5 >>> longest_non_decreasing_subsequence_length(7, [1, 3, 5, 4, 6, 7, 8]) == 4 >>> longest_non_decreasing_subsequence_length(7, [5, 4, 3, 2, 1, 2, 3]) == 3 >>> longest_non_decreasing_subsequence_length(0, []) == 0","solution":"def longest_non_decreasing_subsequence_length(n, prices): Returns the length of the longest contiguous subsequence where stock prices stayed equal or went up. Args: n : int : number of days prices : list : stock prices over several days Returns: int : the length of the longest contiguous subsequence where the stock prices stayed equal or went up if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if prices[i] >= prices[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def calculate_completion_times(n: int, k: int, tasks: List[List[int]]) -> List[int]: Given the number of tasks and the number of subtasks per task, calculates the time each task will be completed assuming the robots can process subtasks in sequence as soon as previous one completes. Parameters: - n (int): number of tasks - k (int): number of subtasks per task - tasks (list of list of int): each inner list contains k integers representing the duration of subtasks in the task Returns: - list of int: completion times for each task >>> calculate_completion_times(3, 2, [[5, 3], [2, 4], [8, 1]]) [8, 6, 9] >>> calculate_completion_times(2, 3, [[1, 3, 5], [2, 2, 2]]) [9, 6] >>> calculate_completion_times(1, 1, [[10]]) [10] >>> calculate_completion_times(4, 3, [[3, 3, 3], [1, 1, 1], [5, 5, 5], [2, 2, 2]]) [9, 3, 15, 6] >>> calculate_completion_times(1, 5, [[1, 1, 1, 1, 1]]) [5]","solution":"def calculate_completion_times(n, k, tasks): Given the number of tasks and the number of subtasks per task, calculates the time each task will be completed assuming the robots can process subtasks in sequence as soon as previous one completes. Parameters: - n (int): number of tasks - k (int): number of subtasks per task - tasks (list of list of int): each inner list contains k integers representing the duration of subtasks in the task Returns: - list of int: completion times for each task completion_times = [] for task in tasks: completion_time = 0 for subtask in task: completion_time += subtask completion_times.append(completion_time) return completion_times # Example usage n = 3 k = 2 tasks = [ [5, 3], [2, 4], [8, 1] ] print(calculate_completion_times(n, k, tasks)) # Output: [8, 10, 9]"},{"question":"def digit_sum(n: int) -> List[int]: Take a positive integer n and return a list of sums of the digits of each number from 1 to n. >>> digit_sum(5) [1, 2, 3, 4, 5] >>> digit_sum(13) [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4]","solution":"def digit_sum(n): Returns a list where each element is the sum of the digits of the corresponding number from 1 to n. def sum_of_digits(num): return sum(int(digit) for digit in str(num)) return [sum_of_digits(i) for i in range(1, n+1)]"},{"question":"def largest_rectangle_from_skyline(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases to determine the largest rectangle area in each provided skyline. Parameters: t (int): The number of test cases. test_cases (list): List of tuples where each tuple contains: - n (int): Number of buildings. - heights (list): List of heights of the buildings. Returns: list: List of integers where each integer represents the maximum rectangular area for the respective test case. results = [] for n, heights in test_cases: results.append(largest_rectangle_area(heights)) return results def largest_rectangle_area(heights: List[int]) -> int: Given a list of heights representing a skyline, this function calculates the maximum rectangular area in the skyline. def test_example_cases(): assert largest_rectangle_from_skyline(3, [(6, [2, 1, 5, 6, 2, 3]), (7, [6, 2, 5, 4, 5, 1, 6]), (5, [2, 4, 2, 1, 10])]) == [10, 12, 10] def test_single_building(): assert largest_rectangle_from_skyline(2, [(1, [5]), (1, [10])]) == [5, 10] def test_equal_heights(): assert largest_rectangle_from_skyline(1, [(4, [4, 4, 4, 4])]) == [16] def test_decreasing_heights(): assert largest_rectangle_from_skyline(1, [(4, [4, 3, 2, 1])]) == [6] def test_increasing_heights(): assert largest_rectangle_from_skyline(1, [(5, [1, 2, 3, 4, 5])]) == [9] def test_alternating_heights(): assert largest_rectangle_from_skyline(1, [(6, [2, 1, 2, 1, 2, 1])]) == [6]","solution":"def largest_rectangle_area(heights): Given a list of heights representing a skyline, this function calculates the maximum rectangular area in the skyline. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' h = heights[top_of_stack] # Calculate the width w = index if not stack else index - stack[-1] - 1 # Update max_area, if needed max_area = max(max_area, h * w) # Now pop the remaining bars from stack and calculate area with each popped bar as the smallest bar while stack: top_of_stack = stack.pop() h = heights[top_of_stack] w = index if not stack else index - stack[-1] - 1 max_area = max(max_area, h * w) return max_area def largest_rectangle_from_skyline(t, test_cases): Processes multiple test cases to determine the largest rectangle area in each provided skyline. Parameters: t (int): The number of test cases. test_cases (list): List of tuples where each tuple contains: - n (int): Number of buildings. - heights (list): List of heights of the buildings. Returns: list: List of integers where each integer represents the maximum rectangular area for the respective test case. results = [] for n, heights in test_cases: results.append(largest_rectangle_area(heights)) return results"},{"question":"def is_prime(n: int) -> bool: Checks if a number n is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(11) == True >>> is_prime(15) == False >>> is_prime(29) == True def smallest_prime_greater_than(m: int) -> int: Returns the smallest prime number greater than m. >>> smallest_prime_greater_than(10) == 11 >>> smallest_prime_greater_than(29) == 31 >>> smallest_prime_greater_than(0) == 2 >>> smallest_prime_greater_than(1) == 2 >>> smallest_prime_greater_than(97) == 101","solution":"def is_prime(n): Checks if a number n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_than(m): Returns the smallest prime number greater than m. candidate = m + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def minimum_candies(N: int) -> int: Returns the minimum number of candies required to distribute among N students such that no two students receive the same number of candies. >>> minimum_candies(3) 6 >>> minimum_candies(1) 1 >>> minimum_candies(2) 3 >>> minimum_candies(4) 10 >>> minimum_candies(100000) 5000050000","solution":"def minimum_candies(N): Returns the minimum number of candies required to distribute among N students such that no two students receive the same number of candies. # Using the sum of the first N natural numbers formula: N * (N + 1) // 2 return N * (N + 1) // 2"},{"question":"def is_perfect_cube(n): Determine if the given integer n is a perfect cube. >>> is_perfect_cube(27) True >>> is_perfect_cube(45) False >>> is_perfect_cube(-64) True >>> is_perfect_cube(0) True >>> is_perfect_cube(1) True >>> def check_perfect_cubes(test_cases): For each integer in the list test_cases, determine if it is a perfect cube. Return a list of \\"YES\\" or \\"NO\\" for each test case. >>> check_perfect_cubes([27, 45, -64]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_perfect_cubes([0, 1, 8, 9, 1000]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>>","solution":"def is_perfect_cube(n): Determine if the given integer n is a perfect cube. if n < 0: n = -n return round(n ** (1/3)) ** 3 == n else: return round(n ** (1/3)) ** 3 == n def check_perfect_cubes(test_cases): results = [] for n in test_cases: if is_perfect_cube(n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_billboards(N: int, H: int, heights: List[int]) -> int: This function calculates the maximum number of billboards that can be placed on the buildings where each billboard is shorter than the building it's placed on by at least H units, and no two adjacent billboards can be on buildings of the same height. # Implementation goes here if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) H = int(data[1]) heights = list(map(int, data[2:])) result = max_billboards(N, H, heights) print(result)","solution":"def max_billboards(N, H, heights): This function calculates the maximum number of billboards that can be placed on the buildings where each billboard is shorter than the building it's placed on by at least H units, and no two adjacent billboards can be on buildings of the same height. max_billboards_count = 0 for i in range(len(heights)): # Check the adjacent buildings for the height condition if i == 0 or heights[i] != heights[i - 1]: max_billboards_count += 1 return max_billboards_count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) H = int(data[1]) heights = list(map(int, data[2:])) result = max_billboards(N, H, heights) print(result)"},{"question":"def remove_vowels(s: str) -> str: Removes all vowels from the input string s. Parameters: s (str): Input string containing only lower-case letters and spaces. Returns: str: A string with all vowels removed. >>> remove_vowels(\\"programming is fun\\") \\"prgrmmng s fn\\" >>> remove_vowels(\\"hello world\\") \\"hll wrld\\" >>> remove_vowels(\\"aeiou\\") \\"\\" >>> remove_vowels(\\"xyz\\") \\"xyz\\"","solution":"def remove_vowels(s): Removes all vowels from the input string s. Parameters: s (str): Input string containing only lower-case letters and spaces. Returns: str: A string with all vowels removed. vowels = \\"aeiou\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def modifyString(S: str, N: int) -> str: Modify the string S by moving the first character to the end of the string exactly N times. Parameters: S (str): The initial string. N (int): The number of operations to perform. Returns: str: The modified string after N operations. Example: >>> modifyString(\\"abcde\\", 3) \\"deabc\\" >>> modifyString(\\"hello\\", 2) \\"llohe\\"","solution":"def modifyString(S, N): Modify the string S by moving the first character to the end of the string exactly N times. Parameters: S (str): The initial string. N (int): The number of operations to perform. Returns: str: The modified string after N operations. length = len(S) # Since rotating the string length times results in the same string, # We can optimize by using N % length effective_rotations = N % length # Perform the rotation modified_string = S[effective_rotations:] + S[:effective_rotations] return modified_string"},{"question":"def second_smallest(nums): Returns the second smallest unique integer in the list, or -1 if there are less than two unique integers. >>> second_smallest([5, 3, 9, 1, 4, 3]) == 3 >>> second_smallest([1, 1, 1, 1]) == -1 >>> second_smallest([7, -2, 4, -2, 0, -1, 5]) == -1 >>> second_smallest([3, 2, 1]) == 2 >>> second_smallest([3]) == -1 >>> second_smallest([1, 1]) == -1 def parse_input(input_string): Parses the input string into a list of integers. >>> parse_input(\\"5 3 9 1 4 3\\") == [5, 3, 9, 1, 4, 3] >>> parse_input(\\"1 1 1 1\\") == [1, 1, 1, 1] >>> parse_input(\\"7 -2 4 -2 0 -1 5\\") == [7, -2, 4, -2, 0, -1, 5]","solution":"def second_smallest(nums): Returns the second smallest unique integer in the list, or -1 if there are less than two unique integers. unique_nums = list(set(nums)) if len(unique_nums) < 2: return -1 unique_nums.sort() return unique_nums[1] def parse_input(input_string): Parses the input string into a list of integers. return list(map(int, input_string.split()))"},{"question":"from collections import defaultdict from typing import List, Tuple def is_strongly_connected(n: int, m: int, streets: List[Tuple[int, int]]) -> str: Determine if it is possible to travel between any two intersections in a city grid with one-way streets. >>> is_strongly_connected(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4)]) \\"YES\\" >>> is_strongly_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"NO\\"","solution":"def is_strongly_connected(n, m, streets): from collections import defaultdict, deque def bfs(start, adj): visited = [False] * (n + 1) queue = deque([start]) while queue: node = queue.popleft() if not visited[node]: visited[node] = True for neighbor in adj[node]: if not visited[neighbor]: queue.append(neighbor) return visited # Build adjacency lists for the original graph and the transposed graph adj = defaultdict(list) radj = defaultdict(list) for u, v in streets: adj[u].append(v) radj[v].append(u) # Perform BFS from any node, here we choose node 1 visited_from_first = bfs(1, adj) # Check if we can reach all nodes from the first node if not all(visited_from_first[1:]): return \\"NO\\" # Perform BFS in the transposed graph from the same node visited_from_first_transposed = bfs(1, radj) # Check if all nodes can reach the first node if not all(visited_from_first_transposed[1:]): return \\"NO\\" return \\"YES\\""},{"question":"def longest_palindromic_substring(s: str) -> str: Determine the longest palindromic contiguous substring within the given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"abacdfgdcaba\\") in [\\"aba\\", \\"aca\\"] True >>> longest_palindromic_substring(\\"abcdcba\\") \\"abcdcba\\" >>> longest_palindromic_substring(\\"abcdefghi\\") \\"a\\" >>> longest_palindromic_substring(\\"bb\\") \\"bb\\" >>> longest_palindromic_substring(\\"\\") \\"\\" >>> longest_palindromic_substring(\\"a\\" * 1000) \\"a\\" * 1000 pass","solution":"def longest_palindromic_substring(s: str) -> str: n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Check for even length palindrome low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindrome low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string s, returns the length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"abacdg\\") 3","solution":"def longest_palindromic_subsequence(s): Given a string s, returns the length of the longest palindromic subsequence. n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"from typing import List, Tuple from math import comb def count_ways_to_get_k_heads(test_cases: List[Tuple[int, int]]) -> List[int]: Count the number of ways to arrange N coins such that exactly K of them are heads. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers (N, K). Returns: List[int]: A list of integers representing the number of ways to arrange the coins for each test case. Examples: >>> count_ways_to_get_k_heads([(5, 3), (4, 2), (6, 0)]) [10, 6, 1] >>> count_ways_to_get_k_heads([(1, 1), (2, 1), (3, 1), (3, 2)]) [1, 2, 3, 3] results = [] for N, K in test_cases: results.append(comb(N, K)) return results def parse_input(input_data: str) -> List[Tuple[int, int]]: Parse the input data into a list of test cases. Args: input_data (str): Input data as a multiline string. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers (N, K). Examples: >>> parse_input(\\"3n5 3n4 2n6 0\\") [(5, 3), (4, 2), (6, 0)] lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] for i in range(1, T + 1): N, K = map(int, lines[i].split()) test_cases.append((N, K)) return test_cases","solution":"from math import comb def count_ways_to_get_k_heads(test_cases): results = [] for N, K in test_cases: results.append(comb(N, K)) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] for i in range(1, T + 1): N, K = map(int, lines[i].split()) test_cases.append((N, K)) return test_cases"},{"question":"from typing import List class QuestionTagSystem: def __init__(self): Initialize the QuestionTagSystem to handle question-tag associations. # Implementation here def add_question(self, question_id: int, tags: List[str]) -> None: Add a question with the given ID and associated tags. Args: question_id (int): The unique ID of the question. tags (List[str]): The tags associated with the question. # Implementation here def query(self, tags: List[str]) -> List[int]: Retrieve all question IDs that contain all the given tags. Args: tags (List[str]): The list of tags to query for. Returns: List[int]: A sorted list of question IDs that have all the given tags, or [-1] if no such question exists. # Implementation here def process_operations(operations: List[str]) -> List[str]: Process a list of operations to add and query questions by tags. Args: operations (List[str]): A list of operations in the form of strings. Returns: List[str]: The results for each QUERY operation as strings. Examples: >>> operations = [ ... \\"ADD 1 2 math science\\", ... \\"ADD 2 3 math physics chemistry\\", ... \\"ADD 3 2 science chemistry\\", ... \\"QUERY 2 math science\\", ... \\"QUERY 1 chemistry\\" ... ] >>> process_operations(operations) ['1', '2 3'] # Implementation here # Unit tests def test_add_and_query(): operations = [ \\"ADD 1 2 math science\\", \\"ADD 2 3 math physics chemistry\\", \\"ADD 3 2 science chemistry\\", \\"QUERY 2 math science\\", \\"QUERY 1 chemistry\\" ] expected_outputs = [ \\"1\\", \\"2 3\\" ] results = process_operations(operations) assert results == expected_outputs def test_query_no_result(): operations = [ \\"ADD 1 2 math science\\", \\"ADD 2 3 math physics chemistry\\", \\"QUERY 1 biology\\" ] expected_outputs = [ \\"-1\\" ] results = process_operations(operations) assert results == expected_outputs def test_add_duplicate_tags(): operations = [ \\"ADD 1 3 math science math\\", \\"QUERY 2 math science\\" ] expected_outputs = [ \\"1\\" ] results = process_operations(operations) assert results == expected_outputs def test_query_multiple_tags(): operations = [ \\"ADD 1 2 math science\\", \\"ADD 2 3 science chemistry biology\\", \\"ADD 3 3 math chemistry biology\\", \\"QUERY 2 math chemistry\\", \\"QUERY 3 math chemistry biology\\" ] expected_outputs = [ \\"3\\", \\"3\\" ] results = process_operations(operations) assert results == expected_outputs def test_query_empty_result(): operations = [ \\"ADD 1 1 math\\", \\"ADD 2 1 science\\", \\"QUERY 1 physics\\" ] expected_outputs = [ \\"-1\\" ] results = process_operations(operations) assert results == expected_outputs","solution":"from collections import defaultdict class QuestionTagSystem: def __init__(self): self.tag_to_questions = defaultdict(set) def add_question(self, question_id, tags): for tag in tags: self.tag_to_questions[tag].add(question_id) def query(self, tags): if not tags: return [] # Get the intersection of question sets for all provided tags result_set = self.tag_to_questions[tags[0]] for tag in tags[1:]: result_set = result_set.intersection(self.tag_to_questions[tag]) # Convert to a sorted list sorted_result = sorted(result_set) return sorted_result if sorted_result else [-1] def process_operations(operations): system = QuestionTagSystem() results = [] for operation in operations: parts = operation.split() if parts[0] == 'ADD': question_id = int(parts[1]) tags = parts[3:] system.add_question(question_id, tags) elif parts[0] == 'QUERY': tags = parts[2:] result = system.query(tags) results.append(' '.join(map(str, result))) return results"},{"question":"def closest_subset_sum(n, T, card_values): Determine the subset (or one of the subsets) of cards whose total sum is closest to the target sum T. Args: n (int): The number of cards. T (int): The target sum. card_values (List[int]): A list of integers representing the values on the cards. Returns: tuple: A tuple containing the closest sum, the number of cards in the subset, and the subset of chosen cards. Example: >>> closest_subset_sum(5, 10, [2, 3, 7, 1, 5]) (10, 2, [3, 7]) >>> closest_subset_sum(4, 15, [8, 4, 5, 9]) (14, 2, [5, 9])","solution":"from itertools import combinations def closest_subset_sum(n, T, card_values): This function takes in the number of cards n, the target value T, and the list of card values, then returns the sum of the chosen subset of cards closest to T, the number of cards in that subset, and the card values. # Initialize the best result with an empty subset best_sum = 0 best_subset = [] # Check all possible subsets for r in range(1, n + 1): for subset in combinations(card_values, r): current_sum = sum(subset) if abs(current_sum - T) < abs(best_sum - T): best_sum = current_sum best_subset = subset elif abs(current_sum - T) == abs(best_sum - T) and current_sum > best_sum: best_sum = current_sum best_subset = subset # Destructure the result k = len(best_subset) return best_sum, k, list(best_subset)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determine if the tree is height-balanced. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> root.left.left.right = TreeNode(4) >>> isBalanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determine if the tree is height-balanced. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) height_difference = abs(left_height - right_height) <= 1 return current_height, left_balanced and right_balanced and height_difference _, is_balanced_tree = check_balance(root) return is_balanced_tree"},{"question":"def find_missing_number(arr): Given an array containing n-1 unique integers in the range 1 to n, returns the missing number in the range. >>> find_missing_number([1, 2, 4, 5, 6]) == 3 >>> find_missing_number([7, 2, 3, 6, 5, 1]) == 4 >>> find_missing_number([2]) == 1 >>> find_missing_number([1]) == 2 >>> find_missing_number([1, 2, 3, 4, 5]) == 6 >>> find_missing_number([1, 2, 3, 4, 5, 6, 8, 9, 10]) == 7","solution":"def find_missing_number(arr): Given an array containing n-1 unique integers in the range 1 to n, returns the missing number in the range. n = len(arr) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(arr) return total_sum - actual_sum"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. If there are multiple substrings with the same length, returns the first one. >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke'","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. If there are multiple substrings with the same length, returns the first one. char_index_map = {} start = 0 max_length = 0 max_substring = \\"\\" for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] return max_substring"},{"question":"def min_moves_in_minefield(N, M, grid): Determine the minimum number of moves required to navigate a character from the top-left corner to the bottom-right corner of a minefield grid represented by an N x M matrix where each cell can either be clear ('.') or contain a mine ('*'). If it is not possible, return -1. >>> min_moves_in_minefield(5, 5, [ ... \\".....\\", ... \\".*.*.\\", ... \\".*.*.\\", ... \\".*.*.\\", ... \\"...*.\\" ... ]) 8 >>> min_moves_in_minefield(3, 3, [ ... \\".*.\\", ... \\".*.\\", ... \\".*.\\" ... ]) -1 >>> min_moves_in_minefield(4, 4, [ ... \\"....\\", ... \\".***\\", ... \\"....\\", ... \\"....\\" ... ]) 6 Args: N (int): The number of rows in the grid. M (int): The number of columns in the grid. grid (List[str]): The grid with clear cells ('.') and mines ('*'). Returns: int: The minimum number of moves required or -1 if not possible.","solution":"from collections import deque def min_moves_in_minefield(N, M, grid): if grid[0][0] == '*' or grid[N-1][M-1] == '*': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if x == N-1 and y == M-1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def longest_palindrome_length(s: str) -> int: Given a string representing the letters in Alice's bag, determine the length of the longest possible palindrome she can form. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"aaabbb\\") 5","solution":"def longest_palindrome_length(s): from collections import Counter letter_counts = Counter(s) length = 0 odd_found = False for count in letter_counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"class Meeting: def __init__(self, start_time, end_time, day_of_week): self.start_time = start_time self.end_time = end_time self.day_of_week = day_of_week def has_conflict(meetings): Check if any two meetings in the list overlap. Two meetings overlap if they are scheduled for the same day and their time intervals intersect. >>> meeting1 = Meeting(\\"09:00\\", \\"10:00\\", \\"Monday\\") >>> meeting2 = Meeting(\\"09:30\\", \\"10:30\\", \\"Monday\\") >>> meeting3 = Meeting(\\"11:00\\", \\"12:00\\", \\"Monday\\") >>> meetings = [meeting1, meeting2, meeting3] >>> has_conflict(meetings) True >>> meeting1 = Meeting(\\"09:00\\", \\"10:00\\", \\"Monday\\") >>> meeting2 = Meeting(\\"10:00\\", \\"11:00\\", \\"Monday\\") >>> meeting3 = Meeting(\\"11:00\\", \\"12:00\\", \\"Monday\\") >>> meetings = [meeting1, meeting2, meeting3] >>> has_conflict(meetings) False pass","solution":"class Meeting: def __init__(self, start_time, end_time, day_of_week): self.start_time = start_time self.end_time = end_time self.day_of_week = day_of_week def has_conflict(meetings): Function to check if any two meetings in the list overlap. Returns True if there is a conflict, otherwise False. meetings_by_day = {} # Group meetings by day of week for meeting in meetings: if meeting.day_of_week not in meetings_by_day: meetings_by_day[meeting.day_of_week] = [] meetings_by_day[meeting.day_of_week].append(meeting) # Check for conflicts in each day's meetings for day in meetings_by_day: day_meetings = meetings_by_day[day] sorted_meetings = sorted(day_meetings, key=lambda m: m.start_time) for i in range(len(sorted_meetings) - 1): if sorted_meetings[i].end_time > sorted_meetings[i+1].start_time: return True return False"},{"question":"def validate_pin(N: int, pin: str) -> bool: Validates a security PIN based on specified criteria: 1. The PIN must be exactly N digits long. 2. The PIN can only contain numeric digits (0-9). 3. The PIN must contain at least one even digit. 4. The PIN must not contain any repeating digits. Arguments: N (int): The required length of the PIN. pin (str): The user-provided PIN. Returns: bool: True if the pin is valid, False otherwise. Examples: >>> validate_pin(4, \\"1234\\") True >>> validate_pin(4, \\"1123\\") False >>> validate_pin(5, \\"12345\\") True >>> validate_pin(6, \\"123456\\") False","solution":"def validate_pin(N, pin): Validates a security PIN based on specified criteria. Args: N (int): The required length of the PIN. pin (str): The user-provided PIN. Returns: bool: True if the pin is valid, False otherwise. if len(pin) != N: return False if not pin.isdigit(): return False if not any(int(digit) % 2 == 0 for digit in pin): return False if len(set(pin)) != len(pin): return False return True"},{"question":"def forest_paths(n: int, m: int): Determines if it's possible to maintain connectivity in the forest with given constraints. Parameters: n (int): number of trees m (int): maximum number of paths Returns: str and list of tuples: \\"Yes\\" followed by list of paths if possible, \\"No\\" otherwise Examples: >>> forest_paths(5, 10) 'Yes', [(1, 2), (2, 3), (3, 4), (4, 5)] >>> forest_paths(5, 4) 'Yes', [(1, 2), (2, 3), (3, 4), (4, 5)] >>> forest_paths(5, 3) 'No' pass","solution":"def forest_paths(n, m): Determines if it's possible to maintain connectivity in the forest with given constraints. Parameters: n (int): number of trees m (int): maximum number of paths Returns: str and list of tuples: \\"Yes\\" followed by list of paths if possible, \\"No\\" otherwise # Minimum number of paths to connect n nodes in a single connected component is n-1 if m >= n - 1: return [\\"Yes\\"] + [(i, i + 1) for i in range(1, n)] else: return [\\"No\\"] # Example usage: # print(forest_paths(5, 10)) # Example 1: Should return \\"Yes\\" followed by the paths # print(forest_paths(5, 4)) # Example 2: Should return \\"No\\""},{"question":"import math from typing import List def getPrimeNumbers(n: int) -> List[int]: Returns a list of all prime numbers up to and including n. >>> getPrimeNumbers(10) [2, 3, 5, 7] >>> getPrimeNumbers(20) [2, 3, 5, 7, 11, 13, 17, 19] primes = [] if n < 2: return primes","solution":"import math def getPrimeNumbers(n): Returns a list of all prime numbers up to and including n. primes = [] if n < 2: return primes # Create a boolean array \\"prime[0..n]\\" and initialize all entries it as true. prime = [True for _ in range(n+1)] p = 2 while p * p <= n: if prime[p] == True: for i in range(p * p, n + 1, p): prime[i] = False p += 1 for p in range(2, n + 1): if prime[p]: primes.append(p) return primes"},{"question":"def is_palindrome(s: str) -> str: Checks if the given 5-letter string s is a palindrome. >>> is_palindrome(\\"radar\\") == \\"Yes\\" >>> is_palindrome(\\"level\\") == \\"Yes\\" >>> is_palindrome(\\"hello\\") == \\"No\\" >>> is_palindrome(\\"world\\") == \\"No\\" >>> is_palindrome(\\"refer\\") == \\"Yes\\" >>> is_palindrome(\\"abcde\\") == \\"No\\"","solution":"def is_palindrome(s): Checks if the given 5-letter string s is a palindrome. Parameters: s (str): A 5-letter string. Returns: str: \\"Yes\\" if s is a palindrome, otherwise \\"No\\". if s == s[::-1]: return \\"Yes\\" else: return \\"No\\""},{"question":"def max_subarray_sum(n, arr): Returns the maximum subarray sum ignoring subarrays consisting only of negative numbers. Input: - A single integer n (1 ≤ n ≤ 10^5) - the number of elements in the sequence. - A sequence of n integers a1, a2, ..., an (-10^9 ≤ ai ≤ 10^9). Output: - A single integer representing the maximum subarray sum considering the rules mentioned above. Example: >>> max_subarray_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum(5, [-5, -3, -1, -7, -8]) 0","solution":"def max_subarray_sum(n, arr): Returns the maximum subarray sum ignoring subarrays consisting only of negative numbers. # Edge case: if all numbers are negative, return 0 if max(arr) < 0: return 0 # Apply Kadane's algorithm to find the maximum subarray sum max_ending_here = max_so_far = arr[0] for i in range(1, n): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def is_multiple_of_3_possible(n: int) -> str: Determines if it's possible to rearrange the digits of a non-negative integer n to form a multiple of 3. If it's possible, returns \\"YES\\" followed by the rearranged number that is a multiple of 3. Otherwise, returns \\"NO\\". >>> is_multiple_of_3_possible(123) 'YESn321' >>> is_multiple_of_3_possible(5) 'NO'","solution":"def is_multiple_of_3_possible(n): Determines if it's possible to rearrange digits of n to form a multiple of 3. Returns \\"YES\\" and the number if possible, otherwise \\"NO\\". # Convert the number to a string to easily manipulate digits digits = [int(d) for d in str(n)] # Check sum of digits for divisibility by 3 if sum(digits) % 3 != 0: return \\"NO\\" # Sort digits in descending order to form the largest possible number digits.sort(reverse=True) rearranged_number = int(''.join(map(str, digits))) return f\\"YESn{rearranged_number}\\""},{"question":"from typing import Tuple class SongDatabase: A class to manage a database of popular songs with functionality to add, delete, compute total duration, and find the longest song in the database. Methods: - add_song(song_id: int, title: str, duration: int) -> None - delete_song(song_id: int) -> None - total_duration() -> int - longest_song() -> Tuple[int, str, int] Example: >>> db = SongDatabase() >>> db.add_song(1, \\"Song One\\", 210) >>> db.add_song(2, \\"Song Two\\", 320) >>> db.add_song(3, \\"Song Three\\", 300) >>> db.total_duration() 830 >>> db.longest_song() (2, \\"Song Two\\", 320) >>> db.delete_song(2) >>> db.total_duration() 510 >>> db.longest_song() (3, \\"Song Three\\", 300) def __init__(self): pass def add_song(self, song_id: int, title: str, duration: int) -> None: pass def delete_song(self, song_id: int) -> None: pass def total_duration(self) -> int: pass def longest_song(self) -> Tuple[int, str, int]: pass # Unit Tests def test_add_song(): db = SongDatabase() db.add_song(1, \\"Song One\\", 210) assert db.songs[1] == (\\"Song One\\", 210) def test_delete_song(): db = SongDatabase() db.add_song(1, \\"Song One\\", 210) db.delete_song(1) assert 1 not in db.songs def test_total_duration(): db = SongDatabase() db.add_song(1, \\"Song One\\", 210) db.add_song(2, \\"Song Two\\", 320) db.add_song(3, \\"Song Three\\", 300) assert db.total_duration() == 830 def test_longest_song(): db = SongDatabase() db.add_song(1, \\"Song One\\", 210) db.add_song(2, \\"Song Two\\", 320) db.add_song(3, \\"Song Three\\", 300) assert db.longest_song() == (2, \\"Song Two\\", 320) def test_longest_song_after_deletion(): db = SongDatabase() db.add_song(1, \\"Song One\\", 210) db.add_song(2, \\"Song Two\\", 320) db.add_song(3, \\"Song Three\\", 300) db.delete_song(2) assert db.longest_song() == (3, \\"Song Three\\", 300) def test_no_songs_total_duration(): db = SongDatabase() assert db.total_duration() == 0 def test_no_songs_longest_song(): db = SongDatabase() assert db.longest_song() == ()","solution":"from typing import Tuple class SongDatabase: def __init__(self): self.songs = {} def add_song(self, song_id: int, title: str, duration: int) -> None: self.songs[song_id] = (title, duration) def delete_song(self, song_id: int) -> None: if song_id in self.songs: del self.songs[song_id] def total_duration(self) -> int: return sum(duration for title, duration in self.songs.values()) def longest_song(self) -> Tuple[int, str, int]: if not self.songs: return () longest = max(self.songs.items(), key=lambda item: item[1][1]) return (longest[0], longest[1][0], longest[1][1])"},{"question":"def count_vowels(text: str) -> int: Returns the number of vowels (a, e, i, o, u) in the given text. The count is case-insensitive and only considers alphabetic characters. >>> count_vowels(\\"Hello World\\") 3 >>> count_vowels(\\"AeIoU\\") 5 >>> count_vowels(\\"bcdfg\\") 0 >>> count_vowels(\\"aeiou\\") 5 >>> count_vowels(\\"AEIOU\\") 5 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"a\\") 1 >>> count_vowels(\\"E\\") 1 >>> count_vowels(\\"The quick brown fox jumps over the lazy dog.\\") 11","solution":"def count_vowels(text): Returns the number of vowels (a, e, i, o, u) in the given text. The count is case-insensitive. vowels = 'aeiou' text = text.lower() count = sum(1 for char in text if char in vowels) return count"},{"question":"def poly_integral(poly, C=0): Calculate the indefinite integral of a polynomial with a constant of integration. :param poly: List of coefficients of the polynomial in ascending order of power. :param C: Constant of integration. :return: List of coefficients of the integrated polynomial. >>> poly_integral([1, 2]) [0, 1.0, 1.0, 0] >>> poly_integral([9, 3, 6], 5) [0, 9.0, 1.5, 2.0, 5]","solution":"def poly_integral(poly, C=0): Calculate the indefinite integral of a polynomial with a constant of integration. :param poly: List of coefficients of the polynomial in ascending order of power. :param C: Constant of integration. :return: List of coefficients of the integrated polynomial. integrated_poly = [0] # Start with the coefficient of the indefinite integral for i in range(len(poly)): integrated_poly.append(poly[i] / (i + 1)) integrated_poly.append(C) # Add the constant of integration return integrated_poly"},{"question":"from typing import List class WordFrequency: def __init__(self): Initialize your data structure here. pass def add(self, word: str): Adds the word to the frequency count. pass def query(self, k: int) -> List[str]: Returns the top k most frequent words. pass def process_stream(queries: List[str]) -> List[str]: Processes a list of queries and returns the result for each \\"QUERY\\" instruction. queries: List of query strings pass","solution":"import heapq from collections import defaultdict class WordFrequency: def __init__(self): self.word_count = defaultdict(int) def add(self, word): Adds the word to the frequency count. word = word.lower() self.word_count[word] += 1 def query(self, k): Returns the top k most frequent words. sorted_words = sorted(self.word_count.items(), key=lambda x: (-x[1], x[0])) return [word for word, count in sorted_words[:k]] def process_stream(queries): Processes a list of queries and returns the result for each \\"QUERY\\" instruction. queries: List of query strings results = [] word_freq = WordFrequency() for query in queries: parts = query.split() if parts[0] == \\"ADD\\": word_freq.add(parts[1]) elif parts[0] == \\"QUERY\\": k = int(parts[1]) top_words = word_freq.query(k) results.extend(top_words) results.append(\\"\\") # To separate results for each query return results"},{"question":"def balanced_teams(N: int, skills: List[int]) -> int: Divide the players into two teams such that the absolute difference between the sums of the skill levels of the players in the two teams is minimized. >>> balanced_teams(4, [1, 2, 3, 4]) 0 >>> balanced_teams(6, [3, 1, 4, 2, 2, 1]) 1","solution":"def balanced_teams(N, skills): total_sum = sum(skills) target = total_sum // 2 dp = [0] * (target + 1) for skill in skills: for j in range(target, skill - 1, -1): dp[j] = max(dp[j], dp[j - skill] + skill) team1_sum = dp[target] team2_sum = total_sum - team1_sum return abs(team1_sum - team2_sum)"},{"question":"def vending_machine(purchase_attempts): Simulate a vending machine that dispenses snacks based on purchase attempts. Each purchase attempt consists of a snack type ('chips' or 'candy') and the number of 1-dollar coins inserted. Args: purchase_attempts (List[str]): A list of strings where each string is a purchase attempt. Returns: List[str]: A list of strings representing the result of each purchase attempt and the summary of total snacks dispensed and money collected. Example: attempts = [ \\"chips 3\\", \\"candy 2\\", \\"chips 1\\", \\"candy 3\\", \\"END\\" ] expected_output = [ \\"Dispensed 1 chips\\", \\"Insufficient coins: 2\\", \\"Insufficient coins: 1\\", \\"Dispensed 1 candy\\", \\"Total snacks dispensed: Chips: 1, Candy: 1\\", \\"Total money collected: 5\\" ] assert vending_machine(attempts) == expected_output","solution":"def vending_machine(purchase_attempts): chip_price = 2 candy_price = 3 chips_count = 0 candy_count = 0 total_money_collected = 0 result = [] for attempt in purchase_attempts: if attempt == \\"END\\": break snack, coins = attempt.split() coins = int(coins) if snack == \\"chips\\": if coins >= chip_price: chips_count += 1 total_money_collected += chip_price result.append(f\\"Dispensed 1 chips\\") else: result.append(f\\"Insufficient coins: {coins}\\") elif snack == \\"candy\\": if coins >= candy_price: candy_count += 1 total_money_collected += candy_price result.append(f\\"Dispensed 1 candy\\") else: result.append(f\\"Insufficient coins: {coins}\\") result.append(f\\"Total snacks dispensed: Chips: {chips_count}, Candy: {candy_count}\\") result.append(f\\"Total money collected: {total_money_collected}\\") return result"},{"question":"def min_rounds_to_solve_problems(problems): Returns the minimum number of rounds required to solve all problems in non-decreasing order of difficulty. :param problems: A list of integers representing the difficulty levels of the problems. :return: Minimum number of rounds to solve all problems. >>> min_rounds_to_solve_problems([1]) 1 >>> min_rounds_to_solve_problems([1, 2]) 1 >>> min_rounds_to_solve_problems([2, 1]) 2 >>> min_rounds_to_solve_problems([4, 2, 3, 1, 5, 6]) 3 >>> min_rounds_to_solve_problems([1, 2, 3, 4, 5]) 1 >>> min_rounds_to_solve_problems([5, 4, 3, 2, 1]) 5 >>> min_rounds_to_solve_problems([10, 1, 2, 20, 15, 25]) 3","solution":"def min_rounds_to_solve_problems(problems): Returns the minimum number of rounds required to solve all problems in non-decreasing order of difficulty. :param problems: A list of integers representing the difficulty levels of the problems. :return: Minimum number of rounds to solve all problems. if not problems: return 0 rounds = 1 for i in range(1, len(problems)): if problems[i] < problems[i - 1]: # This indicates the start of a new round rounds += 1 return rounds"},{"question":"def process_input(input_data: str) -> str: Parse the input data and determine the order in which Ghazu can read all the books. >>> process_input(\\"4nBook1 2 Book2 Book3nBook2 1 Book3nBook3 0nBook4 1 Book1\\") 'Book3 Book2 Book1 Book4' >>> process_input(\\"3nBook1 1 Book2nBook2 1 Book3nBook3 1 Book1\\") 'Not possible'","solution":"from collections import defaultdict, deque def find_reading_order(num_books, book_info): indegree = defaultdict(int) adjacency_list = defaultdict(list) books = set() for book_id, P, *prerequisites in book_info: books.add(book_id) indegree[book_id] += 0 # Initialize indegree for each book for prereq in prerequisites: books.add(prereq) indegree[book_id] += 1 adjacency_list[prereq].append(book_id) # Queue of courses with no prerequisites zero_indegree_queue = deque([book for book in books if indegree[book] == 0]) reading_order = [] while zero_indegree_queue: current_book = zero_indegree_queue.popleft() reading_order.append(current_book) for neighbor in adjacency_list[current_book]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(reading_order) == len(books): return \\" \\".join(reading_order) else: return \\"Not possible\\" def process_input(input_data): lines = input_data.strip().split(\\"n\\") B = int(lines[0]) book_info = [line.split() for line in lines[1:B+1]] book_info = [(info[0], int(info[1]), *info[2:]) for info in book_info] return find_reading_order(B, book_info)"},{"question":"def total_food(days: int, animalType: str) -> float: Returns the total amount of food consumed by an animal type over a number of days. Parameters: days (int): Number of days the animal has been in your care. animalType (str): Type of animal (\\"elephant\\", \\"lion\\", or \\"monkey\\"). Returns: float: Total amount of food consumed by the specified animal type over the given period. >>> total_food(3, \\"elephant\\") 150.0 >>> total_food(3, \\"lion\\") 13.5 >>> total_food(3, \\"monkey\\") 1.2 Raises: ValueError: If the animal type is not \\"elephant\\", \\"lion\\", or \\"monkey\\".","solution":"def total_food(days, animalType): Returns the total amount of food consumed by an animal type over a number of days. if animalType == \\"elephant\\": return days * 50 elif animalType == \\"lion\\": return 3 * days + 1.5 * (days * (days - 1)) / 2 elif animalType == \\"monkey\\": return 0.3 * days + 0.1 * (days * (days - 1)) / 2 else: raise ValueError(\\"Invalid animal type\\")"},{"question":"def count_distinct_substrings(n: int, p: int, s: str) -> int: Counts the number of distinct substrings in a given string s modulo p. Parameters: n (int): Length of the string s. p (int): The prime modulus. s (str): The input string. Returns: int: Number of distinct substrings modulo p. >>> count_distinct_substrings(4, 1000000007, \\"abcd\\") 10 >>> count_distinct_substrings(5, 1000000007, \\"aaaaa\\") 5","solution":"def count_distinct_substrings(n, p, s): Counts the number of distinct substrings in a given string s modulo p. Parameters: n (int): Length of the string s. p (int): The prime modulus. s (str): The input string. Returns: int: Number of distinct substrings modulo p. substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) % p # Example of how to call the function # print(count_distinct_substrings(4, 1000000007, \\"abcd\\")) # Expected output: 10 # print(count_distinct_substrings(5, 1000000007, \\"aaaaa\\")) # Expected output: 5"},{"question":"def logicalOperation(A, B, C, D): Simulates the 4-input logical gate operation described. (A AND B) OR (C XOR D) AND (NOT A OR B) >>> logicalOperation(0, 1, 1, 0) 1 >>> logicalOperation(1, 0, 1, 1) 0 >>> logicalOperation(1, 1, 0, 1) 1 >>> logicalOperation(0, 0, 1, 1) 0 >>> logicalOperation(1, 1, 1, 0) 1 >>> logicalOperation(0, 0, 0, 0) 0 >>> logicalOperation(1, 1, 1, 1) 1 >>> logicalOperation(0, 1, 0, 1) 1","solution":"def logicalOperation(A, B, C, D): Simulates the 4-input logical gate operation described. (A AND B) OR (C XOR D) AND (NOT A OR B) return (A and B) or ((C ^ D) and (not A or B))"},{"question":"def can_sort_heroes(n: int, strengths: List[int]) -> str: Determines if the heroes can be sorted in ascending order using the allowed moves. :param n: int, number of heroes :param strengths: list of int, strengths of heroes :return: str, \\"YES\\" if the heroes can be sorted else \\"NO\\" >>> can_sort_heroes(4, [1, 3, 2, 4]) 'YES' >>> can_sort_heroes(3, [3, 1, 2]) 'NO'","solution":"def can_sort_heroes(n, strengths): Determines if the heroes can be sorted in ascending order using the allowed moves. :param n: int, number of heroes :param strengths: list of int, strengths of heroes :return: str, \\"YES\\" if the heroes can be sorted else \\"NO\\" # A sequential increasing index means a character can never move left more than initial position # and also can never move right more than final position. Hence, indexes would not overlap when sorted. if sorted(strengths) == strengths: return \\"YES\\" inv_count = 0 for i in range(n): for j in range(i + 1, n): if strengths[i] > strengths[j]: inv_count += 1 return \\"YES\\" if inv_count == 1 else \\"NO\\""},{"question":"def is_right_angled_triangle(nums): Determine if there are any three numbers in the list that can form the sides of a right-angled triangle. Parameters: nums (list of int): The list of positive integers. Returns: bool: True if there exist three numbers that can form a right-angled triangle, False otherwise. >>> is_right_angled_triangle([3, 4, 5, 6]) True >>> is_right_angled_triangle([1, 2, 3, 4]) False >>> is_right_angled_triangle([5, 12, 13, 7, 24, 25]) True","solution":"def is_right_angled_triangle(nums): Determine if there are any three numbers in the list that can form the sides of a right-angled triangle. Parameters: nums (list of int): The list of positive integers. Returns: bool: True if there exist three numbers that can form a right-angled triangle, False otherwise. nums = sorted(nums) n = len(nums) # Use the sorted property to check combinations for i in range(n-1, 1, -1): c = nums[i] a = 0 b = i-1 while a < b: if nums[a]**2 + nums[b]**2 == c**2: return True elif nums[a]**2 + nums[b]**2 < c**2: a += 1 else: b -= 1 return False"},{"question":"from typing import List def uniqueSubsets(nums: List[int]) -> List[List[int]]: Returns all unique subsets of the provided list of numbers, including duplicates. >>> uniqueSubsets([1, 2, 2]) [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> uniqueSubsets([0]) [[], [0]]","solution":"from typing import List def uniqueSubsets(nums: List[int]) -> List[List[int]]: Returns all unique subsets of the provided list of numbers, including duplicates. nums.sort() # Sort the array to handle duplicates results = [] def backtrack(start, path): results.append(path[:]) for i in range(start, len(nums)): # If the current element is the same as the previous and we are at the starting point of the subset, skip it if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return results"},{"question":"def count_vowels(s: str) -> int: Returns the count of vowels (a, e, i, o, u) present in the input string s. The function is case-insensitive and does not use any loop structures including but not limited to for, while, or do-while loops. >>> count_vowels(\\"Hello World\\") 3 >>> count_vowels(\\"A quick brown fox jumps over the lazy dog\\") 11 >>> count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") 0 >>> count_vowels(\\"12345,./;'[]=-!@#%\\") 0 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"aaaaaeeeeiiiiioooooouuuuu\\") 25 >>> count_vowels(\\"AEIOUaeiou\\") 10","solution":"def count_vowels(s): Returns the count of vowels (a, e, i, o, u) present in the input string s. vowels = \\"aeiouAEIOU\\" return sum(s.count(vowel) for vowel in vowels)"},{"question":"def rotateMatrix(matrix: List[List[int]]) -> List[List[int]]: Given a matrix with dimensions NxN, rotate the matrix 90 degrees clockwise. >>> rotateMatrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([ [5, 1], [2, 9] ]) [[2, 5], [9, 1]] pass import pytest def test_rotateMatrix_example1(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotateMatrix(matrix) == expected def test_rotateMatrix_example2(): matrix = [ [5, 1], [2, 9] ] expected = [ [2, 5], [9, 1] ] assert rotateMatrix(matrix) == expected def test_rotateMatrix_single_element(): matrix = [ [1] ] expected = [ [1] ] assert rotateMatrix(matrix) == expected def test_rotateMatrix_four_by_four(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotateMatrix(matrix) == expected def test_rotateMatrix_empty(): matrix = [] expected = [] assert rotateMatrix(matrix) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def rotateMatrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. N = len(matrix) # Step 1: Transpose the matrix for i in range(N): for j in range(i+1, N): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(N): matrix[i].reverse() return matrix"},{"question":"def validate_id_number(N: int, id_number: str) -> str: Validates the identification number based on the given criteria: 1. The number should not start with the digit '0'. 2. The identification number should contain at least one even digit. >>> validate_id_number(5, \\"12345\\") 'VALID' >>> validate_id_number(4, \\"5671\\") 'INVALID' >>> validate_id_number(6, \\"009876\\") 'INVALID'","solution":"def validate_id_number(N, id_number): Validates the identification number based on the given criteria: 1. The number should not start with the digit '0'. 2. The identification number should contain at least one even digit. Args: N : int : Length of the identification number id_number : string : Identification number Returns: string : \\"VALID\\" if the number meets all criteria else \\"INVALID\\" if id_number[0] == '0': return \\"INVALID\\" if any(digit in '02468' for digit in id_number): return \\"VALID\\" return \\"INVALID\\""},{"question":"def unique_characters_count(S: str) -> int: Returns the number of unique characters in the string S. >>> unique_characters_count(\\"hello\\") 4 >>> unique_characters_count(\\"abcdef\\") 6 >>> unique_characters_count(\\"aaaaaa\\") 1 >>> unique_characters_count(\\"abcabcabc\\") 3 >>> unique_characters_count(\\"a\\") 1 >>> unique_characters_count(\\"\\") 0","solution":"def unique_characters_count(S): Returns the number of unique characters in the string S. return len(set(S))"},{"question":"from collections import Counter, defaultdict def min_window(s1: str, s2: str) -> str: Find the smallest window in the string s1 which contains all the characters of the string s2. If no such window exists, return an empty string. If there are multiple such windows, return the first occurring one. Examples: >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window(\\"a\\", \\"a\\") \\"a\\" >>> min_window(\\"a\\", \\"aa\\") \\"\\"","solution":"from collections import Counter, defaultdict def min_window(s1: str, s2: str) -> str: if not s1 or not s2 or len(s2) > len(s1): return \\"\\" s2_count = Counter(s2) window_count = defaultdict(int) have, need = 0, len(s2_count) res, res_len = [-1, -1], float(\\"infinity\\") left = 0 for right in range(len(s1)): character = s1[right] window_count[character] += 1 if character in s2_count and window_count[character] == s2_count[character]: have += 1 while have == need: if (right - left + 1) < res_len: res = [left, right] res_len = (right - left + 1) window_count[s1[left]] -= 1 if s1[left] in s2_count and window_count[s1[left]] < s2_count[s1[left]]: have -= 1 left += 1 l, r = res return s1[l:r+1] if res_len != float(\\"infinity\\") else \\"\\""},{"question":"def ball_splitting_winner(n: int) -> str: Determines the winner of the ball splitting game if both play optimally. Alice starts the game. Parameters: n (int): the initial number of balls Returns: str: \\"Alice\\" if Alice has a winning strategy, \\"Bob\\" otherwise Examples: >>> ball_splitting_winner(4) 'Bob' >>> ball_splitting_winner(7) 'Alice' >>> ball_splitting_winner(30) 'Alice'","solution":"def ball_splitting_winner(n): Determines the winner of the ball splitting game if both play optimally. Alice starts the game. Parameters: n (int): the initial number of balls Returns: str: \\"Alice\\" if Alice has a winning strategy, \\"Bob\\" otherwise if n % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"from typing import List, Tuple def can_plant_trees_no_cycles(N: int, M: int, relationships: List[Tuple[int, int]]) -> str: Determine if it is possible to plant trees following the given rules without any cycles. >>> can_plant_trees_no_cycles(3, 2, [(0, 1), (1, 2)]) \\"YES\\" >>> can_plant_trees_no_cycles(3, 3, [(0, 1), (1, 2), (2, 0)]) \\"NO\\" >>> can_plant_trees_no_cycles(4, 2, [(2, 3), (1, 3)]) \\"YES\\"","solution":"def can_plant_trees_no_cycles(N, M, relationships): from collections import defaultdict, deque # Create adjacency list for the graph adjacency_list = defaultdict(list) indegree = [0] * N for a, b in relationships: adjacency_list[a].append(b) indegree[b] += 1 # Topological sort using Kahn's algorithm queue = deque([i for i in range(N) if indegree[i] == 0]) visited_count = 0 while queue: node = queue.popleft() visited_count += 1 for neighbor in adjacency_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If visited count equals N, then no cycle detected return \\"YES\\" if visited_count == N else \\"NO\\""},{"question":"def min_operations_to_avoid_consecutive_chars(T: int, strings: List[str]) -> List[int]: Determine the minimum number of operations required to transform the given string into a string containing no consecutive identical characters. An operation is defined as changing a single character in the string to any other character. Args: T : int : Number of test cases strings : List[str] : A list of strings without spaces, composed of lowercase English letters Returns: List[int] : A list of integers representing the minimum number of operations required for each string Examples: >>> min_operations_to_avoid_consecutive_chars(3, [\\"aab\\", \\"abba\\", \\"abcde\\"]) [1, 1, 0] >>> min_operations_to_avoid_consecutive_chars(1, [\\"aaaa\\"]) [3] >>> min_operations_to_avoid_consecutive_chars(1, [\\"abcd\\"]) [0]","solution":"def min_operations_to_avoid_consecutive_chars(T, strings): results = [] for s in strings: count = 0 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 results.append(count) return results"},{"question":"def largest_rectangle_area(hist): Computes the largest rectangular area in a histogram. Parameters: hist (list of int): A list of non-negative integers representing the heights of histogram bars. Returns: int: The area of the largest rectangle that can be formed in the histogram. Examples: >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([5, 5, 5, 5, 5]) 25 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10, 3]) 18","solution":"def largest_rectangle_area(hist): Computes the largest rectangular area in a histogram. Parameters: hist (list of int): A list of non-negative integers representing the heights of histogram bars. Returns: int: The area of the largest rectangle that can be formed in the histogram. stack = [] max_area = 0 index = 0 while index < len(hist): if not stack or hist[index] >= hist[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() current_area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) while stack: top_of_stack = stack.pop() current_area = (hist[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, current_area) return max_area"},{"question":"def minimum_containers(gem_weights, container_capacities): Returns the minimum number of containers required to store all gemstones. If it's not possible, returns -1. >>> minimum_containers([4, 8, 1], [5, 5, 10]) 2 >>> minimum_containers([4, 8, 1], [2, 2, 2]) -1 >>> minimum_containers([1, 1, 1, 1], [10]) 1 def parse_input(input_string): Parses an input string into gemstone weights and container capacities. >>> parse_input(\\"3 3n4 8 1n5 5 10\\") ([4, 8, 1], [5, 5, 10]) from solution import minimum_containers, parse_input def test_minimum_containers_possible(): gem_weights = [4, 8, 1] container_capacities = [5, 5, 10] assert minimum_containers(gem_weights, container_capacities) == 2 def test_minimum_containers_impossible(): gem_weights = [4, 8, 1] container_capacities = [2, 2, 2] assert minimum_containers(gem_weights, container_capacities) == -1 def test_all_gems_fit_in_one_container(): gem_weights = [1, 1, 1, 1] container_capacities = [10] assert minimum_containers(gem_weights, container_capacities) == 1 def test_input_parsing(): input_string = \\"3 3n4 8 1n5 5 10\\" gem_weights, container_capacities = parse_input(input_string) assert gem_weights == [4, 8, 1] assert container_capacities == [5, 5, 10] def test_example_from_question(): input_string = \\"3 3n4 8 1n5 5 10\\" gem_weights, container_capacities = parse_input(input_string) assert minimum_containers(gem_weights, container_capacities) == 2","solution":"def minimum_containers(gem_weights, container_capacities): Returns the minimum number of containers required to store all gemstones. If it's not possible, returns -1. gem_weights.sort(reverse=True) # Sort gemstones from heaviest to lightest container_capacities.sort(reverse=True) # Sort containers from largest to smallest used_containers = 0 used_capacity = [0] * len(container_capacities) for gem in gem_weights: for i in range(len(container_capacities)): if used_capacity[i] + gem <= container_capacities[i]: used_capacity[i] += gem break else: return -1 return len([c for c in used_capacity if c > 0]) def parse_input(input_string): lines = input_string.strip().split('n') _, _ = map(int, lines[0].split()) gem_weights = list(map(int, lines[1].split())) container_capacities = list(map(int, lines[2].split())) return gem_weights, container_capacities"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aaaaa\\") == 1 >>> length_of_longest_substring(\\"aA1bB2cC\\") == 8 >>> length_of_longest_substring(\\"abcdabcde\\") == 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all distinct characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_zigzag_subsequence(arr: List[int]) -> int: Find the length of the longest Zigzag subsequence for a given array. >>> longest_zigzag_subsequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subsequence([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_subsequence([1, 2, 3]) 2","solution":"def longest_zigzag_subsequence(arr): n = len(arr) if n < 2: return n inc = 1 dec = 1 for i in range(1, n): if arr[i] > arr[i - 1]: inc = dec + 1 elif arr[i] < arr[i - 1]: dec = inc + 1 return max(inc, dec)"},{"question":"def max_area_with_fixed_perimeter(perimeter): Given a perimeter, returns the maximum possible area of a rectangular flower bed. >>> max_area_with_fixed_perimeter(20) 25 >>> max_area_with_fixed_perimeter(30) 56 def solve_max_areas(T, perimeters): Solves for the maximum possible areas for multiple given perimeters. >>> solve_max_areas(2, [20, 30]) [25, 56]","solution":"def max_area_with_fixed_perimeter(perimeter): Given a perimeter, returns the maximum possible area of a rectangular flower bed. # The optimal shape for maximizing the area is a square # For a given perimeter P, the sides of the optimal rectangle are P/4 side_length = perimeter / 4 # Calculating the maximum area using side_length * side_length max_area = int(side_length * side_length) return max_area def solve_max_areas(T, perimeters): results = [] for perimeter in perimeters: results.append(max_area_with_fixed_perimeter(perimeter)) return results"},{"question":"def findSubstring(s: str, words: List[str]) -> List[int]: Write a function that takes a string \`s\` and a list of words \`words\`, and returns the starting indices of all substrings in \`s\` that are a concatenation of each word in \`words\` exactly once and without any intervening characters. The words consist of lowercase English letters. Each word in \`words\` has the same length. >>> findSubstring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> findSubstring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) [] >>> findSubstring(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) [6, 9, 12]","solution":"from collections import Counter def findSubstring(s, words): Finds the starting indices of all substrings in \`s\` that are a concatenation of each word in \`words\` exactly once and without any intervening characters. if not s or not words or not words[0]: return [] word_len = len(words[0]) word_count = len(words) substring_len = word_len * word_count total_len = len(s) if total_len < substring_len: return [] word_map = Counter(words) result_indices = [] for i in range(word_len): left, right = i, i tmp_map = Counter() while right + word_len <= total_len: word = s[right:right + word_len] right += word_len if word in word_map: tmp_map[word] += 1 while tmp_map[word] > word_map[word]: tmp_map[s[left:left + word_len]] -= 1 left += word_len if right - left == substring_len: result_indices.append(left) else: tmp_map.clear() left = right return result_indices"},{"question":"def is_prime(n: int) -> bool: Determine if the given number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(5) == True >>> is_prime(1) == False def can_split_to_alternating_prime_seq(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the sequence can be split into two subsequences which are Alternating Prime Sequences for each test case. >>> can_split_to_alternating_prime_seq(2, [(6, [3, 2, 5, 11, 7, 13]), (4, [4, 6, 8, 10])]) == [\\"YES\\", \\"NO\\"] >>> can_split_to_alternating_prime_seq(1, [(5, [2, 3, 5, 7, 11])]) == [\\"YES\\"]","solution":"def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def can_split_to_alternating_prime_seq(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] # Filter prime numbers from the sequence primes = [x for x in sequence if is_prime(x)] # If less than 2 primes, it can't form any alternating sequence if len(primes) < 2: results.append(\\"NO\\") continue # Check if we can split primes into two alternating sequences odd_count = sum(1 for x in primes if x % 2 != 0) even_count = len(primes) - odd_count # At minimum, each subsequence should have atleast 1 even and 1 odd prime to make alternating sequence if odd_count >= 1 and even_count >= 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid. If no such path exists, returns -1. The grid contains values 0 (unblocked) and 1 (blocked). >>> shortest_path([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) 9 >>> shortest_path([ [0, 1, 1], [1, 1, 0], [1, 0, 0] ]) -1 >>> shortest_path([[0]]) 1 >>> shortest_path([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) -1 >>> shortest_path([ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) -1 >>> shortest_path([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 5 >>> shortest_path([[0] * 100 for _ in range(100)]) 199 # Your code here","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a grid. If no such path exists, returns -1. n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def canFormPalindrome(s: str) -> str: Determine if the given string can be rearranged to form a palindrome. Parameters: s (str): the input string Returns: str: \\"Possible Palindrome\\" if the string can be rearranged to form a palindrome, otherwise \\"Not Possible Palindrome\\" # Your code here # Unit test cases def test_case_1(): assert canFormPalindrome('civic') == \\"Possible Palindrome\\" def test_case_2(): assert canFormPalindrome('ivicc') == \\"Possible Palindrome\\" def test_case_3(): assert canFormPalindrome('hello') == \\"Not Possible Palindrome\\" def test_case_4(): assert canFormPalindrome('aaabbbb') == \\"Possible Palindrome\\" def test_case_5(): assert canFormPalindrome('abc') == \\"Not Possible Palindrome\\" def test_case_6(): assert canFormPalindrome('a') == \\"Possible Palindrome\\" def test_case_7(): assert canFormPalindrome('aa') == \\"Possible Palindrome\\" def test_case_8(): assert canFormPalindrome('aaa') == \\"Possible Palindrome\\" def test_case_9(): assert canFormPalindrome('ab') == \\"Not Possible Palindrome\\" def test_case_10(): assert canFormPalindrome('aba') == \\"Possible Palindrome\\"","solution":"from collections import Counter def canFormPalindrome(s): Determine if the given string can be rearranged to form a palindrome. Parameters: s (str): the input string Returns: str: \\"Possible Palindrome\\" if the string can be rearranged to form a palindrome, otherwise \\"Not Possible Palindrome\\" # Create a counter for each character in the string char_count = Counter(s) # Count characters with an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one # character with an odd number of occurrences if odd_count <= 1: return \\"Possible Palindrome\\" else: return \\"Not Possible Palindrome\\""},{"question":"def collect_leaves(arr: List[int]) -> List[int]: You are given a binary tree represented as a list of integers, where each element corresponds to a node value in a level-order traversal. Null values indicating the absence of children are represented by \`None\`. Write a function named \`collect_leaves\` that takes the binary tree as input and returns a list of the values of all the leaf nodes, ordered from left to right. A leaf node is one that has no children. >>> collect_leaves([1]) [1] >>> collect_leaves([1, 2, 3, None, 5, None, 4]) [5, 4]","solution":"def collect_leaves(arr): if not arr: return [] from collections import deque result = [] nodes = deque([(0, arr[0])]) while nodes: i, value = nodes.popleft() if value is None: continue left_index = 2 * i + 1 right_index = 2 * i + 2 has_left = left_index < len(arr) and arr[left_index] is not None has_right = right_index < len(arr) and arr[right_index] is not None if not has_left and not has_right: result.append(value) if has_left: nodes.append((left_index, arr[left_index])) if has_right: nodes.append((right_index, arr[right_index])) return result"},{"question":"def find_median(nums: List[int]) -> int: Returns the median value of a list of numbers. >>> find_median([1, 2, 3, 4, 5]) == 3 >>> find_median([11, 23, 3, 42, 15]) == 15 >>> find_median([7, 8, 9]) == 8 >>> find_median([-5, -1, -10, -3, -7]) == -5 >>> find_median([-10, 0, 10]) == 0 >>> find_median([42]) == 42","solution":"def find_median(nums): Returns the median value of the list of numbers. # Ensure the list is not modified by making a copy sorted_nums = sorted(nums) n = len(sorted_nums) return sorted_nums[n // 2]"},{"question":"def twoSum(arr: List[int], target: int) -> List[int]: Given an array of integers and a target integer, determine the indices of the two unique numbers in the array that add up to the target. Assume exactly one solution exists, and you may not use the same element twice. Parameters: arr (List[int]): List of integers. target (int): The target sum. Returns: List[int]: List containing indices of the two numbers that add up to the target. Examples: >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([1, 5, 3, 7], 8) [1, 2]","solution":"def twoSum(arr, target): Returns the indices of the two unique numbers in the array that add up to the target. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def fill_garden_grid(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Fill the empty cells in the garden grid such that each number from 1 to n*m appears at most once per row and column, while respecting the pre-filled flowers (-1). Args: n : int : number of rows m : int : number of columns grid : list of list of int : the garden grid with -1 representing flowers and 0 representing empty cells Returns: list of list of int : the filled garden grid pass # Example Test Cases # Feel free to write your own tests assert fill_garden_grid(3, 3, [[0, -1, 0], [-1, 0, -1], [0, -1, 0]]) == [[1, -1, 2], [-1, 3, -1], [2, -1, 1]] assert fill_garden_grid(2, 2, [[0, 0], [-1, 0]]) == [[1, 2], [-1, 1]]","solution":"def fill_garden_grid(n, m, grid): Fill the empty cells in the garden grid such that each number from 1 to n*m appears at most once per row and column, while respecting the pre-filled flowers (-1). Args: n : int : number of rows m : int : number of columns grid : list of list of int : the garden grid with -1 representing flowers and 0 representing empty cells Returns: list of list of int : the filled garden grid from itertools import product def is_valid(grid, row, col, num): for i in range(n): if grid[i][col] == num: return False for j in range(m): if grid[row][j] == num: return False return True # List of all possible numbers to fill in the grid numbers = list(range(1, n * m + 1)) used = set() # Get positions of all empty cells (0s) empty_positions = [(i, j) for i, j in product(range(n), range(m)) if grid[i][j] == 0] def backtrack(idx): if idx == len(empty_positions): return True row, col = empty_positions[idx] for number in numbers: if number not in used and is_valid(grid, row, col, number): grid[row][col] = number used.add(number) if backtrack(idx + 1): return True # Reset the cell and the used number grid[row][col] = 0 used.remove(number) return False backtrack(0) return grid"},{"question":"import random import string def generate_password(L): Generates a random password of length L. Password must include at least one uppercase letter, one lowercase letter, one digit, and one special character. If the length L is outside the range [8, 16], it returns \\"Invalid length\\". >>> import re >>> pattern = re.compile(r\\"(?=.*[a-z])(?=.*[A-Z])(?=.*d)(?=.*[!@#%^&*()-_=+[]{}|;:,.<>?/]).{8,16}\\") >>> password = generate_password(12) >>> bool(pattern.match(password)) True >>> generate_password(5) 'Invalid length' >>> generate_password(17) 'Invalid length'","solution":"import random import string def generate_password(L): Generates a random password of length L. Password must include at least one uppercase letter, one lowercase letter, one digit, and one special character. if L < 8 or L > 16: return \\"Invalid length\\" special_characters = \\"!@#%^&*()-_=+[]{}|;:,.<>?/\\" # Ensure password meets conditions password = [ random.choice(string.ascii_lowercase), random.choice(string.ascii_uppercase), random.choice(string.digits), random.choice(special_characters) ] # Fill the rest of the password length with random choices from all allowed characters all_characters = string.ascii_letters + string.digits + special_characters password.extend(random.choices(all_characters, k=L-4)) # Shuffle the list to avoid any predictable ordering random.shuffle(password) return ''.join(password)"},{"question":"def rearrange_in_place(arr): Rearranges the array in-place such that every i-th position contains the i-th smallest element of arr. Args: arr (list): The list of integers to be rearranged. Returns: None: The function modifies the list in-place. Examples: >>> arr = [3, 5, 2, 1, 6] >>> rearrange_in_place(arr) >>> arr [1, 2, 3, 5, 6] >>> arr = [10, 7, 9, 3, 2] >>> rearrange_in_place(arr) >>> arr [2, 3, 7, 9, 10]","solution":"def rearrange_in_place(arr): Rearranges the array in-place such that every i-th position contains the i-th smallest element of arr. Args: arr (list): The list of integers to be rearranged. Returns: None: The function modifies the list in-place. arr.sort()"},{"question":"def max_valid_teams(n: int, strengths: List[int]) -> int: Returns the maximum number of valid teams that can be formed from the given strengths of participants. A team is valid if and only if: - Each team consists of exactly three participants. - The strengths of the participants in each team have the property that the sum of any two strengths is greater than the strength of the remaining participant. >>> max_valid_teams(7, [10, 20, 30, 40, 50, 60, 70]) 2 >>> max_valid_teams(5, [1, 2, 3, 4, 5]) 1 # Implementation goes here from solution import max_valid_teams def test_single_team_possible(): assert max_valid_teams(7, [10, 20, 30, 40, 50, 60, 70]) == 2 def test_no_team_possible(): assert max_valid_teams(5, [1, 2, 3, 4, 5]) == 1 def test_all_strengths_same(): assert max_valid_teams(6, [3, 3, 3, 3, 3, 3]) == 2 def test_large_numbers(): assert max_valid_teams(4, [10**9, 10**9, 10**9 - 1, 10**9 - 2]) == 1 def test_insufficient_participants(): assert max_valid_teams(2, [1, 2]) == 0 assert max_valid_teams(1, [5]) == 0 def test_additional_participants(): assert max_valid_teams(8, [10, 20, 30, 40, 50, 60, 70, 80]) == 2 def test_large_input_size_with_teams_possible(): participants = [i for i in range(1, 501)] assert max_valid_teams(500, participants) == 166","solution":"def max_valid_teams(n, strengths): Returns the maximum number of valid teams that can be formed from the given strengths of participants. if n < 3: return 0 strengths.sort() teams = 0 i = n - 1 # Start from the strongest participant and move downwards while i >= 2: # Check for a valid team (a, b, c) where a <= b <= c if strengths[i] < strengths[i-1] + strengths[i-2]: teams += 1 i -= 3 # Move back by three, as these three participants form a team else: i -= 1 # Move back by one, as the current strongest does not form a valid team return teams"},{"question":"def minimum_delivery_cost(n: int, m: int, s: int, t: int, C: List[int], roads: List[Tuple[int, int]]) -> int: Returns the minimum delivery cost from house s to house t. Parameters: n: int - number of houses (2 ≤ n ≤ 1000) m: int - number of roads (1 ≤ m ≤ 5000) s: int - starting house index (1 ≤ s ≤ n) t: int - ending house index (1 ≤ t ≤ n) C: List[int] - cost of delivery to each house (1 ≤ C[i] ≤ 1000) roads: List[Tuple[int, int]] - list of roads represented as tuples of houses Returns: int - minimum delivery cost >>> minimum_delivery_cost(4, 4, 1, 4, [2, 3, 5, 1], [(1, 2), (2, 3), (3, 4), (1, 4)]) 3 >>> minimum_delivery_cost(2, 1, 1, 2, [1, 1], [(1, 2)]) 2","solution":"import heapq def minimum_delivery_cost(n, m, s, t, C, roads): Returns the minimum delivery cost from house s to house t. Parameters: n: int - number of houses m: int - number of roads s: int - starting house index (1-based) t: int - ending house index (1-based) C: List[int] - cost of delivery to each house roads: List[Tuple[int, int]] - list of roads represented as tuples of houses Returns: int - minimum delivery cost # Adjust indices to be 0-based for easier indexing s -= 1 t -= 1 C = [0] + C # Transform the list of roads into an adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v in roads: graph[u].append(v) graph[v].append(u) # Dijkstra's algorithm using priority queue pq = [(C[s + 1], s + 1)] # (cost to reach this node, node index) costs = {i: float('inf') for i in range(1, n + 1)} costs[s + 1] = C[s + 1] visited = set() while pq: current_cost, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for neighbor in graph[u]: new_cost = current_cost + C[neighbor] if new_cost < costs[neighbor]: costs[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return costs[t + 1]"},{"question":"def numSquares(n: int) -> int: Returns the minimum number of perfect square numbers which sum to n. >>> numSquares(12) 3 >>> numSquares(13) 2","solution":"def numSquares(n): Returns the minimum number of perfect square numbers which sum to n. if n < 2: return n squares = [] i = 1 while i * i <= n: squares.append(i * i) i += 1 toCheck = {n} level = 0 while toCheck: level += 1 nextCheck = set() for x in toCheck: for y in squares: if x == y: return level if x < y: break nextCheck.add(x - y) toCheck = nextCheck return level"},{"question":"def accessible_floors(N, K) -> List[int]: Returns a sorted list of all unique floors that can be accessed by at least one key. Parameters: N (int): Number of keys. K (int): The multiple range for each key's access. Returns: List[int]: List of unique accessible floors. >>> accessible_floors(5, 3) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] >>> accessible_floors(1, 1) [1] >>> accessible_floors(1, 5) [1, 2, 3, 4, 5] >>> accessible_floors(2, 2) [1, 2, 3, 4] >>> accessible_floors(10, 10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100] pass","solution":"def accessible_floors(N, K): Returns a sorted list of all unique floors that can be accessed by at least one key. Parameters: N (int): Number of keys. K (int): The multiple range for each key's access. Returns: List[int]: List of unique accessible floors. floors = set() for i in range(1, N + 1): for j in range(i, i * K + 1): floors.add(j) return sorted(floors)"},{"question":"def run_length_encode(input_string: str) -> str: Encodes the input_string using Run-Length Encoding (RLE). Parameters: input_string (str): The string to be encoded Returns: str: The RLE encoded string >>> run_length_encode('aaabbcaa') 'a3b2c1a2' >>> run_length_encode('') '' >>> run_length_encode('a') 'a1' >>> run_length_encode('abc') 'a1b1c1' >>> run_length_encode('aaabbaaaccc') 'a3b2a3c3' >>> run_length_encode('aabbaa') 'a2b2a2' >>> run_length_encode('a') 'a1' >>> run_length_encode('aaaaaa') 'a6' >>> run_length_encode('aabbccaabbcc') 'a2b2c2a2b2c2'","solution":"def run_length_encode(input_string): Encodes the input_string using Run-Length Encoding (RLE). Parameters: input_string (str): The string to be encoded Returns: str: The RLE encoded string if not input_string: return \\"\\" encoded_string = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_string.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 encoded_string.append(f\\"{previous_char}{count}\\") return ''.join(encoded_string)"},{"question":"def matrix_spiral_sum(matrix: List[List[int]]) -> int: Write a function \`matrix_spiral_sum\` that takes an \`n x n\` integer matrix as input and returns the sum of its elements when traversed in a spiral order, starting from the top-left corner and moving clockwise. >>> matrix_spiral_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> matrix_spiral_sum([ ... [5] ... ]) == 5 >>> matrix_spiral_sum([ ... [1, 2], ... [3, 4] ... ]) == 10 >>> matrix_spiral_sum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 136 >>> matrix_spiral_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -45 >>> matrix_spiral_sum([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) == 325","solution":"def matrix_spiral_sum(matrix): if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) startRow, endRow = 0, rows - 1 startCol, endCol = 0, cols - 1 spiral_sum = 0 while startRow <= endRow and startCol <= endCol: # Traverse right for col in range(startCol, endCol + 1): spiral_sum += matrix[startRow][col] startRow += 1 # Traverse down for row in range(startRow, endRow + 1): spiral_sum += matrix[row][endCol] endCol -= 1 if startRow <= endRow: # Traverse left for col in range(endCol, startCol - 1, -1): spiral_sum += matrix[endRow][col] endRow -= 1 if startCol <= endCol: # Traverse up for row in range(endRow, startRow - 1, -1): spiral_sum += matrix[row][startCol] startCol += 1 return spiral_sum"},{"question":"def smallest_missing_positive(nums): Returns the smallest positive integer that is not present in the nums list. pass def process_test_cases(t, test_cases): Processes the test cases and returns the results. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains the number of elements and the list of elements :return: List of results for each test case pass def test_smallest_missing_positive(): assert smallest_missing_positive([1, 2, 0]) == 3 assert smallest_missing_positive([3, 4, -1, 1]) == 2 assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert smallest_missing_positive([1, 2, 3, 4, 5]) == 6 def test_process_test_cases(): test_cases = [ (3, [1, 2, 0]), (4, [3, 4, -1, 1]) ] results = process_test_cases(2, test_cases) assert results == [3, 2] test_cases = [ (5, [7, 8, 9, 11, 12]), (5, [1, 2, 3, 4, 5]) ] results = process_test_cases(2, test_cases) assert results == [1, 6]","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer that is not present in the nums list. n = len(nums) # Place each number in its right place if possible for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first index which doesn't have the correct number for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1 def process_test_cases(t, test_cases): results = [] for i in range(t): n, nums = test_cases[i] result = smallest_missing_positive(nums) results.append(result) return results"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\" \\") 1 >>> longest_unique_substring(\\"dvdf\\") 3","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_index = {} longest = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def count_unique_pairs(nums, k): Find the number of unique pairs (i, j) where 0 <= i < j < nums.length such that nums[i] + nums[j] == k. >>> count_unique_pairs([1, 2, 3, 4], 5) 2 >>> count_unique_pairs([3, 1, 4, 1, 5], 6) 1 >>> count_unique_pairs([-1, 1, 0], 0) 1 pass def process_test_cases(t, test_cases): Process multiple test cases for counting unique pairs. >>> process_test_cases(3, [ ... [(4, 5), [1, 2, 3, 4]], ... [(5, 6), [3, 1, 4, 1, 5]], ... [(3, 0), [-1, 1, 0]]]) [2, 1, 1] pass","solution":"def count_unique_pairs(nums, k): seen = set() pairs = set() for num in nums: target = k - num if target in seen: pairs.add((min(num, target), max(num, target))) seen.add(num) return len(pairs) def process_test_cases(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] nums = test_cases[i][1] result = count_unique_pairs(nums, k) results.append(result) return results # Example usage: # t = 3 # test_cases = [ # [(4, 5), [1, 2, 3, 4]], # [(5, 6), [3, 1, 4, 1, 5]], # [(3, 0), [-1, 1, 0]] # ] # print(process_test_cases(t, test_cases)) # Output: [2, 1, 1]"},{"question":"def minOperations(S: str) -> int: Determines the least number of operations required to make all characters in the string S unique. >>> minOperations(\\"abca\\") == 1 True >>> minOperations(\\"aaa\\") == 2 True >>> minOperations(\\"abcd\\") == 0 True >>> minOperations(\\"\\") == 0 True >>> minOperations(\\"aabbcc\\") == 3 True >>> minOperations(\\"abcdefghijklmnopqrstuvwxyz\\") == 0 True >>> minOperations(\\"a\\"*100000) == 99999 True","solution":"def minOperations(S): Determines the least number of operations required to make all characters in the string S unique. if len(S) == 0: # If string is empty, no operations are needed. return 0 char_count = {} duplicates_count = 0 for char in S: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in char_count: if char_count[char] > 1: duplicates_count += char_count[char] - 1 return duplicates_count"},{"question":"import math def count_unique_playlists(playlist: str) -> int: Returns the number of unique playlists that can be created using all the songs in the given playlist exactly once. >>> count_unique_playlists(\\"a\\") == 1 >>> count_unique_playlists(\\"ab\\") == 2 >>> count_unique_playlists(\\"abc\\") == 6 >>> count_unique_playlists(\\"abcd\\") == 24 >>> count_unique_playlists(\\"abcde\\") == 120","solution":"import math def count_unique_playlists(playlist): Returns the number of unique playlists that can be created using all the songs in the given playlist exactly once. n = len(playlist) return math.factorial(n)"},{"question":"def min_edges_to_connect_all_nodes(n: int, m: int, edges: List[Tuple[int, int]]) -> int: You are given a forest graph with \`n\` nodes and \`m\` edges. A forest is an undirected graph with no cycles. Your task is to determine the minimum number of edges required to convert the forest into a single connected tree. In other words, you need to connect all the nodes into one connected component ensuring there is exactly one path between any two nodes. Args: n : int : Number of nodes m : int : Number of edges edges : List[Tuple[int, int]] : List of edges represented by node pairs Returns: int : The minimum number of edges required to connect all nodes into a single tree. Examples: >>> min_edges_to_connect_all_nodes(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> min_edges_to_connect_all_nodes(5, 0, []) 4 >>> min_edges_to_connect_all_nodes(4, 3, [(1, 2), (2, 3), (3, 4)]) 0","solution":"def find_connected_components(n, edges): Find the number of connected components in the forest graph. from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i) components += 1 return components def min_edges_to_connect_all_nodes(n, m, edges): Calculate the minimum number of edges required to connect all nodes in the graph. if n == 1: return 0 components = find_connected_components(n, edges) return components - 1"},{"question":"from typing import List def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make the string s a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"radar\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"abcd\\") 3 >>> min_insertions_to_palindrome(\\"aabb\\") 2 >>> min_insertions_to_palindrome(\\"lngsrt\\") 5","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions needed to make the string s a palindrome. n = len(s) # Create a DP table to store the results of subproblems dp = [[0 for x in range(n)] for y in range(n)] # Fill DP table # The gap represents the gap between the starting and ending indices for gap in range(1, n): for l in range(n - gap): r = l + gap if s[l] == s[r]: dp[l][r] = dp[l + 1][r - 1] else: dp[l][r] = min(dp[l][r - 1], dp[l + 1][r]) + 1 return dp[0][n - 1]"},{"question":"def find_digit_product_number(P: int) -> int: Finds the smallest possible Digit Product Number such that the product of its digits is equal to P. If no such number exists, returns -1. >>> find_digit_product_number(36) 49 >>> find_digit_product_number(10) 25 >>> find_digit_product_number(1) 1 >>> find_digit_product_number(100) 455 >>> find_digit_product_number(29) -1","solution":"def find_digit_product_number(P): Finds the smallest possible Digit Product Number such that the product of its digits is equal to P. If no such number exists, returns -1. if P == 1: return 1 if P < 10: return P factors = [] for digit in range(9, 1, -1): while P % digit == 0: factors.append(digit) P //= digit if P > 1: return -1 factors.sort() digit_product_number = int(''.join(map(str, factors))) return digit_product_number"},{"question":"def reorder_string(s: str) -> str: Reorders the string so that all letters appear before the digits, while maintaining the relative order of both letters and digits from the original string. >>> reorder_string(\\"a1b2c3d4\\") == \\"abcd1234\\" >>> reorder_string(\\"A2B3C4\\") == \\"ABC234\\" >>> reorder_string(\\"abcdef\\") == \\"abcdef\\" >>> reorder_string(\\"ABCDEF\\") == \\"ABCDEF\\" >>> reorder_string(\\"12345\\") == \\"12345\\" >>> reorder_string(\\"67890\\") == \\"67890\\" >>> reorder_string(\\"\\") == \\"\\" >>> reorder_string(\\"a1B2c3D4\\") == \\"aBcD1234\\" >>> reorder_string(\\"z9Y8X7\\") == \\"zYX987\\"","solution":"def reorder_string(s): Reorders the string so that all letters appear before the digits, while maintaining the relative order of both letters and digits from the original string. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def compare_coin_collections(test_cases): Compare the number of coins Adam and Ben have for each test case and determine who has more. Parameters: test_cases (list of tuples): Each tuple contains two integers (A, B), where A is the number of coins Adam has and B is the number of coins Ben has. Returns: list: A list of strings, each either \\"Adam\\" or \\"Ben\\" indicating who has more coins for each test case.","solution":"def compare_coin_collections(test_cases): Compare the number of coins Adam and Ben have for each test case and determine who has more. Parameters: test_cases (list of tuples): Each tuple contains two integers (A, B), where A is the number of coins Adam has and B is the number of coins Ben has. Returns: list: A list of strings, each either \\"Adam\\" or \\"Ben\\" indicating who has more coins for each test case. results = [] for A, B in test_cases: if A > B: results.append(\\"Adam\\") else: results.append(\\"Ben\\") return results"},{"question":"def max_satisfied_employees(n, seating, desires): Determine the maximum number of employees who can have at least one desired neighbor after one swap of seats. Parameters: n (int): The number of employees. seating (List[int]): The current seating arrangement. desires (List[List[int]]): A list where the ith element contains the desired neighbors for the ith employee. Returns: int: The maximum number of employees who can have at least one desired neighbor after one swap of seats. Example: >>> n = 4 >>> seating = [0, 2, 3, 1] >>> desires = [ ... [1, 3], ... [0], ... [1, 2], ... [0] ... ] >>> max_satisfied_employees(n, seating, desires) 3 pass # Implement your solution here # Sample test cases def test_example(): n = 4 seating = [0, 2, 3, 1] desires = [ [1, 3], [0], [1, 2], [0] ] assert max_satisfied_employees(n, seating, desires) == 3 def test_no_desires(): n = 3 seating = [0, 1, 2] desires = [ [], [], [] ] assert max_satisfied_employees(n, seating, desires) == 0 def test_all_satisfied_initially(): n = 3 seating = [0, 1, 2] desires = [ [1], [0, 2], [1] ] assert max_satisfied_employees(n, seating, desires) == 3 def test_increasing_neighbors(): n = 4 seating = [0, 1, 2, 3] desires = [ [1], [0, 2], [1, 3], [2] ] assert max_satisfied_employees(n, seating, desires) == 4","solution":"def max_satisfied_employees(n, seating, desires): Returns the maximum number of employees who can have at least one desired neighbor after one swap of seats. def has_desired_neighbor(employee, seating): pos = seating.index(employee) if pos > 0 and seating[pos - 1] in desires[employee]: return True if pos < n - 1 and seating[pos + 1] in desires[employee]: return True return False # Count initial satisfied employees initial_satisfied = 0 for i in range(n): if has_desired_neighbor(i, seating): initial_satisfied += 1 max_satisfied = initial_satisfied # Try each possible swap for i in range(n): for j in range(i + 1, n): # Swap employees i and j seating[i], seating[j] = seating[j], seating[i] satisfied_after_swap = 0 for k in range(n): if has_desired_neighbor(k, seating): satisfied_after_swap += 1 max_satisfied = max(max_satisfied, satisfied_after_swap) # Swap back seating[i], seating[j] = seating[j], seating[i] return max_satisfied"},{"question":"def first_missing_positive(nums: List[int]) -> int: Finds the first missing positive integer in an unsorted array. The function should have a time complexity of O(n) and utilize constant extra space. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([-1, -2, -3]) 1 from solution import first_missing_positive def test_first_missing_positive_case1(): assert first_missing_positive([3, 4, -1, 1]) == 2 def test_first_missing_positive_case2(): assert first_missing_positive([1, 2, 0]) == 3 def test_first_missing_positive_all_negatives(): assert first_missing_positive([-1, -2, -3]) == 1 def test_first_missing_positive_all_positive_continuous(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 def test_first_missing_positive_all_positive_non_continuous(): assert first_missing_positive([1, 3, 5, 7, 9]) == 2 def test_first_missing_positive_large_array(): assert first_missing_positive(list(range(1, 100000)) + [-1]) == 100000","solution":"def first_missing_positive(nums): Finds the first missing positive integer in an unsorted list of integers. n = len(nums) # Shift numbers to their corresponding indices for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first number that is not at the correct index for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. >>> set(letter_combinations(\\"23\\")) == set([\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"]) >>> letter_combinations(\\"\\") == [] >>> set(letter_combinations(\\"2\\")) == set([\\"a\\",\\"b\\",\\"c\\"]) :param digits: A string containing the digits between 2 to 9. :return: A list of strings representing all possible letter combinations. pass","solution":"def letter_combinations(digits): if not digits: return [] digit_to_letters = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return letters = digit_to_letters[digits[index]] for letter in letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def min_moves_to_meet(N, positions): Returns the minimum number of moves needed for all cats to gather at a single feeding station. :param N: int - number of cats and feeding stations :param positions: List of tuples, each containing (xi, yi, fi) :return: int - minimum number of moves >>> min_moves_to_meet(3, [(1, 1, 2), (1, 3, 3), (3, 3, 1)]) 4 >>> min_moves_to_meet(2, [(2, 2, 5), (3, 3, 5)]) 2","solution":"def min_moves_to_meet(N, positions): Returns the minimum number of moves needed for all cats to gather at a single feeding station. :param N: int - number of cats and feeding stations :param positions: List of tuples, each containing (xi, yi, fi) :return: int - minimum number of moves # Extract the (x, y) positions since the food amount \\"fi\\" is not relevant for movement coordinates = [(pos[0], pos[1]) for pos in positions] # Sorting the x and y coordinates to find the median positions coordinates.sort() x_sorted = sorted(coord[0] for coord in coordinates) y_sorted = sorted(coord[1] for coord in coordinates) # The optimal meeting point will be at the median coordinates to minimize the total distance median_x = x_sorted[N // 2] median_y = y_sorted[N // 2] # Calculate the sum of Manhattan distances to the meeting point (median_x, median_y) total_moves = sum(abs(x - median_x) + abs(y - median_y) for x, y in coordinates) return total_moves # Example usage, will not run during pytest if __name__ == \\"__main__\\": N = 3 positions = [(1, 1, 2), (1, 3, 3), (3, 3, 1)] print(min_moves_to_meet(N, positions)) # Expected output: 4"},{"question":"def minimum_cost_to_connect_houses(n: int, pipes: List[List[int]]) -> int: Write a function that finds the minimum cost to provide water to all houses. If it is impossible to connect all houses, return -1. >>> minimum_cost_to_connect_houses(4, [[1, 2, 1], [2, 3, 4], [3, 4, 2], [1, 4, 3]]) 6 >>> minimum_cost_to_connect_houses(3, [[1, 2, 5]]) -1 >>> minimum_cost_to_connect_houses(2, [[1, 2, 1]]) 1 >>> minimum_cost_to_connect_houses(3, [[1, 2, 1], [2, 3, 1], [1, 3, 2]]) 2 >>> minimum_cost_to_connect_houses(5, [[1, 2, 2], [2, 3, 3], [1, 3, 6], [4, 5, 5]]) -1","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_connect_houses(n, pipes): # Sorting edges based on cost pipes.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 edges_used = 0 for pipe in pipes: house1, house2, cost = pipe house1 -= 1 house2 -= 1 if find(parent, house1) != find(parent, house2): union(parent, rank, house1, house2) mst_cost += cost edges_used += 1 if edges_used == n - 1: return mst_cost return -1"},{"question":"def is_special_lending_id(lending_id: str) -> bool: Returns True if lending_id is a palindrome and its length is even, else returns False. Examples: >>> is_special_lending_id(\\"123321\\") True >>> is_special_lending_id(\\"12321\\") False >>> is_special_lending_id(\\"124421\\") True >>> is_special_lending_id(\\"123456\\") False >>> is_special_lending_id(\\"1233321\\") False","solution":"def is_special_lending_id(lending_id): Returns True if lending_id is a palindrome and its length is even, else returns False. # Check if the ID is a palindrome if lending_id != lending_id[::-1]: return False # Check if the length of the ID is even if len(lending_id) % 2 != 0: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): Constructs a binary tree from preorder and inorder traversal lists. Args: preorder (List[int]): The preorder traversal of the tree. inorder (List[int]): The inorder traversal of the tree. Returns: TreeNode: The root node of the constructed binary tree. Example: >>> preorder = [3, 9, 20, 15, 7, 8, 12] >>> inorder = [9, 3, 15, 20, 8, 12, 7] >>> root = buildTree(preorder, inorder) >>> isinstance(root, TreeNode) True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder, inorder): if not preorder or not inorder: return None root_val = preorder.pop(0) root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.left = buildTree(preorder, inorder[:inorder_index]) root.right = buildTree(preorder, inorder[inorder_index + 1:]) return root"},{"question":"def lexicographically_smallest_array(arr): This function returns the lexicographically smallest array obtainable by reversing any subarray any number of times. >>> lexicographically_smallest_array([3, 1, 4, 1, 5]) [1, 1, 3, 4, 5] >>> lexicographically_smallest_array([9, 8, 7, 6]) [6, 7, 8, 9]","solution":"def lexicographically_smallest_array(arr): This function returns the lexicographically smallest array obtainable by reversing any subarray any number of times. # The smallest lexicographical array is the sorted version of the array return sorted(arr) # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) result = lexicographically_smallest_array(arr) print(\\" \\".join(map(str, result)))"},{"question":"def element_appearing_more_than_n_div_3_times(N, arr): Determines if there is any element that appears strictly more than N/3 times in the array. :param N: Integer, the length of the array :param arr: List of integers, the array elements :return: The element that appears more than N/3 times or 'No' >>> element_appearing_more_than_n_div_3_times(6, [1, 2, 3, 1, 1, 1]) 1 >>> element_appearing_more_than_n_div_3_times(5, [1, 2, 3, 4, 5]) \\"No\\"","solution":"def element_appearing_more_than_n_div_3_times(N, arr): Determines if there is any element that appears strictly more than N/3 times in the array. :param N: Integer, the length of the array :param arr: List of integers, the array elements :return: The element that appears more than N/3 times or 'No' from collections import Counter # Calculate the threshold threshold = N / 3 # Count the frequency of each element in the array counter = Counter(arr) # Check each element frequency against the threshold for elem, count in counter.items(): if count > threshold: return elem return \\"No\\""},{"question":"def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int: Determine the length of the longest substring that contains at most k distinct characters. Args: s (str): a string consisting of lowercase alphabets. k (int): the maximum number of distinct characters. Returns: int: the length of the longest substring with at most k distinct characters. Example: >>> lengthOfLongestSubstringKDistinct(\\"eceba\\", 2) 3 >>> lengthOfLongestSubstringKDistinct(\\"aaaaaaa\\", 1) 7","solution":"def lengthOfLongestSubstringKDistinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. if k == 0: return 0 char_map = {} left = 0 max_len = 0 for right in range(len(s)): if s[right] in char_map: char_map[s[right]] += 1 else: char_map[s[right]] = 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def convert_to_12hr_format(hour: int, minute: int) -> str: Converts time from 24-hour format to 12-hour format with AM/PM. Arguments: hour -- an integer (0 ≤ hour < 24) representing the hour minute -- an integer (0 ≤ minute < 60) representing the minutes Returns: A string representing the given time in 12-hour format followed by AM or PM. >>> convert_to_12hr_format(13, 30) '01:30 PM' >>> convert_to_12hr_format(0, 15) '12:15 AM' >>> convert_to_12hr_format(23, 45) '11:45 PM' >>> convert_to_12hr_format(12, 0) '12:00 PM'","solution":"def convert_to_12hr_format(hour: int, minute: int) -> str: Converts time from 24-hour format to 12-hour format with AM/PM. Arguments: hour -- an integer (0 ≤ hour < 24) representing the hour minute -- an integer (0 ≤ minute < 60) representing the minutes Returns: A string representing the given time in 12-hour format followed by AM or PM. period = \\"AM\\" if hour < 12 else \\"PM\\" hour_12 = hour % 12 hour_12 = 12 if hour_12 == 0 else hour_12 return f\\"{hour_12:02}:{minute:02} {period}\\""},{"question":"def festive_spirit(n: int) -> int: Calculate the 'Festive Spirit' of the given number n. A positive integer n is transformed to its 'Festive Spirit' by summing its digits repeatedly until a single-digit number is obtained. >>> festive_spirit(9875) 2 >>> festive_spirit(12345) 6 pass def test_festive_spirit_single_digit(): assert festive_spirit(5) == 5 assert festive_spirit(9) == 9 def test_festive_spirit_multiple_digits(): assert festive_spirit(10) == 1 assert festive_spirit(9875) == 2 assert festive_spirit(12345) == 6 assert festive_spirit(999999) == 9 def test_festive_spirit_large_number(): assert festive_spirit(1000000000000000000) == 1 assert festive_spirit(999999999999999999) == 9","solution":"def festive_spirit(n): Calculates the 'Festive Spirit' of the given number n. Args: n (int): A positive integer. Returns: int: The single-digit 'Festive Spirit' of n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def fold_array(arr): Folds the array by adding corresponding elements from both ends towards the center until one element is left. >>> fold_array([1, 2, 3, 4, 5]) 15 >>> fold_array([-1, -2, -3, -4]) -10 pass def process_test_cases(T, test_cases): Processes multiple test cases, returning the result after folding the array for each case. For each test case, the result is the remaining element after continuously folding the array. >>> T = 2 >>> test_cases = [(5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4])] >>> process_test_cases(T, test_cases) [15, -10] pass","solution":"def fold_array(arr): Folds the array by adding corresponding elements from both ends towards the center until one element is left. while len(arr) > 1: new_arr = [] for i in range((len(arr) + 1) // 2): if i == len(arr) - i - 1: # Handle middle element in an odd-length array new_arr.append(arr[i]) else: new_arr.append(arr[i] + arr[-i-1]) arr = new_arr return arr[0] def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] results.append(fold_array(arr)) return results"},{"question":"def toy_final_state(n: int, instructions: List[str]) -> int: Determine the final state of the toy after executing all instructions. >>> toy_final_state(5, [\\"ADD 5\\", \\"MUL 3\\", \\"SUB 2\\", \\"ADD 10\\", \\"MUL -1\\"]) -23 >>> toy_final_state(1, [\\"ADD 10\\"]) 10 >>> toy_final_state(1, [\\"SUB 10\\"]) -10 >>> toy_final_state(1, [\\"MUL 10\\"]) 0 >>> toy_final_state(4, [\\"ADD 5\\", \\"SUB 3\\", \\"MUL 4\\", \\"ADD 2\\"]) 10 >>> toy_final_state(3, [\\"ADD 100000\\", \\"SUB 100000\\", \\"MUL 100000\\"]) 0 >>> toy_final_state(3, [\\"ADD -10\\", \\"MUL -2\\", \\"SUB -5\\"]) 25","solution":"def toy_final_state(n, instructions): state = 0 for instruction in instructions: cmd, x = instruction.split() x = int(x) if cmd == \\"ADD\\": state += x elif cmd == \\"SUB\\": state -= x elif cmd == \\"MUL\\": state *= x return state # Example usage: n = 5 instructions = [\\"ADD 5\\", \\"MUL 3\\", \\"SUB 2\\", \\"ADD 10\\", \\"MUL -1\\"] print(toy_final_state(n, instructions)) # Output: -23"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},P={key:0,class:"empty-state"},D=["disabled"],F={key:0},M={key:1};function O(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),n(y,null,v(a.displayedPoems,(o,p)=>(s(),x(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",M,"Loading...")):(s(),n("span",F,"See more"))],8,D)):l("",!0)])}const I=m(E,[["render",O],["__scopeId","data-v-19ff4669"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/33.md","filePath":"guide/33.md"}'),z={name:"guide/33.md"},G=Object.assign(z,{setup(i){return(e,u)=>(s(),n("div",null,[w(I)]))}});export{B as __pageData,G as default};
