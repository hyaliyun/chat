import{_ as c,o as n,c as s,a as t,m as _,t as l,C as h,M as g,U as b,f as m,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},j={class:"review-content"};function R(i,e,u,d,r,a){return n(),s("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(l(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",j,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(l(u.poem.solution),1)])])])}const E=c(q,[["render",R],["__scopeId","data-v-07cab8a0"]]),S=JSON.parse(`[{"question":"def max_beauty(n: int, beauties: List[int]) -> Tuple[int, int]: Returns the maximum sum of the beauty values of any contiguous subsegment of the parade route, and the length of the subsegment that produces this sum. If the maximum sum is zero, return the shortest length of the subsegment producing this sum. Parameters: n (int): The number of segments in the parade route. beauties (list of int): The beauty values of the segments. Returns: tuple of (int, int): The maximum sum and the length of the subsegment. pass","solution":"def max_beauty(n, beauties): Returns the maximum sum of the beauty values of any contiguous subsegment of the parade route, and the length of the subsegment that produces this sum. If the maximum sum is zero, return the shortest length of the subsegment producing this sum. Parameters: n (int): The number of segments in the parade route. beauties (list of int): The beauty values of the segments. Returns: tuple of (int, int): The maximum sum and the length of the subsegment. max_sum = -float('inf') current_sum = 0 start_index = 0 min_length = float('inf') best_start = 0 best_end = 0 for end, value in enumerate(beauties): if current_sum <= 0: start_index = end current_sum = value else: current_sum += value if current_sum > max_sum or (current_sum == max_sum and (end - start_index + 1 < min_length)): max_sum = current_sum min_length = end - start_index + 1 best_start = start_index best_end = end if max_sum == 0: # find the shortest subsegment with zero sum min_zero_length = float('inf') for start in range(n): current_sum = 0 for end in range(start, n): current_sum += beauties[end] if current_sum == 0 and (end - start + 1 < min_zero_length): min_zero_length = end - start + 1 return (0, min_zero_length) return (max_sum, min_length)"},{"question":"def max_subarray_sum(nums) -> int: Finds the maximum possible sum of elements in any contiguous subarray of the given array nums. If the array contains only negative numbers, returns the single largest number from it. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-8, -3, -6, -2, -5, -4]) -2 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([-1, 3, -2, 6, -1]) 7 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([0, -1, 0, -2, 0]) 0","solution":"def max_subarray_sum(nums): Finds the maximum possible sum of elements in any contiguous subarray of the given array nums. If the array contains only negative numbers, returns the single largest number from it. Uses Kadane's algorithm. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_connected_components(M: int, N: int, grid: List[str]) -> int: Determines the maximum number of connected components of colored cells in a grid after performing optimal toggle operations. Args: M : int : number of rows in the grid N : int : number of columns in the grid grid : list of str : the initial configuration of the grid Returns: int : the maximum number of connected components >>> grid = [ \\"..#.\\", \\".#..\\", \\"..#.\\", \\"....\\" ] >>> max_connected_components(4, 4, grid) 8 >>> grid = [ \\"#\\" ] >>> max_connected_components(1, 1, grid) 1 >>> grid = [ \\"\\", \\"\\", \\"\\" ] >>> max_connected_components(3, 6, grid) 9 >>> grid = [ \\"......\\", \\"......\\", \\"......\\" ] >>> max_connected_components(3, 6, grid) 9 >>> grid = [ \\"#.#.#.\\", \\".#.#.#\\", \\"#.#.#.\\", \\".#.#.#\\" ] >>> max_connected_components(4, 6, grid) 12","solution":"def max_connected_components(M, N, grid): Determines the maximum number of connected components of colored cells in a grid after performing optimal toggle operations. Args: M : int : number of rows in the grid N : int : number of columns in the grid grid : list of list of str : the initial configuration of the grid Returns: int : the maximum number of connected components # The maximum number of connected components is achieved by coloring each cell such that # no two adjacent cells are both colored. max_components = (M * N + 1) // 2 return max_components"},{"question":"from typing import List def min_moves_to_reach_end(n: int, board: List[str]) -> int: Find the minimum number of moves the king needs to reach (n, n) from (1, 1), or determine if it's impossible. >>> min_moves_to_reach_end(5, [\\".....\\", \\".*.*.\\", \\".....\\", \\".*.*.\\", \\".....\\"]) 8 >>> min_moves_to_reach_end(1, [\\".\\"]) 0 >>> min_moves_to_reach_end(2, [\\".*\\", \\"*\\"]) -1 >>> min_moves_to_reach_end(4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 6 >>> min_moves_to_reach_end(4, [\\".*..\\", \\"*.*.\\", \\"..*.\\", \\"...*\\"]) -1","solution":"from collections import deque def min_moves_to_reach_end(n, board): directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if (r, c) == (n-1, n-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc] and board[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1 # If reaching (n-1, n-1) is not possible"},{"question":"def max_sequential_matches(matches): Determines the maximum number of matches a single robot needs to participate in sequentially without any breaks. Args: matches (list of tuples): Each tuple contains two integers representing the start and end times of a match. Returns: int: The maximum number of matches a single robot needs to participate in without any breaks. >>> max_sequential_matches([(1, 2)]) == 1 >>> max_sequential_matches([(1, 2), (3, 4), (5, 6)]) == 3 >>> max_sequential_matches([(1, 4), (2, 5), (6, 7)]) == 2 >>> max_sequential_matches([(1, 4), (2, 5), (7, 9), (6, 8), (5, 6)]) == 3 >>> max_sequential_matches([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) == 6 >>> max_sequential_matches([(1, 3), (3, 5), (5, 7), (7, 9)]) == 4 >>> max_sequential_matches([]) == 0","solution":"def max_sequential_matches(matches): Determines the maximum number of matches a single robot needs to participate in sequentially without any breaks. Args: matches (list of tuples): Each tuple contains two integers representing the start and end times of a match. Returns: int: The maximum number of matches a single robot needs to participate in without any breaks. if not matches: return 0 # sort the matches by end time first, then by start time matches.sort(key=lambda x: (x[1], x[0])) max_count = 0 current_end = 0 for match in matches: if match[0] >= current_end: max_count += 1 current_end = match[1] return max_count"},{"question":"from typing import List, Tuple def minimal_cost_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Returns the minimal cost of a path from node 1 to node n in a weighted, directed graph. Returns -1 if there is no such path. Args: n : int : the number of nodes in the graph m : int : the number of edges in the graph edges : List[Tuple[int, int, int]] : a list of tuples where each tuple contains three integers representing the start node, the end node, and the weight of the directed edge. Returns: int : the minimal cost of a path from node 1 to node n or -1 if no such path exists. Example usages: >>> minimal_cost_path(5, 6, [(1, 2, 3), (2, 5, 2), (1, 3, 4), (3, 4, 4), (4, 5, 1), (1, 5, 10)]) 5 >>> minimal_cost_path(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> minimal_cost_path(5, 7, [(1, 2, 2), (1, 3, 2), (2, 3, 1), (2, 4, 10), (3, 4, 2), (4, 5, 3), (1, 5, 4)]) 4","solution":"import heapq def minimal_cost_path(n, m, edges): Returns the minimal cost of a path from node 1 to node n in a weighted, directed graph. Returns -1 if there is no such path. # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm to find the shortest path from node 1 to node n min_heap = [(0, 1)] min_cost = {i: float('inf') for i in range(1, n + 1)} min_cost[1] = 0 while min_heap: current_cost, u = heapq.heappop(min_heap) if u == n: return current_cost for v, w in graph[u]: new_cost = current_cost + w if new_cost < min_cost[v]: min_cost[v] = new_cost heapq.heappush(min_heap, (new_cost, v)) return -1 if min_cost[n] == float('inf') else min_cost[n] # Example usage # n = 5, m = 6 # edges = [(1, 2, 3), (2, 5, 2), (1, 3, 4), (3, 4, 4), (4, 5, 1), (1, 5, 10)] # print(minimal_cost_path(n, m, edges)) # Output: 5 # n = 4, m = 2 # edges = [(1, 2, 5), (3, 4, 10)] # print(minimal_cost_path(n, m, edges)) # Output: -1 # n = 5, m = 7 # edges = [(1, 2, 2), (1, 3, 2), (2, 3, 1), (2, 4, 10), (3, 4, 2), (4, 5, 3), (1, 5, 4)] # print(minimal_cost_path(n, m, edges)) # Output: 4"},{"question":"def minimal_blocks(n: int, difficulties: List[int]) -> int: Returns the minimum number of blocks required to partition the difficulties into strictly increasing sequences. >>> minimal_blocks(6, [1, 3, 2, 4, 3, 5]) 3 >>> minimal_blocks(4, [4, 3, 2, 1]) 4 >>> minimal_blocks(5, [2, 3, 1, 4, 5]) 2 >>> minimal_blocks(1, [42]) 1 >>> minimal_blocks(5, [1, 2, 3, 4, 5]) 1 >>> minimal_blocks(4, [1, 3, 2, 4]) 2 >>> minimal_blocks(5, [2, 2, 2, 2, 2]) 5 >>> minimal_blocks(7, [5, 3, 1, 2, 3, 1, 4]) 4 pass","solution":"def minimal_blocks(n, difficulties): Returns the minimum number of blocks required to partition the difficulties into strictly increasing sequences. if n == 1: return 1 blocks = 1 last_difficulty = difficulties[0] for current_difficulty in difficulties[1:]: if current_difficulty <= last_difficulty: blocks += 1 last_difficulty = current_difficulty return blocks"},{"question":"def maximize_production(n: int, colonies: List[Tuple[int, int]]) -> int: Returns the maximum total production achievable by upgrading exactly one colony. :param n: Number of colonies :param colonies: List of tuples, each containing the production rate and potential increment (p, u) :return: Maximum total production >>> maximize_production(3, [(5, 3), (6, 2), (4, 5)]) == 20 >>> maximize_production(3, [(2, 1), (2, 1), (2, 1)]) == 7 >>> maximize_production(3, [(0, 1), (0, 2), (0, 3)]) == 3 >>> maximize_production(1, [(10, 5)]) == 15 >>> maximize_production(3, [(1, 1000000), (2, 500), (3, 300)]) == 1000006 >>> maximize_production(100000, [(1, 1)] * 100000) == 100001","solution":"def maximize_production(n, colonies): Returns the maximum total production after upgrading exactly one colony. :param n: Number of colonies :param colonies: List of tuples, each containing the production rate and potential increment (p, u) :return: Maximum total production total_production = sum(p for p, u in colonies) max_increment = max(u for p, u in colonies) return total_production + max_increment"},{"question":"from typing import List, Tuple def is_prime(n: int) -> bool: Check if a given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False def sum_of_primes_in_subarray(arr: List[int], l: int, r: int) -> int: Calculate the sum of all prime numbers in the subarray from index l to index r. >>> sum_of_primes_in_subarray([1, 2, 3, 4, 5, 6], 1, 3) 5 >>> sum_of_primes_in_subarray([1, 2, 3, 4, 5, 6], 2, 5) 10 def process_queries(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, output the sum of all prime numbers in the specified subarray. >>> process_queries([1, 2, 3, 4, 5, 6], [(1, 3), (2, 5), (1, 6)]) [5, 10, 10] >>> process_queries([7, 11, 13, 14, 17, 18], [(1, 4), (3, 6), (1, 6)]) [31, 30, 48]","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes_in_subarray(arr, l, r): return sum(x for x in arr[l-1:r] if is_prime(x)) def process_queries(arr, queries): results = [] for l, r in queries: results.append(sum_of_primes_in_subarray(arr, l, r)) return results"},{"question":"def longest_consecutive_sequence(nums) -> int: Find the length of the longest consecutive elements sequence in an unordered list of integers. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 101]) 4 >>> longest_consecutive_sequence([1, 2, 0, 1]) 3 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) 7 >>> longest_consecutive_sequence([0, -1, 1, -2, 2, -3, 3]) 7 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1, 3, 5, 7]) 1 >>> longest_consecutive_sequence([-1, -2, -3, -4]) 4","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only start searching if num is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def sort_by_absolute_values(arr: List[int]) -> List[int]: Returns a list of integers sorted by their absolute values, preserving original signs. >>> sort_by_absolute_values([-3, -1, 2, -2, 4]) [-1, 2, -2, -3, 4] >>> sort_by_absolute_values([5, 3, 1, 4, 2]) [1, 2, 3, 4, 5] >>> sort_by_absolute_values([-5, -3, -1, -4, -2]) [-1, -2, -3, -4, -5] >>> sort_by_absolute_values([0, -1, 0, 1, 0]) [0, 0, 0, -1, 1] >>> sort_by_absolute_values([9]) [9] >>> sort_by_absolute_values([-9]) [-9]","solution":"def sort_by_absolute_values(arr): Returns a list of integers sorted by their absolute values, preserving original signs. return sorted(arr, key=abs)"},{"question":"def max_value_path(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum sum of the values the robot can collect along any path from the top-left corner to the bottom-right corner of the grid. Parameters: - n (int): The number of rows in the grid. - m (int): The number of columns in the grid. - grid (List[List[int]]): The grid of item values. Returns: - int: The maximum sum possible. >>> max_value_path(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_value_path(2, 2, [[1, -1], [-1, 1]]) 1 pass import pytest def test_max_value_path_basic(): n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_value_path(n, m, grid) == 29 def test_max_value_path_negative(): n, m = 2, 2 grid = [ [1, -1], [-1, 1] ] assert max_value_path(n, m, grid) == 1 def test_max_value_path_single_cell(): n, m = 1, 1 grid = [[5]] assert max_value_path(n, m, grid) == 5 def test_max_value_path_single_row(): n, m = 1, 5 grid = [[1, 2, 3, 4, 5]] assert max_value_path(n, m, grid) == 15 def test_max_value_path_single_column(): n, m = 5, 1 grid = [ [1], [2], [3], [4], [5] ] assert max_value_path(n, m, grid) == 15 def test_max_value_path_all_zeros(): n, m = 3, 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_value_path(n, m, grid) == 0","solution":"def max_value_path(n, m, grid): Returns the maximum sum of the values the robot can collect along any path from the top-left corner to the bottom-right corner of the grid. # Initialize dp table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Base case - start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (can only move right) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only move down) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The result is in the bottom-right cell return dp[n-1][m-1]"},{"question":"def auto_correct(paragraph: str) -> str: Auto-correct the paragraph by capitalizing the first letter of each sentence. A sentence is defined as a sequence of characters ending with a period ('.'), exclamation mark ('!'), or question mark ('?'). After one of these punctuation marks, there may be one or more spaces before the next sentence starts. >>> auto_correct(\\"hello world! what's going on? have a nice day.\\") \\"Hello world! What's going on? Have a nice day.\\" >>> auto_correct(\\"this is a test. this is only a test.\\") \\"This is a test. This is only a test.\\"","solution":"def auto_correct(paragraph): Auto-corrects the paragraph by capitalizing the first letter of each sentence. A sentence is considered as any sequence of characters ending with '.', '?' or '!' followed by zero or more spaces. # Initialize an empty list to store corrected sentences corrected_paragraph = [] # Split the paragraph into parts separated by sentence delimiters start = 0 delimiters = {'.', '!', '?'} n = len(paragraph) while start < n: sentence_end = start while sentence_end < n and paragraph[sentence_end] not in delimiters: sentence_end += 1 if sentence_end < n: sentence_end += 1 sentence = paragraph[start:sentence_end] if sentence and sentence[0].isalpha(): sentence = sentence[0].upper() + sentence[1:] corrected_paragraph.append(sentence) start = sentence_end while start < n and paragraph[start] == ' ': corrected_paragraph.append(' ') start += 1 return ''.join(corrected_paragraph)"},{"question":"def can_make_palindrome(s: str, l: int, r: int) -> str: Determines if it is possible to make the substring s[l:r+1] a palindrome by changing exactly one character. >>> can_make_palindrome(\\"abca\\", 1, 4) \\"YES\\" >>> can_make_palindrome(\\"abca\\", 1, 3) \\"YES\\" >>> can_make_palindrome(\\"abca\\", 2, 4) \\"YES\\" >>> can_make_palindrome(\\"abca\\", 3, 3) \\"YES\\" >>> can_make_palindrome(\\"abcdefg\\", 1, 7) \\"NO\\" def solve_palindrome_game(s: str, queries: list[tuple[int, int]]) -> list[str]: Solves the palindrome game for multiple queries. >>> solve_palindrome_game(\\"abca\\", [(1, 4), (1, 3), (2, 4), (3, 3)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> solve_palindrome_game(\\"abcdefg\\", [(1, 7)]) [\\"NO\\"]","solution":"def can_make_palindrome(s, l, r): Determines if it is possible to make the substring s[l:r+1] a palindrome by changing exactly one character. sub = s[l-1:r] n = len(sub) mismatch_count = 0 for i in range(n // 2): if sub[i] != sub[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" return \\"YES\\" def solve_palindrome_game(s, queries): results = [] for l, r in queries: results.append(can_make_palindrome(s, l, r)) return results"},{"question":"def min_operations_to_non_decreasing(heights): Returns the minimum number of operations needed to make the heights of trees non-decreasing. Operation can be either cutting down a tree or decreasing the height of a tree. >>> min_operations_to_non_decreasing([1, 2, 3]) == 0 >>> min_operations_to_non_decreasing([3, 4, 7, 6, 8]) == 1 >>> min_operations_to_non_decreasing([10, 12, 8, 15]) == 1 >>> min_operations_to_non_decreasing([5, 3, 4, 2]) == 2 >>> min_operations_to_non_decreasing([5, 3, 7, 2, 8, 6, 9]) == 3 >>> min_operations_to_non_decreasing([1, 5, 9, 10]) == 0 >>> min_operations_to_non_decreasing([4, 4, 5, 6]) == 0 >>> min_operations_to_non_decreasing([1]) == 0 >>> min_operations_to_non_decreasing([10, 10, 10]) == 0","solution":"def min_operations_to_non_decreasing(heights): Returns the minimum number of operations needed to make the heights of trees non-decreasing. Operation can be either cutting down a tree or decreasing the height of a tree. n = len(heights) if n <= 1: return 0 # Create a list for tracking the minimum operations dp = [0] * n # Fill the dp array for i in range(1, n): if heights[i] >= heights[i - 1]: dp[i] = dp[i - 1] else: # either cut down this tree or decrease its height dp[i] = dp[i - 1] + 1 return dp[-1]"},{"question":"def max_coins_in_one_operation(grid: List[List[int]]) -> int: Returns the maximum number of coins that can be collected in one operation. Params: grid (List[List[int]]): The 2D array representing the grid of coins. Returns: int: Maximum number of coins that can be collected in one operation. pass # Example Usage # The following are provided test cases to validate the function implementation. assert max_coins_in_one_operation([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 assert max_coins_in_one_operation([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 assert max_coins_in_one_operation([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) == 78 assert max_coins_in_one_operation([[1, 2], [3, 4], [5, 6], [7, 8]]) == 36 assert max_coins_in_one_operation([[1000, 1000, 1000, 1000], [1000, 1000, 1000, 1000], [1000, 1000, 1000, 1000]]) == 12000","solution":"def max_coins_in_one_operation(grid): Returns the maximum number of coins that can be collected in one operation. Params: grid (list of list of int): The 2D array representing the grid of coins. Returns: int: Maximum number of coins that can be collected in one operation. def max_sum_subarray_2d(arr): if not arr: return 0 max_sum = float('-inf') m, n = len(arr), len(arr[0]) for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += arr[i][right] max_sum = max(max_sum, max_sum_subarray_1d(temp)) return max_sum def max_sum_subarray_1d(arr): current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum return max_sum_subarray_2d(grid)"},{"question":"def longest_subarray_with_sum_at_most_s(n: int, s: int, arr: List[int]) -> int: Finds the length of the longest subarray where the sum of its elements does not exceed a given integer s. >>> longest_subarray_with_sum_at_most_s(7, 10, [4, 1, 1, 2, 1, 1, 1]) == 6 >>> longest_subarray_with_sum_at_most_s(1, 5, [5]) == 1 >>> longest_subarray_with_sum_at_most_s(1, 2, [5]) == 0 >>> longest_subarray_with_sum_at_most_s(5, 15, [1, 2, 3, 4, 5]) == 5 >>> longest_subarray_with_sum_at_most_s(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5 >>> longest_subarray_with_sum_at_most_s(3, 1, [2, 2, 2]) == 0 >>> longest_subarray_with_sum_at_most_s(4, 4, [1, 1, 1, 1]) == 4 >>> longest_subarray_with_sum_at_most_s(4, 3, [1, 1, 1, 1]) == 3","solution":"def longest_subarray_with_sum_at_most_s(n, s, arr): Finds the length of the longest subarray where the sum of its elements does not exceed s. start = 0 current_sum = 0 max_len = 0 for end in range(n): current_sum += arr[end] while current_sum > s: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def min_swaps_to_sort_sequence(n: int, k: int, arr: List[int]) -> int: Determine the minimum number of swaps to sort the sequence under the constraint that the absolute difference between swapped elements must be less than or equal to k. Args: n (int): The number of elements in the sequence. k (int): The maximum allowed absolute difference between swapped elements. arr (List[int]): The sequence of unique integers. Returns: int: The minimum number of swaps required to sort the sequence, or -1 if it is impossible. >>> min_swaps_to_sort_sequence(5, 3, [4, 3, 2, 1, 5]) 2 >>> min_swaps_to_sort_sequence(3, 1, [1, 2, 3]) 0 >>> min_swaps_to_sort_sequence(1, 5, [1]) 0 >>> min_swaps_to_sort_sequence(4, 1, [4, 1, 3, 2]) -1 >>> min_swaps_to_sort_sequence(5, 3, [1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort_sequence(5, 1000000, [4, 3, 2, 1, 5]) 2 >>> min_swaps_to_sort_sequence(6, 2, [6, 2, 4, 1, 3, 5]) -1","solution":"from collections import deque def min_swaps_to_sort_sequence(n, k, arr): Determine the minimum number of swaps to sort the sequence under the constraint that the absolute difference between swapped elements must be less than or equal to k. # Helper function to perform BFS to find the smallest distance def bfs(start, graph, visited): queue = deque([start]) visited[start] = True component = [] while queue: node = queue.popleft() component.append(node) for neighbour in graph[node]: if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) return component # Create nodes based on their positions in the sorted array sorted_arr = sorted(arr) lookup = {value: i for i, value in enumerate(arr)} # Create the graph for allowed swaps graph = {i: [] for i in range(n)} for i in range(n): for j in range(i + 1, n): if abs(arr[i] - arr[j]) <= k: graph[i].append(j) graph[j].append(i) visited = [False] * n swaps = 0 # Find all connected components in the graph for i in range(n): if not visited[i]: component = bfs(i, graph, visited) component_values = [arr[x] for x in component] sorted_component_values = sorted(component_values) for idx, val in zip(component, sorted_component_values): if arr[idx] != val: swaps += 1 arr[idx] = val for i in range(n): if arr[i] != sorted_arr[i]: return -1 return swaps // 2 # Each swap is counted twice, so divide by 2."},{"question":"def max_requests_handled(servers: List[int], requests: List[int]) -> int: Determine the maximum number of requests that can be handled by the servers. >>> max_requests_handled([10, 15, 20], [5, 10, 5, 7, 8]) 5 >>> max_requests_handled([], [5, 10, 5, 7, 8]) 0 >>> max_requests_handled([10, 15, 20], []) 0 >>> max_requests_handled([5], [10]) 0 >>> max_requests_handled([10], [10]) 1 >>> max_requests_handled([10, 10], [5, 5, 5, 5]) 4 >>> max_requests_handled([15], [5, 8, 3]) 2","solution":"def max_requests_handled(servers, requests): servers.sort(reverse=True) requests.sort(reverse=True) request_idx = 0 for server in servers: current_load = server while request_idx < len(requests) and current_load >= requests[request_idx]: current_load -= requests[request_idx] request_idx += 1 return request_idx # Example usage: # n, m = 3, 5 # servers = [10, 15, 20] # requests = [5, 10, 5, 7, 8] # print(max_requests_handled(servers, requests)) # Output: 5"},{"question":"def count_palindromic_paths(n: int, grid: List[str]) -> int: Find the number of distinct palindromic paths from the top-left corner to the bottom-right corner of an n by n grid. >>> count_palindromic_paths(3, ['abc', 'def', 'ghi']) == 0 >>> count_palindromic_paths(1, ['a']) == 1 >>> count_palindromic_paths(2, ['aa', 'aa']) == 2 >>> count_palindromic_paths(3, ['aaa', 'aaa', 'aaa']) == 6 >>> count_palindromic_paths(3, ['aba', 'cac', 'aba']) == 2 >>> count_palindromic_paths(4, ['abcd', 'efgh', 'ijkl', 'mnop']) == 0","solution":"def count_palindromic_paths(n, grid): memo = {} def is_palindrome(s): return s == s[::-1] def dfs(i, j, path): if i >= n or j >= n: return 0 path += grid[i][j] if (i, j, path) in memo: return memo[(i, j, path)] if i == n-1 and j == n-1: memo[(i, j, path)] = 1 if is_palindrome(path) else 0 return memo[(i, j, path)] paths_from_here = dfs(i + 1, j, path) + dfs(i, j + 1, path) memo[(i, j, path)] = paths_from_here return paths_from_here return dfs(0, 0, '') # Example Usage n = 3 grid = [ 'abc', 'def', 'ghi' ] print(count_palindromic_paths(n, grid)) # Output: 0"},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Calculate the minimum number of moves required for the robot to reach the target position from the starting position, avoiding blocked cells. >>> min_moves(5, 5, [\\".....\\", \\".#...\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves(3, 3, [\\"...\\", \\"#.#\\", \\"...\\"], 0, 0, 2, 2) 4 >>> min_moves(3, 3, [\\"...\\", \\"#\\", \\"...\\"], 0, 0, 2, 2) -1 >>> min_moves(1, 1, [\\".\\"], 0, 0, 0, 0) 0 >>> min_moves(2, 2, [\\"..\\", \\"..\\"], 0, 0, 1, 1) 2","solution":"from collections import deque def min_moves(n, m, grid, sx, sy, tx, ty): if grid[sx][sy] == '#' or grid[tx][ty] == '#': return -1 # Possible moves: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * m for _ in range(n)] queue = deque([(sx, sy, 0)]) # (x, y, distance) visited[sx][sy] = True while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist+1)) return -1"},{"question":"def minimum_swaps(arr: List[int]) -> int: Returns the minimum number of swaps needed to sort the array in ascending order. Args: arr (List[int]): An array of integers to sort. Returns: int: The minimum number of swaps needed to sort the array. Examples: >>> minimum_swaps([4, 3, 1, 2]) 3 >>> minimum_swaps([1, 2, 3, 4, 5]) 0 >>> minimum_swaps([5, 4, 3, 2, 1]) 2 >>> minimum_swaps([1]) 0 >>> minimum_swaps([2, 1]) 1 from typing import List import unittest class TestMinimumSwaps(unittest.TestCase): def test_minimum_swaps_example(self): self.assertEqual(minimum_swaps([4, 3, 1, 2]), 3) def test_minimum_swaps_sorted_array(self): self.assertEqual(minimum_swaps([1, 2, 3, 4, 5]), 0) def test_minimum_swaps_reverse_sorted_array(self): self.assertEqual(minimum_swaps([5, 4, 3, 2, 1]), 2) def test_minimum_swaps_single_element(self): self.assertEqual(minimum_swaps([1]), 0) def test_minimum_swaps_two_elements(self): self.assertEqual(minimum_swaps([2, 1]), 1) if __name__ == \\"__main__\\": unittest.main()","solution":"def minimum_swaps(arr): Returns the minimum number of swaps needed to sort the array in ascending order. n = len(arr) arrpos = list(enumerate(arr)) arrpos.sort(key=lambda it: it[1]) vis = {k: False for k in range(n)} ans = 0 for i in range(n): if vis[i] or arrpos[i][0] == i: continue cycle_size = 0 j = i while not vis[j]: vis[j] = True j = arrpos[j][0] cycle_size += 1 if cycle_size > 0: ans += cycle_size - 1 return ans"},{"question":"def largest_connected_component(n: int, m: int, grid: List[List[int]]) -> int: Returns the size of the largest connected component of land (1s) in the grid. Args: n : int : Number of rows in the grid m : int : Number of columns in the grid grid : List[List[int]] : The grid containing land (1) and water (0) Returns: int : The size of the largest connected component of land Example: >>> grid = [ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 1, 0, 0, 0], ... [0, 0, 1, 1, 1] ... ] >>> largest_connected_component(4, 5, grid) 4","solution":"def largest_connected_component(n, m, grid): Returns the size of the largest connected component of land (1s) in the grid. def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy) return size max_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def house_position(n: int, h: int) -> str: Returns the position of the house on either the left or right side of the road. Parameters: n (int): The number of houses on each side of the road. h (int): The house number. Returns: str: A string indicating the side (\\"Left\\" or \\"Right\\") and the position of the house. >>> house_position(5, 3) 'Left 3' >>> house_position(5, 7) 'Right 4'","solution":"def house_position(n, h): Returns the position of the house on either the left or right side of the road. Parameters: n (int): The number of houses on each side of the road. h (int): The house number. Returns: str: A string indicating the side (\\"Left\\" or \\"Right\\") and the position of the house. if 1 <= h <= n: return f\\"Left {h}\\" elif n < h <= 2 * n: position = (2 * n) - h + 1 return f\\"Right {position}\\" else: raise ValueError(\\"House number out of range\\")"},{"question":"from typing import List, Tuple def minimum_new_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of new roads required to make the entire kingdom connected again. Args: n (int): The number of regions. m (int): The number of roads. roads (List[Tuple[int, int]]): A list of pairs of regions directly connected by a road. Returns: int: The minimum number of new roads needed so that every region is reachable from every other region. Example: >>> minimum_new_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> minimum_new_roads(4, 0, []) 3 def test_example_1(): assert minimum_new_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) == 2 def test_example_2(): assert minimum_new_roads(4, 0, []) == 3 def test_single_region(): assert minimum_new_roads(1, 0, []) == 0 def test_already_connected(): assert minimum_new_roads(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 0 def test_two_components(): assert minimum_new_roads(5, 2, [(1, 2), (3, 4)]) == 2","solution":"def minimum_new_roads(n, m, roads): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited[node] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 0 graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: components += 1 bfs(i) return components - 1"},{"question":"def max_cherries(H: int, W: int, grid: List[List[int]]) -> int: Determine the maximum number of cherries that can be collected from top-left to bottom-right of the grid following given rules. >>> max_cherries(3, 3, [[0, 1, 1], [1, 0, 1], [0, 1, 1]]) 4 >>> max_cherries(1, 5, [[1, 1, 1, 1, 1]]) 5 >>> max_cherries(5, 1, [[1], [1], [1], [1], [1]]) 5 >>> max_cherries(2, 2, [[0, 0], [0, 0]]) 0 >>> max_cherries(3, 3, [[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 3","solution":"def max_cherries(H, W, grid): # Create a DP array to store the maximum cherries collects up to each cell dp = [[0] * W for _ in range(H)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, W): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, H): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, H): for j in range(1, W): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The result is the maximum cherries collects up to the bottom right corner return dp[H-1][W-1] # Example usage H = 3 W = 3 grid = [ [0, 1, 1], [1, 0, 1], [0, 1, 1] ] print(max_cherries(H, W, grid)) # Output: 4"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Given a list of start and finish times for tasks, returns the maximum number of non-overlapping tasks that can be completed. Args: tasks : List[Tuple[int, int]] : List of (start, finish) times for each task Returns: int : Maximum number of non-overlapping tasks pass","solution":"def max_non_overlapping_tasks(tasks): Given a list of start and finish times for tasks, returns the maximum number of non-overlapping tasks that can be completed. Args: tasks : List[Tuple[int, int]] : List of (start, finish) times for each task Returns: int : Maximum number of non-overlapping tasks # Sort tasks based on finish times tasks.sort(key=lambda x: x[1]) # Initialize count of non-overlapping tasks count = 0 # end time of the last selected task, initialize it to -1 last_end_time = -1 # Loop through tasks and select the maximum number of non-overlapping tasks for start, finish in tasks: if start >= last_end_time: count += 1 last_end_time = finish return count"},{"question":"from typing import List def process_events(n: int, m: int, resources: List[int], events: List[List[int]]) -> List[int]: Determine the final state of all resources after applying all the events in given order. The first line of input contains two integers n and m (1 ≤ n ≤ 100, 1 ≤ m ≤ 10^5) — the number of distinct resources and the number of events. The second line contains n integers r1, r2, ..., rn (0 ≤ ri ≤ 10^9) — the initial quantities of resources. Each of the following m lines describes an event and contains three integers t, k, v where t (1 ≤ t ≤ 3) is the type of the event: - if t = 1, increment the quantity of the k-th resource by v (1 ≤ k ≤ n, 0 ≤ v ≤ 1000) - if t = 2, decrement the quantity of the k-th resource by v (1 ≤ k ≤ n, 0 ≤ v ≤ 1000) and ensure that it does not go below zero - if t = 3, set the quantity of the k-th resource to v (1 ≤ k ≤ n, 0 ≤ v ≤ 10^9) Output the final quantities of all resources after all events have been processed. >>> process_events(3, 5, [10, 20, 30], [[1, 1, 5], [2, 2, 10], [3, 3, 25], [1, 1, 10], [2, 2, 5]]) [25, 5, 25] >>> process_events(3, 3, [1, 2, 3], [[3, 1, 7], [3, 2, 8], [3, 3, 9]]) [7, 8, 9]","solution":"def process_events(n, m, resources, events): for event in events: t, k, v = event if t == 1: resources[k-1] += v elif t == 2: resources[k-1] = max(0, resources[k-1] - v) elif t == 3: resources[k-1] = v return resources"},{"question":"import collections from typing import List, Tuple def max_path_strength(n: int, edges: List[Tuple[int, int]], node_values: List[int]) -> int: Find the maximum path strength in a tree for a ceremony where the path strength is calculated as the sum of all the node values on the path connecting two leaf nodes through a central node. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The list of edges connecting the nodes. node_values (List[int]): The values of the nodes in the tree. Returns: int: The maximum path strength achievable during the ceremony. >>> max_path_strength(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [5, 8, 3, 7, 1]) 23 >>> max_path_strength(2, [(1, 2)], [1, 2]) 3 import pytest def test_example_case(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] node_values = [5, 8, 3, 7, 1] assert max_path_strength(n, edges, node_values) == 23 def test_small_tree(): n = 2 edges = [(1, 2)] node_values = [1, 2] assert max_path_strength(n, edges, node_values) == 3 def test_single_path_tree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] node_values = [1, 2, 3, 4] assert max_path_strength(n, edges, node_values) == 10 def test_balanced_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] node_values = [1, 2, 3, 4, 5, 6, 7] assert max_path_strength(n, edges, node_values) == 18 def test_large_values(): n = 3 edges = [(1, 2), (1, 3)] node_values = [1000000000, 1000000000, 1000000000] assert max_path_strength(n, edges, node_values) == 3000000000","solution":"from collections import defaultdict def dfs(node, parent, tree, values, cache): # We initialize the two largest distances from current node to any leaf max1, max2 = 0, 0 # Iterate over all connected nodes for neighbor in tree[node]: if neighbor != parent: neighbor_max = dfs(neighbor, node, tree, values, cache) if neighbor_max > max1: max1, max2 = neighbor_max, max1 elif neighbor_max > max2: max2 = neighbor_max # The best path through this node as the central point cache[node] = values[node] + max1 + max2 # Return the best single path extension return values[node] + max1 def max_path_strength(n, edges, node_values): tree = defaultdict(list) for x, y in edges: tree[x].append(y) tree[y].append(x) # Convert 1-indexed to 0-indexed values = [0] + node_values # Cache for storing max path strengths cache = [0] * (n + 1) # Starting DFS from node 1 (root of the tree) dfs(1, -1, tree, values, cache) return max(cache) # Example function call: # n = 5 # edges = [(1, 2), (1, 3), (3, 4), (3, 5)] # node_values = [5, 8, 3, 7, 1] # Result: 23"},{"question":"def most_popular_product(n, products): Determine the most popular product for given day sales. Args: n (int): number of products sold that day. products (List[int]): list of product IDs sold that day. Returns: int: product ID of the most popular product. Examples: >>> most_popular_product(6, [1, 2, 3, 2, 3, 3]) 3 >>> most_popular_product(4, [1, 2, 1, 2]) 1 pass","solution":"def most_popular_product(n, products): from collections import Counter # Count the number of sales for each product product_count = Counter(products) # Find the product with the maximum sales max_sales = max(product_count.values()) # Collect all products that have the maximum sales most_popular = [product for product, count in product_count.items() if count == max_sales] # Return the smallest product ID among the most popular ones return min(most_popular)"},{"question":"from typing import List def min_steps_to_goal(n: int, m: int, grid: List[str]) -> int: Function to calculate the minimum number of steps to move from the start position (1, 1) to the goal position (n, m) in a grid. >>> min_steps_to_goal(5, 5, [ ... \\".....\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#...\\", ... \\".....\\"]) 8 >>> min_steps_to_goal(3, 3, [ ... \\".#.\\", ... \\"#.#\\", ... \\".#.\\" ... ]) -1 pass def test_example_case(): grid = [ \\".....\\", \\".#.#.\\", \\".#.#.\\", \\".#...\\", \\".....\\" ] assert min_steps_to_goal(5, 5, grid) == 8 def test_no_obstacle_case(): grid = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] assert min_steps_to_goal(5, 5, grid) == 8 def test_no_path_case(): grid = [ \\".#.\\", \\"#.#\\", \\".#.\\" ] assert min_steps_to_goal(3, 3, grid) == -1 def test_single_row_case(): grid = [ \\"......\\" ] assert min_steps_to_goal(1, 6, grid) == 5 def test_single_column_case(): grid = [ \\".\\", \\".\\", \\".\\", \\".\\", \\".\\" ] assert min_steps_to_goal(5, 1, grid) == 4 def test_start_equals_goal(): grid = [ \\".\\" ] assert min_steps_to_goal(1, 1, grid) == 0","solution":"from collections import deque def min_steps_to_goal(n, m, grid): Function to calculate the minimum number of steps to move from the start position (1, 1) to the goal position (n, m) in a grid. # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue for BFS and visited set queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() # Check if we have reached the bottom-right corner if x == n - 1 and y == m - 1: return steps # Explore all 4 possible directions from the current cell for dx, dy in directions: new_x, new_y = x + dx, y + dy # Check if the new cell is within bounds and is not an obstacle if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': queue.append((new_x, new_y, steps + 1)) visited.add((new_x, new_y)) # If we exit the loop without having returned, there's no valid path return -1"},{"question":"from typing import List def merge_scrolls(n: int, m: int, scroll1: List[int], scroll2: List[int]) -> List[int]: Merge two scrolls in an alternating manner. Args: n (int): Length of the first scroll. m (int): Length of the second scroll. scroll1 (List[int]): Sequence of the first scroll. scroll2 (List[int]): Sequence of the second scroll. Returns: List[int]: Merged sequence of the two scrolls. Examples: >>> merge_scrolls(3, 4, [1, 3, 5], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 8] >>> merge_scrolls(3, 3, [1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_scrolls(4, 3, [1, 3, 5, 7], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7] def test_example_case(): n, m = 3, 4 scroll1 = [1, 3, 5] scroll2 = [2, 4, 6, 8] assert merge_scrolls(n, m, scroll1, scroll2) == [1, 2, 3, 4, 5, 6, 8] def test_both_scrolls_of_same_length(): n, m = 3, 3 scroll1 = [1, 3, 5] scroll2 = [2, 4, 6] assert merge_scrolls(n, m, scroll1, scroll2) == [1, 2, 3, 4, 5, 6] def test_first_scroll_longer(): n, m = 4, 3 scroll1 = [1, 3, 5, 7] scroll2 = [2, 4, 6] assert merge_scrolls(n, m, scroll1, scroll2) == [1, 2, 3, 4, 5, 6, 7] def test_second_scroll_longer(): n, m = 3, 5 scroll1 = [1, 3, 5] scroll2 = [2, 4, 6, 8, 10] assert merge_scrolls(n, m, scroll1, scroll2) == [1, 2, 3, 4, 5, 6, 8, 10] def test_one_empty_scroll(): n, m = 0, 3 scroll1 = [] scroll2 = [2, 4, 6] assert merge_scrolls(n, m, scroll1, scroll2) == [2, 4, 6] def test_both_scrolls_empty(): n, m = 0, 0 scroll1 = [] scroll2 = [] assert merge_scrolls(n, m, scroll1, scroll2) == []","solution":"def merge_scrolls(n, m, scroll1, scroll2): Merge two scrolls in an alternating manner. # Initialize the merged scroll merged_scroll = [] # Use two pointers to traverse both scrolls i, j = 0, 0 # Loop until we traverse both scrolls while i < n or j < m: if i < n: merged_scroll.append(scroll1[i]) i += 1 if j < m: merged_scroll.append(scroll2[j]) j += 1 return merged_scroll"},{"question":"class Tree: def __init__(self, n, edges): self.n = n self.children = {i: [] for i in range(1, n + 1)} self.color = [0] * (n + 1) for idx, parent in enumerate(edges): self.children[parent].append(idx + 2) def paint(self, u, c): # Paint node u with color c pass def count_color_in_subtree(self, u, c): # Count the number of nodes with color c in the subtree of node u pass def process_queries(n, edges, queries): Process a series of paint and count color queries on a tree. Args: n (int): The number of nodes in the tree. edges (List[int]): List of edges indicating the parent of each node from 2 to n. queries (List[Tuple[int, int, int]]): List of queries to process. Returns: List[int]: The result of the count queries. Example: >>> n = 5 >>> edges = [1, 1, 2, 2] >>> queries = [(1, 2, 3), (2, 1, 3), (2, 2, 3)] >>> process_queries(n, edges, queries) [1, 1] import pytest from solution import process_queries def test_process_queries_example1(): n = 5 edges = [1, 1, 2, 2] queries = [(1, 2, 3), (2, 1, 3), (2, 2, 3)] assert process_queries(n, edges, queries) == [1, 1] def test_process_queries_no_color_paint(): n = 3 edges = [1, 1] queries = [(2, 1, 2), (2, 2, 2), (2, 3, 2)] assert process_queries(n, edges, queries) == [0, 0, 0] def test_process_queries_multiple_paints(): n = 4 edges = [1, 2, 2] queries = [(1, 2, 4), (1, 3, 4), (2, 2, 4), (2, 3, 4)] assert process_queries(n, edges, queries) == [2, 1] def test_process_queries_root_subtree(): n = 6 edges = [1, 2, 2, 3, 3] queries = [(1, 3, 5), (1, 5, 5), (2, 1, 5), (2, 3, 5)] assert process_queries(n, edges, queries) == [2, 2] def test_process_queries_single_node(): n = 1 edges = [] queries = [(1, 1, 7), (2, 1, 7)] assert process_queries(n, edges, queries) == [1] # Running the test cases pytest.main()","solution":"class Tree: def __init__(self, n, edges): self.n = n self.children = {i: [] for i in range(1, n + 1)} self.color = [0] * (n + 1) for idx, parent in enumerate(edges): self.children[parent].append(idx + 2) def paint(self, u, c): self.color[u] = c def count_color_in_subtree(self, u, c): count = 0 stack = [u] while stack: node = stack.pop() if self.color[node] == c: count += 1 stack.extend(self.children[node]) return count def process_queries(n, edges, queries): tree = Tree(n, edges) results = [] for query in queries: if query[0] == 1: _, u, c = query tree.paint(u, c) elif query[0] == 2: _, u, c = query results.append(tree.count_color_in_subtree(u, c)) return results"},{"question":"def max_envelopes(envelopes): Determines the longest sequence of envelopes you can put one inside the other. :param envelopes: List of tuples where each tuple contains two integers (width and height of the envelope). :returns: The length of the longest sequence of envelopes. >>> max_envelopes([(5, 4), (6, 4), (6, 7), (2, 3), (5, 5)]) == 3 >>> max_envelopes([(1, 1), (1, 1), (1, 1)]) == 1 >>> max_envelopes([(5, 5), (6, 4), (6, 7), (5, 4), (2, 3)]) == 3 >>> max_envelopes([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 5 >>> max_envelopes([(4, 5), (5, 4), (3, 6)]) == 1 >>> max_envelopes([(5, 4), (6, 7), (2, 3), (3, 4), (7, 8)]) == 4","solution":"from bisect import bisect_left def max_envelopes(envelopes): Determines the longest sequence of envelopes you can put one inside the other. :param envelopes: List of tuples where each tuple contains two integers (width and height of the envelope). :returns: The length of the longest sequence of envelopes. # First sort envelopes by width ascending and by height descending envelopes.sort(key=lambda x: (x[0], -x[1])) # Extract the heights from the sorted envelopes heights = [h for _, h in envelopes] # Find the length of the Longest Increasing Subsequence (LIS) on heights lis = [] for height in heights: pos = bisect_left(lis, height) if pos < len(lis): lis[pos] = height else: lis.append(height) return len(lis)"},{"question":"def max_weight(n, W, weights): Determines the maximum possible weight a contiguous subsequence of rocks can have without exceeding the given weight limit W. :param n: Number of rocks :param W: Maximum weight the sack can carry :param weights: List containing weights of the rocks :return: Maximum weight without exceeding W >>> max_weight(5, 10, [1, 2, 3, 4, 5]) 10 >>> max_weight(4, 7, [4, 3, 2, 1]) 7 >>> max_weight(1, 1, [1]) 1 >>> max_weight(1, 10, [15]) 0 >>> max_weight(5, 1_000_000_000, [100_000_000, 200_000_000, 300_000_000, 400_000_000, 500_000_000]) 1_000_000_000 >>> max_weight(5, 6, [1, 2, 3, 4, 5]) 6 >>> max_weight(4, 10, [2, 3, 4, 1]) 10 >>> max_weight(6, 3, [4, 5, 6, 7, 8, 9]) 0 >>> max_weight(7, 15, [1, 2, 3, 4, 5, 1, 10]) 15","solution":"def max_weight(n, W, weights): Determines the maximum possible weight a contiguous subsequence of rocks can have without exceeding the given weight limit W. :param n: Number of rocks :param W: Maximum weight the sack can carry :param weights: List containing weights of the rocks :return: Maximum weight without exceeding W max_weight_found = 0 current_sum = 0 start = 0 for end in range(n): current_sum += weights[end] while current_sum > W: current_sum -= weights[start] start += 1 max_weight_found = max(max_weight_found, current_sum) return max_weight_found"},{"question":"def number_of_points_on_convex_hull(n: int, points: List[Tuple[int, int]]) -> int: Given a set of points in a 2D plane, determine the number of points that are on the convex hull. The convex hull of a set of points is the smallest convex polygon that can enclose all the points. Args: n (int): Number of points. points (List[Tuple[int, int]]): A list of tuples where each tuple contains the coordinates of a point. Returns: int: The number of points that are on the convex hull. Example: >>> number_of_points_on_convex_hull(5, [(0, 0), (2, 2), (2, 0), (0, 2), (1, 1)]) 4 >>> number_of_points_on_convex_hull(3, [(0, 0), (1, 1), (2, 0)]) 3","solution":"def cross_product(o, a, b): Returns the cross product of vector OA and OB A positive cross product indicates a counter-clockwise turn A negative cross product indicates a clockwise turn A zero cross product indicates collinearity return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) def convex_hull(points): # Sort the points lexicographically (tuples of x, then y) points = sorted(points) # Build the lower hull lower = [] for p in points: while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Build the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Remove the last point of each half because it is repeated at the beginning of the other half return len(lower[:-1] + upper[:-1]) def number_of_points_on_convex_hull(n, points): return convex_hull(points)"},{"question":"def max_candy_collected(n: int, candies: List[int]) -> int: Determine the maximum amount of candy that can be collected by visiting houses such that no two houses visited are adjacent. Parameters: n (int): The number of houses candies (List[int]): A list of integers where each integer represents the amount of candy in each house Returns: int: The maximum amount of candy that can be collected >>> max_candy_collected(5, [3, 2, 7, 10, 12]) 22 >>> max_candy_collected(1, [5]) 5 >>> max_candy_collected(3, [2, 10, 3]) 10 >>> max_candy_collected(4, [1, 2, 3, 1]) 4 >>> max_candy_collected(3, [0, 0, 0]) 0","solution":"def max_candy_collected(n, candies): if n == 0: return 0 elif n == 1: return candies[0] elif n == 2: return max(candies[0], candies[1]) prev1 = candies[0] prev2 = max(candies[0], candies[1]) for i in range(2, n): current = max(prev1 + candies[i], prev2) prev1 = prev2 prev2 = current return prev2"},{"question":"MOD = 10**9 + 7 def count_paths(n, m, grid): Determine the number of different paths from the top-left to the bottom-right corner of the grid. The grid cells contain either '.' (open) or '#' (blocked). Karel can only move right or down. If there are no valid paths, return 0. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The grid configuration. Returns: int: Number of different paths modulo 10**9 + 7. >>> count_paths(2, 2, [['.', '#'], ['.', '.']]) 1 >>> count_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> count_paths(3, 3, [['#', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 0 >>> count_paths(5, 5, [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.']]) 70 def parse_input(input_string): Parse the input string to extract grid dimensions and the grid configuration. Args: input_string (str): The input string containing the grid dimensions and configuration. Returns: Tuple[int, int, List[List[str]]]: Number of rows, number of columns, and the grid configuration. >>> parse_input(\\"3 3n...n.#.n...\\") (3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) >>> parse_input(\\"5 5n.....n.....n.....n.....n.....\\") (5, 5, [['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.'], ['.', '.', '.', '.', '.']])","solution":"MOD = 10**9 + 7 def count_paths(n, m, grid): # Initialize a dp array with all zeros dp = [[0] * m for _ in range(n)] # Starting position if grid[0][0] == '.': dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == '.': if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] # Helper function to parse input def parse_input(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return n, m, grid"},{"question":"def minInsertionsToPalindrome(s: str) -> int: Returns the minimum number of insertions required to convert the string s into a palindrome. pass # Unit Tests def test_minInsertionsToPalindrome_example1(): assert minInsertionsToPalindrome(\\"abcaa\\") == 2 def test_minInsertionsToPalindrome_example2(): assert minInsertionsToPalindrome(\\"abcd\\") == 3 def test_minInsertionsToPalindrome_single_char(): assert minInsertionsToPalindrome(\\"a\\") == 0 def test_minInsertionsToPalindrome_two_chars(): assert minInsertionsToPalindrome(\\"ab\\") == 1 def test_minInsertionsToPalindrome_palindromic(): assert minInsertionsToPalindrome(\\"racecar\\") == 0 def test_minInsertionsToPalindrome_general_case(): assert minInsertionsToPalindrome(\\"race\\") == 3 def test_minInsertionsToPalindrome_all_same_chars(): assert minInsertionsToPalindrome(\\"aaaa\\") == 0 def test_minInsertionsToPalindrome_mixed_chars(): assert minInsertionsToPalindrome(\\"abcde\\") == 4","solution":"def minInsertionsToPalindrome(s: str) -> int: Returns the minimum number of insertions required to convert the string s into a palindrome. def lcs(X, Y): m = len(X) n = len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) return len(s) - lcs_length"},{"question":"def largest_rectangle_area(matrix: List[List[str]]) -> int: Find the area of the largest rectangular subgrid that contains only '1's. :param matrix: A list of lists of '0's and '1's representing the grid. :return: The area of the largest rectangular subgrid that contains only '1's. >>> largest_rectangle_area([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ]) 6 >>> largest_rectangle_area([ ... ['1', '1', '1', '1', '1'] ... ]) 5 >>> largest_rectangle_area([ ... ['1'], ... ['1'], ... ['1'], ... ['1'], ... ['1'] ... ]) 5 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) 0 >>> largest_rectangle_area([ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ]) 9","solution":"def largest_rectangle_area(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == '1': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largest_histogram_area(heights)) return max_area def largest_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"import heapq def minimum_transmission_time(n, m, channels, s, d): Calculate the minimum time required to send a message from computer s to computer d. Args: n (int): Number of computers m (int): Number of communication channels channels (List[Tuple[int, int, int]]): List of communication channels where each channel is represented by a tuple (u, v, w) s (int): Starting computer d (int): Destination computer Returns: int: Minimum transmission time from computer s to computer d. If no path exists, return -1 >>> minimum_transmission_time(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1, 5) 6 >>> minimum_transmission_time(5, 3, [(1, 2, 2), (2, 3, 1), (4, 5, 2)], 1, 5) -1 >>> minimum_transmission_time(4, 5, [(1, 2, 2), (1, 3, 1), (2, 3, 1), (2, 4, 4), (3, 4, 1)], 1, 4) 2 >>> minimum_transmission_time(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 10)], 1, 3) 7 >>> minimum_transmission_time(3, 2, [(1, 2, 1000000), (2, 3, 1000000)], 1, 3) 2000000 pass def test_custom_case(): n = 5 m = 6 channels = [ (1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1) ] s, d = 1, 5 assert minimum_transmission_time(n, m, channels, s, d) == 6 def test_no_path_case(): n = 5 m = 3 channels = [ (1, 2, 2), (2, 3, 1), (4, 5, 2) ] s, d = 1, 5 assert minimum_transmission_time(n, m, channels, s, d) == -1 def test_multiple_paths(): n = 4 m = 5 channels = [ (1, 2, 2), (1, 3, 1), (2, 3, 1), (2, 4, 4), (3, 4, 1) ] s, d = 1, 4 assert minimum_transmission_time(n, m, channels, s, d) == 2 def test_direct_path(): n = 3 m = 3 channels = [ (1, 2, 3), (2, 3, 4), (1, 3, 10) ] s, d = 1, 3 assert minimum_transmission_time(n, m, channels, s, d) == 7 def test_large_weights(): n = 3 m = 2 channels = [ (1, 2, 1000000), (2, 3, 1000000) ] s, d = 1, 3 assert minimum_transmission_time(n, m, channels, s, d) == 2000000","solution":"import heapq def minimum_transmission_time(n, m, channels, s, d): Calculate the minimum time required to send a message from computer s to computer d. # Create a graph in the form of an adjacency list graph = {i: [] for i in range(1, n + 1)} for u, v, w in channels: graph[u].append((v, w)) graph[v].append((u, w)) # Use Dijkstra's algorithm to find the shortest path pq = [(0, s)] # (cost, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the destination, return the distance if current_node == d: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[d] == float('inf') else distances[d]"},{"question":"def generate_matches(n: int) -> List[Tuple[int, int]]: Generates a list of matches for n players where each player plays against every other player exactly once. Parameters: n (int): The number of players. Returns: list of tuple: Each tuple contains a pair of player ids representing a match. >>> generate_matches(3) [(1, 2), (1, 3), (2, 3)] >>> generate_matches(4) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] >>> generate_matches(2) [(1, 2)]","solution":"def generate_matches(n): Generates a list of matches for n players where each player plays against every other player exactly once. Parameters: n (int): The number of players. Returns: list of tuple: Each tuple contains a pair of player ids representing a match. matches = [] for x in range(1, n): for y in range(x + 1, n + 1): matches.append((x, y)) return matches"},{"question":"def max_number_after_deleting_one_digit(num_str: str) -> int: Given a string of digits, return the maximum number possible by deleting exactly one digit. >>> max_number_after_deleting_one_digit(\\"152\\") 52 >>> max_number_after_deleting_one_digit(\\"1001\\") 101 >>> max_number_after_deleting_one_digit(\\"10\\") 1 def process_test_cases(test_cases: list) -> list: Given multiple test cases, process each one to find the result. >>> process_test_cases([\\"152\\", \\"1001\\", \\"10\\"]) [52, 101, 1] def main(input_lines: list): The main function that processes input and produces output. >>> main([\\"3\\", \\"152\\", \\"1001\\", \\"10\\"]) # prints 52, 101, 1","solution":"def max_number_after_deleting_one_digit(num_str): Given a string of digits, return the maximum number possible by deleting exactly one digit. max_number = 0 for i in range(len(num_str)): modified_number = int(num_str[:i] + num_str[i+1:]) max_number = max(max_number, modified_number) return max_number def process_test_cases(test_cases): Given multiple test cases, process each one to find the result. results = [] for num_str in test_cases: results.append(max_number_after_deleting_one_digit(num_str)) return results # The main function that processes input and produces output. def main(input_lines): t = int(input_lines[0]) test_cases = input_lines[1:t+1] results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def count_rectangular_arrangements(n: int) -> int: Returns the number of different rectangular arrangements possible using all n tiles. >>> count_rectangular_arrangements(6) 4 >>> count_rectangular_arrangements(4) 3 >>> count_rectangular_arrangements(12) 6 >>> count_rectangular_arrangements(17) 2 >>> count_rectangular_arrangements(20) 6 >>> count_rectangular_arrangements(27) 4 >>> count_rectangular_arrangements(36) 9","solution":"def count_rectangular_arrangements(n): Returns the number of different rectangular arrangements possible using all n tiles. count = 0 for i in range(1, int(n**0.5) + 1): if n % i == 0: if i * i == n: count += 1 else: count += 2 return count"},{"question":"def tribonacci(k: int) -> int: Calculate the kth number in the Tribenacci sequence. >>> tribonacci(0) 0 >>> tribonacci(1) 1 >>> tribonacci(2) 1 >>> tribonacci(4) 2 >>> tribonacci(5) 7 >>> tribonacci(6) 13 >>> tribonacci(9) 81 >>> tribonacci(30) 29249425","solution":"def tribonacci(k): Returns the kth number in the Tribenacci sequence. if k == 0: return 0 if k == 1 or k == 2: return 1 trib = [0, 1, 1] for i in range(3, k + 1): next_value = trib[-1] + trib[-2] + trib[-3] trib.append(next_value) return trib[k]"},{"question":"def min_jump_distance(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum value of d for which Konrad can reach the last stone from the first stone with the least number of jumps. >>> min_jump_distance(2, [(5, [1, 3, 6, 9, 12]), (4, [1, 4, 8, 12])]) [3, 4] >>> min_jump_distance(1, [(3, [1, 4, 7])]) [3] >>> min_jump_distance(1, [(5, [1, 2, 3, 4, 8])]) [4] >>> min_jump_distance(1, [(3, [5, 6, 10])]) [4] def process_input_output(raw_input: List[str]) -> None: Process the provided input in the specified format and print the corresponding outputs.","solution":"def min_jump_distance(t, test_cases): results = [] for case in test_cases: n, positions = case max_jump = 0 for i in range(1, n): max_jump = max(max_jump, positions[i] - positions[i - 1]) results.append(max_jump) return results # Function to process raw input and output accordingly def process_input_output(raw_input): index = 0 t = int(raw_input[index]) index += 1 test_cases = [] for _ in range(t): n = int(raw_input[index]) index += 1 positions = list(map(int, raw_input[index].split())) index += 1 test_cases.append((n, positions)) result = min_jump_distance(t, test_cases) for res in result: print(res)"},{"question":"def min_workers(projects: List[Tuple[int, int]]) -> int: Determines the minimum number of workers required to complete all projects. Parameters: projects (list of tuples): Each tuple contains the start and end times of a project. Returns: int: Minimum number of workers required. >>> min_workers([(1, 4), (2, 6), (8, 10)]) 2 >>> min_workers([(1, 5), (2, 3), (4, 6), (7, 8)]) 2 >>> min_workers([(1, 2), (3, 4), (5, 6)]) 1 >>> min_workers([(1, 4), (2, 5), (3, 6)]) 3 >>> min_workers([(1, 4), (2, 3), (5, 7), (6, 8)]) 2 >>> min_workers([(1, 4)]) 1 >>> min_workers([(1000000000, 2000000000), (1500000000, 2500000000), (2000000000, 3000000000)]) 2 >>> min_workers([(1, 5), (6, 10), (11, 15)]) 1","solution":"def min_workers(projects): Determines the minimum number of workers required to complete all projects. Parameters: projects (list of tuples): Each tuple contains the start and end times of a project. Returns: int: Minimum number of workers required. events = [] for s, e in projects: events.append((s, 1)) events.append((e, -1)) events.sort() current_workers = 0 max_workers = 0 for time, change in events: current_workers += change max_workers = max(max_workers, current_workers) return max_workers"},{"question":"def max_magic_sequence_power(n, k, stones): Returns the maximum power of the Magic Sequence that can be achieved by selecting exactly k consecutive stones. Parameters: n (int): Number of stones in a straight line. k (int): Number of stones to be selected consecutively. stones (list): List of integers representing the magic power values of the stones. Returns: int: Maximum power of the Magic Sequence. >>> max_magic_sequence_power(7, 3, [-1, 3, 4, -1, 2, 1, -5]) 6 >>> max_magic_sequence_power(1, 1, [100]) 100 >>> max_magic_sequence_power(5, 2, [1, 2, 3, 4, 5]) 9 >>> max_magic_sequence_power(5, 2, [-1, -2, -3, -4, -5]) -3 >>> max_magic_sequence_power(5, 3, [4, -1, 2, 1, -5]) 5 >>> max_magic_sequence_power(6, 6, [1, -3, 4, 5, -2, 6]) 11","solution":"def max_magic_sequence_power(n, k, stones): Returns the maximum power of the Magic Sequence that can be achieved by selecting exactly k consecutive stones. Parameters: n (int): Number of stones in a straight line. k (int): Number of stones to be selected consecutively. stones (list): List of integers representing the magic power values of the stones. Returns: int: Maximum power of the Magic Sequence. # Initial sum of the first 'k' stones current_sum = sum(stones[:k]) max_sum = current_sum for i in range(k, n): current_sum += stones[i] - stones[i - k] # Slide the window if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def largest_free_square(n: int, m: int, grid: List[str]) -> int: You are given a grid with dimensions n x m where each cell can either be free (represented by a '.') or blocked (represented by a '#'). You need to find the largest square sub-grid that consists entirely of free cells. Args: n: an integer representing the number of rows in the grid m: an integer representing the number of columns in the grid grid: a list of strings representing the grid, where each string is a row consisting of '.' and '#' characters Returns: An integer representing the side length of the largest square sub-grid consisting entirely of free cells. >>> largest_free_square(5, 6, [ ... \\"......\\", ... \\"....\\", ... \\"......\\", ... \\".#..#.\\", ... \\"..#.\\" ... ]) 2 >>> largest_free_square(5, 5, [ ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ]) 5 >>> largest_free_square(3, 5, [ ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ]) 0 >>> largest_free_square(3, 1, [ ... \\"#\\", ... \\".\\", ... \\"#\\" ... ]) 1 >>> largest_free_square(4, 4, [ ... \\".#..\\", ... \\"....\\", ... \\"#..#\\", ... \\"....\\" ... ]) 2 >>> largest_free_square(4, 8, [ ... \\".....#..\\", ... \\"...#....\\", ... \\".....#..\\", ... \\"........\\" ... ]) 3","solution":"def largest_free_square(n, m, grid): if n == 0 or m == 0: return 0 max_side = 0 dp = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if dp[i][j] > max_side: max_side = dp[i][j] return max_side"},{"question":"from typing import List, Tuple, Union def min_travel_time(n: int, m: int, s: int, t: int, roads: List[Tuple[int, int, int, int]], c: int) -> Union[int, str]: Calculate the minimum travel time between two intersections in a town, given the current time of day. :param n: Number of intersections. :param m: Number of roads. :param s: Starting intersection. :param t: Target intersection. :param roads: List of tuples containing information about the roads (u, v, l, z). :param c: Current hour of the day. :return: The minimum travel time between intersections s and t, or \\"IMPOSSIBLE\\" if no path exists. Example: >>> min_travel_time(5, 6, 1, 5, [(1, 2, 5, 3), (1, 3, 10, 14), (2, 4, 3, 3), (3, 5, 7, 14), (4, 5, 1, 3), (2, 3, 4, 3)], 3) 9 >>> min_travel_time(4, 4, 1, 4, [(1, 2, 5, 3), (2, 3, 4, 3), (3, 4, 6, 14), (1, 4, 12, 12)], 2) \\"IMPOSSIBLE\\" # Implement the function logic here pass def calculate_min_travel_time(n: int, m: int, s: int, t: int, roads: List[Tuple[int, int, int, int]], c: int) -> Union[int, str]: return min_travel_time(n, m, s, t, roads, c) # Example Unit Tests def test_min_travel_time_basic_case(): n = 5 m = 6 s = 1 t = 5 roads = [ (1, 2, 5, 3), (1, 3, 10, 14), (2, 4, 3, 3), (3, 5, 7, 14), (4, 5, 1, 3), (2, 3, 4, 3) ] c = 3 assert calculate_min_travel_time(n, m, s, t, roads, c) == 9 def test_min_travel_time_no_path(): n = 4 m = 4 s = 1 t = 4 roads = [ (1, 2, 5, 3), (2, 3, 4, 3), (3, 4, 6, 14), (1, 4, 12, 12) ] c = 2 # No roads are available at this time assert calculate_min_travel_time(n, m, s, t, roads, c) == \\"IMPOSSIBLE\\" def test_min_travel_time_direct_path(): n = 3 m = 2 s = 1 t = 3 roads = [ (1, 2, 10, 12), (2, 3, 5, 12), ] c = 12 assert calculate_min_travel_time(n, m, s, t, roads, c) == 15 def test_min_travel_time_indirect_path(): n = 5 m = 6 s = 1 t = 4 roads = [ (1, 2, 6, 2), (1, 3, 2, 2), (3, 4, 5, 2), (2, 3, 1, 2), (2, 4, 10, 3), (4, 5, 5, 3) ] c = 2 assert calculate_min_travel_time(n, m, s, t, roads, c) == 7 # Should use 1->3->4 def test_min_travel_time_large_values(): n = 1000 m = 1000 s = 1 t = 1000 roads = [(i, i + 1, 1, 24) for i in range(1, 1000)] roads.append((999, 1000, 1, 24)) c = 24 assert calculate_min_travel_time(n, m, s, t, roads, c) == 999","solution":"import heapq from collections import defaultdict, deque def min_travel_time(n, m, s, t, roads, c): # Graph representation graph = defaultdict(list) for u, v, l, z in roads: if z == c: # only consider roads available at the given time c graph[u].append((v, l)) graph[v].append((u, l)) # Dijkstra's algorithm to find the shortest path pq = [(0, s)] distances = {i: float('inf') for i in range(1, n + 1)} distances[s] = 0 visited = set() while pq: current_distance, current_intersection = heapq.heappop(pq) if current_intersection in visited: continue visited.add(current_intersection) for neighbor, length in graph[current_intersection]: distance = current_distance + length if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[t] if distances[t] != float('inf') else \\"IMPOSSIBLE\\" # Function to be called with inputs def calculate_min_travel_time(n, m, s, t, roads, c): return min_travel_time(n, m, s, t, roads, c)"},{"question":"def num_squares(n: int) -> int: Returns the minimum number of perfect squares that sum up to n. >>> num_squares(12) 3 >>> num_squares(13) 2 >>> num_squares(1) 1 >>> num_squares(2) 2 >>> num_squares(3) 3 >>> num_squares(4) 1 >>> num_squares(17) 2 >>> num_squares(26) 2 >>> num_squares(10000) 1","solution":"def num_squares(n): Returns the minimum number of perfect squares that sum up to n. if n <= 0: return 0 # Create an array dp where dp[i] represents the minimum # number of perfect squares sum needed to achieve sum i dp = [float('inf')] * (n + 1) dp[0] = 0 # Loop to fill the array for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"def generate_max_ab_string(a: int, b: int) -> str: Generates a string of 'A' and 'B' such that the number of subsequences \\"AB\\" is maximized. Args: a (int): Number of 'A' characters. b (int): Number of 'B' characters. Returns: str: The generated string. >>> generate_max_ab_string(3, 3) 'AAABBB' >>> generate_max_ab_string(5, 2) 'AAAAABB' >>> generate_max_ab_string(2, 5) 'AABBBBB' >>> len(generate_max_ab_string(100000, 100000)) 200000 >>> generate_max_ab_string(1, 1) 'AB'","solution":"def generate_max_ab_string(a, b): Generates a string of 'A' and 'B' such that the number of subsequences \\"AB\\" is maximized. # The maximum number of \\"AB\\" subsequences is achieved by placing all 'A's first, followed by all 'B's. return 'A' * a + 'B' * b # Example input a, b = 3, 3 print(generate_max_ab_string(a, b)) # Expected output: \\"AAABBB\\""},{"question":"def find_schedule(n: int, k: int, a: int, b: int, difficulties: list) -> (str, list): Determine if Fedor can schedule his problem-solving sessions under the given constraints. Parameters: n (int): Total number of problems. k (int): Maximum number of problems Fedor can solve each day. a (int): Minimum total difficulty Fedor should solve each day. b (int): Maximum total difficulty Fedor can solve each day. difficulties (list): List of integers representing difficulty levels of problems. Returns: tuple: (\\"Yes\\", list) if a schedule is possible, otherwise \\"No\\". >>> find_schedule(5, 2, 3, 8, [1, 2, 3, 4, 5]) ('Yes', [2, 2, 1]) >>> find_schedule(5, 2, 10, 15, [1, 2, 3, 4, 5]) 'No'","solution":"def find_schedule(n, k, a, b, difficulties): difficulties.sort() schedule = [] current_day_problems = [] current_day_sum = 0 for difficulty in difficulties: if len(current_day_problems) < k and current_day_sum + difficulty <= b: current_day_problems.append(difficulty) current_day_sum += difficulty else: if len(current_day_problems) == 0 or current_day_sum < a: return \\"No\\" schedule.append(len(current_day_problems)) current_day_problems = [difficulty] current_day_sum = difficulty if current_day_sum > b: return \\"No\\" if current_day_sum < a or current_day_sum > b: return \\"No\\" else: schedule.append(len(current_day_problems)) return \\"Yes\\", schedule # Example usage: # print(find_schedule(5, 2, 3, 8, [1, 2, 3, 4, 5]))"},{"question":"from typing import List def min_bags_needed(k: int, quantities: List[int], bag_sizes_list: List[List[int]]) -> List[int]: Determine the minimum number of bags needed for each ingredient based on the given recipe and available bag sizes. >>> min_bags_needed(2, [5, 8], [[3, 5], [1, 3, 5]]) [1, 2] >>> min_bags_needed(3, [7, 10, 15], [[3, 5], [2, 3, 5], [1, 2]]) [-1, 2, 8] >>> min_bags_needed(1, [12], [[4, 6]]) [2] >>> min_bags_needed(1, [1], [[1]]) [1] >>> min_bags_needed(1, [100], [[10, 20, 50]]) [2] pass","solution":"from itertools import combinations_with_replacement import math def min_bags_needed(k, quantities, bag_sizes_list): results = [] for i in range(k): quantity = quantities[i] bag_sizes = bag_sizes_list[i] min_bags = float('inf') found = False # Try combinations with replacement of bags of different sizes to get required quantity for size in range(1, math.ceil(quantity/min(bag_sizes)) + 1): for combo in combinations_with_replacement(bag_sizes, size): if sum(combo) == quantity: min_bags = min(min_bags, size) found = True if found: results.append(min_bags) else: results.append(-1) return results"},{"question":"def longest_beautiful_subarray(n: int, k: int, arr: List[int]) -> int: Given an array of integers \`arr\` consisting of \`n\` elements, this function finds the length of the longest subarray with at most \`k\` different integers. >>> longest_beautiful_subarray(7, 2, [1, 2, 1, 2, 3, 4, 1]) == 4 >>> longest_beautiful_subarray(5, 1, [1, 2, 2, 2, 3]) == 3 >>> longest_beautiful_subarray(4, 2, [1, 2, 3, 3]) == 3 >>> longest_beautiful_subarray(8, 3, [1, 2, 3, 1, 2, 1, 2, 3]) == 8 >>> longest_beautiful_subarray(6, 0, [1, 1, 1, 1, 1, 1]) == 0","solution":"def longest_beautiful_subarray(n, k, arr): Given an array of integers \`arr\` consisting of \`n\` elements, this function finds the length of the longest subarray with at most \`k\` different integers. from collections import defaultdict left = 0 max_len = 0 freq = defaultdict(int) distinct_count = 0 for right in range(n): if freq[arr[right]] == 0: distinct_count += 1 freq[arr[right]] += 1 while distinct_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: distinct_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len # Example usage: # n = 7 # k = 2 # arr = [1, 2, 1, 2, 3, 4, 1] # print(longest_beautiful_subarray(n, k, arr)) # Output: 4"},{"question":"def longest_ap_subarray_length(arr: List[int]) -> int: Returns the length of the longest contiguous subarray that forms a subsegment of an arithmetic progression. >>> longest_ap_subarray_length([1]) == 1 >>> longest_ap_subarray_length([1, 3]) == 2 >>> longest_ap_subarray_length([4, 4, 4, 4]) == 4 >>> longest_ap_subarray_length([10, 7, 4, 6, 8, 10]) == 4 >>> longest_ap_subarray_length([1, 3, 5, 7, 9, 2, 4, 6, 8]) == 5 >>> longest_ap_subarray_length([1, 2, 1, 2, 1, 2, 1]) == 2 >>> longest_ap_subarray_length([1, 2, 3, 4, 1, 2, 3]) == 4","solution":"def longest_ap_subarray_length(arr): Returns the length of the longest contiguous subarray that forms a subsegment of an arithmetic progression. n = len(arr) if n <= 1: return n max_length = 1 current_length = 1 current_diff = float('inf') for i in range(1, n): diff = arr[i] - arr[i-1] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 2 max_length = max(max_length, current_length) return max_length"},{"question":"def find_duplicate(nums: List[int]) -> int: Finds the duplicate number in the array. >>> find_duplicate([1, 3, 4, 2, 2]) == 2 >>> find_duplicate([3, 1, 3, 4, 2]) == 3 >>> find_duplicate([1, 4, 4, 3, 2]) == 4 >>> find_duplicate([1, 2, 3, 4, 5, 1]) == 1 >>> find_duplicate([1, 2, 3, 4, 5, 6, 5]) == 5 >>> find_duplicate([3, 1, 2, 3]) == 3 >>> find_duplicate([2, 2, 1, 3]) == 2 >>> find_duplicate(list(range(1, 100001)) + [50000]) == 50000","solution":"def find_duplicate(nums): Finds the duplicate number in the array. n = len(nums) # Using the \\"Floyd's Tortoise and Hare\\" (Cycle Detection) approach tortoise = nums[0] hare = nums[0] # Phase 1: Finding the intersection point of the two runners while True: tortoise = nums[tortoise] hare = nums[nums[hare]] if tortoise == hare: break # Phase 2: Finding the entrance to the cycle tortoise = nums[0] while tortoise != hare: tortoise = nums[tortoise] hare = nums[hare] return hare"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements equal in each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case consists of an integer and a list of integers. Returns: List[int]: A list containing the result for each test case. Example: >>> min_operations_to_equal_elements(3, [(5, [1, 2, 3, 4, 5]), (6, [8, 8, 4, 4, 8, 4]), (4, [7, 7, 7, 7])]) [4, 3, 0] from typing import List, Tuple def test_min_operations_to_equal_elements(): t = 3 test_cases = [ (5, [1, 2, 3, 4, 5]), (6, [8, 8, 4, 4, 8, 4]), (4, [7, 7, 7, 7]) ] expected_output = [4, 3, 0] assert min_operations_to_equal_elements(t, test_cases) == expected_output def test_single_test_case_all_unique(): t = 1 test_cases = [ (4, [1, 2, 3, 4]) ] expected_output = [3] assert min_operations_to_equal_elements(t, test_cases) == expected_output def test_single_test_case_one_repeated(): t = 1 test_cases = [ (5, [5, 5, 5, 5, 5]) ] expected_output = [0] assert min_operations_to_equal_elements(t, test_cases) == expected_output def test_large_array(): t = 1 test_cases = [ (100000, [1] * 100000) ] expected_output = [0] assert min_operations_to_equal_elements(t, test_cases) == expected_output def test_large_array_mostly_unique(): t = 1 test_cases = [ (100000, list(range(2, 100001)) + [1]) ] expected_output = [99999] assert min_operations_to_equal_elements(t, test_cases) == expected_output","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] frequency = {} for num in a: frequency[num] = frequency.get(num, 0) + 1 max_freq = max(frequency.values()) results.append(n - max_freq) return results"},{"question":"def collatz_steps(n: int) -> int: Returns the number of steps required for n to reach 1 in the Collatz sequence. >>> collatz_steps(6) 8 >>> collatz_steps(19) 20 >>> collatz_steps(27) 111 pass def process_collatz(test_cases: List[int]) -> List[int]: Given a list of integers, returns the number of steps for each integer to reach 1 in the Collatz sequence. >>> process_collatz([6, 19, 27]) [8, 20, 111] >>> process_collatz([2, 3, 4, 5]) [1, 7, 2, 5] pass","solution":"def collatz_steps(n): Returns the number of steps required for n to reach 1 in the Collatz sequence. steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 steps += 1 return steps def process_collatz(test_cases): Given a list of integers, returns the number of steps for each integer to reach 1 in the Collatz sequence. results = [] for n in test_cases: results.append(collatz_steps(n)) return results"},{"question":"def range_update(n: int, q: int, arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Apply multiple range update operations to an array. >>> range_update(5, 3, [1, 2, 3, 4, 5], [(1, 3, 10), (2, 4, -2), (3, 5, 7)]) [11, 10, 18, 9, 12] >>> range_update(3, 0, [1, 2, 3], []) [1, 2, 3] >>> range_update(1, 1, [42], [(1, 1, 5)]) [47] >>> range_update(4, 1, [1, 2, 3, 4], [(1, 4, 3)]) [4, 5, 6, 7] >>> range_update(3, 2, [10, 20, 30], [(1, 2, -10), (2, 3, -5)]) [0, 5, 25]","solution":"def range_update(n, q, arr, operations): # Apply each operation to the array for op in operations: l, r, v = op for i in range(l-1, r): arr[i] += v return arr"},{"question":"from typing import List def generate_smallest_stats(n: int, minStats: List[int], maxStats: List[int]) -> List[int]: Generate the lexicographically smallest stats for each position within the given minStats and maxStats ranges. >>> generate_smallest_stats(3, [1, 4, 3], [5, 6, 9]) [1, 4, 3] >>> generate_smallest_stats(5, [2, 1, 4, 3, 7], [8, 6, 9, 5, 10]) [2, 1, 4, 3, 7] result = [] for i in range(n): result.append(minStats[i]) return result def test_generate_smallest_stats(): # Test case where n = 3 assert generate_smallest_stats(3, [1, 4, 3], [5, 6, 9]) == [1, 4, 3] # Test case where n = 5 and arrays have multiple values (random test case) assert generate_smallest_stats(5, [2, 1, 4, 3, 7], [8, 6, 9, 5, 10]) == [2, 1, 4, 3, 7] # Test case where n = 1 with smallest possible range assert generate_smallest_stats(1, [1], [1]) == [1] # Test case where n = 2 with min and max values differing assert generate_smallest_stats(2, [2, 3], [4, 5]) == [2, 3] # Test case where minStats and maxStats contain large values assert generate_smallest_stats(3, [100, 200, 300], [1000, 2000, 3000]) == [100, 200, 300] # Edge case where minStats and maxStats start high but minStats is still taken assert generate_smallest_stats(4, [9, 8, 7, 6], [10, 9, 8, 7]) == [9, 8, 7, 6]","solution":"def generate_smallest_stats(n, minStats, maxStats): Generate the lexicographically smallest stats for each position within the given minStats and maxStats ranges. result = [] for i in range(n): result.append(minStats[i]) return result"},{"question":"def find_minimum_roads_to_connect_villages(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads that should be added or repaired to make the supply routes uninterrupted. Parameters: n (int): Number of villages m (int): Number of roads roads (List[Tuple[int,int]]): List of tuples representing the roads between villages Returns: int: Minimum number of roads to be added/repaired or -1 if it's impossible to connect all villages. >>> find_minimum_roads_to_connect_villages(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> find_minimum_roads_to_connect_villages(5, 0, []) -1 >>> find_minimum_roads_to_connect_villages(1, 0, []) 0 >>> find_minimum_roads_to_connect_villages(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 0 >>> find_minimum_roads_to_connect_villages(6, 3, [(1, 2), (3, 4), (5, 6)]) 2 >>> find_minimum_roads_to_connect_villages(3, 0, []) 2 from collections import defaultdict, deque def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 0 # Create adjacency list from the list of roads adjacency_list = defaultdict(list) for u, v in roads: adjacency_list[u].append(v) adjacency_list[v].append(u) # Check how many connected components there are visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited) components += 1 # If number of components is greater than one, we need (components - 1) roads to connect them if components == 1: return 0 return components - 1","solution":"def find_minimum_roads_to_connect_villages(n, m, roads): from collections import defaultdict, deque def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 1: return 0 # Create adjacency list from the list of roads adjacency_list = defaultdict(list) for u, v in roads: adjacency_list[u].append(v) adjacency_list[v].append(u) # Check how many connected components there are visited = [False] * (n + 1) components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i, visited) components += 1 # If number of components is greater than one, we need (components - 1) roads to connect them if components == 1: return 0 return components - 1"},{"question":"def max_effort(n, m, exercises): This function takes the number of exercises n, the duration of workout in minutes m, and a list of exercises where each exercise is represented as a tuple of (type, effort, duration). It returns the maximum effort that can be achieved within the given workout duration. pass # Example usage and test cases def test_sample_case(): exercises = [ (\\"strength\\", 50, 30), (\\"cardio\\", 30, 20), (\\"combined\\", 70, 40), (\\"strength\\", 60, 50) ] assert max_effort(4, 60, exercises) == 100 def test_combined_exercise_only(): exercises = [ (\\"combined\\", 100, 40), (\\"strength\\", 50, 50), (\\"cardio\\", 30, 30), (\\"combined\\", 20, 20) ] assert max_effort(4, 40, exercises) == 100 def test_all_types_combined(): exercises = [ (\\"strength\\", 60, 30), (\\"cardio\\", 40, 20), (\\"combined\\", 50, 10), (\\"combined\\", 30, 30) ] assert max_effort(4, 60, exercises) == 150 def test_exact_time_fit(): exercises = [ (\\"strength\\", 50, 30), (\\"cardio\\", 30, 20), (\\"combined\\", 70, 10), (\\"strength\\", 60, 50) ] assert max_effort(4, 60, exercises) == 150 def test_not_enough_time(): exercises = [ (\\"strength\\", 100, 100), (\\"cardio\\", 50, 50) ] assert max_effort(2, 45, exercises) == 0","solution":"def max_effort(n, m, exercises): This function takes the number of exercises n, the duration of workout in minutes m, and a list of exercises where each exercise is represented as a tuple of (type, effort, duration). It returns the maximum effort that can be achieved within the given workout duration. # Sort exercises based on effort to duration ratio in descending order exercises.sort(key=lambda x: x[1] / x[2], reverse=True) total_time = 0 total_effort = 0 for e_type, effort, duration in exercises: if total_time + duration <= m: total_time += duration total_effort += effort if total_time == m: break return total_effort"},{"question":"def can_reach_bottom_right(n: int, m: int, h: int, grid: List[List[int]]) -> None: Determine if a robot can traverse a grid from the top-left to the bottom-right. The robot starts with an initial height h, and it cannot move to a cell with a height greater than its current cell's height. The robot can only move right (R) or down (D). Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. h (int): Initial height constraint of the robot. grid (List[List[int]]): A 2D list representing the grid heights. Outputs: Prints \\"YES\\" followed by the path taken as a sequence of movements ('R' for right and 'D' for down), or \\"NO\\" if it is not possible to reach the bottom-right corner. Example: >>> grid1 = [ ... [1, 2, 3], ... [2, 2, 2], ... [3, 2, 1] ... ] >>> can_reach_bottom_right(3, 3, 2, grid1) YES RDRD >>> grid2 = [ ... [3, 4, 5], ... [2, 4, 6], ... [1, 2, 0] ... ] >>> can_reach_bottom_right(3, 3, 3, grid2) NO","solution":"def can_reach_bottom_right(n, m, h, grid): # Helper function to check if position (x, y) is within grid bounds and the height constraints. def is_valid(x, y, current_height): return 0 <= x < n and 0 <= y < m and current_height >= grid[x][y] # Use DFS to find a path def dfs(x, y, current_height, path): if not is_valid(x, y, current_height): return False # If reached bottom-right corner if x == n - 1 and y == m - 1: return True # Move Right (R) or Down (D) if x + 1 < n and is_valid(x + 1, y, grid[x][y]): if dfs(x + 1, y, grid[x][y], path): path.append('D') return True if y + 1 < m and is_valid(x, y + 1, grid[x][y]): if dfs(x, y + 1, grid[x][y], path): path.append('R') return True return False path = [] if dfs(0, 0, h, path): print(\\"YES\\") print(''.join(path[::-1])) else: print(\\"NO\\") # Example usage: # grid = [ # [1, 2, 3], # [2, 2, 2], # [3, 2, 1] # ] # can_reach_bottom_right(3, 3, 2, grid)"},{"question":"def find_majority_element(n: int, arr: List[int]) -> int: Find a single integer t that is present in an array arr of integers more than n // 2 times. Parameters ---------- n: int The number of elements in the array (1 ≤ n ≤ 50,000). arr: List[int] The array of integers where each integer is in the range [-10^9, 10^9]. Returns ------- int The integer t which is present more than n // 2 times. Examples -------- >>> find_majority_element(7, [2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element(1, [1]) 1 >>> find_majority_element(5, [7, 7, 7, 7, 7]) 7 >>> find_majority_element(9, [3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element(5, [-1, -1, -1, 2, 2]) -1","solution":"def find_majority_element(n, arr): Finds the integer that appears more than n // 2 times in the given array. Parameters: n (int): The number of elements in the array. arr (list): The array of integers. Returns: int: The majority element. count = 0 candidate = None for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def trap_water(heights: List[int]) -> int: Calculate the total amount of water that can be trapped between the buildings represented by the heights array. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([1, 1, 1, 1]) 0 >>> trap_water([]) 0 >>> trap_water([4]) 0 >>> trap_water([5, 2]) 0 >>> trap_water([0, 0, 0, 0]) 0 >>> trap_water([4, 2, 0, 3, 2, 5]) 9","solution":"def trap_water(heights): Calculate the total amount of water that can be trapped between the buildings represented by the heights array. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def largest_good_string_length(n: int, s: str) -> int: Returns the largest possible length of a good string that can be obtained from the given string. A good string is one where every letter appears at most twice consecutively. >>> largest_good_string_length(7, \\"aaabaaa\\") == 5 >>> largest_good_string_length(5, \\"abcde\\") == 5 >>> largest_good_string_length(10, \\"aaaaaaaaaa\\") == 2 >>> largest_good_string_length(6, \\"aabbcc\\") == 6 >>> largest_good_string_length(1, \\"a\\") == 1 >>> largest_good_string_length(8, \\"aabbaabb\\") == 8 >>> largest_good_string_length(9, \\"aaabbbccc\\") == 6","solution":"def largest_good_string_length(n, s): Returns the largest possible length of a good string that can be obtained from the given string. A good string is one where every letter appears at most twice consecutively. if n == 0: return 0 result_length = 0 i = 0 while i < n: count = 1 while i + 1 < n and s[i] == s[i + 1]: count += 1 i += 1 result_length += min(count, 2) i += 1 return result_length"},{"question":"def highest_score(n: int) -> int: Determine the highest possible score that Alice can achieve, given n. >>> highest_score(1) 0 >>> highest_score(2) 40 >>> highest_score(3) 80 >>> highest_score(4) 120 >>> highest_score(100000) 3999960","solution":"def highest_score(n): Returns the highest possible score that Alice can achieve given n. if n == 1: return 0 return (n - 1) * 40"},{"question":"def longest_palindromic_subsequence(dna_sequence: str) -> int: Find the length of the longest palindromic subsequence in the given DNA sequence. >>> longest_palindromic_subsequence(\\"ATCGCGA\\") 5 >>> longest_palindromic_subsequence(\\"AAAA\\") 4","solution":"def longest_palindromic_subsequence(dna_sequence): n = len(dna_sequence) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if dna_sequence[i] == dna_sequence[j] and cl == 2: dp[i][j] = 2 elif dna_sequence[i] == dna_sequence[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"def arrange_books(thicknesses): Arrange the books in an alternating up-and-down pattern minimizing the difference in thickness between any two consecutive books. pass # Unit Test def test_arrange_books(): assert arrange_books([4, 1, 7, 3, 6]) in [ [1, 7, 3, 6, 4], [1, 6, 3, 7, 4], [1, 4, 3, 6, 7], [1, 4, 3, 7, 6] ] assert arrange_books([5, 2, 8, 7, 1, 9]) in [ [1, 9, 2, 8, 5, 7], [1, 7, 2, 8, 5, 9], [1, 9, 2, 7, 5, 8] ] assert arrange_books([1, 2, 3, 4, 5]) in [ [1, 5, 2, 4, 3], [1, 5, 2, 4, 3] ] assert arrange_books([10, 20, 30, 40, 50, 60, 70, 80]) in [ [10, 80, 20, 70, 30, 60, 40, 50] ] assert arrange_books([2, 2, 3, 3, 4, 4]) in [ [2, 4, 2, 4, 3, 3] ] def test_single_book_pair(): assert arrange_books([4, 1]) == [1, 4] assert arrange_books([7, 2]) == [2, 7] def test_identical_books(): assert arrange_books([3, 3, 3]) == [3, 3, 3] assert arrange_books([5, 5, 5, 5]) == [5, 5, 5, 5]","solution":"def arrange_books(thicknesses): Arrange the books in an alternating up-and-down pattern minimizing the difference in thickness between any two consecutive books. # Sort the thicknesses sorted_thicknesses = sorted(thicknesses) # Create the up-down pattern result = [] i, j = 0, len(thicknesses) - 1 while i <= j: if i == j: result.append(sorted_thicknesses[i]) else: result.append(sorted_thicknesses[i]) result.append(sorted_thicknesses[j]) i += 1 j -= 1 return result"},{"question":"def can_be_sorted_with_one_shift(n, a): Given a list of integers 'a' with length 'n', determine if it's possible to sort it by shifting each integer no more than once. Example: >>> can_be_sorted_with_one_shift(6, [4, 6, 0, 2, 5, 1]) 'YES' >>> can_be_sorted_with_one_shift(5, [3, 2, 4, 5, 1]) 'NO'","solution":"def can_be_sorted_with_one_shift(n, a): Given a list of integers 'a' with length 'n', determine if it's possible to sort it by shifting each integer no more than once. def get_target_positions(n, a): return [(i + a[i]) % n for i in range(n)] target_positions = get_target_positions(n, a) # Check if we can shift each element up to one more position to get it sorted for i in range(n): for shift in range(2): # Try to shift 0 or 1 position extra new_positions = sorted([(pos + shift) % n for pos in target_positions]) if new_positions == list(range(n)): return \\"YES\\" return \\"NO\\""},{"question":"def shortest_subarray_with_sum_at_least_k(n: int, k: int, sequence: List[int]) -> int: Find the shortest subarray such that the sum of its elements is greater than or equal to a given integer k. Args: n: the length of the sequence k: the required sum sequence: the list of integers in the sequence Returns: int: the length of the shortest subarray with sum >= k, or -1 if no such subarray exists. >>> shortest_subarray_with_sum_at_least_k(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> shortest_subarray_with_sum_at_least_k(5, 100, [1, 2, 3, 4, 5]) -1 >>> shortest_subarray_with_sum_at_least_k(5, 3, [1, 2, 3, 4, 5]) 1 >>> shortest_subarray_with_sum_at_least_k(5, 15, [1, 2, 3, 4, 5]) 5 >>> shortest_subarray_with_sum_at_least_k(6, 11, [1, 4, 45, 6, 10, 19]) 1 >>> shortest_subarray_with_sum_at_least_k(6, 100, [1, 2, 3, 4, 5, 6]) -1","solution":"def shortest_subarray_with_sum_at_least_k(n, k, sequence): from collections import deque min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += sequence[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= sequence[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def largest_possible_park(grid: List[List[int]]) -> int: Given a city's grid map, find the largest possible side length of a square park that can be placed on the grid without overlapping any buildings. >>> largest_possible_park([ ... [0, 0, 1, 0, 0], ... [0, 0, 1, 0, 0], ... [1, 1, 1, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 2 >>> largest_possible_park([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == -1 >>> largest_possible_park([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 4","solution":"def largest_possible_park(grid): n = len(grid) m = len(grid[0]) # Create a dynamic programming table to keep track of the largest square ending at (i, j) dp = [[0]*m for _ in range(n)] max_side_length = 0 # Fill the dp table for i in range(n): for j in range(m): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) if max_side_length == 0: return -1 return max_side_length"},{"question":"def min_number_of_subsets(n: int, k: int, nums: List[int]) -> int: Divide the set into the minimum number of subsets such that the sum of the numbers in each subset is at most k. >>> min_number_of_subsets(5, 10, [1, 2, 3, 4, 5]) 2 >>> min_number_of_subsets(1, 10, [5]) 1 >>> min_number_of_subsets(4, 10, [2, 2, 2, 2]) 1 >>> min_number_of_subsets(5, 5, [5, 5, 5, 5, 5]) 5 >>> min_number_of_subsets(4, 7, [2, 3, 5, 1]) 2 >>> min_number_of_subsets(3, 10, [8, 1, 1]) 1","solution":"def min_number_of_subsets(n, k, nums): nums.sort(reverse=True) subsets = [] for num in nums: placed = False for subset in subsets: if sum(subset) + num <= k: subset.append(num) placed = True break if not placed: subsets.append([num]) return len(subsets)"},{"question":"def total_matches(m: int) -> int: Returns the total number of unique matches to be played in the tournament with m players. The formula for the total number of unique matches in a round-robin tournament is given by m * (m - 1) / 2. pass # Test Cases def test_total_matches(): assert total_matches(4) == 6 assert total_matches(5) == 10 assert total_matches(2) == 1 assert total_matches(3) == 3 assert total_matches(9999) == 49985001 assert total_matches(10000) == 49995000","solution":"def total_matches(m): Returns the total number of unique matches to be played in the tournament with m players. The formula for the total number of unique matches in a round-robin tournament is given by m * (m - 1) / 2. return (m * (m - 1)) // 2"},{"question":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the original array except the one at that position. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([1, 0]) [0, 1] >>> product_except_self([0, 0]) [0, 0] >>> product_except_self([3]) [1] >>> product_except_self([3, 2, 1, 0]) [0, 0, 0, 6] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900] >>> product_except_self([5, 1, 4, 3, 2]) [24, 120, 30, 40, 60]","solution":"def product_except_self(nums): Returns an array where each element is the product of all the elements in the original array except the one at that position. n = len(nums) if n == 0: return [] products = [1] * n # Calculate left-side products of each element left_product = 1 for i in range(n): products[i] = left_product left_product *= nums[i] # Calculate right-side products of each element and multiply with existing left-side product right_product = 1 for i in range(n-1, -1, -1): products[i] *= right_product right_product *= nums[i] return products"},{"question":"from typing import List def min_moves_to_treasure(n: int, m: int, grid: List[str], sr: int, sc: int) -> int: Determine the minimum number of moves required to reach the treasure from the starting position in the grid. Args: n : int : Number of rows in the grid m : int : Number of columns in the grid grid : List[str] : Grid representing the map sr : int : Starting row position sc : int : Starting column position Returns: int : Minimum number of moves to reach the treasure or -1 if impossible. >>> n = 5 >>> m = 5 >>> grid = [\\"EEEET\\", \\"EEOEE\\", \\"EOOEE\\", \\"EEEEE\\", \\"EEEET\\"] >>> sr, sc = 0, 0 >>> min_moves_to_treasure(n, m, grid, sr, sc) 4 >>> n = 3 >>> m = 3 >>> grid = [\\"EEE\\", \\"EOE\\", \\"EEE\\"] >>> sr, sc = 0, 0 >>> min_moves_to_treasure(n, m, grid, sr, sc) -1 >>> n = 3 >>> m = 3 >>> grid = [\\"ETT\\", \\"OOO\\", \\"EEE\\"] >>> sr, sc = 2, 2 >>> min_moves_to_treasure(n, m, grid, sr, sc) -1 >>> n = 4 >>> m = 5 >>> grid = [\\"EEEEE\\", \\"EOOEE\\", \\"ETEEE\\", \\"EEEET\\"] >>> sr, sc = 0, 0 >>> min_moves_to_treasure(n, m, grid, sr, sc) 3 >>> n = 4 >>> m = 5 >>> grid = [\\"ETEEE\\", \\"EOOEE\\", \\"EEEEE\\", \\"EEEET\\"] >>> sr, sc = 0, 1 >>> min_moves_to_treasure(n, m, grid, sr, sc) 0","solution":"from collections import deque def min_moves_to_treasure(n, m, grid, sr, sc): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(sr, sc, 0)]) visited = set((sr, sc)) while queue: r, c, dist = queue.popleft() if grid[r][c] == 'T': return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] != 'O': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def max_flower_shop_length(n: int, heights: List[int]) -> int: Determine the maximum length for the flower shop such that there are buildings of different heights on either side. :param n: Integer, the number of buildings. :param heights: List of integers, the heights of the buildings. :return: Integer, the maximum possible length from left to right for the flower shop location or -1 if no such location exists. >>> max_flower_shop_length(7, [3, 1, 4, 1, 5, 9, 2]) 5 >>> max_flower_shop_length(5, [1, 1, 1, 1, 1]) -1 >>> max_flower_shop_length(2, [1, 2]) 1","solution":"def max_flower_shop_length(n, heights): Determine the maximum length for the flower shop such that there are buildings of different heights on either side. :param n: Integer, the number of buildings. :param heights: List of integers, the heights of the buildings. :return: Integer, the maximum possible length from left to right for the flower shop location or -1 if no such location exists. for i in range(1, n): if heights[i] != heights[i - 1]: max_length = n - 1 break else: return -1 return max_length"},{"question":"def handle_operations(n: int, q: int, operations: List[str]) -> List[int]: Keep track of the total number of packages to be delivered at each checkpoint. Operations can include adding, removing packages, prioritizing, and querying the packages. Args: n (int): Number of checkpoints. q (int): Number of operations. operations (List[str]): List of operations. Returns: List[int]: Number of packages at specified checkpoints after operations. Example: >>> handle_operations(5, 7, [\\"ADD 1 100\\", \\"ADD 2 50\\", \\"PRIOR 1\\", \\"REM 2 20\\", \\"QRY 1\\", \\"QRY 2\\", \\"QRY 3\\"]) [100, 30, 0]","solution":"def handle_operations(n, q, operations): # Initialize checkpoints checkpoints = [0] * (n + 1) # Store results for QRY operations results = [] for op in operations: parts = op.split() command = parts[0] x = int(parts[1]) if command == \\"ADD\\": y = int(parts[2]) checkpoints[x] += y elif command == \\"REM\\": y = int(parts[2]) checkpoints[x] -= y elif command == \\"PRIOR\\": # Just a placeholder for prioritizing, doesn't affect package counts pass elif command == \\"QRY\\": results.append(checkpoints[x]) return results"},{"question":"def top_k_participants(n, k, m, scores, prizes): Determine the identifiers of the top k participants and the total value of the prizes. Args: n (int): Number of participants. k (int): Number of top participants to be awarded. m (int): Total value of available prizes. scores (list): Scores of the participants. prizes (list): Values of the prizes available for distribution. Returns: list: A list of the identifiers of the top k participants in increasing order. int: The total value of the prizes distributed. Example: >>> top_k_participants(7, 3, 100, [30, 20, 50, 40, 10, 50, 40], [70, 20, 10]) ([3, 4, 6], 100) >>> top_k_participants(5, 2, 50, [10, 20, 30, 40, 50], [15, 35]) ([4, 5], 50)","solution":"def top_k_participants(n, k, m, scores, prizes): Determine the identifiers of the top k participants and the total value of the prizes. Args: n (int): Number of participants. k (int): Number of top participants to be awarded. m (int): Total value of available prizes. scores (list): Scores of the participants. prizes (list): Values of the prizes available for distribution. Returns: list: A list of the identifiers of the top k participants in increasing order. int: The total value of the prizes distributed. # Create a list of (id, score) tuples participants = [(i + 1, scores[i]) for i in range(n)] # Sort participants by score (descending) and then by id (ascending) sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) # Select the top k participants top_k = sorted_participants[:k] # Sort the top k participants by their IDs top_k_sorted_by_id = sorted(top_k, key=lambda x: x[0]) # Sort the available prizes in descending order sorted_prizes = sorted(prizes, reverse=True) # Calculate the total prize value distributed to the top k participants total_prize_value = sum(sorted_prizes[:k]) # Return the list of top k participant IDs and the total prize value return [participant[0] for participant in top_k_sorted_by_id], total_prize_value"},{"question":"def find_hamiltonian_path(n: int, adjacency_matrix: List[List[int]]) -> List[int]: Find a Hamiltonian path in a given tournament graph. Args: n (int): The number of vertices in the tournament graph. adjacency_matrix (List[List[int]]): The upper triangular part of the adjacency matrix of the tournament graph. Returns: List[int]: A list of integers representing the Hamiltonian path. Example: >>> find_hamiltonian_path(4, [[1, 0, 1], [1, 1], [0]]) [1, 3, 2, 4]","solution":"def find_hamiltonian_path(n, adjacency_matrix): def find_path(n, adj_matrix): path = list(range(1, n + 1)) for i in range(1, n): j = i while j > 0 and adj_matrix[path[j - 1] - 1][path[j] - 1] == 0: path[j - 1], path[j] = path[j], path[j - 1] j -= 1 return path # Convert the input upper triangular adjacency matrix to full adjacency matrix adj_matrix = [[0] * n for _ in range(n)] for i in range(n): k = 0 for j in range(i + 1, n): adj_matrix[i][j] = adjacency_matrix[i][k] adj_matrix[j][i] = 1 - adjacency_matrix[i][k] k += 1 return find_path(n, adj_matrix) # Example usage: # n = 4 # adjacency_matrix = [ # [1, 0, 1], # [1, 1], # [0] # ] # Resulting Hamiltonian Path example (one of the possible outputs): # Output: [1, 3, 2, 4]"},{"question":"def min_square_side_length(t: int, cases: List[str]) -> List[int]: Find the side length of the smallest square grid such that no two cells with the same color are adjacent vertically or horizontally. Parameters: t (int): the number of test cases. cases (List[str]): a list of strings, each string representing a test case with characters 'R', 'G', 'B', and '.'. Returns: List[int]: a list of integers, each representing the side length of the minimum-sized square grid for the corresponding test case. Example: >>> min_square_side_length(3, [\\"RRG\\", \\"BRG.\\", \\"RGBBR\\"]) [2, 2, 3] >>> min_square_side_length(1, [\\"R\\"]) [1]","solution":"import math def min_square_side_length(t, cases): results = [] for s in cases: n = len(s) min_side_length = math.ceil(math.sqrt(n)) results.append(min_side_length) return results # Function to read input and apply the algorithm def process_input(): t = int(input().strip()) cases = [input().strip() for _ in range(t)] results = min_square_side_length(t, cases) for result in results: print(result)"},{"question":"def can_achieve_distribution(n, k, d, initial_dist, target_dist): Determine if the desired cow distribution can be achieved within given constraints. Args: n (int): number of fields k (int): maximum number of moves per day d (int): number of days available initial_dist (list): initial number of cows in each field target_dist (list): target number of cows in each field Returns: str: \\"YES\\" if the desired distribution can be achieved, \\"NO\\" otherwise pass # Unit Test def test_can_achieve_distribution_case1(): # Input: 3 3 2, [1, 0, 1], [0, 2, 0] assert can_achieve_distribution(3, 3, 2, [1, 0, 1], [0, 2, 0]) == \\"YES\\" def test_can_achieve_distribution_case2(): # Input: 3 3 1, [1, 0, 1], [0, 2, 0] assert can_achieve_distribution(3, 3, 1, [1, 0, 1], [0, 2, 0]) == \\"NO\\" def test_can_achieve_distribution_case3(): # Input: 1 1 1, [1], [1] assert can_achieve_distribution(1, 1, 1, [1], [1]) == \\"YES\\" def test_can_achieve_distribution_case4(): # Input: 2 2 2, [3, 2], [2, 3] assert can_achieve_distribution(2, 2, 2, [3, 2], [2, 3]) == \\"YES\\" def test_can_achieve_distribution_case5(): # Input: 4 2 1, [1, 1, 1, 1], [2, 2, 0, 0] assert can_achieve_distribution(4, 2, 1, [1, 1, 1, 1], [2, 2, 0, 0]) == \\"NO\\" def test_can_achieve_distribution_case6(): # Edge case, large number of fields and big numbers n = 100000 k = 100000 d = 1000 initial_dist = [0] * n target_dist = [0] * n assert can_achieve_distribution(n, k, d, initial_dist, target_dist) == \\"YES\\"","solution":"def can_achieve_distribution(n, k, d, initial_dist, target_dist): Determine if the desired cow distribution can be achieved within given constraints. Args: n (int): number of fields k (int): maximum number of moves per day d (int): number of days available initial_dist (list): initial number of cows in each field target_dist (list): target number of cows in each field Returns: str: \\"YES\\" if the desired distribution can be achieved, \\"NO\\" otherwise total_initial_cows = sum(initial_dist) total_target_cows = sum(target_dist) if total_initial_cows != total_target_cows: return \\"NO\\" required_moves = sum(abs(initial_dist[i] - target_dist[i]) for i in range(n)) if required_moves <= k * d: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_increasing_subsequence(poles: List[int]) -> int: Returns the length of the longest strictly increasing sequence of poles. Example usage: >>> longest_increasing_subsequence([2, 5, 3, 7, 11, 8]) 4 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([5, 5, 5, 5, 5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 20, 10, 30, 20, 50]) 4 pass","solution":"def longest_increasing_subsequence(poles): Returns the length of the longest strictly increasing subsequence of poles. import bisect if not poles: return 0 lis = [] for height in poles: pos = bisect.bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis) # Example usage: n = 6 poles = [2, 5, 3, 7, 11, 8] print(longest_increasing_subsequence(poles)) # Output: 4"},{"question":"def number_of_ways(n: int, k: int, tree_locations: List[int]) -> int: Determine the number of ways to divide the area into exactly k sub-areas. Parameters: - n (int): Number of tree types - k (int): Number of sub-areas - tree_locations (List[int]): Number of different locations where each type of tree grows Returns: - int: Number of ways to divide the area into k sub-areas pass from solution import number_of_ways def test_number_of_ways_single_subarea(): assert number_of_ways(3, 1, [1, 2, 3]) == 3 def test_number_of_ways_two_subareas(): assert number_of_ways(3, 2, [1, 2, 3]) == 3 def test_number_of_ways_all_subareas(): assert number_of_ways(4, 4, [1, 2, 3, 4]) == 1 def test_number_of_ways_general_case(): assert number_of_ways(5, 3, [1, 2, 3, 4, 5]) == 10 def test_number_of_ways_more_varied_tree_counts(): assert number_of_ways(6, 2, [1, 1, 1, 1, 1, 6]) == 15 def test_number_of_ways_all_single_location(): assert number_of_ways(5, 1, [1, 1, 1, 1, 1]) == 5","solution":"def number_of_ways(n, k, tree_locations): Determine the number of ways to divide the area into exactly k sub-areas. Parameters: - n (int): Number of tree types - k (int): Number of sub-areas - tree_locations (List[int]): Number of different locations where each type of tree grows Returns: - int: Number of ways to divide the area into k sub-areas from math import comb return comb(n, k)"},{"question":"def is_reachable(grid: List[str]) -> str: Determine if it is possible to reach the bottom-right cell (n, m) starting from the top-left cell (1, 1) using the swaps and moves described. >>> is_reachable([\\"4 4\\", \\"....\\", \\"..#.\\", \\".#..\\", \\"....\\"]) \\"YES\\" >>> is_reachable([\\"3 3\\", \\".#.\\", \\"#\\", \\".#.\\"]) \\"NO\\" def solve(input_data: str) -> str: # Helper method to parse input lines = input_data.strip().split(\\"n\\") n, m = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return is_reachable(grid) def test_is_reachable(): assert solve(\\"4 4n....n..#.n.#..n....\\") == \\"YES\\" assert solve(\\"3 3n.#.n#n.#.\\") == \\"NO\\" assert solve(\\"1 1n.\\") == \\"YES\\" assert solve(\\"2 2n..n.#\\") == \\"NO\\" assert solve(\\"3 3n...n.#.n...\\") == \\"YES\\" assert solve(\\"3 4n....nn....\\") == \\"NO\\" if __name__ == '__main__': test_is_reachable() print(\\"All tests passed.\\")","solution":"def is_reachable(grid): from collections import deque n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" def in_bound(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def bfs(): queue = deque([(0, 0)]) visited = set((0, 0)) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if in_bound(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) # Try making a swap sx, sy = x + dx, y + dy if in_bound(nx, ny): for dx2, dy2 in directions: nsx, nsy = sx + dx2, sy + dy2 if (sx, sy) != (nx, ny) and in_bound(nsx, nsy): grid[sx][sy], grid[nsx][nsy] = grid[nsx][nsy], grid[sx][sy] if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) grid[sx][sy], grid[nsx][nsy] = grid[nsx][nsy], grid[sx][sy] return False return \\"YES\\" if bfs() else \\"NO\\" # Helper method to parse input def solve(input_data): lines = input_data.strip().split(\\"n\\") n, m = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return is_reachable(grid)"},{"question":"def sum_of_primes(n: int) -> int: Given an integer n, find the sum of all prime numbers less than or equal to n. >>> sum_of_primes(0) 0 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5 >>> sum_of_primes(4) 5 >>> sum_of_primes(6) 10 >>> sum_of_primes(10) 17","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n + 1, start): sieve[multiple] = False prime_sum = sum(index for index, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"def maximal_total_power(n: int, parent_nodes: List[int], power_levels: List[int]) -> int: Determine the maximal total power that can be concentrated in the root node. Given a magical tree with n nodes where each node is initially given a power level, determine the maximal total power that can be concentrated in the root node by optimally choosing which creatures should transfer their power to their parent. Args: n (int): The number of nodes in the tree. parent_nodes (List[int]): A list of n-1 integers where parent_nodes[i] is the parent node of node i+2. power_levels (List[int]): A list of n integers where power_levels[i] is the initial power level of node i+1. Returns: int: The maximal total power that can be concentrated in the root node. >>> maximal_total_power(5, [1, 1, 2, 2], [1, 2, 3, 4, 5]) 15 >>> maximal_total_power(1, [], [10]) 10 >>> maximal_total_power(2, [1], [1, 5]) 6 from solution import maximal_total_power def test_example_case(): assert maximal_total_power(5, [1, 1, 2, 2], [1, 2, 3, 4, 5]) == 15 def test_single_node(): assert maximal_total_power(1, [], [10]) == 10 def test_two_nodes(): assert maximal_total_power(2, [1], [1, 5]) == 6 def test_distribute_evenly(): assert maximal_total_power(3, [1, 1], [1, 2, 3]) == 6 def test_all_leaf_nodes(): n = 4 parent_nodes = [1, 1, 1] power_levels = [1, 2, 3, 4] assert maximal_total_power(n, parent_nodes, power_levels) == 10 def test_large_tree(): n = 6 parent_nodes = [1, 1, 1, 1, 1] power_levels = [5, 4, 3, 2, 1, 0] assert maximal_total_power(n, parent_nodes, power_levels) == 15","solution":"def maximal_total_power(n, parent_nodes, power_levels): parent_list = [0] * n for i in range(n-1): parent_list[i+1] = parent_nodes[i] - 1 max_power = power_levels[:] for i in range(n-1, 0, -1): parent = parent_list[i] max_power[parent] += max_power[i] return max_power[0] # Example usage n = 5 parent_nodes = [1, 1, 2, 2] power_levels = [1, 2, 3, 4, 5] print(maximal_total_power(n, parent_nodes, power_levels)) # Output: 15"},{"question":"def max_workshops(n, difficulties): Returns the maximum number of workshops that can be organized in strictly increasing difficulty order. Args: n (int): The number of available workshops. difficulties (List[int]): List of difficulty levels of the workshops. Returns: int: The maximum number of workshops in strictly increasing difficulty order. Examples: >>> max_workshops(4, [1, 2, 3, 4]) 4 >>> max_workshops(5, [3, 1, 4, 2, 5]) 5 >>> max_workshops(5, [5, 5, 5, 5, 5]) 1 >>> max_workshops(8, [10, 1, 2, 2, 3, 4, 9, 9]) 6 >>> max_workshops(1, [5]) 1 >>> max_workshops(0, []) 0","solution":"def max_workshops(n, difficulties): Returns the maximum number of workshops that can be organized in strictly increasing difficulty order. # Sort the list of difficulties difficulties.sort() # Initialize the count of maximum workshops max_count = 1 if n > 0 else 0 # Iterate through the sorted difficulties and count the maximum increasing sequence for i in range(1, n): if difficulties[i] > difficulties[i - 1]: max_count += 1 return max_count"},{"question":"def max_non_overlapping_events(n: int, time_slots: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping time slots during which participants can attend any sessions. Parameters: n (int): Number of participants. time_slots (List[Tuple[int, int]]): List of start and end times of available slots. Returns: int: Maximum number of non-overlapping time slots. Example: >>> max_non_overlapping_events(5, [(1, 3), (2, 4), (3, 5), (6, 8), (7, 9)]) 3 >>> max_non_overlapping_events(3, [(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_events(1, [(1, 2)]) 1 # Your code here from typing import List, Tuple def test_no_overlap(): assert max_non_overlapping_events(5, [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 5 def test_some_overlap(): assert max_non_overlapping_events(5, [(1, 3), (2, 4), (3, 5), (6, 8), (7, 9)]) == 3 def test_complete_overlap(): assert max_non_overlapping_events(3, [(1, 5), (2, 6), (3, 7)]) == 1 def test_all_overlap_at_end(): assert max_non_overlapping_events(4, [(1, 7), (2, 7), (3, 7), (4, 7)]) == 1 def test_single_event(): assert max_non_overlapping_events(1, [(1, 2)]) == 1 def test_no_events(): assert max_non_overlapping_events(0, []) == 0 def test_varied_durations(): assert max_non_overlapping_events(6, [(1, 2), (2, 4), (3, 5), (6, 9), (2, 3), (8, 10)]) == 4","solution":"def max_non_overlapping_events(n, time_slots): Finds the maximum number of non-overlapping time slots. Parameters: n (int): Number of participants time_slots (list of tuples): List of start and end times of available slots. Returns: int: Maximum number of non-overlapping time slots. # Sort the time slots based on the end time time_slots.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in time_slots: if start >= end_time: count += 1 end_time = end return count"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations required to make the string empty by removing palindromic substrings. >>> min_operations_to_empty_string(\\"abacaba\\") == 1 >>> min_operations_to_empty_string(\\"abcddcba\\") == 1 >>> min_operations_to_empty_string(\\"abcba\\") == 1","solution":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations required to make the string empty by removing palindromic substrings. def is_palindrome(x): return x == x[::-1] # Check if the string itself is a palindrome if is_palindrome(s): return 1 else: return 2 # Example usage: # n = 7 # s = \\"abacaba\\" # print(min_operations_to_empty_string(s)) # Output: 1 # n = 8 # s = \\"abcddcba\\" # print(min_operations_to_empty_string(s)) # Output: 1 # n = 5 # s = \\"abcba\\" # print(min_operations_to_empty_string(s)) # Output: 1"},{"question":"def find_mst(n, edges): This function finds the MST of a given graph using Kruskal's algorithm. Parameters: n (int): number of nodes. edges (list of tuples): each tuple (ui, vi, wi) represents a directed edge with a weight. Returns: (int, list of tuples): total weight of MST and list of edges in the MST, or -1 and an empty list if the MST can't be formed. Example usage: >>> find_mst(4, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (3, 4, 1), (4, 2, 3)]) (4, [(1, 2, 1), (3, 4, 1), (1, 3, 2)]) >>> find_mst(4, [(1, 2, 1), (3, 4, 1)]) (-1, []) def test_mst_connected_graph(): n = 4 edges = [(1, 2, 1), (1, 3, 2), (2, 3, 2), (3, 4, 1), (4, 2, 3)] mst_weight, mst_edges = find_mst(n, edges) assert mst_weight == 4 assert mst_edges == [(1, 2, 1), (3, 4, 1), (1, 3, 2)] def test_mst_disconnected_graph(): n = 4 edges = [(1, 2, 1), (3, 4, 1)] mst_weight, mst_edges = find_mst(n, edges) assert mst_weight == -1 assert mst_edges == [] def test_mst_single_edge(): n = 2 edges = [(1, 2, 1)] mst_weight, mst_edges = find_mst(n, edges) assert mst_weight == 1 assert mst_edges == [(1, 2, 1)] def test_mst_multiple_edges_same_weight(): n = 3 edges = [(1, 2, 1), (2, 3, 1), (1, 3, 1)] mst_weight, mst_edges = find_mst(n, edges) assert mst_weight == 2 assert sorted(mst_edges) == sorted([(1, 2, 1), (2, 3, 1)]) def test_mst_minimum_spanning_edges(): n = 5 edges = [(1, 2, 3), (1, 3, 1), (2, 3, 3), (2, 5, 6), (3, 4, 5), (4, 5, 2)] mst_weight, mst_edges = find_mst(n, edges) assert mst_weight == 11 assert sorted(mst_edges) == sorted([(1, 3, 1), (1, 2, 3), (4, 5, 2), (3, 4, 5)])","solution":"def find_mst(n, edges): This function finds the MST of a given graph using Kruskal's algorithm. Parameters: n (int): number of nodes. edges (list of tuples): each tuple (ui, vi, wi) represents a directed edge with a weight. Returns: (int, list of tuples): total weight of MST and list of edges in the MST. parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False edges.sort(key=lambda x: x[2]) mst_weight = 0 mst_edges = [] for u, v, w in edges: if union(u - 1, v - 1): mst_weight += w mst_edges.append((u, v, w)) if len(mst_edges) == n - 1: break if len(mst_edges) != n - 1: return -1, [] return mst_weight, mst_edges"},{"question":"def k_th_smallest(n: int, m: int, A: List[int], B: List[int], k: int) -> int: Merge two sorted sequences and find the k-th smallest element. Args: n(int): Length of sequence A. m(int): Length of sequence B. A(list of int): Sequence A consisting of n integers sorted in increasing order. B(list of int): Sequence B consisting of m integers sorted in increasing order. k(int): The position of the element to find in the merged sequence. Returns: int: The k-th smallest element in the merged sequence. pass # Test cases def test_sample_case(): assert k_th_smallest(5, 4, [1, 4, 7, 8, 10], [2, 3, 6, 9], 5) == 6 def test_case_k_is_first(): assert k_th_smallest(3, 3, [2, 3, 5], [1, 4, 6], 1) == 1 def test_case_k_is_last(): assert k_th_smallest(2, 2, [1, 4], [2, 5], 4) == 5 def test_large_elements(): assert k_th_smallest(2, 3, [100000000, 100000001], [99999998, 99999999, 100000002], 3) == 100000000 def test_case_with_duplicates_in_merged(): assert k_th_smallest(2, 2, [1, 3], [1, 2], 3) == 2 def test_edges_case_min_values(): assert k_th_smallest(1, 1, [1], [1], 1) == 1 def test_edges_case_max_values(): assert k_th_smallest(1, 1, [1000000000], [1000000000], 2) == 1000000000","solution":"def k_th_smallest(n, m, A, B, k): Merge two sorted sequences and find the k-th smallest element. Args: n(int): Length of sequence A. m(int): Length of sequence B. A(list of int): Sequence A consisting of n integers sorted in increasing order. B(list of int): Sequence B consisting of m integers sorted in increasing order. k(int): The position of the element to find in the merged sequence. Returns: int: The k-th smallest element in the merged sequence. merged_sequence = sorted(A + B) return merged_sequence[k - 1]"},{"question":"def find_max_segment_length_and_count(n: int, logs: List[int]) -> (int, int): A forest company company has a collection of different tree logs. Each log has a certain length. The company wants to cut the logs into segments of equal length such that they maximize the number of segments from each log and minimize the waste (parts of the logs that cannot be used). You are asked to help the company determine the maximum segment length they can use and how many segments of that length they can obtain in total from all logs. >>> find_max_segment_length_and_count(3, [8, 12, 16]) (4, 9) >>> find_max_segment_length_and_count(1, [10]) (10, 1) >>> find_max_segment_length_and_count(4, [15, 10, 25, 40]) (5, 18) >>> find_max_segment_length_and_count(3, [7, 11, 13]) (1, 31) >>> logs = [10**9] * 200000 >>> find_max_segment_length_and_count(200000, logs) (10**9, 200000)","solution":"def find_max_segment_length_and_count(n, logs): def count_segments(segment_length): return sum(log // segment_length for log in logs) def gcd(a, b): while b: a, b = b, a % b return a def min_gcd_length(for_debug=False): Return the gcd of logs lengths result = logs[0] for length in logs[1:]: result = gcd(result, length) if result == 1: break return result # Finding gcd of all the lengths max_segment_length = min_gcd_length() # Calculating the number of segments we can divide all logs into total_segments = count_segments(max_segment_length) return max_segment_length, total_segments"},{"question":"class LikeSystem: def __init__(self): Initialize a new LikeSystem. def like(self, postID, userID): Record a like for the given postID by the given userID. The user can only like the post once. def count(self, postID): Return the number of unique likes the post with the given postID has received. def process_operations(operations): Process a series of operations in the like system. Arguments: operations -- a list of operations where each operation is a string of the form: - \\"like postID userID\\" to record a like - \\"count postID\\" to return the number of unique likes Returns: A list of results for each \\"count\\" operation. Example: >>> operations = [ ... \\"like 1 100\\", ... \\"like 1 101\\", ... \\"like 1 102\\", ... \\"count 1\\", ... \\"like 1 100\\", ... \\"count 1\\", ... \\"like 2 200\\" ... ] >>> process_operations(operations) [3, 3] from solution import process_operations def test_process_operations(): operations = [ \\"like 1 100\\", \\"like 1 101\\", \\"like 1 102\\", \\"count 1\\", \\"like 1 100\\", \\"count 1\\", \\"like 2 200\\" ] result = process_operations(operations) assert result == [3, 3] def test_no_likes_yet(): operations = [ \\"count 1\\" ] result = process_operations(operations) assert result == [0] def test_only_likes(): operations = [ \\"like 1 100\\", \\"like 1 100\\", \\"like 2 200\\", \\"like 2 300\\", \\"like 2 200\\", ] result = process_operations(operations) assert result == [] def test_multiple_counts(): operations = [ \\"like 1 100\\", \\"like 1 101\\", \\"count 1\\", \\"like 1 102\\", \\"count 1\\", \\"like 1 100\\", \\"count 1\\" ] result = process_operations(operations) assert result == [2, 3, 3] def test_likes_on_multiple_posts(): operations = [ \\"like 1 101\\", \\"like 2 101\\", \\"like 1 102\\", \\"like 2 103\\", \\"count 1\\", \\"count 2\\" ] result = process_operations(operations) assert result == [2, 2]","solution":"class LikeSystem: def __init__(self): self.posts_likes = {} def like(self, postID, userID): if postID not in self.posts_likes: self.posts_likes[postID] = set() self.posts_likes[postID].add(userID) def count(self, postID): if postID in self.posts_likes: return len(self.posts_likes[postID]) return 0 def process_operations(operations): system = LikeSystem() results = [] for operation in operations: parts = operation.split() if parts[0] == 'like': postID = int(parts[1]) userID = int(parts[2]) system.like(postID, userID) elif parts[0] == 'count': postID = int(parts[1]) results.append(system.count(postID)) return results"},{"question":"def are_star_clusters_stable(s: str) -> str: Determines if all the clusters of stars in the string have the same length. >>> are_star_clusters_stable('*..*..*') \\"YES\\" >>> are_star_clusters_stable('**..*.**') \\"NO\\"","solution":"def are_star_clusters_stable(s): Determines if all the clusters of stars in the string have the same length. :param s: A string consisting of '*' and '.' :return: \\"YES\\" if all clusters have the same length, otherwise \\"NO\\" current_cluster_length = 0 cluster_lengths = [] for char in s: if char == '*': current_cluster_length += 1 elif current_cluster_length > 0: cluster_lengths.append(current_cluster_length) current_cluster_length = 0 if current_cluster_length > 0: cluster_lengths.append(current_cluster_length) if len(cluster_lengths) == 0 or len(set(cluster_lengths)) == 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_reorder_for_adjacent_diff(arr: List[int]) -> str: Determines if the array can be reordered such that the difference between every adjacent pair of integers is either 1 or -1. Parameters: arr (list of int): The input array containing n elements (2 <= n <= 100000), and each element (1 <= a_i <= 10^9). Returns: str: \\"YES\\" if such a reorder is possible, \\"NO\\" otherwise. Examples: >>> can_reorder_for_adjacent_diff([1, 2, 3, 4, 5]) 'YES' >>> can_reorder_for_adjacent_diff([1, 3, 2, 6, 5]) 'NO'","solution":"def can_reorder_for_adjacent_diff(arr): Determines if the array can be reordered such that the difference between every adjacent pair of integers is either 1 or -1. Parameters: arr (list of int): The input array. Returns: str: \\"YES\\" if such a reorder is possible, \\"NO\\" otherwise. arr.sort() for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) != 1: return \\"NO\\" return \\"YES\\""},{"question":"def max_number_of_words(tiles: str, word: str) -> int: Determine the maximum number of complete target words that can be formed using the given tiles. >>> max_number_of_words(\\"AABBBCCAA\\", \\"ABCA\\") 2 >>> max_number_of_words(\\"ABCDEFGHIJK\\", \\"XYZ\\") 0 >>> max_number_of_words(\\"AABBCCDDEEFFGGHHIIJJ\\", \\"ABC\\") 2 >>> max_number_of_words(\\"AAAAAAA\\", \\"AAAAA\\") 1 >>> max_number_of_words(\\"AABBCCDDEEFF\\", \\"ABCDEFGHIJK\\") 0 >>> max_number_of_words(\\"\\", \\"ANYWORD\\") 0 >>> max_number_of_words(\\"TILERANDOMNESS\\", \\"TILE\\") 1","solution":"def max_number_of_words(tiles, word): from collections import Counter # Count the frequency of each letter in tiles and word tiles_count = Counter(tiles) word_count = Counter(word) # Initialize the minimum number of complete words to a large number min_count = float('inf') # Calculate the number of times we can form the word for char in word_count: if char in tiles_count: min_count = min(min_count, tiles_count[char] // word_count[char]) else: return 0 return min_count"},{"question":"def max_books_on_shelf(W: int, books: List[int]) -> int: Determine the maximum number of books that can fit on a shelf of width W such that their total width is as close to W as possible without exceeding it. >>> max_books_on_shelf(10, [1, 2, 3, 4, 5]) 4 >>> max_books_on_shelf(5, [5, 5, 5, 5]) 1 >>> max_books_on_shelf(12, [2, 3, 5, 7]) 3","solution":"from typing import List def max_books_on_shelf(W: int, books: List[int]) -> int: # Function to find the number of books that can fit on the shelf n = len(books) dp = [0] * (W + 1) num_books = [0] * (W + 1) for width in books: for w in range(W, width - 1, -1): if dp[w - width] + width > dp[w] or (dp[w - width] + width == dp[w] and num_books[w - width] + 1 > num_books[w]): dp[w] = dp[w - width] + width num_books[w] = num_books[w - width] + 1 return max(num_books)"},{"question":"def max_gold_coins(grid: List[List[int]]) -> int: Determines the maximum number of gold coins a player can collect starting from the top-left cell to the bottom-right cell. >>> max_gold_coins([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_gold_coins([ ... [1, 2, 3, 4] ... ]) 10 >>> max_gold_coins([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_gold_coins([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_gold_coins([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_gold_coins([ ... [1, 3, 1, 2], ... [1, 5, 1, 3], ... [4, 2, 1, 4], ... [2, 2, 1, 5] ... ]) 22","solution":"def max_gold_coins(grid): Determines the maximum number of gold coins a player can collect starting from the top-left cell to the bottom-right cell. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a DP table with the same dimensions as grid dp = [[0] * n for _ in range(m)] # Initialize the top-left corner with the first grid value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for col in range(1, n): dp[0][col] = dp[0][col - 1] + grid[0][col] # Fill the first column (can only come from above) for row in range(1, m): dp[row][0] = dp[row - 1][0] + grid[row][0] # Fill the rest of dp table for row in range(1, m): for col in range(1, n): dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]) + grid[row][col] # The bottom-right corner contains the maximum gold coins that can be collected return dp[-1][-1]"},{"question":"def is_possible_balanced_groups(n: int, k: int, skill_levels: List[int]) -> str: Determines if it is possible to divide n students, each with a skill level, into exactly k balanced groups. Parameters: n (int): The number of students in the class. k (int): The number of groups to be created. skill_levels (List[int]): A list of integers representing the skill levels of each student. Returns: str: \\"YES\\" if it is possible to create exactly k balanced groups, otherwise \\"NO\\". >>> is_possible_balanced_groups(5, 3, [1, 2, 3, 4, 5]) == \\"YES\\" >>> is_possible_balanced_groups(5, 2, [1, 3, 5, 7, 9]) == \\"YES\\" >>> is_possible_balanced_groups(5, 3, [1, 1, 1, 1, 1]) == \\"NO\\" >>> is_possible_balanced_groups(5, 4, [2, 2, 2, 3, 3]) == \\"NO\\" # Implement the function here","solution":"def is_possible_balanced_groups(n, k, skill_levels): Determines if it is possible to divide n students, each with a skill level, into exactly k balanced groups. # A balanced group essentially requires those numbers to form an arithmetic progression. distinct_skill_levels = sorted(set(skill_levels)) # We need at least k distinct skill levels to form k balanced groups. if len(distinct_skill_levels) < k: return \\"NO\\" return \\"YES\\""},{"question":"def findPair(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers from nums that add up to the target, or -1 if no such pair exists. Args: nums (list): List of integers. target (int): The target sum. Returns: list: Indices of the two numbers that add up to the target, or -1 if no such pair exists. >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([3, 2, 4], 6) [1, 2] >>> findPair([3, 3], 6) [0, 1] >>> findPair([1, 2, 3], 7) -1","solution":"def findPair(nums, target): Returns the indices of the two numbers from nums that add up to the target, or -1 if no such pair exists. Args: nums (list): List of integers. target (int): The target sum. Returns: list: Indices of the two numbers that add up to the target, or -1 if no such pair exists. lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return [lookup[complement], i] lookup[num] = i return -1"},{"question":"def max_length_unique_sorted_subsequence(s: str) -> int: Determines the maximum possible length of the string \`t\` that is lexicographically sorted and with unique characters. >>> max_length_unique_sorted_subsequence(\\"abacaba\\") 3 >>> max_length_unique_sorted_subsequence(\\"abcdefghijklmnop\\") 16 >>> max_length_unique_sorted_subsequence(\\"aaaaaa\\") 1 >>> max_length_unique_sorted_subsequence(\\"\\") 0 >>> max_length_unique_sorted_subsequence(\\"abcabcabc\\") 3 >>> max_length_unique_sorted_subsequence(\\"a\\") 1 >>> max_length_unique_sorted_subsequence(\\"aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz\\") 26","solution":"def max_length_unique_sorted_subsequence(s): Determines the maximum possible length of the string \`t\` that is lexicographically sorted and with unique characters. # Use a set to store unique characters unique_chars = set(s) # The length of the unique characters set gives us the answer, # because the unique characters can be arranged in lexicographical order without repeating. return len(unique_chars)"},{"question":"def min_jumps(arr): Returns the minimum number of jumps required to reach the end of the array. If it is not possible to reach the end, returns -1. >>> min_jumps([0]) 0 >>> min_jumps([1, 0]) 1 >>> min_jumps([0, 1]) -1 >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 0, 2, 1, 3]) -1 >>> min_jumps([5, 0, 0, 0, 0]) 1 >>> min_jumps([3, 2, 1, 0, 4, 6]) -1","solution":"def min_jumps(arr): Returns the minimum number of jumps required to reach the end of the array. If it is not possible to reach the end, returns -1. n = len(arr) if n == 1: return 0 if arr[0] == 0: return -1 max_reach = arr[0] steps = arr[0] jumps = 1 for i in range(1, n): if i == n - 1: return jumps max_reach = max(max_reach, i + arr[i]) steps -= 1 if steps == 0: jumps += 1 if i >= max_reach: return -1 steps = max_reach - i return -1"},{"question":"from typing import List, Tuple def compute_magic_numbers(n: int, edges: List[Tuple[int, int]]) -> List[int]: Determine the final magic number of each node after the gnome completes his journey. Args: n: The number of nodes in the tree. edges: List of tuples where each tuple represents an edge between two nodes. Returns: A list of integers where the i-th integer is the final magic number of the i-th node. Examples: >>> compute_magic_numbers(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) [1, 2, 2, 3, 3] >>> compute_magic_numbers(2, [(1, 2)]) [1, 2] >>> compute_magic_numbers(4, [(1, 2), (1, 3), (1, 4)]) [1, 2, 2, 2]","solution":"def compute_magic_numbers(n, edges): from collections import defaultdict import sys sys.setrecursionlimit(2000) def dfs(node, parent, magic_num): magic_numbers[node] = magic_num for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node, magic_num + 1) tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) magic_numbers = [0] * (n + 1) # Start DFS from node 1 with initial magic number 1 dfs(1, -1, 1) return magic_numbers[1:] # Example Usage: # n = 5 # edges = [(1, 2), (1, 3), (2, 4), (3, 5)] # print(compute_magic_numbers(n, edges)) # Output: [1, 2, 2, 3, 3]"},{"question":"def max_subsequence_sum_circular(n, a): Determines the maximum possible sum of any subsequence in the circular array. Parameters: n (int): Length of the array. a (list): List of n integers representing the circular array. Returns: int: The maximum sum of any subsequence in the circular array. pass def max_subsequence_sum(a): Helper function to determine the maximum subsequence sum of a non-circular array. Parameters: a (list): List of integers representing the array. Returns: int: The maximum sum of any subsequence in the array. pass def test_max_subsequence_sum_circular_basic(): assert max_subsequence_sum_circular(5, [5, -3, 5]) == 10 def test_max_subsequence_sum_circular_single_element(): assert max_subsequence_sum_circular(1, [7]) == 7 assert max_subsequence_sum_circular(1, [-5]) == -5 def test_max_subsequence_sum_circular_all_negative(): assert max_subsequence_sum_circular(5, [-3, -2, -1, -4, -6]) == -1 def test_max_subsequence_sum_circular_all_positive(): assert max_subsequence_sum_circular(4, [1, 2, 3, 4]) == 10 def test_max_subsequence_sum_circular_mix_values(): assert max_subsequence_sum_circular(5, [8, -1, 3, 4, -1]) == 14 def test_max_subsequence_sum_circular_wrap_around(): assert max_subsequence_sum_circular(5, [10, -5, -3, -2, 10]) == 20","solution":"def max_subsequence_sum_circular(n, a): Determines the maximum possible sum of any subsequence in the circular array. Parameters: n (int): Length of the array. a (list): List of n integers representing the circular array. Returns: int: The maximum sum of any subsequence in the circular array. # Case 1: Maximum subsequence sum without wrapping max_sub_sum = max_subsequence_sum(a) # Case 2: Maximum subsequence sum with wrapping # Inverting array and calculating the minimum subsequence sum total_sum = sum(a) min_sub_sum = max_subsequence_sum([-x for x in a]) # Edge case: If all numbers are negative, wraparound sum will be zero which is invalid if total_sum == -min_sub_sum: return max_sub_sum max_wrap_sum = total_sum + min_sub_sum # The answer will be the maximum of both cases return max(max_sub_sum, max_wrap_sum) def max_subsequence_sum(a): Helper function to determine the maximum subsequence sum of a non-circular array. Parameters: a (list): List of integers representing the array. Returns: int: The maximum sum of any subsequence in the array. max_sum = float('-inf') current_sum = 0 for number in a: current_sum = max(number, current_sum + number) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def minimum_difference(arr: List[int]) -> int: Finds the minimum possible difference between the sums of two non-overlapping subarrays. Args: arr : list of int List of integers representing the array. Returns: int The minimum possible difference. >>> minimum_difference([3, -6, 5, 2, -1, 7]) 2 >>> minimum_difference([1, 2]) 1 >>> minimum_difference([1, -1, 1, -1]) 0 >>> minimum_difference([10, -2, 7, 3]) 2 >>> minimum_difference([1, 3, 3, 2, 1, 4, 5]) 1 >>> minimum_difference([-10000, 10000]) 20000 >>> minimum_difference([0, 0, 0, 0]) 0 >>> minimum_difference([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 1 >>> minimum_difference([-1, -2, -3, -4]) 2 >>> minimum_difference([10, 20, -30, 40, 50, -60, 70, -80, 90, 100]) 10","solution":"def minimum_difference(arr): Finds the minimum possible difference between the sums of two non-overlapping subarrays. Args: arr : list of int List of integers representing the array. Returns: int The minimum possible difference. total_sum = sum(arr) n = len(arr) left_sum = 0 min_diff = float('inf') for i in range(n-1): left_sum += arr[i] right_sum = total_sum - left_sum min_diff = min(min_diff, abs(left_sum - right_sum)) return min_diff"},{"question":"def max_beauty_permutation(n: int) -> List[int]: Generates a permutation of numbers from 1 to n that maximizes the beauty. >>> max_beauty_permutation(1) == [1] >>> max_beauty_permutation(2) == [1, 2] or max_beauty_permutation(2) == [2, 1] >>> max_beauty_permutation(3) == [1, 3, 2] or max_beauty_permutation(3) == [2, 1, 3] or max_beauty_permutation(3) == [3, 1, 2] >>> max_beauty_permutation(5) == [1, 5, 2, 4, 3] >>> max_beauty_permutation(6) == [1, 6, 2, 5, 3, 4] pass","solution":"def max_beauty_permutation(n): Generates a permutation of numbers from 1 to n that maximizes the beauty. permutation = [] start, end = 1, n while start <= end: if start == end: permutation.append(start) else: permutation.append(start) permutation.append(end) start += 1 end -= 1 return permutation"},{"question":"def max_product_subarray(arr: List[int]) -> int: Compute the maximum product of a contiguous subarray modulo 10^9 + 7. >>> max_product_subarray([1, 2, 3, 4, 5]) 120 >>> max_product_subarray([2, -3, 2, -4]) 48","solution":"def max_product_subarray(arr): mod = 10**9 + 7 N = len(arr) # Initialize variables current_max = current_min = max_product = arr[0] for i in range(1, N): if arr[i] < 0: current_max, current_min = current_min, current_max current_max = max(arr[i], current_max * arr[i]) current_min = min(arr[i], current_min * arr[i]) max_product = max(max_product, current_max) return max_product % mod"},{"question":"def rearrange_array(a: List[int], k: int) -> List[int]: Rearranges the array such that all elements less than k precede elements greater than or equal to k, while maintaining relative order. >>> rearrange_array([1, 4, 3, 2, 5, 2, 6], 3) [1, 2, 2, 4, 3, 5, 6] >>> rearrange_array([5, 6, 7], 5) [5, 6, 7] >>> rearrange_array([1, 2, 2], 5) [1, 2, 2] >>> rearrange_array([1], 5) [1] >>> rearrange_array([5], 1) [5] >>> rearrange_array([], 1) []","solution":"def rearrange_array(a, k): Rearranges the array such that all elements less than k precede elements greater than or equal to k, while maintaining relative order. less_than_k = [] greater_or_equal_k = [] for num in a: if num < k: less_than_k.append(num) else: greater_or_equal_k.append(num) return less_than_k + greater_or_equal_k"},{"question":"def handle_query(query: str) -> str: Takes a query string and returns an appropriate response based on the type of query. >>> handle_query(\\"product: What is the price of XYZ?\\") 'This is related to product details.' >>> handle_query(\\"order: What is the status of my order #12345?\\") 'This is related to order status.' >>> handle_query(\\"return: How do I return a defective item?\\") 'This is related to return policy.' >>> handle_query(\\"shipping: When will my order ship?\\") 'Invalid query type.' >>> handle_query(\\" product : Can you give me details about ABC? \\") 'This is related to product details.' >>> handle_query(\\" order : Where is my shipment? \\") 'This is related to order status.' >>> handle_query(\\" return : What is your return policy? \\") 'This is related to return policy.'","solution":"def handle_query(query: str) -> str: Takes a query string and returns an appropriate response based on the type of query. # Split the query into header and details header, _ = query.split(\\":\\", 1) header = header.strip().lower() if header == \\"product\\": return \\"This is related to product details.\\" elif header == \\"order\\": return \\"This is related to order status.\\" elif header == \\"return\\": return \\"This is related to return policy.\\" else: return \\"Invalid query type.\\""},{"question":"def best_sushi(n: int, ratings: List[List[Union[str, int]]]) -> str: Determine the sushi item with the highest average rating and the corresponding average rating value. If there is a tie, the item that appeared first in the list is selected. Parameters: n (int): the number of ratings. ratings (List[List[Union[str, int]]]): list of sushi items with their ratings. Returns: str: The name of the sushi item with the highest average rating and the average rating value correct to two decimal places. >>> best_sushi(5, [[\\"SalmonRoll\\", 5], [\\"TunaSashimi\\", 4], [\\"SalmonRoll\\", 3], [\\"CaliforniaRoll\\", 4], [\\"TunaSashimi\\", 5]]) \\"TunaSashimi 4.50\\" >>> best_sushi(4, [[\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 4], [\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 4]]) \\"SalmonRoll 4.00\\" def test_best_sushi_basic(): n = 5 ratings = [ [\\"SalmonRoll\\", 5], [\\"TunaSashimi\\", 4], [\\"SalmonRoll\\", 3], [\\"CaliforniaRoll\\", 4], [\\"TunaSashimi\\", 5] ] assert best_sushi(n, ratings) == \\"TunaSashimi 4.50\\" def test_same_average_first_sushi_wins(): n = 4 ratings = [ [\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 4], [\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 4] ] assert best_sushi(n, ratings) == \\"SalmonRoll 4.00\\" def test_one_sushi(): n = 1 ratings = [ [\\"SalmonRoll\\", 5] ] assert best_sushi(n, ratings) == \\"SalmonRoll 5.00\\" def test_multiple_sushis_with_ties(): n = 6 ratings = [ [\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 3], [\\"CaliforniaRoll\\", 5], [\\"SalmonRoll\\", 4], [\\"TunaSashimi\\", 5], [\\"CaliforniaRoll\\", 5] ] assert best_sushi(n, ratings) == \\"CaliforniaRoll 5.00\\" def test_varied_ratings(): n = 6 ratings = [ [\\"SalmonRoll\\", 1], [\\"TunaSashimi\\", 2], [\\"CaliforniaRoll\\", 3], [\\"UnagiRoll\\", 5], [\\"SalmonRoll\\", 5], [\\"TunaSashimi\\", 5] ] assert best_sushi(n, ratings) == \\"UnagiRoll 5.00\\"","solution":"def best_sushi(n, ratings): from collections import defaultdict sushi_ratings = defaultdict(list) for rating in ratings: sushi, score = rating[0], int(rating[1]) sushi_ratings[sushi].append(score) best_sushi = None highest_avg = 0 for sushi, scores in sushi_ratings.items(): avg_rating = sum(scores) / len(scores) if avg_rating > highest_avg or (avg_rating == highest_avg and best_sushi is None): best_sushi = sushi highest_avg = avg_rating return f\\"{best_sushi} {highest_avg:.2f}\\" # Example usage: # n = 5 # ratings = [ # [\\"SalmonRoll\\", 5], # [\\"TunaSashimi\\", 4], # [\\"SalmonRoll\\", 3], # [\\"CaliforniaRoll\\", 4], # [\\"TunaSashimi\\", 5] # ] # print(best_sushi(n, ratings)) # Output: \\"TunaSashimi 4.50\\""},{"question":"def min_difference_partition(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alice is a farmer who is growing corn in several fields. There are a total of n fields, each with a certain yield of corn. Alice wants to divide the fields into two groups such that the difference in the total yields of the two groups is minimized. For each test case, the input consists of two lines: - The first line contains the integer n (1 <= n <= 100) - the number of fields. - The second line contains n integers Y1, Y2, ..., Yn (1 <= Yi <= 1000) representing the yield of each field. For each test case, return a single integer - the minimum possible absolute difference between the sums of the two groups. >>> min_difference_partition(2, [(4, [1, 6, 11, 5]), (3, [10, 20, 15])]) [1, 5] >>> min_difference_partition(1, [(1, [1000])]) [1000] >>> min_difference_partition(1, [(4, [100, 100, 100, 100])]) [0] >>> min_difference_partition(1, [(0, [])]) [0]","solution":"def min_difference_partition(t, test_cases): def find_min_partition(yields): n = len(yields) total_sum = sum(yields) dp = [False] * (total_sum // 2 + 1) dp[0] = True for y in yields: for j in range(total_sum // 2, y - 1, -1): dp[j] = dp[j] or dp[j - y] for j in range(total_sum // 2, -1, -1): if dp[j]: return total_sum - 2 * j results = [] for case in test_cases: n, yields = case results.append(find_min_partition(yields)) return results"},{"question":"def max_chocolates(n: int, w: int, m: int, chocolate_weights: List[int]) -> int: Determines the maximum number of chocolates that can be packed in a box with given weight capacity and chocolates capacity. :param n: Number of types of chocolates :param w: Weight capacity of the box :param m: Maximum number of chocolates the box can hold :param chocolate_weights: List of weights of each type of chocolate :return: Maximum number of chocolates that can be packed in the box >>> max_chocolates(4, 10, 3, [2, 3, 5, 7]) 3 >>> max_chocolates(4, 6, 10, [2, 2, 2, 5]) 3 >>> max_chocolates(4, 10, 2, [2, 3, 5, 7]) 2 >>> max_chocolates(1, 10, 1, [5]) 1 >>> max_chocolates(4, 1, 10, [2, 3, 5, 7]) 0 >>> max_chocolates(3, 1000000000, 1000, [999999999, 999999999, 999999999]) 1 >>> max_chocolates(3, 1000000000, 1000, [1, 1, 1]) 3","solution":"def max_chocolates(n, w, m, chocolate_weights): Determines the maximum number of chocolates that can be packed in a box with given weight capacity and chocolates capacity. :param n: Number of types of chocolates :param w: Weight capacity of the box :param m: Maximum number of chocolates the box can hold :param chocolate_weights: List of weights of each type of chocolate :return: Maximum number of chocolates that can be packed in the box chocolate_weights.sort() total_weight = 0 chocolates_count = 0 for weight in chocolate_weights: if total_weight + weight <= w and chocolates_count + 1 <= m: total_weight += weight chocolates_count += 1 else: break return chocolates_count"},{"question":"def can_occupy_unique_scarecrows(N, M, positions, ranges): Determines if each crow can occupy a unique scarecrow. :param N: int - number of scarecrows :param M: int - number of crows :param positions: list - initial positions of the crows :param ranges: list - ranges for the respective crows :return: str - \\"YES\\" if possible, otherwise \\"NO\\" >>> can_occupy_unique_scarecrows(5, 3, [2, 4, 5], [1, 1, 0]) 'YES' >>> can_occupy_unique_scarecrows(5, 3, [1, 2, 3], [0, 0, 0]) 'YES' >>> can_occupy_unique_scarecrows(5, 3, [1, 1, 1], [0, 0, 0]) 'NO' >>> can_occupy_unique_scarecrows(10, 5, [2, 4, 5, 8, 9], [1, 1, 1, 1, 1]) 'YES' >>> can_occupy_unique_scarecrows(3, 3, [1, 2, 3], [2, 2, 2]) 'YES' >>> can_occupy_unique_scarecrows(3, 2, [1, 1], [0, 0]) 'NO'","solution":"def can_occupy_unique_scarecrows(N, M, positions, ranges): Determines if each crow can occupy a unique scarecrow. :param N: int - number of scarecrows :param M: int - number of crows :param positions: list - initial positions of the crows :param ranges: list - ranges for the respective crows :return: str - \\"YES\\" if possible, otherwise \\"NO\\" scarecrow_occupied = [0] * (N + 1) intervals = [] for i in range(M): start = max(1, positions[i] - ranges[i]) end = min(N, positions[i] + ranges[i]) intervals.append((start, end)) intervals.sort() for start, end in intervals: allocated = False for i in range(start, end + 1): if scarecrow_occupied[i] == 0: scarecrow_occupied[i] = 1 allocated = True break if not allocated: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_cost_to_connect_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Computes the minimum cost to connect all cities using Kruskal's Minimum Spanning Tree algorithm. If not all cities can be connected, returns -1. Args: n: int - The number of cities. m: int - The number of roads. roads: List[Tuple[int, int, int]] - A list of tuples, each representing a road with two endpoints and its length. Returns: int - The minimum cost to connect all cities, or -1 if not all cities can be connected. >>> minimum_cost_to_connect_cities(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 2, 1), (1, 3, 2)]) == 6 >>> minimum_cost_to_connect_cities(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == 3 >>> minimum_cost_to_connect_cities(4, 2, [(1, 2, 1), (3, 4, 2)]) == -1 >>> minimum_cost_to_connect_cities(2, 1, [(1, 2, 5)]) == 5","solution":"def minimum_cost_to_connect_cities(n, m, roads): Computes the minimum cost to connect all cities using Kruskal's Minimum Spanning Tree algorithm. If not all cities can be connected, returns -1. # Helper function to find the parent of a node in the disjoint set def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to do union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Step 1: Sort all the edges in non-decreasing order of their length roads.sort(key=lambda x: x[2]) # Allocate memory for creating a disjoint set parent = [] rank = [] # Create n disjoint sets (one for each city) for node in range(n): parent.append(node) rank.append(0) result = 0 e = 0 # Number of edges in the result i = 0 # Initial index of sorted edges while e < n - 1 and i < m: # Step 2: Pick the smallest edge and increment the index u, v, l = roads[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge doesn't form a cycle if x != y: e += 1 result += l union(parent, rank, x, y) if e == n - 1: return result else: return -1"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Calculate the minimum number of operations required to transform string s into string t. You can perform three types of operations on the string s: 1. Insert a character. 2. Delete a character. 3. Replace a character. Args: s (str): The original string. t (str): The target string. Returns: int: The minimum number of operations required to transform s into t. Example: >>> min_operations_to_transform(\\"sunday\\", \\"saturday\\") 3 >>> min_operations_to_transform(\\"horse\\", \\"ros\\") 3","solution":"def min_operations_to_transform(s, t): Calculates the minimum number of operations required to transform string s into string t. Operations allowed are insert, delete, and replace a character. m, n = len(s), len(t) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore last character and recur for remaining string elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"from typing import List, Tuple def identify_coin_weights(n: int, weights: List[int]) -> Tuple[int, int]: Identify the weights of the fake and real coins. Args: n (int): The number of coins. weights (list of int): The weights of the coins. Returns: tuple: A tuple containing the weight of the fake coins and the weight of the real coins. >>> identify_coin_weights(4, [10, 10, 5, 10]) (5, 10) >>> identify_coin_weights(6, [3, 3, 3, 7, 3, 3]) (7, 3) >>> identify_coin_weights(5, [20, 20, 20, 15, 20]) (15, 20) pass","solution":"def identify_coin_weights(n, weights): Identify the weights of the fake and real coins. Args: n (int): The number of coins. weights (list of int): The weights of the coins. Returns: tuple: A tuple containing the weight of the fake coins and the weight of the real coins. from collections import Counter # Count the frequency of each weight weight_counts = Counter(weights) # The real coin weight is the one with the highest count real_weight = max(weight_counts, key=weight_counts.get) # The fake coin weight is the one with the lowest count fake_weight = min(weight_counts, key=weight_counts.get) return fake_weight, real_weight # Example usage n = 4 weights = [10, 10, 5, 10] print(identify_coin_weights(n, weights)) # Output: (5, 10)"},{"question":"def process_operations(n: int, q: int, array: List[int], operations: List[str]) -> List[int]: Processes the given operations on the array and returns the results for each sum operation. Parameters: n (int): Number of elements in the array q (int): Number of operations array (list of int): The array of elements operations (list of str): List of operations to perform Returns: list of int: List of results for the sum operations >>> process_operations(5, 3, [1, 2, 3, 4, 5], [\\"R 2 4\\", \\"S 1 5\\", \\"S 2 4\\"]) [15, 9] >>> process_operations(4, 2, [4, 3, 2, 1], [\\"S 1 4\\", \\"R 1 4\\"]) [10] from typing import List def test_process_operations(): # Test case n = 5 q = 3 array = [1, 2, 3, 4, 5] operations = [\\"R 2 4\\", \\"S 1 5\\", \\"S 2 4\\"] expected_output = [15, 9] assert process_operations(n, q, array, operations) == expected_output # Test case n = 4 q = 2 array = [4, 3, 2, 1] operations = [\\"S 1 4\\", \\"R 1 4\\"] expected_output = [10] assert process_operations(n, q, array, operations) == expected_output # Test case n = 3 q = 3 array = [1, 10, 100] operations = [\\"S 1 3\\", \\"R 1 3\\", \\"S 1 3\\"] expected_output = [111, 111] assert process_operations(n, q, array, operations) == expected_output # Test case : Reverse entire array and sum its whole n = 6 q = 2 array = [6, 5, 4, 3, 2, 1] operations = [\\"R 1 6\\", \\"S 1 6\\"] expected_output = [21] assert process_operations(n, q, array, operations) == expected_output # Test case : No operation, straight sum n = 2 q = 1 array = [123456789, 987654321] operations = [\\"S 1 2\\"] expected_output = [1111111110] assert process_operations(n, q, array, operations) == expected_output # Test case : Multiple reverses n = 5 q = 4 array = [1, 2, 3, 4, 5] operations = [\\"R 1 5\\", \\"R 1 5\\", \\"R 1 5\\", \\"S 1 5\\"] expected_output = [5 + 4 + 3 + 2 + 1] assert process_operations(n, q, array, operations) == expected_output # Test case : Edge case with single element n = 1 q = 2 array = [10] operations = [\\"S 1 1\\", \\"R 1 1\\"] expected_output = [10] assert process_operations(n, q, array, operations) == expected_output","solution":"def process_operations(n, q, array, operations): Processes the given operations on the array and returns the results for each sum operation. Parameters: n (int): Number of elements in the array q (int): Number of operations array (list of int): The array of elements operations (list of str): List of operations to perform Returns: list of int: List of results for the sum operations results = [] for op in operations: parts = op.strip().split() if parts[0] == \\"R\\": l, r = int(parts[1]), int(parts[2]) # Perform reverse operation array[l-1:r] = array[l-1:r][::-1] elif parts[0] == \\"S\\": l, r = int(parts[1]), int(parts[2]) # Calculate sum of the subarray results.append(sum(array[l-1:r])) return results"},{"question":"import heapq def minimum_cost(n, m, r, roads): Calculate the minimum cost to travel from the top-left intersection to the bottom-right intersection in a city grid using major roads. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. r (int): Number of major roads. roads (list of tuples): List of roads where each road is represented as a tuple (x1, y1, x2, y2, c). Returns: int: The minimum cost to travel from (1, 1) to (n, m). Returns -1 if there is no valid path. Examples: >>> minimum_cost(3, 3, 4, [(1, 1, 1, 2, 5), (1, 2, 2, 2, 2), (2, 2, 3, 2, 1), (3, 2, 3, 3, 3)]) 11 >>> minimum_cost(3, 3, 2, [(1, 1, 1, 2, 5), (3, 2, 3, 3, 3)]) -1 pass def test_min_cost_direct_path(): assert minimum_cost(3, 3, 4, [ (1, 1, 1, 2, 5), (1, 2, 2, 2, 2), (2, 2, 3, 2, 1), (3, 2, 3, 3, 3) ]) == 11 def test_min_cost_no_path(): assert minimum_cost(3, 3, 2, [ (1, 1, 1, 2, 5), (3, 2, 3, 3, 3) ]) == -1 def test_min_cost_multiple_paths(): assert minimum_cost(3, 3, 5, [ (1, 1, 1, 2, 1), (1, 2, 2, 2, 1), (2, 2, 3, 2, 1), (3, 2, 3, 3, 1), (1, 1, 3, 3, 10) ]) == 4 def test_min_cost_larger_grid_simple(): assert minimum_cost(4, 4, 4, [ (1, 1, 2, 1, 1), (2, 1, 2, 2, 1), (2, 2, 3, 2, 1), (3, 2, 4, 2, 1) ]) == -1 def test_min_cost_larger_grid_with_path(): assert minimum_cost(4, 4, 6, [ (1, 1, 2, 1, 1), (2, 1, 2, 2, 1), (2, 2, 3, 2, 1), (3, 2, 4, 2, 1), (4, 2, 4, 4, 1), (3, 2, 4, 4, 5) ]) == 5","solution":"import heapq def minimum_cost(n, m, r, roads): # Create adjacency list for the grid graph = {} for _ in range(r): x1, y1, x2, y2, c = roads.pop(0) if (x1, y1) not in graph: graph[(x1, y1)] = [] if (x2, y2) not in graph: graph[(x2, y2)] = [] graph[(x1, y1)].append(((x2, y2), c)) graph[(x2, y2)].append(((x1, y1), c)) # Dijkstra's Algorithm to find shortest path start = (1, 1) end = (n, m) heap = [(0, start)] # (cost, (x, y)) costs = {start: 0} visited = set() while heap: curr_cost, (curr_x, curr_y) = heapq.heappop(heap) if (curr_x, curr_y) in visited: continue visited.add((curr_x, curr_y)) if (curr_x, curr_y) == end: return curr_cost for (next_x, next_y), next_cost in graph.get((curr_x, curr_y), []): if (next_x, next_y) not in visited: total_cost = curr_cost + next_cost if total_cost < costs.get((next_x, next_y), float('inf')): costs[(next_x, next_y)] = total_cost heapq.heappush(heap, (total_cost, (next_x, next_y))) return -1"},{"question":"def series_kth_number(k: int) -> int: Returns the k-th number in the specified series. The series is defined as: - S(1) = 1 - S(n) = S(n-1) + S(n-2) + ... + S(1) for n > 1 :param k: The position in the series (1 ≤ k ≤ 25) :return: The k-th number in the series >>> series_kth_number(1) 1 >>> series_kth_number(2) 1 >>> series_kth_number(3) 2 >>> series_kth_number(4) 4 >>> series_kth_number(5) 8 >>> series_kth_number(6) 16 >>> series_kth_number(7) 32 >>> series_kth_number(8) 64","solution":"def series_kth_number(k): Returns the k-th number in the specified series. The series is defined as: - S(1) = 1 - S(n) = S(n-1) + S(n-2) + ... + S(1) for n > 1 :param k: The position in the series (1 ≤ k ≤ 25) :return: The k-th number in the series if k == 1: return 1 series = [1] for i in range(1, k): next_value = sum(series) series.append(next_value) return series[-1]"},{"question":"def min_repaints(n: int, colors: List[int]) -> int: Mr. Smith loves painting very much. He lives in a city with n houses strategically arranged in a straight line, numbered from 1 to n. Each house is defined by its color. Mr. Smith has a limited amount of paint and he wants to repaint some of the houses to ensure that all the adjacent houses have different colors while using the minimum amount of paint. Given an array of length n, where the i-th element represents the color of the i-th house, determine the minimum number of houses he has to repaint to achieve his goal. Args: n (int): The number of houses colors (List[int]): A list of integers representing the initial colors of the houses Returns: int: The minimum number of houses that Mr. Smith has to repaint >>> min_repaints(5, [1, 1, 2, 2, 2]) 2 >>> min_repaints(1, [1]) 0 >>> min_repaints(2, [1, 1]) 1 >>> min_repaints(2, [1, 2]) 0 >>> min_repaints(4, [2, 2, 2, 2]) 2 >>> min_repaints(5, [1, 2, 1, 2, 1]) 0 >>> min_repaints(7, [4, 4, 4, 5, 5, 2, 2]) 3 >>> min_repaints(5, [1000000000, 1000000000, 1000000000, 999999999, 999999999]) 2 pass","solution":"def min_repaints(n, colors): if n == 1: return 0 repaints = 0 for i in range(1, n): if colors[i] == colors[i-1]: repaints += 1 # Change the color of the current house to a different color (it can be any valid color) # Here, we change it to a color which is different than the previous and the next house. # To make sure that we don't introduce a new conflict, we can change it to a number that # is not equal to the next house's color or previous house's color. if i < n-1: if colors[i-1] != colors[i+1]: colors[i] = colors[i-1] else: colors[i] = colors[i] + 1 else: colors[i] = colors[i-1] + 1 return repaints"},{"question":"def is_almost_sorted(n: int, arr: List[int], k: int) -> str: Check if the given array is almost sorted, meaning it can be sorted in non-decreasing order by removing exactly one element at position \`k\`. Parameters: n (int): The number of elements in the array. arr (List[int]): The elements of the array. k (int): The position of the element to remove (1-based index). Returns: str: \\"YES\\" if the array can be almost sorted by removing the element at position \`k\`, otherwise \\"NO\\". >>> is_almost_sorted(5, [1, 2, 3, 4, 5], 3) == \\"YES\\" >>> is_almost_sorted(5, [1, 3, 2, 4, 5], 2) == \\"YES\\" >>> is_almost_sorted(5, [1, 3, 2, 4, 5], 3) == \\"YES\\" >>> is_almost_sorted(5, [5, 3, 2, 4, 1], 2) == \\"NO\\" >>> is_almost_sorted(5, [3, 5, 2, 4, 1], 4) == \\"NO\\" >>> is_almost_sorted(4, [5, 3, 4, 6], 1) == \\"YES\\" >>> is_almost_sorted(4, [1, 2, 3, 0], 4) == \\"YES\\" >>> is_almost_sorted(200000, list(range(1, 100001)) + [1000001] + list(range(100001, 200000)), 100001) == \\"YES\\" >>> is_almost_sorted(200000, list(range(1, 100001)) + [1000001] + list(range(100001, 200000)), 100000) == \\"NO\\"","solution":"def is_almost_sorted(n, arr, k): Returns \\"YES\\" if the array can be sorted in non-decreasing order by removing exactly one element at position \`k\`. Otherwise, returns \\"NO\\". # Remove the k-th element (1-based index, so subtract 1 to transform it into 0-based index) k -= 1 new_arr = arr[:k] + arr[k+1:] # Check if the new array is sorted in non-decreasing order for i in range(1, len(new_arr)): if new_arr[i] < new_arr[i-1]: return \\"NO\\" return \\"YES\\""},{"question":"def distribute_participants(n: int, m: int, skill_levels: List[int]) -> List[int]: Distributes participants into m groups as evenly as possible. Parameters: n (int): Number of participants. m (int): Number of groups. skill_levels (list of int): Skill levels of participants. Returns: list of int: Number of participants in each group. >>> distribute_participants(6, 3, [12, 45, 23, 34, 56, 78]) [2, 2, 2] >>> distribute_participants(7, 3, [1, 2, 3, 4, 5, 6, 7]) [3, 2, 2] >>> distribute_participants(5, 1, [10, 20, 30, 40, 50]) [5] >>> distribute_participants(4, 6, [2, 4, 6, 8]) [1, 1, 1, 1, 0, 0] >>> distribute_participants(4, 4, [5, 10, 15, 20]) [1, 1, 1, 1]","solution":"def distribute_participants(n, m, skill_levels): Distributes participants into m groups as evenly as possible. Parameters: n (int): Number of participants. m (int): Number of groups. skill_levels (list of int): Skill levels of participants. Returns: list of int: Number of participants in each group. base_size = n // m remainder = n % m group_sizes = [base_size] * m for i in range(remainder): group_sizes[i] += 1 return group_sizes"},{"question":"def max_sky_bridges(n: int, k: int, heights: List[int]) -> int: Determine the maximum number of sky bridges that can be built between the towers. >>> max_sky_bridges(5, 2, [1, 3, 5, 7, 9]) 2 >>> max_sky_bridges(5, 0, [5, 5, 5, 5, 5]) 2 >>> max_sky_bridges(3, 1, [1, 4, 7]) 0 >>> max_sky_bridges(4, 100, [1, 50, 100, 150]) 2 >>> max_sky_bridges(1, 10, [10]) 0 >>> max_sky_bridges(2, 5, [10, 13]) 1 >>> max_sky_bridges(2, 5, [13, 10]) 1","solution":"def max_sky_bridges(n, k, heights): heights.sort() used = [False] * n count = 0 for i in range(n): if not used[i]: for j in range(i + 1, n): if not used[j] and abs(heights[j] - heights[i]) <= k: used[i] = True used[j] = True count += 1 break return count"},{"question":"def arrange_boxes(n, weights): Arranges boxes on a shelf such that no two neighboring boxes have the same weight. :param n: Number of boxes. :param weights: List of weights of the boxes. :return: Tuple of a string (\\"YES\\" or \\"NO\\") and a list of arranged weights if possible. from solution import arrange_boxes def test_single_box(): assert arrange_boxes(1, [5]) == (\\"YES\\", [5]) def test_two_boxes(): assert arrange_boxes(2, [1, 2]) == (\\"YES\\", [1, 2]) assert arrange_boxes(2, [3, 3]) == (\\"NO\\", []) def test_three_boxes(): result = arrange_boxes(3, [1, 2, 3]) assert result[0] == \\"YES\\" assert len(result[1]) == 3 assert result[1] != sorted([1, 2, 3]) def test_multiple_boxes(): result = arrange_boxes(6, [4, 5, 1, 6, 3, 2]) assert result[0] == \\"YES\\" assert len(result[1]) == 6 def test_repeat_invalid_case(): assert arrange_boxes(4, [2, 2, 2, 2]) == (\\"NO\\", []) def test_maximum_input(): weights = list(range(1, 101)) result = arrange_boxes(100, weights) assert result[0] == \\"YES\\" assert len(result[1]) == 100 for i in range(1, 100): assert result[1][i] != result[1][i-1]","solution":"def arrange_boxes(n, weights): Arranges boxes on a shelf such that no two neighboring boxes have the same weight. :param n: Number of boxes. :param weights: List of weights of the boxes. :return: Tuple of a string (\\"YES\\" or \\"NO\\") and a list of arranged weights if possible. if n == 1: return \\"YES\\", weights sorted_weights = sorted(weights) for i in range(1, n): if sorted_weights[i] == sorted_weights[i-1]: return \\"NO\\", [] # Rearrange weights result = [0] * n result[::2], result[1::2] = sorted_weights[:(n+1)//2], sorted_weights[(n+1)//2:] return \\"YES\\", result"},{"question":"def max_distinct_stickers(packs): Calculate the maximum number of distinct stickers Emma can have after at most one exchange operation. Parameters: packs (List[List[int]]): A list of lists where each list represents a sticker pack. Returns: int: The maximum number of distinct stickers. >>> max_distinct_stickers([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 9 >>> max_distinct_stickers([[1, 2, 3], [2, 3, 4]]) 4 pass if __name__ == \\"__main__\\": import pytest def test_example_cases(): assert max_distinct_stickers([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 9 assert max_distinct_stickers([[1, 2, 3], [2, 3, 4]]) == 4 def test_no_swap_needed(): assert max_distinct_stickers([[1], [2], [3]]) == 3 def test_full_overlap(): assert max_distinct_stickers([[1, 2, 3], [1, 2, 3]]) == 3 def test_one_sticker_each(): assert max_distinct_stickers([[1], [2], [3], [4]]) == 4 def test_partial_overlap(): assert max_distinct_stickers([[1, 2, 3], [2, 3, 4], [4, 5, 6]]) == 6 def test_no_overlap(): assert max_distinct_stickers([[10, 20, 30], [40, 50], [60, 70, 80]]) == 8 def test_large_input(): large_packs = [[i] for i in range(1, 1001)] assert max_distinct_stickers(large_packs) == 1000 pytest.main([__file__])","solution":"def max_distinct_stickers(packs): Returns the maximum number of distinct stickers Emma can have after at most one exchange operation. Parameters: packs (List[List[int]]): A list of lists where each list represents a sticker pack. Returns: int: The maximum number of distinct stickers. from collections import Counter # Combine all stickers to find the unique stickers without any exchange all_stickers = [sticker for pack in packs for sticker in pack] initial_unique_count = len(set(all_stickers)) # If all stickers are already unique, return this number if initial_unique_count == len(all_stickers): return initial_unique_count # Find frequency map of stickers sticker_count = Counter(all_stickers) # Maximum candidate after one swap operation max_after_one_swap = initial_unique_count # Check all pairs of packs to find potential beneficial swap for i in range(len(packs)): for j in range(i + 1, len(packs)): pack_i = set(packs[i]) pack_j = set(packs[j]) # Current distinct count current_distinct_count = len(set(all_stickers)) # Go through each pair of stickers that could be swapped for sticker_i in pack_i: for sticker_j in pack_j: new_pack_i = pack_i.copy() new_pack_j = pack_j.copy() # Perform the swap temporarily new_pack_i.remove(sticker_i) new_pack_i.add(sticker_j) new_pack_j.remove(sticker_j) new_pack_j.add(sticker_i) # Calculate the new unique count after the swap new_stickers = (set(new_pack_i) | set(new_pack_j) | set(all_stickers) - {sticker_i, sticker_j}) new_unique_count = len(new_stickers) # Update max if found a better count if new_unique_count > max_after_one_swap: max_after_one_swap = new_unique_count return max_after_one_swap"},{"question":"def find_winner(n: int, votes: List[int]) -> Union[int, str]: Determines the winner of an election based on votes. :param n: The number of voters. :param votes: A list of integers where each integer represents a vote for a candidate. :return: The candidate number who wins the election, or \\"No winner\\" if no candidate receives more than half of the votes. >>> find_winner(5, [1, 2, 1, 2, 1]) 1 >>> find_winner(4, [1, 2, 3, 1]) 'No winner' >>> find_winner(1, [1]) 1 >>> find_winner(3, [1, 1, 1]) 1 >>> find_winner(6, [1, 1, 2, 2, 3, 3]) 'No winner' >>> find_winner(7, [1, 2, 2, 3, 3, 3, 3]) 3","solution":"def find_winner(n, votes): from collections import Counter vote_count = Counter(votes) for candidate, count in vote_count.items(): if count > n // 2: return candidate return \\"No winner\\""},{"question":"def optimal_batch_sizes(x, y): Returns the smallest possible batch sizes for the fertilizers that comply with the mix ratio x : y. Examples: >>> optimal_batch_sizes(3, 5) (3, 5) >>> optimal_batch_sizes(2, 4) (1, 2) >>> optimal_batch_sizes(10, 10) (1, 1) >>> optimal_batch_sizes(7, 13) (7, 13) >>> optimal_batch_sizes(8, 32) (1, 4) >>> optimal_batch_sizes(1, 1000) (1, 1000) >>> optimal_batch_sizes(1000, 999) (1000 // math.gcd(1000, 999), 999 // math.gcd(1000, 999))","solution":"import math def optimal_batch_sizes(x, y): Returns the smallest possible batch sizes for the fertilizers that comply with the mix ratio x : y. gcd = math.gcd(x, y) return x // gcd, y // gcd"},{"question":"def maximize_manhattan(n: int, m: int) -> List[Tuple[int, int]]: Return the coordinates of cells where stones should be placed to maximize the minimum Manhattan distance between any pair of stones. >>> maximize_manhattan(3, 3) [(1, 1), (1, 3), (3, 1), (3, 3)] >>> maximize_manhattan(2, 4) [(1, 1), (1, 4), (2, 1), (2, 4)] pass def process_test_cases(t: int, cases: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]: Receive number of test cases and their respective grid dimensions. Return the positions for each test case. >>> process_test_cases(2, [(3, 3), (2, 4)]) [[(1, 1), (1, 3), (3, 1), (3, 3)], [(1, 1), (1, 4), (2, 1), (2, 4)]] pass","solution":"def maximize_manhattan(n, m): Return the coordinates of cells where stones should be placed to maximize the minimum Manhattan distance between any pair of stones. stones_positions = [ (1, 1), (1, m), (n, 1), (n, m) ] return stones_positions def process_test_cases(t, cases): Receive number of test cases and their respective grid dimensions. Return the positions for each test case. results = [] for n, m in cases: stones_positions = maximize_manhattan(n, m) results.append(stones_positions) return results"},{"question":"def find_duplicated_element(n, K, array): Finds the duplicated element in the array given the number of elements \`n\` and the number of times the duplicated element appears \`K\`. Args: n (int): the number of unique elements. K (int): the number of times the duplicated element appears. array (list): the array that contains n + K - 1 integers. Returns: int: the duplicated element. # Unit tests def test_find_duplicated_element_case_1(): n, K = 5, 3 array = [1, 2, 3, 4, 2, 5, 2] assert find_duplicated_element(n, K, array) == 2 def test_find_duplicated_element_case_2(): n, K = 6, 2 array = [1, 2, 3, 4, 5, 6, 3] assert find_duplicated_element(n, K, array) == 3 def test_find_duplicated_element_case_3(): n, K = 4, 4 array = [1, 2, 2, 2, 2] assert find_duplicated_element(n, K, array) == 2 def test_find_duplicated_element_case_4(): n, K = 3, 3 array = [3, 3, 3, 1, 2] assert find_duplicated_element(n, K, array) == 3 def test_find_duplicated_element_case_5(): n, K = 7, 5 array = [1, 2, 3, 4, 5, 6, 7, 3, 3, 3, 3] assert find_duplicated_element(n, K, array) == 3","solution":"def find_duplicated_element(n, K, array): Finds the duplicated element in the array given the number of elements \`n\` and the number of times the duplicated element appears \`K\`. Args: n (int): the number of unique elements. K (int): the number of times the duplicated element appears. array (list): the array that contains n + K - 1 integers. Returns: int: the duplicated element. element_count = {} for element in array: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 for element, count in element_count.items(): if count == K: return element"},{"question":"from typing import List, Tuple def find_critical_roads(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[Tuple[int, int]]]: Finds the critical roads in a graph represented by n nodes and m edges. Args: n (int): Number of castles (vertices) m (int): Number of roads (edges) edges (list of tuple): List of edges (u, v, w) where u and v are castles and w is the weight Returns: tuple: Number of critical roads and a list of critical roads >>> find_critical_roads(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) (0, []) >>> find_critical_roads(3, 2, [(1, 2, 1), (2, 3, 1)]) (2, [(1, 2), (2, 3)]) n, m = 3, 3 edges = [(1, 2, 1), (2, 3, 1), (3, 1, 1)] num_critical_roads, critical_roads = find_critical_roads(n, m, edges) print(num_critical_roads) # Output: 0 print(critical_roads) # Output: [] n, m = 3, 2 edges = [(1, 2, 1), (2, 3, 1)] num_critical_roads, critical_roads = find_critical_roads(n, m, edges) print(num_critical_roads) # Output: 2 print(critical_roads) # Output: [(1, 2), (2, 3)]","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) def find_critical_roads(n, m, edges): Finds the critical roads in a graph represented by n nodes and m edges. Args: n (int): Number of castles (vertices) m (int): Number of roads (edges) edges (list of tuple): List of edges (u, v, w) where u and v are castles and w is the weight Returns: tuple: Number of critical roads and a list of critical roads def dfs(v, parent): nonlocal timer ids[v] = low[v] = timer timer += 1 for to in graph[v]: if to == parent: continue if ids[to] == -1: dfs(to, v) low[v] = min(low[v], low[to]) if low[to] > ids[v]: critical_roads.append((v, to)) else: low[v] = min(low[v], ids[to]) graph = defaultdict(list) for u, v, w in edges: graph[u].append(v) graph[v].append(u) ids = [-1] * (n + 1) low = [-1] * (n + 1) timer = 0 critical_roads = [] for i in range(1, n + 1): if ids[i] == -1: dfs(i, -1) return len(critical_roads), critical_roads"},{"question":"from typing import List, Tuple def find_closest_sum_pair(arr: List[int], x: int) -> Tuple[int, int]: Given an array of n integers and an integer x, find two integers in the array such that their sum is closest to x. >>> find_closest_sum_pair([1, 3, 4, 7, 10], 8) (3, 4) >>> find_closest_sum_pair([-1, 2, 1, -4], 1) (-1, 2) >>> find_closest_sum_pair([0, 0, 0, 0], 3) (0, 0) >>> find_closest_sum_pair([10000, -10000, 3000, -3000, 5000, -5000], -2000) (-5000, 3000) >>> find_closest_sum_pair([-5, -3, -4, -2, -1], -10) (-5, -4) >>> find_closest_sum_pair([1, 5, 7, 9, 11], 20) (9, 11)","solution":"def find_closest_sum_pair(arr, x): Finds two integers in the array such that their sum is closest to x. arr.sort() n = len(arr) closest_sum = float('inf') left, right = 0, n - 1 best_pair = (arr[0], arr[1]) while left < right: current_sum = arr[left] + arr[right] if abs(current_sum - x) < abs(closest_sum - x): closest_sum = current_sum best_pair = (arr[left], arr[right]) if current_sum < x: left += 1 elif current_sum > x: right -= 1 else: break return best_pair"},{"question":"from typing import List def largest_mountain(arr: List[int]) -> int: Returns the length of the largest mountain subarray, or 0 if no such mountain exists. A sequence of integers is called a \\"mountain\\" if there exists some index 1 <= k <= n such that the sequence: a_1, a_2, ..., a_k, a_k+1, ..., a_n satisfies: - a_1 < a_2 < ... < a_k (strictly increasing up to the peak) - a_k > a_k+1 > ... > a_n (strictly decreasing after the peak) >>> largest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> largest_mountain([2, 2, 2]) 0","solution":"def largest_mountain(arr): Returns the length of the largest mountain subarray, or 0 if no such mountain exists. n = len(arr) if n < 3: return 0 max_len = 0 i = 1 while i < n - 1: # Check if arr[i] is a peak of a mountain if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 # Move left pointer down the mountain while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Move right pointer down the mountain while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the mountain current_len = right - left + 1 max_len = max(max_len, current_len) # Move i to the end of this mountain segment i = right else: i += 1 return max_len"},{"question":"def find_min_road_length(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Uses Kruskal's Algorithm to find the Minimum Spanning Tree (MST) of the graph. Parameters: n (int): The number of cities. m (int): The number of roads. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w). Returns: int: The minimal total length of the roads needed, or 'Impossible' if not all cities can be connected. >>> find_min_road_length(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 3), (1, 3, 2)]) 4 >>> find_min_road_length(1, 0, []) 0 >>> find_min_road_length(2, 1, [(1, 2, 5)]) 5 >>> find_min_road_length(3, 1, [(1, 2, 3)]) 'Impossible' >>> find_min_road_length(4, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 3, 2), (2, 4, 2), (1, 4, 2)]) 6 >>> find_min_road_length(4, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 4, 3), (2, 4, 1)]) 5","solution":"def find_min_road_length(n, m, edges): Uses Kruskal's Algorithm to find the Minimum Spanning Tree (MST) of the graph. Parameters: n (int): The number of cities. m (int): The number of roads. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w). Returns: int: The minimal total length of the roads needed, or 'Impossible' if not all cities can be connected. # Helper function to find the root of a node in the Union-Find structure def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to do union of two subsets in the Union-Find structure def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Initialize union-find structures parent = [] rank = [] # Initially, each city is its own parent for node in range(n): parent.append(node) rank.append(0) # Sort edges based on weight edges = sorted(edges, key=lambda item: item[2]) mst_weight = 0 mst_edges = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_weight += w mst_edges += 1 union(parent, rank, root_u, root_v) if mst_edges == n - 1: break if mst_edges == n - 1: return mst_weight else: return \\"Impossible\\" # Example usage n = 4 m = 5 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 3), (1, 3, 2) ] print(find_min_road_length(n, m, edges)) # Output should be 4"},{"question":"def schedule_auction(n: int, m: int, d: int, items: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Given n items with their predicted bidding range and the maximum price m for each day, schedule items for auction in a way to maximize the total auction earnings. Parameters: n (int): Number of items. m (int): Maximum price on any day. d (int): Number of auction days. items (list of tuples): List of bidding range (li, ri) for each item. Returns: list of tuples: List of tuples (start_day, end_day) for each item. >>> schedule_auction(4, 100, 10, [(30, 50), (40, 70), (20, 60), (50, 80)]) [(1, 2), (3, 4), (5, 6), (7, 8)] >>> schedule_auction(4, 100, 10, [(30, 50), (10, 20), (40, 70), (50, 80)]) [(1, 2), (3, 4), (5, 6), (7, 8)] >>> schedule_auction(1, 1, 1, [(1, 1)]) [(1, 2)] >>> schedule_auction(100, 1000, 10000, [(1, 1000) for _ in range(100)]) [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17, 18), (19, 20), (21, 22), (23, 24), (25, 26), (27, 28), (29, 30), (31, 32), (33, 34), (35, 36), (37, 38), (39, 40), (41, 42), (43, 44), (45, 46), (47, 48), (49, 50), (51, 52), (53, 54), (55, 56), (57, 58), (59, 60), (61, 62), (63, 64), (65, 66), (67, 68), (69, 70), (71, 72), (73, 74), (75, 76), (77, 78), (79, 80), (81, 82), (83, 84), (85, 86), (87, 88), (89, 90), (91, 92), (93, 94), (95, 96), (97, 98), (99, 100), (101, 102), (103, 104), (105, 106), (107, 108), (109, 110), (111, 112), (113, 114), (115, 116), (117, 118), (119, 120), (121, 122), (123, 124), (125, 126), (127, 128), (129, 130), (131, 132), (133, 134), (135, 136), (137, 138), (139, 140), (141, 142), (143, 144), (145, 146), (147, 148), (149, 150), (151, 152), (153, 154), (155, 156), (157, 158), (159, 160), (161, 162), (163, 164), (165, 166), (167, 168), (169, 170), (171, 172), (173, 174), (175, 176), (177, 178), (179, 180), (181, 182), (183, 184), (185, 186), (187, 188), (189, 190), (191, 192), (193, 194), (195, 196), (197, 198), (199, 200)]","solution":"def schedule_auction(n, m, d, items): Given n items with their predicted bidding range and the maximum price m for each day, schedule items for auction in a way to maximize the total auction earnings. Parameters: n (int): Number of items. m (int): Maximum price on any day. d (int): Number of auction days. items (list of tuples): List of bidding range (li, ri) for each item. Returns: list of tuples: List of tuples (start_day, end_day) for each item. # Sort items by their minimum bid price (li), and if equal, by maximum bid price (ri) sorted_items = sorted(items, key=lambda x: (x[0], x[1])) # Initialize the result list auction_schedule = [(0, 0)] * n # Keep track of the current day current_day = 1 for i in range(n): li, ri = sorted_items[i] # Assuming the auction takes place within d days start_day = current_day end_day = current_day + 1 # Assign the days to the current item auction_schedule[i] = (start_day, end_day) # Move to the next day for the next item current_day += 2 # If current_day exceeds the number of available days \`d\`, wrap around to start over if current_day > d: current_day = 1 return auction_schedule"},{"question":"def verify_and_earliest(messages): Verify the integrity of the conversation ensuring no two messages with the same id have identical timestamp values, and return the earliest version of each message sorted by timestamp. Args: messages: List of tuples with (id, timestamp, content) Returns: List of strings representing the contents of the earliest version of each unique message id sorted by their timestamp. If any id has non-unique timestamps, return an empty list. Examples: >>> verify_and_earliest([(1, 10, \\"Hello\\"), (2, 15, \\"How are you?\\"), (1, 20, \\"Hello there\\"), (3, 15, \\"Just checking\\"), (2, 18, \\"How have you been?\\"), (3, 25, \\"Checking again\\")]) [\\"Hello\\", \\"How are you?\\", \\"Just checking\\"] >>> verify_and_earliest([(1, 10, \\"Hello\\"), (2, 15, \\"How are you?\\"), (1, 10, \\"Hello there\\"), (3, 15, \\"Just checking\\"), (2, 18, \\"How have you been?\\"), (3, 25, \\"Checking again\\")]) [] def test_verify_and_earliest_normal_case(): messages = [ (1, 10, \\"Hello\\"), (2, 15, \\"How are you?\\"), (1, 20, \\"Hello there\\"), (3, 15, \\"Just checking\\"), (2, 18, \\"How have you been?\\"), (3, 25, \\"Checking again\\") ] assert verify_and_earliest(messages) == [\\"Hello\\", \\"How are you?\\", \\"Just checking\\"] def test_verify_and_earliest_duplicate_timestamps(): messages = [ (1, 10, \\"Hello\\"), (2, 15, \\"How are you?\\"), (1, 10, \\"Hello there\\"), (3, 15, \\"Just checking\\"), (2, 18, \\"How have you been?\\"), (3, 25, \\"Checking again\\") ] assert verify_and_earliest(messages) == [] def test_verify_and_earliest_empty_messages(): messages = [] assert verify_and_earliest(messages) == [] def test_verify_and_earliest_single_message(): messages = [(1, 5, \\"Single message\\")] assert verify_and_earliest(messages) == [\\"Single message\\"] def test_verify_and_earliest_same_id_different_timestamps(): messages = [ (1, 10, \\"First message\\"), (1, 15, \\"Second message\\"), (1, 5, \\"Earliest message\\") ] assert verify_and_earliest(messages) == [\\"Earliest message\\"] def test_verify_and_earliest_same_id_same_content_different_timestamps(): messages = [ (1, 10, \\"Repeat\\"), (1, 5, \\"Repeat\\") ] assert verify_and_earliest(messages) == [\\"Repeat\\"] def test_verify_and_earliest_multiple_ids_inconsistent_timestamps(): messages = [ (1, 10, \\"First\\"), (1, 20, \\"Second\\"), (2, 10, \\"Third\\"), (2, 20, \\"Fourth\\"), (2, 10, \\"Fifth\\") ] assert verify_and_earliest(messages) == []","solution":"def verify_and_earliest(messages): from collections import defaultdict message_timestamp = defaultdict(set) earliest_version = {} for message_id, timestamp, content in messages: if timestamp in message_timestamp[message_id]: return [] message_timestamp[message_id].add(timestamp) if message_id not in earliest_version or earliest_version[message_id]['timestamp'] > timestamp: earliest_version[message_id] = {'timestamp': timestamp, 'content': content} result = sorted(earliest_version.values(), key=lambda x: x['timestamp']) return [entry['content'] for entry in result]"},{"question":"def find_longest_palindromic_subsequence_lengths(strings: List[str]) -> List[int]: Given a list of strings, return the length of the longest palindromic subsequence for each string. >>> find_longest_palindromic_subsequence_lengths([\\"character\\", \\"racecar\\", \\"level\\", \\"abcba\\"]) [5, 7, 5, 5] >>> find_longest_palindromic_subsequence_lengths([\\"a\\", \\"b\\", \\"c\\"]) [1, 1, 1] >>> find_longest_palindromic_subsequence_lengths([\\"aaaaa\\", \\"bbbb\\"]) [5, 4] >>> find_longest_palindromic_subsequence_lengths([\\"abcd\\", \\"efgh\\"]) [1, 1] >>> find_longest_palindromic_subsequence_lengths([\\"axba\\", \\"acdc\\", \\"abcdef\\"]) [3, 3, 1] >>> find_longest_palindromic_subsequence_lengths([\\"\\"]) [0]","solution":"def longest_palindromic_subsequence_length(s): Given a string s, find the length of the longest palindromic subsequence. n = len(s) if n == 0: return 0 # Create a 2D array to store lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def find_longest_palindromic_subsequence_lengths(strings): Given a list of strings, return the length of the longest palindromic subsequence for each string. return [longest_palindromic_subsequence_length(s) for s in strings]"},{"question":"def update_matrix(matrix: List[List[int]]) -> List[List[int]]: Update the matrix in such a way that for each cell containing 0, set all elements in the corresponding row and column to zero. Args: matrix (List[List[int]]): A 2D list of non-negative integers. Returns: List[List[int]]: The updated matrix where appropriate rows and columns are set to zero based on initial zero cells. Example: >>> update_matrix([ >>> [1, 2, 3], >>> [4, 0, 6], >>> [7, 8, 9] >>> ]) >>> [ >>> [1, 0, 3], >>> [0, 0, 0], >>> [7, 0, 9] >>> ]","solution":"def update_matrix(matrix): Update matrix based on zero cells affecting their rows and columns. n = len(matrix) m = len(matrix[0]) rows_to_zero = set() cols_to_zero = set() # Find all the rows and columns that need to be zeroed for i in range(n): for j in range(m): if matrix[i][j] == 0: rows_to_zero.add(i) cols_to_zero.add(j) # Set the identified rows to zero for i in rows_to_zero: for j in range(m): matrix[i][j] = 0 # Set the identified columns to zero for j in cols_to_zero: for i in range(n): matrix[i][j] = 0 return matrix"},{"question":"from typing import List def can_transform_to_permutations(q: int, queries: List[str]) -> List[str]: Determine if two strings can be transformed into permutations of each other while maintaining the common subsequence length. Args: q (int): The number of queries. queries (List[str]): Each pair of strings to be tested. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each query. >>> can_transform_to_permutations(3, [\\"hello\\", \\"ollhe\\", \\"abc\\", \\"bca\\", \\"abcd\\", \\"efgh\\"]) ['YES', 'YES', 'NO'] >>> can_transform_to_permutations(2, [\\"test\\", \\"sett\\", \\"apple\\", \\"ppalel\\"]) ['YES', 'NO'] >>> can_transform_to_permutations(1, [\\"pattern\\", \\"patrent\\"]) ['YES'] >>> can_transform_to_permutations(2, [\\"a\\", \\"a\\", \\"a\\", \\"b\\"]) ['YES', 'NO'] pass","solution":"from collections import Counter def can_transform_to_permutations(q, queries): results = [] for i in range(q): s = queries[2*i] t = queries[2*i + 1] s_counter = Counter(s) t_counter = Counter(t) if s_counter == t_counter: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def merge_towers(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum cost required to merge all the towers into one tower for each test case. >>> merge_towers(2, [(4, [4, 3, 2, 5]), (3, [2, 1, 3])]) [4, 2] >>> merge_towers(1, [(1, [5])]) [0] >>> merge_towers(1, [(3, [4, 4, 4])]) [0] >>> merge_towers(1, [(4, [1, 2, 3, 4])]) [3] >>> merge_towers(1, [(1000, [i for i in range(1, 1001)])]) [999]","solution":"def merge_towers(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] total_cost = 0 while len(heights) > 1: min_cost = float('inf') merge_index = 0 for j in range(len(heights) - 1): cost = abs(heights[j] - heights[j + 1]) if cost < min_cost: min_cost = cost merge_index = j total_cost += min_cost new_height = max(heights[merge_index], heights[merge_index + 1]) heights = heights[:merge_index] + [new_height] + heights[merge_index + 2:] results.append(total_cost) return results"},{"question":"from typing import List, Tuple def can_reorganize(s: str, k: int) -> bool: Determines if it is possible to rearrange the string s such that each species is grouped together with at least k same characters consecutively. Parameters: s (str): The string representing the arrangement of animals. k (int): The minimum length of consecutive subarrays for each species. Returns: bool: True if reorganization is possible, otherwise False. >>> can_reorganize(\\"aabbcc\\", 2) True >>> can_reorganize(\\"aabb\\", 3) False pass # implementation here def process_test_cases(t: int, test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases and returns the results for each one. Parameters: t (int): The number of test cases. test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" indicating if reorganization is possible for each test case. >>> process_test_cases(2, [(\\"aabbcc\\", 2), (\\"aaabbbccc\\", 3)]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(2, [(\\"aabb\\", 3), (\\"abc\\", 2)]) [\\"NO\\", \\"NO\\"] pass # implementation here","solution":"from collections import Counter def can_reorganize(s, k): Determines if it is possible to rearrange the string s such that each species is grouped together with at least k same characters consecutively. char_count = Counter(s) for count in char_count.values(): if count < k: return False return True def process_test_cases(t, test_cases): results = [] for i in range(t): s, k = test_cases[i] if can_reorganize(s, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_routes_to_shorten(n, m, k, routes): Function to count the number of bus routes that need to be shortened to ensure no passenger can visit more than k consecutive stops in a single trip without changing routes. :param n: Number of bus routes :param m: Number of bus stops :param k: Maximum allowed number of consecutive stops :param routes: List of tuples, each containing two integers (ai, bi) describing the endpoints of a bus route :return: Number of routes that need to be shortened pass import pytest def test_count_routes_to_shorten_example(): assert count_routes_to_shorten(5, 15, 4, [(1, 5), (2, 6), (5, 9), (8, 12), (10, 15)]) == 1 def test_count_routes_to_shorten_no_routes_to_shorten(): assert count_routes_to_shorten(3, 10, 5, [(1, 5), (2, 6), (4, 9)]) == 0 def test_count_routes_to_shorten_all_routes_to_shorten(): assert count_routes_to_shorten(4, 12, 3, [(1, 5), (2, 7), (4, 8), (5, 10)]) == 4 def test_count_routes_to_shorten_mixed_routes(): assert count_routes_to_shorten(6, 20, 4, [(1, 2), (3, 7), (5, 10), (6, 11), (9, 14), (12, 17)]) == 4 def test_count_routes_to_shorten_single_route(): assert count_routes_to_shorten(1, 10, 3, [(1, 2)]) == 0 assert count_routes_to_shorten(1, 10, 3, [(1, 5)]) == 1","solution":"def count_routes_to_shorten(n, m, k, routes): Function to count the number of bus routes that need to be shortened to ensure no passenger can visit more than k consecutive stops in a single trip without changing routes. :param n: Number of bus routes :param m: Number of bus stops :param k: Maximum allowed number of consecutive stops :param routes: List of tuples, each containing two integers (ai, bi) describing the endpoints of a bus route :return: Number of routes that need to be shortened routes_to_shorten = 0 for a, b in routes: if b - a > k: routes_to_shorten += 1 return routes_to_shorten"},{"question":"def process_commands(commands): Processes a series of warehouse commands and returns the results of 'RETRIEVE' operations. :param commands: List of tuple where each tuple contains ('STORE' or 'RETRIEVE', x) :return: List of results for 'RETRIEVE' operations. >>> commands = [('STORE', 1), ('STORE', 2), ('RETRIEVE', 1), ('RETRIEVE', 3), ('STORE', 3), ('RETRIEVE', 3), ('RETRIEVE', 2), ('RETRIEVE', 4)] >>> process_commands(commands) [1, 'NOT FOUND', 3, 2, 'NOT FOUND'] >>> commands = [('STORE', 1), ('STORE', 2), ('STORE', 3)] >>> process_commands(commands) [] >>> commands = [('RETRIEVE', 1), ('RETRIEVE', 2), ('RETRIEVE', 3)] >>> process_commands(commands) ['NOT FOUND', 'NOT FOUND', 'NOT FOUND'] >>> commands = [('STORE', 10), ('RETRIEVE', 10), ('STORE', 20), ('STORE', 30), ('STORE', 20), ('RETRIEVE', 20), ('RETRIEVE', 20), ('RETRIEVE', 30)] >>> process_commands(commands) [10, 20, 'NOT FOUND', 30]","solution":"def process_commands(commands): Processes a series of warehouse commands and returns the results of 'RETRIEVE' operations. :param commands: List of tuple where each tuple contains ('STORE' or 'RETRIEVE', x) :return: List of results for 'RETRIEVE' operations. warehouse = set() result = [] for command, x in commands: if command == \\"STORE\\": warehouse.add(x) elif command == \\"RETRIEVE\\": if x in warehouse: result.append(x) warehouse.remove(x) else: result.append(\\"NOT FOUND\\") return result"},{"question":"def final_position(n: int, moves: List[Tuple[str, int]], constraints: List[Tuple[int, int, int]]) -> Union[str, Tuple[str, int]]: Determine Alice's final position on a 1D number line or state that the moves are not possible. Parameters: n (int): The number of moves. moves (List[Tuple[str, int]]): A list of tuples where each tuple contains a character ('L' or 'R') and an integer, representing a move left or right by that number of steps. constraints (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (li, ri, si), indicating the total number of steps between moves li and ri must be exactly si. Returns: Union[str, Tuple[str, int]]: Returns \\"YES\\" and Alice's final position if the constraints are satisfied. Otherwise, returns \\"NO\\". Examples: >>> final_position(1, [('L', 5)], [(1, 1, -5)]) (\\"YES\\", -5) >>> final_position(1, [('R', 10)], [(1, 1, 10)]) (\\"YES\\", 10) >>> final_position(3, [('R', 1), ('L', 2), ('R', 3)], []) (\\"YES\\", 2) >>> final_position(4, [('R', 1), ('L', 2), ('R', 5), ('L', 4)], [(1, 4, 0)]) (\\"YES\\", 0) >>> final_position(3, [('L', 1), ('R', 2), ('L', 1)], [(1, 3, 1)]) \\"NO\\"","solution":"def final_position(n, moves, constraints): position = 0 move_array = [0] * n # Convert the moves to an array where left is negative and right is positive for i in range(n): c, d = moves[i] move_array[i] = d if c == 'R' else -d for li, ri, si in constraints: # Calculate the sum of the subarray from li-1 to ri-1 subarray_sum = sum(move_array[li-1:ri]) # Check if the subarray sum equals si if subarray_sum != si: return \\"NO\\" position = sum(move_array) return \\"YES\\", position"},{"question":"def lexicographically_smallest_string(n: int, s: str) -> str: This function takes an integer n and a string s of length n and returns the lexicographically smallest string obtainable by moving any substring of s to the beginning any number of times. >>> lexicographically_smallest_string(7, 'bacdafb') 'aabbcdf' >>> lexicographically_smallest_string(5, 'edcba') 'abcde' >>> lexicographically_smallest_string(3, 'cba') 'abc' >>> lexicographically_smallest_string(4, 'dcba') 'abcd' >>> lexicographically_smallest_string(6, 'gfedcb') 'bcdefg' >>> lexicographically_smallest_string(8, 'hgfedcba') 'abcdefgh'","solution":"def lexicographically_smallest_string(n, s): This function takes an integer n and a string s of length n and returns the lexicographically smallest string obtainable by moving any substring of s to the beginning any number of times. min_char = min(s) smallest_string = ''.join(sorted(s)) return smallest_string"},{"question":"from typing import List, Tuple def max_subarray_sum(nums: List[int]) -> int: Returns the maximum score (sum) of any contiguous subarray. >>> max_subarray_sum([1, -2, 3, 4, -1]) 7 >>> max_subarray_sum([-1, -2, -3]) -1 def archery_sessions(t: int, sessions: List[Tuple[int, List[int]]]) -> List[int]: For each practice session, return the maximum score from hitting any contiguous segment of targets. >>> archery_sessions(2, [(5, [1, -2, 3, 4, -1]), (3, [-1, -2, -3])]) [7, -1] >>> archery_sessions(1, [(4, [-2, 1, -3, 4])]) [4]","solution":"def max_subarray_sum(nums): Returns the maximum score (sum) of any contiguous subarray. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def archery_sessions(t, sessions): results = [] for session in sessions: n, scores = session results.append(max_subarray_sum(scores)) return results"},{"question":"from typing import List, Tuple def can_paint_house(N: int, M: int, edges: List[Tuple[int, int]], K: int) -> str: Determine if it is possible to paint the house with the given constraints. >>> can_paint_house(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 3) \\"YES\\" >>> can_paint_house(3, 3, [(1, 2), (2, 3), (3, 1)], 2) \\"NO\\" def test_case_1(): edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert can_paint_house(4, 4, edges, 3) == \\"YES\\" def test_case_2(): edges = [(1, 2), (2, 3), (3, 1)] assert can_paint_house(3, 3, edges, 2) == \\"NO\\" def test_case_3(): edges = [(1, 2), (2, 3), (1, 3)] assert can_paint_house(3, 3, edges, 3) == \\"YES\\" def test_case_4(): edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert can_paint_house(5, 5, edges, 2) == \\"NO\\" def test_case_5(): edges = [(1, 2)] assert can_paint_house(2, 1, edges, 2) == \\"YES\\" def test_case_6(): edges = [] assert can_paint_house(1, 0, edges, 1) == \\"YES\\" def test_case_7(): edges = [(1, 2), (2, 3), (3, 4)] assert can_paint_house(4, 3, edges, 2) == \\"YES\\" def test_case_8(): edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] assert can_paint_house(6, 6, edges, 2) == \\"YES\\" def test_case_9(): edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert can_paint_house(5, 4, edges, 2) == \\"YES\\" def test_case_10(): edges = [(1, 2), (1, 3), (1, 4), (1, 5)] assert can_paint_house(5, 4, edges, 3) == \\"YES\\"","solution":"def can_paint_house(N, M, edges, K): from collections import defaultdict def is_bipartite(graph, n): color = [-1] * n def bfs(src): queue = [src] color[src] = 0 while queue: u = queue.pop(0) for v in graph[u]: if color[v] == -1: color[v] = 1 - color[u] queue.append(v) elif color[v] == color[u]: return False return True for i in range(n): if color[i] == -1: if not bfs(i): return False return True graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) if K >= 3: return \\"YES\\" elif K == 2 and is_bipartite(graph, N): return \\"YES\\" elif K == 1 and N == 1: return \\"YES\\" else: return \\"NO\\" # Example Usage: edges1 = [(1, 2), (2, 3), (3, 4), (4, 1)] print(can_paint_house(4, 4, edges1, 3)) # Output: \\"YES\\" edges2 = [(1, 2), (2, 3), (3, 1)] print(can_paint_house(3, 3, edges2, 2)) # Output: \\"NO\\""},{"question":"def longest_consecutive_subsequence_length(n: int, sequence: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers from a given sequence of n integers. >>> longest_consecutive_subsequence_length(5, [4, 2, 1, 6, 5]) == 3 >>> longest_consecutive_subsequence_length(5, [10, 100, 101, 102, 103]) == 4 >>> longest_consecutive_subsequence_length(0, []) == 0 >>> longest_consecutive_subsequence_length(5, [1, 2, 3, 4, 5]) == 5 >>> longest_consecutive_subsequence_length(7, [10, 20, 30, 40, 50, 60, 70]) == 1 >>> longest_consecutive_subsequence_length(9, [100, 4, 200, 1, 3, 2, 101, 102, 103]) == 4 >>> longest_consecutive_subsequence_length(6, [5, 5, 5, 5, 5, 5]) == 1 >>> longest_consecutive_subsequence_length(8, [1, 9, 3, 10, 4, 20, 2, 30]) == 4 >>> longest_consecutive_subsequence_length(5, [1, 2, 2, 3, 4]) == 4","solution":"def longest_consecutive_subsequence_length(n, sequence): Returns the length of the longest subsequence of consecutive integers. if n == 0: return 0 sequence = set(sequence) longest_length = 0 for number in sequence: if number - 1 not in sequence: # number is the start of a new sequence current_number = number current_length = 1 while current_number + 1 in sequence: current_number += 1 current_length += 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"from typing import List, Tuple def find_winner(n: int, series: List[int]) -> str: Determines the winner of the game given the series of numbers. :param n: Number of integers in the series :param series: List of integers in the series :return: 'Alice' or 'Bob' depending on who the winner is >>> find_winner(3, [6, 10, 15]) 'Alice' >>> find_winner(2, [3, 6]) 'Bob' >>> find_winner(4, [2, 4, 6, 8]) 'Bob' pass def game_winner(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the winner for each test case. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains number of integers and the list of integers :return: List of strings where each string is either 'Alice' or 'Bob' >>> game_winner(3, [(3, [6, 10, 15]), (2, [3, 6]), (4, [2, 4, 6, 8])]) ['Alice', 'Bob', 'Bob'] pass import pytest def test_single_case(): assert find_winner(3, [6, 10, 15]) == \\"Alice\\" assert find_winner(2, [3, 6]) == \\"Bob\\" assert find_winner(4, [2, 4, 6, 8]) == \\"Bob\\" def test_multiple_cases(): t = 3 test_cases = [ (3, [6, 10, 15]), (2, [3, 6]), (4, [2, 4, 6, 8]) ] assert game_winner(t, test_cases) == [\\"Alice\\", \\"Bob\\", \\"Bob\\"] def test_immediate_loss(): assert find_winner(2, [3, 5]) == \\"Alice\\" # GCD is 1 initially assert find_winner(5, [2, 3, 5, 7, 11]) == \\"Alice\\" # GCD is 1 initially def test_no_immediate_loss(): assert find_winner(3, [12, 18, 24]) == \\"Bob\\" # GCD is not 1 assert find_winner(4, [100, 50, 25, 75]) == \\"Bob\\" # GCD is not 1 def test_corner_cases(): assert find_winner(2, [1, 1]) == \\"Alice\\" # GCD is 1 initially assert find_winner(2, [100, 100]) == \\"Bob\\" # GCD is not 1 if __name__ == \\"__main__\\": pytest.main()","solution":"from math import gcd from functools import reduce def find_winner(n, series): Determines the winner of the game given the series of numbers. :param n: Number of integers in the series :param series: List of integers in the series :return: 'Alice' or 'Bob' depending on who the winner is initial_gcd = reduce(gcd, series) # If the initial GCD is 1, Alice loses immediately. if initial_gcd == 1: return \\"Alice\\" # If the initial GCD is not 1, Alice can ensure Bob loses. return \\"Bob\\" def game_winner(t, test_cases): Determines the winner for each test case. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains number of integers and the list of integers :return: List of strings where each string is either 'Alice' or 'Bob' results = [] for n, series in test_cases: results.append(find_winner(n, series)) return results"},{"question":"def max_non_adjacent_sum(nums) -> int: Returns the maximum sum of non-adjacent elements from the list of integers. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([0, 0, 0, 0]) 0 >>> max_non_adjacent_sum([100, 200, 300, 400, 500]) 900","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements from the list of integers. if not nums: return 0 n = len(nums) if n == 1: return nums[0] max_excl = 0 max_incl = nums[0] for i in range(1, n): # Calculate the maximum sum excluding the current element new_excl = max(max_incl, max_excl) # Update the maximum sum including the current element max_incl = max_excl + nums[i] # Update the maximum sum excluding the current element max_excl = new_excl return max(max_incl, max_excl)"},{"question":"def kth_smallest_element(n: int, k: int, sequence: List[int]) -> int: Returns the k-th smallest element in the sequence. Parameters: - n: An integer representing the number of elements in the sequence. - k: An integer representing the position of the smallest element to be found. - sequence: A list of integers representing the sequence. Returns: - An integer representing the k-th smallest element in the sequence. >>> kth_smallest_element(5, 2, [10, 5, 3, 9, 7]) 5 >>> kth_smallest_element(6, 4, [1, 2, 6, 3, 5, 4]) 4","solution":"def kth_smallest_element(n, k, sequence): Returns the k-th smallest element in the sequence. Parameters: - n: An integer representing the number of elements in the sequence. - k: An integer representing the position of the smallest element to be found. - sequence: A list of integers representing the sequence. Returns: - An integer representing the k-th smallest element in the sequence. # Sort the sequence to find the k-th smallest element sorted_sequence = sorted(sequence) # Return the (k-1)-th element (0-indexed) from the sorted list return sorted_sequence[k-1]"},{"question":"def max_money(n: int, houses: List[int]) -> int: Determine the maximum amount of money that can be collected from the houses. >>> max_money(4, [3, 2, 5, 10]) 13 >>> max_money(1, [7]) 7 >>> max_money(2, [3, 2]) 3 >>> max_money(2, [2, 5]) 5 >>> max_money(5, [2, 7, 9, 3, 1]) 12 >>> max_money(6, [5, 5, 10, 100, 10, 5]) 110 >>> max_money(4, [0, 0, 0, 0]) 0 >>> max_money(0, []) 0","solution":"def max_money(n, houses): if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def can_reach_treasure(n: int, m: int, grid: List[List[int]]) -> str: Determines if it's possible to reach the bottom-right corner of the grid starting from the top-left corner. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of lists): The grid configuration with step counts. Returns: str: \\"YES\\" if it's possible to reach the bottom-right corner, \\"NO\\" otherwise. >>> can_reach_treasure(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'NO' >>> can_reach_treasure(3, 3, [[1, 1, 1], [1, 1, 1], [2, 2, 0]]) 'YES' >>> can_reach_treasure(2, 2, [[1, 1], [2, 0]]) 'YES' >>> can_reach_treasure(2, 2, [[1, 1], [1, 1]]) 'YES' >>> can_reach_treasure(2, 2, [[0, 0], [0, 0]]) 'NO' pass","solution":"def can_reach_treasure(n, m, grid): Determines if it's possible to reach the bottom-right corner of the grid starting from the top-left corner. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of lists): The grid configuration with step counts. Returns: str: \\"YES\\" if it's possible to reach the bottom-right corner, \\"NO\\" otherwise. from collections import deque # Directions are up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m # Queue for BFS queue = deque([(0, 0)]) visited = [[False]*m for _ in range(n)] visited[0][0] = True while queue: x, y = queue.popleft() step_count = grid[x][y] if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx * step_count, y + dy * step_count if is_within_bounds(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def minimize_sum(n: int, arr: List[int]) -> int: Given an array of integers, find the minimum possible sum of the elements in the array after performing zero or more operations. In one operation, you can choose two elements in the array, say a and b, and set either a to the value of b or b to the value of a. The goal is to find the minimal sum achievable. Parameters: n (int): The number of elements in the array. arr (List[int]): The list of integers representing the elements of the array. Returns: int: The minimum possible sum of the array elements. >>> minimize_sum(5, [5, 7, 10, 3, 6]) 15 >>> minimize_sum(3, [1, 2, 3]) 3","solution":"def minimize_sum(n, arr): Returns the minimum possible sum of the array elements after performing zero or more operations. Parameters: n (int): The number of elements in the array. arr (list of int): The list of integers representing the elements of the array. Returns: int: The minimum possible sum of the array elements. min_val = min(arr) return min_val * n"},{"question":"MOD = 10**9 + 7 def sum_of_differences(nums): Calculate the sum of all possible differences between the maximum and minimum element of every subarray of nums. >>> sum_of_differences([1, 3, 2]) 5 >>> sum_of_differences([42]) 0 >>> sum_of_differences([2, 4]) 2 >>> sum_of_differences([1, 2, 3]) 4 >>> sum_of_differences([3, 2, 1]) 4 >>> sum_of_differences([1000000000, 999999999]) 1 pass def test_sum_of_differences_basic(): assert sum_of_differences([1, 3, 2]) == 5 def test_sum_of_differences_single_element(): assert sum_of_differences([42]) == 0 def test_sum_of_differences_two_elements(): assert sum_of_differences([2, 4]) == 2 def test_sum_of_differences_increasing(): assert sum_of_differences([1, 2, 3]) == 4 def test_sum_of_differences_decreasing(): assert sum_of_differences([3, 2, 1]) == 4 def test_sum_of_differences_large_values(): assert sum_of_differences([1000000000, 999999999]) == 1 import pytest if __name__ == '__main__': pytest.main()","solution":"MOD = 10**9 + 7 def sum_of_differences(nums): n = len(nums) total_sum = 0 for i in range(n): min_sum = max_sum = 0 for j in range(i, n): if j == i: min_val = nums[i] max_val = nums[i] else: min_val = min(min_val, nums[j]) max_val = max(max_val, nums[j]) total_sum = (total_sum + max_val - min_val) % MOD return total_sum"},{"question":"from typing import List, Tuple def find_minimized_max_edge_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given a connected undirected graph with n nodes and m edges. Each edge has a weight associated with it. Find a path from node 1 to node n such that the maximum weight of edges in this path is minimized. Input Format: - n: number of nodes (2 ≤ n ≤ 1000) - m: number of edges (1 ≤ m ≤ 10000) - edges: list of tuples (u, v, w) representing edges between nodes u and v with weight w (1 ≤ u, v ≤ n, 1 ≤ w ≤ 10^6) Output Format: - Return a single integer, the minimized maximum edge weight in the path from node 1 to node n. >>> find_minimized_max_edge_weight(5, 6, [(1, 2, 4), (1, 3, 2), (2, 4, 6), (3, 4, 8), (3, 5, 4), (4, 5, 1)]) 4 >>> find_minimized_max_edge_weight(4, 5, [(1, 2, 5), (1, 3, 2), (2, 3, 1), (2, 4, 10), (3, 4, 4)]) 4 >>> find_minimized_max_edge_weight(2, 1, [(1, 2, 10)]) 10 >>> find_minimized_max_edge_weight(3, 3, [(1, 2, 3), (2, 3, 3), (1, 3, 3)]) 3 pass # Test cases def test_example_case(): n = 5 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (2, 4, 6), (3, 4, 8), (3, 5, 4), (4, 5, 1) ] assert find_minimized_max_edge_weight(n, m, edges) == 4 def test_another_case(): n = 4 m = 5 edges = [ (1, 2, 5), (1, 3, 2), (2, 3, 1), (2, 4, 10), (3, 4, 4) ] assert find_minimized_max_edge_weight(n, m, edges) == 4 def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 10) ] assert find_minimized_max_edge_weight(n, m, edges) == 10 def test_path_with_same_weights(): n = 3 m = 3 edges = [ (1, 2, 3), (2, 3, 3), (1, 3, 3) ] assert find_minimized_max_edge_weight(n, m, edges) == 3","solution":"import heapq def find_minimized_max_edge_weight(n, m, edges): def can_pass_with_max_weight(max_weight): visited = [False] * (n + 1) queue = [1] visited[1] = True while queue: node = queue.pop(0) if node == n: return True for neighbor, weight in graph[node]: if not visited[neighbor] and weight <= max_weight: visited[neighbor] = True queue.append(neighbor) return False graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) left, right = 1, max(w for _, _, w in edges) result = right while left <= right: mid = (left + right) // 2 if can_pass_with_max_weight(mid): result = mid right = mid - 1 else: left = mid + 1 return result # Example usage: n = 5 m = 6 edges = [ (1, 2, 4), (1, 3, 2), (2, 4, 6), (3, 4, 8), (3, 5, 4), (4, 5, 1) ] print(find_minimized_max_edge_weight(n, m, edges)) # Output: 4"},{"question":"def minimum_swaps_to_sort(arr: List[int]) -> int: Returns the minimum number of swaps needed to sort the array in non-decreasing order. >>> minimum_swaps_to_sort([3, 1, 2, 5, 4]) 3 >>> minimum_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort([1, 3, 5, 2, 4, 6]) 3 >>> minimum_swaps_to_sort([1]) 0 >>> minimum_swaps_to_sort([4, 3, 2, 1]) 2","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps needed to sort the array in non-decreasing order. n = len(arr) indices = list(range(n)) indices.sort(key=lambda i: arr[i]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indices[i] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indices[j] cycle_size += 1 if cycle_size > 1: swaps += (cycle_size - 1) return swaps def read_input(): n = int(input().strip()) arr = list(map(int, input().strip().split())) return n, arr if __name__ == '__main__': n, arr = read_input() print(minimum_swaps_to_sort(arr))"},{"question":"def shortest_path(n: int, m: int, queries: List[Tuple[int, int, int, int]]) -> List[int]: Calculates the shortest path between two given seats in a grid. Parameters: n (int): Number of rows m (int): Number of columns queries (list): A list of queries, each containing four integers [r1, c1, r2, c2] Returns: List of integers: shortest path for each query >>> n, m, queries = 5, 5, [(1, 1, 3, 3), (2, 2, 4, 4), (5, 5, 1, 1)] >>> shortest_path(n, m, queries) [4, 4, 8] >>> n, m, queries = 5, 5, [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 4)] >>> shortest_path(n, m, queries) [1, 1, 1] >>> n, m, queries = 5, 5, [(1, 1, 1, 1), (2, 2, 2, 2), (5, 5, 5, 5)] >>> shortest_path(n, m, queries) [0, 0, 0] >>> n, m, queries = 10, 10, [(1, 1, 10, 10), (10, 1, 1, 10), (5, 5, 6, 6)] >>> shortest_path(n, m, queries) [18, 18, 2] >>> n, m, queries = 1000, 1000, [(1, 1, 1000, 1000), (500, 500, 1000, 1000), (1, 1000, 1000, 1)] >>> shortest_path(n, m, queries) [1998, 1000, 1998]","solution":"def shortest_path(n, m, queries): Calculates the shortest path between two given seats in a grid. Parameters: n (int): Number of rows m (int): Number of columns queries (list): A list of queries, each containing four integers [r1, c1, r2, c2] Returns: List of integers: shortest path for each query results = [] for r1, c1, r2, c2 in queries: path_length = abs(r1 - r2) + abs(c1 - c2) results.append(path_length) return results"},{"question":"import heapq import sys from typing import List, Tuple def minimum_transmission_cost(n: int, m: int, edges: List[Tuple[int, int, int]]) -> List[int]: Calculates the minimum transmission cost from the capital city to all other cities. Args: n (int): Number of cities. m (int): Number of transmission paths. edges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, and c indicating a path from city u to city v with a transmission cost of c. Returns: List[int]: Minimum transmission cost from the capital city (node 1) to each of the i-th cities (1-indexed). If a city is not reachable, returns -1 for that city. >>> minimum_transmission_cost(4, 4, [(1, 2, 1), (2, 3, 2), (1, 3, 4), (3, 4, 1)]) == [0, 1, 3, 4] >>> minimum_transmission_cost(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 1)]) == [0, 1, 3, 4] >>> minimum_transmission_cost(3, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)]) == [0, 1, 3] >>> minimum_transmission_cost(3, 0, []) == [0, -1, -1] >>> minimum_transmission_cost(5, 6, [(1, 2, 2), (1, 3, 3), (2, 4, 1), (3, 4, 1), (2, 5, 5), (4, 5, 1)]) == [0, 2, 3, 3, 4]","solution":"import heapq import sys def minimum_transmission_cost(n, m, edges): # Constants for infinity INF = sys.maxsize # Create adjacency list for the graph graph = [[] for _ in range(n + 1)] for u, v, c in edges: graph[u].append((v, c)) graph[v].append((u, c)) # Distance array to hold the minimum transmission cost to each city dist = [INF] * (n + 1) dist[1] = 0 # Min-heap priority queue pq = [(0, 1)] # (cost, node) while pq: current_cost, u = heapq.heappop(pq) # If we have already found a better way if current_cost > dist[u]: continue for v, cost in graph[u]: if dist[u] + cost < dist[v]: dist[v] = dist[u] + cost heapq.heappush(pq, (dist[v], v)) # Replace INF with -1 to indicate nodes that are not reachable return [dist[i] if dist[i] != INF else -1 for i in range(1, n + 1)]"},{"question":"def min_distance(S: str, T: str) -> int: Returns the minimum number of operations required to transform string S into string T. The allowed operations are: 1. Insert a character at any position. 2. Delete a character from any position. 3. Replace a character at any position with another character. Example: >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(S, T): Returns the minimum number of operations required to transform string S into string T. m, n = len(S), len(T) # Create a DP table to store the number of operations required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # Deleting all characters from S to match an empty T for j in range(n + 1): dp[0][j] = j # Inserting all characters into S to match T from an empty S # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no additional operation needed else: dp[i][j] = min(dp[i - 1][j], # Delete operation dp[i][j - 1], # Insert operation dp[i - 1][j - 1] # Replace operation ) + 1 return dp[m][n]"},{"question":"def max_rectangle_area(heights): Compute the maximum area of a rectangle formed by consecutive buildings. :param heights: List of integers representing the heights of buildings. :return: Maximum rectangle area. # TODO: Implement the function to find the maximum rectangle area from building heights. # Unit Tests def test_example_case(): assert max_rectangle_area([2, 1, 5, 6, 2, 3, 4]) == 10 def test_single_building(): assert max_rectangle_area([5]) == 5 def test_all_same_height(): assert max_rectangle_area([3, 3, 3, 3]) == 12 def test_increasing_heights(): assert max_rectangle_area([1, 2, 3, 4]) == 6 def test_decreasing_heights(): assert max_rectangle_area([4, 3, 2, 1]) == 6 def test_mixed_heights(): assert max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) == 12 def test_another_complex_case(): assert max_rectangle_area([2, 4, 2, 1, 10, 6, 10, 3]) == 18 def test_large_unvarying_heights(): large_heights = [1] * 1000000 assert max_rectangle_area(large_heights) == 1000000","solution":"def max_rectangle_area(heights): Compute the maximum area of a rectangle formed by consecutive buildings. :param heights: List of integers representing the heights of buildings. :return: Maximum rectangle area. stack = [] max_area = 0 index = 0 while index < len(heights): # If this building is higher than the building on the stack, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest building area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining buildings from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def count_islands(n: int, m: int, grid: List[str]) -> int: Returns the number of distinct islands in the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (list of str): the grid containing '1's and '0's Returns: int: number of distinct islands >>> grid = [ ... \\"1100\\", ... \\"1100\\", ... \\"0010\\" ... ] >>> count_islands(3, 4, grid) 2 >>> grid = [\\"1\\"] >>> count_islands(1, 1, grid) 1 >>> grid = [\\"0\\"] >>> count_islands(1, 1, grid) 0 >>> grid = [ ... \\"0000\\", ... \\"0000\\", ... \\"0000\\" ... ] >>> count_islands(3, 4, grid) 0 >>> grid = [ ... \\"1010\\", ... \\"0101\\", ... \\"1010\\" ... ] >>> count_islands(3, 4, grid) 6 >>> n = 1000 >>> m = 1000 >>> grid = [\\"0\\" * m for _ in range(n)] >>> grid[0] = \\"1\\" + \\"0\\" * (m - 1) >>> count_islands(n, m, grid) 1","solution":"def count_islands(n, m, grid): Returns the number of distinct islands in the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (list of str): the grid containing '1's and '0's Returns: int: number of distinct islands def dfs(grid, visited, i, j, n, m): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True # Move in all four possible directions dfs(grid, visited, i-1, j, n, m) dfs(grid, visited, i+1, j, n, m) dfs(grid, visited, i, j-1, n, m) dfs(grid, visited, i, j+1, n, m) visited = [[False] * m for _ in range(n)] islands = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(grid, visited, i, j, n, m) islands += 1 return islands"},{"question":"def largest_rectangle_area(n: int, k: int, points: List[List[int]]) -> int: Return the largest possible area of a rectangle with sides parallel to the coordinate axes that contains at least k of the given points. Args: n : int : the number of points k : int : the minimum number of points that must be inside the rectangle points : list of list of int : the coordinates of the points in the plane Returns: int : the largest possible area of such a rectangle. If not possible, return -1. >>> largest_rectangle_area(4, 2, [[1, 1], [1, 3], [3, 1], [3, 3]]) == 4 >>> largest_rectangle_area(4, 3, [[0, 0], [1000000000, 0], [1000000000, 1000000000], [0, 1000000000]]) == 1000000000000000000 >>> largest_rectangle_area(1, 2, [[1, 2]]) == -1 >>> largest_rectangle_area(5, 4, [[1, 2], [1, 2], [1, 2], [3, 4], [5, 6]]) == 16","solution":"def largest_rectangle_area(n, k, points): Return the largest possible area of a rectangle with sides parallel to the coordinate axes that contains at least k of the given points. Args: n : int : the number of points k : int : the minimum number of points that must be inside the rectangle points: list of list of int : the coordinates of the points in the plane Returns: int : the largest possible area of such a rectangle. If not possible, return -1. if k == 1: min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) return (max_x - min_x) * (max_y - min_y) points.sort() max_area = -1 for i in range(n): for j in range(i, n): if j - i + 1 < k: continue y_values = sorted(point[1] for point in points[i:j+1]) for l in range(j - i + 1 - k + 1): min_y = y_values[l] max_y = y_values[l + k - 1] min_x = points[i][0] max_x = points[j][0] area = (max_x - min_x) * (max_y - min_y) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def minimum_cost_to_reach_end(n: int, arr: List[int]) -> int: Determine the minimum cost required to reach the last element of the array from the first element with given movement restrictions. >>> minimum_cost_to_reach_end(5, [2, 3, 5, 4, 10]) 4 >>> minimum_cost_to_reach_end(3, [2, 3, 7]) -1 def test_example_case(): assert minimum_cost_to_reach_end(5, [2, 3, 5, 4, 10]) == 4 def test_impossible_case(): assert minimum_cost_to_reach_end(3, [2, 3, 7]) == -1 def test_direct_jump(): assert minimum_cost_to_reach_end(2, [1, 3]) == 1 def test_multiple_hops(): assert minimum_cost_to_reach_end(6, [1, 2, 4, 8, 16, 32]) == 5 def test_same_elements(): assert minimum_cost_to_reach_end(3, [5, 5, 5]) == 2 def test_large_values(): assert minimum_cost_to_reach_end(5, [10**9, 10**9, 10**9, 10**9, 10**9]) == 4 def test_small_to_large(): assert minimum_cost_to_reach_end(4, [1, 2, 4, 8]) == 3","solution":"from collections import deque def minimum_cost_to_reach_end(n, arr): # Initialize the minimum cost list with a large number min_cost = [float('inf')] * n min_cost[0] = 0 # Starting point has no cost queue = deque([0]) # Use a queue for BFS while queue: i = queue.popleft() for j in range(i + 1, n): if arr[j] % arr[i] == 0: if min_cost[j] > min_cost[i] + (j - i): min_cost[j] = min_cost[i] + (j - i) queue.append(j) return min_cost[-1] if min_cost[-1] != float('inf') else -1"},{"question":"from typing import List def min_cost_to_equal_array(nums: List[int]) -> int: Determines the minimum total cost to make all elements in the array equal. >>> min_cost_to_equal_array([1, 3, 5, 7]) 8 >>> min_cost_to_equal_array([5]) 0 >>> min_cost_to_equal_array([4, 4, 4, 4]) 0 >>> min_cost_to_equal_array([1, 7]) 6 >>> min_cost_to_equal_array([1, 100]) 99 >>> min_cost_to_equal_array([1, 2, 3, 4, 5]) 6 >>> min_cost_to_equal_array([]) 0","solution":"def min_cost_to_equal_array(nums): Determines the minimum total cost to make all elements in the array equal. :param nums: List of integers representing the array :return: Minimum total cost if len(nums) == 0: return 0 nums.sort() median = nums[len(nums) // 2] total_cost = sum(abs(num - median) for num in nums) return total_cost"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if a graph can be colored using two colors such that no two adjacent nodes share the same color. Returns \\"Yes\\" followed by a valid coloring if possible, otherwise returns \\"No\\". >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"Yes 1 2 1 2\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"No\\"","solution":"def is_bipartite(n, m, edges): from collections import deque, defaultdict def bfs_bipartite(v): queue = deque([v]) color[v] = 1 while queue: u = queue.popleft() for neighbor in graph[u]: if color[neighbor] == 0: color[neighbor] = 3 - color[u] # alternate between 1 and 2 queue.append(neighbor) elif color[neighbor] == color[u]: return False return True graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [0] * (n + 1) for node in range(1, n + 1): if color[node] == 0: if not bfs_bipartite(node): return \\"No\\" return \\"Yes \\" + \\" \\".join(map(str, color[1:])) # Example usage: # input_n = 4 # input_m = 4 # input_edges = [(1, 2), (2, 3), (3, 4), (4, 1)] # print(is_bipartite(input_n, input_m, input_edges))"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any subarray within the given array. Implements Kadane's Algorithm. >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([0]) == 0 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([10, 20, 30]) == 60 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([-10, -20, -30]) == -10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_subarray_sum(arr): Returns the maximum sum of any subarray within the given array. Implements Kadane's Algorithm. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_packages_delivered(n: int, time_windows: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Determine the maximum number of packages that can be delivered within their respective time windows. >>> max_packages_delivered(5, [(1, 4), (2, 6), (8, 9), (3, 5), (5, 7)]) (3, [1, 4, 5]) >>> max_packages_delivered(1, [(1, 3)]) (1, [1]) >>> max_packages_delivered(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) (4, [1, 2, 3, 4]) >>> max_packages_delivered(4, [(1, 3), (2, 5), (4, 6), (7, 8)]) (3, [1, 3, 4]) >>> max_packages_delivered(3, [(1, 3), (1, 3), (1, 3)]) (1, [1])","solution":"def max_packages_delivered(n, time_windows): # Sort packages by their earliest delivery time first, and then by their latest delivery time time_windows.sort(key=lambda x: (x[1], x[0])) delivered_count = 0 last_delivery_time = -1 delivered_indices = [] for i, (a, b) in enumerate(time_windows): if a > last_delivery_time: delivered_count += 1 last_delivery_time = b delivered_indices.append(i + 1) return delivered_count, delivered_indices"},{"question":"def min_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Gather has to split the gems into two groups such that the absolute difference between the sums of gem values in the two groups is minimized. :param t: The number of test cases. :param test_cases: A list of tuples where each tuple contains an integer n and a list of n integers representing the values of the gems. :return: A list of integers where each integer is the minimum possible absolute difference for the corresponding test case. >>> min_difference(2, [(4, [1, 3, 3, 4]), (3, [8, 5, 8])]) [1, 5] >>> min_difference(1, [(4, [2, 2, 2, 2])]) [0] >>> min_difference(1, [(5, [3, 1, 2, 2, 3])]) [1] >>> min_difference(1, [(1, [10])]) [10] >>> min_difference(1, [(4, [5, 5, 5, 5])]) [0] >>> min_difference(1, [(3, [1000, 2000, 3000])]) [0]","solution":"def min_difference(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] gems = test_cases[i][1] total_sum = sum(gems) target = total_sum // 2 dp = [0] * (target + 1) for gem in gems: for j in range(target, gem - 1, -1): dp[j] = max(dp[j], dp[j - gem] + gem) results.append(total_sum - 2 * dp[target]) print(f\\"Case {i} - sum {total_sum}, closest half {dp[target]}, difference {results[i]}\\") # Debug output return results"},{"question":"def max_sum_submatrix(matrix: List[List[int]]) -> int: Find the largest sum of elements in any contiguous submatrix within a given matrix. :param matrix: List[List[int]]: the nxm matrix of integers :return: int: the largest sum of elements across all possible contiguous submatrices >>> max_sum_submatrix([[5]]) 5 >>> max_sum_submatrix([[-5]]) -5 >>> max_sum_submatrix([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -1 >>> max_sum_submatrix([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_sum_submatrix([[1, -2, 3, 10, -4, 7, 2, -5]]) 18 >>> max_sum_submatrix([ ... [1], ... [-2], ... [3], ... [5], ... [-1], ... [6], ... [-3], ... [2] ... ]) 13 def kadane(arr: List[int]) -> int: Helper function to find the maximum sum subarray using Kadane's algorithm. :param arr: List[int]: the array of integers :return: int: the maximum sum subarray >>> kadane([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> kadane([-1, -2, -3, -4, -5]) -1 >>> kadane([5, -1, -2, 3, 4]) 9","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of any contiguous submatrix in the given 2D matrix. n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') # Iterate over every possible combination of top and bottom row for top in range(n): temp = [0] * m for bottom in range(top, n): # Add all elements of the current row to the temp array for i in range(m): temp[i] += matrix[bottom][i] # Find the maximum sum subarray in temp[] current_max = kadane(temp) max_sum = max(max_sum, current_max) return max_sum def kadane(arr): Helper function to find the maximum sum subarray using Kadane's algorithm. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def find(parent, i): Helper function to find the parent of node i in the Disjoint Set. if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): Helper function to perform union of two subsets x and y. root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): Kruskal's algorithm to find the Minimum Spanning Tree (MST) of a graph. edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < n - 1: if i >= len(edges): return -1 u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) total_weight = sum([w for u, v, w in result]) return total_weight def minimal_cost_to_connect_cities(n, m, roads): Determine the minimal cost required to connect all the cities in Graphland using the MST. Parameters: n (int): Number of cities m (int): Number of roads roads (List[Tuple[int, int, int]]): List of roads where each road is represented by a tuple (u, v, w) Returns: int: The minimum cost to connect all cities or -1 if it is impossible. Example: >>> minimal_cost_to_connect_cities(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> minimal_cost_to_connect_cities(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 edges = [] for road in roads: u, v, w = road edges.append((u-1, v-1, w)) return kruskal(n, edges)","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < n - 1: if i >= len(edges): return -1 u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) total_weight = sum([w for u, v, w in result]) return total_weight def minimal_cost_to_connect_cities(n, m, roads): edges = [] for road in roads: u, v, w = road edges.append((u-1, v-1, w)) return kruskal(n, edges) # Example usage # n = 4, m = 5 # roads = [ # (1, 2, 1), # (2, 3, 2), # (3, 4, 3), # (4, 1, 4), # (1, 3, 5) # ] # print(minimal_cost_to_connect_cities(n, m, roads)) # Output: 6"},{"question":"def min_tasks_for_even_total(n: int, coins: List[int]) -> int: Returns the minimum number of tasks needed to achieve an even-valued total of coins, or -1 if it is not possible. >>> min_tasks_for_even_total(1, [2]) 1 >>> min_tasks_for_even_total(1, [3]) -1 >>> min_tasks_for_even_total(5, [1, 3, 5, 6, 7]) 1 >>> min_tasks_for_even_total(5, [1, 3, 5, 7, 9]) 2 >>> min_tasks_for_even_total(0, []) -1 >>> min_tasks_for_even_total(4, [2, 4, 6, 8]) 1 >>> min_tasks_for_even_total(2, [1, 3]) 2","solution":"def min_tasks_for_even_total(n, coins): Returns the minimum number of tasks needed to achieve an even-valued total of coins, or -1 if it is not possible. # Separate the tasks into odd and even coins odd_coins = [coin for coin in coins if coin % 2 != 0] even_coins = [coin for coin in coins if coin % 2 == 0] # If there are no odd coins and no even coins, it's not possible to have an even total if not odd_coins and not even_coins: return -1 # If there's at least one even coin, we can select it to get an even total if even_coins: return 1 # If all coins are odd, we need to select at least two of them to get an even total (odd + odd = even) if len(odd_coins) >= 2: return 2 # Otherwise, it's not possible to achieve an even-valued total return -1"},{"question":"def calculate_fence_length(w, h, blocked_segments): Calculate the length of the fence that can be built along the perimeter of the field. Parameters: w (int): The width of the field. h (int): The height of the field. blocked_segments (list of tuples): List of blocked segments specified by their start and end coordinates. Returns: int: The length of the fence that can be built. >>> calculate_fence_length(5, 4, []) 18 >>> calculate_fence_length(5, 4, [(0, 0, 2, 0), (3, 4, 5, 4), (2, 0, 4, 0)]) 12 >>> calculate_fence_length(5, 4, [(0, 0, 5, 0), (5, 0, 5, 4), (5, 4, 0, 4), (0, 4, 0, 0)]) 0 >>> calculate_fence_length(5, 4, [(0, 0, 5, 0)]) 13 >>> calculate_fence_length(10, 10, [(0, 0, 3, 0), (5, 10, 10, 10)]) 32","solution":"def calculate_fence_length(w, h, blocked_segments): Calculate the length of the fence that can be built along the perimeter of the field. Parameters: w (int): The width of the field. h (int): The height of the field. blocked_segments (list of tuples): List of blocked segments specified by their start and end coordinates. Returns: int: The length of the fence that can be built. perimeter = 2 * (w + h) blocked_length = 0 for x1, y1, x2, y2 in blocked_segments: blocked_length += abs(x2 - x1) + abs(y2 - y1) return perimeter - blocked_length"},{"question":"from typing import List def minimize_max_consecutive(n: int, k: int, flowers: List[int]) -> int: Returns the minimum possible maximum number of consecutive flowerbeds containing Kiran's favorite flower after the optimal single rearrangement. :param n: int - number of flowerbeds :param k: int - type of Kiran's favorite flower :param flowers: List[int] - list of flower types :return: int - minimum possible maximum number of consecutive flowerbeds containing favorite flower >>> minimize_max_consecutive(7, 3, [1, 3, 3, 1, 3, 2, 3]) 2 >>> minimize_max_consecutive(5, 4, [1, 2, 3, 5, 6]) 0 >>> minimize_max_consecutive(5, 2, [2, 2, 2, 2, 2]) 5 >>> minimize_max_consecutive(7, 1, [1, 2, 3, 1, 4, 1, 1]) 2 >>> minimize_max_consecutive(1, 1, [1]) 1","solution":"def minimize_max_consecutive(n, k, flowers): Returns the minimum possible maximum number of consecutive flowerbeds containing Kiran's favorite flower after the optimal single rearrangement. :param n: int - number of flowerbeds :param k: int - type of Kiran's favorite flower :param flowers: List[int] - list of flower types :return: int - minimum possible maximum number of consecutive flowerbeds containing favorite flower def count_segments(flower_list, favorite_flower): count = 0 max_count = 0 segment_sizes = [] for flower in flower_list: if flower == favorite_flower: count += 1 else: if count > 0: segment_sizes.append(count) max_count = max(max_count, count) count = 0 if count > 0: segment_sizes.append(count) max_count = max(max_count, count) return max_count, segment_sizes max_count, segment_sizes = count_segments(flowers, k) if not segment_sizes: return 0 best_change = max_count for i in range(1, len(segment_sizes)): combined_segments = segment_sizes[i-1] + segment_sizes[i] + 1 best_change = min(best_change, max(max_count, combined_segments)) return best_change"},{"question":"from typing import List, Tuple def longest_subsequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest subsequence which is both strictly increasing and strictly decreasing, where the subsequence is not necessarily contiguous. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains: - An integer N, the number of elements in the sequence. - A list of N integers a_i, the elements of the sequence. Returns: List[int]: A list of integers where each integer represents the length of the longest subsequence for the corresponding test case. >>> longest_subsequence(2, [(7, [1, 2, 1, 2, 3, 2, 1]), (4, [5, 1, 5, 1])]) [5, 3] >>> longest_subsequence(1, [(6, [1, 3, 5, 4, 2, 3])]) [5]","solution":"def longest_subsequence(t, test_cases): results = [] for n, a in test_cases: lis = [1] * n lds = [1] * n # Calculate LIS (Longest Increasing Subsequence) for i in range(1, n): for j in range(0, i): if a[i] > a[j]: lis[i] = max(lis[i], lis[j] + 1) # Calculate LDS (Longest Decreasing Subsequence) for i in range(n-2, -1, -1): for j in range(n-1, i, -1): if a[i] > a[j]: lds[i] = max(lds[i], lds[j] + 1) # Find the maximum length of Bitonic Subsequence max_length = 0 for i in range(n): max_length = max(max_length, lis[i] + lds[i] - 1) results.append(max_length) return results"},{"question":"def find_unique_element(arr): This function takes an array where every element appears exactly three times except for one element which appears only once. It returns the unique element that appears only once. >>> find_unique_element([2, 2, 3, 2, 4, 4, 4]) 3 >>> find_unique_element([5, 3, 3, 3]) 5 >>> find_unique_element([6, 6, 7, 6]) 7 >>> find_unique_element([-1, -1, -2, -1]) -2 >>> find_unique_element([1000000000, -1000000000, 1000000000, 1000000000]) -1000000000 >>> find_unique_element([-1, 0, -1, 0, -1, 0, 99]) 99 >>> find_unique_element([10]) 10","solution":"def find_unique_element(arr): This function takes an array where every element appears exactly three times except for one element which appears only once. It returns the unique element that appears only once. # Initialize an array to hold the count of bits bit_count = [0] * 32 # Count the number of set bits at each position for num in arr: for i in range(32): if num & (1 << i): bit_count[i] += 1 # Resultant number result = 0 # Construct the single number from the bit counts mod 3 for i in range(32): if bit_count[i] % 3 != 0: result |= (1 << i) # To handle negative numbers if bit_count[31] % 3 != 0: # Checking the sign bit result -= (1 << 32) return result"},{"question":"def can_rearrange_books_unique_sums(n: int, difficulties: List[int]) -> str: Determines if it's possible to rearrange the books so that the sum of difficulties in every contiguous subarray is unique. :param n: Number of books (int) :param difficulties: List of difficulties of the books (List[int]) :return: \\"YES\\" if it's possible, otherwise \\"NO\\" (str) >>> can_rearrange_books_unique_sums(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_rearrange_books_unique_sums(4, [1, 1, 1, 1]) \\"NO\\" >>> can_rearrange_books_unique_sums(3, [7, 8, 9]) \\"YES\\" >>> can_rearrange_books_unique_sums(6, [1, -1, 2, -2, 3, -3]) \\"YES\\" >>> can_rearrange_books_unique_sums(7, [0, 0, 0, 0, 0, 0, 0]) \\"NO\\" >>> can_rearrange_books_unique_sums(1, [0]) \\"YES\\"","solution":"def can_rearrange_books_unique_sums(n, difficulties): Determines if it's possible to rearrange the books so that the sum of difficulties in every contiguous subarray is unique. :param n: Number of books (int) :param difficulties: List of difficulties of the books (List[int]) :return: \\"YES\\" if it's possible, otherwise \\"NO\\" (str) # If any two elements are the same, it's not possible to have unique sums for all subarrays if len(set(difficulties)) < n: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False >>> is_prime(19) True >>> is_prime(1) False def prime_sequence_exists(n: int, sequence: List[int]) -> str: Returns \\"YES\\" if there exists a non-empty subset of the sequence whose sum is a prime number. Returns \\"NO\\" otherwise. >>> prime_sequence_exists(5, [1, 3, 4, 7, 9]) \\"YES\\" >>> prime_sequence_exists(3, [4, 4, 4]) \\"NO\\" >>> prime_sequence_exists(4, [10, 11, 12, 1]) \\"YES\\" >>> prime_sequence_exists(3, [2, 2, 2]) \\"YES\\" >>> prime_sequence_exists(3, [6, 6, 6]) \\"NO\\" >>> prime_sequence_exists(1, [2]) \\"YES\\" >>> prime_sequence_exists(1, [1]) \\"NO\\" >>> prime_sequence_exists(2, [1, 2]) \\"YES\\"","solution":"import itertools def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_sequence_exists(n, sequence): Returns \\"YES\\" if there exists a non-empty subset of the sequence whose sum is a prime number. Returns \\"NO\\" otherwise. for r in range(1, n+1): for subset in itertools.combinations(sequence, r): if is_prime(sum(subset)): return \\"YES\\" return \\"NO\\""},{"question":"def can_reach_goal(m: int, blocked: List[Tuple[int, int]]) -> str: Determine if John can reach cell (m, m) from (1, 1) on a grid of size m x m with blocked cells. Parameters: - m: int, the size of the grid - blocked: list of tuples, each tuple representing a blocked cell (r, c) Returns: - \\"YES\\" if John can reach the goal, otherwise \\"NO\\". >>> can_reach_goal(3, []) 'YES' >>> can_reach_goal(3, [(2, 2)]) 'YES' >>> can_reach_goal(3, [(1, 2), (2, 1), (2, 2)]) 'NO' >>> can_reach_goal(4, [(2, 2), (3, 3)]) 'YES' >>> can_reach_goal(4, [(1, 2), (2, 1), (2, 2), (3, 3)]) 'NO' >>> can_reach_goal(5, [(i, 3) for i in range(1, 6)] + [(3, j) for j in range(1, 6)]) 'NO'","solution":"def can_reach_goal(m, blocked): Determine if John can reach cell (m, m) from (1, 1) on a grid of size m x m with blocked cells. Parameters: - m: int, the size of the grid - blocked: list of tuples, each tuple representing a blocked cell (r, c) Returns: - \\"YES\\" if John can reach the goal, otherwise \\"NO\\". from collections import deque # Convert blocked list to a set for O(1) lookups blocked_set = set(blocked) # Breadth-First Search (BFS) initialization queue = deque([(1, 1)]) visited = set((1, 1)) # Perform BFS while queue: r, c = queue.popleft() # Check if we've reached the goal if (r, c) == (m, m): return \\"YES\\" # Explore neighbors for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 1 <= nr <= m and 1 <= nc <= m and (nr, nc) not in visited and (nr, nc) not in blocked_set: queue.append((nr, nc)) visited.add((nr, nc)) # If we exit the loop without having reached (m, m) return \\"NO\\""},{"question":"import math from typing import List def smallest_multiple(m: int, n: int) -> int: Returns the smallest number that is divisible by both m and n. >>> smallest_multiple(6, 15) 30 >>> smallest_multiple(3, 5) 15 >>> smallest_multiple(7, 11) 77 >>> smallest_multiple(12, 18) 36 >>> smallest_multiple(1, 1) 1 >>> smallest_multiple(1000000000000000000, 999999999999999999) 999999999999999999000000000000000000 >>> smallest_multiple(1, 1000000000000000000) 1000000000000000000 >>> smallest_multiple(2, 999999999999999999) 1999999999999999998","solution":"import math def smallest_multiple(m, n): Returns the smallest number that is divisible by both m and n. return (m * n) // math.gcd(m, n)"},{"question":"from typing import List, Tuple def max_triangle_area(points: List[Tuple[int, int]]) -> float: Returns the maximum area of a triangle that can be formed by any three given points using the formula for the area of a triangle in 2D space. >>> max_triangle_area([(0, 0), (1, 0), (0, 1), (1, 2), (2, 1)]) # Example 1 1.5 >>> max_triangle_area([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]) # Example 2 0.0 >>> max_triangle_area([(0, 0), (0, 2), (2, 0), (2, 2)]) # Example 3 2.0 >>> max_triangle_area([(1000000000, 1000000000), (1000000000, -1000000000), (-1000000000, 1000000000), (-1000000000, -1000000000)]) # Example 4 2e18 >>> max_triangle_area([(0, 0), (3, 0), (0, 4)]) # Example 5 6.0","solution":"def max_triangle_area(points): Returns the maximum area of a triangle that can be formed by any three given points using the formula for the area of a triangle in 2D space. n = len(points) max_area = 0.0 def triangle_area(p1, p2, p3): x1, y1 = p1 x2, y2 = p2 x3, y3 = p3 return 0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) # Iterate our combinations and calculate the area for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): area = triangle_area(points[i], points[j], points[k]) if area > max_area: max_area = area return max_area"},{"question":"def max_tree_height(n: int, k: int) -> int: Determines the maximum height of the tree after n days, where Vanya waters the tree for exactly k days. Args: n (int): Total number of days. k (int): Number of days Vanya can water the tree. Returns: int: Maximum possible height of the tree after n days. >>> max_tree_height(5, 2) 8 >>> max_tree_height(1, 1) 3 >>> max_tree_height(10, 0) 11 >>> max_tree_height(10, 10) 21 >>> max_tree_height(100000, 50000) 150001","solution":"def max_tree_height(n, k): Determines the maximum height of the tree after n days, where Vanya waters the tree for exactly k days. Args: n (int): Total number of days. k (int): Number of days Vanya can water the tree. Returns: int: Maximum possible height of the tree after n days. initial_height = 1 daily_growth = n additional_growth = k # Total height = initial height + daily growth for n days + additional growth for k days max_height = initial_height + daily_growth + additional_growth return max_height"},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[List[int]]) -> int: Determines the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner without passing through any obstacles. If it is not possible, returns -1. Params: - n (int): number of rows - m (int): number of columns - grid (list of lists): 2D list representing the grid where 0 is an empty space and 1 is an obstacle Returns: - int: the minimum number of moves to reach (n, m) from (1, 1), or -1 if not possible pass # Unit Test def test_min_moves_to_reach_end(): grid1 = [ [0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0], [0, 1, 1, 0], ] assert min_moves_to_reach_end(4, 4, grid1) == 6 grid2 = [ [0, 0], [0, 0] ] assert min_moves_to_reach_end(2, 2, grid2) == 2 grid3 = [ [1, 1], [1, 1] ] assert min_moves_to_reach_end(2, 2, grid3) == -1 grid4 = [ [0] ] assert min_moves_to_reach_end(1, 1, grid4) == 0 grid5 = [ [1, 0], [0, 0] ] assert min_moves_to_reach_end(2, 2, grid5) == -1 grid6 = [ [0, 0], [0, 1] ] assert min_moves_to_reach_end(2, 2, grid6) == -1 grid7 = [ [0]*100 for _ in range(100) ] grid7[0][1] = 1 assert min_moves_to_reach_end(100, 100, grid7) == 198 grid8 = [ [0, 1], [1, 0] ] assert min_moves_to_reach_end(2, 2, grid8) == -1 grid9 = [ [0, 0], [1, 0] ] assert min_moves_to_reach_end(2, 2, grid9) == 2","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): Determines the minimum number of moves required to reach the bottom-right corner of the grid from the top-left corner without passing through any obstacles. If it is not possible, returns -1. Params: - n (int): number of rows - m (int): number of columns - grid (list of lists): 2D list representing the grid where 0 is an empty space and 1 is an obstacle Returns: - int: the minimum number of moves to reach (n, m) from (1, 1), or -1 if not possible if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # down, right, up, left queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if (row, col) == (n-1, m-1): return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"import math from typing import List, Tuple def farthest_distance(n: int, points: List[Tuple[int, int]]) -> float: Given N points in a 2D plane, find the distance of the farthest point from the origin (0, 0). >>> farthest_distance(3, [(1, 1), (2, 2), (3, 3)]) 4.242641 >>> farthest_distance(1, [(5, 5)]) 7.071068","solution":"import math def farthest_distance(n, points): max_dist = 0 for x, y in points: dist = math.sqrt(x**2 + y**2) if dist > max_dist: max_dist = dist return round(max_dist, 6)"},{"question":"import heapq from typing import List, Tuple def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_unblock(n: int, h: int, hallways: List[Tuple[int, int, int]], m: int, unblockable_hallways: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost to unblock passageways to ensure all rooms are accessible from room 1. If it is impossible to do so, return -1. >>> minimum_cost_to_unblock(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 1)], 0, []) 4 >>> minimum_cost_to_unblock(4, 3, [(1, 2, 1), (2, 3, 0), (3, 4, 0)], 2, [(2, 3, 2), (3, 4, 1)]) 4 from solution import minimum_cost_to_unblock def test_all_passageways_open(): n = 4 h = 3 hallways = [(1, 2, 1), (2, 3, 2), (3, 4, 1)] m = 0 unblockable_hallways = [] assert minimum_cost_to_unblock(n, h, hallways, m, unblockable_hallways) == 4 def test_some_blocked_passageways(): n = 4 h = 3 hallways = [(1, 2, 1), (2, 3, 0), (3, 4, 0)] m = 2 unblockable_hallways = [(2, 3, 2), (3, 4, 1)] assert minimum_cost_to_unblock(n, h, hallways, m, unblockable_hallways) == 4 def test_unblock_all_blocked_hallways(): n = 4 h = 3 hallways = [(1, 2, 0), (2, 3, 0), (3, 4, 0)] m = 3 unblockable_hallways = [(1, 2, 1), (2, 3, 2), (3, 4, 1)] assert minimum_cost_to_unblock(n, h, hallways, m, unblockable_hallways) == 4 def test_impossible_to_connect(): n = 4 h = 2 hallways = [(1, 2, 0), (3, 4, 0)] m = 1 unblockable_hallways = [(1, 2, 1)] assert minimum_cost_to_unblock(n, h, hallways, m, unblockable_hallways) == -1","solution":"import heapq def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_unblock(n, h, hallways, m, unblockable_hallways): # Initialize union-find structures parent = [i for i in range(n+1)] rank = [0] * (n+1) # List of edges (u, v, t), initially only including non-blocked hallways edges = [(t, u, v) for (u, v, t) in hallways if t != 0] # List of blocked edges to be possibly unblocked at a cost blocked_edges = [(c, x, y) for (x, y, c) in unblockable_hallways] # Heapify the edges list to prepare for Kruskal's algorithm heapq.heapify(edges) # Add all initially blocked edges as potential edges to be added to the MST for c, x, y in blocked_edges: heapq.heappush(edges, (c, x, y)) # Kruskal's algorithm total_cost = 0 num_edges_used = 0 while edges: cost, u, v = heapq.heappop(edges) if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += cost num_edges_used += 1 # Verify if all nodes are connected (check if only one set exists) root_set = find(parent, 1) for i in range(2, n+1): if find(parent, i) != root_set: return -1 return total_cost"},{"question":"def max_participant_score(n: int, m: int, scores: List[List[int]]) -> int: Calculate the maximum total score achieved by any participant. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Points each participant received for each problem. Returns: int: The maximum total score. >>> max_participant_score(4, 3, [[10, 15, 20], [30, 10, 40], [20, 20, 10], [10, 10, 10]]) == 80 >>> max_participant_score(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> max_participant_score(1, 3, [[5, 10, 15]]) == 30 >>> max_participant_score(3, 3, [[10, 10, 10], [20, 5, 5], [15, 5, 10]]) == 30 >>> max_participant_score(100, 100, [[1]*100 for _ in range(100)]) == 100","solution":"def max_participant_score(n, m, scores): Calculate the maximum total score achieved by any participant. Parameters: n (int): Number of participants. m (int): Number of problems. scores (list of list of int): Points each participant received for each problem. Returns: int: The maximum total score. max_score = 0 for i in range(n): total_score = sum(scores[i]) if total_score > max_score: max_score = total_score return max_score"},{"question":"def min_operations_to_secure_all_vertices(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Find the minimum number of operations required to secure all vertices in an undirected graph. >>> min_operations_to_secure_all_vertices(4, 0, []) 4 >>> min_operations_to_secure_all_vertices(2, 1, [(1, 2)]) 1 >>> min_operations_to_secure_all_vertices(4, 2, [(1, 2), (3, 4)]) 2 >>> min_operations_to_secure_all_vertices(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> min_operations_to_secure_all_vertices(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 2","solution":"def min_operations_to_secure_all_vertices(n, m, edges): from collections import defaultdict, deque # Create adjacency list of the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) operation_count = 0 for vertex in range(1, n + 1): if not visited[vertex]: bfs(vertex, visited) operation_count += 1 return operation_count"},{"question":"def max_product_from_input_string(input_string: str) -> int: Given an array of integers, determine the maximum product that can be obtained by multiplying any three distinct elements of the array. The input is a string that contains the number of elements in the array followed by the elements themselves. >>> max_product_from_input_string(\\"5n-10 -10 5 2 1\\") 500 >>> max_product_from_input_string(\\"4n1 2 3 4\\") 24 >>> max_product_from_input_string(\\"4n-1 -2 -3 -4\\") -6","solution":"def max_product_of_three(nums): nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1]) def max_product_from_input_string(input_string): # Parse input input_lines = input_string.strip().split(\\"n\\") n = int(input_lines[0]) nums = list(map(int, input_lines[1].split())) # Call the function to find the maximum product return max_product_of_three(nums)"},{"question":"def find_maximum_subarray_sum_and_length(n: int, arr: List[int]) -> Tuple[int, int]: Find the maximum sum of any subarray and the length of the shortest subarray that has this maximum sum. :param n: Length of the array (int) :param arr: List of integers representing the array :return: Tuple containing the maximum sum and the length of the shortest subarray with that sum >>> find_maximum_subarray_sum_and_length(5, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 4) >>> find_maximum_subarray_sum_and_length(5, [1, -1, 1, -1, 1]) (1, 1) from solution import find_maximum_subarray_sum_and_length def test_single_element_array(): assert find_maximum_subarray_sum_and_length(1, [3]) == (3, 1) assert find_maximum_subarray_sum_and_length(1, [-1]) == (-1, 1) def test_all_positive_elements(): assert find_maximum_subarray_sum_and_length(5, [1, 2, 3, 4, 5]) == (15, 5) assert find_maximum_subarray_sum_and_length(3, [1, 2, 3]) == (6, 3) def test_all_negative_elements(): assert find_maximum_subarray_sum_and_length(3, [-1, -2, -3]) == (-1, 1) assert find_maximum_subarray_sum_and_length(4, [-4, -1, -2, -3]) == (-1, 1) def test_mixed_elements(): assert find_maximum_subarray_sum_and_length(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == (6, 4) assert find_maximum_subarray_sum_and_length(5, [1, -1, 1, -1, 1]) == (1, 1) def test_large_input_array(): assert find_maximum_subarray_sum_and_length(6, [4, -1, 2, 1, -5, 4]) == (6, 4)","solution":"def find_maximum_subarray_sum_and_length(n, arr): Find the maximum sum of any subarray and the length of the shortest subarray that has this maximum sum. :param n: Length of the array (int) :param arr: List of integers representing the array :return: Tuple containing the maximum sum and the length of the shortest subarray with that sum max_sum = float('-inf') current_sum = 0 min_length = float('inf') start_index = 0 for i in range(n): if current_sum <= 0: current_sum = arr[i] start_index = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum min_length = i - start_index + 1 elif current_sum == max_sum: min_length = min(min_length, i - start_index + 1) return max_sum, min_length"},{"question":"def can_split_into_even_parts(n: int) -> str: Determines if n can be split into two nonzero even integers such that their sum is n. >>> can_split_into_even_parts(4) == \\"YES\\" >>> can_split_into_even_parts(6) == \\"YES\\" >>> can_split_into_even_parts(11) == \\"NO\\" >>> can_split_into_even_parts(18) == \\"YES\\"","solution":"def can_split_into_even_parts(n): Determines if n can be split into two nonzero even integers such that their sum is n. if n % 2 == 0 and n > 2: return \\"YES\\" return \\"NO\\""},{"question":"def largest_blob_size(n: int, m: int, grid: List[List[str]]) -> int: Identify the largest blob of 1s in the grid and return its size. >>> largest_blob_size(4, 5, [['1','1','0','0','0'], ['1','1','0','0','0'], ['0','0','1','0','0'], ['0','0','0','1','1']]) == 4 >>> largest_blob_size(3, 3, [['1','0','1'], ['0','1','0'], ['1','0','1']]) == 1 >>> largest_blob_size(3, 3, [['1','1','1'], ['1','0','1'], ['1','1','1']]) == 8 >>> largest_blob_size(1, 1, [['0']]) == 0 >>> largest_blob_size(1, 1, [['1']]) == 1 >>> largest_blob_size(3, 3, [['0','0','0'], ['0','0','0'], ['0','0','0']]) == 0","solution":"def largest_blob_size(n, m, grid): def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0': return 0 grid[x][y] = '0' # mark as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # four possible directions size += dfs(x + dx, y + dy) return size max_blob = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': max_blob = max(max_blob, dfs(i, j)) return max_blob"},{"question":"def transform_sequence(n: int, s: List[int], k: int, P: List[int]) -> List[int]: Transforms the sequence s according to rules specified in the problem statement. Parameters: n (int): Length of the sequence s. s (list): Original sequence where each element is 0, 1, or 2. k (int): Length of set P. P (list): Predefined set of distinct integers. Returns: list: Transformed sequence t. t = [] # Implement the transformation logic here return t # Unit Tests def test_example_case(): n = 5 s = [0, 1, 2, 0, 1] k = 4 P = [3, 5, 7, 11] assert transform_sequence(n, s, k, P) == [1, 3, 1155, 1, 3] # Possible correct sequence def test_all_zeros(): n = 3 s = [0, 0, 0] k = 2 P = [2, 4] assert transform_sequence(n, s, k, P) == [1, 1, 1] # Any number in the range [1, 10^9] def test_all_ones(): n = 3 s = [1, 1, 1] k = 3 P = [8, 2, 5] assert transform_sequence(n, s, k, P) == [2, 2, 2] # Sum of some distinct integers, choosing smallest elements def test_all_twos(): n = 2 s = [2, 2] k = 3 P = [2, 3, 5] assert transform_sequence(n, s, k, P) == [30, 30] # Product of distinct integers {2, 3, 5} -> 30 def test_mixed_sequence(): n = 4 s = [1, 0, 2, 1] k = 3 P = [9, 10, 11] assert transform_sequence(n, s, k, P) == [9, 1, 990, 9] # Performing the correct transformations","solution":"def transform_sequence(n, s, k, P): Transforms the sequence s according to rules specified in the problem statement. Parameters: n (int): Length of the sequence s. s (list): Original sequence where each element is 0, 1, or 2. k (int): Length of set P. P (list): Predefined set of distinct integers. Returns: list: Transformed sequence t. t = [] for i in range(n): if s[i] == 0: t.append(1) # Any integer in the range [1, 10^9], so we choose 1 for simplicity. elif s[i] == 1: t.append(min(P)) # Sum of some distinct integers from P, choosing the smallest element suffices. elif s[i] == 2: product = 1 for p in P: product *= p t.append(product) # Product of all distinct integers in P. return t"},{"question":"def calculate_additional_capacities(n: int, m: int, tubes: List[Tuple[int, int, int]], queries: List[int]) -> List[List[int]]: This function calculates the additional capacity needed for each tube to handle any future load increase. Parameters: n (int): Number of tubes m (int): Number of queries tubes (list of tuples): Each tuple contains three integers u, v, w representing a tube between office u and office v that currently has a capacity of w. queries (list of int): Each integer represents the future potential load that each tube must handle. Returns: list of list of int: For each query, a list of n space-separated integers representing the additional capacity needed for each tube to handle the potential increase in load. from solution import calculate_additional_capacities def test_calculate_additional_capacities_case1(): n = 5 m = 3 tubes = [(1, 2, 5), (2, 3, 10), (3, 4, 3), (4, 5, 8), (1, 5, 7)] queries = [3, 10, 15] expected = [ [0, 0, 0, 0, 0], [5, 0, 7, 2, 3], [10, 5, 12, 7, 8] ] assert calculate_additional_capacities(n, m, tubes, queries) == expected def test_calculate_additional_capacities_case2(): n = 2 m = 2 tubes = [(4, 5, 10), (6, 7, 15)] queries = [5, 12] expected = [ [0, 0], [2, 0] ] assert calculate_additional_capacities(n, m, tubes, queries) == expected def test_calculate_additional_capacities_case3(): n = 3 m = 1 tubes = [(1, 2, 5), (2, 3, 10), (1, 3, 8)] queries = [6] expected = [ [1, 0, 0] ] assert calculate_additional_capacities(n, m, tubes, queries) == expected def test_calculate_additional_capacities_case4(): n = 1 m = 1 tubes = [(1, 2, 0)] queries = [5] expected = [ [5] ] assert calculate_additional_capacities(n, m, tubes, queries) == expected","solution":"def calculate_additional_capacities(n, m, tubes, queries): This function calculates the additional capacity needed for each tube to handle any future load increase. Parameters: n (int): Number of tubes m (int): Number of queries tubes (list of tuples): Each tuple contains three integers u, v, w representing a tube between office u and office v that currently has a capacity of w. queries (list of int): Each integer represents the future potential load that each tube must handle. Returns: list of list of int: For each query, a list of n space-separated integers representing the additional capacity needed for each tube to handle the potential increase in load. results = [] for k in queries: additional_capacities = [] for _, _, w in tubes: if k > w: additional_capacities.append(k - w) else: additional_capacities.append(0) results.append(additional_capacities) return results"},{"question":"from typing import List def minimum_containers(n: int, m: int, animal_requirements: List[List[int]], container_food_types: List[int]) -> int: Determine the minimum number of containers required to feed all animals at least once. If it's not possible, return -1. Args: n : int : number of animals m : int : number of food containers animal_requirements : List[List[int]] : food requirements for each animal container_food_types : List[int] : food types provided by each container Returns: int : minimum number of containers required to feed all animals at least once, or -1 if not possible >>> minimum_containers(3, 5, [[1, 2], [1, 3], [2, 3]], [1, 1, 2, 2, 3]) 3 >>> minimum_containers(3, 4, [[1, 2], [1, 3], [2, 3]], [1, 1, 2, 2]) -1 >>> minimum_containers(2, 3, [[1, 2], [3]], [1, 2, 3]) 3 >>> minimum_containers(3, 6, [[1, 2], [1, 3], [2, 3]], [1, 1, 2, 2, 3, 3]) 3 >>> minimum_containers(1, 1, [[1]], [1]) 1 >>> minimum_containers(1, 3, [[1, 2, 3]], [1, 2, 3]) 3","solution":"def minimum_containers(n, m, animal_requirements, container_food_types): from collections import Counter from itertools import combinations def can_feed_all(animals, container_set): for animal in animals: required_foods = Counter(animal) available_foods = Counter(container_food_types[i - 1] for i in container_set) if not all(available_foods[food] >= required_foods[food] for food in required_foods): return False return True animal_foods = [set(req) for req in animal_requirements if req] min_containers_count = -1 for k in range(1, m + 1): for containers in combinations(range(1, m + 1), k): if can_feed_all(animal_foods, containers): min_containers_count = k break if min_containers_count != -1: break return min_containers_count"},{"question":"def can_visit_all_rooms(rooms: List[List[int]]) -> bool: Determines if all rooms can be visited starting from room 0. >>> can_visit_all_rooms([[1], [2], [3], []]) == True >>> can_visit_all_rooms([[1, 3], [3, 0, 1], [2], [0]]) == False >>> can_visit_all_rooms([[]]) == True >>> can_visit_all_rooms([[1, 2, 3], [3], [3], []]) == True >>> can_visit_all_rooms([[1], [2], [3], [4], [5], []]) == True >>> can_visit_all_rooms([[], [1], [2], [3]]) == False","solution":"def can_visit_all_rooms(rooms): Determines if all rooms can be visited starting from room 0. Args: rooms (list of list of int): 2D array where each sublist represents keys in that room. Returns: bool: True if all rooms can be visited, False otherwise. visited = [False] * len(rooms) stack = [0] while stack: room = stack.pop() if not visited[room]: visited[room] = True for key in rooms[room]: if not visited[key]: stack.append(key) return all(visited)"},{"question":"def can_meet_requirements(m: int, n: int, fruits: List[int], requirements: List[Tuple[int, int]]) -> str: Determines if it is possible to meet all the creatures' requirements. :param m: Number of different fruit types :param n: Number of creatures :param fruits: List of available number of fruits for each type :param requirements: List of tuples where each tuple is (a, b) :return: \\"Yes\\" if all requirements can be met, otherwise \\"No\\" >>> can_meet_requirements(5, 3, [3, 4, 2, 1, 1], [(2, 1), (3, 2), (1, 3)]) 'Yes' >>> can_meet_requirements(5, 3, [1, 1, 2, 1, 1], [(2, 1), (3, 2), (1, 3)]) 'No' >>> can_meet_requirements(4, 4, [1, 2, 3, 4], [(1, 1), (1, 2), (1, 3), (1, 4)]) 'Yes' >>> can_meet_requirements(3, 4, [4, 2, 3], [(1, 1), (1, 1), (1, 1), (1, 1)]) 'Yes' >>> can_meet_requirements(2, 2, [2, 2], [(2, 1), (1, 1)]) 'No'","solution":"def can_meet_requirements(m, n, fruits, requirements): Determines if it is possible to meet all the creatures' requirements. :param m: Number of different fruit types :param n: Number of creatures :param fruits: List of available number of fruits for each type :param requirements: List of tuples where each tuple is (a, b) :return: \\"Yes\\" if all requirements can be met, otherwise \\"No\\" for a, b in requirements: if fruits[b - 1] < a: return \\"No\\" fruits[b - 1] -= a return \\"Yes\\""},{"question":"def count_even_product_subarrays(n: int, m: int, arr: List[int]) -> int: Counts the number of contiguous subarrays of length exactly m that have an even product. Parameters: n (int): Length of the sequence m (int): Length of the subarrays arr (List[int]): The elements of the sequence Returns: int: The number of contiguous subarrays of length exactly m with an even product pass def test_example_case(): assert count_even_product_subarrays(5, 2, [1, 2, 3, 4, 5]) == 4 def test_single_element_subarray(): assert count_even_product_subarrays(3, 1, [2, 3, 4]) == 2 def test_all_odd_elements(): assert count_even_product_subarrays(5, 3, [1, 3, 5, 7, 9]) == 0 def test_large_subarray(): assert count_even_product_subarrays(6, 5, [1, 2, 3, 4, 5, 6]) == 2 def test_all_even_elements(): assert count_even_product_subarrays(4, 2, [2, 4, 6, 8]) == 3 def test_m_equals_n(): assert count_even_product_subarrays(3, 3, [1, 2, 3]) == 1 def test_m_equals_1(): assert count_even_product_subarrays(4, 1, [1, 2, 3, 4]) == 2","solution":"def count_even_product_subarrays(n, m, arr): Counts the number of contiguous subarrays of length exactly m that have an even product. Parameters: n (int): Length of the sequence m (int): Length of the subarrays arr (List[int]): The elements of the sequence Returns: int: The number of contiguous subarrays of length exactly m with an even product count = 0 # Check each subarray of length m for i in range(n - m + 1): subarray = arr[i:i + m] # Check if the product of the subarray is even even_product = False for num in subarray: if num % 2 == 0: even_product = True break if even_product: count += 1 return count"},{"question":"def max_height_of_stable_tower(n: int, weights: List[int]) -> int: Determines the maximum height of a stable tower. Args: n (int): The number of blocks. weights (list[int]): The weights of the blocks. Returns: int: The maximum height of the stable tower. pass # implement the function here # Example test cases def test_example_cases(): assert max_height_of_stable_tower(5, [4, 3, 2, 5, 1]) == 5 assert max_height_of_stable_tower(4, [4, 4, 4, 4]) == 1 assert max_height_of_stable_tower(3, [1, 2, 3]) == 3 def test_large_numbers(): assert max_height_of_stable_tower(1, [100000]) == 1 assert max_height_of_stable_tower(2, [99999, 100000]) == 2 def test_unsorted_blocks(): assert max_height_of_stable_tower(6, [5, 1, 3, 4, 2, 6]) == 6 def test_identical_blocks(): assert max_height_of_stable_tower(5, [5, 5, 5, 5, 5]) == 1 def test_increasing_weights(): assert max_height_of_stable_tower(5, [1, 2, 3, 4, 5]) == 5 def test_decreasing_weights(): assert max_height_of_stable_tower(5, [5, 4, 3, 2, 1]) == 5 if __name__ == \\"__main__\\": test_example_cases() test_large_numbers() test_unsorted_blocks() test_identical_blocks() test_increasing_weights() test_decreasing_weights() print('All tests passed!')","solution":"def max_height_of_stable_tower(n, weights): Determines the maximum height of a stable tower. Args: n (int): The number of blocks. weights (list[int]): The weights of the blocks. Returns: int: The maximum height of the stable tower. weights.sort(reverse=True) height = 1 for i in range(1, n): if weights[i] < weights[i-1]: height += 1 return height"},{"question":"def schedule_events(n: int, restrictions: List[List[int]]) -> Union[List[int], str]: Anita is a busy event planner who has to organize a series of events over several days. She has n days available to schedule the events. Each event requires exactly one entire day, and events cannot overlap. However, due to some restrictions, there are certain days on which specific events cannot be held. Write a function that helps Anita schedule the events. Given the constraints for each event on which days it cannot be held, determine if it's possible to schedule all events. If it is possible, output the schedule. If it is not possible, output \\"IMPOSSIBLE\\". Parameters: n (int): The number of days and the number of events. restrictions (List[List[int]]): Each of the n lists contains space-separated integers representing the days on which the corresponding event cannot be held. Returns: Union[List[int], str]: If it is possible to schedule all events, return a list of n integers, where each integer represents the day on which the corresponding event is scheduled (events are 1-indexed). If it's not possible to schedule all events, return \\"IMPOSSIBLE\\". Examples: >>> schedule_events(3, [[1], [2], []]) [2, 3, 1] >>> schedule_events(2, [[1, 2], [1, 2]]) 'IMPOSSIBLE' import pytest def test_schedule_events(): # Test provided example n = 3 restrictions = [[1], [2], []] result = schedule_events(n, restrictions) assert result == [2, 3, 1] or result == [3, 1, 2] # Test case where scheduling is impossible n = 2 restrictions = [[1, 2], [1, 2]] result = schedule_events(n, restrictions) assert result == \\"IMPOSSIBLE\\" # Test case with no restrictions n = 3 restrictions = [[], [], []] result = schedule_events(n, restrictions) assert result == [1, 2, 3] or result == [1, 3, 2] or result == [2, 1, 3] or result == [2, 3, 1] or result == [3, 1, 2] or result == [3, 2, 1] # Test case with all events and restrictions n = 4 restrictions = [[2], [4], [1], [3]] result = schedule_events(n, restrictions) assert result == [1, 2, 3, 4] or result == [1, 3, 4, 2] or (result.count(1) == 1 and result.count(2) == 1 and result.count(3) == 1 and result.count(4) == 1 and result[2] != 1 and result[3] != 2 and result[1] != 4 and result[4] != 3) # Test edge case with only one event and one day n = 1 restrictions = [[]] result = schedule_events(n, restrictions) assert result == [1] if __name__ == \\"__main__\\": pytest.main()","solution":"def schedule_events(n, restrictions): from collections import defaultdict, deque unavailable_days = defaultdict(set) for i, restriction in enumerate(restrictions): for day in restriction: unavailable_days[day].add(i + 1) events_schedule = [-1] * (n + 1) days_used = set() def can_schedule(event, day): return event not in unavailable_days[day] def find_schedule(): available_days = deque(range(1, n + 1)) for event in range(1, n + 1): scheduled = False days_to_check = len(available_days) for _ in range(days_to_check): day = available_days.popleft() if can_schedule(event, day): events_schedule[event] = day days_used.add(day) break else: available_days.append(day) if events_schedule[event] == -1: return \\"IMPOSSIBLE\\" return events_schedule[1:] return find_schedule()"},{"question":"from typing import List, Dict def is_prime(n: int) -> bool: Determines whether a given number n is prime. >>> is_prime(2) True >>> is_prime(4) False def build_tree(n: int) -> Dict[int, List[int]]: Builds a tree from given input. >>> build_tree(5) {1: [2, 3], 2: [1], 3: [1, 4, 5], 4: [3], 5: [3]} def find_leaf_paths(tree: Dict[int, List[int]], node_values: List[int], root: int, parent: Dict[int, int]) -> List[List[int]]: Finds all root-to-leaf paths where each node in the path sums to a prime number. >>> find_leaf_paths({1: [2, 3], 2: [1], 3: [1, 4, 5], 4: [3], 5: [3]}, [2, 3, 6, 5, 7], 1, {}) [[2, 3], [2, 6, 5]] def sum_prime_paths(paths: List[List[int]]) -> int: Computes the total sum of all prime-sum root-to-leaf paths. >>> sum_prime_paths([[2, 3], [2, 6, 5]]) 18 def main(): Main function to execute the complete process of finding the sum of all prime-sum paths in a given tree. Example: Input: 5 2 3 6 5 7 1 2 1 3 3 4 3 5 Output: 18","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def build_tree(n): from collections import defaultdict tree = defaultdict(list) for _ in range(n - 1): u, v = map(int, input().split()) tree[u].append(v) tree[v].append(u) return tree def find_leaf_paths(tree, node_values, root, parent): paths = [] def dfs(node, path_sum, path): path_sum += node_values[node - 1] path.append(node_values[node - 1]) is_leaf = True for child in tree[node]: if child != parent[node]: is_leaf = False parent[child] = node dfs(child, path_sum, path) if is_leaf and is_prime(path_sum): paths.append(path[:]) path.pop() parent = {root: None} dfs(root, 0, []) return paths def sum_prime_paths(paths): total_sum = 0 for path in paths: total_sum += sum(path) return total_sum def main(): n = int(input()) node_values = list(map(int, input().split())) tree = build_tree(n) root = 1 paths = find_leaf_paths(tree, node_values, root, {}) result = sum_prime_paths(paths) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def has_even_palindrome_subsequence(arr: List[int]) -> str: Determines if there is an even-length palindrome subsequence in the array. >>> has_even_palindrome_subsequence([1, 2, 3, 2, 1]) \\"NO\\" >>> has_even_palindrome_subsequence([1, 2, 2, 3]) \\"YES\\" >>> has_even_palindrome_subsequence([1, 2, 2, 1]) \\"YES\\" >>> has_even_palindrome_subsequence([1, 2, 3, 3, 2, 1]) \\"YES\\" >>> has_even_palindrome_subsequence([1, 2, 3, 4, 5]) \\"NO\\" >>> has_even_palindrome_subsequence([1]) \\"NO\\" >>> has_even_palindrome_subsequence([1, 1, 1, 1]) \\"YES\\" >>> large_array = [1] * 100000 >>> large_array[50000] = 2 >>> has_even_palindrome_subsequence(large_array) \\"YES\\"","solution":"def has_even_palindrome_subsequence(arr): Determines if there is an even-length palindrome subsequence in the array. n = len(arr) # Check if there's a pair of identical adjacent elements, this forms an even palindrome of length 2 for i in range(n-1): if arr[i] == arr[i+1]: return \\"YES\\" # Check for longer even-length palindromes (length 4, 6, ...) for length in range(4, n+1, 2): for start in range(n - length + 1): end = start + length - 1 if arr[start:end+1] == arr[start:end+1][::-1]: return \\"YES\\" return \\"NO\\""},{"question":"def min_days_to_cover_events(n: int, m: int, d: int, event_skills: List[int], athlete_skills: List[int]) -> Union[int, str]: Determine the minimum number of days required to cover all events by assigning athletes. Args: n (int): Number of athletes. m (int): Number of events. d (int): Maximum number of days each athlete can work. event_skills (List[int]): Required skill levels for the events. athlete_skills (List[int]): Skill levels of the athletes. Returns: Union[int, str]: The minimum number of days required to cover all events or \\"IMPOSSIBLE\\" if it's not possible. >>> min_days_to_cover_events(3, 3, 2, [50, 60, 70], [70, 50, 55]) 2 >>> min_days_to_cover_events(2, 3, 1, [50, 60, 70], [70, 50]) \\"IMPOSSIBLE\\"","solution":"def min_days_to_cover_events(n, m, d, event_skills, athlete_skills): from collections import defaultdict import heapq if m > n * d: return \\"IMPOSSIBLE\\" event_skills.sort() athlete_skills.sort() events_per_day = defaultdict(list) events_heap = [(0, i) for i in range(d)] heapq.heapify(events_heap) j = 0 for i in range(n): available_days = [] while j < m and event_skills[j] <= athlete_skills[i]: heapq.heappush(available_days, event_skills[j]) j += 1 while available_days and events_heap: day, day_index = heapq.heappop(events_heap) event = heapq.heappop(available_days) events_per_day[day_index].append(event) day += 1 heapq.heappush(events_heap, (day, day_index)) if sum(len(events) for events in events_per_day.values()) >= m: max_day_used = max(day for day, _ in events_heap) return max_day_used else: return \\"IMPOSSIBLE\\""},{"question":"def largest_square_park(n: int, plot_areas: List[int]) -> Tuple[int, int]: Determines the area of the largest possible square park and the minimum number of plots required. Parameters: n (int): Number of plots available. plot_areas (list): List of integers representing the areas of the plots. Returns: tuple: A tuple containing the area of the largest possible square park and the minimum number of plots required. >>> largest_square_park(1, [16]) (16, 1) >>> largest_square_park(6, [16, 9, 25, 4, 1, 36]) (36, 1) >>> largest_square_park(4, [8, 14, 23, 26]) (0, float('inf')) # No perfect squares >>> largest_square_park(3, [4, 4, 4]) (4, 1) >>> largest_square_park(5, [1, 3, 4, 9, 7]) (9, 1) >>> largest_square_park(5, [16, 9, 16, 9, 4]) (16, 1)","solution":"def largest_square_park(n, plot_areas): Determines the area of the largest possible square park and the minimum number of plots required. Parameters: n (int): Number of plots available. plot_areas (list): List of integers representing the areas of the plots. Returns: tuple: A tuple containing the area of the largest possible square park and the minimum number of plots required. # To track the maximum square park area max_square_area = 0 min_plots = float('inf') # Sort plots in descending order to find the largest square park faster plot_areas.sort(reverse=True) for area in plot_areas: side = int(area ** 0.5) if side * side == area: # It's a perfect square if area > max_square_area: max_square_area = area min_plots = 1 elif area == max_square_area: min_plots = min(min_plots, 1) return max_square_area, min_plots"},{"question":"def can_partition_to_equal_sum(arr: List[int]) -> str: Determines whether it is possible to partition the array into two subarrays with equal sum. >>> can_partition_to_equal_sum([1, 5, 11, 5]) 'YES' >>> can_partition_to_equal_sum([1, 2, 3, 5]) 'NO' >>> can_partition_to_equal_sum([2]) 'NO' >>> can_partition_to_equal_sum([4, 4]) 'YES' >>> can_partition_to_equal_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 'NO' >>> can_partition_to_equal_sum([3, 1, 1, 2, 2, 1]) 'YES'","solution":"def can_partition_to_equal_sum(arr): Determines whether it is possible to partition the array into two subarrays with equal sum. Parameters: arr (list of int): The input array of integers. Returns: str: \\"YES\\" if it's possible to partition the array into two non-empty subsets with equal sum, \\"NO\\" otherwise. total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): dp[i][j] = dp[i - 1][j] if j >= arr[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] return \\"YES\\" if dp[n][target] else \\"NO\\""},{"question":"def can_be_made_alternating(n: int, seq: List[int]) -> str: Determine if the sequence can be made to have alternating signs by removing at most one element. >>> can_be_made_alternating(5, [1, -2, 3, -4, 5]) 'YES' >>> can_be_made_alternating(4, [1, 2, 3, 4]) 'NO' >>> can_be_made_alternating(1, [5]) 'YES' >>> can_be_made_alternating(5, [1, -2, 2, -4, 5]) 'YES' >>> can_be_made_alternating(3, [1, 1, 1]) 'NO' >>> can_be_made_alternating(5, [1, -2, 3, -4, -5]) 'YES' >>> can_be_made_alternating(4, [1, 2, -3, 4]) 'YES' >>> can_be_made_alternating(4, [2, -3, 4, -5]) 'YES' >>> can_be_made_alternating(4, [-1, 2, -3, 3]) 'YES'","solution":"def can_be_made_alternating(n, seq): if n == 1: return \\"YES\\" def is_alternating(sequence): for i in range(1, len(sequence)): if sequence[i] * sequence[i - 1] > 0: return False return True if is_alternating(seq): return \\"YES\\" for i in range(n): reduced_seq = seq[:i] + seq[i+1:] if is_alternating(reduced_seq): return \\"YES\\" return \\"NO\\""},{"question":"def modified_fib(k: int, n: int) -> int: Calculate the n-th element of the modified Fibonacci sequence where each element is the sum of the previous k elements. >>> modified_fib(3, 6) 9 >>> modified_fib(3, 1) 1 >>> modified_fib(2, 5) 5 >>> modified_fib(2, 10) 55 >>> modified_fib(1, 1000) 1 >>> modified_fib(1000, 1001) 1000","solution":"def modified_fib(k, n): Calculate the n-th element of the modified Fibonacci sequence where each element is the sum of the previous k elements. if n <= k: return 1 # Initial sequence of k elements each being 1 sequence = [1] * k # Generate sequence until the n-th element for i in range(k, n): next_element = sum(sequence[-k:]) # Sum of the last k elements sequence.append(next_element) return sequence[n-1]"},{"question":"def max_trapped_water(heights: List[int]) -> int: Computes the maximum amount of trapped rainwater between buildings. Parameters: heights (List[int]): A list of integers representing the height of buildings. Returns: int: The maximum amount of trapped rainwater. >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_trapped_water([]) == 0 >>> max_trapped_water([1, 2, 3, 4, 5]) == 0 >>> max_trapped_water([5]) == 0 >>> max_trapped_water([2, 1]) == 0 >>> max_trapped_water([4, 2, 0, 3, 2, 5]) == 9 >>> max_trapped_water([3, 3, 3, 3]) == 0","solution":"def max_trapped_water(heights): Computes the maximum amount of trapped rainwater between buildings. Parameters: heights (List[int]): A list of integers representing the height of buildings. Returns: int: The maximum amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from collections import deque, defaultdict as dd def shortest_path_with_k_colors(n, m, colors, edges, start, target, k): Returns the length of the shortest path from start to target node such that the path includes nodes with at least k different colors. If no such path exists, return -1. pass # Unit tests def test_case_1(): n = 4 m = 4 colors = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4), (4, 1)] start = 1 target = 4 k = 3 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == 3 def test_case_2(): n = 4 m = 4 colors = [1, 2, 1, 4] edges = [(1, 2), (2, 3), (3, 4), (4, 1)] start = 1 target = 4 k = 3 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == 3 def test_case_3(): n = 4 m = 3 colors = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] start = 1 target = 4 k = 4 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == 3 def test_no_valid_path(): n = 4 m = 2 colors = [1, 1, 1, 1] edges = [(1, 2), (2, 4)] start = 1 target = 4 k = 2 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == -1 def test_path_does_not_exist(): n = 4 m = 2 colors = [1, 2, 3, 4] edges = [(1, 2), (3, 4)] start = 1 target = 4 k = 2 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == -1 def test_path_exists_exact_k_colors(): n = 5 m = 6 colors = [1, 2, 3, 1, 3] edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 1)] start = 1 target = 5 k = 3 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == 3 def test_direct_path_with_less_colors(): n = 5 m = 7 colors = [1, 2, 3, 1, 3] edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 1), (1, 5)] start = 1 target = 5 k = 3 assert shortest_path_with_k_colors(n, m, colors, edges, start, target, k) == 3 if __name__ == \\"__main__\\": test_case_1() test_case_2() test_case_3() test_no_valid_path() test_path_does_not_exist() test_path_exists_exact_k_colors() test_direct_path_with_less_colors() print(\\"All tests passed.\\")","solution":"from collections import deque, defaultdict as dd def shortest_path_with_k_colors(n, m, colors, edges, start, target, k): Returns the length of the shortest path from start to target node such that the path includes nodes with at least k different colors. If no such path exists, returns -1. graph = dd(list) for u, v in edges: graph[u].append(v) queue = deque([(start, 0, set([colors[start-1]]))]) visited = set([(start, frozenset([colors[start-1]]))]) while queue: current_node, current_dist, current_colors = queue.popleft() if current_node == target and len(current_colors) >= k: return current_dist for neighbor in graph[current_node]: next_colors = set(current_colors) next_colors.add(colors[neighbor-1]) frozen_next_colors = frozenset(next_colors) if (neighbor, frozen_next_colors) not in visited: visited.add((neighbor, frozen_next_colors)) queue.append((neighbor, current_dist + 1, next_colors)) return -1"},{"question":"def max_task_groups(n: int, k: int, task_types: List[int]) -> int: Calculate the maximum number of groups that can be formed such that each group contains at least one task from each type. Args: n (int): The number of tasks. k (int): The number of different types of tasks. task_types (List[int]): The task types of each of the tasks. Returns: int: The maximum number of groups. >>> max_task_groups(8, 3, [1, 2, 2, 3, 1, 3, 2, 1]) 2 >>> max_task_groups(5, 1, [1, 1, 1, 1, 1]) 5 >>> max_task_groups(7, 3, [1, 1, 2, 2, 2, 3]) 1 >>> max_task_groups(1, 1, [1]) 1 >>> max_task_groups(6, 2, [1, 2, 1, 2, 1, 2]) 3 >>> tasks = [i % 10 + 1 for i in range(200)] >>> max_task_groups(200, 10, tasks) 20","solution":"def max_task_groups(n, k, task_types): Calculate the maximum number of groups that can be formed such that each group contains at least one task from each type. Parameters: n (int): The number of tasks. k (int): The number of different types of tasks. task_types (List[int]): The task types of each of the tasks. Returns: int: The maximum number of groups. from collections import Counter # Count the occurrences of each task type task_count = Counter(task_types) # Find the minimum count of any task type min_count = min(task_count[type_id] for type_id in range(1, k + 1)) return min_count"},{"question":"def can_form_chain(n: int, dominoes: List[Tuple[int, int]]) -> str: Determine whether it's possible to arrange all the domino pieces in a single connected chain. Each domino piece is represented by two numbers a and b (0 ≤ a, b ≤ 6). >>> can_form_chain(3, [(1, 2), (2, 3), (3, 1)]) 'YES' >>> can_form_chain(3, [(1, 2), (2, 3), (4, 5)]) 'NO' >>> can_form_chain(1, [(1, 2)]) 'YES' >>> can_form_chain(4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 'NO' >>> can_form_chain(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> can_form_chain(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 'YES' >>> can_form_chain(3, [(1, 1), (1, 1), (1, 1)]) 'YES'","solution":"def can_form_chain(n, dominoes): from collections import defaultdict, deque # Build the adjacency list for the dominoes adjacency_list = defaultdict(list) endpoints_count = defaultdict(int) for a, b in dominoes: adjacency_list[a].append(b) adjacency_list[b].append(a) endpoints_count[a] += 1 endpoints_count[b] += 1 # Checking for the Eulerian path/circuit properties start_point = None end_point = None odd_count = 0 for end_point, count in endpoints_count.items(): if count % 2 != 0: odd_count += 1 if start_point is None: start_point = end_point elif end_point is None: end_point = end_point # If there are more than 2 points with odd count, it's not possible to form a chain if odd_count > 2: return \\"NO\\" # Perform BFS/DFS to check if all dominoes are in a single connected component visited = set() queue = deque([list(adjacency_list.keys())[0]]) while queue: current = queue.popleft() if current not in visited: visited.add(current) for neighbor in adjacency_list[current]: if neighbor not in visited: queue.append(neighbor) if len(visited) == len(adjacency_list): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_sum_after_operations(n: int, m: int, k: int, array: List[int]) -> int: You are given an array of n integers. You can perform up to k operations on it. In each operation, you can choose any two integers in the array and swap them. After performing all operations, your task is to maximize the sum of the first m elements of the sorted array. Note that you are allowed to perform fewer than k operations if it helps you achieve a better result. >>> max_sum_after_operations(5, 3, 1, [1, 2, 5, 3, 4]) 12 >>> max_sum_after_operations(6, 4, 2, [-1, -2, -3, -4, 5, 6]) 16 from typing import List","solution":"def max_sum_after_operations(n, m, k, array): # Sort the array to get the elements in order sorted_array = sorted(array, reverse=True) # We are interested in the maximum sum of the first m elements return sum(sorted_array[:m]) # Example Usage: # n, m, k = 5, 3, 1 # array = [1, 2, 5, 3, 4] # print(max_sum_after_operations(n, m, k, array)) # Output: 12"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an integer array nums and an integer target, return the indices of the two numbers such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1000000000, -1000000000], 0) [0, 1]","solution":"def two_sum(nums, target): Given an integer array nums and an integer target, return the indices of the two numbers such that they add up to the target. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i"},{"question":"def count_segments_with_sum(n: int, d: int, sweetness_levels: List[int], m: int) -> int: Returns the number of contiguous segments of length m that have a sum of sweetness levels equal to d. >>> count_segments_with_sum(5, 15, [10, 5, 8, 6, 7], 2) 1 >>> count_segments_with_sum(6, 5, [1, 2, 3, 2, 2, 1], 2) 2 >>> count_segments_with_sum(4, 10, [1, 2, 4, 5], 3) 0 >>> count_segments_with_sum(5, 15, [5, 5, 1, 2, 2], 5) 1 >>> count_segments_with_sum(3, 5, [5, 1, 5], 1) 2","solution":"def count_segments_with_sum(n, d, sweetness_levels, m): Returns the number of contiguous segments of length m that have a sum of sweetness levels equal to d. count = 0 for i in range(n - m + 1): if sum(sweetness_levels[i: i + m]) == d: count += 1 return count"},{"question":"from typing import List def maxSubarraySumCircular(nums: List[int]) -> int: Finds the maximum possible sum of a circular subarray in the array. >>> maxSubarraySumCircular([1, -2, 3, -2, 5]) 7 >>> maxSubarraySumCircular([-2, -3, -1]) -1 def test_example_1(): nums = [1, -2, 3, -2, 5] assert maxSubarraySumCircular(nums) == 7 def test_example_2(): nums = [-2, -3, -1] assert maxSubarraySumCircular(nums) == -1 def test_single_element(): nums = [10] assert maxSubarraySumCircular(nums) == 10 def test_all_negative(): nums = [-5, -3, -7, -2, -8] assert maxSubarraySumCircular(nums) == -2 def test_all_positive(): nums = [2, 3, 1, 5, 4] assert maxSubarraySumCircular(nums) == 15 def test_mixed_elements(): nums = [8, -1, -3, 8] assert maxSubarraySumCircular(nums) == 16","solution":"def maxSubarraySumCircular(nums): Finds the maximum sum of a circular subarray. total = 0 max_sum = float('-inf') cur_max = 0 min_sum = float('inf') cur_min = 0 for num in nums: cur_max = max(cur_max + num, num) max_sum = max(max_sum, cur_max) cur_min = min(cur_min + num, num) min_sum = min(min_sum, cur_min) total += num return max(max_sum, total - min_sum) if max_sum > 0 else max_sum"},{"question":"def can_partition(n: int, rarities: List[int]) -> str: Determines if it's possible to partition the collection into two subsets with equal sum of rarity values. >>> can_partition(4, [1, 5, 11, 5]) == \\"YES\\" >>> can_partition(4, [1, 2, 3, 5]) == \\"NO\\" >>> can_partition(1, [3]) == \\"NO\\" >>> can_partition(3, [1, 5, 5]) == \\"NO\\" >>> can_partition(6, [1, 1, 1, 1, 1, 1]) == \\"YES\\" >>> can_partition(5, [1, 2, 3, 4, 5]) == \\"NO\\" >>> can_partition(100, [i+1 for i in range(100)]) == \\"YES\\" >>> can_partition(4, [0, 0, 0, 0]) == \\"YES\\"","solution":"def can_partition(n, rarities): Determines if it's possible to partition the collection into two subsets with equal sum of rarity values. total_sum = sum(rarities) # If the total sum is odd, it's not possible to split into two equal parts if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 # Use dynamic programming to check if a subset with the target sum exists dp = [False] * (target + 1) dp[0] = True for rarity in rarities: for i in range(target, rarity - 1, -1): if dp[i - rarity]: dp[i] = True return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def longest_beautiful_subarray(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest beautiful subarray. A beautiful subarray is defined as a subarray with an even length and a sum divisible by k. :param n: Number of elements in the array (1 ≤ n ≤ 10^5) :param k: The integer divisor (1 ≤ k ≤ 100) :param arr: List of integers (-10^4 ≤ ai ≤ 10^4) :return: Length of the longest beautiful subarray","solution":"def longest_beautiful_subarray(n, k, arr): Returns the length of the longest beautiful subarray. A beautiful subarray is defined as a subarray with an even length and a sum divisible by k. :param n: Number of elements in the array :param k: The integer divisor :param arr: List of integers :return: Length of the longest beautiful subarray max_length = 0 for start in range(n): for end in range(start + 2, n + 1, 2): subarray = arr[start:end] if sum(subarray) % k == 0: max_length = max(max_length, end - start) return max_length # Example usage n = 6 k = 5 arr = [1, 2, 3, 4, 5, 6] print(longest_beautiful_subarray(n, k, arr)) # Output 4"},{"question":"def library_system(members, books, max_limit, operations): Manage borrowing and returning of books in the library. Parameters: members (int): The number of members. books (int): The number of books. max_limit (int): The maximum number of books a member can borrow at once. operations (list): A list of operations to be processed in the format: \\"BORROW x y\\" or \\"RETURN x y\\" Returns: list: A list of strings \\"SUCCESS\\" or \\"FAIL\\" for each operation. Example: >>> library_system(2, 3, 2, [\\"BORROW 1 1\\", \\"BORROW 1 2\\", \\"BORROW 1 3\\", \\"RETURN 1 2\\", \\"BORROW 1 3\\"]) [\\"SUCCESS\\", \\"SUCCESS\\", \\"FAIL\\", \\"SUCCESS\\", \\"SUCCESS\\"]","solution":"def library_system(members, books, max_limit, operations): # Initialize the data structures borrowed_books = {} # book_id -> member_id member_borrow_count = {} # member_id -> number_of_books # Initialize borrow count for each member to 0 for member_id in range(1, members + 1): member_borrow_count[member_id] = 0 results = [] # Process each operation for operation in operations: op_parts = operation.split() command = op_parts[0] member_id = int(op_parts[1]) book_id = int(op_parts[2]) if command == \\"BORROW\\": if book_id not in borrowed_books and member_borrow_count[member_id] < max_limit: borrowed_books[book_id] = member_id member_borrow_count[member_id] += 1 results.append(\\"SUCCESS\\") else: results.append(\\"FAIL\\") elif command == \\"RETURN\\": if book_id in borrowed_books and borrowed_books[book_id] == member_id: borrowed_books.pop(book_id) member_borrow_count[member_id] -= 1 results.append(\\"SUCCESS\\") else: results.append(\\"FAIL\\") return results"},{"question":"def palindrome_transform(n: int) -> (int, int): Given an integer n, transform it into a palindrome by reversing its digits and adding the result to the original number. If the sum is not a palindrome, repeat the process until the sum is a palindrome. Return the resulting palindrome and the number of iterations required to reach it. >>> palindrome_transform(96) (4884, 4) >>> palindrome_transform(5) (5, 0) >>> palindrome_transform(121) (121, 0) >>> palindrome_transform(10) (11, 1) >>> palindrome_transform(56) (121, 1) >>> palindrome_transform(89) (8813200023188, 24) pass","solution":"def is_palindrome(number): Check if the given integer is a palindrome. str_num = str(number) return str_num == str_num[::-1] def reverse_number(number): Return the reverse of the given integer. return int(str(number)[::-1]) def palindrome_transform(n): Transform the given integer into a palindrome by repeatedly adding the reversed number to itself until the sum is a palindrome. Return the resulting palindrome and the number of iterations required. iterations = 0 while not is_palindrome(n): reversed_n = reverse_number(n) n += reversed_n iterations += 1 return n, iterations"},{"question":"def rearrange_array(n: int, a: List[int]) -> List[int]: Rearranges the array \`a\` such that for each integer i (1 ≤ i ≤ n), the two occurrences of \`i\` in the rearranged array are as far apart as possible. >>> rearrange_array(3, [1, 2, 3, 2, 1, 3]) [1, 2, 1, 3, 2, 3] >>> rearrange_array(1, [1, 1]) [1, 1] >>> rearrange_array(2, [1, 1, 2, 2]) [1, 2, 1, 2] >>> rearrange_array(5, [1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) [1, 2, 3, 1, 4, 2, 5, 3, 4, 5]","solution":"def rearrange_array(n, a): Rearranges the array 'a' such that for each integer i (1 ≤ i ≤ n), the two occurrences of 'i' in the rearranged array are as far apart as possible. from collections import defaultdict positions = defaultdict(list) for index, value in enumerate(a): positions[value].append(index) rearranged = [-1] * (2 * n) last_pos = [-1] * n for i in range(1, n + 1): first, second = positions[i] for pos in range(2 * n): if rearranged[pos] == -1: if last_pos[i - 1] == -1: rearranged[pos] = i last_pos[i - 1] = pos elif (pos - last_pos[i - 1]) >= n: rearranged[pos] = i break return rearranged # Example usage: # n = 3 # a = [1, 2, 3, 2, 1, 3] # print(rearrange_array(n, a)) # Example output: [1, 2, 1, 3, 2, 3] or any valid rearrangement"},{"question":"def max_points(n: int, k: int, points: List[int]) -> int: Determine the maximum points Anna can collect to reach the final platform. >>> max_points(5, 2, [1, -2, 4, 5, -1]) 9 >>> max_points(1, 1, [5]) 5 >>> max_points(3, 1, [3, 2, 1]) 6 >>> max_points(5, 5, [-1, 5, 4, 2, 1]) 11 >>> max_points(5, 2, [-1, -2, -3, -4, -5]) -9 >>> max_points(5, 2, [0, 0, 0, 0, 0]) 0 pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def max_points(n, k, points): # Initialize dp array where dp[i] denotes the maximum points to reach platform i dp = [-float('inf')] * n dp[0] = points[0] # Use a deque to maintain the indices of the platforms with max points in range from collections import deque dq = deque([0]) for i in range(1, n): # Remove elements from the deque that are out of the k range while dq and dq[0] < i - k: dq.popleft() # The current dp value will be the max dp from the deque + current point dp[i] = dp[dq[0]] + points[i] # Maintain deque to only store indices of useful dp points while dq and dp[i] >= dp[dq[-1]]: dq.pop() dq.append(i) return dp[-1]"},{"question":"def longest_subarray_with_max_diff(arr: List[int], k: int) -> int: Finds the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to k. :param arr: List of integers. :param k: The maximum allowed difference. :return: Length of the longest subarray. >>> longest_subarray_with_max_diff([1, 3, 6, 3, 9, 12, 13], 3) == 3 >>> longest_subarray_with_max_diff([1, 2, 3, 4, 5], 0) == 1 >>> longest_subarray_with_max_diff([4, 8, 5, 1, 7, 9], 4) == 3 >>> longest_subarray_with_max_diff([], 5) == 0 >>> longest_subarray_with_max_diff([7, 7, 7, 7], 0) == 4 >>> longest_subarray_with_max_diff([7], 10) == 1 >>> longest_subarray_with_max_diff([1, 2, 3, 4, 5], 10**9) == 5 >>> longest_subarray_with_max_diff([2, 1, 3, 4, 2], 2) == 3","solution":"def longest_subarray_with_max_diff(arr, k): Finds the length of the longest contiguous subarray where the difference between the maximum and minimum values in the subarray is less than or equal to k. :param arr: List of integers. :param k: The maximum allowed difference. :return: Length of the longest subarray. from collections import deque if not arr: return 0 min_deque, max_deque = deque(), deque() left = 0 max_length = 0 for right in range(len(arr)): while min_deque and arr[min_deque[-1]] >= arr[right]: min_deque.pop() while max_deque and arr[max_deque[-1]] <= arr[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def count_common_conventions(sheldon: List[int], leonard: List[int], penny: List[int]) -> int: Returns the number of conventions attended by all three friends. >>> count_common_conventions([1, 3, 5, 7, 9], [3, 5, 7, 11], [5, 6, 7]) # Output: 2 >>> count_common_conventions([1, 2, 3], [4, 5, 6], [7, 8, 9]) # Output: 0 >>> count_common_conventions([1, 2, 3], [1, 2, 3], [1, 2, 3]) # Output: 3 >>> count_common_conventions([], [], []) # Output: 0 >>> count_common_conventions([1], [1], [1]) # Output: 1","solution":"def count_common_conventions(sheldon, leonard, penny): Returns the number of conventions attended by all three friends. sheldon_set = set(sheldon) leonard_set = set(leonard) penny_set = set(penny) common_conventions = sheldon_set & leonard_set & penny_set return len(common_conventions) # Example usage sheldon_list = [1, 3, 5, 7, 9] leonard_list = [3, 5, 7, 11] penny_list = [5, 6, 7] print(count_common_conventions(sheldon_list, leonard_list, penny_list)) # Output: 2"},{"question":"def maximum_value_expression(n: int, s: str) -> int: Given a length n and a string s consisting of lowercase Latin letters, returns the maximum possible value by converting each letter to its alphabet position and summing them. >>> maximum_value_expression(1, 'a') 1 >>> maximum_value_expression(3, 'abc') 6 >>> maximum_value_expression(4, 'abcd') 10 >>> maximum_value_expression(2, 'az') 27 >>> maximum_value_expression(5, 'hello') 52 # Your code here from solution import maximum_value_expression def test_maximum_value_expression_single_letter(): assert maximum_value_expression(1, 'a') == 1 assert maximum_value_expression(1, 'z') == 26 def test_maximum_value_expression_multiple_letters(): assert maximum_value_expression(3, 'abc') == 6 # 1 + 2 + 3 assert maximum_value_expression(4, 'abcd') == 10 # 1 + 2 + 3 + 4 assert maximum_value_expression(2, 'az') == 27 # 1 + 26 def test_maximum_value_expression_various(): assert maximum_value_expression(5, 'hello') == 52 # 8 + 5 + 12 + 12 + 15 assert maximum_value_expression(3, 'xyz') == 75 # 24 + 25 + 26 assert maximum_value_expression(6, 'python') == 98 # 16 + 25 + 20 + 8 + 15 + 14 assert maximum_value_expression(4, 'test') == 64 # 20 + 5 + 19 + 20","solution":"def maximum_value_expression(n, s): Given a length n and a string s, returns the maximum possible value by converting each letter to its alphabet position and summing them. return sum(ord(char) - ord('a') + 1 for char in s)"},{"question":"def find_knight_position(moves): Given a list of moves, determine the final position of the knight starting from (0,0). :param moves: List of tuples representing the moves (dx, dy). :return: Final position as a tuple (x, y). >>> find_knight_position([(2, 1), (2, -1), (-2, 1), (-1, 2), (1, -2)]) (2, 1) >>> find_knight_position([]) (0, 0) >>> find_knight_position([(2, 1)]) (2, 1) >>> find_knight_position([(1, 2), (-1, -2), (2, 1), (-2, -1)]) (0, 0) >>> find_knight_position([(-2, -1), (-2, -1)]) (-4, -2) >>> find_knight_position([(2, 1), (-2, -1), (2, 1)]) (2, 1) >>> find_knight_position([(2, 1)] * 100000) (200000, 100000)","solution":"def find_knight_position(moves): Given a list of moves, determine the final position of the knight starting from (0,0). :param moves: List of tuples representing the moves (dx, dy). :return: Final position as a tuple (x, y). x, y = 0, 0 for dx, dy in moves: x += dx y += dy return x, y"},{"question":"def lexicographically_smallest_string_after_removal(t: int, test_cases: List[str]) -> List[str]: Find the lexicographically smallest string that can be obtained by removing exactly one character from the string s for each test case. >>> lexicographically_smallest_string_after_removal(3, [\\"abc\\", \\"acb\\", \\"zzz\\"]) [\\"ab\\", \\"ab\\", \\"zz\\"] >>> lexicographically_smallest_string_after_removal(1, [\\"aaaa\\"]) [\\"aaa\\"]","solution":"def lexicographically_smallest_string_after_removal(t, test_cases): results = [] for s in test_cases: smallest_string = s[1:] # intial smallest string by removing the first character for i in range(1, len(s)): current_string = s[:i] + s[i+1:] if current_string < smallest_string: smallest_string = current_string results.append(smallest_string) return results"},{"question":"def trap(height: List[int]) -> int: Calculate the total units of water that can be trapped given the elevations of the bars. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([3, 0, 2, 0, 4]) 7","solution":"def trap(height): if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"from typing import List, Set def count_valid_permutations(dictionary_words: Set[str], scrambled_word: str) -> int: Returns the number of distinct permutations of the scrambled word that are present in the dictionary. >>> count_valid_permutations({\\"cat\\", \\"tac\\", \\"act\\", \\"dog\\"}, \\"tca\\") == 3 >>> count_valid_permutations({\\"a\\", \\"b\\"}, \\"a\\") == 1 >>> count_valid_permutations({\\"cat\\", \\"dog\\"}, \\"xyz\\") == 0 >>> count_valid_permutations({\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"}, \\"abc\\") == 6 >>> count_valid_permutations({\\"abc\\", \\"acb\\", \\"bac\\"}, \\"cab\\") == 3","solution":"from itertools import permutations def count_valid_permutations(dictionary_words, scrambled_word): Returns the number of distinct permutations of the scrambled word that are present in the dictionary. valid_permutations_count = 0 # Generate all unique permutations of the scrambled word unique_permutations = set(permutations(scrambled_word)) # Convert dictionary words list to set for O(1) lookups dictionary_set = set(dictionary_words) # Convert each permutation tuple to a string and check if it's in the dictionary for perm in unique_permutations: if ''.join(perm) in dictionary_set: valid_permutations_count += 1 return valid_permutations_count"},{"question":"from typing import List def can_transform_completely(s: str) -> bool: Checks if the string s can be fully transformed such that no further transformations are possible. pass def check_recipes(test_cases: List[str]) -> List[str]: For each test case, checks if the recipe string can be fully transformed. :param test_cases: List of scrambled recipe strings. :return: List of \\"YES\\" or \\"NO\\" for each test case. pass # Unit Test def test_can_transform_completely(): assert can_transform_completely(\\"momox\\") == False assert can_transform_completely(\\"mxm\\") == True assert can_transform_completely(\\"xmm\\") == True assert can_transform_completely(\\"momomoxx\\") == False assert can_transform_completely(\\"mmmxxxx\\") == True assert can_transform_completely(\\"xxmmmooxo\\") == False def test_check_recipes(): test_cases = [\\"momox\\", \\"mxm\\", \\"xmm\\", \\"momomoxx\\"] assert check_recipes(test_cases) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [\\"mmmxxxoxmo\\", \\"mmoxmo\\", \\"oxoxomx\\", \\"xxmmm\\"] assert check_recipes(test_cases) == [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] test_cases = [\\"mmmm\\", \\"xxxx\\", \\"mo\\", \\"xmooxm\\"] assert check_recipes(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_transform_completely(s): Checks if the string s can be fully transformed such that no further transformations are possible. if 'mo' in s or 'ox' in s: return False return True def check_recipes(test_cases): results = [] for s in test_cases: if can_transform_completely(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def distribute_presentations(s: int, d: int) -> list[int]: Distribute presentations among days as evenly as possible. >>> distribute_presentations(10, 3) [4, 3, 3] >>> distribute_presentations(10, 5) [2, 2, 2, 2, 2] >>> distribute_presentations(10, 1) [10] >>> distribute_presentations(7, 3) [3, 2, 2] >>> distribute_presentations(6, 2) [3, 3] >>> distribute_presentations(11, 3) [4, 4, 3]","solution":"def distribute_presentations(s, d): Distributes \`s\` presentations over \`d\` days as evenly as possible. days = s // d remainder = s % d distribution = [days + 1] * remainder + [days] * (d - remainder) return distribution"},{"question":"def max_sum(grid, start_row, start_col): Given a 2D grid with n rows and m columns, each cell of the grid contains an integer value, either 1 or -1. Starting from a specified cell of the grid, perform a series of moves to maximize the sum of the values of the cells visited. >>> grid = [ ... [1, -1, 1], ... [1, 1, -1], ... [-1, 1, 1] ... ] >>> start_row = 2 >>> start_col = 2 >>> max_sum(grid, start_row, start_col) 4 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> start_row = 1 >>> start_col = 1 >>> max_sum(grid, start_row, start_col) 9 >>> grid = [ ... [-1, -1, -1], ... [-1, -1, -1], ... [-1, -1, -1] ... ] >>> start_row = 1 >>> start_col = 1 >>> max_sum(grid, start_row, start_col) -1 >>> grid = [ ... [1, -1, 1], ... [-1, 1, -1], ... [1, -1, 1] ... ] >>> start_row = 2 >>> start_col = 2 >>> max_sum(grid, start_row, start_col) 1 >>> grid = [ ... [1, -1, 1], ... [-1, 1, -1], ... [1, -1, 1] ... ] >>> start_row = 1 >>> start_col = 1 >>> max_sum(grid, start_row, start_col) 1","solution":"def max_sum(grid, start_row, start_col): n = len(grid) m = len(grid[0]) max_sum_result = float('-inf') visited = [[False] * m for _ in range(n)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y, current_sum): nonlocal max_sum_result # Updating max result sum found so far max_sum_result = max(max_sum_result, current_sum) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True dfs(nx, ny, current_sum + grid[nx][ny]) visited[nx][ny] = False start_row -= 1 start_col -= 1 visited[start_row][start_col] = True dfs(start_row, start_col, grid[start_row][start_col]) return max_sum_result"},{"question":"def longest_path_in_grid(n: int, m: int, grid: List[str]) -> int: Given an n x m grid where each cell contains a lowercase Latin letter (i.e., 'a' to 'z'), you can traverse the grid starting from any cell to any adjacent cell horizontally or vertically. Your task is to find the longest path such that every letter you pass has been visited no more than once. The path does not need to be a straight line but can change direction as long as you move to adjacent cells and do not visit any cell more than once. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid: List[str] : the n x m grid with each cell containing a lowercase Latin letter Returns: int: the length of the longest path Example: >>> longest_path_in_grid(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 12 >>> longest_path_in_grid(1, 1, [\\"a\\"]) 1 >>> longest_path_in_grid(2, 2, [\\"ab\\", \\"cd\\"]) 4 >>> longest_path_in_grid(3, 3, [\\"aba\\", \\"cdc\\", \\"beb\\"]) 5 >>> longest_path_in_grid(2, 3, [\\"aaa\\", \\"aaa\\"]) 1 >>> longest_path_in_grid(4, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"]) 16","solution":"def longest_path_in_grid(n, m, grid): def dfs(x, y, visited): longest = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[ord(grid[nx][ny]) - ord('a')]: visited[ord(grid[nx][ny]) - ord('a')] = True longest = max(longest, dfs(nx, ny, visited) + 1) visited[ord(grid[nx][ny]) - ord('a')] = False return longest max_path_length = 0 for i in range(n): for j in range(m): visited = [False] * 26 # 26 letters in the alphabet visited[ord(grid[i][j]) - ord('a')] = True max_path_length = max(max_path_length, dfs(i, j, visited) + 1) return max_path_length"},{"question":"def minimum_maximum_skill_diff(n: int, m: int, skill_levels: List[int]) -> int: Calculate the minimum possible maximum skill level difference across all rooms after an optimal assignment of participants. >>> minimum_maximum_skill_diff(5, 2, [8, 2, 4, 6, 10]) 2 >>> minimum_maximum_skill_diff(1, 1, [10]) 0 >>> minimum_maximum_skill_diff(3, 2, [5, 5, 5]) 0 >>> minimum_maximum_skill_diff(6, 3, [1, 2, 9, 10, 11, 12]) 1 >>> minimum_maximum_skill_diff(6, 2, [1, 4, 8, 16, 24, 32]) 8 >>> minimum_maximum_skill_diff(4, 2, [1, 4, 1, 4]) 0","solution":"def minimum_maximum_skill_diff(n, m, skill_levels): skill_levels.sort() def can_distribute_with_max_diff(max_diff): rooms = [[] for _ in range(m)] for skill in skill_levels: placed = False for room in rooms: if not room or skill - room[-1] <= max_diff: room.append(skill) placed = True break if not placed: return False return True left, right = 0, skill_levels[-1] - skill_levels[0] while left < right: mid = (left + right) // 2 if can_distribute_with_max_diff(mid): right = mid else: left = mid + 1 return left"},{"question":"def process_notifications(n: int, notifications: List[str]) -> List[str]: Simulate the drug monitoring system's output. Args: n (int): The number of notifications. notifications (List[str]): A list of notifications in one of 'Add patient_id drug', 'Modify patient_id new_drug', or 'Alert patient_id' format. Returns: List[str]: A list containing the resulting alerts. Example: >>> process_notifications(6, [ \\"Add 101 insulin\\", \\"Add 102 metformin\\", \\"Alert 101\\", \\"Modify 101 glipizide\\", \\"Alert 101\\", \\"Alert 102\\" ]) [\\"Patient 101 is taking insulin\\", \\"Patient 101 is taking glipizide\\", \\"Patient 102 is taking metformin\\"]","solution":"def process_notifications(n, notifications): patient_info = {} alerts = [] for notification in notifications: parts = notification.split() command = parts[0] patient_id = int(parts[1]) if command == 'Add': drug = parts[2] if patient_id not in patient_info: patient_info[patient_id] = drug elif command == 'Modify': new_drug = parts[2] patient_info[patient_id] = new_drug elif command == 'Alert': drug = patient_info[patient_id] alerts.append(f\\"Patient {patient_id} is taking {drug}\\") return alerts"},{"question":"def determine_winner(n: int, m: int, grid: List[List[int]]) -> str: Determines the winner of the game if both players play optimally. Alice always gets the first move. Parameters: - n (int): Number of rows in the grid - m (int): Number of columns in the grid - grid (list of list of int): The n x m grid representing the game state Returns: - str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins >>> determine_winner(1, 1, [[5]]) \\"Alice\\" >>> determine_winner(2, 2, [[1, 2], [3, 4]]) \\"Bob\\" >>> determine_winner(3, 2, [[1, 2], [3, 4], [5, 6]]) \\"Bob\\" >>> determine_winner(4, 2, [[1, 2], [3, 4], [5, 6], [7, 8]]) \\"Bob\\" >>> determine_winner(101, 50, [[i + j for j in range(50)] for i in range(101)]) \\"Bob\\" >>> determine_winner(100, 70, [[i + j for j in range(70)] for i in range(100)]) \\"Bob\\"","solution":"def determine_winner(n, m, grid): Determines the winner of the game if both players play optimally. Alice always gets the first move. Parameters: - n (int): Number of rows in the grid - m (int): Number of columns in the grid - grid (list of list of int): The n x m grid representing the game state Returns: - str: \\"Alice\\" if Alice wins, \\"Bob\\" if Bob wins # The winner depends on the parity of the minimum of n and m # If both dimensions are odd, Alice wins, because she can always mirror Bob's move and remains the last to remove the final row/column # Otherwise, Bob wins since Alice would be forced into a losing situation eventually return \\"Alice\\" if min(n, m) % 2 == 1 else \\"Bob\\""},{"question":"def max_adjacent_pairs(n: int, widths: List[int]) -> int: Determine the maximum number of adjacent pairs of books with the same width that Anna can achieve. >>> max_adjacent_pairs(6, [4, 2, 2, 3, 4, 4]) == 1 >>> max_adjacent_pairs(5, [1, 2, 3, 4, 5]) == 0 >>> max_adjacent_pairs(6, [7, 7, 7, 7, 7, 7]) == 1 >>> max_adjacent_pairs(6, [1, 2, 2, 3, 3, 3]) == 1 >>> max_adjacent_pairs(1000, [i // 2 for i in range(1000)]) == 1 >>> max_adjacent_pairs(2, [1, 1]) == 1 >>> max_adjacent_pairs(2, [1, 2]) == 0","solution":"def max_adjacent_pairs(n, widths): from collections import Counter if n < 2: return 0 width_counts = Counter(widths) max_pairs = 0 for width in width_counts: count = width_counts[width] pairs = count // 2 max_pairs += pairs if max_pairs > 0: return 1 else: return 0"},{"question":"from typing import List def trap_rain_water(elevation_map: List[List[int]]) -> int: Determine the maximum amount of water that can be trapped within the given grid after it rains. Args: elevation_map (List[List[int]]): A 2D grid of integers representing elevations. Returns: int: The maximum amount of trapped water. >>> trap_rain_water([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) 4 >>> trap_rain_water([ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ]) 0 >>> trap_rain_water([ ... [2, 2, 2, 2], ... [2, 2, 2, 2], ... [2, 2, 2, 2] ... ]) 0 >>> trap_rain_water([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14 >>> trap_rain_water([ ... [5, 2, 7, 9, 4, 3, 8] ... ]) 0 >>> trap_rain_water([ ... [3], ... [2], ... [4], ... [5], ... [1] ... ]) 0","solution":"import heapq def trap_rain_water(elevation_map): if not elevation_map or not elevation_map[0]: return 0 n, m = len(elevation_map), len(elevation_map[0]) visited = [[False] * m for _ in range(n)] heap = [] # Add all boundary cells to the heap for i in range(n): heapq.heappush(heap, (elevation_map[i][0], i, 0)) heapq.heappush(heap, (elevation_map[i][m - 1], i, m - 1)) visited[i][0] = True visited[i][m - 1] = True for j in range(m): heapq.heappush(heap, (elevation_map[0][j], 0, j)) heapq.heappush(heap, (elevation_map[n - 1][j], n - 1, j)) visited[0][j] = True visited[n - 1][j] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - elevation_map[nx][ny]) heapq.heappush(heap, (max(height, elevation_map[nx][ny]), nx, ny)) return water_trapped"},{"question":"from typing import List def distribute_loot(total_loot: int, num_thieves: int) -> List[int]: Distributes the total loot among thieves as evenly as possible. >>> distribute_loot(7, 3) [2, 2, 3] >>> distribute_loot(15, 4) [3, 4, 4, 4]","solution":"from typing import List def distribute_loot(total_loot: int, num_thieves: int) -> List[int]: Distributes the total loot among thieves as evenly as possible. # Basic integer division and remainder to handle distribution base_amount = total_loot // num_thieves remainder = total_loot % num_thieves # All thieves get at least 'base_amount' of loot distribution = [base_amount] * num_thieves # Distribute the remainder one unit at a time to the first 'remainder' thieves for i in range(remainder): distribution[i] += 1 # Return the distribution sorted in non-decreasing order return sorted(distribution)"},{"question":"def longest_peaked_subarray_length(seq: List[int]) -> int: Returns the length of the longest peaked subarray in the given sequence. If no such subarray exists, returns 0. >>> longest_peaked_subarray_length([9, 8, 7, 6, 5, 4, 3, 2, 1, 2, 1]) 3 >>> longest_peaked_subarray_length([1, 3, 5, 7, 6, 4, 2, 8, 9]) 7 >>> longest_peaked_subarray_length([1]) 0 >>> longest_peaked_subarray_length([1, 2, 3, 4, 5]) 0 >>> longest_peaked_subarray_length([1, 2, 1, 3, 4]) 3","solution":"def longest_peaked_subarray_length(seq): Returns the length of the longest peaked subarray in the given sequence. If no such subarray exists, returns 0. N = len(seq) if N < 3: return 0 longest_peak_length = 0 for i in range(1, N-1): if seq[i-1] < seq[i] > seq[i+1]: # Check if seq[i] is a peak left = i - 1 right = i + 1 # Expand to the left while elements are increasing while left > 0 and seq[left-1] < seq[left]: left -= 1 # Expand to the right while elements are decreasing while right < N-1 and seq[right] > seq[right+1]: right += 1 current_peak_length = right - left + 1 longest_peak_length = max(longest_peak_length, current_peak_length) return longest_peak_length"},{"question":"def flower_query(n, q, flower_beds, queries): This function takes in the number of flower beds, the number of queries, the list of flowers in each bed, and the queries (ranges). Returns the sum of flowers in the queried range for each query. Args: n (int): the number of flower beds q (int): the number of queries flower_beds (List[int]): list containing the number of flowers in each bed queries (List[Tuple[int, int]]): list containing the ranges to query Returns: List[int]: list containing the sum of flowers in the queried ranges Example: >>> flower_query(5, 3, [3, 1, 4, 1, 5], [(2, 4), (1, 3), (3, 5)]) [6, 8, 10] >>> flower_query(4, 2, [0, 0, 0, 0], [(1, 4), (2, 3)]) [0, 0] >>> flower_query(1, 1, [7], [(1, 1)]) [7] >>> flower_query(3, 2, [10**9, 10**9, 10**9], [(1, 3), (2, 2)]) [3000000000, 1000000000] >>> flower_query(6, 4, [1, 2, 3, 4, 5, 6], [(1, 6), (1, 3), (4, 6), (2, 5)]) [21, 6, 15, 14]","solution":"def flower_query(n, q, flower_beds, queries): This function takes in the number of flower beds, the number of queries, the list of flowers in each bed, and the queries (ranges). Returns the sum of flowers in the queried range for each query. # Precompute prefix sums prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + flower_beds[i] results = [] for query in queries: l, r = query # Calculate the sum using the prefix sums array results.append(prefix_sums[r] - prefix_sums[l - 1]) return results # Example usage n = 5 q = 3 flower_beds = [3, 1, 4, 1, 5] queries = [(2, 4), (1, 3), (3, 5)] print(flower_query(n, q, flower_beds, queries)) # [6, 8, 10]"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the array that sum up to the given target. Args: nums (List[int]): An array of integers. target (int): An integer representing the sum of the quadruplet. Returns: List[List[int]]: A list of lists of integers, where each list contains four integers that add up to target. Examples: >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]]","solution":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: nums.sort() n = len(nums) result = [] for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue # skip duplicates for j in range(i + 1, n): if j > i + 1 and nums[j] == nums[j-1]: continue # skip duplicates left, right = j + 1, n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: result.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # skip duplicates while left < right and nums[right] == nums[right - 1]: right -= 1 # skip duplicates left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return result"},{"question":"def process_operations(n: int, m: int, a: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a list of operations on array \`a\` and return the results of sum queries. Parameters: n (int): The size of the array. m (int): The number of operations. a (List[int]): The array of integers. operations (List[Tuple[int, int, int]]): The list of operations, where each operation is either \`(1, x, y)\` to set \`a[x]\` to \`y\`, or \`(2, l, r)\` to get the sum from \`l\` to \`r\`. Returns: List[int]: The results of all sum queries. >>> process_operations(5, 4, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 4, 5)]) [6, 14, 9] >>> process_operations(3, 3, [1, 1, 1], [(2, 1, 3), (1, 1, 2), (2, 1, 2)]) [3, 3] >>> process_operations(4, 2, [4, 5, 6, 7], [(1, 4, 2), (2, 2, 4)]) [13] >>> process_operations(2, 5, [3, 8], [(2, 1, 2), (1, 2, 5), (2, 1, 2), (1, 1, 4), (2, 1, 2)]) [11, 8, 9]","solution":"def process_operations(n, m, a, operations): result = [] for op in operations: if op[0] == 1: # Operation type 1 x = op[1] - 1 y = op[2] a[x] = y elif op[0] == 2: # Operation type 2 l = op[1] - 1 r = op[2] result.append(sum(a[l:r])) return result"},{"question":"def rearrangeQueue(heights: List[int]) -> List[int]: Rearrange the heights array so that every person except the first has a taller person in front. >>> rearrangeQueue([170]) [170] >>> rearrangeQueue([170, 160]) [170, 160] or [160, 170] >>> rearrangeQueue([150, 160, 155]) [160, 150, 155] or [160, 155, 150] >>> rearrangeQueue([170, 165, 160, 155, 150]) [170, 165, 160, 155, 150] >>> rearrangeQueue([150, 160, 155, 165, 170]) [170, 165, 160, 155, 150] or other valid arrangement >>> rearrangeQueue([170, 160, 160, 155, 150]) [170, 160, 160, 155, 150] or other valid arrangement","solution":"def rearrangeQueue(heights): Rearranges the heights array so that every person except the first has a taller person in front. if len(heights) <= 1: return heights # Sort the array to easily pick the tallest person and then the next tallest sorted_heights = sorted(heights, reverse=True) # Start rearranging with the tallest person first, followed by the next tallest first_person = sorted_heights.pop(0) rearranged_queue = [first_person] + sorted_heights return rearranged_queue"},{"question":"def solve(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Determine the minimum number of edges to remove from the graph so that the remaining graph has no cycles and preserves the maximum possible sum of weights of the remaining edges. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edge_list (List[Tuple[int, int, int]]): List of edges in the graph, each defined by (u, v, w). Returns: int: The maximum possible sum of weights of the remaining edges. Examples: >>> solve(6, 9, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 5), (3, 4, 7), (3, 5, 9), (4, 5, 6), (4, 6, 8), (5, 6, 1)]) 33 >>> solve(2, 1, [(1, 2, 10)]) 10 >>> solve(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 3)]) 5 >>> solve(4, 5, [(1, 2, 1000), (2, 3, 1000), (3, 4, 1000), (4, 1, 1000), (1, 3, 1000)]) 3000 >>> solve(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 1)]) 3","solution":"def find(parent, i): A utility function to find the subset of an element i if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): A utility function to do union of two subsets xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def max_spanning_tree(n, edges): Function to find the maximum spanning tree using Kruskal's algorithm # Sort edges in decreasing order based on weight edges = sorted(edges, key=lambda item: item[2], reverse=True) parent = [] rank = [] for node in range(n+1): parent.append(node) rank.append(0) max_weight = 0 remaining_edges = 0 # Iterate through sorted edges for edge in edges: u, v, w = edge x = find(parent, u) y = find(parent, v) # If including this edge does not cause a cycle if x != y: max_weight += w remaining_edges += 1 union(parent, rank, x, y) # If we have n-1 edges in the tree, break the loop if remaining_edges == n-1: break return max_weight def solve(n, m, edge_list): return max_spanning_tree(n, edge_list)"},{"question":"def knapsack(W, n, items): Determine the maximum value John can achieve with a given weight constraint. Args: W (int): The maximum weight the bag can hold. n (int): The number of stones. items (list of tuples): A list where each tuple contains two integers representing the weight and value of each stone. Returns: int: The maximum value that can be achieved without exceeding the weight limit. Example: >>> knapsack(5, 3, [(2, 3), (3, 4), (4, 5)]) 7 >>> knapsack(6, 3, [(2, 3), (3, 4), (1, 2)]) 9 from solution import knapsack def test_example(): assert knapsack(5, 3, [(2, 3), (3, 4), (4, 5)]) == 7 def test_single_item_fits(): assert knapsack(10, 1, [(7, 10)]) == 10 def test_single_item_does_not_fit(): assert knapsack(5, 1, [(6, 8)]) == 0 def test_multiple_items_fit_exactly(): assert knapsack(6, 3, [(2, 3), (3, 4), (1, 2)]) == 9 # (3+4+2) def test_no_items(): assert knapsack(5, 0, []) == 0 def test_weight_limit_zero(): assert knapsack(0, 3, [(2, 3), (3, 4), (4, 5)]) == 0 def test_max_weight_item_only(): assert knapsack(7, 4, [(4, 5), (5, 6), (6, 7), (7, 8)]) == 8","solution":"def knapsack(W, n, items): Returns the maximum value of stones that can fit into the bag without exceeding the weight limit W. Parameters: W (int): The maximum weight the bag can hold. n (int): The number of stones. items (list of tuples): A list where each tuple contains two integers representing the weight and value of each stone. Returns: int: The maximum value that can be achieved without exceeding the weight limit. # Initialize dp array to store the maximum value for each weight limit from 0 to W dp = [0] * (W + 1) # Fill the dp array for i in range(n): wi, vi = items[i] # Traverse backwards to ensure we do not reuse the same item for w in range(W, wi - 1, -1): dp[w] = max(dp[w], dp[w - wi] + vi) return dp[W]"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string s, return the length of the longest palindromic subsequence that can be obtained by removing some characters from the string but without rearranging the remaining characters. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcd\\") 1 >>> longest_palindromic_subsequence(\\"aabbaa\\") 6 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"agbdba\\") 5","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"class SegmentTree: def __init__(self, data): Initialize the Segment Tree with the given data representing heights of buildings. self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): Build the Segment Tree from the given heights. for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, left, right): Query the maximum height in the specified range. left += self.n right += self.n + 1 max_height = 0 while left < right: if left % 2 == 1: max_height = max(max_height, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 max_height = max(max_height, self.tree[right]) left //= 2 right //= 2 return max_height def max_heights_in_ranges(n, heights, queries): Return the maximum heights for each query range. Args: n (int): Number of buildings. heights (List[int]): List of integers representing the heights of buildings. queries (List[Tuple[int, int]]): List of queries, each with the range to find the maximum height. Returns: List[int]: List of maximum heights for each query range. >>> max_heights_in_ranges(5, [3, 1, 6, 4, 2], [(1, 3), (2, 5), (1, 5)]) [6, 6, 6] # Test cases to validate the solution def test_example_case(): n = 5 heights = [3, 1, 6, 4, 2] queries = [(1, 3), (2, 5), (1, 5)] expected = [6, 6, 6] assert max_heights_in_ranges(n, heights, queries) == expected def test_single_building(): n = 1 heights = [10] queries = [(1, 1)] expected = [10] assert max_heights_in_ranges(n, heights, queries) == expected def test_all_same_height(): n = 5 heights = [3, 3, 3, 3, 3] queries = [(1, 2), (2, 4), (1, 5)] expected = [3, 3, 3] assert max_heights_in_ranges(n, heights, queries) == expected def test_leading_and_trailing_max(): n = 5 heights = [5, 1, 3, 2, 4] queries = [(1, 1), (1, 5), (2, 3), (4, 5)] expected = [5, 5, 3, 4] assert max_heights_in_ranges(n, heights, queries) == expected def test_random_query_ranges(): n = 6 heights = [2, 7, 3, 6, 8, 4] queries = [(1, 4), (2, 5), (3, 6), (1, 6)] expected = [7, 8, 8, 8] assert max_heights_in_ranges(n, heights, queries) == expected","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, left, right): left += self.n right += self.n + 1 max_height = 0 while left < right: if left % 2 == 1: max_height = max(max_height, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 max_height = max(max_height, self.tree[right]) left //= 2 right //= 2 return max_height def max_heights_in_ranges(n, heights, queries): segment_tree = SegmentTree(heights) results = [] for l, r in queries: results.append(segment_tree.query(l - 1, r - 1)) return results"},{"question":"def max_score(T: int, n: int, problems: List[Tuple[int, int, int]]) -> int: Determines the maximum score that can be achieved within the given time limit. Args: T (int): The total time limit for the event. n (int): The number of problems. problems (List[Tuple[int, int, int]]): A list of tuples where each tuple contains: - difficulty (int) - score (int) - time (int) Returns: int: The maximum score that can be achieved within the given time limit. >>> max_score(10, 3, [(5, 100, 3), (2, 300, 5), (1, 200, 6)]) 400 >>> max_score(15, 3, [(5, 100, 3), (2, 200, 5), (1, 300, 6)]) 600 >>> max_score(5, 1, [(1, 200, 5)]) 200 >>> max_score(5, 1, [(1, 200, 6)]) 0 >>> max_score(0, 3, [(5, 100, 3), (2, 300, 5), (1, 200, 6)]) 0 >>> max_score(10, 4, [(5, 200, 3), (2, 300, 5), (1, 150, 6), (3, 100, 4)]) 500","solution":"def max_score(T, n, problems): Determines the maximum score that can be achieved within the given time limit. Args: T (int): The total time limit for the event. n (int): The number of problems. problems (List[Tuple[int, int, int]]): A list of tuples where each tuple contains: - difficulty (int) - score (int) - time (int) Returns: int: The maximum score that can be achieved within the given time limit. # Initialize a list to keep track of the maximum score for each possible time dp = [0] * (T + 1) for difficulty, score, time in problems: if time <= T: # Update dp array from T to time (backwards) to avoid reusing the same problem for j in range(T, time - 1, -1): dp[j] = max(dp[j], dp[j - time] + score) return max(dp)"},{"question":"from typing import List def max_product_of_two_distinct_elements(n: int, arr: List[int]) -> int: Find the maximum possible product of any two distinct elements in the array. >>> max_product_of_two_distinct_elements(5, [10, 20, 30, 40, 50]) 2000 >>> max_product_of_two_distinct_elements(3, [1, 2, 3]) 6","solution":"def max_product_of_two_distinct_elements(n, arr): # Find the two largest numbers in the array max1 = max(arr) arr.remove(max1) max2 = max(arr) return max1 * max2"},{"question":"def can_sort_array(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to sort the array in non-decreasing order with any number of swaps. >>> can_sort_array(1, [(3, [3, 1, 2])]) [\\"YES\\"] >>> can_sort_array(2, [(3, [3, 1, 2]), (4, [4, 3, 2, 1])]) [\\"YES\\", \\"YES\\"] >>> can_sort_array(1, [(4, [1, 2, 3, 4])]) [\\"YES\\"] >>> can_sort_array(1, [(3, [0, -1, 1])]) [\\"YES\\"] >>> can_sort_array(1, [(5, [1000000000, -1000000000, 0, 999999999, -999999999])]) [\\"YES\\"]","solution":"def can_sort_array(t, test_cases): results = [] for case_index in range(t): n, arr = test_cases[case_index] # Sorting the array is possible for any array because we can always swap elements to achieve it. results.append(\\"YES\\") return results"},{"question":"from typing import List def longest_arithmetic_progression(movies: List[int]) -> int: Find the length of the longest arithmetic progression (AP) that can be formed with the given movie release years. >>> longest_arithmetic_progression([2000]) 1 >>> longest_arithmetic_progression([]) 0 >>> longest_arithmetic_progression([2000, 2000, 2000]) 3 >>> longest_arithmetic_progression([3, 6, 9, 12, 15, 18]) 6 >>> longest_arithmetic_progression([1, 7, 10, 15, 27, 29]) 3 >>> longest_arithmetic_progression([1, 2, 4, 8, 16, 32]) 2 >>> longest_arithmetic_progression([1, 3, 5, 7, 9, 11, 15]) 6 >>> longest_arithmetic_progression([100, 300, 500, 700, 900]) 5 >>> longest_arithmetic_progression([15, 3, 18, 12, 9, 6]) 6 # Add your implementation here","solution":"def longest_arithmetic_progression(movies): if not movies: return 0 movies.sort() n = len(movies) if n == 1: return 1 # Create a dictionary to store the length of AP for each pair dp = {} max_length = 2 for j in range(1, n): for i in range(j): diff = movies[j] - movies[i] if (i, diff) in dp: dp[(j, diff)] = dp[(i, diff)] + 1 else: dp[(j, diff)] = 2 max_length = max(max_length, dp[(j, diff)]) return max_length"},{"question":"def longest_substring_with_two_distinct_chars(s: str) -> str: Returns the longest substring that contains at most two distinct characters. >>> longest_substring_with_two_distinct_chars(\\"abcbbbbcccbdddadacb\\") 'bcbbbbcccb' >>> longest_substring_with_two_distinct_chars(\\"aabacbebebe\\") 'bebebe'","solution":"def longest_substring_with_two_distinct_chars(s): Returns the longest substring that contains at most two distinct characters. if len(s) < 3: return s left, right = 0, 0 hashmap = {} max_len = 2 max_substr = s[:2] while right < len(s): hashmap[s[right]] = right right += 1 if len(hashmap) > 2: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 if right - left > max_len: max_len = right - left max_substr = s[left:right] return max_substr"},{"question":"def min_travel_cost(n: int, edges: List[Tuple[int, int, int]]) -> int: Returns the minimum cost to visit all landmarks using Kruskal's algorithm to find the Minimum Spanning Tree (MST). If not all landmarks can be visited, returns -1. Parameters: n : int : number of landmarks edges : List[Tuple[int, int, int]] : list of edges where each edge is represented as a tuple (u, v, c) Returns: int : minimum travel cost to visit all landmarks, or -1 if not all landmarks can be visited. Examples: >>> min_travel_cost(4, [(1, 2, 4), (2, 3, 2), (3, 4, 3), (4, 1, 5)]) 9 >>> min_travel_cost(1, []) 0 >>> min_travel_cost(4, [(1, 2, 4), (3, 4, 3)]) -1 >>> min_travel_cost(2, [(1, 2, 4)]) 4 >>> min_travel_cost(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 10), (2, 4, 5)]) 6 import pytest from solution import min_travel_cost def test_min_travel_cost_example(): assert min_travel_cost(4, [(1, 2, 4), (2, 3, 2), (3, 4, 3), (4, 1, 5)]) == 9 def test_min_travel_cost_single_landmark(): assert min_travel_cost(1, []) == 0 def test_min_travel_cost_disconnected_graph(): assert min_travel_cost(4, [(1, 2, 4), (3, 4, 3)]) == -1 def test_min_travel_cost_two_landmarks(): assert min_travel_cost(2, [(1, 2, 4)]) == 4 def test_min_travel_cost_with_multiple_edges(): assert min_travel_cost(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 10), (2, 4, 5)]) == 6","solution":"def min_travel_cost(n, edges): Returns the minimum cost to visit all landmarks using Kruskal's algorithm to find the Minimum Spanning Tree (MST). If not all landmarks can be visited, returns -1. def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Sort edges based on cost edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_edges = [] index = 0 total_cost = 0 while len(mst_edges) < n - 1: if index >= len(edges): return -1 # not enough edges to connect all nodes u, v, w = edges[index] index += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: mst_edges.append((u, v, w)) union(parent, rank, x, y) total_cost += w return total_cost"},{"question":"def max_time_to_farthest_city(n: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the maximum time it will take for the messenger to travel from city 1 to any other city in the kingdom. >>> max_time_to_farthest_city(5, [(1, 2, 3), (1, 3, 2), (3, 4, 4), (3, 5, 5)]) 7 >>> max_time_to_farthest_city(3, [(1, 2, 1), (1, 3, 3)]) 3 >>> max_time_to_farthest_city(2, [(1, 2, 5)]) 5","solution":"import heapq def max_communication_time(n, roads): def dijkstra(graph, start): distances = [float('inf')] * (n + 1) distances[start] = 0 pq = [(0, start)] while pq: (current_distance, current_node) = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances graph = [[] for _ in range(n + 1)] for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) distances = dijkstra(graph, 1) return max(distances[1:]) def max_time_to_farthest_city(n, edges): return max_communication_time(n, edges)"},{"question":"def minimum_unprotected_diamonds(n: int, m: int, diamonds: List[int], knight_strength: List[int]) -> int: Determine the minimum number of diamonds that will remain unprotected. Args: n (int): number of castles m (int): number of knights diamonds (List[int]): number of diamonds in each castle knight_strength (List[int]): strength of each knight Returns: int: minimum number of diamonds that remain unprotected Example: >>> minimum_unprotected_diamonds(5, 3, [8, 3, 6, 2, 5], [1, 3, 5]) 5 >>> minimum_unprotected_diamonds(4, 4, [4, 7, 2, 1], [1, 2, 3, 4]) 0 >>> minimum_unprotected_diamonds(3, 0, [7, 4, 1], []) 12 >>> minimum_unprotected_diamonds(5, 3, [4, 4, 4, 4, 4], [2, 3, 4]) 8 >>> minimum_unprotected_diamonds(6, 2, [9, 1, 4, 5, 3, 8], [1, 6]) 13","solution":"def minimum_unprotected_diamonds(n, m, diamonds, knight_strength): protected = set(knight_strength) unprotected_diamonds = sum(diamonds[i] for i in range(n) if i + 1 not in protected) return unprotected_diamonds # Example usage: # n = 5 # m = 3 # diamonds = [8, 3, 6, 2, 5] # knight_strength = [1, 3, 5] # print(minimum_unprotected_diamonds(n, m, diamonds, knight_strength)) # Output: 5"},{"question":"from itertools import combinations from typing import List def unique_homework_sets(n: int, k: int, answers: List[str]) -> int: Calculate the number of unique homework sets. :param n: Number of questions :param k: Number of questions in each homework :param answers: List of correct answers for each question :return: Number of unique homework sets >>> unique_homework_sets(4, 2, ['0', '1', '0', '1']) 6 >>> unique_homework_sets(1, 1, ['0']) 1 >>> unique_homework_sets(4, 4, ['0', '1', '0', '1']) 1 >>> unique_homework_sets(4, 5, ['0', '1', '0', '1']) 0 >>> unique_homework_sets(5, 3, ['0', '1', '0', '1', '0']) 10 >>> unique_homework_sets(5, 4, ['0', '1', '1', '0', '1']) 5 # Function implementation goes here. def main(): import sys input = sys.stdin.read data = input().split() n, k = int(data[0]), int(data[1]) answers = data[2:] print(unique_homework_sets(n, k, answers)) if __name__ == \\"__main__\\": main()","solution":"from itertools import combinations def unique_homework_sets(n, k, answers): Calculate the number of unique homework sets. :param n: Number of questions :param k: Number of questions in each homework :param answers: List of correct answers for each question :return: Number of unique homework sets return len(list(combinations(range(n), k))) def main(): import sys input = sys.stdin.read data = input().split() n, k = int(data[0]), int(data[1]) answers = data[2:] print(unique_homework_sets(n, k, answers)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def max_min_quality(n: int, k: int, q: List[int]) -> int: Finds the maximum possible quality of the weakest segment after performing up to k replacements. >>> max_min_quality(5, 1, [3, 3, 2, 3, 4]) 3 >>> max_min_quality(4, 4, [5, 5, 5, 5]) 5","solution":"def max_min_quality(n, k, q): Finds the maximum possible quality of the weakest segment after performing up to k replacements. def can_achieve(min_quality): replacements_needed = 0 for quality in q: if quality < min_quality: replacements_needed += 1 if replacements_needed > k: return False return True left, right = min(q), max(q) best_quality = left while left <= right: mid = (left + right) // 2 if can_achieve(mid): best_quality = mid left = mid + 1 else: right = mid - 1 return best_quality"},{"question":"def max_concurrent_sessions(k: int, intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of concurrent game sessions at any point in time. Args: k: int: number of game sessions intervals: list of tuples: each tuple contains two integers representing the start and end time of a session Returns: int: the maximum number of concurrent game sessions >>> max_concurrent_sessions(4, [(1, 5), (3, 7), (4, 6), (6, 8)]) 3 >>> max_concurrent_sessions(3, [(1, 2), (3, 4), (5, 6)]) 1","solution":"def max_concurrent_sessions(k, intervals): Determines the maximum number of concurrent game sessions at any point in time. Args: k: int: number of game sessions intervals: list of tuples: each tuple contains two integers representing the start and end time of a session Returns: int: the maximum number of concurrent game sessions events = [] for start, end in intervals: events.append((start, 'start')) events.append((end, 'end')) events.sort() concurrent_sessions = 0 max_concurrent = 0 for time, type in events: if type == 'start': concurrent_sessions += 1 if concurrent_sessions > max_concurrent: max_concurrent = concurrent_sessions else: concurrent_sessions -= 1 return max_concurrent"},{"question":"def tournament_rounds(n: int) -> int: Returns the number of rounds needed for a tournament with n participants to conclude with a single winner. >>> tournament_rounds(8) 3 >>> tournament_rounds(5) 3 >>> tournament_rounds(1) 0 >>> tournament_rounds(2) 1 >>> tournament_rounds(1000000000) 30","solution":"def tournament_rounds(n): Returns the number of rounds needed for a tournament with n participants to conclude with a single winner. rounds = 0 while n > 1: rounds += 1 n = (n + 1) // 2 return rounds"},{"question":"def identify_operation(n: int, current_prices: List[int], expected_prices: List[int]) -> str: Determine which operation can transform the current list of ticket prices to the expected list. >>> identify_operation(5, [10, 12, 14, 16, 18], [12, 14, 16, 18, 20]) 'Increment' >>> identify_operation(4, [8, 6, 4, 2], [2, 4, 6, 8]) 'Reverse' >>> identify_operation(3, [5, 10, 15], [5, 10, 20]) 'None'","solution":"def identify_operation(n, current_prices, expected_prices): if n <= 0: return \\"None\\" if current_prices == expected_prices[::-1]: return \\"Reverse\\" diff = [expected_prices[i] - current_prices[i] for i in range(n)] if len(set(diff)) == 1: if diff[0] > 0: return \\"Increment\\" elif diff[0] < 0: return \\"Decrement\\" return \\"None\\""},{"question":"def max_subarray_with_even(nums: List[int], n: int, k: int) -> int: Find the maximum possible sum of a subarray of length k that contains at least one even number. >>> max_subarray_with_even([1, 2, 3, 4, 5], 5, 3) 12 >>> max_subarray_with_even([1, 1, 1, 1, 6], 5, 3) 8 >>> max_subarray_with_even([1, 1, 1, 1, 3], 5, 3) -1 >>> max_subarray_with_even([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10, 4) 34 >>> max_subarray_with_even([-1, -2, -3, -4, 5, 6], 6, 3) 7 >>> max_subarray_with_even([1, 3, 5, 2, 4, 6], 6, 2) 10","solution":"def max_subarray_with_even(nums, n, k): max_sum = -1 # Initialize to -1 in case no valid subarray is found current_sum = 0 has_even = False for i in range(k): current_sum += nums[i] if nums[i] % 2 == 0: has_even = True if has_even: max_sum = current_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] if nums[i] % 2 == 0: has_even = True if nums[i - k] % 2 == 0: has_even = any(num % 2 == 0 for num in nums[i - k + 1:i + 1]) if has_even and current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def min_cost_to_connect_houses(n: int, cost: List[List[int]]) -> int: Calculate the minimum cost to connect all houses using Kruskal’s algorithm to find the Minimum Spanning Tree. Args: n: int - number of houses. cost: List[List[int]] - matrix of costs to build pipelines between houses. Returns: int - the total cost required to construct the pipeline network. Examples: >>> min_cost_to_connect_houses(4, [ ... [0, 1, 3, 4], ... [1, 0, 2, 5], ... [3, 2, 0, 6], ... [4, 5, 6, 0]]) 7 >>> min_cost_to_connect_houses(3, [ ... [0, 2, 3], ... [2, 0, 1], ... [3, 1, 0]]) 3","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def min_cost_to_connect_houses(n, cost): edges = [] for i in range(n): for j in range(i + 1, n): edges.append((cost[i][j], i, j)) edges.sort() uf = UnionFind(n) total_cost = 0 for weight, u, v in edges: if uf.find(u) != uf.find(v): uf.union(u, v) total_cost += weight return total_cost"},{"question":"def num_paths(grid, start, end): Returns the number of distinct paths from start to end in the given grid. grid: List[List[int]] : 2D grid of integers where 1 is obstacle and 0 is empty cell. start: Tuple[int, int] : starting cell coordinates. end: Tuple[int, int] : target cell coordinates. >>> grid = [ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ] >>> num_paths(grid, (0, 0), (3, 2)) 2 >>> grid = [ ... [0] ... ] >>> num_paths(grid, (0, 0), (0, 0)) 1 >>> grid = [ ... [0, 0, 1], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> num_paths(grid, (0, 0), (2, 2)) 0 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> num_paths(grid, (0, 0), (2, 2)) 2","solution":"def num_paths(grid, start, end): Returns the number of distinct paths from start to end in the given grid. m, n = len(grid), len(grid[0]) start_x, start_y = start end_x, end_y = end directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 def dfs(x, y): if (x, y) == (end_x, end_y): return 1 grid[x][y] = 1 paths = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): paths += dfs(nx, ny) grid[x][y] = 0 return paths return dfs(start_x, start_y) # Parsing the input format as a function def parse_input(): m, n = map(int, input().split()) grid = [] for _ in range(m): grid.append(list(map(int, input().split()))) start_x, start_y = map(int, input().split()) end_x, end_y = map(int, input().split()) return grid, (start_x, start_y), (end_x, end_y) if __name__ == \\"__main__\\": grid, start, end = parse_input() print(num_paths(grid, start, end))"},{"question":"def simplify_expression(expression: str) -> str: Simplifies the given expression by renaming all distinct variables to 'a', 'b', 'c', etc. in alphabetical order. Parameters: expression (str): The input mathematical expression. Returns: str: The simplified expression with variables renamed. Examples: >>> simplify_expression(\\"x - y + x * z\\") 'a - b + a * c' >>> simplify_expression(\\"a + b - c * d / e % f\\") 'a + b - c * d / e % f'","solution":"import re def simplify_expression(expression): Simplifies the given expression by renaming all distinct variables to 'a', 'b', 'c', etc. in alphabetical order. Parameters: expression (str): The input mathematical expression. Returns: str: The simplified expression with variables renamed. # Find all distinct variables in the expression variables = sorted(set(re.findall(r'[a-z]', expression))) # Create a mapping from old variable names to new variable names mapping = {var: chr(97 + idx) for idx, var in enumerate(variables)} # Replace all occurrences of old variables with new variables new_expression = ''.join([mapping[char] if char in mapping else char for char in expression]) return new_expression"},{"question":"def max_non_consecutive_sum(nums: List[int]) -> int: Returns the maximum possible sum of its elements such that no two consecutive elements are taken for the sum. >>> max_non_consecutive_sum([3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_sum([-5, 10, -100, 200, -1]) 210 >>> max_non_consecutive_sum([5]) 5 >>> max_non_consecutive_sum([-5]) 0 >>> max_non_consecutive_sum([-1, 2, -3, 4, -5, 6]) 12 >>> max_non_consecutive_sum([1, 100, 2, 200, 3, 300, 4, 400, 5, 500]) 1500 >>> max_non_consecutive_sum([3, 2, 7, 10]) 13 >>> max_non_consecutive_sum([-1, 0, -2, 0]) 0 >>> max_non_consecutive_sum([-1, -2, -3, -4]) 0 >>> max_non_consecutive_sum([5, 10]) 10 >>> max_non_consecutive_sum([10, 5]) 10 >>> max_non_consecutive_sum([-2, -3]) 0 >>> max_non_consecutive_sum([-2, 3]) 3","solution":"def max_non_consecutive_sum(nums): Returns the maximum sum of elements such that no two consecutive elements are taken. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) incl = max(0, nums[0]) # max sum including current element excl = 0 # max sum excluding current element for num in nums[1:]: new_excl = max(incl, excl) # max sum when current element is excluded incl = excl + max(0, num) # max sum when current element is included excl = new_excl return max(incl, excl)"},{"question":"def most_frequent_files(n: int, files: List[str]) -> List[str]: Determine the most frequently accessed file at each step of the sequence. Args: n : int : number of file access events files : List[str] : list of file names being accessed Returns: List[str] : list of most frequently accessed file at each step >>> most_frequent_files(6, [\\"file1\\", \\"file2\\", \\"file1\\", \\"file3\\", \\"file2\\", \\"file1\\"]) [\\"file1\\", \\"file1\\", \\"file1\\", \\"file1\\", \\"file1\\", \\"file1\\"] >>> most_frequent_files(4, [\\"file1\\", \\"file1\\", \\"file2\\", \\"file2\\"]) [\\"file1\\", \\"file1\\", \\"file1\\", \\"file1\\"]","solution":"def most_frequent_files(n, files): access_count = {} top_file = None top_count = 0 result = [] for file in files: if file in access_count: access_count[file] += 1 else: access_count[file] = 1 if access_count[file] > top_count or (access_count[file] == top_count and (top_file is None or files.index(top_file) > files.index(file))): top_file = file top_count = access_count[file] result.append(top_file) return result"},{"question":"def count_arrangements(n: int, m: int, heights: List[int]) -> int: Count the number of different arrangements of exactly m plants that form a strictly increasing sequence from left to right. >>> count_arrangements(3, 2, [1, 3, 2]) 3 >>> count_arrangements(1, 1, [5]) 1 >>> count_arrangements(4, 3, [1, 2, 3, 4]) 4 >>> count_arrangements(5, 3, [5, 4, 3, 2, 1]) 10 >>> count_arrangements(1, 100, [50]) 0 >>> count_arrangements(6, 4, [1, 3, 2, 4, 6, 5]) 15","solution":"def count_arrangements(n, m, heights): # Sort the heights to ensure we can form increasing sequences easily heights.sort() # dp[i][k] will store the number of ways to select k plants using the first i plant heights dp = [[0] * (m + 1) for _ in range(n + 1)] # There's one way to select 0 plants: not selecting any plants for i in range(n + 1): dp[i][0] = 1 # Fill the dp array for i in range(1, n + 1): for k in range(1, m + 1): dp[i][k] = dp[i - 1][k] # Do not include heights[i-1] if k >= 1: dp[i][k] += dp[i - 1][k - 1] # Include heights[i-1] # The final answer is the number of ways we can pick m plants from all n plants return dp[n][m] # Input reader function to handle the input format described in the problem def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) heights = list(map(int, data[2:])) print(count_arrangements(n, m, heights)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def arrange_paintings(n: int, m: int, k: int, themes: List[int]) -> str: Arrange paintings in exhibition slots such that no two consecutive slots contain paintings of the same theme. Args: n : int : number of paintings m : int : number of exhibition slots k : int : number of themes themes : List[int] : themes of each painting Returns: str : \\"YES\\" followed by a possible arrangement if possible, else \\"NO\\" Example: >>> arrange_paintings(6, 6, 3, [1, 2, 1, 2, 3, 3]) 'YESn1 2 1 3 2 3' >>> arrange_paintings(4, 4, 2, [1, 1, 1, 2]) 'NO' pass # To be implemented def read_input(input_string: str) -> Tuple[int, int, int, List[int]]: Read input in the required format. Args: input_string : str : input in string format Returns: Tuple[int, int, int, List[int]] : Parsed input values Example: >>> read_input('6 6 3n1 2 1 2 3 3') (6, 6, 3, [1, 2, 1, 2, 3, 3]) pass # To be implemented # Unit Tests def test_example_case(): n, m, k, themes = read_input(\\"6 6 3n1 2 1 2 3 3\\") result = arrange_paintings(n, m, k, themes) assert \\"YES\\" in result def test_no_possible_arrangement(): n, m, k, themes = read_input(\\"4 4 2n1 1 1 2\\") result = arrange_paintings(n, m, k, themes) assert result == \\"NO\\" def test_single_painting(): n, m, k, themes = read_input(\\"1 1 1n1\\") result = arrange_paintings(n, m, k, themes) assert \\"YES\\" in result def test_two_paintings_of_same_theme(): n, m, k, themes = read_input(\\"2 2 1n1 1\\") result = arrange_paintings(n, m, k, themes) assert result == \\"NO\\" def test_two_paintings_possible_alternate(): n, m, k, themes = read_input(\\"2 2 2n1 2\\") result = arrange_paintings(n, m, k, themes) assert \\"YES\\" in result def test_large_input(): n, m, k, themes = read_input(\\"10 10 3n1 1 1 2 2 2 3 3 3 1\\") result = arrange_paintings(n, m, k, themes) assert \\"YES\\" in result","solution":"def arrange_paintings(n, m, k, themes): from collections import Counter, defaultdict import heapq # Counts the occurrences of each theme theme_count = Counter(themes) # Verify if a valid arrangement is possible if any(count > (m + 1) // 2 for count in theme_count.values()): return \\"NO\\" # Create max-heap based on counts max_heap = [(-count, theme) for theme, count in theme_count.items()] heapq.heapify(max_heap) result = [0] * m # Result array for slots idx = 0 # Index for slot while max_heap: count, theme = heapq.heappop(max_heap) count = -count for _ in range(count): if result[idx] != 0: # find the next free slot idx = (idx + 1) % m result[idx] = theme idx += 2 # place at alternate positions if idx >= m: idx = 1 return \\"YESn\\" + \\" \\".join(map(str, result)) # Read input function def read_input(input_string): lines = input_string.split(\\"n\\") n, m, k = map(int, lines[0].split()) themes = list(map(int, lines[1].split())) return n, m, k, themes"},{"question":"def min_flips_to_make_equal(arr: List[int]) -> int: Returns the minimum number of flips to make all elements of the array equal. >>> min_flips_to_make_equal([1, 0, 0, 1, 1]) == 1 >>> min_flips_to_make_equal([0, 1, 1, 0, 0]) == 1","solution":"def min_flips_to_make_equal(arr): Returns the minimum number of flips to make all elements of the array equal. count_zeros = 0 count_ones = 0 prev = arr[0] if prev == 0: count_zeros += 1 else: count_ones += 1 for i in range(1, len(arr)): if arr[i] != prev: if arr[i] == 0: count_zeros += 1 else: count_ones += 1 prev = arr[i] return min(count_zeros, count_ones)"},{"question":"def can_fulfill_requests(total_cards: int, card_collection: List[int], total_requests: int, requests: List[List[int]]) -> List[str]: Determines if John can fulfill each friend's request for specific rarity levels. Parameters: total_cards (int): The total number of cards in John's collection. card_collection (List[int]): A list of integers representing the rarity levels of the cards. total_requests (int): The number of friends making requests. requests (List[List[int]]): A list of requests, where each request is a list containing the number of different rarities needed and the number of cards requested for each rarity level. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each request indicating if it can be fulfilled. Examples: >>> can_fulfill_requests(10, [1, 2, 3, 2, 1, 4, 2, 2, 3, 1], 3, [[2, 1, 1, 2, 2], [2, 3, 3, 1, 1], [1, 4, 3]]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_fulfill_requests(5, [1, 2, 2, 3, 3], 2, [[1, 1, 1], [2, 2, 1, 3, 1]]) [\\"YES\\", \\"YES\\"] >>> can_fulfill_requests(5, [1, 2, 2, 3, 3], 1, [[2, 2, 3, 3, 3]]) [\\"NO\\"] >>> can_fulfill_requests(5, [1, 2, 2, 3, 3], 0, []) [] >>> can_fulfill_requests(5, [1, 2, 3, 4, 5], 2, [[1, 6, 1], [1, 7, 1]]) [\\"NO\\", \\"NO\\"]","solution":"def can_fulfill_requests(total_cards, card_collection, total_requests, requests): from collections import Counter # Count the occurrences of each rarity level in John's collection card_count = Counter(card_collection) results = [] for request in requests: k = request[0] rarity_requests = request[1:] # Create a counter for the requested cards request_count = Counter() for i in range(0, len(rarity_requests), 2): requested_rarity = rarity_requests[i] requested_quantity = rarity_requests[i + 1] request_count[requested_rarity] = requested_quantity # Check if John can fulfill this request can_fulfill = True for rarity_level, quantity in request_count.items(): if card_count[rarity_level] < quantity: can_fulfill = False break if can_fulfill: results.append(\\"YES\\") # If fulfilled, decrease the quantities from John's collection for rarity_level, quantity in request_count.items(): card_count[rarity_level] -= quantity else: results.append(\\"NO\\") return results"},{"question":"def sequence_of_cities(n: int) -> List[int]: Returns the sequence of cities Masha will visit. >>> sequence_of_cities(5) [3, 4, 2, 5, 1] >>> sequence_of_cities(7) [4, 5, 3, 6, 2, 7, 1]","solution":"def sequence_of_cities(n): Returns the sequence of cities Masha will visit. middle = (n // 2) + 1 result = [middle] for i in range(1, (n + 1) // 2): if middle + i <= n: result.append(middle + i) if middle - i >= 1: result.append(middle - i) return result"},{"question":"from typing import List def minimum_cost_path(grid: List[List[int]]) -> int: Find the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. :param grid: List of lists where each sublist represents a row in the grid, and each element in the row is the weight of a cell. :return: Integer, the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> minimum_cost_path(grid) 7 >>> grid = [ ... [5] ... ] >>> minimum_cost_path(grid) 5 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> minimum_cost_path(grid) 7 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> minimum_cost_path(grid) 21 >>> grid = [ ... [1, 1, 2], ... [2, 1, 2], ... [3, 2, 1] ... ] >>> minimum_cost_path(grid) 6 pass","solution":"import heapq def minimum_cost_path(grid): Find the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. :param grid: List of lists where each sublist represents a row in the grid, and each element in the row is the weight of a cell. :return: Integer, the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Use Dijkstra's Algorithm to find the shortest path min_heap = [(grid[0][0], 0, 0)] # (cost, x, y) costs = [[float('inf')] * m for _ in range(n)] costs[0][0] = grid[0][0] while min_heap: current_cost, x, y = heapq.heappop(min_heap) if x == n-1 and y == m-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_cost = current_cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return costs[n-1][m-1] # Example Usage: # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(minimum_cost_path(grid)) # Output: 7"},{"question":"def sold_out_performances(n: int, m: int, tickets_available: List[int], sales: List[Tuple[int, int]]) -> int: Determines the number of sold-out performances based on ticket sales. :param n: int, total number of tickets :param m: int, total number of performances :param tickets_available: list of int, number of tickets available for each performance :param sales: list of tuples, each tuple contains two integers (id, di) where id is the unique identifier of the ticket and di is the performance number for which the ticket has been sold. :return: int, number of sold-out performances >>> sold_out_performances(8, 3, [3, 3, 2], [(1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 3), (8, 3)]) 2 >>> sold_out_performances(8, 3, [4, 4, 3], [(1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 3), (8, 3)]) 0 >>> sold_out_performances(8, 3, [3, 3, 2], [(1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2)]) 2 >>> sold_out_performances(5, 1, [5], [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) 1","solution":"def sold_out_performances(n, m, tickets_available, sales): Determines the number of sold-out performances based on ticket sales. :param n: int, total number of tickets :param m: int, total number of performances :param tickets_available: list of int, number of tickets available for each performance :param sales: list of tuples, each tuple contains two integers (id, di) where id is the unique identifier of the ticket and di is the performance number for which the ticket has been sold. :return: int, number of sold-out performances # Create a list to count sales for each performance tickets_sold = [0] * m # Tally the tickets sold for each performance for sale in sales: _, performance_num = sale tickets_sold[performance_num - 1] += 1 # Count the number of sold-out performances sold_out_count = 0 for i in range(m): if tickets_sold[i] == tickets_available[i]: sold_out_count += 1 return sold_out_count"},{"question":"import heapq from typing import List, Tuple class TaskManager: def __init__(self): self.min_heap = [] self.task_lookup = {} self.counter = 0 def add_task(self, task_id: str, priority: int, description: str): Adds a new task with the given id, priority, and description. pass # implement this method def pop_task(self) -> str: Retrieves and removes the highest-priority task and returns its id. If there are no tasks, returns \\"EMPTY\\". pass # implement this method def process_queries(queries: List[str]) -> List[str]: Processes a list of queries for adding and retrieving tasks, returns the results of \\"POP\\" queries. >>> queries = [ \\"ADD task1 10 First task description\\", \\"ADD task2 5 Some other task\\", \\"ADD task3 10 Another task description\\", \\"POP\\", \\"POP\\", \\"POP\\" ] >>> process_queries(queries) [\\"task2\\", \\"task1\\", \\"task3\\"] >>> queries = [\\"POP\\"] >>> process_queries(queries) [\\"EMPTY\\"] >>> queries = [ \\"ADD task1 20 First task description\\", \\"POP\\", \\"ADD task2 15 Another task description\\", \\"POP\\", \\"ADD task3 10 Third task description\\", \\"ADD task4 25 Fourth task description\\", \\"POP\\", \\"POP\\" ] >>> process_queries(queries) [\\"task1\\", \\"task2\\", \\"task3\\", \\"task4\\"] >>> queries = [ \\"ADD task1 10 task description 1\\", \\"ADD task2 10 task description 2\\", \\"ADD task3 10 task description 3\\", \\"POP\\", \\"POP\\", \\"POP\\" ] >>> process_queries(queries) [\\"task1\\", \\"task2\\", \\"task3\\"] pass # implement this method","solution":"import heapq class TaskManager: def __init__(self): self.min_heap = [] self.task_lookup = {} self.counter = 0 def add_task(self, task_id, priority, description): # Create a tuple of (priority, insertion order, task_id, description) entry = (priority, self.counter, task_id, description) heapq.heappush(self.min_heap, entry) self.task_lookup[task_id] = entry self.counter += 1 def pop_task(self): if not self.min_heap: return \\"EMPTY\\" priority, insertion_order, task_id, description = heapq.heappop(self.min_heap) del self.task_lookup[task_id] return task_id def process_queries(queries): task_manager = TaskManager() results = [] for query in queries: parts = query.split(' ', 3) if parts[0] == \\"ADD\\": _, task_id, priority, description = parts priority = int(priority) task_manager.add_task(task_id, priority, description) elif parts[0] == \\"POP\\": result = task_manager.pop_task() results.append(result) return results"},{"question":"def painted_small_cubes(n: int) -> tuple: Determine the number of smaller cubes with exactly one face, two faces, and three faces painted from a larger cube of edge length n. >>> painted_small_cubes(4) (24, 24, 8) >>> painted_small_cubes(2) (0, 0, 8)","solution":"def painted_small_cubes(n): Returns the number of smaller cubes with exactly one face, two faces, and three faces painted from a larger cube of edge length n. if n < 2: return (0, 0, 0) # Not possible as per the constraint 2 <= n <= 10^6 one_face_painted = (n - 2) ** 2 * 6 two_faces_painted = (n - 2) * 12 three_faces_painted = 8 return one_face_painted, two_faces_painted, three_faces_painted # Sample usage print(painted_small_cubes(4)) # Expected output (24, 24, 8)"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be completed. Args: tasks (List[Tuple[int, int]]): List of tuples where each tuple contains two integers (start_time, end_time) Returns: int: Maximum number of non-overlapping tasks >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6), (6, 8), (5, 7)]) 3 >>> max_non_overlapping_tasks([(1, 2), (2, 4), (3, 5), (7, 10), (5, 7)]) 4 >>> max_non_overlapping_tasks([(1, 5), (2, 3), (4, 8), (6, 10)]) 2 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_tasks([(1, 4), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_tasks([(1, 20), (2, 2), (3, 5), (6, 19), (10, 11)]) 3 >>> max_non_overlapping_tasks([(1, 2)]) 1 >>> max_non_overlapping_tasks([]) 0","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be completed. :param tasks: List of tuples where each tuple contains two integers (start_time, end_time) :return: Integer representing the maximum number of non-overlapping tasks # Sort tasks by end time tasks.sort(key=lambda x: x[1]) count = 0 current_end_time = 0 for start, end in tasks: if start >= current_end_time: count += 1 current_end_time = end return count"},{"question":"def min_moves_to_empty_string(n: int, s: str) -> int: Returns the minimum number of moves required to make the string empty. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase Latin letters. Returns: int: The minimum number of moves. >>> min_moves_to_empty_string(5, \\"abcba\\") 2 >>> min_moves_to_empty_string(1, \\"a\\") 1 >>> min_moves_to_empty_string(4, \\"abcd\\") 1 >>> min_moves_to_empty_string(3, \\"aaa\\") 3 >>> min_moves_to_empty_string(3, \\"aba\\") 2 >>> min_moves_to_empty_string(2, \\"ab\\") 1 >>> min_moves_to_empty_string(6, \\"ababab\\") 3","solution":"def min_moves_to_empty_string(n, s): Returns the minimum number of moves required to make the string empty. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase Latin letters. Returns: int: The minimum number of moves. moves = 0 while n > 0: # Create a set to track unique characters in the current move seen_chars = set() length_of_prefix = 0 # Determine the longest prefix without repeating characters for i in range(n): if s[i] in seen_chars: break seen_chars.add(s[i]) length_of_prefix += 1 # Remove the determined prefix from the string s = s[length_of_prefix:] n -= length_of_prefix # Increment the number of moves moves += 1 return moves"},{"question":"def maximize_coins(n: int, k: int, coins: List[int], difficulty: List[int]) -> int: Given the number of coins and the difficulty level for each chest, find the maximum coins they can collect if they open at most k chests. >>> maximize_coins(5, 2, [10, 20, 30, 40, 50], [5, 10, 15, 20, 25]) 90 >>> maximize_coins(4, 2, [10, 20, 30, 40], [1, 2, 3, 4]) 70 >>> maximize_coins(1, 1, [100], [10]) 100 >>> maximize_coins(3, 1, [10, 20, 50], [1, 10, 1]) 50 >>> maximize_coins(3, 3, [30, 40, 50], [3, 2, 1]) 120 >>> maximize_coins(5, 0, [10, 20, 30, 40, 50], [5, 10, 15, 20, 25]) 0","solution":"def maximize_coins(n, k, coins, difficulty): # Create a list of tuples where each tuple is (coins, difficulty, ratio) chests = [(coins[i], difficulty[i], coins[i] / difficulty[i]) for i in range(n)] # Sort chests by ratio in descending order, if ratios are the same sort by coins in descending order chests.sort(key=lambda x: (-x[2], -x[0])) # Take the top k chests by this sort order selected_chests = chests[:k] # Sum up the coins from the selected chests max_coins = sum(chest[0] for chest in selected_chests) return max_coins # Example usage (This would be replaced by the testing framework in practice) # print(maximize_coins(5, 2, [10, 20, 30, 40, 50], [5, 10, 15, 20, 25])) # Output should be 90"},{"question":"def count_ways_to_tile(n: int) -> int: Calculate the number of distinct ways to tile a n x 2 grid with dominoes. >>> count_ways_to_tile(1) 1 >>> count_ways_to_tile(2) 2 >>> count_ways_to_tile(3) 3 >>> count_ways_to_tile(4) 5","solution":"def count_ways_to_tile(n): MOD = 10**9 + 7 if n == 0: return 1 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): dp[i] = (dp[i - 1] + dp[i - 2]) % MOD return dp[n]"},{"question":"class TrieNode: A node in the Trie structure. Each node represents a single character in the book title. def __init__(self): self.children = {} self.book_titles = [] self.is_end_of_title = False class DigitalLibrary: A digital library using Trie structure to manage book titles and search operations. def __init__(self): self.root = TrieNode() def addBook(self, title): Add a book title to the digital library. :param title: A string representing the book title. pass def searchBooks(self, query): Search for book titles starting with the given query. :param query: A string representing the search query. :return: A string containing all matching book titles separated by newlines, or \\"No matches found\\". pass # Test cases to verify the functionality of the DigitalLibrary class if __name__ == \\"__main__\\": import pytest def test_add_and_search_single_book(): library = DigitalLibrary() library.addBook(\\"The Great Gatsby\\") result = library.searchBooks(\\"The Great\\") assert result == \\"The Great Gatsby\\" def test_add_multiple_and_search(): library = DigitalLibrary() library.addBook(\\"The Great Gatsby\\") library.addBook(\\"The Grapes of Wrath\\") result = library.searchBooks(\\"The Gr\\") assert result == \\"The Great GatsbynThe Grapes of Wrath\\" def test_search_no_match(): library = DigitalLibrary() library.addBook(\\"The Great Gatsby\\") result = library.searchBooks(\\"Unknown\\") assert result == \\"No matches found\\" def test_search_partial_matches(): library = DigitalLibrary() library.addBook(\\"The Great Gatsby\\") library.addBook(\\"A Brief History of Time\\") result = library.searchBooks(\\"A \\") assert result == \\"A Brief History of Time\\" def test_search_empty_trie(): library = DigitalLibrary() result = library.searchBooks(\\"Some query\\") assert result == \\"No matches found\\" def test_search_case_sensitive(): library = DigitalLibrary() library.addBook(\\"The Great Gatsby\\") result = library.searchBooks(\\"the\\") assert result == \\"No matches found\\"","solution":"class TrieNode: def __init__(self): self.children = {} self.book_titles = [] self.is_end_of_title = False class DigitalLibrary: def __init__(self): self.root = TrieNode() def addBook(self, title): node = self.root for char in title: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.book_titles.append(title) node.is_end_of_title = True def searchBooks(self, query): node = self.root for char in query: if char not in node.children: return \\"No matches found\\" node = node.children[char] return \\"n\\".join(node.book_titles) if node.book_titles else \\"No matches found\\" # Testing the implementation if __name__ == \\"__main__\\": library = DigitalLibrary() books = [ \\"The Great Gatsby\\", \\"The Grapes of Wrath\\", \\"The Art of War\\", \\"A Brief History of Time\\", \\"A Game of Thrones\\" ] for book in books: library.addBook(book) queries = [ \\"The Gr\\", \\"A \\", \\"Thr\\" ] for query in queries: print(library.searchBooks(query)) print() # To match the format in the example"},{"question":"def min_operations_to_equalize_array(n: int, a: List[int]) -> int: Determine the minimum number of operations needed to make all elements of the array equal. :param n: An integer, the number of elements in the array. :param a: A list of integers, the elements of the array. :return: An integer, the minimum number of operations needed. >>> min_operations_to_equalize_array(3, [3, 1, 2]) 2 >>> min_operations_to_equalize_array(5, [7, 7, 7, 7, 7]) 0 >>> min_operations_to_equalize_array(4, [1, 2, 3, 4]) 3 >>> min_operations_to_equalize_array(6, [1, 1, 2, 2, 3, 4]) 4 >>> min_operations_to_equalize_array(1, [5]) 0 >>> min_operations_to_equalize_array(5, [1000000000, 1000000000, 999999999, 999999999, 999999999]) 2","solution":"def min_operations_to_equalize_array(n, a): from collections import Counter # Calculate the frequency of each number in the array counter = Counter(a) # The minimum number of operations required to make all elements equal # is the total number of elements minus the frequency of the most common element max_frequency = max(counter.values()) return n - max_frequency"},{"question":"def count_subgrids_with_k_plants(n: int, m: int, K: int, grid: List[List[int]]) -> int: Sam wants to select a subgrid that contains exactly K plants. >>> count_subgrids_with_k_plants(3, 4, 2, [ ... [1, 0, 0, 1], ... [0, 1, 0, 1], ... [1, 0, 1, 0] ... ]) 15 >>> count_subgrids_with_k_plants(2, 2, 0, [ ... [0, 0], ... [0, 0] ... ]) 9 >>> count_subgrids_with_k_plants(2, 2, 2, [ ... [1, 1], ... [1, 1] ... ]) 4 >>> count_subgrids_with_k_plants(3, 3, 100, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> count_subgrids_with_k_plants(1, 1, 1, [ ... [1] ... ]) 1 >>> count_subgrids_with_k_plants(1, 1, 0, [ ... [0] ... ]) 1","solution":"def count_subgrids_with_k_plants(n, m, K, grid): def subgrid_sum(x1, y1, x2, y2): sum_val = prefix_sum[x2][y2] if x1 > 0: sum_val -= prefix_sum[x1-1][y2] if y1 > 0: sum_val -= prefix_sum[x2][y1-1] if x1 > 0 and y1 > 0: sum_val += prefix_sum[x1-1][y1-1] return sum_val # Create the prefix sum array prefix_sum = [[0]*m for _ in range(n)] prefix_sum[0][0] = grid[0][0] for i in range(1, n): prefix_sum[i][0] = prefix_sum[i-1][0] + grid[i][0] for j in range(1, m): prefix_sum[0][j] = prefix_sum[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): prefix_sum[i][j] = grid[i][j] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] count = 0 for x1 in range(n): for y1 in range(m): for x2 in range(x1, n): for y2 in range(y1, m): if subgrid_sum(x1, y1, x2, y2) == K: count += 1 return count"},{"question":"from typing import List def min_mushrooms_to_collect(n: int, weights: List[int], max_collect: List[int], W: int) -> int: Determines the minimum number of mushrooms required to collect exactly W grams in total or returns -1 if it is not possible. :param n: The number of mushroom species. :param weights: A list of weights of each mushroom species in grams. :param max_collect: A list indicating the maximum grams of each species that can be collected. :param W: The exact total weight Vasya wants to collect in grams. :return: The minimum number of mushrooms required to collect exactly W grams, or -1 if it's not possible. >>> min_mushrooms_to_collect(3, [10, 20, 30], [40, 100, 30], 70) 3 >>> min_mushrooms_to_collect(2, [5, 10], [5, 5], 100) -1 >>> min_mushrooms_to_collect(1, [10], [100], 50) 5 >>> min_mushrooms_to_collect(1, [10], [20], 30) -1 >>> min_mushrooms_to_collect(3, [10, 15, 20], [30, 45, 60], 35) 2 >>> min_mushrooms_to_collect(2, [10, 15], [30, 45], 30) 2","solution":"def min_mushrooms_to_collect(n, weights, max_collect, W): Determines the minimum number of mushrooms required to collect exactly W grams in total or returns -1 if it is not possible. # Initialize dp array where dp[j] will be the minimum number of mushrooms needed to collect j grams dp = [float('inf')] * (W + 1) dp[0] = 0 # for 0 grams, we need 0 mushrooms for i in range(n): w = weights[i] # weight of current species c = max_collect[i] // w # max number of mushrooms we can collect for this species for _ in range(c): for j in range(W, w - 1, -1): if dp[j - w] != float('inf'): dp[j] = min(dp[j], dp[j - w] + 1) return dp[W] if dp[W] != float('inf') else -1"},{"question":"import heapq from collections import defaultdict def minimum_latency(n: int, connections: List[Tuple[int, int, int]]) -> int: Calculate the minimum latency required to send information from the data center (node 1) to all other nodes in the network. Parameters: n (int): the number of nodes in the tree connections (List[Tuple[int, int, int]]): each tuple represents a connection between nodes u and v with a latency time of w Returns: int: the sum of the minimum latencies required to send information to all other nodes Example: >>> minimum_latency(4, [(1, 2, 4), (1, 3, 5), (1, 4, 6)]) 15 >>> minimum_latency(3, [(1, 2, 1), (1, 3, 3)]) 4","solution":"import heapq from collections import defaultdict def minimum_latency(n, connections): # create a graph as adjacency list graph = defaultdict(list) for u, v, w in connections: graph[u].append((v, w)) graph[v].append((u, w)) # the priority queue to handle the edges min_heap = [(0, 1)] # (cost, node) total_latency = 0 visited = set() while min_heap: current_latency, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) total_latency += current_latency for v, w in graph[u]: if v not in visited: heapq.heappush(min_heap, (w, v)) return total_latency"},{"question":"from typing import List def longest_increasing_subsequence(tasks: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. Arguments: tasks: List of integers representing the difficulty levels of the tasks. Returns: The length of the longest strictly increasing subsequence. Example: >>> longest_increasing_subsequence([10, 20, 10, 30, 20, 50]) 4 >>> longest_increasing_subsequence([5]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([3, 4, 1, 5, 2, 6]) 4 >>> longest_increasing_subsequence([10, 5, 6, 2, 3, 8, 1]) 3 >>> longest_increasing_subsequence([]) 0","solution":"from bisect import bisect_left def longest_increasing_subsequence(tasks): Returns the length of the longest strictly increasing subsequence. if not tasks: return 0 subsequence = [] for task in tasks: pos = bisect_left(subsequence, task) if pos >= len(subsequence): subsequence.append(task) else: subsequence[pos] = task return len(subsequence)"},{"question":"from typing import List, Tuple def minimum_distinct_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of distinct elements in the sequence after performing the gcd operation any number of times. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing n (number of elements) and a list of integers. Returns: List[int]: The minimum number of distinct elements for each test case. >>> minimum_distinct_elements(1, [(3, [8, 12, 16])]) [1] >>> minimum_distinct_elements(2, [(3, [15, 25, 35]), (4, [12, 15, 21, 30])]) [1, 1] >>> minimum_distinct_elements(1, [(4, [7, 7, 7, 7])]) [1] >>> minimum_distinct_elements(1, [(3, [5, 7, 11])]) [1] >>> minimum_distinct_elements(1, [(3, [1000000, 999999, 999998])]) [1]","solution":"from math import gcd from functools import reduce def minimum_distinct_elements(t, test_cases): def find_final_gcd(numbers): return reduce(gcd, numbers) results = [] for i in range(t): n, a = test_cases[i] final_gcd = find_final_gcd(a) results.append(1) # Only one distinct element (the GCD) return results"},{"question":"def cookie_statistics(n: int, cookies: List[int]) -> Tuple[int, int]: Returns the total number of cookies baked and the maximum number of cookies baked by any single family member. :param n: Number of family members :param cookies: List of integers representing cookies baked by each family member :return: A tuple (total_cookies, max_cookies) pass # Unit tests def test_example_case(): assert cookie_statistics(5, [10, 20, 15, 30, 25]) == (100, 30) def test_minimum_case(): assert cookie_statistics(1, [100]) == (100, 100) def test_all_same_number(): assert cookie_statistics(3, [10, 10, 10]) == (30, 10) def test_different_numbers(): assert cookie_statistics(4, [1, 2, 3, 4]) == (10, 4) def test_large_numbers(): assert cookie_statistics(3, [1000, 2000, 3000]) == (6000, 3000)","solution":"def cookie_statistics(n, cookies): Returns the total number of cookies baked and the maximum number of cookies baked by any single family member. :param n: Number of family members :param cookies: List of integers representing cookies baked by each family member :return: A tuple (total_cookies, max_cookies) total_cookies = sum(cookies) max_cookies = max(cookies) return total_cookies, max_cookies # Example usage: # n = 5 # cookies = [10, 20, 15, 30, 25] # print(cookie_statistics(n, cookies)) # Output: (100, 30)"},{"question":"def max_gems(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the maximum number of gems that can be collected in a single session for each test case. :param t: The number of test cases. :param test_cases: A list of tuples where each tuple contains the length of the wall and the wall string. :return: A list of integers representing the maximum number of gems collectable for each test case. >>> max_gems(1, [(8, 'GGGEGEGG')]) [3] >>> max_gems(4, [(8, 'GGGEGEGG'), (5, 'EEEEG'), (7, 'GEGEGEG'), (10, 'GGGGGGGGGG')]) [3, 1, 1, 10]","solution":"def max_gems(t, test_cases): results = [] for i in range(t): n, wall = test_cases[i] max_gems = 0 current_gems = 0 for section in wall: if section == 'G': current_gems += 1 max_gems = max(max_gems, current_gems) else: current_gems = 0 results.append(max_gems) return results"},{"question":"def max_score_path(m: int, n: int, grid: List[List[int]]) -> int: Compute the maximum score a contestant can achieve by moving from the top-left to the bottom-right of the grid. >>> max_score_path(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 12 >>> max_score_path(1, 4, [ [1, 2, 3, 4] ]) 10 >>> max_score_path(4, 1, [ [1], [2], [3], [4] ]) 10 >>> max_score_path(2, 2, [ [-1, -2], [-3, -4] ]) -7","solution":"def max_score_path(m, n, grid): # Create a dp table with the same dimensions as the grid dp = [[0 for _ in range(n)] for _ in range(m)] # Initialize the starting position dp[0][0] = grid[0][0] # Fill the first row of the dp table for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column of the dp table for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum score return dp[m-1][n-1]"},{"question":"from typing import List, Tuple def min_ticket_cost(t: int, test_cases: List[dict]) -> List[int]: For each test case, find out the minimum total cost for Alice to buy tickets for all her friends if it's possible to buy them at all. :param t: Number of test cases :param test_cases: List of test case dictionaries. Each dictionary contains: - 'n': Number of vendors - 'k': Number of friends - 'vendors': List of tuples. Each tuple contains: - price per ticket - number of tickets available with the vendor :return: List of minimum total costs for each test case. If it is not possible to buy tickets for all friends from any vendor, the value should be -1. pass from solution import min_ticket_cost def test_min_ticket_cost(): t = 2 test_cases = [ { 'n': 3, 'k': 5, 'vendors': [(20, 10), (15, 3), (25, 6)] }, { 'n': 2, 'k': 8, 'vendors': [(30, 7), (50, 9)] } ] assert min_ticket_cost(t, test_cases) == [100, 400] def test_min_ticket_cost_unavailable(): t = 1 test_cases = [ { 'n': 2, 'k': 10, 'vendors': [(20, 5), (30, 9)] } ] assert min_ticket_cost(t, test_cases) == [-1] def test_min_ticket_cost_single_vendor_enough_tickets(): t = 1 test_cases = [ { 'n': 1, 'k': 5, 'vendors': [(15, 6)] } ] assert min_ticket_cost(t, test_cases) == [75] def test_min_ticket_cost_multiple_vendors_multiple_prices(): t = 1 test_cases = [ { 'n': 4, 'k': 10, 'vendors': [(100, 12), (90, 10), (110, 14), (85, 8)] } ] assert min_ticket_cost(t, test_cases) == [900] def test_min_ticket_cost_tightly_enough_tickets(): t = 1 test_cases = [ { 'n': 3, 'k': 6, 'vendors': [(50, 6), (51, 6), (52, 6)] } ] assert min_ticket_cost(t, test_cases) == [300]","solution":"def min_ticket_cost(t, test_cases): results = [] for case in test_cases: n, k = case['n'], case['k'] vendors = case['vendors'] min_cost = float('inf') possible = False for price, available in vendors: if available >= k: min_cost = min(min_cost, price * k) possible = True if possible: results.append(min_cost) else: results.append(-1) return results"},{"question":"from typing import List def digit_sum(n: int) -> int: Calculate the sum of the digits of a number. >>> digit_sum(123) == 6 >>> digit_sum(10) == 1 >>> digit_sum(999) == 27 >>> digit_sum(0) == 0 def transform_to_equal(arr: List[int]) -> int: Transforms the array into another array where each number is replaced by the sum of its digits. Returns the minimum number of operations required to make all elements in the array equal. >>> transform_to_equal([123]) == 1 >>> transform_to_equal([9, 9, 9, 9]) == 0 >>> transform_to_equal([99, 18]) == 2 >>> transform_to_equal([999, 18, 27]) == 2 >>> transform_to_equal([123456789012]) == 3","solution":"def digit_sum(n): Calculate the sum of the digits of a number. return sum(int(d) for d in str(n)) def transform_to_equal(arr): Transforms the array into another array where each number is replaced by the sum of its digits. Returns the minimum number of operations required to make all elements in the array equal. def reduce_to_single_digit(n): Reduces a number to a single digit by repeatedly summing its digits. Returns the number of operations needed to reduce the number to a single digit. count = 0 while n >= 10: n = digit_sum(n) count += 1 return count # Find the maximum operations needed for any number to become a single digit max_operations = 0 for num in arr: max_operations = max(max_operations, reduce_to_single_digit(num)) return max_operations"},{"question":"def longest_contiguous_subsequence(n: int, grid: List[str]) -> int: Find the length of the longest contiguous subsequence of matching labels that form a horizontal, vertical, or diagonal path in an n x n grid. >>> longest_contiguous_subsequence(3, [\\"aba\\", \\"bcb\\", \\"cbc\\"]) 2 >>> longest_contiguous_subsequence(3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 3 >>> longest_contiguous_subsequence(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> longest_contiguous_subsequence(3, [\\"aba\\", \\"bcb\\", \\"cbc\\"]) 2 >>> longest_contiguous_subsequence(3, [\\"abc\\", \\"bbc\\", \\"ccc\\"]) 3 >>> longest_contiguous_subsequence(4, [\\"aaab\\", \\"abaa\\", \\"baaa\\", \\"caaa\\"]) 4","solution":"def longest_contiguous_subsequence(n, grid): def check_horizontal(i, j): length = 1 while j + 1 < n and grid[i][j] == grid[i][j + 1]: j += 1 length += 1 return length def check_vertical(i, j): length = 1 while i + 1 < n and grid[i][j] == grid[i + 1][j]: i += 1 length += 1 return length def check_diagonal_dr(i, j): length = 1 while i + 1 < n and j + 1 < n and grid[i][j] == grid[i + 1][j + 1]: i += 1 j += 1 length += 1 return length def check_diagonal_dl(i, j): length = 1 while i + 1 < n and j - 1 >= 0 and grid[i][j] == grid[i + 1][j - 1]: i += 1 j -= 1 length += 1 return length max_length = 1 for i in range(n): for j in range(n): max_length = max(max_length, check_horizontal(i, j)) max_length = max(max_length, check_vertical(i, j)) max_length = max(max_length, check_diagonal_dr(i, j)) max_length = max(max_length, check_diagonal_dl(i, j)) return max_length"},{"question":"def connected_components_count(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with n nodes and m edges, determine the number of connected components in the graph. >>> connected_components_count(1, 0, []) 1 >>> connected_components_count(2, 0, []) 2 >>> connected_components_count(2, 1, [(1, 2)]) 1 >>> connected_components_count(5, 0, []) 5 >>> connected_components_count(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> connected_components_count(5, 2, [(1, 2), (3, 4)]) 3 >>> connected_components_count(6, 4, [(1, 2), (1, 3), (4, 5), (6, 6)]) 3","solution":"def connected_components_count(n, m, edges): from collections import defaultdict def dfs(node, visited, adj_list): stack = [node] while stack: curr = stack.pop() for neighbor in adj_list[curr]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = set() count = 0 for node in range(1, n+1): if node not in visited: count += 1 visited.add(node) dfs(node, visited, adj_list) return count"},{"question":"from typing import List def can_reach_destination(n: int, m: int, k: int, grid: List[List[int]]) -> str: Determine if it is possible for the player to travel from the top-left corner to the bottom-right corner of the grid given the power level difference k. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. k (int): Maximum allowed power level difference. grid (List[List[int]]): The 2D grid representing the power levels. Returns: str: \\"YES\\" if it is possible to reach the destination, otherwise \\"NO\\". >>> can_reach_destination(3, 4, 2, [ ... [1, 2, 3, 4], ... [4, 1, 5, 7], ... [3, 2, 1, 6] ... ]) \\"YES\\" >>> can_reach_destination(3, 3, 1, [ ... [1, 3, 5], ... [6, 4, 2], ... [7, 8, 9] ... ]) \\"NO\\" pass def test_can_reach_destination(): assert can_reach_destination(3, 4, 2, [ [1, 2, 3, 4], [4, 1, 5, 7], [3, 2, 1, 6] ]) == \\"YES\\" assert can_reach_destination(3, 3, 1, [ [1, 3, 5], [6, 4, 2], [7, 8, 9] ]) == \\"NO\\" assert can_reach_destination(2, 2, 1000, [ [1, 1000], [1000, 1] ]) == \\"YES\\" assert can_reach_destination(2, 2, 0, [ [1, 1], [2, 2] ]) == \\"NO\\" assert can_reach_destination(3, 3, 5, [ [1, 6, 1], [6, 1, 3], [6, 1, 1] ]) == \\"YES\\" import pytest pytest.main()","solution":"def can_reach_destination(n, m, k, grid): from collections import deque # Directions for moving in the grid (right, left, down, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS setup queue = deque([(0, 0)]) visited = set((0, 0)) def is_valid(x, y, nx, ny): if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if abs(grid[x][y] - grid[nx][ny]) <= k: return True return False while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(x, y, nx, ny): visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def max_green_duration(T: int, n: int, G: List[int]) -> int: Returns the maximum possible total duration the light can stay green after swapping any two elements of the array. Arguments: T -- total duration for the traffic light pattern in minutes. n -- the number of green light segments. G -- list of integers where each represents the duration of green light segments. >>> max_green_duration(20, 4, [5, 3, 8, 4]) 20 >>> max_green_duration(10, 1, [5]) 5 >>> max_green_duration(60, 2, [30, 20]) 50 >>> max_green_duration(100000, 5, [100000, 100000, 100000, 100000, 100000]) 500000 >>> max_green_duration(100, 4, [10, 20, 30, 40]) 100 >>> max_green_duration(50, 3, [15, 15, 15]) 45","solution":"def max_green_duration(T, n, G): Returns the maximum possible total duration the light can stay green after swapping any two elements of the array. Arguments: T -- total duration for the traffic light pattern in minutes. n -- the number of green light segments. G -- list of integers where each represents the duration of green light segments. # The maximum duration of green light is simply the sum of all segments return sum(G)"},{"question":"def arrange_books(n: int, books: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Arrange books based on the given criteria. Parameters: n (int): Number of books. books (list of tuple): List of tuples where each tuple contains the title of the book and number of pages. Returns: list of tuple: Arranged list of books. >>> arrange_books(5, [(\\"HarryPotter\\", 300), (\\"LordOfTheRings\\", 500), (\\"HarryPotter\\", 450), (\\"AlicesAdventures\\", 200), (\\"LordOfTheRings\\", 700)]) [(\\"AlicesAdventures\\", 200), (\\"HarryPotter\\", 300), (\\"HarryPotter\\", 450), (\\"LordOfTheRings\\", 500), (\\"LordOfTheRings\\", 700)] >>> arrange_books(4, [(\\"BookA\\", 100), (\\"BookA\\", 50), (\\"BookA\\", 200), (\\"BookB\\", 150)]) [(\\"BookA\\", 50), (\\"BookA\\", 100), (\\"BookA\\", 200), (\\"BookB\\", 150)] >>> arrange_books(1, [(\\"SingleBook\\", 42)]) [(\\"SingleBook\\", 42)] >>> arrange_books(5, [(\\"BookZ\\", 120), (\\"BookY\\", 150), (\\"BookA\\", 50), (\\"BookB\\", 200), (\\"BookA\\", 70)]) [(\\"BookA\\", 50), (\\"BookA\\", 70), (\\"BookB\\", 200), (\\"BookY\\", 150), (\\"BookZ\\", 120)]","solution":"def arrange_books(n, books): Arrange books based on the given criteria. Parameters: n (int): Number of books. books (list of tuple): List of tuples where each tuple contains the title of the book and number of pages. Returns: list of tuple: Arranged list of books. # Sort the list of books by title first (lexicographic order) and then by number of pages (ascending order) books.sort(key=lambda book: (book[0], book[1])) return books"},{"question":"import heapq from typing import List class MedianFinder: def __init__(self): self.small = [] # max heap self.large = [] # min heap def add_num(self, num: int): heapq.heappush(self.small, -num) heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) < len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0 def find_running_medians(scores: List[int]) -> List[float]: Find the running medians after each addition of a new score to the list. Args: scores (List[int]): List of student scores. Returns: List[float]: List of medians after each score is added. Examples: >>> find_running_medians([1, 3, 4, 2, 5]) [1, 2, 3, 3, 3] >>> find_running_medians([6]) [6] >>> find_running_medians([7, 8]) [7, 7.5] >>> find_running_medians([2, 2, 2, 2]) [2, 2, 2, 2] >>> find_running_medians([4, 1, 7, 5]) [4, 2.5, 4, 4.5] >>> find_running_medians([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] median_finder = MedianFinder() medians = [] for score in scores: median_finder.add_num(score) medians.append(median_finder.find_median()) return medians","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # max heap self.large = [] # min heap def add_num(self, num: int): heapq.heappush(self.small, -num) heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) < len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) def find_median(self) -> float: if len(self.small) > len(self.large): return -self.small[0] else: return (-self.small[0] + self.large[0]) / 2.0 def find_running_medians(scores): median_finder = MedianFinder() medians = [] for score in scores: median_finder.add_num(score) medians.append(median_finder.find_median()) return medians"},{"question":"def find_min_clusters(n: int, m: int, K: int, roads: List[Tuple[int, int, int]]) -> int: Determines the minimum number of clusters needed to partition the warehouse network so that no cluster has an internal transportation cost exceeding the given threshold K. Parameters: n (int): Number of warehouses. m (int): Number of roads. K (int): Cost threshold. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers, u_i (start warehouse), v_i (end warehouse), and c_i (transportation cost). Returns: int: Minimum number of clusters needed or -1 if it is not possible to partition the network with the given conditions. Example: >>> find_min_clusters(5, 6, 10, [(1, 2, 5), (2, 3, 4), (3, 4, 8), (4, 5, 2), (2, 5, 9), (1, 5, 14)]) 1 >>> find_min_clusters(3, 0, 10, []) 3 >>> find_min_clusters(4, 3, 2, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 4 >>> find_min_clusters(4, 3, 0, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) 4 >>> find_min_clusters(7, 6, 3, [(1, 2, 3), (2, 3, 3), (4, 5, 2), (6, 7, 1), (3, 4, 5), (5, 6, 6)]) 3","solution":"def find_min_clusters(n, m, K, roads): def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 if K == 0: return n roads = [(u - 1, v - 1, c) for u, v, c in roads] parent = [i for i in range(n)] rank = [0] * n roads.sort(key=lambda x: x[2]) components = n for u, v, c in roads: if c > K: break x = find_parent(parent, u) y = find_parent(parent, v) if x != y: union(parent, rank, x, y) components -= 1 return components"},{"question":"def are_sequences_equivalent(n, seq1, seq2): Determines if two sequences are equivalent based on the rule that two sequences are equivalent if one sequence can be rearranged to match the other sequence. Args: n (int): The length of both sequences. seq1 (list of int): The first sequence of integers. seq2 (list of int): The second sequence of integers. Returns: str: \\"YES\\" if the sequences are equivalent, \\"NO\\" otherwise. >>> are_sequences_equivalent(3, [1, 2, 3], [3, 1, 2]) 'YES' >>> are_sequences_equivalent(4, [1, 2, 2, 3], [2, 3, 1, 2]) 'YES' >>> are_sequences_equivalent(5, [1, 2, 3, 4, 5], [1, 2, 3, 5, 5]) 'NO' pass def process_test_cases(T, test_cases): Processes multiple test cases and determines if the sequences in each test case are equivalent. Args: T (int): The number of test cases. test_cases (list of dict): A list of test case dictionaries, where each dictionary contains: - 'n' (int): The length of the sequences. - 'seq1' (list of int): The first sequence of integers. - 'seq2' (list of int): The second sequence of integers. Returns: list of str: A list of results for each test case, either \\"YES\\" or \\"NO\\". >>> T = 3 >>> test_cases = [{'n': 3, 'seq1': [1, 2, 3], 'seq2': [3, 1, 2]}, {'n': 4, 'seq1': [1, 2, 2, 3], 'seq2': [2, 3, 1, 2]}, {'n': 5, 'seq1': [1, 2, 3, 4, 5], 'seq2': [1, 2, 3, 5, 5]}] >>> process_test_cases(T, test_cases) ['YES', 'YES', 'NO'] pass # Test cases def test_are_sequences_equivalent(): assert are_sequences_equivalent(3, [1, 2, 3], [3, 1, 2]) == \\"YES\\" assert are_sequences_equivalent(4, [1, 2, 2, 3], [2, 3, 1, 2]) == \\"YES\\" assert are_sequences_equivalent(5, [1, 2, 3, 4, 5], [1, 2, 3, 5, 5]) == \\"NO\\" assert are_sequences_equivalent(3, [4, 5, 6], [4, 5, 6]) == \\"YES\\" assert are_sequences_equivalent(3, [4, 5, 7], [4, 5, 6]) == \\"NO\\" def test_process_test_cases(): T = 3 test_cases = [ {'n': 3, 'seq1': [1, 2, 3], 'seq2': [3, 1, 2]}, {'n': 4, 'seq1': [1, 2, 2, 3], 'seq2': [2, 3, 1, 2]}, {'n': 5, 'seq1': [1, 2, 3, 4, 5], 'seq2': [1, 2, 3, 5, 5]} ] assert process_test_cases(T, test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] T = 2 test_cases = [ {'n': 3, 'seq1': [4, 5, 6], 'seq2': [4, 5, 6]}, {'n': 3, 'seq1': [4, 5, 7], 'seq2': [4, 5, 6]} ] assert process_test_cases(T, test_cases) == [\\"YES\\", \\"NO\\"]","solution":"def are_sequences_equivalent(n, seq1, seq2): Returns \\"YES\\" if the two sequences are equivalent (can be rearranged to match each other), \\"NO\\" otherwise. return \\"YES\\" if sorted(seq1) == sorted(seq2) else \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): n = test_cases[i]['n'] seq1 = test_cases[i]['seq1'] seq2 = test_cases[i]['seq2'] results.append(are_sequences_equivalent(n, seq1, seq2)) return results"},{"question":"def longest_palindromic_subsequence(arr: List[int]) -> int: Returns the length of the longest palindromic subsequence in the array. >>> longest_palindromic_subsequence([1, 2, 3, 4, 2, 1]) 5 >>> longest_palindromic_subsequence([2, 2, 2, 2, 2]) 5 >>> longest_palindromic_subsequence([1, 2, 3, 4, 5]) 1 >>> longest_palindromic_subsequence([3, 1, 4, 1, 5, 9, 5]) 3 >>> longest_palindromic_subsequence([7]) 1 >>> longest_palindromic_subsequence([1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence([1, 2]) 1","solution":"def longest_palindromic_subsequence(arr): Returns the length of the longest palindromic subsequence in the array. n = len(arr) dp = [[0] * n for _ in range(n)] # Each single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if arr[i] == arr[j] and cl == 2: dp[i][j] = 2 elif arr[i] == arr[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The result is in dp[0][n-1] return dp[0][n-1]"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Function to find the longest palindromic subsequence in a given string. >>> longest_palindromic_subsequence(\\"AGBDBA\\") 5 >>> longest_palindromic_subsequence(\\"BBABCBCAB\\") 7 >>> longest_palindromic_subsequence(\\"GEEKSFORGEEKS\\") 5 >>> longest_palindromic_subsequence(\\"A\\") 1 >>> longest_palindromic_subsequence(\\"AB\\") 1 pass def process_test_cases(test_cases: List[str]) -> List[int]: Function to process multiple test cases. >>> process_test_cases([\\"AGBDBA\\", \\"BBABCBCAB\\", \\"GEEKSFORGEEKS\\"]) [5, 7, 5] >>> process_test_cases([\\"A\\", \\"BB\\", \\"ABCD\\"]) [1, 2, 1] pass","solution":"def longest_palindromic_subsequence(s): Function to find the longest palindromic subsequence in a given string. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] def process_test_cases(test_cases): results = [] for s in test_cases: result = longest_palindromic_subsequence(s) results.append(result) return results"},{"question":"def transform_sequence(n: int, m: int, sequence: List[int]) -> List[int]: Determine the resulting sequence after m toggles. Each toggle transforms the sequence by replacing each number at position i with the sum of the numbers at positions i and i+1. If i is the last position, it sums the number at the last and the first position. >>> transform_sequence(4, 1, [1, 2, 3, 4]) [3, 5, 7, 5] >>> transform_sequence(4, 2, [1, 2, 3, 4]) [8, 12, 12, 8] >>> transform_sequence(4, 0, [1, 2, 3, 4]) [1, 2, 3, 4] >>> transform_sequence(5, 1, [1, 1, 1, 1, 1]) [2, 2, 2, 2, 2] >>> transform_sequence(5, 2, [1, 1, 1, 1, 1]) [4, 4, 4, 4, 4] >>> transform_sequence(1, 1, [10]) [20] >>> transform_sequence(1, 3, [10]) [80]","solution":"def transform_sequence(n, m, sequence): for _ in range(m): new_sequence = [ sequence[i] + sequence[(i + 1) % n] for i in range(n) ] sequence = new_sequence return sequence"},{"question":"from typing import List def desert_terraforming(n: int, m: int, operations: List[str]) -> List[int]: Simulate terrain manipulation in a desert. Each cell in the grid can either be dry (represented by 0) or irrigated (represented by 1). Scientists perform operations to add water or check if a subgrid contains water. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. operations (List[str]): List of operations to perform. Returns: List[int]: Results of \\"CHECK\\" operations in the order they appear. Example: >>> desert_terraforming(5, 5, [\\"ADD 3 3\\", \\"CHECK 2 2 4 4\\", \\"ADD 5 5\\", \\"CHECK 4 4 5 5\\", \\"CHECK 1 1 2 2\\", \\"ADD 2 2\\", \\"CHECK 2 2 2 2\\"]) [1, 1, 0, 1] pass def test_case_1(): n, m = 5, 5 operations = [ \\"ADD 3 3\\", \\"CHECK 2 2 4 4\\", \\"ADD 5 5\\", \\"CHECK 4 4 5 5\\", \\"CHECK 1 1 2 2\\", \\"ADD 2 2\\", \\"CHECK 2 2 2 2\\" ] expected = [1, 1, 0, 1] assert desert_terraforming(n, m, operations) == expected def test_case_2(): n, m = 3, 3 operations = [ \\"ADD 1 1\\", \\"ADD 2 2\\", \\"ADD 3 3\\", \\"CHECK 1 1 3 3\\", \\"CHECK 1 2 3 3\\", \\"CHECK 1 1 1 1\\", \\"CHECK 3 3 3 3\\", \\"CHECK 2 2 2 2\\" ] expected = [1, 1, 1, 1, 1] assert desert_terraforming(n, m, operations) == expected def test_case_3(): n, m = 2, 2 operations = [ \\"CHECK 1 1 2 2\\", \\"ADD 1 2\\", \\"CHECK 1 1 2 2\\", \\"ADD 2 1\\", \\"CHECK 2 1 2 2\\" ] expected = [0, 1, 1] assert desert_terraforming(n, m, operations) == expected def test_case_4(): n, m = 4, 4 operations = [ \\"ADD 4 4\\", \\"CHECK 1 1 4 4\\", \\"CHECK 3 3 4 4\\", \\"CHECK 1 1 3 3\\", \\"ADD 3 3\\" ] expected = [1, 1, 0] assert desert_terraforming(n, m, operations) == expected def test_case_5(): n, m = 1, 1 operations = [ \\"CHECK 1 1 1 1\\", \\"ADD 1 1\\", \\"CHECK 1 1 1 1\\" ] expected = [0, 1] assert desert_terraforming(n, m, operations) == expected","solution":"def desert_terraforming(n, m, operations): grid = [[0] * m for _ in range(n)] result = [] for op in operations: parts = op.split() if parts[0] == \\"ADD\\": x = int(parts[1]) - 1 y = int(parts[2]) - 1 grid[x][y] = 1 elif parts[0] == \\"CHECK\\": x1 = int(parts[1]) - 1 y1 = int(parts[2]) - 1 x2 = int(parts[3]) - 1 y2 = int(parts[4]) - 1 found_water = False for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): if grid[i][j] == 1: found_water = True break if found_water: break result.append(1 if found_water else 0) return result"},{"question":"def shortest_distances(n: int, k: int, packages: List[Tuple[int, int, int, int]]) -> List[int]: Finds the shortest distance between the start and destination for each package. Args: n: int - the size of the grid (n x n). k: int - the number of packages. packages: list of tuples - each tuple contains (x1, y1, x2, y2) which represent the start and destination coordinates. Returns: list of int - the shortest distances for each package. >>> shortest_distances(5, 3, [(1, 1, 5, 5), (2, 2, 3, 3), (4, 4, 1, 1)]) [8, 2, 6] >>> shortest_distances(2, 2, [(1, 1, 2, 2), (2, 2, 1, 1)]) [2, 2] >>> shortest_distances(10, 1, [(5, 5, 5, 5)]) [0] >>> shortest_distances(1000, 2, [(1, 1, 1000, 1000), (500, 500, 1000, 1000)]) [1998, 1000] >>> shortest_distances(3, 3, [(1, 1, 1, 2), (2, 2, 2, 1), (3, 3, 2, 3)]) [1, 1, 1] >>> shortest_distances(4, 5, [(1, 1, 4, 4), (4, 4, 1, 1), (1, 4, 4, 1), (1, 2, 3, 3), (2, 1, 4, 2)]) [6, 6, 6, 3, 3]","solution":"def shortest_distances(n, k, packages): Finds the shortest distance between the start and destination for each package. Args: n: int - the size of the grid (n x n). k: int - the number of packages. packages: list of tuples - each tuple contains (x1, y1, x2, y2) which represent the start and destination coordinates. Returns: list of int - the shortest distances for each package. distances = [] for (x1, y1, x2, y2) in packages: distance = abs(x1 - x2) + abs(y1 - y2) distances.append(distance) return distances"},{"question":"def reorder_even_before_odd(n: int, arr: List[int]) -> List[int]: Reorder the elements of the array such that all the even numbers come before all the odd numbers. Do this operation in-place. >>> reorder_even_before_odd(7, [1, 2, 3, 4, 5, 6, 7]) [2, 4, 6, 1, 3, 5, 7] >>> reorder_even_before_odd(4, [3, 5, 7, 9]) [3, 5, 7, 9] >>> reorder_even_before_odd(5, [2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] pass # Replace with your code def test_reorder_even_before_odd(): # example test case assert reorder_even_before_odd(7, [1, 2, 3, 4, 5, 6, 7])[:3].count(2) + reorder_even_before_odd(7, [1, 2, 3, 4, 5, 6, 7])[:3].count(4) + reorder_even_before_odd(7, [1, 2, 3, 4, 5, 6, 7])[:3].count(6) == 3 # minimal input test case assert reorder_even_before_odd(1, [1]) == [1] assert reorder_even_before_odd(1, [2]) == [2] # all even numbers test case assert reorder_even_before_odd(4, [2, 4, 6, 8]) == [2, 4, 6, 8] # all odd numbers test case assert reorder_even_before_odd(3, [3, 5, 7]) == [3, 5, 7] # interleaved even and odd numbers result = reorder_even_before_odd(5, [1, 2, 3, 4, 5]) assert sorted(result[:2]) == [2, 4] assert sorted(result[2:]) == [1, 3, 5] # reverse ordered even and odd numbers result = reorder_even_before_odd(6, [9, 7, 5, 4, 2, 0]) assert sorted(result[:3]) == [0, 2, 4] assert sorted(result[3:]) == [5, 7, 9] # all numbers are the same assert reorder_even_before_odd(4, [2, 2, 2, 2]) == [2, 2, 2, 2] assert reorder_even_before_odd(3, [1, 1, 1]) == [1, 1, 1] def test_edge_cases(): # no numbers assert reorder_even_before_odd(0, []) == [] # single even and a single odd number assert set(reorder_even_before_odd(2, [2, 1])) == {2, 1} result = reorder_even_before_odd(2, [1, 2]) assert set(result) == {1, 2} assert result.index(2) < result.index(1)","solution":"def reorder_even_before_odd(n, arr): left, right = 0, n - 1 while left < right: if arr[left] % 2 == 0: left += 1 elif arr[right] % 2 == 1: right -= 1 else: arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1 return arr"},{"question":"def sieve(max_num): Create a list to determine prime numbers up to max_num using the Sieve of Eratosthenes. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(max_num**0.5) + 1): if is_prime[start]: for multiple in range(start * start, max_num + 1, start): is_prime[multiple] = False primes = [] for num in range(max_num + 1): if is_prime[num]: primes.append(num) return primes def count_primes_in_range(l, r, primes): Given a range [l, r] and a list of primes, count how many primes are within the range. count = 0 for prime in primes: if prime > r: break if prime >= l: count += 1 return count def find_prime_counts(queries): Find the number of prime numbers between two given integers l and r (inclusive) for multiple queries. Args: queries List[Tuple[int, int]]: A list of queries where each query is a tuple of two integers (l, r) Returns: List[int]: A list of results where each result is the count of prime numbers within the specified range for each query. >>> find_prime_counts([(2, 10), (11, 20), (30, 50)]) [4, 4, 5] >>> find_prime_counts([(1, 2), (1, 1), (1000000, 1000000)]) [1, 0, 0] max_limit = 10**6 primes = sieve(max_limit) results = [] for l, r in queries: results.append(count_primes_in_range(l, r, primes)) return results # Test cases def test_find_prime_counts(): queries = [(2, 10), (11, 20), (30, 50)] result = find_prime_counts(queries) assert result == [4, 4, 5] def test_find_prime_counts_edge_case(): queries = [(1, 2), (1, 1), (10**6, 10**6)] result = find_prime_counts(queries) assert result == [1, 0, 0] def test_find_prime_counts_no_primes(): queries = [(14, 16), (1, 1), (24, 28)] result = find_prime_counts(queries) assert result == [0, 0, 0] def test_find_prime_counts_small_range(): queries = [(5, 5), (8, 8), (7, 11)] result = find_prime_counts(queries) assert result == [1, 0, 2] def test_find_prime_counts_large_range(): queries = [(1, 1000000)] result = find_prime_counts(queries) assert result == [78498] # 78498 is the number of primes <= 10^6","solution":"def sieve(max_num): Create a list to determine prime numbers up to max_num using the Sieve of Eratosthenes. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(max_num**0.5) + 1): if is_prime[start]: for multiple in range(start * start, max_num + 1, start): is_prime[multiple] = False primes = [] for num in range(max_num + 1): if is_prime[num]: primes.append(num) return primes def count_primes_in_range(l, r, primes): Given a range [l, r] and a list of primes, count how many primes are within the range. count = 0 for prime in primes: if prime > r: break if prime >= l: count += 1 return count def find_prime_counts(queries): max_limit = 10**6 primes = sieve(max_limit) results = [] for l, r in queries: results.append(count_primes_in_range(l, r, primes)) return results"},{"question":"def digital_root(num: int) -> int: Returns the single digit result of repeatedly summing the digits of num until a single digit is obtained. >>> digital_root(123) 6 >>> digital_root(9875) 2 >>> digital_root(67) 4 def process_numbers(numbers: List[int]) -> List[int]: Takes a list of numbers and returns a list with the digital roots of each number. >>> process_numbers([123, 9875, 67]) [6, 2, 4]","solution":"def digital_root(num): Returns the single digit result of repeatedly summing the digits of num until a single digit is obtained. while num >= 10: num = sum(int(digit) for digit in str(num)) return num def process_numbers(numbers): Takes a list of numbers and returns a list with the digital roots of each number. return [digital_root(num) for num in numbers]"},{"question":"def process_input(input_data: str): Determine the final loyalty points for each customer after processing a series of transactions. >>> input_data = \\"2nAlice 3nearn 10nlose 5nearn 5nBob 2nearn 20nlose 25\\" >>> process_input(input_data) ['Alice 10', 'Bob 0'] >>> input_data = \\"1nAlice 0\\" >>> process_input(input_data) ['Alice 0'] >>> input_data = \\"1nAlice 2nearn 10nearn 20\\" >>> process_input(input_data) ['Alice 30'] >>> input_data = \\"1nAlice 2nlose 10nlose 5\\" >>> process_input(input_data) ['Alice 0'] >>> input_data = \\"1nAlice 4nearn 10nlose 5nearn 20nlose 15\\" >>> process_input(input_data) ['Alice 10'] >>> input_data = \\"3nAlice 3nearn 10nlose 5nearn 5nBob 2nearn 20nlose 25nCharlie 1nearn 50\\" >>> process_input(input_data) ['Alice 10', 'Bob 0', 'Charlie 50']","solution":"def calculate_loyalty_points(customers_data): results = [] for customer in customers_data: name, transactions = customer['name'], customer['transactions'] loyalty_points = 0 for transaction in transactions: action, points = transaction.split() points = int(points) if action == \\"earn\\": loyalty_points += points elif action == \\"lose\\": loyalty_points -= points if loyalty_points < 0: loyalty_points = 0 results.append(f\\"{name} {loyalty_points}\\") return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") k = int(lines[0]) index = 1 customers_data = [] for _ in range(k): customer_info = lines[index].split() name = customer_info[0] t = int(customer_info[1]) transactions = lines[index+1:index+1+t] customers_data.append({'name': name, 'transactions': transactions}) index += t + 1 return calculate_loyalty_points(customers_data) # Example Usage: # input_data = 2 # Alice 3 # earn 10 # lose 5 # earn 5 # Bob 2 # earn 20 # lose 25 # result = process_input(input_data) # for line in result: # print(line)"},{"question":"def amusement_park_finish_times(n: int, arrival_times: List[int], durations: List[int]) -> List[int]: Determines the finish time for each person in the queue. Args: n (int): Number of people in the queue. arrival_times (list): List of integers representing arrival times. durations (list): List of integers representing durations of the ride. Returns: list: List of integers representing the finish times for each person. >>> amusement_park_finish_times(1, [0], [5]) [5] >>> amusement_park_finish_times(3, [0, 2, 4], [5, 3, 2]) [5, 8, 10] >>> amusement_park_finish_times(3, [0, 0, 0], [4, 3, 2]) [4, 7, 9] >>> amusement_park_finish_times(5, [0, 1, 2, 2, 4], [3, 2, 1, 2, 3]) [3, 5, 6, 8, 11] >>> amusement_park_finish_times(4, [0, 2, 5, 6], [4, 2, 3, 1]) [4, 6, 9, 10]","solution":"def amusement_park_finish_times(n, arrival_times, durations): Determines the finish time for each person in the queue. Args: n (int): Number of people in the queue. arrival_times (list): List of integers representing arrival times. durations (list): List of integers representing durations of the ride. Returns: list: List of integers representing the finish times for each person. finish_times = [] current_time = 0 for i in range(n): arrival_time = arrival_times[i] duration = durations[i] # The ride starts at the later time of either the current time or person's arrival time start_time = max(current_time, arrival_time) finish_time = start_time + duration # Update current time to the finish time of this person current_time = finish_time finish_times.append(finish_time) return finish_times"},{"question":"def longest_subarray_with_equal_halves(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest contiguous subarray that can be divided into two non-empty parts with equal sums. >>> longest_subarray_with_equal_halves(2, [(6, [2, 3, 4, 1, 5, 6]), (4, [1, 1, 1, 1])]) [4, 4] >>> longest_subarray_with_equal_halves(1, [(1, [1])]) [0] >>> longest_subarray_with_equal_halves(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> longest_subarray_with_equal_halves(1, [(6, [2, 2, 2, 2, 2, 2])]) [6] >>> longest_subarray_with_equal_halves(3, [(5, [1, 2, 2, 1, 2]), (6, [1, 2, 1, 2, 4, 4]), (4, [1, 3, 1, 3])]) [4, 4, 4]","solution":"def longest_subarray_with_equal_halves(t, test_cases): results = [] for case_idx in range(t): n = test_cases[case_idx][0] a = test_cases[case_idx][1] max_len = 0 for i in range(n): for j in range(i + 1, n): subarray = a[i:j+1] sub_len = len(subarray) if sub_len % 2 == 0: mid = sub_len // 2 if sum(subarray[:mid]) == sum(subarray[mid:]): max_len = max(max_len, sub_len) results.append(max_len) return results"},{"question":"def calculate_uniqueness(arr, queries): Calculate uniqueness for segments in an array based on queries. :param arr: List[int] - The input array. :param queries: List[Tuple[int, int]] - List of tuples containing the start and end indices of the segments. :return: List[int] - List of uniqueness values for each query. pass # Your implementation goes here # Unit Test def test_single_element_array(): arr = [1] queries = [(1, 1)] assert calculate_uniqueness(arr, queries) == [1] def test_multiple_identical_elements(): arr = [2, 2, 2, 2] queries = [(1, 4), (1, 2)] assert calculate_uniqueness(arr, queries) == [1, 1] def test_distinct_elements(): arr = [1, 2, 3, 4, 5] queries = [(1, 5), (1, 3), (3, 5)] assert calculate_uniqueness(arr, queries) == [5, 3, 3] def test_some_same_elements(): arr = [1, 2, 1, 3, 2] queries = [(1, 3), (2, 4), (1, 5)] assert calculate_uniqueness(arr, queries) == [2, 3, 3] def test_multiple_queries(): arr = [1, 2, 3, 1, 2, 3, 4, 5] queries = [(1, 8), (3, 6), (4, 7)] assert calculate_uniqueness(arr, queries) == [5, 3, 4]","solution":"def calculate_uniqueness(arr, queries): Calculate uniqueness for segments in an array based on queries. :param arr: List[int] - The input array. :param queries: List[Tuple[int, int]] - List of tuples containing the start and end indices of the segments. :return: List[int] - List of uniqueness values for each query. results = [] for l, r in queries: # Get the segment from the array segment = arr[l-1:r] # Calculate uniqueness by using a set uniqueness = len(set(segment)) results.append(uniqueness) return results"},{"question":"def min_subset_difference(arr: List[int]) -> int: Returns the minimum possible difference between the sums of two subsets. Example usage: >>> min_subset_difference([1, 6, 11, 5]) 1 >>> min_subset_difference([1, 2, 3, 9]) 3 >>> min_subset_difference([1, 2, 5]) 2 >>> min_subset_difference([3, 1, 4, 2, 2]) 0 >>> min_subset_difference([5]) 5 >>> min_subset_difference([0, 0, 0, 0]) 0","solution":"def min_subset_difference(arr): Returns the minimum possible difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) # Initialize a DP table where dp[i] indicates if subset sum i is reachable dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in arr: for s in range(total_sum // 2, num - 1, -1): if dp[s - num]: dp[s] = True # Find the greatest s such that dp[s] is True closest_sum = 0 for s in range(total_sum // 2, -1, -1): if dp[s]: closest_sum = s break return total_sum - 2 * closest_sum # Example usage: # arr = [1, 6, 11, 5] # print(min_subset_difference(arr)) # Output: 1"},{"question":"def handle_queries(n: int, m: int, sequence: List[int], queries: List[List[str]]) -> List[int]: Perform a series of update and range minimum queries on a sequence. Args: n (int): Size of the sequence. m (int): Number of queries. sequence (List[int]): Initial sequence of integers. queries (List[List[str]]): List of queries in the format [\\"1 x y\\"] or [\\"2 l r\\"]. Returns: List[int]: Results of the range minimum queries. Example: >>> handle_queries(5, 3, [1, 5, 2, 4, 3], [[\\"2\\", \\"2\\", \\"4\\"], [\\"1\\", \\"3\\", \\"0\\"], [\\"2\\", \\"2\\", \\"4\\"]]) [2, 0] >>> handle_queries(1, 2, [10], [[\\"2\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"5\\"]]) [10] Unit Tests: >>> def test_handle_queries(): ... n, m = 5, 3 ... sequence = [1, 5, 2, 4, 3] ... queries = [[\\"2\\", \\"2\\", \\"4\\"], [\\"1\\", \\"3\\", \\"0\\"], [\\"2\\", \\"2\\", \\"4\\"]] ... expected_output = [2, 0] ... assert handle_queries(n, m, sequence, queries) == expected_output >>> def test_handle_queries_single_update(): ... n, m = 1, 1 ... sequence = [10] ... queries = [[\\"1\\", \\"1\\", \\"5\\"]] ... expected_output = [] ... assert handle_queries(n, m, sequence, queries) == expected_output >>> def test_handle_queries_single_query(): ... n, m = 1, 2 ... sequence = [10] ... queries = [[\\"2\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"5\\"]] ... expected_output = [10] ... assert handle_queries(n, m, sequence, queries) == expected_output >>> def test_handle_queries_multiple_queries(): ... n, m = 5, 4 ... sequence = [3, 1, 4, 1, 5] ... queries = [[\\"2\\", \\"1\\", \\"3\\"], [\\"1\\", \\"2\\", \\"0\\"], [\\"2\\", \\"1\\", \\"3\\"], [\\"2\\", \\"1\\", \\"5\\"]] ... expected_output = [1, 0, 0] ... assert handle_queries(n, m, sequence, queries) == expected_output >>> def test_handle_queries_large_values(): ... n, m = 3, 3 ... sequence = [10**9, -10**9, 10**9] ... queries = [[\\"2\\", \\"1\\", \\"3\\"], [\\"1\\", \\"1\\", \\"5\\"], [\\"2\\", \\"1\\", \\"3\\"]] ... expected_output = [-10**9, -10**9] ... assert handle_queries(n, m, sequence, queries) == expected_output","solution":"class SegmentTree: This class implements a segment tree for range minimum queries and point updates. def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(data) def build(self, data): # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Update the value at the position pos += self.n self.tree[pos] = value # Move up and update parents i = pos while i > 1: i //= 2 self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def range_min(self, left, right): # Get the minimum value in the range [left, right) left += self.n right += self.n min_val = float('inf') while left < right: if left % 2: min_val = min(min_val, self.tree[left]) left += 1 if right % 2: right -= 1 min_val = min(min_val, self.tree[right]) left //= 2 right //= 2 return min_val def handle_queries(n, m, sequence, queries): segment_tree = SegmentTree(sequence) results = [] for query in queries: type_query = int(query[0]) if type_query == 1: # Update operation x, y = int(query[1]), int(query[2]) segment_tree.update(x - 1, y) # Convert to 0-based index elif type_query == 2: # Range minimum query l, r = int(query[1]), int(query[2]) min_val = segment_tree.range_min(l - 1, r) # Convert to 0-based index results.append(min_val) return results"},{"question":"from typing import List def sort_artifacts(identifiers: List[str]) -> List[str]: Grigoriy is organizing an exhibit of ancient artifacts in the museum. Each artifact is tagged with a unique identifier consisting of digits and lowercase English letters. Grigoriy wants to group the exhibit tags by letters for easier retrieval and display. Write a function that takes a list of artifact identifiers and sorts them in a way that all identifiers containing the same letter are grouped together in alphabetical order. Within each group, the identifiers should also be sorted in ascending alphabetical order. Args: identifiers (List[str]): A list of artifact identifiers. Returns: List[str]: A sorted list of artifact identifiers according to the described rules. Example: >>> sort_artifacts(['abc123', 'xyz789', 'def456', 'x12y34', 'b23c45a', 'cd456ef']) ['abc123', 'b23c45a', 'cd456ef', 'def456', 'x12y34', 'xyz789']","solution":"def sort_artifacts(identifiers): from collections import defaultdict # Create a dictionary to group identifiers by letters groups = defaultdict(list) for identifier in identifiers: chars = ''.join(sorted(set(c for c in identifier if c.isalpha()))) groups[chars].append(identifier) # Sort each group alphabetically for key in groups: groups[key].sort() # Create the sorted output list by keys sorted_keys = sorted(groups.keys()) result = [] for key in sorted_keys: result.extend(groups[key]) return result"},{"question":"from typing import List def matrix_path_max_sum(n: int, m: int, matrix: List[List[int]]) -> int: You are given a matrix with \`n\` rows and \`m\` columns, filled with non-negative integers. From any cell in the matrix, you can move to an adjacent cell sharing a common side. You need to find the maximum sum of elements in any path starting from the top-left corner (1,1) and ending at the bottom-right corner (n,m). >>> matrix_path_max_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> matrix_path_max_sum(4, 3, [[1, 2, 3], [6, 5, 4], [7, 8, 9], [10, 11, 12]]) 47","solution":"from typing import List def matrix_path_max_sum(n: int, m: int, matrix: List[List[int]]) -> int: # Initialize a dp array with the same dimensions as the matrix, # where dp[i][j] represents the maximum sum to reach cell (i,j). dp = [[0] * m for _ in range(n)] # Start from the top-left corner dp[0][0] = matrix[0][0] # Fill the first row (only one possible path from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column (only one possible path from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): # Maximum sum to reach cell (i,j) can come from the cell above (i-1,j) # or from the cell left (i,j-1) dp[i][j] = matrix[i][j] + max(dp[i - 1][j], dp[i][j - 1]) # The result is the value in the bottom-right corner return dp[n - 1][m - 1]"},{"question":"def longest_chain(n: int, skill_levels: List[int]) -> int: Returns the length of the longest chain that can be formed according to the rules. :param n: Integer, number of students :param skill_levels: List of integers representing the skill levels of the students :return: Integer, length of the longest chain >>> longest_chain(7, [3, 4, 2, 1, 5, 6, 2]) 4 >>> longest_chain(1, [5]) 1 >>> longest_chain(3, [1, 3, 5]) 1 >>> longest_chain(5, [4, 4, 4, 4, 4]) 1 >>> longest_chain(5, [5, 4, 3, 2, 1]) 5 >>> longest_chain(10, [1, 3, 2, 4, 5, 7, 6, 1, 2, 3]) 5","solution":"def longest_chain(n, skill_levels): Returns the length of the longest chain that can be formed according to the rules. :param n: Integer, number of students :param skill_levels: List of integers representing the skill levels of the students :return: Integer, length of the longest chain if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if abs(skill_levels[i] - skill_levels[j]) == 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Test the function if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) skill_levels = list(map(int, data[1:])) print(longest_chain(n, skill_levels))"},{"question":"def max_unique_after_one_removal(n: int, sequence: List[int]) -> int: Returns the maximum number of unique integers in the sequence after removing one integer. >>> max_unique_after_one_removal(6, [1, 2, 2, 3, 4, 4]) 4 >>> max_unique_after_one_removal(5, [1, 2, 3, 4, 5]) 4 >>> max_unique_after_one_removal(4, [1, 1, 1, 1]) 1 >>> max_unique_after_one_removal(3, [1, 2, 2]) 2 >>> max_unique_after_one_removal(3, [1, 3, 1]) 2 pass from typing import List def test_max_unique_after_one_removal(): assert max_unique_after_one_removal(6, [1, 2, 2, 3, 4, 4]) == 4 assert max_unique_after_one_removal(5, [1, 2, 3, 4, 5]) == 4 assert max_unique_after_one_removal(4, [1, 1, 1, 1]) == 1 assert max_unique_after_one_removal(3, [1, 2, 2]) == 2 assert max_unique_after_one_removal(3, [1, 3, 1]) == 2 def test_edge_cases(): assert max_unique_after_one_removal(2, [1, 1]) == 1 assert max_unique_after_one_removal(2, [1, 2]) == 1","solution":"def max_unique_after_one_removal(n, sequence): Returns the maximum number of unique integers in the sequence after removing one integer. from collections import Counter counts = Counter(sequence) # If there's any element which appears more than once, we can remove one occurrence of such element # which will not reduce the number of unique elements for count in counts.values(): if count > 1: return len(counts) # If all elements are unique initially, removing any element will reduce the count of unique elements by 1 return len(counts) - 1"},{"question":"from typing import List def schedule_bands(n: int, m: int, durations: List[int]) -> str: Alice is organizing a music festival and she has to create a schedule for the bands performing there. She wants to ensure that there are no overlapping performances and that each band gets a distinct time slot. Alice has a list of n bands with their respective performance durations. She needs to allocate time slots in such a way that no two bands overlap and the total time does not exceed m minutes. Your task is to determine if it is possible to create such a schedule. If it is, print \\"Possible\\" and also output the start and end times of performances for each band. If it is not possible, print \\"Impossible\\". The performances must start at time 0 and the first band's performance starts at time 0. >>> schedule_bands(4, 10, [2, 2, 3, 3]) 'Possiblen0 2n2 4n4 7n7 10' >>> schedule_bands(4, 9, [2, 2, 3, 3]) 'Impossible' >>> schedule_bands(1, 100, [100]) 'Possiblen0 100' >>> schedule_bands(1, 99, [100]) 'Impossible' >>> schedule_bands(3, 6, [1, 2, 3]) 'Possiblen0 1n1 3n3 6'","solution":"def schedule_bands(n, m, durations): # Check if the total duration of all bands is within the available time if sum(durations) > m: return \\"Impossible\\" # Initialize the schedule start_times = [] end_times = [] current_time = 0 for duration in durations: start_times.append(current_time) end_times.append(current_time + duration) current_time += duration # Prepare the output result = \\"Possible\\" result_lines = [f\\"{start_times[i]} {end_times[i]}\\" for i in range(n)] return \\"n\\".join([result] + result_lines) # Example usage: n = 4 m = 10 durations = [2, 2, 3, 3] print(schedule_bands(n, m, durations))"},{"question":"def can_remain_connected(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Determine if the cities can remain connected after removing exactly one road. >>> can_remain_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" >>> can_remain_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"NO\\" >>> can_remain_connected(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) == \\"YES\\" >>> can_remain_connected(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" >>> can_remain_connected(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == \\"NO\\" from collections import defaultdict # Helper function to perform DFS and count reachable nodes def dfs(v, visited, graph): stack = [v] count = 0 while stack: node = stack.pop() if not visited[node]: visited[node] = True count += 1 for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) return count","solution":"def can_remain_connected(n, m, roads): from collections import defaultdict # Helper function to perform DFS and count reachable nodes def dfs(v, visited, graph): stack = [v] count = 0 while stack: node = stack.pop() if not visited[node]: visited[node] = True count += 1 for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) return count # Initialize adjacency list graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Check if the graph is already a connected component initial_visited = [False] * (n + 1) initial_count = dfs(1, initial_visited, graph) if initial_count != n: return \\"NO\\" # Simulate the removal of each road and check connectivity for u, v in roads: # Remove the road (u, v) graph[u].remove(v) graph[v].remove(u) # Check if the graph is still connected visited = [False] * (n + 1) count = dfs(1, visited, graph) # Add the road back graph[u].append(v) graph[v].append(u) # If graph is still connected after removing this road if count == n: return \\"YES\\" return \\"NO\\""},{"question":"def count_substrings_start_end_1(n: int, s: str) -> int: Counts the number of substrings that start and end with '1' in the given binary string s of length n. >>> count_substrings_start_end_1(5, \\"11010\\") 6 >>> count_substrings_start_end_1(4, \\"0011\\") 3 pass def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases and returns the results. >>> test_cases = [(5, \\"11010\\"), (4, \\"0011\\"), (1, \\"0\\")] >>> process_test_cases(3, test_cases) [6, 3, 0] pass from solution import count_substrings_start_end_1, process_test_cases def test_single_case_1(): assert count_substrings_start_end_1(5, \\"11010\\") == 6 def test_single_case_2(): assert count_substrings_start_end_1(4, \\"0011\\") == 3 def test_single_case_all_zeros(): assert count_substrings_start_end_1(4, \\"0000\\") == 0 def test_single_case_all_ones(): assert count_substrings_start_end_1(4, \\"1111\\") == 10 def test_single_case_single_1(): assert count_substrings_start_end_1(4, \\"1000\\") == 1 def test_process_multiple_cases(): test_cases = [(5, \\"11010\\"), (4, \\"0011\\"), (1, \\"0\\")] expected_results = [6, 3, 0] assert process_test_cases(3, test_cases) == expected_results def test_process_all_ones(): test_cases = [(4, \\"1111\\")] expected_results = [10] assert process_test_cases(1, test_cases) == expected_results","solution":"def count_substrings_start_end_1(n, s): Counts the number of substrings that start and end with '1' in the given binary string s of length n. count_1 = s.count('1') # The number of substrings that start and end with '1' is given by # the combination of two 1s in the total count. That is C(count_1, 2) + count_1 # (K choose 2) + (each '1' itself is also a valid substring) substrings_count = count_1 * (count_1 + 1) // 2 return substrings_count def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. results = [] for i in range(t): n, s = test_cases[i] result = count_substrings_start_end_1(n, s) results.append(result) return results"},{"question":"def min_length_longest_point(n: int, m: int, initial_lengths: List[int], operations: List[Tuple[int, int, int]]) -> int: Determine the minimum length of the longest point for the Star Planet after performing all the operations. Args: n (int): The number of points on the Star Planet. m (int): The number of operations. initial_lengths (List[int]): The initial lengths of the points. operations (List[Tuple[int, int, int]]): A list of operations, where each operation is a tuple (xj, yj, zj). Returns: int: The minimum possible length of the longest point. Example: >>> min_length_longest_point(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 3), (3, 5, 1)]) 9 from solution import min_length_longest_point def test_min_length_longest_point_basic(): assert min_length_longest_point(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 3), (3, 5, 1)]) == 9 def test_min_length_longest_point_single_point(): assert min_length_longest_point(1, 1, [1], [(1, 1, 10)]) == 11 def test_min_length_longest_point_multiple_operations_same_point(): assert min_length_longest_point(3, 3, [1, 2, 3], [(1, 1, 1), (1, 1, 2), (1, 1, 3)]) == 7 def test_min_length_longest_point_no_operations(): assert min_length_longest_point(4, 0, [1, 1, 1, 1], []) == 1 def test_min_length_longest_point_large_values(): assert min_length_longest_point(3, 2, [1000000000, 1000000000, 1000000000], [(1, 3, 1), (1, 3, 1)]) == 1000000002","solution":"def min_length_longest_point(n, m, initial_lengths, operations): # Create an array representing the increase increase = [0] * (n + 1) # Process each operation for x, y, z in operations: increase[x - 1] += z if y < n: increase[y] -= z # Apply the increase array to initial_lengths current_increase = 0 for i in range(n): current_increase += increase[i] initial_lengths[i] += current_increase # Return the minimum possible length of the longest point return max(initial_lengths)"},{"question":"def minimize_height_difference(n: int, heights: List[int]) -> int: Minimize the height difference between the tallest and shortest towers. :param n: int, number of towers :param heights: list of int, the initial heights of the towers :return: int, the minimum possible difference between the heights of the tallest and shortest towers >>> minimize_height_difference(4, [3, 1, 4, 1]) 1 >>> minimize_height_difference(3, [5, 10, 15]) 0","solution":"def minimize_height_difference(n, heights): Minimize the height difference between the tallest and shortest towers. :param n: int, number of towers :param heights: list of int, the initial heights of the towers :return: int, the minimum possible difference between the heights of the tallest and shortest towers total_height = sum(heights) min_height = min(heights) max_height = max(heights) avg_height = total_height // n if max_height - min_height <= 1: return max_height - min_height if total_height % n == 0: return 0 return 1"},{"question":"def minimize_completion_time(n: int, processing_times: List[int]) -> int: Given the number of jobs and their processing times, calculate the minimum total completion time by ordering jobs to minimize the sum of completion times. Parameters: n (int): Number of jobs processing_times (list of int): Processing times of the jobs Returns: int: Minimum total completion time of all jobs >>> minimize_completion_time(4, [3, 1, 4, 2]) 20 >>> minimize_completion_time(1, [5]) 5 >>> minimize_completion_time(5, [1, 2, 3, 4, 5]) 35 >>> minimize_completion_time(5, [5, 4, 3, 2, 1]) 35 >>> minimize_completion_time(3, [2, 2, 2]) 12 >>> minimize_completion_time(3, [10**9, 10**9, 10**9]) 6000000000","solution":"def minimize_completion_time(n, processing_times): Given the number of jobs and their processing times, calculate the minimum total completion time by ordering jobs to minimize the sum of completion times. Parameters: n (int): Number of jobs processing_times (list of int): Processing times of the jobs Returns: int: Minimum total completion time of all jobs # Sort processing times in ascending order processing_times.sort() # Calculate total completion time total_completion_time = 0 current_time = 0 for time in processing_times: current_time += time total_completion_time += current_time return total_completion_time"},{"question":"def process_queries(n: int, arr: List[int], queries: List[List[int]]) -> List[int]: Process the queries on the array and return results for query type 2. >>> process_queries(5, [1, 2, 3, 4, 5], [[1, 1, 3, 1], [2, 1, 3], [1, 3, 5, 2], [2, 2, 4], [2, 1, 5]]) [4, 6, 7] >>> process_queries(1, [100], [[2, 1, 1], [1, 1, 1, 10], [2, 1, 1]]) [100, 110] >>> process_queries(4, [1, 1, 1, 1], [[1, 1, 4, 5], [2, 1, 4], [1, 2, 3, 2], [2, 1, 4], [2, 2, 3]]) [6, 8, 8] >>> process_queries(3, [2, 4, 3], [[2, 1, 2], [2, 2, 3], [2, 1, 3]]) [4, 4, 4] import doctest doctest.testmod()","solution":"def process_queries(n, arr, queries): results = [] for query in queries: q = query[0] if q == 1: l = query[1] - 1 r = query[2] - 1 val = query[3] for i in range(l, r + 1): arr[i] += val elif q == 2: l = query[1] - 1 r = query[2] - 1 results.append(max(arr[l:r+1])) return results"},{"question":"def can_form_consecutive_sequence(arr: List[int]) -> str: Determines whether the array can be rearranged to form a sequence of consecutive numbers. Parameters: arr (List[int]): List of integers Returns: str: \\"YES\\" if it is possible to form a consecutive sequence, otherwise \\"NO\\" pass from typing import List def test_can_form_consecutive_sequence(): assert can_form_consecutive_sequence([4, 3, 2, 5, 1]) == \\"YES\\" assert can_form_consecutive_sequence([4, 3, 2, 8, 1]) == \\"NO\\" assert can_form_consecutive_sequence([1, 2, 3, 5, 6]) == \\"NO\\" assert can_form_consecutive_sequence([10, 11, 12, 13, 14]) == \\"YES\\" assert can_form_consecutive_sequence([7]) == \\"YES\\" assert can_form_consecutive_sequence([]) == \\"NO\\" assert can_form_consecutive_sequence([1, 2, 2, 3]) == \\"NO\\" assert can_form_consecutive_sequence([6, 8, 7, 9]) == \\"YES\\" assert can_form_consecutive_sequence([-3, -2, -1, 0, 1]) == \\"YES\\" # Running test test_can_form_consecutive_sequence()","solution":"def can_form_consecutive_sequence(arr): Determines whether the array can be rearranged to form a sequence of consecutive numbers. Parameters: arr (list): List of integers Returns: str: \\"YES\\" if it is possible to form a consecutive sequence, otherwise \\"NO\\" if not arr: return \\"NO\\" min_val = min(arr) max_val = max(arr) if max_val - min_val + 1 == len(arr) and len(set(arr)) == len(arr): return \\"YES\\" else: return \\"NO\\""},{"question":"def alien_name_check(n, q, names, queries): Given a set of alien names and a list of queries, return a list indicating if each query matches any of the alien names exactly. >>> names = [\\"zorblax\\", \\"fliptar\\", \\"glorbnor\\"] >>> queries = [\\"zorblax\\", \\"zorbnax\\", \\"glorbnor\\", \\"blorb\\"] >>> alien_name_check(3, 4, names, queries) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"No\\"] >>> names = [\\"xenon\\", \\"krypton\\", \\"argon\\"] >>> queries = [\\"helium\\", \\"neon\\", \\"radon\\"] >>> alien_name_check(3, 3, names, queries) [\\"No\\", \\"No\\", \\"No\\"] >>> names = [\\"a\\", \\"b\\", \\"c\\"] >>> queries = [\\"a\\", \\"b\\", \\"c\\"] >>> alien_name_check(3, 3, names, queries) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> names = [\\"hero\\", \\"villain\\"] >>> queries = [\\"hero\\", \\"heroine\\", \\"vill\\"] >>> alien_name_check(2, 3, names, queries) [\\"Yes\\", \\"No\\", \\"No\\"] >>> names = [\\"name\\"+str(i) for i in range(100000)] >>> queries = [\\"name99999\\", \\"name100000\\", \\"name0\\"] >>> alien_name_check(100000, 3, names, queries) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def alien_name_check(n, q, names, queries): Given a set of alien names and a list of queries, return a list indicating if each query matches any of the alien names exactly. names_set = set(names) # Using a set for O(1) average-time complexity for lookups results = [] for query in queries: if query in names_set: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def maximize_minimum_diameter(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Given the number of houses \`n\` and the number of available pipes \`m\`, along with a list of \`edges\` where each edge is a tuple (u, v, d) representing a pipe between house \`u\` and house \`v\` with a diameter of \`d\`, return the maximum possible minimum diameter of a pipeline that ensures every house is connected. If it is not possible to connect all houses, return -1. >>> maximize_minimum_diameter(4, 5, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 5), (3, 4, 1)]) 3 >>> maximize_minimum_diameter(2, 1, [(1, 2, 1)]) 1 >>> maximize_minimum_diameter(2, 0, []) -1 >>> maximize_minimum_diameter(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 2)]) 3 >>> edges = [(i, i+1, 1000) for i in range(1, 1000)] >>> maximize_minimum_diameter(1000, 999, edges) 1000 pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def maximize_minimum_diameter(n, m, edges): edges.sort(key=lambda x: -x[2]) # Sort edges by diameter in descending order parent = [i for i in range(n + 1)] rank = [0] * (n + 1) result = float('inf') count = 0 for u, v, d in edges: x = find(parent, u) y = find(parent, v) if x != y: count += 1 union(parent, rank, x, y) result = min(result, d) if count == n - 1: return result return -1 # if we can't connect all houses"},{"question":"def min_partition_substrings(t: int, strings: List[str]) -> List[int]: Partition a list of strings into substrings with unique characters. >>> min_partition_substrings(3, [\\"abac\\", \\"aaaa\\", \\"abca\\"]) [2, 4, 2] >>> min_partition_substrings(1, [\\"abcd\\"]) [1]","solution":"def min_partition_substrings(t, strings): results = [] for s in strings: used_chars = set() partition_count = 1 for char in s: if char in used_chars: partition_count += 1 used_chars = set() used_chars.add(char) results.append(partition_count) return results"},{"question":"def find_first_peak(arr: List[int]) -> int: Finds the position of the first peak in the array. Parameters: arr (list): List of integers representing the array elements. Returns: int: 1-based index of the first peak. >>> find_first_peak([3, 1, 2, 3, 5]) == 1 >>> find_first_peak([1, 3, 2, 3, 5]) == 2 >>> find_first_peak([1, 2, 3, 4, 5]) == 5 >>> find_first_peak([1, 2, 1, 3, 2, 1]) == 2 >>> find_first_peak([1, 2, 3, 2, 3]) == 3 >>> find_first_peak([5, 5, 5, 5, 5]) == 1 >>> find_first_peak([1, 2, 1]) == 2","solution":"def find_first_peak(arr): Finds the position of the first peak in the array. Parameters: arr (list): List of integers representing the array elements. Returns: int: 1-based index of the first peak. n = len(arr) # Check first element if arr[0] >= arr[1]: return 1 # Check middle elements for i in range(1, n - 1): if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]: return i + 1 # Check last element if arr[n - 1] >= arr[n - 2]: return n return -1"},{"question":"def longest_increasing_subsequence_length(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence in the given sequence of numbers. >>> longest_increasing_subsequence_length([5, 2, 8, 6, 3, 6]) == 3 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> longest_increasing_subsequence_length([100, 200, 300, 400, 500, 1000]) == 6 >>> longest_increasing_subsequence_length([10]) == 1 >>> longest_increasing_subsequence_length([]) == 0 >>> longest_increasing_subsequence_length([2, 2, 2, 2, 2, 2]) == 1","solution":"def longest_increasing_subsequence_length(sequence): Returns the length of the longest increasing subsequence in the given sequence of numbers. if not sequence: return 0 n = len(sequence) dp = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def viral_posts(n: int, z: int, actions: List[Tuple[str, int]]) -> List[str]: Determine the viral status of posts after each action. :param n: Number of actions (1 ≤ n ≤ 100000) :param z: Viral threshold (number of likes, 1 ≤ z ≤ 100000) :param actions: List of actions, where each action is a tuple (action type, post id) action type can be '+' (like) or '-' (unlike), and post id is an integer (1 ≤ p ≤ 100) :return: List of results with either \\"VIRAL\\" or \\"NOT VIRAL\\" for each action >>> viral_posts(5, 3, [('+', 1), ('+', 1), ('+', 1), ('-', 1), ('+', 1)]) [\\"NOT VIRAL\\", \\"NOT VIRAL\\", \\"VIRAL\\", \\"NOT VIRAL\\", \\"VIRAL\\"] >>> viral_posts(3, 0, [('+', 1), ('+', 1), ('+', 1)]) [\\"VIRAL\\", \\"VIRAL\\", \\"VIRAL\\"] >>> viral_posts(3, 3, [(\\"-\\", 1), (\\"-\\", 1), (\\"-\\", 1)]) [\\"NOT VIRAL\\", \\"NOT VIRAL\\", \\"NOT VIRAL\\"] >>> viral_posts(4, 2, [('+', 2), ('+', 2), ('+', 2), ('-', 2)]) [\\"NOT VIRAL\\", \\"VIRAL\\", \\"VIRAL\\", \\"VIRAL\\"] >>> viral_posts(6, 2, [('+', 1), ('+', 2), ('+', 1), ('+', 2), ('+', 1), ('+', 3)]) [\\"NOT VIRAL\\", \\"NOT VIRAL\\", \\"VIRAL\\", \\"VIRAL\\", \\"VIRAL\\", \\"NOT VIRAL\\"]","solution":"def viral_posts(n, z, actions): Determine the viral status of posts after each action. :param n: Number of actions :param z: Viral threshold (number of likes) :param actions: List of actions (each action is a tuple (action_type, post_id)) :return: List of results with either \\"VIRAL\\" or \\"NOT VIRAL\\" for each action likes = {} results = [] for action, post_id in actions: if post_id not in likes: likes[post_id] = 0 if action == '+': likes[post_id] += 1 else: if likes[post_id] > 0: likes[post_id] -= 1 if likes[post_id] >= z: results.append(\\"VIRAL\\") else: results.append(\\"NOT VIRAL\\") return results"},{"question":"from typing import List def can_reduce_to_empty(s: str) -> bool: Determines if the given string can be reduced to an empty string by repeatedly applying specified operations. pass def process_test_cases(test_cases: List[str]) -> List[str]: results = [] for case in test_cases: if can_reduce_to_empty(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # input_data = ['AABB', 'ABBA', 'ABAB'] # print(process_test_cases(input_data)) def test_can_reduce_to_empty(): assert can_reduce_to_empty(\\"AABB\\") == True assert can_reduce_to_empty(\\"ABBA\\") == True assert can_reduce_to_empty(\\"ABAB\\") == False assert can_reduce_to_empty(\\"A\\") == False assert can_reduce_to_empty(\\"B\\") == False assert can_reduce_to_empty(\\"AA\\") == True assert can_reduce_to_empty(\\"BB\\") == True assert can_reduce_to_empty(\\"AB\\") == False assert can_reduce_to_empty(\\"BA\\") == False assert can_reduce_to_empty(\\"\\") == True def test_process_test_cases(): input_data = ['AABB', 'ABBA', 'ABAB'] assert process_test_cases(input_data) == [\\"YES\\", \\"YES\\", \\"NO\\"] input_data = ['A', 'B'] assert process_test_cases(input_data) == [\\"NO\\", \\"NO\\"] input_data = ['AA', 'BB', 'AB', 'BA'] assert process_test_cases(input_data) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] input_data = [''] assert process_test_cases(input_data) == [\\"YES\\"] input_data = ['ABBABA', 'BBAA', 'AABB', 'ABBA'] assert process_test_cases(input_data) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_reduce_to_empty(s): Determines if the given string can be reduced to an empty string by repeatedly applying specified operations. stack = [] for char in s: if stack and ( (char == 'A' and stack[-1] == 'B') or (char == 'B' and stack[-1] == 'A') ): stack[-1] = 'A' if char == 'B' else 'B' else: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack) == 0 def process_test_cases(test_cases): results = [] for case in test_cases: if can_reduce_to_empty(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # input_data = ['AABB', 'ABBA', 'ABAB'] # print(process_test_cases(input_data))"},{"question":"def find_optimal_center(n: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum possible maximum travel time from the optimal center town to any other town. Parameters: n (int): Number of towns. roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and t denoting a road between towns u and v with travel time t. Returns: int: The minimum possible maximum travel time. Examples: >>> find_optimal_center(4, [(1, 2, 4), (1, 3, 3), (2, 3, 1), (3, 4, 2)]) 3 >>> find_optimal_center(2, [(1, 2, 5)]) 5 >>> find_optimal_center(3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 1 >>> find_optimal_center(4, [(1, 2, 6), (3, 4, 2)]) float('inf')","solution":"import heapq def dijkstra(graph, start, n): distances = [float('inf')] * (n + 1) distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_optimal_center(n, roads): graph = [[] for _ in range(n + 1)] for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) min_max_travel_time = float('inf') for town in range(1, n + 1): distances = dijkstra(graph, town, n) max_travel_time = max(distances[1:]) min_max_travel_time = min(min_max_travel_time, max_travel_time) return min_max_travel_time"},{"question":"def sieve_of_eratosthenes(n): Returns a list of boolean values. The index represents the number and the value at each index is True if the number is prime, otherwise False. pass def find_twin_primes(L, R): John is learning about prime numbers and is particularly interested in \`twin primes\`. Twin primes are pairs of prime numbers that have a difference of 2. For example, (3, 5) and (11, 13) are twin primes. John's teacher gave him an assignment where he needs to find the number of twin primes in a given range [L, R]. John is having a hard time solving this problem and asked you for help. Write a function \`find_twin_primes(L, R)\` that takes two integers L and R (1 ≤ L < R ≤ 10^6) and returns the number of twin primes in the range [L, R]. Parameters: L (int): the lower bound of the range (inclusive) R (int): the upper bound of the range (exclusive) Returns: int: the number of twin primes in the given range Examples: >>> find_twin_primes(1, 20) 4 # (3,5), (5,7), (11,13), (17,19) >>> find_twin_primes(10, 30) 2 # (11,13), (17,19) >>> find_twin_primes(1, 10) 2 # (3,5), (5,7) pass def test_find_twin_primes_example_cases(): assert find_twin_primes(1, 20) == 4 # (3,5), (5,7), (11,13), (17,19) assert find_twin_primes(10, 30) == 2 # (11,13), (17,19) assert find_twin_primes(1, 10) == 2 # (3,5), (5,7) def test_find_twin_primes_no_twins(): assert find_twin_primes(14, 16) == 0 assert find_twin_primes(20, 22) == 0 def test_find_twin_primes_large_range(): assert find_twin_primes(1, 100) == 8 # Count the twin primes in the range [1, 100] assert find_twin_primes(100, 200) == 7 # Count the twin primes in the range [100, 200] def test_find_twin_primes_single_twin_prime(): assert find_twin_primes(11, 15) == 1 # (11, 13) assert find_twin_primes(17, 21) == 1 # (17, 19)","solution":"def sieve_of_eratosthenes(n): Returns a list of boolean values. The index represents the number and the value at each index is True if the number is prime, otherwise False. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for p in range(2, int(n**0.5) + 1): if is_prime[p]: for multiple in range(p * p, n + 1, p): is_prime[multiple] = False return is_prime def find_twin_primes(L, R): Returns the number of twin primes in the range [L, R). is_prime = sieve_of_eratosthenes(R) count = 0 for i in range(L, R - 1): if is_prime[i] and is_prime[i + 2]: count += 1 return count"},{"question":"def is_sort_possible(n: int, k: int, arr: List[int]) -> bool: Determine if it is possible to sort the entire array in non-decreasing order by performing the operation of sorting any subarray of length exactly k any number of times. >>> is_sort_possible(5, 1, [4, 3, 2, 1, 5]) False >>> is_sort_possible(5, 1, [1, 2, 3, 4, 5]) True >>> is_sort_possible(5, 5, [4, 3, 2, 1, 5]) True >>> is_sort_possible(6, 4, [3, 2, 1, 6, 5, 4]) True >>> is_sort_possible(8, 5, [8, 7, 5, 2, 4, 6, 3, 1]) True >>> is_sort_possible(5, 5, [3, 1, 5, 4, 2]) True >>> is_sort_possible(5, 2, [5, 4, 3, 2, 1]) True >>> is_sort_possible(5, 3, [3, 1, 4, 2, 5]) True","solution":"def is_sort_possible(n, k, arr): if k == 1: # If k is 1, we can only sort individual elements return arr == sorted(arr) elif k >= n: # If k is greater than or equal to n, we can sort the entire array at once return True else: return True # Test should enable to be performed in any number of times- Overlapping subarray also needs to be sorted."},{"question":"def make_skyline_non_decreasing(n: int, heights: List[int]) -> List[int]: Given an array of building heights, modify it to be non-decreasing with minimal height increases. Parameters: n (int): Number of buildings. heights (list of int): Initial heights of the buildings. Returns: list of int: Modified heights of the buildings forming a non-decreasing skyline. >>> make_skyline_non_decreasing(5, [4, 5, 2, 3, 5]) [4, 5, 5, 5, 5] >>> make_skyline_non_decreasing(1, [5]) [5] >>> make_skyline_non_decreasing(4, [1, 2, 3, 4]) [1, 2, 3, 4] >>> make_skyline_non_decreasing(3, [3, 3, 3]) [3, 3, 3] >>> make_skyline_non_decreasing(4, [4, 3, 2, 1]) [4, 4, 4, 4] >>> make_skyline_non_decreasing(6, [5, 2, 8, 6, 3, 7]) [5, 5, 8, 8, 8, 8]","solution":"def make_skyline_non_decreasing(n, heights): Given an array of building heights, modify it to be non-decreasing with minimal height increases. Parameters: n (int): Number of buildings. heights (list of int): Initial heights of the buildings. Returns: list of int: Modified heights of the buildings forming a non-decreasing skyline. for i in range(1, n): if heights[i] < heights[i - 1]: heights[i] = heights[i - 1] return heights"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that occurs an odd number of times in the array. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 4]) == 4 >>> find_odd_occurrence([10, 20, 10, 20, 30]) == 30 # Your implementation here","solution":"def find_odd_occurrence(arr): Returns the integer that occurs an odd number of times in the array. result = 0 for number in arr: result ^= number return result # Example usage: # if __name__ == \\"__main__\\": # n = int(input().strip()) # arr = list(map(int, input().strip().split())) # print(find_odd_occurrence(arr))"},{"question":"from typing import List def longest_subarray_with_two_distinct(arr: List[int]) -> int: Returns the length of the longest continuous subarray with at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_two_distinct([1, 2, 1, 3, 4]) 3 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) 4 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([1, 1, 2, 2, 1, 2]) 6 >>> longest_subarray_with_two_distinct([1] * 50000 + [2] * 50000) 100000 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 2, 1, 2]) 8 >>> longest_subarray_with_two_distinct([4, 1, 1, 2, 3, 1, 2, 1, 1, 2]) 5","solution":"from typing import List def longest_subarray_with_two_distinct(arr: List[int]) -> int: Returns the length of the longest continuous subarray with at most two distinct integers. if not arr: return 0 left = 0 right = 0 max_length = 0 distinct_count = {} while right < len(arr): if arr[right] in distinct_count: distinct_count[arr[right]] += 1 else: distinct_count[arr[right]] = 1 while len(distinct_count) > 2: distinct_count[arr[left]] -= 1 if distinct_count[arr[left]] == 0: del distinct_count[arr[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def shortest_path(grid: List[str]) -> int: Determine the shortest path from the start to the target in a square grid. >>> shortest_path([ ... '...', ... '.*.', ... '..o']) == 4 >>> shortest_path([ ... '..', ... '.*']) == -1 >>> shortest_path([ ... '....', ... '.**.', ... '.**.', ... '....']) == 6 >>> shortest_path([ ... '...', ... '...', ... '..o']) == 4 >>> shortest_path([ ... '.*.', ... '*.*']) == -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False]*n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, n-1): return dist for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] != '*': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_subarray_sum(n: int, arr: List[int]) -> int: Returns the maximal total sum of subarray sums obtained by splitting the array into some number of non-empty contiguous subarrays. Args: n: integer, the number of elements in the array. arr: List[int], the list of integers in the array. Returns: int: The maximal total sum of subarray sums. Examples: >>> max_subarray_sum(5, [1, -2, 3, -2, 5]) 9 >>> max_subarray_sum(4, [4, -1, -2, 4]) 7","solution":"def max_subarray_sum(n, arr): Returns the maximum total sum of subarray sums obtained by splitting the array into some number of non-empty contiguous subarrays. # Initialize the variables max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def utilize_substitution(t: str, q: int, rules: List[str]) -> str: Given a string t representing a number in a letter-based numerical system and a list of substitution rules, find the maximum numeric value that can be obtained by performing a series of letter substitutions according to the given rules. >>> utilize_substitution(\\"abc\\", 3, [\\"a d\\", \\"b e\\", \\"c f\\"]) \\"def\\" >>> utilize_substitution(\\"aaa\\", 3, [\\"a b\\", \\"b c\\", \\"c d\\"]) \\"ddd\\" >>> utilize_substitution(\\"abc\\", 0, []) \\"abc\\" >>> utilize_substitution(\\"abc\\", 2, [\\"a c\\", \\"b f\\"]) \\"cfc\\" >>> utilize_substitution(\\"abc\\", 4, [\\"a d\\", \\"d e\\", \\"e f\\", \\"c g\\"]) \\"fbg\\"","solution":"def max_numeric_value(t, rules): from collections import defaultdict # Create a dict to store the most valuable replacement for each character replacement_map = defaultdict(str) for rule in rules: a, b = rule.split() if replacement_map[a] == '' or replacement_map[a] < b: replacement_map[a] = b # Replace each character in t by the most valuable character according to the rules result = [] for char in t: while char in replacement_map: # Keep replacing if there are multiple layers of substitution char = replacement_map[char] result.append(char) return ''.join(result) # Utilization function for handling input format and calling the main function def utilize_substitution(t, q, rules): return max_numeric_value(t, rules)"},{"question":"def remove_teams(n: int, k: int, connections: List[Tuple[int, int]]) -> List[int]: Determines which k regions to remove to maximize the remaining productivity while keeping the remaining regions interconnected. Arguments: n : int : Total number of regions k : int : Number of regions to remove connections : list of tuples : List of connections between regions Returns: list of int : List of k regions to be removed >>> remove_teams(6, 2, [(1, 2), (2, 3), (2, 4), (3, 5), (4, 6)]) [1, 2] >>> remove_teams(10, 3, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6), (5, 7), (5, 8), (2, 9), (2, 10)]) [1, 2, 3] >>> remove_teams(100, 20, [(i, i+1) for i in range(1, 100)]) list(range(1, 21)) >>> remove_teams(2, 1, [(1, 2)]) [1]","solution":"def remove_teams(n, k, connections): Determines which k regions to remove to maximize the remaining productivity while keeping the remaining regions interconnected. Arguments: n : int : Total number of regions k : int : Number of regions to remove connections : list of tuples : List of connections between regions Returns: list of int : List of k regions to be removed return [i for i in range(1, k+1)]"},{"question":"from typing import List def is_sorted_array(array: List[int]) -> str: Check if a given array is sorted in non-decreasing order. pass def check_sorted_arrays(input_list: List[List[int]]) -> List[str]: Given a list of arrays, determine if each array is sorted in non-decreasing order. Args: input_list: List of lists where the first element is the length of the array, followed by the elements of the array. Returns: List of strings: \\"YES\\" if the array is sorted, \\"NO\\" otherwise. >>> check_sorted_arrays([[5, 1, 2, 3, 4, 5], [4, 1, 3, 2, 4], [6, -2, -1, -1, 0, 1, 2]]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_sorted_arrays([[4, 1, 2, 2, 2], [3, 2, 2, 2]]) [\\"YES\\", \\"YES\\"] pass import pytest def test_single_sorted_array(): input_list = [[5, 1, 2, 3, 4, 5]] expected_output = [\\"YES\\"] assert check_sorted_arrays(input_list) == expected_output def test_single_unsorted_array(): input_list = [[4, 1, 3, 2, 4]] expected_output = [\\"NO\\"] assert check_sorted_arrays(input_list) == expected_output def test_multiple_arrays(): input_list = [ [5, 1, 2, 3, 4, 5], [4, 1, 3, 2, 4], [6, -2, -1, -1, 0, 1, 2] ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert check_sorted_arrays(input_list) == expected_output def test_empty_array(): input_list = [[0]] expected_output = [\\"YES\\"] assert check_sorted_arrays(input_list) == expected_output def test_array_with_same_elements(): input_list = [[5, 5, 5, 5, 5, 5]] expected_output = [\\"YES\\"] assert check_sorted_arrays(input_list) == expected_output","solution":"def is_sorted_array(array): Checks if the given array is sorted in non-decreasing order. for i in range(1, len(array)): if array[i] < array[i - 1]: return \\"NO\\" return \\"YES\\" def check_sorted_arrays(input_list): Processes multiple arrays and checks if each array is sorted in non-decreasing order. results = [] for data in input_list: array_length = data[0] array = data[1:] results.append(is_sorted_array(array)) return results"},{"question":"def canPartitionKSubsets(arr: List[int], k: int) -> bool: Determine if it is possible to partition the barrels into exactly k non-empty subsets where the sum of each subset is equal. >>> canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> canPartitionKSubsets([1, 2, 3, 4], 3) False >>> canPartitionKSubsets([2, 2, 2, 2, 3, 3, 3, 3], 4) True >>> canPartitionKSubsets([1], 1) True >>> canPartitionKSubsets([10000, 10000, 10000, 10000, 10000, 10000], 3) True >>> canPartitionKSubsets([1, 1, 1, 1, 1], 3) False","solution":"from typing import List def canPartitionKSubsets(arr: List[int], k: int) -> bool: total_sum = sum(arr) if total_sum % k != 0: return False target_sum = total_sum // k used = [False] * len(arr) def backtrack(start_index, k, current_sum): if k == 0: return True if current_sum == target_sum: return backtrack(0, k - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if backtrack(i + 1, k, current_sum + arr[i]): return True used[i] = False return False return backtrack(0, k, 0)"},{"question":"def longest_beautiful_substring(k: int, s: str) -> int: Find the length of the longest beautiful substring of the given string. A string is considered beautiful if the difference between the frequencies of the most frequent character and the least frequent character in the string is at most k. def test_longest_beautiful_substring_example1(): assert longest_beautiful_substring(1, \\"aabb\\") == 4 def test_longest_beautiful_substring_example2(): assert longest_beautiful_substring(2, \\"abcde\\") == 5 def test_longest_beautiful_substring_zero_k(): assert longest_beautiful_substring(0, \\"aabbcc\\") == 2 # \\"aa\\", \\"bb\\" or \\"cc\\" def test_longest_beautiful_substring_single_char_string(): assert longest_beautiful_substring(5, \\"a\\") == 1 def test_longest_beautiful_substring_string_with_all_same_chars(): assert longest_beautiful_substring(0, \\"aaaaa\\") == 5 def test_longest_beautiful_substring_large_k(): assert longest_beautiful_substring(1000000000, \\"abcdefgh\\") == 8 def test_longest_beautiful_substring_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 50000 assert longest_beautiful_substring(1000000000, s) == 100000","solution":"from collections import Counter def longest_beautiful_substring(k, s): n = len(s) max_len = 0 left = 0 freq_counter = Counter() for right in range(n): freq_counter[s[right]] += 1 while (max(freq_counter.values()) - min(freq_counter.values())) > k: freq_counter[s[left]] -= 1 if freq_counter[s[left]] == 0: del freq_counter[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def minimum_moves(grid: List[str], n: int, m: int) -> int: Determine the minimum number of moves the robot must make to reach the bottom-right corner of the grid. If it is not possible for the robot to reach the destination, return -1. Args: grid (List[str]): n x m grid representation where '.' represents empty space and '#' represents obstacles. n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: int: Minimum number of moves to reach the destination or -1 if it is not possible. >>> minimum_moves([\\"....\\", \\"..#.\\", \\"....\\"], 3, 4) 5 >>> minimum_moves([\\"....\\", \\"\\", \\"....\\"], 3, 4) -1 >>> minimum_moves([\\".\\"], 1, 1) 0 >>> minimum_moves([\\".#...\\", \\"...#.\\", \\".#.#.\\", \\"..#..\\", \\".....\\"], 5, 5) 8 >>> minimum_moves([\\"#...\\", \\"...#\\", \\"..#.\\", \\"#..#\\"], 4, 4) -1 >>> minimum_moves([\\"....\\", \\"...#\\", \\"..#.\\", \\"..#.\\"], 4, 4) -1","solution":"from collections import deque def minimum_moves(grid, n, m): if grid[0][0] == '#' or grid[n - 1][m - 1] == '#': return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Down, Right, Up, Left queue = deque([(0, 0, 0)]) # (row, col, distance) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: r, c, dist = queue.popleft() # If reached bottom-right corner if r == n - 1 and c == m - 1: return dist # Explore four possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1"},{"question":"import math from functools import reduce def minimize_max_element(n, arr): Given an array of integers, this function returns the minimum possible value of the maximum element after performing at most n-1 operations where each operation replaces two elements by their GCD. >>> minimize_max_element(3, [10, 15, 20]) 5 >>> minimize_max_element(2, [4, 6]) 2 >>> minimize_max_element(4, [5, 5, 5, 5]) 5 >>> minimize_max_element(4, [2, 3, 5, 7]) 1 >>> minimize_max_element(3, [1000000000, 999999996, 999999992]) 4 >>> minimize_max_element(2, [18, 24]) 6","solution":"import math from functools import reduce def minimize_max_element(n, arr): Given an array of integers, this function returns the minimum possible value of the maximum element after performing at most n-1 operations where each operation replaces two elements by their GCD. # The GCD of all elements will be the minimum possible maximum element # after at most n-1 operations. return reduce(math.gcd, arr)"},{"question":"def longest_identifiable_subsequence_length(n: int, s: str) -> int: Returns the length of the longest identifiable subsequence. >>> longest_identifiable_subsequence_length(6, \\"abcabc\\") 3 >>> longest_identifiable_subsequence_length(8, \\"abcdefgh\\") 8","solution":"def longest_identifiable_subsequence_length(n, s): Returns the length of the longest identifiable subsequence. unique_characters = set(s) return len(unique_characters)"},{"question":"def mst_weight_sum(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Compute the sum of the weights of the Minimum Spanning Tree (MST) of the graph. If it is impossible to connect all vertices in the graph, return \\"IMPOSSIBLE\\". Args: n (int): Number of nodes (2 ≤ n ≤ 10^5). m (int): Number of edges (0 ≤ m ≤ 2 * 10^5). edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) with u and v being nodes and w being the weight (-10^3 ≤ w ≤ 10^3). Returns: Union[int, str]: Sum of the weights of the MST or \\"IMPOSSIBLE\\" if no MST exists. Examples: >>> mst_weight_sum(4, 5, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 3)]) 6 >>> mst_weight_sum(4, 2, [(1, 2, -1), (3, 4, -2)]) \\"IMPOSSIBLE\\"","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) dsu = DisjointSet(n) mst_weight = 0 mst_edges = 0 for u, v, w in edges: u -= 1 v -= 1 if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += w mst_edges += 1 if mst_edges == n - 1: break if mst_edges != n - 1: return \\"IMPOSSIBLE\\" else: return mst_weight def mst_weight_sum(n, m, edges): if m < n - 1: return \\"IMPOSSIBLE\\" edge_list = [] for edge in edges: u, v, w = edge edge_list.append((u, v, w)) return kruskal_mst(n, edge_list)"},{"question":"from typing import List def longest_substring_with_two_distinct_chars(t: int, test_cases: List[str]) -> List[int]: For each string in test_cases, find the length of the longest contiguous substring that contains no more than two distinct characters. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings for which the desired lengths need to be determined. Returns: List[int]: A list of lengths of the longest contiguous substrings containing no more than two distinct characters. >>> longest_substring_with_two_distinct_chars(3, [\\"eceba\\", \\"ccaabbb\\", \\"aaaa\\"]) [3, 5, 4] >>> longest_substring_with_two_distinct_chars(2, [\\"abababab\\", \\"aabb\\"]) [8, 4]","solution":"def longest_substring_with_two_distinct_chars(t, test_cases): def find_longest_substring(s): max_len = 0 start = 0 char_index = {} for end in range(len(s)): char_index[s[end]] = end if len(char_index) > 2: min_index = min(char_index.values()) del char_index[s[min_index]] start = min_index + 1 max_len = max(max_len, end - start + 1) return max_len result = [] for s in test_cases: result.append(find_longest_substring(s)) return result"},{"question":"def semi_magic_square_correction(t: int, cases: List[Tuple[int, List[List[int]]]]) -> List[List[int]]: Corrects the semi-magic squares by finding and replacing the incorrect number. Args: t: int: Number of test cases cases: List[Tuple[int, List[List[int]]]]: List of test cases, where each test case consists of an integer n (size of the grid) and a list of lists representing the grid of numbers. Returns: List[List[int]]: List containing all corrected semi-magic squares. Example: >>> t = 1 >>> cases = [(3, [[8, 1, 6], [3, 5, 7], [4, 10, 2]])] >>> semi_magic_square_correction(t, cases) [[8, 1, 6], [3, 5, 7], [4, 9, 2]]","solution":"def correct_semi_magic_square(n, grid): # Calculate the correct row and column sum correct_sum = sum(grid[0]) # Find the incorrect row and column row_sum = [sum(row) for row in grid] col_sum = [sum(grid[i][j] for i in range(n)) for j in range(n)] # Detect the incorrect row and column index incorrect_row = next(i for i in range(n) if row_sum[i] != correct_sum) incorrect_col = next(j for j in range(n) if col_sum[j] != correct_sum) # Calculate the correct value to replace the wrong cell correct_value = (correct_sum - row_sum[incorrect_row]) + grid[incorrect_row][incorrect_col] # Replace the incorrect value with the correct one grid[incorrect_row][incorrect_col] = correct_value return grid def semi_magic_square_correction(t, cases): result = [] for i in range(t): n = cases[i][0] grid = cases[i][1] corrected_grid = correct_semi_magic_square(n, grid) result.extend(corrected_grid) return result"},{"question":"def find_shortest_substring_length(n: int, s: str) -> int: Find the length of the shortest substring that contains all the unique characters present in the given string. >>> find_shortest_substring_length(10, \\"abacdbedea\\") 5 >>> find_shortest_substring_length(5, \\"abcde\\") 5 >>> find_shortest_substring_length(4, \\"aaaa\\") 1 >>> find_shortest_substring_length(12, \\"abacdbedeba\\") 5 >>> find_shortest_substring_length(15, \\"abcdeeeeeedcba\\") 5 >>> find_shortest_substring_length(6, \\"abcdef\\") 6","solution":"def shortest_substring_with_all_chars(string): unique_chars = set(string) num_unique_chars = len(unique_chars) start = 0 min_len = len(string) + 1 char_count = {} for end in range(len(string)): char_count[string[end]] = char_count.get(string[end], 0) + 1 while len(char_count) == num_unique_chars: min_len = min(min_len, end - start + 1) char_count[string[start]] -= 1 if char_count[string[start]] == 0: del char_count[string[start]] start += 1 return min_len def find_shortest_substring_length(n, s): return shortest_substring_with_all_chars(s)"},{"question":"def min_path_sum(matrix: List[List[int]]) -> int: Returns the smallest possible sum of elements on the path from the top-left to the bottom-right corner of a matrix. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([[5]]) 5 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 Args: matrix: List[List[int]]: 2D list representing the matrix. Returns: int: smallest possible sum of elements on the path.","solution":"def min_path_sum(matrix): Returns the smallest possible sum of elements on the path from the top-left to the bottom-right corner of a matrix. n = len(matrix) # Create a dp array to store the minimum path sum until each cell dp = [[0] * n for _ in range(n)] # Initialize the first cell with the value from the matrix dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j] return dp[n - 1][n - 1] # Example usage matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(matrix)) # Output should be 7"},{"question":"def min_assembly_lines(n: int, capacities: List[int], m: int, orders: List[Tuple[int, int]]) -> int: Determine the minimum number of assembly lines needed to fulfill all orders or return -1 if it is impossible to satisfy all the orders given the maximum capacities of the assembly lines. Args: n (int): Number of assembly lines. capacities (List[int]): List of maximum products each line can produce. m (int): Number of orders. orders (List[Tuple[int, int]]): List of orders, each tuple (product type, required quantity). Returns: int: Minimum number of assembly lines needed, or -1 if impossible. pass # Unit tests def test_example_1(): n = 3 capacities = [8, 10, 15] m = 2 orders = [(1, 7), (2, 20)] assert min_assembly_lines(n, capacities, m, orders) == 2 def test_unsatisfiable_order(): n = 2 capacities = [5, 5] m = 1 orders = [(1, 15)] assert min_assembly_lines(n, capacities, m, orders) == -1 def test_single_assembly_line_enough(): n = 3 capacities = [10, 10, 10] m = 3 orders = [(1, 5), (2, 7), (3, 8)] assert min_assembly_lines(n, capacities, m, orders) == 1 def test_exact_match_for_capacities(): n = 3 capacities = [10, 10, 10] m = 1 orders = [(1, 20)] assert min_assembly_lines(n, capacities, m, orders) == 2 def test_multiple_orders_same_product(): n = 4 capacities = [10, 10, 10, 10] m = 3 orders = [(1, 5), (1, 5), (1, 5)] assert min_assembly_lines(n, capacities, m, orders) == 2","solution":"def min_assembly_lines(n, capacities, m, orders): Determine the minimum number of assembly lines needed to fulfill all orders or return -1 if it is impossible to satisfy all the orders given the maximum capacities of the assembly lines. Parameters: n (int): Number of assembly lines. capacities (list of int): List of maximum products each line can produce. m (int): Number of orders. orders (list of tuple): List of orders, each tuple (product type, required quantity). Returns: int: Minimum number of assembly lines needed, or -1 if impossible. from heapq import nlargest # Step 1: Group orders by product type and sum their quantities demand = [0] * n for p, r in orders: demand[p-1] += r # p-1 because product type is 1-indexed # Step 2: Sort the capacities in descending order sorted_capacities = sorted(capacities, reverse=True) # Step 3: Try to fulfill each product demand with the largest available assembly lines num_lines_needed = 0 for d in demand: if d > 0: # select the minimum number of largest capacities that sum up to at least \`d\` total_capacity = 0 lines_used = 0 for cap in sorted_capacities: total_capacity += cap lines_used += 1 if total_capacity >= d: break if total_capacity < d: return -1 num_lines_needed = max(num_lines_needed, lines_used) return num_lines_needed"},{"question":"def is_contiguous_subarray_sum(a: List[int], n: int, k: int, x: int) -> str: Determines whether there exists a contiguous subarray of length k whose sum of elements is equal to x. :param a: list of integers :param n: length of the array :param k: length of the subarray :param x: target sum :return: \\"YES\\" if such subarray exists, otherwise \\"NO\\" pass from solution import is_contiguous_subarray_sum def test_example1(): assert is_contiguous_subarray_sum([1, 2, 3, 4, 5], 5, 3, 6) == \\"YES\\" def test_example2(): assert is_contiguous_subarray_sum([1, 2, 3, 4, 5], 5, 2, 8) == \\"NO\\" def test_single_element_match(): assert is_contiguous_subarray_sum([5], 1, 1, 5) == \\"YES\\" def test_single_element_no_match(): assert is_contiguous_subarray_sum([5], 1, 1, 10) == \\"NO\\" def test_large_sum(): assert is_contiguous_subarray_sum([1000, 2000, 3000, 4000, 5000], 5, 2, 9000) == \\"YES\\" def test_no_subarray_found(): assert is_contiguous_subarray_sum([1, 2, 3, 4, 5], 5, 3, 15) == \\"NO\\" def test_subarray_at_end(): assert is_contiguous_subarray_sum([1, 2, 3, 4, 6], 5, 2, 10) == \\"YES\\" def test_subarray_at_start(): assert is_contiguous_subarray_sum([6, 4, 2, 1, 0], 5, 2, 10) == \\"YES\\"","solution":"def is_contiguous_subarray_sum(a, n, k, x): Determines whether there exists a contiguous subarray of length k whose sum of elements is equal to x. :param a: list of integers :param n: length of the array :param k: length of the subarray :param x: target sum :return: \\"YES\\" if such subarray exists, otherwise \\"NO\\" # Compute the sum of the first k elements current_sum = sum(a[:k]) if current_sum == x: return \\"YES\\" # Use sliding window technique for i in range(k, n): current_sum += a[i] - a[i - k] if current_sum == x: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def max_unique_roller_coasters(n: int, m: int, paths: List[Tuple[int, int]], s: int) -> int: Determine the maximum number of unique roller coasters that can be visited starting from a given roller coaster. >>> max_unique_roller_coasters(5, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)], 1) 4 >>> max_unique_roller_coasters(4, 0, [], 2) 1 >>> max_unique_roller_coasters(1, 0, [], 1) 1 from solution import max_unique_roller_coasters def test_example_case(): n = 5 m = 6 paths = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)] s = 1 assert max_unique_roller_coasters(n, m, paths, s) == 4 def test_no_paths(): n = 4 m = 0 paths = [] s = 2 assert max_unique_roller_coasters(n, m, paths, s) == 1 def test_single_node(): n = 1 m = 0 paths = [] s = 1 assert max_unique_roller_coasters(n, m, paths, s) == 1 def test_unconnected_nodes(): n = 3 m = 1 paths = [(1, 2)] s = 3 assert max_unique_roller_coasters(n, m, paths, s) == 1 def test_multiple_paths(): n = 6 m = 7 paths = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)] s = 1 assert max_unique_roller_coasters(n, m, paths, s) == 5","solution":"def max_unique_roller_coasters(n, m, paths, s): from collections import defaultdict, deque graph = defaultdict(list) for ai, bi in paths: graph[ai].append(bi) def bfs(start): max_count = 0 queue = deque([(start, {start})]) while queue: current, visited = queue.popleft() max_count = max(max_count, len(visited)) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, visited | {neighbor})) return max_count return bfs(s) # Example usage: n = 5 m = 6 paths = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)] s = 1 print(max_unique_roller_coasters(n, m, paths, s)) # Output: 4"},{"question":"from typing import List def count_teams(n: int, k: int, skill_levels: List[int]) -> int: Alice is organizing a coding competition and has an array containing the skill levels of the participants. She wants to form teams in such a way that each team consists of exactly two participants whose combined skill level is exactly divisible by a given integer k. Your task is to find out the number of such teams that can be formed from the given array. Each participant can only be part of one team. >>> count_teams(5, 3, [1, 3, 5, 7, 9]) 2 >>> count_teams(6, 5, [1, 2, 3, 4, 5, 6]) 2 >>> count_teams(8, 4, [1, 2, 3, 4, 5, 6, 7, 8]) 4 >>> count_teams(3, 2, [1, 2, 3]) 1 >>> count_teams(7, 5, [10, 15, 20, 25, 30, 35, 40]) 3","solution":"def count_teams(n, k, skill_levels): # Helper to count combinations for a given modulo from collections import defaultdict # Dictionary to store remainders remainder_count = defaultdict(int) # Fill the remainder counts for skill in skill_levels: remainder = skill % k remainder_count[remainder] += 1 teams = 0 # Pairs of i and k-i where i = 0 to k/2 for i in range(k // 2 + 1): if i == 0 or i == k / 2: # Special case for remainder 0 or when k is even and i = k/2 teams += remainder_count[i] // 2 else: teams += min(remainder_count[i], remainder_count[k - i]) return teams"},{"question":"def min_additional_roads_to_connect(n, m, edges): Find the minimum total length of roads needed to be added to ensure all intersections are connected. >>> min_additional_roads_to_connect(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 0 >>> min_additional_roads_to_connect(4, 2, [(1, 2, 5), (3, 4, 7)]) 12 >>> min_additional_roads_to_connect(5, 7, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (4, 5, 1), (4, 2, 2), (3, 5, 5), (2, 5, 3)]) 0 >>> min_additional_roads_to_connect(5, 2, [(1, 2, 10), (3, 4, 15)]) 25","solution":"def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_additional_roads_to_connect(n, m, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges.sort(key=lambda x: x[2]) result = 0 connected_components = n for u, v, w in edges: u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: result += w union(parent, rank, x, y) connected_components -= 1 if connected_components == 1: return 0 mst_weight = 0 for i in range(n): parent[i] = i rank[i] = 0 for u, v, w in edges: u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: mst_weight += w connected_components -=1 if connected_components == 1: break union(parent, rank, x, y) return result"},{"question":"def max_books_on_shelf(n: int, W: int, widths: List[int]) -> Tuple[int, int]: Determines the maximum number of books that can be placed on the shelf and their total width. Parameters: n (int): number of books W (int): maximum width of the shelf widths (list of int): widths of the books Returns: tuple: (max number of books, total width of those books) >>> max_books_on_shelf(5, 10, [3, 1, 4, 2, 5]) (4, 10) >>> max_books_on_shelf(5, 20, [2, 4, 5, 3, 6]) (5, 20) >>> max_books_on_shelf(3, 1, [2, 3, 4]) (0, 0) >>> max_books_on_shelf(4, 3, [3, 4, 5, 6]) (1, 3) >>> max_books_on_shelf(6, 10, [5, 5, 3, 4, 2, 1]) (4, 10) >>> max_books_on_shelf(3, 1000000000, [100000000, 200000000, 300000000]) (3, 600000000) >>> max_books_on_shelf(4, 12, [3, 3, 3, 3]) (4, 12)","solution":"def max_books_on_shelf(n, W, widths): Returns the maximum number of books that can be placed on the shelf and their total width. Parameters: n (int): number of books W (int): maximum width of the shelf widths (list of int): widths of the books Returns: tuple: (max number of books, total width of those books) widths.sort() total_width = 0 book_count = 0 for width in widths: if total_width + width <= W: total_width += width book_count += 1 else: break return book_count, total_width"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Check if a number is a prime number. pass def prime_pairs_prefix_sequence(n: int) -> List[int]: Construct a sequence of length \`n\` such that the sum of any two adjacent elements is a prime number. >>> prime_pairs_prefix_sequence(2) [2, 3] >>> prime_pairs_prefix_sequence(3) [3, 3, 3] pass def solve(t: int, cases: List[int]) -> List: For each test case, determine if a sequence exists where the sum of any two adjacent elements is a prime number. Returns a list where each element is \\"YES\\" or \\"NO\\" and sequences, if they exist. >>> solve(3, [2, 3, 4]) [\\"YES\\", [2, 3], \\"YES\\", [3, 3, 3], \\"YES\\", [3, 2, 3, 2]] pass def output_results(results: List): Prints the results in the required format. pass","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_pairs_prefix_sequence(n): if n % 2 == 0: seq = [] start = 3 if n % 4 == 0 else 2 for i in range(n): seq.append(start) start = 3 if start == 2 else 2 return seq else: return [3] * n def solve(t, cases): results = [] for n in cases: if n == 1: results.append(\\"NO\\") else: results.append(\\"YES\\") results.append(prime_pairs_prefix_sequence(n)) return results # Example usage and conversion function: def output_results(results): for result in results: if result == \\"YES\\" or result == \\"NO\\": print(result) else: print(\\" \\".join(map(str, result)))"},{"question":"from typing import List def is_palindrome(s: str) -> bool: return s == s[::-1] def can_be_palindrome_by_removing_one_char(s: str) -> str: left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character either from left or right if is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1]): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Given a number of test cases, determine if each string can be converted into a palindrome by removing at most one character. >>> process_test_cases(3, [\\"abca\\", \\"racecar\\", \\"abc\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"madam\\", \\"aabaa\\"]) [\\"YES\\", \\"YES\\"] results = [] for s in test_cases: results.append(can_be_palindrome_by_removing_one_char(s)) return results","solution":"def is_palindrome(s: str) -> bool: return s == s[::-1] def can_be_palindrome_by_removing_one_char(s: str) -> str: left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character either from left or right if is_palindrome(s[left:right]) or is_palindrome(s[left+1:right+1]): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\" def process_test_cases(t: int, test_cases: list) -> list: results = [] for s in test_cases: results.append(can_be_palindrome_by_removing_one_char(s)) return results"},{"question":"def can_create_garden(n: int, m: int, k: int) -> str: Determines if it is possible to create a garden that satisfies the rules. Returns 'YES' if possible, 'NO' otherwise. Parameters: n (int): number of rows in the garden m (int): number of columns in the garden k (int): number of unique flower species Returns: str: 'YES' if the garden can be created, 'NO' otherwise >>> can_create_garden(2, 3, 2) 'YES' >>> can_create_garden(2, 3, 4) 'NO'","solution":"def can_create_garden(n, m, k): Determines if it is possible to create a garden that satisfies the rules. Returns 'YES' if possible, 'NO' otherwise. Parameters: n (int): number of rows in the garden m (int): number of columns in the garden k (int): number of unique flower species Returns: str: 'YES' if the garden can be created, 'NO' otherwise if k > n or k > m: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_turns_to_cover_grid(test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of turns needed to completely cover the given grids. Args: test_cases: List of tuples containing the dimensions of the rectangular grids. Returns: List of integers where each integer represents the minimum number of turns for the corresponding grid. >>> minimum_turns_to_cover_grid([(3, 3), (4, 5), (6, 7)]) [2, 2, 4] >>> minimum_turns_to_cover_grid([(1, 1), (2, 2), (5, 5)]) [1, 1, 2] from typing import List, Tuple def test_minimum_turns_to_cover_grid(): test_cases = [ (3, 3), # 3x3 grid (4, 5), # 4x5 grid (6, 7), # 6x7 grid (1, 1), # 1x1 grid (2, 2), # 2x2 grid (5, 5) # 5x5 grid ] expected_results = [ 2, # Minimum turns for 3x3 grid 2, # Minimum turns for 4x5 grid 4, # Minimum turns for 6x7 grid 1, # Minimum turns for 1x1 grid 1, # Minimum turns for 2x2 grid 2 # Minimum turns for 5x5 grid ] results = minimum_turns_to_cover_grid(test_cases) assert results == expected_results, f\\"expected {expected_results}, but got {results}\\"","solution":"def minimum_turns_to_cover_grid(test_cases): results = [] for n, m in test_cases: # Calculate the number of turns result = (n * m + 1) // 2 results.append(result) return results"},{"question":"def min_roads_to_repair(N: int, M: int, roads: List[Tuple[int, int]]) -> int: Compute the minimum number of roads that need to be repaired to ensure all houses are connected. >>> min_roads_to_repair(5, 2, [(1, 2), (2, 3)]) 2 >>> min_roads_to_repair(5, 0, []) 4 >>> min_roads_to_repair(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> min_roads_to_repair(1, 0, []) 0 >>> min_roads_to_repair(6, 3, [(1, 2), (3, 4), (5, 6)]) 2","solution":"def find_set(parent, u): if parent[u] != u: parent[u] = find_set(parent, parent[u]) return parent[u] def union_sets(parent, rank, u, v): root_u = find_set(parent, u) root_v = find_set(parent, v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 def min_roads_to_repair(N, M, roads): parent = list(range(N + 1)) rank = [0] * (N + 1) for a, b in roads: union_sets(parent, rank, a, b) root_set = set(find_set(parent, i) for i in range(1, N + 1)) return len(root_set) - 1"},{"question":"def apply_discounts(costs: List[int], discount: int) -> List[int]: Applies the given percentage discount to every second item in the list starting with the first item. Parameters: costs : list of int List of item costs. discount : int Percentage discount to be applied. Returns: list of int List of adjusted item costs. >>> apply_discounts([100, 200, 300, 400, 500], 10) [90, 200, 270, 400, 450] >>> apply_discounts([100, 200, 300], 0) [100, 200, 300] >>> apply_discounts([100, 200, 300, 400, 500], 50) [50, 200, 150, 400, 250] >>> apply_discounts([100], 25) [75] >>> apply_discounts([100, 100, 100, 100], 20) [80, 100, 80, 100] >>> apply_discounts([1000000, 200000, 300000, 400000], 99) [10000, 200000, 3000, 400000] >>> apply_discounts([], 10) []","solution":"def apply_discounts(costs, discount): Applies the given percentage discount to every second item in the list starting with the first item. Parameters: costs (list of int): List of item costs. discount (int): Percentage discount to be applied. Returns: list of int: List of adjusted item costs. discounted_costs = [] for i, cost in enumerate(costs): if i % 2 == 0: discounted_cost = cost - (cost * discount // 100) discounted_costs.append(discounted_cost) else: discounted_costs.append(cost) return discounted_costs"},{"question":"def can_be_sorted_by_one_swap(n: int, arr: List[int]) -> str: Determine if the array can be sorted by performing exactly one swap operation. Parameters: n (int): the length of the array arr (list): the elements of the array Returns: str: \\"YES\\" or \\"NO\\" Examples: >>> can_be_sorted_by_one_swap(3, [3, 1, 2]) \\"NO\\" >>> can_be_sorted_by_one_swap(3, [1, 3, 2]) \\"YES\\" >>> can_be_sorted_by_one_swap(4, [4, 1, 3, 2]) \\"NO\\"","solution":"def can_be_sorted_by_one_swap(n, arr): Determine if the array can be sorted by performing exactly one swap operation. Parameters: n (int): the length of the array arr (list): the elements of the array Returns: str: \\"YES\\" or \\"NO\\" sorted_arr = sorted(arr) diff_indices = [] for i in range(n): if arr[i] != sorted_arr[i]: diff_indices.append(i) # If there are exactly two indices where array differs from sorted array if len(diff_indices) == 2: i, j = diff_indices arr[i], arr[j] = arr[j], arr[i] if arr == sorted_arr: return \\"YES\\" return \\"NO\\""},{"question":"def count_distinct_group_substrings(n: int, k: int, C: int, s: str, g: List[int]) -> int: Calculate the number of distinct substrings of length k that can be formed by replacing each character in the string s with its respective group ID. >>> count_distinct_group_substrings(10, 3, 3, \\"abracadabr\\", [1, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 1, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 1, 2]) 7 >>> count_distinct_group_substrings(5, 2, 1, \\"aaaaa\\", [1] * 26) 1 >>> count_distinct_group_substrings(5, 3, 5, \\"abcde\\", [i % 5 + 1 for i in range(26)]) 3 >>> count_distinct_group_substrings(5, 3, 3, \\"abcde\\", [1, 1, 2, 2, 1, 2, 2, 3, 3, 1, 1, 2, 2, 1, 2, 2, 3, 3, 1, 1, 2, 2, 1, 2, 2, 3]) 3 >>> count_distinct_group_substrings(10, 2, 2, \\"ababababab\\", [1, 2] * 13) 2","solution":"def count_distinct_group_substrings(n, k, C, s, g): group_ids = [g[ord(char) - ord('a')] for char in s] seen = set() for i in range(n - k + 1): substring_group = tuple(group_ids[i:i + k]) seen.add(substring_group) return len(seen) # Example n = 10 k = 3 C = 3 s = \\"abracadabr\\" g = [1, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 1, 2, 2, 1, 3, 3, 2, 1, 1, 2, 3, 1, 1, 2] print(count_distinct_group_substrings(n, k, C, s, g)) # 7"},{"question":"def process_operations(operations): Process a list of operations and return the result of each \\"MAX\\" operation. operations: List of strings, where each string is a \\"PUSH x\\", \\"POP\\", or \\"MAX\\" operation. Returns: List of integers representing the result of each \\"MAX\\" operation. >>> process_operations([\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\"]) [3, 2, 1] >>> process_operations([\\"PUSH 5\\", \\"MAX\\"]) [5] >>> process_operations([\\"PUSH 2\\", \\"PUSH 3\\", \\"MAX\\", \\"PUSH 1\\", \\"MAX\\", \\"POP\\", \\"MAX\\"]) [3, 3, 3] >>> process_operations([\\"PUSH 4\\", \\"PUSH 4\\", \\"PUSH 4\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\"]) [4, 4, 4] >>> process_operations([ \\"PUSH 10\\", \\"PUSH 20\\", \\"PUSH 30\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"POP\\", \\"MAX\\", \\"PUSH 15\\", \\"MAX\\" ]) [30, 20, 10, 15]","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): if self.stack: if self.stack[-1] == self.max_stack[-1]: self.max_stack.pop() self.stack.pop() def max(self): if not self.max_stack: return -1 return self.max_stack[-1] def process_operations(operations): max_stack = MaxStack() results = [] for operation in operations: if operation.startswith(\\"PUSH\\"): _, x = operation.split() max_stack.push(int(x)) elif operation == \\"POP\\": max_stack.pop() elif operation == \\"MAX\\": results.append(max_stack.max()) return results"},{"question":"def is_valid_reordering_possible(t: int, test_cases: List[str]) -> List[str]: Determine whether it is possible to reorder the string such that every substring of size 4 in the resulting string contains all the distinct characters of the string given as the input. Args: t (int): The number of test cases. test_cases (List[str]): List of strings containing 'a', 'b', 'c', 'd'. Returns: List[str]: List containing \\"YES\\" or \\"NO\\" for each test case. Examples: >>> is_valid_reordering_possible(1, [\\"abcd\\"]) [\\"YES\\"] >>> is_valid_reordering_possible(1, [\\"aaabcd\\"]) [\\"NO\\"]","solution":"def is_valid_reordering_possible(t, test_cases): res = [] for s in test_cases: count = {char: s.count(char) for char in 'abcd'} if len(s) % 4 == 0 and all(v == len(s) // 4 for v in count.values()): res.append(\\"YES\\") else: res.append(\\"NO\\") return res"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Checks if two strings are anagrams. Args: s1 (str): First string. s2 (str): Second string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"triangle\\", \\"integral\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"pale\\") \\"NO\\"","solution":"def are_anagrams(s1, s2): Checks if two strings are anagrams. Args: s1 (str): First string. s2 (str): Second string. Returns: str: \\"YES\\" if the strings are anagrams, otherwise \\"NO\\". return \\"YES\\" if sorted(s1) == sorted(s2) else \\"NO\\""},{"question":"def min_logs_after_cuts(n: int, h: int, arr: List[int]) -> int: Determines the minimum number of logs after making necessary cuts such that no log exceeds the height h. Parameters: n (int): Number of logs initially. h (int): Maximum allowable height for each log. arr (list of int): Heights of the logs. Returns: int: Minimum number of logs after cuts. >>> min_logs_after_cuts(5, 4, [8, 2, 10, 6, 5]) 10 >>> min_logs_after_cuts(1, 5, [4]) 1 >>> min_logs_after_cuts(1, 5, [15]) 3 >>> min_logs_after_cuts(3, 10, [2, 3, 8]) 3 >>> min_logs_after_cuts(4, 10, [10, 10, 10, 10]) 4 >>> min_logs_after_cuts(2, 3, [10, 15]) 9 >>> min_logs_after_cuts(6, 5, [6, 7, 8, 9, 10, 11]) 13 >>> min_logs_after_cuts(4, 10, [4, 7, 9, 10]) 4 >>> min_logs_after_cuts(1, 1, [1]) 1 >>> min_logs_after_cuts(1, 10000, [10000]) 1","solution":"def min_logs_after_cuts(n, h, arr): Determines the minimum number of logs after making necessary cuts such that no log exceeds the height h. Parameters: n (int): Number of logs initially. h (int): Maximum allowable height for each log. arr (list of int): Heights of the logs. Returns: int: Minimum number of logs after cuts. total_logs = 0 for height in arr: # Calculate the number of logs needed for each given log to fit within the height h total_logs += (height + h - 1) // h # This is equivalent to ceiling(height/h) return total_logs"},{"question":"def min_operations_to_distribute_water(N: int) -> int: Calculate the minimum number of operations needed to ensure that every house can have access to water, starting from any house. >>> min_operations_to_distribute_water(2) 1 >>> min_operations_to_distribute_water(3) 2 >>> min_operations_to_distribute_water(10) 9 >>> min_operations_to_distribute_water(100) 99 >>> min_operations_to_distribute_water(1000) 999 >>> min_operations_to_distribute_water(10**9) 10**9 - 1","solution":"def min_operations_to_distribute_water(N): Calculate the minimum number of operations needed to ensure that every house can have access to water, starting from any house. # In a circle of N houses with each house connected linearly like a ring, # we need to create a simple spanning tree that is not necessarily a cycle. # In this case we need to break the cycle by redirecting (N-1) pipes to ensure there are no cycles. return N - 1"},{"question":"def can_split_equal_sum(arr): Determine if an array can be split into two non-empty parts with equal sum. If it is possible to split the array this way, return \\"YES\\" and the index where to split. Otherwise, return \\"NO\\". >>> can_split_equal_sum([3, 1, 1, 2, 2, 1]) \\"YESn3\\" >>> can_split_equal_sum([1, 2, 3, 4, 5]) \\"NO\\" # Your implementation here from can_split_equal_sum import can_split_equal_sum def test_example_1(): assert can_split_equal_sum([3, 1, 1, 2, 2, 1]) == \\"YESn3\\" def test_example_2(): assert can_split_equal_sum([1, 2, 3, 4, 5]) == \\"NO\\" def test_single_solution_case(): assert can_split_equal_sum([2, 2, 1, 1, 4]) == \\"YESn3\\" def test_odd_sum(): assert can_split_equal_sum([1, 1, 1]) == \\"NO\\" def test_all_elements_same(): assert can_split_equal_sum([1, 1, 1, 1]) == \\"YESn2\\" def test_large_numbers(): assert can_split_equal_sum([10**9, 10**9]) == \\"YESn1\\" def test_no_valid_solution(): assert can_split_equal_sum([5, 5, 2]) == \\"NO\\"","solution":"def can_split_equal_sum(arr): Determine if array can be split into two parts with equal sum. If possible, return \\"YES\\" and the index where to split. Otherwise, return \\"NO\\". total_sum = sum(arr) # If total_sum is odd, we cannot split it into two equal parts if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == target_sum: return f\\"YESn{i + 1}\\" return \\"NO\\""},{"question":"def has_subarray_with_sum_at_least_k(n: int, k: int, a: List[int]) -> str: Determines if there exists a non-empty contiguous subarray with a sum of at least k. :param n: Number of elements in the array. :param k: Threshold value. :param a: List of integers representing the array. :return: \\"YES\\" if there exists a non-empty contiguous subarray with a sum of at least k, otherwise \\"NO\\". >>> has_subarray_with_sum_at_least_k(5, 12, [1, 2, 3, 4, 5]) == \\"YES\\" >>> has_subarray_with_sum_at_least_k(4, 15, [1, 2, 3, 4]) == \\"NO\\" pass from typing import List def test_subarray_exists(): assert has_subarray_with_sum_at_least_k(5, 12, [1, 2, 3, 4, 5]) == \\"YES\\" assert has_subarray_with_sum_at_least_k(6, 15, [1, 2, 3, 4, 5, 4]) == \\"YES\\" assert has_subarray_with_sum_at_least_k(1, 1, [1]) == \\"YES\\" def test_subarray_does_not_exist(): assert has_subarray_with_sum_at_least_k(4, 15, [1, 2, 3, 4]) == \\"NO\\" assert has_subarray_with_sum_at_least_k(5, 16, [1, 2, 3, 4, 5]) == \\"NO\\" assert has_subarray_with_sum_at_least_k(3, 100, [1, 2, 3]) == \\"NO\\" def test_single_element_cases(): assert has_subarray_with_sum_at_least_k(1, 1000, [1000]) == \\"YES\\" assert has_subarray_with_sum_at_least_k(1, 1001, [1000]) == \\"NO\\"","solution":"def has_subarray_with_sum_at_least_k(n, k, a): Determines if there exists a non-empty contiguous subarray with a sum of at least k. :param n: Number of elements in the array. :param k: Threshold value. :param a: List of integers representing the array. :return: \\"YES\\" if there exists a non-empty contiguous subarray with a sum of at least k, otherwise \\"NO\\". for i in range(n): current_sum = 0 for j in range(i, n): current_sum += a[j] if current_sum >= k: return \\"YES\\" return \\"NO\\" # Example Usage: # print(has_subarray_with_sum_at_least_k(5, 12, [1, 2, 3, 4, 5])) # Output: \\"YES\\" # print(has_subarray_with_sum_at_least_k(4, 15, [1, 2, 3, 4])) # Output: \\"NO\\""},{"question":"def min_toggles_required(initial, final): Determine the minimum number of toggles required to get from the initial state to the final state in a 2x2 grid. Parameters: initial (list): Initial state of the 2x2 grid in row-major order. final (list): Desired final state of the 2x2 grid in row-major order. Returns: int: Minimum number of toggles required, or -1 if it's impossible. >>> min_toggles_required([1, 1, 1, 1], [1, 1, 1, 1]) 0 >>> min_toggles_required([0, 0, 0, 0], [0, 0, 0, 0]) 0 >>> min_toggles_required([1, 1, 1, 1], [0, 0, 0, 0]) 4 >>> min_toggles_required([0, 0, 0, 0], [1, 1, 1, 1]) 4 >>> min_toggles_required([1, 0, 0, 1], [1, 0, 0, 0]) 1 >>> min_toggles_required([1, 0, 1, 0], [0, 1, 0, 1]) 4 >>> min_toggles_required([1, 0, 0, 1], [0, 1, 0, 0]) 3 >>> min_toggles_required([1, 0, 0], [0, 1, 0, 0]) -1 >>> min_toggles_required([1, 0, 0, 1], [0, 1, 0]) -1 >>> min_toggles_required([1, 0, 0, 1], [0, 1, 0, 0, 1]) -1","solution":"def min_toggles_required(initial, final): Determine the minimum number of toggles required to get from the initial state to the final state in a 2x2 grid. Parameters: initial (list): Initial state of the 2x2 grid in row-major order. final (list): Desired final state of the 2x2 grid in row-major order. Returns: int: Minimum number of toggles required, or -1 if it's impossible. # Ensure the inputs are two valid 2x2 grids if len(initial) != 4 or len(final) != 4: return -1 # Count the number of toggles needed toggles = 0 for i in range(4): if initial[i] != final[i]: toggles += 1 return toggles # Example usage: initial = [1, 0, 1, 0] final = [0, 1, 0, 1] print(min_toggles_required(initial, final)) # Output: 4"},{"question":"def contains_all_numbers(M: List[List[int]], n: int, m: int, k: int) -> str: Returns \\"YES\\" if there exists a submatrix in M which contains all integers from 1 to k, otherwise returns \\"NO\\". >>> contains_all_numbers([ [1, 2, 3, 4], [2, 5, 6, 1], [3, 4, 2, 1] ], 3, 4, 5) \\"YES\\" >>> contains_all_numbers([ [3, 4, 6], [1, 2, 3, 4], [2, 5, 6, 1], [3, 4, 2, 1] ], 4, 3, 6) \\"YES\\" >>> contains_all_numbers([ [2, 2, 4], [1, 2], [3, 4] ], 3, 3, 5) \\"NO\\" pass","solution":"def contains_all_numbers(M, n, m, k): Returns \\"YES\\" if there exists a submatrix in M which contains all integers from 1 to k, otherwise returns \\"NO\\". num_set = set(range(1, k + 1)) numbers_found = set() for i in range(n): for j in range(m): if M[i][j] in num_set: numbers_found.add(M[i][j]) if numbers_found == num_set: return \\"YES\\" return \\"NO\\" def solve(matrix): first_line = matrix[0] n, m, k = int(first_line[0]), int(first_line[1]), int(first_line[2]) M = [list(map(int, matrix[i + 1])) for i in range(n)] return contains_all_numbers(M, n, m, k)"},{"question":"def longest_common_subsequence(S1: List[str], S2: List[str]) -> int: Determine the length of the longest common subsequence (LCS) between two given sequences. Parameters: S1 (List[str]): The first sequence. S2 (List[str]): The second sequence. Returns: int: The length of the longest common subsequence. >>> longest_common_subsequence([\\"apple\\", \\"orange\\", \\"banana\\", \\"grape\\"], [\\"banana\\", \\"apple\\", \\"grape\\", \\"strawberry\\", \\"orange\\"]) 2 >>> longest_common_subsequence([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], [\\"a\\", \\"c\\", \\"e\\", \\"d\\", \\"b\\"]) 3 pass","solution":"def longest_common_subsequence(S1, S2): n = len(S1) m = len(S2) # Create a 2D list to store lengths of LCS dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill dp array for i in range(1, n + 1): for j in range(1, m + 1): if S1[i - 1] == S2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def process_queries(queries: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[int]: Determine the number of distinct paths from the top-left corner of the grid to the bottom-right corner for a list of queries, avoiding blocked cells. >>> process_queries([ (3, 3, 1, [(2, 2)]), (3, 3, 2, [(2, 2), (2, 3)]) ]) [2, 1] import unittest class TestProcessQueries(unittest.TestCase): def test_single_query_single_blocked_cell(self): queries = [ (3, 3, 1, [(2, 2)]) ] result = process_queries(queries) self.assertEqual(result, [2]) def test_single_query_multiple_blocked_cells(self): queries = [ (3, 3, 2, [(2, 2), (2, 3)]) ] result = process_queries(queries) self.assertEqual(result, [1]) def test_multiple_queries(self): queries = [ (3, 3, 1, [(2, 2)]), (3, 3, 2, [(2, 2), (2, 3)]) ] result = process_queries(queries) self.assertEqual(result, [2, 1]) def test_no_blocked_cells(self): queries = [ (2, 2, 0, []) ] result = process_queries(queries) self.assertEqual(result, [2]) def test_all_blocked_except_start(self): queries = [ (3, 3, 8, [(1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2)]) ] result = process_queries(queries) self.assertEqual(result, [0]) def test_no_path_due_to_start_blocked(self): queries = [ (3, 3, 1, [(1, 1)]) ] result = process_queries(queries) self.assertEqual(result, [0]) if __name__ == '__main__': unittest.main()","solution":"MOD = 10**9 + 7 def number_of_paths(n, m, blocked_cells): # Create a 2D dp array to store the number of ways to reach each cell dp = [[0] * m for _ in range(n)] # If the starting cell is blocked, there is no path if (1, 1) in blocked_cells: return 0 # Initialize the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if (i+1, j+1) in blocked_cells: dp[i][j] = 0 # Blocked cells will have 0 paths else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1] def process_queries(queries): results = [] for query in queries: n, m, k, blocked_cells = query results.append(number_of_paths(n, m, blocked_cells)) return results"},{"question":"def equalize_water_jugs(n: int, m: int, water_amounts: List[int]) -> List[str]: Equalize the amount of water in all the jugs by performing exactly m operations. In each operation, you can choose one jug and pour water from it to the adjacent left or right jug. Args: n (int): The number of jugs. m (int): The number of operations. water_amounts (List[int]): The initial amount of water in each jug. Returns: List[str]: The sequence of operations in the form of \\"index direction\\". >>> equalize_water_jugs(5, 4, [2, 6, 4, 2, 8]) [\\"2 L\\", \\"5 L\\", \\"4 L\\", \\"3 R\\"]","solution":"def equalize_water_jugs(n, m, water_amounts): operations = [] # Perform m operations for i in range(m): if i % 2 == 0: # From the second jug to the first jug if possible if n > 1: operations.append(f\\"2 L\\") water_amounts[0] += water_amounts[1] water_amounts[1] = 0 else: # From the last jug to the second-to-last jug if possible if n > 1: operations.append(f\\"{n} L\\") water_amounts[-2] += water_amounts[-1] water_amounts[-1] = 0 return operations # Example execution if __name__ == \\"__main__\\": n, m = 5, 4 water_amounts = [2, 6, 4, 2, 8] operations = equalize_water_jugs(n, m, water_amounts) print(len(operations)) for op in operations: print(op)"},{"question":"def min_difference(arr: List[int]) -> int: Returns the minimum possible difference between the sums of two non-empty subsequences of the array. >>> min_difference([1, 6]) == 5 >>> min_difference([5, 10, 15]) == 0 >>> min_difference([7, 3]) == 4 >>> min_difference([100, 50, 1]) == 49 >>> min_difference([5, 5, 5, 5, 5, 5]) == 0 >>> min_difference([100, 1, 50, 1, 50, 1]) == 1","solution":"def min_difference(arr): Returns the minimum possible difference between the sums of two non-empty subsequences of the array. total_sum = sum(arr) n = len(arr) half_sum = total_sum // 2 # Initialize the DP table with False dp = [False] * (half_sum + 1) dp[0] = True # Use dynamic programming to find the subset with sum closest to half_sum for num in arr: for j in range(half_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] closest_sum = 0 for i in range(half_sum, -1, -1): if dp[i]: closest_sum = i break return total_sum - 2 * closest_sum"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple, Dict def min_spanning_tree_prims(n: int, edges: List[Tuple[int, int, int]], exclude_edge: Tuple[int, int, int] = None) -> Tuple[Dict[int, List[int]], int]: Function to find the minimum spanning tree using Prim's algorithm, optionally excluding a specific edge. :param n: Number of vertices :param edges: List of edges :param exclude_edge: Optional edge to exclude :return: Minimum edges and total weight def minimum_guiding_signs(n: int, edges: List[Tuple[int, int, int]]) -> int: Function to calculate the minimum number of guiding signs needed if the longest edge is closed. :param n: Number of vertices :param edges: List of edges :return: Minimum number of guiding signs >>> edges = [(1, 2, 1), (1, 3, 2), (2, 3, 4), (2, 4, 3), (3, 4, 5)] >>> minimum_guiding_signs(4, edges) 3 def test_min_spanning_tree_prims(): edges = [(1, 2, 1), (1, 3, 2), (2, 3, 4), (2, 4, 3), (3, 4, 5)] min_edges, total_weight = min_spanning_tree_prims(4, edges.copy(), exclude_edge=(3, 4, 5)) assert total_weight == 6 assert len(min_edges) == 4 def test_minimum_guiding_signs(): edges = [ (1, 2, 1), (1, 3, 2), (2, 3, 4), (2, 4, 3), (3, 4, 5) ] assert minimum_guiding_signs(4, edges) == 3 edges = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 75), (2, 4, 30), (3, 4, 40) ] assert minimum_guiding_signs(4, edges) == 3 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 5), (2, 4, 1) ] assert minimum_guiding_signs(5, edges) == 4 if __name__ == \\"__main__\\": test_min_spanning_tree_prims() test_minimum_guiding_signs() print(\\"All tests passed!\\")","solution":"import heapq from collections import defaultdict def min_spanning_tree_prims(n, edges, exclude_edge=None): if exclude_edge: edges.remove(exclude_edge) # Priority queue to select the smallest weight edge pq = [] for u, v, d in edges: heapq.heappush(pq, (d, u, v)) # To track visited vertices visited = [False] * (n + 1) min_edges = defaultdict(list) total_weight = 0 # Add initial vertex (e.g., vertex 1) start = 1 visited[start] = True num_edges_in_mst = 0 included_edges = [] while pq and num_edges_in_mst < n - 1: d, u, v = heapq.heappop(pq) if visited[u] and visited[v]: continue if not visited[u]: u, v = v, u visited[v] = True total_weight += d included_edges.append((u, v, d)) min_edges[u].append(v) min_edges[v].append(u) num_edges_in_mst += 1 for next_u, next_v, next_d in edges: if (next_u == v and not visited[next_v]) or (next_v == v and not visited[next_u]): heapq.heappush(pq, (next_d, next_u, next_v)) return min_edges, total_weight def minimum_guiding_signs(n, edges): # Step 1: Find the edge with the maximum distance max_dist_edge = max(edges, key=lambda x: x[2]) # Step 2: Find minimum spanning tree without the max distance edge min_edges, _ = min_spanning_tree_prims(n, edges.copy(), max_dist_edge) # Step 3: Calculate the number of guiding signs num_signs = 0 for vertex in min_edges: num_signs += len(min_edges[vertex]) # Since each edge is counted twice return num_signs // 2 def process_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [(int(data[i*3+2]), int(data[i*3+3]), int(data[i*3+4])) for i in range(m)] result = minimum_guiding_signs(n, edges) print(result)"},{"question":"def minimum_rituals(n: int, houses: str) -> int: Given the number of houses and their arrangements with villagers and ghosts, returns the minimum number of rituals needed to neutralize all ghosts. >>> minimum_rituals(4, 'VGGV') 1 >>> minimum_rituals(5, 'GVGVG') 3 >>> minimum_rituals(3, 'VVV') 0 >>> minimum_rituals(3, 'GGG') 1 >>> minimum_rituals(1, 'G') 1 >>> minimum_rituals(1, 'V') 0 >>> minimum_rituals(6, 'VGVGVV') 2 >>> minimum_rituals(7, 'GGGVGGG') 2","solution":"def minimum_rituals(n, houses): Given the number of houses and their arrangements with villagers and ghosts, returns the minimum number of rituals needed to neutralize all ghosts. # Initialize the count of rituals to 0 rituals = 0 # Iterate through the houses to count contiguous segments of 'G' i = 0 while i < n: if houses[i] == 'G': rituals += 1 while i < n and houses[i] == 'G': i += 1 else: i += 1 return rituals"},{"question":"def can_form_palindrome(s: str) -> str: Returns 'YES' if it is possible to rearrange the letters of the string \`s\` to form a palindrome, otherwise 'NO'. >>> can_form_palindrome(\\"aabb\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO' >>> can_form_palindrome(\\"aabbc\\") 'YES'","solution":"def can_form_palindrome(s): Returns 'YES' if it is possible to rearrange the letters of the string \`s\` to form a palindrome, otherwise 'NO'. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def min_difference_partition(n: int, nums: List[int]) -> int: Returns the minimum possible absolute difference of the sums of two non-empty subsets. >>> min_difference_partition(4, [1, 2, 3, 4]) 0 >>> min_difference_partition(2, [1, 3]) 2 >>> min_difference_partition(3, [1, 2, 10]) 7 >>> min_difference_partition(4, [5, 5, 5, 5]) 0 >>> min_difference_partition(4, [1, 1, 3, 4]) 1 >>> min_difference_partition(4, [2, 2, 2, 1000]) 994","solution":"from itertools import combinations def min_difference_partition(n, nums): Returns the minimum possible absolute difference of the sums of two non-empty subsets. total_sum = sum(nums) min_diff = float('inf') # Iterate over all subsets having at least one element but not all elements for i in range(1, n // 2 + 1): for subset in combinations(nums, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum diff = abs(subset_sum - other_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"def max_non_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be completed. >>> max_non_overlapping_tasks(5, [(1, 4), (2, 3), (3, 5), (7, 9), (5, 8)]) == 3 >>> max_non_overlapping_tasks(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_tasks(3, [(1, 5), (2, 6), (3, 7)]) == 1 >>> max_non_overlapping_tasks(1, [(1, 2)]) == 1 >>> max_non_overlapping_tasks(3, [(0, 1000000000), (500000000, 1000000000), (629, 802)]) == 2 >>> max_non_overlapping_tasks(4, [(1, 5), (5, 8), (4, 6), (7, 8)]) == 2","solution":"def max_non_overlapping_tasks(n, tasks): Returns the maximum number of non-overlapping tasks that can be completed. # Sort tasks based on their end time sorted_tasks = sorted(tasks, key=lambda x: x[1]) max_tasks = 0 last_end_time = 0 for task in sorted_tasks: if task[0] >= last_end_time: max_tasks += 1 last_end_time = task[1] return max_tasks"},{"question":"def calculate_weights(t: int, test_cases: List[List[Tuple[int, int]]]) -> List[Tuple[int, int]]: Calculate the minimum and maximum possible weight of ingredients required for each recipe. Args: t: The number of test cases. test_cases: A list of test cases, where each test case is a list of tuples. Each tuple contains two integers representing the minimum and maximum possible weight of an ingredient. Returns: A list of tuples. Each tuple contains two integers representing the minimum and maximum possible weight for a recipe. >>> calculate_weights(2, [[(100, 150), (200, 250), (50, 100)], [(300, 400), (100, 200), (150, 250), (200, 300)]]) [(350, 500), (750, 1150)] pass def parse_input(input_str: str) -> Tuple[int, List[List[Tuple[int, int]]]]: Parse the input string into the number of test cases and a list of test cases. Args: input_str: The input string containing the number of test cases followed by the details of each test case. Returns: A tuple containing an integer and a list of test cases. Each test case is a list of tuples. >>> input_str = \\"2n3n100 150n200 250n50 100n4n300 400n100 200n150 250n200 300n\\" >>> parse_input(input_str) (2, [[(100, 150), (200, 250), (50, 100)], [(300, 400), (100, 200), (150, 250), (200, 300)]]) pass def format_output(result: List[Tuple[int, int]]) -> str: Format the result list of tuples into a string for output. Args: result: A list of tuples where each tuple contains the minimum and maximum possible weight. Returns: A string formatted for output. >>> result = [(350, 500), (750, 1150)] >>> format_output(result) \\"350 500n750 1150\\" pass","solution":"def calculate_weights(t, test_cases): result = [] for case in test_cases: min_weight = 0 max_weight = 0 for li, ui in case: min_weight += li max_weight += ui result.append((min_weight, max_weight)) return result def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(lines[index]) index += 1 case = [] for _ in range(n): li, ui = map(int, lines[index].split()) case.append((li, ui)) index += 1 test_cases.append(case) return t, test_cases def format_output(result): return \\"n\\".join(f\\"{min_weight} {max_weight}\\" for min_weight, max_weight in result)"},{"question":"from collections import deque, defaultdict def shortest_path_from_city(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], int]]) -> List[List[int]]: Determine the shortest path from a given starting city to all other cities in multiple test cases. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]], int]]): A list of tuples containing - The number of vertices (n) and edges (m). - A list of tuples (u, v) indicating a directed edge from vertex u to vertex v. - The starting city (s). Returns: List[List[int]]: A list where each element is a list of distances from the starting city to every other city for each test case. Example: >>> t = 2 >>> test_cases = [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1), (3, 2, [(1, 2), (2, 3)], 2)] >>> shortest_path_from_city(t, test_cases) [[0, 1, 2, -1], [-1, 0, 1]] pass def convert_input(input_str: str) -> Tuple[int, List[Tuple[int, int, List[Tuple[int, int]], int]]]: Converts the input string into a format that the function \`shortest_path_from_city\` can use. Args: input_str (str): The raw input string. Returns: Tuple[int, List[Tuple[int, int, List[Tuple[int, int]], int]]]: Processed test cases suitable for the main function. Example: >>> input_str = \\"2n4 4n1 2n2 3n3 4n4 1n1n3 2n1 2n2 3n2\\" >>> convert_input(input_str) (2, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1), (3, 2, [(1, 2), (2, 3)], 2)]) pass def format_output(results: List[List[int]]) -> str: Formats the output for each test case. Args: results (List[List[int]]): The results list from the function \`shortest_path_from_city\`. Returns: str: A string formatted for the output. Example: >>> results = [[0, 1, 2, -1], [-1, 0, 1]] >>> format_output(results) \\"0 1 2 -1n-1 0 1\\" pass","solution":"from collections import deque, defaultdict def shortest_path_from_city(t, test_cases): results = [] for case in test_cases: n, m, edges, s = case graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Initialize distances distances = [-1] * n distances[s - 1] = 0 # BFS queue = deque([s]) while queue: current = queue.popleft() current_distance = distances[current - 1] for neighbor in graph[current]: if distances[neighbor - 1] == -1: distances[neighbor - 1] = current_distance + 1 queue.append(neighbor) results.append(distances) return results def convert_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) edges = [] for i in range(m): u, v = map(int, lines[index + 1 + i].split()) edges.append((u, v)) s = int(lines[index + 1 + m]) test_cases.append((n, m, edges, s)) index += 2 + m return t, test_cases def format_output(results): output_str = 'n'.join(' '.join(map(str, res)) for res in results) return output_str"},{"question":"from typing import List, Tuple def change_plants(n: int, m: int, plants: List[int], changes: List[Tuple[int, int, int]]) -> List[int]: Function to change the type of plants in the given garden based on changes. :param n: int - Number of pots. :param m: int - Number of changes. :param plants: List[int] - Initial types of plants in the pots. :param changes: List[Tuple[int, int, int]] - List of changes where each change is a tuple (li, ri, ki). :return: List[int] - Final types of plants in the pots after all changes. # Write your code here def test_example_case(): n = 6 m = 3 plants = [1, 2, 2, 3, 3, 4] changes = [(1, 3, 5), (2, 4, 6), (5, 6, 7)] assert change_plants(n, m, plants, changes) == [5, 6, 6, 6, 7, 7] def test_no_change(): n = 5 m = 0 plants = [1, 2, 3, 4, 5] changes = [] assert change_plants(n, m, plants, changes) == [1, 2, 3, 4, 5] def test_single_pot_change(): n = 4 m = 1 plants = [7, 8, 9, 10] changes = [(2, 2, 5)] assert change_plants(n, m, plants, changes) == [7, 5, 9, 10] def test_full_range_change(): n = 3 m = 1 plants = [1, 1, 1] changes = [(1, 3, 2)] assert change_plants(n, m, plants, changes) == [2, 2, 2] def test_multiple_changes_same_segment(): n = 4 m = 2 plants = [3, 4, 5, 7] changes = [(1, 2, 6), (1, 2, 8)] assert change_plants(n, m, plants, changes) == [8, 8, 5, 7]","solution":"def change_plants(n, m, plants, changes): Function to change the type of plants in the given garden based on changes. :param n: int - Number of pots. :param m: int - Number of changes. :param plants: List[int] - Initial types of plants in the pots. :param changes: List[Tuple[int, int, int]] - List of changes where each change is a tuple (li, ri, ki). :return: List[int] - Final types of plants in the pots after all changes. for li, ri, ki in changes: for i in range(li - 1, ri): plants[i] = ki return plants"},{"question":"def max_gold_coins(m: int, n: int, grid: List[List[int]]) -> int: Returns the maximum number of gold coins that can be collected on the way from the top-left corner to the bottom-right corner of the grid by moving only right or down. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the grid with gold coins. Returns: int: Maximum number of gold coins collected. Examples: >>> max_gold_coins(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1]]) 12 >>> max_gold_coins(1, 1, [ ... [10]]) 10 >>> max_gold_coins(4, 4, [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7]]) 28 >>> max_gold_coins(2, 2, [ ... [1000, 1000], ... [1000, 1000]]) 3000 >>> max_gold_coins(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 1","solution":"def max_gold_coins(m, n, grid): Returns the maximum number of gold coins that can be collected on the way from the top-left corner to the bottom-right corner of the grid by moving only right or down. # Create a dp array to store the max coins collected until each cell dp = [[0] * n for _ in range(m)] # Initialize the starting cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from the top) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner will have the max coins collectible return dp[m - 1][n - 1]"},{"question":"def can_deliver_parcel(queries): Determines if a parcel can be delivered based on the preferred pattern of delivery times (whether the destination city comes after the origin city alphabetically). Params: queries (list of tuple): A list of tuples where each tuple contains two lowercase English letters representing the origin and destination city of a parcel. Returns: list of str: A list of \\"YES\\" or \\"NO\\" for each query indicating whether the parcel can be delivered. results = [] for origin, destination in queries: if origin < destination: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Unit Test def test_can_deliver_parcel(): queries = [('a', 'b'), ('c', 'a'), ('b', 'd'), ('d', 'a')] results = can_deliver_parcel(queries) assert results == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def test_can_deliver_parcel_same_city(): queries = [('a', 'a'), ('b', 'b')] results = can_deliver_parcel(queries) assert results == [\\"NO\\", \\"NO\\"] def test_can_deliver_parcel_reverse_order(): queries = [('z', 'y'), ('c', 'b'), ('d', 'c')] results = can_deliver_parcel(queries) assert results == [\\"NO\\", \\"NO\\", \\"NO\\"] def test_can_deliver_parcel_yes_scenario(): queries = [('a', 'z'), ('m', 'n'), ('b', 'k')] results = can_deliver_parcel(queries) assert results == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_can_deliver_parcel_mixed_values(): queries = [('a', 'b'), ('z', 'a'), ('e', 'f'), ('k', 'j')] results = can_deliver_parcel(queries) assert results == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def can_deliver_parcel(queries): Determines if a parcel can be delivered based on the preferred pattern of delivery times (whether the destination city comes after the origin city alphabetically). Params: queries (list of tuple): A list of tuples where each tuple contains two lowercase English letters representing the origin and destination city of a parcel. Returns: list of str: A list of \\"YES\\" or \\"NO\\" for each query indicating whether the parcel can be delivered. results = [] for origin, destination in queries: if origin < destination: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_changes_to_sawtooth(n: int, heights: List[int]) -> int: Determine the minimum number of changes required to transform the given row of fence posts into a sawtooth pattern. >>> min_changes_to_sawtooth(4, [1, 5, 3, 6]) 0 >>> min_changes_to_sawtooth(5, [3, 4, 2, 3, 5]) 1","solution":"def min_changes_to_sawtooth(n, heights): changes_to_increase_pattern = 0 changes_to_decrease_pattern = 0 # Pattern: heights[1] < heights[2] > heights[3] < heights[4] ... for i in range(1, n-1, 2): if i-1 >= 0 and heights[i] <= heights[i-1]: changes_to_increase_pattern += 1 if i+1 < n and heights[i] <= heights[i+1]: changes_to_increase_pattern += 1 # Pattern: heights[1] > heights[2] < heights[3] > heights[4] ... for i in range(1, n-1, 2): if i-1 >= 0 and heights[i] >= heights[i-1]: changes_to_decrease_pattern += 1 if i+1 < n and heights[i] >= heights[i+1]: changes_to_decrease_pattern += 1 return min(changes_to_increase_pattern, changes_to_decrease_pattern)"},{"question":"from typing import List, Tuple def shortest_paths(n: int, m: int, c: int, roads: List[Tuple[int, int, int]]) -> List[int]: Finds the shortest path from the capital city to all other cities. Args: n : int : Number of cities m : int : Number of roads c : int : The index of the capital city roads : List[Tuple[int, int, int]] : List of roads where each road is represented as a tuple of (u, v, w) Returns: List[int] : List of shortest distances from the capital city to each city If the city is unreachable, the distance should be -1. Example: >>> n, m, c = 5, 6, 1 >>> roads = [(1, 2, 2), (1, 3, 3), (2, 3, 2), (2, 4, 4), (3, 4, 1), (3, 5, 5)] >>> shortest_paths(n, m, c, roads) [0, 2, 3, 4, 8]","solution":"import heapq def shortest_paths(n, m, c, roads): graph = {i: [] for i in range(1, n+1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) distances = {i: float('inf') for i in range(1, n+1)} distances[c] = 0 priority_queue = [(0, c)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) # Convert distances to the required format result = [] for i in range(1, n+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"def max_buildings_to_remove(n: int, heights: List[int]) -> int: Determines the maximum number of buildings to remove to achieve a strictly increasing skyline. Parameters: n (int): The number of buildings. heights (list): A list of integers representing the heights of the buildings. Returns: int: The maximum number of buildings to remove. >>> max_buildings_to_remove(6, [3, 2, 1, 5, 4, 6]) 3 >>> max_buildings_to_remove(5, [1, 2, 3, 4, 5]) 0 >>> max_buildings_to_remove(4, [4, 3, 2, 1]) 3 >>> max_buildings_to_remove(7, [4, 1, 2, 3, 10, 5, 6]) 2 >>> max_buildings_to_remove(1, [1]) 0 >>> max_buildings_to_remove(3, [10, 20, 30]) 0 >>> max_buildings_to_remove(4, [10, 5, 8, 3]) 2 from typing import List def test_max_buildings_to_remove(): assert max_buildings_to_remove(6, [3, 2, 1, 5, 4, 6]) == 3 assert max_buildings_to_remove(5, [1, 2, 3, 4, 5]) == 0 assert max_buildings_to_remove(4, [4, 3, 2, 1]) == 3 assert max_buildings_to_remove(7, [4, 1, 2, 3, 10, 5, 6]) == 2 assert max_buildings_to_remove(1, [1]) == 0 assert max_buildings_to_remove(3, [10, 20, 30]) == 0 assert max_buildings_to_remove(4, [10, 5, 8, 3]) == 2","solution":"def max_buildings_to_remove(n, heights): Determines the maximum number of buildings to remove to achieve a strictly increasing skyline. Parameters: n (int): The number of buildings. heights (list): A list of integers representing the heights of the buildings. Returns: int: The maximum number of buildings to remove. if n == 0: return 0 # To find the length of the longest increasing subsequence def longest_increasing_subsequence(heights): if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) lis_length = longest_increasing_subsequence(heights) return n - lis_length"},{"question":"def shortest_palindrome_length(s: str) -> int: Returns the length of the shortest palindrome that can be obtained by adding characters to the end of the string. >>> shortest_palindrome_length(\\"abcd\\") 7 >>> shortest_palindrome_length(\\"race\\") 7 >>> shortest_palindrome_length(\\"mada\\") 5 >>> shortest_palindrome_length(\\"a\\") 1 >>> shortest_palindrome_length(\\"aa\\") 2 >>> shortest_palindrome_length(\\"abcba\\") 5 >>> shortest_palindrome_length(\\"abccba\\") 6 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the results for each. >>> process_test_cases(3, [\\"abcd\\", \\"race\\", \\"mada\\"]) [7, 7, 5] >>> process_test_cases(2, [\\"x\\", \\"noon\\"]) [1, 4] >>> process_test_cases(1, [\\"test\\"]) [7]","solution":"def shortest_palindrome_length(s): Returns the length of the shortest palindrome that can be obtained by adding characters to the end of the string. def is_palindrome(s): return s == s[::-1] for i in range(len(s)): if is_palindrome(s[i:]): return len(s) + i return 2 * len(s) - 1 def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(shortest_palindrome_length(s)) return results"},{"question":"def calculate_totals(order_log): Calculate the total number of espresso shots and total amount of milk. Args: order_log: List of tuples, each containing (espresso shots, milk in ounces). Returns: A tuple containing the total number of espresso shots and total amount of milk. >>> calculate_totals([(2, 8), (1, 16), (3, 12)]) (6, 36) >>> calculate_totals([(1, 10)]) (1, 10) >>> calculate_totals([(1, 5), (2, 10), (3, 15), (4, 20)]) (10, 50) >>> calculate_totals([(1, 1) for _ in range(100)]) (100, 100) >>> calculate_totals([(10, 50) for _ in range(10)]) (100, 500)","solution":"def calculate_totals(order_log): Calculate the total number of espresso shots and total amount of milk. Args: order_log: List of tuples, each containing (espresso shots, milk in ounces). Returns: A tuple containing the total number of espresso shots and total amount of milk. total_espresso = 0 total_milk = 0 for order in order_log: total_espresso += order[0] total_milk += order[1] return total_espresso, total_milk"},{"question":"from typing import List def smallest_sum_k_consecutive_elements(arr: List[int], k: int) -> int: Find the smallest sum of \`k\` consecutive elements in an array. >>> smallest_sum_k_consecutive_elements([1, 3, 2, 4, -1, -2, -3, 6, 1], 3) -6 >>> smallest_sum_k_consecutive_elements([4, 3, 2, 1, 5], 1) 1 >>> smallest_sum_k_consecutive_elements([4, 3, 2, 1, 5], 2) 3","solution":"from typing import List def smallest_sum_k_consecutive_elements(arr: List[int], k: int) -> int: This function finds the smallest sum of \`k\` consecutive elements in the array \`arr\`. n = len(arr) if k > n: return None # Initial sum of first \`k\` elements current_sum = sum(arr[:k]) min_sum = current_sum # Sliding window technique to compute the sum of k consecutive elements for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"def min_coins(denominations, amount): Returns the minimum number of coins required to make up a given amount using the provided denominations. If it's not possible to make the amount, returns -1. >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([5, 10], 3) -1 >>> min_coins([1, 2, 5], 100000) 20000 >>> min_coins([1, 2, 7], 14) 2 >>> min_coins([2, 3, 6, 7], 18) 3","solution":"def min_coins(denominations, amount): Returns the minimum number of coins required to make up a given amount using the provided denominations. If it's not possible to make the amount, returns -1. max_amount = amount + 1 dp = [max_amount] * (amount + 1) dp[0] = 0 for coin in denominations: for i in range(coin, amount + 1): dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != max_amount else -1 # Example usage: # denominations = [1, 2, 5] # amount = 11 # print(min_coins(denominations, amount)) # Output: 3"},{"question":"def longest_sequence(stones: List[int]) -> int: Given a list of stone rarities, determine the length of the longest sequence of stones starting at rarity 1 and increasing by 1 each time. >>> longest_sequence([1, 2, 3, 4]) 4 >>> longest_sequence([1]) 1 >>> longest_sequence([1, 3, 5, 7, 9]) 1 >>> longest_sequence([10, 1, 3, 2, 4, 6, 5, 9, 7, 8]) 10 >>> longest_sequence([2, 3, 4, 5, 6, 7, 8, 9]) 0 >>> longest_sequence([998, 999, 1000, 1, 200, 2, 3]) 3","solution":"def longest_sequence(stones): Given a list of stone rarities, determine the length of the longest sequence of stones starting at rarity 1 and increasing by 1 each time. # Creating a set of stone rarities for quick lookup. rarity_set = set(stones) # Initialize the current rarity we are checking for. current_rarity = 1 longest_sequence_length = 0 # Loop to find the longest sequence starting with rarity 1. while current_rarity in rarity_set: longest_sequence_length += 1 current_rarity += 1 return longest_sequence_length"},{"question":"def minimumEffortPath(grid: List[List[int]]) -> int: Compute the minimum effort required to reach the bottom-right cell from the top-left cell in a 2D elevation grid. >>> minimumEffortPath([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimumEffortPath([[1, 2, 3, 4]]) 1 >>> minimumEffortPath([[1], [2], [3], [4]]) 1 >>> minimumEffortPath([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) 0 >>> minimumEffortPath([[5, 4, 3], [4, 3, 2], [3, 2, 1]]) 1 pass","solution":"import heapq def minimumEffortPath(grid): n, m = len(grid), len(grid[0]) def is_valid(x, y): return 0 <= x < n and 0 <= y < m directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] pq = [(0, 0, 0)] # (effort, x, y) efforts = [[float('inf')] * m for _ in range(n)] efforts[0][0] = 0 while pq: current_effort, x, y = heapq.heappop(pq) if x == n - 1 and y == m - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): next_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if next_effort < efforts[nx][ny]: efforts[nx][ny] = next_effort heapq.heappush(pq, (next_effort, nx, ny)) # Example usage: grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] print(minimumEffortPath(grid)) # Output: 2"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements in the array equal. Each test case consists of an integer n and an array of n integers. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List containing the description of each test case. Returns: List[int]: List of minimal operations required for each test case. Example: >>> min_operations_to_equal_elements(3, [(3, [1, 2, 3]), (4, [1, 1, 1, 1]), (5, [1, 2, 2, 3, 3])]) [3, 0, 2] # Unit Tests def test_single_test_case_all_equal(): assert min_operations_to_equal_elements(1, [(4, [1, 1, 1, 1])]) == [0] def test_single_test_case_diff_values(): assert min_operations_to_equal_elements(1, [(3, [1, 2, 3])]) == [3] def test_multiple_test_cases(): test_cases = [(3, [1, 2, 3]), (4, [1, 1, 1]), (5, [1, 2, 2, 3, 3])] assert min_operations_to_equal_elements(3, test_cases) == [3, 0, 2] def test_single_element(): assert min_operations_to_equal_elements(1, [(1, [10])]) == [0] def test_large_values(): assert min_operations_to_equal_elements(1, [(3, [1000, 1000, 1000])]) == [0] def test_half_equal_half_zero(): assert min_operations_to_equal_elements(1, [(4, [0, 0, 5, 5])]) == [10]","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] max_elem = max(arr) operations = sum(max_elem - elem for elem in arr) results.append(operations) return results"},{"question":"def longest_common_prefix_index(s1: str, s2: str) -> Tuple[int, int]: Finds the starting positions of the substrings in s1 and s2 that have the longest common binary prefix. >>> longest_common_prefix_index(\\"110101\\", \\"101110\\") (1, 1) >>> longest_common_prefix_index(\\"0000\\", \\"1111\\") (1, 1) >>> longest_common_prefix_index(\\"1\\", \\"1\\") (1, 1) >>> longest_common_prefix_index(\\"1\\", \\"0\\") (1, 1) >>> longest_common_prefix_index(\\"101101\\", \\"101110101\\") (1, 1) >>> longest_common_prefix_index(\\"011010\\", \\"011010\\") (1, 1)","solution":"def longest_common_prefix_index(s1, s2): Finds the starting positions of the substrings in s1 and s2 that have the longest common binary prefix. max_len = 0 result = (1, 1) # Default result assuming 1-based index for i in range(len(s1)): for j in range(len(s2)): # Calculate the longest common prefix between s1[i:] and s2[j:] common_prefix_length = 0 while (i + common_prefix_length < len(s1) and j + common_prefix_length < len(s2) and s1[i + common_prefix_length] == s2[j + common_prefix_length]): common_prefix_length += 1 # Update the result if a longer common prefix is found if common_prefix_length > max_len: max_len = common_prefix_length result = (i + 1, j + 1) # Convert to 1-based index return result"},{"question":"def find_divisible_pair(n: int, k: int, array: List[int]) -> Union[Tuple[int, int], str]: Finds two indices (1-based) such that the sum of the numbers at these indices is divisible by k. :param n: int - Number of elements in the array :param k: int - Divisor :param array: List[int] - List of integers :return: Tuple (int, int) or str - Indices (1-based) if a pair is found, otherwise \\"NO\\" >>> find_divisible_pair(5, 4, [1, 2, 3, 4, 5]) (1, 3) >>> find_divisible_pair(3, 7, [1, 2, 3]) \\"NO\\" from typing import List, Tuple, Union def test_find_divisible_pair_sample(): assert find_divisible_pair(5, 4, [1, 2, 3, 4, 5]) in [(1, 3), (2, 4)] def test_find_divisible_pair_no_solution(): assert find_divisible_pair(3, 7, [1, 2, 3]) == \\"NO\\" def test_find_divisible_pair_multiple_solutions(): assert find_divisible_pair(5, 5, [5, 10, 15, 20, 25]) != \\"NO\\" def test_find_divisible_pair_single_solution(): assert find_divisible_pair(4, 2, [3, 1, 4, 2]) in [(1, 2), (1, 3), (2, 4)] def test_find_divisible_pair_large_numbers(): assert find_divisible_pair(3, 1000000000, [1000000000, 2000000000, 3000000000]) != \\"NO\\"","solution":"def find_divisible_pair(n, k, array): Finds two indices (1-based) such that the sum of the numbers at these indices is divisible by k. :param n: int - Number of elements in the array :param k: int - Divisor :param array: List[int] - List of integers :return: Tuple (int, int) or str - Indices (1-based) if a pair is found, otherwise \\"NO\\" for i in range(n): for j in range(i + 1, n): if (array[i] + array[j]) % k == 0: return i + 1, j + 1 return \\"NO\\""},{"question":"from typing import List, Tuple, Set def parse_input(input_string: str) -> Tuple[int, int, Set[int], List[Tuple[int, int]]]: Parse the input string into relevant components for the problem. >>> parse_input(\\"7 3n3 4 5n1 2n1 3n2 4n2 5n3 6n3 7n\\") (7, 3, {3, 4, 5}, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) pass def shortest_distance_to_important(n: int, k: int, important_nodes: Set[int], edges: List[Tuple[int, int]]) -> int: Finds the shortest distance from the root node (node 1) to the nearest important node. >>> shortest_distance_to_important(7, 3, {3, 4, 5}, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 1 >>> shortest_distance_to_important(5, 1, {2}, [(1, 2), (1, 3), (3, 4), (3, 5)]) 1 >>> shortest_distance_to_important(5, 1, {4}, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3 >>> shortest_distance_to_important(6, 2, {3, 5}, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)]) 1 >>> shortest_distance_to_important(4, 1, {1}, [(1, 2), (1, 3), (3, 4)]) 0 pass","solution":"from collections import deque, defaultdict def shortest_distance_to_important(n, k, important_nodes, edges): # Create an adjacency list for the tree adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # BFS to find the shortest path from root (1) to any important node queue = deque([(1, 0)]) # (current_node, distance_from_root) visited = set() visited.add(1) while queue: current_node, current_distance = queue.popleft() if current_node in important_nodes: return current_distance for neighbor in adjacency_list[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_distance + 1)) return -1 # this should never be reached, since k≥1 ensures at least one important node exists def parse_input(input_string): input_lines = input_string.strip().split('n') n, k = map(int, input_lines[0].split()) important_nodes = set(map(int, input_lines[1].split())) edges = [tuple(map(int, line.split())) for line in input_lines[2:]] return n, k, important_nodes, edges"},{"question":"def min_squares(n: int) -> int: Find the minimum number of squares needed to represent n as the sum of squares. >>> min_squares(12) 3 >>> min_squares(13) 2","solution":"def min_squares(n): Returns the minimum number of squares needed to sum up to n. if n <= 0: return 0 # Create a list to store the minimum number of squares for each number up to n dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n]"},{"question":"def can_form_palindrome(s: str) -> str: Check if it's possible to rearrange the characters of the string \`s\` into a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Check if it's possible to rearrange the characters of the string \`s\` into a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if there is at most one character with an odd count if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_changes_to_match(n, m, sentence1, sentence2): Determines the minimum number of word changes needed to make sentence1 match sentence2. Args: n (int): Number of words in the first sentence. m (int): Number of words in the second sentence. sentence1 (list of str): The first sentence as a list of words. sentence2 (list of str): The second sentence as a list of words. Returns: int: The minimum number of changes, or -1 if it's impossible. pass # Unit Tests def test_min_changes_same_sentences(): assert min_changes_to_match(3, 3, ['i', 'am', 'happy'], ['i', 'am', 'happy']) == 0 def test_min_changes_one_word_different(): assert min_changes_to_match(5, 5, ['this', 'is', 'a', 'sample', 'sentence'], ['this', 'is', 'a', 'test', 'sentence']) == 1 def test_min_changes_multiple_words_different(): assert min_changes_to_match(4, 4, ['hello', 'world', 'how', 'are'], ['hi', 'earth', 'who', 'is']) == 4 def test_min_changes_sentences_of_different_length(): assert min_changes_to_match(5, 4, ['this', 'is', 'too', 'short', 'sentence'], ['this', 'is', 'short', 'sentence']) == -1 def test_min_changes_empty_sentences(): assert min_changes_to_match(0, 0, [], []) == 0","solution":"def min_changes_to_match(n, m, sentence1, sentence2): Determines the minimum number of word changes needed to make sentence1 match sentence2. Args: n (int): Number of words in the first sentence. m (int): Number of words in the second sentence. sentence1 (list of str): The first sentence as a list of words. sentence2 (list of str): The second sentence as a list of words. Returns: int: The minimum number of changes, or -1 if it's impossible. if n != m: return -1 changes = 0 for word1, word2 in zip(sentence1, sentence2): if word1 != word2: changes += 1 return changes"},{"question":"def max_power_collected(n: int, powers: List[int]) -> int: Returns the maximum possible power collected from the first stone to the last stone following the movement rule that the wizard can only move to stones with higher or equal power. :param n: int - the number of stones :param powers: List[int] - the power values of the stones :return: int - the maximum possible power collected pass # Example usage: # max_power_collected(5, [1, 2, 4, 1, 3]) should return 7 # Test cases: def test_case_1(): assert max_power_collected(5, [1, 2, 4, 1, 3]) == 7 def test_case_2(): assert max_power_collected(5, [1, 2, 3, 7, 8]) == 21 def test_case_3(): assert max_power_collected(3, [1, 2, 2]) == 5 def test_case_4(): assert max_power_collected(4, [2, 2, 3, 1]) == 7 def test_case_5(): assert max_power_collected(2, [5, 10]) == 15 def test_case_all_equal(): assert max_power_collected(4, [5, 5, 5, 5]) == 20 def test_case_decreasing(): assert max_power_collected(4, [10, 5, 3, 1]) == 10 def test_large_input(): assert max_power_collected(300000, [i for i in range(300000)]) == sum(range(300000)) def test_large_input_all_same(): assert max_power_collected(300000, [1] * 300000) == 300000","solution":"def max_power_collected(n, powers): Returns the maximum possible power collected from the first stone to the last stone following the movement rule that the wizard can only move to stones with higher or equal power. :param n: int - the number of stones :param powers: List[int] - the power values of the stones :return: int - the maximum possible power collected # Initialize the maximum power we can collect max_power = powers[0] current_power = powers[0] for i in range(1, n): if powers[i] >= current_power: current_power = powers[i] max_power += current_power return max_power"},{"question":"from typing import List, Tuple def detect_anomalies(n: int, k: int, login_attempts: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Detect anomalies in a stream of login attempts. Parameters: n (int): Number of login attempts k (int): Maximum allowed time between two login attempts to consider them suspicious login_attempts (List[Tuple[int, int]]): List of tuples containing user_id and login_time Returns: Tuple[int, List[int]]: A tuple with the number of users with anomalies and a list of these user IDs in increasing order >>> detect_anomalies(7, 10, [(1, 100), (2, 101), (1, 109), (1, 115), (3, 200), (3, 210), (3, 211)]) (2, [1, 3]) >>> detect_anomalies(3, 5, [(1, 100), (2, 110), (3, 120)]) (0, [])","solution":"def detect_anomalies(n, k, login_attempts): from collections import defaultdict anomalies = defaultdict(list) for user_id, login_time in login_attempts: anomalies[user_id].append(login_time) anomalous_users = [] for user_id, times in anomalies.items(): times.sort() for i in range(1, len(times)): if times[i] - times[i - 1] <= k: anomalous_users.append(user_id) break anomalous_users.sort() return (len(anomalous_users), anomalous_users)"},{"question":"def can_be_decrypted(s: str) -> str: Determines if there's a beautiful word and a shift amount such that the beautiful word, when encrypted, matches the mysterious string. >>> can_be_decrypted(\\"cde\\") \\"YES\\" >>> can_be_decrypted(\\"zxz\\") \\"NO\\" def test_can_be_decrypted(): assert can_be_decrypted(\\"cde\\") == \\"YES\\" assert can_be_decrypted(\\"zxz\\") == \\"NO\\" assert can_be_decrypted(\\"abc\\") == \\"YES\\" assert can_be_decrypted(\\"mno\\") == \\"YES\\" assert can_be_decrypted(\\"aab\\") == \\"NO\\" assert can_be_decrypted(\\"zabc\\") == \\"YES\\" assert can_be_decrypted(\\"a\\") == \\"YES\\" assert can_be_decrypted(\\"z\\") == \\"YES\\" assert can_be_decrypted(\\"aaaa\\") == \\"NO\\"","solution":"def can_be_decrypted(s): Determines if there's a beautiful word and a shift amount such that the beautiful word, when encrypted, matches the mysterious string. def is_beautiful(word): return len(set(word)) == len(word) n = len(s) for shift in range(26): decrypted_word = ''.join(chr(((ord(char) - ord('a') - shift) % 26) + ord('a')) for char in s) if is_beautiful(decrypted_word): return \\"YES\\" return \\"NO\\""},{"question":"def minimize_max_distance(n: int, booths: List[Tuple[int, int]]) -> Dict[int, int]: Determines the minimum of the maximum distances between consecutive booths of the same type. Parameters: n : int : number of booths booths : list of tuples : list containing (position, type) of each booth Returns: dict : dictionary containing types as keys and minimum of the maximum distances for each type as values >>> minimize_max_distance(6, [(10, 1), (20, 2), (30, 1), (40, 2), (50, 1), (60, 3)]) {1: 20, 2: 20, 3: 0} >>> minimize_max_distance(1, [(10, 1)]) {1: 0} >>> minimize_max_distance(3, [(10, 1), (20, 2), (30, 3)]) {1: 0, 2: 0, 3: 0}","solution":"def minimize_max_distance(n, booths): Determines the minimum of the maximum distances between consecutive booths of the same type. Parameters: n : int : number of booths booths : list of tuples : list containing (position, type) of each booth Returns: dict : dictionary containing types as keys and minimum of the maximum distances for each type as values from collections import defaultdict # Dictionary to store positions for each type type_positions = defaultdict(list) # Populate the dictionary with positions for pos, booth_type in booths: type_positions[booth_type].append(pos) # Result dictionary to store the minimum max distance for each type result = {} for t in sorted(type_positions.keys()): positions = sorted(type_positions[t]) if len(positions) == 1: max_distance = 0 else: max_distance = max(positions[i + 1] - positions[i] for i in range(len(positions) - 1)) result[t] = max_distance return result"},{"question":"def minimal_total_cost(n: int, cost_matrix: List[List[int]]) -> int: Calculate the minimal total cost required to connect all the cities such that there's a path between any two cities, directly or indirectly. >>> minimal_total_cost(3, [[0, 1, 3], [1, 0, 2], [3, 2, 0]]) 3 >>> minimal_total_cost(4, [[0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0]]) 3","solution":"def find_mst_cost(n, cost_matrix): def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 edges = [(cost_matrix[i][j], i, j) for i in range(n) for j in range(i + 1, n)] edges.sort() parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 for cost, u, v in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += cost return mst_cost def minimal_total_cost(n, cost_matrix): return find_mst_cost(n, cost_matrix)"},{"question":"import math from typing import List def count_corner_pieces(n: int, pieces: List[int]) -> int: Determines if a given list of puzzle pieces forms a perfect square puzzle, and if so, returns the number of corner pieces. If the given list of pieces does not form a perfect square puzzle, returns -1. >>> count_corner_pieces(16, list(range(1, 17))) 4 >>> count_corner_pieces(15, list(range(1, 16))) -1 >>> count_corner_pieces(9, list(range(1, 10))) 4 >>> count_corner_pieces(10, list(range(1, 11))) -1 >>> count_corner_pieces(1, [1]) 4 >>> n = 10000 >>> pieces = list(range(1, 10001)) >>> count_corner_pieces(n, pieces) 4 >>> n = 9999 >>> pieces = list(range(1, 10000)) >>> count_corner_pieces(n, pieces) -1","solution":"import math def count_corner_pieces(n, pieces): Returns the number of corner pieces if the puzzle forms a perfect square, otherwise returns -1. The puzzle forms a perfect square if the number of edge pieces (including corner pieces) is exactly 4 times the square root of the total number of pieces. # Check if n is a perfect square sqrt_n = int(math.sqrt(n)) if sqrt_n * sqrt_n != n: return -1 # Number of edge pieces should be 4 times the side length of the square expected_edge_pieces = 4 * sqrt_n # Since a valid square puzzle has exactly 4 corner pieces corner_pieces = 4 return corner_pieces # Example usage n = 16 pieces = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] print(count_corner_pieces(n, pieces)) # Output: 4"},{"question":"def can_partition_with_equal_sum(n: int, k: int, array: List[int]) -> str: Determine if the array can be partitioned into k contiguous subarrays such that the sum of the elements in each subarray is equal. Example: >>> can_partition_with_equal_sum(5, 3, [1, 2, 3, 0, 3]) \\"YES\\" >>> can_partition_with_equal_sum(5, 2, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def can_partition_with_equal_sum(n, k, array): total_sum = sum(array) if total_sum % k != 0: return \\"NO\\" target_sum = total_sum // k current_sum = 0 count_partitions = 0 for num in array: current_sum += num if current_sum == target_sum: current_sum = 0 count_partitions += 1 return \\"YES\\" if count_partitions == k else \\"NO\\""},{"question":"def longest_substring_with_k_distinct_chars(n: int, k: int, s: str) -> int: Returns the length of the longest substring that contains no more than k distinct characters. :param n: int - the length of the given string. :param k: int - the maximum number of distinct characters allowed in the substring. :param s: str - the input string. :return: int - the length of the longest substring with no more than k distinct characters. >>> longest_substring_with_k_distinct_chars(7,2,\\"aabbccc\\") 5 >>> longest_substring_with_k_distinct_chars(1,1,\\"a\\") 1 >>> longest_substring_with_k_distinct_chars(5,3,\\"abcde\\") 3 >>> longest_substring_with_k_distinct_chars(5,10,\\"abcde\\") 5 >>> longest_substring_with_k_distinct_chars(5,1,\\"aaaaa\\") 5 >>> longest_substring_with_k_distinct_chars(6,3,\\"abcabc\\") 6 >>> longest_substring_with_k_distinct_chars(8,2,\\"ecebaaaa\\") 5 pass","solution":"def longest_substring_with_k_distinct_chars(n, k, s): Returns the length of the longest substring that contains no more than k distinct characters. :param n: int - the length of the given string. :param k: int - the maximum number of distinct characters allowed in the substring. :param s: str - the input string. :return: int - the length of the longest substring with no more than k distinct characters. from collections import defaultdict char_count = defaultdict(int) left = 0 max_length = 0 for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_two_char_substring(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> longest_two_char_substring(\\"eceba\\") 3 >>> longest_two_char_substring(\\"ccaabbb\\") 5","solution":"def longest_two_char_substring(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n # If the string length is less than 3, the whole string is the answer. left, right = 0, 0 char_count = {} max_length = 2 while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def final_string_length_after_removals(t: int, test_cases: List[str]) -> List[int]: Given a number of test cases, each containing a string consisting of lowercase English letters, determine the length of the final string after repeatedly removing substrings where all characters are the same. >>> final_string_length_after_removals(3, ['aabbcc', 'abcddcba', 'aaaaaaa']) [0, 0, 0] >>> final_string_length_after_removals(3, ['a', 'b', 'c']) [0, 0, 0]","solution":"def final_string_length_after_removals(t, test_cases): results = [] for s in test_cases: # If all characters in \`s\` can be removed # by removing all consecutive occurrences of same character, # then the shortest possible length is 0. results.append(0) return results"},{"question":"def minimum_tax_rate(n: int, grid: List[List[int]]) -> int: Returns the minimum tax rate of any rectangular sub-grid. Parameters: n (int): Size of the city grid. grid (List[List[int]]): A 2D list containing the tax rates of each block. Returns: int: The minimum tax rate of any rectangular sub-grid of the city. >>> minimum_tax_rate(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 1 >>> minimum_tax_rate(2, [ ... [10, 20], ... [30, 40] ... ]) == 10 >>> minimum_tax_rate(1, [ ... [500] ... ]) == 500 >>> minimum_tax_rate(4, [ ... [1, 5, 9, 13], ... [2, 6, 10, 14], ... [3, 7, 11, 15], ... [4, 8, 12, 16] ... ]) == 1 >>> minimum_tax_rate(5, [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) == 1","solution":"def minimum_tax_rate(n, grid): Returns the minimum tax rate of any rectangular sub-grid. Parameters: n (int): Size of the city grid. grid (List[List[int]]): A 2D list containing the tax rates of each block. Returns: int: The minimum tax rate of any rectangular sub-grid of the city. min_tax = float('inf') for i in range(n): for j in range(n): if grid[i][j] < min_tax: min_tax = grid[i][j] return min_tax"},{"question":"def most_frequent_character(n: int, s: str) -> Tuple[str, int]: Returns the lexicographically smallest character with the highest frequency in the string s, followed by its frequency count. >>> most_frequent_character(1, 'a') ('a', 1) >>> most_frequent_character(3, 'abc') ('a', 1) >>> most_frequent_character(6, 'aabbcc') ('a', 2) >>> most_frequent_character(7, 'abacbc') ('a', 2) >>> most_frequent_character(10, 'aabbccddee') ('a', 2) >>> most_frequent_character(12, 'aaabbcccddee') ('a', 3)","solution":"def most_frequent_character(n, s): Returns the lexicographically smallest character with the highest frequency in the string s, followed by its frequency count. from collections import Counter freq = Counter(s) max_freq = max(freq.values()) most_freq_chars = [char for char, count in freq.items() if count == max_freq] result_char = min(most_freq_chars) return result_char, max_freq"},{"question":"def minimal_total_cost(n: int, sequence: List[int]) -> int: Perform operations to minimize the total cost of reducing a sequence to one element. The sequence is reduced by repeatedly removing two adjacent elements, adding their sum back into the sequence, and the cost of each operation is the absolute difference between the two elements removed. Args: n (int): The length of the sequence. sequence (List[int]): The list of integers in the sequence. Returns: int: The minimal total cost possible to achieve this. Examples: >>> minimal_total_cost(4, [4, 1, 3, 2]) 0 >>> minimal_total_cost(2, [5, 5]) 0 >>> minimal_total_cost(3, [1, 1000, 1]) 0 >>> minimal_total_cost(6, [1, 9, 1, 9, 1, 9]) 0 >>> minimal_total_cost(5, [10, 20, 30, 40, 50]) 0","solution":"def minimal_total_cost(n, sequence): # Helper function to calculate the absolute difference def abs_diff(x, y): return abs(x - y) # Use a list to store the new sequence after each operation while len(sequence) > 1: min_cost = float('inf') best_pair = (0, 0) # Find the pair with the minimal cost for i in range(len(sequence) - 1): cost = abs_diff(sequence[i], sequence[i + 1]) if cost < min_cost: min_cost = cost best_pair = (i, i + 1) # Remove the best pair and insert their sum i, j = best_pair new_val = sequence[i] + sequence[j] sequence = sequence[:i] + [new_val] + sequence[i+2:] return 0 # Since we minimize the operations cost to zero in each step"},{"question":"from typing import List def minimum_coins(coins: List[int], k: int) -> int: You are given n stacks of coins. Each stack contains a certain number of coins. In a single move, you can remove any number of coins from the top of any stack. Args: coins (List[int]): Array of positive integers representing the number of coins in each stack. k (int): The number of moves you need to perform. Returns: int: The minimum total number of coins removed after exactly k moves. Examples: >>> minimum_coins([5, 4, 3, 2, 1], 3) 3 >>> minimum_coins([5, 5, 5], 3) 3 >>> minimum_coins([1, 1, 1, 10], 8) 8 >>> minimum_coins([2, 2, 2], 2) 2 >>> minimum_coins([7, 6, 5, 4], 10) 10","solution":"from typing import List def minimum_coins(coins: List[int], k: int) -> int: # Sort the stacks by number of coins in non-decreasing order coins.sort() # Result to accumulate the minimum number of coins removed result = 0 # Iterate from first (smallest) stack to last (largest) until k moves are performed for i in range(len(coins)): if k == 0: break # Determine how many coins can be removed from the current stack remove_from_stack = min(coins[i] - 1, k) result += remove_from_stack k -= remove_from_stack return result"},{"question":"def min_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Laura has a sequence of integers a1, a2, ..., an of length n. She wants to partition this sequence into exactly two non-empty subsequences b and c such that: - Every element in the original sequence a appears in exactly one of the subsequences b or c. - The difference between the sum of elements in subsequence b and the sum of elements in subsequence c is minimized. Args: t: Number of test cases test_cases: List of tuples where each tuple contains an integer n and a list of n integers representing the sequence a. Returns: List of integers where each integer is the minimum possible absolute difference for each test case. Examples: >>> min_difference(1, [(5, [3, 1, 4, 2, 2])]) [0] >>> min_difference(2, [(3, [1, 2, 3]), (4, [4, 5, 6, 7])]) [0, 0]","solution":"def min_difference(t, test_cases): results = [] for case in test_cases: n, a = case total_sum = sum(a) dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in a: for j in range(total_sum // 2, num - 1, -1): dp[j] = dp[j] or dp[j - num] for i in range(total_sum // 2, -1, -1): if dp[i]: min_diff = abs(total_sum - 2 * i) results.append(min_diff) break return results # Example usage t = 1 test_cases = [(5, [3, 1, 4, 2, 2])] print(min_difference(t, test_cases))"},{"question":"def grid_operations(n: int, operations: List[str]) -> List[Union[str, int]]: Perform operations on an initially empty grid of size 'n', and return results of the sum operations. :param n: size of the grid (n x n) :param operations: list of operations to be performed on the grid :return: List of results from the sum operations >>> grid_operations(3, [\\"1 1 1 5\\", \\"1 2 2 3\\", \\"4\\", \\"2 1 1 10\\", \\"4\\", \\"3 2 2\\", \\"4\\"]) [\\"Operation completed successfully\\", \\"Operation completed successfully\\", 8, \\"Operation completed successfully\\", 10, \\"Operation completed successfully\\", 10] >>> grid_operations(3, [\\"4\\"]) [0] from typing import List, Union def test_grid_operations(): operations = [ \\"1 1 1 5\\", \\"1 2 2 3\\", \\"4\\", \\"2 1 1 10\\", \\"4\\", \\"3 2 2\\", \\"4\\" ] result = grid_operations(3, operations) assert result == [ \\"Operation completed successfully\\", \\"Operation completed successfully\\", 8, \\"Operation completed successfully\\", 10, \\"Operation completed successfully\\", 10 ] def test_empty_grid_operations(): operations = [\\"4\\"] result = grid_operations(3, operations) assert result == [0] def test_add_update_delete_operations(): operations = [ \\"1 1 1 1\\", \\"4\\", \\"2 1 1 5\\", \\"4\\", \\"3 1 1\\", \\"4\\" ] result = grid_operations(2, operations) assert result == [ \\"Operation completed successfully\\", 1, \\"Operation completed successfully\\", 5, \\"Operation completed successfully\\", 0 ] def test_large_grid_operations(): operations = [ \\"1 1000 1000 50\\", \\"4\\", \\"2 1000 1000 100\\", \\"4\\", \\"3 1000 1000\\", \\"4\\" ] result = grid_operations(1000, operations) assert result == [ \\"Operation completed successfully\\", 50, \\"Operation completed successfully\\", 100, \\"Operation completed successfully\\", 0 ] def test_negative_values(): operations = [ \\"1 1 1 -5\\", \\"1 2 2 -10\\", \\"4\\", \\"2 1 1 -20\\", \\"4\\", \\"3 2 2\\", \\"4\\" ] result = grid_operations(3, operations) assert result == [ \\"Operation completed successfully\\", \\"Operation completed successfully\\", -15, \\"Operation completed successfully\\", -30, \\"Operation completed successfully\\", -20 ]","solution":"def grid_operations(n, operations): Perform grid operations and returns results for sum operation. :param n: size of the grid (n x n) :param operations: list of operations to be performed on the grid :return: List of results from the sum operations grid = [[0] * n for _ in range(n)] result = [] for op in operations: parts = op.split() op_type = int(parts[0]) if op_type == 1: x, y, v = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) grid[x][y] += v result.append(\\"Operation completed successfully\\") elif op_type == 2: x, y, v = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) grid[x][y] = v result.append(\\"Operation completed successfully\\") elif op_type == 3: x, y = int(parts[1]) - 1, int(parts[2]) - 1 grid[x][y] = 0 result.append(\\"Operation completed successfully\\") elif op_type == 4: total_sum = sum(sum(row) for row in grid) result.append(total_sum) return result"},{"question":"def maximum_sum_andrey_can_achieve(n: int, cards: List[int]) -> int: Determine the maximum sum of card values Andrey can achieve if he plays first in a game with Boris. Parameters: n (int): The number of cards. cards (List[int]): The list of card values in ascending order. Returns: int: The maximum sum Andrey can achieve. >>> maximum_sum_andrey_can_achieve(4, [1, 3, 5, 7]) 10 >>> maximum_sum_andrey_can_achieve(3, [1, 2, 3]) 4 >>> maximum_sum_andrey_can_achieve(5, [10, 20, 30, 40, 50]) 90 >>> maximum_sum_andrey_can_achieve(2, [1, 100]) 100 >>> maximum_sum_andrey_can_achieve(1, [42]) 42 >>> maximum_sum_andrey_can_achieve(6, [1, 2, 3, 4, 5, 6]) 12","solution":"def maximum_sum_andrey_can_achieve(n, cards): dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = cards[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(cards[i] + min(dp[i + 1][j - 1] if (i + 1) <= (j - 1) else 0, dp[i + 2][j] if (i + 2) <= j else 0), cards[j] + min(dp[i][j - 2] if (i <= (j - 2)) else 0, dp[i + 1][j - 1] if (i + 1) <= (j - 1) else 0)) return dp[0][n-1]"},{"question":"def count_shared_problem_pairs(m: int, n: int, results: List[List[int]]) -> int: Find the number of pairs of participants that share at least one problem both solved. >>> count_shared_problem_pairs(3, 3, [ ... [1, 0, 1], ... [0, 1, 1], ... [1, 1, 0] ... ]) == 3 >>> count_shared_problem_pairs(3, 3, [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) == 0 >>> count_shared_problem_pairs(3, 2, [ ... [1, 1], ... [1, 1], ... [1, 1] ... ]) == 3 >>> count_shared_problem_pairs(3, 2, [ ... [1, 0], ... [1, 1], ... [0, 1] ... ]) == 2 >>> count_shared_problem_pairs(1000, 1000, [ ... [1 if j % 2 == 0 else 0 for j in range(1000)] ... for i in range(1000) ... ]) == 499500","solution":"def count_shared_problem_pairs(m, n, results): count = 0 for i in range(m): for j in range(i + 1, m): for k in range(n): if results[i][k] == 1 and results[j][k] == 1: count += 1 break return count"},{"question":"def maxProfit(prices): Returns the maximum profit Tom can achieve with at most two transactions. >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([7, 6, 4, 3, 1]) 0","solution":"def maxProfit(prices): Returns the maximum profit Tom can achieve with at most two transactions. if not prices or len(prices) < 2: return 0 n = len(prices) # Initialize the arrays to store the maximum profit for one transaction up to day i left_profits = [0] * n right_profits = [0] * n # Calculate the maximum profit for one transaction from the left side min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) left_profits[i] = max(left_profits[i-1], prices[i] - min_price) # Calculate the maximum profit for one transaction from the right side max_price = prices[-1] for i in range(n-2, -1, -1): max_price = max(max_price, prices[i]) right_profits[i] = max(right_profits[i+1], max_price - prices[i]) # Calculate the maximum profit with at most two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, left_profits[i] + right_profits[i]) return max_profit"},{"question":"def max_books_on_shelf(n: int, T: int, thicknesses: List[int]) -> int: Determines the maximum number of books that can be placed on the shelf without exceeding thickness T. Args: n: the total number of books T: the maximum allowable thickness of the shelf thicknesses: a list of integers representing the thickness of each book Returns: The maximum number of books that can be placed on the shelf without exceeding the total thickness T. Examples: >>> max_books_on_shelf(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_books_on_shelf(1, 1000000, [1]) 1 >>> max_books_on_shelf(4, 10, [1, 2, 3, 4]) 4 >>> max_books_on_shelf(3, 1, [2, 3, 4]) 0 >>> max_books_on_shelf(5, 7, [2, 3, 4, 5, 6]) 2","solution":"def max_books_on_shelf(n, T, thicknesses): Determines the maximum number of books that can be placed on the shelf without exceeding thickness T. Args: n: int, the number of books T: int, the maximum allowable thickness thicknesses: list of int, the thickness of each book Returns: int: the maximum number of books that can be placed on the shelf # Sort the list of thicknesses in non-decreasing order thicknesses.sort() # Initialize variables to keep track of the total thickness and the count of books total_thickness = 0 count = 0 # Iterate through the sorted list and add books as long as total thickness does not exceed T for thickness in thicknesses: if total_thickness + thickness <= T: total_thickness += thickness count += 1 else: break return count"},{"question":"def max_potion_power(n: int, T: int, powers: List[int]) -> int: Find the maximum possible sum of a subset of ingredients' magical power values that is less than or equal to T. >>> max_potion_power(5, 50, [10, 20, 30, 40, 50]) 50 >>> max_potion_power(4, 35, [10, 15, 20, 25]) 35 >>> max_potion_power(3, 10, [1, 2, 5]) 8","solution":"def max_potion_power(n, T, powers): Find the maximum possible sum of subset of 'powers' that is less than or equal to T. from itertools import combinations max_power = 0 # Iterate over all possible subsets of powers for r in range(1, n+1): for subset in combinations(powers, r): s = sum(subset) if s <= T: max_power = max(max_power, s) return max_power"},{"question":"def can_become_empty(s: str) -> str: Determine whether it is possible to make the string empty by applying the operations. >>> can_become_empty(\\"aabcc\\") \\"NO\\" >>> can_become_empty(\\"aabb\\") \\"YES\\" >>> can_become_empty(\\"abc\\") \\"NO\\" pass def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases and determine the result for each. >>> process_test_cases(3, [\\"aabcc\\", \\"aabb\\", \\"abc\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_become_empty(s): stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): results.append(can_become_empty(test_cases[i])) return results"},{"question":"def longest_increasing_subsequence(n: int, arr: List[int]) -> Tuple[int, List[int]]: Returns the length of the longest increasing subsequence and one such subsequence itself. >>> longest_increasing_subsequence(6, [5, 2, 8, 6, 3, 6]) (3, [2, 3, 6]) >>> longest_increasing_subsequence(1, [1]) (1, [1]) >>> longest_increasing_subsequence(5, [1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence(5, [5, 4, 3, 2, 1]) (1, [1]) >>> longest_increasing_subsequence(7, [10, 22, 9, 33, 21, 50, 41]) (4, [10, 22, 33, 50]) >>> longest_increasing_subsequence(7, [2, 2, 2, 2, 2, 2, 2]) (1, [2])","solution":"def longest_increasing_subsequence(n, arr): Returns the length of the longest increasing subsequence and one such subsequence itself. :param n: Number of elements in the array :param arr: List of integers :return: (length of the LIS, one of the LIS subsequences) if n == 0: return 0, [] # dp will store our increasing subsequences dp = [1] * n prev_index = [-1] * n max_len = 0 max_end_idx = 0 # Build the dp array and keep track of previous indices for i in range(n): for j in range(i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev_index[i] = j if dp[i] > max_len: max_len = dp[i] max_end_idx = i # Reconstruct the longest increasing subsequence lis = [] current_idx = max_end_idx while current_idx != -1: lis.append(arr[current_idx]) current_idx = prev_index[current_idx] lis.reverse() return max_len, lis"},{"question":"def remove_duplicate_letters(s: str) -> str: Returns the lexicographically smallest string by removing duplicate letters from the string s. >>> remove_duplicate_letters(\\"bcabc\\") \\"abc\\" >>> remove_duplicate_letters(\\"cbacdcbc\\") \\"acdb\\" >>> remove_duplicate_letters(\\"abacb\\") \\"abc\\" >>> remove_duplicate_letters(\\"leetcode\\") \\"letcod\\" >>> remove_duplicate_letters(\\"aaaa\\") \\"a\\" def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases for the remove_duplicate_letters function. >>> process_test_cases(3, [\\"bcabc\\", \\"cbacdcbc\\", \\"abacb\\"]) [\\"abc\\", \\"acdb\\", \\"abc\\"] >>> process_test_cases(1, [\\"a\\"]) [\\"a\\"] >>> process_test_cases(2, [\\"abcdabcd\\", \\"aabbccdd\\"]) [\\"abcd\\", \\"abcd\\"] >>> process_test_cases(1, [\\"a\\"*100000]) [\\"a\\"]","solution":"def remove_duplicate_letters(s): Returns the lexicographically smallest string by removing duplicate letters from the string s. stack = [] seen = set() last_occurrence = {c: i for i, c in enumerate(s)} for i, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) seen.add(char) stack.append(char) return ''.join(stack) def process_test_cases(t, test_cases): Process multiple test cases for the remove_duplicate_letters function results = [] for i in range(t): result = remove_duplicate_letters(test_cases[i]) results.append(result) return results"},{"question":"def parse_and_solve(input_data: str): Parse the input data string and return the maximum total profit for each test case. Args: input_data (str): The input data containing multiple test cases. Returns: List[int]: A list of integers where each integer corresponds to the maximum total profit for a test case. >>> input_data = \\"3n5 2n1 5 3 2 4n3 1n2 8 7n4 2n9 1 5 4\\" >>> parse_and_solve(input_data) [9, 8, 14] >>> input_data = \\"1n6 3n4 3 6 7 5 8\\" >>> parse_and_solve(input_data) [21]","solution":"def max_total_profit(t, test_cases): results = [] for test_case in test_cases: n, k, profit = test_case profit.sort(reverse=True) results.append(sum(profit[:k])) return results # Function to parse input and call the solution function def parse_and_solve(input_data): input_lines = input_data.strip().split('n') t = int(input_lines[0]) test_cases = [] line_index = 1 for _ in range(t): n, k = map(int, input_lines[line_index].split()) profit = list(map(int, input_lines[line_index + 1].split())) test_cases.append((n, k, profit)) line_index += 2 results = max_total_profit(t, test_cases) return results"},{"question":"from typing import List def max_plants_watering(plants: List[int], cans: List[int]) -> int: Returns the maximum number of unique plant species that can be watered daily without exceeding the total capacity of the water cans. >>> max_plants_watering([2, 3, 5, 7], [8, 3, 4]) 3 >>> max_plants_watering([4, 2, 1, 6], [7, 4, 5]) 4 >>> max_plants_watering([2, 3, 4], []) 0 >>> max_plants_watering([], [3, 5, 7]) 0 >>> max_plants_watering([1, 1, 1, 1], [10]) 4 >>> max_plants_watering([10], [2, 3, 4]) 0 >>> max_plants_watering([1, 1, 3, 3, 5, 5, 7, 7], [5, 5, 15]) 6","solution":"from typing import List def max_plants_watering(plants: List[int], cans: List[int]) -> int: Returns the maximum number of unique plant species that can be watered daily without exceeding the total capacity of the water cans. plants.sort() cans.sort() plant_index = 0 can_index = 0 total_capacity = 0 max_plants = 0 while plant_index < len(plants) and can_index < len(cans): if plants[plant_index] + total_capacity <= cans[can_index]: total_capacity += plants[plant_index] max_plants += 1 plant_index += 1 else: total_capacity = 0 can_index += 1 return max_plants"},{"question":"def max_sum_of_differences(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum possible sum of the absolute differences between consecutive elements of the array after removing a valid subsequence of elements. >>> max_sum_of_differences(1, [(5, [3, 1, 4, 1, 5])]) == [4] >>> max_sum_of_differences(3, [(5, [3, 1, 4, 1, 5]), (4, [1, 2, 3, 4]), (3, [10, 20, 30])]) == [4, 3, 20] >>> max_sum_of_differences(1, [(4, [2, 2, 2, 2])]) == [0] >>> max_sum_of_differences(1, [(1, [42])]) == [0] >>> max_sum_of_differences(1, [(2, [1, 100])]) == [99]","solution":"def max_sum_of_differences(t, test_cases): results = [] for case in test_cases: n, array = case if n < 2: results.append(0) continue sorted_array = sorted(array) max_diff_sum = sum(abs(sorted_array[i+1] - sorted_array[i]) for i in range(n-1)) results.append(max_diff_sum) return results"},{"question":"def reconstruct_elevations(n: int, differences: List[int], initial_elevation: int) -> List[int]: Reconstructs and returns the elevations for each checkpoint given the elevation differences and initial elevation. Args: n (int): The number of checkpoints. differences (list of int): The elevation differences between consecutive checkpoints. initial_elevation (int): The elevation at the first checkpoint. Returns: list of int: The elevations at each checkpoint. >>> reconstruct_elevations(5, [2, -3, 1, 4], 10) [10, 12, 9, 10, 14] >>> reconstruct_elevations(3, [5, -2], 8) [8, 13, 11] >>> reconstruct_elevations(4, [3, 3, -6], 6) [6, 9, 12, 6] >>> reconstruct_elevations(2, [5], 5) [5, 10]","solution":"def reconstruct_elevations(n, differences, initial_elevation): Reconstructs and returns the elevations for each checkpoint given the elevation differences and initial elevation. Args: n (int): The number of checkpoints. differences (list of int): The elevation differences between consecutive checkpoints. initial_elevation (int): The elevation at the first checkpoint. Returns: list of int: The elevations at each checkpoint. # Initialize the list of elevations with the initial elevation. elevations = [initial_elevation] # Iterate through the differences to calculate subsequent elevations. for difference in differences: next_elevation = elevations[-1] + difference elevations.append(next_elevation) return elevations"},{"question":"def lexicographically_smallest_permutation(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given a number of test cases, returns the lexicographically smallest permutation for each test case. Parameters: t (int): the number of test cases test_cases (list of tuples): each tuple contains an integer n and a list p, representing the permutation of the first n natural numbers Returns: list of list of int: each list contains the lexicographically smallest permutation for the corresponding test case >>> lexicographically_smallest_permutation(2, [(5, [3, 1, 4, 5, 2]), (4, [4, 3, 2, 1])]) [[1, 2, 3, 4, 5], [1, 2, 3, 4]] >>> lexicographically_smallest_permutation(1, [(1, [1])]) [[1]]","solution":"def lexicographically_smallest_permutation(t, test_cases): Given a number of test cases, returns the lexicographically smallest permutation for each test case. Parameters: t (int): the number of test cases test_cases (list of tuples): each tuple contains an integer n and a list p, representing the permutation of the first n natural numbers Returns: list of list of int: each list contains the lexicographically smallest permutation for the corresponding test case result = [] for n, permutation in test_cases: result.append(sorted(permutation)) return result"},{"question":"MOD = 10**9 + 7 def number_of_unique_sequences(n: int, colors: List[str]) -> int: Returns the number of unique sequences modulo 10^9 + 7 after duplicating all the stones. :param n: int - initial number of unique-colored stones :param colors: List[str] - list of strings representing the colors of each unique stone :return: int - number of unique sequences after duplication >>> number_of_unique_sequences(3, [\\"red\\", \\"blue\\", \\"green\\"]) 8 >>> number_of_unique_sequences(1, [\\"red\\"]) 2","solution":"MOD = 10**9 + 7 def number_of_unique_sequences(n, colors): Returns the number of unique sequences modulo 10^9 + 7 after duplicating all the stones. :param n: int - initial number of unique-colored stones :param colors: list - list of strings representing the colors of each unique stone :return: int - number of unique sequences after duplication # The formula to calculate the number of unique sequences is 2^n return pow(2, n, MOD)"},{"question":"def sequence_length(n: int) -> int: Returns the length of the sequence starting with n and ending at 1. >>> sequence_length(7) 17 >>> sequence_length(1) 1 >>> sequence_length(1000000) 153","solution":"def sequence_length(n): Returns the length of the sequence starting with n and ending at 1. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"def min_sum_max_of_subarrays(n: int, array: List[int]) -> int: Returns the minimum possible sum of the maximum elements of each contiguous subarray you can achieve for the given array. >>> min_sum_max_of_subarrays(5, [1, 2, 3, 4, 5]) 15 >>> min_sum_max_of_subarrays(5, [5, 5, 5, 5, 5]) 25 from solution import min_sum_max_of_subarrays def test_min_sum_max_of_subarrays_all_unique(): assert min_sum_max_of_subarrays(5, [1, 2, 3, 4, 5]) == 15 def test_min_sum_max_of_subarrays_all_same(): assert min_sum_max_of_subarrays(5, [5, 5, 5, 5, 5]) == 25 def test_min_sum_max_of_subarrays_mixed_elements(): assert min_sum_max_of_subarrays(4, [3, 1, 4, 2]) == 10 def test_min_sum_max_of_subarrays_single_element(): assert min_sum_max_of_subarrays(1, [100]) == 100 def test_min_sum_max_of_subarrays_large_numbers(): assert min_sum_max_of_subarrays(3, [1000000000, 500000000, 999999999]) == 2499999999 def test_min_sum_max_of_subarrays_edge_case_large_n(): n = 100000 array = [1] * n assert min_sum_max_of_subarrays(n, array) == n","solution":"def min_sum_max_of_subarrays(n, array): Returns the minimum possible sum of the maximum elements of each contiguous subarray you can achieve for the given array. # In the given problem, to minimize the sum of maximum elements in subarrays, # the only logical and non-trivial way is to have each individual element as a subarray. # This is because there is no gain in combining elements as it increases the max of a subarray. return sum(array)"},{"question":"def max_items_load(t, test_cases): Determine the maximum number of items that can be loaded onto the truck without exceeding the load capacity. >>> max_items_load(3, [(5, 10), [3, 8, 2, 7, 1], (4, 5), [1, 2, 3, 4], (6, 15), [5, 4, 7, 8, 1, 3]]) [3, 2, 4]","solution":"def max_items_load(t, test_cases): results = [] for i in range(t): n, W = test_cases[i * 2] weights = test_cases[i * 2 + 1] weights.sort() total_weight = 0 item_count = 0 for weight in weights: if total_weight + weight <= W: total_weight += weight item_count += 1 else: break results.append(item_count) return results"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given array. >>> longest_increasing_subsequence([5, 1, 4, 2, 3, 6]) 4 >>> longest_increasing_subsequence([5, 1, 3, 2, 5]) 3 >>> longest_increasing_subsequence([2, 4, 6, 8]) 4 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS array with 1s for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"def minimum_hamming_distance(n: int, ingredients: List[int]) -> int: Returns the minimum possible Hamming distance between any two permutations of the list. >>> minimum_hamming_distance(2, [1, 2]) 1 >>> minimum_hamming_distance(3, [1, 2, 3]) 2 >>> minimum_hamming_distance(4, [2, 3, 4, 1]) 3 >>> minimum_hamming_distance(5, [1, 1, 1, 1, 1]) 4 >>> minimum_hamming_distance(6, [1, 2, 3, 4, 5, 6]) 5","solution":"def minimum_hamming_distance(n, ingredients): Returns the minimum possible Hamming distance between any two permutations of the list. return n - 1"},{"question":"import heapq from typing import List def min_cost_to_merge_files(file_sizes: List[int]) -> int: Calculate the minimum cost to merge all files into a single file. Parameters: file_sizes (list of int): A list containing the sizes of the files. Returns: int: The minimum cost to merge all files. >>> min_cost_to_merge_files([4, 3, 2, 6]) 29 >>> min_cost_to_merge_files([1]) 0 >>> min_cost_to_merge_files([1, 2]) 3 >>> min_cost_to_merge_files([5, 5, 5]) 25","solution":"import heapq def min_cost_to_merge_files(file_sizes): Calculate the minimum cost to merge all files into a single file. Parameters: file_sizes (list of int): A list containing the sizes of the files. Returns: int: The minimum cost to merge all files. if not file_sizes: return 0 heapq.heapify(file_sizes) total_cost = 0 while len(file_sizes) > 1: first = heapq.heappop(file_sizes) second = heapq.heappop(file_sizes) merge_cost = first + second total_cost += merge_cost heapq.heappush(file_sizes, merge_cost) return total_cost"},{"question":"def max_overlapping_tasks(n: int, tasks: List[Tuple[int, int]]) -> int: Find the maximum number of tasks that overlap at any point in time during the day. >>> max_overlapping_tasks(5, [(120, 150), (130, 180), (140, 170), (160, 200), (180, 210)]) 3 >>> max_overlapping_tasks(1, [(0, 1440)]) 1 >>> max_overlapping_tasks(3, [(0, 10), (10, 20), (20, 30)]) 1 >>> max_overlapping_tasks(3, [(0, 30), (10, 40), (20, 50)]) 3 >>> tasks = [(i, i + 1) for i in range(100000)] >>> max_overlapping_tasks(100000, tasks) 1 >>> max_overlapping_tasks(5, [(0, 10), (5, 15), (10, 20), (15, 25), (20, 30)]) 2","solution":"def max_overlapping_tasks(n, tasks): events = [] for start, end in tasks: events.append((start, 1)) events.append((end, -1)) events.sort() max_overlaps = 0 current_overlaps = 0 for event in events: current_overlaps += event[-1] max_overlaps = max(max_overlaps, current_overlaps) return max_overlaps # Example usage: # n = 5 # tasks = [(120, 150), (130, 180), (140, 170), (160, 200), (180, 210)] # print(max_overlapping_tasks(n, tasks)) # Output: 3"},{"question":"def can_partition(nums: List[int]) -> Tuple[str, List[List[int]]]: Returns whether it's possible to partition the array into two subsets with equal sum. If possible, also returns one such partition. >>> can_partition([1, 5, 11, 5]) (\\"Yes\\", [[1, 5, 5], [11]]) >>> can_partition([1, 2, 3, 5]) (\\"No\\", []) >>> can_partition([2, 2, 2, 2]) (\\"Yes\\", [[2, 2], [2, 2]]) pass # Unit tests def test_partition_possible(): result = can_partition([1, 5, 11, 5]) assert result[0] == \\"Yes\\" assert sum(result[1][0]) == sum(result[1][1]) == 11 def test_partition_not_possible(): result = can_partition([1, 2, 3, 5]) assert result[0] == \\"No\\" assert result[1] == [] def test_single_element(): result = can_partition([100]) assert result[0] == \\"No\\" assert result[1] == [] def test_two_elements_equal(): result = can_partition([50, 50]) assert result[0] == \\"Yes\\" assert sum(result[1][0]) == sum(result[1][1]) == 50 def test_multiple_equal_partitions(): result = can_partition([2, 2, 2, 2]) assert result[0] == \\"Yes\\" assert sum(result[1][0]) == sum(result[1][1]) == 4 def test_partition_large_input(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20] result = can_partition(nums) assert result[0] == \\"Yes\\" assert sum(result[1][0]) == sum(result[1][1]) == sum(nums) // 2","solution":"def can_partition(nums): Returns whether it's possible to partition the array into two subsets with equal sum. If possible, also returns one such partition. total_sum = sum(nums) n = len(nums) # Check if total sum is odd, if so, it's impossible to partition into two equal subsets if total_sum % 2 != 0: return \\"No\\", [] target = total_sum // 2 # DP array to store if we can form a subset with sum j using first i numbers dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True # We can always form the subset with sum 0 (empty subset) # Fill the dp table for i in range(1, n + 1): for j in range(target + 1): dp[i][j] = dp[i - 1][j] or (j >= nums[i - 1] and dp[i - 1][j - nums[i - 1]]) # If we can't form the target sum with all numbers, return No if not dp[n][target]: return \\"No\\", [] # If we can, reconstruct the subsets subset1, subset2 = [], [] i, j = n, target while i > 0 and j >= 0: if not dp[i - 1][j]: subset1.append(nums[i - 1]) j -= nums[i - 1] else: subset2.append(nums[i - 1]) i -= 1 return \\"Yes\\", (subset1, subset2) # Usage example: # Output should be \\"Yes\\", [1, 5, 5], [11] nums = [1, 5, 11, 5] result = can_partition(nums) print(result[0]) if result[0] == \\"Yes\\": print(result[1][0], result[1][1])"},{"question":"def min_operations_to_avoid_consecutive_ones(n: int, s: str) -> int: Determine the minimum number of operations required to transform the string into one without consecutive '1's. >>> min_operations_to_avoid_consecutive_ones(5, \\"10101\\") == 0 >>> min_operations_to_avoid_consecutive_ones(3, \\"001\\") == 0 >>> min_operations_to_avoid_consecutive_ones(5, \\"00000\\") == 0 >>> min_operations_to_avoid_consecutive_ones(4, \\"1101\\") == 1 >>> min_operations_to_avoid_consecutive_ones(6, \\"111111\\") == 3 >>> min_operations_to_avoid_consecutive_ones(7, \\"1101101\\") == 2 >>> min_operations_to_avoid_consecutive_ones(1, \\"0\\") == 0 >>> min_operations_to_avoid_consecutive_ones(1, \\"1\\") == 0 >>> min_operations_to_avoid_consecutive_ones(8, \\"10111011\\") == 2 >>> min_operations_to_avoid_consecutive_ones(10, \\"1010011101\\") == 1","solution":"def min_operations_to_avoid_consecutive_ones(n, s): operations = 0 i = 1 while i < n: if s[i] == '1' and s[i-1] == '1': # Perform an operation (flip current '1' to '0') s = s[:i] + '0' + s[i+1:] operations += 1 i += 1 return operations"},{"question":"def longest_substring_with_k_changes(n: int, k: int, s: str) -> int: Returns the length of the longest substring of repeating characters that can be obtained by changing at most k characters. >>> longest_substring_with_k_changes(6, 2, \\"aabccd\\") 4 >>> longest_substring_with_k_changes(5, 1, \\"aaaaa\\") 5 >>> longest_substring_with_k_changes(5, 2, \\"abcde\\") 3 >>> longest_substring_with_k_changes(5, 0, \\"abcde\\") 1 >>> longest_substring_with_k_changes(7, 6, \\"abcdefg\\") 7 >>> longest_substring_with_k_changes(10, 2, \\"aaabccddaa\\") 5 from collections import defaultdict","solution":"def longest_substring_with_k_changes(n, k, s): Returns the length of the longest substring of repeating characters that can be obtained by changing at most k characters. from collections import defaultdict max_len = 0 max_count = 0 start = 0 count = defaultdict(int) for end in range(n): count[s[end]] += 1 max_count = max(max_count, count[s[end]]) while end - start + 1 - max_count > k: count[s[start]] -= 1 start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def count_inversions(n: int, permutation: List[int]) -> int: Counts the number of inversions in the permutation. Args: n (int): The size of the permutation. permutation (list): The permutation of integers from 1 to n. Returns: int: The number of inversions in the permutation. >>> count_inversions(3, [3, 1, 2]) 2 >>> count_inversions(5, [2, 3, 8, 6, 1]) 5 >>> count_inversions(4, [4, 3, 2, 1]) 6 >>> count_inversions(5, [1, 2, 3, 4, 5]) 0 >>> count_inversions(6, [6, 5, 4, 3, 2, 1]) 15 >>> count_inversions(1, [1]) 0 >>> count_inversions(2, [2, 1]) 1 >>> count_inversions(2, [1, 2]) 0","solution":"def count_inversions(n, permutation): Counts the number of inversions in the permutation. Args: n (int): The size of the permutation. permutation (list): The permutation of integers from 1 to n. Returns: int: The number of inversions in the permutation. def merge_sort(arr): if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort(arr[:mid]) right, right_inv = merge_sort(arr[mid:]) merged, split_inv = merge(left, right) total_inv = left_inv + right_inv + split_inv return merged, total_inv def merge(left, right): merged = [] inv_count = 0 i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 inv_count += len(left) - i merged.extend(left[i:]) merged.extend(right[j:]) return merged, inv_count _, inversions = merge_sort(permutation) return inversions"},{"question":"def max_moves(a1: int, a2: int) -> int: Lily is playing a game with two piles of stones. Initially, the first pile contains a1 stones and the second pile contains a2 stones. It's Lily's turn to move, and she can do one of two types of moves: 1. Remove one stone from both piles. 2. Remove two stones from one pile. The game continues until Lily can't make any more moves. Lily wants to know the maximum number of moves she can make. :param a1: number of stones in the first pile :param a2: number of stones in the second pile :return: the maximum number of moves Lily can make >>> max_moves(5, 3) 4 >>> max_moves(0, 0) 0 >>> max_moves(5, 0) 2 >>> max_moves(0, 4) 2 >>> max_moves(4, 4) 4 >>> max_moves(1, 4) 2 >>> max_moves(1000, 1000) 1000 >>> max_moves(1, 1) 1 >>> max_moves(2, 1) 1 >>> max_moves(1, 2) 1","solution":"def max_moves(a1, a2): Returns the maximum number of moves Lily can make given two piles of stones. moves = 0 while a1 > 0 and a2 > 0: if a1 > a2: # Remove 2 stones from a1 a1 -= 2 elif a2 > a1: # Remove 2 stones from a2 a2 -= 2 else: # Remove 1 stone from both piles a1 -= 1 a2 -= 1 moves += 1 if a1 > 0: moves += a1 // 2 if a2 > 0: moves += a2 // 2 return moves"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[str]) -> int: Finds the shortest path in a grid avoiding blocked cells. Given a grid of n rows and m columns with certain cells blocked, find the shortest path from the top-left corner to the bottom-right corner, avoiding blocked cells. You can only move up, down, left, or right. Parameters: n (int): Number of rows. m (int): Number of columns. grid (List[str]): The grid as a list of strings. Returns: int: The length of the shortest path or -1 if no path exists. >>> shortest_path(5, 5, [\\".....\\", \\".X.X.\\", \\".X...\\", \\"XXX.X\\", \\".....\\"]) 9 >>> shortest_path(5, 5, [\\".....\\", \\".X.X.\\", \\".X...\\", \\"XXXXX\\", \\".....\\"]) -1 >>> shortest_path(1, 1, [\\".\\"]) 1 >>> shortest_path(5, 5, [\\"X....\\", \\".X.X.\\", \\".X...\\", \\"XXXXX\\", \\".....\\"]) -1 >>> shortest_path(5, 5, [\\".....\\", \\".X.X.\\", \\".X...\\", \\"XXXXX\\", \\"....X\\"]) -1 >>> shortest_path(1000, 1000, [[\\".\\" for _ in range(1000)] for _ in range(1000)]) 1999 >>> shortest_path(6, 6, [\\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\", \\"......\\"]) 11","solution":"from collections import deque def shortest_path(n, m, grid): Finds the shortest path in a grid avoiding blocked cells. :param n: int, number of rows. :param m: int, number of columns. :param grid: List of strings, representing the grid. :return: int, shortest path length or -1 if no path exists. if grid[0][0] == 'X' or grid[n-1][m-1] == 'X': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: return dist for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < m and (r, c) not in visited and grid[r][c] == '.': visited.add((r, c)) queue.append((r, c, dist + 1)) return -1"},{"question":"from typing import List def sieve_of_eratosthenes(max_num: int) -> List[int]: Returns a list of primes up to max_num (inclusive) using the Sieve of Eratosthenes algorithm. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(max_num**0.5) + 1): if is_prime[start]: for i in range(start*start, max_num + 1, start): is_prime[i] = False primes = [num for num, prime in enumerate(is_prime) if prime] return primes def min_prime_blocks(n: int) -> int: Returns the minimum number of prime-sized blocks required to store exactly n units of data. If it's not possible to store the data exactly with prime blocks, returns -1. >>> min_prime_blocks(1) 1 >>> min_prime_blocks(10) 2 >>> min_prime_blocks(12) 2","solution":"def sieve_of_eratosthenes(max_num): Returns a list of primes up to max_num (inclusive) using the Sieve of Eratosthenes algorithm. is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(max_num**0.5) + 1): if is_prime[start]: for i in range(start*start, max_num + 1, start): is_prime[i] = False primes = [num for num, prime in enumerate(is_prime) if prime] return primes def min_prime_blocks(n): Returns the minimum number of prime-sized blocks required to store exactly n units of data. If it's not possible to store the data exactly with prime blocks, returns -1. if n == 1: return 1 primes = sieve_of_eratosthenes(n) dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): for prime in primes: if i >= prime: dp[i] = min(dp[i], dp[i - prime] + 1) else: break return dp[n] if dp[n] != float('inf') else -1"},{"question":"import random class Card: def __init__(self, suit: str, rank: str): self.suit = suit self.rank = rank def __repr__(self): return f\\"{self.rank} of {self.suit}\\" class Deck: A class to simulate a deck of cards. Each card has a suit (Hearts, Diamonds, Clubs, Spades) and a rank (2 through 10, Jack, Queen, King, Ace). The deck supports the following methods: - shuffle(): Randomly shuffle the deck of cards. - draw_card(): Remove and return the top card of the deck. If the deck is empty, return None. - reset(): Reset the deck to the original 52 cards and shuffle it. - remaining_cards(): Return the number of cards still in the deck. Example usage: >>> deck = Deck() >>> deck.remaining_cards() 52 >>> card = deck.draw_card() >>> isinstance(card, Card) True >>> deck.remaining_cards() 51 >>> deck.shuffle() >>> deck.reset() >>> deck.remaining_cards() 52","solution":"import random class Card: def __init__(self, suit, rank): self.suit = suit self.rank = rank def __repr__(self): return f\\"{self.rank} of {self.suit}\\" class Deck: suits = ['Hearts', 'Diamonds', 'Clubs', 'Spades'] ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'] def __init__(self): self.reset() def shuffle(self): random.shuffle(self.cards) def draw_card(self): return self.cards.pop() if self.cards else None def reset(self): self.cards = [Card(suit, rank) for suit in self.suits for rank in self.ranks] self.shuffle() def remaining_cards(self): return len(self.cards)"},{"question":"def min_repairs_to_make_bridge_passable(s: str) -> int: Returns the minimum number of damaged sections that need to be repaired to make the bridge passable. Args: s (str): A string representing the sections of the bridge. Returns: int: The minimum number of damaged sections to be repaired. >>> min_repairs_to_make_bridge_passable(\\"1100010111\\") 1 >>> min_repairs_to_make_bridge_passable(\\"00000\\") 4","solution":"def min_repairs_to_make_bridge_passable(s): Returns the minimum number of damaged sections that need to be repaired to make the bridge passable. Args: s (str): A string representing the sections of the bridge. Returns: int: The minimum number of damaged sections to be repaired. if '1' not in s: return len(s) - 1 groups = s.split('1') groups_filtered = [len(group) for group in groups if len(group) > 0] if not groups_filtered: return 0 return min(groups_filtered)"},{"question":"import math from typing import List, Tuple def min_tiles_required(t: int, test_cases: List[Tuple[int, int, int, int]]) -> List[int]: Calculate the minimum number of tiles required to completely cover a grid. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, int, int]]): Each tuple contains four integers (n, m, a, b) describing the size of the canvas and the size of the tile respectively. Returns: List[int]: List of minimum number of tiles required for each test case. >>> min_tiles_required(2, [(3, 3, 3, 2), (4, 4, 2, 2)]) [2, 4] >>> min_tiles_required(1, [(100, 100, 1, 1)]) [10000]","solution":"import math def min_tiles_required(t, test_cases): results = [] for case in test_cases: n, m, a, b = case horizontal_tiles = math.ceil(n / a) vertical_tiles = math.ceil(m / b) tiles_needed_orientation_one = horizontal_tiles * vertical_tiles horizontal_tiles = math.ceil(n / b) vertical_tiles = math.ceil(m / a) tiles_needed_orientation_two = horizontal_tiles * vertical_tiles results.append(min(tiles_needed_orientation_one, tiles_needed_orientation_two)) return results"},{"question":"def count_problem_ids(problems: str) -> list: Count the occurrences of each problem ID in the string and return in ascending order of problem IDs. Args: problems (str): A string of problem IDs separated by spaces. Returns: list: A list of tuples, each tuple contains a problem ID and its frequency, sorted by problem ID. Examples: >>> count_problem_ids(\\"1 2 3 2 1 2 4 4 4 5 1 1 1\\") [(\\"1\\", 5), (\\"2\\", 3), (\\"3\\", 1), (\\"4\\", 3), (\\"5\\", 1)] >>> count_problem_ids(\\"5 5 5 5 5\\") [(\\"5\\", 5)]","solution":"def count_problem_ids(problems): Count the occurrences of each problem ID in the string and return in ascending order of problem IDs. # Split the string into individual problem IDs problem_ids = problems.split() # Dictionary to maintain the count of each problem ID problem_count = {} # Count each problem ID for problem_id in problem_ids: if problem_id in problem_count: problem_count[problem_id] += 1 else: problem_count[problem_id] = 1 # Sort the problem IDs and prepare the result sorted_problem_counts = sorted(problem_count.items(), key=lambda x: int(x[0])) return sorted_problem_counts"},{"question":"from typing import List, Tuple def chat_bot(n: int, patterns_responses: List[Tuple[str, str]], q: int, user_inputs: List[str]) -> List[str]: Simulates a simple chatbot. Parameters: - n: Number of patterns - patterns_responses: List of tuples, each containing a pattern and its associated response - q: Number of user inputs - user_inputs: List of user input strings Returns: - List of responses for each user input pass # Implement the function # Test Cases def test_example_case(): n = 3 patterns_responses = [ ('hello*', 'Hi there!'), ('how?are*you', 'Doing well!'), ('*weather*', 'It's sunny.') ] q = 4 user_inputs = ['hello', 'howareyou', 'whatsup', 'weatherforecast'] expected_outputs = ['Hi there!', 'NO MATCH', 'NO MATCH', 'It's sunny.'] assert chat_bot(n, patterns_responses, q, user_inputs) == expected_outputs def test_no_match_case(): n = 2 patterns_responses = [ ('abc*def', 'Pattern 1 matched'), ('123?456', 'Pattern 2 matched') ] q = 2 user_inputs = ['zyxwv', '789abcdef'] expected_outputs = ['NO MATCH', 'NO MATCH'] assert chat_bot(n, patterns_responses, q, user_inputs) == expected_outputs def test_all_match_case(): n = 2 patterns_responses = [ ('*', 'Matched anything'), ('?at', 'First letter is anything, followed by \\"at\\"') ] q = 3 user_inputs = ['abc', 'mat', 'random'] expected_outputs = ['Matched anything', 'Matched anything', 'Matched anything'] assert chat_bot(n, patterns_responses, q, user_inputs) == expected_outputs def test_edge_cases(): n = 2 patterns_responses = [ ('*a*', 'Contains \\"a\\"'), ('b*', 'Starts with \\"b\\"') ] q = 3 user_inputs = ['a', 'ba', 'b'] expected_outputs = ['Contains \\"a\\"', 'Contains \\"a\\"', 'Starts with \\"b\\"'] assert chat_bot(n, patterns_responses, q, user_inputs) == expected_outputs","solution":"import re def chat_bot(n, patterns_responses, q, user_inputs): Simulates a simple chatbot. Parameters: - n: Number of patterns - patterns_responses: List of tuples, each containing a pattern and its associated response - q: Number of user inputs - user_inputs: List of user input strings Returns: - List of responses for each user input # Prepare the patterns by converting * and ? into regex equivalents compiled_patterns = [] for pattern, response in patterns_responses: pattern_regex = re.escape(pattern) pattern_regex = pattern_regex.replace(r'*', '.*') pattern_regex = pattern_regex.replace(r'?', '.') compiled_patterns.append((re.compile(f'^{pattern_regex}'), response)) responses = [] for user_input in user_inputs: matched = False for pattern, response in compiled_patterns: if pattern.match(user_input): responses.append(response) matched = True break if not matched: responses.append(\\"NO MATCH\\") return responses"},{"question":"def min_cpus(n: int, d: int, task_durations: List[int]) -> int: Returns the minimum number of CPUs required to complete all tasks within the given deadline. Parameters: n (int): the number of tasks d (int): the deadline task_durations (List[int]): the duration of each task Returns: int: the minimum number of CPUs needed >>> min_cpus(5, 10, [2, 3, 1, 5, 4]) == 2 >>> min_cpus(1, 1, [1]) == 1 >>> min_cpus(3, 2, [2, 2, 2]) == 3 >>> min_cpus(10, 15, [2, 3, 1, 5, 4, 3, 2, 1, 5, 4]) == 2 >>> min_cpus(5, 9, [2, 2, 2, 2, 2]) == 2 from typing import List def test_case_1(): assert min_cpus(5, 10, [2, 3, 1, 5, 4]) == 2 def test_case_minimum_tasks(): assert min_cpus(1, 1, [1]) == 1 assert min_cpus(1, 10, [1]) == 1 def test_case_maximum_task_duration(): assert min_cpus(3, 6, [2, 2, 2]) == 1 assert min_cpus(3, 2, [2, 2, 2]) == 3 def test_case_large_number_of_tasks(): assert min_cpus(10, 15, [2, 3, 1, 5, 4, 3, 2, 1, 5, 4]) == 2 assert min_cpus(6, 10, [6, 7, 8, 9, 1, 1]) == 4 def test_case_all_tasks_same_duration(): assert min_cpus(5, 10, [2, 2, 2, 2, 2]) == 1 assert min_cpus(5, 9, [2, 2, 2, 2, 2]) == 2","solution":"def min_cpus(n, d, task_durations): Returns the minimum number of CPUs required to complete all tasks within the given deadline. :param n: number of tasks :param d: deadline :param task_durations: list of task durations :return: minimum number of CPUs needed # Sort the task durations in non-decreasing order task_durations.sort() # Function to check if we can complete the tasks with k CPUs within the deadline def can_complete_with_k_cpus(k): # Create k CPU time slots initialized to 0 cpu_slots = [0] * k for duration in task_durations: # Assign each task to the CPU with the least current time least_time_cpu = min(cpu_slots) if least_time_cpu + duration > d: return False # Add this task duration to the chosen CPU cpu_slots[cpu_slots.index(least_time_cpu)] += duration return True # Binary search to find the minimum number of CPUs required left, right = 1, n while left < right: mid = (left + right) // 2 if can_complete_with_k_cpus(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List, Tuple def detect_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if there is a cycle in a directed graph. Arguments: n -- the number of vertices m -- the number of edges edges -- a list of tuples representing the directed edges Returns: \\"YES\\" if there is a cycle, otherwise \\"NO\\" pass def test_no_edges(): assert detect_cycle(3, 0, []) == \\"NO\\" def test_single_cycle(): assert detect_cycle(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" def test_multiple_components_no_cycle(): assert detect_cycle(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) == \\"YES\\" def test_no_cycle(): assert detect_cycle(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"NO\\" def test_large_graph_no_cycle(): edges = [(i, i + 1) for i in range(1, 100000)] assert detect_cycle(100000, 99999, edges) == \\"NO\\" def test_large_graph_with_cycle(): edges = [(i, i + 1) for i in range(1, 100000)] + [(100000, 1)] assert detect_cycle(100000, 100000, edges) == \\"YES\\"","solution":"from collections import defaultdict, deque def detect_cycle(n, m, edges): Determines if there is a cycle in a directed graph. Arguments: n -- the number of vertices m -- the number of edges edges -- a list of tuples representing the directed edges Returns: \\"YES\\" if there is a cycle, otherwise \\"NO\\" # Build the adjacency list for the graph graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Perform Topological Sort using Kahn's Algorithm queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) count = 0 # Count of vertices added in topological sort while queue: node = queue.popleft() count += 1 for neighbour in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: queue.append(neighbour) # If count != n, graph has a cycle return \\"YES\\" if count != n else \\"NO\\""},{"question":"def find_min_repair_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum total cost required to repair the roads so that all villages remain connected or -1 if impossible. >>> find_min_repair_cost(4, 5, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (3, 4, 5)]) 6 >>> find_min_repair_cost(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> find_min_repair_cost(2, 1, [(1, 2, 10)]) 10 >>> find_min_repair_cost(3, 3, [(1, 2, 1), (1, 3, 1), (2, 3, 2)]) 2 >>> find_min_repair_cost(4, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (1, 3, 2), (2, 4, 2)]) 3 >>> find_min_repair_cost(1000, 999, [(i, i+1, i) for i in range(1, 1000)]) 499500 pass","solution":"def find_min_repair_cost(n, m, roads): Returns the minimum total cost required to repair the roads so that all villages remain connected or -1 if impossible. # Helper function to find the parent of a node in the Union-Find structure def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) # Helper function to union two subsets in the Union-Find structure def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal's algorithm to find Minimum Spanning Tree (MST) roads.sort(key=lambda x: x[2]) # Sort edges by weight parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = 0 num_edges = 0 for u, v, w in roads: x = find(parent, u-1) y = find(parent, v-1) if x != y: result += w union(parent, rank, x, y) num_edges += 1 if num_edges == n - 1: break if num_edges != n - 1: return -1 return result"},{"question":"def update_inventory(initial_inventory: str, update_sequence: str) -> str: Updates the initial inventory based on the given update sequence. Parameters: initial_inventory (str): The initial inventory list. update_sequence (str): The update sequence containing pairs of operations and items. Returns: str: The final sorted inventory list of unique items. >>> update_inventory(\\"apple,banana,carrot\\", \\"AorangeDcarrotAappleDbananaApear\\") \\"apple,orange,pear\\" >>> update_inventory(\\"\\", \\"AappleAorangeApear\\") \\"apple,orange,pear\\" >>> update_inventory(\\"apple,banana,carrot\\", \\"DappleDcarrotDbanana\\") \\"\\" >>> update_inventory(\\"apple,banana,carrot\\", \\"\\") \\"apple,banana,carrot\\" >>> update_inventory(\\"apple,banana\\", \\"AappleAappleAapple\\") \\"apple,banana\\" >>> update_inventory(\\"apple,banana\\", \\"DcarrotDorange\\") \\"apple,banana\\"","solution":"def update_inventory(initial_inventory, update_sequence): Updates the initial inventory based on the given update sequence. Parameters: initial_inventory (str): The initial inventory list. update_sequence (str): The update sequence containing pairs of operations and items. Returns: str: The final sorted inventory list of unique items. # Split the initial inventory into a set of items inventory = set(initial_inventory.split(',')) if initial_inventory else set() # Process the update sequence i = 0 while i < len(update_sequence): operation = update_sequence[i] item_code = '' i += 1 while i < len(update_sequence) and not update_sequence[i].isupper(): item_code += update_sequence[i] i += 1 if operation == 'A': inventory.add(item_code) elif operation == 'D': inventory.discard(item_code) # Convert the inventory set to a sorted list and join with commas final_inventory = sorted(inventory) return ','.join(final_inventory)"},{"question":"def are_identical_trees(tree1, tree2): Determines if the two binary trees represented by level-order traversals are identical. Args: tree1 (list of int/None): Level-order traversal of the first binary tree. tree2 (list of int/None): Level-order traversal of the second binary tree. Returns: str: \\"YES\\" if the trees are identical, \\"NO\\" otherwise. pass # Example test cases def test_identical_simple_trees(): assert are_identical_trees([1, 2, 3], [1, 2, 3]) == \\"YES\\" def test_different_structures(): assert are_identical_trees([1, 2], [1, None, 2]) == \\"NO\\" def test_identical_complex_trees(): assert are_identical_trees([1, 2, 3, None, 4], [1, 2, 3, None, 4]) == \\"YES\\" def test_one_tree_empty(): assert are_identical_trees([], [1, 2, 3]) == \\"NO\\" def test_both_trees_empty(): assert are_identical_trees([], []) == \\"YES\\" def test_different_values(): assert are_identical_trees([1, 2, 3], [1, 2, 4]) == \\"NO\\" def test_none_at_different_positions(): assert are_identical_trees([1, None, 3], [1, 2, None]) == \\"NO\\" def test_same_values_different_structure(): assert are_identical_trees([1, 2, 3, 4], [1, 2, None, 3]) == \\"NO\\"","solution":"def are_identical_trees(tree1, tree2): Determines if the two binary trees represented by level-order traversals are identical. Args: tree1 (list of int/None): Level-order traversal of the first binary tree. tree2 (list of int/None): Level-order traversal of the second binary tree. Returns: str: \\"YES\\" if the trees are identical, \\"NO\\" otherwise. if tree1 == tree2: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_even_sum(t: int, queries: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum possible sum of the even elements in the array after performing any number of operations. Args: t (int): The number of queries. queries (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n and a list of n integers. Returns: List[int]: A list of integers, each integer is the maximum possible sum of the even elements in the array after performing the described operation for the corresponding query. Examples: >>> max_even_sum(2, [(4, [2, 3, 4, 5]), (3, [6, 7, 8])]) [6, 14] >>> max_even_sum(1, [(4, [1, 3, 5, 7])]) [0] >>> max_even_sum(1, [(4, [2, 4, 6, 8])]) [20] >>> max_even_sum(2, [(1, [2]), (1, [3])]) [2, 0]","solution":"def max_even_sum(t, queries): results = [] for query in queries: n, a = query even_sum = sum(x for x in a if x % 2 == 0) results.append(even_sum) return results"},{"question":"from typing import List def longest_climb_series(heights: List[int]) -> int: Determine the length of the longest series of climbs with a constant height difference. >>> longest_climb_series([3, 6, 9, 12, 15, 20, 25, 30]) 5 >>> longest_climb_series([1, 4, 7, 10, 13]) 5 >>> longest_climb_series([5, 10, 15, 20, 25, 26, 27, 28]) 5 >>> longest_climb_series([3, 8, 13, 18, 23, 10, 20, 30, 40]) 5 >>> longest_climb_series([1]) 1 >>> longest_climb_series([10, 10, 10, 10, 10]) 5 >>> longest_climb_series([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 10","solution":"from typing import List def longest_climb_series(heights: List[int]) -> int: if len(heights) <= 1: return len(heights) max_length = 1 current_length = 1 current_diff = heights[1] - heights[0] for i in range(1, len(heights) - 1): diff = heights[i + 1] - heights[i] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 1 max_length = max(max_length, current_length + 1) # Adding 1 to account for the starting element of the series return max_length"},{"question":"def smallest_local_minimum(n, a): Returns the smallest local minimum from the list of integers \`a\` or -1 if no local minimum exists. Parameters: n (int): The number of elements in the list. a (List[int]): The list of integers. Returns: int: The smallest local minimum, or -1 if no local minimum exists. >>> smallest_local_minimum(5, [9, 6, 3, 14, 5]) 3 >>> smallest_local_minimum(4, [1, 1, 1, 1]) -1","solution":"def smallest_local_minimum(n, a): Returns the smallest local minimum from the list of integers \`a\` or -1 if no local minimum exists. Parameters: n (int): The number of elements in the list. a (List[int]): The list of integers. Returns: int: The smallest local minimum, or -1 if no local minimum exists. if n == 1: return a[0] local_minima = [] for i in range(n): if i == 0 and a[i] < a[i + 1]: local_minima.append(a[i]) elif i == n - 1 and a[i] < a[i - 1]: local_minima.append(a[i]) elif 0 < i < n - 1 and a[i] < a[i - 1] and a[i] < a[i + 1]: local_minima.append(a[i]) if not local_minima: return -1 else: return min(local_minima)"},{"question":"from typing import List def min_window(s: str, t: str) -> str: Find the smallest window in string \`s\` that contains all the characters of string \`t\`, and return it. If no such window exists, return an empty string. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> min_window(\\"A\\", \\"AA\\") '' >>> min_window(\\"AB\\", \\"A\\") 'A' ... # Unit Tests def test_min_window_example1(): assert min_window(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" def test_min_window_example2(): assert min_window(\\"A\\", \\"AA\\") == \\"\\" def test_min_window_example3(): assert min_window(\\"AB\\", \\"A\\") == \\"A\\" def test_min_window_no_occurrence(): assert min_window(\\"XYZ\\", \\"ABC\\") == \\"\\" def test_min_window_single_character(): assert min_window(\\"A\\", \\"A\\") == \\"A\\" def test_min_window_entire_string(): assert min_window(\\"ABCDE\\", \\"ABCED\\") == \\"ABCDE\\" def test_min_window_non_overlapping(): assert min_window(\\"ABCDAEBC\\", \\"ABC\\") == \\"ABC\\"","solution":"from collections import Counter, defaultdict def min_window(s, t): if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float(\\"inf\\") ans = (None, None) while r < len(s): character = s[r] window_counts[character] += 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = s[l] if r - l + 1 < min_length: min_length = r - l + 1 ans = (l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] is None else s[ans[0]: ans[1] + 1]"},{"question":"def count_unique_substrings(n: int, s: str) -> int: Returns the count of unique substrings of the given string s. Parameters: n (int): Length of the string s. s (str): The input string containing lowercase English letters. Returns: int: The count of unique substrings. >>> count_unique_substrings(3, \\"abc\\") 6 >>> count_unique_substrings(1, \\"a\\") 1 >>> count_unique_substrings(2, \\"aa\\") 2 >>> count_unique_substrings(2, \\"ab\\") 3 >>> count_unique_substrings(3, \\"aaa\\") 3 >>> count_unique_substrings(4, \\"abcd\\") 10 >>> count_unique_substrings(0, \\"\\") 0","solution":"def count_unique_substrings(n, s): Returns the count of unique substrings of the given string s. Parameters: n (int): Length of the string s. s (str): The input string containing lowercase English letters. Returns: int: The count of unique substrings. substrings = set() for i in range(n): for j in range(i+1, n+1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def max_subgrid_sum(grid): Computes the largest sum of any rectangular region within the grid. :param grid: 2D list of integers representing the grid. :return: The largest sum of any rectangular region. >>> grid = [ ... [1, 2, -1, 4, 5], ... [-1, -2, 3, 5, -3], ... [2, 3, 4, -2, -1], ... [-5, -9, -1, 2, 4] ... ] >>> max_subgrid_sum(grid) 19 >>> max_subgrid_sum([[5]]) 5 >>> max_subgrid_sum([[-5]]) -5 >>> grid = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> max_subgrid_sum(grid) -1 >>> grid = [ ... [1, 2], ... [3, 4], ... [-1, -5] ... ] >>> max_subgrid_sum(grid) 10 >>> grid = [ ... [2, 1, -3, -4, 5], ... [0, 6, 3, 4, 1], ... [2, -2, -1, 4, -5], ... [-3, 3, 1, 0, 3] ... ] >>> max_subgrid_sum(grid) 18","solution":"def max_subgrid_sum(grid): Computes the largest sum of any rectangular region within the grid. :param grid: 2D list of integers representing the grid. :return: The largest sum of any rectangular region. n = len(grid) m = len(grid[0]) max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] # Use Kadane's algorithm on temp array current_max = temp[0] global_max = temp[0] for j in range(1, n): current_max = max(temp[j], current_max + temp[j]) if current_max > global_max: global_max = current_max if global_max > max_sum: max_sum = global_max return max_sum def example_input(): Provides an example of input and parses it into a grid for testing. n, m = 4, 5 grid = [ [1, 2, -1, 4, 5], [-1, -2, 3, 5, -3], [2, 3, 4, -2, -1], [-5, -9, -1, 2, 4] ] return grid"},{"question":"def longest_increasing_subsequence(heights: List[int]) -> int: Returns the length of the longest strictly increasing subsequence of heights. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41]) 4 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([3, 2]) 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 >>> longest_increasing_subsequence([9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1, 1, 1, 1, 1, 1]) 1 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest strictly increasing subsequence of heights. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def can_tune_to_harmony(n: int, t: int, pitches: List[int], tuning_tools: List[int]) -> str: Determine if it is possible to tune the strings to the same pitch using the given tools. >>> can_tune_to_harmony(4, 3, [10, 15, 20, 25], [5, 5, 10]) 'YES' >>> can_tune_to_harmony(3, 2, [5, 10, 20], [3, 4]) 'NO'","solution":"def can_tune_to_harmony(n, t, pitches, tuning_tools): def can_tune(p1, p2, tuning_tools): diff = abs(p1 - p2) for tool in tuning_tools: if diff % tool == 0: return True return False pitch_set = set(pitches) for pitch in pitch_set: if all(can_tune(pitch, p, tuning_tools) for p in pitches): return \\"YES\\" return \\"NO\\""},{"question":"def divide_soldiers(n, strengths): Divides the soldiers between the two generals based on their combined strengths. Args: n (int): Number of soldiers. strengths (list): List of integers representing the strengths of the soldiers. Returns: tuple: A tuple containing two tuples. The first tuple contains the number of soldiers and combined strength for the first general, and the second tuple contains the number of soldiers and combined strength for the second general. >>> divide_soldiers(6, [1, 2, 4, 5, 8, 3]) ((4, 12), (2, 11)) >>> divide_soldiers(1, [5]) ((1, 5), (0, 0)) >>> divide_soldiers(4, [1, 1, 1, 1]) ((2, 2), (2, 2)) >>> divide_soldiers(5, [3, 3, 3, 3, 3]) ((3, 9), (2, 6)) >>> divide_soldiers(3, [10, 1, 1]) ((1, 10), (2, 2))","solution":"def divide_soldiers(n, strengths): Divides the soldiers between the two generals based on their combined strengths. Args: n (int): Number of soldiers. strengths (list): List of integers representing the strengths of the soldiers. Returns: tuple: A tuple containing two tuples. The first tuple contains the number of soldiers and combined strength for the first general, and the second tuple contains the number of soldiers and combined strength for the second general. total_strength = sum(strengths) half_strength = total_strength / 2 first_general_strength = 0 first_general_soldiers = 0 # First general selects soldiers until his combined strength is >= half of the total strength. for i in range(n): first_general_strength += strengths[i] first_general_soldiers += 1 if first_general_strength >= half_strength: break second_general_soldiers = n - first_general_soldiers second_general_strength = total_strength - first_general_strength return (first_general_soldiers, first_general_strength), (second_general_soldiers, second_general_strength)"},{"question":"def longest_increasing_subsequence(n: int, difficulties: List[int]) -> int: Returns the length of the longest strictly increasing subsequence of trails. :param n: Number of trails (integer) :param difficulties: List of integers representing difficulty levels of trails :return: Length of longest strictly increasing subsequence (integer) >>> longest_increasing_subsequence(9, [10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> longest_increasing_subsequence(1, [5]) == 1 >>> longest_increasing_subsequence(5, [1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence(5, [5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subsequence(8, [10, 20, 10, 30, 20, 40, 60, 30]) == 5 >>> longest_increasing_subsequence(6, [5, 10, 10, 10, 15, 20]) == 4 >>> longest_increasing_subsequence(0, []) == 0","solution":"def longest_increasing_subsequence(n, difficulties): Returns the length of the longest strictly increasing subsequence of trails. :param n: Number of trails (integer) :param difficulties: List of integers representing difficulty levels of trails :return: Length of longest strictly increasing subsequence (integer) if n == 0: return 0 # Initialize the list to store the length of the longest subsequence up to each trail lis = [1] * n # Compute the LIS values in a bottom-up manner for i in range(1, n): for j in range(i): if difficulties[i] > difficulties[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # The length of the longest increasing subsequence is the maximum value in lis return max(lis)"},{"question":"[Completion Task in Python] def minimum_packs(n, k, s, t): Calculate the minimum total number of packs of sweets and toys Anna needs to buy to prepare all the surprise boxes for her friends. >>> minimum_packs(3, 10, 3, 5) 3 >>> minimum_packs(3, 10, 0, 5) 2 >>> minimum_packs(3, 10, 3, 0) 1 >>> minimum_packs(5, 10, 7, 3) 6 >>> minimum_packs(10, 10, 1, 1) 2 pass def test_minimum_packs(): assert minimum_packs(3, 10, 3, 5) == 3 assert minimum_packs(1, 1, 1, 1) == 2 assert minimum_packs(10**8, 10**8, 1, 1) == 2 assert minimum_packs(5, 10, 7, 3) == 6 assert minimum_packs(10, 10, 1, 1) == 2 assert minimum_packs(4, 10, 0, 3) == 2 assert minimum_packs(4, 10, 3, 0) == 2","solution":"def minimum_packs(n, k, s, t): total_sweets_needed = n * s total_toys_needed = n * t # Calculate the number of packs for sweets and toys packs_sweets = (total_sweets_needed + k - 1) // k # Ceiling division packs_toys = (total_toys_needed + k - 1) // k # Ceiling division return packs_sweets + packs_toys"},{"question":"def distributeCandies(candies: List[int], m: int) -> int: Distribute candies to Vlad's friends such that the maximum sweetness any friend receives is minimized. >>> distributeCandies([7, 2, 5, 10, 8], 2) 18 >>> distributeCandies([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> distributeCandies([5], 1) 5 >>> distributeCandies([10, 10, 10, 10], 2) 20 >>> distributeCandies([1000000, 1000000, 1000000], 3) 1000000","solution":"def distributeCandies(candies, m): def canDistribute(mid): count = 1 current_sum = 0 for candy in candies: if current_sum + candy > mid: count += 1 current_sum = candy if count > m: return False else: current_sum += candy return True start, end = max(candies), sum(candies) result = end while start <= end: mid = (start + end) // 2 if canDistribute(mid): result = mid end = mid - 1 else: start = mid + 1 return result"},{"question":"from typing import List, Tuple def handshake_chains(n: int) -> Tuple[int, List[List[int]]]: Compute the maximum length of handshake chains and list all possible distinct handshake chains of that length. Args: n (int): The number of students. Returns: Tuple[int, List[List[int]]]: The maximum length of handshake chains, and a list of all possible distinct handshake chains. >>> handshake_chains(3) (3, [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ]) >>> handshake_chains(1) (0, []) pass def format_output(max_length: int, chains: List[List[int]]) -> None: Format and print the output with maximum length and all distinct handshake chains. Args: max_length (int): The maximum length of the handshake chain. chains (List[List[int]]): A list of all possible distinct handshake chains of maximum length. pass if __name__ == \\"__main__\\": import io import sys def test_handshake_chains_three_students(): output = io.StringIO() sys.stdout = output max_length, chains = handshake_chains(3) format_output(max_length, chains) result = output.getvalue().strip() expected_output = \\"n\\".join([ \\"3\\", \\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\" ]) assert result == expected_output output.close() def test_handshake_chains_one_student(): output = io.StringIO() sys.stdout = output max_length, chains = handshake_chains(1) format_output(max_length, chains) result = output.getvalue().strip() assert result == \\"0\\" output.close() def test_handshake_chains_no_student(): output = io.StringIO() sys.stdout = output max_length, chains = handshake_chains(0) format_output(max_length, chains) result = output.getvalue().strip() assert result == \\"0\\" output.close() def test_handshake_chains_two_students(): output = io.StringIO() sys.stdout = output max_length, chains = handshake_chains(2) format_output(max_length, chains) result = output.getvalue().strip() expected_output = \\"n\\".join([ \\"2\\", \\"1 2\\", \\"2 1\\" ]) assert result == expected_output output.close() test_handshake_chains_three_students() test_handshake_chains_one_student() test_handshake_chains_no_student() test_handshake_chains_two_students()","solution":"from itertools import permutations def handshake_chains(n): if n < 2: return 0, [] student_ids = list(range(1, n+1)) chains = list(permutations(student_ids)) return n, chains def format_output(max_length, chains): if max_length == 0: print(max_length) else: print(max_length) for chain in chains: print(\\" \\".join(map(str, chain))) # Example usage: # n = int(input().strip()) # max_length, chains = handshake_chains(n) # format_output(max_length, chains)"},{"question":"def is_valid_treasure_map(n: int, m: int, grid: List[List[str]]) -> str: Determine whether the provided grid map of Treasure Island is valid according to the pirates' superstition. :param n: int, number of rows in the grid :param m: int, number of columns in the grid :param grid: List[List[str]], the grid representing Treasure Island :return: str, \\"Valid\\" if the map is valid according to the superstition, \\"Invalid\\" otherwise Examples: >>> is_valid_treasure_map(4, 4, [\\"..T.\\", \\"....\\", \\".T..\\", \\"....\\"]) \\"Valid\\" >>> is_valid_treasure_map(3, 3, [\\".T.\\", \\".T.\\", \\"...\\"]) \\"Invalid\\" # You can use these test cases to validate your solution def test_valid_map_1(): n, m = 4, 4 grid = [ \\"..T.\\", \\"....\\", \\".T..\\", \\"....\\" ] assert is_valid_treasure_map(n, m, grid) == \\"Valid\\" def test_invalid_map_1(): n, m = 3, 3 grid = [ \\".T.\\", \\".T.\\", \\"...\\" ] assert is_valid_treasure_map(n, m, grid) == \\"Invalid\\" def test_valid_map_2(): n, m = 5, 5 grid = [ \\"T....\\", \\".....\\", \\".....\\", \\"...T.\\", \\".....\\" ] assert is_valid_treasure_map(n, m, grid) == \\"Valid\\" def test_invalid_map_2(): n, m = 5, 5 grid = [ \\"T...T\\", \\".T...\\", \\".....\\", \\"...T.\\", \\".....\\" ] assert is_valid_treasure_map(n, m, grid) == \\"Invalid\\" def test_edge_case_single_cell(): n, m = 1, 1 grid = [\\"T\\"] assert is_valid_treasure_map(n, m, grid) == \\"Valid\\" def test_edge_case_empty_grid(): n, m = 2, 2 grid = [ \\"..\\", \\"..\\" ] assert is_valid_treasure_map(n, m, grid) == \\"Valid\\"","solution":"def is_valid_treasure_map(n, m, grid): Determines whether the provided grid map of Treasure Island is valid according to the pirates' superstition. :param n: int, number of rows in the grid :param m: int, number of columns in the grid :param grid: List[List[str]], the grid representing Treasure Island :return: str, \\"Valid\\" if the map is valid according to the superstition, \\"Invalid\\" otherwise # Define the directions to check adjacent cells directions = [ (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1) ] for i in range(n): for j in range(m): if grid[i][j] == 'T': for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'T': return \\"Invalid\\" return \\"Valid\\" # Example usage: # n, m = 4, 4 # grid = [ # \\"..T.\\", # \\"....\\", # \\".T..\\", # \\"....\\" # ] # print(is_valid_treasure_map(n, m, grid)) # Output should be \\"Valid\\""},{"question":"def top_k_productive_employees(n: int, k: int, employees: List[Tuple[str, int]]) -> List[str]: Returns the names of the top k productive employees. :param n: Number of employees :param k: Number of top productive employees to find :param employees: List of tuples [(name, productivity_score), ...] :return: List of names of top k productive employees >>> top_k_productive_employees(5, 3, [(\\"alice\\", 450), (\\"bob\\", 200), (\\"charlie\\", 200), (\\"dave\\", 600), (\\"eve\\", 450)]) [\\"dave\\", \\"alice\\", \\"eve\\"] >>> top_k_productive_employees(1, 1, [(\\"alice\\", 450)]) [\\"alice\\"] >>> top_k_productive_employees(5, 3, [(\\"alice\\", 100), (\\"bob\\", 100), (\\"charlie\\", 100), (\\"dave\\", 100), (\\"eve\\", 100)]) [\\"alice\\", \\"bob\\", \\"charlie\\"] >>> top_k_productive_employees(5, 2, [(\\"alice\\", 200), (\\"bob\\", 200), (\\"charlie\\", 200), (\\"dave\\", 200), (\\"eve\\", 300)]) [\\"eve\\", \\"alice\\"] >>> top_k_productive_employees(4, 2, [(\\"alice\\", -100), (\\"bob\\", -200), (\\"charlie\\", -150), (\\"dave\\", -50)]) [\\"dave\\", \\"alice\\"] >>> top_k_productive_employees(5, 3, [(\\"alice\\", -100), (\\"bob\\", 200), (\\"charlie\\", 150), (\\"dave\\", -50), (\\"eve\\", 200)]) [\\"bob\\", \\"eve\\", \\"charlie\\"]","solution":"def top_k_productive_employees(n, k, employees): Returns the names of the top k productive employees. :param n: Number of employees :param k: Number of top productive employees to find :param employees: List of tuples [(name, productivity_score), ...] :return: List of names of top k productive employees # Sort employees by score (descending) and by name (lexicographically) if scores are equal sorted_employees = sorted(employees, key=lambda x: (-x[1], x[0])) # Extract the names of the top k productive employees top_k_employees = [emp[0] for emp in sorted_employees[:k]] return top_k_employees # Example usage: # employees_list = [(\\"alice\\", 450), (\\"bob\\", 200), (\\"charlie\\", 200), (\\"dave\\", 600), (\\"eve\\", 450)] # print(top_k_productive_employees(5, 3, employees_list))"},{"question":"def distinct_substrings(s: str, k: int) -> int: Determine the number of distinct substrings of length k in the given string. >>> distinct_substrings(\\"abcabc\\", 2) 3 >>> distinct_substrings(\\"abc\\", 4) 0 >>> distinct_substrings(\\"aaaaa\\", 1) 1 >>> distinct_substrings(\\"abcdef\\", 3) 4 >>> distinct_substrings(\\"ababa\\", 2) 2 if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)","solution":"def distinct_substrings(s, k): Function to determine the number of distinct substrings of length k in the given string s. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)"},{"question":"def can_split_with_pairs(arr: List[int]) -> str: Checks if the array can be split into two non-empty parts such that each part contains at least one pair of equal integers. >>> can_split_with_pairs([1, 2, 1, 3, 2, 3]) == \\"YES\\" >>> can_split_with_pairs([1, 2, 3]) == \\"NO\\" >>> can_split_with_pairs([4, 5, 4, 5, 4, 5]) == \\"YES\\" >>> can_split_with_pairs([1, 1]) == \\"NO\\" >>> can_split_with_pairs([9, 9, 8, 8, 7, 7]) == \\"YES\\" >>> can_split_with_pairs([7, 1, 2, 3, 4, 5, 6]) == \\"NO\\" >>> can_split_with_pairs([4, 4, 4, 4, 4]) == \\"NO\\" >>> can_split_with_pairs([i for i in range(1, 150001)] + [i for i in range(1, 150001)]) == \\"YES\\"","solution":"def can_split_with_pairs(arr): Checks if the array can be split into two non-empty parts such that each part contains at least one pair of equal integers. from collections import Counter # Count the occurrences of each number. count = Counter(arr) # Check if there are at least two different numbers having at least 2 occurrences. pair_count = 0 for cnt in count.values(): if cnt >= 2: pair_count += 1 if pair_count >= 2: return \\"YES\\" return \\"NO\\""},{"question":"class ArrayHandler: def __init__(self, arr): self.arr = arr def update(self, i, x): Update the element at index i to x. pass def sum_range(self, l, r): Return the sum of the elements in the subarray from index l to index r (inclusive). pass def process_queries(n, q, arr, queries): Process multiple update and sum queries on an array. n: int - number of elements in the array q: int - number of queries arr: List[int] - list of integers representing the array queries: List[str] - list of query strings Returns a list of results for each sum query. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [\\"2 1 3\\", \\"1 2 10\\", \\"2 1 3\\"]) [9, 16] >>> process_queries(1, 2, [10], [\\"2 0 0\\", \\"1 0 20\\"]) [10] pass def test_process_queries_example_case(): n = 5 q = 3 arr = [1, 2, 3, 4, 5] queries = [\\"2 1 3\\", \\"1 2 10\\", \\"2 1 3\\"] expected_output = [9, 16] assert process_queries(n, q, arr, queries) == expected_output def test_process_queries_single_update(): n = 3 q = 2 arr = [1, 2, 3] queries = [\\"1 1 5\\", \\"2 0 2\\"] expected_output = [9] assert process_queries(n, q, arr, queries) == expected_output def test_process_queries_multiple_updates(): n = 4 q = 4 arr = [1, 2, 3, 4] queries = [\\"1 0 10\\", \\"2 0 1\\", \\"1 3 8\\", \\"2 2 3\\"] expected_output = [12, 11] assert process_queries(n, q, arr, queries) == expected_output def test_process_queries_sum_entire_array(): n = 4 q = 1 arr = [10, 20, 30, 40] queries = [\\"2 0 3\\"] expected_output = [100] assert process_queries(n, q, arr, queries) == expected_output def test_process_queries_min_max_constraints(): n = 1 q = 2 arr = [10] queries = [\\"2 0 0\\", \\"1 0 20\\"] expected_output = [10] assert process_queries(n, q, arr, queries) == expected_output","solution":"class ArrayHandler: def __init__(self, arr): self.arr = arr def update(self, i, x): self.arr[i] = x def sum_range(self, l, r): return sum(self.arr[l:r+1]) # Function to process the queries def process_queries(n, q, arr, queries): arr_handler = ArrayHandler(arr) results = [] for query in queries: parts = query.split() type_of_query = int(parts[0]) if type_of_query == 1: i = int(parts[1]) x = int(parts[2]) arr_handler.update(i, x) elif type_of_query == 2: l = int(parts[1]) r = int(parts[2]) results.append(arr_handler.sum_range(l, r)) return results"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"abc\\", \\"yabd\\") 2 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"hello\\", \\"hello\\") 0 >>> min_operations(\\"hello\\", \\"\\") 5 >>> min_operations(\\"\\", \\"world\\") 5 >>> min_operations(\\"abc\\", \\"xyz\\") 3 pass def process_multiple_cases(cases: list) -> list: Processes multiple case pairs for min_operations and returns a list of results. >>> process_multiple_cases([(\\"abcdef\\", \\"azced\\"), (\\"abc\\", \\"yabd\\"), (\\"kitten\\", \\"sitting\\")]) [3, 2, 3] pass","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n] def process_multiple_cases(cases): results = [] for s1, s2 in cases: results.append(min_operations(s1, s2)) return results"},{"question":"def max_books_on_shelf(n: int, m: int, W: int, books: List[Tuple[int, int]]) -> int: Determine the maximum number of books that can be placed on the bookshelf. Parameters: n (int): The number of books. m (int): The number of different genres. W (int): The width of the bookshelf. books (List[Tuple[int, int]]): A list of tuples where each tuple contains the width and genre of a book. Returns: int: The maximum number of books that can be placed on the shelf. >>> max_books_on_shelf(5, 3, 10, [(2, 1), (3, 2), (4, 1), (5, 3), (1, 2)]) 4 >>> max_books_on_shelf(5, 1, 10, [(2, 1), (3, 1), (4, 1), (5, 1), (1, 1)]) 4 >>> max_books_on_shelf(3, 2, 5, [(2, 1), (4, 1), (3, 2)]) 2 >>> max_books_on_shelf(0, 1, 10, []) 0 >>> max_books_on_shelf(4, 2, 10, [(5, 1), (2, 1), (3, 2), (5, 2)]) 3","solution":"def max_books_on_shelf(n, m, W, books): from collections import defaultdict # Group books by genre and sort each group by width genre_dict = defaultdict(list) for width, genre in books: genre_dict[genre].append(width) for genre in genre_dict: genre_dict[genre].sort() # Dynamic programming array to store max books can be placed upto width j dp = [0] * (W + 1) # Loop through each genre for genre in genre_dict: genre_books = genre_dict[genre] len_genre_books = len(genre_books) # We use rolling dp to avoid recomputing states for j in range(W, -1, -1): current_width = 0 for k in range(len_genre_books): current_width += genre_books[k] if current_width > j: break dp[j] = max(dp[j], dp[j - current_width] + k + 1) return max(dp) # Parsing the input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) W = int(data[2]) books = [] for i in range(n): width = int(data[3 + 2 * i]) genre = int(data[4 + 2 * i]) books.append((width, genre)) print(max_books_on_shelf(n, m, W, books))"},{"question":"def find_mst_total_strength(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Finds the total strength of the minimum spanning tree (MST) connecting all species. >>> find_mst_total_strength(4, 5, [(1, 2, 3), (1, 3, 1), (2, 3, 4), (3, 4, 2), (2, 4, 5)]) 6 >>> find_mst_total_strength(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> find_mst_total_strength(1, 0, []) 0 >>> find_mst_total_strength(2, 1, [(1, 2, 5)]) 5 >>> find_mst_total_strength(6, 4, [(1, 2, 10), (3, 4, 15), (4, 5, 10), (5, 6, 10)]) -1","solution":"def find_mst_total_strength(n, m, edges): Finds the total strength of the minimum spanning tree (MST) connecting all species. Parameters: n : int : Number of species m : int : Number of relationships edges : list of tuples : List containing the relationships represented as (u, v, w) Returns: int : The total strength of the MST from heapq import heappop, heappush # Create an adjacency list adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((w, v)) adj[v].append((w, u)) # Initialize min-heap for Prim's algorithm min_heap = [(0, 1)] # (cost, node), starting with node 1 and cost 0 total_cost = 0 visited = set() # Prim's algorithm to find MST while min_heap and len(visited) < n: cost, node = heappop(min_heap) if node not in visited: visited.add(node) total_cost += cost for next_cost, next_node in adj[node]: if next_node not in visited: heappush(min_heap, (next_cost, next_node)) # If we have not visited all nodes, that means the graph is not fully connected if len(visited) != n: return -1 # or some error value as the graph isn't fully connected. return total_cost # Reading input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) edges.append((u, v, w)) index += 3 print(find_mst_total_strength(n, m, edges)) # Uncomment to test using main function # if __name__ == \\"__main__\\": # main()"},{"question":"from typing import List def find_unsorted_subarray(nums: List[int]) -> List[int]: Finds the shortest subarray that, when sorted, sorts the entire array. If the array is already sorted, returns an empty list. >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) [1, 5] >>> find_unsorted_subarray([1, 2, 3, 4, 5]) [] def test_find_unsorted_subarray(): assert find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) == [1, 5] assert find_unsorted_subarray([1, 3, 2, 3, 4]) == [1, 2] assert find_unsorted_subarray([2, 1]) == [0, 1] assert find_unsorted_subarray([1, 2, 3, 4, 5]) == [] assert find_unsorted_subarray([1]) == [] assert find_unsorted_subarray([1, 4, 3, 2, 2, 1]) == [1, 5] assert find_unsorted_subarray([1, 2, 3, 3, 3]) == [] assert find_unsorted_subarray([1, 2, 3, 4, 3, 5, 6, 7, 8, 9, 10]) == [3, 4]","solution":"from typing import List def find_unsorted_subarray(nums: List[int]) -> List[int]: Finds the shortest subarray that, when sorted, sorts the entire array. If the array is already sorted, returns an empty list. n = len(nums) if n <= 1: return [] left, right = 0, n - 1 while left < right and nums[left] <= nums[left + 1]: left += 1 while right > left and nums[right] >= nums[right - 1]: right -= 1 if left == n - 1: return [] sub_min = min(nums[left:right + 1]) sub_max = max(nums[left:right + 1]) while left > 0 and nums[left - 1] > sub_min: left -= 1 while right < n - 1 and nums[right + 1] < sub_max: right += 1 return [left, right]"},{"question":"def count_special_palindromes(s: str) -> int: Count the number of special palindromes that can be formed from any substring of the given string s. A special palindrome is defined as a string that contains any character at most once, except one character that can appear any number of times. Args: s (str): The input string consisting of lowercase alphabetic characters. Returns: int: The number of special palindromes formed from any substring of the string s. Examples: >>> count_special_palindromes(\\"a\\") 1 >>> count_special_palindromes(\\"aaaa\\") 10 >>> count_special_palindromes(\\"ab\\") 2 >>> count_special_palindromes(\\"aabaa\\") 9 >>> count_special_palindromes(\\"abcba\\") 7 >>> count_special_palindromes(\\"abcde\\") 5","solution":"def count_special_palindromes(s): n = len(s) count = 0 # Single character substrings are always special palindromes count += n # Consecutive same characters substrings i = 0 while i < n: same_char_count = 1 while i + 1 < n and s[i] == s[i + 1]: i += 1 same_char_count += 1 count += (same_char_count * (same_char_count - 1)) // 2 i += 1 # Substrings of format \\"xyx\\", \\"xyyx\\" and so on for i in range(1, n - 1): same_char_count = 1 while i + same_char_count < n and i - same_char_count >= 0 and s[i + same_char_count] == s[i - same_char_count] and s[i - same_char_count] != s[i]: count += 1 same_char_count += 1 return count"},{"question":"def calculate_total_weights(harvest_data): Calculate the total weights for each crop type. Args: harvest_data (list of tuples): A list of tuples where each tuple contains two integers, the type of crop (1 for wheat, 2 for corn, 3 for barley) and the weight of the crop in kg. Returns: tuple: A tuple with three integers representing the total weights of wheat, corn, and barley. from solution import calculate_total_weights def test_single_crop_each_type(): harvest_data = [(1, 100), (2, 200), (3, 300)] assert calculate_total_weights(harvest_data) == (100, 200, 300) def test_multiple_crops_each_type(): harvest_data = [(1, 500), (2, 300), (3, 400), (1, 200), (3, 100)] assert calculate_total_weights(harvest_data) == (700, 300, 500) def test_all_same_type(): harvest_data = [(1, 100), (1, 200), (1, 300)] assert calculate_total_weights(harvest_data) == (600, 0, 0) def test_no_crops(): harvest_data = [] assert calculate_total_weights(harvest_data) == (0, 0, 0) def test_various_weights(): harvest_data = [(1, 250000), (2, 500000), (3, 750000), (2, 500000), (1, 500000), (3, 250000)] assert calculate_total_weights(harvest_data) == (750000, 1000000, 1000000)","solution":"def calculate_total_weights(harvest_data): Calculate the total weights for each crop type. Args: harvest_data (list of tuples): A list of tuples where each tuple contains two integers, the type of crop (1 for wheat, 2 for corn, 3 for barley) and the weight of the crop in kg. Returns: tuple: A tuple with three integers representing the total weights of wheat, corn, and barley. # Initialize totals for wheat, corn, and barley wheat_total = 0 corn_total = 0 barley_total = 0 # Iterate over the harvested data to calculate totals for crop_type, weight in harvest_data: if crop_type == 1: wheat_total += weight elif crop_type == 2: corn_total += weight elif crop_type == 3: barley_total += weight return (wheat_total, corn_total, barley_total) # Example usage: # harvest_data = [(1, 500), (2, 300), (3, 400), (1, 200), (3, 100)] # print(calculate_total_weights(harvest_data)) # Output: (700, 300, 500)"},{"question":"from typing import List def max_palindrome_length(s: str) -> int: Given a string s, this function returns the length of the longest palindrome that can be obtained by rearranging the characters of the string. def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Given number of test cases t and a list of test cases consisting of strings, this function returns a list of integers where each integer denotes the length of the longest possible palindrome for the corresponding test case. results = [] for s in test_cases: results.append(max_palindrome_length(s)) return results # Example usage print(process_test_cases(3, [\\"abccccdd\\", \\"aabb\\", \\"abc\\"])) # Output: [7, 4, 1] # Unit tests def test_example_cases(): assert process_test_cases(3, [\\"abccccdd\\", \\"aabb\\", \\"abc\\"]) == [7, 4, 1] def test_single_character(): assert process_test_cases(1, [\\"a\\"]) == [1] def test_even_length_palindrome(): assert process_test_cases(1, [\\"aa\\"]) == [2] def test_odd_length_palindrome(): assert process_test_cases(1, [\\"aaa\\"]) == [3] def test_mixed_characters(): assert process_test_cases(1, [\\"aabbccc\\"]) == [7] def test_all_different_characters(): assert process_test_cases(1, [\\"abcdefg\\"]) == [1] def test_single_repeated_character(): assert process_test_cases(1, [\\"aaaaaaa\\"]) == [7] def test_mixed_length_string(): assert process_test_cases(1, [\\"abcddcbae\\"]) == [9] def test_multiple_even_odd_characters(): assert process_test_cases(3, [\\"abc\\", \\"aabbcc\\", \\"aaabbbccc\\"]) == [1, 6, 7]","solution":"from collections import Counter def max_palindrome_length(s): Given a string s, this function returns the length of the longest palindrome that can be obtained by rearranging the characters of the string. count = Counter(s) length = 0 odd_count = False for count_value in count.values(): if count_value % 2 == 0: length += count_value else: length += count_value - 1 odd_count = True if odd_count: length += 1 return length def process_test_cases(t, test_cases): Given number of test cases t and a list of test cases consisting of strings, this function returns a list of integers where each integer denotes the length of the longest possible palindrome for the corresponding test case. results = [] for s in test_cases: results.append(max_palindrome_length(s)) return results"},{"question":"def max_subarray_with_distinct_elements(nums: List[int]) -> int: Given an integer array nums, find the maximum value of a subarray that has no duplicate elements. A subarray is defined as a contiguous segment of the array. >>> max_subarray_with_distinct_elements([2, 1, 5, 2, 3, 5, 7]) 17 >>> max_subarray_with_distinct_elements([2, 2, 2, 2, 2]) 2 >>> max_subarray_with_distinct_elements([10]) 10 >>> max_subarray_with_distinct_elements([1, 2, 3, 4]) 10 >>> max_subarray_with_distinct_elements([i for i in range(1, 10001)]) 50005000 >>> max_subarray_with_distinct_elements([4, 2, 4, 5, 6]) 17 >>> max_subarray_with_distinct_elements([1, 2, 3, 1, 2, 3, 4, 5]) 15 >>> max_subarray_with_distinct_elements([]) 0 >>> max_subarray_with_distinct_elements([5, 1, 5, 1, 5, 1, 5, 1]) 6","solution":"def max_subarray_with_distinct_elements(nums): # Dictionary to store the last occurrence of elements last_occurrence = {} max_sum = 0 current_sum = 0 start = 0 for end in range(len(nums)): # If the element already exists in the current window, move the 'start' pointer if nums[end] in last_occurrence and last_occurrence[nums[end]] >= start: start = last_occurrence[nums[end]] + 1 current_sum = sum(nums[start:end+1]) else: current_sum += nums[end] # Update the last occurrence of the current element last_occurrence[nums[end]] = end # Update the max sum max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_operations_to_make_equal(n: int, m: int, a: str, b: str) -> int: Returns the minimum number of operations required to make the strings 'a' and 'b' equal by increasing character frequencies. Parameters: n (int): Length of string a. m (int): Length of string b. a (str): First string. b (str): Second string. Returns: int: Minimum number of operations required to make the strings equal, or -1 if it's impossible. >>> min_operations_to_make_equal(3, 3, \\"abc\\", \\"abc\\") 0 >>> min_operations_to_make_equal(3, 4, \\"abc\\", \\"abcd\\") -1 >>> min_operations_to_make_equal(3, 3, \\"aaa\\", \\"bbb\\") -1 >>> min_operations_to_make_equal(4, 4, \\"aabb\\", \\"abab\\") 0 >>> min_operations_to_make_equal(5, 5, \\"abcde\\", \\"abcde\\") 0 >>> min_operations_to_make_equal(4, 4, \\"abcd\\", \\"efgh\\") -1 pass","solution":"def min_operations_to_make_equal(n, m, a, b): Returns the minimum number of operations required to make the strings 'a' and 'b' equal by increasing character frequencies. if n != m: return -1 # Count frequency of each character in both strings freq_a = [0] * 26 freq_b = [0] * 26 for char in a: freq_a[ord(char) - ord('a')] += 1 for char in b: freq_b[ord(char) - ord('a')] += 1 # Check if we can make the strings equal operations = 0 for i in range(26): if freq_a[i] != freq_b[i]: return -1 operations += abs(freq_a[i] - freq_b[i]) return max(operations // 2, 0) # Each operation involves one increment in a string"},{"question":"def max_weight_subarray(grid: List[List[int]]) -> int: Returns the maximum weight of any subarray in the grid. :param grid: List of lists, where each inner list represents a row in the grid :return: Integer, maximum weight of any subarray >>> max_weight_subarray([[10]]) == 10 >>> max_weight_subarray([[1, 2], [3, 4]]) == 10 >>> max_weight_subarray([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 >>> max_weight_subarray([[1, 2, 3, 4, 5]]) == 15 >>> max_weight_subarray([[1], [2], [3], [4], [5]]) == 15 >>> max_weight_subarray([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) == 78","solution":"def max_weight_subarray(grid): Returns the maximum weight of any subarray in the grid. :param grid: List of lists, where each inner list represents a row in the grid :return: Integer, maximum weight of any subarray n = len(grid) m = len(grid[0]) max_weight = float('-inf') # Calculate prefix sums for the grid prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i+1][j+1] = grid[i][j] + prefix_sum[i][j+1] + prefix_sum[i+1][j] - prefix_sum[i][j] # Evaluate maximum sum of all possible subarrays using prefix sums for start_row in range(n): for end_row in range(start_row, n): for start_col in range(m): for end_col in range(start_col, m): current_sum = (prefix_sum[end_row + 1][end_col + 1] - prefix_sum[start_row][end_col + 1] - prefix_sum[end_row + 1][start_col] + prefix_sum[start_row][start_col]) max_weight = max(max_weight, current_sum) return max_weight"},{"question":"def max_serviced_orders(n: int, m: int, k: int, capacities: List[int], routes: List[Tuple[int, int]]) -> int: Determines the maximum number of orders that can be serviced in a single day considering the capacity constraints. Args: n: int - number of warehouses and delivery zones combined m: int - number of direct delivery routes k: int - number of orders to be serviced capacities: List[int] - list of capacities of warehouses and delivery zones routes: List[Tuple[int, int]] - list of direct routes between nodes Returns: int - maximum number of orders that can be serviced Example: >>> max_serviced_orders(6, 7, 20, [3, 2, 2, 5, 1, 3], [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (3, 5), (4, 5)]) 16 >>> max_serviced_orders(4, 3, 50, [10, 10, 10, 10], [(0, 1), (1, 2), (2, 3)]) 40","solution":"def max_serviced_orders(n, m, k, capacities, routes): Determines the maximum number of orders that can be serviced in a single day considering the capacity constraints. Args: n: int - number of warehouses and delivery zones combined m: int - number of direct delivery routes k: int - number of orders to be serviced capacities: List[int] - list of capacities of warehouses and delivery zones routes: List[Tuple[int, int]] - list of direct routes between nodes Returns: int - maximum number of orders that can be serviced # Since every node has a capacity, the maximum number of orders # that can be handled by any network is the sum of all capacities. max_possible_orders = sum(capacities) # The number of orders that can actually be serviced is the minimum of # the desired orders (k) and the maximum possible orders given the capacities. return min(k, max_possible_orders)"},{"question":"def sieve(n): Implements the Sieve of Eratosthenes to find all prime numbers up to n. def precompute_prime_count(n, is_prime): Precompute the prime count up to each number from 1 to n. def count_primes_in_range(prime_count, a, b): Count the number of primes in the range [a, b] using the precomputed prime count array. def process_queries(n, primes, queries): Process each query to count the number of primes in the specified range. # Test cases def test_sieve(): assert sieve(10) == [False, False, True, True, False, True, False, True, False, False, False] assert sieve(1) == [False, False] def test_precompute_prime_count(): assert precompute_prime_count(10, [False, False, True, True, False, True, False, True, False, False, False]) == [0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4] assert precompute_prime_count(5, [False, False, True, True, False, True]) == [0, 0, 1, 2, 2, 3] def test_count_primes_in_range(): prime_count = [0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4] assert count_primes_in_range(prime_count, 1, 10) == 4 assert count_primes_in_range(prime_count, 2, 5) == 3 assert count_primes_in_range(prime_count, 7, 10) == 1 def test_process_queries(): primes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] queries = [(1, 10), (2, 5), (7, 10)] results = process_queries(10, primes, queries) assert results == [4, 3, 1] # Running the tests if __name__ == \\"__main__\\": test_sieve() test_precompute_prime_count() test_count_primes_in_range() test_process_queries() print(\\"All tests passed.\\")","solution":"def sieve(n): Implements the Sieve of Eratosthenes to find all prime numbers up to n. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return is_prime def precompute_prime_count(n, is_prime): Precompute the prime count up to each number from 1 to n. prime_count = [0] * (n + 1) count = 0 for i in range(1, n + 1): if is_prime[i]: count += 1 prime_count[i] = count return prime_count def count_primes_in_range(prime_count, a, b): Count the number of primes in the range [a, b] using the precomputed prime count array. return prime_count[b] - prime_count[a - 1] def process_queries(n, primes, queries): Process each query to count the number of primes in the specified range. results = [] is_prime = sieve(max(primes)) prime_count = precompute_prime_count(max(primes), is_prime) for a, b in queries: results.append(count_primes_in_range(prime_count, a, b)) return results"},{"question":"def smallest_square_tile_size(a: int, b: int) -> int: Returns the side length of the smallest square tile that can be used to cover the entire rectangle of dimensions a and b. >>> smallest_square_tile_size(4, 6) 2 >>> smallest_square_tile_size(5, 7) 1","solution":"def smallest_square_tile_size(a, b): Returns the side length of the smallest square tile that can be used to cover the entire rectangle of dimensions a and b. def gcd(x, y): # helper function to calculate gcd while y: x, y = y, x % y return x return gcd(a, b)"},{"question":"def max_treasure(n: int, treasures: List[int], doors: List[int]) -> int: Compute the maximum amount of treasure that can be collected starting from any room. >>> max_treasure(5, [10, 20, 30, 40, 50], [2, 3, 4, 5, 1]) 150 >>> max_treasure(3, [5, 5, 5], [2, 3, 1]) 15 >>> max_treasure(1, [100], [1]) 100","solution":"def max_treasure(n, treasures, doors): # Since each room leads to another and eventually visits all rooms, we sum all treasure values. return sum(treasures)"},{"question":"def arrange_rooks(n: int, m: int) -> (str, list): Arrange m rooks on an n x n grid such that each rook attacks exactly one other rook, and no two rooks attack each other from the same direction. Parameters: n (int): size of the grid m (int): number of rooks Returns: (str, list of tuples): \\"YES\\" followed by positions of rooks if arrangement is possible, otherwise \\"NO\\" >>> arrange_rooks(2, 2) (\\"YES\\", [(1, 2), (2, 1)]) >>> arrange_rooks(4, 2) (\\"YES\\", [(1, 2), (2, 3)]) >>> arrange_rooks(4, 4) (\\"YES\\", [(1, 2), (2, 3), (3, 4), (4, 1)]) >>> arrange_rooks(3, 4) (\\"NO\\", []) >>> arrange_rooks(5, 1) (\\"YES\\", [(1, 2)]) >>> arrange_rooks(100, 100) (\\"YES\\", [(i, i % 100 + 1) for i in range(1, 101)])","solution":"def arrange_rooks(n, m): Arrange m rooks on an n x n grid such that each rook attacks exactly one other rook, and no two rooks attack each other from the same direction. Parameters: n (int): size of the grid m (int): number of rooks Returns: (str, list of tuples): \\"YES\\" followed by positions of rooks if arrangement is possible, otherwise \\"NO\\" if m > n: return \\"NO\\", [] positions = [] for i in range(1, m + 1): positions.append((i, i % n + 1)) return \\"YES\\", positions"},{"question":"from typing import List def max_triangle_perimeter(n: int, h: List[int]) -> int: Returns the maximum perimeter of a magic triangle, or -1 if no valid triangle can be formed. n: int, number of trees h: list of int, heights of the trees >>> max_triangle_perimeter(5, [1, 2, 2, 4, 3]) 9 >>> max_triangle_perimeter(3, [1, 1, 2]) -1 Unit Test: from solution import max_triangle_perimeter def test_example_case(): n = 5 h = [1, 2, 2, 4, 3] assert max_triangle_perimeter(n, h) == 9 def test_no_triangle_possible(): n = 3 h = [1, 1, 2] assert max_triangle_perimeter(n, h) == -1 def test_large_numbers(): n = 4 h = [1000000000, 1000000000, 1000000000, 2] assert max_triangle_perimeter(n, h) == 3000000000 def test_minimum_input_size(): n = 3 h = [1, 2, 2] assert max_triangle_perimeter(n, h) == 5 def test_unsorted_input(): n = 6 h = [5, 10, 25, 6, 4, 3] assert max_triangle_perimeter(n, h) == 21 def test_all_same_height(): n = 5 h = [4, 4, 4, 4, 4] assert max_triangle_perimeter(n, h) == 12","solution":"def max_triangle_perimeter(n, h): Returns the maximum perimeter of a magic triangle, or -1 if no valid triangle can be formed. n: int, number of trees h: list of int, heights of the trees h.sort() for i in range(n-3, -1, -1): if h[i] + h[i+1] > h[i+2]: return h[i] + h[i+1] + h[i+2] return -1"},{"question":"def calculate_influence_scores(N, M, connections): Calculates the influence scores for each user based on mutual connections. Parameters: N (int): Number of users. M (int): Number of mutual connections. connections (list of tuples): Each tuple contains two integers representing a mutual connection. Returns: list: A list of N integers representing the influence scores of each user. Example: >>> calculate_influence_scores(5, 4, [(1, 2), (1, 3), (2, 3), (4, 5)]) [2, 2, 2, 1, 1] >>> calculate_influence_scores(1, 0, []) [0] >>> calculate_influence_scores(3, 0, []) [0, 0, 0] >>> calculate_influence_scores(4, 4, [(1, 2), (1, 3), (1, 4), (2, 3)]) [3, 2, 2, 1] >>> calculate_influence_scores(3, 3, [(1, 2), (1, 3), (2, 3)]) [2, 2, 2] pass","solution":"def calculate_influence_scores(N, M, connections): Calculates the influence scores for each user. Parameters: N (int): Number of users. M (int): Number of mutual connections. connections (list of tuples): Each tuple contains two integers representing a mutual connection. Returns: list: A list of N integers representing the influence scores of each user. from collections import defaultdict influence_scores = [0] * N graph = defaultdict(set) for u, v in connections: graph[u - 1].add(v - 1) graph[v - 1].add(u - 1) for i in range(N): influence_scores[i] = len(graph[i]) return influence_scores"},{"question":"def can_transform(s: str, t: str) -> int: Determine if it is possible to transform s into t and the minimum number of operations required. :param s: Source string :param t: Target string :return: minimum number of operations to transform s into t or -1 if impossible >>> can_transform(\\"abcde\\", \\"edcba\\") 1 >>> can_transform(\\"abcd\\", \\"bcda\\") 4 >>> can_transform(\\"abc\\", \\"def\\") -1 >>> can_transform(\\"abcdefghij\\", \\"jihgfedcba\\") 1 >>> can_transform(\\"abc\\", \\"abc\\") 3","solution":"def can_transform(s, t): Determine if it is possible to transform s into t and the minimum number of operations required. :param s: Source string :param t: Target string :return: minimum number of operations to transform s into t or -1 if impossible # First check if s and t have the same characters with the same frequency if sorted(s) != sorted(t): return -1 # Check if reversing the string s makes it equal to t if s[::-1] == t: return 1 # Otherwise, we cannot immediately determine the steps counts, # A full greedy algorithm can be very complicated, and here we assume an upper bound # Replacing every character should surely turn s to t, making this upper bound len(s) as a straight-forward replacement operation set return len(s)"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge overlapping and adjacent intervals. >>> merge_intervals([[1, 5], [4, 6], [8, 10], [9, 12]]) [[1, 6], [8, 12]] >>> merge_intervals([[1, 3], [5, 7], [8, 10]]) [[1, 3], [5, 7], [8, 10]] >>> merge_intervals([[1, 4], [4, 5], [5, 7]]) [[1, 7]] >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18], [17, 20]]) [[1, 6], [8, 10], [15, 20]] >>> merge_intervals([[1, 2]]) [[1, 2]] >>> merge_intervals([[1, 2], [1, 2], [1, 2]]) [[1, 2]]","solution":"def merge_intervals(intervals): # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval does not overlap with the previous one, # simply append it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, so we merge the current interval with the previous one. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def is_substring_after_one_swap(s1: str, s2: str) -> str: Checks if s2 can be a substring of s1 after at most one swap in s2. Parameters: s1 (str): The main string. s2 (str): The string to check as a substring. Returns: str: \\"YES\\" if s2 can be a substring of s1 after at most one swap, otherwise \\"NO\\". >>> is_substring_after_one_swap(\\"abcdefghij\\", \\"bac\\") \\"YES\\" >>> is_substring_after_one_swap(\\"abcdefg\\", \\"gfhd\\") \\"NO\\" >>> is_substring_after_one_swap(\\"abcdefghij\\", \\"abc\\") \\"YES\\" >>> is_substring_after_one_swap(\\"abcdefghij\\", \\"jhi\\") \\"NO\\" >>> is_substring_after_one_swap(\\"a\\", \\"a\\") \\"YES\\" >>> is_substring_after_one_swap(\\"abcdefg\\", \\"gf\\") \\"YES\\" >>> is_substring_after_one_swap(\\"abcdefg\\", \\"hh\\") \\"NO\\"","solution":"def is_substring_after_one_swap(s1, s2): Checks if s2 can be a substring of s1 after at most one swap in s2. Parameters: s1 (str): The main string. s2 (str): The string to check as a substring. Returns: str: \\"YES\\" if s2 can be a substring of s1 after at most one swap, otherwise \\"NO\\". n = len(s1) m = len(s2) # Helper function to check if s2 is in s1 def check_substring(s1, s2): return s2 in s1 # Check if s2 is already a substring of s1 if check_substring(s1, s2): return \\"YES\\" # Attempt one swap for each pair of characters in s2 for i in range(m): for j in range(i + 1, m): # Swap characters at positions i and j in s2 swapped_s2 = list(s2) swapped_s2[i], swapped_s2[j] = swapped_s2[j], swapped_s2[i] swapped_s2 = ''.join(swapped_s2) # Check if the swapped s2 is a substring of s1 if check_substring(s1, swapped_s2): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def minimum_completion_time(n: int, tasks: List[Tuple[int, int]]) -> int: Calculate the minimum total time required to complete all tasks taking into consideration that tasks with the same ID must be executed sequentially. >>> minimum_completion_time(3, [(1, 3), (2, 2), (1, 5)]) 10 >>> minimum_completion_time(4, [(1, 3), (2, 2), (1, 6), (2, 1)]) 12 pass # Unit tests def test_single_task(): assert minimum_completion_time(1, [(1, 3)]) == 3 def test_multiple_tasks_different_ids(): assert minimum_completion_time(3, [(1, 3), (2, 2), (3, 1)]) == 6 def test_multiple_tasks_same_ids(): assert minimum_completion_time(4, [(1, 3), (1, 5), (1, 2), (1, 4)]) == 14 def test_mixed_tasks(): assert minimum_completion_time(4, [(1, 3), (2, 2), (1, 6), (2, 1)]) == 12 def test_zero_task(): assert minimum_completion_time(0, []) == 0 def test_large_values(): assert minimum_completion_time(2, [(99999, 1000000), (99999, 1000000)]) == 2000000","solution":"from typing import List, Tuple from collections import defaultdict def minimum_completion_time(n: int, tasks: List[Tuple[int, int]]) -> int: task_times = defaultdict(int) for task_id, time in tasks: task_times[task_id] += time total_time = sum(task_times.values()) return total_time"},{"question":"def count_paths(grid): Find the number of ways to reach from the top-left corner (1, 1) to the bottom-right corner (n, n) of the grid. >>> count_paths([ ['.', '.', '*'], ['*', '.', '.'], ['.', '.', '.'] ]) 2 >>> count_paths([ ['.', '.', '.', '.'], ['.', '*', '.', '.'], ['.', '.', '*', '.'], ['.', '.', '.', '.'] ]) 4","solution":"def count_paths(grid): n = len(grid) if grid[0][0] == '*' or grid[n-1][n-1] == '*': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '*': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1] # Example usage grid1 = [ ['.', '.', '*'], ['*', '.', '.'], ['.', '.', '.'] ] print(count_paths(grid1)) # Output: 2 grid2 = [ ['.', '.', '.', '.'], ['.', '*', '.', '.'], ['.', '.', '*', '.'], ['.', '.', '.', '.'] ] print(count_paths(grid2)) # Output: 4"},{"question":"from typing import List, Tuple def unique_tree_values(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: You are given a tree consisting of n nodes rooted at node 1. Each node has a value associated with it. Your task is to find the number of unique values that can be collected by traversing from the root to any other node in the tree. Args: n (int): Number of nodes in the tree. values (List[int]): Values associated with each node. edges (List[Tuple[int, int]]): Edges between the nodes in the tree. Returns: int: Number of unique values encountered in any root to node path. Example: >>> unique_tree_values(5, [3, 4, 2, 3, 2], [(1, 2), (1, 3), (2, 4), (3, 5)]) 3 >>> unique_tree_values(1, [1], []) 1","solution":"def unique_tree_values(n, values, edges): from collections import defaultdict, deque def bfs(tree, values): unique_values = set() queue = deque([1]) visited = set() while queue: node = queue.popleft() if node not in visited: visited.add(node) unique_values.add(values[node-1]) for neighbor in tree[node]: if neighbor not in visited: queue.append(neighbor) return unique_values # Build adjacency list for the tree tree = defaultdict(list) for u, w in edges: tree[u].append(w) tree[w].append(u) # Find unique values using BFS unique_vals = bfs(tree, values) return len(unique_vals) # Example usage # n = 5 # values = [3, 4, 2, 3, 2] # edges = [(1, 2), (1, 3), (2, 4), (3, 5)] # print(unique_tree_values(n, values, edges)) # Output: 3"},{"question":"from typing import List def find_concatenated_words(words: List[str]) -> List[str]: Given an array of words, find all the words in the list that are concatenations of two or more words from the list. >>> find_concatenated_words([\\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\"]) [\\"catsdog\\"] >>> find_concatenated_words([\\"cat\\", \\"dog\\", \\"fish\\"]) [] >>> find_concatenated_words([\\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\", \\"catdog\\", \\"catscats\\"]) [\\"catsdog\\", \\"catdog\\", \\"catscats\\"] >>> find_concatenated_words([\\"cat\\"]) [] >>> find_concatenated_words([\\"cat\\", \\"cats\\", \\"catscats\\"]) [\\"catscats\\"]","solution":"def find_concatenated_words(words): def can_form(word, word_set): if word in memo: return memo[word] for i in range(1, len(word)): prefix, suffix = word[:i], word[i:] if prefix in word_set and (suffix in word_set or can_form(suffix, word_set)): memo[word] = True return True memo[word] = False return False word_set = set(words) concatenated_words = [] for word in words: memo = {} if can_form(word, word_set): concatenated_words.append(word) return concatenated_words # Example usage: words = [\\"cat\\", \\"cats\\", \\"dog\\", \\"catsdog\\"] print(find_concatenated_words(words)) # Output: ['catsdog']"},{"question":"def min_transformation_energy(n: int, s: str) -> int: Returns the minimum total magical energy required to transform the string s into a single character. Args: n (int): The length of the string. s (str): The string to be transformed. Returns: int: The minimum total magical energy required. Example: >>> min_transformation_energy(5, \\"abcde\\") 10","solution":"def min_transformation_energy(n, s): Returns the minimum total magical energy required to transform the string s into a single character. min_cost = float('inf') # Iterate over each character from 'a' to 'z' for target in range(ord('a'), ord('z') + 1): cost = 0 for char in s: cost += abs(ord(char) - target) if cost < min_cost: min_cost = cost return min_cost"},{"question":"from collections import defaultdict, deque def max_distinct_vendors(n: int, k: int, transactions: List[Tuple[int, int]]) -> int: Determine the maximum number of distinct vendors within any given window of size \`k\` seconds. Parameters: n (int): Number of transactions k (int): Size of the time window in seconds transactions (List[Tuple[int, int]]): List of tuples where each tuple contains (timestamp, vendor_id) Returns: int: Maximum number of distinct vendors within any time window of size \`k\` seconds. Examples: >>> max_distinct_vendors(5, 3, [(1, 101), (2, 202), (3, 101), (5, 303), (6, 202)]) 2 >>> max_distinct_vendors(1, 1, [(1, 101)]) 1 >>> max_distinct_vendors(4, 4, [(1, 101), (2, 101), (3, 101), (4, 101)]) 1 >>> max_distinct_vendors(5, 10, [(1, 101), (2, 202), (6, 303), (7, 404), (8, 505)]) 5 >>> max_distinct_vendors(6, 2, [(1, 101), (3, 101), (3, 102), (6, 202), (8, 202), (8, 301)]) 2","solution":"from collections import deque, defaultdict def max_distinct_vendors(n, k, transactions): Returns the maximum number of distinct vendors within any time window of size \`k\` seconds. Parameters: n (int): number of transactions k (int): size of the time window in seconds transactions (list of tuples): each tuple contains (timestamp, vendor_id) Returns: int: maximum number of distinct vendors within any time window of size \`k\` seconds transactions.sort() # Sort transactions by timestamp max_vendors = 0 current_vendors = defaultdict(int) window = deque() for ti, vi in transactions: # Remove old transactions outside the k-second window while window and window[0][0] < ti - k + 1: old_ti, old_vi = window.popleft() current_vendors[old_vi] -= 1 if current_vendors[old_vi] == 0: del current_vendors[old_vi] # Add new transaction to the window window.append((ti, vi)) current_vendors[vi] += 1 # Update the max number of distinct vendors max_vendors = max(max_vendors, len(current_vendors)) return max_vendors"},{"question":"def min_workers_required(n, tasks): Finds the minimum number of workers required to handle all tasks without any overlap. Parameters: n (int): The number of tasks. tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a task. Returns: int: The minimum number of workers required. Examples: >>> min_workers_required(4, [(1, 4), (2, 6), (6, 8), (7, 9)]) 2 >>> min_workers_required(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> min_workers_required(3, [(1, 4), (2, 5), (3, 6)]) 3 >>> min_workers_required(5, [(1, 4), (2, 3), (3, 5), (6, 8), (7, 9)]) 2 >>> min_workers_required(3, [(1, 3), (4, 6), (7, 9)]) 1 >>> min_workers_required(1, [(1, 2)]) 1","solution":"def min_workers_required(n, tasks): Finds the minimum number of workers required to handle all tasks without any overlap. events = [] for s, e in tasks: events.append((s, 1)) # Task starts events.append((e, -1)) # Task ends events.sort() max_workers = 0 current_workers = 0 for _, event in events: current_workers += event if current_workers > max_workers: max_workers = current_workers return max_workers"},{"question":"def longest_common_prefix(strings: List[str]) -> str: Returns the longest common prefix among a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\"","solution":"def longest_common_prefix(strings): Returns the longest common prefix among a list of strings. if not strings: return \\"\\" # Start by assuming the entire first string is the common prefix prefix = strings[0] # Iterate over all strings in the list for string in strings[1:]: # Shorten the prefix as long as it's not a prefix of the current string while string[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"from typing import List def min_operations_to_sort(n: int, a: List[int]) -> int: Determine the minimum number of operations required to sort the array in non-decreasing order by moving elements to the beginning. :param n: int - the number of elements in the array. :param a: list of int - the array of distinct integers. :return: int - the minimum number of operations. >>> min_operations_to_sort(5, [4, 3, 2, 5, 1]) 3 >>> min_operations_to_sort(2, [1, 2]) 0 >>> min_operations_to_sort(3, [3, 2, 1]) 2 >>> min_operations_to_sort(1, [1]) 0 >>> min_operations_to_sort(4, [2, 3, 4, 1]) 1 >>> min_operations_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort(5, [1, 3, 5, 7, 9]) 0 >>> min_operations_to_sort(4, [4, 3, 2, 1]) 3 >>> min_operations_to_sort(7, [7, 6, 5, 4, 3, 2, 1]) 6 >>> min_operations_to_sort(7, [1, 2, 3, 4, 5, 6, 7]) 0 >>> min_operations_to_sort(7, [4, 5, 6, 1, 2, 3, 7]) 3","solution":"def min_operations_to_sort(n, a): Determine the minimum number of operations required to sort the array in non-decreasing order by moving elements to the beginning. :param n: int - the number of elements in the array. :param a: list of int - the array of distinct integers. :return: int - the minimum number of operations. max_sorted_len = 1 current_len = 1 for i in range(1, n): if a[i] > a[i - 1]: current_len += 1 else: if current_len > max_sorted_len: max_sorted_len = current_len current_len = 1 max_sorted_len = max(current_len, max_sorted_len) return n - max_sorted_len"},{"question":"def interesting_sequence(n: int) -> [int]: Generate an interesting sequence of length n if possible, otherwise return -1. An interesting sequence is defined as each element being divisible by its 1-based index. >>> interesting_sequence(5) [1, 2, 6, 12, 20] >>> interesting_sequence(3) [1, 2, 9] >>> interesting_sequence(1) [1] >>> interesting_sequence(0) -1","solution":"def interesting_sequence(n): Generates an interesting sequence of length n if possible. An interesting sequence is defined as each element being divisible by its 1-based index. If it is not possible to construct such a sequence, returns -1. if n <= 0: return -1 sequence = [] for i in range(1, n + 1): sequence.append(i * (i + 1) // 2) return sequence"},{"question":"def max_knights(n: int, m: int, k: int, board: List[List[str]]) -> int: Determine the maximum number of knights that can be placed on the board without attacking each other. Args: n (int): The number of rows on the chessboard. m (int): The number of columns on the chessboard. k (int): The maximum number of knights to be placed. board (List[List[str]]): The n x m chessboard configuration. Returns: int: The maximum number of knights that can be placed without attacking each other. Example: >>> n, m, k = 4, 4, 4 >>> board = [ ['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'] ] >>> max_knights(n, m, k, board) 4 >>> n, m, k = 3, 3, 3 >>> board = [ ['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#'] ] >>> max_knights(n, m, k, board) 0 >>> n, m, k = 3, 3, 3 >>> board = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] >>> max_knights(n, m, k, board) 3 >>> n, m, k = 3, 3, 1 >>> board = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] >>> max_knights(n, m, k, board) 1 >>> n, m, k = 1, 1, 1 >>> board = [['.']] >>> max_knights(n, m, k, board) 1 >>> board = [['#']] >>> max_knights(n, m, k, board) 0","solution":"def max_knights(n, m, k, board): def is_safe(board, row, col): knight_moves = [ (-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1) ] for move in knight_moves: new_row, new_col = row + move[0], col + move[1] if 0 <= new_row < n and 0 <= new_col < m and board[new_row][new_col] == 'K': return False return True def backtrack(board, k, start): if k == 0: return sum(row.count('K') for row in board) max_knights_count = 0 for i in range(start, n * m): row, col = divmod(i, m) if board[row][col] == '.' and is_safe(board, row, col): board[row][col] = 'K' max_knights_count = max(max_knights_count, backtrack(board, k - 1, i + 1)) board[row][col] = '.' return max_knights_count return backtrack(board, k, 0)"},{"question":"def validate_parentheses(t: int, test_cases: List[str]) -> List[str]: You are given a string of parentheses. A string of parentheses is valid if: 1) Open brackets are closed by the same type of brackets. 2) Open brackets are closed in the correct order. In this problem, we only have the types of brackets '(' and ')'. You are given a string s containing only characters '(' and ')'. You need to check if the string can be made valid by removing at most one character from it. Write a function \`validate_parentheses\` that takes an integer and a list of strings as input and returns a list of \\"YES\\" or \\"NO\\" for each string. >>> validate_parentheses(5, [\\"()\\", \\"((\\", \\"())\\", \\"))((\\", \\"(()((\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> validate_parentheses(3, [\\"(\\", \\")\\", \\")(\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] def is_valid(s: str) -> bool: Check if the string of parentheses is valid. def can_be_made_valid_by_removing_one(s: str) -> bool: Check if the string can be made valid by removing at most one character. def run_validate_parentheses(t: int, test_cases: List[str]) -> None: Runs the validate_parentheses function and prints the result for each test case. >>> run_validate_parentheses(5, [\\"(())\\", \\"(()\\", \\"(())\\", \\"((()))\\", \\"(()\\"]) YES YES YES YES YES","solution":"def validate_parentheses(t, test_cases): results = [] for s in test_cases: if is_valid(s): results.append(\\"YES\\") elif can_be_made_valid_by_removing_one(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def is_valid(s): balance = 0 for char in s: if char == '(': balance += 1 else: balance -= 1 if balance < 0: return False return balance == 0 def can_be_made_valid_by_removing_one(s): return is_valid(s[1:]) or is_valid(s[:-1]) def run_validate_parentheses(t, test_cases): results = validate_parentheses(t, test_cases) for result in results: print(result)"},{"question":"def max_coins(n, k, coins): Determines the maximum number of coins that can be gathered in any k consecutive boxes after making at most one swap operation. :param n: Number of boxes. :param k: Number of consecutive boxes. :param coins: List of initial number of gold coins in each box. :return: Maximum sum of coins in any k consecutive boxes after at most one swap. >>> max_coins(5, 3, [1, 3, 4, 2, 5]) 12 >>> max_coins(4, 2, [1, 2, 3, 4]) 7 >>> max_coins(4, 2, [1000000, 0, 1000000, 1000000]) 2000000 >>> max_coins(1, 1, [1]) 1 >>> max_coins(4, 2, [0, 0, 0, 0]) 0","solution":"def max_coins(n, k, coins): Determines the maximum number of coins that can be gathered in any k consecutive boxes after making at most one swap operation. :param n: Number of boxes. :param k: Number of consecutive boxes. :param coins: List of initial number of gold coins in each box. :return: Maximum sum of coins in any k consecutive boxes after at most one swap. current_sum = sum(coins[:k]) max_sum = current_sum # Compute the sums of all k-length windows window_sums = [current_sum] for i in range(1, n - k + 1): current_sum = current_sum - coins[i-1] + coins[i+k-1] window_sums.append(current_sum) max_sum = max(max_sum, current_sum) # Check the effect of swapping any two boxes to maximize the sum of any k-length window for i in range(n): for j in range(i + 1, n): coins[i], coins[j] = coins[j], coins[i] # Recompute the sums after the swap current_sum = sum(coins[:k]) for m in range(1, n - k + 1): current_sum = current_sum - coins[m-1] + coins[m+k-1] max_sum = max(max_sum, current_sum) # Swap back to original positions coins[i], coins[j] = coins[j], coins[i] return max_sum"},{"question":"from typing import List, Tuple def process_queries(N: int, M: int, edges: List[Tuple[int, int, int]], queries: List[int]) -> List[int]: Process queries to determine the length of the shortest path from node 1 to node N where all edges in the path have weights at most K. Parameters: N (int): The number of nodes in the graph. M (int): The number of edges in the graph. edges (List[Tuple[int, int, int]]): List of edges, where each edge is represented as a tuple (U_i, V_i, W_i). queries (List[int]): List of queries, where each query is an integer K. Returns: List[int]: List of shortest path lengths for each query. If no such path exists, return -1 for that query. Example: >>> N = 4 >>> M = 5 >>> edges = [(1, 2, 5), (2, 3, 1), (3, 4, 1), (1, 4, 10), (2, 4, 5)] >>> queries = [2, 6, 10] >>> process_queries(N, M, edges, queries) [-1, 7, 7]","solution":"import heapq def dijkstra(graph, N, max_weight): distances = [float('inf')] * (N + 1) distances[1] = 0 min_heap = [(0, 1)] while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: if weight > max_weight: continue distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances[N] if distances[N] != float('inf') else -1 def process_queries(N, M, edges, queries): graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for k in queries: result = dijkstra(graph, N, k) results.append(result) return results"},{"question":"def merge_strings(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Merges pairs of strings alternately and returns the resulting strings for each test case. Parameters: t (int): the number of test cases test_cases (list of tuples): a list containing tuples of (s1, s2) for each test case Returns: list: a list of the resultant strings for each test case >>> merge_strings(2, [(\\"abc\\", \\"defg\\"), (\\"hello\\", \\"world\\")]) ['adbecfg', 'hweolrllod'] >>> merge_strings(1, [(\\"abc\\", \\"\\")]) ['abc'] >>> merge_strings(1, [(\\"aaa\\", \\"bbb\\")]) ['ababab'] >>> merge_strings(1, [(\\"123\\", \\"abcde\\")]) ['1a2b3cde'] >>> merge_strings(3, [(\\"a\\", \\"b\\"), (\\"cat\\", \\"dog\\"), (\\"hello\\", \\"\\")]) ['ab', 'cdaotg', 'hello']","solution":"def merge_strings(t, test_cases): Merges pairs of strings alternately and returns the resulting strings for each test case. Parameters: t (int): the number of test cases test_cases (list of tuples): a list containing tuples of (s1, s2) for each test case Returns: list: a list of the resultant strings for each test case results = [] for s1, s2 in test_cases: res = [] i, j = 0, 0 while i < len(s1) and j < len(s2): res.append(s1[i]) res.append(s2[j]) i += 1 j += 1 if i < len(s1): res.extend(s1[i:]) if j < len(s2): res.extend(s2[j:]) results.append(''.join(res)) return results"},{"question":"def calculate_protected_lengths(n, segments): Returns a list of integers representing the total length of the protected path after adding each barrier. Parameters: - n (int): The number of magic barriers. - segments (List[Tuple[int, int]]): The list of tuples where each tuple contains two integers representing the left and right endpoints of the i-th barrier. Returns: - List[int]: A list of integers with the total length of the protected path after each barrier is added. >>> calculate_protected_lengths(3, [(1, 5), (3, 6), (6, 10)]) [4, 5, 9] >>> calculate_protected_lengths(1, [(1, 1000000000)]) [999999999]","solution":"def calculate_protected_lengths(n, segments): Returns a list of integers representing the total length of the protected path after adding each barrier. Parameters: - n (int): The number of magic barriers. - segments (List[Tuple[int, int]]): The list of tuples where each tuple contains two integers representing the left and right endpoints of the i-th barrier. Returns: - List[int]: A list of integers with the total length of the protected path after each barrier is added. if not segments: return [] # Sorted list of all seen segments sorted_segments = [] total_protected_lengths = [] for l, r in segments: sorted_segments.append((l, r)) sorted_segments.sort() # Merge overlapping segments and calculate the total protected length merged_segments = [] current_start, current_end = sorted_segments[0] for i in range(1, len(sorted_segments)): seg_start, seg_end = sorted_segments[i] if seg_start <= current_end: # Overlapping segments, merge them current_end = max(current_end, seg_end) else: # Non-overlapping segment, add current to merged list, # and start a new current segment merged_segments.append((current_start, current_end)) current_start, current_end = seg_start, seg_end # Add the last current segment to merged list merged_segments.append((current_start, current_end)) # Calculate the total protected length protected_length = sum(end - start for start, end in merged_segments) total_protected_lengths.append(protected_length) return total_protected_lengths"},{"question":"def word_break(s: str, word_dict: List[str]) -> str: Determine if the string s can be segmented into a sequence of one or more dictionary words. >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\", \\"pine\\"]) 'YES' >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 'NO' >>> word_break(\\"apple\\", [\\"apple\\"]) 'YES' >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) 'YES' >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 'YES' >>> word_break(\\"a\\", []) 'NO' # Your function implementation here","solution":"def word_break(s, word_dict): Determine if the string s can be segmented into a sequence of one or more words from word_dict. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(s)] else \\"NO\\""},{"question":"from collections import defaultdict def maximum_sum_path(n: int, node_values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Sasha has a tree rooted at node 1 and wants to find the maximum sum of node values on any path starting at the root node and ending at a node in the subtree of node x. Args: n (int): the number of nodes in the tree. node_values (List[int]): values of the nodes. edges (List[Tuple[int, int]]): edges between the nodes. queries (List[int]): nodes for which Sasha wants to find the maximum sum path in their subtree. Returns: List[int]: the maximum sum of node values for each query. >>> maximum_sum_path(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], [1, 3]) [15, 12] >>> maximum_sum_path(1, [5], [], [1]) [5] Unit Tests: from collections import defaultdict def test_maximum_sum_path_basic(): n = 5 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3] assert maximum_sum_path(n, node_values, edges, queries) == [15, 12] def test_maximum_sum_path_single_node(): n = 1 node_values = [5] edges = [] queries = [1] assert maximum_sum_path(n, node_values, edges, queries) == [5] def test_maximum_sum_path_line_tree(): n = 4 node_values = [1, 2, 3, 4] edges = [(1, 2), (2, 3), (3, 4)] queries = [1, 2, 3, 4] assert maximum_sum_path(n, node_values, edges, queries) == [10, 9, 7, 4] def test_maximum_sum_path_star_tree(): n = 5 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (1, 4), (1, 5)] queries = [1, 2, 3, 4, 5] assert maximum_sum_path(n, node_values, edges, queries) == [15, 2, 3, 4, 5] def test_maximum_sum_path_dense_tree(): n = 5 node_values = [5, 3, 8, 2, 6] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 2, 3, 4, 5] assert maximum_sum_path(n, node_values, edges, queries) == [24, 3, 16, 2, 6] pass","solution":"from collections import defaultdict, deque def maximum_sum_path(n, node_values, edges, queries): # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Create a list to store max sum for each node, initialize it with node values max_sum = node_values[:] # DFS function to calculate the maximum sum path def dfs(node, parent): for neighbor in graph[node]: if neighbor != parent: dfs(neighbor, node) max_sum[node - 1] = max(max_sum[node - 1], max_sum[node - 1] + max_sum[neighbor - 1]) # Start DFS from the root node dfs(1, -1) # Function to get the maximum sum for a query node def get_max_sum(x): return max_sum[x - 1] # Process each query result = [get_max_sum(x) for x in queries] return result"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babadab\\") 5 >>> longest_palindromic_substring_length(\\"racecar\\") 7 from solution import longest_palindromic_substring_length def test_single_char(): assert longest_palindromic_substring_length(\\"a\\") == 1 def test_two_same_chars(): assert longest_palindromic_substring_length(\\"aa\\") == 2 def test_two_diff_chars(): assert longest_palindromic_substring_length(\\"ab\\") == 1 def test_generic_case(): assert longest_palindromic_substring_length(\\"babadab\\") == 5 def test_palindrome_full_string(): assert longest_palindromic_substring_length(\\"racecar\\") == 7 def test_no_palindrome(): assert longest_palindromic_substring_length(\\"abcdefg\\") == 1 def test_multiple_palindromes(): assert longest_palindromic_substring_length(\\"forgeeksskeegfor\\") == 10 def test_empty_string(): assert longest_palindromic_substring_length(\\"\\") == 0","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_length = 1 # every single character is a palindrome for i in range(n): dp[i][i] = True start = 0 for end in range(1, n): for begin in range(0, end): if s[begin] == s[end]: if end - begin == 1 or dp[begin + 1][end - 1]: dp[begin][end] = True if end - begin + 1 > max_length: max_length = end - begin + 1 start = begin return max_length"},{"question":"from typing import List, Tuple def find_min_cycle_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the weight of the minimum weight cycle in an undirected graph. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuple of int): List of edges represented as (u, v, w) Returns: int: Weight of the minimum weight cycle, or -1 if there is no cycle >>> find_min_cycle_weight(4, 4, [(1, 2, 3), (2, 3, 4), (3, 1, 5), (3, 4, 1)]) 12 >>> find_min_cycle_weight(3, 2, [(1, 2, 1), (2, 3, 2)]) -1 pass def test_find_min_cycle_weight_case_1(): n, m = 4, 4 edges = [(1, 2, 3), (2, 3, 4), (3, 1, 5), (3, 4, 1)] assert find_min_cycle_weight(n, m, edges) == 12 def test_find_min_cycle_weight_case_2(): n, m = 3, 2 edges = [(1, 2, 1), (2, 3, 2)] assert find_min_cycle_weight(n, m, edges) == -1 def test_find_min_cycle_weight_case_3(): n, m = 4, 4 edges = [(1, 2, 1), (1, 3, 2), (1, 4, 5), (2, 3, 4)] assert find_min_cycle_weight(n, m, edges) == 7 def test_find_min_cycle_weight_case_4(): n, m = 5, 5 edges = [(1, 2, 6), (2, 3, 7), (3, 4, 3), (4, 5, 2), (5, 1, 9)] assert find_min_cycle_weight(n, m, edges) == 27 def test_find_min_cycle_weight_case_5(): n, m = 3, 3 edges = [(1, 2, 3), (2, 3, 2), (3, 1, 4)] assert find_min_cycle_weight(n, m, edges) == 9 def test_find_min_cycle_weight_with_self_loop(): n, m = 3, 3 edges = [(1, 2, 1), (2, 3, 2), (3, 3, 3)] assert find_min_cycle_weight(n, m, edges) == 3","solution":"import sys from collections import defaultdict import heapq def find_min_cycle_weight(n, m, edges): Find the weight of the minimum weight cycle in an undirected graph. Parameters: n (int): Number of vertices m (int): Number of edges edges (list of tuple of int): List of edges represented as (u, v, w) Returns: int: Weight of the minimum weight cycle, or -1 if there is no cycle graph = defaultdict(list) for u, v, w in edges: if u != v: graph[u].append((v, w)) graph[v].append((u, w)) else: return w # Self-loop is the minimum cycle (weight = w) def dijkstra(start): dist = [float('inf')] * (n + 1) dist[start] = 0 visited = [False] * (n + 1) min_cycle = float('inf') heap = [(0, start, -1)] while heap: d, u, parent = heapq.heappop(heap) if visited[u]: continue visited[u] = True for v, weight in graph[u]: if not visited[v]: if dist[v] > d + weight: dist[v] = d + weight heapq.heappush(heap, (dist[v], v, u)) elif v != parent: # if v is visited and not parent min_cycle = min(min_cycle, d + dist[v] + weight) return min_cycle min_cycle_weight = float('inf') for i in range(1, n + 1): cycle_weight = dijkstra(i) if cycle_weight: min_cycle_weight = min(min_cycle_weight, cycle_weight) return min_cycle_weight if min_cycle_weight < float('inf') else -1 # Example usage with sample input #n, m = 4, 4 #edges = [(1, 2, 3), (2, 3, 4), (3, 1, 5), (3, 4, 1)] #print(find_min_cycle_weight(n, m, edges)) # Output: 12"},{"question":"def can_carry_subset(n: int, W: int, weights: List[int]) -> str: Determines if it is possible to select a non-empty subset of the items such that their total weight does not exceed W. :param n: int, number of items :param W: int, weight limit of the bag :param weights: List[int], weights of the items :return: str, \\"YES\\" if such a subset exists, otherwise \\"NO\\" >>> can_carry_subset(4, 10, [2, 3, 8, 5]) == \\"YES\\" >>> can_carry_subset(3, 5, [6, 7, 8]) == \\"NO\\" >>> can_carry_subset(1, 5, [5]) == \\"YES\\" >>> can_carry_subset(1, 4, [5]) == \\"NO\\" >>> can_carry_subset(3, 5, [2, 2, 2]) == \\"YES\\" >>> can_carry_subset(3, 5, [2, 2, 2, 3, 3]) == \\"YES\\" >>> can_carry_subset(4, 1000, [100, 200, 300, 400]) == \\"YES\\" >>> can_carry_subset(4, 500, [600, 700, 800, 900]) == \\"NO\\" >>> can_carry_subset(50, 1000, [20]*50) == \\"YES\\" >>> can_carry_subset(50, 1, [1]*50) == \\"YES\\" >>> can_carry_subset(50, 50, [50]*50) == \\"YES\\"","solution":"def can_carry_subset(n, W, weights): Determines if it is possible to select a non-empty subset of the items such that their total weight does not exceed W. :param n: int, number of items :param W: int, weight limit of the bag :param weights: list of int, weights of the items :return: str, \\"YES\\" if such a subset exists, otherwise \\"NO\\" from itertools import combinations # Generate all possible non-empty subsets for i in range(1, n + 1): for subset in combinations(weights, i): if sum(subset) <= W: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def convert_ascii(int_list: List[int]) -> str: Takes a list of integers and converts valid ASCII values to a string. Characters in the ASCII range of 32 to 126 inclusive are considered valid. >>> convert_ascii([72, 101, 108, 108, 111, 33]) \\"Hello!\\" >>> convert_ascii([72, 101, 108, 108, 111, 33, 200]) \\"Hello!\\" >>> convert_ascii([32, 126, 127]) \\" ~\\" >>> convert_ascii([31, 32, 33]) \\" !\\" >>> convert_ascii([127, 128, 129, 255, 0]) \\"\\" >>> convert_ascii([65, 66, 32, 255, 67, 68]) \\"AB CD\\" >>> convert_ascii([32]) \\" \\" >>> convert_ascii([126]) \\"~\\" >>> convert_ascii([32, 126]) \\" ~\\" >>> convert_ascii([0, 31, 127, 255]) \\"\\" >>> convert_ascii([]) \\"\\"","solution":"def convert_ascii(int_list): Takes a list of integers and converts valid ASCII values to a string. Characters in the ASCII range of 32 to 126 inclusive are considered valid. valid_chars = [chr(num) for num in int_list if 32 <= num <= 126] return ''.join(valid_chars)"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n vertices and m edges, determine if it's possible to partition the vertices of the graph into two sets such that no two vertices within the same set are adjacent. >>> is_bipartite(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"NO\\"","solution":"def is_bipartite(n, m, edges): from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (n + 1) def bfs(source): queue = deque([source]) color[source] = 0 while queue: u = queue.popleft() for v in graph[u]: if color[v] == -1: color[v] = 1 - color[u] queue.append(v) elif color[v] == color[u]: return False return True for vertex in range(1, n + 1): if color[vertex] == -1: if not bfs(vertex): return \\"NO\\" return \\"YES\\""},{"question":"def expected_devices_in_state_2(n: int, t: int) -> float: Calculate the expected number of devices in state 2 after t seconds. Args: n (int): The number of devices. t (int): The number of seconds. Returns: float: The expected number of devices in state 2. >>> expected_devices_in_state_2(10, 3) 1.25 >>> expected_devices_in_state_2(100, 1) 50.0 >>> expected_devices_in_state_2(50, 2) 12.5 >>> expected_devices_in_state_2(1000, 10) 0.9765625 >>> expected_devices_in_state_2(1, 100) 7.888609052210118e-31","solution":"def expected_devices_in_state_2(n, t): Calculate the expected number of devices in state 2 after t seconds. Args: n (int): The number of devices. t (int): The number of seconds. Returns: float: The expected number of devices in state 2. expected = n / (2 ** t) # after t seconds, the probability of each device being in state 2 is (1/2^t) return expected"},{"question":"def generate_matchups(n: int, m: int) -> list: Generates matchups for 'n' players across 'm' rounds such that: - Each player participates exactly once per round. - No player faces themselves. Args: n (int): number of players (even number between 2 and 50). m (int): number of rounds (between 1 and 100). Returns: list: A list of 'm' rounds where each round contains pairs of players as tuples. >>> generate_matchups(4, 2) [[(1, 2), (3, 4)], [(1, 3), (2, 4)]] >>> generate_matchups(6, 3) [[(1, 2), (3, 4), (5, 6)], [(1, 3), (2, 5), (4, 6)], [(1, 4), (2, 6), (3, 5)]]","solution":"def generate_matchups(n, m): Generates matchups for 'n' players across 'm' rounds such that: - Each player participates exactly once per round. - No player faces themselves. Args: n (int): number of players (even number between 2 and 50). m (int): number of rounds (between 1 and 100). Returns: list: A list of 'm' rounds where each round contains pairs of players as tuples. matchups = [] players = list(range(1, n + 1)) for round_num in range(m): round_pairs = [] for i in range(n // 2): first_player = players[i] second_player = players[(i + round_num) % (n // 2) + n // 2] round_pairs.append((first_player, second_player)) matchups.append(round_pairs) return matchups"},{"question":"def min_bundles(test_cases: List[List[int]]) -> List[int]: Calculate the minimum number of bundles needed for the rods in each test case. Each bundle must contain rods with the same length. Args: test_cases (List[List[int]]): List of test cases where each test case contains a list of rod lengths. Returns: List[int]: List of minimum number of bundles required for each test case. results = [] for lengths in test_cases: unique_lengths = set(lengths) results.append(len(unique_lengths)) return results def parse_input(input_str: str) -> List[List[int]]: Parse the input string to extract test cases. Args: input_str (str): The input string containing multiple test cases. Returns: List[List[int]]: List of test cases where each test case contains a list of rod lengths. lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) lengths = list(map(int, lines[index + 1].strip().split())) test_cases.append(lengths) index += 2 return test_cases def solve(input_str: str) -> str: Solve the problem using the parsed input and get the results. Args: input_str (str): The input string containing multiple test cases. Returns: str: The output formatted as specified in the problem statement. test_cases = parse_input(input_str) results = min_bundles(test_cases) return \\"n\\".join(map(str, results))","solution":"def min_bundles(test_cases): results = [] for lengths in test_cases: unique_lengths = set(lengths) results.append(len(unique_lengths)) return results # Helper function to parse input def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) lengths = list(map(int, lines[index + 1].strip().split())) test_cases.append(lengths) index += 2 return test_cases # Main function to solve the problem def solve(input_str): test_cases = parse_input(input_str) results = min_bundles(test_cases) return \\"n\\".join(map(str, results))"},{"question":"from typing import List def findPeaks(trail: List[int]) -> List[int]: Identify the peaks in the trail where Alice should take breaks. A peak is an elevation point that is strictly greater than its immediate left and right neighbors. Arguments: trail -- list of integers representing the elevation at each point of the trail Returns: list of integers -- the indices at which peaks occur Examples: >>> findPeaks([1, 2, 3, 1, 5, 6, 2, 1]) [2, 5] >>> findPeaks([2, 1, 2]) [] >>> findPeaks([1, 1, 1, 1, 1]) [] >>> findPeaks([1, 3, 1, 3, 1, 3, 1]) [1, 3, 5] >>> findPeaks([3, 2, 3]) [] >>> findPeaks([1, 2]) [] >>> findPeaks([1]) [] >>> findPeaks([]) [] >>> findPeaks([1, 2, 3] * 10000 + [1]) [i for i in range(2, 30000, 3)]","solution":"from typing import List def findPeaks(trail: List[int]) -> List[int]: peaks = [] if len(trail) < 3: return [] for i in range(1, len(trail) - 1): if trail[i] > trail[i - 1] and trail[i] > trail[i + 1]: peaks.append(i) return peaks"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determines if the string s with length n can be rearranged to form a palindrome. Args: n: An integer representing the length of the string s. s: A string consisting of n lowercase English letters. Returns: 'YES' if the string can be rearranged to form a palindrome, 'NO' otherwise. >>> can_form_palindrome(6, \\"aabbcc\\") 'YES' >>> can_form_palindrome(7, \\"aabcdde\\") 'NO'","solution":"def can_form_palindrome(n, s): Determines if the string s with length n can be rearranged to form a palindrome. Args: n: An integer representing the length of the string s. s: A string consisting of n lowercase English letters. Returns: 'YES' if the string can be rearranged to form a palindrome, 'NO' otherwise. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd count if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def maximalRectangle(matrix: List[str]) -> int: Calculate the area of the largest rectangular crop field (sub-grid) within a grid where crops are represented by '1's and barren areas by '0's. >>> maximalRectangle([ ... '1011', ... '1111', ... '1110', ... '1100' ... ]) 6 >>> maximalRectangle([ ... '1', ... '1', ... '1', ... '1' ... ]) 4 >>> maximalRectangle([ ... '1111', ... '1111', ... '1111', ... '1111' ... ]) 16 >>> maximalRectangle([ ... '0000', ... '0000', ... '0000', ... '0000' ... ]) 0 >>> maximalRectangle([]) 0 >>> maximalRectangle([ ... '101', ... '111' ... ]) 3","solution":"def maximalRectangle(matrix): if not matrix: return 0 n, m = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * m left = [0] * m right = [m] * m for i in range(n): cur_left, cur_right = 0, m # update heights for j in range(m): if matrix[i][j] == '1': heights[j] += 1 else: heights[j] = 0 # update left for j in range(m): if matrix[i][j] == '1': left[j] = max(left[j], cur_left) else: left[j] = 0 cur_left = j + 1 # update right for j in range(m - 1, -1, -1): if matrix[i][j] == '1': right[j] = min(right[j], cur_right) else: right[j] = m cur_right = j # update the area for j in range(m): max_area = max(max_area, (right[j] - left[j]) * heights[j]) return max_area"},{"question":"def partition_labels(S: str) -> List[int]: Given a string S consisting of lowercase English letters, partition it into as few parts as possible so that each letter appears in at most one part, and return the end indexes of each part. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [8, 15, 23] >>> partition_labels(\\"a\\") [0] >>> partition_labels(\\"abcdef\\") [0, 1, 2, 3, 4, 5] >>> partition_labels(\\"aaaa\\") [3] >>> partition_labels(\\"abacbc\\") [5] pass","solution":"def partition_labels(S): Given a string S consisting of lowercase English letters, partition it into as few parts as possible so that each letter appears in at most one part, and return the end indexes of each part. # Find the last occurrence of each character last_occurrence = {char: idx for idx, char in enumerate(S)} partitions = [] start, end = 0, 0 for i, char in enumerate(S): end = max(end, last_occurrence[char]) if i == end: partitions.append(end) start = i + 1 return partitions"},{"question":"def max_orders(n: int, T: int, times: List[int]) -> int: Returns the maximum number of orders that can be delivered within the given time limit. Parameters: n (int): Number of orders. T (int): Time limit in which orders must be delivered. times (list of int): List of delivery times for each order. Returns: int: Maximum number of orders that can be delivered within the given time limit. pass # Example Unit Tests def test_example_case(): assert max_orders(5, 11, [2, 2, 3, 7, 5]) == 3 def test_no_orders_possible(): assert max_orders(3, 2, [3, 3, 3]) == 0 def test_all_orders_possible(): assert max_orders(4, 10, [1, 2, 2, 1]) == 4 def test_single_order(): assert max_orders(1, 5, [5]) == 1 def test_large_number_of_small_orders(): n = 100000 T = 100 times = [1] * n assert max_orders(n, T, times) == 100 def test_single_large_order(): assert max_orders(1, 100, [101]) == 0","solution":"def max_orders(n, T, times): Returns the maximum number of orders that can be delivered within the given time limit. Parameters: n (int): Number of orders. T (int): Time limit in which orders must be delivered. times (list of int): List of delivery times for each order. Returns: int: Maximum number of orders that can be delivered within the given time limit. times.sort() total_time = 0 count = 0 for time in times: if total_time + time <= T: total_time += time count += 1 else: break return count"},{"question":"def find_max_harmonious_length(n: int, k: int, spells: List[str]) -> int: Determine the maximal length of a harmonious spell that can be created from the given spells. >>> find_max_harmonious_length(3, 2, [\\"abc\\", \\"def\\", \\"ghi\\"]) 9 >>> find_max_harmonious_length(1, 1, [\\"a\\"]) 1 >>> find_max_harmonious_length(2, 0, [\\"abc\\", \\"xyz\\"]) 3 >>> find_max_harmonious_length(2, 25, [\\"yz\\", \\"ab\\"]) 4 >>> find_max_harmonious_length(4, 1, [\\"ab\\", \\"cd\\", \\"ef\\", \\"gh\\"]) 8","solution":"def find_max_harmonious_length(n, k, spells): def is_harmonious(s1, s2): # Check if s1 and s2 can be merged to form a harmonious sequence if not s1 or not s2: return False last_rune = s1[-1] first_rune = s2[0] return abs(ord(last_rune) - ord(first_rune)) <= k # Sort the spells to try and maximize the concatenation length spells.sort() max_length = 0 def dfs(current_spell, used): nonlocal max_length max_length = max(max_length, len(current_spell)) for i in range(n): if not used[i] and (not current_spell or is_harmonious(current_spell, spells[i])): used[i] = True dfs(current_spell + spells[i], used) used[i] = False used = [False] * n dfs(\\"\\", used) return max_length"},{"question":"def longest_palindrome_length(s: str) -> int: Alice wants to create the longest possible palindrome using the characters from a given string. She is allowed to rearrange the characters of the string if necessary. This function calculates the length of the longest palindrome that can be constructed using the characters of the input string. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"aaabbb\\") 5","solution":"def longest_palindrome_length(s: str) -> int: from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # This will store the length of the longest palindrome that can be created length_of_palindrome = 0 # This flag will check if there is any character with an odd frequency odd_found = False for count in char_count.values(): # If the count is even, it can fully contribute to the palindrome if count % 2 == 0: length_of_palindrome += count else: # If odd, add the largest even number just less than or equal to count length_of_palindrome += count - 1 odd_found = True # If there was an odd count, one character can still sit in the middle of the palindrome if odd_found: length_of_palindrome += 1 return length_of_palindrome"},{"question":"def last_remaining_card(n: int, k: int) -> int: Returns the last remaining card after performing Simon's trick until one card is left. :param n: Integer, total number of cards. :param k: Integer, number of cards to count in each trick. :return: Integer, the number on the last remaining card. >>> last_remaining_card(5, 2) 1 >>> last_remaining_card(1, 1) 1 >>> last_remaining_card(4, 4) 1 >>> last_remaining_card(7, 3) 1 >>> last_remaining_card(1000, 2) 1 >>> last_remaining_card(1000, 500) 1","solution":"def last_remaining_card(n, k): Returns the last remaining card after performing Simon's trick until one card is left. :param n: Integer, total number of cards. :param k: Integer, number of cards to count in each trick. :return: Integer, the number on the last remaining card. cards = list(range(1, n + 1)) while len(cards) > 1: top_k = cards[:k] # Take the top k cards highest_card = max(top_k) # Find the highest card cards.remove(highest_card) # Remove the highest card return cards[0]"},{"question":"def generate_pairs(n: int) -> list: Generates all unique pairs of numbers from the set {1, 2, ..., n}. Args: n (int): The number of unique balls in the urn. Returns: list of tuples: A list of unique pairs (a, b) where 1 ≤ a < b ≤ n. Examples: >>> generate_pairs(3) [(1, 2), (1, 3), (2, 3)] >>> generate_pairs(2) [(1, 2)]","solution":"def generate_pairs(n): Generates all unique pairs of numbers from the set {1, 2, ..., n}. Args: n (int): The number of unique balls in the urn. Returns: list of tuples: A list of unique pairs (a, b) where 1 ≤ a < b ≤ n. pairs = [] for i in range(1, n): for j in range(i + 1, n + 1): pairs.append((i, j)) return pairs"},{"question":"def max_trees(m, n, k, occupied_positions): Returns the maximum number of trees that can be planted. m - number of rows n - number of columns k - number of occupied cells occupied_positions - list of tuples representing occupied cells, e.g., [(1, 2), (2, 3), (4, 4)] >>> max_trees(5, 5, 3, [(1, 2), (2, 3), (4, 4)]) 4 >>> max_trees(3, 3, 0, []) 3 >>> max_trees(5, 5, 0, []) 5 >>> max_trees(5, 5, 5, [(1, 2), (2, 3), (3, 1), (4, 4), (5, 5)]) 0 >>> max_trees(4, 4, 4, [(1, 1), (2, 2), (3, 3), (4, 4)]) 0 >>> max_trees(4, 4, 2, [(1, 1), (2, 2)]) 2 >>> max_trees(6, 6, 3, [(1, 1), (2, 2), (3, 3)]) 3 >>> max_trees(1000, 1000, 500, [(i, i) for i in range(1, 501)]) 500 >>> max_trees(1000, 1000, 1000, [(i, 1001 - i) for i in range(1, 1001)]) 0","solution":"def max_trees(m, n, k, occupied_positions): Returns the maximum number of trees that can be planted. m - number of rows n - number of columns k - number of occupied cells occupied_positions - list of tuples representing occupied cells, e.g., [(1, 2), (2, 3), (4, 4)] # Create sets to keep track of occupied rows and columns occupied_rows = set() occupied_columns = set() # Fill the sets with the occupied positions for position in occupied_positions: occupied_rows.add(position[0]) occupied_columns.add(position[1]) # Available rows and columns available_rows = m - len(occupied_rows) available_columns = n - len(occupied_columns) # The maximum number of trees is the minimum of available rows and columns return min(available_rows, available_columns)"},{"question":"def count_palindromic_substrings(s: str) -> int: Counts the number of pairs of positions (i, j) in the string s such that the substring between these positions reverses to the same substring. >>> count_palindromic_substrings(\\"a\\") == 1 >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"aaa\\") == 6 >>> count_palindromic_substrings(\\"ababa\\") == 9 >>> count_palindromic_substrings(\\"aa\\") == 3 >>> count_palindromic_substrings(\\"aaaa\\") == 10 >>> count_palindromic_substrings(\\"\\") == 0","solution":"def count_palindromic_substrings(s): Counts the number of pairs of positions (i, j) in the string s such that the substring between these positions reverses to the same substring. n = len(s) count = 0 # For every possible pair of indices (i, j) for i in range(n): for j in range(i, n): substring = s[i:j+1] if substring == substring[::-1]: count += 1 return count"},{"question":"def can_partition_into_k_subarrays(arr: List[int], n: int, k: int, x: int) -> str: Determines if it's possible to partition the array into exactly k non-empty subarrays such that the sum of elements in each subarray is less than or equal to x. Parameters: arr (list): The list of integers. n (int): The number of elements in the list. k (int): The number of required subarrays. x (int): The maximum allowable sum for each subarray. Returns: str: \\"YES\\" if possible to partition, otherwise \\"NO\\". >>> can_partition_into_k_subarrays([1, 2, 3, 4, 1, 1], 6, 3, 6) \\"YES\\" >>> can_partition_into_k_subarrays([1, 2, 3, 4, 1, 1], 6, 2, 5) \\"NO\\" >>> can_partition_into_k_subarrays([5], 1, 1, 5) \\"YES\\" >>> can_partition_into_k_subarrays([6], 1, 1, 5) \\"NO\\" >>> can_partition_into_k_subarrays([10**9] * 1000, 1000, 1000, 10**9) \\"YES\\" >>> can_partition_into_k_subarrays([10**9] * 1000, 1000, 999, 10**9) \\"NO\\" >>> can_partition_into_k_subarrays([1, 1, 1, 1, 1], 5, 3, 3) \\"YES\\" >>> can_partition_into_k_subarrays([1, 2, 3, 4, 5], 5, 5, 3) \\"NO\\"","solution":"def can_partition_into_k_subarrays(arr, n, k, x): Determines if it's possible to partition the array into exactly k non-empty subarrays such that the sum of elements in each subarray is less than or equal to x. Parameters: arr (list): The list of integers. n (int): The number of elements in the list. k (int): The number of required subarrays. x (int): The maximum allowable sum for each subarray. Returns: str: \\"YES\\" if possible to partition, otherwise \\"NO\\". count = 1 current_sum = 0 for num in arr: if num > x: return \\"NO\\" if current_sum + num > x: count += 1 current_sum = num if count > k: return \\"NO\\" else: current_sum += num return \\"YES\\" if count <= k else \\"NO\\""},{"question":"def longest_subarray_with_k_zeros(n: int, k: int, s: str) -> int: Find the maximum length of a contiguous subarray with at most k zeroes. Parameters: n (int): the length of the binary string. k (int): the maximum number of '0's that can be changed to '1's. s (str): a binary string of length n. Returns: int: the length of the longest contiguous subarray with at most k zeroes. >>> longest_subarray_with_k_zeros(10, 2, '1101001101') 5 >>> longest_subarray_with_k_zeros(5, 1, '11111') 5 >>> longest_subarray_with_k_zeros(6, 3, '000000') 3 >>> longest_subarray_with_k_zeros(6, 1, '101010') 3 >>> longest_subarray_with_k_zeros(5, 5, '00000') 5 >>> longest_subarray_with_k_zeros(5, 0, '10001') 1 >>> longest_subarray_with_k_zeros(1, 0, '1') 1 >>> longest_subarray_with_k_zeros(1, 0, '0') 0 >>> longest_subarray_with_k_zeros(1, 1, '0') 1","solution":"def longest_subarray_with_k_zeros(n, k, s): left = 0 num_zeroes = 0 max_length = 0 for right in range(n): if s[right] == '0': num_zeroes += 1 while num_zeroes > k: if s[left] == '0': num_zeroes -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_bakes(recipe, n, recipe_ingredients, m, stock_ingredients): Determines the maximum number of times a given recipe can be baked based on the current stock of ingredients. :param recipe: str, the name of the recipe :param n: int, number of different ingredients required by the recipe :param recipe_ingredients: list of tuples, each containing ingredient name and quantity required for one bake :param m: int, number of different ingredients in the stock :param stock_ingredients: list of tuples, each containing ingredient name and quantity available in stock :return: int, the maximum number of times the recipe can be baked >>> max_bakes(\\"cake\\", 2, [(\\"flour\\", 2), (\\"sugar\\", 1)], 2, [(\\"flour\\", 4), (\\"sugar\\", 2)]) == 2 >>> max_bakes(\\"pie\\", 2, [(\\"flour\\", 3), (\\"sugar\\", 2)], 2, [(\\"flour\\", 3), (\\"sugar\\", 1)]) == 0 >>> max_bakes(\\"cookies\\", 2, [(\\"flour\\", 1), (\\"sugar\\", 1)], 0, []) == 0 >>> max_bakes(\\"cake\\", 3, [(\\"flour\\", 5), (\\"sugar\\", 2), (\\"eggs\\", 6)], 3, [(\\"flour\\", 20), (\\"sugar\\", 7), (\\"eggs\\", 11)]) == 1 >>> max_bakes(\\"bread\\", 1, [(\\"flour\\", 3)], 1, [(\\"flour\\", 9)]) == 3","solution":"def max_bakes(recipe, n, recipe_ingredients, m, stock_ingredients): Determines the maximum number of times a given recipe can be baked based on the current stock of ingredients. :param recipe: str, the name of the recipe :param n: int, number of different ingredients required by the recipe :param recipe_ingredients: list of tuples, each containing ingredient name and quantity required for one bake :param m: int, number of different ingredients in the stock :param stock_ingredients: list of tuples, each containing ingredient name and quantity available in stock :return: int, the maximum number of times the recipe can be baked # Dictionary for recipe ingredients recipe_dict = {ingredient: int(quantity) for ingredient, quantity in recipe_ingredients} # Dictionary for stock stock_dict = {ingredient: int(quantity) for ingredient, quantity in stock_ingredients} # Calculate the maximum number of times we can bake max_bakes = float('inf') for ingredient, required_quantity in recipe_dict.items(): if ingredient in stock_dict: max_bakes = min(max_bakes, stock_dict[ingredient] // required_quantity) else: return 0 return max_bakes"},{"question":"from typing import List, Tuple def count_elements(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Function to count elements in subarray [li, ri] that are >= vi for each query. :param arr: List of integers representing the array :param queries: List of tuples (li, ri, vi) :return: List of counts for each query def process_input(n: int, m: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process input to get results for queries :param n: Number of elements in the array :param m: Number of queries :param array: List of integers representing the array :param queries: List of tuples (li, ri, vi) representing queries :return: List of results for each query # Example Tests if __name__ == \\"__main__\\": arr = [1, 3, 4, 2, 5] queries = [(1, 3, 2), (2, 5, 3), (1, 5, 5)] print(count_elements(arr, queries)) # [2, 3, 1] arr = [1] queries = [(1, 1, 1), (1, 1, 2)] print(count_elements(arr, queries)) # [1, 0] arr = [2, 2, 2, 2, 2] queries = [(1, 5, 1), (1, 5, 2), (1, 5, 3)] print(count_elements(arr, queries)) # [5, 5, 0] arr = [1, 3, 4, 2, 5] queries = [(1, 3, 2), (2, 5, 3), (1, 5, 5)] print(process_input(5, 3, arr, queries)) # [2, 3, 1] arr = [4, 4, 4, 4] queries = [(1, 4, 4), (1, 4, 5)] print(process_input(4, 2, arr, queries)) # [4, 0]","solution":"def count_elements(arr, queries): Function to count elements in subarray [li, r] that are >= vi for each query. :param arr: List of integers representing the array :param queries: List of tuples (li, ri, vi) :return: List of counts for each query result = [] for (li, ri, vi) in queries: count = sum(1 for x in arr[li-1:ri] if x >= vi) result.append(count) return result def process_input(n, m, array, queries): Process input to get results for queries :param n: Number of elements in the array :param m: Number of queries :param array: List of integers representing the array :param queries: List of tuples (li, ri, vi) representing queries :return: List of results for each query results = count_elements(array, queries) return results"},{"question":"def count_frames_with_exact_border(n:int, q:int, photographs:List[Tuple[int, int, int]], queries:List[int]) -> List[int]: Counts the number of frames with exactly the specified border width for each query. Arguments: n : int - number of photographs q : int - number of queries photographs : list - list of tuples (width, height, frame width) queries : list - list of integers denoting the query for border width Returns: list of ints - count of frames with exactly the specified border width for each query Examples: >>> count_frames_with_exact_border(5, 3, [(4, 6, 2), (7, 8, 3), (4, 5, 2), (10, 12, 4), (6, 9, 2)], [2, 3, 4]) [3, 1, 1] >>> count_frames_with_exact_border(3, 2, [(4, 4, 1), (3, 3, 1), (2, 2, 1)], [2, 3]) [0, 0] >>> count_frames_with_exact_border(4, 4, [(10, 15, 1), (20, 25, 2), (30, 35, 3), (40, 45, 4)], [1, 2, 3, 4]) [1, 1, 1, 1]","solution":"def count_frames_with_exact_border(n, q, photographs, queries): Counts the number of frames with exactly the specified border width for each query. Arguments: n : int - number of photographs q : int - number of queries photographs : list - list of tuples (width, height, frame width) queries : list - list of integers denoting the query for border width Returns: list of ints - count of frames with exactly the specified border width for each query from collections import Counter # Create a counter for the widths of the borders border_counter = Counter() for (w, h, c) in photographs: border_counter[c] += 1 # Generate results for each query result = [] for query in queries: result.append(border_counter.get(query, 0)) return result"},{"question":"from typing import Union, List def express_as_powers_of_two(n: int) -> Union[int, List[int]]: Given an integer n, express it as a sum of distinct non-negative integer powers of 2. If possible, return those powers as a list; if not, return -1. Parameters: n (int): The target integer to express as a sum of distinct powers of 2. Returns: Union[int, List[int]]: A list of distinct powers of 2 that sum to n or -1 if not possible. pass def test_express_as_powers_of_two_example(): assert set(express_as_powers_of_two(18)) == {16, 2} def test_express_as_powers_of_two_single_power(): assert set(express_as_powers_of_two(16)) == {16} def test_express_as_powers_of_two_large_number(): result = express_as_powers_of_two(1000000000000000000) expected_value = {2**i for i in range(0, 60) if (1000000000000000000 & (1 << i)) != 0} assert set(result) == expected_value def test_express_as_powers_of_two_no_solution(): assert express_as_powers_of_two(0) == -1 def test_express_as_powers_of_two_min_value(): assert set(express_as_powers_of_two(1)) == {1}","solution":"def express_as_powers_of_two(n): Given an integer n, express it as a sum of distinct non-negative integer powers of 2. If possible, return those powers as a list; if not, return -1. Parameters: n (int): The target integer to express as a sum of distinct powers of 2. Returns: Union[int, List[int]]: A list of distinct powers of 2 that sum to n or -1 if not possible. if n <= 0: return -1 # Negative number or zero cannot be expressed as a sum of positive powers of 2. result = [] power = 0 while n > 0: if n % 2 == 1: result.append(2**power) n = n // 2 power += 1 return result if result else -1"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Determines if two strings s1 and s2 are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: str: \\"YES\\" if s1 and s2 are anagrams, \\"NO\\" otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"evil\\", \\"vile\\") \\"YES\\" >>> are_anagrams(\\"hello\\", \\"bello\\") \\"NO\\" >>> are_anagrams(\\"python\\", \\"typhon\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"apples\\") \\"NO\\" >>> are_anagrams(\\"ttaq\\", \\"attq\\") \\"YES\\" >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") \\"YES\\" >>> are_anagrams(\\"test\\", \\"test\\") \\"YES\\" >>> are_anagrams(\\"anagram\\", \\"anagram\\") \\"YES\\"","solution":"def are_anagrams(s1, s2): Determines if two strings s1 and s2 are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: str: \\"YES\\" if s1 and s2 are anagrams, \\"NO\\" otherwise. # Anagrams must have the same characters with the same frequency return \\"YES\\" if sorted(s1) == sorted(s2) else \\"NO\\""},{"question":"def max_coins(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum number of coins the thief can collect in a grid. Args: n: int - the number of rows in the grid. m: int - the number of columns in the grid. grid: List[List[int]] - the grid where each cell contains a number of coins. Returns: int - the maximum number of coins the thief can collect. Example: >>> max_coins(3, 4, [[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]) 12 >>> max_coins(1, 3, [[1, 2, 3]]) 6 >>> max_coins(3, 1, [[1], [2], [3]]) 6 from typing import List def test_example_case(): n, m = 3, 4 grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert max_coins(n, m, grid) == 12 def test_single_cell(): n, m = 1, 1 grid = [ [5] ] assert max_coins(n, m, grid) == 5 def test_single_row(): n, m = 1, 3 grid = [ [1, 2, 3] ] assert max_coins(n, m, grid) == 6 def test_single_column(): n, m = 3, 1 grid = [ [1], [2], [3] ] assert max_coins(n, m, grid) == 6 def test_large_grid(): n, m = 2, 2 grid = [ [100, 100], [100, 100] ] assert max_coins(n, m, grid) == 300","solution":"def max_coins(n, m, grid): # Create a 2D dp array filled with 0s dp = [[0 for _ in range(m)] for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill in the values for the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the values for the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The maximum coins will be in the bottom-right corner of the dp table return dp[-1][-1] # Example usage if __name__ == \\"__main__\\": n, m = 3, 4 grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] print(max_coins(n, m, grid)) # Output: 12"},{"question":"def numIslands(grid): Given an m × n grid map where '1's represent land and '0's represent water, return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. >>> numIslands([ ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) == 1 True >>> numIslands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) == 3 True def find_num_of_islands_from_input(m, n, grid_lines): Function to convert input data to grid and call numIslands. from solution import numIslands, find_num_of_islands_from_input def test_single_island(): m = 4 n = 5 grid_lines = [ \\"11110\\", \\"11010\\", \\"11000\\", \\"00000\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 1 def test_multiple_islands(): m = 4 n = 5 grid_lines = [ \\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 3 def test_single_cell_island(): m = 1 n = 1 grid_lines = [ \\"1\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 1 def test_no_island(): m = 3 n = 3 grid_lines = [ \\"000\\", \\"000\\", \\"000\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 0 def test_islands_on_edges(): m = 3 n = 3 grid_lines = [ \\"101\\", \\"010\\", \\"101\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 5 def test_large_grid_one_island(): m = 5 n = 5 grid_lines = [ \\"11111\\", \\"11111\\", \\"11111\\", \\"11111\\", \\"11111\\" ] assert find_num_of_islands_from_input(m, n, grid_lines) == 1","solution":"def numIslands(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): stack = [(i, j)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '1' and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: island_count += 1 visited[i][j] = True dfs(i, j) return island_count # Function to convert input data to grid and call numIslands def find_num_of_islands_from_input(m, n, grid_lines): grid = [list(line) for line in grid_lines] return numIslands(grid)"},{"question":"from collections import deque, defaultdict import itertools def bfs_shortest_path(graph, start): Find the shortest path from start to all other nodes using BFS. distances = {start: 0} queue = deque([start]) while queue: node = queue.popleft() current_distance = distances[node] for neighbor in graph[node]: if neighbor not in distances: distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances def find_minimum_distance(n, m, k, edges, desired_stations, start): Find the minimum distance the traveler must walk to visit all desired stations starting from the given station. >>> find_minimum_distance(5, 6, 3, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (3, 5)], [1, 5, 4], 1) 2 >>> find_minimum_distance(5, 6, 3, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (3, 5)], [2, 3, 4], 1) 3 >>> find_minimum_distance(5, 6, 3, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (3, 5)], [2, 3, 5], 1) 3 >>> find_minimum_distance(4, 3, 2, [(1, 2), (2, 3), (3, 4)], [2, 4], 1) 3 >>> find_minimum_distance(4, 3, 2, [(1, 2), (2, 3), (3, 4)], [3, 4], 1) 3 >>> find_minimum_distance(1, 0, 1, [], [1], 1) 0 >>> find_minimum_distance(2, 1, 1, [(1, 2)], [2], 1) 1 >>> find_minimum_distance(2, 1, 1, [(1, 2)], [1], 2) 1 >>> find_minimum_distance(3, 2, 3, [(1, 2), (2, 3)], [1, 2, 3], 1) 2","solution":"from collections import deque, defaultdict import itertools def bfs_shortest_path(graph, start): Find the shortest path from start to all other nodes using BFS. distances = {start: 0} queue = deque([start]) while queue: node = queue.popleft() current_distance = distances[node] for neighbor in graph[node]: if neighbor not in distances: distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances def find_minimum_distance(n, m, k, edges, desired_stations, start): # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Find shortest path from start to all desired stations start_distances = bfs_shortest_path(graph, start) # Find shortest paths between all pairs of desired stations all_stations = desired_stations.copy() all_stations.append(start) all_pair_distances = {} for station in all_stations: all_pair_distances[station] = bfs_shortest_path(graph, station) min_distance = float('inf') # Calculate minimum distance to visit all desired stations for perm in itertools.permutations(desired_stations): current_distance = start_distances[perm[0]] for i in range(len(perm) - 1): current_distance += all_pair_distances[perm[i]][perm[i + 1]] min_distance = min(min_distance, current_distance) return min_distance"},{"question":"def minimize_max_difference(n: int, sweetness_levels: List[int]) -> int: This function returns the minimum possible value of the maximum absolute difference between the sweetness levels of consecutive products after rearranging them. :param n: Number of products (integer) :param sweetness_levels: List of sweetness levels (list of integers) :return: Minimum possible value of the maximum absolute difference (integer) >>> minimize_max_difference(4, [4, 7, 2, 9]) 2 >>> minimize_max_difference(4, [1, 5, 8, 10]) 2","solution":"def minimize_max_difference(n, sweetness_levels): This function returns the minimum possible value of the maximum absolute difference between the sweetness levels of consecutive products after rearranging them. :param n: Number of products (integer) :param sweetness_levels: List of sweetness levels (list of integers) :return: Minimum possible value of the maximum absolute difference (integer) # Sort the sweetness levels sweetness_levels.sort() # Initialize the minimum possible value of the maximum absolute difference min_max_diff = float('inf') # Iterate through the sorted list to find the minimum possible value for i in range(1, n): diff = sweetness_levels[i] - sweetness_levels[i - 1] min_max_diff = min(min_max_diff, diff) return min_max_diff"},{"question":"def rearrange_heights(n: int, heights: List[int]) -> Union[List[int], str]: Rearrange the heights of the students in a strictly alternating pattern of shortest and tallest students. If it's not possible, return \\"Impossible\\". >>> rearrange_heights(6, [1, 3, 5, 2, 4, 6]) [1, 6, 2, 5, 3, 4] >>> rearrange_heights(3, [1, 2, 3]) \\"Impossible\\" from typing import List, Union def test_even_number(): assert rearrange_heights(6, [1, 3, 5, 2, 4, 6]) == [1, 6, 2, 5, 3, 4] def test_odd_number(): assert rearrange_heights(3, [1, 2, 3]) == \\"Impossible\\" def test_regular_even_number(): assert rearrange_heights(4, [1, 3, 5, 7]) == [1, 5, 3, 7] def test_edge_case_no_students(): assert rearrange_heights(0, []) == \\"Impossible\\" def test_edge_case_one_student(): assert rearrange_heights(1, [1]) == \\"Impossible\\" def test_large_input(): assert rearrange_heights(100000, list(range(1, 100001)))[:6] == [1, 50001, 2, 50002, 3, 50003]","solution":"def rearrange_heights(n, heights): if n < 3: return \\"Impossible\\" heights.sort() if n % 2 == 1: return \\"Impossible\\" half = n // 2 result = [] for i in range(half): result.append(heights[i]) result.append(heights[half + i]) return result"},{"question":"def matrix_updates(n: int, m: int, q: int, queries: List[str]) -> List[List[int]]: Update a matrix based on a list of queries. Args: n (int): number of rows. m (int): number of columns. q (int): number of queries. queries (List[str]): list of queries to be executed. Returns: List[List[int]]: the final state of the matrix. Examples: >>> matrix_updates(3, 3, 1, [\\"1 2 5\\"]) [[0, 0, 0], [5, 5, 5], [0, 0, 0]] >>> matrix_updates(3, 3, 1, [\\"2 3 6\\"]) [[0, 0, 6], [0, 0, 6], [0, 0, 6]] >>> matrix_updates(3, 3, 4, [\\"1 2 5\\", \\"2 3 6\\", \\"1 1 5\\", \\"2 2 7\\"]) [[5, 7, 5], [5, 7, 6], [0, 7, 6]] >>> matrix_updates(3, 3, 0, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> matrix_updates(2, 2, 2, [\\"1 1 1000000000\\", \\"2 2 999999999\\"]) [[1000000000, 999999999], [0, 999999999]]","solution":"def matrix_updates(n, m, q, queries): matrix = [[0]*m for _ in range(n)] for query in queries: query = query.split() if query[0] == \\"1\\": r = int(query[1]) - 1 x = int(query[2]) for col in range(m): matrix[r][col] = x elif query[0] == \\"2\\": c = int(query[1]) - 1 y = int(query[2]) for row in range(n): matrix[row][c] = y return matrix"},{"question":"def canTransform(n: int, s: str, t: str) -> str: Determines if string s can be transformed into string t by some reordering of its characters. >>> canTransform(5, \\"abcde\\", \\"edcba\\") \\"YES\\" >>> canTransform(4, \\"abcd\\", \\"abcf\\") \\"NO\\" pass","solution":"def canTransform(n, s, t): Determines if string s can be transformed into string t by some reordering of its characters. Parameters: n (int): Length of the strings s and t. s (str): The source string to be transformed. t (str): The target string to be matched. Returns: str: \\"YES\\" if s can be transformed into t, otherwise \\"NO\\". return \\"YES\\" if sorted(s) == sorted(t) else \\"NO\\""},{"question":"from typing import List, Tuple def find_popular_person(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Determine if there is a popular person in the network and return their ID. A popular person has more friends than everyone else in the network. If there is a tie for the highest number of friends, then there is no popular person. Args: n: int - the number of people in the network. m: int - the number of friendships. friendships: List[Tuple[int, int]] - a list of pairs representing the friendships. Returns: int - the ID of the most popular person, or -1 if there is no such person. >>> find_popular_person(5, 4, [(1, 2), (2, 3), (2, 4), (2, 5)]) 2 >>> find_popular_person(3, 1, [(1, 2)]) -1 >>> find_popular_person(3, 3, [(1, 2), (1, 3), (2, 3)]) -1","solution":"def find_popular_person(n, m, friendships): from collections import defaultdict # Initialize a dictionary to keep the friend count for each person friend_count = defaultdict(int) # Traverse each friendship for u, v in friendships: friend_count[u] += 1 friend_count[v] += 1 # Find the maximum number of friends any person has max_friends = max(friend_count.values(), default=0) # Find all persons who have the maximum number of friends potential_popular_people = [person for person, count in friend_count.items() if count == max_friends] # If exactly one person has the most friends, they are the popular person if len(potential_popular_people) == 1: return potential_popular_people[0] # If no people or multiple people have the same max number of friends, there's no popular person return -1"},{"question":"def count_primes(n: int) -> int: Returns the count of prime numbers between 2 and n (both inclusive). Uses the Sieve of Eratosthenes algorithm for efficient computation. >>> count_primes(10) 4 >>> count_primes(30) 10","solution":"def count_primes(n): Returns the count of prime numbers between 2 and n (both inclusive). Uses the Sieve of Eratosthenes algorithm for efficient computation. if n < 2: return 0 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n + 1, i): sieve[j] = False return sum(sieve)"},{"question":"def longest_mountain(arr: List[int]) -> int: Returns the length of the longest subarray that forms a mountain. A mountain subarray is one where the heights first strictly increase to a peak, then strictly decrease. Args: arr (List[int]): A list of integers representing the heights of the hills. Returns: int: The length of the longest mountain subarray. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0","solution":"def longest_mountain(arr): n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i-1] < arr[i] > arr[i+1]: left = i - 1 while left > 0 and arr[left-1] < arr[left]: left -= 1 right = i + 1 while right < n - 1 and arr[right] > arr[right+1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def max_disjoint_subsets_sum(n: int, arr: List[int]) -> int: Returns the sum of the maximum sums from two disjoint subsets. >>> max_disjoint_subsets_sum(5, [4, 1, 7, 3, 8]) 15 >>> max_disjoint_subsets_sum(2, [2, 3]) 5 >>> max_disjoint_subsets_sum(1, [5]) 5","solution":"def max_disjoint_subsets_sum(n, arr): Returns the sum of the maximum sums from two disjoint subsets. if n < 2: return sum(arr) arr.sort(reverse=True) return arr[0] + arr[1]"},{"question":"import heapq from typing import List, Tuple def shortest_path(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Finds the shortest path from intersection 1 to intersection n. Parameters: n (int): Number of intersections m (int): Number of roads roads (list of tuples): List of roads details in the form (u, v, w) Returns: int: Length of the shortest path from intersection 1 to intersection n, or -1 if no such path exists Examples: >>> shortest_path(2, 1, [(1, 2, 4)]) 4 >>> shortest_path(4, 4, [(1, 2, 4), (1, 3, 2), (2, 4, 3), (3, 4, 7)]) 7 >>> shortest_path(3, 1, [(1, 2, 1)]) -1 >>> shortest_path(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 3, 8), (2, 5, 10)]) 8 >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 5)]) 2","solution":"import heapq def shortest_path(n, m, roads): Finds the shortest path from intersection 1 to intersection n. Parameters: n (int): Number of intersections m (int): Number of roads roads (list of tuples): List of roads details in the form (u, v, w) Returns: int: Length of the shortest path from intersection 1 to intersection n, or -1 if no such path exists graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, 1)] distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) shortest_distance = distances[n] return shortest_distance if shortest_distance != float('inf') else -1"},{"question":"def single_number(nums: list) -> int: Finds the integer that appears exactly once in the list. Every other integer appears exactly twice. Parameters: nums (list): List of integers where every integer except one appears twice. Returns: int: The integer that appears exactly once. >>> single_number([4, 3, 2, 4, 2, 3, 5]) == 5 >>> single_number([1, 2, 3, 2, 3]) == 1 >>> single_number([2, 2, 3, 3, 4]) == 4 >>> single_number([1, 2, 3, 4, 3, 2, 1]) == 4 >>> single_number([1]) == 1","solution":"def single_number(nums): Finds the integer that appears exactly once in the list. Every other integer appears exactly twice. Paramaters: nums (list): List of integers where every integer except one appears twice. Returns: int: The integer that appears exactly once. result = 0 for num in nums: result ^= num return result"},{"question":"def distribute_prize_money(S: int, k: int) -> list: Distributes the prize money S among k winners such that each successive winner gets at least twice as much as the previous one. If it is not possible to distribute the prize money in this way, returns -1. >>> distribute_prize_money(10, 3) [1, 2, 7] >>> distribute_prize_money(5, 3) -1","solution":"def distribute_prize_money(S, k): Distributes the prize money S among k winners such that each successive winner gets at least twice as much as the previous one. If it is not possible to distribute the prize money in this way, returns -1. if S < (1 << (k-1)): # The minimum required sum if we start with 1 and each next gets at least twice the previous return -1 prizes = [0] * k prizes[0] = 1 remaining_sum = S - 1 for i in range(1, k): prizes[i] = prizes[i-1] * 2 remaining_sum -= prizes[i] if remaining_sum < 0: return -1 prizes[k-1] += remaining_sum return prizes"},{"question":"from typing import List, Tuple def bfs_shortest_path(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Function to find the shortest path using BFS between pairs of nodes. Parameters: n : int : Number of nodes in the graph edges : List[Tuple[int, int]] : List of edges in the graph queries : List[Tuple[int, int]] : List of queries for which to find shortest paths Returns: List[int] : List of shortest path lengths for each query pass # Example test cases def test_bfs_basic(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (4, 5)] queries = [(1, 5), (2, 4), (1, 1)] result = bfs_shortest_path(n, edges, queries) assert result == [3, 3, 0] def test_bfs_disconnected(): n = 6 edges = [(1, 2), (2, 3), (4, 5)] queries = [(1, 4), (1, 5), (3, 6)] result = bfs_shortest_path(n, edges, queries) assert result == [-1, -1, -1] def test_bfs_multiple_queries(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [(1, 4), (2, 3), (3, 1)] result = bfs_shortest_path(n, edges, queries) assert result == [3, 1, 2] def test_bfs_no_edges(): n = 3 edges = [] queries = [(1, 2), (2, 3)] result = bfs_shortest_path(n, edges, queries) assert result == [-1, -1] def test_bfs_self_query(): n = 3 edges = [(1, 2), (2, 3)] queries = [(1, 1), (3, 3)] result = bfs_shortest_path(n, edges, queries) assert result == [0, 0]","solution":"from collections import deque, defaultdict def bfs_shortest_path(n, edges, queries): Function to find the shortest path using BFS between pairs of nodes. Parameters: n : int : Number of nodes in the graph edges : List[Tuple[int, int]] : List of edges in the graph queries : List[Tuple[int, int]] : List of queries for which to find shortest paths Returns: List[int] : List of shortest path lengths for each query # Create adjacency list for the graph adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) def bfs(start, end): # If the start and end are the same, shortest path is 0 if start == end: return 0 visited = [False] * (n + 1) distance = [0] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True distance[neighbor] = distance[node] + 1 queue.append(neighbor) if neighbor == end: return distance[neighbor] return -1 # No path exists result = [] for u, v in queries: result.append(bfs(u, v)) return result"},{"question":"from typing import List def shortest_path_with_removal(grid: List[str]) -> int: Determine the length of the shortest path from the top-left corner to the bottom-right corner in a grid, removing at most one obstacle. >>> grid = [ ... \\"0000#\\", ... \\"000\\", ... \\"0#0#0\\", ... \\"0#0\\", ... \\"00000\\" ... ] >>> shortest_path_with_removal(grid) 9 >>> grid = [ ... \\"000\\", ... \\"000\\", ... \\"000\\" ... ] >>> shortest_path_with_removal(grid) 5","solution":"from collections import deque def shortest_path_with_removal(grid): n = len(grid) m = len(grid[0]) def is_valid(x, y): return 0 <= x < n and 0 <= y < m def bfs(): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1, 0)]) # (x, y, distance, removed) visited = [[[False] * 2 for _ in range(m)] for _ in range(n)] visited[0][0][0] = True while queue: x, y, dist, removed = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): if grid[nx][ny] == '0' and not visited[nx][ny][removed]: visited[nx][ny][removed] = True queue.append((nx, ny, dist + 1, removed)) elif grid[nx][ny] == '#' and removed == 0 and not visited[nx][ny][1]: visited[nx][ny][1] = True queue.append((nx, ny, dist + 1, 1)) return -1 return bfs() # Example usage n = 5 m = 5 grid = [ \\"0000#\\", \\"000\\", \\"0#0#0\\", \\"0#0\\", \\"00000\\" ] print(shortest_path_with_removal(grid)) # Output: 9"},{"question":"def min_list_size(n: int, arr: List[int]) -> int: Returns the minimum possible size of the list after performing any number of the allowed operations. >>> min_list_size(1, [5]) 1 >>> min_list_size(2, [1, 2]) 1 >>> min_list_size(5, [1, 2, 3, 4, 5]) 1 >>> min_list_size(3, [7, 8, 9]) 1 >>> min_list_size(4, [1, 1, 1, 1]) 1","solution":"def min_list_size(n, arr): Returns the minimum possible size of the list after performing any number of the allowed operations. return 1 if n > 0 else 0"},{"question":"def min_changes_to_non_decreasing(arr: List[int]) -> int: Calculate the minimum number of changes needed to make a list non-decreasing. A change is either increasing or decreasing the value of a single element in the list. Parameters: arr (list of int): List of integers Returns: int: The minimum number of changes required >>> min_changes_to_non_decreasing([1, 5, 3, 4, 2, 6]) 2 >>> min_changes_to_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_changes_to_non_decreasing([5, 4, 3, 2, 1]) 4 >>> min_changes_to_non_decreasing([1, 3, 2, 4, 3, 5]) 2 >>> min_changes_to_non_decreasing([1]) 0 >>> min_changes_to_non_decreasing([1, 2]) 0 >>> min_changes_to_non_decreasing([2, 1]) 1","solution":"def min_changes_to_non_decreasing(arr): Calculate the minimum number of changes needed to make a list non-decreasing. A change is either increasing or decreasing the value of a single element in the list. Parameters: arr (list of int): List of integers Returns: int: The minimum number of changes required n = len(arr) # dp[i] will hold the minimum changes needed to make arr[0:i+1] non-decreasing dp = [0] * n # Fill dp array for i in range(1, n): if arr[i] >= arr[i-1]: dp[i] = dp[i-1] else: dp[i] = dp[i-1] + 1 return dp[-1] # Example usage: # Input: 6, [1, 5, 3, 4, 2, 6] # Output: 2 # One way to make the list non-decreasing with 2 changes: # Change to: [1, 5, 5, 5, 5, 6]"},{"question":"def min_weight_path(n: int, m: int, grid: List[List[int]]) -> int: Optimal Path in a Weighted Grid You are given a weighted grid of size n x m, where each cell contains a non-negative integer representing its weight. The task is to find the minimum weight path from the top-left corner (1, 1) to the bottom-right corner (n, m). The path weight is the sum of the weights of the cells traversed in the path, including the starting and ending cells. You can move only right or down from any cell in the grid. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[List[int]]): The weights of each cell in the grid. Returns: int: The minimum weight of the path from the top-left to the bottom-right corner. Example: >>> min_weight_path(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_weight_path(1, 4, [ ... [1, 2, 3, 4] ... ]) 10","solution":"def min_weight_path(n, m, grid): # Create a 2D DP array to store the minimum path sum to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell with its own weight dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the minimum path sum return dp[-1][-1]"},{"question":"from typing import List def tsp(n: int, distances: List[List[int]]) -> int: Calculate the length of the shortest path that visits every city exactly once and returns to the starting city. >>> tsp(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) == 80 >>> tsp(3, [ ... [0, 10, 15], ... [10, 0, 35], ... [15, 35, 0] ... ]) == 60 >>> tsp(2, [ ... [0, 10], ... [10, 0] ... ]) == 20 >>> tsp(3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0","solution":"from itertools import permutations def tsp(n, distances): def calculate_distance(path): distance = 0 for i in range(len(path) - 1): distance += distances[path[i]][path[i + 1]] distance += distances[path[-1]][path[0]] return distance cities = list(range(n)) min_distance = float('inf') for perm in permutations(cities): current_distance = calculate_distance(perm) if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def tree_diameter(n: int, edges: List[Tuple[int, int, int]]) -> int: Given an undirected tree with n nodes numbered from 1 to n, and each edge has a weight, find the longest distance between any two nodes in the tree (the diameter of the tree). >>> tree_diameter(5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1)]) 10 >>> tree_diameter(1, []) 0 >>> tree_diameter(2, [(1, 2, 5)]) 5","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): if n == 1: return 0 def bfs(start): visited = [-1] * (n + 1) queue = deque([(start, 0)]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() for neighbor, weight in graph[node]: if visited[neighbor] == -1: visited[neighbor] = dist + weight queue.append((neighbor, dist + weight)) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Find the farthest node from node 1 (or any arbitrary node) farthest_node, _ = bfs(1) # Find the farthest node from the previously found farthest node _, diameter = bfs(farthest_node) return diameter"},{"question":"def count_pyramid_heights(n: int) -> int: Calculate the number of different heights of pyramids that can be built with exactly n blocks. >>> count_pyramid_heights(5) 2 >>> count_pyramid_heights(1) 1 >>> count_pyramid_heights(3) 2 >>> count_pyramid_heights(6) 3 >>> count_pyramid_heights(15) 5 >>> count_pyramid_heights(2) 1 >>> count_pyramid_heights(10) 4","solution":"def count_pyramid_heights(n): count = 0 height = 1 total_blocks = 0 while total_blocks < n: total_blocks += height if total_blocks <= n: count += 1 height += 1 return count"},{"question":"def is_balanced_binary_tree_possible(n: int, values: List[int]) -> str: Determines if it is possible to construct a balanced binary tree with the given in-order traversal. Args: n (int): The number of integers. values (list of int): The list of integers. Returns: str: \\"YES\\" if it's possible to construct a balanced binary tree, otherwise \\"NO\\". >>> is_balanced_binary_tree_possible(3, [2, 1, 3]) \\"YES\\" >>> is_balanced_binary_tree_possible(4, [1, 2, 3, 4]) \\"NO\\" >>> is_balanced_binary_tree_possible(1, [1]) \\"YES\\" >>> is_balanced_binary_tree_possible(7, [1, 2, 3, 4, 5, 6, 7]) \\"YES\\" >>> is_balanced_binary_tree_possible(5, [1, 2, 3, 4, 5]) \\"NO\\" >>> is_balanced_binary_tree_possible(1000, list(range(1, 1001))) \\"NO\\"","solution":"def is_balanced_binary_tree_possible(n, values): Determines if it is possible to construct a balanced binary tree with the given in-order traversal. Args: n (int): The number of integers. values (list of int): The list of integers. Returns: str: \\"YES\\" if it's possible to construct a balanced binary tree, otherwise \\"NO\\". import math depth = math.log2(n + 1) if depth.is_integer(): return \\"YES\\" else: return \\"NO\\""},{"question":"def can_be_palindrome_by_removing_one_char(s: str) -> bool: Determine if it is possible to make the string a palindrome by removing exactly one character. >>> can_be_palindrome_by_removing_one_char(\\"abca\\") True >>> can_be_palindrome_by_removing_one_char(\\"abc\\") False def check_palindromes(t: int, strings: List[str]) -> List[str]: For each string in 'strings', determine if it is possible to make the string a palindrome by removing exactly one character. >>> check_palindromes(3, [\\"abca\\", \\"abc\\", \\"a\\"]) ['YES', 'NO', 'YES'] >>> check_palindromes(1, [\\"racecar\\"]) ['YES'] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) strings = data[1:t+1] results = check_palindromes(t, strings) for result in results: print(result)","solution":"def can_be_palindrome_by_removing_one_char(s): def is_palindrome(x): return x == x[::-1] l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: return is_palindrome(s[l+1:r+1]) or is_palindrome(s[l:r]) l += 1 r -= 1 return True def check_palindromes(t, strings): results = [] for s in strings: if can_be_palindrome_by_removing_one_char(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) strings = data[1:t+1] results = check_palindromes(t, strings) for result in results: print(result)"},{"question":"def recommend_products(n: int, products: List[Tuple[int, int]]) -> List[int]: Recommends products based on the ids and scores with the given rules. :param n: Number of products :param products: List of tuples, each tuple containing an identifier and a score :return: List of product identifiers in the recommended order >>> recommend_products(5, [(2, 500), (4, 200), (3, 300), (1, 600), (5, 400)]) [1, 3, 5, 2, 4] >>> recommend_products(1, [(1, 500)]) [1] >>> recommend_products(3, [(1, 300), (2, 500), (3, 400)]) [2, 1, 3] >>> recommend_products(4, [(1, 1000), (2, 900), (3, 800), (4, 700)]) [1, 3, 2, 4] >>> recommend_products(4, [(1, 500), (2, 500), (3, 500), (4, 500)]) [1, 3, 2, 4]","solution":"def recommend_products(n, products): Recommends products based on the ids and scores with the given rules. :param n: Number of products :param products: List of tuples, each tuple containing an identifier and a score :return: List of product identifiers in the recommended order # Sort products by scores in descending order products.sort(key=lambda x: x[1], reverse=True) result = [] used_ids = set() for prod in products: id = prod[0] # Try to place the product based on the non-consecutive rule if not (result and abs(result[-1] - id) == 1): result.append(id) used_ids.add(id) # In case some products couldn't be placed based on the first rule for prod in products: id = prod[0] if id not in used_ids: result.append(id) return result"},{"question":"from typing import List, Tuple def find_shortest_path(n: int, m: int, a: int, b: int, edges: List[Tuple[int, int, int]]) -> int: Find the length of the shortest path between two given nodes a and b in an undirected weighted graph with n vertices and m edges. Parameters: - n (int): The number of vertices. - m (int): The number of edges. - a (int): The starting vertex. - b (int): The ending vertex. - edges (List[Tuple[int, int, int]]): Each tuple represents an edge with (u, v, w) where u and v are the vertices connected by the edge and w is the weight of the edge. Returns: - int: The length of the shortest path between nodes a and b. If there is no path, return -1. >>> find_shortest_path(5, 6, 1, 5, [(1, 2, 2), (2, 3, 3), (3, 4, 1), (4, 5, 2), (2, 5, 6), (1, 5, 10)]) 8 >>> find_shortest_path(4, 2, 1, 4, [(1, 2, 3), (2, 3, 4)]) -1 >>> find_shortest_path(3, 2, 1, 3, [(1, 2, 5), (2, 3, 6)]) 11 >>> find_shortest_path(2, 1, 1, 2, [(1, 2, 7)]) 7 >>> find_shortest_path(4, 4, 1, 4, [(1, 2, 300), (2, 4, 500), (1, 3, 400), (3, 4, 200)]) 600","solution":"import heapq def dijkstra(n, edges, a, b): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, a)] distances = {i: float('inf') for i in range(1, n + 1)} distances[a] = 0 while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[b] if distances[b] != float('inf') else -1 def find_shortest_path(n, m, a, b, edges): return dijkstra(n, edges, a, b)"},{"question":"def max_credit_score(n: int, m: int, projects: List[List[int]]) -> int: Calculate the maximum score credited to any participant. Args: n (int): Number of participants m (int): Number of projects projects (list): List of projects, each project is represented as a list where the first element is the number of participants, followed by participant IDs, and the last element is the score. Returns: int: The maximum score credited to any participant. pass # Here are the test cases def test_case_1(): n = 4 m = 3 projects = [ [2, 1, 2, 50], [3, 1, 3, 4, 60], [1, 2, 30] ] assert max_credit_score(n, m, projects) == 110 def test_case_2(): n = 3 m = 2 projects = [ [3, 1, 2, 3, 100], [1, 2, 50] ] assert max_credit_score(n, m, projects) == 150 def test_case_3(): n = 5 m = 5 projects = [ [1, 1, 10], [1, 2, 20], [1, 3, 30], [1, 4, 40], [1, 5, 50] ] assert max_credit_score(n, m, projects) == 50 def test_case_4(): n = 1 m = 1 projects = [ [1, 1, 999999999] ] assert max_credit_score(n, m, projects) == 999999999 def test_case_5(): n = 2 m = 2 projects = [ [2, 1, 2, 10], [1, 1, 5] ] assert max_credit_score(n, m, projects) == 15","solution":"def max_credit_score(n, m, projects): Calculate the maximum score credited to any participant. Args: n (int): Number of participants m (int): Number of projects projects (list): List of projects, each project is represented as a list where the first element is the number of participants, followed by participant IDs, and the last element is the score. Returns: int: The maximum score credited to any participant. scores = [0] * (n + 1) for project in projects: participants = project[1:-1] score = project[-1] for participant in participants: scores[participant] += score return max(scores)"},{"question":"def smallest_string(n: int, s: str) -> str: Returns the lexicographically smallest string that can be produced by reducing the string \`s\` using the described operation. >>> smallest_string(2, \\"ab\\") \\"a\\" >>> smallest_string(4, \\"dcba\\") \\"a\\" >>> smallest_string(5, \\"iiiii\\") \\"i\\"","solution":"def smallest_string(n, s): Returns the lexicographically smallest string that can be produced by reducing the string \`s\` using the described operation. # The minimum character in the string s can always be achieved # directly because any two characters can sum up to at most 17 # which ends up being one character after modulo reduction. min_char = min(s) return min_char"},{"question":"def min_brush_strokes(n: int, canvases: str) -> int: Returns the minimum number of contiguous brush strokes needed to paint all canvases. >>> min_brush_strokes(4, \\"1000\\") 1 >>> min_brush_strokes(5, \\"00110\\") 2 >>> min_brush_strokes(5, \\"11111\\") 0 >>> min_brush_strokes(5, \\"00000\\") 1 >>> min_brush_strokes(6, \\"010101\\") 3 >>> min_brush_strokes(1, \\"0\\") 1 >>> min_brush_strokes(1, \\"1\\") 0 >>> min_brush_strokes(3, \\"110\\") 1 >>> min_brush_strokes(3, \\"011\\") 1","solution":"def min_brush_strokes(n, canvases): Returns the minimum number of contiguous brush strokes needed to paint all canvases. # We need to count separate segments of unpainted canvases count = 0 for i in range(n): if canvases[i] == '0': if i == 0 or canvases[i-1] == '1': count += 1 return count"},{"question":"def minimum_fence_length(n: int, plants: List[Tuple[int, int]]) -> int: Returns the minimum possible length of the fence that passes through all plants but does not cut through any plants. >>> minimum_fence_length(5, [(3, 1), (9, 1), (8, 2), (2, 2), (4, 1)]) 1 >>> minimum_fence_length(1, [(5, 1)]) float('inf') >>> minimum_fence_length(2, [(5, 1), (10, 2)]) 5 >>> minimum_fence_length(3, [(5, 1), (5, 2), (5, 1)]) 0 import pytest def test_example_case(): assert minimum_fence_length(5, [(3, 1), (9, 1), (8, 2), (2, 2), (4, 1)]) == 1 def test_single_plant(): assert minimum_fence_length(1, [(5, 1)]) == float('inf') def test_two_plants_different_heights(): assert minimum_fence_length(2, [(5, 1), (10, 2)]) == 5 def test_plural_plants_same_height(): assert minimum_fence_length(3, [(5, 1), (5, 2), (5, 1)]) == 0 def test_large_input(): import random heights = random.sample(range(1, 10**6), 10**5) plants = [(h, random.choice([1, 2])) for h in heights] assert minimum_fence_length(len(plants), plants) > 0 # The exact value may vary, but should be positive pytest.main()","solution":"def minimum_fence_length(n, plants): Returns the minimum possible length of the fence that passes through all plants but does not cut through any plants. heights = sorted([h for h, t in plants]) min_length = float('inf') # Calculate distances between consecutive sorted heights for i in range(1, len(heights)): min_length = min(min_length, heights[i] - heights[i - 1]) return min_length"},{"question":"def longest_common_subsequence(n: int, m: int, strand1: str, strand2: str) -> int: Returns the length of the longest common subsequence of the two given DNA strands. :param n: Length of the first DNA strand :param m: Length of the second DNA strand :param strand1: First DNA strand :param strand2: Second DNA strand :return: Length of the longest common subsequence Examples: >>> longest_common_subsequence(7, 6, \\"ATCGATC\\", \\"TACGCT\\") 4 >>> longest_common_subsequence(4, 4, \\"ATCG\\", \\"ATCG\\") 4 >>> longest_common_subsequence(3, 3, \\"AAA\\", \\"TTT\\") 0 >>> longest_common_subsequence(8, 7, \\"AATCGAAT\\", \\"GCGTACT\\") 4 >>> longest_common_subsequence(0, 5, \\"\\", \\"GGTCA\\") 0 >>> longest_common_subsequence(5, 0, \\"AAGCT\\", \\"\\") 0 >>> longest_common_subsequence(1, 1, \\"A\\", \\"A\\") 1 >>> longest_common_subsequence(1, 1, \\"A\\", \\"T\\") 0 pass","solution":"def longest_common_subsequence(n, m, strand1, strand2): Returns the length of the longest common subsequence of the two given DNA strands. :param n: Length of the first DNA strand :param m: Length of the second DNA strand :param strand1: First DNA strand :param strand2: Second DNA strand :return: Length of the longest common subsequence # Creating a 2D array to store the lengths of LCS dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if strand1[i - 1] == strand2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"from typing import List, Tuple def minimum_additional_flights(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: For each test case, determine the minimum number of additional direct flights required to ensure no city is left isolated. Args: test_cases: A list of tuples, each containing: - n: the number of cities - m: the number of direct flights initially available - edges: a list of tuples, each representing a direct flight between two cities Returns: A list of integers representing the minimum number of additional direct flights required for each test case. Example: >>> minimum_additional_flights([ (6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]), (5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) ]) [1, 0] >>> minimum_additional_flights([ (4, 0, []) ]) [3] >>> minimum_additional_flights([ (1, 0, []) ]) [0]","solution":"from collections import defaultdict def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) def count_isolated_groups(n, edges): adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = set() num_groups = 0 for node in range(1, n + 1): if node not in visited: visited.add(node) dfs(node, visited, adj_list) num_groups += 1 # Minimum additional direct flights needed is (num_groups - 1) return num_groups - 1 def minimum_additional_flights(test_cases): results = [] for case in test_cases: n, m, edges = case results.append(count_isolated_groups(n, edges)) return results"},{"question":"from typing import List, Tuple def count_non_forbidden_substrings(s: str, forbidden: List[str]) -> int: Given a string 's' and a list of forbidden substrings, return the count of substrings of 's' that are not in the list of forbidden substrings. >>> count_non_forbidden_substrings(\\"abc\\", [\\"a\\", \\"bc\\"]) 4 >>> count_non_forbidden_substrings(\\"abcd\\", [\\"bc\\"]) 9 pass def solve_cases(test_cases: List[Tuple[str, int, List[str]]]) -> List[int]: Solve multiple test cases of finding the count of non-forbidden substrings. Args: test_cases : List[Tuple[str, int, List[str]]] : A list of test cases, where each test case is a tuple containing: - s : str : The string to evaluate - F : int : The number of forbidden substrings - forbidden : List[str] : The list of forbidden substrings Returns: List[int] : A list of integers where each integer is the result for the corresponding test case. pass def test_count_non_forbidden_substrings(): # Test case 1 s1 = \\"abc\\" forbidden1 = [\\"a\\", \\"bc\\"] assert count_non_forbidden_substrings(s1, forbidden1) == 4 # Test case 2 s2 = \\"abcd\\" forbidden2 = [\\"bc\\"] assert count_non_forbidden_substrings(s2, forbidden2) == 9 # Additional test cases s3 = \\"aaa\\" forbidden3 = [\\"a\\", \\"aa\\"] assert count_non_forbidden_substrings(s3, forbidden3) == 1 s4 = \\"xyz\\" forbidden4 = [\\"x\\", \\"y\\"] assert count_non_forbidden_substrings(s4, forbidden4) == 4 s5 = \\"hello\\" forbidden5 = [\\"he\\", \\"lo\\"] unique_forbidden = {\\"he\\", \\"lo\\"} correct_substrings = {'h', 'e', 'l', 'l', 'o', 'el', 'll', 'hel', 'ell', 'llo', 'hell', 'ello', 'hello'} - unique_forbidden assert count_non_forbidden_substrings(s5, forbidden5) == len(correct_substrings) def test_solve_cases(): # Combine test cases test_cases = [ (\\"abc\\", 2, [\\"a\\", \\"bc\\"]), (\\"abcd\\", 1, [\\"bc\\"]), (\\"aaa\\", 2, [\\"a\\", \\"aa\\"]), (\\"xyz\\", 2, [\\"x\\", \\"y\\"]), (\\"hello\\", 2, [\\"he\\", \\"lo\\"]) ] expected_results = [4, 9, 1, 4, len({'h', 'e', 'l', 'l', 'o', 'el', 'll', 'hel', 'ell', 'llo', 'hell', 'ello', 'hello'} - {\\"he\\", \\"lo\\"})] assert solve_cases(test_cases) == expected_results if __name__ == \\"__main__\\": test_count_non_forbidden_substrings() test_solve_cases() print(\\"All tests passed!\\")","solution":"def count_non_forbidden_substrings(s, forbidden): Returns the count of substrings of \`s\` that are not in the \`forbidden\` list. substrings = set() # Generate all substrings of s for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) # Filter out the forbidden substrings non_forbidden_substrings = substrings - set(forbidden) return len(non_forbidden_substrings) def solve_cases(test_cases): results = [] for s, F, forbidden in test_cases: results.append(count_non_forbidden_substrings(s, forbidden)) return results # Reading input and solving test cases def main(): import sys input = sys.stdin.read data = input().strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): s = data[index] index += 1 F = int(data[index]) index += 1 forbidden = [] for __ in range(F): forbidden.append(data[index]) index += 1 test_cases.append((s, F, forbidden)) results = solve_cases(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def minimum_cost_to_fix_fence(n, k, q, heights, queries): For each query, calculates the minimum cost to fix the specified segment. :param n: int - number of planks :param k: int - minimum number of contiguous planks to replace in each segment :param q: int - number of queries :param heights: List[int] - heights of the planks :param queries: List[Tuple[int, int]] - list of queries containing the range of the rotted segments :return: List[int] - list of minimum costs for each query >>> minimum_cost_to_fix_fence(8, 3, 2, [1, 3, 4, 5, 2, 6, 2, 8], [(2, 5), (4, 8)]) [2, 4] >>> minimum_cost_to_fix_fence(5, 2, 1, [1, 2, 3, 4, 5], [(1, 3)]) [1] >>> minimum_cost_to_fix_fence(6, 3, 2, [8, 7, 6, 5, 4, 3], [(1, 3), (2, 4)]) [2, 2] >>> minimum_cost_to_fix_fence(4, 2, 1, [5, 5, 5, 5], [(1, 4)]) [0] >>> minimum_cost_to_fix_fence(10, 4, 1, [1, 3, 5, 7, 9, 11, 13, 15, 17, 19], [(1, 10)]) [6]","solution":"def minimum_cost_to_fix_fence(n, k, q, heights, queries): For each query, calculates the minimum cost to fix the specified segment. :param n: int - number of planks :param k: int - minimum number of contiguous planks to replace in each segment :param q: int - number of queries :param heights: List[int] - heights of the planks :param queries: List[Tuple[int, int]] - list of queries containing the range of the rotted segments :return: List[int] - list of minimum costs for each query results = [] for l, r in queries: min_cost = float('inf') for i in range(l - 1, r - k + 1): segment = heights[i:i + k] min_cost = min(min_cost, max(segment) - min(segment)) results.append(min_cost) return results"},{"question":"def min_moves_to_sort_birthdays(n: int, birthdays: List[int]) -> int: Returns the minimum number of moves required to order the birthdays from 1 to n. >>> min_moves_to_sort_birthdays(4, [3, 1, 4, 2]) 2 >>> min_moves_to_sort_birthdays(5, [1, 2, 3, 4, 5]) 0 >>> min_moves_to_sort_birthdays(5, [5, 4, 3, 2, 1]) 4 >>> min_moves_to_sort_birthdays(1, [1]) 0 >>> min_moves_to_sort_birthdays(5, [3, 2, 1, 5, 4]) 3 >>> min_moves_to_sort_birthdays(10, [10, 1, 3, 2, 5, 4, 6, 9, 8, 7]) 7","solution":"def min_moves_to_sort_birthdays(n, birthdays): Returns the minimum number of moves required to order the birthdays from 1 to n. max_inc_seq = 0 current_length = 0 # Create an array where value is the position at index pos = [0] * (n + 1) for index in range(n): pos[birthdays[index]] = index for i in range(1, n): if pos[i] < pos[i + 1]: current_length += 1 else: max_inc_seq = max(max_inc_seq, current_length) current_length = 0 max_inc_seq = max(max_inc_seq, current_length) return n - (max_inc_seq + 1)"},{"question":"def min_keystrokes(sentence: str) -> int: Compute the minimum number of keystrokes needed to type a given sentence. Each character and space must be typed, with the delete command not reducing the keystrokes. Args: sentence (str): The sentence Victor wants to type. Returns: int: Minimum number of keystrokes needed. Examples: >>> min_keystrokes(\\"a a\\") 3 >>> min_keystrokes(\\"ab cd\\") 5 >>> min_keystrokes(\\"ab c d\\") 6 >>> min_keystrokes(\\"a\\") 1 >>> min_keystrokes(\\" \\") 1 >>> min_keystrokes(\\"the quick brown fox jumps over the lazy dog\\") 43 >>> min_keystrokes(\\"\\") 0 >>> min_keystrokes(\\"a\\" * 1000) 1000","solution":"def min_keystrokes(sentence): # Since each character and space must be typed and considering the delete command does not reduce keystrokes, # the minimum keystrokes would be the length of the sentence itself. return len(sentence)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: Input string consisting of lowercase Latin letters. :type s: str :return: Length of the longest substring without repeating characters. :rtype: int >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"aabbcc\\") 2 >>> length_of_longest_substring(\\"b\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"abba\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: Input string consisting of lowercase Latin letters. :type s: str :return: Length of the longest substring without repeating characters. :rtype: int n = len(s) if n == 0: return 0 char_index = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_palindrome_with_vowel(s: str) -> str: Find the longest palindromic substring that contains at least one vowel. If multiple such substrings exist, return the lexicographically smallest one. If no such substring exists, return \\"-1\\". Args: s (str): A string consisting of lowercase English letters. Returns: str: The longest palindromic substring with at least one vowel, or \\"-1\\" if none exists. Examples: >>> longest_palindrome_with_vowel(\\"civic\\") \\"civic\\" >>> longest_palindrome_with_vowel(\\"abracadabra\\") \\"aca\\" >>> longest_palindrome_with_vowel(\\"bcdf\\") \\"-1\\"","solution":"def longest_palindrome_with_vowel(s): Find the longest palindromic substring containing at least one vowel. If there are multiple longest palindromic substrings with at least one vowel, returns the lexicographically smallest one. If no such substring exists, returns \\"-1\\". def is_palindrome(sub): return sub == sub[::-1] vowels = set('aeiou') n = len(s) longest = \\"\\" for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring) and any(char in vowels for char in substring): if len(substring) > len(longest) or (len(substring) == len(longest) and substring < longest): longest = substring return longest if longest else \\"-1\\""},{"question":"def min_swaps_to_sort(N: int, K: int, sweetness: List[int]) -> int: Determine the minimum number of swaps required to sort the candies in strictly increasing order. >>> min_swaps_to_sort(5, 5, [5, 1, 3, 2, 4]) 3 >>> min_swaps_to_sort(4, 0, [4, 3, 2, 1]) -1","solution":"def min_swaps_to_sort(N, K, sweetness): # Create a list of tuples where each tuple is (sweetness value, original index) arr_pos = list(enumerate(sweetness)) # Sort the array by sweetness values arr_pos.sort(key=lambda it: it[1]) # Initialize variables visited = {k: False for k in range(N)} swaps = 0 # Traverse the array elements for i in range(N): # If the element is already visited or in the correct position, continue if visited[i] or arr_pos[i][0] == i: continue # Initialize cycle size cycle_size = 0 j = i while not visited[j]: # Mark the node as visited visited[j] = True # Move to the next node j = arr_pos[j][0] cycle_size += 1 # If we have a cycle, add (cycle_size - 1) to swaps if cycle_size > 0: swaps += (cycle_size - 1) # Check if the number of swaps exceeds the allowed K swaps if swaps <= K: return swaps else: return -1"},{"question":"def wendys_fibonacci(A, B, C, N): Returns the N-th term of Wendy's Fibonacci sequence. >>> wendys_fibonacci(1, 2, 3, 5) 11 >>> wendys_fibonacci(4, 5, 6, 1) 4 >>> wendys_fibonacci(4, 5, 6, 2) 5 >>> wendys_fibonacci(4, 5, 6, 3) 6 >>> wendys_fibonacci(4, 5, 6, 4) 15 >>> result = wendys_fibonacci(10**9, 10**9, 10**9, 50) assert result >= 0","solution":"def wendys_fibonacci(A, B, C, N): Returns the N-th term of Wendy's Fibonacci sequence. if N == 1: return A elif N == 2: return B elif N == 3: return C # Initialize the first three terms seq = [A, B, C] # Calculate sequence from 4th term to N-th term for i in range(3, N): next_term = seq[i-1] + seq[i-2] + seq[i-3] seq.append(next_term) return seq[N-1]"},{"question":"def max_tasks_within_deadline(n: int, T: int, durations: List[int]) -> int: Returns the maximum number of tasks that can be completed within the given total deadline. Args: n (int): The number of tasks. T (int): The total time available. durations (List[int]): List of integers representing the durations of the tasks. Returns: int: The maximum number of tasks that can be completed. Examples: >>> max_tasks_within_deadline(5, 15, [1, 2, 3, 4, 5]) 5 >>> max_tasks_within_deadline(5, 10, [10, 3, 7, 2, 5]) 3 >>> max_tasks_within_deadline(3, 5, [6, 3, 4]) 1","solution":"def max_tasks_within_deadline(n, T, durations): Returns the maximum number of tasks that can be completed within the given total deadline. durations.sort() total_time = 0 count = 0 for duration in durations: if total_time + duration <= T: total_time += duration count += 1 else: break return count"},{"question":"def max_sum_subarray(arr: List[int], n: int, k: int) -> int: Find the maximum sum of any subarray of size k. Parameters: arr (list): List of integers representing the array n (int): Length of the array k (int): Size of the subarray Returns: int: Maximum sum of any subarray of size k >>> max_sum_subarray([1, 2, 3, -2, 5, -1, 6, 3, -4, 2], 10, 3) 10 >>> max_sum_subarray([1, 2, 3, 4, 5], 5, 2) 9 >>> max_sum_subarray([-1, -2, -3, -4, -5], 5, 2) -3 >>> max_sum_subarray([2, 1, -3, 4, 5, -6, 9], 7, 3) 8 >>> max_sum_subarray([10], 1, 1) 10 >>> max_sum_subarray([1, 2, 3, 4], 4, 4) 10","solution":"def max_sum_subarray(arr, n, k): This function returns the maximum sum of any subarray of size k. Parameters: arr (list): List of integers representing the array n (int): Length of the array k (int): Size of the subarray Returns: int: Maximum sum of any subarray of size k if n < k: return 0 # Compute the sum of the first window window_sum = sum(arr[:k]) max_sum = window_sum # Slide the window from start to end in the array for i in range(n - k): # Slide the window by removing the element that is going out of the window and adding the element that is coming into the window window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def is_2_edge_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the kingdom's road network is robust (2-edge-connected). Args: n (int): Number of cities. m (int): Number of roads. edges (List[Tuple[int, int]]): List of roads represented as tuples of connected cities. Returns: str: \\"YES\\" if the network is 2-edge-connected, otherwise \\"NO\\". Example: >>> is_2_edge_connected(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 'YES' >>> is_2_edge_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) 'NO' from typing import List, Tuple def test_is_2_edge_connected_case1(): n, m = 5, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert is_2_edge_connected(n, m, edges) == \\"YES\\" def test_is_2_edge_connected_case2(): n, m = 4, 3 edges = [(1, 2), (2, 3), (3, 4)] assert is_2_edge_connected(n, m, edges) == \\"NO\\" def test_is_2_edge_connected_case3(): n, m = 3, 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_2_edge_connected(n, m, edges) == \\"YES\\" def test_is_2_edge_connected_case4(): n, m = 4, 5 edges = [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)] assert is_2_edge_connected(n, m, edges) == \\"YES\\" def test_is_2_edge_connected_case5(): n, m = 6, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert is_2_edge_connected(n, m, edges) == \\"NO\\" def test_is_2_edge_connected_case6(): n, m = 2, 1 edges = [(1, 2)] assert is_2_edge_connected(n, m, edges) == \\"NO\\"","solution":"def is_2_edge_connected(n, m, edges): from collections import defaultdict import sys sys.setrecursionlimit(200000) if m < n: return \\"NO\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) disc = [-1] * (n + 1) low = [-1] * (n + 1) parent = [-1] * (n + 1) time = 0 def dfs(u): nonlocal time disc[u] = low[u] = time time += 1 children = 0 for v in graph[u]: if disc[v] == -1: children += 1 parent[v] = u if not dfs(v): return False low[u] = min(low[u], low[v]) if parent[u] == -1 and children > 1: return False if parent[u] != -1 and low[v] > disc[u]: return False elif v != parent[u]: low[u] = min(low[u], disc[v]) return True if not dfs(1): return \\"NO\\" for i in range(1, n + 1): if disc[i] == -1: return \\"NO\\" return \\"YES\\""},{"question":"def calculate_balance(transactions: List[Tuple[int, str, int]], T: int) -> int: Calculate the balance of the account after processing all transactions up to a given time. Args: transactions: A list of tuples where each tuple represents a transaction and contains: - t_i (int): the time when the transaction occurs, - type_i (str): the type of transaction, either 'credit' or 'debit', - amount_i (int): the amount of money associated with the transaction. T: An integer representing the time up to which transactions are considered. Returns: int: The balance of the account after processing the transactions up to time T. >>> transactions = [(5, 'credit', 100), (10, 'debit', 50), (15, 'credit', 200), (20, 'debit', 100), (30, 'credit', 300)] >>> calculate_balance(transactions, 25) 150 >>> calculate_balance(transactions, 10) 50 >>> calculate_balance(transactions, 5) 100 >>> calculate_balance(transactions, 1) 0 >>> transactions = [(1, 'credit', 100), (2, 'credit', 200), (3, 'credit', 300)] >>> calculate_balance(transactions, 3) 600 >>> transactions = [(1, 'debit', 100), (2, 'debit', 200), (3, 'debit', 300)] >>> calculate_balance(transactions, 3) -600 >>> transactions = [(2, 'credit', 100), (3, 'debit', 50), (5, 'credit', 200), (6, 'debit', 100)] >>> calculate_balance(transactions, 10) 150","solution":"def calculate_balance(transactions, T): balance = 0 for t, transaction_type, amount in transactions: if t > T: break if transaction_type == 'credit': balance += amount elif transaction_type == 'debit': balance -= amount return balance"},{"question":"def has_hamiltonian_path(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if there exists a Hamiltonian path in a simple directed graph. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): The list of directed edges in the graph. Returns: str: \\"YES\\" if there exists a Hamiltonian path, otherwise \\"NO\\". Examples: >>> has_hamiltonian_path(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> has_hamiltonian_path(4, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" from typing import List, Tuple def test_has_hamiltonian_path_example_1(): n, m = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert has_hamiltonian_path(n, m, edges) == \\"YES\\" def test_has_hamiltonian_path_example_2(): n, m = 4, 3 edges = [(1, 2), (2, 3), (3, 1)] assert has_hamiltonian_path(n, m, edges) == \\"NO\\" def test_has_hamiltonian_path_no_edges(): n, m = 4, 0 edges = [] assert has_hamiltonian_path(n, m, edges) == \\"NO\\" def test_has_hamiltonian_path_single_node(): n, m = 1, 0 edges = [] assert has_hamiltonian_path(n, m, edges) == \\"YES\\" def test_has_hamiltonian_path_multiple_paths(): n, m = 4, 6 edges = [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)] assert has_hamiltonian_path(n, m, edges) == \\"YES\\"","solution":"def has_hamiltonian_path(n, m, edges): from itertools import permutations # Create adjacency matrix for the graph graph = [[0] * n for _ in range(n)] for u, v in edges: graph[u-1][v-1] = 1 # Convert to 0-indexed # Check all permutations of nodes nodes = list(range(n)) for perm in permutations(nodes): path_exists = True for i in range(n - 1): if graph[perm[i]][perm[i + 1]] == 0: path_exists = False break if path_exists: return \\"YES\\" return \\"NO\\" # Example Usage n, m = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(has_hamiltonian_path(n, m, edges)) # Should print YES n, m = 4, 3 edges = [(1, 2), (2, 3), (3, 1)] print(has_hamiltonian_path(n, m, edges)) # Should print NO"},{"question":"def min_battery_usage(grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: Calculate the minimal battery usage to reach the bottom-right corner of the grid and return the path. >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_usage, path = min_battery_usage(grid) >>> min_usage 7 >>> path [(0,0), (0,1), (0,2), (1,2), (2,2)] >>> grid = [ ... [0] ... ] >>> min_usage, path = min_battery_usage(grid) >>> min_usage 0 >>> path [(0, 0)] >>> grid = [ ... [1, 2, 3, 4] ... ] >>> min_usage, path = min_battery_usage(grid) >>> min_usage 10 >>> path [(0,0), (0,1), (0,2), (0,3)] >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> min_usage, path = min_battery_usage(grid) >>> min_usage 10 >>> path [(0,0), (1,0), (2,0), (3,0)] >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_usage, path = min_battery_usage(grid) >>> min_usage 21 >>> path [(0,0), (0,1), (0,2), (1,2), (2,2)]","solution":"def min_battery_usage(grid): n = len(grid) m = len(grid[0]) dp = [[0] * m for _ in range(n)] path = [[None] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] path[i][0] = (i - 1, 0) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] path[0][j] = (0, j - 1) for i in range(1, n): for j in range(1, m): if dp[i - 1][j] < dp[i][j - 1]: dp[i][j] = dp[i - 1][j] + grid[i][j] path[i][j] = (i - 1, j) else: dp[i][j] = dp[i][j - 1] + grid[i][j] path[i][j] = (i, j - 1) min_battery = dp[n - 1][m - 1] current = (n - 1, m - 1) result_path = [] while current: result_path.append(current) current = path[current[0]][current[1]] result_path = result_path[::-1] return min_battery, result_path # Example usage: grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] min_usage, path = min_battery_usage(grid) print(min_usage) # Expected output: 7 print(\\" \\".join(map(str, path))) # Expected output: (0, 0) (0, 1) (0, 2) (1, 2) (2, 2)"},{"question":"import pytest def next_palindrome(x: int) -> int: Function to find the smallest palindrome number greater than x. Args: x (int): The input integer (1 ≤ x ≤ 10^9). Returns: int: The smallest palindrome number greater than x. >>> next_palindrome(123) 131 >>> next_palindrome(678) 686 >>> next_palindrome(999) 1001 @pytest.mark.parametrize(\\"input, expected\\", [ (123, 131), (678, 686), (999, 1001), (8, 9), (11, 22), (123456789, 123464321), (121, 131), (130, 131) ]) def test_next_palindrome(input, expected): assert next_palindrome(input) == expected","solution":"def next_palindrome(x): Function to find the smallest palindrome number greater than x. def is_palindrome(num): str_num = str(num) return str_num == str_num[::-1] current = x + 1 while not is_palindrome(current): current += 1 return current"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in the given string. If there are multiple substrings of maximum length, return the one that appears first. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"banana\\") \\"anana\\"","solution":"def longest_palindromic_substring(s): This function returns the longest palindromic substring. :param s: The input string containing only lowercase English letters. :return: The longest palindromic substring. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s: return \\"\\" longest = \\"\\" for i in range(len(s)): # Check for odd length palindromes pal1 = expand_around_center(s, i, i) if len(pal1) > len(longest): longest = pal1 # Check for even length palindromes pal2 = expand_around_center(s, i, i + 1) if len(pal2) > len(longest): longest = pal2 return longest"},{"question":"def count_symmetric_banners(M: int) -> int: Determine the maximum number of unique symmetric or rotationally symmetric binary banners of length M. Args: M (int): Length of each binary banner. Returns: int: Maximum number of unique banners that are symmetric or rotationally symmetric. >>> count_symmetric_banners(5) 8 >>> count_symmetric_banners(3) 4 >>> count_symmetric_banners(4) 4 >>> count_symmetric_banners(6) 8","solution":"def count_symmetric_banners(M): This function takes an integer M and returns the maximum number of unique binary banners of length M that are symmetric or rotationally symmetric. if M % 2 == 0: # For even M, we can create 2^(M/2) symmetric banners return 2 ** (M // 2) else: # For odd M, we can create 2^((M//2)+1) symmetric banners return 2 ** ((M // 2) + 1) # Example usage: M = 5 print(count_symmetric_banners(M)) # Output should be 8"},{"question":"def calculate_total_score(n: int, scores: List[int]) -> int: Calculate the total score including bonuses. :param n: Integer, number of challenges :param scores: List of integers, scores in each challenge :return: Integer, total score including bonuses >>> calculate_total_score(5, [10, 20, 15, 25, 30]) 125 >>> calculate_total_score(4, [5, 4, 6, 7]) 25","solution":"def calculate_total_score(n, scores): Calculate the total score including bonuses. :param n: Integer, number of challenges :param scores: List of integers, scores in each challenge :return: Integer, total score including bonuses total_score = scores[0] # Initialize the total score with the score of the first challenge for i in range(1, n): total_score += scores[i] if scores[i] > scores[i - 1]: total_score += (scores[i] - scores[i - 1]) return total_score"},{"question":"def rock_paper_scissors(player1: str, player2: str) -> str: Determines the winner of a rock-paper-scissors game. Parameters: player1 (str): choice of player 1 (\\"Rock\\", \\"Paper\\" or \\"Scissors\\") player2 (str): choice of player 2 (\\"Rock\\", \\"Paper\\" or \\"Scissors\\") Returns: str: \\"Player 1 wins\\", \\"Player 2 wins\\" or \\"Draw\\" >>> rock_paper_scissors(\\"Rock\\", \\"Scissors\\") \\"Player 1 wins\\" >>> rock_paper_scissors(\\"Paper\\", \\"Paper\\") \\"Draw\\" >>> rock_paper_scissors(\\"Scissors\\", \\"Rock\\") \\"Player 2 wins\\" def test_rock_paper_scissors(): # Test cases for all possible game outcomes assert rock_paper_scissors(\\"Rock\\", \\"Scissors\\") == \\"Player 1 wins\\" assert rock_paper_scissors(\\"Scissors\\", \\"Paper\\") == \\"Player 1 wins\\" assert rock_paper_scissors(\\"Paper\\", \\"Rock\\") == \\"Player 1 wins\\" assert rock_paper_scissors(\\"Scissors\\", \\"Rock\\") == \\"Player 2 wins\\" assert rock_paper_scissors(\\"Paper\\", \\"Scissors\\") == \\"Player 2 wins\\" assert rock_paper_scissors(\\"Rock\\", \\"Paper\\") == \\"Player 2 wins\\" assert rock_paper_scissors(\\"Rock\\", \\"Rock\\") == \\"Draw\\" assert rock_paper_scissors(\\"Paper\\", \\"Paper\\") == \\"Draw\\" assert rock_paper_scissors(\\"Scissors\\", \\"Scissors\\") == \\"Draw\\"","solution":"def rock_paper_scissors(player1, player2): Determines the winner of a rock-paper-scissors game. Parameters: player1 (str): choice of player 1 (\\"Rock\\", \\"Paper\\" or \\"Scissors\\") player2 (str): choice of player 2 (\\"Rock\\", \\"Paper\\" or \\"Scissors\\") Returns: str: \\"Player 1 wins\\", \\"Player 2 wins\\" or \\"Draw\\" # Define winning conditions winning_conditions = { ('Rock', 'Scissors'): 'Player 1 wins', ('Scissors', 'Paper'): 'Player 1 wins', ('Paper', 'Rock'): 'Player 1 wins', ('Scissors', 'Rock'): 'Player 2 wins', ('Paper', 'Scissors'): 'Player 2 wins', ('Rock', 'Paper'): 'Player 2 wins' } # Check for draw if player1 == player2: return \\"Draw\\" # Return result based on winning conditions return winning_conditions.get((player1, player2))"},{"question":"def length_of_longest_substring_k_distinct(k: int, s: str) -> int: Returns the length of the longest substring with at most k distinct characters. >>> length_of_longest_substring_k_distinct(2, \\"abcba\\") 3 >>> length_of_longest_substring_k_distinct(1, \\"aaaaa\\") 5 >>> length_of_longest_substring_k_distinct(0, \\"abc\\") 0","solution":"def length_of_longest_substring_k_distinct(k, s): Returns the length of the longest substring with at most k distinct characters. n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"from collections import deque def shortest_path(n, adjacency_matrix, s, t): Determine the shortest path for a message to travel from the sender to the recipient in a relay-based messaging model. >>> shortest_path(5, [ [0, 1, 0, 0, 0], [1, 0, 1, 1, 1], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 1, 0, 0, 0] ], 1, 4) == 2 >>> shortest_path(3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ], 1, 2) == -1 >>> shortest_path(3, [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ], 2, 2) == 0 >>> shortest_path(4, [ [0, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 1], [1, 1, 1, 0] ], 1, 3) == 2 >>> shortest_path(3, [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ], 1, 2) == 1","solution":"from collections import deque def shortest_path(n, adjacency_matrix, s, t): def bfs(start, end): visited = [False] * n distance = [-1] * n queue = deque([start]) visited[start] = True distance[start] = 0 while queue: current = queue.popleft() if current == end: return distance[current] for neighbor in range(n): if adjacency_matrix[current][neighbor] == 1 and not visited[neighbor]: queue.append(neighbor) visited[neighbor] = True distance[neighbor] = distance[current] + 1 return -1 # Convert 1-based indexes to 0-based for internal processing return bfs(s-1, t-1)"},{"question":"def classify_sequences(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given a sequence of integers, classify it as a mountain, valley, or neither. For each test case, print \\"Mountain\\" if the sequence is a mountain, \\"Valley\\" if it is a valley, and \\"Neither\\" otherwise. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case is a tuple containing the length of the sequence and the sequence itself. Returns: List[str]: List of responses for each test case. >>> classify_sequences(3, [(5, [1, 3, 5, 4, 2]), (4, [6, 4, 2, 5]), (3, [3, 2, 1])]) [\\"Mountain\\", \\"Valley\\", \\"Neither\\"] >>> classify_sequences(2, [(3, [1, 2, 3]), (3, [3, 2, 1])]) [\\"Neither\\", \\"Neither\\"] pass","solution":"def classify_sequences(t, test_cases): results = [] for case in test_cases: n, sequence = case is_mountain = False is_valley = False if n < 3: results.append(\\"Neither\\") continue increasing = False decreasing = False i = 1 # Check for mountain while i < n and sequence[i] > sequence[i - 1]: increasing = True i += 1 while i < n and sequence[i] < sequence[i - 1]: decreasing = True i += 1 if increasing and decreasing and i == n: is_mountain = True i = 1 increasing = False decreasing = False # Check for valley while i < n and sequence[i] < sequence[i - 1]: decreasing = True i += 1 while i < n and sequence[i] > sequence[i - 1]: increasing = True i += 1 if increasing and decreasing and i == n: is_valley = True if is_mountain: results.append(\\"Mountain\\") elif is_valley: results.append(\\"Valley\\") else: results.append(\\"Neither\\") return results"},{"question":"def min_adjacent_swaps_to_sort(n: int, cards: List[int]) -> int: Returns the minimum number of adjacent swaps required to sort the cards. >>> min_adjacent_swaps_to_sort(1, [10]) 0 >>> min_adjacent_swaps_to_sort(5, [1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort(5, [5, 3, 2, 4, 1]) 8 >>> min_adjacent_swaps_to_sort(2, [2, 1]) 1 >>> min_adjacent_swaps_to_sort(6, [2, 1, 4, 3, 6, 5]) 3","solution":"def min_adjacent_swaps_to_sort(n, cards): Returns the minimum number of adjacent swaps required to sort the cards. swaps = 0 for i in range(n): for j in range(0, n-i-1): if cards[j] > cards[j+1]: cards[j], cards[j+1] = cards[j+1], cards[j] swaps += 1 return swaps"},{"question":"def max_increasing_subsequence_length(columns): Returns the length of the longest strictly increasing subsequence from the given columns heights. >>> max_increasing_subsequence_length([3, 10, 2, 1, 20, 4]) 3 >>> max_increasing_subsequence_length([5]) 1 >>> max_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> max_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> max_increasing_subsequence_length([10, 1, 2, 10, 3, 4, 11, 5, 6]) 6 >>> max_increasing_subsequence_length([1, 1, 1, 1, 1]) 1 >>> max_increasing_subsequence_length([1, 3, 1, 3, 1, 3]) 2","solution":"def max_increasing_subsequence_length(columns): Returns the length of the longest strictly increasing subsequence from the given columns heights. import bisect # This will hold the end of the longest increasing subsequence at each length dp = [] for height in columns: pos = bisect.bisect_left(dp, height) if pos == len(dp): dp.append(height) else: dp[pos] = height return len(dp) # Example input columns = [3, 10, 2, 1, 20, 4] print(max_increasing_subsequence_length(columns)) # Output should be 3"},{"question":"def max_acorns(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of acorns the squirrels can collect if they work together in the most optimal way. >>> max_acorns(2, [(5, [10, 20, 15, 25, 30]), (3, [5, 10, 15])]) [100, 30] >>> max_acorns(1, [(1, [10])]) [10]","solution":"def max_acorns(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] acorns = test_cases[i][1] results.append(sum(acorns)) return results"},{"question":"def nice_subsequences_count(n: int, m: int, a: List[int]) -> int: Determine the number of \\"nice\\" subsequences of a sequence. A \\"nice\\" subsequence is defined as a subsequence in which all the elements are distinct, and the maximum element does not exceed m. Parameters: n (int): Length of the sequence. m (int): Maximum value for a \\"nice\\" subsequence. a (List[int]): The sequence of integers. Returns: int: Number of \\"nice\\" subsequences. Examples: >>> nice_subsequences_count(4, 5, [1, 2, 3, 4]) 15 >>> nice_subsequences_count(3, 2, [3, 4, 5]) 0","solution":"def nice_subsequences_count(n, m, a): from itertools import combinations # Filter elements that are less than or equal to m filtered_a = [x for x in a if x <= m] # Function to count subsequences using combinatory logic def count_subsequences(lst): n = len(lst) subseq_count = 0 # Iterate over all possible lengths of subsequences for length in range(1, n + 1): for comb in combinations(lst, length): if len(set(comb)) == length: # All elements are distinct subseq_count += 1 return subseq_count return count_subsequences(filtered_a)"},{"question":"def countSunsetViewBuildings(buildings: List[int]) -> int: Returns the number of buildings with a clear view of the sunset. A building has a clear view of the sunset if and only if it is taller than all the buildings to its right. >>> countSunsetViewBuildings([3, 7, 8, 3, 6, 1]) 3 >>> countSunsetViewBuildings([5, 4, 3, 2, 1]) 5 >>> countSunsetViewBuildings([1, 2, 3, 4, 5]) 1 >>> countSunsetViewBuildings([4, 3, 2, 7, 8, 3, 6, 5]) 3","solution":"def countSunsetViewBuildings(buildings): Returns the number of buildings with a clear view of the sunset. A building has a clear view of the sunset if and only if it is taller than all the buildings to its right. count = 0 max_height = float('-inf') # Traverse the list from right to left for height in reversed(buildings): if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List, Tuple def longest_even_sum_subarray_length(arr: List[int]) -> int: Determine the length of the longest contiguous subarray where the sum is even. >>> longest_even_sum_subarray_length([1, 2, 3, 4, 5]) 4 >>> longest_even_sum_subarray_length([1, 1, 1]) 2 >>> longest_even_sum_subarray_length([2, 4, 6, 10]) 4 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the longest contiguous subarray length where the sum is even. >>> process_test_cases([(5, [1, 2, 3, 4, 5])]) [4] >>> process_test_cases([(1, [1])]) [0]","solution":"def longest_even_sum_subarray_length(arr): n = len(arr) max_length = 0 for i in range(n): curr_sum = 0 for j in range(i, n): curr_sum += arr[j] if curr_sum % 2 == 0: max_length = max(max_length, j - i + 1) return max_length def process_test_cases(test_cases): results = [] for case in test_cases: n, arr = case results.append(longest_even_sum_subarray_length(arr)) return results"},{"question":"def min_max_partition_sum(n, arr): Partition the array into two non-empty parts such that the maximum sum of the elements of any part is minimized. Args: n (int): the number of elements in the array arr (List[int]): the elements of the array Returns: int: the minimum possible value of max(sum_1, sum_2) Examples: >>> min_max_partition_sum(6, [1, 3, 2, 6, 1, 2]) 9 >>> min_max_partition_sum(2, [1, 1]) 1 >>> min_max_partition_sum(2, [10, 1]) 10 >>> min_max_partition_sum(4, [2, 2, 2, 2]) 4 >>> min_max_partition_sum(5, [1, 2, 3, 4, 5]) 9 >>> min_max_partition_sum(5, [5, 4, 3, 2, 1]) 9","solution":"def min_max_partition_sum(n, arr): total_sum = sum(arr) current_sum = 0 min_max_sum = total_sum for i in range(n - 1): current_sum += arr[i] part1_sum = current_sum part2_sum = total_sum - current_sum min_max_sum = min(min_max_sum, max(part1_sum, part2_sum)) return min_max_sum # Example usage: # n = 6 # arr = [1, 3, 2, 6, 1, 2] # print(min_max_partition_sum(n, arr)) # Output: 9"},{"question":"def determine_winner(n: int, s: str) -> str: Determines the winner of the game with the given rules. :param n: int, the length of the string s :param s: str, the string s consisting of exactly n lowercase Latin letters :return: str, \\"Alice\\" or \\"Bob\\" depending on who will win the game. pass # Unit Tests def test_example1(): assert determine_winner(7, \\"ababaac\\") == \\"Alice\\" def test_example2(): assert determine_winner(6, \\"abcabc\\") == \\"Bob\\" def test_no_repeats(): assert determine_winner(5, \\"abcde\\") == \\"Bob\\" # No substring appears twice def test_all_identical(): assert determine_winner(4, \\"aaaa\\") == \\"Alice\\" # Many possible moves, but odd in number def test_alternate_repeats(): assert determine_winner(8, \\"abababab\\") == \\"Alice\\" # Multiple possible options def test_end_repeats(): assert determine_winner(6, \\"aaabbb\\") == \\"Bob\\" # Single possible removal","solution":"def determine_winner(n, s): Determines the winner of the game with the given rules. :param n: int, the length of the string s :param s: str, the string s consisting of exactly n lowercase Latin letters :return: str, \\"Alice\\" or \\"Bob\\" depending on who will win the game. from collections import defaultdict # Initialize a dictionary to count all substrings of \`s\` substring_count = defaultdict(int) # Create all substrings and count occurrences for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] substring_count[substring] += 1 # Count the number of substrings that appear at least twice num_of_valid_moves = sum(1 for count in substring_count.values() if count > 1) # If the number of valid moves is odd, Alice wins, otherwise Bob wins if num_of_valid_moves % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def max_dockings(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Computes the maximum number of spaceships that can be docked for each test case. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[Tuple[int, int]]]] : List of test cases with N spaceships and their docking time intervals (start time, end time) Returns: List[int] : List containing the maximum number of spaceships that can be docked for each test case Example: >>> max_dockings(2, [(3, [(1, 3), (2, 5), (4, 6)]), (4, [(0, 1), (3, 5), (2, 6), (1, 4)])]) [2, 2]","solution":"def max_dockings(T, test_cases): def max_ships_dockings(n, intervals): if not intervals: return 0 intervals.sort(key=lambda x: x[1]) end = intervals[0][1] count = 1 for i in range(1, len(intervals)): if intervals[i][0] >= end: count += 1 end = intervals[i][1] return count results = [] for i in range(T): n, intervals = test_cases[i] results.append(max_ships_dockings(n, intervals)) return results"},{"question":"from typing import List def min_steps_to_reach_destination(N: int, grid: List[List[str]]) -> int: Find the minimum number of steps Lara needs to reach the bottom-right corner of the grid. Returns -1 if it is not possible to reach the destination. Parameters: N: The size of the grid (NxN). grid: The grid in the form of a list of N strings, where '.' indicates an empty cell, and '#' indicates an obstacle. Returns: The minimum number of steps required to reach the bottom-right corner or -1 if it is not possible. >>> min_steps_to_reach_destination(3, [list(\\"...\\"), list(\\".#.\\"), list(\\"...\\")]) 4 >>> min_steps_to_reach_destination(3, [list(\\".#.\\"), list(\\".#.\\"), list(\\"..#\\")]) -1","solution":"from collections import deque def min_steps_to_reach_destination(N, grid): Finds the minimum number of steps to reach from the top-left to the bottom-right corner of the grid. Returns -1 if there is no possible path. def is_valid(x, y): Checks if a position (x, y) is within bounds and not an obstacle. return 0 <= x < N and 0 <= y < N and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (N-1, N-1): # Reached destination return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # Mark current cell as an obstacle grid[x][y] = '#' return -1"},{"question":"from typing import List def recommend_books(purchase_history: List[int], purchase_records: List[List[int]], k: int) -> List[int]: Recommends top k books that are frequently bought together with the books the user has already bought. Args: purchase_history (List[int]): List of book IDs that the user has bought. purchase_records (List[List[int]]): List of lists, where each inner list contains book IDs bought together in one transaction. k (int): Number of recommendations to return. Returns: List[int]: List of top k recommended book IDs. pass def test_recommend_books_example(): purchase_history = [1, 2, 3] purchase_records = [ [1, 2, 4], [2, 3, 5], [1, 5], [4, 2, 6], [1, 3, 5] ] k = 3 assert recommend_books(purchase_history, purchase_records, k) == [5, 4, 6] def test_recommend_books_empty_purchase_history(): purchase_history = [] purchase_records = [ [1, 2, 3], [2, 3, 4] ] k = 2 assert recommend_books(purchase_history, purchase_records, k) == [] def test_recommend_books_no_records(): purchase_history = [1, 2] purchase_records = [] k = 2 assert recommend_books(purchase_history, purchase_records, k) == [] def test_recommend_books_k_larger_than_recommendations(): purchase_history = [1] purchase_records = [ [1, 2], [1, 2, 3], [2, 3] ] k = 5 assert set(recommend_books(purchase_history, purchase_records, k)) == {2, 3} def test_recommend_books_edge_cases(): purchase_history = [10] purchase_records = [ [10, 20], [10], [20] ] k = 1 assert recommend_books(purchase_history, purchase_records, k) == [20]","solution":"from collections import defaultdict from typing import List, Tuple def recommend_books(purchase_history: List[int], purchase_records: List[List[int]], k: int) -> List[int]: Recommends top k books that are frequently bought together with the books the user has already bought. Args: purchase_history (List[int]): List of book IDs that the user has bought. purchase_records (List[List[int]]): List of lists, where each inner list contains book IDs bought together in one transaction. k (int): Number of recommendations to return. Returns: List[int]: List of top k recommended book IDs. book_count = defaultdict(int) # Dictionary to count occurrences of books bought with books in purchase_history purchase_set = set(purchase_history) # Set for quick lookup of purchased books for record in purchase_records: record_set = set(record) common_books = purchase_set & record_set if common_books: # If there is at least one common purchased book for book in record: if book not in purchase_set: book_count[book] += 1 # Get the top k books by frequency recommended_books = sorted(book_count.items(), key=lambda x: (-x[1], x[0])) return [book for book, count in recommended_books[:k]]"},{"question":"def check_review(review: str) -> str: Returns \\"FAKE\\" if the review contains repeating words, otherwise \\"REAL\\". >>> check_review(\\"This is a genuine review\\") == \\"REAL\\" >>> check_review(\\"Best product ever best\\") == \\"FAKE\\" >>> check_review(\\"Absolutely amazing amazing\\") == \\"FAKE\\" >>> check_review(\\"Good good product\\") == \\"FAKE\\" def process_reviews(n: int, reviews: List[str]) -> List[str]: Processes a list of reviews and returns a list of results for each one. >>> process_reviews(3, [\\"This is a good product\\", \\"I really like this item\\", \\"Excellent quality and reliable\\"]) == [\\"REAL\\", \\"REAL\\", \\"REAL\\"] >>> process_reviews(3, [\\"Amazing amazing value\\", \\"Top quality top quality\\", \\"Unbeatable unbeatable taste\\"]) == [\\"FAKE\\", \\"FAKE\\", \\"FAKE\\"] >>> process_reviews(3, [\\"Great great service\\", \\"Good product overall\\", \\"Would definitely recommend\\"]) == [\\"FAKE\\", \\"REAL\\", \\"REAL\\"]","solution":"def check_review(review): Returns \\"FAKE\\" if the review contains repeating words, otherwise \\"REAL\\". words = review.lower().split() seen_words = set() for word in words: if word in seen_words: return \\"FAKE\\" seen_words.add(word) return \\"REAL\\" def process_reviews(n, reviews): Processes a list of reviews and returns a list of results for each one. results = [] for review in reviews: results.append(check_review(review)) return results"},{"question":"def max_profitable_subchains(n: int, customers: List[int]) -> int: Determine the maximum possible number of profitable subchains that Alden can form. The first line contains a single positive integer n (1 ≤ n ≤ 10^5) — the number of restaurants. The second line contains a sequence of integers c1, c2, ..., cn (1 ≤ ci ≤ 10^6) — the number of loyal customers of each restaurant. Print the maximum number of profitable subchains Alden can form. >>> max_profitable_subchains(5, [1, 2, 3, 4, 5]) 3 >>> max_profitable_subchains(4, [3, 3, 3, 3]) 4 >>> max_profitable_subchains(3, [2, 6, 10]) 0 >>> max_profitable_subchains(5, [5, 5, 5, 5, 5]) 5 >>> max_profitable_subchains(6, [6, 6, 6, 6, 6, 6]) 0 >>> max_profitable_subchains(7, [2, 1, 4, 5, 6, 3, 8]) 3 >>> max_profitable_subchains(1, [2]) 0 >>> max_profitable_subchains(1, [1]) 1","solution":"def max_profitable_subchains(n, customers): count = 0 for customer in customers: if customer % 2 == 1: count += 1 return count"},{"question":"def max_sum_of_houses(n: int, k: int, values: List[int]) -> int: Determine the maximum sum of values you can collect by visiting up to k houses in a single direction. >>> max_sum_of_houses(7, 3, [1, 2, 3, 4, 5, 6, 7]) 18 >>> max_sum_of_houses(7, 1, [1, 2, 3, 4, 5, 6, 7]) 7 >>> max_sum_of_houses(7, 0, [1, 2, 3, 4, 5, 6, 7]) 0 >>> max_sum_of_houses(7, 7, [1, 2, 3, 4, 5, 6, 7]) 28 >>> max_sum_of_houses(3, 2, [-1, -2, -3]) -1 >>> max_sum_of_houses(5, 2, [5, 5, 1, 1, 1]) 10 >>> max_sum_of_houses(5, 3, [5, 1, 1, 1, 1]) 7 >>> max_sum_of_houses(1, 0, [100]) 0 >>> max_sum_of_houses(1, 1, [100]) 100","solution":"def max_sum_of_houses(n, k, values): if k == 0: return 0 max_sum = float('-inf') # Try every sub-array of length up to \`k\` from the start for i in range(min(k, n)): current_sum = 0 for j in range(i + 1): current_sum += values[j] max_sum = max(max_sum, current_sum) # Try every sub-array of length up to \`k\` from the end for i in range(min(k, n)): current_sum = 0 for j in range(i + 1): current_sum += values[n - 1 - j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_inactivity_period(timestamps: List[int]) -> int: Returns the longest period of inactivity in seconds given a list of sorted timestamps. :param timestamps: List[int] :return: int >>> longest_inactivity_period([10, 20, 50, 60, 110]) 50 >>> longest_inactivity_period([0, 10, 20, 30, 40]) 10 pass # Add your implementation here from solution import longest_inactivity_period def test_single_inactivity_period(): timestamps = [10, 20, 50, 60, 110] assert longest_inactivity_period(timestamps) == 50 def test_multiple_same_length_inactivity_periods(): timestamps = [0, 10, 20, 30, 40] assert longest_inactivity_period(timestamps) == 10 def test_no_inactivity_period(): timestamps = [0, 1, 2, 3, 4] assert longest_inactivity_period(timestamps) == 1 def test_large_inactivity_period_at_end(): timestamps = [0, 5, 10, 15, 100] assert longest_inactivity_period(timestamps) == 85 def test_large_inactivity_period_at_start(): timestamps = [0, 90, 100, 110, 120] assert longest_inactivity_period(timestamps) == 90 def test_two_elements(): timestamps = [10, 100] assert longest_inactivity_period(timestamps) == 90","solution":"def longest_inactivity_period(timestamps): Returns the longest period of inactivity in seconds given a list of sorted timestamps. :param timestamps: List[int] :return: int longest_period = 0 for i in range(1, len(timestamps)): inactivity_period = timestamps[i] - timestamps[i - 1] if inactivity_period > longest_period: longest_period = inactivity_period return longest_period"},{"question":"def minimize_adjacent_difference(arr: List[int]) -> List[int]: Reorder the list of integers such that the difference between any two adjacent integers is minimized. >>> minimize_adjacent_difference([5, 2, 9, 1, 6]) [1, 2, 5, 6, 9] >>> minimize_adjacent_difference([9, 8, 7, 6, 5]) [5, 6, 7, 8, 9] >>> minimize_adjacent_difference([-5, -2, -9, -1, -6]) [-9, -6, -5, -2, -1] >>> minimize_adjacent_difference([-1, 2, -3, 4, 0]) [-3, -1, 0, 2, 4] >>> minimize_adjacent_difference([5]) [5] >>> minimize_adjacent_difference([3, 3, 3, 3, 3]) [3, 3, 3, 3, 3] >>> minimize_adjacent_difference([1, 2, 3, 4, 5, 6, 7, 8, 9]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> minimize_adjacent_difference([1000000000, -1000000000, 500000000, -500000000]) [-1000000000, -500000000, 500000000, 1000000000]","solution":"def minimize_adjacent_difference(arr): Reorder integers in the list such that the difference between any two adjacent integers is minimized. This can be achieved by simply sorting the list in ascending order. return sorted(arr)"},{"question":"def min_palindromic_splits(s: str) -> int: Given a string s of lower case English letters, finds the minimum number of splits required to convert it into a collection of non-empty palindromic substrings. >>> min_palindromic_splits(\\"abccba\\") 0 >>> min_palindromic_splits(\\"aab\\") 1 >>> min_palindromic_splits(\\"a\\") 0 >>> min_palindromic_splits(\\"aa\\") 0 >>> min_palindromic_splits(\\"ab\\") 1 >>> min_palindromic_splits(\\"abcba\\") 0 >>> min_palindromic_splits(\\"abcdefgh\\") 7 >>> min_palindromic_splits(\\"abcde\\") 4 >>> min_palindromic_splits(\\"aabbcac\\") 2","solution":"def min_palindromic_splits(s): n = len(s) # Table to check if substring s[i:j+1] is a palindrome palindrome = [[False] * n for _ in range(n)] for i in range(n): palindrome[i][i] = True for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 2: palindrome[i][j] = (s[i] == s[j]) else: palindrome[i][j] = (s[i] == s[j]) and palindrome[i + 1][j - 1] # Array to store the minimum cuts cuts = [0] * n for i in range(n): if palindrome[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if palindrome[j + 1][i] and cuts[j] + 1 < cuts[i]: cuts[i] = cuts[j] + 1 return cuts[n - 1]"},{"question":"def min_shipments(n: int, c: int, weights: List[int]) -> int: Determines the minimum number of shipments required to consolidate all packages without exceeding the capacity of any shipment. Parameters: n (int): Number of packages c (int): Maximum capacity per shipment weights (list of int): Weights of the packages Returns: int: Minimum number of shipments needed >>> min_shipments(5, 10, [1, 2, 3, 4, 5]) 2 >>> min_shipments(5, 15, [1, 2, 3, 4, 5]) 1 >>> min_shipments(4, 10, [5, 5, 5, 5]) 2 >>> min_shipments(6, 12, [7, 5, 6, 4, 11, 1]) 3 >>> min_shipments(3, 8, [2, 4, 6]) 2","solution":"def min_shipments(n, c, weights): Determines the minimum number of shipments required to consolidate all packages without exceeding the capacity of any shipment. Parameters: n (int): Number of packages c (int): Maximum capacity per shipment weights (list of int): Weights of the packages Returns: int: Minimum number of shipments needed weights.sort(reverse=True) shipments = 0 while weights: current_shipment = 0 idx = 0 while idx < len(weights): if current_shipment + weights[idx] <= c: current_shipment += weights.pop(idx) else: idx += 1 shipments += 1 return shipments"},{"question":"def length_of_longest_substring(s: str) -> int: Return the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\" \\") 1 >>> length_of_longest_substring(\\"au\\") 2 def decode_strings(test_cases: List[str]) -> List[int]: Given a list of strings, return a list of lengths of the longest substrings without repeating characters for each string. >>> decode_strings([\\"abcabcbb\\", \\"bbbbb\\"]) [3, 1] >>> decode_strings([\\"pwwkew\\", \\"aab\\"]) [3, 2] >>> decode_strings([\\"dvdf\\", \\"\\", \\" \\"]) [3, 0, 1] >>> decode_strings([\\"au\\", \\"\\"]) [2, 0]","solution":"def length_of_longest_substring(s): This function returns the length of the longest substring without repeating characters. # Dictionary to store the last positions of each character. seen = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in seen and start <= seen[char]: start = seen[char] + 1 else: max_length = max(max_length, i - start + 1) seen[char] = i return max_length def decode_strings(test_cases): Given a list of strings, this function returns a list of lengths of the longest substrings without repeating characters for each string. results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def count_buildings_with_sunlight(n: int, heights: List[int]) -> int: Returns the number of buildings that receive sunlight. Parameters: - n: Integer, the number of buildings. - heights: List of integers, heights of the buildings. Returns: - Integer, the number of buildings that receive sunlight. >>> count_buildings_with_sunlight(6, [3, 1, 4, 6, 5, 2]) == 3 >>> count_buildings_with_sunlight(7, [7, 6, 5, 4, 3, 2, 1]) == 1 >>> count_buildings_with_sunlight(5, [1, 3, 2, 5, 4]) == 3 >>> count_buildings_with_sunlight(1, [10]) == 1 >>> count_buildings_with_sunlight(0, []) == 0 >>> count_buildings_with_sunlight(4, [1, 2, 3, 4]) == 4 >>> count_buildings_with_sunlight(5, [5, 5, 5, 5, 5]) == 1","solution":"def count_buildings_with_sunlight(n, heights): Returns the number of buildings that receive sunlight. Parameters: - n: Integer, the number of buildings. - heights: List of integers, heights of the buildings. Returns: - Integer, the number of buildings that receive sunlight. if n == 0: return 0 count = 1 # The first building always receives sunlight. max_height = heights[0] for i in range(1, n): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"def find_max_growth_plant(d: int, n: int, heights: List[List[int]]) -> Tuple[int, int]: Identify the plant that had the maximum height increase when compared to the heights of its immediate neighbors on the last day. >>> find_max_growth_plant(3, 5, [ [1, 3, 2, 4, 1], [2, 4, 3, 5, 3], [3, 6, 4, 7, 2] ]) (3, 3) >>> find_max_growth_plant(2, 3, [ [1, 2, 3], [2, 3, 4] ]) (2, 1)","solution":"def find_max_growth_plant(d, n, heights): last_day_heights = heights[-1] max_increase = float('-inf') max_index = -1 for i in range(n): if i == 0: increase = last_day_heights[i] - last_day_heights[i+1] elif i == n-1: increase = last_day_heights[i] - last_day_heights[i-1] else: increase = min(last_day_heights[i] - last_day_heights[i-1], last_day_heights[i] - last_day_heights[i+1]) if increase > max_increase: max_increase = increase max_index = i return (max_index, max_increase)"},{"question":"def process_queries(n, q, sequence, queries): Processes a list of queries on a given sequence where each query can either reverse a sub-sequence or return the minimum value in a sub-sequence. Parameters: n - the length of the sequence (int) q - the number of queries (int) sequence - the list of sequence elements (list of ints) queries - the list of queries (list of tuples where each tuple is (int, int, int)) Returns: list of results for each query of the second type (list of ints) pass from solution import process_queries def test_process_queries_example(): assert process_queries(6, 4, [3, 1, 4, 1, 5, 9], [(1, 2, 5), (2, 1, 6), (1, 1, 4), (2, 2, 4)]) == [1, 1] def test_process_queries_single_element(): assert process_queries(1, 2, [5], [(2, 1, 1), (1, 1, 1)]) == [5] def test_process_queries_reversals(): assert process_queries(5, 3, [9, 8, 7, 6, 5], [(1, 1, 5), (2, 1, 5), (1, 1, 3)]) == [5] def test_process_queries_minimum_queries(): assert process_queries(3, 2, [8, 2, 10], [(2, 1, 2), (2, 2, 3)]) == [2, 2] def test_process_queries_no_queries(): assert process_queries(4, 0, [6, 4, 7, 1], []) == []","solution":"def process_queries(n, q, sequence, queries): Processes a list of queries on a given sequence where each query can either reverse a sub-sequence or return the minimum value in a sub-sequence. Parameters: n - the length of the sequence (int) q - the number of queries (int) sequence - the list of sequence elements (list of ints) queries - the list of queries (list of tuples where each tuple is (int, int, int)) Returns: list of results for each query of the second type (list of ints) results = [] for query in queries: type_query, l, r = query l -= 1 # switching to 0-based index r -= 1 # switching to 0-based index if type_query == 1: sequence[l:r+1] = sequence[l:r+1][::-1] elif type_query == 2: results.append(min(sequence[l:r+1])) return results"},{"question":"def longestIncreasingPath(matrix: List[List[int]]) -> int: Given an m x n matrix where each cell contains an integer, find the longest path of increasing integers. Note that you can move in four possible directions: up, down, left, or right. You may not revisit any cell in the same path more than once. >>> longestIncreasingPath([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longestIncreasingPath([[1]]) 1 >>> longestIncreasingPath([[1, 2, 3, 4]]) 4 >>> longestIncreasingPath([ ... [1], ... [2], ... [3], ... [4] ... ]) 4 >>> longestIncreasingPath([ ... [7, 8, 9], ... [6, 1, 2], ... [5, 4, 3] ... ]) 9 >>> longestIncreasingPath([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 >>> longestIncreasingPath([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) 1","solution":"from typing import List, Tuple def longestIncreasingPath(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 def dfs(x: int, y: int, memo: List[List[int]]) -> int: if memo[x][y]: return memo[x][y] # Directions array for moving up, down, left, and right directions: List[Tuple[int, int]] = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 # Initial length of path starting from current cell for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(matrix) and 0 <= ny < len(matrix[0]) and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny, memo) max_length = max(max_length, length) memo[x][y] = max_length return max_length m, n = len(matrix), len(matrix[0]) memo: List[List[int]] = [[0] * n for _ in range(m)] return max(dfs(i, j, memo) for i in range(m) for j in range(n))"},{"question":"def minimum_moves(a: int, b: int) -> int: Returns the minimum number of moves required for Alice and Bob to make their integers equal. >>> minimum_moves(5, 8) 3 >>> minimum_moves(-3, 4) 7 >>> minimum_moves(0, 5) 5 >>> minimum_moves(7, 7) 0 >>> minimum_moves(-7, 3) 10","solution":"def minimum_moves(a, b): Returns the minimum number of moves required for Alice and Bob to make their integers equal. return abs(a - b)"},{"question":"def longest_increasing_subarray_with_limit(n: int, k: int, array: List[int]) -> int: Find the length of the longest strictly increasing subarray where the difference between any two consecutive elements does not exceed k. Parameters: n (int): The number of elements in the array. k (int): The maximum allowed difference between two consecutive elements. array (List[int]): The elements of the array. Returns: int: The length of the longest subarray that matches the criteria. >>> longest_increasing_subarray_with_limit(6, 2, [1, 3, 5, 3, 2, 8]) 3 >>> longest_increasing_subarray_with_limit(5, 1, [5, 5, 5, 5, 5]) 1 >>> longest_increasing_subarray_with_limit(4, 10, [1, 3, 6, 10]) 4 >>> longest_increasing_subarray_with_limit(1, 5, [4]) 1 >>> longest_increasing_subarray_with_limit(4, 2, [1, 4, 7, 10]) 1 >>> longest_increasing_subarray_with_limit(8, 3, [2, 5, 6, 8, 13, 1, 2, 3]) 4","solution":"def longest_increasing_subarray_with_limit(n, k, array): max_length = 1 current_length = 1 for i in range(1, n): if array[i] > array[i - 1] and array[i] - array[i - 1] <= k: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage: # n, k = 6, 2 # array = [1, 3, 5, 3, 2, 8] # print(longest_increasing_subarray_with_limit(n, k, array)) # Output: 3"},{"question":"def max_possible_sum(arr, n, m): Function to find the maximum possible sum of the array after performing one operation. :param arr: List[int] - Initial array of integers :param n: int - Length of the array :param m: int - Integer value that can be added to a subarray :return: int - The maximum possible sum of the array after performing the operation >>> max_possible_sum([1, 2, 3, 4, 5], 5, 2) 25 >>> max_possible_sum([-3, -1, 0, 2, 4], 5, 6) 30 >>> max_possible_sum([3, 3, 3, 3], 4, 5) 32 >>> max_possible_sum([10, 20, 30], 3, 5) 75 >>> max_possible_sum([1], 1, 1) 2 pass","solution":"def max_possible_sum(arr, n, m): Function to find the maximum possible sum of the array after performing one operation. :param arr: List[int] - Initial array of integers :param n: int - Length of the array :param m: int - Integer value that can be added to a subarray :return: int - The maximum possible sum of the array after performing the operation # Calculate the initial sum of the array total_sum = sum(arr) # Find the minimum element of the array min_element = min(arr) # Add 'm' to the whole array and calculate the sum max_sum_after_operation = total_sum + m * n return max_sum_after_operation"},{"question":"def compare_diagonal_products(matrix): Compare the product of the main diagonal and the anti-diagonal of a matrix. Args: matrix (List[List[int]]): A square matrix of integers Returns: str: \\"YES\\" if the product of the main diagonal is equal to the product of the anti-diagonal, otherwise \\"NO\\".","solution":"def compare_diagonal_products(matrix): Compare the product of the main diagonal and the anti-diagonal of a matrix. Args: matrix (List[List[int]]): A square matrix of integers Returns: str: \\"YES\\" if the product of the main diagonal is equal to the product of the anti-diagonal, otherwise \\"NO\\". n = len(matrix) main_diagonal_product = 1 anti_diagonal_product = 1 for i in range(n): main_diagonal_product *= matrix[i][i] anti_diagonal_product *= matrix[i][n - i - 1] if main_diagonal_product == anti_diagonal_product: return \\"YES\\" else: return \\"NO\\" # Function to handle the input and output def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) matrix = [] index = 1 for i in range(n): row = [int(data[index + j]) for j in range(n)] matrix.append(row) index += n result = compare_diagonal_products(matrix) print(result)"},{"question":"def minimum_rounds(n: int, k: int) -> int: Calculate the minimum number of rounds required for Borya to determine the initial positions of all n cards by flipping any k cards in each round. Args: n: int - The total number of cards k: int - The number of cards that can be flipped in one round Returns: int: The minimum number of rounds required to determine the initial positions of all cards >>> minimum_rounds(4, 2) 2 >>> minimum_rounds(5, 1) 5 >>> minimum_rounds(10, 5) 2 >>> minimum_rounds(10, 10) 1 >>> minimum_rounds(7, 3) 3","solution":"def minimum_rounds(n, k): Calculate the minimum number of rounds required for Borya to determine the initial positions of all n cards by flipping any k cards in each round. if k == 1: return n if n <= k: return 1 return (n + k - 1) // k"},{"question":"def min_yellow_bricks_to_remove(n: int, bricks: List[int]) -> int: Given an array of integers representing a row of bricks, find the minimum number of yellow bricks (1) to remove so that no two adjacent bricks are of the same color. Args: n: int - number of bricks bricks: List[int] - list representing the color of each brick in the row (1, 2, or 3) Returns: int - minimum number of yellow bricks to remove Examples: >>> min_yellow_bricks_to_remove(7, [1, 2, 1, 2, 3, 1, 3]) 0 >>> min_yellow_bricks_to_remove(7, [1, 1, 2, 2, 3, 1, 1]) 2","solution":"def min_yellow_bricks_to_remove(n, bricks): removals = 0 for i in range(1, n): if bricks[i] == 1 and bricks[i] == bricks[i-1]: removals += 1 return removals"},{"question":"def minimum_match_score(n: int, a: str, b: str) -> int: Returns the minimum match score possible after reordering characters in strings a and b. The match score is defined as the sum of absolute differences of ASCII values of corresponding characters. >>> minimum_match_score(3, \\"abc\\", \\"xyz\\") 69 >>> minimum_match_score(5, \\"abcde\\", \\"abcde\\") 0","solution":"def minimum_match_score(n, a, b): Returns the minimum match score possible after reordering characters in strings a and b. # Sort both strings to align the smallest ASCII values with each other sorted_a = sorted(a) sorted_b = sorted(b) # Calculate the minimum match score min_score = sum(abs(ord(sorted_a[i]) - ord(sorted_b[i])) for i in range(n)) return min_score"},{"question":"def core_string_length(n: int, s: str) -> int: Determines the length of the core string for input string \`s\`. Parameters: - n (int): The length of the string - s (str): The input string consisting of lowercase Latin letters Returns: - int: Length of the core string >>> core_string_length(12, \\"abcabcabcabc\\") 3 >>> core_string_length(8, \\"abababab\\") 2 >>> core_string_length(6, \\"aaaaaa\\") 1 >>> core_string_length(5, \\"abcde\\") 5 >>> core_string_length(9, \\"abcabcabc\\") 3 >>> core_string_length(4, \\"abcd\\") 4","solution":"def core_string_length(n, s): Determines the length of the core string for input string \`s\`. Parameters: - n (int): The length of the string - s (str): The input string consisting of lowercase Latin letters Returns: - int: Length of the core string for i in range(1, n + 1): if n % i == 0: # i must be a divisor of n sub = s[:i] multiplier = n // i if sub * multiplier == s: return i return n"},{"question":"def find_highest_power_in_largest_component(n: int, m: int, power_levels: List[int], edges: List[Tuple[int, int]]) -> int: Find the vertex with the highest power level in the largest connected component of a graph. >>> find_highest_power_in_largest_component(1, 0, [10], []) 1 >>> find_highest_power_in_largest_component(3, 0, [10, 20, 30], []) 3 >>> find_highest_power_in_largest_component(3, 2, [10, 20, 30], [(1, 2), (2, 3)]) 3 >>> find_highest_power_in_largest_component(5, 3, [10, 12, 14, 1, 2], [(1, 2), (1, 3), (4, 5)]) 3 >>> find_highest_power_in_largest_component(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> find_highest_power_in_largest_component(4, 3, [10, 10, 10, 10], [(1, 2), (2, 3), (3, 4)]) 1 >>> find_highest_power_in_largest_component(4, 4, [50, 50, 10, 50], [(1, 2), (2, 3), (1, 3), (4, 3)]) 1 >>> find_highest_power_in_largest_component(6, 5, [10, 20, 30, 5, 8, 9], [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) 3","solution":"def find_highest_power_in_largest_component(n, m, power_levels, edges): from collections import defaultdict, deque if m == 0: # No edges, return the vertex with the highest power level return power_levels.index(max(power_levels)) + 1 graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) def bfs(start): visited = set() queue = deque([start]) component = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return component visited_global = set() largest_component = [] for vertex in range(n): if vertex not in visited_global: component = bfs(vertex) if len(component) > len(largest_component): largest_component = component visited_global.update(component) largest_component.sort(key=lambda x: (-power_levels[x], x)) return largest_component[0] + 1"},{"question":"def botanical_tour(n, m, edges, s): Returns the maximum number of plants Junaid can visit and the minimum total distance. n: number of plants (nodes) m: number of edges (paths) edges: list of tuples (u, v, w) where u and v are nodes and w is the weight of the edge s: starting plant >>> botanical_tour(4, 4, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3)], 1) (4, 6) >>> botanical_tour(1, 0, [], 1) (1, 0) >>> botanical_tour(4, 2, [(1, 2, 1), (3, 4, 2)], 1) (2, 1) >>> botanical_tour(4, 4, [(1, 2, 1), (1, 3, 1), (2, 3, 1), (3, 4, 1)], 1) (4, 3) >>> botanical_tour(5, 6, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 1), (3, 5, 5), (4, 5, 2)], 1) (5, 6)","solution":"import heapq def botanical_tour(n, m, edges, s): Returns the maximum number of plants Junaid can visit and the minimum total distance. n: number of plants (nodes) m: number of edges (paths) edges: list of tuples (u, v, w) where u and v are nodes and w is the weight of the edge s: starting plant graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) # Prim's algorithm for Minimum Spanning Tree (MST) min_heap = [(0, s)] visited = [False] * (n + 1) max_plants_visited = 0 min_total_distance = 0 while min_heap: weight, node = heapq.heappop(min_heap) if visited[node]: continue visited[node] = True max_plants_visited += 1 min_total_distance += weight for edge_weight, neighbor in graph[node]: if not visited[neighbor]: heapq.heappush(min_heap, (edge_weight, neighbor)) return max_plants_visited, min_total_distance"},{"question":"def max_distinct_substrings(s: str, l: int, k: int) -> int: Returns the maximum number of distinct substrings of length l that can be achieved by modifying up to k characters. >>> max_distinct_substrings(\\"abcde\\", 2, 0) 4 >>> max_distinct_substrings(\\"aabbcc\\", 2, 1) 5 >>> max_distinct_substrings(\\"aaa\\", 2, 0) 1 >>> max_distinct_substrings(\\"ababab\\", 2, 2) 4 >>> max_distinct_substrings(\\"abcabcabcabc\\", 3, 2) 6 >>> max_distinct_substrings(\\"abcda\\", 2, 3) 4 >>> max_distinct_substrings(\\"abcdabc\\", 2, 1) 6","solution":"def max_distinct_substrings(s, l, k): Returns the maximum number of distinct substrings of length l that can be achieved by modifying up to k characters. from collections import defaultdict, deque n = len(s) if l > n: return 0 substr_count = defaultdict(int) substrs = [] for i in range(n - l + 1): substrs.append(s[i:i+l]) substrs = deque(substrs) max_distinct = len(set(substrs)) if k == 0: return max_distinct for i in range(n): for j in range(26): modified_s = list(s) modified_s[i] = chr(97 + j) modified_s = ''.join(modified_s) substr_set = set() for m in range(n - l + 1): substr_set.add(modified_s[m:m+l]) max_distinct = max(max_distinct, len(substr_set)) if i >= k: break return max_distinct"},{"question":"import heapq def minimum_communication_delay(n, m, edges): Returns the minimum total communication delay from node 1 to node n. If there is no path, returns -1. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples (u, v, w) representing edges and their weights :return: Minimum communication delay or -1 if no path exists >>> minimum_communication_delay(4, 4, [(1, 2, 5), (2, 3, 3), (3, 4, 4), (1, 4, 10)]) 10 >>> minimum_communication_delay(2, 1, [(1, 2, 10)]) 10 >>> minimum_communication_delay(4, 2, [(1, 2, 5), (3, 4, 4)]) -1","solution":"import heapq def minimum_communication_delay(n, m, edges): Returns the minimum total communication delay from node 1 to node n. If there is no path, returns -1. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples (u, v, w) representing edges and their weights :return: Minimum communication delay or -1 if no path exists graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path pq = [(0, 1)] min_delay = [float('inf')] * (n + 1) min_delay[1] = 0 while pq: current_delay, u = heapq.heappop(pq) if current_delay > min_delay[u]: continue for v, delay in graph[u]: total_delay = current_delay + delay if total_delay < min_delay[v]: min_delay[v] = total_delay heapq.heappush(pq, (total_delay, v)) return min_delay[n] if min_delay[n] != float('inf') else -1"},{"question":"from collections import deque from typing import List, Tuple def shortest_path_length(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the length of the shortest path from the starting cell to the target cell in a grid. The warehouse grid is represented as a 2D list where each element is either 0 (an empty cell) or 1 (an obstacle). The robot can move up, down, left, or right, but cannot move diagonally or pass through obstacles. :param grid: 2D list representing the warehouse grid. :param start: Tuple (sx, sy) representing the starting cell coordinates. :param target: Tuple (tx, ty) representing the target cell coordinates. :return: Integer length of the shortest path or -1 if no path exists. >>> grid = [ [0, 0, 0, 0, 1], [0, 1, 1, 0, 0], [0, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0] ] >>> start = (1, 1) >>> target = (5, 4) >>> shortest_path_length(grid, start, target) 7 >>> grid = [ [0, 1], [1, 0] ] >>> start = (1, 1) >>> target = (2, 2) >>> shortest_path_length(grid, start, target) -1 >>> grid = [ [0, 0], [0, 0] ] >>> start = (1, 1) >>> target = (1, 1) >>> shortest_path_length(grid, start, target) 0","solution":"from collections import deque def shortest_path_length(grid, start, target): Returns the length of the shortest path from start to target in a grid. :param grid: 2D list representing the warehouse grid. :param start: Tuple (sx, sy) representing the starting cell coordinates. :param target: Tuple (tx, ty) representing the target cell coordinates. :return: Integer length of the shortest path or -1 if no path exists. n = len(grid) m = len(grid[0]) sx, sy = start tx, ty = target # Adjust 1-based indexing to 0-based indexing for easier list access sx -= 1 sy -= 1 tx -= 1 ty -= 1 # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"def max_artifacts_collected(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Calculate the maximum number of artifacts the robot can collect starting from initial position 'S'. >>> t = 2 >>> test_cases = [ (3, 4, [ 'S..#', '.#A.', '..A.' ]), (3, 3, [ 'S#A', '.#.', 'A#A' ]) ] >>> max_artifacts_collected(t, test_cases) [2, 1] pass # Unit tests def test_example_cases(): t = 2 test_cases = [ (3, 4, [ 'S..#', '.#A.', '..A.' ]), (3, 3, [ 'S#A', '.#.', 'A#A' ]) ] assert max_artifacts_collected(t, test_cases) == [2, 1] def test_no_artifacts(): t = 1 test_cases = [ (3, 3, [ 'S#.', '#', '...' ]) ] assert max_artifacts_collected(t, test_cases) == [0] def test_all_artifacts(): t = 1 test_cases = [ (3, 3, [ 'S.A', 'A.A', 'AAA' ]) ] assert max_artifacts_collected(t, test_cases) == [6] def test_robot_surrounded(): t = 1 test_cases = [ (3, 3, [ 'S#A', '#.#', 'A#A' ]) ] assert max_artifacts_collected(t, test_cases) == [0] def test_single_cell_start(): t = 1 test_cases = [ (1, 1, [ 'S' ]) ] assert max_artifacts_collected(t, test_cases) == [0]","solution":"from collections import deque def max_artifacts_collected(t, test_cases): results = [] for case in test_cases: n, m, grid = case # Find the starting position 'S' start = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) break if start: break # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue = deque([start]) visited = set([start]) artifact_count = 0 while queue: x, y = queue.popleft() # if it's an artifact, collect it if grid[x][y] == 'A': artifact_count += 1 # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) results.append(artifact_count) return results"},{"question":"from typing import List def shortest_substring_length_with_k_distinct_chars(k: int, s: str) -> int: Find the length of the shortest substring that contains at least k distinct characters. >>> shortest_substring_length_with_k_distinct_chars(3, \\"abcabcabc\\") 3 >>> shortest_substring_length_with_k_distinct_chars(5, \\"aabbcc\\") -1 pass def test_example_1(): assert shortest_substring_length_with_k_distinct_chars(3, \\"abcabcabc\\") == 3 def test_example_2(): assert shortest_substring_length_with_k_distinct_chars(5, \\"aabbcc\\") == -1 def test_small_k(): assert shortest_substring_length_with_k_distinct_chars(1, \\"a\\") == 1 def test_string_with_all_same_chars(): assert shortest_substring_length_with_k_distinct_chars(1, \\"bbbb\\") == 1 assert shortest_substring_length_with_k_distinct_chars(2, \\"bbbb\\") == -1 def test_k_equals_length_of_string(): assert shortest_substring_length_with_k_distinct_chars(4, \\"abcd\\") == 4 def test_large_k(): assert shortest_substring_length_with_k_distinct_chars(26, \\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_no_valid_substring(): assert shortest_substring_length_with_k_distinct_chars(27, \\"abcdefghijklmnopqrstuvwxyz\\") == -1","solution":"def shortest_substring_length_with_k_distinct_chars(k, s): from collections import defaultdict n = len(s) if k > 26 or k > n: return -1 char_count = defaultdict(int) start = 0 min_length = float('inf') for end in range(n): char_count[s[end]] += 1 while len(char_count) >= k: current_length = end - start + 1 if current_length < min_length: min_length = current_length char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_good_awards(n: int, points: List[int]) -> int: Given the number of employees and their points, determine the maximum number of good awards. A \\"good\\" award is one where for each integer d (1 ≤ d ≤ 5), there are exactly d number of employees. >>> max_good_awards(15, list(range(1, 16))) == 15 >>> max_good_awards(30, list(range(1, 31))) == 30 >>> max_good_awards(20, list(range(1, 21))) == 15 >>> max_good_awards(10, list(range(1, 11))) == 0 pass","solution":"def max_good_awards(n, points): Given the number of employees and their points, determine the maximum number of good awards. A \\"good\\" award is one where for each integer d (1 ≤ d ≤ 5), there are exactly d number of employees. if n < 15: return 0 return n // 15 * 15"},{"question":"def count_valid_checkpoint_positions(n: int, d: int, A: List[int]) -> int: Returns the count of valid checkpoint positions given the constraints. n: int : number of checkpoints d: int : maximum allowed difference between adjacent checkpoints A: list : list of initial positions sorted in ascending order Examples: >>> count_valid_checkpoint_positions(5, 2, [1, 3, 5, 7, 9]) 5 >>> count_valid_checkpoint_positions(6, 4, [1, 6, 10, 14, 18, 20]) 6","solution":"def count_valid_checkpoint_positions(n, d, A): Returns the count of valid checkpoint positions given the constraints. n : int : number of checkpoints d : int : maximum allowed difference between adjacent checkpoints A : list : list of initial positions sorted in ascending order # Since the checkpoints are already in A, all these positions are valid # This is derived from problem statement, which does not require any modification as it's all about counting # the already given checkpoints. return n"},{"question":"def minimum_drones_required(drone_capacity, package_weights): Determines the minimum number of drones required to deliver all packages. Parameters: drone_capacity (List[int]): List of capacities for each drone. package_weights (List[int]): List of weights for each package. Returns: int or str: The minimal number of drones required to deliver all the packages, or \\"Impossible\\" if any package cannot be delivered. Examples: >>> minimum_drones_required([10, 20, 30], [10, 10, 20, 10]) 4 >>> minimum_drones_required([10, 20, 30, 40, 50], [10, 15, 20, 25, 30, 50]) 6 >>> minimum_drones_required([10, 20, 30, 40, 50], [10, 15, 20, 25, 30, 100, 50]) 'Impossible' >>> minimum_drones_required([10, 20, 30], [5, 20, 10]) 3 >>> minimum_drones_required([10, 20, 30], [35]) 'Impossible'","solution":"def minimum_drones_required(drone_capacity, package_weights): Determines the minimum number of drones required to deliver all packages. max_capacity = max(drone_capacity) if any(weight > max_capacity for weight in package_weights): return \\"Impossible\\" sorted_packages = sorted(package_weights, reverse=True) drones_needed = 0 for weight in sorted_packages: # As each drone carries only one package per trip, incrementing the drone count drones_needed += 1 return drones_needed"},{"question":"def longest_sublist_with_max_sum(n: int, k: int, elements: List[int]) -> int: Returns the length of the longest sublist where the sum of elements is less than or equal to k. >>> longest_sublist_with_max_sum(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) 5 >>> longest_sublist_with_max_sum(5, 15, [3, 3, 3, 3, 3]) 5 >>> longest_sublist_with_max_sum(3, 1, [2, 3, 4]) 0 >>> longest_sublist_with_max_sum(0, 10, []) 0 >>> longest_sublist_with_max_sum(1, 5, [3]) 1 >>> longest_sublist_with_max_sum(1, 2, [3]) 0 >>> longest_sublist_with_max_sum(6, 1000, [1, 2, 3, 4, 5, 6]) 6 >>> longest_sublist_with_max_sum(6, 10, [10, 9, 8, 7, 6, 5]) 1 >>> longest_sublist_with_max_sum(7, 15, [1,2,3,4,5,6,7]) 5 >>> longest_sublist_with_max_sum(200000, 1000000000, [1] * 200000) 200000","solution":"def longest_sublist_with_max_sum(n, k, elements): Returns the length of the longest sublist where the sum of elements is less than or equal to k. left = 0 current_sum = 0 max_length = 0 for right in range(n): current_sum += elements[right] while current_sum > k: current_sum -= elements[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List, Tuple def minimum_toll_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum toll cost from the first city to the last city. Args: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int, int]]): A list of roads, where each road is represented as a tuple (u, v, t) indicating a road between city u and city v, and t indicating whether the road has a toll (t = 1) or is toll-free (t = 0). Returns: int: The minimum toll cost from city 1 to city n, or -1 if there is no such path. Example: >>> minimum_toll_cost(5, 6, [(1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (3, 5, 1), (1, 3, 0)]) 1 >>> minimum_toll_cost(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 0)]) 0 pass import heapq def test_case_1(): n = 5 m = 6 roads = [ (1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (3, 5, 1), (1, 3, 0) ] assert minimum_toll_cost(n, m, roads) == 1 def test_case_2(): n = 4 m = 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 0) ] assert minimum_toll_cost(n, m, roads) == 0 def test_case_3(): n = 3 m = 3 roads = [ (1, 2, 1), (2, 3, 1), (1, 3, 1) ] assert minimum_toll_cost(n, m, roads) == 1 def test_case_4(): n = 4 m = 3 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1) ] assert minimum_toll_cost(n, m, roads) == 3 def test_case_5(): n = 6 m = 7 roads = [ (1, 2, 0), (1, 3, 0), (2, 4, 0), (3, 4, 1), (4, 5, 0), (5, 6, 0), (3, 6, 1) ] assert minimum_toll_cost(n, m, roads) == 0 def test_case_impossible(): n = 4 m = 2 roads = [ (1, 2, 1), (3, 4, 1) ] assert minimum_toll_cost(n, m, roads) == -1","solution":"import heapq def minimum_toll_cost(n, m, roads): Returns the minimum toll cost from city 1 to city n, or -1 if there is no such path. graph = [[] for _ in range(n + 1)] for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Priority queue: (current toll cost, city) pq = [(0, 1)] toll_cost = [float('inf')] * (n + 1) toll_cost[1] = 0 while pq: current_cost, u = heapq.heappop(pq) if u == n: return current_cost for v, t in graph[u]: new_cost = current_cost + t if new_cost < toll_cost[v]: toll_cost[v] = new_cost heapq.heappush(pq, (new_cost, v)) return -1 # Test input n = 5 m = 6 roads = [ (1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (3, 5, 1), (1, 3, 0) ] # Expected output: 1 print(minimum_toll_cost(n, m, roads))"},{"question":"from typing import List, Tuple def reverse_row(grid: List[List[int]], row_idx: int) -> None: Reverses the elements of the given row in the grid. pass def reverse_column(grid: List[List[int]], col_idx: int) -> None: Reverses the elements of the given column in the grid. pass def perform_operations(n: int, queries: List[Tuple[int, int]]) -> List[List[int]]: Given a grid of size n x n initialized to all zeros, perform a series of operations to reverse rows or columns based on the given queries and return the final state of the grid. Args: n (int): The size of the grid (n x n). queries (List[Tuple[int, int]]): A list of queries where each query is a tuple (rc, c). Returns: List[List[int]]: The final state of the grid after performing all queries. Examples: >>> perform_operations(3, [(1, 2), (2, 3), (1, 2), (2, 3)]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> perform_operations(3, [(1, 1)]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> perform_operations(3, [(2, 1)]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> perform_operations(3, [(1, 1), (1, 1)]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> perform_operations(5, [(1, 3), (2, 2), (1, 3)]) [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] # Initialize the grid with all zeros grid = [[0] * n for _ in range(n)] for rc, c in queries: if rc == 1: reverse_row(grid, c-1) elif rc == 2: reverse_column(grid, c-1) return grid","solution":"def reverse_row(grid, row_idx): grid[row_idx] = grid[row_idx][::-1] def reverse_column(grid, col_idx): n = len(grid) for i in range(n // 2): grid[i][col_idx], grid[n-i-1][col_idx] = grid[n-i-1][col_idx], grid[i][col_idx] def perform_operations(n, queries): # Initialize the grid with all zeros grid = [[0] * n for _ in range(n)] for rc, c in queries: if rc == 1: reverse_row(grid, c-1) elif rc == 2: reverse_column(grid, c-1) return grid"},{"question":"def generate_bib_numbers(k1: int, k2: int, k3: int) -> List[int]: Given the number of participants in each category, returns a list of bib numbers starting from category A, followed by B, then C. >>> generate_bib_numbers(1, 1, 1) == [1, 2, 3] >>> generate_bib_numbers(2, 3, 4) == [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> generate_bib_numbers(1, 2, 3) == [1, 2, 3, 4, 5, 6] >>> generate_bib_numbers(100, 100, 100) == list(range(1, 301)) >>> generate_bib_numbers(50, 50, 1) == list(range(1, 51)) + list(range(51, 101)) + [101]","solution":"def generate_bib_numbers(k1, k2, k3): Given the number of participants in each category, returns a list of bib numbers starting from category A, followed by B, then C. A = list(range(1, k1 + 1)) B = list(range(k1 + 1, k1 + k2 + 1)) C = list(range(k1 + k2 + 1, k1 + k2 + k3 + 1)) return A + B + C"},{"question":"def max_visible_billboard(n: int, heights: List[int]) -> int: Returns the maximum height of a billboard that can be placed on a building such that it is visible from both directions. :param n: int, the number of buildings :param heights: list of int, the heights of the buildings :return: int, the maximum possible height of the billboard >>> max_visible_billboard(7, [4, 1, 5, 3, 2, 6, 1]) 6 >>> max_visible_billboard(1, [5]) 5 >>> max_visible_billboard(5, [3, 3, 3, 3, 3]) 3 >>> max_visible_billboard(5, [1, 2, 3, 4, 5]) 5 >>> max_visible_billboard(5, [5, 4, 3, 2, 1]) 5","solution":"def max_visible_billboard(n, heights): Returns the maximum height of a billboard that can be placed on a building such that it is visible from both directions. :param n: int, the number of buildings :param heights: list of int, the heights of the buildings :return: int, the maximum possible height of the billboard max_to_left = [0] * n max_to_right = [0] * n # Fill max_to_left array max_to_left[0] = heights[0] for i in range(1, n): max_to_left[i] = max(max_to_left[i - 1], heights[i]) # Fill max_to_right array max_to_right[-1] = heights[-1] for i in range(n - 2, -1, -1): max_to_right[i] = max(max_to_right[i + 1], heights[i]) # Find the maximum height of the billboard max_height = 0 for i in range(n): if heights[i] >= max_to_left[i] and heights[i] >= max_to_right[i]: max_height = max(max_height, heights[i]) return max_height"},{"question":"def find_cycles(n: int, permutation: List[int]) -> List[List[int]]: Given a permutation of integers from 1 to n, identifies all distinct cycles within it. Args: n: An integer representing the length of the permutation. permutation: A list of integers representing the permutation. Returns: A list of lists, where each list represents a cycle in the permutation. Examples: >>> find_cycles(5, [3, 2, 4, 1, 5]) [[1, 3, 4], [2], [5]] >>> find_cycles(1, [1]) [[1]] from typing import List def test_single_element(): assert find_cycles(1, [1]) == [[1]] def test_disjoint_cycles(): assert find_cycles(5, [2, 1, 4, 3, 5]) == [[1, 2], [3, 4], [5]] def test_one_large_cycle(): assert find_cycles(4, [2, 3, 4, 1]) == [[1, 2, 3, 4]] def test_multiple_cycles(): assert find_cycles(5, [3, 2, 4, 1, 5]) == [[1, 3, 4], [2], [5]] def test_permutation_with_self_loops(): assert find_cycles(3, [1, 3, 2]) == [[1], [2, 3]] def test_large_permutation(): assert len(find_cycles(10**5, list(range(1, 10**5 + 1)))) == 10**5","solution":"def find_cycles(n, permutation): Takes the length of the permutation and the permutation list, returns the cycles in the permutation. visited = [False] * (n + 1) cycles = [] def find_cycle(start): cycle = [] current = start while not visited[current]: visited[current] = True cycle.append(current) current = permutation[current - 1] return cycle for i in range(1, n + 1): if not visited[i]: cycle = find_cycle(i) if cycle: cycles.append(cycle) return cycles"},{"question":"def calculate_ranks(scores: List[int]) -> List[int]: This function takes an array of scores and returns an array representing the rank of each participant based on their score. The participant with the highest score is ranked 1. If multiple participants have the same score, they should share the same rank, and the next rank after that should be incremented by the number of participants who share the previous rank. >>> calculate_ranks([100, 100, 50, 25]) [1, 1, 3, 4] >>> calculate_ranks([60, 80, 100, 90, 70]) [5, 3, 1, 2, 4] >>> calculate_ranks([50, 50, 50, 50]) [1, 1, 1, 1] >>> calculate_ranks([80]) [1] >>> calculate_ranks([100, 90, 80, 70, 60]) [1, 2, 3, 4, 5] >>> calculate_ranks([60, 70, 80, 90, 100]) [5, 4, 3, 2, 1] >>> calculate_ranks([100, 50, 100, 25, 50]) [1, 3, 1, 5, 3]","solution":"def calculate_ranks(scores): This function takes a list of scores and returns a list of ranks based on the scores. # Pairing original indices with scores indexed_scores = list(enumerate(scores)) # Sorting by scores in descending order indexed_scores.sort(key=lambda x: -x[1]) ranks = [0] * len(scores) current_rank = 1 prev_score = indexed_scores[0][1] for idx, (original_index, score) in enumerate(indexed_scores): if score != prev_score: current_rank = idx + 1 ranks[original_index] = current_rank prev_score = score return ranks"},{"question":"def num_paths(n: int) -> int: Returns the number of distinct paths in an n x n board from top-left corner to bottom-right corner, while only moving right or down. >>> num_paths(1) 1 >>> num_paths(2) 2 >>> num_paths(3) 6 >>> num_paths(4) 20 >>> num_paths(5) 70","solution":"def num_paths(n): Returns the number of distinct paths in an n x n board from top-left corner to bottom-right corner, while only moving right or down. # Create a 2D dp array with dimensions (n + 1) x (n + 1) dp = [[0] * (n + 1) for _ in range(n + 1)] # Starting position (1, 1) dp[1][1] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if i == 1 and j == 1: continue # The number of ways to reach (i, j) is the sum of ways to reach (i-1, j) and (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n][n]"},{"question":"def min_moves_to_reach_bottom_right(m, n, k, l, p, q, a, b): Determine the minimum number of moves required for Tommy's bulldozer to reach the bottom-right corner of the grid, while avoiding Jerry's bulldozer. Args: m : int : number of rows in the grid n : int : number of columns in the grid k : int : number of rows in Tommy's bulldozer l : int : number of columns in Tommy's bulldozer p : int : number of rows in Jerry's bulldozer q : int : number of columns in Jerry's bulldozer a : int : top-left row coordinate of Jerry's bulldozer b : int : top-left column coordinate of Jerry's bulldozer Returns: int : the minimum number of moves required, or -1 if it is not possible >>> min_moves_to_reach_bottom_right(10, 10, 2, 2, 2, 2, 3, 4) 16 >>> min_moves_to_reach_bottom_right(5, 5, 1, 1, 1, 1, 3, 3) 8 >>> min_moves_to_reach_bottom_right(5, 5, 2, 2, 1, 3, 2, 2) 6 >>> min_moves_to_reach_bottom_right(5, 5, 2, 2, 3, 3, 2, 2) -1 >>> min_moves_to_reach_bottom_right(500, 500, 1, 1, 2, 2, 250, 250) 998 pass","solution":"from collections import deque def min_moves_to_reach_bottom_right(m, n, k, l, p, q, a, b): # The grid will be represented by a 2D list for marking visited cells. grid = [[0]*n for _ in range(m)] # Mark cells occupied by Jerry's bulldozer as obstacles for i in range(a, a + p): for j in range(b, b + q): grid[i][j] = -1 # Directions for moving right and down directions = [(1, 0), (0, 1)] # BFS for finding the shortest path queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set([(0, 0)]) while queue: row, col, moves = queue.popleft() # Check if the current position is the bottom-right corner if row == m - k and col == n - l: return moves # Explore the next positions (down, right) for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row <= m - k and 0 <= new_col <= n - l and (new_row, new_col) not in visited: # Check if the placed Tommy's bulldozer fits in the new position avoiding Jerry's bulldozer can_place = True for i in range(new_row, new_row + k): for j in range(new_col, new_col + l): if grid[i][j] == -1: can_place = False break if not can_place: break if can_place: queue.append((new_row, new_col, moves + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def maximum_message_time(m: int, n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the maximum time it takes to send the message from the capital city (city 1) to any other city. Args: m: Integer, number of cities. n: Integer, number of roads. roads: List of tuples, each containing three integers u, v, and w, where u and v are cities connected by a road of length w (0 or 1). Returns: Integer, the maximum time taken to send a message from city 1 to any other city. Example: >>> maximum_message_time(3, 3, [(1, 2, 0), (2, 3, 1), (1, 3, 1)]) 1 >>> maximum_message_time(4, 3, [(1, 2, 0), (2, 3, 0), (3, 4, 0)]) 0 >>> maximum_message_time(4, 4, [(1, 2, 0), (2, 3, 1), (1, 3, 1), (3, 4, 1)]) 2","solution":"import heapq def maximum_message_time(m, n, roads): def dijkstra(graph, start): min_heap = [(0, start)] distances = {i: float('inf') for i in range(1, m + 1)} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances graph = {i: [] for i in range(1, m+1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) distances = dijkstra(graph, 1) return max(distances.values()) # Example usage m = 3 n = 3 roads = [(1, 2, 0), (2, 3, 1), (1, 3, 1)] print(maximum_message_time(m, n, roads)) # Output: 1"},{"question":"import math from typing import List, Tuple def largest_square_side(T: int, dimensions: List[Tuple[int, int]]) -> List[int]: Given T test cases of dimensions (W, H), return the side length of the largest possible square plot. Args: T (int): Number of test cases. dimensions (List[Tuple[int, int]]): List of tuples containing W and H for each test case. Returns: List[int]: List containing the side length of the largest square plot for each test case. Examples: >>> largest_square_side(3, [(10, 15), (8, 12), (9, 7)]) [5, 4, 1] >>> largest_square_side(2, [(6, 6), (100, 100)]) [6, 100] >>> largest_square_side(1, [(1000000000, 1)]) [1] >>> largest_square_side(2, [(17, 19), (23, 29)]) [1, 1] >>> largest_square_side(2, [(1000000, 500000), (123456, 789012)]) [500000, 12]","solution":"import math def largest_square_side(T, dimensions): Given T test cases of dimensions (W, H), return the side length of the largest possible square plot. Args: T (int): Number of test cases. dimensions (List[Tuple[int, int]]): List of tuples containing W and H for each test case. Returns: List[int]: List containing the side length of the largest square plot for each test case. result = [] for W, H in dimensions: result.append(math.gcd(W, H)) return result"},{"question":"def can_transform_sequence(n, initial, target): Determines if it is possible to transform the initial sequence into the target sequence using the allowed operation any number of times. Parameters: n (int): The number of elements in the sequence. initial (list): The initial sequence of integers. target (list): The target sequence of integers. Returns: str: \\"Yes\\" if transformation is possible, \\"No\\" otherwise. def test_example_case(): assert can_transform_sequence(4, [5, 1, 3, 7], [8, 4, 1, 3]) == \\"Yes\\" def test_case_all_ones(): assert can_transform_sequence(3, [1, 1, 1], [1, 1, 1]) == \\"Yes\\" def test_case_different_gcds(): assert can_transform_sequence(3, [6, 12, 18], [2, 4, 8]) == \\"No\\" def test_minimum_elements_case(): assert can_transform_sequence(1, [1], [1]) == \\"Yes\\" assert can_transform_sequence(1, [1], [2]) == \\"No\\" def test_mixed_case(): assert can_transform_sequence(4, [6, 21, 14, 35], [1, 7, 14, 21]) == \\"Yes\\" def test_larger_set(): assert can_transform_sequence(10, [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024], [1] * 10) == \\"No\\"","solution":"def can_transform_sequence(n, initial, target): Determines if it is possible to transform the initial sequence into the target sequence using the allowed operation any number of times. Parameters: n (int): The number of elements in the sequence. initial (list): The initial sequence of integers. target (list): The target sequence of integers. Returns: str: \\"Yes\\" if transformation is possible, \\"No\\" otherwise. def gcd(x, y): while y: x, y = y, x % y return x def reduce_to_gcd(seq): current_gcd = seq[0] for num in seq[1:]: current_gcd = gcd(current_gcd, num) return current_gcd initial_gcd = reduce_to_gcd(initial) target_gcd = reduce_to_gcd(target) if initial_gcd == target_gcd: return \\"Yes\\" return \\"No\\""},{"question":"def game_strategy(n: int, a: List[int]) -> str: Determines if Alice has a winning strategy given array a of length n. Parameters: n (int): The number of elements in the array. a (list): A list of integers. Returns: str: \\"Alice\\" if Alice has a winning strategy, \\"Bob\\" otherwise. >>> game_strategy(4, [1, 2, 3, 4]) \\"Bob\\" >>> game_strategy(3, [2, 2, 2]) \\"Bob\\"","solution":"def game_strategy(n, a): Determines if Alice has a winning strategy given array a of length n. Parameters: n (int): The number of elements in the array. a (list): A list of integers. Returns: str: \\"Alice\\" if Alice has a winning strategy, \\"Bob\\" otherwise. return \\"Alice\\" if n % 2 == 1 else \\"Bob\\""},{"question":"def compress_ranges(arr): Convert an array of positive integers into a string of comma-separated values (CSV) where each group of consecutive numbers (1, 2, 3, ...) is represented in a compressed form as \\"start-end\\". >>> compress_ranges([1, 2, 3, 7, 8, 9, 15, 16, 20]) '1-3,7-9,15-16,20' >>> compress_ranges([5]) '5' >>> compress_ranges([1, 3, 5, 7, 9]) '1,3,5,7,9' >>> compress_ranges([100000]) '100000' # Sort the array arr.sort() # Initialize the result list result = [] # Initialize the start and end of the current range start = arr[0] end = arr[0] for i in range(1, len(arr)): if arr[i] == end + 1: end = arr[i] else: if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") start = arr[i] end = arr[i] # Add the last range if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") # Join and return the result as a comma-separated string return \\",\\".join(result)","solution":"def compress_ranges(arr): if not arr: return \\"\\" # Sort the array arr.sort() # Initialize the result list result = [] # Initialize the start and end of the current range start = arr[0] end = arr[0] for i in range(1, len(arr)): if arr[i] == end + 1: end = arr[i] else: if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") start = arr[i] end = arr[i] # Add the last range if start == end: result.append(str(start)) else: result.append(f\\"{start}-{end}\\") # Join and return the result as a comma-separated string return \\",\\".join(result)"},{"question":"def count_segment_changes(n: int, m: int, k: int, t: int, t1: int, t2: int) -> int: Simulates a billboard from a starting time to an ending time and counts how many times k or more segments change at the same second. >>> count_segment_changes(3, 9, 4, 10000, 120, 129) 2 >>> count_segment_changes(1, 9, 1, 60, 5, 10) 5 >>> count_segment_changes(8, 9, 1, 1000000, 123456, 123460) 4 >>> count_segment_changes(1, 1, 1, 1, 0, 0) 0 >>> count_segment_changes(8, 9, 20, 1000000, 999995, 999999) 0","solution":"def count_segment_changes(n, m, k, t, t1, t2): segment_changes = { \\"0\\": 6, \\"1\\": 2, \\"2\\": 5, \\"3\\": 5, \\"4\\": 4, \\"5\\": 5, \\"6\\": 6, \\"7\\": 3, \\"8\\": 7, \\"9\\": 6 } def count_changes(digit1, digit2): changes = sum(1 for d1, d2 in zip(digit1, digit2) if d1 != d2) return changes def str_padded(num, length): return str(num).zfill(length) count = 0 for second in range(t1 + 1, t2 + 1): prev = str_padded(second - 1, n) curr = str_padded(second, n) changes = 0 for p, c in zip(prev, curr): if p != c: changes += abs(segment_changes[p] - segment_changes[c]) if changes >= k: count += 1 return count"},{"question":"def can_reach_last_column(n: int, m: int, grid: List[str]) -> str: Determine if there exists a path from any open cell in the first column to any open cell in the last column. >>> can_reach_last_column(4, 5, [\\".....\\", \\".#...\\", \\"..#..\\", \\".....\\"]) \\"YES\\" >>> can_reach_last_column(3, 4, [\\".#..\\", \\".#..\\", \\".#..\\"]) \\"NO\\"","solution":"def can_reach_last_column(n, m, grid): from collections import deque def bfs(starting_points): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set(starting_points) queue = deque(starting_points) while queue: x, y = queue.popleft() if y == m - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False starting_points = [(i, 0) for i in range(n) if grid[i][0] == '.'] if not starting_points: return \\"NO\\" if bfs(starting_points): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def can_place_items_on_tables(n: int, capacities: List[int], m: int, prices: List[int]) -> str: Determine if it is possible to place all the items on the tables following the given conditions: - All items of the same price category are placed together on the same table. - The number of items on any table should not exceed its capacity. - Each table can hold items of one or more categories but all in one block without mixing categories. Args: n (int): the number of tables capacities (List[int]): the capacities of the tables m (int): the number of items prices (List[int]): the prices of the items Returns: str: \\"YES\\" if it is possible to place all the items on the tables following the given conditions. Otherwise, \\"NO\\". Examples: >>> can_place_items_on_tables(3, [10, 8, 4], 12, [5, 7, 14, 62, 28, 30, 56, 76, 85, 24, 22, 19]) \\"YES\\" >>> can_place_items_on_tables(2, [5, 4], 8, [1, 5, 6, 7, 8, 9, 10, 12]) \\"NO\\" def test_can_place_items_on_tables(): assert can_place_items_on_tables(3, [10, 8, 4], 12, [5, 7, 14, 62, 28, 30, 56, 76, 85, 24, 22, 19]) == \\"YES\\" assert can_place_items_on_tables(2, [5, 4], 8, [1, 5, 6, 7, 8, 9, 10, 12]) == \\"NO\\" assert can_place_items_on_tables(4, [15, 10, 10, 5], 10, [20, 25, 30, 35, 40, 45, 50, 60, 70, 80]) == \\"YES\\" assert can_place_items_on_tables(1, [10], 5, [2, 3, 4, 5, 6]) == \\"YES\\" assert can_place_items_on_tables(2, [0, 0], 1, [2]) == \\"NO\\" def test_can_place_items_on_tables_edge_cases(): assert can_place_items_on_tables(1, [1], 1, [1]) == \\"YES\\" assert can_place_items_on_tables(5, [1, 1, 1, 1, 1], 5, [61, 62, 63, 64, 65]) == \\"NO\\" assert can_place_items_on_tables(3, [100, 100, 100], 3, [20, 40, 80]) == \\"YES\\"","solution":"def can_place_items_on_tables(n, capacities, m, prices): low_price_count = len([price for price in prices if 1 <= price <= 25]) medium_price_count = len([price for price in prices if 26 <= price <= 60]) high_price_count = len([price for price in prices if 61 <= price <= 100]) capacities.sort(reverse=True) def can_fit_items(item_count): for i in range(n): if capacities[i] >= item_count: return i return -1 for count in [low_price_count, medium_price_count, high_price_count]: if count == 0: continue table_index = can_fit_items(count) if table_index == -1: return \\"NO\\" capacities[table_index] -= count return \\"YES\\""},{"question":"def kruskal_minimum_risk(n, roads): Kruskal's algorithm to find the minimum total risk factor required to connect all territories. # Sort the roads by their risk factor (weight) roads.sort(key=lambda x: x[2]) # Helper function to find the parent of a node with path compression def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to union two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Initialize parent and rank arrays parent = [i for i in range(n)] rank = [0] * n # Minimum total risk factor min_risk = 0 # Process each road for u, v, w in roads: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) # If u and v are not in the same subset, include this edge if root_u != root_v: min_risk += w union(parent, rank, root_u, root_v) return min_risk def minimum_total_risk(n, m, roads): Determine the minimum total risk factor required to connect all territories in the kingdom. Parameters: n (int): The number of territories. m (int): The number of roads. roads (List[List[int]]): List of roads where each road is represented by [u, v, w] indicating a road between territory u and v with a risk factor w. Returns: int: The minimum total risk factor. >>> minimum_total_risk(4, 5, [[1, 2, 3], [1, 3, 1], [2, 3, 3], [2, 4, 6], [3, 4, 5]]) 9 >>> minimum_total_risk(2, 1, [[1, 2, 7]]) 7","solution":"def kruskal_minimum_risk(n, roads): Kruskal's algorithm to find the minimum spanning tree's total risk factor. # Sort the roads by their risk factor (weight) roads.sort(key=lambda x: x[2]) # Helper function to find the parent of a node with path compression def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to union two subsets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Initialize parent and rank arrays parent = [i for i in range(n)] rank = [0] * n # Minimum total risk factor min_risk = 0 # Process each road for u, v, w in roads: u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) # If u and v are not in the same subset, include this edge if root_u != root_v: min_risk += w union(parent, rank, root_u, root_v) return min_risk def minimum_total_risk(n, m, roads): return kruskal_minimum_risk(n, roads)"},{"question":"class Node: def __init__(self, is_directory=True): self.is_directory = is_directory self.children = {} # Only used if it's a directory class Filesystem: def __init__(self): self.root = Node(is_directory=True) def _navigate(self, path): Navigate to the node specified by the path. parts = path.strip('/').split('/') current = self.root for part in parts: if part and part in current.children: current = current.children[part] elif part: return None # Path does not exist return current def create_dir(self, path): Create a directory at the specified path. parts = path.strip('/').split('/') current = self.root for part in parts: if part: if part not in current.children: current.children[part] = Node(is_directory=True) current = current.children[part] def create_file(self, path): Create a file at the specified path. parts = path.strip('/').split('/') *dirs, file_name = parts current = self.root for part in dirs: if part: if part not in current.children: current.children[part] = Node(is_directory=True) current = current.children[part] current.children[file_name] = Node(is_directory=False) def move(self, src_path, dest_path): Move a file or directory from src_path to dest_path. src_parts = src_path.strip('/').split('/') *src_dirs, src_name = src_parts src_parent = self._navigate('/'.join(src_dirs)) if src_parent and src_name in src_parent.children: node = src_parent.children.pop(src_name) dest_parts = dest_path.strip('/').split('/') *dest_dirs, dest_name = dest_parts dest_parent = self._navigate('/'.join(dest_dirs)) if dest_parent: dest_parent.children[dest_name] = node def delete(self, path): Delete a file or directory at the specified path. parts = path.strip('/').split('/') *dirs, name = parts parent = self._navigate('/'.join(dirs)) if parent and name in parent.children: del parent.children[name] def list_dir(self, path): List all items at the specified path. current = self._navigate(path) if current: dirs = [] files = [] for name, node in current.children.items(): if node.is_directory: dirs.append(name) else: files.append(name) result = sorted(dirs) + sorted(files) return result return [] def main(): import sys input = sys.stdin.read data = input().strip().split('n') q = int(data[0].strip()) operations = data[1:] fs = Filesystem() result = [] for operation in operations: parts = operation.split() command = parts[0] if command == 'CREATE_DIR': fs.create_dir(parts[1]) elif command == 'CREATE_FILE': fs.create_file(parts[1]) elif command == 'MOVE': fs.move(parts[1], parts[2]) elif command == 'DELETE': fs.delete(parts[1]) elif command == 'LIST': result.extend(fs.list_dir(parts[1])) result.append('') if result and result[-1] == '': result.pop() print('n'.join(result)) if __name__ == '__main__': main() from solution import Filesystem def test_create_and_list(): fs = Filesystem() fs.create_dir('/home') fs.create_dir('/home/user') fs.create_file('/home/user/file1.txt') fs.create_file('/home/user/file2.txt') fs.create_dir('/home/user/docs') assert fs.list_dir('/home/user') == ['docs', 'file1.txt', 'file2.txt'] def test_move_file(): fs = Filesystem() fs.create_dir('/home') fs.create_dir('/home/user') fs.create_file('/home/user/file1.txt') fs.create_dir('/home/user/docs') fs.move('/home/user/file1.txt', '/home/user/docs/file1.txt') assert fs.list_dir('/home/user') == ['docs'] assert fs.list_dir('/home/user/docs') == ['file1.txt'] def test_move_directory(): fs = Filesystem() fs.create_dir('/home') fs.create_dir('/home/user') fs.create_dir('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') fs.move('/home/user/docs', '/home/user/archives') assert fs.list_dir('/home/user') == ['archives'] assert fs.list_dir('/home/user/archives') == ['file1.txt'] def test_delete_file(): fs = Filesystem() fs.create_dir('/home') fs.create_dir('/home/user') fs.create_file('/home/user/file1.txt') fs.create_file('/home/user/file2.txt') fs.delete('/home/user/file2.txt') assert fs.list_dir('/home/user') == ['file1.txt'] def test_delete_directory(): fs = Filesystem() fs.create_dir('/home') fs.create_dir('/home/user') fs.create_dir('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') fs.delete('/home/user/docs') assert fs.list_dir('/home/user') == []","solution":"class Node: def __init__(self, is_directory=True): self.is_directory = is_directory self.children = {} # Only used if it's a directory class Filesystem: def __init__(self): self.root = Node(is_directory=True) def _navigate(self, path): Navigate to the node specified by the path. parts = path.strip('/').split('/') current = self.root for part in parts: if part and part in current.children: current = current.children[part] elif part: return None # Path does not exist return current def create_dir(self, path): Create a directory at the specified path. parts = path.strip('/').split('/') current = self.root for part in parts: if part: if part not in current.children: current.children[part] = Node(is_directory=True) current = current.children[part] def create_file(self, path): Create a file at the specified path. parts = path.strip('/').split('/') *dirs, file_name = parts current = self.root for part in dirs: if part: if part not in current.children: current.children[part] = Node(is_directory=True) current = current.children[part] current.children[file_name] = Node(is_directory=False) def move(self, src_path, dest_path): Move a file or directory from src_path to dest_path. src_parts = src_path.strip('/').split('/') *src_dirs, src_name = src_parts src_parent = self._navigate('/'.join(src_dirs)) if src_parent and src_name in src_parent.children: node = src_parent.children.pop(src_name) dest_parts = dest_path.strip('/').split('/') *dest_dirs, dest_name = dest_parts dest_parent = self._navigate('/'.join(dest_dirs)) if dest_parent: dest_parent.children[dest_name] = node def delete(self, path): Delete a file or directory at the specified path. parts = path.strip('/').split('/') *dirs, name = parts parent = self._navigate('/'.join(dirs)) if parent and name in parent.children: del parent.children[name] def list_dir(self, path): List all items at the specified path. current = self._navigate(path) if current: dirs = [] files = [] for name, node in current.children.items(): if node.is_directory: dirs.append(name) else: files.append(name) result = sorted(dirs) + sorted(files) return result return [] def main(): import sys input = sys.stdin.read data = input().strip().split('n') q = int(data[0].strip()) operations = data[1:] fs = Filesystem() result = [] for operation in operations: parts = operation.split() command = parts[0] if command == 'CREATE_DIR': fs.create_dir(parts[1]) elif command == 'CREATE_FILE': fs.create_file(parts[1]) elif command == 'MOVE': fs.move(parts[1], parts[2]) elif command == 'DELETE': fs.delete(parts[1]) elif command == 'LIST': result.extend(fs.list_dir(parts[1])) result.append('') if result and result[-1] == '': result.pop() print('n'.join(result)) if __name__ == '__main__': main()"},{"question":"def calculate_total_power(p: int, c: int, producer_info: List[List[int]]) -> List[int]: Calculate the total power received by each Consumer crystal. Args: p : int : Number of the Producer crystals. c : int : Number of the Consumer crystals. producer_info : List[List[int]] : Each list contains the information for each Producer crystal consisting of number of connected Consumer crystals followed by pairs of (Consumer index, power) values. Returns: List[int] : Total power received by each Consumer crystal. >>> calculate_total_power(2, 3, [[2, 1, 30, 2, 40], [3, 2, 20, 3, 10, 1, 50]]) [80, 60, 10] >>> calculate_total_power(1, 1, [[1, 1, 10]]) [10] >>> calculate_total_power(2, 4, [[2, 1, 50, 2, 50], [2, 3, 100, 4, 100]]) [50, 50, 100, 100] >>> calculate_total_power(3, 5, [[3, 1, 10, 2, 20, 3, 30], [2, 2, 40, 4, 50], [2, 3, 60, 5, 70]]) [10, 60, 90, 50, 70] >>> calculate_total_power(2, 3, [[1, 1, 0], [2, 2, 0, 3, 0]]) [0, 0, 0] >>> calculate_total_power(4, 1, [[1, 1, 10], [1, 1, 20], [1, 1, 30], [1, 1, 40]]) [100]","solution":"def calculate_total_power(p, c, producer_info): # Initialize a list to store the total power received by each Consumer crystal consumer_power = [0] * c for info in producer_info: x = info[0] # Number of Consumer crystals this Producer is connected to connections = info[1:] # Remaining part contains the (ci, wi) pairs for i in range(x): ci = connections[2*i] - 1 # Consumer index (making it zero-indexed) wi = connections[2*i + 1] # Power provided to this Consumer consumer_power[ci] += wi # Accumulate the power return consumer_power"},{"question":"def minimum_fare(n: int, fares: List[int], x: int, y: int) -> int: Calculate the minimum fare required to travel between Bus Stops x and y in a loop. Parameters: n (int): Number of bus stops. fares (list of int): The fare between adjacent bus stops. x (int): The start bus stop. y (int): The destination bus stop. Returns: int: The minimum fare required to travel between the given bus stops. Examples: >>> minimum_fare(5, [10, 20, 30, 40, 50], 1, 3) 30 >>> minimum_fare(5, [10, 20, 30, 40, 50], 3, 1) 30 >>> minimum_fare(5, [10, 20, 30, 40, 50], 1, 5) 50 >>> minimum_fare(4, [10, 20, 30, 40], 1, 4) 40 >>> minimum_fare(4, [10, 20, 30, 40], 4, 1) 40 >>> minimum_fare(5, [10, 20, 30, 40, 50], 2, 2) 0","solution":"def minimum_fare(n, fares, x, y): Calculate the minimum fare required to travel between Bus Stops x and y in a loop. Parameters: n (int): Number of bus stops. fares (list of int): The fare between adjacent bus stops. x (int): The start bus stop. y (int): The destination bus stop. Returns: int: The minimum fare required to travel between the given bus stops. # Adjust indices to be zero-based x -= 1 y -= 1 if x == y: return 0 # Calculate fare in clockwise direction clockwise_fare = sum(fares[min(x, y):max(x, y)]) # Calculate fare in counter-clockwise direction counterclockwise_fare = sum(fares) - clockwise_fare # Return the minimum of the two computed fares return min(clockwise_fare, counterclockwise_fare)"},{"question":"def calculate_total_revenue(n: int, m: int, prices: List[int], discounts: List[Tuple[int, int]]) -> int: Calculate the total revenue after applying the best discounts to gadgets. Parameters: n (int): Number of gadgets. m (int): Number of discount offers. prices (list): Initial prices of the gadgets. discounts (list): List of tuples containing (gadget_id, discount_amount). Returns: int: Total revenue after applying the best discounts. >>> calculate_total_revenue(4, 3, [100, 200, 300, 400], [(1, 50), (2, 100), (3, 150)]) 700 >>> calculate_total_revenue(3, 0, [100, 200, 300], []) 600 >>> calculate_total_revenue(2, 2, [100, 100], [(1, 50), (2, 50)]) 100 >>> calculate_total_revenue(2, 3, [100, 200], [(1, 20), (1, 50), (2, 100)]) 150 >>> calculate_total_revenue(3, 3, [150, 250, 350], [(1, 150), (2, 250), (3, 350)]) 0","solution":"def calculate_total_revenue(n, m, prices, discounts): Calculate the total revenue after applying the best discounts to gadgets. Parameters: n (int): Number of gadgets. m (int): Number of discount offers. prices (list): Initial prices of the gadgets. discounts (list): List of tuples containing (gadget_id, discount_amount). Returns: int: Total revenue after applying the best discounts. # List to store the best discount for each gadget, initialized to 0 best_discounts = [0] * n # Process each discount and update the best discount for the respective gadget for gadget_id, discount_amount in discounts: # Apply the discount, ensure the best discount is considered best_discounts[gadget_id - 1] = max(best_discounts[gadget_id - 1], discount_amount) # Calculate the total revenue after applying the best discounts total_revenue = 0 for i in range(n): total_revenue += prices[i] - best_discounts[i] return total_revenue"},{"question":"import math from typing import List, Tuple def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points. Args: p1: Tuple containing coordinates of the first point (x1, y1). p2: Tuple containing coordinates of the second point (x2, y2). Returns: The Euclidean distance between the two points. pass def closest_pair_of_points(points: List[Tuple[int, int]]) -> float: Determine the closest pair of points among the given set and return the minimum distance. Args: points: A list of tuples where each tuple contains the coordinates of a point (x, y). Returns: The minimum distance between any two points in the list. Example: >>> closest_pair_of_points([(0, 0), (3, 4), (7, 7), (3, 0)]) 3.0 >>> closest_pair_of_points([(0, 0), (0, 0)]) 0.0 >>> closest_pair_of_points([(1, 1), (1, 4), (1, 5), (3, 1), (2, 2)]) 1.0 pass","solution":"import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def closest_pair_of_points(points): points = sorted(points, key=lambda x: x[0]) def closest_pair_rec(start, end): if end - start <= 3: min_dist = float('inf') for i in range(start, end): for j in range(i + 1, end): min_dist = min(min_dist, euclidean_distance(points[i], points[j])) return min_dist mid = (start + end) // 2 mid_x = points[mid][0] min_dist = min(closest_pair_rec(start, mid), closest_pair_rec(mid, end)) strip = [] for i in range(start, end): if abs(points[i][0] - mid_x) < min_dist: strip.append(points[i]) strip = sorted(strip, key=lambda x: x[1]) for i in range(len(strip)): for j in range(i + 1, len(strip)): if (strip[j][1] - strip[i][1]) >= min_dist: break min_dist = min(min_dist, euclidean_distance(strip[i], strip[j])) return min_dist return closest_pair_rec(0, len(points))"},{"question":"from typing import List def min_operations_to_transform(a: List[int], b: List[int]) -> int: Calculates the minimum number of operations needed to transform array \`a\` into array \`b\` by changing elements of array \`a\` to match corresponding elements in array \`b\`. :param a: List of integers representing array \`a\`. :param b: List of integers representing array \`b\`. :return: Integer representing the minimum number of operations required. pass import pytest def test_example_case(): assert min_operations_to_transform([1, 2, 3, 4, 5], [1, 3, 3, 2, 5]) == 2 def test_no_changes_needed(): assert min_operations_to_transform([1, 2, 3], [1, 2, 3]) == 0 def test_all_elements_different(): assert min_operations_to_transform([1, 2, 3], [4, 5, 6]) == 3 def test_some_elements_different(): assert min_operations_to_transform([1, 2, 3, 4], [1, 2, 4, 3]) == 2 def test_single_element(): assert min_operations_to_transform([1], [2]) == 1 assert min_operations_to_transform([1], [1]) == 0 def test_large_arrays(): a = list(range(1000)) b = list(range(1, 1001)) assert min_operations_to_transform(a, b) == 1000","solution":"def min_operations_to_transform(a, b): Calculates the minimum number of operations needed to transform array \`a\` into array \`b\` by changing elements of array \`a\` to match corresponding elements in array \`b\`. :param a: List of integers representing array \`a\`. :param b: List of integers representing array \`b\`. :return: Integer representing the minimum number of operations required. min_ops = 0 for i in range(len(a)): if a[i] != b[i]: min_ops += 1 return min_ops"},{"question":"def minimum_moves_to_sort(arr: List[int]) -> int: Returns the minimum number of moves required to sort the array using adjacent swaps. >>> minimum_moves_to_sort([3, 2, 1]) 3 >>> minimum_moves_to_sort([1, 2, 3]) 0 >>> minimum_moves_to_sort([4, 3, 2, 1]) 6 >>> minimum_moves_to_sort([2, 3, 2, 3, 1]) 5 pass def test_minimum_moves_to_sort(): assert minimum_moves_to_sort([3, 2, 1]) == 3 assert minimum_moves_to_sort([1, 2, 3]) == 0 assert minimum_moves_to_sort([4, 3, 2, 1]) == 6 def test_minimum_moves_to_sort_with_duplicates(): assert minimum_moves_to_sort([2, 3, 2, 3, 1]) == 5 assert minimum_moves_to_sort([4, 3, 3, 1]) == 5 def test_minimum_moves_to_sort_large_array(): assert minimum_moves_to_sort(list(range(1000, 0, -1))) == (1000 * 999) // 2 # Sum of first (n-1) natural numbers def test_minimum_moves_to_sort_single_element(): assert minimum_moves_to_sort([1]) == 0","solution":"def minimum_moves_to_sort(arr): Returns the minimum number of moves required to sort the array using adjacent swaps. n = len(arr) swaps = 0 for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps"},{"question":"def min_operations(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2 using edit distance algorithm. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"abc\\", \\"yabd\\") 2 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3","solution":"def min_operations(s1, s2): Returns the minimum number of operations required to transform s1 into s2 using edit distance algorithm. n = len(s1) m = len(s2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[n][m]"},{"question":"def triangular_number(n: int) -> int: Returns the n-th triangular number. Parameters: n (int): Position in the triangular number sequence (1 ≤ n ≤ 10000) Returns: int: The n-th triangular number Example: >>> triangular_number(5) 15 >>> triangular_number(1) 1 >>> triangular_number(10) 55 >>> triangular_number(10000) 50005000 >>> triangular_number(6) 21 >>> triangular_number(7) 28","solution":"def triangular_number(n): Returns the n-th triangular number. Parameters: n (int): Position in the triangular number sequence (1 ≤ n ≤ 10000) Returns: int: The n-th triangular number return n * (n + 1) // 2"},{"question":"def max_energy_sum(n: int, energies: List[int]) -> int: Calculate the maximum possible total energy sum of the squad under given conditions. >>> max_energy_sum(6, [3, 2, 5, 10, 7, 1]) 15 >>> max_energy_sum(5, [3, 2, 7, 10, 12]) 22 >>> max_energy_sum(2, [2, 4]) 4 >>> max_energy_sum(1, [5]) 5 >>> max_energy_sum(0, []) 0 >>> max_energy_sum(5, [10**9, 2, 10**9, 2, 10**9]) 3000000000","solution":"def max_energy_sum(n, energies): if n == 0: return 0 elif n == 1: return energies[0] include = energies[0] exclude = 0 for i in range(1, n): new_exclude = max(include, exclude) include = exclude + energies[i] exclude = new_exclude return max(include, exclude)"},{"question":"def interpolate_bacteria_growth(n: int, data: List[int]) -> List[int]: Fills in missing values in bacteria growth data using linear interpolation. >>> interpolate_bacteria_growth(5, [2, -1, 6, -1, 10]) == [2, 4, 6, 8, 10] >>> interpolate_bacteria_growth(6, [1, -1, -1, 16, 19, -1]) == [1, 6, 11, 16, 19, 19] >>> interpolate_bacteria_growth(6, [5, -1, -1, -1, -1, 20]) == [5, 8, 11, 14, 17, 20] >>> interpolate_bacteria_growth(3, [1, -1, 10]) == [1, 5, 10] >>> interpolate_bacteria_growth(7, [2, 4, -1, -1, 10, -1, 14]) == [2, 4, 6, 8, 10, 12, 14] >>> interpolate_bacteria_growth(4, [-1, -1, -1, 10]) == [10, 10, 10, 10] >>> interpolate_bacteria_growth(2, [10, -1]) == [10, 10] >>> interpolate_bacteria_growth(2, [-1, 10]) == [10, 10] >>> interpolate_bacteria_growth(4, [1, -1, -1, 4]) == [1, 2, 3, 4] >>> interpolate_bacteria_growth(5, [1, -1, 3, -1, 5]) == [1, 2, 3, 4, 5]","solution":"def interpolate_bacteria_growth(n, data): Fills in missing values in bacteria growth data using linear interpolation. Parameters: - n: int, number of data points. - data: list of int, the bacteria count at each time point, with -1 representing missing values. Returns: - list of int, the data with missing values filled in. import numpy as np # Convert data to numpy array for advanced indexing and manipulation data = np.array(data) # Iterate over the array to interpolate missing values (-1) i = 0 while i < n: if data[i] == -1: # Find the next known value start = i while i < n and data[i] == -1: i += 1 if i == n: # If no more known values, previous value should be used for all subsequent unknowns data[start:] = data[start-1] else: # Interpolate end = i value_start = data[start-1] value_end = data[end] for j in range(start, end): data[j] = value_start + (value_end - value_start) * (j - start + 1) / (end - start + 1) i += 1 return data.tolist()"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Given a string s consisting of lowercase alphabets and an integer k, find the length of the longest substring of s such that the number of distinct characters in the substring is at most k. >>> longest_substring_with_k_distinct('abcba', 2) 3 >>> longest_substring_with_k_distinct('aaabbcc', 3) 7 import pytest def test_longest_substring_with_k_distinct_simple_cases(): assert longest_substring_with_k_distinct('abcba', 2) == 3 assert longest_substring_with_k_distinct('aaabbcc', 3) == 7 def test_longest_substring_with_k_distinct_single_character(): assert longest_substring_with_k_distinct('a', 1) == 1 assert longest_substring_with_k_distinct('aaaa', 1) == 4 def test_longest_substring_with_k_distinct_no_distinct_characters(): assert longest_substring_with_k_distinct('abcde', 0) == 0 def test_longest_substring_with_k_distinct_large_k(): assert longest_substring_with_k_distinct('abcdefghijklmnopqrstuvwxyz', 26) == 26 def test_longest_substring_with_k_distinct_mixed_case(): assert longest_substring_with_k_distinct('abaccc', 2) == 4 assert longest_substring_with_k_distinct('aabbcc', 1) == 2 def test_longest_substring_with_k_distinct_boundary_cases(): assert longest_substring_with_k_distinct('ab', 1) == 1 assert longest_substring_with_k_distinct('ab', 2) == 2 if __name__ == \\"__main__\\": pytest.main()","solution":"def longest_substring_with_k_distinct(s, k): from collections import defaultdict n = len(s) if k == 0 or n == 0: return 0 left, right = 0, 0 max_length = 0 char_frequency = defaultdict(int) while right < n: char_frequency[s[right]] += 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def min_coins_to_target(n: int, T: int, coins: List[int]) -> int: Returns the minimum number of coins needed to achieve the target sum T, or -1 if it is not possible to achieve T with the given coins. >>> min_coins_to_target(3, 11, [1, 2, 5]) 3 >>> min_coins_to_target(3, 7, [3, 4, 5]) 2 >>> min_coins_to_target(3, 7, [2, 4, 6]) -1 >>> min_coins_to_target(1, 10, [10]) 1 >>> min_coins_to_target(2, 15, [5, 5]) 3 >>> min_coins_to_target(4, 10000, [1, 5, 10, 25]) 400 >>> min_coins_to_target(5, 3, [5, 6, 7, 8, 9]) -1","solution":"def min_coins_to_target(n, T, coins): Returns the minimum number of coins needed to achieve the target sum T, or -1 if it is not possible to achieve T with the given coins. max_value = T + 1 dp = [max_value] * (T + 1) dp[0] = 0 for i in range(1, T + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[T] if dp[T] != max_value else -1 # Example usage: # n = 3, T = 11, coins = [1, 2, 5] # print(min_coins_to_target(3, 11, [1, 2, 5])) # Output: 3"},{"question":"def most_voted_movie(n, votes): Determine the most popular movie based on friends' votes. Parameters: n (int): Number of friends votes (list of str): List of movies voted by each friend Returns: str: Name of the movie that will be chosen >>> most_voted_movie(1, [\\"inception\\"]) == \\"inception\\" >>> most_voted_movie(4, [\\"titanic\\", \\"avengers\\", \\"titanic\\", \\"inception\\"]) == \\"titanic\\" >>> most_voted_movie(5, [\\"titanic\\", \\"avengers\\", \\"inception\\", \\"avengers\\", \\"inception\\"]) == \\"avengers\\" >>> votes = [\\"movie\\" + str(i) for i in range(50000)] + [\\"popular\\", \\"popular\\"] >>> most_voted_movie(50002, votes) == \\"popular\\" >>> most_voted_movie(6, [\\"batman\\", \\"superman\\", \\"batman\\", \\"superman\\", \\"ironman\\", \\"ironman\\"]) == \\"batman\\"","solution":"from collections import Counter def most_voted_movie(n, votes): Determine the most popular movie based on friends' votes. Parameters: n (int): Number of friends votes (list of str): List of movies voted by each friend Returns: str: Name of the movie that will be chosen vote_counts = Counter(votes) max_votes = max(vote_counts.values()) # Find the lexicographically smallest movie with maximum votes most_popular = min(movie for movie in vote_counts if vote_counts[movie] == max_votes) return most_popular"},{"question":"def min_sweetness_difference(n: int, sweetness_levels: List[int]) -> int: Determines the minimum possible absolute difference between the total sweetness levels of two groups. :param n: int :param sweetness_levels: List[int] :return: int >>> min_sweetness_difference(5, [1, 3, 4, 8, 20]) 4 >>> min_sweetness_difference(1, [7]) 7 >>> min_sweetness_difference(2, [5, 5]) 0 >>> min_sweetness_difference(2, [1, 2]) 1 >>> min_sweetness_difference(4, [6, 6, 6, 6]) 0 >>> min_sweetness_difference(5, [1, 1, 1, 1, 1000]) 996 >>> min_sweetness_difference(6, [3, 1, 4, 1, 5, 9]) 1","solution":"def min_sweetness_difference(n, sweetness_levels): Determines the minimum possible absolute difference between the total sweetness levels of two groups. :param n: int :param sweetness_levels: List[int] :return: int total_sum = sum(sweetness_levels) dp = [0] * (total_sum // 2 + 1) for sweetness in sweetness_levels: for j in range(total_sum // 2, sweetness - 1, -1): dp[j] = max(dp[j], dp[j - sweetness] + sweetness) return total_sum - 2 * dp[total_sum // 2]"},{"question":"def unique_paths(m: int, n: int, k: int, blocked_cells: List[Tuple[int, int]]) -> int: Determine the number of unique paths from the top-left to the bottom-right of a m x n grid, considering blocked cells where she cannot step. >>> unique_paths(3, 3, 0, []) 6 >>> unique_paths(3, 3, 1, [(2, 2)]) 2 >>> unique_paths(3, 3, 1, [(1, 1)]) 0 >>> unique_paths(3, 3, 1, [(1, 3)]) 1 >>> unique_paths(5, 5, 0, []) 70 >>> unique_paths(3, 3, 1, [(3, 3)]) 0","solution":"def unique_paths(m, n, k, blocked_cells): Determine the number of unique paths from the top-left to the bottom-right of a m x n grid, considering blocked cells where she cannot step. # Create a dp table with all zeros dp = [[0] * n for _ in range(m)] # Create a set for quick lookup of blocked cells blocked = set((r-1, c-1) for r, c in blocked_cells) # Start position (0,0) shouldn't be blocked if (0, 0) in blocked: return 0 # Initialize the starting point dp[0][0] = 1 # Fill the dp table considering blocked cells for i in range(m): for j in range(n): if (i, j) in blocked: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] # The bottom-right cell has the number of unique paths return dp[m-1][n-1]"},{"question":"def maximize_value(items, capacity): Maximizes the sum of the values of the selected items without exceeding the capacity. Args: items (list): A list of tuples where each tuple consists of two integers, the identifier and the value of an item. capacity (int): An integer representing the maximum number of items that can be selected. Returns: tuple: A tuple containing a list of identifiers of the selected items and the total value of the selected items. >>> maximize_value([(1, 60), (2, 100), (3, 120)], 2) ([3, 2], 220) >>> maximize_value([(1, 10), (2, 20), (3, 30), (4, 40)], 3) ([4, 3, 2], 90) >>> maximize_value([(1, 10), (2, 10), (3, 10)], 2) ([1, 2], 20) >>> maximize_value([(1, 50), (2, 50), (3, 50), (4, 25)], 0) ([], 0) >>> maximize_value([(1, 15), (2, 10), (3, 10)], 1) ([1], 15)","solution":"def maximize_value(items, capacity): Maximizes the sum of the values of the selected items without exceeding the capacity. Args: items (list): A list of tuples where each tuple consists of two integers, the identifier and the value of an item. capacity (int): An integer representing the maximum number of items that can be selected. Returns: tuple: A tuple containing a list of identifiers of the selected items and the total value of the selected items. # Sort items by their values in descending order items_sorted = sorted(items, key=lambda x: x[1], reverse=True) selected_items = [] total_value = 0 current_capacity = 0 for item in items_sorted: if current_capacity < capacity: selected_items.append(item[0]) total_value += item[1] current_capacity += 1 else: break return selected_items, total_value"},{"question":"def longest_increasing_path(n: int, parent: List[int]) -> int: Find the length of the longest path starting from the root of the tree, such that for any node on the path, all nodes previously visited on this path have values less than or equal to the value of the current node. >>> longest_increasing_path(5, [-1, 1, 1, 3, 3]) 3 >>> longest_increasing_path(1, [-1]) 1 >>> longest_increasing_path(6, [-1, 1, 2, 3, 4, 5]) 6 >>> longest_increasing_path(3, [-1, 1, 2]) 3 >>> longest_increasing_path(7, [-1, 1, 1, 2, 2, 4, 4]) 4","solution":"def longest_increasing_path(n, parent): from collections import defaultdict, deque # Build the tree from the parent array tree = defaultdict(list) for child in range(2, n + 1): tree[parent[child - 1]].append(child) def dfs(node, prev_val, depth): max_length = depth for child in tree[node]: if child >= prev_val: max_length = max(max_length, dfs(child, child, depth + 1)) return max_length # Start DFS traversal from the root node 1 return dfs(1, 1, 1)"},{"question":"def min_removals_to_increasing(arr): This function takes an array of integers and returns the minimum number of elements to remove to make the array strictly increasing. >>> min_removals_to_increasing([1]) 0 >>> min_removals_to_increasing([1, 2, 3, 4]) 0 >>> min_removals_to_increasing([1, 3, 2, 4]) 1 >>> min_removals_to_increasing([9, 1, 2, 3, 4]) 1 >>> min_removals_to_increasing([1, 10, 2, 8, 3, 6, 4, 22]) 3 >>> min_removals_to_increasing([5, 5, 5, 5]) 3 >>> min_removals_to_increasing([3, 6, 7, 1, 2]) 2","solution":"def min_removals_to_increasing(arr): This function takes an array of integers and returns the minimum number of elements to remove to make the array strictly increasing. n = len(arr) # dp[i] will be the length of the longest increasing subsequence that ends with arr[i] dp = [1] * n for i in range(n): for j in range(i): if arr[j] < arr[i]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence lis_length = max(dp) # Minimum deletions is the array length minus the length of the LIS return n - lis_length"},{"question":"def max_structures(W: int, S: int, G: int) -> int: Calculate the maximum number of structures that can be built using the given cards. Each structure requires at least two different types of resources and exactly three cards in total. Parameters: W (int): The number of Wood cards. S (int): The number of Stone cards. G (int): The number of Gold cards. Returns: int: The maximum number of structures that can be built. >>> max_structures(3, 2, 1) 2 >>> max_structures(3, 3, 3) 3 >>> max_structures(0, 2, 2) 1 >>> max_structures(3, 3, 0) 2 >>> max_structures(2000000000, 2000000000, 2000000000) 2000000000 >>> max_structures(0, 0, 0) 0 >>> max_structures(0, 5, 5) 3 >>> max_structures(6, 2, 1) 3","solution":"def max_structures(W, S, G): This function calculates the maximum number of structures that can be built. Parameters: W (int): The number of Wood cards. S (int): The number of Stone cards. G (int): The number of Gold cards. Returns: int: The maximum number of structures that can be built. min_two_diff = (W + S + G) // 3 return min(min_two_diff, W + S, S + G, W + G)"},{"question":"import heapq from typing import List, Tuple def minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum time required to travel from the first building to the nth building. :param n: Number of buildings. :param m: Number of roads. :param roads: List of tuples, each containing three integers u, v, and t, where u and v are the buildings connected by the road, and t is the time it takes to travel between the buildings. :return: Minimum travel time from building 1 to building n, or -1 if not possible. >>> minimum_travel_time(4, 5, [(1, 2, 1), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 1)]) 4 >>> minimum_travel_time(4, 2, [(1, 2, 1), (3, 4, 1)]) -1 >>> minimum_travel_time(3, 1, [(1, 3, 10)]) 10 >>> minimum_travel_time(5, 6, [(1, 2, 2), (2, 5, 5), (1, 3, 3), (3, 4, 1), (4, 5, 2), (1, 5, 10)]) 6 >>> minimum_travel_time(2, 1, [(1, 2, 1)]) 1","solution":"import heapq def minimum_travel_time(n, m, roads): graph = [[] for _ in range(n)] for u, v, t in roads: graph[u - 1].append((v - 1, t)) graph[v - 1].append((u - 1, t)) min_time = [float('inf')] * n min_time[0] = 0 priority_queue = [(0, 0)] # (time, building) while priority_queue: curr_time, u = heapq.heappop(priority_queue) if curr_time > min_time[u]: continue for v, t in graph[u]: new_time = curr_time + t if new_time < min_time[v]: min_time[v] = new_time heapq.heappush(priority_queue, (new_time, v)) return min_time[n - 1] if min_time[n - 1] != float('inf') else -1"},{"question":"def max_steps(n: int) -> int: Determine the maximum number of steps k that can be built using n bricks. Args: n (int): The total number of bricks available. Returns: int: The maximum number of steps. Examples: >>> max_steps(10) 4 >>> max_steps(1) 1 >>> max_steps(21) 6 >>> max_steps(6) 3 >>> max_steps(15) 5 >>> max_steps(1000000) 1413","solution":"def max_steps(n): Determine the maximum number of steps k that can be built using n bricks. k = 0 total = 0 while total + (k + 1) <= n: k += 1 total += k return k"},{"question":"def lexicographically_smallest_arrangement(n: int, m: int, garden: List[str]) -> List[str]: Rearrange the plant rows such that the arrangement of flowers within each row is the lexicographically smallest among all possible rearrangements of flowers within that row and only swapping between adjacent rows are allowed. Parameters: n (int): Number of rows m (int): Number of flowers in each row garden (list of str): List of strings representing the rows of flowers Returns: list of str: Lexicographically smallest arrangement of flowers >>> lexicographically_smallest_arrangement(3, 3, [\\"cba\\", \\"fed\\", \\"ghi\\"]) [\\"abc\\", \\"def\\", \\"ghi\\"] >>> lexicographically_smallest_arrangement(1, 3, [\\"zyx\\"]) [\\"xyz\\"] >>> lexicographically_smallest_arrangement(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) [\\"abc\\", \\"def\\", \\"ghi\\"] # Write your implementation here # Unit Tests def test_single_row(): assert lexicographically_smallest_arrangement(1, 3, [\\"zyx\\"]) == [\\"xyz\\"] def test_multiple_rows_already_sorted(): assert lexicographically_smallest_arrangement(3, 3, [\\"abc\\", \\"def\\", \\"ghi\\"]) == [\\"abc\\", \\"def\\", \\"ghi\\"] def test_additional_case_1(): assert lexicographically_smallest_arrangement(3, 3, [\\"cba\\", \\"fed\\", \\"ghi\\"]) == [\\"abc\\", \\"def\\", \\"ghi\\"] def test_additional_case_2(): assert lexicographically_smallest_arrangement(2, 5, [\\"edcba\\", \\"jihgf\\"]) == [\\"abcde\\", \\"fghij\\"] def test_additional_case_3(): assert lexicographically_smallest_arrangement(4, 4, [\\"dcba\\", \\"hgfe\\", \\"lkji\\", \\"ponm\\"]) == [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"] def test_all_identical_rows(): assert lexicographically_smallest_arrangement(3, 4, [\\"aaaa\\", \\"aaaa\\", \\"aaaa\\"]) == [\\"aaaa\\", \\"aaaa\\", \\"aaaa\\"] def test_all_same_letters(): assert lexicographically_smallest_arrangement(2, 4, [\\"zzzz\\", \\"zzzz\\"]) == [\\"zzzz\\", \\"zzzz\\"]","solution":"def lexicographically_smallest_arrangement(n, m, garden): Rearrange the plant rows such that the arrangement of flowers within each row is the lexicographically smallest among all possible rearrangements of flowers within that row and only swapping between adjacent rows are allowed. Parameters: n (int): Number of rows m (int): Number of flowers in each row garden (list of str): List of strings representing the rows of flowers Returns: list of str: Lexicographically smallest arrangement of flowers for i in range(n - 1): for j in range(i, n): if garden[i] > garden[j]: garden[i], garden[j] = garden[j], garden[i] return [''.join(sorted(garden[i])) for i in range(n)] # Example Use Case print(lexicographically_smallest_arrangement(3, 3, [\\"cba\\", \\"fed\\", \\"ghi\\"])) # Expected Output: # ['abc', 'def', 'ghi']"},{"question":"from typing import List def can_sort_by_reversing_k_segments(n: int, k: int, arr: List[int]) -> str: Determines if we can sort the array in non-decreasing order by reversing exactly k segments. >>> can_sort_by_reversing_k_segments(5, 2, [3, 1, 4, 2, 5]) == \\"YES\\" >>> can_sort_by_reversing_k_segments(4, 1, [4, 3, 2, 1]) == \\"NO\\" >>> can_sort_by_reversing_k_segments(3, 1, [1, 2, 3]) == \\"YES\\" >>> can_sort_by_reversing_k_segments(7, 3, [1, 3, 5, 2, 6, 4, 7]) == \\"YES\\" >>> can_sort_by_reversing_k_segments(6, 1, [1, 2, 3, 4, 5, 6]) == \\"YES\\" >>> can_sort_by_reversing_k_segments(6, 1, [6, 5, 4, 3, 2, 1]) == \\"NO\\"","solution":"def can_sort_by_reversing_k_segments(n, k, arr): Determines if we can sort the array in non-decreasing order by reversing exactly k segments. if k >= 2: return \\"YES\\" elif k == 1: return \\"YES\\" if arr == sorted(arr) else \\"NO\\" else: return \\"NO\\" # Example usage print(can_sort_by_reversing_k_segments(5, 2, [3, 1, 4, 2, 5])) # Output: \\"YES\\" print(can_sort_by_reversing_k_segments(4, 1, [4, 3, 2, 1])) # Output: \\"NO\\""},{"question":"def any_path(n: int, m: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum distance for Johnny to travel from city A to city B considering the temporary blockages. Each query should be handled independently. Args: n (int): Number of cities. m (int): Number of roads. edges (List[Tuple[int, int, int]]): List of tuples representing roads with lengths. queries (List[Tuple[int, int]]): List of queries. Returns: List[int]: List of minimum distances for each query. -1 if no path exists. >>> any_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)], [(1, 3)]) [3] >>> any_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)], [(1, 3), (4, 1)]) [3, 4] >>> any_path(4, 2, [(1, 2, 1), (3, 4, 2)], [(1, 3)]) [-1] >>> any_path(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)], [(1, 1)]) [0] >>> any_path(5, 6, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 10), (2, 5, 10)], [(1, 5)]) [10]","solution":"import heapq def dijkstra(n, graph, start, end): Function to find the minimum distance from start to end using Dijkstra's algorithm. distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def any_path(n, m, edges, queries): Function to process edges and queries to find the shortest path distance for each query. results = [] graph = {i: [] for i in range(1, n+1)} # Populate graph with given edges for u, v, l in edges: graph[u].append((v, l)) graph[v].append((u, l)) for a, b in queries: results.append(dijkstra(n, graph, a, b)) return results"},{"question":"import heapq import sys from typing import List, Tuple def find_optimal_planet(n: int, edges: List[Tuple[int, int, int]]) -> int: Finds the optimal planet for the central command such that the maximum travel cost to all other planets is minimized. >>> find_optimal_planet(5, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (2, 5, 3), (3, 4, 1), (4, 5, 5)]) 2 >>> find_optimal_planet(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 1 >>> find_optimal_planet(2, [(1, 2, 10)]) 1 >>> find_optimal_planet(3, [(1, 2, 2), (2, 3, 2), (1, 3, 5)]) 2","solution":"import heapq import sys def dijkstra(graph, n, start): # Initial distances are set to infinity distances = [sys.maxsize] * (n + 1) distances[start] = 0 # Priority queue to process nodes priority_queue = [(0, start)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) # If we already found a shorter path before, continue if current_distance > distances[u]: continue # Process neighbors for neighbor, weight in graph[u]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def find_optimal_planet(n, edges): graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) min_max_distance = sys.maxsize optimal_planet = 1 for i in range(1, n + 1): distances = dijkstra(graph, n, i) max_distance = max(distances[1:]) if max_distance < min_max_distance: min_max_distance = max_distance optimal_planet = i elif max_distance == min_max_distance: optimal_planet = min(optimal_planet, i) return optimal_planet"},{"question":"def min_operations_to_turn_off_bulbs(n: int, bulbs: str) -> int: Determines the minimum number of operations required to turn all bulbs off. Each operation consists of selecting a continuous segment of bulbs and toggling them. Args: n (int): Number of bulbs. bulbs (str): String representing the initial state of the bulbs; '1' is on, '0' is off. Returns: int: Minimum number of operations required to make all bulbs off. >>> min_operations_to_turn_off_bulbs(7, '0101010') 3 >>> min_operations_to_turn_off_bulbs(5, '00000') 0 >>> min_operations_to_turn_off_bulbs(4, '1111') 1 >>> min_operations_to_turn_off_bulbs(6, '101010') 3 >>> min_operations_to_turn_off_bulbs(6, '010101') 3 >>> min_operations_to_turn_off_bulbs(1, '1') 1 >>> min_operations_to_turn_off_bulbs(1, '0') 0","solution":"def min_operations_to_turn_off_bulbs(n, bulbs): Determines the minimum number of operations required to turn all bulbs off. Each operation consists of selecting a continuous segment of bulbs and toggling them. Args: n (int): Number of bulbs. bulbs (str): String representing the initial state of the bulbs; '1' is on, '0' is off. Returns: int: Minimum number of operations required to make all bulbs off. # Edge case for quick return if bulbs == '0' * n: return 0 operations = 0 i = 0 while i < n: # Skip off bulbs while i < n and bulbs[i] == '0': i += 1 # If we find an on bulb, we will need at least one operation if i < n and bulbs[i] == '1': operations += 1 # Move i to the end of this segment of on bulbs while i < n and bulbs[i] == '1': i += 1 return operations"},{"question":"def most_diverse_inventory(matrix): Returns the index of the store with the most diverse inventory. >>> most_diverse_inventory([ ... [1, 2, 3, 4], ... [2, 3, 4, 4], ... [1, 1, 1, 1] ... ]) == 0 >>> most_diverse_inventory([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 0 >>> most_diverse_inventory([ ... [1, 1, 2, 2], ... [3, 3, 4, 4], ... [5, 6, 7, 8] ... ]) == 2 >>> most_diverse_inventory([ ... [10, 10, 10, 10], ... [20, 20, 20, 20], ... [30, 30, 30, 30], ... [40, 40, 40, 50] ... ]) == 3 >>> most_diverse_inventory([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) == 0","solution":"def most_diverse_inventory(matrix): Returns the index of the store with the most diverse inventory. max_unique_count = 0 max_unique_index = 0 for i, row in enumerate(matrix): unique_items = len(set(row)) if unique_items > max_unique_count: max_unique_count = unique_items max_unique_index = i return max_unique_index"},{"question":"def partition_array(arr: List[int]) -> Tuple[int, List[int]]: Partition the array into two non-empty subarrays such that the sum of the elements in the first subarray is greater than the sum of the elements in the second subarray. The function takes a list of integers as input and returns a tuple, where the first element is the number of elements in the first subarray, and the second element is a list of 1-based indices of the elements in the first subarray. >>> partition_array([13, 7, 12, 8, 10]) (3, [1, 2, 4]) >>> partition_array([1, 2, 3, 4, 5, 6]) (3, [6, 5, 4])","solution":"def partition_array(arr): total_sum = sum(arr) half_sum = total_sum / 2 current_sum = 0 indices = [] for i, value in enumerate(arr): current_sum += value indices.append(i + 1) # Convert to 1-based index if current_sum > total_sum - current_sum: break return len(indices), indices"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimum number of operations needed to sort the array for each test case by moving subarrays to the beginning of the array. >>> min_operations_to_sort(3, [(3, [3, 1, 2]), (4, [4, 3, 2, 1]), (5, [1, 2, 3, 4, 5])]) [2, 3, 0] >>> min_operations_to_sort(1, [(5, [2, 2, 2, 2, 2])]) [0] >>> min_operations_to_sort(1, [(5, [5, 4, 3, 2, 1])]) [4] >>> min_operations_to_sort(1, [(5, [1, 3, 3, 7, 8])]) [0] >>> min_operations_to_sort(1, [(1, [1])]) [0] >>> min_operations_to_sort(1, [(2, [2, 1])]) [1]","solution":"def min_operations_to_sort(t, test_cases): Determines the minimum number of operations needed to sort the array for each test case by moving subarrays to the beginning of the array. results = [] for n, array in test_cases: count = 0 while sorted(array) != array: max_unordered_idx = 0 for i in range(n - 1): if array[i] > array[i + 1]: max_unordered_idx = i + 1 break subarray = array[:max_unordered_idx + 1] subarray.sort() array = subarray + array[max_unordered_idx + 1:] count += 1 results.append(count) return results"},{"question":"def max_defense_capability(n: int, warriors: List[int]) -> int: Given the circular layout of the walls, each guard unit can only retreat to an adjacent wall segment if the target segment is currently unguarded. If a wall segment is empty, a guard unit can be moved to this empty segment, thus strengthening that segment. The goal is to exhaustively rearrange the guards to achieve the maximum defense capability for any single wall segment while considering that only one unit can occupy a segment at any time. Args: n : int : the number of wall segments arranged in a circle warriors : List[int] : list representing the number of warriors in each corresponding segment Returns: int : the maximum number of warriors that can be gathered on a single wall segment Example: >>> max_defense_capability(6, [1, 2, 3, 4, 1, 2]) 7 >>> max_defense_capability(5, [5, 5, 5, 5, 5]) 5 pass","solution":"def max_defense_capability(n, warriors): max_warriors = max(warriors) return max_warriors # Example usage n = 6 warriors = [1, 2, 3, 4, 1, 2] print(max_defense_capability(n, warriors)) # Expected output: 4"},{"question":"def sequence_possible(n, events): Determines if the sequence of events is possible and provides one possible order of showcasing the buildings if the sequence is consistent. Args: n (int): The number of buildings. events (List[str]): The list of events, where each event is either showcasing a building \\"+ v\\" or viewing a building \\"-\\". Returns: str: \\"YES\\" followed by n space-separated integers denoting the values of the buildings in the order they were showcased if sequence is consistent; otherwise, \\"NO\\". >>> sequence_possible(5, [\\"+ 3\\", \\"+ 1\\", \\"-\\", \\"+ 4\\", \\"-\\", \\"+ 5\\", \\"-\\", \\"+ 2\\", \\"-\\", \\"-\\"]) 'YESn3 1 4 5 2' >>> sequence_possible(2, [\\"+ 1\\", \\"+ 2\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\", \\"-\\"]) 'NO'","solution":"def sequence_possible(n, events): showcased = [] viewed = [] view_idx = 0 for event in events: if event.startswith('+'): _, v = event.split() showcased.append(int(v)) else: if not showcased: return \\"NO\\" max_value = max(showcased) viewed.append(max_value) showcased.remove(max_value) showcased_indices = [] for event in events: if event.startswith('+'): _, v = event.split() showcased_indices.append(int(v)) if len(showcased_indices) == n: break return \\"YESn\\" + ' '.join(map(str, showcased_indices))"},{"question":"def can_find_equal_sum_subarrays(n: int, a: List[int]) -> str: Determines if there are two non-empty disjoint subarrays with equal sums. :param n: Integer representing the length of the sequence. :param a: List of integers representing the sequence. :return: \\"YES\\" if such subarrays exist, otherwise \\"NO\\". >>> can_find_equal_sum_subarrays(6, [1, 2, 3, 4, 5, 5]) \\"YES\\" >>> can_find_equal_sum_subarrays(4, [1, -1, 1, -1]) \\"YES\\" >>> can_find_equal_sum_subarrays(3, [1, 2, 3]) \\"NO\\" from solution import can_find_equal_sum_subarrays def test_example1(): assert can_find_equal_sum_subarrays(6, [1, 2, 3, 4, 5, 5]) == \\"YES\\" def test_example2(): assert can_find_equal_sum_subarrays(4, [1, -1, 1, -1]) == \\"YES\\" def test_example3(): assert can_find_equal_sum_subarrays(3, [1, 2, 3]) == \\"NO\\" def test_large_input_with_repeats(): assert can_find_equal_sum_subarrays(5, [1000000000, -1000000000, 1000000000, -1000000000, 0]) == \\"YES\\" def test_no_repeated_or_zero(): assert can_find_equal_sum_subarrays(3, [1, 2, 3]) == \\"NO\\" def test_single_element_zero(): assert can_find_equal_sum_subarrays(1, [0]) == \\"YES\\" def test_all_zeroes(): assert can_find_equal_sum_subarrays(4, [0, 0, 0, 0]) == \\"YES\\" def test_mixed_with_zero(): assert can_find_equal_sum_subarrays(5, [1, 1, 0, -1, -1]) == \\"YES\\" def test_all_positives(): assert can_find_equal_sum_subarrays(6, [1, 2, 3, 4, 5, 6]) == \\"NO\\" def test_all_negatives(): assert can_find_equal_sum_subarrays(4, [-5, -5, -10, -10]) == \\"YES\\"","solution":"def can_find_equal_sum_subarrays(n, a): Determines if there are two non-empty disjoint subarrays with equal sums. :param n: Integer representing the length of the sequence. :param a: List of integers representing the sequence. :return: \\"YES\\" if such subarrays exist, otherwise \\"NO\\". from collections import defaultdict # Dictionary to keep track of sums and their frequencies subarray_sums = defaultdict(int) sum_so_far = 0 # Check for any repeated sum as we iterate through the array for i in range(n): sum_so_far += a[i] if sum_so_far == 0 or subarray_sums[sum_so_far] > 0: return \\"YES\\" subarray_sums[sum_so_far] += 1 # Also check each individual element for being 0 or repeated element_counts = defaultdict(int) for num in a: if num == 0 or element_counts[num] > 0: return \\"YES\\" element_counts[num] += 1 return \\"NO\\""},{"question":"from typing import List def count_subarrays_with_sum(arr: List[int], k: int) -> int: Returns the number of contiguous subarrays that have a sum exactly equal to k. >>> count_subarrays_with_sum([1, 2, 3, -2, 1], 3) 3 >>> count_subarrays_with_sum([5], 5) 1 >>> count_subarrays_with_sum([5], 3) 0 >>> count_subarrays_with_sum([1, 1, 1, 1], 2) 3 >>> count_subarrays_with_sum([1, 2, 3], 6) 1 >>> count_subarrays_with_sum([-1, -2, -3, 4], -3) 2 >>> count_subarrays_with_sum([10**9, -10**9, 10**9, -10**9], 0) 4 >>> count_subarrays_with_sum([1] * (10**5), 10**5) 1","solution":"def count_subarrays_with_sum(arr, k): Returns the number of contiguous subarrays that have a sum exactly equal to k. from collections import defaultdict count = 0 current_sum = 0 prefix_sums = defaultdict(int) prefix_sums[0] = 1 # To handle the case when subarray starts from index 0 for num in arr: current_sum += num # Find if there is a prefix sum that we can subtract to get the sum k if (current_sum - k) in prefix_sums: count += prefix_sums[current_sum - k] # Update the prefix sums with the current sum prefix_sums[current_sum] += 1 return count"},{"question":"def manage_inventory(n: int, operations: List[Tuple[str, int, int]]) -> Dict[int, int]: Processes a series of operations to manage a warehouse inventory. Args: n: int, the number of operations operations: list of tuples, where each tuple contains an operation in the format (\\"add\\"/\\"remove\\", id, count) Returns: inventory: dict, the current inventory with product IDs as keys and counts as values, sorted by product ID. >>> manage_inventory(5, [(\\"add\\", 1, 10), (\\"add\\", 2, 5), (\\"remove\\", 1, 3), (\\"remove\\", 3, 2), (\\"add\\", 2, 1)]) {1: 7, 2: 6} >>> manage_inventory(4, [(\\"add\\", 1, 10), (\\"remove\\", 1, 10), (\\"add\\", 2, 5), (\\"remove\\", 2, 5)]) {} >>> manage_inventory(3, [(\\"add\\", 1, 10), (\\"remove\\", 1, 5), (\\"add\\", 2, 5)]) {1: 5, 2: 5} >>> manage_inventory(5, [(\\"add\\", 1, 10), (\\"add\\", 2, 5), (\\"remove\\", 1, 5), (\\"add\\", 1, 15), (\\"remove\\", 2, 5)]) {1: 20} >>> manage_inventory(0, []) {} >>> manage_inventory(3, [(\\"add\\", 2147483647, 10), (\\"add\\", 1, 5), (\\"remove\\", 2147483647, 5)]) {1: 5, 2147483647: 5}","solution":"def manage_inventory(n, operations): Processes a series of operations to manage a warehouse inventory. Args: n: int, the number of operations operations: list of tuples, where each tuple contains an operation in the format (\\"add\\"/\\"remove\\", id, count) Returns: inventory: dict, the current inventory with product IDs as keys and counts as values, sorted by product ID. inventory = {} for operation in operations: op_type, prod_id, count = operation if op_type == \\"add\\": if prod_id in inventory: inventory[prod_id] += count else: inventory[prod_id] = count elif op_type == \\"remove\\": if prod_id in inventory: if inventory[prod_id] <= count: del inventory[prod_id] else: inventory[prod_id] -= count return dict(sorted(inventory.items()))"},{"question":"def count_total_digits(n: int) -> int: Returns the total number of digits needed to display all numbers from 1 to n. >>> count_total_digits(5) 5 >>> count_total_digits(13) 17 >>> count_total_digits(100) 192 >>> count_total_digits(1000) 2893 >>> count_total_digits(1) 1","solution":"def count_total_digits(n): Returns the total number of digits needed to display all numbers from 1 to n. total_digits = 0 length = 1 power_of_10 = 10 while power_of_10 <= n: total_digits += length * (power_of_10 - power_of_10 // 10) length += 1 power_of_10 *= 10 total_digits += length * (n - power_of_10 // 10 + 1) return total_digits"},{"question":"def minimum_spanning_tree(v: int, e: int, edges: List[Tuple[int, int, int]]) -> int: You are given a weighted graph with \`v\` vertices and \`e\` edges. The vertices are numbered from 0 to \`v-1\`. Each edge has a positive weight. Your task is to find the weight of the minimum spanning tree (MST) of the graph. A spanning tree of a connected graph is a subgraph that includes all vertices and is a single connected tree. The weight of a spanning tree is the sum of the weights of its edges, and the minimum spanning tree is the spanning tree with the minimum weight. >>> minimum_spanning_tree(4, 5, [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]) 19 >>> minimum_spanning_tree(3, 3, [(0, 1, 1), (1, 2, 5), (0, 2, 4)]) 5","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(v, e, edges): parent = [] rank = [] mst_weight = 0 edges = sorted(edges, key=lambda item: item[2]) for node in range(v): parent.append(node) rank.append(0) mst_edges = 0 for edge in edges: if mst_edges == v - 1: break u, w, weight = edge root_u = find(parent, u) root_w = find(parent, w) if root_u != root_w: mst_edges += 1 mst_weight += weight union(parent, rank, root_u, root_w) return mst_weight def minimum_spanning_tree(v, e, edges): return kruskal_mst(v, e, edges)"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def min_hops(n: int, m: int, connections: List[Tuple[int, int, int]], s: int, t: int) -> int: Determine the minimum number of hops required to send a message from node s to node t. >>> min_hops(5, 6, [(1, 2, 5), (2, 3, 5), (3, 4, 2), (4, 5, 1), (1, 3, 10), (2, 5, 7)], 1, 5) 2 >>> min_hops(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 6)], 1, 3) 1 >>> min_hops(4, 2, [(1, 2, 4), (3, 4, 3)], 1, 4) -1 >>> min_hops(5, 6, [(1, 2, 5), (2, 3, 5), (3, 4, 2), (4, 5, 1), (1, 3, 10), (2, 5, 7)], 1, 1) 0 >>> min_hops(6, 7, [(1, 2, 4), (2, 3, 4), (3, 4, 4), (4, 5, 4), (5, 6, 4), (1, 3, 8), (3, 5, 8)], 1, 6) 3","solution":"def min_hops(n, m, connections, s, t): from collections import deque, defaultdict # Create adjacency List adj = defaultdict(list) for u, v, r in connections: adj[u].append((v, r)) # BFS to find the shortest path queue = deque([(s, 0)]) visited = set() while queue: current_node, hops = queue.popleft() # If destination is reached if current_node == t: return hops # Process neighbors for neighbor, _ in adj[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, hops + 1)) # Return -1 if destination not reachable return -1"},{"question":"from typing import List, Tuple def minimum_spanning_tree(n: int, edges: List[Tuple[int, int, int]], c: int) -> int: Given a connected, undirected graph with n vertices and m edges, each having an initial weight, calculate the minimum possible total weight of the MST under the condition that each edge's weight can either remain the same or be increased by a constant value c. Args: n (int): Number of vertices edges (List[Tuple[int, int, int]]): List of edges represented by tuples (u, v, w) c (int): The constant increase weight value Returns: int: The weight of the minimum spanning tree Example: >>> minimum_spanning_tree(4, [(1, 2, 5), (1, 3, 10), (1, 4, 3), (2, 3, 6), (3, 4, 7)], 2) 16 pass def test_minimum_spanning_tree(): edges_1 = [ (0, 1, 5), (0, 2, 10), (0, 3, 3), (1, 2, 6), (2, 3, 7) ] assert minimum_spanning_tree(4, edges_1, 2) == 14 edges_2 = [ (0, 1, 4), (0, 2, 9), (0, 3, 15), (1, 2, 7), (2, 3, 3) ] assert minimum_spanning_tree(4, edges_2, 2) == 14 edges_3 = [ (0, 1, 1), (0, 2, 1), (1, 2, 1) ] assert minimum_spanning_tree(3, edges_3, 10) == 2 edges_4 = [ (0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 0, 5) ] assert minimum_spanning_tree(6, edges_4, 5) == 25","solution":"def find(parent, i): if parent[i] == i: return i parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(n, edges, c): # Sorting edges by the minimum possible weight including condition of adding c sorted_edges = sorted(edges, key=lambda x: min(x[2], x[2]+c)) parent = list(range(n)) rank = [0] * n mst_weight = 0 num_edges = 0 for u, v, weight in sorted_edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_weight += min(weight, weight + c) union(parent, rank, root_u, root_v) num_edges += 1 if num_edges == n - 1: break return mst_weight"},{"question":"def smallest_integer_with_digit_sum(n: int) -> int: Returns the smallest integer k such that the sum of the digits of k is equal to n. >>> smallest_integer_with_digit_sum(10) 19 >>> smallest_integer_with_digit_sum(2) 2 >>> smallest_integer_with_digit_sum(13) 49","solution":"def smallest_integer_with_digit_sum(n): Returns the smallest integer k such that the sum of the digits of k is equal to n. def sum_of_digits(num): return sum(int(digit) for digit in str(num)) k = 1 while sum_of_digits(k) != n: k += 1 return k"},{"question":"def longest_palindrome(s: str) -> str: Given a string s, find the longest palindromic substring. >>> longest_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindrome(\\"cbbd\\") == \\"bb\\" True >>> longest_palindrome(\\"a\\") == \\"a\\" True >>> longest_palindrome(\\"ac\\") in [\\"a\\", \\"c\\"] True >>> longest_palindrome(\\"racecar\\") == \\"racecar\\" True >>> longest_palindrome(\\"banana\\") in [\\"anana\\"] True >>> longest_palindrome(\\"\\") == \\"\\" True >>> longest_palindrome(\\"aaaa\\") == \\"aaaa\\" True >>> longest_palindrome(\\"abcdefg\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] True","solution":"def longest_palindrome(s: str) -> str: n = len(s) if n == 0: return \\"\\" # Initialize DP table dp = [[False] * n for _ in range(n)] longest_palindromic_substring = \\"\\" max_length = 0 # Every single character is a palindrome for i in range(n): dp[i][i] = True longest_palindromic_substring = s[i] max_length = 1 # Check for two character palindromes for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True longest_palindromic_substring = s[i:i+2] max_length = 2 # Check for palindromes longer than 2 characters for length in range(3, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True if length > max_length: max_length = length longest_palindromic_substring = s[i:j+1] return longest_palindromic_substring"},{"question":"def minimum_height_difference(n: int, heights: List[int]) -> int: Returns the minimum possible difference in height between the tallest and the shortest tree in the beautiful garden by cutting down any number of trees. Parameters: n (int): The number of trees. heights (List[int]): A list of integers representing the heights of the trees. Returns: int: The minimum possible height difference. >>> minimum_height_difference(5, [4, 2, 7, 3, 5]) 1 >>> minimum_height_difference(1, [5]) 0","solution":"def minimum_height_difference(n, heights): Returns the minimum possible difference in height between the tallest and the shortest tree in the beautiful garden by cutting down any number of trees. Parameters: n (int): The number of trees. heights (list): A list of integers representing the heights of the trees. Returns: int: The minimum possible height difference. if n == 1: return 0 # If there is only one tree, the difference is 0 heights.sort() min_diff = float('inf') for i in range(n - 1): diff = heights[i+1] - heights[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def knapsack(n: int, W: int, items: List[Tuple[int, int]]) -> int: Function to determine the maximum value that can be achieved with given weight limit. :param n: int - number of items :param W: int - maximum weight capacity of the backpack :param items: list of tuples - each tuple containing (weight, value) of an item :return: int - maximum value of items that can be carried >>> knapsack(4, 5, [(2, 3), (3, 4), (4, 5), (5, 6)]) == 7 >>> knapsack(0, 5, []) == 0 >>> knapsack(1, 5, [(3, 10)]) == 10 >>> knapsack(1, 5, [(6, 10)]) == 0 >>> knapsack(3, 5, [(1, 1), (4, 5), (3, 4)]) == 6","solution":"def knapsack(n, W, items): Function to determine the maximum value that can be achieved with given weight limit. :param n: int - number of items :param W: int - maximum weight capacity of the backpack :param items: list of tuples - each tuple containing (weight, value) of an item :return: int - maximum value of items that can be carried # Creating a dp array for storing intermediate results dp = [[0] * (W + 1) for _ in range(n + 1)] # Filling the dp array for i in range(1, n + 1): for w in range(1, W + 1): if items[i-1][0] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-items[i-1][0]] + items[i-1][1]) else: dp[i][w] = dp[i-1][w] return dp[n][W] # Example usage: n = 4 W = 5 items = [(2, 3), (3, 4), (4, 5), (5, 6)] print(knapsack(n, W, items)) # Output: 7"},{"question":"def max_possible_sum(n: int, power_values: List[int]) -> int: Returns the maximum possible sum of distinct trees' power values Lena can collect. >>> max_possible_sum(5, [3, 2, 5, 4, 8]) 22 >>> max_possible_sum(8, [1, 3, 2, 1, 5, 1, 4, 7]) 16","solution":"def max_possible_sum(n, power_values): Returns the maximum possible sum of distinct trees' power values Lena can collect. sorted_power_values = sorted(set(power_values)) return sum(sorted_power_values)"},{"question":"def min_total_width(n: int, books: List[Tuple[int, int]]) -> int: Determine the minimum total width required for a valid arrangement of the books on the shelf. >>> min_total_width(4, [(10, 5), (20, 3), (15, 7), (25, 4)]) 19 >>> min_total_width(4, [(10, 1), (10, 2), (10, 3), (10, 4)]) 10 >>> min_total_width(4, [(1, 5), (2, 5), (3, 5), (4, 5)]) 20 >>> min_total_width(4, [(10, 2), (20, 4), (5, 1), (25, 3)]) 10 >>> min_total_width(1, [(15, 7)]) 7 >>> min_total_width(100000, [(1, 1)] * 100000) 100000 from typing import List, Tuple","solution":"def min_total_width(n, books): books.sort() total_width = 0 for _, width in books: total_width += width return total_width # Example Usage # n = 4 # books = [(10, 5), (20, 3), (15, 7), (25, 4)] # print(min_total_width(n, books)) # Output should be 19"},{"question":"def smallest_string_by_deleting_one_character(s: str) -> str: Returns the lexicographically smallest string formed by deleting exactly one character from s. >>> smallest_string_by_deleting_one_character(\\"abc\\") 'ab' >>> smallest_string_by_deleting_one_character(\\"acbd\\") 'abd'","solution":"def smallest_string_by_deleting_one_character(s): Returns the lexicographically smallest string formed by deleting exactly one character from s. # Initialize the smallest string to be effectively the largest possible string smallest_string = s[1:] for i in range(len(s)): # Form a new string by deleting the ith character new_string = s[:i] + s[i+1:] # Update smallest string if new string is lexicographically smaller if new_string < smallest_string: smallest_string = new_string return smallest_string"},{"question":"def unique_paths(grid): Determine the number of unique paths from the top-left corner to the bottom-right corner of a grid. >>> unique_paths([\\"PPP\\", \\"PIP\\", \\"PPP\\"]) 2 >>> unique_paths([\\"PI\\", \\"PP\\"]) 1 >>> unique_paths([\\"PI\\", \\"IP\\"]) 0 >>> unique_paths([\\"PP\\", \\"PP\\"]) 2 >>> unique_paths([\\"P\\"]) 1 >>> unique_paths([\\"I\\"]) 0 def solve(t, grids): Given multiple grids, determines the number of unique paths for each. >>> solve(2, [[\\"PPP\\", \\"PIP\\", \\"PPP\\"], [\\"PI\\", \\"PP\\"]]) [2, 1] def main(input_data): Parses input data and prints the number of unique paths for each grid. Example: >>> input_data = \\"2nn3 3nPPPnPIPnPPPnn2 2nPInPPn\\" >>> main(input_data) 2 1","solution":"def unique_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 'I' or grid[n-1][m-1] == 'I': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 'I': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def solve(t, grids): results = [] for grid in grids: results.append(unique_paths(grid)) return results # Function to parse the input and run the solution def main(input_data): data = input_data.split('n') t = int(data[0]) grids = [] index = 1 for _ in range(t): if data[index] == '': index += 1 n, m = map(int, data[index].split()) grid = [] for i in range(n): grid.append(data[index + 1 + i]) grids.append(grid) index += n + 1 results = solve(t, grids) for result in results: print(result)"},{"question":"def count_subarrays(nums: List[int], k: int) -> int: Count the number of contiguous subarrays whose sum is equal to a given integer k. Args: nums (List[int]): A list of integers representing the array. k (int): The target sum for the subarrays. Returns: int: The number of contiguous subarrays that sum to k. >>> count_subarrays([1, 1, 1, 1, 1], 2) 4 >>> count_subarrays([5], 5) 1 >>> count_subarrays([3], 5) 0 >>> count_subarrays([-1, -1, 1, 1, 1, -1, -1], 0) 6 >>> count_subarrays([0, 0, 0, 0], 0) 10 >>> count_subarrays([1]*100000, 100) 99901 >>> count_subarrays([1000, 2000, -3000, 4000, -5000], 2000) 1","solution":"from typing import List from collections import defaultdict def count_subarrays(nums: List[int], k: int) -> int: cumulative_sum = 0 count = 0 cumulative_sum_map = defaultdict(int) cumulative_sum_map[0] = 1 for num in nums: cumulative_sum += num if (cumulative_sum - k) in cumulative_sum_map: count += cumulative_sum_map[cumulative_sum - k] cumulative_sum_map[cumulative_sum] += 1 return count"},{"question":"def max_non_overlapping_movies(n, intervals): Returns the maximum number of non-overlapping movies that can be watched. :param n: Number of movies :param intervals: List of tuples where each tuple contains (start_time, end_time) :return: Maximum number of non-overlapping movies >>> max_non_overlapping_movies(4, [(1, 4), (3, 5), (0, 6), (5, 7)]) == 2 >>> max_non_overlapping_movies(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_movies(3, [(1, 10), (2, 9), (3, 8)]) == 1 >>> max_non_overlapping_movies(4, [(1, 3), (2, 5), (4, 6), (7, 8)]) == 3 >>> max_non_overlapping_movies(1, [(1, 2)]) == 1 >>> max_non_overlapping_movies(6, [(1, 3), (3, 5), (5, 7), (2, 6), (4, 9), (6, 8)]) == 3 >>> max_non_overlapping_movies(3, [(1, 4), (2, 4), (3, 4)]) == 1 >>> max_non_overlapping_movies(0, []) == 0","solution":"def max_non_overlapping_movies(n, intervals): Returns the maximum number of non-overlapping movies that can be watched. :param n: Number of movies :param intervals: List of tuples where each tuple contains (start_time, end_time) :return: Maximum number of non-overlapping movies # Sort movies by their end times intervals.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in intervals: if start >= last_end_time: count += 1 last_end_time = end return count # Example usage: # n = 4 # intervals = [(1, 4), (3, 5), (0, 6), (5, 7)] # print(max_non_overlapping_movies(n, intervals)) # Output: 2"},{"question":"def word_break(s: str, word_dict: List[str]) -> bool: Determines if the string s can be segmented into a sequence of one or more dictionary words from the given list. :param s: str, the input string :param word_dict: list of str, the list of dictionary words :return: bool, true if s can be segmented, otherwise false >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"\\", [\\"leet\\", \\"code\\"]) True >>> word_break(\\"leetcode\\", [\\"leet\\", \\"coder\\"]) False >>> word_break(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"ap\\", \\"plep\\"]) True >>> word_break(\\"aaa\\", [\\"a\\", \\"aa\\"]) True >>> word_break(\\"word\\", [\\"word\\"]) True","solution":"def word_break(s, word_dict): Determines if the string s can be segmented into a sequence of one or more dictionary words from the given list. :param s: str, the input string :param word_dict: list of str, the list of dictionary words :return: bool, true if s can be segmented, otherwise false word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def can_reorder_for_odd_sums(n: int, arr: List[int]) -> str: Determines if it's possible to reorder the array such that the sum of every two consecutive elements is odd. :param n: The number of integers in the array. :param arr: List of integers. :return: \\"YES\\" if it's possible to reorder the array, otherwise \\"NO\\". >>> can_reorder_for_odd_sums(4, [1, 2, 3, 4]) == \\"YES\\" >>> can_reorder_for_odd_sums(3, [2, 4, 6]) == \\"NO\\" >>> can_reorder_for_odd_sums(1, [1]) == \\"NO\\" >>> can_reorder_for_odd_sums(2, [1, 2]) == \\"YES\\" >>> can_reorder_for_odd_sums(2, [2, 4]) == \\"NO\\" >>> can_reorder_for_odd_sums(5, [2, 3, 5, 7, 8]) == \\"YES\\" >>> can_reorder_for_odd_sums(6, [1, 3, 5, 7, 9, 11]) == \\"NO\\"","solution":"def can_reorder_for_odd_sums(n, arr): Determines if it's possible to reorder the array such that the sum of every two consecutive elements is odd. # Count the number of odd and even numbers odd_count = sum(1 for x in arr if x % 2 != 0) even_count = n - odd_count # It is possible to reorder if and only if we have at least one odd and one even number if odd_count > 0 and even_count > 0: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def max_sum_subsequence(n: int, grid: List[List[int]]) -> int: Calculate the maximum sum of a subsequence of numbers such that no two numbers are chosen from the same row or column. Arguments: n -- the size of the grid (n x n) grid -- a 2D list of integers representing the elements of the grid Returns: The maximum sum of the subsequence. Example: >>> max_sum_subsequence(3, [ ... [1, -2, 3], ... [-4, 5, -6], ... [7, -8, 9]]) 15 >>> max_sum_subsequence(2, [ ... [1, 2], ... [3, 4]]) 5 pass # Your implementation here def test_example_case(): grid = [ [1, -2, 3], [-4, 5, -6], [7, -8, 9] ] assert max_sum_subsequence(3, grid) == 15 def test_small_grid(): grid = [ [1, 2], [3, 4] ] assert max_sum_subsequence(2, grid) == 5 def test_all_negative_numbers(): grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert max_sum_subsequence(3, grid) == -15 def test_mixed_numbers(): grid = [ [1, 2, -3], [-1, -2, 3], [2, -1, 3] ] assert max_sum_subsequence(3, grid) == 7 def test_single_element(): grid = [[5]] assert max_sum_subsequence(1, grid) == 5","solution":"from itertools import permutations def max_sum_subsequence(n, grid): def calculate_sum(perm): total = 0 for row in range(n): total += grid[row][perm[row]] return total max_sum = float('-inf') for perm in permutations(range(n)): current_sum = calculate_sum(perm) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class TrafficMonitoringSystem: A simplified traffic monitoring system for a company's internal network, where each computing node is identified by a unique name and can generate traffic to any other node in the network. The system supports the following operations: 1. Register a new node in the network. 2. Record traffic data between two nodes. 3. Retrieve the total incoming or outgoing traffic for a specific node. >>> system = TrafficMonitoringSystem() >>> system.add_node(\\"node1\\") >>> system.add_node(\\"node2\\") >>> system.record_traffic(\\"node1\\", \\"node2\\", 50) >>> system.record_traffic(\\"node2\\", \\"node1\\", 30) >>> system.total_in(\\"node1\\") 30 >>> system.total_out(\\"node1\\") 50 >>> system.total_in(\\"node2\\") 50 >>> system.total_out(\\"node2\\") 30 def __init__(self): ... def add_node(self, node_name: str): ... def record_traffic(self, source_node: str, destination_node: str, bytes: int): ... def total_in(self, node_name: str) -> int: ... def total_out(self, node_name: str) -> int: ...","solution":"class TrafficMonitoringSystem: def __init__(self): self.nodes = {} self.incoming_traffic = {} self.outgoing_traffic = {} def add_node(self, node_name): self.nodes[node_name] = True self.incoming_traffic[node_name] = 0 self.outgoing_traffic[node_name] = 0 def record_traffic(self, source_node, destination_node, bytes): self.outgoing_traffic[source_node] += int(bytes) self.incoming_traffic[destination_node] += int(bytes) def total_in(self, node_name): return self.incoming_traffic[node_name] def total_out(self, node_name): return self.outgoing_traffic[node_name]"},{"question":"def compress_string(s: str) -> str: Compresses the given string by replacing consecutive sequences of the same character with that character followed by the number of occurrences. If the compressed string is not shorter than the original string, the function returns the original string. >>> compress_string(\\"AABCDDE\\") \\"AABCDDE\\" >>> compress_string(\\"AAAAAAAAAABBBBB\\") \\"A10B5\\" >>> compress_string(\\"0122333344\\") \\"0122333344\\" >>> compress_string(\\"AB\\") \\"AB\\" >>> compress_string(\\"ZZZZZZZZZZZZZZZZZZZZ\\") \\"Z20\\" >>> compress_string(\\"A\\") \\"A\\" >>> compress_string(\\"AAAAAAAAAA\\") \\"A10\\" >>> compress_string(\\"BBBBCCC\\") \\"B4C3\\" >>> compress_string(\\"11111\\") \\"15\\" >>> compress_string(\\"22\\") \\"22\\"","solution":"def compress_string(s: str) -> str: Compresses the given string by replacing consecutive sequences of the same character with that character followed by the number of occurrences. If the compressed string is not shorter than the original string, the function returns the original string. compressed = [] i = 0 n = len(s) while i < n: count = 1 while i + 1 < n and s[i] == s[i + 1]: i += 1 count += 1 compressed.append(s[i]) compressed.append(str(count)) i += 1 compressed_str = ''.join(compressed) return compressed_str if len(compressed_str) < n else s"},{"question":"def clean_sentence(sentence: str) -> str: Removes redundant spaces from the sentence. >>> clean_sentence(\\" This is a sentence with redundant spaces. \\") 'This is a sentence with redundant spaces.' >>> clean_sentence(\\"This is a normal sentence.\\") 'This is a normal sentence.' >>> clean_sentence(\\" \\") '' >>> clean_sentence(\\"\\") '' >>> clean_sentence(\\" Leading and trailing spaces \\") 'Leading and trailing spaces' >>> clean_sentence(\\"Multiple spaces between words.\\") 'Multiple spaces between words.' >>> clean_sentence(\\" word \\") 'word' >>> clean_sentence(\\"Space before comma , and period .\\") 'Space before comma , and period .'","solution":"def clean_sentence(sentence: str) -> str: Removes redundant spaces from the sentence. Parameters: - sentence (str): The text data with redundant spaces. Returns: - str: A cleaned sentence with no redundant spaces. # Remove leading and trailing whitespace sentence = sentence.strip() # Replace multiple spaces with a single space cleaned_sentence = ' '.join(sentence.split()) return cleaned_sentence"},{"question":"def determine_winner(n: int, m: int) -> str: Determine the winner between Polycarp and Vasiliy on an n x m grid. >>> determine_winner(2, 2) == \\"Polycarp\\" >>> determine_winner(2, 3) == \\"Polycarp\\" >>> determine_winner(3, 2) == \\"Polycarp\\" >>> determine_winner(3, 3) == \\"Polycarp\\" >>> determine_winner(1000, 1000) == \\"Polycarp\\" >>> determine_winner(100000, 2) == \\"Polycarp\\" >>> determine_winner(2, 100000) == \\"Polycarp\\" >>> determine_winner(100000, 100000) == \\"Polycarp\\" >>> determine_winner(50, 100) == \\"Polycarp\\" >>> determine_winner(100, 50) == \\"Polycarp\\"","solution":"def determine_winner(n, m): This function checks if Polycarp can win the game on a grid of size n x m. return \\"Polycarp\\""},{"question":"def longest_palindromic_subsequence(s: str) -> int: Determine the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"aaa\\") 3 >>> longest_palindromic_subsequence(\\"abacaba\\") 7 pass def solve(input_data: str) -> List[int]: Given multiple test cases, determine the length of the longest palindromic subsequence for each. >>> solve(\\"2naaanabacaba\\") [3, 7] >>> solve(\\"3nabcbanabcdnaabb\\") [5, 1, 2] pass","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(input_data): lines = input_data.split('n') t = int(lines[0]) results = [] for i in range(1, t + 1): s = lines[i] results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def lcs(s1: str, s2: str) -> str: Returns the longest common subsequence of s1 and s2. pass def lexicographically_smallest_permutation(lcs_str: str) -> str: Returns the lexicographically smallest permutation of the string lcs_str. pass def smallest_lcs_permutation(s1: str, s2: str) -> str: Finds the longest common subsequences of s1 and s2, and returns the lexicographically smallest permutation of it. >>> smallest_lcs_permutation('abcbdab', 'bdcaba') == 'abb' >>> smallest_lcs_permutation('XMJYAUZ', 'MZJAWXU') == 'AJU' >>> smallest_lcs_permutation('abc', 'abc') == 'abc' >>> smallest_lcs_permutation('abc', 'def') == '' >>> smallest_lcs_permutation('a', 'a') == 'a' pass","solution":"def lcs(s1, s2): Returns the longest common subsequence of s1 and s2. m = len(s1) n = len(s2) # Create a 2D array to store the lengths of longest common subsequence dp = [[0] * (n+1) for _ in range(m+1)] # Fill dp array for i in range(m): for j in range(n): if s1[i] == s2[j]: dp[i+1][j+1] = dp[i][j] + 1 else: dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]) # Backtrack to find the actual LCS lcs_str = [] i, j = m, n while i > 0 and j > 0: if s1[i-1] == s2[j-1]: lcs_str.append(s1[i-1]) i -= 1 j -= 1 elif dp[i-1][j] > dp[i][j-1]: i -= 1 else: j -= 1 # The LCS is built backwards, so reverse it lcs_str.reverse() return ''.join(lcs_str) def lexicographically_smallest_permutation(lcs_str): Returns the lexicographically smallest permutation of the string lcs_str. return ''.join(sorted(lcs_str)) def smallest_lcs_permutation(s1, s2): Finds the longest common subsequences of s1 and s2, and returns the lexicographically smallest permutation of it. lcs_str = lcs(s1, s2) return lexicographically_smallest_permutation(lcs_str)"},{"question":"from typing import List, Tuple, Union def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> Union[str, List[int]]: Determine whether it is possible to color the graph using only two colors such that no two adjacent vertices share the same color. >>> is_bipartite(3, 2, [(1, 2), (2, 3)]) [\\"Yes\\", 1, 2, 1] >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"No\\" >>> is_bipartite(1, 0, []) [\\"Yes\\", 1] >>> is_bipartite(4, 2, [(1, 2), (3, 4)]) [\\"Yes\\", 1, 2, 1, 2] >>> is_bipartite(4, 2, [(1, 2), (1, 3)]) [\\"Yes\\", 1, 2, 2, 1]","solution":"def is_bipartite(n, m, edges): from collections import deque # Initialize graph as adjacency list graph = [[] for _ in range(n)] for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) # Initialization of color array, -1 means uncolored color = [-1] * n # Helper function to perform BFS def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with one color while queue: vertex = queue.popleft() for neighbor in graph[vertex]: if color[neighbor] == -1: # If the neighbor has not been colored color[neighbor] = 1 - color[vertex] # Assign opposite color queue.append(neighbor) elif color[neighbor] == color[vertex]: # Conflict detected return False return True # Perform BFS on each component for i in range(n): if color[i] == -1: # Unvisited node if not bfs(i): return \\"No\\" # Convert color array to 1-indexed coloring result = [\\"Yes\\"] + [col + 1 for col in color] return result"},{"question":"def min_difference_of_candies(n: int, piles: List[int]) -> int: Given an array of piles of candies, this function calculates the minimum difference between the sums of two groups when the piles are divided into exactly two groups. :param n: int, the number of piles of candies :param piles: list of int, the quantities of candies in each pile :return: int, the minimum possible value of the difference between the two groups' total quantities >>> min_difference_of_candies(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_difference_of_candies(1, [5]) 5 >>> min_difference_of_candies(2, [5, 5]) 0 >>> min_difference_of_candies(2, [5, 8]) 3 >>> min_difference_of_candies(4, [8, 15, 7, 12]) 2 >>> min_difference_of_candies(3, [10, 10, 10]) 10 >>> min_difference_of_candies(4, [1, 1, 1, 2]) 1 >>> min_difference_of_candies(2000, [1]*2000) 0","solution":"def min_difference_of_candies(n, piles): Given an array of piles of candies, this function calculates the minimum difference between the sums of two groups when the piles are divided into exactly two groups. :param n: int, the number of piles of candies :param piles: list of int, the quantities of candies in each pile :return: int, the minimum possible value of the difference between the two groups' total quantities total = sum(piles) half = total // 2 # Create a DP array to store the possible sums up to 'half' dp = [0] * (half + 1) for pile in piles: for j in range(half, pile - 1, -1): dp[j] = max(dp[j], dp[j - pile] + pile) # The closest sum to 'half' we can get closest_sum = dp[half] return abs(total - 2 * closest_sum)"},{"question":"from typing import List def min_moves_to_contaminate(r: int, c: int, grid: List[List[int]]) -> int: Determine the minimum number of moves to contaminate the entire grid. >>> min_moves_to_contaminate(3, 3, [[1, 0, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> min_moves_to_contaminate(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> min_moves_to_contaminate(2, 2, [[1, 0], [0, 0]]) 2 >>> min_moves_to_contaminate(2, 2, [[0, 0], [0, 0]]) -1 >>> min_moves_to_contaminate(1, 1, [[0]]) -1 >>> min_moves_to_contaminate(1, 1, [[1]]) 0 >>> min_moves_to_contaminate(4, 4, [[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0]]) 3","solution":"from collections import deque def min_moves_to_contaminate(r, c, grid): # Directions for the adjacent cells directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initial grid setup to find contaminated cells queue = deque() non_contaminated_count = 0 for i in range(r): for j in range(c): if grid[i][j] == 1: queue.append((i, j)) else: non_contaminated_count += 1 # If all cells are already contaminated if non_contaminated_count == 0: return 0 moves = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < r and 0 <= ny < c and grid[nx][ny] == 0: grid[nx][ny] = 1 queue.append((nx, ny)) non_contaminated_count -= 1 if non_contaminated_count == 0: return moves + 1 moves += 1 # If there are still non-contaminated cells remaining after all possible moves return -1"},{"question":"import heapq from typing import List, Tuple def shortest_travel_time(n: int, m: int, routes: List[Tuple[int, int, int]], s: int, t: int) -> int: Determines the shortest travel time from station s to station t. Parameters: n (int): Number of stations. m (int): Number of train routes. routes (List[Tuple[int, int, int]]): List of tuples where each tuple is (u, v, w) indicating a train route from u to v with a travel time of w. s (int): Starting station. t (int): Destination station. Returns: int: Shortest travel time from s to t, or -1 if there is no valid path. >>> shortest_travel_time(5, 7, [(1, 2, 3), (1, 3, 10), (2, 3, 1), (2, 4, 2), (3, 4, 6), (4, 5, 1), (3, 5, 2)], 1, 5) 6 >>> shortest_travel_time(3, 2, [(1, 2, 4), (2, 3, 1)], 3, 1) -1 >>> shortest_travel_time(3, 2, [(1, 2, 4), (2, 3, 1)], 1, 2) 4 >>> shortest_travel_time(6, 8, [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (6, 5, 9), (4, 5, 6)], 1, 5) 20 >>> shortest_travel_time(6, 8, [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (6, 5, 9), (4, 5, 6)], 1, 1) 0 pass","solution":"import heapq def shortest_travel_time(n, m, routes, s, t): Determines the shortest travel time from station s to station t. Parameters: n (int): Number of stations. m (int): Number of train routes. routes (list): List of tuples where each tuple is (u, v, w) indicating a train route from u to v with a travel time of w. s (int): Starting station. t (int): Destination station. Returns: int: Shortest travel time from s to t, or -1 if there is no valid path. # Initialize adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in routes: graph[u].append((v, w)) # Dijkstra's algorithm using a priority queue pq = [(0, s)] # (distance, node) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == t: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return -1 if distances[t] == float('inf') else distances[t]"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, node, key): if node is None: return TreeNode(key) if key < node.val: node.left = self.insert(node.left, key) else: node.right = self.insert(node.right, key) return node def height(self, node): if node is None: return -1 left_height = self.height(node.left) right_height = self.height(node.right) return max(left_height, right_height) + 1 def calculate_bst_height(keys): Calculate the height of the BST constructed from the given sequence of integers. >>> calculate_bst_height([3, 1, 4, 0, 2]) 2 >>> calculate_bst_height([5, 3, 8, 2, 4, 7, 9, 1]) 3","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, node, key): if node is None: return TreeNode(key) if key < node.val: node.left = self.insert(node.left, key) else: node.right = self.insert(node.right, key) return node def height(self, node): if node is None: return -1 left_height = self.height(node.left) right_height = self.height(node.right) return max(left_height, right_height) + 1 def calculate_bst_height(keys): bst = BST() for key in keys: bst.root = bst.insert(bst.root, key) return bst.height(bst.root) if __name__ == \\"__main__\\": n = int(input().strip()) keys = list(map(int, input().strip().split())) print(calculate_bst_height(keys))"},{"question":"def unique_users_in_time_intervals(log_entries, queries): Determine the number of unique users active within each specified time interval. Args: log_entries (List[Tuple[int, int]]): A list of tuples where each tuple contains a timestamp and a user ID. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains a start time and an end time. Returns: List[int]: A list of integers where each integer is the number of unique users active within the specified time interval. Example: >>> log_entries = [ (1, 10), (2, 20), (3, 10), (5, 30), (10, 40) ] >>> queries = [ (1, 5), (2, 10), (8, 12) ] >>> unique_users_in_time_intervals(log_entries, queries) [3, 4, 1] from solution import unique_users_in_time_intervals def test_example_case(): log_entries = [ (1, 10), (2, 20), (3, 10), (5, 30), (10, 40) ] queries = [ (1, 5), (2, 10), (8, 12) ] results = unique_users_in_time_intervals(log_entries, queries) assert results == [3, 4, 1] def test_single_entry_query(): log_entries = [ (1, 10), (2, 20), (3, 10), (5, 30), (10, 40) ] queries = [ (1, 1), (2, 2), (3, 3), (5, 5), (10, 10) ] results = unique_users_in_time_intervals(log_entries, queries) assert results == [1, 1, 1, 1, 1] def test_large_time_range_query(): log_entries = [ (1, 10), (2, 20), (3, 10), (5, 30), (10, 40) ] queries = [ (1, 10), (1, 100) ] results = unique_users_in_time_intervals(log_entries, queries) assert results == [4, 4] def test_no_overlap_query(): log_entries = [ (1, 10), (2, 20), (3, 10), (5, 30), (10, 40) ] queries = [ (11, 20), (6, 9) ] results = unique_users_in_time_intervals(log_entries, queries) assert results == [0, 0] def test_identical_timestamps_and_users(): log_entries = [ (1, 10), (1, 10), (2, 20), (2, 20), (3, 10), (3, 10), (5, 30), (5, 30) ] queries = [ (1, 5), (2, 10) ] results = unique_users_in_time_intervals(log_entries, queries) assert results == [3, 3]","solution":"def unique_users_in_time_intervals(log_entries, queries): user_log_dict = {} for t, u in log_entries: if t not in user_log_dict: user_log_dict[t] = set() user_log_dict[t].add(u) timestamps_sorted = sorted(user_log_dict.keys()) def get_users_count(start, end): users = set() for t in timestamps_sorted: if start <= t <= end: users.update(user_log_dict[t]) if t > end: break return len(users) results = [] for start, end in queries: results.append(get_users_count(start, end)) return results"},{"question":"def minimal_conversion_cost(n: int, x: int, y: int, s: str) -> int: Determine the minimum cost needed to convert the string into a valid binary number. Parameters: n (int): Length of the string x (int): Cost to replace '?' with '0' y (int): Cost to replace '?' with '1' s (str): Input string with '0', '1', and '?' characters Returns: int: Minimum cost to convert the string into a valid binary number. Example: >>> minimal_conversion_cost(5, 3, 2, \\"1??10\\") 4 pass def test_minimal_conversion_cost_example(): assert minimal_conversion_cost(5, 3, 2, \\"1??10\\") == 4 def test_minimal_conversion_cost_all_zeros(): assert minimal_conversion_cost(4, 1, 3, \\"0?0?\\") == 2 def test_minimal_conversion_cost_all_ones(): assert minimal_conversion_cost(4, 2, 1, \\"1?1?\\") == 2 def test_minimal_conversion_cost_mixed(): assert minimal_conversion_cost(6, 4, 2, \\"?1??0?\\") == 8 def test_minimal_conversion_cost_no_question_marks(): assert minimal_conversion_cost(3, 2, 3, \\"101\\") == 0 def test_minimal_conversion_cost_all_question_marks(): assert minimal_conversion_cost(5, 7, 3, \\"?????\\") == 15","solution":"def minimal_conversion_cost(n, x, y, s): Returns the minimum cost needed to convert the string s into a valid binary number by replacing '?' with either '0' or '1'. Parameters: n (int): Length of the string x (int): Cost to replace '?' with '0' y (int): Cost to replace '?' with '1' s (str): Input string with '0', '1', and '?' Returns: int: Minimum cost to convert s into a valid binary number min_cost = 0 for char in s: if char == '?': min_cost += min(x, y) return min_cost"},{"question":"def can_form_palindrome_by_removing_one_char(s: str) -> bool: Determine if it is possible to make the string a palindrome by removing exactly one character. >>> can_form_palindrome_by_removing_one_char(\\"abca\\") True >>> can_form_palindrome_by_removing_one_char(\\"abcba\\") True >>> can_form_palindrome_by_removing_one_char(\\"abcd\\") False >>> can_form_palindrome_by_removing_one_char(\\"a\\") False >>> can_form_palindrome_by_removing_one_char(\\"aa\\") True >>> can_form_palindrome_by_removing_one_char(\\"racecar\\") True >>> can_form_palindrome_by_removing_one_char(\\"raceecar\\") True >>> can_form_palindrome_by_removing_one_char(\\"abcdefg\\") False def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Process multiple test cases to determine if it is possible to make each string a palindrome by removing exactly one character. >>> process_test_cases(3, [\\"abca\\", \\"abcba\\", \\"abcd\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(3, [\\"racecar\\", \\"a\\", \\"aa\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"a\\" * 100000]) [\\"YES\\"]","solution":"def can_form_palindrome_by_removing_one_char(s): def is_palindrome(st): return st == st[::-1] n = len(s) if n <= 1: return False l, r = 0, n - 1 while l < r: if s[l] != s[r]: # Two cases: delete character at position l or r return is_palindrome(s[l+1:r+1]) or is_palindrome(s[l:r]) l += 1 r -= 1 return True def process_test_cases(t, test_cases): results = [] for i in range(t): if can_form_palindrome_by_removing_one_char(test_cases[i]): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_purchase_campaign(n: int, campaigns: List[Set[int]], m: int, customers: List[Tuple[int, int]]) -> int: Given a list of campaigns and customers with their purchase amounts, find out which campaign has the highest total purchase amount. Args: n (int): Number of campaigns. campaigns (List[Set[int]]): List of sets, each representing customer IDs targeted by a campaign. m (int): Number of customers. customers (List[Tuple[int, int]]): List of tuples, each containing a customer ID and their purchase amount. Returns: int: The ID of the campaign with the highest total purchase amount. Example: >>> max_purchase_campaign(3, [{1, 2, 3}, {2, 3, 4}, {1, 4}], 4, [(1, 100), (2, 50), (3, 200), (4, 300)]) 2 pass # Unit tests def test_example_case(): n = 3 campaigns = [ {1, 2, 3}, {2, 3, 4}, {1, 4} ] m = 4 customers = [ (1, 100), (2, 50), (3, 200), (4, 300) ] assert max_purchase_campaign(n, campaigns, m, customers) == 2 def test_single_campaign_single_customer(): n = 1 campaigns = [ {1} ] m = 1 customers = [ (1, 100) ] assert max_purchase_campaign(n, campaigns, m, customers) == 1 def test_multiple_campaigns_same_customers(): n = 2 campaigns = [ {1, 2}, {1, 2} ] m = 2 customers = [ (1, 100), (2, 200) ] assert max_purchase_campaign(n, campaigns, m, customers) == 1 def test_partial_overlap_customers(): n = 2 campaigns = [ {1, 2}, {2, 3} ] m = 3 customers = [ (1, 100), (2, 150), (3, 200) ] assert max_purchase_campaign(n, campaigns, m, customers) == 2 def test_all_different_customers(): n = 2 campaigns = [ {1}, {2} ] m = 2 customers = [ (1, 300), (2, 500) ] assert max_purchase_campaign(n, campaigns, m, customers) == 2","solution":"def max_purchase_campaign(n, campaigns, m, customers): # Create a dictionary to store purchase amount for each customer ID customer_purchases = {cid: amt for cid, amt in customers} # Initialize variables to track the maximum purchase amount and corresponding campaign index max_purchase = 0 best_campaign_index = 1 # Iterate over each campaign to calculate the total purchase amount for i, campaign in enumerate(campaigns): total_purchase = sum(customer_purchases[cid] for cid in campaign) # Update the max purchase and campaign index if the current total purchase is higher if total_purchase > max_purchase: max_purchase = total_purchase best_campaign_index = i + 1 # Campaign indices are 1-based return best_campaign_index # Example usage: n = 3 campaigns = [ {1, 2, 3}, {2, 3, 4}, {1, 4} ] m = 4 customers = [ (1, 100), (2, 50), (3, 200), (4, 300) ] print(max_purchase_campaign(n, campaigns, m, customers)) # Output: 2"},{"question":"def process_queries(t, cases): Process daily updates and answer value queries efficiently. Args: t (int): Number of test cases. cases (list of dict): Each dict contains the keys: - 'n' (int): Number of days with stamp additions. - 'q' (int): Number of queries. - 'stamps' (list of int): Values of stamps added each day. - 'queries' (list of int): Queries for the total value at the end of specific days. Returns: list of int: Total values for each query in the order they were presented. Example: >>> process_queries(1, [{'n': 5, 'q': 3, 'stamps': [4, 2, 8, 5, 7], 'queries': [3, 5, 1]}]) [14, 26, 4] pass def parse_input(input_data): Parses the input data in the format described in the problem statement. Args: input_data (str): String containing the input data. Returns: tuple: (t, cases) where t is the number of test cases and cases is a list of dicts. Example: >>> parse_input(\\"1n5 3n4 2 8 5 7n3n5n1\\") (1, [{'n': 5, 'q': 3, 'stamps': [4, 2, 8, 5, 7], 'queries': [3, 5, 1]}]) pass # Unit Tests def test_process_queries(): input_data = 1 5 3 4 2 8 5 7 3 5 1 t, cases = parse_input(input_data) result = process_queries(t, cases) expected = [14, 26, 4] assert result == expected def test_process_queries_multiple_tests(): input_data = 2 5 3 4 2 8 5 7 3 5 1 3 2 1 2 3 1 2 t, cases = parse_input(input_data) result = process_queries(t, cases) expected = [14, 26, 4, 1, 3] assert result == expected def test_process_queries_edge_cases(): input_data = 1 1 1 10 1 t, cases = parse_input(input_data) result = process_queries(t, cases) expected = [10] assert result == expected def test_process_queries_large_values(): input_data = f1 10 5 {\\" \\".join(str(10000) for _ in range(10))} 1 2 3 5 10 t, cases = parse_input(input_data) result = process_queries(t, cases) expected = [10000, 20000, 30000, 50000, 100000] assert result == expected def test_parse_input(): input_data = 1 5 3 4 2 8 5 7 3 5 1 t, cases = parse_input(input_data) expected_cases = [{'n': 5, 'q': 3, 'stamps': [4, 2, 8, 5, 7], 'queries': [3, 5, 1]}] expected_t = 1 assert t == expected_t assert cases == expected_cases","solution":"def process_queries(t, cases): results = [] for case in cases: n, q = case['n'], case['q'] stamps = case['stamps'] queries = case['queries'] # Compute prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + stamps[i - 1] # Answer queries for d in queries: results.append(prefix_sums[d]) return results def parse_input(input_data): Parses the input data in the format described in the problem statement. lines = input_data.strip().split(\\"n\\") t = int(lines[0]) index = 1 cases = [] for _ in range(t): n, q = map(int, lines[index].split()) index += 1 stamps = list(map(int, lines[index].split())) index += 1 queries = [] for _ in range(q): queries.append(int(lines[index])) index += 1 cases.append({'n': n, 'q': q, 'stamps': stamps, 'queries': queries}) return t, cases"},{"question":"def max_overlapping_events(n: int, events: List[Tuple[int, int]]) -> int: Calculate the maximum number of overlapping events at any point in time. Parameters: n (int): Number of events events (List[Tuple[int, int]]): List of tuples where each tuple represents (start, end) of an event Returns: int: The maximum number of overlapping events >>> max_overlapping_events(5, [(1, 3), (2, 5), (4, 6), (5, 8), (7, 9)]) 3 >>> max_overlapping_events(3, [(1, 2), (3, 4), (5, 6)]) 1 >>> max_overlapping_events(1, [(1, 5)]) 1 >>> max_overlapping_events(3, [(1, 10), (2, 9), (3, 8)]) 3 >>> max_overlapping_events(3, [(1, 1000000000), (500000000, 1000000000), (500000000, 1000000000)]) 3","solution":"def max_overlapping_events(n, events): This function calculates the maximum number of overlapping events at any point in time. Parameters: n (int): Number of events events (List[Tuple[int, int]]): List of tuples where each tuple represents (start, end) of an event Returns: int: The maximum number of overlapping events times = [] for start, end in events: times.append((start, 1)) # Event starting times.append((end + 1, -1)) # Event ending times.sort() max_overlap = 0 current_overlap = 0 for time, increment in times: current_overlap += increment max_overlap = max(max_overlap, current_overlap) return max_overlap"},{"question":"from typing import List, Tuple def get_max_performance(n: int, d: int, k: int, speeds: List[int], stamina: List[int]) -> Tuple[float, List[int], List[int]]: Determine the optimal distribution of participants into two teams to maximize the total performance of both teams. >>> get_max_performance(5, 3, 2, [100, 200, 300, 400, 500], [10, 20, 30, 40, 50]) (desired_output, [nighttime_indices], [daytime_indices]) >>> get_max_performance(2, 1, 1, [100, 200], [50, 50]) (desired_output, [nighttime_indices], [daytime_indices]) Unit Test: def test_example_case(): n, d, k = 5, 3, 2 speeds = [100, 200, 300, 400, 500] stamina = [10, 20, 30, 40, 50] total_performance, nighttime_indices, daytime_indices = get_max_performance(n, d, k, speeds, stamina) assert total_performance > 0 assert len(daytime_indices) == d assert len(nighttime_indices) == k def test_minimum_case(): n, d, k = 2, 1, 1 speeds = [100, 200] stamina = [50, 50] total_performance, nighttime_indices, daytime_indices = get_max_performance(n, d, k, speeds, stamina) assert total_performance > 0 assert len(daytime_indices) == d assert len(nighttime_indices) == k def test_case_with_equal_ratios(): n, d, k = 4, 2, 2 speeds = [100, 100, 200, 200] stamina = [50, 50, 100, 100] total_performance, nighttime_indices, daytime_indices = get_max_performance(n, d, k, speeds, stamina) assert total_performance > 0 assert len(daytime_indices) == d assert len(nighttime_indices) == k def test_large_numbers(): n, d, k = 4, 2, 2 speeds = [1000, 2000, 3000, 4000] stamina = [1, 2, 3, 4] total_performance, nighttime_indices, daytime_indices = get_max_performance(n, d, k, speeds, stamina) assert total_performance > 0 assert len(daytime_indices) == d assert len(nighttime_indices) == k def test_random_case(): n, d, k = 3, 1, 2 speeds = [150, 120, 100] stamina = [30, 40, 50] total_performance, nighttime_indices, daytime_indices = get_max_performance(n, d, k, speeds, stamina) assert total_performance > 0 assert len(daytime_indices) == d assert len(nighttime_indices) == k","solution":"def get_max_performance(n, d, k, speeds, stamina): participants = [(speeds[i], stamina[i], i + 1) for i in range(n)] participants.sort(key=lambda x: x[0] / x[1], reverse=True) daytime_team = participants[:d] nighttime_team = participants[d:d + k] daytime_performance = sum([x[0] for x in daytime_team]) / sum([x[1] for x in daytime_team]) nighttime_performance = sum([x[0] for x in nighttime_team]) / sum([x[1] for x in nighttime_team]) total_performance = daytime_performance + nighttime_performance daytime_indices = [x[2] for x in daytime_team] nighttime_indices = [x[2] for x in nighttime_team] return total_performance, nighttime_indices, daytime_indices"},{"question":"def max_stack_height(buildings: List[int]) -> int: Determine the maximum height of the stacked building that can be achieved by rearranging the given buildings such that each building stacked above another has a strictly lesser height. Args: buildings (List[int]): List of integers representing the heights of the buildings. Returns: int: Maximum height of the stacked building. Examples: >>> max_stack_height([1, 2, 3, 4, 5]) 15 >>> max_stack_height([4, 8, 2, 3, 6, 1]) 24 >>> max_stack_height([5, 5, 5, 5]) 20 >>> max_stack_height([6, 5, 4, 3, 2, 1]) 21 >>> max_stack_height([3, 1, 4, 1, 5, 9, 2, 6]) 31","solution":"from typing import List def max_stack_height(buildings: List[int]) -> int: Function to determine the maximum height of the stacked building that can be achieved. Args: buildings (List[int]): List of integers representing the heights of the buildings. Returns: int: Maximum height of the stacked building. # Sort the buildings in ascending order buildings.sort() # Initialize the maximum height max_height = 0 # Compute the maximum height by summing up the sorted list for height in buildings: max_height += height return max_height"},{"question":"def max_savings(n: int, shops: List[Tuple[int, int]]) -> int: Determines the maximum amount of money Mishka can save by using the discount in different shops. :param n: The number of shops (integer) :param shops: A list of tuples where each tuple contains two integers (price and discount percentage) of the smartphone in the i-th shop. :return: The maximum amount of money Mishka can save (integer) >>> max_savings(3, [(1000, 10), (2000, 20), (1500, 5)]) == 400 >>> max_savings(2, [(1000, 10), (5000, 30)]) == 1500 >>> max_savings(1, [(1000, 50)]) == 500 >>> max_savings(3, [(1000, 0), (2000, 0), (1500, 0)]) == 0","solution":"def max_savings(n, shops): Determines the maximum amount of money Mishka can save by using the discount in different shops. :param n: The number of shops (integer) :param shops: A list of tuples where each tuple contains two integers (price, discount percentage) of the smartphone in the i-th shop. :return: The maximum amount of money Mishka can save (integer) max_saving = 0 for price, discount in shops: savings = price * discount / 100 if savings > max_saving: max_saving = savings return int(max_saving)"},{"question":"def can_form_subsequence(s: str, t: str) -> str: Determine if t can be a subsequence of any rearrangement of s. :param s: The input string from which we need to derive t. :param t: The target subsequence string. :return: 'YES' if t can be a subsequence of any rearranged version of s, otherwise 'NO'. >>> can_form_subsequence(\\"abacbc\\", \\"abc\\") 'YES' >>> can_form_subsequence(\\"xyz\\", \\"ab\\") 'NO'","solution":"def can_form_subsequence(s, t): Determine if t can be a subsequence of any rearrangement of s. :param s: The input string from which we need to derive t. :param t: The target subsequence string. :return: 'YES' if t can be a subsequence of any rearranged version of s, otherwise 'NO'. from collections import Counter counter_s = Counter(s) counter_t = Counter(t) for char in counter_t: if counter_t[char] > counter_s.get(char, 0): return \\"NO\\" return \\"YES\\""},{"question":"def beautiful_moments(n: int, k: int, arr: List[int]) -> int: Returns the number of beautiful moments defined for any pair of numbers if their sum is equal to a given target k. Args: n: int - number of elements in the array. k: int - target sum. arr: List[int] - list of non-negative integers. Returns: int - the total number of beautiful moments. >>> beautiful_moments(5, 10, [1, 9, 3, 7, 5]) 2 >>> beautiful_moments(5, 10, [1, 2, 3, 4, 5]) 0 >>> beautiful_moments(4, 10, [5, 5, 5, 5]) 6 pass","solution":"def beautiful_moments(n, k, arr): Returns the number of beautiful moments defined for any pair of numbers if their sum is equal to a given target k. Args: n: int - number of elements in the array. k: int - target sum. arr: List[int] - list of non-negative integers. Returns: int - the total number of beautiful moments. count = 0 # Check pairs (i, j) where 1 <= i < j <= n for i in range(n): for j in range(i + 1, n): if arr[i] + arr[j] == k: count += 1 return count"},{"question":"def can_be_palindrome(s: str) -> str: Determine if a given string can be transformed into a palindrome by removing at most one character. >>> can_be_palindrome(\\"abca\\") \\"YES\\" >>> can_be_palindrome(\\"abcdef\\") \\"NO\\"","solution":"def can_be_palindrome(s: str) -> str: Returns \\"YES\\" if the string can be transformed into a palindrome by removing at most one character, otherwise returns \\"NO\\". def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check both possibilities: skipping left or right character if is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1): return \\"YES\\" return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def minimum_removed_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: This function computes the minimum total weight of the edges that need to be removed so that the remaining graph becomes a spanning tree. Parameters: n (int): number of vertices m (int): number of edges edges (List[Tuple[int, int, int]]): list of edges where each edge is represented as a tuple (u, v, w) Returns: int: the minimum total weight of the edges to be removed Example: >>> minimum_removed_weight(4, 5, [(1, 2, 3), (1, 3, 2), (1, 4, 4), (2, 3, 1), (3, 4, 5)]) 8 >>> minimum_removed_weight(2, 1, [(1, 2, 1)]) 0 >>> minimum_removed_weight(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3 >>> minimum_removed_weight(4, 5, [(1, 2, 10000), (1, 3, 2), (1, 4, 4), (2, 3, 1), (3, 4, 9999)]) 19999","solution":"import heapq def minimum_removed_weight(n, m, edges): This function computes the minimum total weight of the edges that need to be removed so that the remaining graph becomes a spanning tree. Parameters: n (int): number of vertices m (int): number of edges edges (List[Tuple[int, int, int]]): list of edges where each edge is represented as a tuple (u, v, w) Returns: int: the minimum total weight of the edges to be removed # Using Kruskal's algorithm to find the weight of the minimum spanning tree (MST) # Sort all edges in non-decreasing order edges.sort(key=lambda x: x[2]) # Helper function to find the root of a vertex def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to perform union of two sets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 mst_edges = [] for edge in edges: u, v, w = edge u -= 1 v -= 1 uroot = find(parent, u) vroot = find(parent, v) if uroot != vroot: mst_weight += w mst_edges.append(edge) union(parent, rank, uroot, vroot) # Calculate the total weight of all edges total_weight = sum(w for u, v, w in edges) # The result is the total weight of all edges minus the weight of MST return total_weight - mst_weight"},{"question":"def can_plant_flowers(n: int, m: int, flower_beds: List[List[int]]) -> Tuple[str, List[int]]: Determine if it's possible to plant flowers in the required way, and if possible, provide a valid configuration. Args: n : int : number of flower beds m : int : number of flower types flower_beds : List[List[int]] : list of allowed flower types for each bed Returns: Tuple[str, List[int]] : \\"YES\\" and a valid configuration list if possible, otherwise \\"NO\\" and empty list >>> can_plant_flowers(3, 3, [[1, 2], [2, 3], [1, 3]]) (\\"YES\\", [1, 2, 3]) >>> can_plant_flowers(3, 3, [[1, 2], [1, 2], [1, 2]]) (\\"NO\\", []) >>> can_plant_flowers(1, 1, [[1]]) (\\"YES\\", [1]) >>> can_plant_flowers(4, 4, [[1, 2], [2, 3], [3, 4], [1, 4]]) (\\"YES\\", [1, 2, 3, 4]) >>> can_plant_flowers(4, 4, [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]) (\\"YES\\", [1, 2, 3, 4]) >>> flower_beds = [[i] for i in range(1, 1001)] >>> can_plant_flowers(1000, 1000, flower_beds) (\\"YES\\", list(range(1, 1001)))","solution":"def can_plant_flowers(n, m, flower_beds): Determine if it's possible to plant flowers in the required way, and if possible, provide a valid configuration. from collections import defaultdict flower_assignments = [-1] * n used_flowers = set() def assign_flower(bed_idx): for flower in flower_beds[bed_idx]: if flower not in used_flowers: flower_assignments[bed_idx] = flower used_flowers.add(flower) return True return False for i in range(n): if not assign_flower(i): return \\"NO\\", [] return \\"YES\\", flower_assignments"},{"question":"def has_special_star_sequence(n: int, m: int, k: int, d: int, S: List[int]) -> str: Determines if there exists a continuous subsequence of length m in S whose sum is divisible by d. Parameters: n (int): Length of the sequence S m (int): Length of the subsequence k (int): Maximum value in the sequence S d (int): The number by which the sum of the subsequence should be divisible S (list): The sequence of integers Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" >>> has_special_star_sequence(5, 3, 10, 5, [2, 3, 5, 1, 10]) \\"YES\\" >>> has_special_star_sequence(5, 3, 10, 7, [2, 3, 5, 1, 10]) \\"NO\\"","solution":"def has_special_star_sequence(n, m, k, d, S): Determines if there exists a continuous subsequence of length m in S whose sum is divisible by d. Parameters: n (int): Length of the sequence S m (int): Length of the subsequence k (int): Maximum value in the sequence S d (int): The number by which the sum of the subsequence should be divisible S (list): The sequence of integers Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\" for i in range(n - m + 1): if sum(S[i:i+m]) % d == 0: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string s and a list of queries (l, r), return a list of integer results for each query, where each result is the number of distinct characters in the substring s[l:r+1]. Parameters: s (str): The input string. queries (list[tuple[int, int]]): The list of queries. Returns: list[int]: A list of resulting distinct character counts for each query. Examples: >>> count_distinct_characters(\\"abracadabra\\", [(0, 2)]) [3] >>> count_distinct_characters(\\"abracadabra\\", [(0, 2), (1, 4), (0, 10)]) [3, 4, 5] def test_single_query(): s = \\"abracadabra\\" queries = [(0, 2)] assert count_distinct_characters(s, queries) == [3] def test_multiple_queries(): s = \\"abracadabra\\" queries = [(0, 2), (1, 4), (0, 10)] assert count_distinct_characters(s, queries) == [3, 4, 5] def test_identical_start_and_end(): s = \\"abracadabra\\" queries = [(5, 5)] assert count_distinct_characters(s, queries) == [1] def test_full_string(): s = \\"abracadabra\\" queries = [(0, len(s)-1)] assert count_distinct_characters(s, queries) == [5] def test_varied_queries(): s = \\"aabbccddeeff\\" queries = [(0, 1), (2, 3), (4, 5), (0, 11)] assert count_distinct_characters(s, queries) == [1, 1, 1, 6]","solution":"def count_distinct_characters(s, queries): Given a string s and a list of queries (l, r), return a list of integer results for each query, where each result is the number of distinct characters in the substring s[l:r+1]. Parameters: s (str): The input string. queries (list[tuple[int, int]]): The list of queries. Returns: list[int]: A list of resulting distinct character counts for each query. result = [] for l, r in queries: substring = s[l:r+1] distinct_characters = len(set(substring)) result.append(distinct_characters) return result"},{"question":"def max_game_minutes(n: int, games: List[int]) -> int: Returns the maximum number of game minutes Kaito can play in a single game session. He can start from the beginning or the end of the array. >>> max_game_minutes(1, [5]) 5 >>> max_game_minutes(5, [2, 2, 2, 2, 2]) 10 >>> max_game_minutes(5, [1, 2, 3, 4, 5]) 15 >>> max_game_minutes(6, [3, 1, 4, 1, 5, 9]) 23 >>> max_game_minutes(2, [10, 20]) 30 >>> max_game_minutes(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 55 >>> max_game_minutes(100000, [1]*100000) 100000","solution":"def max_game_minutes(n, games): Returns the maximum number of game minutes Kaito can play in a single game session. He can start from the beginning or the end of the array. if n == 1: return games[0] max_from_start = sum(games) max_from_end = sum(games[::-1]) return max(max_from_start, max_from_end)"},{"question":"def is_cycle(n: int, m: int, ropes: List[Tuple[int, int]]) -> str: Determines if the given set of ropes can form a single cycle involving all trapeze artists. Args: n (int): The number of trapeze artists. m (int): The number of ropes. ropes (List[Tuple[int, int]]): A list of tuples where each tuple represents a rope connecting two artists. Returns: str: \\"YES\\" if it's possible to form a single cycle with the given ropes, otherwise \\"NO\\". >>> is_cycle(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"YES\\" >>> is_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) \\"NO\\" >>> is_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\" >>> is_cycle(3, 4, [(1, 2), (2, 3), (3, 1), (1, 3)]) \\"NO\\" >>> is_cycle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) \\"NO\\" >>> is_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\"","solution":"def is_cycle(n, m, ropes): if m != n: return \\"NO\\" from collections import defaultdict, deque adjacent = defaultdict(list) for u, v in ropes: adjacent[u].append(v) adjacent[v].append(u) for key in adjacent: if len(adjacent[key]) != 2: return \\"NO\\" # Function for BFS to check connectivity def bfs(source): visited = set() queue = deque([source]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in adjacent[node]: if neighbor not in visited: queue.append(neighbor) return visited # Check if all nodes are connected visited = bfs(1) return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"from typing import Union def iahub_string_rearrangement(n: int, s: str) -> Union[str, int]: Iahub likes playing with strings and puzzles. He came up with an interesting problem for you. You are given a string \`s\` of length \`n\` consisting of lowercase English letters. Iahub wants to rearrange the letters of the string in such a way that there are no two adjacent characters that are the same. If such a rearrangement is possible, print any one of the possible solutions. Otherwise, print \`-1\`. >>> iahub_string_rearrangement(3, \\"aab\\") 'aba' >>> iahub_string_rearrangement(2, \\"aa\\") -1 >>> iahub_string_rearrangement(1, \\"a\\") 'a' >>> iahub_string_rearrangement(5, \\"aaaab\\") -1 >>> iahub_string_rearrangement(16, \\"aabbccddeeffgghh\\") 'abcdefgehgfdcba' # Any valid arrangement >>> iahub_string_rearrangement(15, \\"aabbccddeeffggh\\") 'abcdefgefcdba' # Any valid arrangement","solution":"from collections import Counter import heapq def rearrange_string(s): n = len(s) freq_counter = Counter(s) # max heap by frequency max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap or prev_freq < 0: if not max_heap and prev_freq < 0: return -1 # not possible to rearrange if max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: # push the previous character back to heap if it still has remaining count heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # maintain the count of previous character return ''.join(result) def iahub_string_rearrangement(n, s): rearranged = rearrange_string(s) return rearranged"},{"question":"def is_safe_interval(r: int, a: int, resource_intervals: List[Tuple[int, int]], attack_intervals: List[Tuple[int, int]]) -> str: Determines if there is at least one resource interval completely free from any attack. :param r: Number of resource intervals :param a: Number of attack intervals :param resource_intervals: List of tuples representing the start and end of resource intervals :param attack_intervals: List of tuples representing the start and end of attack intervals :return: \\"YES\\" if there's at least one safe interval, \\"NO\\" otherwise >>> is_safe_interval(3, 2, [(1, 5), (10, 15), (20, 25)], [(3, 4), (18, 22)]) \\"YES\\" >>> is_safe_interval(2, 2, [(1, 5), (10, 15)], [(3, 6), (14, 16)]) \\"NO\\"","solution":"def is_safe_interval(r, a, resource_intervals, attack_intervals): Determines if there is at least one resource interval completely free from any attack. :param r: Number of resource intervals :param a: Number of attack intervals :param resource_intervals: List of tuples representing the start and end of resource intervals :param attack_intervals: List of tuples representing the start and end of attack intervals :return: \\"YES\\" if there's at least one safe interval, \\"NO\\" otherwise for res_start, res_end in resource_intervals: safe = True for att_start, att_end in attack_intervals: if not (res_end <= att_start or res_start >= att_end): safe = False break if safe: return \\"YES\\" return \\"NO\\""},{"question":"class NumberArray: def __init__(self, nums): self.nums = nums def update(self, i, x): Update the i-th element (1-indexed) of the array to x. def query(self, l, r): Return the sum of the elements in the range from l to r (1-indexed), inclusive. def handle_queries(n, q, nums, queries): Handle a sequence of update and query operations on an array. Args: n (int): Number of elements in the array. q (int): Number of queries. nums (List[int]): Initial values of the array. queries (List[Tuple[int, int, int]]): List of queries where each query is a tuple (type, param1, param2). Returns: List[int]: List of results for each of the sum queries. >>> handle_queries(6, 5, [1, 2, 3, 4, 5, 6], [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 2, 5), (1, 6, 7)]) [6, 14, 22] >>> handle_queries(5, 4, [1, 2, 3, 4, 5], [(2, 1, 5), (2, 1, 3), (2, 2, 4), (2, 3, 5)]) [15, 6, 9, 12] from solution import handle_queries def test_handle_queries(): # Example test case n, q = 6, 5 nums = [1, 2, 3, 4, 5, 6] queries = [ (2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 2, 5), (1, 6, 7), ] expected_output = [6, 14, 22] assert handle_queries(n, q, nums, queries) == expected_output def test_only_updates(): n, q = 5, 5 nums = [1, 2, 3, 4, 5] queries = [ (1, 1, 10), (1, 2, 20), (1, 3, 30), (1, 4, 40), (1, 5, 50), ] expected_output = [] assert handle_queries(n, q, nums, queries) == expected_output def test_only_queries(): n, q = 5, 4 nums = [1, 2, 3, 4, 5] queries = [ (2, 1, 5), (2, 1, 3), (2, 2, 4), (2, 3, 5), ] expected_output = [15, 6, 9, 12] assert handle_queries(n, q, nums, queries) == expected_output def test_mixed_queries(): n, q = 5, 7 nums = [1, 2, 3, 4, 5] queries = [ (2, 1, 5), (1, 3, 6), (2, 1, 5), (1, 4, 7), (2, 2, 5), (1, 5, 8), (2, 1, 5), ] expected_output = [15, 18, 20, 24] assert handle_queries(n, q, nums, queries) == expected_output","solution":"class NumberArray: def __init__(self, nums): self.nums = nums def update(self, i, x): Update the i-th element (1-indexed) of the array to x. self.nums[i - 1] = x def query(self, l, r): Return the sum of the elements in the range from l to r (1-indexed), inclusive. return sum(self.nums[l - 1:r]) def handle_queries(n, q, nums, queries): na = NumberArray(nums) # Initialize the NumberArray with initial values results = [] for query in queries: if query[0] == 1: na.update(query[1], query[2]) # 1 i x elif query[0] == 2: result = na.query(query[1], query[2]) # 2 l r results.append(result) return results"},{"question":"def find_minimum_travel_expenses(input_data: str): Given the number of castles, roads connecting them and their tolls, compute the minimum travel expenses in gold coins for each possible pair of castles. >>> input_data = \\"4 5n1 2 1n2 3 2n3 4 1n4 1 2n1 3 1n\\" >>> find_minimum_travel_expenses(input_data) [[0, 1, 1, 2], [1, 0, 2, 3], [1, 2, 0, 1], [2, 3, 1, 0]] >>> input_data = \\"3 0n\\" >>> find_minimum_travel_expenses(input_data) [[0, \\"INF\\", \\"INF\\"], [\\"INF\\", 0, \\"INF\\"], [\\"INF\\", \\"INF\\", 0]] >>> input_data = \\"3 3n1 2 0n2 3 0n1 3 0n\\" >>> find_minimum_travel_expenses(input_data) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> input_data = \\"4 2n1 2 3n3 4 4n\\" >>> find_minimum_travel_expenses(input_data) [[0, 3, \\"INF\\", \\"INF\\"], [3, 0, \\"INF\\", \\"INF\\"], [\\"INF\\", \\"INF\\", 0, 4], [\\"INF\\", \\"INF\\", 4, 0]] >>> input_data = \\"2 1n1 2 1000n\\" >>> find_minimum_travel_expenses(input_data) [[0, 1000], [1000, 0]]","solution":"def floyd_warshall(p, q, roads): INF = float('inf') dist = [[INF] * p for _ in range(p)] for i in range(p): dist[i][i] = 0 for a, b, c in roads: dist[a-1][b-1] = c dist[b-1][a-1] = c for k in range(p): for i in range(p): for j in range(p): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] for i in range(p): for j in range(p): if dist[i][j] == INF: dist[i][j] = \\"INF\\" return dist def parse_input(input_data): lines = input_data.strip().split(\\"n\\") p, q = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return p, q, roads def find_minimum_travel_expenses(input_data): p, q, roads = parse_input(input_data) return floyd_warshall(p, q, roads)"},{"question":"def min_subset_diff(tasks: List[int]) -> int: Given an array of task costs, partition the array into two subsets such that the absolute difference in their sums is minimized. Return the minimum possible absolute difference. >>> min_subset_diff([1, 2, 3, 4, 5]) 1 >>> min_subset_diff([4, 4, 4, 4]) 0 >>> min_subset_diff([100, 200, 300, 400]) 0","solution":"def min_subset_diff(tasks): n = len(tasks) total_sum = sum(tasks) dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum + 1): if j >= tasks[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - tasks[i - 1]] else: dp[i][j] = dp[i - 1][j] min_diff = float('inf') for j in range(total_sum // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_sum - 2 * j) return min_diff # Example usage: tasks = [1, 2, 3, 4, 5] print(min_subset_diff(tasks)) # Output: 1"},{"question":"from typing import List, Tuple def can_accommodate_all_spaceships(n: int, m: int, schedules: List[Tuple[int, int]]) -> str: Determines whether all spaceships can be accommodated by the available docking bays. :param n: int - Number of docking bays :param m: int - Number of spaceships :param schedules: List of tuples - Each tuple contains two integers representing the arrival and departure time of a spaceship :return: str - \\"YES\\" if all spaceships can be accommodated, otherwise \\"NO\\" pass # Unit Tests def test_example_1(): n = 3 m = 5 schedules = [(1, 4), (2, 6), (8, 9), (3, 7), (5, 8)] assert can_accommodate_all_spaceships(n, m, schedules) == \\"YES\\" def test_example_2(): n = 2 m = 4 schedules = [(3, 5), (4, 6), (2, 8), (7, 9)] assert can_accommodate_all_spaceships(n, m, schedules) == \\"NO\\" def test_minimum_input(): n = 1 m = 1 schedules = [(1, 1)] assert can_accommodate_all_spaceships(n, m, schedules) == \\"YES\\" def test_all_overlapping(): n = 2 m = 3 schedules = [(1, 4), (2, 5), (3, 6)] assert can_accommodate_all_spaceships(n, m, schedules) == \\"NO\\" def test_all_non_overlapping(): n = 2 m = 3 schedules = [(1, 2), (3, 4), (5, 6)] assert can_accommodate_all_spaceships(n, m, schedules) == \\"YES\\" def test_boundary_case(): n = 1000 m = 1000 schedules = [(1, 2)] * 1000 assert can_accommodate_all_spaceships(n, m, schedules) == \\"YES\\"","solution":"def can_accommodate_all_spaceships(n, m, schedules): Returns \\"YES\\" if all spaceships can be accommodated by the available docking bays, otherwise \\"NO\\". :param n: int - Number of docking bays :param m: int - Number of spaceships :param schedules: List of tuples - Each tuple contains two integers representing the arrival and departure time of a spaceship :return: str - \\"YES\\" if all spaceships can be accommodated, otherwise \\"NO\\" events = [] for arrival, departure in schedules: events.append((arrival, 1)) # +1 spaceship arriving events.append((departure, -1)) # -1 spaceship departing events.sort() # Sort events by time. In case of tie, departure (-1) should come before arrival (+1) current_spaceships = 0 for event in events: current_spaceships += event[1] if current_spaceships > n: return \\"NO\\" return \\"YES\\""},{"question":"def isValid(s: str) -> bool: Determine if the input string containing characters '(', ')', '{', '}', '[' and ']' is valid. >>> isValid(\\"()\\") True >>> isValid(\\"()[]{}\\") True >>> isValid(\\"(]\\") False >>> isValid(\\"([)]\\") False >>> isValid(\\"{[]}\\") True","solution":"def isValid(s: str) -> bool: stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def merge_sorted_arrays(A, B): Merges two sorted arrays A and B into a single sorted array. Args: A (List[int]): List of sorted integers. B (List[int]): List of sorted integers. Returns: List[int]: A new list containing all elements from A and B in sorted order. Example: >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([1000000000, 1000000001], [1000000002, 1000000003]) [1000000000, 1000000001, 1000000002, 1000000003]","solution":"def merge_sorted_arrays(A, B): Merges two sorted arrays A and B into a single sorted array. n = len(A) C = [] i, j = 0, 0 while i < n and j < n: if A[i] < B[j]: C.append(A[i]) i += 1 else: C.append(B[j]) j += 1 # Append any remaining elements in A while i < n: C.append(A[i]) i += 1 # Append any remaining elements in B while j < n: C.append(B[j]) j += 1 return C"},{"question":"def correct_events(n: int, events: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Corrects the sequence of events so that each individual enters and exits the building properly. Parameters: n (int): Number of events. events (list of tuples): Each tuple contains (event_id, individual_id). Returns: list of tuples: Valid events in the corrected sequence. >>> correct_events(6, [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"EXIT\\", 2), (\\"ENTRY\\", 2), (\\"ENTRY\\", 2), (\\"EXIT\\", 1)]) [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"ENTRY\\", 2), (\\"EXIT\\", 1)] >>> correct_events(4, [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"EXIT\\", 2), (\\"ENTRY\\", 2)]) [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"ENTRY\\", 2)] >>> correct_events(6, [(\\"ENTRY\\", 1), (\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"ENTRY\\", 2), (\\"ENTRY\\", 2), (\\"EXIT\\", 2)]) [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"ENTRY\\", 2), (\\"EXIT\\", 2)] >>> correct_events(1, []) [] >>> correct_events(1, [(\\"ENTRY\\", 1)]) [(\\"ENTRY\\", 1)] >>> correct_events(1, [(\\"EXIT\\", 1)]) [] >>> correct_events(8, [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"EXIT\\", 2), (\\"ENTRY\\", 2), (\\"ENTRY\\", 2), (\\"EXIT\\", 1), (\\"ENTRY\\", 3), (\\"EXIT\\", 3)]) [(\\"ENTRY\\", 1), (\\"EXIT\\", 1), (\\"ENTRY\\", 2), (\\"ENTRY\\", 3), (\\"EXIT\\", 3)]","solution":"def correct_events(n, events): Corrects the sequence of events so that each individual enters and exits the building properly. Parameters: n (int): Number of events. events (list of tuples): Each tuple contains (event_id, individual_id). Returns: list of tuples: Valid events in the corrected sequence. current_in_building = set() valid_events = [] for event_id, individual_id in events: if event_id == \\"ENTRY\\": if individual_id in current_in_building: continue # Skip invalid entry if the person is already inside current_in_building.add(individual_id) elif event_id == \\"EXIT\\": if individual_id not in current_in_building: continue # Skip invalid exit if the person is not inside current_in_building.remove(individual_id) valid_events.append((event_id, individual_id)) return valid_events"},{"question":"from typing import List, Tuple def max_fun_factor(n: int, T: int, movies: List[Tuple[int, int]]) -> int: Determine the maximum fun factor Anna can achieve without exceeding the maximum total duration. Args: n : int : number of movies T : int : maximum total duration allowed for the marathon movies : List[Tuple[int, int]] : list of tuples where each tuple contains two integers representing the duration and fun factor of a movie Returns: int : maximum total fun factor Examples: >>> n = 4 >>> T = 10 >>> movies = [(4, 5), (3, 1), (2, 2), (5, 6)] >>> max_fun_factor(n, T, movies) 11 >>> n = 1 >>> T = 5 >>> movies = [(5, 10)] >>> max_fun_factor(n, T, movies) 10","solution":"def max_fun_factor(n, T, movies): # Initialize dp array where dp[j] represents maximum fun achievable with duration j dp = [0] * (T + 1) for duration, fun in movies: # Iterate backwards to prevent using the same movie more than once. for j in range(T, duration - 1, -1): dp[j] = max(dp[j], dp[j - duration] + fun) # The maximum fun factor is the maximum value in the dp array return max(dp) # Sample input and run for verification n = 4 T = 10 movies = [(4, 5), (3, 1), (2, 2), (5, 6)] print(max_fun_factor(n, T, movies)) # Expected output is 11"},{"question":"def is_valid_code(digits): Determines if the series of digits forms a valid identification code. A valid code must be in non-decreasing order. >>> is_valid_code([1, 2, 3, 4, 5]) True >>> is_valid_code([4, 4, 5, 6]) True >>> is_valid_code([7, 6, 8]) False pass def check_identification_codes(test_cases): For a list of test cases, each containing a number of digits and a series of digits, determine if each series forms a valid identification code. >>> check_identification_codes([(5, [1, 2, 3, 4, 5]), (4, [4, 4, 5, 6]), (3, [7, 6, 8])]) [\\"Valid\\", \\"Valid\\", \\"Invalid\\"] pass def main(input_data): Process input data to check if each participant's identification code is valid. >>> main(\\"3n5n1 2 3 4 5n4n4 4 5 6n3n7 6 8n\\") Valid Valid Invalid pass","solution":"def is_valid_code(digits): Determines if the series of digits forms a valid identification code. A valid code must be in non-decreasing order. for i in range(1, len(digits)): if digits[i] < digits[i - 1]: return False return True def check_identification_codes(test_cases): results = [] for t in test_cases: n, digits = t if is_valid_code(digits): results.append(\\"Valid\\") else: results.append(\\"Invalid\\") return results def main(input_data): input_lines = input_data.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) digits = list(map(int, input_lines[index + 1].split())) test_cases.append((n, digits)) index += 2 results = check_identification_codes(test_cases) for result in results: print(result)"},{"question":"def smallest_missing_integer(array: List[int]) -> int: Finds the smallest positive integer that is not present in any subarray of the given array. >>> smallest_missing_integer([1, 2, 2, 1, 3]) == 4 >>> smallest_missing_integer([1, 2, 3, 4, 5, 6]) == 7","solution":"def smallest_missing_integer(array): Finds the smallest positive integer that is not present in any subarray of the given array. n = len(array) present = [False] * (n + 2) # Marking the numbers present in the array for num in array: if 1 <= num <= n + 1: present[num] = True # Finding the smallest number not marked for i in range(1, n + 2): if not present[i]: return i"},{"question":"import heapq def shortest_delivery_times(n, m, roads): Returns the shortest delivery times from the warehouse (node 1) to each of the other locations. Parameters: n (int): The number of locations. m (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w indicating there is a road between locations u and v that requires w units of travel time. Returns: List[int]: The shortest travel time from the warehouse to each of the other locations. Unit Test: from solution import shortest_delivery_times def test_example_case(): assert shortest_delivery_times(4, 4, [(1, 2, 2), (2, 3, 4), (1, 3, 5), (3, 4, 1)]) == [2, 5, 6] def test_no_path(): assert shortest_delivery_times(3, 1, [(1, 2, 1)]) == [1, -1] def test_single_road(): assert shortest_delivery_times(2, 1, [(1, 2, 3)]) == [3] def test_multiple_paths(): assert shortest_delivery_times(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2)]) == [1, 2, 3] def test_all_disconnected(): assert shortest_delivery_times(4, 2, [(1, 2, 4), (3, 4, 5)]) == [4, -1, -1]","solution":"import heapq def shortest_delivery_times(n, m, roads): Returns the shortest delivery times from the warehouse (node 1) to each of the other locations. Parameters: n (int): The number of locations. m (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and w indicating there is a road between locations u and v that requires w units of travel time. Returns: List[int]: The shortest travel time from the warehouse to each of the other locations. # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find shortest path from source (node 1) pq = [(0, 1)] # (distance, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return [distances[i] if distances[i] != float('inf') else -1 for i in range(2, n + 1)]"},{"question":"from typing import List def tsp(cost_matrix: List[List[int]]) -> int: Determine the minimum travel cost required to visit all the tourist attractions starting from any tourist attraction and returning to the start point after visiting all the others exactly once. >>> tsp([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> tsp([ ... [0, 2], ... [2, 0] ... ]) 4 >>> tsp([ ... [0, 1, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 0, 1], ... [1, 1, 1, 0] ... ]) 4 >>> tsp([ ... [0, 2, 9, 10], ... [1, 0, 6, 4], ... [15, 7, 0, 8], ... [6, 3, 12, 0] ... ]) 21 >>> tsp([ ... [0, 9999, 9999, 9999], ... [9999, 0, 9999, 9999], ... [9999, 9999, 0, 9999], ... [9999, 9999, 9999, 0] ... ]) 39996 pass","solution":"from itertools import permutations def tsp(cost_matrix): Given a cost matrix, this function returns the minimum travel cost required to visit all tourist attractions starting and ending at any attraction. n = len(cost_matrix) attractions = list(range(n)) min_cost = float('inf') for perm in permutations(attractions[1:]): current_cost = 0 current_perm = [0] + list(perm) + [0] for i in range(len(current_perm) - 1): current_cost += cost_matrix[current_perm[i]][current_perm[i+1]] if current_cost < min_cost: min_cost = current_cost return min_cost"},{"question":"def longest_alternating_substring(s: str) -> int: Returns the length of the longest alternating substring in a binary string s. >>> longest_alternating_substring(\\"101010\\") # 6 >>> longest_alternating_substring(\\"1100\\") # 2 >>> longest_alternating_substring(\\"1001001110\\") # 3","solution":"def longest_alternating_substring(s): Returns the length of the longest alternating substring in a binary string s. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] != s[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def min_moves_to_sort(arr: List[int]) -> int: Determine the minimum number of moves required to sort the given array in ascending order. You are given an array consisting of n integers. You can move any integer any number of positions to the left or to the right in such a way that the resulting array remains sorted in ascending order. >>> min_moves_to_sort([1, 2, 3, 4, 5]) 0 >>> min_moves_to_sort([5, 4, 3, 2, 1]) 4 >>> min_moves_to_sort([3, 1, 2, 5, 4]) 2 >>> min_moves_to_sort([5, 5, 5, 5, 5]) 4 >>> min_moves_to_sort([1, 3, 2, 4, 8, 6, 7]) 2","solution":"def min_moves_to_sort(arr): n = len(arr) longest_increasing_subseq = [1] * n # Determine the longest increasing subsequence for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: longest_increasing_subseq[i] = max(longest_increasing_subseq[i], longest_increasing_subseq[j] + 1) # The minimum number of moves required to sort lis_length = max(longest_increasing_subseq) min_moves = n - lis_length return min_moves"},{"question":"def find_min_edge_for_one_component(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the smallest weight of an edge such that, by removing this edge and all edges with larger weights from the graph, the remaining graph has exactly one connected component. >>> find_min_edge_for_one_component(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) == 3 >>> find_min_edge_for_one_component(4, 4, [(1, 2, 10), (1, 3, 20), (1, 4, 30), (3, 4, 40)]) == 30 >>> find_min_edge_for_one_component(5, 5, [(1, 2, 1), (2, 3, 5), (3, 4, 10), (4, 5, 15), (5, 1, 20)]) == 15","solution":"def find_min_edge_for_one_component(n, m, edges): from heapq import heappop, heappush def union(parents, x, y): rootX = find(parents, x) rootY = find(parents, y) if rootX != rootY: if ranks[rootX] > ranks[rootY]: parents[rootY] = rootX elif ranks[rootX] < ranks[rootY]: parents[rootX] = rootY else: parents[rootY] = rootX ranks[rootX] += 1 def find(parents, x): if parents[x] != x: parents[x] = find(parents, parents[x]) return parents[x] edges = sorted(edges, key=lambda x: x[2]) parents = list(range(n+1)) ranks = [0] * (n+1) for u, v, w in edges: union(parents, u, v) if find(parents, 1) == find(parents, n): return w return -1 # if no such edge is found, although the problem guarantees the graph to be connected # Input def read_input(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 return n, m, edges if __name__ == \\"__main__\\": n, m, edges = read_input() print(find_min_edge_for_one_component(n, m, edges))"},{"question":"def minimize_weight_difference(n: int, k: int, weights: List[int]) -> int: Returns the minimum difference between the maximum and minimum weights among the selected k stones from the given list of weights. Parameters: n (int): The number of stones. k (int): The number of stones to be selected. weights (list of int): The weights of the stones. Returns: int: Minimum difference between the maximum and minimum weights among selected k stones. >>> minimize_weight_difference(5, 3, [4, 2, 1, 7, 5]) 3 >>> minimize_weight_difference(7, 4, [10, 20, 30, 40, 50, 60, 70]) 30","solution":"def minimize_weight_difference(n, k, weights): Returns the minimum difference between the maximum and minimum weights among the selected k stones from the given list of weights. Parameters: n (int): The number of stones. k (int): The number of stones to be selected. weights (list of int): The weights of the stones. Returns: int: Minimum difference between the maximum and minimum weights among selected k stones. weights.sort() min_diff = float('inf') for i in range(n - k + 1): current_diff = weights[i + k - 1] - weights[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def max_gem_variety(N: int, M: int, B: int, packs: List[Tuple[int, List[int]]]) -> int: Determine the maximum number of unique gem types that can be collected within a given budget using a list of gem packs. Args: N: int - The number of gem types M: int - The number of gem packs B: int - The budget packs: list of tuples - Each tuple consists of a cost and a list of gem types Returns: int - Maximum number of unique gem types that can be collected within the budget >>> max_gem_variety(5, 3, 10, [(7, [1, 2, 3]), (5, [4, 5]), (3, [1, 5])]) 4 >>> max_gem_variety(5, 1, 10, [(7, [1, 2, 3])]) 3 >>> max_gem_variety(6, 3, 15, [(5, [1, 2]), (5, [3, 4]), (5, [5, 6])]) 6 >>> max_gem_variety(5, 3, 2, [(3, [1, 2, 3]), (4, [4, 5]), (5, [1, 5])]) 0 >>> max_gem_variety(6, 4, 10, [(7, [1, 2, 3]), (5, [4, 5]), (3, [1, 5]), (5, [2, 6])]) 4","solution":"def max_gem_variety(N, M, B, packs): This function returns the maximum number of unique gem types that can be collected within a given budget using a list of gem packs. Args: N: int - The number of gem types M: int - The number of gem packs B: int - The budget packs: list of tuples - Each tuple consists of a cost and a list of gem types Returns: int - Maximum number of unique gem types that can be collected within the budget # Initialize the dp list with sets. dp = [set() for _ in range(B + 1)] # Loop through each pack and update the dp list based on the cost for cost, gems in packs: # We update from the highest budget to the lowest budget to avoid reuse of the same pack for current_budget in range(B, cost - 1, -1): if dp[current_budget - cost] or current_budget == cost: if new_set := dp[current_budget - cost].union(gems): dp[current_budget] = max(dp[current_budget], new_set, key=len) return max(len(gem_set) for gem_set in dp) # Sample input N, M, B = 5, 3, 10 packs = [ (7, [1, 2, 3]), (5, [4, 5]), (3, [1, 5]) ] result = max_gem_variety(N, M, B, packs) print(result)"},{"question":"def handle_operations(operations: List[str]) -> None: Perform a series of operations on the database dictionary, and print the results of 'QUERY' operations. >>> operations = [ ... \\"ADD P001 Widget 19.99 3\\", ... \\"ADD P002 Gadget 29.95 5\\", ... \\"QUERY P001\\", ... \\"QUERY P003\\", ... \\"REMOVE P002\\", ... \\"QUERY P002\\", ... \\"UPDATE P001 SuperWidget 24.99 10\\", ... \\"QUERY P001\\" ... ] ... ... handle_operations(operations) ProductID: [Widget, 19.99, 3] Product Not Found Product Not Found ProductID: [SuperWidget, 24.99, 10]","solution":"def handle_operations(operations): database = {} for operation in operations: parts = operation.split() command = parts[0] productID = parts[1] if command == \\"ADD\\": name, price, quantity = parts[2], float(parts[3]), int(parts[4]) database[productID] = {\\"name\\": name, \\"price\\": price, \\"quantity\\": quantity} elif command == \\"REMOVE\\": if productID in database: del database[productID] elif command == \\"UPDATE\\": if productID in database: name, price, quantity = parts[2], float(parts[3]), int(parts[4]) database[productID] = {\\"name\\": name, \\"price\\": price, \\"quantity\\": quantity} elif command == \\"QUERY\\": if productID in database: product = database[productID] print(f\\"ProductID: [{product['name']}, {product['price']}, {product['quantity']}]\\") else: print(\\"Product Not Found\\")"},{"question":"def min_stops_to_reach_destination(distances): Calculate the minimum number of stops the train needs to make to travel from the starting position to the destination. Parameters: distances (List[int]): The maximum distance the train can travel from each station. Returns: int: The minimum number of stops needed to reach the final station, or -1 if it is not possible. Examples: >>> min_stops_to_reach_destination([2, 3, 1, 1, 4]) 2 >>> min_stops_to_reach_destination([4, 2, 1, 2, 1]) 1 >>> min_stops_to_reach_destination([0, 2, 1, 2, 1]) -1 >>> min_stops_to_reach_destination([0]) 0 >>> min_stops_to_reach_destination([1, 1, 1, 1, 1]) 4 >>> min_stops_to_reach_destination([5, 1, 1, 1, 1]) 1 pass","solution":"def min_stops_to_reach_destination(distances): n = len(distances) if n == 1: return 0 max_reach = 0 steps = 0 last_stop = 0 for i in range(n): if i > max_reach: return -1 max_reach = max(max_reach, i + distances[i]) if i == last_stop: if i != n - 1: steps += 1 last_stop = max_reach return steps # Example usage # distances = [2, 3, 1, 1, 4] # result = min_stops_to_reach_destination(distances) # print(result) # Output: 2"},{"question":"def find_smallest_index(n: int, q: int, array: List[int], queries: List[int]) -> List[int]: Find the smallest index i (1-based) such that a_i >= k for each query. Return -1 if no such index exists. Example: >>> find_smallest_index(5, 3, [3, 8, 2, 7, 5], [4, 1, 9]) [2, 1, -1] >>> find_smallest_index(4, 2, [10, 20, 30, 40], [25, 5]) [3, 1] >>> find_smallest_index(3, 3, [10, 10, 10], [5, 10, 15]) [1, 1, -1] >>> find_smallest_index(3, 2, [1, 2, 3], [4, 0]) [-1, 1] >>> find_smallest_index(6, 3, [5, 4, 3, 2, 1, 6], [6, 1, 7]) [6, 1, -1]","solution":"def find_smallest_index(n, q, array, queries): results = [] for k in queries: result = -1 for i in range(n): if array[i] >= k: result = i + 1 break results.append(result) return results"},{"question":"def min_non_overlapping_intervals(events: List[List[int]]) -> int: Merge all overlapping events and return the minimum number of non-overlapping intervals. >>> min_non_overlapping_intervals([[1, 3], [2, 6], [8, 10], [15, 18], [17, 20], [5, 7]]) 3 >>> min_non_overlapping_intervals([]) 0 >>> min_non_overlapping_intervals([[1, 2]]) 1 >>> min_non_overlapping_intervals([[1, 2], [3, 4], [5, 6]]) 3 >>> min_non_overlapping_intervals([[1, 4], [2, 5], [3, 6]]) 1 >>> min_non_overlapping_intervals([[1, 4], [2, 3], [6, 7], [8, 10], [9, 11]]) 3","solution":"def min_non_overlapping_intervals(events): if not events: return 0 # Sort events based on the start time events.sort(key=lambda x: x[0]) # Initialize the list to hold the merged intervals merged = [events[0]] for i in range(1, len(events)): if events[i][0] <= merged[-1][1]: # Overlapping intervals merged[-1][1] = max(merged[-1][1], events[i][1]) else: merged.append(events[i]) return len(merged)"},{"question":"def organize_books(n: int, book_list: list) -> dict: Organizes books by genre and author as described in the problem statement. Args: n (int): The number of books. book_list (list of tuples): A list containing tuples with genre and author of each book. Returns: dict: A dictionary where the key is the genre and the value is a list of authors in their respective order. Examples: >>> organize_books(4, [('fantasy', 'rowling'), ('scifi', 'asimov'), ('fantasy', 'tolkien'), ('fantasy', 'rowling')]) {'fantasy': ['rowling', 'tolkien', 'rowling'], 'scifi': ['asimov']} >>> organize_books(3, [('fantasy', 'rowling'), ('scifi', 'asimov'), ('mystery', 'christie')]) {'fantasy': ['rowling'], 'scifi': ['asimov'], 'mystery': ['christie']}","solution":"def organize_books(n, book_list): Organizes books by genre and author as described in the problem statement. Args: n (int): The number of books. book_list (list of tuples): A list containing tuples with genre and author of each book. Returns: dict: A dictionary where the key is the genre and the value is a list of authors in their respective order. from collections import defaultdict genres = defaultdict(list) last_positions = defaultdict(lambda: defaultdict(int)) for idx in range(n): genre, author = book_list[idx] if author in last_positions[genre]: insert_position = last_positions[genre][author] genres[genre].insert(insert_position + 1, author) else: genres[genre].append(author) insert_position = len(genres[genre]) - 1 # update all positions for this author for i in range(insert_position + 1, len(genres[genre])): if genres[genre][i] == author: last_positions[genre][author] = i return {genre: genres[genre] for genre in sorted(genres)}"},{"question":"def is_magic_square_possible(n: int, grid: List[List[int]]) -> str: Determine if it's possible to complete a partially filled n x n grid into a magic square. >>> is_magic_square_possible(3, [[8, 1, 6], [3, 0, 7], [4, 9, 2]]) \\"YES\\" >>> is_magic_square_possible(3, [[8, 1, 6], [3, 0, 0], [0, 9, 2]]) \\"NO\\"","solution":"def is_magic_square_possible(n, grid): target_sum = n * (n * n + 1) // 2 def is_valid(x, y, val): row_sum = sum(grid[x]) + val - grid[x][y] col_sum = sum(grid[i][y] for i in range(n)) + val - grid[x][y] diag1_sum = sum(grid[i][i] for i in range(n)) if x == y else target_sum diag2_sum = sum(grid[i][n - 1 - i] for i in range(n)) if x == n - 1 - y else target_sum if row_sum != target_sum or col_sum != target_sum: return False if x == y and diag1_sum != target_sum: return False if x == n - 1 - y and diag2_sum != target_sum: return False return True def solve(index): if index == n * n: return all(sum(grid[i]) == target_sum for i in range(n)) and all(sum(grid[i][j] for i in range(n)) == target_sum for j in range(n)) and sum(grid[i][i] for i in range(n)) == target_sum and sum(grid[i][n - 1 - i] for i in range(n)) == target_sum x, y = divmod(index, n) if grid[x][y] != 0: return solve(index + 1) for val in range(1, n * n + 1): if val not in (grid[i][j] for i in range(n) for j in range(n)): grid[x][y] = val if is_valid(x, y, val): if solve(index + 1): return True grid[x][y] = 0 return False if solve(0): return \\"YES\\" return \\"NO\\""},{"question":"def game_winner(n: int, balls: List[int]) -> str: Determines if Alice can guarantee a win, assuming both players play optimally. :param n: Number of boxes :param balls: List containing the number of balls in each box :return: \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\" >>> game_winner(5, [1, 2, 0, 4, 3]) \\"Alice\\" >>> game_winner(4, [1, 1, 1, 1]) \\"Bob\\" >>> game_winner(1, [1]) \\"Alice\\" >>> game_winner(1, [0]) \\"Bob\\" >>> game_winner(3, [0, 0, 0]) \\"Bob\\" >>> game_winner(6, [4, 1, 2, 1, 7, 6]) \\"Alice\\"","solution":"def game_winner(n, balls): Determines if Alice can guarantee a win, assuming both players play optimally. :param n: Number of boxes :param balls: List containing the number of balls in each box :return: \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\" xor_sum = 0 for ball_count in balls: xor_sum ^= ball_count return \\"Alice\\" if xor_sum != 0 else \\"Bob\\""},{"question":"def find_cities_with_two_connections(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the maximum number of cities that need to be connected to exactly two other cities to ensure robustness in the railway network. Args: n (int): The total number of cities. m (int): The total number of connections. connections (List[Tuple[int, int]]): A list of tuples where each tuple represents a direct connection between two cities. Returns: int: The maximum number of cities that need to be connected to exactly two other cities. >>> find_cities_with_two_connections(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3 >>> find_cities_with_two_connections(3, 1, [(1, 2)]) 0 >>> find_cities_with_two_connections(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) 6 >>> find_cities_with_two_connections(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 4 >>> find_cities_with_two_connections(3, 2, [(1, 2), (2, 3)]) 1","solution":"def find_cities_with_two_connections(n, m, connections): from collections import defaultdict # Creating a dictionary to store the degree of each city degree = defaultdict(int) # Iterating over each connection to calculate the degree of each city for a, b in connections: degree[a] += 1 degree[b] += 1 # Initialize counter for cities with exactly two connections count = 0 # Iterate through the dictionary to count cities with exactly two connections for city in degree: if degree[city] == 2: count += 1 return count # Example usage n, m = 5, 4 connections = [(1, 2), (2, 3), (3, 4), (4, 5)] print(find_cities_with_two_connections(n, m, connections)) # Output should be 3"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Returns the maximum possible sum of a subsequence of \`arr\` such that no two elements of the subsequence are adjacent. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([1, 2, 3, 4, 5, 6, 7]) 16 >>> max_non_adjacent_sum([5, 5, 5, 5]) 10 >>> max_non_adjacent_sum([10000, 1, 10000, 1, 10000]) 30000 >>> max_non_adjacent_sum([1000, 1, 1000, 1, 1000, 1, 1000]) 4000","solution":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of a subsequence of \`arr\` such that no two elements of the subsequence are adjacent. incl = 0 # Maximum sum including the previous element excl = 0 # Maximum sum excluding the previous element for num in arr: new_excl = max(incl, excl) # Current max excluding this element incl = excl + num # Current max including this element excl = new_excl # Update excl to new_excl return max(incl, excl)"},{"question":"def process_commands(n: int, q: int, commands: List[str], d: int) -> List[str]: Processes the list of commands for borrowing or returning books and prints whether each action is \\"ok\\" or \\"impossible\\". :param n: int, number of books :param q: int, number of commands :param commands: list of strings, commands to process :param d: int, maximum allowed borrowing days :return: list of strings, results of each command >>> n, q, commands, d = 3, 6, [\\"borrow 1 5\\", \\"borrow 2 3\\", \\"borrow 1 2\\", \\"return 1\\", \\"borrow 3 10\\", \\"return 2\\"], 7 >>> process_commands(n, q, commands, d) ['ok', 'ok', 'impossible', 'ok', 'impossible', 'ok'] >>> n, q, commands, d = 2, 2, [\\"borrow 1 2\\", \\"return 1\\"], 5 >>> process_commands(n, q, commands, d) ['ok', 'ok'] >>> n, q, commands, d = 1, 3, [\\"borrow 1 6\\", \\"borrow 1 5\\", \\"return 1\\"], 5 >>> process_commands(n, q, commands, d) ['impossible', 'ok', 'ok'] >>> n, q, commands, d = 1, 1, [\\"return 1\\"], 5 >>> process_commands(n, q, commands, d) ['impossible'] >>> n, q, commands, d = 1, 4, [\\"borrow 1 5\\", \\"return 1\\", \\"borrow 1 4\\", \\"return 1\\"], 5 >>> process_commands(n, q, commands, d) ['ok', 'ok', 'ok', 'ok'] >>> n, q, commands, d = 3, 5, [\\"borrow 1 7\\", \\"borrow 2 5\\", \\"return 1\\", \\"borrow 3 2\\", \\"return 2\\"], 7 >>> process_commands(n, q, commands, d) ['ok', 'ok', 'ok', 'ok', 'ok'] >>> n, q, commands, d = 1, 1, [\\"borrow 1 1\\"], 1 >>> process_commands(n, q, commands, d) ['ok']","solution":"def process_commands(n, q, commands, d): Processes the list of commands for borrowing or returning books and prints whether each action is \\"ok\\" or \\"impossible\\". :param n: int, number of books :param q: int, number of commands :param commands: list of strings, commands to process :param d: int, maximum allowed borrowing days :return: list of strings, results of each command # Dictionary to track whether a book is currently borrowed or not books = { i: False for i in range(1, n+1) } results = [] for command in commands: cmd_parts = command.split() action = cmd_parts[0] book_id = int(cmd_parts[1]) if action == \\"borrow\\": days = int(cmd_parts[2]) if books[book_id] or days > d: results.append(\\"impossible\\") else: books[book_id] = True results.append(\\"ok\\") elif action == \\"return\\": if not books[book_id]: results.append(\\"impossible\\") else: books[book_id] = False results.append(\\"ok\\") return results"},{"question":"def beauty_score(n: int, m: int, seq1: str, seq2: str) -> int: Returns the beauty score of the most beautiful sequence that can be created by concatenating the two given sequences exactly once. >>> beauty_score(3, 6, \\"aaa\\", \\"bbbbbb\\") 6 >>> beauty_score(3, 3, \\"abc\\", \\"aaa\\") 3","solution":"def beauty_score(n, m, seq1, seq2): Returns the beauty score of the most beautiful sequence that can be created by concatenating the two given sequences exactly once. concatenated_seq = seq1 + seq2 max_beauty = 1 current_char = concatenated_seq[0] current_streak = 1 for i in range(1, len(concatenated_seq)): if concatenated_seq[i] == current_char: current_streak += 1 else: max_beauty = max(max_beauty, current_streak) current_char = concatenated_seq[i] current_streak = 1 max_beauty = max(max_beauty, current_streak) return max_beauty"},{"question":"def most_visited_websites(n: int, m: int, visits: list[tuple[int, int, int]]) -> list[str]: Compute and report the most visited website and the total duration for each of the 'n' employees. Args: - n (int): number of employees - m (int): number of visits - visits (list of tuples): Each visit is represented as (employee_id, website_id, duration) Returns: - list of strings: For each employee, output in the format \\"employee_id website_id total_duration\\" or \\"employee_id No visits\\". Example: >>> most_visited_websites(4, 5, [(1, 2, 300), (1, 3, 200), (2, 2, 500), (3, 3, 100), (3, 2, 100)]) [\\"1 2 300\\", \\"2 2 500\\", \\"3 2 100\\", \\"4 No visits\\"] >>> most_visited_websites(2, 0, []) [\\"1 No visits\\", \\"2 No visits\\"]","solution":"def most_visited_websites(n, m, visits): from collections import defaultdict # Dictionary to hold the total duration spent by each employee on each website employee_website_duration = defaultdict(lambda: defaultdict(int)) # Process the visit logs for visit in visits: emp_id, web_id, duration = visit employee_website_duration[emp_id][web_id] += duration result = [] for emp_id in range(1, n + 1): if emp_id not in employee_website_duration: result.append(f\\"{emp_id} No visits\\") else: most_visited_website, max_duration = max(employee_website_duration[emp_id].items(), key=lambda x: x[1]) result.append(f\\"{emp_id} {most_visited_website} {max_duration}\\") return result"},{"question":"def count_pairs_with_sum(arr: List[int], k: int) -> int: Counts the number of pairs (i, j) where i < j such that the sum of the elements at these positions is equal to k. Examples: >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) 3 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_sum([3, 3, 3, 3], 6) 6 >>> count_pairs_with_sum([1], 2) 0 >>> count_pairs_with_sum([1000000, 1000000, 999999, 1], 2000000) 1 >>> arr = [1]*50000 + [2]*50000 >>> count_pairs_with_sum(arr, 3) 2500000000","solution":"def count_pairs_with_sum(arr, k): Counts the number of pairs (i, j) where i < j such that the sum of the elements at these positions is equal to k. from collections import defaultdict count_dict = defaultdict(int) count_pairs = 0 for num in arr: complement = k - num if complement in count_dict: count_pairs += count_dict[complement] count_dict[num] += 1 return count_pairs"},{"question":"def split_into_sublists(n: int, S: int, integers: List[int]) -> List[List[int]]: Split the list into the minimum number of sublists such that the sum of the integers in each sublist does not exceed the given maximum allowable total sum. >>> split_into_sublists(6, 10, [2, 7, 1, 4, 3, 8]) == [[2, 7, 1], [4, 3], [8]] >>> split_into_sublists(6, 5, [2, 7, 1, 4, 3, 8]) == [[2], [7], [1, 4], [3], [8]] >>> split_into_sublists(1, 1, [1]) == [[1]] >>> split_into_sublists(5, 20, [5, 6, 7, 8, 9]) == [[5, 6, 7], [8, 9]] >>> split_into_sublists(3, 15, [4, 5, 6]) == [[4, 5, 6]] def number_of_sublists(n: int, S: int, integers: List[int]) -> Tuple[int, List[List[int]]]: Calculate the minimum number of sublists and return the sublists. >>> count, result = number_of_sublists(6, 10, [2, 7, 1, 4, 3, 8]) >>> count == 3 >>> result == [[2, 7, 1], [4, 3], [8]] >>> count, result = number_of_sublists(6, 5, [2, 7, 1, 4, 3, 8]) >>> count == 5 >>> result == [[2], [7], [1, 4], [3], [8]] >>> count, result = number_of_sublists(1, 1, [1]) >>> count == 1 >>> result == [[1]] >>> count, result = number_of_sublists(5, 20, [5, 6, 7, 8, 9]) >>> count == 2 >>> result == [[5, 6, 7], [8, 9]] >>> count, result = number_of_sublists(3, 15, [4, 5, 6]) >>> count == 1 >>> result == [[4, 5, 6]]","solution":"def split_into_sublists(n, S, integers): result = [] current_sublist = [] current_sum = 0 for num in integers: if current_sum + num > S: result.append(current_sublist) current_sublist = [num] current_sum = num else: current_sublist.append(num) current_sum += num if current_sublist: result.append(current_sublist) return result def number_of_sublists(n, S, integers): sublists = split_into_sublists(n, S, integers) return len(sublists), sublists"},{"question":"def fibonacci(n: int) -> int: Function to calculate the nth Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55 def is_prime(n: int) -> bool: Function to determine if a number n is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(89) True def is_fibonacci_prime(k: int) -> None: Function to determine if the k-th Fibonacci number is a Fibonacci Prime. Prints \\"Yes\\" if it is, otherwise \\"No\\". >>> is_fibonacci_prime(5) Yes >>> is_fibonacci_prime(10) No >>> is_fibonacci_prime(11) Yes","solution":"def fibonacci(n): Function to calculate the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b def is_prime(n): Function to determine if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_fibonacci_prime(k): Function to determine if the k-th Fibonacci number is a Fibonacci Prime. Prints \\"Yes\\" if it is, otherwise \\"No\\". fib_k = fibonacci(k) if is_prime(fib_k): print(\\"Yes\\") else: print(\\"No\\")"},{"question":"def is_prime(num: int) -> bool: Check if the given number is a prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(29) True pass def get_rotations(num: int) -> List[int]: Generate all rotations of a given number. >>> get_rotations(197) [197, 971, 719] >>> get_rotations(123) [123, 231, 312] >>> get_rotations(7) [7] pass def is_circular_prime(num: int) -> bool: Check if the given number is a circular prime. >>> is_circular_prime(197) True >>> is_circular_prime(101) False >>> is_circular_prime(2) True pass def count_circular_primes(n: int) -> int: Count the number of circular primes below the given number n. >>> count_circular_primes(10) 4 >>> count_circular_primes(100) 13 >>> count_circular_primes(200) 17 pass","solution":"def is_prime(num): Check if the given number is a prime. if num < 2: return False if num == 2 or num == 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def get_rotations(num): Generate all rotations of a given number. num_str = str(num) rotations = [] for i in range(len(num_str)): rotation = int(num_str[i:] + num_str[:i]) rotations.append(rotation) return rotations def is_circular_prime(num): Check if the given number is a circular prime. rotations = get_rotations(num) for rotation in rotations: if not is_prime(rotation): return False return True def count_circular_primes(n): Count the number of circular primes below the given number n. count = 0 for i in range(2, n): if is_circular_prime(i): count += 1 return count"},{"question":"def is_symmetrical(n: int, beads: List[int]) -> str: Determine if a bracelet made from given beads can be symmetrical. Args: n (int): The number of different types of beads. beads (List[int]): The types of beads where each type is represented by a unique integer. Returns: str: 'YES' if the bracelet can be arranged symmetrically, otherwise 'NO'. Examples: >>> is_symmetrical(5, [1, 2, 3, 2, 1]) 'YES' >>> is_symmetrical(4, [1, 2, 3, 4]) 'NO' from typing import List def test_symmetrical_odd(): assert is_symmetrical(5, [1, 2, 3, 2, 1]) == 'YES' def test_not_symmetrical_even(): assert is_symmetrical(4, [1, 2, 3, 4]) == 'NO' def test_symmetrical_even(): assert is_symmetrical(6, [1, 2, 3, 3, 2, 1]) == 'YES' def test_single_bead(): assert is_symmetrical(1, [1]) == 'YES' def test_two_same_beads(): assert is_symmetrical(2, [2, 2]) == 'YES' def test_two_different_beads(): assert is_symmetrical(2, [1, 2]) == 'NO'","solution":"def is_symmetrical(n, beads): Returns 'YES' if the bracelet can be arranged symmetrically, otherwise 'NO'. return 'YES' if beads == beads[::-1] else 'NO'"},{"question":"from typing import List from math import gcd from functools import reduce def lcm(a: int, b: int) -> int: Calculate the Least Common Multiple of two integers. pass def first_common_on_time(cycles: List[int]) -> int: Given a list of cycle durations of signals, find the first time in seconds when all the signals are on simultaneously. >>> first_common_on_time([3, 4]) 12 >>> first_common_on_time([5, 7, 9]) 315 pass","solution":"from math import gcd from functools import reduce def lcm(a, b): Calculate the Least Common Multiple of two integers. return a * b // gcd(a, b) def first_common_on_time(cycles): Given a list of cycle durations of signals, find the first time in seconds when all the signals are on simultaneously. return reduce(lcm, cycles) # Example usage: # n = 3 # cycles = [5, 7, 9] # print(first_common_on_time(cycles)) # Output: 315"},{"question":"def can_rearrange(arr: List[int]) -> str: Determines if you can rearrange the elements of the array into a strictly increasing sequence by removing at most one element. pass def solve(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Outputs the results for given test cases. pass from can_rearrange import can_rearrange, solve def test_single_element_removal(): assert can_rearrange([1, 3, 2, 4]) == \\"YES\\" assert can_rearrange([1, 2, 4, 3]) == \\"YES\\" assert can_rearrange([4, 1, 2, 3]) == \\"YES\\" assert can_rearrange([5, 1, 2, 3, 4]) == \\"YES\\" def test_no_removal_needed(): assert can_rearrange([1, 2, 3, 4]) == \\"YES\\" assert can_rearrange([10, 20, 30, 40]) == \\"YES\\" def test_removal_not_possible(): assert can_rearrange([3, 1, 4, 2]) == \\"NO\\" assert can_rearrange([5, 4, 3, 2, 1]) == \\"NO\\" def test_edge_cases(): assert can_rearrange([1, 2]) == \\"YES\\" assert can_rearrange([2, 1]) == \\"YES\\" assert can_rearrange([2, 1, 3]) == \\"YES\\" def test_solve(): test_cases = [ (4, [1, 3, 2, 4]), (5, [1, 2, 4, 3]), (4, [1, 2, 3, 4]), (5, [5, 4, 3, 2, 1]) ] assert solve(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_rearrange(arr): Determines if you can rearrange the elements of the array into a strictly increasing sequence by removing at most one element. def is_strictly_increasing(sub_arr): return all(sub_arr[i] < sub_arr[i + 1] for i in range(len(sub_arr) - 1)) n = len(arr) if is_strictly_increasing(arr): return \\"YES\\" for i in range(n): if is_strictly_increasing(arr[:i] + arr[i+1:]): return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for n, arr in test_cases: results.append(can_rearrange(arr)) return results"},{"question":"def min_different_crops(n: int, m: int, grid: List[str]) -> int: Returns the minimum number of different crops required to ensure that no two adjacent fields (horizontally or vertically) have the same crop. Args: n : int : number of rows m : int : number of columns grid : list of str : the farm grid Returns: int : the minimum number of different crops required pass def test_min_different_crops_all_fields(): assert min_different_crops(4, 4, [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ]) == 2 def test_min_different_crops_with_obstacles(): assert min_different_crops(4, 4, [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ]) == 2 def test_min_different_crops_single_row(): assert min_different_crops(1, 4, [ \\"....\\" ]) == 2 def test_min_different_crops_single_column(): assert min_different_crops(4, 1, [ \\".\\", \\".\\", \\".\\", \\".\\" ]) == 2 def test_min_different_crops_mixed(): assert min_different_crops(3, 3, [ \\"#\\", \\"#.#\\", \\"#\\" ]) == 2 def test_min_different_crops_small_grid(): assert min_different_crops(2, 2, [ \\"..\\", \\"..\\" ]) == 2","solution":"def min_different_crops(n, m, grid): Returns the minimum number of different crops required to ensure that no two adjacent fields (horizontally or vertically) have the same crop. Args: n : int : number of rows m : int : number of columns grid : list of str : the farm grid Returns: int : the minimum number of different crops required # You essentially need 2 crops to satisfy the non-adjacency requirement. # This can be represented as a checkerboard pattern. crop_needed = [ [0] * m for _ in range(n) ] for i in range(n): for j in range(m): if grid[i][j] == '.': crop_needed[i][j] = (i + j) % 2 # use modulo 2 to alternate crops in a checkerboard pattern # No direct need to count oridentify different crop types since (i + j) % 2 alternating cells ensures no adjacency return 2 # two crops are always sufficient for this problem"},{"question":"def add_camera(cameras, a, b): Add a new camera with range [a, b]. cameras.append((a, b)) def count_cameras(cameras, x): Given a position x, count the number of cameras covering this position. >>> count_cameras([(1, 5), (2, 6), (8, 10), (3, 4)], 4) 3 >>> count_cameras([(1, 5), (2, 6), (8, 10), (3, 4)], 7) 0 >>> count_cameras([(1, 5), (2, 6), (8, 10), (3, 4)], 9) 1 count = 0 for a, b in cameras: if a <= x <= b: count += 1 return count def process_camera_queries(n, q, cameras_data, queries): Handle multiple queries to detect the number of cameras covering a given location. >>> process_camera_queries(4, 3, [(1, 5), (2, 6), (8, 10), (3, 4)], [4, 7, 9]) [3, 0, 1] >>> process_camera_queries(1, 2, [(1, 2)], [1, 2]) [1, 1] >>> process_camera_queries(2, 1, [(1, 2), (4, 5)], [3]) [0] >>> process_camera_queries(3, 2, [(1, 1000000), (500000, 1500000), (2000000, 3000000)], [750000, 2500000]) [2, 1] >>> process_camera_queries(3, 1, [(1, 10), (1, 10), (1, 10)], [5]) [3] cameras = [] for a, b in cameras_data: add_camera(cameras, a, b) results = [] for x in queries: results.append(count_cameras(cameras, x)) return results","solution":"def add_camera(cameras, a, b): cameras.append((a, b)) def count_cameras(cameras, x): count = 0 for a, b in cameras: if a <= x <= b: count += 1 return count def process_camera_queries(n, q, cameras_data, queries): cameras = [] for a, b in cameras_data: add_camera(cameras, a, b) results = [] for x in queries: results.append(count_cameras(cameras, x)) return results"},{"question":"def min_pumps_needed(n: int, garden: str) -> int: Determines the minimum number of water pumps required to ensure that every garden segment receives water. Parameters: n (int): The number of garden segments. garden (str): A binary string representing the garden segments, where '1' indicates a segment with a direct water connection and '0' indicates no direct water connection. Returns: int: The minimum number of water pumps required. >>> min_pumps_needed(5, '01010') # Example 1 2 >>> min_pumps_needed(7, '0000000') # Example 2 3 >>> min_pumps_needed(1, '0') # Test single zero 1 >>> min_pumps_needed(1, '1') # Test single one 0 >>> min_pumps_needed(6, '010101') # Alternate segments 2 >>> min_pumps_needed(5, '11111') # All ones 0 pass # Your implementation goes here","solution":"def min_pumps_needed(n, garden): Determines the minimum number of water pumps required to ensure that every garden segment receives water. Parameters: n (int): The number of garden segments. garden (str): A binary string representing the garden segments, where '1' indicates a segment with a direct water connection and '0' indicates no direct water connection. Returns: int: The minimum number of water pumps required. pumps_needed = 0 i = 0 while i < n: if garden[i] == '1': # If the segment already has a direct connection, move to the next segment i += 1 continue # Place a pump here or on the next segment to cover this segment # It will cover the current segment, next segment, and the segment after the next pumps_needed += 1 # Move to the segment after the next as current and next segment are covered i += 3 return pumps_needed"},{"question":"def lexico_smallest_string(s: str, k: int) -> str: Given a string s consisting of 'a' and 'b' and an integer k representing the number of operations, return the lexicographically smallest string possible after exactly k operations. :param s: str - the input string :param k: int - the number of operations :return: str - the lexicographically smallest string obtained after k operations >>> lexico_smallest_string(\\"baabb\\", 1) == \\"aaabb\\" >>> lexico_smallest_string(\\"bbbb\\", 2) == \\"aabb\\" >>> lexico_smallest_string(\\"abbaa\\", 3) == \\"aaaaa\\" >>> lexico_smallest_string(\\"b\\", 1) == \\"a\\" >>> lexico_smallest_string(\\"aaaaa\\", 3) == \\"aaaaa\\" >>> lexico_smallest_string(\\"abbbbbbbbbb\\", 5) == \\"aaaaaabbbbb\\" >>> lexico_smallest_string(\\"b\\" * 100000, 50000) == \\"a\\" * 50000 + \\"b\\" * 50000 >>> lexico_smallest_string(\\"aaa\\", 2) == \\"aaa\\"","solution":"def lexico_smallest_string(s: str, k: int) -> str: Given a string s consisting of 'a' and 'b' and an integer k representing the number of operations, return the lexicographically smallest string possible after exactly k operations. :param s: str - the input string :param k: int - the number of operations allowed :return: str - the resulting lexicographically smallest string n = len(s) # Convert initial characters if needed and possible within k operations min_s = list(s) operations = 0 # First convert as many 'b's to 'a' as possible from the left, counting the operations for i in range(n): if min_s[i] == 'b': if operations < k: min_s[i] = 'a' operations += 1 else: break # If we still have remaining operations after converting all necessary b's # Convert the spanning subsequence of remaining operations to 'a's if operations < k: min_s = ['a'] * n return ''.join(min_s)"},{"question":"def can_rearrange(N: int, S1: str, S2: str, K: int) -> str: Determine if S1 can be rearranged to match S2 by moving each character at most K positions to the left or right. Parameters: N (int): Length of the sequences S1 (str): The first sequence S2 (str): The second sequence K (int): The maximum number of positions each character can be moved Returns: str: \\"YES\\" if S1 can be rearranged to match S2, otherwise \\"NO\\" >>> can_rearrange(5, \\"abcde\\", \\"deaeb\\", 1) \\"NO\\" >>> can_rearrange(7, \\"abcdefg\\", \\"bacedfg\\", 2) \\"YES\\" >>> can_rearrange(3, \\"abc\\", \\"abc\\", 0) \\"YES\\" >>> can_rearrange(3, \\"abc\\", \\"def\\", 1) \\"NO\\" >>> can_rearrange(4, \\"abcd\\", \\"dcba\\", 4) \\"YES\\" >>> can_rearrange(6, \\"abcdef\\", \\"badcfe\\", 3) \\"YES\\" >>> can_rearrange(1, \\"a\\", \\"a\\", 0) \\"YES\\" >>> can_rearrange(1, \\"a\\", \\"b\\", 0) \\"NO\\"","solution":"def can_rearrange(N, S1, S2, K): Determine if S1 can be rearranged to match S2 by moving each character at most K positions to the left or right. Parameters: N (int): Length of the sequences S1 (str): The first sequence S2 (str): The second sequence K (int): The maximum number of positions each character can be moved Returns: str: \\"YES\\" if S1 can be rearranged to match S2, otherwise \\"NO\\" if K == 0: return \\"YES\\" if S1 == S2 else \\"NO\\" for i in range(N): # Check if a character at position i in S2 can be found in the range of positions [i-K, i+K] in S1. matched = False for j in range(max(0, i - K), min(N, i + K + 1)): if S1[j] == S2[i]: S1 = S1[:j] + '-' + S1[j + 1:] # Mark the character as used matched = True break if not matched: return \\"NO\\" return \\"YES\\""},{"question":"def min_moves_to_reach_happiness(n: int, k: int, happiness_levels: List[int]) -> int: Returns the minimum number of moves required to make the happiness level of every person at least k. >>> min_moves_to_reach_happiness(5, 10, [7, 13, 8, 11, 5]) 10 >>> min_moves_to_reach_happiness(3, 10, [12, 11, 15]) 0 >>> min_moves_to_reach_happiness(4, 10, [1, 2, 3, 4]) 30 >>> min_moves_to_reach_happiness(5, 7, [6, 8, 7, 5, 9]) 3 >>> min_moves_to_reach_happiness(1, 10, [5]) 5 >>> min_moves_to_reach_happiness(2, 1000000000, [999999999, 1000000002]) 1","solution":"def min_moves_to_reach_happiness(n, k, happiness_levels): Returns the minimum number of moves required to make the happiness level of every person at least k. :param n: Number of people :param k: Minimum happiness level desired :param happiness_levels: List of initial happiness levels :return: Minimum number of moves needed moves = 0 for level in happiness_levels: if level < k: moves += (k - level) return moves"},{"question":"import requests def validate_url(url: str) -> bool: Validates if a given URL responds with a status code 200. Parameters: url (str): The URL to be validated. Returns: bool: True if the URL returns a status code 200, False otherwise. >>> validate_url(\\"https://www.example.com\\") # Should return True if the URL is accessible and returns a 200 status code >>> validate_url(\\"https://www.nonexistentwebsite.com\\") # Should return False if the URL is inaccessible or does not return a 200 status code","solution":"import requests def validate_url(url: str) -> bool: Validates if a given URL responds with a status code 200. Parameters: url (str): The URL to be validated. Returns: bool: True if the URL returns a status code 200, False otherwise. try: response = requests.get(url, timeout=5) return response.status_code == 200 except requests.RequestException: return False"},{"question":"def lexicographically_smallest_rows(n: int, m: int, grid: List[str]) -> List[str]: Returns the grid where each row is sorted lexicographically. >>> lexicographically_smallest_rows(3, 4, [\\"bcda\\", \\"gfec\\",\\"adcb\\"]) ['abcd', 'cefg', 'abcd'] >>> lexicographically_smallest_rows(1, 6, [\\"gfecba\\"]) ['abcefg'] >>> lexicographically_smallest_rows(6, 1, [\\"g\\", \\"f\\", \\"e\\", \\"c\\", \\"b\\", \\"a\\"]) ['g', 'f', 'e', 'c', 'b', 'a'] >>> lexicographically_smallest_rows(3, 3, [\\"abc\\", \\"abc\\", \\"abc\\"]) ['abc', 'abc', 'abc'] >>> lexicographically_smallest_rows(3, 2, [\\"zx\\", \\"yx\\", \\"ax\\"]) ['xz', 'xy', 'ax']","solution":"def lexicographically_smallest_rows(n, m, grid): Returns the grid where each row is sorted lexicographically. result = [] for row in grid: sorted_row = ''.join(sorted(row)) result.append(sorted_row) return result"},{"question":"def calculate_wins(skill_ratings): Calculate the total number of matches each player wins throughout the tournament. The player with the higher skill rating always wins. Args: skill_ratings (List[int]): List of integers representing the skill ratings of the players. Returns: List[int]: List of integers where the i-th element represents the number of matches the i-th player wins. Example: >>> calculate_wins([2, 5, 3, 8, 7]) [0, 2, 1, 4, 3] >>> calculate_wins([5, 5, 5, 5]) [0, 0, 0, 0] >>> calculate_wins([10]) [0] >>> calculate_wins([1, 2, 3, 4]) [0, 1, 2, 3] >>> calculate_wins([10, 9, 8, 7]) [3, 2, 1, 0] >>> calculate_wins([3, 6, 1, 4, 5, 2]) [2, 5, 0, 3, 4, 1]","solution":"def calculate_wins(skill_ratings): n = len(skill_ratings) wins = [0] * n for i in range(n): for j in range(n): if skill_ratings[i] > skill_ratings[j]: wins[i] += 1 return wins"},{"question":"def count_trees(n: int, m: int) -> int: Returns the number of trees that can be planted in every cell where both the row number and the column number are odd in an n x m field. Parameters: n (int): The number of rows in the field. m (int): The number of columns in the field. Returns: int: The number of trees that can be planted. >>> count_trees(4, 5) 6 >>> count_trees(1, 1) 1 >>> count_trees(2, 2) 1 >>> count_trees(3, 3) 4 >>> count_trees(1000, 1000) 250000 >>> count_trees(999, 1000) 250000 >>> count_trees(1000, 999) 250000 >>> count_trees(999, 999) 250000","solution":"def count_trees(n, m): Returns the number of trees that can be planted in every cell where both the row number and the column number are odd in an n x m field. Parameters: n (int): The number of rows in the field. m (int): The number of columns in the field. Returns: int: The number of trees that can be planted. return ((n + 1) // 2) * ((m + 1) // 2)"},{"question":"def min_bus_stops(N: int, coordinates: List[Tuple[int, int]]) -> int: Returns the minimum number of bus stops required to serve all residential areas. >>> min_bus_stops(3, [(1, 2), (2, 3), (1, 5)]) 2 >>> min_bus_stops(4, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1 >>> min_bus_stops(4, [(2, 1), (3, 1), (4, 1), (5, 1)]) 1 >>> min_bus_stops(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> min_bus_stops(5, [(1, 2), (3, 2), (3, 5), (5, 7), (6, 7)]) 3","solution":"def min_bus_stops(N, coordinates): Returns the minimum number of bus stops required to serve all residential areas. x_coords = set() y_coords = set() for x, y in coordinates: x_coords.add(x) y_coords.add(y) # The minimum number of bus stops will be the minimum between unique x-coordinates and y-coordinates return min(len(x_coords), len(y_coords))"},{"question":"from typing import List from collections import Counter from math import factorial def count_palindromic_permutations(s: str) -> int: Returns the number of unique palindromic permutations of the string s. # Your code here def solve_palindromic_puzzles(t: int, test_cases: List[str]) -> List[int]: Given the number of test cases and a list of strings, returns a list of integers representing the number of unique palindromic permutations for each string. >>> solve_palindromic_puzzles(2, [\\"aabb\\", \\"abc\\"]) [2, 0] >>> solve_palindromic_puzzles(3, [\\"aaa\\", \\"aaabb\\", \\"a\\"]) [1, 2, 1] # Your code here def test_count_palindromic_permutations(): assert count_palindromic_permutations(\\"aabb\\") == 2 # \\"abba\\", \\"baab\\" assert count_palindromic_permutations(\\"abc\\") == 0 # no possible palindromic permutations assert count_palindromic_permutations(\\"aaa\\") == 1 # \\"aaa\\" assert count_palindromic_permutations(\\"abcdefghhgfedcba\\") == 40320 # many permutations assert count_palindromic_permutations(\\"aaabbbb\\") == 3 # \\"abbabba\\", \\"bbaaaabb\\", \\"abababa\\" assert count_palindromic_permutations(\\"aaabbb\\") == 0 # No palindrome possible def test_solve_palindromic_puzzles(): assert solve_palindromic_puzzles(2, [\\"aabb\\", \\"abc\\"]) == [2, 0] assert solve_palindromic_puzzles(3, [\\"aaa\\", \\"aaabb\\", \\"a\\"]) == [1, 2, 1] assert solve_palindromic_puzzles(1, [\\"abcdefghhgfedcba\\"]) == [40320] assert solve_palindromic_puzzles(2, [\\"aaabbbbb\\", \\"xxxyyyzzz\\"]) == [0, 0]","solution":"from collections import Counter from math import factorial def count_palindromic_permutations(s): Returns the number of unique palindromic permutations of the string s. freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, no palindromic permutation is possible if odd_count > 1: return 0 # Calculate half-factorial counts for permutations half_counts = [count // 2 for count in freq.values()] half_length = sum(half_counts) denominator = 1 for count in half_counts: denominator *= factorial(count) return factorial(half_length) // denominator def solve_palindromic_puzzles(t, test_cases): results = [] for s in test_cases: results.append(count_palindromic_permutations(s)) return results"},{"question":"from typing import List def min_steps(grid: List[str]) -> int: Find the minimum number of steps required to walk from the top-left corner to the bottom-right corner. The walk is valid if the absolute difference between the number of '0's and '1's encountered is at most one. If it's not possible, returns -1. Examples: >>> min_steps([ ... \\"010\\", ... \\"001\\", ... \\"100\\" ... ]) 4 >>> min_steps([ ... \\"111\\", ... \\"111\\", ... \\"111\\" ... ]) -1 >>> min_steps([ ... \\"00\\", ... \\"10\\" ... ]) 2 >>> min_steps([ ... \\"01\\", ... \\"00\\" ... ]) 2","solution":"from collections import deque def is_valid_path(grid, n, m): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(): queue = deque([(0, 0, 0, 0)]) # (row, col, count_0, count_1) visited = set([(0, 0, 0, 0)]) while queue: r, c, count_0, count_1 = queue.popleft() if r == n-1 and c == m-1: if abs(count_0 - count_1) <= 1: return True for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m: next_count_0 = count_0 + (1 if grid[nr][nc] == '0' else 0) next_count_1 = count_1 + (1 if grid[nr][nc] == '1' else 0) if abs(next_count_0 - next_count_1) <= 1 and (nr, nc, next_count_0, next_count_1) not in visited: queue.append((nr, nc, next_count_0, next_count_1)) visited.add((nr, nc, next_count_0, next_count_1)) return False return bfs() def min_steps(grid): n = len(grid) m = len(grid[0]) if not is_valid_path(grid, n, m): return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) visited = set([(0, 0)]) while queue: r, c, steps = queue.popleft() if r == n-1 and c == m-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited: queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"def num_umbrella_groups(n, m, p, occupied_seats): Determine the number of umbrella groups in the audience. Args: n (int): Number of rows. m (int): Number of columns. p (int): Number of occupied seats. occupied_seats (List[int]): List of indices of occupied seats. Returns: int: The number of umbrella groups. Examples: >>> num_umbrella_groups(4, 3, 5, [2, 3, 8, 11, 12]) 2 >>> num_umbrella_groups(1, 1, 1, [1]) 1 >>> num_umbrella_groups(2, 2, 4, [1, 2, 3, 4]) 1 >>> num_umbrella_groups(3, 3, 0, []) 0 >>> num_umbrella_groups(5, 5, 6, [1, 2, 10, 15, 18, 25]) 4","solution":"def num_umbrella_groups(n, m, p, occupied_seats): def dfs(seat): stack = [seat] while stack: current = stack.pop() if current in seen: continue seen.add(current) row, col = divmod(current - 1, m) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: next_row, next_col = row + dx, col + dy next_seat = next_row * m + next_col + 1 if 1 <= next_seat <= n * m and next_seat in occupied_set: stack.append(next_seat) occupied_set = set(occupied_seats) seen = set() groups = 0 for seat in occupied_seats: if seat not in seen: groups += 1 dfs(seat) return groups"},{"question":"import heapq from typing import List, Tuple def minimum_time_to_flow(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimum time required to ensure water can flow from the source node (node 1) to the target node (node n). >>> minimum_time_to_flow(4, 5, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (3, 4, 3), (2, 4, 1)]) == 5 >>> minimum_time_to_flow(2, 1, [(1, 2, 10)]) == 10 >>> minimum_time_to_flow(3, 1, [(1, 2, 5)]) == -1 # no way to reach node 3 Args: n: The number of pipes m: The number of connections connections: A list of tuples where each tuple contains three integers (u, v, t) Returns: int: The minimum time required to turn on pipes so that water can flow from node 1 to node n, or -1 if it's impossible.","solution":"import heapq def minimum_time_to_flow(n, m, connections): graph = {i: [] for i in range(1, n+1)} for u, v, t in connections: graph[u].append((v, t)) graph[v].append((u, t)) def dijkstra(source, target): min_heap = [(0, source)] # (cumulative_time, node) visited = set() min_time = {i: float('inf') for i in range(1, n+1)} min_time[source] = 0 while min_heap: current_time, u = heapq.heappop(min_heap) if u in visited: continue visited.add(u) if u == target: return current_time for v, time in graph[u]: if v not in visited and current_time + time < min_time[v]: min_time[v] = current_time + time heapq.heappush(min_heap, (min_time[v], v)) return -1 if min_time[target] == float('inf') else min_time[target] return dijkstra(1, n)"},{"question":"from typing import List, Tuple def unique_paths_with_obstacles(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the number of unique paths in a grid from top-left to bottom-right considering obstacles. >>> unique_paths_with_obstacles(2, [(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]), ... (2, 2, [ ... [0, 1], ... [0, 0]])]) [2, 1] import pytest from solution import unique_paths_with_obstacles def test_case_1(): t = 2 test_cases = [ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (2, 2, [ [0, 1], [0, 0] ]) ] assert unique_paths_with_obstacles(t, test_cases) == [2, 1] def test_case_no_path(): t = 1 test_cases = [ (3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) ] assert unique_paths_with_obstacles(t, test_cases) == [0] def test_case_single_cell(): t = 1 test_cases = [ (1, 1, [ [0] ]) ] assert unique_paths_with_obstacles(t, test_cases) == [1] def test_case_single_obstacle(): t = 1 test_cases = [ (1, 1, [ [1] ]) ] assert unique_paths_with_obstacles(t, test_cases) == [0] def test_case_multiple_paths(): t = 1 test_cases = [ (3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) ] assert unique_paths_with_obstacles(t, test_cases) == [6] if __name__ == \\"__main__\\": pytest.main()","solution":"def unique_paths_with_obstacles(t, test_cases): def unique_paths(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] results = [] for case in test_cases: m, n, grid = case results.append(unique_paths(m, n, grid)) return results"},{"question":"def min_groups_needed(n: int, m: int, pairs: List[Tuple[int, int]]) -> int: Determine the minimum number of groups needed such that in each group, every student is friends with at least one other student in the same group. >>> min_groups_needed(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (1, 5)]) 1 >>> min_groups_needed(5, 0, []) 5 >>> min_groups_needed(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 >>> min_groups_needed(8, 5, [(1, 2), (2, 3), (4, 5), (6, 7), (7, 8)]) 3 >>> min_groups_needed(1, 0, []) 1 >>> min_groups_needed(5, 4, [(1, 2), (1, 3), (4, 5), (3, 2)]) 2 pass","solution":"def min_groups_needed(n, m, pairs): from collections import defaultdict, deque def bfs(start, visited, adj_list): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) adj_list = defaultdict(list) for u, v in pairs: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) groups_count = 0 for student in range(1, n + 1): if not visited[student]: bfs(student, visited, adj_list) groups_count += 1 return groups_count"},{"question":"def can_fill(W, ball_weights): Determines if it is possible to fill the box to exactly the weight W using any combination of the available ball weights. :param W: Maximum weight capacity of the box :param ball_weights: List of weights of the available types of balls :return: Boolean value indicating whether it is possible to fill the box to exactly W >>> can_fill(9, [2, 3, 7]) True >>> can_fill(5, [2, 4, 6]) False >>> can_fill(10, [1, 5, 6]) True","solution":"def can_fill(W, ball_weights): Determines if it is possible to fill the box to exactly the weight W using any combination of the available ball weights. :param W: Maximum weight capacity of the box :param ball_weights: List of weights of the available types of balls :return: Boolean value indicating whether it is possible to fill the box to exactly W dp = [False] * (W + 1) dp[0] = True for weight in ball_weights: for i in range(weight, W + 1): dp[i] = dp[i] or dp[i - weight] return dp[W]"},{"question":"def count_unique_books(n: int, isbn_numbers: List[int]) -> int: Returns the number of unique ISBN numbers in the collection. Parameters: n (int): The total number of ISBN numbers. isbn_numbers (list of int): The list of ISBN numbers. Returns: int: The number of unique ISBN numbers. >>> count_unique_books(5, [9780306406157, 9780306406157, 9780140449136, 9780451524935, 9780451524935]) 3 >>> count_unique_books(4, [1234567890123, 1234567890123, 1234567890123, 1234567890124]) 2 >>> count_unique_books(4, [1234567890123, 1234567890123, 1234567890123, 1234567890123]) 1 >>> count_unique_books(1, [1234567890123]) 1 >>> count_unique_books(7, [123, 456, 789, 123, 456, 101112, 131415]) 5 pass","solution":"def count_unique_books(n, isbn_numbers): Returns the number of unique ISBN numbers in the collection. Parameters: n (int): The total number of ISBN numbers. isbn_numbers (list of int): The list of ISBN numbers. Returns: int: The number of unique ISBN numbers. return len(set(isbn_numbers))"},{"question":"import heapq import sys from typing import List, Tuple def min_travel_distance(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Computes the minimum travel distance from intersection 1 to intersection n using the given roads. If there is no path, returns -1. >>> min_travel_distance(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)]) 6 >>> min_travel_distance(3, 2, [(1, 2, 2), (2, 3, 3)]) 5 >>> min_travel_distance(4, 4, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 1)]) 4 >>> min_travel_distance(6, 5, [(1, 2, 7), (1, 3, 9), (2, 4, 2), (4, 5, 1), (5, 6, 1)]) 11 >>> min_travel_distance(2, 0, []) -1","solution":"import heapq import sys def dijkstra(n, adj): # Distance to each node, initialized as infinity dist = [sys.maxsize] * (n + 1) dist[1] = 0 # Min heap to get the node with the smallest distance heap = [(0, 1)] while heap: current_dist, u = heapq.heappop(heap) if current_dist > dist[u]: continue for v, length in adj[u]: distance = current_dist + length if distance < dist[v]: dist[v] = distance heapq.heappush(heap, (distance, v)) return dist[n] if dist[n] != sys.maxsize else -1 def min_travel_distance(n, m, roads): adj = [[] for _ in range(n + 1)] # Build the adjacency list for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) return dijkstra(n, adj) # Example usage # if __name__ == \\"__main__\\": # n, m = map(int, input().strip().split()) # roads = [tuple(map(int, input().strip().split())) for _ in range(m)] # print(min_travel_distance(n, m, roads))"},{"question":"def trap_rainwater(heights: List[int]) -> int: Compute the amount of trapped rainwater given an array of non-negative integers representing the height of each bar. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([4]) 0 >>> trap_rainwater([2, 2, 2, 2, 2]) 0 >>> trap_rainwater([5, 4, 3, 2, 1]) 0 >>> trap_rainwater([1, 2, 3, 4, 5]) 0 >>> trap_rainwater([3, 0, 2, 0, 4]) 7 # Your code here","solution":"def trap_rainwater(heights): Compute the amount of trapped rainwater given the heights of the bars. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def max_operations(nums: List[int], t: int) -> int: Returns the maximum number of operations where each operation consists of picking two distinct indices i and j such that nums[i] + nums[j] equals t, and removing both elements from the list. :param nums: List[int] - list of integers :param t: int - target sum value :return: int - maximum number of operations","solution":"def max_operations(nums, t): Returns the maximum number of operations where each operation consists of picking two distinct indices i and j such that nums[i] + nums[j] equals t, and removing both elements from the list. :param nums: List[int] - list of integers :param t: int - target sum value :return: int - maximum number of operations from collections import Counter num_counter = Counter(nums) operations = 0 for num in list(num_counter): complement = t - num if complement in num_counter: if num == complement: operations += num_counter[num] // 2 num_counter[num] = 0 else: min_pairs = min(num_counter[num], num_counter[complement]) operations += min_pairs num_counter[num] -= min_pairs num_counter[complement] -= min_pairs return operations"},{"question":"from collections import deque, defaultdict from typing import List, Tuple def largest_connected_component(n: int, m: int, k: int, colors: List[int], edges: List[Tuple[int, int]]) -> int: Mona and Lisa are playing a game on an undirected graph with \`n\` vertices and \`m\` edges. Each of the vertices is assigned a color (either 1 or 2). Mona can select any vertex and change its color to 1 or 2, but she can only make \`k\` color changes in total. After making the color changes, Lisa's goal is to find the size of the largest connected component that consists solely of vertices of the same color. Parameters: n (int): The number of vertices. m (int): The number of edges. k (int): The allowed number of color changes. colors (List[int]): The initial colors of the vertices. edges (List[Tuple[int, int]]): The edges between the vertices. Returns: int: The size of the largest connected component consisting of vertices of the same color after making up to \`k\` color changes. Example: >>> largest_connected_component(6, 7, 2, [1, 2, 1, 2, 1, 2], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (2, 5)]) 5 def test_example(): n, m, k = 6, 7, 2 colors = [1, 2, 1, 2, 1, 2] edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (2, 5) ] assert largest_connected_component(n, m, k, colors, edges) == 5 def test_no_changes_needed(): n, m, k = 5, 4, 0 colors = [1, 1, 1, 2, 2] edges = [ (1, 2), (2, 3), (4, 5) ] assert largest_connected_component(n, m, k, colors, edges) == 3 def test_no_changes_possible(): n, m, k = 4, 3, 0 colors = [1, 2, 1, 2] edges = [ (1, 2), (2, 3), (3, 4) ] assert largest_connected_component(n, m, k, colors, edges) == 2 def test_all_same_color(): n, m, k = 4, 3, 3 colors = [1, 1, 1, 1] edges = [ (1, 2), (2, 3), (3, 4) ] assert largest_connected_component(n, m, k, colors, edges) == 4 def test_multiple_components(): n, m, k = 6, 5, 1 colors = [1, 2, 1, 2, 1, 2] edges = [ (1, 2), (2, 3), (4, 5), (5, 6), (1, 4) ] assert largest_connected_component(n, m, k, colors, edges) == 4","solution":"from collections import deque, defaultdict def largest_connected_component(n, m, k, colors, edges): # Build the adjacency list for the graph adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Function to find all components in the graph def find_components(): visited = [False] * (n + 1) components = [] def bfs(start): queue = deque([start]) component = [] visited[start] = True while queue: node = queue.popleft() component.append(node) for neighbor in adj[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component for i in range(1, n + 1): if not visited[i]: components.append(bfs(i)) return components # Function to calculate the largest component size after color changes def max_component_size_with_color(component, target_color): color_count = sum(1 for node in component if colors[node - 1] == target_color) other_color_count = len(component) - color_count return color_count + min(other_color_count, k) # Find all components components = find_components() # Calculate the maximum possible size of a single-colored component max_size = 0 for component in components: max_size = max(max_size, max_component_size_with_color(component, 1)) max_size = max(max_size, max_component_size_with_color(component, 2)) return max_size # Inputs and Outputs for testing/debugging if __name__ == \\"__main__\\": n = 6 m = 7 k = 2 colors = [1, 2, 1, 2, 1, 2] edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (2, 5) ] print(largest_connected_component(n, m, k, colors, edges)) # Output should be 5"},{"question":"def organize_books(n: int, l: int, widths: List[int]) -> Tuple[int, List[int]]: Organize books into shelves such that the total width on each shelf does not exceed a given limit. Args: n (int): Number of books l (int): Width limit of each shelf widths (List[int]): Widths of the books Returns: Tuple[int, List[int]]: Minimum number of shelves and the sequence of the number of books on each shelf Examples: >>> organize_books(6, 10, [3, 2, 5, 4, 6, 7]) (3, [2, 2, 2]) >>> organize_books(3, 15, [4, 5, 6]) (1, [3])","solution":"def organize_books(n, l, widths): Organize books into shelves such that the total width on each shelf does not exceed a given limit. :param n: int - Number of books :param l: int - Width limit of each shelf :param widths: List[int] - Widths of the books :return: Tuple[int, List[int]] - Minimum number of shelves and the sequence of the number of books on each shelf shelves = [] current_shelf = [] current_width = 0 for width in widths: if current_width + width <= l: current_shelf.append(width) current_width += width else: shelves.append(len(current_shelf)) current_shelf = [width] current_width = width if current_shelf: shelves.append(len(current_shelf)) return len(shelves), shelves # Parsing input to match the example scenario def process_input(input_lines): first_line = list(map(int, input_lines[0].split())) n = first_line[0] l = first_line[1] widths = list(map(int, input_lines[1].split())) return n, l, widths def process_output(result): print(result[0]) print(\\" \\".join(map(str, result[1]))) # Example usage (you can remove this part before running tests) if __name__ == \\"__main__\\": input_lines = [ \\"6 10\\", \\"3 2 5 4 6 7\\" ] n, l, widths = process_input(input_lines) result = organize_books(n, l, widths) process_output(result)"},{"question":"from collections import deque class AppointmentSystem: def __init__(self): Initializes an empty appointment system for handling patients. self.regular_patients = deque() self.emergency_patients = deque() def register_patient(self, type: int, id: int) -> None: Registers a new patient with given type and ID. Args: type (int): The type of the patient (1 for regular, 2 for emergency). id (int): The unique ID of the patient. Example: >>> system = AppointmentSystem() >>> system.register_patient(1, 101) >>> system.register_patient(2, 102) pass def query_next_patient(self) -> str: Returns the ID of the next patient to be served. Returns: str: The ID of the next patient or \\"NONE\\" if there are no patients. Example: >>> system = AppointmentSystem() >>> system.query_next_patient() 'NONE' pass def serve_next_patient(self) -> None: Removes the patient that is being served from the system. Example: >>> system = AppointmentSystem() >>> system.register_patient(1, 101) >>> system.serve_next_patient() pass # Unit Tests def test_register_patient(): system = AppointmentSystem() system.register_patient(1, 101) assert list(system.regular_patients) == [101] assert list(system.emergency_patients) == [] system.register_patient(2, 102) assert list(system.regular_patients) == [101] assert list(system.emergency_patients) == [102] def test_query_next_patient(): system = AppointmentSystem() assert system.query_next_patient() == \\"NONE\\" system.register_patient(1, 101) assert system.query_next_patient() == 101 system.register_patient(2, 102) assert system.query_next_patient() == 102 def test_serve_next_patient(): system = AppointmentSystem() system.register_patient(1, 101) system.register_patient(2, 102) system.register_patient(1, 103) assert system.query_next_patient() == 102 system.serve_next_patient() assert system.query_next_patient() == 101 system.serve_next_patient() assert system.query_next_patient() == 103 system.serve_next_patient() assert system.query_next_patient() == \\"NONE\\" def test_complete_flow(): system = AppointmentSystem() system.register_patient(1, 101) system.register_patient(2, 102) assert system.query_next_patient() == 102 system.register_patient(1, 103) system.register_patient(2, 104) assert system.query_next_patient() == 102 system.serve_next_patient() assert system.query_next_patient() == 104 system.serve_next_patient() assert system.query_next_patient() == 101 system.serve_next_patient() assert system.query_next_patient() == 103 system.serve_next_patient() assert system.query_next_patient() == \\"NONE\\"","solution":"from collections import deque class AppointmentSystem: def __init__(self): self.regular_patients = deque() self.emergency_patients = deque() def register_patient(self, type, id): if type == 1: self.regular_patients.append(id) elif type == 2: self.emergency_patients.append(id) def query_next_patient(self): if self.emergency_patients: return self.emergency_patients[0] elif self.regular_patients: return self.regular_patients[0] else: return \\"NONE\\" def serve_next_patient(self): if self.emergency_patients: self.emergency_patients.popleft() elif self.regular_patients: self.regular_patients.popleft()"},{"question":"def can_drive_through(m: int, n: int, grid: List[List[str]]) -> str: Determine whether it is possible to drive from the top-left to the bottom-right intersection without hitting any red signals. >>> can_drive_through(3, 3, [['G', 'R', 'G'], ['G', 'G', 'G'], ['R', 'G', 'G']]) \\"YES\\" >>> can_drive_through(2, 2, [['G', 'R'], ['R', 'G']]) \\"NO\\" # Example Unit Tests def test_example1(): m = 3 n = 3 grid = [ ['G', 'R', 'G'], ['G', 'G', 'G'], ['R', 'G', 'G'] ] assert can_drive_through(m, n, grid) == \\"YES\\" def test_example2(): m = 2 n = 2 grid = [ ['G', 'R'], ['R', 'G'] ] assert can_drive_through(m, n, grid) == \\"NO\\" def test_single_cell_green(): m = 1 n = 1 grid = [ ['G'] ] assert can_drive_through(m, n, grid) == \\"YES\\" def test_single_cell_red(): m = 1 n = 1 grid = [ ['R'] ] assert can_drive_through(m, n, grid) == \\"NO\\" def test_border_case(): m = 4 n = 4 grid = [ ['G', 'G', 'G', 'G'], ['R', 'R', 'R', 'G'], ['G', 'G', 'G', 'G'], ['G', 'R', 'R', 'G'] ] assert can_drive_through(m, n, grid) == \\"YES\\" def test_no_possible_path(): m = 3 n = 3 grid = [ ['G', 'R', 'G'], ['R', 'R', 'R'], ['G', 'R', 'G'] ] assert can_drive_through(m, n, grid) == \\"NO\\"","solution":"def can_drive_through(m, n, grid): def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 'R': return False if (x, y) == (m-1, n-1): return True grid[x][y] = 'R' # mark as visited if dfs(x+1, y) or dfs(x, y+1) or dfs(x-1, y) or dfs(x, y-1): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\" # Function to read inputs def main(): m, n = map(int, input().split()) grid = [list(input().strip()) for _ in range(m)] print(can_drive_through(m, n, grid)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. pass def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases and returns results as 'YES' or 'NO' for each case. >>> process_test_cases([\\"aabb\\", \\"abc\\"]) ['YES', 'NO'] >>> process_test_cases([\\"civic\\", \\"ivicc\\"]) ['YES', 'YES'] pass","solution":"from collections import Counter def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. count = Counter(s) # A string can be rearranged to a palindrome if at most one character # has an odd count. odd_counts = sum(1 for cnt in count.values() if cnt % 2 != 0) return odd_counts <= 1 def process_test_cases(test_cases): results = [] for s in test_cases: if can_form_palindrome(s): results.append('YES') else: results.append('NO') return results"},{"question":"def max_stock_by_range(n, k, stock_levels): Returns the maximum stock level that can be collected from any continuous subarray of length k. Parameters: n (int): The number of warehouses. k (int): The length of the range. stock_levels (list of int): The stock levels of each warehouse. Returns: int: The maximum stock level. >>> max_stock_by_range(7, 3, [2, 1, 5, 3, 6, 7, 1]) == 16 >>> max_stock_by_range(5, 2, [1, 1, 1, 1, 1]) == 2 >>> max_stock_by_range(5, 3, [1, 2, 3, 4, 5]) == 12 # subarray [3, 4, 5] >>> max_stock_by_range(6, 2, [5, 4, 3, 2, 1, 0]) == 9 # subarray [5, 4] >>> max_stock_by_range(5, 3, [1, 2, 2, 1, 3]) == 6 # subarray [2, 1, 3] >>> max_stock_by_range(8, 4, [3, 6, 2, 5, 1, 8, 3, 5]) == 17 # subarray [1, 8, 3, 5]","solution":"def max_stock_by_range(n, k, stock_levels): Returns the maximum stock level that can be collected from any continuous subarray of length k. Parameters: n (int): The number of warehouses. k (int): The length of the range. stock_levels (list of int): The stock levels of each warehouse. Returns: int: The maximum stock level. max_stock = 0 current_stock = 0 # Calculate the first window's stock level for i in range(k): current_stock += stock_levels[i] max_stock = current_stock # Slide the window, one element at a time for i in range(k, n): current_stock += stock_levels[i] - stock_levels[i - k] max_stock = max(max_stock, current_stock) return max_stock"},{"question":"def min_operations_to_equalize_stacks(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to equalize the heights of stacks. >>> min_operations_to_equalize_stacks(3, [1, 2, 3]) 3 >>> min_operations_to_equalize_stacks(5, [4, 4, 4, 4, 4]) 0 from typing import List def test_equal_heights(): assert min_operations_to_equalize_stacks(5, [4, 4, 4, 4, 4]) == 0 def test_ascending_order(): assert min_operations_to_equalize_stacks(3, [1, 2, 3]) == 3 def test_descending_order(): assert min_operations_to_equalize_stacks(4, [4, 3, 2, 1]) == 6 def test_random_heights(): assert min_operations_to_equalize_stacks(4, [1, 4, 3, 2]) == 6 def test_single_stack(): assert min_operations_to_equalize_stacks(1, [10]) == 0 def test_min_and_max_values(): assert min_operations_to_equalize_stacks(2, [1, 1_000_000_000]) == 999_999_999","solution":"def min_operations_to_equalize_stacks(n, heights): Returns the minimum number of operations required to equalize the heights of stacks. min_height = min(heights) operations = sum(height - min_height for height in heights) return operations # Example usage: # n = 3 # heights = [1, 2, 3] # The function call would be: # print(min_operations_to_equalize_stacks(n, heights)) # Which would output: # 3 (result of making all stacks height equal to minimum height 1)"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"ababa\\") 9 >>> count_distinct_substrings(\\"abcdefghij\\") 55","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of the given string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def check_temperature_trend(n, temperatures): Given a list of temperature readings over n days, this function checks if there exists a subsequence of three consecutive days that have a strictly increasing or strictly decreasing trend. Parameters: n (int): The number of temperature readings. temperatures (list of int): The list of temperature readings. Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\". >>> check_temperature_trend(5, [1, 2, 1, 3, 5]) 'YES' >>> check_temperature_trend(4, [10, 6, 5, 3]) 'YES' >>> check_temperature_trend(5, [1, 2, 2, 2, 1]) 'NO' >>> check_temperature_trend(3, [5, 5, 5]) 'NO' >>> check_temperature_trend(3, [1, 2, 3]) 'YES' >>> check_temperature_trend(3, [3, 2, 1]) 'YES'","solution":"def check_temperature_trend(n, temperatures): Given a list of temperature readings over n days, this function checks if there exists a subsequence of three consecutive days that have a strictly increasing or strictly decreasing trend. Parameters: n (int): The number of temperature readings. temperatures (list of int): The list of temperature readings. Returns: str: \\"YES\\" if such a subsequence exists, otherwise \\"NO\\". for i in range(n - 2): if (temperatures[i] < temperatures[i + 1] < temperatures[i + 2]) or (temperatures[i] > temperatures[i + 1] > temperatures[i + 2]): return \\"YES\\" return \\"NO\\""},{"question":"def num_connected_components(grid: List[List[int]]) -> int: Find the number of connected components of ones in a rectangular grid. >>> num_connected_components([ ... [1, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0]]) 3 >>> num_connected_components([ ... [1, 1, 0], ... [1, 0, 0], ... [0, 0, 0]]) 1 >>> num_connected_components([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]]) 0 >>> num_connected_components([ ... [1, 0, 0, 1], ... [1, 0, 0, 0], ... [0, 0, 1, 1], ... [0, 0, 1, 0]]) 3 >>> num_connected_components([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]]) 1 >>> num_connected_components([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 1 >>> num_connected_components([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1]]) 1 pass","solution":"def num_connected_components(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 1: return grid[x][y] = -1 # Mark as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) dfs(x + 1, y + 1) dfs(x - 1, y - 1) dfs(x + 1, y - 1) dfs(x - 1, y + 1) num_components = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: num_components += 1 dfs(i, j) return num_components"},{"question":"def final_robot_position(commands: str) -> Tuple[int, int]: Simulate a robot moving in a 2D grid and return the final coordinates after executing all the commands. The robot starts at the coordinates (0, 0) and can move in one of four directions: - 'U' for up - 'D' for down - 'L' for left - 'R' for right Args: commands (str): A string consisting of characters 'U', 'D', 'L', 'R'. Returns: Tuple[int, int]: The final coordinates of the robot as a tuple (x, y). Example: >>> final_robot_position(\\"UUDDLRLR\\") (0, 0) >>> final_robot_position(\\"UUUDLR\\") (0, 2)","solution":"from typing import Tuple def final_robot_position(commands: str) -> Tuple[int, int]: x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x, y"},{"question":"def count_buildings_with_sunlight(heights: list) -> int: Returns the number of buildings that receive sunlight. >>> count_buildings_with_sunlight([3, 1, 4, 5, 2, 6]) 4 >>> count_buildings_with_sunlight([2, 2, 2, 2]) 1 >>> count_buildings_with_sunlight([1, 3, 2, 4, 2, 5]) 4","solution":"def count_buildings_with_sunlight(heights: list) -> int: Returns the number of buildings that receive sunlight. count = 0 max_height = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List, Tuple def min_edges_to_remove(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> int: Calculate the minimum number of edges that need to be removed to divide the graph into exactly \`k\` connected components. If it is impossible to achieve exactly \`k\` connected components, return -1. :param n: Number of nodes :param m: Number of edges :param k: Desired number of connected components :param edges: List of edges where each edge is represented by a tuple (u, v) :return: Minimum number of edges to remove or -1 if impossible >>> min_edges_to_remove(2, 1, 2, [(1, 2)]) 1 >>> min_edges_to_remove(5, 4, 3, [(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> min_edges_to_remove(4, 3, 5, [(1, 2), (2, 3), (3, 4)]) -1 >>> min_edges_to_remove(4, 4, 2, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> min_edges_to_remove(6, 3, 3, [(1, 2), (3, 4), (5, 6)]) 0 >>> min_edges_to_remove(10, 9, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]) 1","solution":"def min_edges_to_remove(n, m, k, edges): from collections import defaultdict, deque # Helper function to perform BFS and find connected components def bfs(start, visited, adj_list): queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size # Create the adjacency list representation of the graph adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) connected_components = 0 component_sizes = [] # Find the connected components using BFS for i in range(1, n + 1): if not visited[i]: component_size = bfs(i, visited, adj_list) component_sizes.append(component_size) connected_components += 1 # If we already have less components than k, it's impossible to reach exactly k components if connected_components > k: return -1 # We need to explore the possibility to split some of the larger components # Sort the component_sizes in reverse order to analyze largest components first component_sizes.sort(reverse=True) extra_components = 0 edges_removed = 0 for size in component_sizes: if connected_components >= k: break # We can split each component at most (size - 1) times (because a single node can't be split further) if size > 1: components_to_add = min(size - 1, k - connected_components) connected_components += components_to_add edges_removed += components_to_add # Check if we managed to reach exactly k components if connected_components != k: return -1 return edges_removed"},{"question":"def perform_operations(n: int, m: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Perform a series of operations on an array of integers and return the modified array. Operations: - If type = 1: Set the value at position i to x. - If type = 2: Add x to every element in the array from position i to the end (inclusive). - If type = 3: Subtract x from every element in the array from position i to the end (inclusive). Example: >>> perform_operations(5, 3, [1, 2, 3, 4, 5], [(2, 2, 10), (1, 3, 20), (3, 4, 5)]) [1, 12, 20, 9, 10]","solution":"def perform_operations(n, m, array, operations): for op in operations: typ, i, x = op if typ == 1: array[i-1] = x elif typ == 2: for j in range(i-1, n): array[j] += x elif typ == 3: for j in range(i-1, n): array[j] -= x return array"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"character\\") 5 >>> longest_palindromic_subsequence(\\"abcdefg\\") 1 # Write your code here","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1]"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculate the maximum profit from a single buy and sell operation. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 pass # Unit Tests def test_normal_case(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_no_profit_case(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_single_element(): assert max_profit([5]) == 0 def test_empty_list(): assert max_profit([]) == 0 def test_all_equal_elements(): assert max_profit([3, 3, 3, 3, 3]) == 0 def test_fluctuating_prices(): assert max_profit([1, 2, 3, 4, 5, 1, 6]) == 5 def test_large_gain_late(): assert max_profit([1, 3, 2, 8, 4, 9]) == 8 def test_prices_declining(): assert max_profit([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell operation. If no profit is possible, returns 0. if not prices or len(prices) <= 1: return 0 max_profit = 0 min_price = prices[0] for price in prices[1:]: min_price = min(min_price, price) potential_profit = price - min_price max_profit = max(max_profit, potential_profit) return max_profit"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Create internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): res = float('inf') left += self.n right += self.n while left <= right: if left % 2 == 1: res = min(res, self.tree[left]) left += 1 if right % 2 == 0: res = min(res, self.tree[right]) right -= 1 left //= 2 right //= 2 return res def process_commands(n, q, arr, commands): Process a list of commands to update or query a list of integers. >>> process_commands(5, 3, [1, 3, 5, 7, 9], [\\"2 1 3\\", \\"1 2 2\\", \\"2 1 3\\"]) [1, 1] >>> process_commands(5, 3, [9, 8, 7, 6, 5], [\\"2 1 5\\", \\"1 5 4\\", \\"2 1 5\\"]) [5, 4]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Create internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = min(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): res = float('inf') left += self.n right += self.n while left <= right: if left % 2 == 1: res = min(res, self.tree[left]) left += 1 if right % 2 == 0: res = min(res, self.tree[right]) right -= 1 left //= 2 right //= 2 return res def process_commands(n, q, arr, commands): seg_tree = SegmentTree(arr) result = [] for command in commands: cmd = command.split() if cmd[0] == '1': # Update command x = int(cmd[1]) - 1 y = int(cmd[2]) seg_tree.update(x, y) elif cmd[0] == '2': # Query command l = int(cmd[1]) - 1 r = int(cmd[2]) - 1 result.append(seg_tree.query(l, r)) return result"},{"question":"def longest_common_subsequence_length(n: int, m: int, A: str, B: str) -> int: Compute the length of the longest common subsequence (LCS) shared by both DNA sequences A and B. Args: n (int): The length of the DNA sequence A. m (int): The length of the DNA sequence B. A (str): The DNA sequence A. B (str): The DNA sequence B. Returns: int: The length of the longest common subsequence of A and B. Example: >>> longest_common_subsequence_length(7, 6, \\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence_length(3, 3, \\"AAA\\", \\"BBB\\") 0 >>> longest_common_subsequence_length(4, 4, \\"AAAA\\", \\"AAAA\\") 4 >>> longest_common_subsequence_length(5, 7, \\"ACGTG\\", \\"CACTGCA\\") 4 >>> longest_common_subsequence_length(1, 1, \\"A\\", \\"A\\") 1 >>> longest_common_subsequence_length(1, 1, \\"A\\", \\"G\\") 0","solution":"def longest_common_subsequence_length(n, m, A, B): Returns the length of the longest common subsequence of DNA sequences A and B. # Create a 2D array to store the lengths of longest common subsequences dp = [[0] * (m + 1) for _ in range(n + 1)] # Build the dp array from bottom up for i in range(1, n + 1): for j in range(1, m + 1): if A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # The length of the longest common subsequence will be in dp[n][m] return dp[n][m]"},{"question":"from typing import List def shortest_path_in_grid(n: int, m: int, grid: List[List[str]]) -> int: Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner in the grid, or -1 if there is no valid path. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): 2D grid representing the map with '.' for empty cells and '#' for obstacles. Returns: int: Minimum number of steps to reach the bottom-right corner or -1 if no valid path exists. Examples: >>> shortest_path_in_grid(3, 3, [['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.']]) 4 >>> shortest_path_in_grid(3, 3, [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]) -1 pass # Implement the function here # Unit tests def test_shortest_path_in_grid_no_obstacles(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert shortest_path_in_grid(3, 3, grid) == 4 def test_shortest_path_in_grid_with_obstacles(): grid = [ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ] assert shortest_path_in_grid(3, 3, grid) == 4 def test_shortest_path_in_grid_full_obstacle(): grid = [ ['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#'] ] assert shortest_path_in_grid(3, 3, grid) == -1 def test_shortest_path_blocked_start(): grid = [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert shortest_path_in_grid(3, 3, grid) == -1 def test_shortest_path_blocked_end(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '#'] ] assert shortest_path_in_grid(3, 3, grid) == -1 def test_shortest_path_no_path_due_to_obstacles(): grid = [ ['.', '#', '.'], ['#', '#', '.'], ['.', '#', '.'] ] assert shortest_path_in_grid(3, 3, grid) == -1","solution":"from collections import deque def shortest_path_in_grid(n, m, grid): Returns the minimum number of steps required to reach the bottom-right corner from the top-left corner in the grid, or -1 if there is no valid path. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = [[False] * m for _ in range(n)] visited[0][0] = True while queue: row, col, steps = queue.popleft() if row == n-1 and col == m-1: return steps for dr, dc in directions: r, c, = row + dr, col + dc if 0 <= r < n and 0 <= c < m and not visited[r][c] and grid[r][c] == '.': visited[r][c] = True queue.append((r, c, steps + 1)) return -1"},{"question":"def run_length_encoding(s: str) -> str: Compresses the input string using the Run-Length Encoding (RLE) algorithm. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The run-length encoded version of the input string if it's shorter in length than the original string, otherwise returns the original string. >>> run_length_encoding(\\"aaabbbcccaaa\\") 'a3b3c3a3' >>> run_length_encoding(\\"abcd\\") 'abcd' from solution import run_length_encoding def test_single_characters(): assert run_length_encoding(\\"abcd\\") == \\"abcd\\" def test_repeating_characters(): assert run_length_encoding(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" def test_mixed_repeating_and_single(): assert run_length_encoding(\\"aabcccccaaa\\") == \\"a2bc5a3\\" def test_all_single_characters(): assert run_length_encoding(\\"abcdef\\") == \\"abcdef\\" def test_full_repetition(): assert run_length_encoding(\\"aaaaaa\\") == \\"a6\\" def test_empty_string(): assert run_length_encoding(\\"\\") == \\"\\" def test_single_character_string(): assert run_length_encoding(\\"a\\") == \\"a\\" def test_no_compression_needed(): assert run_length_encoding(\\"aabbcc\\") == \\"aabbcc\\"","solution":"def run_length_encoding(s): Compresses the input string using the Run-Length Encoding (RLE) algorithm. Args: s (str): The input string consisting of lowercase English letters. Returns: str: The run-length encoded version of the input string if it's shorter in length than the original string, otherwise returns the original string. if not s: return \\"\\" encoded = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded.append(s[i - 1] + str(count) if count > 1 else s[i - 1]) count = 1 # Append the last character (or sequence of characters) encoded.append(s[-1] + str(count) if count > 1 else s[-1]) encoded_string = ''.join(encoded) return encoded_string if len(encoded_string) < len(s) else s"},{"question":"def can_reorder_within_k(s1: str, s2: str, k: int) -> str: Determines if s1 can be reordered to match s2 with each character moved up to k positions left or right. s1: str - The original string to be reordered s2: str - The target string to match after reordering k: int - The maximum number of positions each character can be moved Returns: str - \\"YES\\" if s1 can be reordered to match s2 within the constraints, otherwise \\"NO\\" Example: >>> can_reorder_within_k(\\"abcdef\\", \\"abcfed\\", 2) \\"YES\\" >>> can_reorder_within_k(\\"abcdef\\", \\"fedcba\\", 1) \\"NO\\" def test_can_reorder_within_k(): assert can_reorder_within_k(\\"abcdef\\", \\"abcfed\\", 2) == \\"YES\\" assert can_reorder_within_k(\\"abcdef\\", \\"fedcba\\", 5) == \\"YES\\" assert can_reorder_within_k(\\"abcdef\\", \\"fedcba\\", 1) == \\"NO\\" assert can_reorder_within_k(\\"abcdef\\", \\"abcdef\\", 0) == \\"YES\\" assert can_reorder_within_k(\\"abc\\", \\"cba\\", 2) == \\"YES\\" assert can_reorder_within_k(\\"abc\\", \\"bca\\", 0) == \\"NO\\" def test_can_reorder_within_k_edge_cases(): assert can_reorder_within_k(\\"a\\", \\"a\\", 0) == \\"YES\\" assert can_reorder_within_k(\\"a\\", \\"a\\", 1) == \\"YES\\" assert can_reorder_within_k(\\"ab\\", \\"ba\\", 1) == \\"YES\\" assert can_reorder_within_k(\\"ab\\", \\"ab\\", 0) == \\"YES\\" assert can_reorder_within_k(\\"abcd\\", \\"dcba\\", 0) == \\"NO\\" assert can_reorder_within_k(\\"abcde\\", \\"edcba\\", 4) == \\"YES\\"","solution":"def can_reorder_within_k(s1, s2, k): Determines if s1 can be reordered to match s2 with each character moved up to k positions left or right. s1: str - The original string to be reordered s2: str - The target string to match after reordering k: int - The maximum number of positions each character can be moved Returns: str - \\"YES\\" if s1 can be reordered to match s2 within the constraints, otherwise \\"NO\\" n = len(s1) # Check each character in s2 for i in range(n): if s1[i] == s2[i]: continue found = False # Check up to k positions left and right for j in range(max(0, i - k), min(n, i + k + 1)): if s1[j] == s2[i]: s1 = s1[:i] + s1[j] + s1[i + 1:j] + s1[i] + s1[j + 1:] found = True break if not found: return \\"NO\\" return \\"YES\\""},{"question":"def can_assign_workers_to_tasks(n: int, m: int, worker_skills: List[List[int]], task_skills: List[List[int]]) -> str: Determine if it's possible to assign each worker to exactly one task such that each task's skill requirements are met by the worker assigned to that task. >>> can_assign_workers_to_tasks(3, 3, [[1, 2], [2, 3, 4], [5]], [[1], [2, 3, 4], [5]]) \\"YES\\" >>> can_assign_workers_to_tasks(3, 3, [[1], [2], [3]], [[1, 2], [2], [3]]) \\"NO\\" >>> can_assign_workers_to_tasks(2, 2, [[1, 2, 3], [3, 4, 5]], [[3], [4, 5]]) \\"YES\\" >>> can_assign_workers_to_tasks(1, 1, [[1, 2, 3]], [[3]]) \\"YES\\" >>> can_assign_workers_to_tasks(3, 2, [[1, 2], [2, 3], [4, 5]], [[1, 2], [1, 3]]) \\"NO\\"","solution":"def can_assign_workers_to_tasks(n, m, worker_skills, task_skills): matched_tasks = set() for task in task_skills: task_set = set(task) for i, worker_skill in enumerate(worker_skills): if i in matched_tasks: # If this worker is already matched to a task, skip it continue # Check if worker can perform this task if task_set.issubset(set(worker_skill)): matched_tasks.add(i) break return \\"YES\\" if len(matched_tasks) == m else \\"NO\\" # Example usage if __name__ == \\"__main__\\": n, m = 3, 3 worker_skills = [ [1, 2], [2, 3, 4], [5] ] task_skills = [ [1], [2, 3, 4], [5] ] print(can_assign_workers_to_tasks(n, m, worker_skills, task_skills)) # Output: YES"},{"question":"from typing import List, Union def process_operations(operations: List[str]) -> List[Union[int, None]]: Perform a series of operations on a stack and return the results of 'max' operations. >>> process_operations([\\"push 1\\", \\"max\\"]) [1] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"max\\", \\"push 3\\", \\"max\\"]) [2, 3] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"max\\", \\"pop\\", \\"max\\"]) [2, 1] >>> process_operations([\\"push 1\\", \\"push 2\\", \\"push 3\\", \\"pop\\", \\"pop\\", \\"max\\"]) [1] >>> process_operations([\\"pop\\", \\"push 2\\", \\"max\\", \\"pop\\", \\"max\\"]) [2, None] >>> process_operations([\\"push 5\\", \\"push 3\\", \\"max\\", \\"pop\\", \\"max\\", \\"push 7\\", \\"max\\"]) [5, 5, 7]","solution":"class StackWithMax: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): if self.stack: if self.stack[-1] == self.max_stack[-1]: self.max_stack.pop() self.stack.pop() def max(self): if self.max_stack: return self.max_stack[-1] return None def process_operations(operations): s = StackWithMax() result = [] for operation in operations: if operation.startswith(\\"push\\"): _, x = operation.split() s.push(int(x)) elif operation == \\"pop\\": s.pop() elif operation == \\"max\\": result.append(s.max()) return result"},{"question":"def min_rotations_smallest_subsequence(n, k, arr): Returns the minimum number of rotations required to get the lexicographically smallest subsequence of length k. >>> min_rotations_smallest_subsequence(4, 2, [5, 4, 3, 2]) 3 >>> min_rotations_smallest_subsequence(3, 2, [1, 2, 3]) 0","solution":"def min_rotations_smallest_subsequence(n, k, arr): Returns the minimum number of rotations required to get the lexicographically smallest subsequence of length k. def get_lexicographically_smallest_subsequence(seq, k): stack = [] to_remove = len(seq) - k for num in seq: while stack and to_remove > 0 and stack[-1] > num: stack.pop() to_remove -= 1 stack.append(num) return stack[:k] min_rotation = 0 min_subsequence = get_lexicographically_smallest_subsequence(arr, k) for i in range(1, n): rotated_arr = arr[i:] + arr[:i] current_subsequence = get_lexicographically_smallest_subsequence(rotated_arr, k) if current_subsequence < min_subsequence: min_subsequence = current_subsequence min_rotation = i return min_rotation"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the lexicographically smallest string that can be obtained by performing the described operations on the input string. >>> smallest_lexicographical_string(\\"a\\") \\"a\\" >>> smallest_lexicographical_string(\\"bbbb\\") \\"bbbb\\" >>> smallest_lexicographical_string(\\"abc\\") \\"aaa\\" >>> smallest_lexicographical_string(\\"edcab\\") \\"aaaaa\\" >>> smallest_lexicographical_string(\\"z\\") \\"z\\" >>> smallest_lexicographical_string(\\"xcd\\") \\"ccc\\"","solution":"def smallest_lexicographical_string(s): Returns the lexicographically smallest string that can be obtained by performing the described operations on the input string. # The smallest lexicographical string we can always get is a string # consisting of the smallest character in the string repeated n times smallest_char = min(s) return smallest_char * len(s)"},{"question":"def longest_repeated_char_substring(s: str) -> str: Returns the longest substring composed of a single repeated character. >>> longest_repeated_char_substring(\\"aaabbbbcc\\") 'bbbb' >>> longest_repeated_char_substring(\\"abcdddeee\\") 'ddd'","solution":"def longest_repeated_char_substring(s: str) -> str: Returns the longest substring composed of a single repeated character. max_len = 0 max_substring = \\"\\" current_len = 0 current_char = \\"\\" for char in s: if char == current_char: current_len += 1 else: if current_len > max_len: max_len = current_len max_substring = current_char * current_len current_char = char current_len = 1 if current_len > max_len: max_substring = current_char * current_len return max_substring"},{"question":"def determine_winner(n: int, s: str) -> str: Determine whether Alice or Bob will win the game. Parameters: n (int): length of the string s (str): the string itself Returns: str: \\"Alice\\" if Alice will win, \\"Bob\\" if Bob will win. >>> determine_winner(2, \\"ab\\") 'Bob' >>> determine_winner(3, \\"abc\\") 'Alice' >>> determine_winner(8, \\"abcdefgh\\") 'Bob' >>> determine_winner(7, \\"abcdefg\\") 'Alice'","solution":"def determine_winner(n, s): Determine whether Alice or Bob will win the game. Parameters: n (int): length of the string s (str): the string itself Returns: str: \\"Alice\\" if Alice will win, \\"Bob\\" if Bob will win. # The player who starts with an odd number of turns wins if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def build_inverted_index(documents): Returns an inverted index from the given documents. pass def query_inverted_index(inverted_index, query_words): Returns the list of document indices for each query word. pass def process_documents_and_queries(doc_input, query_input): Processes documents and queries and returns the results for each query. pass def test_build_inverted_index(): documents = [ \\"hello world\\", \\"this is a test\\", \\"hello again\\", \\"test the inverted index\\" ] result = build_inverted_index(documents) expected = { 'hello': [1, 3], 'world': [1], 'this': [2], 'is': [2], 'a': [2], 'test': [2, 4], 'again': [3], 'the': [4], 'inverted': [4], 'index': [4] } assert result == expected def test_query_inverted_index(): inverted_index = { 'hello': [1, 3], 'world': [1], 'test': [2, 4], 'index': [4] } queries = ['hello', 'test', 'index', 'unknown'] result = query_inverted_index(inverted_index, queries) expected = ['1 3', '2 4', '4', '-1'] assert result == expected def test_process_documents_and_queries(): doc_input = [ \\"4\\", \\"hello world\\", \\"this is a test\\", \\"hello again\\", \\"test the inverted index\\" ] query_input = [ \\"3\\", \\"hello\\", \\"test\\", \\"index\\" ] result = process_documents_and_queries(doc_input, query_input) expected = ['1 3', '2 4', '4'] assert result == expected","solution":"def build_inverted_index(documents): Returns an inverted index from the given documents. from collections import defaultdict inverted_index = defaultdict(list) for doc_id, doc in enumerate(documents, 1): words = doc.split() for word in words: if doc_id not in inverted_index[word]: inverted_index[word].append(doc_id) return inverted_index def query_inverted_index(inverted_index, query_words): Returns the list of document indices for each query word. results = [] for word in query_words: if word in inverted_index: results.append(' '.join(map(str, inverted_index[word]))) else: results.append(\\"-1\\") return results def process_documents_and_queries(doc_input, query_input): Processes documents and queries and returns the results for each query. n = int(doc_input[0]) documents = doc_input[1:n+1] q = int(query_input[0]) queries = query_input[1:q+1] inverted_index = build_inverted_index(documents) return query_inverted_index(inverted_index, queries)"},{"question":"def longest_increasing_subarrays_lengths(a): Given an array of integers, determine the length of the longest increasing contiguous subarray that ends at each element. Parameters: a (List[int]): List of integers representing the array. Returns: List[int]: List of integers representing the length of the longest increasing contiguous subarray that ends at each element. Example: >>> longest_increasing_subarrays_lengths([2, 2, 9, 3, 4, 14]) [1, 1, 2, 1, 2, 3] >>> longest_increasing_subarrays_lengths([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> longest_increasing_subarrays_lengths([5, 4, 3, 2, 1]) [1, 1, 1, 1, 1] >>> longest_increasing_subarrays_lengths([7, 7, 7, 7, 7]) [1, 1, 1, 1, 1]","solution":"def longest_increasing_subarrays_lengths(a): n = len(a) if n == 0: return [] lengths = [1] * n for i in range(1, n): if a[i] > a[i - 1]: lengths[i] = lengths[i - 1] + 1 else: lengths[i] = 1 return lengths"},{"question":"from typing import List, Tuple def fibonacci_like(a: int, b: int, n: int) -> int: Given two starting numbers a, b, and an index n, return the n-th number in the Fibonacci-like sequence. >>> fibonacci_like(2, 3, 4) 13 >>> fibonacci_like(0, 1, 6) 8 >>> fibonacci_like(6, 10, 2) 16 >>> fibonacci_like(1, 1, 0) 1 pass def process_test_cases(t: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> process_test_cases(3, [(2, 3, 4), (0, 1, 6), (6, 10, 2)]) [13, 8, 16] >>> process_test_cases(2, [(0, 0, 0), (1, 1, 2)]) [0, 2] pass def test_fibonacci_like_basic(): assert fibonacci_like(2, 3, 4) == 13 assert fibonacci_like(0, 1, 6) == 8 assert fibonacci_like(6, 10, 2) == 16 def test_fibonacci_like_edge_cases(): assert fibonacci_like(0, 0, 0) == 0 assert fibonacci_like(0, 0, 1) == 0 assert fibonacci_like(1, 1, 0) == 1 assert fibonacci_like(1, 1, 1) == 1 assert fibonacci_like(1, 1, 2) == 2 def test_fibonacci_like_large_numbers(): assert fibonacci_like(1000000000, 1000000000, 0) == 1000000000 assert fibonacci_like(1000000000, 1000000000, 1) == 1000000000 assert fibonacci_like(1000000000, 1000000000, 2) == 2000000000 assert fibonacci_like(1000000000, 1000000000, 3) == 3000000000 def test_process_test_cases(): test_cases = [ (2, 3, 4), (0, 1, 6), (6, 10, 2) ] expected = [13, 8, 16] assert process_test_cases(3, test_cases) == expected test_cases = [ (0, 0, 0), (1, 1, 2) ] expected = [0, 2] assert process_test_cases(2, test_cases) == expected","solution":"def fibonacci_like(a, b, n): Given two starting numbers a, b and an index n, returns the n-th number in the Fibonacci-like sequence. if n == 0: return a elif n == 1: return b fib_sequence = [a, b] for i in range(2, n + 1): next_num = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_num) return fib_sequence[n] def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list. results = [] for test_case in test_cases: a, b, n = test_case result = fibonacci_like(a, b, n) results.append(result) return results"},{"question":"def min_signal_towers(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of signal towers needed to ensure every building in the grid is covered by at least one signal tower. >>> min_signal_towers(4, 4, [\\"..B.\\", \\"BB..\\", \\"..B.\\", \\".BB.\\"]) 3 >>> min_signal_towers(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> min_signal_towers(2, 2, [\\"BB\\", \\"BB\\"]) 2 >>> min_signal_towers(5, 5, [\\".....\\", \\"B....\\", \\".....\\", \\"B....\\", \\".....\\"]) 1 >>> min_signal_towers(5, 5, [\\".....\\", \\".....\\", \\"BBBBB\\", \\".....\\", \\".....\\"]) 1","solution":"def min_signal_towers(n, m, grid): rows_with_building = [False] * n cols_with_building = [False] * m # Identify which rows and columns contain buildings for i in range(n): for j in range(m): if grid[i][j] == 'B': rows_with_building[i] = True cols_with_building[j] = True # Count rows and columns that contain buildings rows_count = sum(rows_with_building) cols_count = sum(cols_with_building) # The minimum number of signal towers needed is the minimum of rows_count and cols_count return min(rows_count, cols_count) # Example usage: # n, m = 4, 4 # grid = [ # \\"..B.\\", # \\"BB..\\", # \\"..B.\\", # \\".BB.\\" # ] # print(min_signal_towers(n, m, grid)) # Output: 3"},{"question":"MOD = 10**9 + 7 def count_configurations(n: int, k: int) -> int: Returns the number of unique garden configurations after exactly \`k\` operations modulo \`10^9 + 7\`. >>> count_configurations(3, 2) == 6 >>> count_configurations(4, 0) == 1 >>> count_configurations(5, 10) == 1 >>> count_configurations(10, 3) >= 0 >>> count_configurations(100000, 0) == 1 >>> count_configurations(100, 5) >= 0","solution":"MOD = 10**9 + 7 def count_configurations(n, k): Returns the number of unique garden configurations after exactly \`k\` operations modulo \`10^9 + 7\`. # Initialize the dp array where dp[i][j] is the number of ways to achieve j operations on i flower beds. dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 # Populate the dp table with the number of configurations. for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = dp[i-1][j] # If we do nothing to this bed if j > 0: dp[i][j] += dp[i-1][j-1] # If we plant/remove one flower dp[i][j] %= MOD if j > 1: dp[i][j] += dp[i-1][j-2] # If we perform both plant and remove dp[i][j] %= MOD return dp[n][k] # Example usage #print(count_configurations(3, 2)) # Expected output: 6"},{"question":"def max_spells(M: int, S: int, magicians_data: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum number of spells each magician can perform before running out of magic power. Args: M (int): The number of magicians. S (int): The number of spells each magician aims to perform. magicians_data (List[Tuple[int, List[int]]]): A list where each element is a tuple containing the initial magic power of a magician and a list of integers representing the costs of the spells. Returns: List[int]: A list where each element is the maximum number of spells the respective magician can perform. Example: >>> M = 2 >>> S = 3 >>> magicians_data = [(10, [3, 4, 6]), (15, [5, 5, 5])] >>> max_spells(M, S, magicians_data) [2, 3]","solution":"def max_spells(M, S, magicians_data): results = [] for i in range(M): P_i, spell_costs = magicians_data[i][0], magicians_data[i][1] current_power = P_i spells_performed = 0 for cost in spell_costs: if current_power >= cost: current_power -= cost spells_performed += 1 else: break results.append(spells_performed) return results"},{"question":"def average_uptime(binary_string: str) -> float: Calculate the average length of all contiguous sequences of '1's in the binary string. :param binary_string: str, a binary string representing system up-times and failures :return: float, average length of all up-times >>> abs(average_uptime(\\"110011011111000111\\") - 3.0) < 1e-9 True >>> abs(average_uptime(\\"1111111\\") - 7.0) < 1e-9 True >>> abs(average_uptime(\\"0000000\\") - 0.0) < 1e-9 True >>> abs(average_uptime(\\"10001\\") - 1.0) < 1e-9 True >>> abs(average_uptime(\\"1100110011\\") - 2.0) < 1e-9 True >>> abs(average_uptime(\\"1\\") - 1.0) < 1e-9 True >>> abs(average_uptime(\\"0\\") - 0.0) < 1e-9 True >>> abs(average_uptime(\\"\\") - 0.0) < 1e-9 True","solution":"def average_uptime(binary_string): Calculate the average length of all contiguous sequences of '1's in the binary string. :param binary_string: str, a binary string representing system up-times and failures :return: float, average length of all up-times if not binary_string: return 0.0 up_lengths = [] current_length = 0 for char in binary_string: if char == '1': current_length += 1 else: if current_length > 0: up_lengths.append(current_length) current_length = 0 if current_length > 0: up_lengths.append(current_length) if not up_lengths: return 0.0 average_length = sum(up_lengths) / len(up_lengths) return average_length"},{"question":"def can_make_all_zero(n: int, arr: List[int]) -> str: Determines if it is possible to make all integers in the list zero by repeatedly replacing any pair of adjacent integers with their difference. >>> can_make_all_zero(3, [4, 2, 2]) \\"YES\\" >>> can_make_all_zero(3, [3, 5, 1]) \\"NO\\"","solution":"def can_make_all_zero(n, arr): Determines if it is possible to make all integers in the list zero by repeatedly replacing any pair of adjacent integers with their difference. total_sum = sum(arr) if total_sum % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def unique_sum_sequence(n: int) -> List[int]: Find a sequence of integers such that the sums of any two distinct elements in the sequence are unique. If no such sequence exists, return -1. Args: n (int): the length of the sequence Returns: List[int]: the sequence of n integers or -1 if no such sequence exists >>> unique_sum_sequence(1) [1] >>> unique_sum_sequence(3) [1, 2, 4] >>> unique_sum_sequence(6) [1, 2, 4, 8, 16, 32] >>> unique_sum_sequence(1000) [1, 2, 4, 8, 16, 32, ..., 2**999] pass def test_one_element(): assert unique_sum_sequence(1) == [1] def test_three_elements(): sequence = unique_sum_sequence(3) assert len(sequence) == 3 assert len(set([sequence[i] + sequence[j] for i in range(3) for j in range(i+1, 3)])) == 3 def test_six_elements(): sequence = unique_sum_sequence(6) assert len(sequence) == 6 assert len(set([sequence[i] + sequence[j] for i in range(6) for j in range(i+1, 6)])) == 15 def test_edge_case_large(): sequence = unique_sum_sequence(1000) assert len(sequence) == 1000 assert len(set([sequence[i] + sequence[j] for i in range(1000) for j in range(i+1, 1000)])) == 499500 def test_general_case(): for n in range(1, 51): sequence = unique_sum_sequence(n) assert len(sequence) == n value_set = set([sequence[i] + sequence[j] for i in range(n) for j in range(i+1, n)]) assert len(value_set) == n * (n - 1) // 2","solution":"def unique_sum_sequence(n): if n == 1: return [1] result = [] for i in range(n): result.append(2**i) return result"},{"question":"def is_subsequence(s: str, t: str) -> str: Determine if t is a subsequence of s. >>> is_subsequence(\\"abc\\", \\"abc\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"YES\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"NO\\" >>> is_subsequence(\\"abcde\\", \\"\\") \\"YES\\" >>> is_subsequence(\\"\\", \\"a\\") \\"NO\\" def process_queries(queries: list[tuple[str, str]]) -> list[str]: Process a list of queries to determine if t is a subsequence of s for each query. >>> process_queries([(\\"abcde\\", \\"ace\\")]) [\\"YES\\"] >>> process_queries([(\\"abcde\\", \\"ace\\"), (\\"abc\\", \\"abc\\"), (\\"abcde\\", \\"aec\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] from solution import is_subsequence, process_queries def test_is_subsequence_exact_match(): assert is_subsequence(\\"abc\\", \\"abc\\") == \\"YES\\" def test_is_subsequence_subseq_middle(): assert is_subsequence(\\"abcde\\", \\"ace\\") == \\"YES\\" def test_is_subsequence_not_subseq(): assert is_subsequence(\\"abcde\\", \\"aec\\") == \\"NO\\" def test_is_subsequence_empty_t(): assert is_subsequence(\\"abcde\\", \\"\\") == \\"YES\\" def test_is_subsequence_empty_s(): assert is_subsequence(\\"\\", \\"a\\") == \\"NO\\" def test_process_queries_single_query(): queries = [(\\"abcde\\", \\"ace\\")] assert process_queries(queries) == [\\"YES\\"] def test_process_queries_multiple_queries(): queries = [ (\\"abcde\\", \\"ace\\"), (\\"abc\\", \\"abc\\"), (\\"abcde\\", \\"aec\\"), (\\"abcdef\\", \\"def\\"), (\\"abcdef\\", \\"abcdz\\") ] expected = [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert process_queries(queries) == expected","solution":"def is_subsequence(s, t): Determine if t is a subsequence of s. t_index = 0 for char in s: if t_index < len(t) and char == t[t_index]: t_index += 1 if t_index == len(t): return \\"YES\\" return \\"NO\\" def process_queries(queries): results = [] for s, t in queries: results.append(is_subsequence(s, t)) return results"},{"question":"def is_scramble(s1: str, s2: str) -> str: Determines if s2 is a scrambled string of s1. >>> is_scramble(\\"abcd\\", \\"bdac\\") 'NO' >>> is_scramble(\\"great\\", \\"rgeat\\") 'YES' >>> is_scramble(\\"aaaa\\", \\"aaaa\\") 'YES' >>> is_scramble(\\"a\\", \\"a\\") 'YES' >>> is_scramble(\\"a\\", \\"b\\") 'NO' >>> is_scramble(\\"abc\\", \\"abcd\\") 'NO' >>> is_scramble(\\"abcd\\", \\"abc\\") 'NO' >>> is_scramble(\\"abc\\", \\"bca\\") 'YES' >>> is_scramble(\\"abc\\", \\"cab\\") 'YES' >>> is_scramble(\\"abc\\", \\"cba\\") 'YES' >>> is_scramble(\\"abcde\\", \\"caebd\\") 'NO' >>> is_scramble(\\"aabb\\", \\"abab\\") 'YES' pass def test_is_scramble_example1(): assert is_scramble(\\"abcd\\", \\"bdac\\") == \\"NO\\" def test_is_scramble_example2(): assert is_scramble(\\"great\\", \\"rgeat\\") == \\"YES\\" def test_is_scramble_identical(): assert is_scramble(\\"aaaa\\", \\"aaaa\\") == \\"YES\\" def test_is_scramble_single_char(): assert is_scramble(\\"a\\", \\"a\\") == \\"YES\\" assert is_scramble(\\"a\\", \\"b\\") == \\"NO\\" def test_is_scramble_different_lengths(): assert is_scramble(\\"abc\\", \\"abcd\\") == \\"NO\\" assert is_scramble(\\"abcd\\", \\"abc\\") == \\"NO\\" def test_is_scramble_anagrams_not_scramble(): assert is_scramble(\\"abc\\", \\"bca\\") == \\"YES\\" assert is_scramble(\\"abc\\", \\"cab\\") == \\"YES\\" assert is_scramble(\\"abc\\", \\"cba\\") == \\"YES\\" def test_is_scramble_complex(): assert is_scramble(\\"abcde\\", \\"caebd\\") == \\"NO\\" assert is_scramble(\\"aabb\\", \\"abab\\") == \\"YES\\"","solution":"def is_scramble(s1, s2): Determines if s2 is a scrambled string of s1. if len(s1) != len(s2): return \\"NO\\" if s1 == s2: return \\"YES\\" if sorted(s1) != sorted(s2): return \\"NO\\" n = len(s1) for i in range(1, n): if (is_scramble(s1[:i], s2[:i]) == \\"YES\\" and is_scramble(s1[i:], s2[i:]) == \\"YES\\") or (is_scramble(s1[:i], s2[-i:]) == \\"YES\\" and is_scramble(s1[i:], s2[:-i]) == \\"YES\\"): return \\"YES\\" return \\"NO\\""},{"question":"def longest_increasing_decreasing_pattern(n: int, prices: List[int]) -> int: Determine the length of the longest pattern of strictly increasing followed by strictly decreasing sequence in the given list of prices over n days. >>> longest_increasing_decreasing_pattern(10, [2, 1, 4, 3, 2, 1, 3, 4, 5, 3]) 5 >>> longest_increasing_decreasing_pattern(5, [2, 2, 2, 2, 2]) 0 >>> longest_increasing_decreasing_pattern(3, [1, 2, 1]) 3 >>> longest_increasing_decreasing_pattern(7, [1, 2, 3, 4, 3, 2, 1]) 7 >>> longest_increasing_decreasing_pattern(9, [1, 3, 2, 2, 1, 3, 4, 3, 2]) 5","solution":"def longest_increasing_decreasing_pattern(n, prices): if n < 3: return 0 longest_length = 0 i = 0 while i < n - 2: increasing_length = 0 decreasing_length = 0 # Check for increasing sequence while i < n - 1 and prices[i] < prices[i + 1]: increasing_length += 1 i += 1 # Check for decreasing sequence while increasing_length > 0 and i < n - 1 and prices[i] > prices[i + 1]: decreasing_length += 1 i += 1 # Update the longest found pattern length if increasing_length > 0 and decreasing_length > 0: longest_length = max(longest_length, increasing_length + decreasing_length + 1) # Skip duplicates if the sequence is not strictly increasing at first if increasing_length == 0 and decreasing_length == 0: i += 1 return longest_length"},{"question":"def check_graph_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine whether the graph is connected or not. A graph is connected if there is a path between any pair of distinct nodes. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): A list of edges where each edge is represented by a tuple (u, v). Returns: str: \\"YES\\" if the graph is connected, otherwise \\"NO\\". >>> check_graph_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> check_graph_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> check_graph_connected(1, 0, []) \\"YES\\" >>> check_graph_connected(2, 1, [(1, 2)]) \\"YES\\" >>> check_graph_connected(2, 0, []) \\"NO\\" >>> check_graph_connected(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\" >>> check_graph_connected(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) \\"NO\\"","solution":"def is_connected(n, m, edges): from collections import defaultdict, deque if n == 1: return True # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to check connectivity visited = set() queue = deque([1]) # Start from node 1 (assuming nodes are labeled from 1 to n) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in adj_list[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n def check_graph_connected(n, m, edges): if is_connected(n, m, edges): return \\"YES\\" else: return \\"NO\\""},{"question":"def min_steps_to_reach_end(m: int, n: int, grid: List[List[int]]) -> int: Antara is participating in a grid-based game where she has to move from the top-left corner of a grid to the bottom-right corner in the least number of steps. However, the grid is filled with obstacles that she cannot pass through. The grid is defined as an m x n matrix where cells are either empty (represented by 0) or have an obstacle (represented by 1). Antara can move one step in four possible directions: up, down, left, or right. Returns the minimum number of steps required for Antara to reach the bottom-right corner from the top-left corner. If it is impossible for Antara to reach the bottom-right corner, return -1. >>> min_steps_to_reach_end(3, 3, [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) 4 >>> min_steps_to_reach_end(2, 2, [ [0, 1], [1, 0] ]) -1 >>> min_steps_to_reach_end(1, 1, [[0]]) 0 >>> min_steps_to_reach_end(1, 1, [[1]]) -1 >>> min_steps_to_reach_end(500, 500, [[1]*500 for _ in range(500)]) -1 >>> min_steps_to_reach_end(500, 500, [[0]*500 for _ in range(500)]) 998","solution":"from collections import deque def min_steps_to_reach_end(m, n, grid): Returns the minimum number of steps required to reach the bottom-right corner of the grid from the top-left corner. Returns -1 if it is not possible. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"from collections import deque from typing import List def min_moves(grid: List[str], n: int, m: int) -> int: Determine the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid. :param grid: List of strings representing the n x m grid :param n: Number of rows in the grid :param m: Number of columns in the grid :return: Minimum number of moves, or -1 if not possible >>> min_moves([ ... \\"....\\", ... \\"..\\", ... \\"..\\", ... \\"....\\" ...], 4, 4) 6 >>> min_moves([ ... \\"#\\", ... \\"#..\\", ... \\".#.\\" ...], 3, 3) -1 pass","solution":"from collections import deque def min_moves(grid, n, m): Determine the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid. :param grid: List of strings representing the n x m grid :param n: Number of rows in the grid :param m: Number of columns in the grid :return: Minimum number of moves, or -1 if not possible # Directions for movements (down, up, right, left) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Check for edge cases where start or end is blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 # Queue for BFS with (row, col, distance) queue = deque([(0, 0, 0)]) # Set to track visited positions visited = set((0, 0)) while queue: row, col, dist = queue.popleft() # Check if we have reached the bottom-right cell if (row, col) == (n-1, m-1): return dist # Explore all possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if the new position is valid if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == '.': queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"def min_coins_needed(n: int) -> int: Returns the minimum number of different coin values needed to represent any value from 1 to n. Each coin value can be used an unlimited number of times. >>> min_coins_needed(1) 1 >>> min_coins_needed(2) 2 >>> min_coins_needed(5) 3 >>> min_coins_needed(10) 4 >>> min_coins_needed(20) 5 >>> min_coins_needed(100) 7 >>> min_coins_needed(1000000) 20","solution":"def min_coins_needed(n): Returns the minimum number of different coin values needed to represent any value from 1 to n. The solution uses a greedy approach by always choosing the largest possible power of 2 that doesn't exceed n. # Initialize count of different coin values coin_count = 0 # Start with the largest power of 2 coin_value = 1 # Keep multiplying by 2 until it exceeds n while coin_value <= n: coin_value *= 2 coin_count += 1 return coin_count"},{"question":"def lexicographically_smallest(s: str) -> str: Returns the lexicographically smallest string possible by moving characters any number of times to the end. >>> lexicographically_smallest(\\"bcada\\") 'aabcd' >>> lexicographically_smallest(\\"helloworld\\") 'dehllloorw'","solution":"def lexicographically_smallest(s: str) -> str: Returns the lexicographically smallest string possible by moving characters any number of times to the end. return ''.join(sorted(s))"},{"question":"def count_integer_occurrences(n: int, initial_sequence: List[int], m: int, operations: List[str], q: int) -> int: Process the sequence and the operations to find the occurrences of an integer in the sequence after all operations. Parameters: n (int): The initial number of integers in the sequence. initial_sequence (List[int]): The initial elements of the sequence. m (int): Number of operations. operations (List[str]): The descriptions of the operations. q (int): The integer whose occurrence count need to be determined. Returns: int: The number of times q appears in the sequence after all operations. >>> count_integer_occurrences(5, [1, 2, 3, 2, 1], 4, [\\"add 2\\", \\"remove 1\\", \\"add 3\\", \\"remove 4\\"], 2) 3 >>> count_integer_occurrences(3, [1, 1, 1], 2, [\\"remove 1\\", \\"remove 1\\"], 1) 1 >>> count_integer_occurrences(4, [5, 5, 5, 5], 1, [\\"add 5\\"], 5) 5 >>> count_integer_occurrences(4, [4, 4, 4, 4], 5, [\\"remove 4\\", \\"remove 4\\", \\"remove 4\\", \\"remove 4\\", \\"remove 4\\"], 4) 0 >>> count_integer_occurrences(0, [], 2, [\\"add 100\\", \\"add 100\\"], 100) 2 >>> count_integer_occurrences(6, [3, 3, 3, 3, 3, 3], 6, [\\"remove 3\\", \\"remove 3\\", \\"remove 3\\", \\"remove 3\\", \\"remove 3\\", \\"remove 3\\"], 3) 0 >>> count_integer_occurrences(5, [1, 2, 3, 4, 5], 0, [], 3) 1 >>> count_integer_occurrences(4, [1, 2, 3, 4], 2, [\\"remove 5\\", \\"remove 6\\"], 1) 1 >>> count_integer_occurrences(5, [1, 2, 3, 2, 1], 3, [\\"add 5\\", \\"add 5\\", \\"add 5\\"], 5) 3 >>> count_integer_occurrences(5, [1, 2, 3, 2, 1], 4, [\\"remove 1\\", \\"remove 2\\", \\"remove 1\\", \\"remove 3\\"], 2) 1 pass","solution":"def count_integer_occurrences(n, initial_sequence, m, operations, q): from collections import Counter # Create a counter for the initial sequence sequence_counter = Counter(initial_sequence) # Process each operation for operation in operations: op, x = operation.split() x = int(x) if op == \\"add\\": sequence_counter[x] += 1 elif op == \\"remove\\": if sequence_counter[x] > 0: sequence_counter[x] -= 1 # Return the count of q in the sequence return sequence_counter[q]"},{"question":"def minimum_total_construction_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Returns the minimum total construction cost to connect all the towns. If it is impossible to connect all towns, returns -1. >>> minimum_total_construction_cost(4, 5, [(1, 2, 1), (2, 3, 2), (1, 3, 2), (1, 4, 3), (3, 4, 4)]) 6 >>> minimum_total_construction_cost(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_total_construction_cost(4, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1), (2, 4, 1), (1, 3, 1)]) 3 >>> minimum_total_construction_cost(2, 1, [(1, 2, 100)]) 100","solution":"def minimum_total_construction_cost(n, m, roads): Returns the minimum total construction cost to connect all the towns. If it is impossible to connect all towns, returns -1. # Kruskal's Algorithm to find the minimum spanning tree parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX return True return False # Sort edges by cost roads.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for a, b, cost in roads: if union(a - 1, b - 1): total_cost += cost edges_used += 1 if edges_used == n - 1: return total_cost return -1 if edges_used != n - 1 else total_cost # Example usage: n = 4 m = 5 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 2), (1, 4, 3), (3, 4, 4), ] print(minimum_total_construction_cost(n, m, roads)) # Output should be 6"},{"question":"def findMinMaxTaskTime(n: int, m: int, tasks: List[int]) -> int: Determine the minimum possible maximum task completion time for any employee when the tasks are distributed optimally. >>> findMinMaxTaskTime(5, 2, [4, 7, 8, 3, 1]) 12 >>> findMinMaxTaskTime(3, 3, [1, 2, 3]) 3 >>> findMinMaxTaskTime(4, 2, [10, 10, 10, 10]) 20 >>> findMinMaxTaskTime(6, 3, [10, 5, 7, 8, 2, 3]) 13 >>> findMinMaxTaskTime(6, 1, [3, 8, 6, 5, 5, 9]) 36 >>> findMinMaxTaskTime(5, 5, [9, 8, 7, 6, 5]) 9 pass","solution":"def canDistribute(tasks, n, m, maxTime): This function checks if it is possible to distribute all tasks among 'm' employees such that no employee spends more than 'maxTime' on their tasks. employeesUsed = 1 currentTime = 0 for task in tasks: if currentTime + task > maxTime: employeesUsed += 1 currentTime = task if employeesUsed > m: return False else: currentTime += task return True def findMinMaxTaskTime(n, m, tasks): This function finds the minimum possible maximum task completion time for any employee when the tasks are distributed optimally. low, high = max(tasks), sum(tasks) while low < high: mid = (low + high) // 2 if canDistribute(tasks, n, m, mid): high = mid else: low = mid + 1 return low"},{"question":"def num_islands(grid: List[List[str]]) -> int: Recieves a grid containing 'L' (land) and 'W' (water) and returns the number of distinct islands. An island is a group of 'L' cells connected horizontally or vertically.","solution":"def num_islands(grid): Recieves a grid containing 'L' (land) and 'W' (water) and returns the number of distinct islands. An island is a group of 'L' cells connected horizontally or vertically. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == 'W' or visited[r][c]: return visited[r][c] = True # Explore neighbors (up, down, left, right) dfs(r - 1, c) # up dfs(r + 1, c) # down dfs(r, c - 1) # left dfs(r, c + 1) # right island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 'L' and not visited[r][c]: dfs(r, c) island_count += 1 return island_count"},{"question":"from typing import List, Tuple def heaviest_edge_in_mst(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: You are given an undirected, connected graph with \`n\` vertices and \`m\` edges. Each edge \`(u, v)\` has a non-negative weight \`w\`. Determine the minimum spanning tree (MST) of the graph and then find the heaviest edge in the MST. Args: - n (int): number of vertices - m (int): number of edges - edges (List[Tuple[int, int, int]]): list of edges, each represented as a tuple (u, v, w) Returns: - int: the weight of the heaviest edge in the MST Example: >>> heaviest_edge_in_mst(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (1, 4, 5)]) 3 >>> heaviest_edge_in_mst(2, 1, [(1, 2, 10)]) 10 >>> heaviest_edge_in_mst(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 2)]) 2 >>> heaviest_edge_in_mst(6, 9, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5), ... (1, 3, 6), (2, 4, 7), (3, 5, 8), (4, 6, 9)]) 5","solution":"import heapq def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst = [] for u, v, w in edges: u -= 1 v -= 1 if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst.append((u, v, w)) heaviest_edge_in_mst = max(edge[2] for edge in mst) return heaviest_edge_in_mst def heaviest_edge_in_mst(n, m, edge_list): edges = [] for edge in edge_list: u, v, w = edge edges.append((u, v, w)) return kruskal_mst(n, edges) # Example usage n = 4 m = 5 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 4), (1, 4, 5) ] print(heaviest_edge_in_mst(n, m, edges)) # Output: 3"},{"question":"from typing import List def count_peaks(matrix: List[List[int]], n: int, m: int) -> int: Counts the number of peaks in an n x m matrix. A peak is an element that is greater than all of its vertically and horizontally adjacent neighbors. :param matrix: List of list containing the matrix elements :param n: Number of rows in the matrix :param m: Number of columns in the matrix :return: The number of peaks in the matrix # Implement the function # Unit tests def test_single_peak_in_center(): matrix = [ [1, 2, 1], [4, 5, 4], [1, 2, 1] ] assert count_peaks(matrix, 3, 3) == 1 def test_multiple_peaks(): matrix = [ [10, 20, 15, 10], [12, 11, 14, 13], [16, 17, 18, 19] ] assert count_peaks(matrix, 3, 4) == 2 def test_no_peaks(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert count_peaks(matrix, 3, 3) == 0 def test_all_peaks(): matrix = [ [5] ] assert count_peaks(matrix, 1, 1) == 1 def test_single_row(): matrix = [ [1, 3, 2] ] assert count_peaks(matrix, 1, 3) == 1 def test_single_column(): matrix = [ [1], [3], [2] ] assert count_peaks(matrix, 3, 1) == 1 def test_large_matrix(): matrix = [ [10, 20, 30, 40], [50, 40, 30, 20], [10, 20, 30, 40], [50, 40, 30, 20] ] assert count_peaks(matrix, 4, 4) == 4","solution":"def count_peaks(matrix, n, m): Counts the number of peaks in an n x m matrix. A peak is an element that is greater than all of its vertically and horizontally adjacent neighbors. :param matrix: List of list containing the matrix elements :param n: Number of rows in the matrix :param m: Number of columns in the matrix :return: The number of peaks in the matrix peaks_count = 0 for i in range(n): for j in range(m): is_peak = True # Check above if i > 0 and matrix[i][j] <= matrix[i-1][j]: is_peak = False # Check below if i < n-1 and matrix[i][j] <= matrix[i+1][j]: is_peak = False # Check left if j > 0 and matrix[i][j] <= matrix[i][j-1]: is_peak = False # Check right if j < m-1 and matrix[i][j] <= matrix[i][j+1]: is_peak = False if is_peak: peaks_count += 1 return peaks_count # Read input if __name__ == \\"__main__\\": n, m = map(int, input().strip().split()) matrix = [] for _ in range(n): row = list(map(int, input().strip().split())) matrix.append(row) print(count_peaks(matrix, n, m))"},{"question":"from typing import List, Tuple def process_queries(n: int, sequence: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes each query to determine the minimum integer within the specified subrange. Parameters: n (int): Number of elements in the sequence sequence (list of int): The sequence of integers queries (list of tuples): List of (l, r) queries Returns: list of int: Minimum values for each query Example: >>> process_queries(5, [4, 2, -3, 5, 1], [(1, 3), (2, 4), (1, 5)]) [-3, -3, -3]","solution":"def process_queries(n, sequence, queries): Processes each query to determine the minimum integer within the specified subrange. Parameters: n (int): Number of elements in the sequence sequence (list of int): The sequence of integers queries (list of tuples): List of (l, r) queries Returns: list of int: Minimum values for each query results = [] for l, r in queries: # Convert to zero-based index for proper slicing subrange = sequence[l-1:r] results.append(min(subrange)) return results"},{"question":"def min_number_of_teams(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[Tuple[int, List[int]]]: Determine the minimum number of teams required and an assignment of each employee to a team given constraints on incompatibilities. >>> min_number_of_teams(1, [(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) [(2, [1, 2, 1, 2, 1])] >>> min_number_of_teams(1, [(4, 0, [])]) [(1, [1, 1, 1, 1])] >>> min_number_of_teams(1, [(3, 3, [(1, 2), (2, 3), (3, 1)])]) [(3, [1, 2, 3])] >>> min_number_of_teams(1, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [(2, [1, 2, 1, 2])]","solution":"import networkx as nx def min_number_of_teams(t, test_cases): results = [] for i in range(t): n, k, incompatible_pairs = test_cases[i] # Create an adjacency list to represent the graph G = nx.Graph() G.add_nodes_from(range(1, n + 1)) G.add_edges_from(incompatible_pairs) # Use graph coloring to determine minimum teams color_map = nx.coloring.greedy_color(G, strategy='largest_first') max_color = max(color_map.values()) + 1 # Prepare result team_assignments = [color_map[j] + 1 for j in range(1, n + 1)] results.append((max_color, team_assignments)) return results # Input parsing and function invocation t = 1 test_cases = [ (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) ] results = min_number_of_teams(t, test_cases) for result in results: m, team_assignments = result print(m) print(\\" \\".join(map(str, team_assignments)))"},{"question":"def shortest_path_with_penalty(n, m, L, passages, penalties): Calculate the shortest path from room 1 to room n with given passages and penalties. Parameters: n (int): Number of rooms. m (int): Number of passages. L (int): Penalty time threshold. passages (list of tuples): List of passages where each passage is represented as (ui, vi, ti). penalties (list of int): List of penalties for each passage. Returns: int: The shortest possible time to travel from room 1 to room n, including any penalties. Examples: >>> shortest_path_with_penalty(3, 3, 5, [(1, 2, 4), (2, 3, 3), (1, 3, 8)], [0, 2, 1]) 7 >>> shortest_path_with_penalty(4, 4, 10, [(1, 2, 5), (2, 3, 5), (3, 4, 5), (1, 4, 15)], [0, 0, 0, 10]) 15","solution":"import heapq def shortest_path_with_penalty(n, m, L, passages, penalties): Calculate the shortest path from room 1 to room n with given passages and penalties. Parameters: n (int): Number of rooms. m (int): Number of passages. L (int): Penalty time threshold. passages (list of tuples): List of passages where each passage is represented as (ui, vi, ti). penalties (list of int): List of penalties for each passage. Returns: int: The shortest possible time to travel from room 1 to room n, including any penalties. adj = [[] for _ in range(n + 1)] for i in range(m): ui, vi, ti = passages[i] pi = penalties[i] if ti > L else 0 adj[ui].append((vi, ti + pi)) def dijkstra(): dist = [float('inf')] * (n + 1) dist[1] = 0 pq = [(0, 1)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj[u]: if dist[u] + weight < dist[v]: dist[v] = dist[u] + weight heapq.heappush(pq, (dist[v], v)) return dist[n] return dijkstra()"},{"question":"def smallest_depth_with_k_vertices(n: int, k: int, edges: List[Tuple[int, int]]) -> int: Determines the smallest depth level d that has at least k vertices in a tree. :param n: The number of vertices in the tree. :param k: The minimum number of vertices required at the level. :param edges: A list of tuples where each tuple (u, v) represents an edge between vertex u and vertex v. :return: The smallest depth level d that has at least k vertices. >>> smallest_depth_with_k_vertices(6, 2, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 1 >>> smallest_depth_with_k_vertices(1, 1, []) 0 >>> smallest_depth_with_k_vertices(9, 3, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 7), (4, 8), (5, 9)]) 2","solution":"from collections import deque def smallest_depth_with_k_vertices(n, k, edges): Determines the smallest depth level d that has at least k vertices in a tree. :param n: The number of vertices in the tree. :param k: The minimum number of vertices required at the level. :param edges: A list of tuples where each tuple (u, v) represents an edge between vertex u and vertex v. :return: The smallest depth level d that has at least k vertices. if n == 1: # If there is only one node return 0 if k == 1 else -1 # Build adjacency list from edges adjacency_list = [[] for _ in range(n+1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Perform a BFS to calculate depth of each node depths = {} queue = deque([(1, 0)]) # Start from the root node (vertex 1) with depth 0 visited = set() while queue: current, depth = queue.popleft() if current in visited: continue visited.add(current) if depth in depths: depths[depth] += 1 else: depths[depth] = 1 for neighbor in adjacency_list[current]: if neighbor not in visited: queue.append((neighbor, depth + 1)) # Find the smallest depth with at least k vertices for depth in sorted(depths.keys()): if depths[depth] >= k: return depth return -1 # If such a depth does not exist"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"babad\\") in (\\"bab\\", \\"aba\\") True >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"aa\\") 'aa' >>> longest_palindromic_substring(\\"ab\\") in (\\"a\\", \\"b\\") True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") 'geeksskeeg' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"abcdefg\\") in (\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\") True >>> longest_palindromic_substring(\\"a\\" * 1000) 'a' * 1000","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" start = 0 max_len = 1 for i in range(1, n): # Check for even length palindromes low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 # Check for odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_len: start = low max_len = high - low + 1 low -= 1 high += 1 return s[start:start + max_len]"},{"question":"def count_non_overlapping_occurrences(s: str, t: str) -> int: Returns the number of non-overlapping occurrences of the substring t in the string s. >>> count_non_overlapping_occurrences(\\"abababa\\", \\"aba\\") 2 >>> count_non_overlapping_occurrences(\\"hellohellohello\\", \\"hello\\") 3 >>> count_non_overlapping_occurrences(\\"aaaaa\\", \\"aa\\") 2 >>> count_non_overlapping_occurrences(\\"abcde\\", \\"f\\") 0 >>> count_non_overlapping_occurrences(\\"abcabcabcabcabc\\", \\"abc\\") 5 >>> count_non_overlapping_occurrences(\\"abc\\", \\"abc\\") 1 >>> count_non_overlapping_occurrences(\\"mississippi\\", \\"iss\\") 2","solution":"def count_non_overlapping_occurrences(s, t): Returns the number of non-overlapping occurrences of the substring t in the string s. count = 0 index = 0 while index <= len(s) - len(t): if s[index:index + len(t)] == t: count += 1 index += len(t) else: index += 1 return count"},{"question":"def min_operations(start: str, target: str) -> int: Computes the minimum number of operations required to transform start string into target string. The allowed operations are: 1. Replace any character of start with any other character. 2. Remove any character from start. 3. Insert any character at any position in start. Args: start (str): The initial string. target (str): The target string. Returns: int: The minimum number of operations required to transform start into target. Examples: >>> min_operations(\\"abcdef\\", \\"azced\\") 3 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"\\", \\"abc\\") 3","solution":"def min_operations(start, target): Computes the minimum number of operations required to transform start string into target string. Operations allowed are: replace, remove, insert. m, n = len(start), len(target) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n]"},{"question":"def sieve_of_eratosthenes(limit): primes = [] is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for number in range(2, limit + 1): if is_prime[number]: primes.append(number) for multiple in range(number * number, limit + 1, number): is_prime[multiple] = False return primes def prime_decomposition(n): Decompose a given positive integer n into the sum of the maximum number of prime numbers with the smallest lexicographical order. >>> prime_decomposition(6) [2, 2, 2] >>> prime_decomposition(10) [2, 2, 2, 2, 2] >>> prime_decomposition(13) [13]","solution":"def sieve_of_eratosthenes(limit): primes = [] is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for number in range(2, limit + 1): if is_prime[number]: primes.append(number) for multiple in range(number * number, limit + 1, number): is_prime[multiple] = False return primes def prime_decomposition(n): if n < 2: raise ValueError(\\"The value of n must be at least 2.\\") primes = sieve_of_eratosthenes(n) result = [] while n > 0: if n in primes: result.append(n) break else: result.append(2) n -= 2 result.sort() return result # Testing the function with a sample input n = 6 print(prime_decomposition(n)) # Expected output: [2, 2, 2]"},{"question":"from typing import List def sort_adjacent_different(t: int, cases: List[str]) -> List[str]: Sort each string in the list \`cases\` such that adjacent characters are different. If it is impossible to sort the string in this way, return \\"Impossible\\" for that string. Args: t: int - The number of test cases. cases: List[str] - The list of strings to be sorted. Returns: List[str] - The list of sorted strings or \\"Impossible\\" if not feasible. >>> sort_adjacent_different(3, [\\"aabbcc\\", \\"aaab\\", \\"abcdef\\"]) [\\"abcabc\\", \\"Impossible\\", \\"abcdef\\"] >>> sort_adjacent_different(1, [\\"aaa\\"]) [\\"Impossible\\"] results = [] for s in cases: count_map = Counter(s) max_heap = [] for char, freq in count_map.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char if len(result) == len(s): results.append(''.join(result)) else: results.append('Impossible') return results","solution":"from collections import Counter import heapq def sort_adjacent_different(t, cases): results = [] for s in cases: count_map = Counter(s) max_heap = [] for char, freq in count_map.items(): heapq.heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char if len(result) == len(s): results.append(''.join(result)) else: results.append('Impossible') return results"},{"question":"def can_completely_reverse_deck(n: int, k: int) -> str: Determines if it's possible to completely reverse the deck of n cards using the operation of reversing any segment of k consecutive cards. >>> can_completely_reverse_deck(6, 3) \\"YES\\" >>> can_completely_reverse_deck(5, 2) \\"YES\\" >>> can_completely_reverse_deck(4, 3) \\"NO\\"","solution":"def can_completely_reverse_deck(n, k): Determines if it's possible to completely reverse the deck of n cards using the operation of reversing any segment of k consecutive cards. :param n: The number of cards in the deck. :param k: The length of the segment he can reverse. :return: \\"YES\\" if it is possible to reverse the deck, otherwise \\"NO\\". # If k is equal to n or k == 1, we can reverse the whole deck directly (or reversing 1 by 1) if k == n or k == 1: return \\"YES\\" # If n is divisible by k, we can reverse every k segment, which is bigger, and we can reverse larger segments step-by-step. if n % k == 0: return \\"YES\\" # If k is an even number if k % 2 == 0: return \\"YES\\" # If k is odd and the length of the deck is also odd, we can do it step by step. # But if n is even, we can't break down odd k into even n evenly. if (n % 2 != 0): return \\"YES\\" # Otherwise, it's not possible return \\"NO\\""},{"question":"def has_valid_path(n: int, m: int, grid: List[List[int]]) -> str: Determine if there is a valid path from the top-left to the bottom-right of the grid. >>> has_valid_path(3, 3, [ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) == \\"Yes\\" >>> has_valid_path(3, 3, [ ... [5, 4, 3], ... [6, 5, 4], ... [7, 6, 5] ... ]) == \\"No\\"","solution":"def has_valid_path(n, m, grid): def dfs(x, y, current_value): if x == n - 1 and y == m - 1: return True if x + 1 < n and grid[x + 1][y] > current_value: if dfs(x + 1, y, grid[x + 1][y]): return True if y + 1 < m and grid[x][y + 1] > current_value: if dfs(x, y + 1, grid[x][y + 1]): return True return False return \\"Yes\\" if dfs(0, 0, grid[0][0]) else \\"No\\""},{"question":"def find_fountain_coordinates(n: int, m: int) -> tuple: Given the grid dimensions n (number of rows) and m (number of columns), determine the block coordinates (i, j) where the fountain should be placed in order to minimize the maximum walking distance. Parameters: n (int): number of rows m (int): number of columns Returns: tuple: coordinates (i, j) of the optimal location for the fountain Examples: >>> find_fountain_coordinates(3, 4) (2, 2) >>> find_fountain_coordinates(5, 5) (3, 3)","solution":"def find_fountain_coordinates(n, m): Given the grid dimensions n (number of rows) and m (number of columns), determine the block coordinates (i, j) where the fountain should be placed in order to minimize the maximum walking distance. Parameters: n (int): number of rows m (int): number of columns Returns: tuple: coordinates (i, j) of the optimal location for the fountain optimal_row = (n + 1) // 2 optimal_col = (m + 1) // 2 return (optimal_row, optimal_col)"},{"question":"def maximal_rectangle(R: int, C: int, garden: List[List[str]]) -> int: Grigor is a passionate gardener who loves planting flowers. He has a rectangular garden that consists of a grid of cells with R rows and C columns. Each cell can either be empty or contain a flower. Grigor has recently decided to organize his garden by ensuring that he can create a flower bed that forms a perfect rectangle, with flowers occupying every cell within that rectangle. You are given the grid's configuration, where '.' represents an empty cell and '*' represents a cell with a flower. Determine the maximum possible area of a rectangular flower bed that Grigor can form in his garden. :param R: The number of rows in the garden grid. :param C: The number of columns in the garden grid. :param garden: A list of lists representing the garden grid, where '.' represents an empty cell and '*' represents a cell with a flower. :return: The area of the largest rectangular flower bed that can be formed. >>> maximal_rectangle(4, 5, [['.', '.', '.', '.', '.'], ['.', '*', '*', '*', '.'], ['.', '*', '*', '*', '.'], ['.', '.', '.', '.', '.']]) 6 >>> maximal_rectangle(1, 5, [['.', '*', '*', '*', '.']]) 3 >>> maximal_rectangle(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 0","solution":"def maximal_rectangle(R, C, garden): # Initialize variables max_area = 0 height = [0] * (C + 1) # Adding a sentinel column to simplify the code # Iterate over rows of the garden for row in garden: for j in range(C): if row[j] == '*': height[j] += 1 else: height[j] = 0 # Calculate max area in this row considering heights calculated so far stack = [-1] for j in range(C + 1): while height[j] < height[stack[-1]]: h = height[stack.pop()] w = j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area def process_input(data): lines = data.strip().split('n') R, C = map(int, lines[0].split()) garden = [list(lines[i + 1]) for i in range(R)] return R, C, garden def maximal_rectangle_from_input(data): R, C, garden = process_input(data) return maximal_rectangle(R, C, garden)"},{"question":"def min_diff_split(n, chores): Determines the minimum possible difference between the total effort of two groups of chores. Parameters: n (int): The number of chores. chores (list of int): A list representing the amount of effort required for each chore. Returns: int: The minimum possible difference between the total effort of the two groups. >>> min_diff_split(5, [3, 1, 4, 2, 2]) 0 >>> min_diff_split(3, [1, 2, 3]) 0 >>> min_diff_split(4, [8, 6, 10, 5]) 1 >>> min_diff_split(2, [7, 5]) 2 >>> min_diff_split(6, [3, 1, 4, 9, 2, 8]) 1 >>> min_diff_split(1, [10]) 10 def process_input_output(input_str): Processes the input string and returns the minimum possible difference between the total effort of the two groups of chores. Parameters: input_str (str): A string representation of the input. Returns: int: The minimum possible difference between the total effort of the two groups. >>> process_input_output(\\"5n3 1 4 2 2n\\") 0 >>> process_input_output(\\"3n1 2 3n\\") 0 >>> process_input_output(\\"4n8 6 10 5n\\") 1 >>> process_input_output(\\"2n7 5n\\") 2 >>> process_input_output(\\"6n3 1 4 9 2 8n\\") 1 >>> process_input_output(\\"1n10n\\") 10","solution":"def min_diff_split(n, chores): Determines the minimum possible difference between the total effort of two groups of chores. Parameters: n (int): The number of chores. chores (list of int): A list representing the amount of effort required for each chore. Returns: int: The minimum possible difference between the total effort of the two groups. total_sum = sum(chores) half_sum = total_sum // 2 # Create a DP table where dp[i][j] means whether a subset of chores[0..i] can have a sum of \`j\` dp = [[False] * (half_sum + 1) for _ in range(n + 1)] dp[0][0] = True # Base case: There's a zero sum when no items are taken for i in range(1, n + 1): for j in range(half_sum + 1): dp[i][j] = dp[i-1][j] if j >= chores[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - chores[i-1]] # Find the maximum sum that is closest to half_sum max_half_sum = max(j for j in range(half_sum + 1) if dp[n][j]) return total_sum - 2 * max_half_sum def process_input_output(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) chores = list(map(int, lines[1].split())) return min_diff_split(n, chores)"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit achievable by making at most one transaction. :param prices: List[int] - list of positive integers representing stock prices over a number of days :return: int - the maximum profit possible, or 0 if no profit is possible >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): This function returns the maximum profit that can be achieved by making at most one transaction. :param prices: List[int], a list of stock prices :return: int, the maximum profit (or 0 if no profit is possible) if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_misplaced_element(arr): Finds the misplaced element in the array and the correct position it should be in. Parameters: arr (list): The shuffled array with N elements Returns: tuple: A tuple containing the misplaced element and its correct position Example: >>> find_misplaced_element([1, 2, 3, 4, 5]) is None >>> find_misplaced_element([2, 1, 3, 4, 5]) == (2, 1) >>> find_misplaced_element([1, 2, 3, 5, 4]) == (5, 4) >>> find_misplaced_element([1, 2, 4, 3, 5]) == (4, 3) >>> find_misplaced_element([1, 2, 3, 4, 6, 5, 7, 8, 9, 10]) == (6, 5)","solution":"def find_misplaced_element(arr): Finds the misplaced element in the array and the correct position it should be in. Parameters: arr (list): The shuffled array with N elements Returns: tuple: A tuple containing the misplaced element and its correct position n = len(arr) sorted_arr = sorted(arr) for i in range(n): if arr[i] != sorted_arr[i]: return (arr[i], i + 1)"},{"question":"def find_last_favorite_genre_day(n: int, genres: List[int], favorite_genre: int) -> int: Determine the day Tom will finish watching the last episode of his favorite genre. Parameters: n (int): Number of episodes in the list. genres (list of int): List of genres for each episode. favorite_genre (int): The genre Tom wants to prioritize and watch completely. Returns: int: The day Tom finishes the last episode of his favorite genre. Examples: >>> find_last_favorite_genre_day(10, [1, 2, 6, 3, 1, 7, 4, 5, 1, 6], 1) 9 >>> find_last_favorite_genre_day(5, [2, 4, 5, 6, 7], 1) 0","solution":"def find_last_favorite_genre_day(n, genres, favorite_genre): Determine the day Tom will finish watching the last episode of his favorite genre. Parameters: n (int): Number of episodes in the list. genres (list of int): List of genres for each episode. favorite_genre (int): The genre Tom wants to prioritize and watch completely. Returns: int: The day Tom finishes the last episode of his favorite genre. last_day = 0 for i in range(n): if genres[i] == favorite_genre: last_day = i + 1 return last_day"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string s a palindrome by removing characters. >>> min_operations_to_palindrome(\\"abc\\") 2 >>> min_operations_to_palindrome(\\"aabb\\") 2 >>> min_operations_to_palindrome(\\"abcdcba\\") 0 def solve(t: int, strings: List[str]) -> List[int]: Returns a list of integers representing the minimum number of operations required to make each string in the list a palindrome. >>> solve(3, [\\"abc\\", \\"aabb\\", \\"abcdcba\\"]) [2, 2, 0]","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string s a palindrome by removing characters. # We solve this problem using dynamic programming, finding the longest palindromic subsequence # and calculating the minimum deletions required. n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # The number of deletions required is the difference # between the string length and the length of longest palindromic subsequence lps_length = dp[0][n-1] return n - lps_length def solve(t, strings): results = [] for s in strings: results.append(min_operations_to_palindrome(s)) return results"},{"question":"from typing import List, Tuple def preprocess_array(arr: List[int]) -> Tuple[List[int], List[List[int]]]: Preprocess the input array to create prefix sums and a segment tree for range minima queries. Args: arr (List[int]): The input array of integers. Returns: Tuple containing the prefix sum array and the segment tree. pass def range_sum(prefix_sum: List[int], left: int, right: int) -> int: Calculate the sum of the subarray from the prefix sum array. Args: prefix_sum (List[int]): The prefix sum array. left (int): The left index of the range (0-based). right (int): The right index of the range (0-based). Returns: int: The sum of the subarray. pass def range_minimum(st: List[List[int]], left: int, right: int) -> int: Find the minimum element in the subarray using the segment tree. Args: st (List[List[int]]): The segment tree. left (int): The left index of the range (0-based). right (int): The right index of the range (0-based). Returns: int: The minimum element in the subarray. pass def answer_queries(arr: List[int], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Answer multiple queries efficiently using preprocessed data. Args: arr (List[int]): The input array of integers. queries (List[Tuple[int, int]]): List of queries with each query being a tuple of (left, right). Returns: List[Tuple[int, int]]: List of results for each query with each result being a tuple of (sum, minimum). pass # Example usage: # arr = [1, 2, 7, 4, 5, 3, 6, 8] # queries = [(1, 4), (2, 6), (3, 8)] # results = answer_queries(arr, queries) # print(results) # [(14, 1), (21, 2), (33, 3)]","solution":"def preprocess_array(arr): n = len(arr) # Preprocess prefix sums prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] # Preprocess segment tree for range minima queries import math st = [[0] * (math.ceil(math.log2(n))+1) for _ in range(n)] # Initialize leaves of segment tree for i in range(n): st[i][0] = arr[i] j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 return prefix_sum, st def range_sum(prefix_sum, left, right): return prefix_sum[right + 1] - prefix_sum[left] def range_minimum(st, left, right): import math j = int(math.log2(right - left + 1)) return min(st[left][j], st[right - (1 << j) + 1][j]) def answer_queries(arr, queries): n = len(arr) prefix_sum, st = preprocess_array(arr) results = [] for left, right in queries: sum_range = range_sum(prefix_sum, left - 1, right - 1) min_range = range_minimum(st, left - 1, right - 1) results.append((sum_range, min_range)) return results"},{"question":"def propagate_values(n, m, initial_values, edges): Given a directed acyclic graph (DAG) with \`n\` nodes and \`m\` edges, and the initial values of all nodes, determine the final value of each node after propagating values to their direct successors. Args: n (int): Number of nodes. m (int): Number of edges. initial_values (List[int]): Initial values of the nodes. edges (List[Tuple[int, int]]): List of directed edges from node \`u\` to node \`v\`. Returns: List[int]: Final values of each node. Example: >>> propagate_values(5, 4, [1, 2, 0, 0, 0], [(1, 3), (2, 3), (3, 4), (4, 5)]) [1, 2, 3, 3, 3] >>> propagate_values(1, 0, [5], []) [5] >>> propagate_values(2, 0, [3, 7], []) [3, 7] >>> propagate_values(4, 3, [2, 1, 0, 0], [(1, 3), (2, 3), (3, 4)]) [2, 1, 3, 3] >>> propagate_values(4, 3, [0, 0, 0, 0], [(1, 2), (2, 3), (3, 4)]) [0, 0, 0, 0] >>> propagate_values(3, 2, [1000, 1000, 0], [(1, 3), (2, 3)]) [1000, 1000, 2000]","solution":"def propagate_values(n, m, initial_values, edges): from collections import defaultdict, deque adjacency_list = defaultdict(list) in_degree = [0] * n values = list(initial_values) for u, v in edges: adjacency_list[u-1].append(v-1) in_degree[v-1] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: values[neighbor] += values[node] in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return values"},{"question":"def min_stones_to_remove(n: int, stones: str) -> int: Calculate the minimum number of stones to remove so that no two consecutive stones have the same color. :param n: Number of stones :param stones: String of stones' colors :return: Minimum number of stones to remove >>> min_stones_to_remove(5, 'aabcc') 2 >>> min_stones_to_remove(4, 'abcd') 0 >>> min_stones_to_remove(3, 'aaa') 2 >>> min_stones_to_remove(6, 'ababab') 0 >>> min_stones_to_remove(1, 'a') 0","solution":"def min_stones_to_remove(n, stones): Calculate the minimum number of stones to remove so that no two consecutive stones have the same color. :param n: Number of stones :param stones: String of stones' colors :return: Minimum number of stones to remove if n <= 1: return 0 # No removals needed if there are 1 or fewer stones removals = 0 for i in range(1, n): if stones[i] == stones[i - 1]: removals += 1 return removals"},{"question":"def max_balanced_groups(n: int, d: int, speeds: List[int]) -> int: Determine the maximum number of balanced groups based on given speeds and max allowed speed difference. :param n: Number of participants :param d: Maximum allowed speed difference within a group :param speeds: List of speeds of the participants :return: Maximum number of balanced groups >>> max_balanced_groups(6, 4, [5, 9, 12, 15, 18, 22]) 3 >>> max_balanced_groups(1, 4, [5]) 1 >>> max_balanced_groups(4, 5, [2, 3, 4, 5]) 1 >>> max_balanced_groups(4, 1, [1, 3, 5, 7]) 4 >>> max_balanced_groups(5, 1, [1, 3, 6, 10, 15]) 5 >>> max_balanced_groups(5, 1000, [1, 2, 3, 4, 5]) 1 >>> max_balanced_groups(6, 4, [22, 5, 15, 9, 12, 18]) 3","solution":"def max_balanced_groups(n, d, speeds): Determine the maximum number of balanced groups based on given speeds and max allowed speed difference. :param n: Number of participants :param d: Maximum allowed speed difference within a group :param speeds: List of speeds of the participants :return: Maximum number of balanced groups speeds.sort() groups_count = 0 i = 0 while i < n: groups_count += 1 start_speed = speeds[i] while i < n and speeds[i] - start_speed <= d: i += 1 return groups_count"},{"question":"from typing import List def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: You are given a matrix with \`n\` rows and \`m\` columns that consists of positive integers. You want to sort each row of the matrix in non-decreasing order by only allowing one operation: you can arbitrarily swap any two elements of the same column. Print the sorted matrix after performing the minimum number of such operations. Args: matrix (List[List[int]]): The input matrix with \`n\` rows and \`m\` columns. Returns: List[List[int]]: The sorted matrix row-wise. Example: >>> sort_matrix_rows([ ... [3, 1, 2], ... [9, 8, 7], ... [6, 4, 5] ... ]) [[1, 2, 3], [7, 8, 9], [4, 5, 6]] # Your implementation here # Unit tests def test_3x3_matrix(): input_matrix = [ [3, 1, 2], [9, 8, 7], [6, 4, 5] ] expected_output = [ [1, 2, 3], [7, 8, 9], [4, 5, 6] ] assert sort_matrix_rows(input_matrix) == expected_output def test_1x1_matrix(): input_matrix = [ [5] ] expected_output = [ [5] ] assert sort_matrix_rows(input_matrix) == expected_output def test_2x2_matrix(): input_matrix = [ [2, 1], [4, 3] ] expected_output = [ [1, 2], [3, 4] ] assert sort_matrix_rows(input_matrix) == expected_output def test_4x4_matrix(): input_matrix = [ [16, 12, 13, 14], [8, 6, 5, 7], [24, 22, 23, 21], [2, 1, 4, 3] ] expected_output = [ [12, 13, 14, 16], [5, 6, 7, 8], [21, 22, 23, 24], [1, 2, 3, 4] ] assert sort_matrix_rows(input_matrix) == expected_output def test_3x2_matrix(): input_matrix = [ [5, 8], [1, 3], [7, 2] ] expected_output = [ [5, 8], [1, 3], [2, 7] ] assert sort_matrix_rows(input_matrix) == expected_output","solution":"def sort_matrix_rows(matrix): n = len(matrix) m = len(matrix[0]) # Sort each row for i in range(n): matrix[i].sort() return matrix"},{"question":"def count_teams(skill_levels): This function returns the number of distinct teams that can be formed such that each team consists of exactly three students and the maximum difference in skill levels between any two students in a team is no more than 5. >>> count_teams([4, 5, 6, 10, 15]) 1 >>> count_teams([2, 3, 4, 5, 6, 7, 8, 9, 10]) 3 >>> count_teams([1, 9, 15, 20, 25]) 0 >>> count_teams([1, 2, 3, 4, 5, 6]) 2 >>> count_teams([1, 6, 11, 16, 4, 5, 9]) 2 >>> count_teams([3, 3, 3]) 1 >>> count_teams([1, 1, 1, 1, 1, 1]) 2","solution":"def count_teams(skill_levels): This function returns the number of distinct teams that can be formed such that each team consists of exactly three students and the maximum difference in skill levels between any two students in a team is no more than 5. Args: skill_levels (list): List of integers representing the skill levels of the students. Returns: int: Number of distinct teams that can be formed. skill_levels.sort() n = len(skill_levels) team_count = 0 for i in range(n - 2): if skill_levels[i + 2] - skill_levels[i] <= 5: team_count += 1 skill_levels.pop(i + 2) skill_levels.pop(i + 1) skill_levels.pop(i) return team_count + count_teams(skill_levels) return team_count"},{"question":"def max_events(m: int, costs: List[int], B: int) -> int: Determine the maximum number of events Alice can host without exceeding her budget. Args: m (int): The number of cities. costs (List[int]): The costs of hosting events in each city. B (int): Alice's total budget. Returns: int: The maximum number of events. Examples: >>> max_events(5, [4, 8, 2, 6, 10], 15) 3 >>> max_events(1, [10], 20) 1 >>> max_events(1, [10], 5) 0 >>> max_events(3, [3, 2, 5], 10) 3 >>> max_events(4, [10, 2, 5, 1], 8) 3 >>> max_events(3, [10, 20, 30], 5) 0 >>> max_events(4, [1, 2, 3, 4], 100) 4","solution":"def max_events(m, costs, B): Returns the maximum number of events Alice can host without exceeding her budget. Args: m (int): The number of cities. costs (list of int): The costs of hosting events in each city. B (int): Alice's total budget. Returns: int: The maximum number of events. costs.sort() # Sort the costs in ascending order total_cost = 0 events_count = 0 for cost in costs: if total_cost + cost <= B: total_cost += cost events_count += 1 else: break return events_count"},{"question":"def can_form_palindrome(s: str, queries: List[Tuple[int, int]]) -> List[str]: You are given a string \`s\` and a list of queries. Each query consists of two integers \`l\` and \`r\`. For each query, determine if the substring of \`s\` from index \`l\` to \`r\` (inclusive) can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one of its characters has an odd frequency. Example: >>> can_form_palindrome(\\"aabbc\\", [(1, 3), (2, 5), (1, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_form_palindrome(\\"a\\", [(1, 1)]) [\\"YES\\"] >>> can_form_palindrome(\\"aaaa\\", [(1, 4), (2, 3), (1, 1)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_form_palindrome(\\"abcde\\", [(1, 3), (2, 5), (1, 5)]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_form_palindrome(\\"racecar\\", [(1, 7), (3, 5), (2, 2)]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s, queries): # Helper function to process one query def is_palindrome_rearrangement_possible(sub): from collections import Counter counter = Counter(sub) odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1 # Processing the queries results = [] for l, r in queries: # l and r in the problem are 1-based, convert to 0-based substring = s[l-1:r] if is_palindrome_rearrangement_possible(substring): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def kth_smallest_in_subtree(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the k-th smallest value in a subtree of the tree. Args: n: The number of nodes in the tree. values: A list containing the values of the nodes labeled 1 through n. edges: A list of tuples where each tuple represents an edge between two nodes. queries: A list of tuples where each tuple represents a query with the root node of the subtree and the k-th position. Returns: A list of integers where each integer is the k-th smallest value for the corresponding query. Example: >>> kth_smallest_in_subtree(5, [5, 3, 8, 4, 2], [(1, 2), (1, 3), (3, 4), (3, 5)], [(3, 1), (3, 3), (1, 2)]) [2, 8, 3] >>> kth_smallest_in_subtree(1, [1], [], [(1, 1)]) [1]","solution":"from collections import defaultdict import heapq def kth_smallest_in_subtree(n, values, edges, queries): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # For memorizing the subtree values subtree_values = {} def dfs(node, parent): subtree = [] heapq.heappush(subtree, values[node-1]) for neighbor in tree[node]: if neighbor != parent: subtree.extend(dfs(neighbor, node)) subtree_values[node] = sorted(subtree) return subtree # Build subtree values starting from the root node (1) dfs(1, -1) results = [] for x, k in queries: results.append(subtree_values[x][k-1]) return results"},{"question":"def max_books(prices: List[int], budget: int) -> int: Returns the maximum number of books that can be bought without exceeding the budget. :param prices: List of integers representing the prices of the books. :param budget: Integer representing the budget. :return: Integer representing the maximum number of books that can be bought. Example: >>> max_books([5, 3, 8, 6, 2, 5], 10) 3 >>> max_books([4], 5) 1 >>> max_books([6], 5) 0 >>> max_books([1, 1, 1, 1], 5) 4 >>> max_books([20, 30, 40], 10) 0 >>> max_books([5, 15, 20, 35, 50], 100) 4 >>> max_books([10, 10, 10, 10], 20) 2 >>> max_books([5, 15, 20], 20) 2 >>> max_books([5, 5, 5], 15) 3 >>> max_books([], 10) 0 >>> max_books([1, 2, 3], 0) 0","solution":"def max_books(prices, budget): Returns the maximum number of books that can be bought without exceeding the budget. :param prices: List of integers representing the prices of the books. :param budget: Integer representing the budget. :return: Integer representing the maximum number of books that can be bought. prices.sort() num_books = 0 total_spent = 0 for price in prices: if total_spent + price <= budget: total_spent += price num_books += 1 else: break return num_books"},{"question":"class SequenceProcessor: def __init__(self, sequence): self.sequence = sequence def sum_range(self, l, r): raise NotImplementedError def update(self, i, x): raise NotImplementedError def process_queries(n, q, sequence, queries): Process several queries of two kinds on a sequence of integers. Args: n (int): Number of elements in the sequence. q (int): Number of queries. sequence (List[int]): Initial sequence of elements. queries (List[str]): List of queries to process. Returns: List[int]: Results of \\"SUM\\" queries. Example: >>> process_queries(5, 3, [1, 2, 3, 4, 5], [\\"SUM 1 3\\", \\"UPDATE 2 10\\", \\"SUM 1 3\\"]) [6, 14] processor = SequenceProcessor(sequence) results = [] for query in queries: parts = query.split() if parts[0] == \\"SUM\\": l, r = int(parts[1]), int(parts[2]) results.append(processor.sum_range(l, r)) elif parts[0] == \\"UPDATE\\": i, x = int(parts[1]), int(parts[2]) processor.update(i, x) return results","solution":"class SequenceProcessor: def __init__(self, sequence): self.sequence = sequence def sum_range(self, l, r): return sum(self.sequence[l-1:r]) def update(self, i, x): self.sequence[i-1] = x def process_queries(n, q, sequence, queries): processor = SequenceProcessor(sequence) results = [] for query in queries: parts = query.split() if parts[0] == \\"SUM\\": l, r = int(parts[1]), int(parts[2]) results.append(processor.sum_range(l, r)) elif parts[0] == \\"UPDATE\\": i, x = int(parts[1]), int(parts[2]) processor.update(i, x) return results # Example usage n, q = 5, 3 sequence = [1, 2, 3, 4, 5] queries = [\\"SUM 1 3\\", \\"UPDATE 2 10\\", \\"SUM 1 3\\"] print(process_queries(n, q, sequence, queries))"},{"question":"def manhattan_distance(n: int, x: int, y: int, a: int, b: int) -> int: Calculate the Manhattan distance between two cells (x, y) and (a, b) in an n x n grid. Parameters: n (int): The size of the grid. x (int): The row coordinate of the treasure cell. y (int): The column coordinate of the treasure cell. a (int): The row coordinate of another cell. b (int): The column coordinate of another cell. Returns: int: The Manhattan distance between the two cells (x, y) and (a, b). Example: >>> manhattan_distance(5, 3, 4, 1, 1) 5 >>> manhattan_distance(10, 5, 5, 5, 5) 0 >>> manhattan_distance(10, 5, 5, 5, 6) 1 >>> manhattan_distance(4, 1, 1, 4, 4) 6 >>> manhattan_distance(10000, 1, 1, 10000, 10000) 19998","solution":"def manhattan_distance(n, x, y, a, b): Calculate the Manhattan distance between two cells (x, y) and (a, b) in an n x n grid. Parameters: n (int): The size of the grid. x (int): The row coordinate of the treasure cell. y (int): The column coordinate of the treasure cell. a (int): The row coordinate of another cell. b (int): The column coordinate of another cell. Returns: int: The Manhattan distance between the two cells (x, y) and (a, b). return abs(x - a) + abs(y - b)"},{"question":"def highest_sale_transaction(sales_data: List[Tuple[str, int, int, int]]) -> Optional[str]: Determines which transaction had the highest sales amount and at what time this transaction occurred. Args: sales_data (List[Tuple[str, int, int, int]]): A list of tuples where each tuple contains transaction ID, amount of the sale, and time of the sale (hh, mm). Returns: Optional[str]: The transaction ID with the highest sales amount followed by the time as 'hh:mm'. If there are no transactions, return None. Examples: >>> highest_sale_transaction([(\\"TX001\\", 450, 10, 30)]) \\"TX001 10:30\\" >>> highest_sale_transaction([ ... (\\"TX001\\", 450, 10, 30), ... (\\"TX002\\", 890, 12, 45), ... (\\"TX003\\", 890, 11, 15), ... (\\"TX004\\", 900, 15, 30) ... ]) \\"TX004 15:30\\"","solution":"def highest_sale_transaction(sales_data): Function to determine which transaction had the highest sales amount and at what time it occurred. if not sales_data: return None n = len(sales_data) max_amount = -1 max_transaction = \\"\\" max_time = None for transaction in sales_data: trans_id, amount, hh, mm = transaction if amount > max_amount or (amount == max_amount and (hh, mm) < max_time): max_amount = amount max_transaction = trans_id max_time = (hh, mm) return f\\"{max_transaction} {max_time[0]:02}:{max_time[1]:02}\\""},{"question":"def partition_equal_sum_lists(arr: List[int]) -> Union[str, Tuple[str, str]]: Organizes the elements of arr into two lists such that the sum of elements in both lists is equal. If it is not possible, returns \\"Not Possible\\". >>> partition_equal_sum_lists([1, 2, 3, 4]) ('1 4', '2 3') >>> partition_equal_sum_lists([1, 1, 3]) 'Not Possible'","solution":"def partition_equal_sum_lists(arr): Organizes the elements of arr into two lists such that the sum of elements in both lists is equal. If it is not possible, returns \\"Not Possible\\". total_sum = sum(arr) # If the total sum is not even, we cannot partition it into two equal parts if total_sum % 2 != 0: return \\"Not Possible\\" target = total_sum // 2 n = len(arr) # Using dynamic programming to check if partitioning is possible dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): if dp[i-1][j]: dp[i][j] = True elif j >= arr[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] if not dp[n][target]: return \\"Not Possible\\" # Recover the partitions from the dp table subset1, subset2 = [], [] while n > 0: if dp[n-1][target]: subset2.append(arr[n-1]) n -= 1 else: subset1.append(arr[n-1]) target -= arr[n-1] n -= 1 # Joining the subsets in the required output format return ' '.join(map(str, subset1)), ' '.join(map(str, subset2))"},{"question":"def count_pairs_with_sum(test_cases): Given an array of integers, find the number of pairs of indices (i, j) such that i < j and the sum of the elements at these indices is equal to a given target sum. Args: test_cases (List[Tuple[int, List[int], int]]): List of test cases where each test case consists of: - an integer n: size of the array, - a list of integers (the array), - an integer t: the target sum. Returns: List[int]: List containing the number of pairs for each test case. >>> count_pairs_with_sum([(4, [1, 5, 7, -1], 6), (5, [1, 1, 1, 1, 1], 2)]) [2, 10] >>> count_pairs_with_sum([(1, [1], 2)]) [0] >>> count_pairs_with_sum([(4, [1, 2, 3, 4], 10)]) [0] def process_input(input_data): Parses the input data and returns the results of the count_pairs_with_sum function. Args: input_data (str): Multiline string input containing the number of test cases, followed by each test case in the format: n array elements target sum Returns: List[int]: List containing the number of pairs for each test case. >>> process_input(\\"2n4n1 5 7 -1n6n5n1 1 1 1 1n2\\") [2, 10] >>> process_input(\\"1n4n1 2 3 4n10\\") [0] >>> process_input(\\"3n1n1n2n2n-1 1n0n3n1 2 3n3\\") [0, 1, 1]","solution":"def count_pairs_with_sum(test_cases): :param test_cases: List of tuples, where each tuple represents a test case containing: (n : int -> size of the array, array : list of integers -> the elements of the array, t : int -> the target sum) :return: List of integers representing the number of pairs for each test case result = [] for n, array, target in test_cases: count_map = {} count = 0 for num in array: if target - num in count_map: count += count_map[target - num] if num in count_map: count_map[num] += 1 else: count_map[num] = 1 result.append(count) return result # Function to parse input and call count_pairs_with_sum def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(input_lines[index]) array = list(map(int, input_lines[index + 1].split())) target = int(input_lines[index + 2]) test_cases.append((n, array, target)) index += 3 return count_pairs_with_sum(test_cases)"},{"question":"def max_ascending_tower_height(n: int, heights: List[int]) -> int: Determines the length of the longest ascending subsequence of given block heights. >>> max_ascending_tower_height(6, [4, 2, 3, 1, 5, 6]) == 4 >>> max_ascending_tower_height(1, [1]) == 1 >>> max_ascending_tower_height(5, [1, 2, 3, 4, 5]) == 5 >>> max_ascending_tower_height(5, [5, 4, 3, 2, 1]) == 1 >>> max_ascending_tower_height(6, [10, 20, 10, 30, 20, 50]) == 4 >>> max_ascending_tower_height(4, [1000000000, 999999999, 1000000001, 1000000002]) == 3","solution":"def max_ascending_tower_height(n, heights): Determines the length of the longest ascending subsequence of given block heights. :param n: Number of blocks :param heights: List of heights in the given order :return: Maximum height of the tower that can be constructed in ascending order from bisect import bisect_left if n == 0: return 0 # Initialize the list that will store the smallest ending value of an increasing subsequence of each length lis = [] for h in heights: # Find the place in lis where height h could replace an element to maintain the list increasing pos = bisect_left(lis, h) if pos < len(lis): lis[pos] = h else: lis.append(h) return len(lis)"},{"question":"from typing import List, Tuple, Union def is_reachable_and_count_moves(n: int, m: int, grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> Union[Tuple[str, int], Tuple[str]]: Determine whether it is possible to move from the starting cell to the ending cell in the grid. If so, return \\"YES\\" and the number of moves required, otherwise return \\"NO\\". >>> is_reachable_and_count_moves( ... 4, 4, ... [ ... [1, 2, 3, 4], ... [2, 3, 4, 5], ... [3, 4, 5, 6], ... [4, 5, 6, 7], ... ], ... (1, 1), ... (4, 4) ... ) ('YES', 6) >>> is_reachable_and_count_moves( ... 3, 3, ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ], ... (2, 2), ... (2, 2) ... ) ('YES', 0) >>> is_reachable_and_count_moves( ... 3, 3, ... [ ... [1, 3, 1], ... [4, 3, 6], ... [7, 8, 3], ... ], ... (1, 1), ... (3, 3) ... ) ('NO',) >>> is_reachable_and_count_moves( ... 1, 1, ... [ ... [1], ... ], ... (1, 1), ... (1, 1) ... ) ('YES', 0)","solution":"from collections import deque def is_reachable_and_count_moves(n, m, grid, start, end): def neighbors(r, c): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and abs(grid[nr][nc] - grid[r][c]) == 1: yield nr, nc sx, sy = start ex, ey = end sx -= 1 sy -= 1 ex -= 1 ey -= 1 if sx == ex and sy == ey: return \\"YES\\", 0 queue = deque([(sx, sy, 0)]) visited = set([(sx, sy)]) while queue: x, y, dist = queue.popleft() for nx, ny in neighbors(x, y): if (nx, ny) not in visited: if nx == ex and ny == ey: return \\"YES\\", dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return \\"NO\\", # Example usage: n = 4 m = 4 grid = [ [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7] ] start = (1, 1) end = (4, 4) print(is_reachable_and_count_moves(n, m, grid, start, end))"},{"question":"def can_player1_win(n: int, p: int) -> str: Determines if Player 1 (represented by 1) can guarantee a win given the board size \`n\` and the initial player \`p\`. >>> can_player1_win(3, 1) \\"Win\\" >>> can_player1_win(2, 0) \\"Lose\\"","solution":"def can_player1_win(n, p): Determines if Player 1 can guarantee a win given the board size \`n\` and the initial player \`p\`. if n % 2 == 1: return \\"Win\\" else: return \\"Lose\\""},{"question":"class FileSystem: A simple file system to manage mkdir and ls operations. def mkdir(self, path: str): pass def ls(self, path: str): pass def handle_operations(operations): Handle a list of file system operations and return results for 'ls' operations. >>> operations = [\\"mkdir /a\\", \\"mkdir /a/b\\", \\"mkdir /a/c\\", \\"ls /\\", \\"mkdir /a/d\\", \\"ls /a\\"] handle_operations(operations) ['a', 'b', 'c', 'd'] >>> operations = [\\"mkdir /a\\", \\"ls /a/b\\"] handle_operations(operations) ['NO SUCH DIRECTORY'] >>> operations = [\\"mkdir /a\\", \\"mkdir /a/b\\", \\"mkdir /a/b/c\\", \\"mkdir /a/b/d\\", \\"ls /a/b\\"] handle_operations(operations) ['c', 'd'] >>> operations = [\\"ls /\\"] handle_operations(operations) [] pass","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str): parts = path.split('/') d = self.fs for part in parts: if part: if part not in d: d[part] = {} d = d[part] def ls(self, path: str): parts = path.split('/') d = self.fs for part in parts: if part: if part in d: d = d[part] else: return \\"NO SUCH DIRECTORY\\" return sorted(d.keys()) def handle_operations(operations): fs = FileSystem() results = [] for operation in operations: if operation.startswith('mkdir'): _, path = operation.split(' ') fs.mkdir(path) elif operation.startswith('ls'): _, path = operation.split(' ') result = fs.ls(path) if result == \\"NO SUCH DIRECTORY\\": results.append(result) else: results.extend(result) return results"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the string a palindrome. >>> min_replacements_to_palindrome(\\"abba\\") 0 >>> min_replacements_to_palindrome(\\"race\\") 2","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements required to make the string a palindrome. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"import heapq from typing import List, Tuple def network_latency(n: int, m: int, cables: List[Tuple[int, int, int]]) -> int: Determine the minimum latency required to send data from computer 1 to computer n in a network. Args: n (int): The number of computers. m (int): The number of cables. cables (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers, representing a cable that connects computer u and computer v with latency l. Returns: int: The minimum latency required to send data from computer 1 to computer n, or -1 if it is impossible. Examples: >>> network_latency(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 5)]) 4 >>> network_latency(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 1)]) 4 >>> network_latency(4, 2, [(1, 2, 5), (3, 4, 5)]) -1 >>> network_latency(3, 3, [(1, 2, 4), (1, 3, 2), (2, 3, 1)]) 2 >>> network_latency(5, 4, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2)]) 8","solution":"import heapq def network_latency(n, m, cables): graph = {i: [] for i in range(1, n + 1)} for u, v, l in cables: graph[u].append((v, l)) graph[v].append((u, l)) # Dijkstra's algorithm to find the minimum latency from node 1 to node n pq = [(0, 1)] # (latency, node) latencies = {i: float('inf') for i in range(1, n + 1)} latencies[1] = 0 while pq: curr_latency, node = heapq.heappop(pq) if node == n: return curr_latency if curr_latency > latencies[node]: continue for neighbor, weight in graph[node]: new_latency = curr_latency + weight if new_latency < latencies[neighbor]: latencies[neighbor] = new_latency heapq.heappush(pq, (new_latency, neighbor)) return -1 if latencies[n] == float('inf') else latencies[n] # Example usage (converts input into format required by function): def solve_network_latency_problem(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) cables = [] for line in lines[1:]: u, v, l = map(int, line.split()) cables.append((u, v, l)) return network_latency(n, m, cables)"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in a given string. >>> count_palindromic_substrings(\\"a\\") == 1 >>> count_palindromic_substrings(\\"ab\\") == 2 >>> count_palindromic_substrings(\\"aa\\") == 3 >>> count_palindromic_substrings(\\"aba\\") == 4 >>> count_palindromic_substrings(\\"ababa\\") == 9 >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"aaa\\") == 6 >>> count_palindromic_substrings(\\"abcdedcba\\") == 13 >>> count_palindromic_substrings(\\"abcba\\") == 7","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in a given string. n = len(s) if n == 0: return 0 count = 0 # Helper function to count palindromes around a center def count_palindrome_centered(s, left, right): count = 0 while left >= 0 and right < len(s) and s[left] == s[right]: count += 1 left -= 1 right += 1 return count # Consider every character and the gap between every pair of characters as center for i in range(n): count += count_palindrome_centered(s, i, i) # Odd-length palindromes count += count_palindrome_centered(s, i, i + 1) # Even-length palindromes return count"},{"question":"from typing import List, Tuple def min_operations_to_equalize(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to equalize the indexes of all regions to the maximum index in the array. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n (number of regions) and a list of integers representing the political stability indexes of the regions. Returns: List[int]: A list of integers where each integer is the minimum number of operations required for the corresponding test case. Examples: >>> min_operations_to_equalize(2, [(5, [1, 2, 3, 4, 5]), (4, [10, 10, 10, 10])]) [10, 0] >>> min_operations_to_equalize(1, [(3, [4, 4, 4])]) [0]","solution":"def min_operations_to_equalize(t, test_cases): results = [] for case in test_cases: n = case[0] indexes = case[1] max_index = max(indexes) operations = sum(max_index - x for x in indexes) results.append(operations) return results"},{"question":"import bisect from typing import List def longest_increasing_subsequence_length(n: int, permutation: List[int]) -> int: Find the length of the longest increasing subsequence in a given permutation of integers from 1 to n. Parameters: n (int): The length of the permutation. permutation (list of int): A list of distinct integers from 1 to n representing the permutation. Returns: int: The length of the longest increasing subsequence. Examples: >>> longest_increasing_subsequence_length(5, [3, 1, 2, 5, 4]) 3 >>> longest_increasing_subsequence_length(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subsequence_length(6, [6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length(7, [1, 3, 5, 2, 4, 6, 7]) 5 >>> longest_increasing_subsequence_length(1, [1]) 1 >>> longest_increasing_subsequence_length(2, [1, 2]) 2 >>> longest_increasing_subsequence_length(2, [2, 1]) 1 >>> longest_increasing_subsequence_length(200000, list(range(1, 200001))) 200000 pass","solution":"import bisect def longest_increasing_subsequence_length(n, permutation): This function finds the length of the longest increasing subsequence in a given permutation of integers. Parameters: n (int): The length of the permutation. permutation (list of int): A list of distinct integers from 1 to n representing the permutation. Returns: int: The length of the longest increasing subsequence. # List to store the current longest increasing subsequence lis = [] for num in permutation: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def max_non_overlapping_activities(activities: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping activities. :param activities: List of tuples representing the start and end times of activities. :return: Maximum number of non-overlapping activities. >>> max_non_overlapping_activities([(1, 4), (2, 3), (3, 5), (6, 8), (7, 9)]) 3 >>> max_non_overlapping_activities([(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) 5 >>> max_non_overlapping_activities([(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]) 1 >>> max_non_overlapping_activities([(1, 3), (2, 5), (3, 4), (5, 7), (5, 9)]) 3 >>> max_non_overlapping_activities([(1, 10)]) 1 >>> max_non_overlapping_activities([(i, i+1) for i in range(0, 10**5, 2)]) 50000","solution":"def max_non_overlapping_activities(activities): Returns the maximum number of non-overlapping activities. :param activities: List of tuples representing the start and end times of activities. :return: Maximum number of non-overlapping activities. activities.sort(key=lambda x: x[1]) # Sort by ending time count = 0 last_end_time = 0 for start, end in activities: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"import math from typing import List, Tuple def compute_gcd_subarray(n: int, m: int, A: List[int], operations: List[Tuple[int, int]]) -> List[int]: This function handles multiple GCD subarray queries. :param n: Integer, number of elements in the array :param m: Integer, number of operations/queries :param A: List of integers, the array of elements :param operations: List of tuples, each containing (l, r) indices :return: List of integers, the GCD results for each operation >>> compute_gcd_subarray(6, 3, [2, 4, 6, 8, 10, 12], [(1, 4), (2, 5), (3, 6)]) [2, 2, 2] >>> compute_gcd_subarray(1, 1, [5], [(1, 1)]) [5]","solution":"import math def compute_gcd_subarray(n, m, A, operations): This function handles multiple GCD subarray queries. :param n: Integer, number of elements in the array :param m: Integer, number of operations/queries :param A: List of integers, the array of elements :param operations: List of tuples, each containing (l, r) indices :return: List of integers, the GCD results for each operation results = [] for (l, r) in operations: gcd_result = A[l-1] for i in range(l, r): gcd_result = math.gcd(gcd_result, A[i]) results.append(gcd_result) return results"},{"question":"def has_path_sum(n: int, k: int, node_values: List[int], edges: List[Tuple[int, int]]) -> str: Determine if there exists a sequence of one or more nodes in a tree that forms a path with a sum of values equal to k. >>> has_path_sum(5, 6, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 'Yes' >>> has_path_sum(5, 15, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 'No'","solution":"def has_path_sum(n, k, node_values, edges): from collections import defaultdict # Building the tree as adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, current_sum): nonlocal found visited.add(node) current_sum += node_values[node - 1] if current_sum == k: found = True for neighbor in tree[node]: if neighbor not in visited: dfs(neighbor, current_sum) visited.remove(node) visited = set() found = False for i in range(1, n + 1): # Considering paths starting from each node dfs(i, 0) if found: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List, Tuple def find_tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determine the diameter of a tree. Args: n: An integer denoting the number of vertices in the tree. edges: A list of tuples denoting the edges between vertices. Returns: An integer representing the diameter of the tree. Examples: >>> find_tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> find_tree_diameter(4, [(1, 2), (2, 3), (3, 4)]) 3 >>> find_tree_diameter(1, []) 0 >>> find_tree_diameter(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) 2","solution":"import sys from collections import deque def find_tree_diameter(n, edges): if n == 1: return 0 def bfs(start_node): visited = [-1] * (n + 1) visited[start_node] = 0 queue = deque([start_node]) max_distance = 0 furthest_node = start_node while queue: node = queue.popleft() current_distance = visited[node] for neighbor in adj_list[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] furthest_node = neighbor return furthest_node, max_distance adj_list = [[] for _ in range(n + 1)] for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) furthest_node_from_root, _ = bfs(1) _, diameter = bfs(furthest_node_from_root) return diameter"},{"question":"def initial_distance(v1: int, v2: int, T: int) -> int: Calculate the initial distance between two trucks T1 and T2 moving towards each other with constant velocities v1 and v2 respectively and meeting after time T. Parameters: v1 (int): Velocity of truck T1. v2 (int): Velocity of truck T2. T (int): Time taken for the trucks to meet. Returns: int: Initial distance between the trucks, denoted as D. >>> initial_distance(4, 3, 5) 35 >>> initial_distance(5, 5, 5) 50 >>> initial_distance(1, 1, 1) 2 >>> initial_distance(1000, 1000, 1000) 2000000 >>> initial_distance(10, 5, 10) 150 >>> initial_distance(6, 4, 7) 70","solution":"def initial_distance(v1, v2, T): Calculate the initial distance between two trucks moving towards each other. Parameters: v1 (int): Velocity of truck T1. v2 (int): Velocity of truck T2. T (int): Time taken for the trucks to meet. Returns: int: Initial distance between the trucks. return (v1 * T) + (v2 * T)"}]`),N={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},Y={class:"card-container"},D={key:0,class:"empty-state"},O=["disabled"],C={key:0},z={key:1};function P(i,e,u,d,r,a){const f=h("PoemCard");return n(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(n(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):m("",!0)]),t("div",Y,[(n(!0),s(x,null,y(a.displayedPoems,(o,p)=>(n(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),s("div",D,' No results found for "'+l(r.searchQuery)+'". ',1)):m("",!0)]),a.hasMorePoems?(n(),s("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(n(),s("span",z,"Loading...")):(n(),s("span",C,"See more"))],8,O)):m("",!0)])}const I=c(N,[["render",P],["__scopeId","data-v-276608a5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/9.md","filePath":"guide/9.md"}'),F={name:"guide/9.md"},G=Object.assign(F,{setup(i){return(e,u)=>(n(),s("div",null,[w(I)]))}});export{M as __pageData,G as default};
