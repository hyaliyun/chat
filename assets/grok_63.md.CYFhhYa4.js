import{_,o as s,c as r,a as t,m as c,t as d,C as p,M as g,U as b,f as u,F as y,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},R={class:"review-content"};function A(n,e,l,m,i,a){return s(),r("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",R,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const N=_(q,[["render",A],["__scopeId","data-v-2166acfe"]]),F=JSON.parse(`[{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. If n is less than 0, returns None. >>> fibonacci(-1) is None >>> fibonacci(-10) is None >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(30) == 832040 >>> fibonacci(50) == 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number. If n is less than 0, returns None. if n < 0: return None if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def watering_schedule(days): Returns the earliest day on which all plants will be in full bloom. Parameters: days (List[int]): Each element represents the number of days required by a plant to bloom. Returns: int: The earliest day on which all plants will bloom. Examples: >>> watering_schedule([3, 1, 2, 4]) == 4 >>> watering_schedule([5, 9, 2, 8]) == 9 >>> watering_schedule([7, 3, 5, 1]) == 7","solution":"def watering_schedule(days): Returns the earliest day on which all plants will be in full bloom. Parameters: days (List[int]): Each element represents the number of days required by a plant to bloom. Returns: int: The earliest day on which all plants will bloom. if not days: return 0 return max(days)"},{"question":"def is_prime(n: int) -> bool: Write a function is_prime that checks if a given positive integer n is a prime number or not. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(11) == True >>> is_prime(29) == True >>> is_prime(1) == False >>> is_prime(4) == False >>> is_prime(10) == False >>> is_prime(15) == False >>> is_prime(100) == False >>> is_prime(-1) == False >>> is_prime(0) == False # Implement the function here","solution":"def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True"},{"question":"def compare_version(version1: str, version2: str) -> int: Compare two version numbers given as strings and determine which one is greater. >>> compare_version(\\"1.0\\", \\"1\\") 0 >>> compare_version(\\"0.1\\", \\"1.1\\") -1 >>> compare_version(\\"1.0.1\\", \\"1\\") 1 >>> compare_version(\\"7.5.2.4\\", \\"7.5.3\\") -1","solution":"def compare_version(version1: str, version2: str) -> int: # Split the versions by '.' v1_parts = list(map(int, version1.split('.'))) v2_parts = list(map(int, version2.split('.'))) # Determine the maximum length for comparison max_length = max(len(v1_parts), len(v2_parts)) # Compare each part for i in range(max_length): part1 = v1_parts[i] if i < len(v1_parts) else 0 part2 = v2_parts[i] if i < len(v2_parts) else 0 if part1 > part2: return 1 elif part1 < part2: return -1 # If all parts are equal return 0"},{"question":"import numpy as np def concatenate_lists(list1: str, list2: str) -> np.ndarray: Concatenates two space separated lists of integers into a single NumPy array. Parameters: list1 (str): A space separated string of integers. list2 (str): A space separated string of integers. Returns: np.ndarray: Concatenated NumPy array. Examples: >>> concatenate_lists(\\"1 2 3\\", \\"4 5 6\\") array([1, 2, 3, 4, 5, 6]) >>> concatenate_lists(\\"-1 -2 -3\\", \\"4 5 6\\") array([-1, -2, -3, 4, 5, 6])","solution":"import numpy as np def concatenate_lists(list1, list2): Concatenates two space separated lists of integers into a single NumPy array. Parameters: list1 (str): A space separated string of integers. list2 (str): A space separated string of integers. Returns: np.ndarray: Concatenated NumPy array. array1 = np.array(list(map(int, list1.split())), dtype=int) array2 = np.array(list(map(int, list2.split())), dtype=int) return np.concatenate((array1, array2))"},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. >>> longest_common_substring(\\"abcdef\\", \\"zabcf\\") == 3 >>> longest_common_substring(\\"12345\\", \\"54321\\") == 1 >>> longest_common_substring(\\"foo\\", \\"bar\\") == 0 >>> longest_common_substring(\\"\\", \\"foo\\") == 0 >>> longest_common_substring(\\"foo\\", \\"\\") == 0 >>> longest_common_substring(\\"abc\\", \\"abc\\") == 3 >>> longest_common_substring(\\"abcd\\", \\"efgh\\") == 0 >>> longest_common_substring(\\"abcdef\\", \\"cdefgh\\") == 4 >>> longest_common_substring(\\"ababc\\", \\"abcdabc\\") == 3","solution":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Initialize the DP table with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] longest = 0 # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) return longest"},{"question":"from typing import List def decode_coordinates(grid: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> List[List[int]]: Decode the given coordinates to determine the actual position in the grid after applying the specified transformations: rotate 90 degrees clockwise and mirror horizontally. Args: grid (List[List[int]]): The 5x5 grid represented as a list of lists. x1 (int): The x-coordinate of the top-left corner of the section of the grid. y1 (int): The y-coordinate of the top-left corner of the section of the grid. x2 (int): The x-coordinate of the bottom-right corner of the section of the grid. y2 (int): The y-coordinate of the bottom-right corner of the section of the grid. Returns: List[List[int]]: The transformed sub-grid after applying the specified transformations. Examples: >>> grid = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> decode_coordinates(grid, 1, 1, 3, 3) [[19, 14, 9], [18, 13, 8], [17, 12, 7]] >>> decode_coordinates(grid, 0, 0, 4, 4) [[25, 20, 15, 10, 5], [24, 19, 14, 9, 4], [23, 18, 13, 8, 3], [22, 17, 12, 7, 2], [21, 16, 11, 6, 1]]","solution":"from typing import List def decode_coordinates(grid: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> List[List[int]]: # Extract the sub-grid subgrid = [row[y1:y2+1] for row in grid[x1:x2+1]] # Rotate the sub-grid 90 degrees clockwise rotated = list(zip(*subgrid[::-1])) # Mirror the sub-grid horizontally mirrored = [list(row) for row in rotated[::-1]] return mirrored"},{"question":"def categorizeParticipants(participants): Categorize participants into 'fast', 'average', and 'slow' based on their finishing time. Parameters: participants (list): A list of dictionaries where each dictionary has keys \\"name\\" and \\"time\\". Returns: dict: A dictionary with keys \\"fast\\", \\"average\\", and \\"slow\\", each containing a list of names. pass # Test cases def test_categorizeParticipants_all_fast(): participants = [ {\\"name\\": \\"Alice\\", \\"time\\": 4}, {\\"name\\": \\"David\\", \\"time\\": 3}, {\\"name\\": \\"John\\", \\"time\\": 5} ] result = categorizeParticipants(participants) assert result == { \\"fast\\": [\\"Alice\\", \\"David\\", \\"John\\"], \\"average\\": [], \\"slow\\": [] } def test_categorizeParticipants_all_average(): participants = [ {\\"name\\": \\"Alice\\", \\"time\\": 7}, {\\"name\\": \\"David\\", \\"time\\": 6}, {\\"name\\": \\"John\\", \\"time\\": 10} ] result = categorizeParticipants(participants) assert result == { \\"fast\\": [], \\"average\\": [\\"Alice\\", \\"David\\", \\"John\\"], \\"slow\\": [] } def test_categorizeParticipants_all_slow(): participants = [ {\\"name\\": \\"Alice\\", \\"time\\": 11}, {\\"name\\": \\"David\\", \\"time\\": 15}, {\\"name\\": \\"John\\", \\"time\\": 12} ] result = categorizeParticipants(participants) assert result == { \\"fast\\": [], \\"average\\": [], \\"slow\\": [\\"Alice\\", \\"David\\", \\"John\\"] } def test_categorizeParticipants_mixed_categories(): participants = [ {\\"name\\": \\"Alice\\", \\"time\\": 4}, {\\"name\\": \\"Bob\\", \\"time\\": 7}, {\\"name\\": \\"Charlie\\", \\"time\\": 10}, {\\"name\\": \\"David\\", \\"time\\": 3}, {\\"name\\": \\"Eve\\", \\"time\\": 11} ] result = categorizeParticipants(participants) assert result == { \\"fast\\": [\\"Alice\\", \\"David\\"], \\"average\\": [\\"Bob\\", \\"Charlie\\"], \\"slow\\": [\\"Eve\\"] } def test_categorizeParticipants_empty_list(): participants = [] result = categorizeParticipants(participants) assert result == { \\"fast\\": [], \\"average\\": [], \\"slow\\": [] }","solution":"def categorizeParticipants(participants): Categorize participants into 'fast', 'average', and 'slow' based on their finishing time. Parameters: participants (list): A list of dictionaries where each dictionary has keys \\"name\\" and \\"time\\". Returns: dict: A dictionary with keys \\"fast\\", \\"average\\", and \\"slow\\", each containing a list of names. categories = { \\"fast\\": [], \\"average\\": [], \\"slow\\": [] } for participant in participants: name = participant[\\"name\\"] time = participant[\\"time\\"] if time <= 5: categories[\\"fast\\"].append(name) elif time <= 10: categories[\\"average\\"].append(name) else: categories[\\"slow\\"].append(name) # Sort the names alphabetically in each category for key in categories: categories[key].sort() return categories"},{"question":"def reverse_words(s: str) -> str: Takes a string s consisting of words separated by single spaces and returns a new string with the words in reversed order. >>> reverse_words(\\"the sky is blue\\") \\"blue is sky the\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"python\\") \\"python\\" >>> reverse_words(\\"good morning\\") \\"morning good\\" >>> reverse_words(\\"well, done!\\") \\"done! well,\\" >>> reverse_words(\\"123 456 789\\") \\"789 456 123\\"","solution":"def reverse_words(s): Takes a string s consisting of words separated by single spaces and returns a new string with the words in reversed order. words = s.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"def format_solution(n, m, preferences): Determine the maximum number of happy pairs and provide an arrangement. A \\"happy pair\\" is defined as two adjacent kids who have the same preference for a toy. The function should return the maximum number of happy pairs and any example arrangement. >>> format_solution(6, 3, [1, 1, 3, 2, 2, 3]) (3, [1, 1, 3, 3, 2, 2, 1]) >>> format_solution(5, 2, [2, 2, 1, 1, 1]) (2, [2, 2, 1, 1, 1, 2]) >>> format_solution(4, 2, [1, 2, 1, 2]) (2, [1, 1, 2, 2, 1]) if __name__ == \\"__main__\\": from solution import format_solution def test_example1(): n = 6 m = 3 preferences = [1, 1, 3, 2, 2, 3] expected_pairs = 3 result_pairs, result_arrangement = format_solution(n, m, preferences) assert result_pairs == expected_pairs assert len(result_arrangement) == n + 1 assert result_arrangement[0] == result_arrangement[-1] def test_example2(): n = 5 m = 2 preferences = [2, 2, 1, 1, 1] expected_pairs = 2 result_pairs, result_arrangement = format_solution(n, m, preferences) assert result_pairs == expected_pairs assert len(result_arrangement) == n + 1 assert result_arrangement[0] == result_arrangement[-1] def test_example3(): n = 4 m = 2 preferences = [1, 2, 1, 2] expected_pairs = 2 result_pairs, result_arrangement = format_solution(n, m, preferences) assert result_pairs == expected_pairs assert len(result_arrangement) == n + 1 assert result_arrangement[0] == result_arrangement[-1] test_example1() test_example2() test_example3()","solution":"def max_happy_pairs(n, m, preferences): from collections import Counter counts = Counter(preferences) pairs = 0 remaining = [] for toy in counts: pairs += counts[toy] // 2 if counts[toy] % 2: remaining.append(toy) arrangement = [] for toy, count in counts.items(): arrangement.extend([toy] * (count // 2 * 2)) # Add pairs # If we have remaining toys left that couldn't form pairs if remaining: remaining.sort() for toy in remaining: arrangement.append(toy) return pairs, arrangement def format_solution(n, m, preferences): pairs, arrangement = max_happy_pairs(n, m, preferences) # arranging them as circle return pairs, arrangement + [arrangement[0]] n = 6 m = 3 preferences = [1, 1, 3, 2, 2, 3] result = format_solution(n, m, preferences) print(result)"},{"question":"def is_valid_parentheses_sequence(S: str) -> bool: Given a string S containing only the characters '(' and ')', determines whether the sequence is a valid parentheses sequence. >>> is_valid_parentheses_sequence(\\"()\\") True >>> is_valid_parentheses_sequence(\\"(()())\\") True >>> is_valid_parentheses_sequence(\\"(())(()\\") False >>> is_valid_parentheses_sequence(\\"\\") True >>> is_valid_parentheses_sequence(\\")(\\") False >>> is_valid_parentheses_sequence(\\"((())())()\\") True >>> is_valid_parentheses_sequence(\\"((())(())())(\\") False def check_parentheses_sequences(test_cases: list) -> list: Given a list of test cases containing strings of parentheses, determines whether each sequence is a valid parentheses sequence. >>> check_parentheses_sequences([\\"()\\", \\"(()())\\", \\"(())(()\\", \\")\\", \\"((\\", \\"(())\\", \\"()()()()\\", \\"(()))\\", \\"(((((())))))\\"]) [True, True, False, False, False, True, True, False, True]","solution":"def is_valid_parentheses_sequence(S): Given a string S containing only the characters '(' and ')', determines whether the sequence is a valid parentheses sequence. Parameters: S (str): The string of parentheses to be checked. Returns: bool: Returns True if the sequence is valid, otherwise False. stack = [] for char in S: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0 def check_parentheses_sequences(test_cases): Given a list of test cases containing strings of parentheses, determines whether each sequence is a valid parentheses sequence. Parameters: test_cases (list): A list of strings, each string is a test case. Returns: list: A list of boolean values, each corresponds to whether the sequence in the test case is valid. results = [] for case in test_cases: results.append(is_valid_parentheses_sequence(case)) return results"},{"question":"def alphabetize_then_digits(s: str) -> str: Sort the string such that all letters come before any digits, while maintaining the relative order of letters and digits from the original string. :param s: string containing letters and digits :return: sorted string with letters first followed by digits Examples: >>> alphabetize_then_digits(\\"a1b2c3\\") 'abc123' >>> alphabetize_then_digits(\\"3a2b1c\\") 'abc321' >>> alphabetize_then_digits(\\"abc123\\") 'abc123' >>> alphabetize_then_digits(\\"4g3h2i1\\") 'ghi4321' >>> alphabetize_then_digits(\\"z2y1x0\\") 'zyx210'","solution":"def alphabetize_then_digits(s: str) -> str: Sort the string such that all letters come before any digits, while maintaining the relative order of letters and digits from the original string. :param s: string containing letters and digits :return: sorted string with letters first followed by digits letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return ''.join(letters + digits)"},{"question":"def maximum_possible_remaining_element(arr): Returns the maximum possible value of the remaining element after performing the described operations on the array. pass # Unit tests def test_example_1(): assert maximum_possible_remaining_element([1, 2, 3]) == 6 def test_example_2(): assert maximum_possible_remaining_element([1, 1, 1, 1, 1]) == 5 def test_single_element(): assert maximum_possible_remaining_element([7]) == 7 def test_two_elements(): assert maximum_possible_remaining_element([2, 3]) == 5 def test_large_numbers(): assert maximum_possible_remaining_element([1000, 2000, 3000, 4000]) == 10000 def test_mixed_numbers(): assert maximum_possible_remaining_element([1, 2, 3, 4, 5]) == 15 def test_identical_elements(): assert maximum_possible_remaining_element([10, 10, 10]) == 30","solution":"def maximum_possible_remaining_element(arr): Returns the maximum possible value of the remaining element after performing the described operations on the array. return sum(arr)"},{"question":"def reverse_alternate_words(s: str) -> str: Reverses every alternate word in the string s starting from the second one. Parameters: s (str): A string with words separated by spaces. Returns: str: A string with every alternate word reversed. >>> reverse_alternate_words(\\"Hello world this is a test\\") \\"Hello dlrow this si a tset\\" >>> reverse_alternate_words(\\"a b c d e\\") \\"a b c d e\\" >>> reverse_alternate_words(\\"Hello\\") \\"Hello\\" >>> reverse_alternate_words(\\" Hello world \\") \\"Hello dlrow\\" >>> reverse_alternate_words(\\"a b c d\\") \\"a b c d\\"","solution":"def reverse_alternate_words(s): Reverses every alternate word in the string s starting from the second one. Parameters: s (str): A string with words separated by spaces. Returns: str: A string with every alternate word reversed. words = s.split() for i in range(1, len(words), 2): words[i] = words[i][::-1] return ' '.join(words)"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. pass def filter_primes(nums: List[int]) -> List[int]: Return a list of prime numbers from the given list of integers. >>> filter_primes([2,3,4,5,6,7,8,9,10]) [2,3,5,7] >>> filter_primes([15,21,22,23,25,29]) [23,29] >>> filter_primes([1,4,6,8,10]) [] >>> filter_primes([1,2,3,17,20,21,31,44]) [2,3,17,31] >>> filter_primes([11]) [11] >>> filter_primes([10]) [] >>> filter_primes([]) [] >>> filter_primes([2,3,5,7,11,13,17]) [2,3,5,7,11,13,17] pass","solution":"def is_prime(n): \\"Check if a number is a prime number.\\" if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(nums): \\"Return a list of prime numbers from the given list of integers.\\" return [num for num in nums if is_prime(num)]"},{"question":"def smallest_lexicographical_order(n: int, books: List[str]) -> List[str]: Returns the smallest lexicographical order possible by making at most one swap. Parameters: n (int): The number of books. books (list of str): A list of n 13-digit ISBNs. Returns: list of str: The best sorted order. >>> smallest_lexicographical_order(3, ['9780306406157', '9780140449136', '9780199208316']) ['9780140449136', '9780306406157', '9780199208316'] >>> smallest_lexicographical_order(4, ['9780807281918', '9780807281919', '9780807281920', '9780807281921']) ['9780807281918', '9780807281919', '9780807281920', '9780807281921'] >>> smallest_lexicographical_order(1, ['9780306406157']) ['9780306406157'] >>> smallest_lexicographical_order(2, ['9780306406157', '9780140449136']) ['9780140449136', '9780306406157'] >>> smallest_lexicographical_order(3, ['9780140449136', '9780199208316', '9780306406157']) ['9780140449136', '9780199208316', '9780306406157']","solution":"def smallest_lexicographical_order(n, books): Returns the smallest lexicographical order possible by making at most one swap. Parameters: n (int): The number of books. books (list of str): A list of n 13-digit ISBNs. Returns: list of str: The best sorted order. # Find the lexicographical ordered list sorted_books = sorted(books) # If the list is already sorted, no swap needed. if sorted_books == books: return books # Find the first differing point for i in range(n): # Compare the actual list with the sorted list if books[i] != sorted_books[i]: break minimum_list = books[:] # try to swap the i-th element with all further elements to get smallest order for j in range(i + 1, n): new_books = books[:i] + [books[j]] + books[i + 1:j] + [books[i]] + books[j + 1:] if new_books < minimum_list: minimum_list = new_books return minimum_list"},{"question":"from typing import List def min_length_after_removals(strings: List[str]) -> List[int]: Returns the minimum possible length of the string after removing all consecutive occurrences of any character. >>> min_length_after_removals([\\"aabbcc\\", \\"abc\\", \\"aaaaa\\"]) [0, 3, 0] >>> min_length_after_removals([\\"abcdef\\", \\"aaabcdef\\", \\"abcabc\\"]) [6, 0, 6] pass def process_input(num_cases: int, list_of_strings: List[str]) -> List[int]: Processes input by applying min_length_after_removals function to each string. >>> process_input(3, [\\"aabbcc\\", \\"abc\\", \\"aaaaa\\"]) [0, 3, 0] >>> process_input(2, [\\"abcdef\\", \\"gggg\\"]) [6, 0] pass def test_min_length_after_removals(): assert min_length_after_removals([\\"aabbcc\\", \\"abc\\", \\"aaaaa\\"]) == [0, 3, 0] assert min_length_after_removals([\\"abcdef\\", \\"aaabcdef\\", \\"abcabc\\"]) == [6, 0, 6] assert min_length_after_removals([\\"xxyz\\", \\"xyzzz\\", \\"xy\\"]) == [0, 0, 2] assert min_length_after_removals([\\"a\\", \\"bb\\", \\"ccdd\\"]) == [1, 0, 0] assert min_length_after_removals([\\"mnopq\\", \\"mnooq\\", \\"mmnop\\"]) == [5, 0, 0] def test_process_input(): assert process_input(3, [\\"aabbcc\\", \\"abc\\", \\"aaaaa\\"]) == [0, 3, 0] assert process_input(2, [\\"abcdef\\", \\"gggg\\"]) == [6, 0] if __name__ == \\"__main__\\": test_min_length_after_removals() test_process_input() print(\\"All tests passed.\\")","solution":"def min_length_after_removals(strings): Returns the minimum possible length of the string after removing all consecutive occurrences of any character. results = [] for s in strings: if any(s[i] == s[i+1] for i in range(len(s)-1)): results.append(0) else: results.append(len(s)) return results def process_input(num_cases, list_of_strings): return min_length_after_removals(list_of_strings)"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given an array of integers where each element represents the height of a building, the width of each building being 1, find the maximum rectangular area that can be formed in the histogram. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([3, 3, 3, 3]) 12 >>> largest_rectangle_area([4, 3, 2, 1]) 6 >>> largest_rectangle_area([1, 2, 3, 4]) 6 >>> largest_rectangle_area([2, 4, 2, 1]) 6 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Finds the maximum rectangular area in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def calculate_delivery_times(data): Given the input data, calculates and returns the total delivery time for each driver. :param data: List of strings, each string contains driver name followed by the number of deliveries and delivery times. :return: List of strings with each driver and their total delivery time in the format '<Driver Name>: <Total Time> minutes' def test_calculate_delivery_times(): data = [ \\"Alice 3 30 40 50\\", \\"Bob 2 20 60\\", \\"Charlie 4 25 35 45 55\\" ] expected_output = [ \\"Alice: 120 minutes\\", \\"Bob: 80 minutes\\", \\"Charlie: 160 minutes\\" ] assert calculate_delivery_times(data) == expected_output def test_single_driver_single_delivery(): data = [ \\"David 1 100\\" ] expected_output = [ \\"David: 100 minutes\\" ] assert calculate_delivery_times(data) == expected_output def test_single_driver_multiple_deliveries(): data = [ \\"Eva 3 15 25 35\\" ] expected_output = [ \\"Eva: 75 minutes\\" ] assert calculate_delivery_times(data) == expected_output def test_multiple_drivers_with_one_delivery_each(): data = [ \\"Fred 1 50\\", \\"George 1 70\\", \\"Helen 1 90\\" ] expected_output = [ \\"Fred: 50 minutes\\", \\"George: 70 minutes\\", \\"Helen: 90 minutes\\" ] assert calculate_delivery_times(data) == expected_output def test_edge_case_large_numbers(): data = [ \\"Ian 50 \\" + \\" \\".join(str(i) for i in range(1, 51)) ] expected_output = [ \\"Ian: 1275 minutes\\" ] assert calculate_delivery_times(data) == expected_output","solution":"def calculate_delivery_times(data): Given the input data, calculates and returns the total delivery time for each driver. :param data: List of strings, each string contains driver name followed by the number of deliveries and delivery times. :return: List of strings with each driver and their total delivery time in the format '<Driver Name>: <Total Time> minutes' result = [] for entry in data: parts = entry.split() driver_name = parts[0] num_deliveries = int(parts[1]) delivery_times = list(map(int, parts[2:2 + num_deliveries])) total_time = sum(delivery_times) result.append(f\\"{driver_name}: {total_time} minutes\\") return result"},{"question":"def maximize_lexicographical_order(s: str, n: int) -> str: Removes n characters from the string s to maximize its lexicographical order. Parameters: s (str): the input string consisting of lowercase English letters. n (int): the number of characters to remove. Returns: str: the string after n operations, maximizing lexicographical order. Examples: >>> maximize_lexicographical_order(\\"abcde\\", 2) \\"cde\\" >>> maximize_lexicographical_order(\\"aabbcc\\", 3) \\"bcc\\"","solution":"def maximize_lexicographical_order(s, n): Removes n characters from the string s to maximize its lexicographical order. Parameters: s (str): the input string consisting of lowercase English letters. n (int): the number of characters to remove. Returns: str: the string after n operations, maximizing lexicographical order. stack = [] remove_count = n for char in s: while stack and remove_count > 0 and stack[-1] < char: stack.pop() remove_count -= 1 stack.append(char) # If we still need to remove more characters, remove them from the end result = stack[:-remove_count] if remove_count else stack return ''.join(result)"},{"question":"def minimum_fuel_needed(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum amount of fuel needed for the truck to complete its route. Arguments: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases, where each test case is a tuple containing an integer (number of segments) and a list of integers (fuel consumption for each segment) Returns: List[int] : list of integers representing the minimum fuel needed for each test case >>> minimum_fuel_needed(1, [(4, [3, 1, 4, 2])]) [10] >>> minimum_fuel_needed(2, [(4, [3, 1, 4, 2]), (5, [5, 3, 6, 2, 4])]) [10, 20] >>> minimum_fuel_needed(1, [(3, [1, 1, 1])]) [3] >>> minimum_fuel_needed(1, [(4, [1000000, 1000000, 1000000, 1000000])]) [4000000]","solution":"def minimum_fuel_needed(T, test_cases): results = [] for i in range(T): M, fuel_segments = test_cases[i] # since it's a closed loop and we need to pass through all segments, # the minimum fuel needed is simply the sum of all the fuel consumption values. total_fuel = sum(fuel_segments) results.append(total_fuel) return results"},{"question":"def sum_of_multiples(n: int) -> int: Returns the sum of all multiples of 3 or 5 below n. >>> sum_of_multiples(10) == 23 >>> sum_of_multiples(20) == 78 >>> sum_of_multiples(30) == 195 >>> sum_of_multiples(1) == 0 >>> sum_of_multiples(5) == 3","solution":"def sum_of_multiples(n): Returns the sum of all multiples of 3 or 5 below n. total = 0 for i in range(n): if i % 3 == 0 or i % 5 == 0: total += i return total"},{"question":"def digital_persistence(n: int) -> int: Returns the digital persistence of a non-negative integer n. Digital persistence is the number of times you must replace the number with the sum of its digits until it becomes a single-digit number. >>> digital_persistence(0) == 0 >>> digital_persistence(5) == 0 >>> digital_persistence(9) == 0 >>> digital_persistence(10) == 1 >>> digital_persistence(56) == 2 >>> digital_persistence(987) == 2 >>> digital_persistence(199) == 3 >>> digital_persistence(999999999999999999) == 2 >>> digital_persistence(1234567890) == 2","solution":"def digital_persistence(n): Returns the digital persistence of a non-negative integer n. Digital persistence is the number of times you must replace the number with the sum of its digits until it becomes a single-digit number. if n < 10: return 0 def sum_of_digits(num): return sum(int(digit) for digit in str(num)) persistence = 0 while n >= 10: n = sum_of_digits(n) persistence += 1 return persistence"},{"question":"def partition_count(n: int, k: int) -> int: Calculate the number of ways to partition \`n\` distinct objects into \`k\` non-empty, unordered subsets. >>> partition_count(3, 2) 3 >>> partition_count(5, 3) 25","solution":"def partition_count(n: int, k: int) -> int: Calculate the number of ways to partition \`n\` distinct objects into \`k\` non-empty, unordered subsets. This function uses Stirling numbers of the second kind. # Initialize a DP table where dp[i][j] will store the number of ways to partition i objects into j subsets dp = [[0]*(n+1) for _ in range(n+1)] # Base case: there's exactly 1 way to partition 0 objects into 0 subsets dp[0][0] = 1 # Fill the DP table for i in range(1, n+1): for j in range(1, k+1): dp[i][j] = j * dp[i-1][j] + dp[i-1][j-1] return dp[n][k]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing only non-negative integers, addition (+), and multiplication (*) operators. The function respects the precedence of operators: multiplication takes precedence over addition. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"4*5\\") 20 >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100*2+12\\") 212 >>> evaluate_expression(\\"2+3*4+5*6\\") 44 >>> evaluate_expression(\\"2*3+4*5\\") 26 >>> evaluate_expression(\\"42\\") 42","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing only non-negative integers, addition (+), and multiplication (*) operators. The function respects the precedence of operators: multiplication takes precedence over addition. # Tokenize the expression tokens = [] num = 0 for char in expression: if char.isdigit(): num = num * 10 + int(char) else: tokens.append(num) tokens.append(char) num = 0 tokens.append(num) # Append the last number # Handle multiplication first i = 0 while i < len(tokens): if tokens[i] == '*': left = tokens[i-1] right = tokens[i+1] result = left * right tokens = tokens[:i-1] + [result] + tokens[i+2:] i -= 1 # Adjust the index to account for the shortened list else: i += 1 # Handle addition result = 0 i = 0 while i < len(tokens): if isinstance(tokens[i], int): result += tokens[i] i += 1 return result"},{"question":"def sort_employees(n, employees): Given a list of strings representing employees and their ages, sort the list in ascending order by age. If two employees have the same age, sort them by their names in alphabetical order. pass def format_employee_list(sorted_employees): Formats the sorted list of employees for output. pass def test_sort_employees_case_1(): n = 4 employees = [(\\"Alice\\", 30), (\\"Bob\\", 25), (\\"Charlie\\", 25), (\\"David\\", 30)] sorted_employees = sort_employees(n, employees) formatted_output = format_employee_list(sorted_employees) assert formatted_output == [\\"Bob 25\\", \\"Charlie 25\\", \\"Alice 30\\", \\"David 30\\"] def test_sort_employees_case_2(): n = 3 employees = [(\\"Zara\\", 28), (\\"Yvonne\\", 28), (\\"Xander\\", 27)] sorted_employees = sort_employees(n, employees) formatted_output = format_employee_list(sorted_employees) assert formatted_output == [\\"Xander 27\\", \\"Yvonne 28\\", \\"Zara 28\\"] def test_sort_employees_single_entry(): n = 1 employees = [(\\"Alice\\", 30)] sorted_employees = sort_employees(n, employees) formatted_output = format_employee_list(sorted_employees) assert formatted_output == [\\"Alice 30\\"] def test_sort_employees_all_same_age(): n = 3 employees = [(\\"Charlie\\", 50), (\\"Bob\\", 50), (\\"Alice\\", 50)] sorted_employees = sort_employees(n, employees) formatted_output = format_employee_list(sorted_employees) assert formatted_output == [\\"Alice 50\\", \\"Bob 50\\", \\"Charlie 50\\"] def test_sort_employees_same_name(): n = 3 employees = [(\\"Alice\\", 30), (\\"Alice\\", 25), (\\"Alice\\", 35)] sorted_employees = sort_employees(n, employees) formatted_output = format_employee_list(sorted_employees) assert formatted_output == [\\"Alice 25\\", \\"Alice 30\\", \\"Alice 35\\"]","solution":"def sort_employees(n, employees): Given a list of strings representing employees and their ages, sort the list in ascending order by age. If two employees have the same age, sort them by their names in alphabetical order. # Sort primarily by age, secondarily by name sorted_employees = sorted(employees, key=lambda employee: (employee[1], employee[0])) return sorted_employees def format_employee_list(sorted_employees): Formats the sorted list of employees for output. return [f\\"{name} {age}\\" for name, age in sorted_employees]"},{"question":"class CircularDeque: def __init__(self, k: int): Initialize your data structure here. Set the size of the deque to be k. pass def insertFront(self, value: int) -> bool: Adds an item at the front of Deque. Return true if the operation is successful. pass def insertLast(self, value: int) -> bool: Adds an item at the rear of Deque. Return true if the operation is successful. pass def deleteFront(self) -> bool: Deletes an item from the front of Deque. Return true if the operation is successful. pass def deleteLast(self) -> bool: Deletes an item from the rear of Deque. Return true if the operation is successful. pass def getFront(self) -> int: Get the front item from the deque. pass def getRear(self) -> int: Get the last item from the deque. pass def isEmpty(self) -> bool: Checks whether the deque is empty or not. pass def isFull(self) -> bool: Checks whether the deque is full or not. pass from solution import CircularDeque def test_insertFront(): circularDeque = CircularDeque(3) assert circularDeque.insertFront(1) == True assert circularDeque.insertFront(2) == True assert circularDeque.insertFront(3) == True assert circularDeque.insertFront(4) == False assert circularDeque.getFront() == 3 def test_insertLast(): circularDeque = CircularDeque(3) assert circularDeque.insertLast(1) == True assert circularDeque.insertLast(2) == True assert circularDeque.insertLast(3) == True assert circularDeque.insertLast(4) == False assert circularDeque.getRear() == 3 def test_deleteFront(): circularDeque = CircularDeque(3) circularDeque.insertLast(1) circularDeque.insertLast(2) circularDeque.insertLast(3) assert circularDeque.deleteFront() == True assert circularDeque.deleteFront() == True assert circularDeque.deleteFront() == True assert circularDeque.deleteFront() == False def test_deleteLast(): circularDeque = CircularDeque(3) circularDeque.insertLast(1) circularDeque.insertLast(2) circularDeque.insertLast(3) assert circularDeque.deleteLast() == True assert circularDeque.deleteLast() == True assert circularDeque.deleteLast() == True assert circularDeque.deleteLast() == False def test_getFront(): circularDeque = CircularDeque(3) assert circularDeque.getFront() == -1 circularDeque.insertLast(1) assert circularDeque.getFront() == 1 circularDeque.insertLast(2) assert circularDeque.getFront() == 1 def test_getRear(): circularDeque = CircularDeque(3) assert circularDeque.getRear() == -1 circularDeque.insertLast(1) assert circularDeque.getRear() == 1 circularDeque.insertLast(2) assert circularDeque.getRear() == 2 def test_isEmpty(): circularDeque = CircularDeque(3) assert circularDeque.isEmpty() == True circularDeque.insertLast(1) assert circularDeque.isEmpty() == False def test_isFull(): circularDeque = CircularDeque(3) assert circularDeque.isFull() == False circularDeque.insertLast(1) circularDeque.insertLast(2) circularDeque.insertLast(3) assert circularDeque.isFull() == True def test_wrap_around(): circularDeque = CircularDeque(3) assert circularDeque.insertLast(1) == True assert circularDeque.insertLast(2) == True assert circularDeque.deleteFront() == True assert circularDeque.deleteFront() == True assert circularDeque.insertLast(3) == True assert circularDeque.insertLast(4) == True assert circularDeque.insertLast(5) == True assert circularDeque.getFront() == 3 assert circularDeque.getRear() == 5","solution":"class CircularDeque: def __init__(self, k: int): Initialize your data structure here. Set the size of the deque to be k. self.k = k self.deque = [None] * k self.front = 0 self.rear = 0 self.size = 0 def insertFront(self, value: int) -> bool: Adds an item at the front of Deque. Return true if the operation is successful. if self.isFull(): return False self.front = (self.front - 1 + self.k) % self.k self.deque[self.front] = value self.size += 1 return True def insertLast(self, value: int) -> bool: Adds an item at the rear of Deque. Return true if the operation is successful. if self.isFull(): return False self.deque[self.rear] = value self.rear = (self.rear + 1) % self.k self.size += 1 return True def deleteFront(self) -> bool: Deletes an item from the front of Deque. Return true if the operation is successful. if self.isEmpty(): return False self.front = (self.front + 1) % self.k self.size -= 1 return True def deleteLast(self) -> bool: Deletes an item from the rear of Deque. Return true if the operation is successful. if self.isEmpty(): return False self.rear = (self.rear - 1 + self.k) % self.k self.size -= 1 return True def getFront(self) -> int: Get the front item from the deque. if self.isEmpty(): return -1 return self.deque[self.front] def getRear(self) -> int: Get the last item from the deque. if self.isEmpty(): return -1 return self.deque[(self.rear - 1 + self.k) % self.k] def isEmpty(self) -> bool: Checks whether the deque is empty or not. return self.size == 0 def isFull(self) -> bool: Checks whether the deque is full or not. return self.size == self.k"},{"question":"from typing import List, Tuple from math import sqrt from itertools import permutations def minimum_travel_distance(houses: List[Tuple[int, int]]) -> float: Calculate the minimal total distance the postman must travel to deliver all the mail and return to the origin. >>> minimum_travel_distance([(1, 2), (3, 4), (6, 8), (2, 1)]) # Output depends on optimal calculation >>> minimum_travel_distance([]) == 0 >>> minimum_travel_distance([(0, 1), (0, 2)]) == 4 >>> minimum_travel_distance([(1, 1)]) == sqrt(2) * 2 Args: houses (List[Tuple[int, int]]): A list of house coordinates. Returns: float: The minimal total distance to visit all houses and return to origin.","solution":"from itertools import permutations from math import sqrt def euclidean_distance(point1, point2): return sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2) def total_distance(path): # Path includes return to the origin distance = 0 for i in range(len(path) - 1): distance += euclidean_distance(path[i], path[i + 1]) return distance def minimum_travel_distance(houses): if not houses: return 0 origin = (0, 0) shortest_path_distance = float('inf') # Generating all permutations of the house coordinates for perm in permutations(houses): # Create a full path that starts at the origin, visits all houses, and returns to the origin full_path = [origin] + list(perm) + [origin] path_distance = total_distance(full_path) # Updating the shortest path distance found shortest_path_distance = min(shortest_path_distance, path_distance) return shortest_path_distance"},{"question":"def compare_versions(version1: str, version2: str) -> int: Compare two version numbers version1 and version2. Returns: 1 if version1 > version2 -1 if version1 < version2 0 if version1 == version2 Examples: >>> compare_versions(\\"1.0\\", \\"1.0.0\\") 0 >>> compare_versions(\\"2.1\\", \\"1.9.9\\") 1 >>> compare_versions(\\"1.2\\", \\"1.10\\") -1 from solution import compare_versions def test_compare_versions_equal(): assert compare_versions(\\"1.0\\", \\"1.0.0\\") == 0 assert compare_versions(\\"1.1\\", \\"1.1\\") == 0 assert compare_versions(\\"2.0\\", \\"2.0.0.0\\") == 0 assert compare_versions(\\"0.0.1\\", \\"0.0.1.0\\") == 0 def test_compare_versions_greater(): assert compare_versions(\\"1.2\\", \\"1.1\\") == 1 assert compare_versions(\\"1.1.1\\", \\"1.1.0\\") == 1 assert compare_versions(\\"2.0\\", \\"1.9.9\\") == 1 assert compare_versions(\\"1.2.0\\", \\"1.1.9\\") == 1 def test_compare_versions_less(): assert compare_versions(\\"1.1\\", \\"1.2\\") == -1 assert compare_versions(\\"1.0.0\\", \\"1.0.1\\") == -1 assert compare_versions(\\"1.9.9\\", \\"2.0\\") == -1 assert compare_versions(\\"1.1.9\\", \\"1.2.0\\") == -1 def test_compare_versions_varied_length(): assert compare_versions(\\"1\\", \\"1.0.1\\") == -1 assert compare_versions(\\"1.0.0.0.0\\", \\"1.0\\") == 0 assert compare_versions(\\"1.0.2\\", \\"1.0.10\\") == -1","solution":"def compare_versions(version1: str, version2: str) -> int: Compares two version numbers version1 and version2. Returns: 1 if version1 > version2 -1 if version1 < version2 0 if version1 == version2 v1_parts = list(map(int, version1.split('.'))) v2_parts = list(map(int, version2.split('.'))) # Pad the shorter version with zeros while len(v1_parts) < len(v2_parts): v1_parts.append(0) while len(v2_parts) < len(v1_parts): v2_parts.append(0) # Compare each part for v1, v2 in zip(v1_parts, v2_parts): if v1 > v2: return 1 elif v1 < v2: return -1 return 0"},{"question":"def parseAttributes(html: str) -> str: Parses and modifies HTML attributes based on predefined rules. Replaces \`class\` with \`className\`, \`for\` with \`htmlFor\`, adds \`data-parsed=\\"true\\"\` to all <div> elements, and adds \`target=\\"_blank\\"\` to all <a> elements. Examples: >>> parseAttributes('<div class=\\"container\\">Content</div><a href=\\"link.html\\">Link</a><label for=\\"input\\">Label</label>') '<div className=\\"container\\" data-parsed=\\"true\\">Content</div><a href=\\"link.html\\" target=\\"_blank\\">Link</a><label htmlFor=\\"input\\">Label</label>' >>> parseAttributes('<DIV class=\\"main\\"><A href=\\"https://example.com\\">Example</A></DIV>') '<DIV className=\\"main\\" data-parsed=\\"true\\"><A href=\\"https://example.com\\" target=\\"_blank\\">Example</A></DIV>' >>> parseAttributes('<span>Text</span>') '<span>Text</span>' >>> parseAttributes('<div class=\\"wrap\\" data-other=\\"value\\">Another div</div>') '<div className=\\"wrap\\" data-other=\\"value\\" data-parsed=\\"true\\">Another div</div>' >>> parseAttributes('<Div CLASS=\\"wrap\\"><A hRef=\\"link.html\\">Link</A><Label For=\\"name\\">Name</Label></Div>') '<Div className=\\"wrap\\" data-parsed=\\"true\\"><A hRef=\\"link.html\\" target=\\"_blank\\">Link</A><Label htmlFor=\\"name\\">Name</Label></Div>'","solution":"import re def parseAttributes(html): Parses and modifies HTML attributes based on predefined rules. Replaces \`class\` with \`className\`, \`for\` with \`htmlFor\`, adds \`data-parsed=\\"true\\"\` to all <div> elements, and adds \`target=\\"_blank\\"\` to all <a> elements. # Using regular expressions for case-insensitive replacement # Replace class with className in a case-insensitive way html = re.sub(r'bclassb', 'className', html, flags=re.IGNORECASE) # Replace for with htmlFor in a case-insensitive way html = re.sub(r'bforb', 'htmlFor', html, flags=re.IGNORECASE) # Add data-parsed=\\"true\\" to all <div> elements html = re.sub(r'(<divb[^>]*)(>)', r'1 data-parsed=\\"true\\"2', html, flags=re.IGNORECASE) # Add target=\\"_blank\\" to all <a> elements html = re.sub(r'(<ab[^>]*)(>)', r'1 target=\\"_blank\\"2', html, flags=re.IGNORECASE) return html"},{"question":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. >>> filter_primes([]) == [] >>> filter_primes([4, 6, 8, 10, 12]) == [] >>> filter_primes([2, 3, 4, 5, 10, 13, 17]) == [2, 3, 5, 13, 17] >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([101, 103, 107, 109, 110, 111, 112]) == [101, 103, 107, 109] >>> filter_primes([-1, -2, -3, 0, 2, 19, 25, 27]) == [2, 19]","solution":"def is_prime(n): Check if a number is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def filter_primes(numbers): Returns a new list containing only the prime numbers from the original list. return [number for number in numbers if is_prime(number)]"},{"question":"def max_coins(coins: List[int]) -> int: Returns the maximum amount of money you can collect following the game rules. >>> max_coins([5, 3, 7, 10]) 15 >>> max_coins([8, 15, 3, 7]) 22 >>> max_coins([10]) 10 >>> max_coins([4, 7]) 7 >>> max_coins([10, 10, 10, 10]) 20 >>> max_coins([20, 30, 2, 2, 2, 10]) 42","solution":"def max_coins(coins): n = len(coins) dp = [[0] * n for _ in range(n)] for length in range(1, n+1): for i in range(n-length+1): j = i + length - 1 a = 0 if i+2 > j else dp[i+2][j] b = 0 if i+1 > j-1 else dp[i+1][j-1] c = 0 if i > j-2 else dp[i][j-2] dp[i][j] = max(coins[i] + min(a, b), coins[j] + min(b, c)) return dp[0][n-1]"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original array except the one at \`i\`. You must solve it without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([3, 2, 1]) [2, 3, 6] >>> product_except_self([10]) [1] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([0, 0, 0]) [0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns a list such that each element at index \`i\` of the new list is the product of all the numbers in the original array except the one at \`i\`. n = len(nums) # Initialize left and right products respectively left_products = [1] * n right_products = [1] * n # Construct the left products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Construct the right products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List, Optional def find_third_largest(lst: List[int]) -> Optional[int]: Returns the third largest unique number in the list. If the list does not have at least three unique numbers, returns None. Examples: >>> find_third_largest([4, 1, 7, 7, 3, 4, 2]) 3 >>> find_third_largest([10, 5, 9, 10, 5, 8]) 8 >>> find_third_largest([1, 2]) None >>> find_third_largest([3, 3, 3, 3]) None from solution import find_third_largest def test_third_largest_standard_cases(): assert find_third_largest([4, 1, 7, 7, 3, 4, 2]) == 3 assert find_third_largest([10, 5, 9, 10, 5, 8]) == 8 def test_less_than_three_unique_numbers(): assert find_third_largest([1, 2]) == None assert find_third_largest([3, 3, 3, 3]) == None def test_exactly_three_unique_numbers(): assert find_third_largest([1, 2, 3]) == 1 assert find_third_largest([10, 5, 8, 5, 8, 10]) == 5 def test_more_than_three_unique_numbers(): assert find_third_largest([5, 1, 2, 3, 4]) == 3 assert find_third_largest([9, 7, 10, 2, 1, 8]) == 8 def test_single_element(): assert find_third_largest([1]) == None def test_two_elements(): assert find_third_largest([1, 2]) == None def test_all_same_elements(): assert find_third_largest([7, 7, 7]) == None","solution":"def find_third_largest(lst): Returns the third largest unique number in the list. If the list does not have at least three unique numbers, returns None. unique_numbers = list(set(lst)) if len(unique_numbers) < 3: return None unique_numbers.sort(reverse=True) return unique_numbers[2]"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money you can rob tonight without alerting the police. The constraint is that you cannot rob two adjacent houses because it will trigger the alarm. >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12","solution":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob tonight without alerting the police. if not nums: return 0 if len(nums) <= 2: return max(nums) # Initialize an array to keep track of the maximum loot up to each house dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) # Fill the dp array with the maximum loot up to each house for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def min_swaps(books): This function calculates the minimum number of swaps required to sort the books in ascending order. :param books: List of integers representing the current order of books. :return: Integer representing the minimum number of swaps required to sort the books. >>> min_swaps([4, 3, 1, 2]) 3 >>> min_swaps([1, 5, 4, 3, 2]) 2 from solution import min_swaps def test_min_swaps_case1(): assert min_swaps([4, 3, 1, 2]) == 3 def test_min_swaps_case2(): assert min_swaps([1, 5, 4, 3, 2]) == 2 def test_min_swaps_already_sorted(): assert min_swaps([1, 2, 3, 4, 5]) == 0 def test_min_swaps_reverse_order(): assert min_swaps([5, 4, 3, 2, 1]) == 2 def test_min_swaps_single_element(): assert min_swaps([1]) == 0 def test_min_swaps_two_elements(): assert min_swaps([2, 1]) == 1 def test_min_swaps_large_case(): assert min_swaps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 5","solution":"def min_swaps(books): This function calculates the minimum number of swaps required to sort the books in ascending order. :param books: List of integers representing the current order of books. :return: Integer representing the minimum number of swaps required to sort the books. n = len(books) book_positions = {book: i for i, book in enumerate(books)} sorted_books = sorted(books) swaps = 0 visited = [False] * n for i in range(n): if visited[i] or books[i] == sorted_books[i]: continue cycle_length = 0 x = i while not visited[x]: visited[x] = True x = book_positions[sorted_books[x]] cycle_length += 1 if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"def first_missing_positive(nums): Given an array of integers, find the first missing positive integer in linear time and using constant extra space. The array can contain duplicates and negative numbers as well. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3","solution":"def first_missing_positive(nums): Returns the first missing positive integer from the list nums. The function modifies the input list in place and uses constant extra space. n = len(nums) for i in range(n): # Loop to place numbers at their correct indices if possible while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap the numbers to their correct positions correct_index = nums[i] - 1 nums[i], nums[correct_index] = nums[correct_index], nums[i] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left corner to the bottom-right corner of a rectangular grid, avoiding obstacles. An empty cell is represented by a 0, and a cell with an obstacle is represented by a 1. The function returns the length of the shortest path, or -1 if no such path exists. >>> grid1 = [ ... [0, 0, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid1) 4 >>> grid2 = [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid2) -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) # Directions for moving up, down, left, and right directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: r, c, d = queue.popleft() # Check if we have reached the target cell if r == n - 1 and c == m - 1: return d # Explore the neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, d + 1)) # If we finished processing all nodes and didn't reach the end return -1 # Example usage grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] print(shortest_path(grid)) # Output: 4"},{"question":"from typing import List def maxCount(m: int, n: int, ops: List[List[int]]) -> int: You are given a grid with \`m\` rows and \`n\` columns, initially filled with zeros. You are also given an array of operations \`ops\`, where \`ops[i] = [ai, bi]\` means that all cells in the submatrix from \`(0, 0)\` to \`(ai-1, bi-1)\` (inclusive) are incremented by 1. Define the maximum integer in the grid after performing all the operations. Return the number of cells in the grid that contain the maximum integer. Example: >>> maxCount(3, 3, [[2, 2], [3, 3]]) 4 if not ops: return m * n # If there are no operations, all cells contain the maximum integer which is 0 min_ai = min(op[0] for op in ops) min_bi = min(op[1] for op in ops) return min_ai * min_bi","solution":"from typing import List def maxCount(m: int, n: int, ops: List[List[int]]) -> int: Returns the number of cells in the grid that contain the maximum integer after performing all the given operations. if not ops: return m * n # If there are no operations, all cells contain the maximum integer which is 0 min_ai = min(op[0] for op in ops) min_bi = min(op[1] for op in ops) return min_ai * min_bi"},{"question":"def longest_alternating_subsequence_length(binary_string: str) -> int: Finds the length of the longest contiguous subsequence where the binary digits alternate. Args: binary_string (str): A string of binary digits ('0's and '1's). Returns: int: The length of the longest alternating subsequence. Examples: >>> longest_alternating_subsequence_length('110100110') 4 >>> longest_alternating_subsequence_length('1') 1 >>> longest_alternating_subsequence_length('1010101010') 10 >>> longest_alternating_subsequence_length('1111111') 1","solution":"def longest_alternating_subsequence_length(binary_string: str) -> int: Finds the length of the longest contiguous subsequence where the binary digits alternate. if not binary_string: return 0 max_length = 1 current_length = 1 for i in range(1, len(binary_string)): if binary_string[i] != binary_string[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def evaluate_expressions(expressions: List[str]) -> List: Evaluate each mathematical expression in the list. Return a new list with the results. Example: >>> evaluate_expressions([\\"2+3*4\\", \\"10/2-1\\", \\"5-5/0\\", \\"6*7+8\\", \\"abc+1\\"]) [14, 4.0, None, 50, None]","solution":"def evaluate_expressions(expressions): def evaluate(expression): try: return eval(expression) except (ZeroDivisionError, SyntaxError, NameError): return None return [evaluate(expr) for expr in expressions]"},{"question":"def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of integers. >>> filter_primes([4, 6, 7, 9, 11, 13, 15]) [7, 11, 13] >>> filter_primes([0, 1, 2, 3]) [2, 3]","solution":"def is_prime(n): Checks if a number n is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the given list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"from typing import List def find_duplicate_names(names: List[str]) -> List[str]: Returns a list of names that appear more than once in the original list, case insensitive, and sorted in ascending alphabetical order. >>> find_duplicate_names([\\"Alice\\", \\"Bob\\", \\"alice\\", \\"Eve\\", \\"eve\\", \\"Charlie\\"]) == [\\"alice\\", \\"eve\\"] >>> find_duplicate_names([\\"Anna\\", \\"anna\\", \\"John\\", \\"john\\", \\"John\\"]) == [\\"anna\\", \\"john\\"] >>> find_duplicate_names([\\"Anna\\", \\"Bob\\", \\"Charlie\\", \\"David\\"]) == []","solution":"def find_duplicate_names(names): Returns a sorted list of names that appear more than once in the original list, case insensitive and without duplication. if not names: return [] name_count = {} for name in names: normalized_name = name.lower() if normalized_name in name_count: name_count[normalized_name] += 1 else: name_count[normalized_name] = 1 duplicates = [name for name, count in name_count.items() if count > 1] return sorted(duplicates)"},{"question":"def word_count(s: str) -> dict: Counts the occurrences of each unique word in a given string, ignoring punctuation and case. Parameters: s (str): The input string. Returns: dict: A dictionary where keys are unique words and values are their counts. Examples: >>> word_count('Hello, world! Hello.') {'hello': 2, 'world': 1} >>> word_count('Python is great. Python.') {'python': 2, 'is': 1, 'great': 1} >>> word_count(' Hey there hey there! ') {'hey': 2, 'there': 2} >>> word_count('no punctuation here') {'no': 1, 'punctuation': 1, 'here': 1} >>> word_count('') {} >>> word_count('!!!,,,???.') {} >>> word_count('One fish, two fish. Red fish, blue fish.') {'one': 1, 'fish': 4, 'two': 1, 'red': 1, 'blue': 1} >>> word_count('123 123 abc 123') {'123': 3, 'abc': 1} # Implementation here","solution":"import re from collections import defaultdict def word_count(s): Counts the occurrences of each unique word in a given string, ignoring punctuation and case. Parameters: s (str): The input string. Returns: dict: A dictionary where keys are unique words and values are their counts. # Remove punctuation and convert to lower case cleaned_string = re.sub(r'[^ws]', '', s).lower() words = cleaned_string.split() word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"from typing import List def highest_product_of_three(nums: List[int]) -> int: Returns the highest product possible by multiplying any three distinct integers from the list. Parameters: nums (list): List of integers. Returns: int: Highest product of any three distinct integers. Examples: >>> highest_product_of_three([10, 3, 5, 6, 20]) 1200 >>> highest_product_of_three([-10, -10, 5, 2]) 500 def test_highest_product_of_three(): assert highest_product_of_three([10, 3, 5, 6, 20]) == 1200 assert highest_product_of_three([-10, -10, 5, 2]) == 500 assert highest_product_of_three([1, 2, 3, 4, 5, 6]) == 120 assert highest_product_of_three([-10, -10, -5, -2]) == -100 assert highest_product_of_three([1, 10, -5, 1, -100]) == 5000 def test_highest_product_of_three_not_enough_elements(): try: highest_product_of_three([1, 2]) except ValueError as e: assert str(e) == \\"The list must contain at least three integers\\" def test_highest_product_of_three_with_zeros(): assert highest_product_of_three([0, 0, 0, 0]) == 0 assert highest_product_of_three([0, -1, 3, 100]) == 0","solution":"def highest_product_of_three(nums): Returns the highest product possible by multiplying any three distinct integers from the list. Parameters: nums (list): List of integers. Returns: int: Highest product of any three distinct integers. if len(nums) < 3: raise ValueError(\\"The list must contain at least three integers\\") # Sort the list in ascending order nums.sort() # The maximum product can be from three largest values or two smallest values (negative) and the largest value max_product = max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1]) return max_product"},{"question":"def is_perfect_number(num): Returns True if num is a perfect number, and False otherwise. Returns \\"Not valid\\" if the input num is not a positive integer. Examples: >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(5) False >>> is_perfect_number(\\"28\\") \\"Not valid\\" >>> is_perfect_number(-6) \\"Not valid\\" def test_perfect_number(): assert is_perfect_number(6) == True def test_non_perfect_number(): assert is_perfect_number(5) == False def test_another_perfect_number(): assert is_perfect_number(28) == True def test_non_integer_input(): assert is_perfect_number(\\"28\\") == \\"Not valid\\" def test_negative_number_input(): assert is_perfect_number(-6) == \\"Not valid\\" def test_zero_input(): assert is_perfect_number(0) == \\"Not valid\\"","solution":"def is_perfect_number(num): Returns True if num is a perfect number, and False otherwise. Returns \\"Not valid\\" if the input num is not a positive integer. if not isinstance(num, int) or num <= 0: return \\"Not valid\\" divisors_sum = sum(i for i in range(1, num) if num % i == 0) return divisors_sum == num"},{"question":"def sliding_window_concatenate(input_list: List[str], k: int) -> List[str]: Takes a list of strings and an integer k, and returns a list with a sliding window of length k concatenated together. If the input list length is less than k, return an empty list. >>> sliding_window_concatenate([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], 3) ['abc', 'bcd', 'cde'] >>> sliding_window_concatenate([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 2) ['applebanana', 'bananacherry', 'cherrydate'] >>> sliding_window_concatenate([\\"a\\", \\"b\\"], 3) [] # Unit Test def test_sliding_window_concatenate_normal_case(): assert sliding_window_concatenate([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], 3) == [\\"abc\\", \\"bcd\\", \\"cde\\"] def test_sliding_window_concatenate_paircase(): assert sliding_window_concatenate([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 2) == [\\"applebanana\\", \\"bananacherry\\", \\"cherrydate\\"] def test_sliding_window_concatenate_large_k(): assert sliding_window_concatenate([\\"a\\", \\"b\\"], 3) == [] def test_sliding_window_concatenate_k_is_one(): assert sliding_window_concatenate([\\"x\\", \\"y\\", \\"z\\"], 1) == [\\"x\\", \\"y\\", \\"z\\"] def test_sliding_window_concatenate_list_too_small(): assert sliding_window_concatenate([], 2) == [] assert sliding_window_concatenate([\\"only\\"], 2) == [] def test_sliding_window_concatenate_large_list(): input_list = [\\"s\\" for _ in range(1000)] assert sliding_window_concatenate(input_list, 1000) == [\\"\\".join([\\"s\\" for _ in range(1000)])] def test_sliding_window_concatenate_k_equals_length(): input_list = [\\"one\\", \\"two\\"] assert sliding_window_concatenate(input_list, 2) == [\\"onetwo\\"] def test_sliding_window_concatenate_single_element(): assert sliding_window_concatenate([\\"single\\"], 1) == [\\"single\\"]","solution":"def sliding_window_concatenate(input_list, k): Takes a list of strings and an integer k, and returns a list with a sliding window of length k concatenated together. If the input list length is less than k, return an empty list. if len(input_list) < k: return [] result = [] for i in range(len(input_list) - k + 1): window_concatenation = ''.join(input_list[i:i+k]) result.append(window_concatenation) return result"},{"question":"[Completion Task in Python] class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_mirrors(root1: TreeNode, root2: TreeNode) -> bool: Check if two binary trees with the given root nodes are mirror images of each other. >>> root1 = TreeNode(1) >>> root1.left = TreeNode(2) >>> root1.right = TreeNode(3) >>> root2 = TreeNode(1) >>> root2.left = TreeNode(3) >>> root2.right = TreeNode(2) >>> are_mirrors(root1, root2) True >>> root3 = TreeNode(1) >>> root3.left = TreeNode(2) >>> root3.right = TreeNode(3) >>> root4 = TreeNode(1) >>> root4.left = TreeNode(2) >>> root4.right = TreeNode(3) >>> are_mirrors(root3, root4) False # Your code here","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def are_mirrors(root1: TreeNode, root2: TreeNode) -> bool: Check if two binary trees with the given root nodes are mirror images of each other. # If both nodes are None, they are mirrors (empty subtrees) if root1 is None and root2 is None: return True # If only one of the nodes is None, they are not mirrors if root1 is None or root2 is None: return False # Check if the values of the nodes are the same and recursively check their subtrees return (root1.val == root2.val and are_mirrors(root1.left, root2.right) and are_mirrors(root1.right, root2.left))"},{"question":"def singleNumber(nums: List[int]) -> int: Given an array of integers, where every element appears three times except for one, which appears exactly once. Find that single one. Your algorithm should have a linear runtime complexity and use no extra memory. >>> singleNumber([2, 2, 3, 2]) 3 >>> singleNumber([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def singleNumber(nums): Given an array of integers, each appearing three times except for one appearing once, this function returns that single integer. bit_count = [0] * 32 # To store the sum of bits at each position in 32-bit integers for num in nums: for i in range(32): bit_count[i] += (num >> i) & 1 result = 0 for i in range(32): if bit_count[i] % 3: # Only the non-triplicated number will contribute to this bit if i == 31: # Handle negative numbers result -= (1 << i) else: result |= (1 << i) return result"},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Given a string s of length n consisting of uppercase and lowercase English letters, construct a new string t by rearranging the characters of s such that no two adjacent characters in t are the same. If it is not possible to construct such a string t, output \\"Impossible\\". >>> rearrange_string(\\"aabbcc\\") 'abcabc' >>> rearrange_string(\\"aaa\\") 'Impossible' pass def test_rearrange_string(): assert rearrange_string(\\"aabbcc\\") == \\"abcabc\\" or rearrange_string(\\"aabbcc\\") == \\"acbacb\\" assert rearrange_string(\\"aaa\\") == \\"Impossible\\" assert rearrange_string(\\"a\\") == \\"a\\" assert rearrange_string(\\"ab\\") == \\"ab\\" or rearrange_string(\\"ab\\") == \\"ba\\" assert rearrange_string(\\"aaabbbc\\") == \\"abababc\\" or rearrange_string(\\"aaabbbc\\") == \\"ababacb\\" or rearrange_string(\\"aaabbbc\\") == \\"ababcab\\" assert rearrange_string(\\"ababab\\") == \\"ababab\\" or rearrange_string(\\"ababab\\") == \\"bababa\\" assert rearrange_string(\\"aaab\\") == \\"Impossible\\"","solution":"from collections import Counter import heapq def rearrange_string(s): char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) previous_char = None previous_freq = 0 result = [] while max_heap: current_freq, current_char = heapq.heappop(max_heap) result.append(current_char) if previous_char and previous_freq < 0: heapq.heappush(max_heap, (previous_freq, previous_char)) previous_char = current_char previous_freq = current_freq + 1 if len(result) == len(s): return ''.join(result) else: return \\"Impossible\\" def solve(s): return rearrange_string(s)"},{"question":"def find_largest_unique_substring(s: str) -> int: Write a function \`find_largest_unique_substring\` that takes a string \`s\` as an input and returns the length of the largest substring without repeating characters. Examples: >>> find_largest_unique_substring(\\"abcabcbb\\") 3 >>> find_largest_unique_substring(\\"bbbbb\\") 1 >>> find_largest_unique_substring(\\"pwwkew\\") 3","solution":"def find_largest_unique_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 char_index_map = {} start = 0 max_length = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minMeetingRooms(intervals: List[List[int]]) -> int: Determines the minimum number of conference rooms required for given meetings. Each meeting time is a pair of integers [si, ei] where \`0 <= si < ei <= 24\`. Example: >>> minMeetingRooms([[0, 30], [5, 10], [15, 20]]) 2 >>> minMeetingRooms([[7, 10], [2, 4]]) 1","solution":"def minMeetingRooms(intervals): Determines the minimum number of conference rooms required for given meetings. Parameters: intervals (List[List[int]]): List of meeting time intervals. Returns: int: The minimum number of conference rooms required. if not intervals: return 0 # Extract start and end times separately starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) start_pointer, end_pointer = 0, 0 used_rooms = 0 # Iterate through the start times and compare with end times while start_pointer < len(starts): if starts[start_pointer] < ends[end_pointer]: used_rooms += 1 else: end_pointer += 1 start_pointer += 1 return used_rooms"},{"question":"def can_cover_workday(start: int, end: int, workers: List[Tuple[int, int]]) -> str: Determines if it's possible to cover the entire range from start to end with the given workers' schedules. Parameters: - start: integer, start hour of the required workday - end: integer, end hour of the required workday - workers: list of tuples, each containing two integers representing the range of hours a worker can work (inclusive) Returns: - 'YES' if it's possible to cover the entire range from start to end, 'NO' otherwise. >>> can_cover_workday(8, 17, [(8, 12), (12, 15), (14, 17)]) 'YES' >>> can_cover_workday(9, 18, [(8, 10), (11, 14), (16, 19)]) 'NO' >>> can_cover_workday(10, 15, [(10, 11), (11, 13), (13, 15)]) 'YES' >>> can_cover_workday(9, 17, []) 'NO' >>> can_cover_workday(11, 19, [(11, 13), (13, 16), (15, 19)]) 'YES' >>> can_cover_workday(8, 15, [(8, 10), (12, 14), (14, 15)]) 'NO' >>> can_cover_workday(6, 10, [(6, 10)]) 'YES'","solution":"def can_cover_workday(start, end, workers): Determines if it's possible to cover the entire range from start to end with the given workers' schedules. Parameters: - start: integer, start hour of the required workday - end: integer, end hour of the required workday - workers: list of tuples, each containing two integers representing the range of hours a worker can work (inclusive) Returns: - 'YES' if it's possible to cover the entire range from start to end, 'NO' otherwise. workers.sort() current_end = start for li, ri in workers: if li > current_end: break if li <= current_end < ri: current_end = ri if current_end >= end: return \\"YES\\" return \\"NO\\""},{"question":"def rotateMatrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. >>> rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotateMatrix([[1]]) [[1]] >>> rotateMatrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"def rotateMatrix(matrix): Rotates a square matrix 90 degrees clockwise. n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n - i - 1] = matrix[i][j] return result"},{"question":"def generate_pascals_triangle(n: int) -> list: Generate Pascal's Triangle up to n rows. Each entry in the triangle is a binomial coefficient. Parameters: n (int): Number of rows in Pascal's Triangle. Returns: list: Pascal's Triangle represented as a list of lists. >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascals_triangle(1) [[1]] >>> generate_pascals_triangle(0) []","solution":"def generate_pascals_triangle(n: int) -> list: Generate Pascal's Triangle up to n rows. Each entry in the triangle is a binomial coefficient. Parameters: n (int): Number of rows in Pascal's Triangle. Returns: list: Pascal's Triangle represented as a list of lists. if n == 0: return [] triangle = [[1]] for row_num in range(1, n): row = [1] previous_row = triangle[row_num - 1] for j in range(1, row_num): row.append(previous_row[j - 1] + previous_row[j]) row.append(1) triangle.append(row) return triangle"},{"question":"def find_anagrams(word: str, words_list: List[str]) -> List[str]: This function takes a word and a list of words, then returns all anagrams of that word found in the list of words. >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"silent\\"]) ['enlist', 'inlets', 'silent'] >>> find_anagrams(\\"race\\", [\\"care\\", \\"acer\\", \\"car\\", \\"racecar\\", \\"scare\\"]) ['care', 'acer']","solution":"def find_anagrams(word, words_list): This function takes a word and a list of words, then returns all anagrams of that word found in the list of words. sorted_word = sorted(word) return [w for w in words_list if sorted(w) == sorted_word]"},{"question":"from typing import List, Dict, Any def aggregateObject(objs: List[Dict[str, Any]]) -> Dict[str, List[Any]]: Aggregates multiple objects into a single object. If a property key appears in more than one object, the values of those keys will be concatenated into an array. >>> aggregateObject([{ 'a': 1, 'b': 2 }, { 'b': 3, 'c': 4 }, { 'a': 5, 'c': [6, 7] }]) {'a': [1, 5], 'b': [2, 3], 'c': [4, 6, 7]}","solution":"def aggregateObject(objs): Aggregates multiple objects into a single object. If a property key appears in more than one object, the values of those keys will be concatenated into an array. Params: - objs (List[Dict]): A list of objects to be aggregated. Returns: - Dict: The aggregated object. result = {} for obj in objs: for key, value in obj.items(): if key in result: if isinstance(value, list): result[key].extend(value) else: result[key].append(value) else: if isinstance(value, list): result[key] = value[:] else: result[key] = [value] return result"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing addition and multiplication. Multiplication is evaluated before addition according to standard precedence rules. :param expression: str, a mathematical expression (e.g., \\"3+2*2\\") :return: int, result of evaluating the expression >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"3*2\\") == 6 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"1+2*3+4*5\\") == 27 >>> evaluate_expression(\\"100+200*300\\") == 60100","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing addition and multiplication. Multiplication is evaluated before addition according to standard precedence rules. :param expression: str, a mathematical expression (e.g., \\"3+2*2\\") :return: int, result of evaluating the expression # Split the expression into tokens for alternation between numbers and operators tokens = [] num = 0 for char in expression: if char.isdigit(): num = num * 10 + int(char) else: tokens.append(num) tokens.append(char) num = 0 tokens.append(num) # First pass: process all multiplications stack = [] i = 0 while i < len(tokens): if str(tokens[i]).isdigit(): stack.append(tokens[i]) elif tokens[i] == '+': stack.append(tokens[i]) elif tokens[i] == '*': num = stack.pop() i += 1 num *= tokens[i] stack.append(num) i += 1 # Second pass: process all additions result = stack[0] i = 1 while i < len(stack): if stack[i] == '+': result += stack[i + 1] i += 2 return result"},{"question":"from typing import List def majority_element(nums: List[int]) -> List[int]: Given an integer array of size n, find all elements that appear more than  n/3  times. >>> majority_element([3,2,3]) [3] >>> majority_element([1]) [1] >>> majority_element([1,1,1,3,3,2,2,2]) [1,2]","solution":"def majority_element(nums): Given an integer array of size n, find all elements that appear more than  n/3  times. if not nums: return [] # Using Boyer-Moore Voting Algorithm to find potential candidates candidate1 = candidate2 = None count1 = count2 = 0 for num in nums: if candidate1 == num: count1 += 1 elif candidate2 == num: count2 += 1 elif count1 == 0: candidate1, count1 = num, 1 elif count2 == 0: candidate2, count2 = num, 1 else: count1 -= 1 count2 -= 1 # Validate the candidates result = [] for candidate in (candidate1, candidate2): if nums.count(candidate) > len(nums) // 3: result.append(candidate) return result"},{"question":"def find_most_frequent(nums: List[int]) -> int: Returns the integer that appears most frequently in the list. If there is a tie, returns the smallest integer among the most frequent ones. >>> find_most_frequent([1, 3, 1, 3, 2, 1]) == 1 >>> find_most_frequent([4, 4, 4, 9, 2, 9, 9]) == 4 >>> find_most_frequent([1, 2, 3, 4]) in [1, 2, 3, 4] >>> find_most_frequent([]) == None >>> find_most_frequent([42]) == 42 >>> find_most_frequent([-1, -1, -2, -3, -1, -2]) == -1 >>> find_most_frequent([1, 2, 1, 2, 3, 3]) == 1","solution":"def find_most_frequent(nums): Returns the integer that appears most frequently in the list. If there is a tie, returns the smallest integer among the most frequent ones. if not nums: return None from collections import Counter count = Counter(nums) max_frequency = max(count.values()) most_frequent = [num for num, freq in count.items() if freq == max_frequency] return min(most_frequent)"},{"question":"def find_pairs_with_sum(array: List[int], target: int) -> List[List[int]]: Finds all unique pairs in an array that add up to a specific target sum. Each pair is returned as a list in which the smaller number comes first. The pairs are sorted in ascending order based on the first element of the pair. >>> find_pairs_with_sum([3, 4, 5, 2, -1, 0, 7, 1], 5) [[0, 5], [1, 4], [2, 3]] >>> find_pairs_with_sum([1, 2, 3, 4], 10) [] >>> find_pairs_with_sum([1, 1, 1, 2, 2, 3, 3, 4, 4], 5) [[1, 4], [2, 3]] >>> find_pairs_with_sum([-5, -4, -3, -2, -1], -6) [[-5, -1], [-4, -2]] >>> find_pairs_with_sum([0, 0, 2, 3], 2) [[0, 2]] >>> find_pairs_with_sum([1, 3, 2, 2, 3, 4], 5) [[1, 4], [2, 3]]","solution":"def find_pairs_with_sum(array, target): Finds all unique pairs in an array that add up to a specific target sum. Each pair is returned as a list in which the smaller number comes first. The pairs are sorted in ascending order based on the first element of the pair. :param array: List of integers :param target: Target sum :return: List of unique pairs found_pairs = set() seen_numbers = set() for number in array: complement = target - number if complement in seen_numbers: pair = tuple(sorted((number, complement))) found_pairs.add(pair) seen_numbers.add(number) # Sort pairs and convert back to list form sorted_pairs = sorted([list(pair) for pair in found_pairs]) return sorted_pairs"},{"question":"def max_circular_tiles(L, W, r): Computes the maximum number of circular tiles of radius r that can fit within a rectangular area of dimensions L x W without overlapping. Args: L (float or int): The length of the rectangular area. W (float or int): The width of the rectangular area. r (float or int): The radius of the circular tiles. Returns: int: The maximum number of circular tiles that can fit within the given rectangular area. >>> max_circular_tiles(10, 10, 1) 25 >>> max_circular_tiles(0, 10, 1) 0 >>> max_circular_tiles(10, 0, 1) 0 >>> max_circular_tiles(10, 10, 5) 1 >>> max_circular_tiles(3, 3, 2) 0 >>> max_circular_tiles(4, 4, 1) 4 >>> max_circular_tiles(10, 9, 1.5) 9","solution":"import math def max_circular_tiles(L, W, r): Computes the maximum number of circular tiles of radius r that can fit within a rectangular area of dimensions L x W without overlapping. Args: L (float or int): The length of the rectangular area. W (float or int): The width of the rectangular area. r (float or int): The radius of the circular tiles. Returns: int: The maximum number of circular tiles that can fit within the given rectangular area. # The diameter of one tile d = 2 * r # Number of tiles that can fit along the length and width num_tiles_length = L // d num_tiles_width = W // d # Total number of tiles max_tiles = int(num_tiles_length * num_tiles_width) return max_tiles"},{"question":"def selection_sort_trace(lst: List[int]) -> List[Tuple[int, int, List[int], int]]: Perform selection sort on the given list and return the trace information. Each step contains the indices swapped, the list after swap, and the sum of the list at that point. :param lst: List of integers to be sorted. :return: List of tuples with (index1, index2, list after swap, sum of list)","solution":"def selection_sort_trace(lst): Perform selection sort on the given list and return the trace information. Each step contains the indices swapped, the list after swap, and the sum of the list at that point. :param lst: List of integers to be sorted. :return: List of tuples with (index1, index2, list after swap, sum of list) trace = [] n = len(lst) list_sum = sum(lst) for i in range(n): min_index = i for j in range(i + 1, n): if lst[j] < lst[min_index]: min_index = j if min_index != i: lst[i], lst[min_index] = lst[min_index], lst[i] trace.append((i, min_index, lst[:], list_sum)) return trace"},{"question":"def make_equal_zeros_ones(t: int, test_cases: List[Tuple[int, str]]) -> List[List[int]]: Determine if it is possible to make each binary string have an equal number of 0s and 1s by flipping bits, and return the indices of the bits to flip. >>> make_equal_zeros_ones(4, [(6, \\"110000\\"), (5, \\"11111\\"), (8, \\"10101010\\"), (3, \\"110\\")]) [[-1], [-1], [0], [-1]] >>> make_equal_zeros_ones(1, [(4, \\"0000\\")]) [[-1]] >>> make_equal_zeros_ones(1, [(6, \\"010101\\")]) [[0]] >>> make_equal_zeros_ones(1, [(2, \\"00\\")]) [[-1]] >>> make_equal_zeros_ones(1, [(4, \\"1001\\")]) [[0]]","solution":"def make_equal_zeros_ones(t, test_cases): results = [] for case in test_cases: n, s = case count_0 = s.count('0') count_1 = s.count('1') if n % 2 != 0 or count_0 != count_1: results.append([-1]) else: results.append([0]) return results"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Calculate the number of unique paths for the robot to move from the top-left corner to the bottom-right corner of the grid, avoiding blocked cells. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) == 1 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> unique_paths_with_obstacles([[0, 1, 1], [1, 1, 1], [1, 1, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 1, 0, 0]]) == 0 >>> unique_paths_with_obstacles([[0], [0], [1], [0]]) == 0 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) == 0 >>> unique_paths_with_obstacles([[0]*10 for _ in range(10)]) == 48620","solution":"def unique_paths_with_obstacles(grid): m = len(grid) n = len(grid[0]) # Create a DP table with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Start from the top-left corner dp[0][0] = 1 if grid[0][0] == 0 else 0 # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] if grid[0][j] == 0 else 0 # Fill the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] if grid[i][0] == 0 else 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] else: dp[i][j] = 0 # The bottom-right corner will have the number of unique paths return dp[m - 1][n - 1]"},{"question":"def can_be_rewarded(attendance: str) -> bool: Determines if a student can be rewarded based on their attendance record. A student can be rewarded if they meet the following criteria: 1. They were absent ('A') for fewer than 2 days in total. 2. They were not late ('L') for 3 or more consecutive days at any point. :param attendance: A string representing the attendance record. :return: True if the student can be rewarded, False otherwise. pass","solution":"def can_be_rewarded(attendance: str) -> bool: Determines if a student can be rewarded based on their attendance record. A student can be rewarded if: 1. They were absent for fewer than 2 days. 2. They were not late for 3 or more consecutive days at any point. :param attendance: A string representing the attendance record. :return: True if the student can be rewarded, False otherwise. absences = attendance.count('A') if absences >= 2: return False if 'LLL' in attendance: return False return True"},{"question":"from typing import List def divide_and_round(numbers: List[int], k: int) -> List[int]: Divides each element in the list by k and rounds to the nearest integer. In case of ties (i.e., exactly halfway between two integers), it rounds to the nearest even integer. >>> divide_and_round([10, 20, 30, 40], 3) [3, 7, 10, 13] >>> divide_and_round([15, 25, 35], 5) [3, 5, 7] >>> divide_and_round([2.5, 3.5, 4.5], 1) [2, 4, 4] >>> divide_and_round([-2.5, -3.5, -4.5], 1) [-2, -4, -4] >>> divide_and_round([0, 0, 0], 1) [0, 0, 0] >>> divide_and_round([-10, 20, -30, 40], 5) [-2, 4, -6, 8] >>> divide_and_round([-10, -20, -30], 5) [-2, -4, -6]","solution":"def divide_and_round(numbers, k): Divides each element in the list by k and rounds to the nearest integer. In case of ties (i.e., exactly halfway between two integers), it rounds to the nearest even integer. return [round(num / k) for num in numbers]"},{"question":"from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: Given an array of strings, group anagrams together. Two strings are anagrams if and only if their sorted characters are equal. Args: strs: List[str] : List of strings Returns: List[List[str]] : Grouped anagrams Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\",\\"tea\\",\\"ate\\"], [\\"tan\\",\\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]]","solution":"def group_anagrams(strs): Groups anagrams together from the given list of strings. Args: strs: List[str] : List of strings Returns: List[List[str]] : Grouped anagrams from collections import defaultdict anagrams = defaultdict(list) for string in strs: sorted_str = ''.join(sorted(string)) anagrams[sorted_str].append(string) return list(anagrams.values())"},{"question":"def first_missing_positive(nums): Find the smallest missing positive integer from the given list nums. Example 1: >>> first_missing_positive([3, 4, -1, 1]) 2 Example 2: >>> first_missing_positive([1, 2, 0]) 3 Example 3: >>> first_missing_positive([7, 8, 9, 11, 12]) 1 Example 4: >>> first_missing_positive([1, 1, 0, -1, -2]) 2 Example 5: >>> first_missing_positive([2, 3, 4, 5, 6]) 1","solution":"def first_missing_positive(nums): Find the smallest missing positive integer from the given list nums. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def is_password_valid(password: str) -> bool: Checks if the given password is valid based on the specified rules: 1. It must be at least 8 characters long. 2. It must contain at least one uppercase letter. 3. It must contain at least one lowercase letter. 4. It must contain at least one digit. >>> is_password_valid(\\"Password123\\") # returns: True >>> is_password_valid(\\"pass123\\") # returns: False (less than 8 characters) >>> is_password_valid(\\"PASSWORD123\\") # returns: False (no lowercase letter) >>> is_password_valid(\\"password123\\") # returns: False (no uppercase letter) >>> is_password_valid(\\"Password\\") # returns: False (no digit) >>> is_password_valid(\\"Passw0rd\\") # returns: True","solution":"def is_password_valid(password: str) -> bool: Checks if the given password is valid based on the specified rules. if len(password) < 8: return False has_upper = False has_lower = False has_digit = False for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True return has_upper and has_lower and has_digit"},{"question":"def min_steps_to_make_empty(s: str) -> int: Returns the minimum number of steps to make the string empty by removing palindromic subsequences. >>> min_steps_to_make_empty(\\"ababa\\") 1 >>> min_steps_to_make_empty(\\"abb\\") 2 >>> min_steps_to_make_empty(\\"baabb\\") 2 >>> min_steps_to_make_empty(\\"ab\\") 2 >>> min_steps_to_make_empty(\\"a\\") 1 >>> min_steps_to_make_empty(\\"b\\") 1 >>> min_steps_to_make_empty(\\"aa\\") 1 >>> min_steps_to_make_empty(\\"bb\\") 1 >>> min_steps_to_make_empty(\\"a\\" * 1000) 1 >>> min_steps_to_make_empty(\\"ab\\" * 500) 2","solution":"def min_steps_to_make_empty(s): Returns the minimum number of steps to make the string empty by removing palindromic subsequences. # If the string is already a palindrome, we can remove it in one step if s == s[::-1]: return 1 # If the string is not a palindrome, we need two steps: # One to remove all 'a's and another to remove all 'b's (or vice versa) return 2"},{"question":"def removeKdigits(s: str, k: int) -> str: Remove k digits from the string s to form the smallest possible number. >>> removeKdigits(\\"1432219\\", 3) '1219' >>> removeKdigits(\\"10200\\", 1) '200' >>> removeKdigits(\\"10\\", 2) '0' >>> removeKdigits(\\"1234567890\\", 9) '0' >>> removeKdigits(\\"5337\\", 2) '33' >>> removeKdigits(\\"9876543210\\", 3) '6543210' >>> removeKdigits(\\"10\\", 1) '0' >>> removeKdigits(\\"10001\\", 1) '1'","solution":"def removeKdigits(s, k): Remove k digits from the string s to form the smallest possible number. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to be removed, remove them from the end stack = stack[:-k] if k else stack # Convert stack to string and remove leading zeros result = ''.join(stack).lstrip('0') return result or \\"0\\""},{"question":"from typing import List, Tuple def prime_sum_subsets(input_data: str) -> List[int]: Determine the smallest length of subsets whose sum is a prime number. Args: input_data (str): String input containing multiple test cases. Returns: List[int]: List containing the size of the smallest subset whose sum is a prime number for each test case. If no such subset exists, the output should be -1. Example: >>> input_data = '1n5n1 2 3 4 5' >>> prime_sum_subsets(input_data) [1] >>> input_data = '1n4n4 6 8 10' >>> prime_sum_subsets(input_data) [-1] pass def test_example_case(): input_data = '1n5n1 2 3 4 5' assert prime_sum_subsets(input_data) == [1] def test_no_prime_subsets(): input_data = '1n4n4 6 8 10' assert prime_sum_subsets(input_data) == [-1] def test_prime_subset_lengths(): input_data = '2n3n10 3 9n4n11 14 -5 -4' assert prime_sum_subsets(input_data) == [1, 1] def test_negative_numbers(): input_data = '1n4n-5 -7 -10 -11' assert prime_sum_subsets(input_data) == [-1] def test_single_element_prime(): input_data = '1n1n7' assert prime_sum_subsets(input_data) == [1] def test_mixed_numbers(): input_data = '1n5n-6 5 -3 2 1' assert prime_sum_subsets(input_data) == [1] def test_multiple_primes(): input_data = '1n6n1 2 4 6 15 17' assert prime_sum_subsets(input_data) == [1]","solution":"from itertools import combinations import math def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(math.sqrt(num)) + 1, 2): if num % i == 0: return False return True def smallest_prime_subset_length(test_cases): results = [] for case in test_cases: n, array = case min_length = float('inf') found_prime_sum = False # Check all subsets with non-zero size for r in range(1, n + 1): for subset in combinations(array, r): if is_prime(sum(subset)): found_prime_sum = True min_length = min(min_length, len(subset)) if found_prime_sum: results.append(min_length) else: results.append(-1) return results def parse_input(input_data): data = input_data.split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) array = list(map(int, data[index + 1: index + 1 + n])) test_cases.append((n, array)) index += n + 1 return test_cases def prime_sum_subsets(input_data): test_cases = parse_input(input_data) return smallest_prime_subset_length(test_cases)"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the array nums. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([1]) 1 >>> longest_consecutive_sequence([10, 5, 15, 20]) 1 >>> longest_consecutive_sequence([1, 1, 1, 1]) 1 >>> longest_consecutive_sequence([1, 2, 0, -1, -2]) 5 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 4, 5, 5, 6]) 6","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in the array nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def minCost(costs: List[List[int]]) -> int: Returns the minimum cost to paint all houses such that no two adjacent houses have the same color. :param costs: List[List[int]]: The costs to paint each house in three different colors :return: int: The minimum cost to paint all houses >>> minCost([[17,2,17],[16,16,5],[14,3,19]]) 10 >>> minCost([[7,6,2]]) 2","solution":"def minCost(costs): Returns the minimum cost to paint all houses such that no two adjacent houses have the same color. :param costs: List[List[int]]: The costs to paint each house in three different colors :return: int: The minimum cost to paint all houses if not costs: return 0 n = len(costs) for i in range(1, n): costs[i][0] += min(costs[i-1][1], costs[i-1][2]) costs[i][1] += min(costs[i-1][0], costs[i-1][2]) costs[i][2] += min(costs[i-1][0], costs[i-1][1]) return min(costs[-1])"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. A prime number is greater than 1 and has no positive divisors other than 1 and itself. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(1) == False >>> is_prime(4) == False >>> is_prime(29) == True >>> is_prime(97) == True >>> is_prime(100) == False >>> is_prime(104729) == True >>> is_prime(0) == False >>> is_prime(-1) == False >>> is_prime(-10) == False >>> is_prime(49) == False >>> is_prime(121) == False >>> is_prime(169) == False pass","solution":"from math import isqrt def is_prime(n): Returns True if n is a prime number, otherwise False. A prime number is greater than 1 and has no positive divisors other than 1 and itself. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def calculate(expression: str) -> float: Evaluates a string containing an arithmetic expression and returns the result. Supports +, -, *, / operations and respects parentheses precedence. >>> calculate(\\"3 + 5\\") -> 8 >>> calculate(\\"10 + 2 * 6\\") -> 22 >>> calculate(\\"100 * 2 + 12\\") -> 212 >>> calculate(\\"100 * ( 2 + 12 )\\") -> 1400 >>> calculate(\\"100 * ( 2 + 12 ) / 14\\") -> 100.0 >>> calculate(\\"-3 + 5\\") -> 2 >>> calculate(\\"10 + (-2) * 6\\") -> -2 >>> calculate(\\"7 / 2\\") -> 3.5 >>> calculate(\\"2 + 3 * (2 - 1)\\") -> 5 >>> calculate(\\"10 - (2 + 3)\\") -> 5","solution":"def calculate(expression): Evaluates a string containing an arithmetic expression and returns the result. Supports +, -, *, / operations and respects parentheses precedence. import re import operator # Dictionary to map operators to corresponding functions ops = { '+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv } def evaluate(tokens): stack = [] num = 0 sign = '+' i = 0 while i < len(tokens): token = tokens[i] if token.isdigit(): num = int(token) if token == '(': j = i balance = 0 while i < len(tokens): if tokens[i] == '(': balance += 1 if tokens[i] == ')': balance -= 1 if balance == 0: break i += 1 num = evaluate(tokens[j + 1:i]) if token in ops or i == len(tokens) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(stack.pop() / num) sign = token num = 0 i += 1 return sum(stack) # Remove spaces and split token using regex tokens = re.findall(r'd+|[-+*/()]', expression.replace(' ', '')) return evaluate(tokens)"},{"question":"def factorial_string(n: int) -> str: Returns a string representation of the factorial of n. >>> factorial_string(3) == '6' >>> factorial_string(0) == '1' >>> factorial_string(10) == '3628800'","solution":"def factorial_string(n): Returns a string representation of the factorial of n. if n == 0: return str(1) factorial = 1 for i in range(1, n + 1): factorial *= i return str(factorial)"},{"question":"def can_sort_by_reversing_subarray(arr): Determines if the array can be sorted in ascending order by reversing any subarray. Args: arr (List[int]): An integer array \`arr\` of unique integers. Returns: bool: Return \`true\` if the array can be sorted using the described operations, and \`false\` otherwise. Examples: >>> can_sort_by_reversing_subarray([1, 3, 2, 4, 5]) True >>> can_sort_by_reversing_subarray([1, 2, 3, 5, 4]) True >>> can_sort_by_reversing_subarray([3, 1, 2, 4, 5]) False pass Unit Test: from solution import can_sort_by_reversing_subarray def test_sorted_array(): assert can_sort_by_reversing_subarray([1, 2, 3, 4, 5]) == True def test_single_element(): assert can_sort_by_reversing_subarray([1]) == True def test_two_elements(): assert can_sort_by_reversing_subarray([2, 1]) == True def test_simple_reversable(): assert can_sort_by_reversing_subarray([1, 3, 2, 4, 5]) == True def test_reverse_ending(): assert can_sort_by_reversing_subarray([1, 2, 3, 5, 4]) == True def test_no_reversable(): assert can_sort_by_reversing_subarray([3, 1, 2, 4, 5]) == False def test_long_reversable(): assert can_sort_by_reversing_subarray([1, 5, 4, 3, 2, 6, 7]) == True def test_multiple_unsorted_segments(): assert can_sort_by_reversing_subarray([1, 5, 4, 6, 3, 2, 7]) == False def test_large_array_sorted(): assert can_sort_by_reversing_subarray(list(range(1000))) == True def test_large_array_reverse_ending(): assert can_sort_by_reversing_subarray(list(range(1, 999)) + [1000, 999]) == True","solution":"def can_sort_by_reversing_subarray(arr): Determines if the array can be sorted in ascending order by reversing any subarray. sorted_arr = sorted(arr) n = len(arr) # Find the first and last positions where arr differs from sorted_arr start, end = 0, n - 1 while start < n and arr[start] == sorted_arr[start]: start += 1 while end >= 0 and arr[end] == sorted_arr[end]: end -= 1 # If the entire array is already sorted if start >= end: return True # Reverse the subarray from start to end and check if it matches the sorted array reversed_subarray = arr[:start] + arr[start:end+1][::-1] + arr[end+1:] return reversed_subarray == sorted_arr"},{"question":"def rotate_array(arr: list, n: int) -> list: Rotates the given array to the right by n positions. Args: arr (list of int): The array to rotate. n (int): The number of positions to rotate to the right. Returns: list of int: The rotated array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([10, 20, 30, 40, 50], 3) [30, 40, 50, 10, 20] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1], 2) [1] >>> rotate_array([], 3) [] >>> rotate_array([1, 2, 3, 4, 5], 12) [4, 5, 1, 2, 3]","solution":"def rotate_array(arr, n): Rotates the given array to the right by n positions. Args: arr (list of int): The array to rotate. n (int): The number of positions to rotate to the right. Returns: list of int: The rotated array. if not arr: return arr n = n % len(arr) # To handle if n is greater than the length of the array return arr[-n:] + arr[:-n]"},{"question":"def find_added_character(str1: str, str2: str) -> str: Determine if str2 can be formed by rearranging str1 and adding exactly one character. If possible, return the added character, otherwise return an empty string. >>> find_added_character(\\"abc\\", \\"abcd\\") \\"d\\" >>> find_added_character(\\"aabbcc\\", \\"abacabc\\") \\"a\\" >>> find_added_character(\\"xyz\\", \\"yxz\\") \\"\\" >>> find_added_character(\\"hello\\", \\"hhelloo\\") \\"h\\"","solution":"def find_added_character(str1: str, str2: str) -> str: Determine if str2 can be formed by rearranging str1 and adding exactly one character. If possible, return the added character, otherwise return an empty string. from collections import Counter # Use Counter to count frequency of each character in both strings counter1 = Counter(str1) counter2 = Counter(str2) # Iterate through the characters and their counts in counter2 for char, count in counter2.items(): # If the character count in counter2 is one more than in counter1, return that character if count == counter1[char] + 1: return char # If no such character is found, return an empty string (though, by constraint this should never occur) return \\"\\""},{"question":"def can_form_sum(matrix: List[List[int]], S: int) -> bool: Given a matrix of dimension m x n consisting of non-negative integers, determine if you can remove exactly one number from each row such that the resulting sum of the selected numbers from each row equals a target value S. >>> can_form_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 15) True >>> can_form_sum([[1, 10], [2, 6], [3, 1]], 12) False","solution":"from itertools import product def can_form_sum(matrix, S): Determines if you can remove exactly one number from each row such that the resulting sum equals a target value S. # Get all combinations of picking one element from each row all_combinations = product(*matrix) # Check if any combination sums up to S for combination in all_combinations: if sum(combination) == S: return True return False"},{"question":"def convert_to_seconds(time_str: str) -> int: Converts a time duration from a mixed format into standardized seconds. >>> convert_to_seconds(\\"2h3m5s\\") == 7385 >>> convert_to_seconds(\\"1d2h\\") == 93600 >>> convert_to_seconds(\\"4m45s\\") == 285 >>> convert_to_seconds(\\"1d1s\\") == 86401 # Your code here def test_convert_to_seconds_example1(): assert convert_to_seconds(\\"2h3m5s\\") == 7385 def test_convert_to_seconds_example2(): assert convert_to_seconds(\\"1d2h\\") == 93600 def test_convert_to_seconds_example3(): assert convert_to_seconds(\\"4m45s\\") == 285 def test_convert_to_seconds_example4(): assert convert_to_seconds(\\"1d1s\\") == 86401 def test_convert_to_seconds_only_days(): assert convert_to_seconds(\\"2d\\") == 172800 def test_convert_to_seconds_only_hours(): assert convert_to_seconds(\\"5h\\") == 18000 def test_convert_to_seconds_only_minutes(): assert convert_to_seconds(\\"30m\\") == 1800 def test_convert_to_seconds_only_seconds(): assert convert_to_seconds(\\"45s\\") == 45 def test_convert_to_seconds_all_units(): assert convert_to_seconds(\\"1d1h1m1s\\") == 90061","solution":"def convert_to_seconds(time_str: str) -> int: Converts a time duration from a mixed format into standardized seconds. import re # Define the conversion factors time_units = {'d': 86400, 'h': 3600, 'm': 60, 's': 1} # Regex to match the pattern of the input string pattern = r\\"(d+)([dhms])\\" total_seconds = 0 # Find all matches in the input string matches = re.findall(pattern, time_str) for value, unit in matches: total_seconds += int(value) * time_units[unit] return total_seconds"},{"question":"from typing import List def full_justify(words: List[str], k: int) -> List[str]: Given an array of strings \`words\` and a width \`k\`, format the text such that each line has exactly \`k\` characters and is fully justified. >>> full_justify([\\"This\\", \\"is\\", \\"an\\", \\"example\\", \\"of\\", \\"text\\", \\"justification.\\"], 16) [\\"This is an\\", \\"example of text\\", \\"justification. \\"] >>> full_justify([\\"What\\",\\"must\\",\\"be\\",\\"acknowledgment\\",\\"shall\\",\\"be\\"], 16) [\\"What must be\\", \\"acknowledgment \\", \\"shall be \\"] >>> full_justify([\\"Science\\",\\"is\\",\\"what\\",\\"we\\",\\"understand\\",\\"well\\",\\"enough\\",\\"to\\",\\"explain\\",\\"to\\",\\"a\\",\\"computer.\\",\\"Art\\",\\"is\\",\\"everything\\",\\"else\\",\\"we\\",\\"do\\"], 20) [\\"Science is what we\\", \\"understand well\\", \\"enough to explain to\\", \\"a computer. Art is\\", \\"everything else we\\", \\"do \\"] >>> full_justify([\\"one\\"], 10) [\\"one \\"] >>> full_justify([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], 5) [\\"abcd \\", \\"efgh \\", \\"ijkl \\"]","solution":"def full_justify(words, k): def justify_line(line_words, max_width, is_last_line=False): if is_last_line or len(line_words) == 1: return ' '.join(line_words).ljust(max_width) n_spaces = max_width - sum(len(word) for word in line_words) n_slots = len(line_words) - 1 spaces = [n_spaces // n_slots] * n_slots for i in range(n_spaces % n_slots): spaces[i] += 1 justified_line = '' for word, space in zip(line_words, spaces): justified_line += word + ' ' * space justified_line += line_words[-1] return justified_line result = [] line_words = [] line_length = 0 for word in words: if line_length + len(line_words) + len(word) > k: result.append(justify_line(line_words, k)) line_words = [] line_length = 0 line_words.append(word) line_length += len(word) # Handle the last line if line_words: result.append(justify_line(line_words, k, is_last_line=True)) return result"},{"question":"def max_potion_power(ingredients, max_weight): Determines the maximum power of a potion that can be crafted without exceeding the weight limit. Uses a dynamic programming approach similar to the knapsack problem. :param ingredients: List of tuples where each tuple contains (power, weight) of an ingredient :param max_weight: Integer representing the maximum weight the player can carry :return: Maximum power that can be achieved without exceeding the weight limit >>> max_potion_power([(10, 2), (40, 3), (30, 4), (50, 5)], 6) 50 >>> max_potion_power([(100, 1)], 5) 100 >>> max_potion_power([(40, 2), (50, 3)], 5) 90 def parse_input(input_text): lines = input_text.strip().split('n') N = int(lines[0]) ingredients = [tuple(map(int, line.split())) for line in lines[1:N+1]] W = int(lines[N+1]) return ingredients, W","solution":"def max_potion_power(ingredients, max_weight): Determines the maximum power of a potion that can be crafted without exceeding the weight limit. Uses a dynamic programming approach similar to the knapsack problem. :param ingredients: List of tuples where each tuple contains (power, weight) of an ingredient :param max_weight: Integer representing the maximum weight the player can carry :return: Maximum power that can be achieved without exceeding the weight limit n = len(ingredients) dp = [[0] * (max_weight + 1) for _ in range(n + 1)] for i in range(1, n + 1): power, weight = ingredients[i-1] for w in range(max_weight + 1): if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + power) else: dp[i][w] = dp[i-1][w] return dp[n][max_weight] # Parse input def parse_input(input_text): lines = input_text.strip().split('n') N = int(lines[0]) ingredients = [tuple(map(int, line.split())) for line in lines[1:N+1]] W = int(lines[N+1]) return ingredients, W def main(input_text): ingredients, max_weight = parse_input(input_text) return max_potion_power(ingredients, max_weight)"},{"question":"def can_transform_to_sum(N: int, M: int, A: List[int]) -> bool: Determines if it is possible to transform the array such that the sum of the elements becomes exactly M using the given operation. >>> can_transform_to_sum(5, 15, [1, 2, 3, 4, 5]) True >>> can_transform_to_sum(4, 50, [7, 10, 13, 14]) False","solution":"def can_transform_to_sum(N, M, A): Determines if it is possible to transform the array such that the sum of the elements becomes exactly M using the given operation. return sum(A) == M"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(13) True >>> is_prime(25) False >>> is_prime(89) True pass def smallest_prime_fibonacci(a: int, b: int) -> int: Find the smallest prime number that is also a Fibonacci number in the range [a, b]. >>> smallest_prime_fibonacci(10, 100) 13 >>> smallest_prime_fibonacci(50, 60) -1 >>> smallest_prime_fibonacci(1, 1) -1 >>> smallest_prime_fibonacci(1, 2) 2 >>> smallest_prime_fibonacci(60, 1000) 89 >>> smallest_prime_fibonacci(100, 5000) 233 >>> smallest_prime_fibonacci(1, 1000000000000000000) 2 pass","solution":"def is_prime(n): Check if a number is prime. if n < 2: return False if n in (2, 3): return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def smallest_prime_fibonacci(a, b): Find the smallest prime number that is also a Fibonacci number in the range [a, b]. x, y = 0, 1 while x <= b: if x >= a and is_prime(x): return x x, y = y, x + y return -1"},{"question":"def trap(height: List[int]) -> int: Calculate the amount of rainwater trapped after raining. :param height: List of non-negative integers representing the heights of elevation levels. :return: Integer representing the amount of rainwater trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([5]) 0 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([1, 0, 2, 0, 1]) 2","solution":"def trap(height): Calculate the amount of rainwater trapped after raining. :param height: List of non-negative integers representing the heights of elevation levels. :return: Integer representing the amount of rainwater trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def find_single(nums: List[int]) -> int: Finds the element that appears exactly once in the array where every other element appears twice. Args: nums (List[int]): List of integers where every element except one appears exactly twice. Returns: int: The single element that appears exactly once. >>> find_single([4, 1, 2, 1, 2]) 4 >>> find_single([2, 2, 1]) 1 Unit Test: from solution import find_single def test_find_single_example1(): assert find_single([4, 1, 2, 1, 2]) == 4 def test_find_single_example2(): assert find_single([2, 2, 1]) == 1 def test_find_single_single_element(): assert find_single([1]) == 1 def test_find_single_larger_case(): assert find_single([1, 1, 2, 2, 3, 3, 4]) == 4 def test_find_single_another_case(): assert find_single([11, 22, 22, 11, 33, 33, 44, 55, 44]) == 55","solution":"def find_single(nums): Finds the element that appears exactly once in the array where every other element appears twice. Args: nums (List[int]): List of integers where every element except one appears exactly twice. Returns: int: The single element that appears exactly once. single = 0 for num in nums: single ^= num return single"},{"question":"def generate_triangle_patterns(test_cases: List[int]) -> List[str]: Given a list of integer test cases, generate a list of triangle patterns. >>> generate_triangle_patterns([2, 3, 4]) ['*n**', '*n**n***', '*n**n***n****'] >>> generate_triangle_patterns([1]) ['*'] >>> generate_triangle_patterns([50]) ['*n**n***n****n*****n******n*******n********n*********n**********n***********n************n*************n**************n***************n****************n*****************n******************n*******************n********************n*********************n**********************n***********************n************************n*************************n**************************n***************************n****************************n*****************************n******************************n*******************************n********************************n*********************************n**********************************n***********************************n************************************n*************************************n**************************************n***************************************n****************************************n*****************************************n******************************************n*******************************************n********************************************n*********************************************n**********************************************n***********************************************n************************************************n'] def process_triangle_patterns(input_string: str) -> str: Process the input and output in the correct format. >>> process_triangle_patterns(\\"3n2n3n4\\") '*n**nn*n**n***nn*n**n***n****' >>> process_triangle_patterns(\\"1n5\\") '*n**n***n****n*****' >>> process_triangle_patterns(\\"2n1n2\\") '*nn*n**'","solution":"def generate_triangle_patterns(test_cases): Given a list of integer test cases, generate a list of triangle patterns. Args: test_cases: List[int] - A list of integers. Returns: List[str] - A list of strings, where each string represents a triangle pattern separated by newline characters. results = [] for n in test_cases: pattern = [] for i in range(1, n + 1): pattern.append('*' * i) results.append('n'.join(pattern)) return results # Function to process the input and output in the correct format def process_triangle_patterns(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [int(input_lines[i]) for i in range(1, T + 1)] patterns = generate_triangle_patterns(test_cases) return 'nn'.join(patterns)"},{"question":"from typing import Dict, List, Union def manage_employees(departments: Dict[str, List[Dict[str, Union[int, str, float]]]], operations: List[Dict[str, Union[str, int, float]]]) -> List[Union[List[Dict[str, Union[int, str, float]]], float, Dict[str, Union[int, str, float]]]]: A company has multiple departments, each with its own list of employees. Each employee has a unique ID, a name, and a salary. The company administration wants to implement a system that will allow them to manage employee information and calculate statistics about their employees' salaries. The function performs the following tasks: 1. Adds a new employee to a specified department. 2. Removes an employee from a specified department. 3. Retrieves the list of all employees in a specified department. 4. Calculates the average salary in a specified department. 5. Retrieves the employee with the highest salary in a specified department. 6. Retrieves the employee with the lowest salary in a specified department. :param departments: Dictionary of departments with lists of employees :param operations: List of operations to perform on the departments :return: List of results for each operation >>> departments = { ... \\"HR\\": [ ... {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"salary\\": 50000}, ... {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"salary\\": 60000} ... ], ... \\"Engineering\\": [ ... {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"salary\\": 70000} ... ] ... } >>> operations = [ ... {\\"operation\\": \\"add\\", \\"department\\": \\"HR\\", \\"id\\": 4, \\"name\\": \\"David\\", \\"salary\\": 55000}, ... {\\"operation\\": \\"remove\\", \\"department\\": \\"Engineering\\", \\"id\\": 3}, ... {\\"operation\\": \\"list\\", \\"department\\": \\"HR\\"}, ... {\\"operation\\": \\"average\\", \\"department\\": \\"HR\\"}, ... {\\"operation\\": \\"max\\", \\"department\\": \\"HR\\"}, ... {\\"operation\\": \\"min\\", \\"department\\": \\"HR\\"} ... ] >>> manage_employees(departments, operations) [[], [], [{'id': 1, 'name': 'Alice', 'salary': 50000}, {'id': 2, 'name': 'Bob', 'salary': 60000}, {'id': 4, 'name': 'David', 'salary': 55000}], 55000.0, {'id': 2, 'name': 'Bob', 'salary': 60000}, {'id': 1, 'name': 'Alice', 'salary': 50000}]","solution":"from typing import Dict, List, Union def manage_employees(departments: Dict[str, List[Dict[str, Union[int, str, float]]]], operations: List[Dict[str, Union[str, int, float]]]) -> List[Union[List[Dict[str, Union[int, str, float]]], float, Dict[str, Union[int, str, float]]]]: results = [] for operation in operations: if operation[\\"operation\\"] == \\"add\\": departments[operation[\\"department\\"]].append({ \\"id\\": operation[\\"id\\"], \\"name\\": operation[\\"name\\"], \\"salary\\": operation[\\"salary\\"] }) results.append([]) elif operation[\\"operation\\"] == \\"remove\\": department = departments[operation[\\"department\\"]] departments[operation[\\"department\\"]] = [emp for emp in department if emp[\\"id\\"] != operation[\\"id\\"]] results.append([]) elif operation[\\"operation\\"] == \\"list\\": department = departments[operation[\\"department\\"]] sorted_dept = sorted(department, key=lambda x: x[\\"id\\"]) results.append(sorted_dept) elif operation[\\"operation\\"] == \\"average\\": department = departments[operation[\\"department\\"]] avg_salary = sum(emp[\\"salary\\"] for emp in department) / len(department) results.append(avg_salary) elif operation[\\"operation\\"] == \\"max\\": department = departments[operation[\\"department\\"]] max_salary_emp = max(department, key=lambda x: x[\\"salary\\"]) results.append(max_salary_emp) elif operation[\\"operation\\"] == \\"min\\": department = departments[operation[\\"department\\"]] min_salary_emp = min(department, key=lambda x: x[\\"salary\\"]) results.append(min_salary_emp) return results"},{"question":"def count_vowel_titles(titles: List[str]) -> int: Counts the number of titles that start with a vowel (A, E, I, O, U). >>> count_vowel_titles([\\"Ender's Game\\", \\"The Hobbit\\", \\"Othello\\", \\"anna karenina\\", \\"1984\\"]) == 3 >>> count_vowel_titles([\\"Gone with the Wind\\", \\"Pride and Prejudice\\", \\"To Kill a Mockingbird\\"]) == 2 >>> count_vowel_titles([\\"The Catcher in the Rye\\", \\"the great gatsby\\", \\"Moby Dick\\"]) == 0 >>> count_vowel_titles([]) == 0 >>> count_vowel_titles([\\"\\"]) == 0","solution":"def count_vowel_titles(titles): Counts the number of titles that start with a vowel (A, E, I, O, U). Args: titles (list of str): List of book titles. Returns: int: Number of titles starting with a vowel. vowels = \\"AEIOUaeiou\\" count = 0 for title in titles: if title and title[0] in vowels: count += 1 return count"},{"question":"def num_ways_to_climb(N: int) -> int: Returns the number of ways to climb a staircase of N steps if you can only take 1 or 2 steps at a time. >>> num_ways_to_climb(0) 1 >>> num_ways_to_climb(1) 1 >>> num_ways_to_climb(2) 2 >>> num_ways_to_climb(3) 3 >>> num_ways_to_climb(5) 8 >>> num_ways_to_climb(10) 89 >>> num_ways_to_climb(20) 10946 >>> num_ways_to_climb(30) 1346269","solution":"def num_ways_to_climb(N): Returns the number of ways to climb a staircase of N steps if you can only take 1 or 2 steps at a time. if N == 0: return 1 if N == 1: return 1 ways = [0] * (N + 1) ways[0] = 1 ways[1] = 1 for i in range(2, N + 1): ways[i] = ways[i - 1] + ways[i - 2] return ways[N]"},{"question":"from typing import List def sort_even_before_odd(nums: List[int]) -> List[int]: Returns a list of integers sorted in non-decreasing order, with all even numbers appearing before any odd numbers. The relative order among even numbers and among odd numbers is preserved. >>> sort_even_before_odd([3, 1, 2, 4]) [2, 4, 3, 1] >>> sort_even_before_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_even_before_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> sort_even_before_odd([]) [] >>> sort_even_before_odd([2]) [2] >>> sort_even_before_odd([1]) [1] >>> sort_even_before_odd([2, 4, 1, 3]) [2, 4, 1, 3] >>> sort_even_before_odd([1, 3, 5, 7, 9]) [1, 3, 5, 7, 9] >>> sort_even_before_odd([2, 4, 6, 8, 10]) [2, 4, 6, 8, 10] >>> sort_even_before_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 4, 6, 8, 10, 1, 3, 5, 7, 9]","solution":"def sort_even_before_odd(nums): Returns a list of integers sorted in non-decreasing order, with all even numbers appearing before any odd numbers. The relative order among even numbers and among odd numbers is preserved. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def min_transformations(s: str) -> int: Determines the minimum number of transformations needed to make the string a palindrome. :param s: A string consisting of characters 'a' and 'b' only. :return: The minimum number of transformations required. >>> min_transformations(\\"ab\\") 1 >>> min_transformations(\\"abbba\\") 0 >>> min_transformations(\\"aab\\") 1","solution":"def min_transformations(s): Determines the minimum number of transformations needed to make the string a palindrome. :param s: A string consisting of characters 'a' and 'b' only. :return: The minimum number of transformations required. n = len(s) transformations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: transformations += 1 return transformations"},{"question":"def unique_notifications(user_preferences, events): Determines the total number of unique notifications each user receives based on their preferences. :param user_preferences: List of sets containing preferences of each user :param events: List of event strings :return: List of integers representing the number of unique notifications for each user >>> unique_notifications([{'login', 'purchase', 'logout'}, {'comment', 'share'}], ['login', 'logout', 'login', 'purchase', 'login', 'comment']) [3, 1] >>> unique_notifications([{'login', 'logout'}, {'purchase', 'comment', 'share'}, {'like', 'login'}], ['login', 'purchase', 'like', 'share', 'comment', 'logout', 'like']) [2, 3, 2] >>> unique_notifications([{'msg', 'email'}, {'follow', 'unfollow'}, {'login'}], ['msg', 'email', 'login', 'follow']) [2, 1, 1] def process_input(n, user_data, k, event_data): Processes input data for unique_notifications function. :param n: Number of users :param user_data: List containing user preference data :param k: Number of events :param event_data: List containing event strings :return: Output of unique_notifications function >>> process_input(2, ['3', 'login', 'purchase', 'logout', '2', 'comment', 'share'], 6, ['login', 'logout', 'login', 'purchase', 'login', 'comment']) [3, 1]","solution":"def unique_notifications(user_preferences, events): Determines the total number of unique notifications each user receives based on their preferences. :param user_preferences: List of sets containing preferences of each user :param events: List of event strings :return: List of integers representing the number of unique notifications for each user unique_events = set(events) notifications = [] for preferences in user_preferences: notification_count = len(preferences.intersection(unique_events)) notifications.append(notification_count) return notifications def process_input(n, user_data, k, event_data): user_preferences = [] index = 0 for _ in range(n): m = int(user_data[index]) preferences = set(user_data[index + 1: index + 1 + m]) user_preferences.append(preferences) index += 1 + m events = event_data return unique_notifications(user_preferences, events)"},{"question":"def find_leaders(arr: List[int]) -> List[int]: Given an array of integers, return an array consisting of all the leaders in the array. An element is a leader if it is greater than all the elements to its right side in the array. The rightmost element is always a leader. >>> find_leaders([16, 17, 4, 3, 5, 2]) [17, 5, 2] >>> find_leaders([1, 2, 3, 4, 0]) [4, 0]","solution":"def find_leaders(arr): Finds all the leaders in the array. A leader is an element that is greater than all elements to its right. The rightmost element is always considered a leader. if not arr: return [] n = len(arr) leaders = [arr[-1]] # The rightmost element is always a leader max_from_right = arr[-1] # Traverse the array from right to left for i in range(n-2, -1, -1): if arr[i] > max_from_right: leaders.append(arr[i]) max_from_right = arr[i] # Since leaders are collected in reverse order, we reverse the list return leaders[::-1]"},{"question":"from typing import List def untangle_list(arr: List[int]) -> List[int]: Given an integer array \`arr\`, return a new array containing the prime numbers from the input array followed by the non-prime numbers, both groups sorted in ascending order. >>> untangle_list([11, 4, 6, 7, 9, 10, 5]) [5, 7, 11, 4, 6, 9, 10] >>> untangle_list([29, 15, 14, 23, 8, 3]) [3, 23, 29, 8, 14, 15] >>> untangle_list([]) [] >>> untangle_list([8, 10, 12, 4, 6]) [4, 6, 8, 10, 12] >>> untangle_list([19, 2, 17, 11, 5]) [2, 5, 11, 17, 19]","solution":"from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def untangle_list(arr: List[int]) -> List[int]: Returns a new array containing the prime numbers from the input array followed by the non-prime numbers, both groups sorted in ascending order. primes = [] non_primes = [] for num in arr: if is_prime(num): primes.append(num) else: non_primes.append(num) primes.sort() non_primes.sort() return primes + non_primes"},{"question":"def find_unique_element(arr): Finds the element that appears only once in the array where all other elements appear exactly twice. >>> find_unique_element([4, 1, 2, 1, 2]) 4 >>> find_unique_element([2, 2, 3, 3, 5]) 5 >>> find_unique_element([7, 3, 3, 2, 2]) 7 >>> find_unique_element([-1, -1, -2]) -2 >>> find_unique_element([10]) 10 >>> find_unique_element([9, 7, 7, 9, 5, 5, 4]) 4 >>> find_unique_element([10, 8, 10, 6, 6]) 8 >>> find_unique_element([1, -3, 1, -1, -3, -1, 4]) 4","solution":"def find_unique_element(arr): Finds the element that appears only once in the array where all other elements appear exactly twice. The solution uses XOR to achieve this with linear runtime and constant space complexity. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def highest_product_of_three(nums): Determine the highest possible product of any three distinct integers from an input list. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([10, 10, 10]) 1000 >>> highest_product_of_three([-10, -10, 1, 3, 2]) 300 >>> highest_product_of_three([-1, -2, -3, -4, -5]) -6","solution":"def highest_product_of_three(nums): nums = sorted(nums) # Sort the input list # Calculating the product of highest three numbers max_product_1 = nums[-1] * nums[-2] * nums[-3] # Calculating the product of two smallest (negative, if any) and the largest number max_product_2 = nums[0] * nums[1] * nums[-1] return max(max_product_1, max_product_2)"},{"question":"def filter_palindromes(strings: List[str]) -> List[str]: Returns a list of strings that are palindromes. >>> filter_palindromes([\\"madam\\", \\"racecar\\", \\"level\\"]) [\\"madam\\", \\"racecar\\", \\"level\\"] >>> filter_palindromes([\\"hello\\", \\"world\\", \\"python\\"]) [] >>> filter_palindromes([\\"hello\\", \\"madam\\", \\"world\\", \\"racecar\\"]) [\\"madam\\", \\"racecar\\"] >>> filter_palindromes([]) [] >>> filter_palindromes([\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> filter_palindromes([\\"madam\\", \\"madam\\", \\"hello\\"]) [\\"madam\\", \\"madam\\"] >>> filter_palindromes([\\"abcd\\", \\"efgh\\"]) []","solution":"def filter_palindromes(strings): Returns a list of strings that are palindromes. return [string for string in strings if string == string[::-1]]"},{"question":"def can_attend_all_meetings(intervals: List[List[int]]) -> bool: Determines if a person can attend all meetings given the intervals. >>> can_attend_all_meetings([[0, 30], [5, 10], [15, 20]]) False >>> can_attend_all_meetings([[7, 10], [2, 4]]) True","solution":"def can_attend_all_meetings(intervals): Determines if a person can attend all meetings given the intervals. Args: intervals (List[List[int]]): A list of meeting time intervals. Returns: bool: True if a person can attend all meetings, False otherwise. intervals.sort(key=lambda x: x[0]) # Sort intervals by start time for i in range(1, len(intervals)): if intervals[i][0] < intervals[i - 1][1]: # Check for overlap return False return True"},{"question":"from typing import List def partition_labels(s: str) -> List[int]: Write a function \`partition_labels(s)\` that takes a string \`s\` and returns a list of integers representing the lengths of partitions such that each letter appears in at most one part. The partitions are determined by finding the farthest occurrence of each letter in the string and ensuring that each partition extends up to the farthest occurrence of any character in that partition. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abcdefg\\") [1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaaaa\\") [7] >>> partition_labels(\\"eccbbbbdec\\") [10] >>> partition_labels(\\"abcdddab\\") [8] >>> partition_labels(\\"\\") [] >>> partition_labels(\\"aaabbbccc\\") [3, 3, 3]","solution":"def partition_labels(s): Given a string s, partitions it such that each letter appears in at most one part. Returns a list of integers representing the lengths of partitions. # Find the last occurrence of each character in the string last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start = 0 end = 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) # When we reach the end of the current partition if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"def find_two_sum_indices(arr, target): Finds two indices of distinct integers in the array whose sum is equal to the target. :param arr: List of integers :param target: Target integer sum :return: List containing the indices of the two integers whose sum is equal to the target. If no such pair exists, returns an empty list. def process_test_cases(test_cases): Processes multiple test cases to find pairs of indices whose elements sum to the target. :param test_cases: A list of tuples, each tuple contains (n, array, target) :return: A list of results where each result is a list of indices or an empty list. if __name__ == \\"__main__\\": test_find_two_sum_indices() test_process_test_cases() def test_find_two_sum_indices(): assert find_two_sum_indices([2, 7, 11, 15, -3], 9) == [0, 1] or find_two_sum_indices([2, 7, 11, 15, -3], 9) == [1, 0] assert find_two_sum_indices([1, 2, 3, 4], 8) == [] assert find_two_sum_indices([1, 1, 1], 2) == [0, 1] or find_two_sum_indices([1, 1, 1], 2) == [0, 2] or find_two_sum_indices([1, 1, 1], 2) == [1, 2] def test_process_test_cases(): test_cases = [ (5, [2, 7, 11, 15, -3], 9), (4, [1, 2, 3, 4], 8), (3, [1, 1, 1], 2) ] results = process_test_cases(test_cases) assert results == [[0, 1], [], [0, 1]] or results == [[0, 1], [], [0, 2]] or results == [[0, 1], [], [1, 2]] or results == [[1, 0], [], [0, 1]] or results == [[1, 0], [], [0, 2]] or results == [[1, 0], [], [1, 2]]","solution":"def find_two_sum_indices(arr, target): Finds two indices of distinct integers in the array whose sum is equal to the target. :param arr: List of integers :param target: Target integer sum :return: List containing the indices of the two integers whose sum is equal to the target. If no such pair exists, returns an empty list. index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: return [index_map[complement], i] index_map[num] = i return [] def process_test_cases(test_cases): Processes multiple test cases to find pairs of indices whose elements sum to the target. :param test_cases: A list of tuples, each tuple contains (n, array, target) :return: A list of results where each result is a list of indices or an empty list. results = [] for n, array, target in test_cases: results.append(find_two_sum_indices(array, target)) return results"},{"question":"def longest_word_length(sentence: str) -> int: Write a function that takes a string containing a sentence and returns the length of the longest word in the sentence. If there are multiple words with the same length, return the length of the first one that appears. >>> longest_word_length(\\"hello\\") == 5 >>> longest_word_length(\\"The quick brown fox\\") == 5 >>> longest_word_length(\\"Jumped over the lazy dog\\") == 6 >>> longest_word_length(\\"I am very fine\\") == 4 >>> longest_word_length(\\"\\") == 0 >>> longest_word_length(\\"A B C\\") == 1","solution":"def longest_word_length(sentence): Returns the length of the longest word in the given sentence. If there are multiple words with the same length, returns the length of the first one that appears. :param sentence: str - A string containing a sentence. :return: int - The length of the longest word. words = sentence.split() max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) return max_length"},{"question":"def create_matrix(n: int) -> List[List[int]]: Create a square matrix of size n with the specified pattern. The matrix should have its main diagonal filled with ones, and every element to the right of the main diagonal should also be one. All other elements in the matrix should be zero. Parameters: n (int): Size of the matrix Returns: list of list of int: n x n matrix with the pattern >>> create_matrix(1) [[1]] >>> create_matrix(2) [[1, 1], [0, 1]] >>> create_matrix(3) [[1, 1, 1], [0, 1, 1], [0, 0, 1]] >>> create_matrix(4) [[1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]]","solution":"def create_matrix(n): Create a square matrix of size n with the specified pattern. Parameters: n (int): Size of the matrix Returns: list of list of int: n x n matrix with the pattern matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(i, n): matrix[i][j] = 1 return matrix"},{"question":"def count_palindromes(words: List[str]) -> int: Returns the number of palindromes in a list of words. A palindrome is a word that reads the same backward as forward. >>> count_palindromes([\\"racecar\\", \\"level\\", \\"world\\", \\"madam\\", \\"python\\"]) 3 >>> count_palindromes([\\"world\\"]) 0","solution":"def count_palindromes(words): Returns the number of palindromes in a list of words. A palindrome is a word that reads the same backward as forward. count = 0 for word in words: if word == word[::-1]: count += 1 return count"},{"question":"def closest_rectangle_dimensions(T: int, test_cases: List[int]) -> List[Tuple[int, int]]: Returns the dimensions of the rectangular enclosure with minimum difference between length and width for each area in test_cases. >>> closest_rectangle_dimensions(2, [15, 16]) [(5, 3), (4, 4)] >>> closest_rectangle_dimensions(3, [10, 20, 7]) [(5, 2), (5, 4), (7, 1)] from typing import List, Tuple def test_closest_rectangle_dimensions_simple(): T = 2 test_cases = [15, 16] assert closest_rectangle_dimensions(T, test_cases) == [(5, 3), (4, 4)] def test_closest_rectangle_dimensions_additional(): T = 3 test_cases = [10, 20, 7] assert closest_rectangle_dimensions(T, test_cases) == [(5, 2), (5, 4), (7, 1)] def test_closest_rectangle_dimensions_edge_cases(): T = 2 test_cases = [1, 1000000] assert closest_rectangle_dimensions(T, test_cases) == [(1, 1), (1000, 1000)] def test_closest_rectangle_dimensions_same_width_length(): T = 1 test_cases = [25] assert closest_rectangle_dimensions(T, test_cases) == [(5, 5)]","solution":"def closest_rectangle_dimensions(T, test_cases): Returns the dimensions of the rectangular enclosure with minimum difference between length and width for each area in test_cases. results = [] for M in test_cases: min_diff = float('inf') best_length = 0 best_width = 0 for W in range(1, int(M**0.5) + 1): if M % W == 0: L = M // W if L >= W and (L - W < min_diff): min_diff = L - W best_length = L best_width = W results.append((best_length, best_width)) return results # Example execution T = 2 test_cases = [15, 16] print(closest_rectangle_dimensions(T, test_cases)) # [(5, 3), (4, 4)]"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given a 2D grid of characters and a word, checks whether the word can be constructed from sequentially adjacent cells in the grid, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCCED\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"SEE\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCB\\") False from solution import exist def test_word_found_in_grid(): grid = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = \\"ABCCED\\" assert exist(grid, word) == True def test_word_found_in_grid_case_2(): grid = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = \\"SEE\\" assert exist(grid, word) == True def test_word_not_found_in_grid(): grid = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] word = \\"ABCB\\" assert exist(grid, word) == False def test_empty_word(): grid = [['A','B'], ['C','D']] word = \\"\\" assert exist(grid, word) == False def test_single_letter_word_found(): grid = [['A']] word = \\"A\\" assert exist(grid, word) == True def test_single_letter_word_not_found(): grid = [['A']] word = \\"B\\" assert exist(grid, word) == False","solution":"def exist(board, word): if not board or not word: return False rows, cols = len(board), len(board[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or board[x][y] != word[index]: return False temp = board[x][y] board[x][y] = \\"#\\" found = (dfs(x-1, y, index+1) or dfs(x+1, y, index+1) or dfs(x, y-1, index+1) or dfs(x, y+1, index+1)) board[x][y] = temp return found for row in range(rows): for col in range(cols): if dfs(row, col, 0): return True return False"},{"question":"def min_coins_to_make_amount(n: int, m: int, coins: List[int]) -> int: This function returns the minimum number of coins required to make amount m using the available coins. If it's not possible, it returns -1. pass def process_test_cases(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: This function processes multiple test cases and returns the results for each case. Args: T : int : number of test cases test_cases : List[Tuple[Tuple[int, int], List[int]]] : list of test cases Returns: List[int] : list of results for each test case pass # Unit Tests def test_case_1(): assert process_test_cases(2, [ [(3, 11), [1, 2, 5]], [(4, 7), [2, 3, 5, 7]] ]) == [3, 1] def test_case_with_unavailable_amount(): assert process_test_cases(1, [ [(3, 4), [3, 5, 7]] ]) == [-1] def test_case_single_coin(): assert process_test_cases(1, [ [(1, 10), [2]] ]) == [5] def test_case_multiple_combinations(): assert process_test_cases(1, [ [(4, 7), [1, 3, 4, 5]] ]) == [2] def test_case_large_values(): assert process_test_cases(1, [ [(4, 1000), [1, 5, 10, 25]] ]) == [40]","solution":"def min_coins_to_make_amount(n, m, coins): This function returns the minimum number of coins required to make amount m using the available coins. If it's not possible, it returns -1. # Initialize the dp array with an amount larger than possible dp = [float('inf')] * (m + 1) dp[0] = 0 # Base case: 0 coins to make amount 0 for coin in coins: for x in range(coin, m + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[m] if dp[m] != float('inf') else -1 def process_test_cases(T, test_cases): results = [] for i in range(T): n, m = test_cases[i][0] coins = test_cases[i][1] results.append(min_coins_to_make_amount(n, m, coins)) return results"},{"question":"def filterAndCount(arr, k): Filters out elements from arr that are greater than k and returns the count of remaining elements. Returns -1 if arr is empty or k is not a positive integer. Parameters: arr (List[int]): An array of integers. k (int): An integer threshold. Returns: int: The count of elements in the filtered array or -1 for invalid input. >>> filterAndCount([1, 3, 5, 7, 9], 5) 3 >>> filterAndCount([10, 20, 30, 40], 25) 2 >>> filterAndCount([], 5) -1 >>> filterAndCount([1, 2, 3, 4], -5) -1","solution":"def filterAndCount(arr, k): Filters out elements from arr that are greater than k and returns the count of remaining elements. Returns -1 if arr is empty or k is not a positive integer. if not arr or not isinstance(k, int) or k <= 0: return -1 filtered_array = [x for x in arr if x <= k] return len(filtered_array)"},{"question":"def sum_primes(n: int) -> int: Returns the sum of all prime numbers less than n. >>> sum_primes(10) 17 >>> sum_primes(20) 77 >>> sum_primes(2) 0 >>> sum_primes(50) 328","solution":"def sum_primes(n): Returns the sum of all prime numbers less than n. if n <= 2: return 0 primes = [True] * n primes[0] = primes[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if primes[start]: for i in range(start*start, n, start): primes[i] = False return sum(i for i, prime in enumerate(primes) if prime)"},{"question":"def find_duplicates(nums: [int]) -> [int]: Finds all the integers that appear twice in the input list and returns them in ascending order. >> find_duplicates([4,3,2,7,8,2,3,1]) == [2,3] >> find_duplicates([1,1,2,3]) == [1] >> find_duplicates([2,2]) == [2] >> find_duplicates([1,2,3,4]) == [] >> find_duplicates([10,9,8,7,6,5,4,3,2,1]) == [] from solution import find_duplicates def test_find_duplicates_example_cases(): assert find_duplicates([4,3,2,7,8,2,3,1]) == [2, 3] assert find_duplicates([1,1,2,3]) == [1] assert find_duplicates([2,2]) == [2] assert find_duplicates([1,2,3,4]) == [] assert find_duplicates([10,9,8,7,6,5,4,3,2,1]) == [] def test_find_duplicates_all_unique(): assert find_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [] def test_find_duplicates_all_duplicates(): assert find_duplicates([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == [1, 2, 3, 4, 5] def test_find_duplicates_mixed_cases(): assert find_duplicates([1, 5, 3, 2, 4, 3, 2, 1]) == [1, 2, 3] assert find_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 8, 10]) == [8] def test_find_duplicates_large_input(): large_input = list(range(1, 100001)) + [99999, 100000] assert find_duplicates(large_input) == [99999, 100000]","solution":"def find_duplicates(nums): Returns a list of integers that appear twice in the input list. The output list is sorted in ascending order. duplicates = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: duplicates.append(abs(num)) nums[index] = -nums[index] duplicates.sort() return duplicates"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Find the Kth smallest element in an N x N sorted matrix. Parameters: - matrix: A list of N lists, each containing N sorted integers. - k: The position of the smallest element to find. Returns: - The Kth smallest element in the matrix. pass def test_example(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 5) == 11 def test_single_element_matrix(): matrix = [ [1] ] assert kth_smallest(matrix, 1) == 1 def test_two_by_two_matrix(): matrix = [ [1, 3], [2, 4] ] assert kth_smallest(matrix, 3) == 3 def test_larger_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert kth_smallest(matrix, 4) == 4 def test_another_example(): matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 6) == 12","solution":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Find the Kth smallest element in an N x N sorted matrix. Parameters: - matrix: A list of N lists, each containing N sorted integers. - k: The position of the smallest element to find. Returns: - The Kth smallest element in the matrix. N = len(matrix) min_heap = [] for r in range(min(N, k)): # Only need to consider the first k rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) count, number = 0, 0 while min_heap: number, r, c = heapq.heappop(min_heap) count += 1 if count == k: break if c + 1 < N: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) return number"},{"question":"def sumFib(N: int) -> int: Calculates the sum of the first N Fibonacci numbers. Parameters: N (int): The number of Fibonacci numbers to sum. Returns: int: The sum of the first N Fibonacci numbers. pass # Unit Tests def test_sumFib_5(): assert sumFib(5) == 7, \\"Test case 1 failed\\" def test_sumFib_7(): assert sumFib(7) == 20, \\"Test case 2 failed\\" def test_sumFib_10(): assert sumFib(10) == 88, \\"Test case 3 failed\\" def test_sumFib_1(): assert sumFib(1) == 0, \\"Test case 4 failed\\" def test_sumFib_2(): assert sumFib(2) == 1, \\"Test case 5 failed\\"","solution":"def sumFib(N): Calculates the sum of the first N Fibonacci numbers. Parameters: N (int): The number of Fibonacci numbers to sum. Returns: int: The sum of the first N Fibonacci numbers. if N <= 0: return 0 fib_nums = [0, 1] for i in range(2, N): next_fib = fib_nums[-1] + fib_nums[-2] fib_nums.append(next_fib) return sum(fib_nums[:N])"},{"question":"def longest_subarray_with_sum_at_most_k(n: int, arr: List[int], k: int) -> int: Finds the length of the longest subarray with a sum less than or equal to k. Parameters: n (int): Length of the array arr (list of int): Array of integers k (int): Upper limit for the subarray sum Returns: int: Length of the longest subarray with sum <= k >>> longest_subarray_with_sum_at_most_k(5, [1, 2, 3, 4, 5], 9) == 3 >>> longest_subarray_with_sum_at_most_k(5, [2, 1, 5, 1, 3], 4) == 2 >>> longest_subarray_with_sum_at_most_k(1, [5], 5) == 1 >>> longest_subarray_with_sum_at_most_k(1, [6], 5) == 0 >>> longest_subarray_with_sum_at_most_k(4, [1, 2, 3, 2], 10) == 4 >>> longest_subarray_with_sum_at_most_k(0, [], 5) == 0 >>> longest_subarray_with_sum_at_most_k(3, [1, 2, 3], 1000) == 3","solution":"def longest_subarray_with_sum_at_most_k(n, arr, k): Finds the length of the longest subarray with a sum less than or equal to k. Parameters: n (int): Length of the array arr (list of int): Array of integers k (int): Upper limit for the subarray sum Returns: int: Length of the longest subarray with sum <= k current_sum = 0 start = 0 max_length = 0 for end in range(n): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 if current_sum <= k: max_length = max(max_length, end - start + 1) return max_length"},{"question":"import re from typing import List def check_palindromes(strings: List[str]) -> List[bool]: Returns a list of booleans indicating whether the respective strings are palindromes after transformation. >>> check_palindromes([\\"A man, a plan, a canal: Panama\\", \\"race a car\\", \\"No 'x' in Nixon\\"]) [True, False, True] >>> check_palindromes([\\"12321\\", \\"123456\\"]) [True, False]","solution":"import re def check_palindromes(strings): Returns a list of booleans indicating whether the respective strings are palindromes after transformation. results = [] for s in strings: # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is a palindrome results.append(cleaned == cleaned[::-1]) return results"},{"question":"def find_nth_in_series(n: int) -> int: Returns the n-th number in the series: 1, 3, 6, 8, 11, 13, ... The series is constructed by starting with 1 and alternating between adding 2 and 3 to the previous number. >>> find_nth_in_series(1) 1 >>> find_nth_in_series(2) 3 >>> find_nth_in_series(3) 6 >>> find_nth_in_series(4) 8","solution":"def find_nth_in_series(n): Returns the n-th number in the series: 1, 3, 6, 8, 11, 13, ... if n <= 0: raise ValueError(\\"The input should be a positive integer.\\") series = [1] add_2 = True for _ in range(1, n): if add_2: series.append(series[-1] + 2) else: series.append(series[-1] + 3) add_2 = not add_2 return series[n-1]"},{"question":"def summation_sequence(test_cases: List[int]) -> List[str]: Compute the summation sequence for each test case. Args: test_cases (List[int]): List of integers representing test cases. Returns: List[str]: A list of strings where each string is a sequence followed by its sum in parentheses. >>> summation_sequence([3]) [\\"1 2 (3)\\"] >>> summation_sequence([6]) [\\"1 2 3 (6)\\"] >>> summation_sequence([11]) [\\"1 2 3 4 5 (15)\\"] >>> summation_sequence([1]) [\\"1 (1)\\"] >>> summation_sequence([3, 6, 11, 1]) [\\"1 2 (3)\\", \\"1 2 3 (6)\\", \\"1 2 3 4 5 (15)\\", \\"1 (1)\\"]","solution":"def summation_sequence(test_cases): results = [] for X in test_cases: summation = 0 sequence = [] S = 1 while summation < X: summation += S sequence.append(S) S += 1 result = \\" \\".join(map(str, sequence)) + f\\" ({summation})\\" results.append(result) return results"},{"question":"def pairwise_adder(lst): Implement a function \`pairwise_adder\` that takes a list of numbers and returns a new list containing the pairwise sums of the original list. Each element of the new list should be a sum of two consecutive elements from the input list. If the input list has fewer than two elements, return an empty list. >>> pairwise_adder([1, 2, 3, 4]) [3, 5, 7] >>> pairwise_adder([10, -2, 3]) [8, 1] >>> pairwise_adder([5]) [] >>> pairwise_adder([]) [] # Your code here pass","solution":"def pairwise_adder(lst): Returns a new list containing the pairwise sums of the original list. Each element of the new list is a sum of two consecutive elements from the input list. if len(lst) < 2: return [] return [lst[i] + lst[i + 1] for i in range(len(lst) - 1)]"},{"question":"def sum_of_multiples(n): Returns the sum of all multiples of 3 or 5 that are less than n. >>> sum_of_multiples(10) 23 >>> sum_of_multiples(20) 78 >>> sum_of_multiples(0) 0 >>> sum_of_multiples(1) 0 >>> sum_of_multiples(100) 2318","solution":"def sum_of_multiples(n): Returns the sum of all multiples of 3 or 5 that are less than n. total = 0 for i in range(1, n): if (i % 3 == 0) or (i % 5 == 0): total += i return total"},{"question":"import fnmatch from typing import List def matches_patterns(filenames: List[str], patterns: List[str]) -> List[str]: Determine for each pattern if there is any filename from the email list that matches the pattern. Wildcard '?' matches exactly one character while '*' matches zero or more characters of any type. >>> matches_patterns([\\"file1.txt\\", \\"backup.docx\\", \\"report2023.pdf\\"], [\\"*.txt\\", \\"f?le?.*\\"]) [\\"YES\\", \\"NO\\"] >>> matches_patterns([\\"file1.txt\\", \\"backup.docx\\", \\"report2023.pdf\\"], [\\"*.doc\\", \\"*.xls\\"]) [\\"NO\\", \\"NO\\"] >>> matches_patterns([\\"file1.txt\\", \\"backup.docx\\", \\"report2023.pdf\\"], [\\"file?.txt\\", \\"r??ort2023.pdf\\"]) [\\"YES\\", \\"YES\\"] >>> matches_patterns([\\"file1.txt\\", \\"backup.docx\\", \\"report2023.pdf\\"], [\\"*.pdf\\"]) [\\"YES\\"]","solution":"import fnmatch def matches_patterns(filenames, patterns): results = [] for pattern in patterns: matched = any(fnmatch.fnmatch(filename, pattern) for filename in filenames) results.append(\\"YES\\" if matched else \\"NO\\") return results def solve(test_cases): results = [] for case in test_cases: filenames, patterns = case case_result = matches_patterns(filenames, patterns) results.append(case_result) return results # Example to process the provided input and call the solution function def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) filenames = [input_lines[index + i + 1] for i in range(n)] index += n + 1 m = int(input_lines[index]) patterns = [input_lines[index + i + 1] for i in range(m)] index += m + 1 test_cases.append((filenames, patterns)) results = solve(test_cases) for case_result in results: for result in case_result: print(result) # Code for taking input from the user if needed if __name__ == \\"__main__\\": input_data = 1 3 file1.txt backup.docx report2023.pdf 2 *.txt f?le?.* process_input(input_data)"},{"question":"def can_form_palindrome(s: str) -> bool: Write a function that takes a scrambled string and determines whether it can be rearranged to form a palindrome. A palindrome is a word or phrase that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). The function should return True if the string can be rearranged to form a palindrome and False otherwise. >>> can_form_palindrome(\\"Tact Coa\\") == True >>> can_form_palindrome(\\"Hello\\") == False >>> can_form_palindrome(\\"a\\") == True >>> can_form_palindrome(\\"\\") == True >>> can_form_palindrome(\\"abba\\") == True >>> can_form_palindrome(\\"aba\\") == True >>> can_form_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> can_form_palindrome(\\"aaaa\\") == True >>> can_form_palindrome(\\"madam\\") == True","solution":"def can_form_palindrome(s): Determines if a scrambled string can be rearranged to form a palindrome. # Normalize the string: remove non-alphabetic characters and convert to lowercase normalized_s = ''.join(char.lower() for char in s if char.isalpha()) # Count the occurrence of each character char_count = {} for char in normalized_s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to form a palindrome, there must be at most one character with an odd count return odd_count <= 1"},{"question":"def max_pieces(rods: list, k: int) -> int: Given an array of integers representing the lengths of rods and an integer representing the specific length of each piece, find the maximum number of pieces of length k that can be obtained by cutting up the rods. >>> max_pieces([10, 15, 20], 5) 9 >>> max_pieces([14], 3) 4 >>> max_pieces([8, 7, 6], 10) 0 >>> max_pieces([6, 12, 18], 6) 6 >>> max_pieces([1000000000, 1000000000], 1000000000) 2","solution":"def max_pieces(rods: list, k: int) -> int: Returns the maximum number of pieces of length k that can be obtained by cutting the rods. if k <= 0: raise ValueError(\\"k should be a positive integer\\") total_pieces = sum(rod // k for rod in rods) return total_pieces"},{"question":"from typing import Dict def lengthOfLongestSubstring(s: str) -> int: Given a string \`s\`, return the length of the longest substring without repeating characters. The function should return an integer representing the length of the longest substring with all unique characters. >>> lengthOfLongestSubstring(\\"\\") == 0 >>> lengthOfLongestSubstring(\\"a\\") == 1 >>> lengthOfLongestSubstring(\\"abcdef\\") == 6 >>> lengthOfLongestSubstring(\\"abcabcbb\\") == 3 >>> lengthOfLongestSubstring(\\"bbbbb\\") == 1 >>> lengthOfLongestSubstring(\\"pwwkew\\") == 3 >>> lengthOfLongestSubstring(\\"!@#!@!\\") == 3 >>> lengthOfLongestSubstring(\\"aA1bB2cC3\\") == 9 >>> lengthOfLongestSubstring(\\"a\\" * 10000) == 1","solution":"def lengthOfLongestSubstring(s): Returns the length of the longest substring without repeating characters. char_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> dict: Merges two dictionaries. If a key exists in both dictionaries, the value from the second dictionary is used. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing key-value pairs from both dictionaries. >>> merge_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': 3, 'c': 4} >>> merge_dicts({}, {'a': 1}) {'a': 1} >>> merge_dicts({'a': {'nested': 1}}, {'a': {'nested': 2}}) {'a': {'nested': 2}}","solution":"def merge_dicts(dict1, dict2): Merges two dictionaries. If a key exists in both dictionaries, the value from the second dictionary is used. Args: dict1 (dict): The first dictionary. dict2 (dict): The second dictionary. Returns: dict: A new dictionary containing key-value pairs from both dictionaries. merged_dict = dict1.copy() # Make a copy of the first dictionary merged_dict.update(dict2) # Update the copy with key-value pairs from the second dictionary return merged_dict"},{"question":"def smallest_substring_with_all_distinct_chars(s: str) -> int: Returns the length of the smallest contiguous substring that contains all distinct characters of the input string. >>> smallest_substring_with_all_distinct_chars(\\"abcabcbb\\") == 3 >>> smallest_substring_with_all_distinct_chars(\\"aaaa\\") == 1 >>> smallest_substring_with_all_distinct_chars(\\"abcd\\") == 4 >>> smallest_substring_with_all_distinct_chars(\\"bbbbbbb\\") == 1 >>> smallest_substring_with_all_distinct_chars(\\"aabcbcdbca\\") == 4 >>> smallest_substring_with_all_distinct_chars(\\"abababab\\") == 2 >>> smallest_substring_with_all_distinct_chars(\\"aabbccabc\\") == 3","solution":"def smallest_substring_with_all_distinct_chars(s): Returns the length of the smallest contiguous substring that contains all distinct characters of the input string. distinct_chars = set(s) total_distinct = len(distinct_chars) n = len(s) min_length = float('inf') left = 0 char_count = {} for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == total_distinct: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length"},{"question":"def min_largest_sum(nums: List[int], k: int) -> int: Partition the integer array 'nums' into 'k' non-empty contiguous subarrays such that the sum of the maximum sum of these subarrays is minimized. Return the minimum value of the largest sum among these 'k' subarrays. >>> min_largest_sum([7,2,5,10,8], 2) 18 >>> min_largest_sum([1,2,3,4,5], 2) 9 >>> min_largest_sum([1,4,4], 3) 4","solution":"def min_largest_sum(nums, k): def can_partition(nums, k, max_sum): current_sum = 0 subarray_count = 1 # At least one subarray needs to exist for num in nums: current_sum += num if current_sum > max_sum: subarray_count += 1 current_sum = num if subarray_count > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def longest_palindromic_subsequence(S: str) -> int: Returns the length of the largest palindromic subsequence in the given string S. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcd\\") 1 pass def solve(test_cases: List[str]) -> List[int]: For a list of strings, returns a list of integers representing the length of the largest palindromic subsequence in each string. >>> solve([\\"bbabcbcab\\", \\"abcd\\", \\"a\\", \\"aa\\", \\"aaaaa\\", \\"abc\\"]) [7, 1, 1, 2, 5, 1] pass # Tests def test_single_character(): assert solve([\\"a\\"]) == [1] def test_all_same_characters(): assert solve([\\"aaaaa\\"]) == [5] def test_no_palindrome(): assert solve([\\"abc\\"]) == [1] def test_subsequence_palindrome(): assert solve([\\"bbabcbcab\\"]) == [7] def test_length_two_palindrome(): assert solve([\\"aa\\"]) == [2] def test_mixed_cases(): assert solve([ \\"bbabcbcab\\", \\"abcd\\", \\"a\\", \\"aa\\", \\"aaaaa\\", \\"abc\\" ]) == [7, 1, 1, 2, 5, 1] def test_multiple_cases(): assert solve([ \\"abccba\\", \\"racecar\\", \\"civic\\", \\"deified\\", \\"rotor\\", \\"aabbcc\\" ]) == [6, 7, 5, 7, 5, 2]","solution":"def longest_palindromic_subsequence(S): Returns the length of the largest palindromic subsequence in the given string S. n = len(S) dp = [[0]*n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if S[i] == S[j] and cl == 2: dp[i][j] = 2 elif S[i] == S[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(test_cases): results = [] for S in test_cases: results.append(longest_palindromic_subsequence(S)) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Given a string s, determine if it can be reordered to form a palindrome. A string is a palindrome if it reads the same forwards and backwards. Examples: >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"def can_form_palindrome(s): Determines if the string can be reordered to form a palindrome. from collections import Counter # Count occurrences of each character count = Counter(s) # Count the number of characters with odd occurrences odd_count = sum(1 for char, cnt in count.items() if cnt % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Returns True if the target exists in the matrix, otherwise False. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> searchMatrix(matrix, 5) True >>> searchMatrix(matrix, 20) False def test_searchMatrix_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert searchMatrix(matrix, target) == True def test_searchMatrix_not_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 assert searchMatrix(matrix, target) == False def test_searchMatrix_first_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 1 assert searchMatrix(matrix, target) == True def test_searchMatrix_last_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 30 assert searchMatrix(matrix, target) == True def test_searchMatrix_single_element_true(): matrix = [ [1] ] target = 1 assert searchMatrix(matrix, target) == True def test_searchMatrix_single_element_false(): matrix = [ [1] ] target = 2 assert searchMatrix(matrix, target) == False def test_searchMatrix_empty_matrix(): assert searchMatrix([], 1) == False def test_searchMatrix_empty_row(): assert searchMatrix([[]], 1) == False","solution":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Returns True if the target exists in the matrix, otherwise False. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"def encodeString(s: str, shift: int) -> str: Encodes a string by shifting each letter by the given number of places in the alphabet. Wraps around if the end of the alphabet is reached. Other characters remain unchanged. >>> encodeString(\\"abcd XYZ\\", 3) == \\"defg ABC\\" >>> encodeString(\\"abcd XYZ\\", 0) == \\"abcd XYZ\\" >>> encodeString(\\"abcd XYZ\\", 26) == \\"abcd XYZ\\" >>> encodeString(\\"abc XYZ\\", 3) == \\"def ABC\\" >>> encodeString(\\"Hello, World!\\", 13) == \\"Uryyb, Jbeyq!\\" >>> encodeString(\\"aBcD XyZ\\", 3) == \\"dEfG AbC\\" >>> encodeString(\\"1234 !@#\\", 5) == \\"1234 !@#\\"","solution":"def encodeString(s, shift): Encodes a string by shifting each letter by the given number of places in the alphabet. Wraps around if the end of the alphabet is reached. Other characters remain unchanged. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in s)"},{"question":"def generate_sensor_grid(n: int) -> List[str]: Generates a valid n x n grid of sensors and empty cells. Each sensor can communicate directly with at least one other sensor. Example: >>> generate_sensor_grid(1) ['*'] >>> generate_sensor_grid(2) ['*.', '.*'] >>> generate_sensor_grid(3) ['*.*', '.*.', '*.*'] >>> generate_sensor_grid(4) ['*.*.', '.*.*', '*.*.', '.*.*'] >>> generate_sensor_grid(5) ['*.*.*', '.*.*.', '*.*.*', '.*.*.', '*.*.*']","solution":"def generate_sensor_grid(n): Generates a valid n x n grid of sensors and empty cells. Each sensor can communicate directly with at least one other sensor. grid = [] for i in range(n): row = [] for j in range(n): if (i + j) % 2 == 0: row.append('*') else: row.append('.') grid.append(''.join(row)) return grid"},{"question":"def is_balanced(s: str) -> bool: Check if the input string s has balanced brackets. Args: s (str): The input string containing only the characters (), {}, and []. Returns: bool: True if the string is balanced, False otherwise. >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"()[]{}\\") == True >>> is_balanced(\\"{[]}\\") == True >>> is_balanced(\\"(]\\") == False >>> is_balanced(\\"([)]\\") == False >>> is_balanced(\\"{[}\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"(((((((((())))))))))\\") == True >>> is_balanced(\\"(((((((((()))))))))\\") == False >>> is_balanced(\\"[[[[]]]]\\") == True >>> is_balanced(\\"[[[[]]]\\") == False >>> is_balanced(\\"{[()]}\\") == True >>> is_balanced(\\"{[(])}\\") == False","solution":"def is_balanced(s): Check if the input string s has balanced brackets. Args: s (str): The input string containing only the characters (), {}, and []. Returns: bool: True if the string is balanced, False otherwise. # Dictionary to hold the mapping of closing to opening brackets bracket_map = {')': '(', '}': '{', ']': '['} # Stack to keep track of opening brackets stack = [] # Iterate over each character in the string for char in s: # If the character is a closing bracket if char in bracket_map: # Pop the topmost element from the stack (or use a dummy value if empty) top_element = stack.pop() if stack else '#' # Check if the popped element matches the corresponding opening bracket if bracket_map[char] != top_element: return False else: # If it is an opening bracket, push it onto the stack stack.append(char) # Stack should be empty if all brackets are balanced return not stack"},{"question":"from typing import List def array_products(arr: List[int]) -> List[int]: Given an array of integers, return a new array where each element is the product of all elements in the input array except the one at the current index. >>> array_products([1, 2, 3, 4]) [24, 12, 8, 6] >>> array_products([0, 1, 2, 3]) [6, 0, 0, 0] >>> array_products([2, 3, 4, 5]) [60, 40, 30, 24] >>> array_products([1, 2]) [2, 1] >>> array_products([9, 8]) [8, 9] >>> array_products([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> array_products([3, 2, 1, 4, 6]) [48, 72, 144, 36, 24]","solution":"from typing import List def array_products(arr: List[int]) -> List[int]: n = len(arr) # Initialize the left and right product lists left_products = [1] * n right_products = [1] * n result = [1] * n # Fill left products for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Fill right products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Construct result from left_products and right_products for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def kaprekar(n: int) -> str: Determines if a number is a Kaprekar number. >>> kaprekar(9) \\"Kaprekar\\" >>> kaprekar(45) \\"Kaprekar\\" >>> kaprekar(12) \\"Not!!\\" >>> kaprekar(297) \\"Kaprekar\\" >>> kaprekar(1) \\"Kaprekar\\"","solution":"def kaprekar(n): Determines if a number is a Kaprekar number. Parameters: n (int): A positive integer to check. Returns: str: \\"Kaprekar\\" if the number is a Kaprekar number, otherwise \\"Not!!\\" if n < 0: return \\"Not!!\\" if n < 10: # All single-digit numbers are Kaprekar numbers return \\"Kaprekar\\" sq = str(n ** 2) len_n = len(str(n)) left = int(sq[:-len_n]) if sq[:-len_n] else 0 right = int(sq[-len_n:]) if left + right == n: return \\"Kaprekar\\" else: return \\"Not!!\\""},{"question":"def find_minimum_questions(n: int) -> (int, List[int]): Given an integer n, this function will return the minimum number of questions k necessary to determine any number x between 1 and n, as well as the sequence of y values for the questions. >>> find_minimum_questions(5) (3, [2, 3, 5]) >>> find_minimum_questions(7) (4, [2, 3, 5, 7]) >>> find_minimum_questions(1) (0, [])","solution":"def find_minimum_questions(n): Given an integer n, this function will return the minimum number of questions k necessary to determine any number x between 1 and n, as well as the sequence of y values for the questions. # We will use prime numbers up to n because each prime will uniquely identify a number. def sieve_of_eratosthenes(max_num): is_prime = [True] * (max_num + 1) p = 2 while p * p <= max_num: if is_prime[p]: for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 primes = [p for p in range(2, max_num + 1) if is_prime[p]] return primes primes = sieve_of_eratosthenes(n) return (len(primes), primes)"},{"question":"def most_frequent_element(lst: List[int]) -> int: Returns the element that appears most frequently in the list. If multiple elements have the same highest frequency, returns the smallest element among them. Examples: >>> most_frequent_element([1, 3, 2, 1, 4, 1, 3, 4, 4]) 1 >>> most_frequent_element([5, 5, 5, 3, 3, 3, 2]) 3 >>> most_frequent_element([10, 20, 10, 10, 30, 30]) 10 >>> most_frequent_element([6, 6, 6, 7, 7, 7, 8, 8]) 6 >>> most_frequent_element([9, 1, 2, 2, 9, 9, 1, 1, 2, 2]) 2 pass # Your code goes here def test_most_frequent_element_single(): assert most_frequent_element([1]) == 1 assert most_frequent_element([5]) == 5 assert most_frequent_element([42]) == 42 def test_most_frequent_element_typical_case(): assert most_frequent_element([1, 3, 2, 1, 4, 1, 3, 4, 4]) == 1 assert most_frequent_element([5, 5, 5, 3, 3, 3, 2]) == 3 assert most_frequent_element([10, 20, 10, 10, 30, 30]) == 10 assert most_frequent_element([6, 6, 6, 7, 7, 7, 8, 8]) == 6 assert most_frequent_element([9, 1, 2, 2, 9, 9, 1, 1, 2, 2]) == 2 def test_most_frequent_element_empty_list(): assert most_frequent_element([]) == None def test_most_frequent_element_all_unique(): assert most_frequent_element([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 def test_most_frequent_element_all_same(): assert most_frequent_element([7, 7, 7, 7, 7]) == 7","solution":"def most_frequent_element(lst): Returns the element that appears most frequently in the list. If multiple elements have the same highest frequency, returns the smallest element among them. if not lst: return None from collections import Counter count = Counter(lst) max_freq = max(count.values()) # Filter elements with the maximum frequency max_freq_elements = [key for key, value in count.items() if value == max_freq] # Return the smallest element among those with the maximum frequency return min(max_freq_elements)"},{"question":"def smallest_digit_sum(n: int) -> int: Returns the smallest non-negative integer whose digits add up to n. >>> smallest_digit_sum(0) == 0 >>> smallest_digit_sum(1) == 1 >>> smallest_digit_sum(5) == 5 >>> smallest_digit_sum(10) == 19 >>> smallest_digit_sum(25) == 799","solution":"def smallest_digit_sum(n): Returns the smallest non-negative integer whose digits add up to n. if n == 0: return 0 number = 0 digit_sum = 0 digit_multiplier = 1 while n > 0: digit = min(9, n) number += digit * digit_multiplier digit_sum += digit n -= digit digit_multiplier *= 10 return number"},{"question":"def longest_even_subarray(arr: List[int]) -> int: Returns the length of the longest subarray that contains only even numbers >>> longest_even_subarray([1, 2, 4, 6, 3, 8, 10, 12]) 4 >>> longest_even_subarray([2, 4, 1, 2, 4, 6, 8]) 4 >>> longest_even_subarray([1]) 0 >>> longest_even_subarray([2]) 1 >>> longest_even_subarray([]) 0","solution":"def longest_even_subarray(arr): Returns the length of the longest subarray that contains only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one of the characters has an odd frequency. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aaabb\\") True >>> can_form_palindrome(\\"abcabc\\") True >>> can_form_palindrome(\\"abcadef\\") False","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one of the characters has an odd frequency. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. from collections import Counter # Get the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # To form a palindrome, we can have at most one character with an odd frequency return odd_count <= 1"},{"question":"def categorize_tasks(tasks): Categorizes tasks based on days remaining until their deadline. Parameters: tasks (list of tuples): A list where each tuple contains a task name and the number of days remaining. Returns: dict: A dictionary with tasks categorized as \\"Urgent\\", \\"Upcoming\\", and \\"Later\\". >>> categorize_tasks([(\\"Submit report\\", 2), (\\"Pay bills\\", 5), (\\"Finish project\\", 8)]) {\\"Urgent\\": [\\"Submit report\\"], \\"Upcoming\\": [\\"Pay bills\\"], \\"Later\\": [\\"Finish project\\"]} >>> categorize_tasks([]) {\\"Urgent\\": [], \\"Upcoming\\": [], \\"Later\\": []}","solution":"def categorize_tasks(tasks): Categorizes tasks based on days remaining until their deadline. Parameters: tasks (list of tuples): A list where each tuple contains a task name and the number of days remaining. Returns: dict: A dictionary with tasks categorized as \\"Urgent\\", \\"Upcoming\\", and \\"Later\\". categorized_tasks = { \\"Urgent\\": [], \\"Upcoming\\": [], \\"Later\\": [] } for task_name, days_remaining in tasks: if 0 <= days_remaining <= 2: categorized_tasks[\\"Urgent\\"].append(task_name) elif 3 <= days_remaining <= 5: categorized_tasks[\\"Upcoming\\"].append(task_name) else: categorized_tasks[\\"Later\\"].append(task_name) return categorized_tasks"},{"question":"def product_except_self(nums): Returns a list where each element is the product of all the elements in the original list except the element at that index. Examples: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([1, 0, 0, 4]) [0, 0, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([]) [] >>> product_except_self([1]) [1] >>> product_except_self([2]) [1]","solution":"def product_except_self(nums): Returns a list where each element is the product of all the elements in the original list except the element at that index. if not nums: return [] n = len(nums) if n == 1: return [1] result = [1] * n # Fill result with the product of elements to the left of each index left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Multiply by the product of elements to the right of each index right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def unique_digit_sum(lst: List[int]) -> bool: Determines if the given list of integers has unique digit sums. The function returns True if all digit sums are unique, otherwise False. >>> unique_digit_sum([123, 146, 258]) True >>> unique_digit_sum([123, 321, 446]) False >>> unique_digit_sum([123]) True >>> unique_digit_sum([-123, -146, -258]) True >>> unique_digit_sum([0, 10, -10]) False >>> unique_digit_sum([123, -124, 9, -18]) False","solution":"def unique_digit_sum(lst): Determines if the given list of integers has unique digit sums. The function returns True if all digit sums are unique, otherwise False. def digit_sum(n): return sum(int(d) for d in str(abs(n))) digit_sums = set() for number in lst: d_sum = digit_sum(number) if d_sum in digit_sums: return False digit_sums.add(d_sum) return True"},{"question":"def count_vowels(strings: List[str]) -> List[Tuple[str, int]]: Takes a list of strings and returns a list of tuples. Each tuple should contain a string from the input list and the count of vowels (a, e, i, o, u, both upper-case and lower-case) in that string. >>> count_vowels([\\"hello\\", \\"world\\", \\"Python\\"]) [(\\"hello\\", 2), (\\"world\\", 1), (\\"Python\\", 1)] >>> count_vowels([\\"AeiOu\\", \\"bcdEF\\", \\"GHIjkl\\"]) [(\\"AeiOu\\", 5), (\\"bcdEF\\", 1), (\\"GHIjkl\\", 1)] >>> count_vowels([\\"\\"]) [(\\"\\", 0)] >>> count_vowels([\\"bcdfg\\", \\"hjklm\\", \\"xyz\\"]) [(\\"bcdfg\\", 0), (\\"hjklm\\", 0), (\\"xyz\\", 0)] >>> count_vowels([\\"aeiou\\", \\"AEIOU\\"]) [(\\"aeiou\\", 5), (\\"AEIOU\\", 5)] >>> count_vowels([]) []","solution":"def count_vowels(strings): Takes a list of strings and returns a list of tuples. Each tuple contains a string from the input list and the count of vowels in that string. vowels = set('aeiouAEIOU') def vowel_count(s): return sum(1 for char in s if char in vowels) return [(s, vowel_count(s)) for s in strings]"},{"question":"def solve_sudoku(board): Solve a Sudoku puzzle by filling the empty cells. Args: board (List[List[str]]): 2D list representing the Sudoku board to be solved. Returns: None: The board is modified in-place with the solved puzzle. Example: >>> board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] >>> solve_sudoku(board) >>> expected_solved_board = [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] >>> assert board == expected_solved_board","solution":"def solve_sudoku(board): def is_valid(board, row, col, num): # Check row for i in range(9): if board[row][i] == num: return False # Check column for i in range(9): if board[i][col] == num: return False # Check 3x3 block start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == '.': for num in '123456789': if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = '.' return False return True solve(board)"},{"question":"from typing import List def findMaxLength(nums: List[int]) -> int: Given a list of integers \`nums\`, determine the maximum length of a contiguous subarray with an equal number of 0s and 1s. Args: nums: List[int] - List of integers containing only 0s and 1s. Returns: int - Maximum length of a contiguous subarray with an equal number of 0s and 1s. Example: >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1, 0, 0, 1, 1, 0]) 6","solution":"def findMaxLength(nums): Returns the maximum length of a contiguous subarray with an equal number of 0s and 1s. count = 0 max_length = 0 count_dict = {0: -1} for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"from collections import Counter import re def k_most_frequent_words(k, text): Returns the k most frequent words in the given text. If two words have the same frequency, the word which comes first lexicographically should appear first. >>> k_most_frequent_words(1, \\"word\\") [\\"word\\"] >>> k_most_frequent_words(1, \\"test test test\\") [\\"test\\"] >>> k_most_frequent_words(2, \\"Test test TEST\\") [\\"test\\"] >>> k_most_frequent_words(3, \\"This is a test. This test is only a test.\\") [\\"test\\", \\"a\\", \\"is\\"] >>> k_most_frequent_words(2, \\"bb bb aa aa cc cc\\") [\\"aa\\", \\"bb\\"] >>> k_most_frequent_words(2, \\"word word word alpha alpha beta beta\\") [\\"word\\", \\"alpha\\"]","solution":"from collections import Counter import re def k_most_frequent_words(k, text): Returns the k most frequent words in the given text. If two words have the same frequency, the word which comes first lexicographically should appear first. # Normalize text to lowercase and split into words words = re.findall(r'b[a-z]+b', text.lower()) # Count the frequency of each word word_counter = Counter(words) # Sort the words first by frequency (descending) then lexicographically (ascending) sorted_words = sorted(word_counter.items(), key=lambda item: (-item[1], item[0])) # Extract and return the k most frequent words return [word for word, count in sorted_words[:k]]"},{"question":"def find_missing_element(B: List[int]) -> int: Finds the missing element in an array B of size N with elements ranging from 1 to N inclusive. >>> find_missing_element([3, 7, 1, 2, 8, 4, 5]) == 6 >>> find_missing_element([1, 2, 4, 5, 6]) == 3 >>> find_missing_element([9, 8, 7, 5, 4, 3, 2, 1]) == 6","solution":"def find_missing_element(B): Finds the missing element in an array B of size N with elements ranging from 1 to N inclusive. n = len(B) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(B) return expected_sum - actual_sum"},{"question":"def num_islands(grid): This function returns the number of distinct islands in a given grid. >>> num_islands([ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ]) == 3 >>> num_islands([]) == 0 >>> num_islands([ ... ['0', '0', '0'], ... ['0', '0', '0'], ... ['0', '0', '0'] ... ]) == 0 >>> num_islands([ ... ['1', '1'], ... ['1', '1'] ... ]) == 1 >>> num_islands([ ... ['0', '0', '0'], ... ['0', '1', '0'], ... ['0', '0', '0'] ... ]) == 1 >>> num_islands([ ... ['1', '0', '0', '1'], ... ['0', '0', '0', '0'], ... ['1', '0', '1', '1'], ... ['0', '0', '0', '0'] ... ]) == 4","solution":"def num_islands(grid): This function returns the number of distinct islands in a given grid. def dfs(x, y): # Check bounds and if the current cell is water or already visited if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == '0': return # Mark this cell as visited by setting it to '0' grid[x][y] = '0' # Visit all neighboring cells (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) if not grid: return 0 num_of_islands = 0 # Traverse the grid for i in range(len(grid)): for j in range(len(grid[i])): # Start a DFS if a '1' is found if grid[i][j] == '1': num_of_islands += 1 dfs(i, j) return num_of_islands"},{"question":"from typing import List, Tuple def largest_number(nums: List[int]) -> str: Returns the largest possible number that can be formed by concatenating the array elements. >>> largest_number([3, 30, 34]) \\"34330\\" >>> largest_number([9, 5, 34, 3]) \\"95343\\" >>> largest_number([20, 1, 9, 4, 0]) \\"942010\\" >>> largest_number([0, 0, 0, 0, 0]) \\"0\\" def solve(test_cases: List[Tuple[int, List[int]]]) -> List[str]: results = [] for case in test_cases: n, nums = case largest_num = largest_number(nums) results.append(largest_num) return results def test_cases(): assert solve([(3, [3, 30, 34]), (4, [9, 5, 34, 3]), (5, [20, 1, 9, 4, 0]), (6, [0, 0, 0, 0, 0, 0])]) == [\\"34330\\", \\"95343\\", \\"942010\\", \\"0\\"] assert solve([(4, [1, 2, 3, 4])]) == [\\"4321\\"] assert solve([(4, [1, 1, 1, 1])]) == [\\"1111\\"] assert solve([(3, [12, 121, 120])]) == [\\"12121120\\"] assert solve([(4, [0, 5, 9, 34])]) == [\\"95340\\"] assert solve([(5, [0, 0, 0, 0, 0])]) == [\\"0\\"]","solution":"from functools import cmp_to_key def largest_number(nums): Returns the largest number possible by concatenating the given integers. # Custom comparator for sorting def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all integers to strings to form the basis of comparison nums_str = list(map(str, nums)) # Sort using the custom comparator nums_str.sort(key=cmp_to_key(compare)) # Concatenate sorted numbers result = ''.join(nums_str) # Edge case: If the largest number is '0', it means all numbers are '0' if result[0] == '0': return '0' return result def solve(test_cases): results = [] for case in test_cases: n, nums = case largest_num = largest_number(nums) results.append(largest_num) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"aa\\") 2 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"abcd\\") 1 >>> longest_palindromic_subsequence(\\"agbdba\\") 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in s. n = len(s) # Create a table to store lengths of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Single character palindromes for i in range(n): dp[i][i] = 1 # Build the table dp[][] in bottom-up manner for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # Length of the longest palindromic subsequence return dp[0][n-1]"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying on one day and selling on another day in the future. If no profit can be made, return 0. :param prices: List of integers representing the prices of a given stock on different days :return: Maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 def test_example_1(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_example_2(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_single_day(): assert max_profit([10]) == 0 def test_two_days_profit(): assert max_profit([1, 10]) == 9 def test_two_days_no_profit(): assert max_profit([10, 1]) == 0 def test_empty_prices(): assert max_profit([]) == 0 def test_constant_prices(): assert max_profit([5, 5, 5, 5, 5]) == 0 def test_fluctuating_prices(): assert max_profit([3, 2, 6, 5, 0, 3]) == 4","solution":"from typing import List def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be made by buying on one day and selling on another day in the future. If no profit can be made, return 0. :param prices: List of integers representing the prices of a given stock on different days :return: Maximum profit if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_second_min_and_second_max(n: int, seq: List[int]) -> Tuple[int, int]: Returns the second smallest and second largest elements from the list, seq. >>> find_second_min_and_second_max(6, [10, 5, 9, 12, 6, 8]) == (6, 10) >>> find_second_min_and_second_max(5, [4, 7, 9, 1, 5]) == (4, 7) >>> find_second_min_and_second_max(7, [4, 4, 7, 9, 1, 1, 5]) == (4, 7) >>> find_second_min_and_second_max(2, [1, 2]) == (2, 1) >>> find_second_min_and_second_max(5, [5, 5, 5, 7, 1]) == (5, 5) >>> find_second_min_and_second_max(4, [8, 3, 5, 9]) == (5, 8)","solution":"def find_second_min_and_second_max(n, seq): Returns the second smallest and second largest elements from the list, seq. # Remove duplicates by converting to a set and then back to a sorted list sorted_unique_seq = sorted(set(seq)) # Second smallest and second largest from the sorted unique elements second_smallest = sorted_unique_seq[1] second_largest = sorted_unique_seq[-2] return second_smallest, second_largest"},{"question":"def countSwaps(arr): Returns the minimum number of swaps required to sort the array in ascending order. >>> countSwaps([4, 3, 2, 1]) 2 >>> countSwaps([2, 3, 4, 1, 5]) 3 >>> countSwaps([1, 2, 3, 4, 5]) 0 >>> countSwaps([1]) 0 >>> countSwaps([2, 1]) 1 def process_test_cases(input_data): Process the input for multiple test cases and return the results. >>> input_data = \\"2n4 4 3 2 1n5 2 3 4 1 5\\" >>> process_test_cases(input_data) [2, 3] >>> input_data = \\"3n3 3 2 1n4 1 2 3 4n2 2 1\\" >>> process_test_cases(input_data) [1, 0, 1] >>> input_data = \\"1n5 5 4 3 2 1\\" >>> process_test_cases(input_data) [2]","solution":"def countSwaps(arr): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) arr_pos = list(enumerate(arr)) # Sort arr_pos by array value arr_pos.sort(key=lambda it: it[1]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): # if element is already in the correct position or already visited if visited[i] or arr_pos[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][0] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps def process_test_cases(input_data): Process the input for multiple test cases and return the results. results = [] input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) for i in range(1, T + 1): case_data = list(map(int, input_lines[i].split())) N = case_data[0] arr = case_data[1:] swap_count = countSwaps(arr) results.append(swap_count) return results"},{"question":"def count_unique_paths(M: int, N: int, blocked_cells: list) -> int: Given a rectangle of size MxN, find the total number of unique paths from the top-left corner to the bottom-right corner, considering certain cells are blocked. pass def process_test_cases(T: int, test_cases: list) -> list: Process multiple test cases to find the total number of unique paths for each test case. >>> process_test_cases(2, [(3, 3, 1, [(2, 2)]), (4, 4, 2, [(2, 2), (3, 3)])]) [2, 4] >>> process_test_cases(1, [(2, 2, 0, [])]) [2] pass def test_count_unique_paths(): assert count_unique_paths(3, 3, [(2, 2)]) == 2 assert count_unique_paths(4, 4, [(2, 2), (3, 3)]) == 4 assert count_unique_paths(2, 2, []) == 2 assert count_unique_paths(1, 1, [(1, 1)]) == 0 def test_process_test_cases(): test_cases = [ (3, 3, 1, [(2, 2)]), (4, 4, 2, [(2, 2), (3, 3)]), ] assert process_test_cases(2, test_cases) == [2, 4] test_cases = [ (2, 2, 0, []), ] assert process_test_cases(1, test_cases) == [2] test_cases = [ (1, 1, 1, [(1, 1)]), ] assert process_test_cases(1, test_cases) == [0]","solution":"def count_unique_paths(M, N, blocked_cells): dp = [[0]*N for _ in range(M)] if (1, 1) in blocked_cells: return 0 dp[0][0] = 1 for i in range(M): for j in range(N): if (i+1, j+1) in blocked_cells: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1] def process_test_cases(T, test_cases): results = [] for case in test_cases: M, N, B, blocked_cells = case result = count_unique_paths(M, N, blocked_cells) results.append(result) return results"},{"question":"def is_valid(s: str) -> bool: Determine if the input string s is a valid expression of brackets. # Valid cases >>> is_valid(\\"()\\") True >>> is_valid(\\"()[]{}\\") True >>> is_valid(\\"[({})]\\") True >>> is_valid(\\"{[()]}\\") True # Invalid cases >>> is_valid(\\"[(]{)}\\") False >>> is_valid(\\"([)]\\") False >>> is_valid(\\"((()\\") False >>> is_valid(\\"{[()]}}\\") False # Empty string >>> is_valid(\\"\\") True","solution":"def is_valid(s): Determine if the input string s is a valid expression of brackets. Args: s (str): input string containing the brackets Returns: bool: True if the string is valid, otherwise False stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def circular_shift(word: str, n: int) -> str: Shifts the characters of the word to the right by n positions in a circular manner. >>> circular_shift(\\"example\\", 3) 'pleexam' >>> circular_shift(\\"coding\\", 1) 'gcodin' >>> circular_shift(\\"challenge\\", 5) 'lengechal' >>> circular_shift(\\"rotate\\", 4) 'aterot'","solution":"def circular_shift(word, n): Shifts the characters of the word to the right by n positions in a circular manner. Parameters: word (str): The word to be shifted. n (int): The number of right circular shifts. Returns: str: The word after the circular shift. if not word: return word n = n % len(word) # To handle cases where n is larger than the word length return word[-n:] + word[:-n]"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, return a new array such that each element at index \`i\` of the new array is the product of all the numbers in the original array except the one at \`i\` without using division. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([-1, 0, 1, 2, -2]) [0, 4, 0, 0, 0]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given an array of integers, returns a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at i. This is done without using division and in O(n) time complexity. length = len(nums) # Create two arrays to store the product of elements to the left and to the right of each element left_products = [1] * length right_products = [1] * length result = [1] * length # Populate the left_products array for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Populate the right_products array for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct the result array by multiplying left_products and right_products for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def check_inclusion(s1: str, s2: str) -> bool: Check if s2 contains any permutation of s1. >>> check_inclusion(\\"ab\\", \\"eidbaooo\\") == True >>> check_inclusion(\\"ab\\", \\"eidboaoo\\") == False >>> check_inclusion(\\"adc\\", \\"dcda\\") == True >>> check_inclusion(\\"abcd\\", \\"eabcd\\") == True","solution":"def check_inclusion(s1, s2): Returns True if s2 contains any permutation of s1, False otherwise. from collections import Counter n1, n2 = len(s1), len(s2) if n1 > n2: return False s1_count = Counter(s1) window_count = Counter(s2[:n1]) if s1_count == window_count: return True for i in range(n1, n2): window_count[s2[i]] += 1 window_count[s2[i-n1]] -= 1 if window_count[s2[i-n1]] == 0: del window_count[s2[i-n1]] if s1_count == window_count: return True return False"},{"question":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome. :param s: string containing only lowercase letters :return: True if s is a palindrome, False otherwise >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"world\\") False >>> is_palindrome(\\"python\\") False >>> is_palindrome(\\"x\\") True","solution":"def is_palindrome(s): Determines if the given string is a palindrome. :param s: string containing only lowercase letters :return: True if s is a palindrome, False otherwise return s == s[::-1]"},{"question":"def harvest_crops(N, initial_seeds): Calculate the maximum number of harvests for each crop type after 'N' game days. Parameters: N (int): The number of game days. initial_seeds (dict): Initial number of seeds for each crop type. Returns: dict: Maximum number of harvests for each crop type. Examples: >>> harvest_crops(12, {\\"wheat\\": 5, \\"carrots\\": 10, \\"potatoes\\": 20}) {\\"wheat\\": 2, \\"carrots\\": 3, \\"potatoes\\": 2} >>> harvest_crops(25, {\\"wheat\\": 8, \\"carrots\\": 10, \\"potatoes\\": 20}) {\\"wheat\\": 4, \\"carrots\\": 6, \\"potatoes\\": 5} pass","solution":"def harvest_crops(N, initial_seeds): Calculate the maximum number of harvests for each crop type after 'N' game days. Parameters: N (int): The number of game days. initial_seeds (dict): Initial number of seeds for each crop type. Returns: dict: Maximum number of harvests for each crop type. # Growth time in days for each crop growth_times = { 'wheat': 6, 'carrots': 4, 'potatoes': 5 } max_harvests = {} for crop, initial in initial_seeds.items(): # Calculate the number of complete growth cycles within N days cycles = N // growth_times[crop] max_harvests[crop] = cycles return max_harvests"},{"question":"def can_reach_destination(n: int, m: int, maze: List[List[str]]) -> str: Determines if the robot can reach the bottom-right corner of the maze. Parameters: n (int): The number of rows in the maze. m (int): The number of columns in the maze. maze (list): A list of lists representing the maze grid. Returns: str: \\"YES\\" if the robot can reach the bottom-right corner, \\"NO\\" otherwise. >>> can_reach_destination(5, 5, [ ... ['.', '.', '.', '.', '#'], ... ['.', '#', '.', '.', '.'], ... ['.', '.', '#', '.', '.'], ... ['.', '.', '.', '.', '#'], ... ['#', '.', '.', '.', '.'], ... ]) == \\"YES\\" >>> can_reach_destination(5, 5, [ ... ['.', '#', '#', '#', '#'], ... ['#', '#', '#', '#', '#'], ... ['#', '#', '#', '#', '#'], ... ['#', '#', '#', '#', '#'], ... ['#', '#', '#', '#', '.'], ... ]) == \\"NO\\" >>> can_reach_destination(2, 2, [ ... ['.', '#'], ... ['#', '.'], ... ]) == \\"NO\\" >>> can_reach_destination(2, 2, [ ... ['.', '.'], ... ['.', '.'], ... ]) == \\"YES\\" >>> can_reach_destination(1, 1, [['.']]) == \\"YES\\" >>> can_reach_destination(1, 1, [['#']]) == \\"NO\\"","solution":"def can_reach_destination(n, m, maze): Determines if the robot can reach the bottom-right corner of the maze. Parameters: n (int): The number of rows in the maze. m (int): The number of columns in the maze. maze (list): A list of strings representing the maze grid. Returns: str: \\"YES\\" if the robot can reach the bottom-right corner, \\"NO\\" otherwise. if maze[0][0] == '#' or maze[n-1][m-1] == '#': return \\"NO\\" from collections import deque # Direction vectors for moving right and down directions = [(0, 1), (1, 0)] queue = deque([(0, 0)]) while queue: x, y = queue.popleft() # If we've reached the bottom-right corner if x == n-1 and y == m-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == '.': queue.append((nx, ny)) # Mark the cell as visited by changing '.' to '#' maze[nx][ny] = '#' return \\"NO\\""},{"question":"import heapq from collections import defaultdict import sys def find_min_cost(n: int, flights: List[List[int]], src: int, dst: int) -> int: Determines the minimum cost to travel from a source city to a destination city. If it's impossible to travel between cities, returns -1. >>> find_min_cost(4, [[0, 1, 100], [1, 2, 200], [2, 3, 300], [0, 3, 1000]], 0, 3) 600 >>> find_min_cost(3, [[0, 1, 200], [1, 2, 100]], 0, 2) 300 >>> find_min_cost(3, [[0, 1, 500], [1, 2, 200]], 0, 1) 500 >>> find_min_cost(3, [[0, 1, 500], [1, 2, 200]], 0, 2) 700 >>> find_min_cost(2, [], 0, 1) -1 >>> find_min_cost(5, [[0, 1, 100], [1, 2, 200], [2, 3, 300], [3, 4, 400]], 0, 4) 1000 >>> find_min_cost(5, [[0, 1, 100], [1, 2, 200], [1, 3, 250], [3, 4, 50]], 0, 4) 400 >>> find_min_cost(4, [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 2, 500], [2, 0, 300]], 0, 3) 300","solution":"import heapq from collections import defaultdict import sys def find_min_cost(n, flights, src, dst): Determines the minimum cost to travel from source city to destination city. If it's impossible to travel, returns -1. graph = defaultdict(list) for u, v, w in flights: graph[u].append((v, w)) min_heap = [(0, src)] # (cost, city) min_cost = {i: sys.maxsize for i in range(n)} min_cost[src] = 0 while min_heap: curr_cost, u = heapq.heappop(min_heap) if u == dst: return curr_cost for v, w in graph[u]: new_cost = curr_cost + w if new_cost < min_cost[v]: min_cost[v] = new_cost heapq.heappush(min_heap, (new_cost, v)) return -1 if min_cost[dst] == sys.maxsize else min_cost[dst]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string representing an arithmetic expression consisting of integers, parentheses, and the operators '+', '-', '*', and '/'. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") 23 >>> evaluate_expression(\\"2-3/(2+1)\\") 1","solution":"def evaluate_expression(expression: str) -> int: def operate(op, second, first): if op == '+': return first + second elif op == '-': return first - second elif op == '*': return first * second elif op == '/': return int(first / second) # Ensure integer division def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operations(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(operate(operator, right, left)) operators, values = [], [] idx, n = 0, len(expression) while idx < n: if expression[idx] == ' ': idx += 1 continue if expression[idx] == '(': operators.append(expression[idx]) elif expression[idx].isdigit(): val = 0 while idx < n and expression[idx].isdigit(): val = val * 10 + int(expression[idx]) idx += 1 values.append(val) idx -= 1 elif expression[idx] == ')': while operators and operators[-1] != '(': apply_operations(operators, values) operators.pop() # Pop the '(' else: while (operators and precedence(operators[-1]) >= precedence(expression[idx])): apply_operations(operators, values) operators.append(expression[idx]) idx += 1 while operators: apply_operations(operators, values) return values[0]"},{"question":"def sum_followed_by_smaller(nums): Returns the sum of integers in the list which are followed by a smaller integer. >>> sum_followed_by_smaller([1, 2, 3]) 0 >>> sum_followed_by_smaller([5, 4, 3, 2, 1]) 14 >>> sum_followed_by_smaller([2, 1, 5, 3]) 7 from solution import sum_followed_by_smaller def test_sum_followed_by_smaller_all_descending(): assert sum_followed_by_smaller([5, 4, 3, 2, 1]) == 14 def test_sum_followed_by_smaller_mixed_order(): assert sum_followed_by_smaller([2, 1, 5, 3]) == 7 def test_sum_followed_by_smaller_single_ascending(): assert sum_followed_by_smaller([1, 2, 3]) == 0 def test_sum_followed_by_smaller_single_element(): assert sum_followed_by_smaller([1]) == 0 def test_sum_followed_by_smaller_same_values(): assert sum_followed_by_smaller([2, 2, 2]) == 0 def test_sum_followed_by_smaller_no_elements(): assert sum_followed_by_smaller([]) == 0 def test_sum_followed_by_smaller_same_value_followed_by_smaller(): assert sum_followed_by_smaller([3, 3, 1]) == 3","solution":"def sum_followed_by_smaller(nums): Returns the sum of integers in the list which are followed by a smaller integer. result = 0 for i in range(len(nums) - 1): if nums[i] > nums[i + 1]: result += nums[i] return result"},{"question":"class Employee: def __init__(self, name: str, title: str, reports: list): self.name = name self.title = title self.reports = reports def find_highest_ranked(employee: Employee) -> str: Determine the highest-ranking member in a specific section of the company's hierarchy. >>> ceo = Employee(\\"Alice\\", \\"CEO\\", []) >>> vp1 = Employee(\\"Bob\\", \\"Vice President\\", []) >>> vp2 = Employee(\\"Carol\\", \\"Vice President\\", []) >>> manager = Employee(\\"David\\", \\"Manager\\", []) >>> engineer = Employee(\\"Eve\\", \\"Engineer\\", []) >>> intern = Employee(\\"Frank\\", \\"Intern\\", []) >>> ceo.reports = [vp1, vp2] >>> vp1.reports = [manager] >>> manager.reports = [engineer] >>> engineer.reports = [intern] >>> find_highest_ranked(manager) 'David' >>> find_highest_ranked(ceo) 'Alice'","solution":"class Employee: def __init__(self, name: str, title: str, reports: list): self.name = name self.title = title self.reports = reports RANKS = { \\"CEO\\": 1, \\"President\\": 2, \\"Vice President\\": 3, \\"Director\\": 4, \\"Manager\\": 5, \\"Lead\\": 6, \\"Engineer\\": 7, \\"Intern\\": 8 } def find_highest_ranked(employee: Employee) -> str: def dfs(emp): nonlocal highest_rank, highest_ranked_employee if RANKS[emp.title] < highest_rank: highest_rank = RANKS[emp.title] highest_ranked_employee = emp.name for report in emp.reports: dfs(report) highest_rank = float('inf') highest_ranked_employee = \\"\\" dfs(employee) return highest_ranked_employee"},{"question":"def removeDuplicates(lst): Returns a new list with duplicate elements removed from the input list, while preserving the order of the first occurrence of each element. >>> removeDuplicates([1, 3, 3, 2, 1, 4]) [1, 3, 2, 4] >>> removeDuplicates([1, 2, 3, 4]) [1, 2, 3, 4] >>> removeDuplicates([]) [] >>> removeDuplicates([1]) [1] >>> removeDuplicates([2, 2, 2, 2]) [2] >>> removeDuplicates([1, 2, 2, 3, 4, 4, 5, 1]) [1, 2, 3, 4, 5]","solution":"def removeDuplicates(lst): Returns a new list with duplicates removed from the input list, preserving the order. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def letter_count(s: str) -> dict: Takes a string as input and returns a dictionary where each key is a lowercase letter from the string and the corresponding value is the count of occurrences of that letter. Ignore non-letter characters and consider uppercase and lowercase letters as the same. >>> letter_count(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> letter_count(\\"OpenAI GPT-3.\\") {'o': 1, 'p': 2, 'e': 1, 'n': 1, 'a': 1, 'i': 1, 'g': 1, 't': 1} >>> letter_count(\\"Python 3.8\\") {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1} >>> letter_count(\\"123, Let's Code!\\") {'l': 1, 'e': 2, 't': 1, 's': 1, 'c': 1, 'o': 1, 'd': 1}","solution":"def letter_count(s: str) -> dict: Takes a string as input and returns a dictionary where each key is a lowercase letter from the string and the corresponding value is the count of occurrences of that letter. Ignore non-letter characters and consider uppercase and lowercase letters as the same. from collections import Counter # Convert string to lowercase and filter out non-letter characters filtered_s = ''.join(c for c in s.lower() if c.isalpha()) # Count occurrences of each letter return dict(Counter(filtered_s))"},{"question":"from collections import deque from typing import List def shortest_path_to_target(grid: List[List[int]]) -> int: Finds the shortest path from the top-left corner to the nearest target cell in the grid. Returns -1 if there is no path to any target cell. >>> shortest_path_to_target([[0, 1, 2], [0, 0, 0], [1, 0, 0]]) == 4 >>> shortest_path_to_target([[0, 1, 1], [0, 1, 2], [0, 0, 0]]) == 5 >>> shortest_path_to_target([[0, 1], [1, 2]]) == -1 # Implement the function here","solution":"from collections import deque def shortest_path_to_target(grid): Finds the shortest path from the top-left corner to the nearest target cell in the grid. Returns -1 if there is no path to any target cell. if not grid: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if grid[r][c] == 2: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] != 1: queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def int_to_roman(num: int) -> str: Converts a given positive integer to a Roman numeral. :param num: Positive integer to convert, expected to be in the range 1 to 3999. :return: A string representing the Roman numeral. >>> int_to_roman(3) III >>> int_to_roman(4) IV >>> int_to_roman(9) IX >>> int_to_roman(58) LVIII >>> int_to_roman(1994) MCMXCIV pass def test_single_digits(): assert int_to_roman(1) == 'I' assert int_to_roman(3) == 'III' assert int_to_roman(4) == 'IV' assert int_to_roman(5) == 'V' assert int_to_roman(9) == 'IX' def test_double_digits(): assert int_to_roman(10) == 'X' assert int_to_roman(11) == 'XI' assert int_to_roman(20) == 'XX' assert int_to_roman(40) == 'XL' assert int_to_roman(50) == 'L' assert int_to_roman(90) == 'XC' def test_triple_digits(): assert int_to_roman(100) == 'C' assert int_to_roman(300) == 'CCC' assert int_to_roman(400) == 'CD' assert int_to_roman(500) == 'D' assert int_to_roman(900) == 'CM' def test_four_digits(): assert int_to_roman(1000) == 'M' assert int_to_roman(1987) == 'MCMLXXXVII' assert int_to_roman(2999) == 'MMCMXCIX' assert int_to_roman(3999) == 'MMMCMXCIX' def test_mixed_numbers(): assert int_to_roman(58) == 'LVIII' assert int_to_roman(1994) == 'MCMXCIV' assert int_to_roman(2022) == 'MMXXII'","solution":"def int_to_roman(num: int) -> str: Converts a given positive integer to a Roman numeral. :param num: Positive integer to convert, expected to be in the range 1 to 3999. :return: A string representing the Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"def bestGrowthYear(growthData): Returns the year with the highest average tree height. If multiple years have the same highest average, return the earliest year among them. max_avg_height = float('-inf') best_year = None for data in growthData: year = data['year'] heights = data['heights'] avg_height = sum(heights) / len(heights) if avg_height > max_avg_height or (avg_height == max_avg_height and (best_year is None or year < best_year)): max_avg_height = avg_height best_year = year return best_year # Unit Tests def test_bestGrowthYear_single_year(): growthData = [ {'year': 2021, 'heights': [5, 7, 8]} ] assert bestGrowthYear(growthData) == 2021 def test_bestGrowthYear_multiple_years(): growthData = [ {'year': 2018, 'heights': [3, 5, 7, 10]}, {'year': 2019, 'heights': [2, 3, 5, 6, 7]}, {'year': 2020, 'heights': [10, 13, 11]}, ] assert bestGrowthYear(growthData) == 2020 def test_bestGrowthYear_tie(): growthData = [ {'year': 2018, 'heights': [4, 4, 4]}, {'year': 2019, 'heights': [5, 3, 4]}, {'year': 2020, 'heights': [6, 2, 4]}, ] assert bestGrowthYear(growthData) == 2018 def test_bestGrowthYear_with_large_range_of_years(): growthData = [ {'year': 1990, 'heights': [1, 2, 3]}, {'year': 2000, 'heights': [10, 10, 10]}, {'year': 2010, 'heights': [5, 5, 5, 5]}, ] assert bestGrowthYear(growthData) == 2000 def test_bestGrowthYear_single_height_per_year(): growthData = [ {'year': 2018, 'heights': [7]}, {'year': 2019, 'heights': [6]}, {'year': 2020, 'heights': [10]}, ] assert bestGrowthYear(growthData) == 2020 def test_bestGrowthYear_all_years_same_avg(): growthData = [ {'year': 2018, 'heights': [7, 7]}, {'year': 2019, 'heights': [8, 6]}, {'year': 2020, 'heights': [9, 5]}, ] assert bestGrowthYear(growthData) == 2018","solution":"def bestGrowthYear(growthData): Returns the year with the highest average tree height. If multiple years have the same highest average, return the earliest year among them. max_avg_height = float('-inf') best_year = None for data in growthData: year = data['year'] heights = data['heights'] avg_height = sum(heights) / len(heights) if avg_height > max_avg_height or (avg_height == max_avg_height and (best_year is None or year < best_year)): max_avg_height = avg_height best_year = year return best_year"},{"question":"def max_histogram_area(heights): Returns the maximum rectangular area in the histogram. >>> max_histogram_area([1, 2, 3, 4, 5]) == 9 >>> max_histogram_area([6, 2, 5, 4, 5, 1, 6]) == 12 pass def max_rectangular_area_in_histograms(test_cases): Returns the maximum rectangular area for each histogram in a list of test cases. >>> test_cases = [(5, [1, 2, 3, 4, 5]), (7, [6, 2, 5, 4, 5, 1, 6])] >>> max_rectangular_area_in_histograms(test_cases) == [9, 12] pass","solution":"def max_histogram_area(heights): Returns the maximum rectangular area in the histogram. stack = [] max_area = 0 for i, height in enumerate(heights): while stack and heights[stack[-1]] > height: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack: h = heights[stack.pop()] w = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area def max_rectangular_area_in_histograms(test_cases): Returns the maximum rectangular area for each histogram in a list of test cases. results = [] for n, heights in test_cases: results.append(max_histogram_area(heights)) return results"},{"question":"def find_zero_sum_pairs(arr): Returns a list of unique pairs that add up to zero from the original array. Each inner pair should have the smaller number first. Examples: >>> find_zero_sum_pairs([1, -1, 2, -2, 3]) [[-1, 1], [-2, 2]] >>> find_zero_sum_pairs([3, -3, 4, -4, 5, -5, 3, -3]) [[-3, 3], [-4, 4], [-5, 5]] from solution import find_zero_sum_pairs def test_find_zero_sum_pairs_case_1(): assert find_zero_sum_pairs([1, -1, 2, -2, 3]) == [[-1, 1], [-2, 2]] def test_find_zero_sum_pairs_case_2(): assert find_zero_sum_pairs([3, -3, 4, -4, 5, -5, 3, -3]) == [[-3, 3], [-4, 4], [-5, 5]] def test_find_zero_sum_pairs_no_pairs(): assert find_zero_sum_pairs([1, 2, 3, 4, 5]) == [] def test_find_zero_sum_pairs_with_duplicates(): assert find_zero_sum_pairs([1, -1, 1, -1]) == [[-1, 1]] def test_find_zero_sum_pairs_empty(): assert find_zero_sum_pairs([]) == [] def test_find_zero_sum_pairs_single_element(): assert find_zero_sum_pairs([1]) == [] assert find_zero_sum_pairs([-1]) == [] def test_find_zero_sum_pairs_mix_positive_and_negative(): assert find_zero_sum_pairs([10, -10, -5, 5, 7, -7, 1, -1]) == [[-10, 10], [-5, 5], [-7, 7], [-1, 1]]","solution":"def find_zero_sum_pairs(arr): Returns a list of unique pairs that add up to zero. Each inner pair should have the smaller number first. seen = set() result = [] for num in arr: target = -num if target in seen: pair = sorted([target, num]) if pair not in result: result.append(pair) else: seen.add(num) return result"},{"question":"def can_split_array(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to split the array into two subarrays with equal sum for each test case. Args: T : int : The number of test cases test_cases : List[Tuple[int, List[int]]] : List of tuples, where each tuple contains an integer N and a list of N integers. Returns: List[str] : List containing \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_split_array(2, [(4, [1, 2, 3, 4]), (3, [2, 4, 8])]) [\\"YES\\", \\"NO\\"]","solution":"def can_split_array(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] total_sum = sum(A) if total_sum % 2 != 0: results.append(\\"NO\\") continue # Use set to keep track of prefix sums we have seen prefix_sum_set = set() prefix_sum = 0 for num in A: prefix_sum += num if prefix_sum == total_sum // 2 or (prefix_sum - total_sum // 2) in prefix_sum_set: results.append(\\"YES\\") break prefix_sum_set.add(prefix_sum) else: results.append(\\"NO\\") return results"},{"question":"def find_pair_with_sum(arr, target): Finds two distinct elements in the array such that their sum is equal to the target. If such a pair exists, returns the two elements in non-decreasing order. If no such pair exists, returns \\"Not found\\". Examples: >>> find_pair_with_sum([2, 7, 11, 15, 1], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4], 8) 'Not found'","solution":"def find_pair_with_sum(arr, target): Finds two distinct elements in the array such that their sum is equal to the target. If such a pair exists, returns the two elements in non-decreasing order. If no such pair exists, returns \\"Not found\\". seen = {} for num in arr: complement = target - num if complement in seen: return tuple(sorted((num, complement))) seen[num] = True return \\"Not found\\""},{"question":"def final_robot_coordinates(T: int, commands_list: List[str]) -> List[Tuple[int, int]]: Function to determine the final coordinates of the robot after executing all the commands. Parameters: T (int): The number of test cases. commands_list (list): List of command strings for each test case. Returns: list: List of tuples representing the final coordinates for each test case. >>> final_robot_coordinates(3, [\\"LLRR\\", \\"UDUD\\", \\"LULLL\\"]) [(0, 0), (0, 0), (-4, 1)] >>> final_robot_coordinates(1, [\\"LLLL\\"]) [(-4, 0)] >>> final_robot_coordinates(1, [\\"RRRR\\"]) [(4, 0)] >>> final_robot_coordinates(1, [\\"UUUU\\"]) [(0, 4)] >>> final_robot_coordinates(1, [\\"DDDD\\"]) [(0, -4)] >>> final_robot_coordinates(2, [\\"UDLR\\", \\"DLUR\\"]) [(0, 0), (0, 0)] >>> final_robot_coordinates(1, [\\"\\"]) [(0, 0)]","solution":"def final_robot_coordinates(T, commands_list): Function to determine the final coordinates of the robot after executing all the commands. Parameters: T (int): The number of test cases. commands_list (list): List of command strings for each test case. Returns: list: List of tuples representing the final coordinates for each test case. results = [] for commands in commands_list: x = y = 0 for command in commands: if command == 'L': x -= 1 elif command == 'R': x += 1 elif command == 'U': y += 1 elif command == 'D': y -= 1 results.append((x, y)) return results"},{"question":"import math from typing import Tuple def circle_and_sphere_calculations(radius: float) -> Tuple[float, float, float]: Given the radius of a circle, this function calculates and returns the circumference of the circle, the area of the circle, and the volume of a sphere with the same radius. :param radius: float, the radius of the circle/sphere :return: tuple: (circumference, area, volume) >>> round(circle_and_sphere_calculations(3)[0], 5) == 18.84954 True >>> round(circle_and_sphere_calculations(3)[1], 5) == 28.27431 True >>> round(circle_and_sphere_calculations(3)[2], 5) == 113.09724 True >>> round(circle_and_sphere_calculations(1)[0], 5) == 6.28318 True >>> round(circle_and_sphere_calculations(1)[1], 5) == 3.14159 True >>> round(circle_and_sphere_calculations(1)[2], 5) == 4.18879 True >>> round(circle_and_sphere_calculations(10)[0], 5) == 62.83180 True >>> round(circle_and_sphere_calculations(10)[1], 5) == 314.159 True >>> round(circle_and_sphere_calculations(10)[2], 5) == 4188.78667 True >>> round(circle_and_sphere_calculations(0)[0], 5) == 0.0 True >>> round(circle_and_sphere_calculations(0)[1], 5) == 0.0 True >>> round(circle_and_sphere_calculations(0)[2], 5) == 0.0 True","solution":"import math def circle_and_sphere_calculations(radius): Given the radius of a circle, this function calculates and returns the circumference of the circle, the area of the circle, and the volume of a sphere with the same radius. :param radius: float, the radius of the circle/sphere :return: tuple: (circumference, area, volume) pi = 3.14159 circumference = 2 * pi * radius area = pi * radius**2 volume = (4/3) * pi * radius**3 return circumference, area, volume"},{"question":"def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: Given an integer array nums and an integer target, find all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 1. 0 <= a, b, c, d < nums.length 2. a, b, c, and d are distinct indices 3. nums[a] + nums[b] + nums[c] + nums[d] == target Return an array containing all such unique quadruplets. The solution set must not contain duplicate quadruplets. >>> findQuadruplets([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> findQuadruplets([1, 2, 3, 4], 50) [] >>> findQuadruplets([1], 0) [] >>> findQuadruplets([1, 1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> findQuadruplets([-3, -1, 0, 2, 4, 5], 2) [[-3, -1, 2, 4]]","solution":"def findQuadruplets(nums, target): nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, length - 1 while left < right: sum_quad = nums[i] + nums[j] + nums[left] + nums[right] if sum_quad == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_quad < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def sum_even_or_odd(lst: List[int]) -> str: Returns a string indicating whether the sum of the integers in the list is even or odd. Parameters: lst (list of int): A list of integers. Returns: str: \\"The sum is even\\" if the sum of the list is even, \\"The sum is odd\\" if the sum is odd. >>> sum_even_or_odd([]) == \\"The sum is even\\" >>> sum_even_or_odd([2]) == \\"The sum is even\\" >>> sum_even_or_odd([1]) == \\"The sum is odd\\" >>> sum_even_or_odd([2, 4, 6]) == \\"The sum is even\\" >>> sum_even_or_odd([1, 3, 5]) == \\"The sum is odd\\" >>> sum_even_or_odd([1, 2, 3]) == \\"The sum is even\\" >>> sum_even_or_odd([1, 2, 4]) == \\"The sum is odd\\"","solution":"def sum_even_or_odd(lst): Returns a string indicating whether the sum of the integers in the list is even or odd. Parameters: lst (list of int): A list of integers. Returns: str: \\"The sum is even\\" if the sum of the list is even, \\"The sum is odd\\" if the sum is odd. total = sum(lst) if total % 2 == 0: return \\"The sum is even\\" else: return \\"The sum is odd\\""},{"question":"from math import gcd from functools import reduce from typing import List, Tuple def process_test_case(n: int, elements: List[int]) -> int: Returns the final value of all elements in the list after replacing pairs with their GCD until all values are the same. # The function should return the greatest common divisor of all list elements. def main(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns results. # The function should return a list of results for each test case. def test_process_test_case(): assert process_test_case(3, [2, 4, 8]) == 2 assert process_test_case(5, [14, 7, 28, 49, 21]) == 7 assert process_test_case(4, [10, 20, 30, 20]) == 10 assert process_test_case(2, [5, 15]) == 5 assert process_test_case(3, [1, 1, 1]) == 1 def test_main(): t = 3 test_cases = [ (3, [2, 4, 8]), (5, [14, 7, 28, 49, 21]), (4, [10, 20, 30, 20]) ] assert main(t, test_cases) == [2, 7, 10] t = 2 test_cases = [ (3, [3, 6, 9]), (4, [12, 15, 18, 21]) ] assert main(t, test_cases) == [3, 3]","solution":"from math import gcd from functools import reduce def process_test_case(n, elements): Returns the final value of all elements in the list after replacing pairs with their GCD until all values are the same. # The final value will be the GCD of all elements in the list return reduce(gcd, elements) def main(t, test_cases): Processes multiple test cases and returns results. results = [] for i in range(t): n = test_cases[i][0] elements = test_cases[i][1] results.append(process_test_case(n, elements)) return results"},{"question":"def squirrels_hit_each_other(n, throws): Determine if any pair of squirrels hit each other with their nut throws. :param n: Number of squirrels :param throws: List of tuples, each containing position and throw distance of a squirrel. :return: 'YES' if there exists a pair that hits each other, otherwise 'NO'.","solution":"def squirrels_hit_each_other(n, throws): Determine if any pair of squirrels hit each other with their nut throws. :param n: Number of squirrels :param throws: List of tuples, each containing position and throw distance of a squirrel. :return: 'YES' if there exists a pair that hits each other, otherwise 'NO'. throw_map = {} # Dictionary to store the resulting positions after throws for position, distance in throws: right_throw = position + distance left_throw = position - distance # Check if the current position matches the right throw of any previous squirrel # or the left throw of any previous squirrel if right_throw in throw_map or left_throw in throw_map: return \\"YES\\" # Store the current position as reachable by the right and left throws throw_map[position] = (right_throw, left_throw) return \\"NO\\""},{"question":"def longest_subarray_with_sum(nums: List[int], S: int) -> int: Returns the length of the longest contiguous subarray that sums up to exactly S. >>> longest_subarray_with_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_with_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_with_sum([1, 2, 3], 7) 0","solution":"def longest_subarray_with_sum(nums, S): Returns the length of the longest contiguous subarray that sums up to exactly S. prefix_sum = {0: -1} # Dictionary to store the first occurrence of prefix sums current_sum = 0 max_len = 0 for i, num in enumerate(nums): current_sum += num if current_sum - S in prefix_sum: max_len = max(max_len, i - prefix_sum[current_sum - S]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return max_len"},{"question":"def find_ceremonies(N: int, ids: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Determine the total number of ceremonies where the sum of two IDs equals 10, and return the list of the pairs of IDs participating in each ceremony. >>> find_ceremonies(6, [1, 9, 2, 8, 7, 3]) (3, [(1, 9), (2, 8), (3, 7)]) >>> find_ceremonies(4, [1, 2, 3, 4]) (0, []) >>> find_ceremonies(4, [1, 3, 7, 9]) (2, [(1, 9), (3, 7)]) >>> find_ceremonies(3, [1, 9, 11]) (1, [(1, 9)]) >>> find_ceremonies(6, [1, 9, 1, 9, 1, 9]) (3, [(1, 9), (1, 9), (1, 9)])","solution":"def find_ceremonies(N, ids): ids.sort() start, end = 0, N - 1 ceremonies = [] while start < end: sum_ids = ids[start] + ids[end] if sum_ids == 10: ceremonies.append((ids[start], ids[end])) start += 1 end -= 1 elif sum_ids < 10: start += 1 else: end -= 1 return len(ceremonies), ceremonies"},{"question":"def manage_inventory(operations): Manages the book inventory and processes a list of operations. Args: operations (list of str): List of operations to perform. Returns: list: Results of query operations. from solution import manage_inventory def test_add_books(): assert manage_inventory([ 'add Book1 5', 'add Book2 3', 'query Book1', 'query Book2' ]) == [5, 3] def test_update_books(): assert manage_inventory([ 'add Book1 5', 'add Book2 3', 'update Book1 4', 'update Book2 -1', 'query Book1', 'query Book2' ]) == [9, 2] def test_mixed_operations(): assert manage_inventory([ 'add Book1 5', 'add Book2 3', 'update Book1 4', 'update Book2 -1', 'query Book1', 'query Book2', 'add Book3 7', 'update Book3 -2', 'query Book3' ]) == [9, 2, 5] def test_update_to_zero(): assert manage_inventory([ 'add Book1 10', 'update Book1 -10', 'query Book1' ]) == [0] def test_no_books(): assert manage_inventory([]) == []","solution":"def manage_inventory(operations): Manages the book inventory and processes a list of operations. Args: operations (list of str): List of operations to perform. Returns: list: Results of query operations. inventory = {} result = [] for operation in operations: parts = operation.split() command = parts[0] title = parts[1] if command == 'add': count = int(parts[2]) inventory[title] = count elif command == 'update': count = int(parts[2]) if title in inventory: inventory[title] += count elif command == 'query': if title in inventory: result.append(inventory[title]) return result"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. from collections import defaultdict if len(s) <= 2: return len(s) left = 0 max_len = 0 char_count = defaultdict(int) for right in range(len(s)): char_count[s[right]] += 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def longestSubstringWithKDistinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. >>> longestSubstringWithKDistinct(\\"eceba\\", 2) 3 >>> longestSubstringWithKDistinct(\\"aa\\", 1) 2 >>> longestSubstringWithKDistinct(\\"\\", 2) 0 >>> longestSubstringWithKDistinct(\\"eceba\\", 0) 0 >>> longestSubstringWithKDistinct(\\"a\\", 1) 1 >>> longestSubstringWithKDistinct(\\"aabacbebebe\\", 3) 7 >>> longestSubstringWithKDistinct(\\"aabacbebebe\\", 10) 11 >>> longestSubstringWithKDistinct(\\"abcdef\\", 3) 3 >>> longestSubstringWithKDistinct(\\"abc\\", 5) 3","solution":"def longestSubstringWithKDistinct(s, k): Returns the length of the longest substring with at most k distinct characters. if k == 0 or not s: return 0 char_count = {} max_length = 0 left = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, collect the tree's nodes in a level-order traversal from bottom to top. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrderBottom(root) [[15, 7], [9, 20], [3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> levelOrderBottom(root) [[4, 5], [2, 3], [1]] >>> levelOrderBottom(None) [] >>> root = TreeNode(1) >>> levelOrderBottom(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> levelOrderBottom(root) [[2, 3], [1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> levelOrderBottom(root) [[3], [2], [1]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderBottom(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.insert(0, level) return result"},{"question":"def can_arrange_books(book_heights, height_limit): Determines if all the books can be arranged within the shelves without exceeding the height limit of a single shelf. Args: book_heights (list of int): heights of the books. height_limit (int): the height limit of each shelf. Returns: str: 'YES' if all books can be arranged within the given shelves, 'NO' otherwise. Examples: >>> can_arrange_books([1, 2, 3, 4, 5], 15) 'YES' >>> can_arrange_books([6, 7, 8, 9, 10], 25) 'YES' >>> can_arrange_books([11, 12, 13, 14, 15], 50) 'NO' >>> can_arrange_books([], 10) 'YES' >>> can_arrange_books([10], 10) 'YES' >>> can_arrange_books([20], 10) 'NO'","solution":"def can_arrange_books(book_heights, height_limit): Determines if all the books can be arranged within the shelves without exceeding the height limit of a single shelf. Args: book_heights (list of int): heights of the books. height_limit (int): the height limit of each shelf. Returns: str: 'YES' if all books can be arranged within the given shelves, 'NO' otherwise. total_height = sum(book_heights) if total_height <= height_limit: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_common_prefix(strs: List[str]) -> str: Determine the longest common prefix of a list of strings. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"hello\\"]) \\"hello\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"abc\\", \\"ab\\"]) \\"ab\\" >>> longest_common_prefix([\\"common\\", \\"common\\"]) \\"common\\" >>> longest_common_prefix([\\"\\", \\"\\"]) \\"\\"","solution":"def longest_common_prefix(strs): Function to determine the longest common prefix of a list of strings. Parameters: strs (list of str): list of strings Returns: str: longest common prefix or an empty string if there is no common prefix if not strs: return \\"\\" prefix = strs[0] for string in strs[1:]: while string[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] return prefix"},{"question":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def insert_into_circular_list(head: Node, value: int) -> Node: Insert a new node with the given value into the circular linked list in sorted order. >>> head = Node(3) >>> head.next = Node(5, head) >>> insert_into_circular_list(head, 4) [3, 4, 5] >>> insert_into_circular_list(None, 1) [1] pass","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def insert_into_circular_list(head: Node, value: int) -> Node: new_node = Node(value) # Case 1: The list is empty if not head: new_node.next = new_node return new_node # Case 2: Insert in the non-empty list current = head while True: # Case 2.1: Insert between current and current.next if (current.val <= value <= current.next.val) or (current.val > current.next.val and (value > current.val or value < current.next.val)): new_node.next = current.next current.next = new_node break current = current.next # Case 2.2: We have looped the entire list and none of the above conditions met, place after current if current == head: new_node.next = current.next current.next = new_node break # Case 3: Deciding the new head (if head is greater than the value being inserted, new_node is the new head) if value < head.val: return new_node else: return head"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number is a prime number. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(20) == False >>> is_prime(1) == False def filter_primes(numbers: List[int]) -> List[int]: Returns a list containing only the prime numbers from the input list of integers. >>> filter_primes([10, 11, 12, 13, 14, 15]) == [11, 13] >>> filter_primes([2, 3, 4, 5, 6, 7]) == [2, 3, 5, 7] >>> filter_primes([1, 2, 3, 4, 5]) == [2, 3, 5] >>> filter_primes([10, 20, 30, 40]) == [] >>> filter_primes([]) == [] >>> filter_primes([30, 37, 41, 42, 43, 45]) == [37, 41, 43]","solution":"def is_prime(n): Checks if a number is a prime number. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n ** 0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the input list of integers. return [num for num in numbers if is_prime(num)]"},{"question":"def sort_teams(test_cases: list) -> list: Sort teams based on given keywords lexicographically. In case of a tie, break the tie by the team ID in ascending order. Args: test_cases (list): A list of test cases. Each test case is a dictionary containing: - 'N': Number of teams - 'teams': A list of dictionaries, each containing: - 'teamID': The teams unique ID - 'keywords': List of keywords associated with the team Returns: list: A list of strings. Each string contains the sorted team IDs for the respective test case. Examples: >>> test_cases = [ { 'N': 3, 'teams': [ {'teamID': 2, 'keywords': ['apple', 'banana', 'cherry']}, {'teamID': 1, 'keywords': ['apple', 'banana']}, {'teamID': 3, 'keywords': ['apple', 'cherry']} ] }, { 'N': 2, 'teams': [ {'teamID': 1, 'keywords': ['lemon', 'orange']}, {'teamID': 2, 'keywords': ['apple', 'banana']} ] } ] >>> sort_teams(test_cases) [\\"1 2 3\\", \\"2 1\\"]","solution":"def sort_teams(test_cases): results = [] for case in test_cases: N = case['N'] teams = case['teams'] # Sort based on keywords lexicographically, and in case of tie, by teamID sorted_teams = sorted(teams, key=lambda team: (team['keywords'], team['teamID'])) # Collect sorted team IDs sorted_team_ids = [team['teamID'] for team in sorted_teams] results.append(\\" \\".join(map(str, sorted_team_ids))) return results"},{"question":"def sum_even_product_odd(lst: list) -> tuple: Compute the sum of all even numbers and the product of all odd numbers in the list. Parameters: lst (list of int): List of integers. Returns: tuple: A tuple containing the sum of the even numbers and the product of the odd numbers. Examples: >>> sum_even_product_odd([2, 3, 4, 5]) (6, 15) >>> sum_even_product_odd([1, 3, 5]) (0, 15) >>> sum_even_product_odd([2, 4, 6]) (12, 1) >>> sum_even_product_odd([]) (0, 1) >>> sum_even_product_odd([7]) (0, 7) >>> sum_even_product_odd([8]) (8, 1) >>> sum_even_product_odd([2, -3, 4, -5]) (6, 15) >>> sum_even_product_odd([-2, -4, -6]) (-12, 1) >>> sum_even_product_odd([-1, -3, -5]) (0, -15)","solution":"def sum_even_product_odd(lst): Compute the sum of all even numbers and the product of all odd numbers in the list. Parameters: lst (list of int): List of integers. Returns: tuple: A tuple containing the sum of the even numbers and the product of the odd numbers. sum_even = 0 product_odd = 1 for num in lst: if num % 2 == 0: sum_even += num else: product_odd *= num if all(num % 2 == 0 for num in lst): product_odd = 1 return (sum_even, product_odd)"},{"question":"def longest_alternating_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray that alternates between even and odd numbers. >>> longest_alternating_subarray([1, 2, 3, 4, 5, 6]) 6 >>> longest_alternating_subarray([2, 4, 6, 8, 10]) 1 >>> longest_alternating_subarray([1]) 1 >>> longest_alternating_subarray([2]) 1 >>> longest_alternating_subarray([]) 0","solution":"def longest_alternating_subarray(arr): Returns the length of the longest contiguous subarray that alternates between even and odd numbers. Parameters: arr (list of int): The list of integers to check. Returns: int: The length of the longest alternating subarray. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if (arr[i] % 2 == 0 and arr[i-1] % 2 != 0) or (arr[i] % 2 != 0 and arr[i-1] % 2 == 0): current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def temperature_difference(datasets): Given a list of datasets, each containing temperatures for a given week, returns a list of strings with differences between the highest and lowest temperatures for each dataset. >>> temperature_difference([[20, 30, 25, 35, 31, 20, 22]]) [\\"TEMP DIFF 15\\"] >>> temperature_difference([[-10, -15, -20, -5, -12, -18, -14]]) [\\"TEMP DIFF 15\\"] pass def parse_input(num_datasets, all_temperatures): Parses and structures the input data to make it suitable for the main function. >>> parse_input(1, [20, 30, 25, 35, 31, 20, 22]) [[20, 30, 25, 35, 31, 20, 22]] >>> parse_input(1, [-10, -15, -20, -5, -12, -18, -14]) [[-10, -15, -20, -5, -12, -18, -14]] pass def main(input_data): Main function to integrate the input parsing and temperature difference calculation. >>> main(\\"1n20 30 25 35 31 20 22\\") [\\"TEMP DIFF 15\\"] >>> main(\\"1n-10 -15 -20 -5 -12 -18 -14\\") [\\"TEMP DIFF 15\\"] pass","solution":"def temperature_difference(datasets): Given a list of datasets, each containing temperatures for a given week, returns a list of strings with differences between the highest and lowest temperatures for each dataset. result = [] for temperatures in datasets: highest_temp = max(temperatures) lowest_temp = min(temperatures) diff = highest_temp - lowest_temp result.append(f\\"TEMP DIFF {diff}\\") return result def parse_input(num_datasets, all_temperatures): Parses and structures the input data to make it suitable for the main function. datasets = [] index = 0 for _ in range(num_datasets): dataset = all_temperatures[index:index+7] datasets.append(dataset) index += 7 return datasets def main(input_data): Main function to integrate the input parsing and temperature difference calculation. lines = input_data.strip().split('n') num_datasets = int(lines[0]) all_temperatures = list(map(int, ' '.join(lines[1:]).split())) datasets = parse_input(num_datasets, all_temperatures) return temperature_difference(datasets)"},{"question":"def smallest_number_after_deleting_one_digit(number: str) -> int: Returns the smallest number that can be obtained by deleting exactly one digit of the given number. Parameters: number (str): A string of digits to process. Returns: int: The smallest number after deleting one digit. >>> smallest_number_after_deleting_one_digit(\\"152\\") 12 >>> smallest_number_after_deleting_one_digit(\\"1001\\") 1","solution":"def smallest_number_after_deleting_one_digit(number): Returns the smallest number that can be obtained by deleting exactly one digit of the given number. Parameters: number (str): A string of digits to process. Returns: int: The smallest number after deleting one digit. smallest = float('inf') for i in range(len(number)): # Removing the i-th digit new_number = int(number[:i] + number[i+1:]) # Update the smallest number found if new_number < smallest: smallest = new_number return smallest"},{"question":"def get_top_k_songs(songs: List[Dict[str, int]], k: int) -> List[Dict[str, int]]: Returns the top k most played songs from the playlist. If two songs have the same play count, the song that appears first in the playlist is preferred. Args: songs (List[Dict[str, int]]): List of dictionaries where each dictionary contains 'title' and 'play_count'. k (int): The number of top songs to return. Returns: List[Dict[str, int]]: List of top k most played songs. Examples: >>> songs = [ ... {\\"title\\": \\"Song A\\", \\"play_count\\": 30}, ... {\\"title\\": \\"Song B\\", \\"play_count\\": 55}, ... {\\"title\\": \\"Song C\\", \\"play_count\\": 25}, ... {\\"title\\": \\"Song D\\", \\"play_count\\": 55}, ... {\\"title\\": \\"Song E\\", \\"play_count\\": 10} ... ] >>> k = 2 >>> get_top_k_songs(songs, k) [{'title': 'Song B', 'play_count': 55}, {'title': 'Song D', 'play_count': 55}] >>> k = 3 >>> get_top_k_songs(songs, k) [{'title': 'Song B', 'play_count': 55}, {'title': 'Song D', 'play_count': 55}, {'title': 'Song A', 'play_count': 30}] pass from typing import List, Dict def test_get_top_k_songs_basic(): songs = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 30}, {\\"title\\": \\"Song B\\", \\"play_count\\": 55}, {\\"title\\": \\"Song C\\", \\"play_count\\": 25}, {\\"title\\": \\"Song D\\", \\"play_count\\": 55}, {\\"title\\": \\"Song E\\", \\"play_count\\": 10} ] k = 2 expected = [ {\\"title\\": \\"Song B\\", \\"play_count\\": 55}, {\\"title\\": \\"Song D\\", \\"play_count\\": 55} ] assert get_top_k_songs(songs, k) == expected def test_get_top_k_songs_with_ties(): songs = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 30}, {\\"title\\": \\"Song B\\", \\"play_count\\": 55}, {\\"title\\": \\"Song C\\", \\"play_count\\": 25}, {\\"title\\": \\"Song D\\", \\"play_count\\": 55}, {\\"title\\": \\"Song E\\", \\"play_count\\": 10} ] k = 3 expected = [ {\\"title\\": \\"Song B\\", \\"play_count\\": 55}, {\\"title\\": \\"Song D\\", \\"play_count\\": 55}, {\\"title\\": \\"Song A\\", \\"play_count\\": 30} ] assert get_top_k_songs(songs, k) == expected def test_get_top_k_songs_single_song(): songs = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 30} ] k = 1 expected = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 30} ] assert get_top_k_songs(songs, k) == expected def test_get_top_k_songs_all_same_play_count(): songs = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 10}, {\\"title\\": \\"Song B\\", \\"play_count\\": 10}, {\\"title\\": \\"Song C\\", \\"play_count\\": 10}, {\\"title\\": \\"Song D\\", \\"play_count\\": 10} ] k = 2 expected = [ {\\"title\\": \\"Song A\\", \\"play_count\\": 10}, {\\"title\\": \\"Song B\\", \\"play_count\\": 10} ] assert get_top_k_songs(songs, k) == expected def test_get_top_k_songs_large_playlist(): songs = [{\\"title\\": f\\"Song {i}\\", \\"play_count\\": i} for i in range(100)] k = 10 expected = [{\\"title\\": f\\"Song {i}\\", \\"play_count\\": i} for i in range(99, 89, -1)] assert get_top_k_songs(songs, k) == expected","solution":"def get_top_k_songs(songs, k): Returns the top k most played songs from the playlist. If two songs have the same play count, the song that appears first in the playlist is preferred. # Sort the songs by play count in descending order and by their original order if play counts are the same sorted_songs = sorted(songs, key=lambda x: (-x['play_count'], songs.index(x))) # Return the top k songs return sorted_songs[:k]"},{"question":"def generate_sequence(n: int, f: Callable[[int], int]) -> List[int]: Generates the first \`n\` values of a sequence defined by the function \`f\`. :param n: The number of values to generate. :param f: A function that takes an index and returns the corresponding value in the sequence. :return: A list of the first \`n\` values of the sequence. >>> def fib(index: int) -> int: >>> if index == 0: >>> return 0 >>> elif index == 1: >>> return 1 >>> else: >>> return fib(index - 1) + fib(index - 2) >>> generate_sequence(5, fib) [0, 1, 1, 2, 3] from typing import List, Callable def test_generate_sequence_with_fib(): assert generate_sequence(0, fib) == [] assert generate_sequence(1, fib) == [0] assert generate_sequence(2, fib) == [0, 1] assert generate_sequence(3, fib) == [0, 1, 1] assert generate_sequence(5, fib) == [0, 1, 1, 2, 3] def test_generate_sequence_custom_function(): square = lambda x: x ** 2 assert generate_sequence(0, square) == [] assert generate_sequence(1, square) == [0] assert generate_sequence(2, square) == [0, 1] assert generate_sequence(3, square) == [0, 1, 4] assert generate_sequence(5, square) == [0, 1, 4, 9, 16] def test_generate_sequence_custom_function_doubling(): double = lambda x: x * 2 assert generate_sequence(0, double) == [] assert generate_sequence(1, double) == [0] assert generate_sequence(2, double) == [0, 2] assert generate_sequence(3, double) == [0, 2, 4] assert generate_sequence(5, double) == [0, 2, 4, 6, 8]","solution":"from typing import List, Callable def generate_sequence(n: int, f: Callable[[int], int]) -> List[int]: Generates the first \`n\` values of a sequence defined by the function \`f\`. :param n: The number of values to generate. :param f: A function that takes an index and returns the corresponding value in the sequence. :return: A list of the first \`n\` values of the sequence. return [f(i) for i in range(n)] def fib(index: int) -> int: Returns the Fibonacci number at the given index \`index\`. :param index: The index in the Fibonacci sequence. :return: The Fibonacci number. if index == 0: return 0 elif index == 1: return 1 else: return fib(index - 1) + fib(index - 2)"},{"question":"def count_vowels(s: str) -> int: Count the number of vowels (a, e, i, o, u) in the given string. The function should be case-insensitive. >>> count_vowels(\\"Hello World\\") 3 >>> count_vowels(\\"Programming is fun!\\") 5 >>> count_vowels(\\"\\") 0 >>> count_vowels(\\"aeiouAEIOU\\") 10 >>> count_vowels(\\"bcdfghjklmnpqrstvwxyz\\") 0 >>> count_vowels(\\"12345Aeiou!\\") 5 Parameters: s (str): The input string. Returns: int: Number of vowels in the string.","solution":"def count_vowels(s): Counts the number of vowels (a, e, i, o, u) in the given string s. The function is case-insensitive. Parameters: s (str): The input string. Returns: int: Number of vowels in the string. vowels = 'aeiou' count = 0 for char in s.lower(): if char in vowels: count += 1 return count"},{"question":"def parse_log(log_entry: str) -> dict: Parses a log entry to extract the IP address, date, and requested resource. Args: log_entry (str): A string representing one log entry. Returns: dict: A dictionary with the keys 'ip', 'date', and 'request' containing the respective parsed data. >>> parse_log('127.0.0.1 - - [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\"') {'ip': '127.0.0.1', 'date': '10/Oct/2000:13:55:36 -0700', 'request': 'GET /apache_pb.gif HTTP/1.0'} >>> parse_log('192.168.1.1 - - [15/May/2021:10:15:42 -0700] \\"POST /api/v1/users HTTP/2\\"') {'ip': '192.168.1.1', 'date': '15/May/2021:10:15:42 -0700', 'request': 'POST /api/v1/users HTTP/2'} >>> parse_log('10.0.0.1 - - [01/Jan/2022:00:00:00 -0700] \\"PUT /data HTTP/1.1\\"') {'ip': '10.0.0.1', 'date': '01/Jan/2022:00:00:00 -0700', 'request': 'PUT /data HTTP/1.1'} >>> parse_log('172.16.0.1 - - [11/Nov/2021:18:00:00 -0700] \\"DELETE /files/sample.txt HTTP/1.1\\"') {'ip': '172.16.0.1', 'date': '11/Nov/2021:18:00:00 -0700', 'request': 'DELETE /files/sample.txt HTTP/1.1'} >>> parse_log('203.0.113.1 - - [25/Dec/2021:23:59:59 -0700] \\"OPTIONS /api/endpoint HTTP/2\\"') {'ip': '203.0.113.1', 'date': '25/Dec/2021:23:59:59 -0700', 'request': 'OPTIONS /api/endpoint HTTP/2'}","solution":"def parse_log(log_entry): Parses a log entry to extract the IP address, date, and requested resource. Args: log_entry (str): A string representing one log entry. Returns: dict: A dictionary with the keys 'ip', 'date', and 'request' containing the respective parsed data. parts = log_entry.split(' ') ip = parts[0] date = log_entry.split('[')[1].split(']')[0] request = log_entry.split('\\"')[1] return { 'ip': ip, 'date': date, 'request': request }"},{"question":"import heapq class UserIDManager: A company wants to build an application that assigns unique user IDs to its users. They want the IDs to be incremental starting from 1. However, they also need a feature that allows deactivation of user accounts, freeing up the IDs. When a new user registers, the system should assign the smallest available ID that is not currently in use. def __init__(self): Initializes an empty UserIDManager. def register(self) -> int: Registers a new user and returns the assigned user ID. >>> manager = UserIDManager() >>> manager.register() 1 >>> manager.register() 2 def deactivate(self, user_id: int) -> None: Deactivates the given user ID, making it available for future registrations. >>> manager = UserIDManager() >>> manager.register() 1 >>> manager.register() 2 >>> manager.deactivate(1)","solution":"import heapq class UserIDManager: def __init__(self): self.available_ids = [] self.next_id = 1 def register(self) -> int: if self.available_ids: return heapq.heappop(self.available_ids) else: user_id = self.next_id self.next_id += 1 return user_id def deactivate(self, user_id: int) -> None: if user_id < self.next_id and user_id not in self.available_ids: heapq.heappush(self.available_ids, user_id)"},{"question":"def can_split(s: str, word_dict: List[str], max_splits: int) -> bool: Determine if the string can be split into words from the dictionary using at most max_splits splits. :param s: The input string to be split. :param word_dict: List of words that can be used to split the string. :param max_splits: Maximum number of splits allowed. :return: True if s can be split within max_splits, otherwise False. >>> can_split(\\"applepenapple\\", [\\"apple\\", \\"pen\\"], 2) True >>> can_split(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"], 1) False >>> can_split(\\"aaaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\"], 2) True >>> can_split(\\"apple\\", [\\"apple\\"], 0) True >>> can_split(\\"applepen\\", [\\"a\\", \\"b\\"], 2) False >>> can_split(\\"aaaabbbb\\", [\\"aaaa\\", \\"bbbb\\"], 1) True","solution":"def can_split(s, word_dict, max_splits): Determine if the string can be split into words from the dictionary using at most max_splits splits. :param s: The input string to be split. :param word_dict: List of words that can be used to split the string. :param max_splits: Maximum number of splits allowed. :return: True if s can be split within max_splits, otherwise False. n = len(s) word_set = set(word_dict) def can_split_recursive(start_index, splits_left): if start_index == n: return True if splits_left < 0: return False for end_index in range(start_index + 1, n + 1): if s[start_index:end_index] in word_set: if can_split_recursive(end_index, splits_left - 1): return True return False return can_split_recursive(0, max_splits)"},{"question":"def subarray_weights(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the weight of subarrays as per the queries. Parameters: n (int): The length of the array. q (int): The number of queries. arr (list of int): The array elements. queries (list of tuple): List of (l, r) queries. Returns: list of int: Weights of the subarrays for each query. Examples: >>> subarray_weights(10, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [(1, 5), (3, 7), (6, 10)]) [5, 5, 5] >>> subarray_weights(6, 2, [4, 1, 5, 3, 2, 6], [(2, 4), (1, 6)]) [2, 3]","solution":"def subarray_weights(n, q, arr, queries): Calculate the weight of subarrays as per the queries. Parameters: n (int): The length of the array. q (int): The number of queries. arr (list of int): The array elements. queries (list of tuple): List of (l, r) queries. Returns: list of int: Weights of the subarrays for each query. results = [] for l, r in queries: subarray = arr[l-1:r] weight = 0 max_element = float('-inf') for element in subarray: if element > max_element: max_element = element weight += 1 results.append(weight) return results"},{"question":"from typing import List def calculate_total_bonus(ratings: List[int]) -> int: Calculates the total amount of bonuses based on performance ratings. Parameters: - ratings (List[int]): A list of integers where each integer represents an employee's performance rating (1 to 5). Returns: - int: The total amount of bonuses to be distributed. Examples: >>> calculate_total_bonus([1, 3, 4, 5, 2, 5, 3]) 6000 >>> calculate_total_bonus([1, 2, 1, 2, 1]) 0 >>> calculate_total_bonus([5, 5, 5]) 6000 >>> calculate_total_bonus([1, 1, 1]) 0 >>> calculate_total_bonus([3, 3, 3]) 1500 >>> calculate_total_bonus([5]) 2000 >>> calculate_total_bonus([3]) 500 >>> calculate_total_bonus([4]) 1000 >>> calculate_total_bonus([2]) 0 # Implementation here","solution":"from typing import List def calculate_total_bonus(ratings: List[int]) -> int: Calculates the total amount of bonuses based on performance ratings. Parameters: - ratings (List[int]): A list of integers where each integer represents an employee's performance rating (1 to 5). Returns: - int: The total amount of bonuses to be distributed. bonus_distribution = { 1: 0, 2: 0, 3: 500, 4: 1000, 5: 2000 } total_bonus = sum(bonus_distribution[rating] for rating in ratings) return total_bonus"},{"question":"def max_min_product(lst: List[int]) -> int: Returns the product of the maximum and minimum values in the list. >>> max_min_product([4, 3, 6, 8, 2]) 16 >>> max_min_product([-3, 0, -2, 5, 9]) -27","solution":"def max_min_product(lst): Returns the product of the maximum and minimum values in the list. max_val = max(lst) min_val = min(lst) return max_val * min_val"},{"question":"def min_moves_to_palindrome(s: str) -> int: Returns the minimum number of moves required to make the string a palindrome. >>> min_moves_to_palindrome(\\"abca\\") 1 >>> min_moves_to_palindrome(\\"racecar\\") 0 >>> min_moves_to_palindrome(\\"hello\\") 2 >>> min_moves_to_palindrome(\\"abcba\\") 0 >>> min_moves_to_palindrome(\\"a\\") 0 >>> min_moves_to_palindrome(\\"aa\\") 0 >>> min_moves_to_palindrome(\\"ab\\") 1 pass def solve(t: int, strings: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list. >>> solve(4, [\\"abca\\", \\"racecar\\", \\"hello\\", \\"abcba\\"]) [1, 0, 2, 0] >>> solve(3, [\\"a\\", \\"aa\\", \\"ab\\"]) [0, 0, 1] >>> solve(1, [\\"madam\\"]) [0] >>> solve(2, [\\"abcd\\", \\"dcba\\"]) [2, 2] pass","solution":"def min_moves_to_palindrome(s): Returns the minimum number of moves required to make the string a palindrome. left, right = 0, len(s) - 1 moves = 0 while left < right: if s[left] != s[right]: moves += 1 left += 1 right -= 1 return moves def solve(t, strings): results = [] for s in strings: results.append(min_moves_to_palindrome(s)) return results"},{"question":"def find_median(numbers: List[int]) -> float: Returns the median value of a list of integers. >>> find_median([3, 1, 2]) 2 >>> find_median([4, 1, 7, 2, 6]) 4 >>> find_median([20, 1, 2, 3, 4]) 3 >>> find_median([7, 9, 2, 10, 3, 5]) 6","solution":"def find_median(numbers): Returns the median of the list of numbers. numbers.sort() # Sort the list in ascending order n = len(numbers) mid = n // 2 if n % 2 == 0: # If even, the median is the average of the two middle numbers return (numbers[mid - 1] + numbers[mid]) / 2 else: # If odd, the median is the middle number return numbers[mid]"},{"question":"def max_subarray_sum(nums): Finds the subarray (containing at least one number) which has the largest sum and returns its sum. For example: >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5,4,-1,7,8]) == 23","solution":"def max_subarray_sum(nums): Finds the subarray with the largest sum and returns its sum. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(13) True >>> is_prime(1) False pass def primes_less_than_n(N: int) -> list: Returns a list of all prime numbers less than N. >>> primes_less_than_n(10) [2, 3, 5, 7] >>> primes_less_than_n(2) [] >>> primes_less_than_n(12) [2, 3, 5, 7, 11] >>> primes_less_than_n(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> primes_less_than_n(3) [2] >>> primes_less_than_n(1) [] >>> primes_less_than_n(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def primes_less_than_n(N): Returns a list of all prime numbers less than N. return [num for num in range(2, N) if is_prime(num)]"},{"question":"def categorize_string(s: str, n: int, key_category_pairs: List[Tuple[str, str]]) -> str: Categorize a string based on the first occurring keyword in it. Parameters: s (str): The string to be categorized n (int): The number of keyword-category pairs key_category_pairs (list of tuples): A list where each tuple contains a keyword and its corresponding category Returns: str: The category of the string based on the first matching keyword, \\"no category found\\" if no match pass def test_no_match(): s = \\"thisisateststring\\" n = 2 key_category_pairs = [(\\"key1\\", \\"category1\\"), (\\"key2\\", \\"category2\\")] assert categorize_string(s, n, key_category_pairs) == \\"no category found\\" def test_single_match(): s = \\"thisisateststringwithakeyword\\" n = 2 key_category_pairs = [(\\"keyword\\", \\"category1\\"), (\\"test\\", \\"category2\\")] assert categorize_string(s, n, key_category_pairs) == \\"category2\\" def test_multiple_matches(): s = \\"findthecorrectmatch\\" n = 3 key_category_pairs = [(\\"correct\\", \\"category1\\"), (\\"find\\", \\"category2\\"), (\\"match\\", \\"category3\\")] assert categorize_string(s, n, key_category_pairs) == \\"category2\\" def test_match_overlap(): s = \\"abcdabcdabcd\\" n = 3 key_category_pairs = [(\\"abc\\", \\"category1\\"), (\\"bcd\\", \\"category2\\"), (\\"abcd\\", \\"category3\\")] assert categorize_string(s, n, key_category_pairs) == \\"category1\\" def test_exact_match(): s = \\"perfectmatch\\" n = 1 key_category_pairs = [(\\"perfectmatch\\", \\"category1\\")] assert categorize_string(s, n, key_category_pairs) == \\"category1\\"","solution":"def categorize_string(s, n, key_category_pairs): Categorize a string based on the first occurring keyword in it. Parameters: s (str): The string to be categorized n (int): The number of keyword-category pairs key_category_pairs (list of tuples): A list where each tuple contains a keyword and its corresponding category Returns: str: The category of the string based on the first matching keyword, \\"no category found\\" if no match earliest_index = len(s) category = \\"no category found\\" for keyword, cat in key_category_pairs: index = s.find(keyword) if index != -1 and index < earliest_index: earliest_index = index category = cat return category"},{"question":"def magical_forest_game(T: int, test_cases: List[List[List[int]]]) -> List[str]: Chef has started a new game called \\"Magical Forest\\". In this game, each player needs to collect magical orbs scattered in the forest. Each player has a separate bag to store these orbs and the player with most magical power wins the game. Each orb has a magical power associated with it, and the players can gain additional magical power by collecting specific sets of orbs. The rules for gaining additional magical power are as follows: - If a player collects a set of 3 different types of orbs, they gain an additional +5 magical power. - If a player collects a set of 4 different types of orbs, they gain an additional +10 magical power. - If a player collects a set of 5 different types of orbs, they gain an additional +20 magical power. Given the number of orbs and their types collected by each player, your task is to determine the winner with the highest total magical power. If there are multiple players with the highest magical power, the output should be \\"tie\\". If Chef is the only player with the highest magical power, the output should be \\"chef\\". -----Input----- The first line of input contains a single integer T denoting the number of test cases. Each test case consists of: - An integer N denoting the number of players. - N lines, each containing an integer \`m_i\` followed by \`m_i\` space-separated integers representing the types of orbs in the i-th player's bag. -----Output----- For each test case, output a single line containing the result as specified in the statement. >>> magical_forest_game(2, [[[5, 1, 2, 3, 4, 5], [6, 1, 1, 2, 2, 3, 3], [7, 1, 2, 3, 4, 5, 6, 1]], [[4, 1, 3, 3, 2], [5, 2, 5, 6, 7, 4]]]) [\\"chef\\", \\"1\\"] >>> magical_forest_game(1, [[[1, 2, 3], [1, 2, 3]]]) [\\"tie\\"] >>> magical_forest_game(2, [[[1, 2, 3], [1, 2, 2, 3, 3]], [[5, 1, 2, 3, 4, 5]]]) [\\"chef\\", \\"chef\\"] >>> magical_forest_game(1, [[[1, 3, 2, 3], [2, 5, 6, 7, 4]]]) [\\"2\\"]","solution":"def calculate_magical_power(orbs): unique_orbs = len(set(orbs)) additional_power = 0 if unique_orbs >= 5: additional_power += 20 unique_orbs -= 5 if unique_orbs >= 4: additional_power += 10 unique_orbs -= 4 if unique_orbs >= 3: additional_power += 5 return len(orbs) + additional_power def find_winner(test_cases): results = [] for players_data in test_cases: max_power = -1 max_index = -1 tie = False chef_winner = False for index, orbs in enumerate(players_data): power = calculate_magical_power(orbs) if power > max_power: max_power = power max_index = index tie = False chef_winner = (index == 0) elif power == max_power: tie = True chef_winner = False if tie: results.append(\\"tie\\") elif chef_winner: results.append(\\"chef\\") else: results.append(str(max_index + 1)) return results def magical_forest_game(T, test_cases): return find_winner(test_cases)"},{"question":"from typing import List def minRefuelStops(d: int, t: int, stations: List[int]) -> int: Determine the minimum number of refueling stops required to reach the destination. >>> minRefuelStops(200, 600, [100, 200, 400, 500]) 2 >>> minRefuelStops(300, 1000, [200, 400, 600, 800]) 3 >>> minRefuelStops(100, 400, [150, 250, 350]) -1","solution":"from typing import List import heapq def minRefuelStops(d: int, t: int, stations: List[int]) -> int: if d >= t: return 0 stations.append(t) # add the destination as the last station max_heap = [] # max heap to keep track of max fuel in reverse (negative values for max heap) prev_distance = 0 fuel = d refuels = 0 for station in stations: fuel -= (station - prev_distance) while max_heap and fuel < 0: # refuel to continue fuel -= heapq.heappop(max_heap) refuels += 1 if fuel < 0: return -1 heapq.heappush(max_heap, -d) # push the fuel tank capacity prev_distance = station return refuels"},{"question":"def maximize_string_value(n: int, S: str, A: List[int]) -> str: Determine the maximum value of the resultant string after Alice and Bob have completed their turns. Parameters: n (int): Length of the string S. S (str): Input string consisting of lowercase English letters. A (list of int): List of integers representing values corresponding to each character in S. Returns: str: Maximum value of the resultant string. >>> maximize_string_value(4, \\"abdc\\", [3, 7, 9, 2]) \\"9732\\" >>> maximize_string_value(1, \\"a\\", [5]) \\"5\\" >>> maximize_string_value(4, \\"abcd\\", [5, 5, 5, 5]) \\"5555\\" >>> maximize_string_value(5, \\"edcba\\", [4, 3, 2, 1, 5]) \\"54321\\" >>> maximize_string_value(6, \\"abcdef\\", [6, 5, 4, 3, 2, 1]) \\"654321\\" >>> maximize_string_value(6, \\"aaabbb\\", [3, 2, 1, 6, 5, 4]) \\"654321\\"","solution":"def maximize_string_value(n, S, A): Returns the maximum value of the resultant string after Alice and Bob have completed their turns. Parameters: n (int): Length of the string S. S (str): Input string consisting of lowercase English letters. A (list of int): List of integers representing values corresponding to each character in S. Returns: str: Maximum value of the resultant string. char_value_pairs = list(zip(S, A)) char_value_pairs.sort(key=lambda pair: pair[1], reverse=True) max_value_str = ''.join(str(pair[1]) for pair in char_value_pairs) return max_value_str"},{"question":"def user_score(likes, posts): Calculate the user score based on likes and posts. Args: likes (int): Total number of likes received. posts (int): Total number of posts written. Returns: float: The calculated score, rounded to two decimal places. If posts is zero, returns 0.00. >>> user_score(120, 60) 2.00 >>> user_score(50, 25) 2.00 >>> user_score(500, 0) 0.00 >>> user_score(100, 33) 3.03","solution":"def user_score(likes, posts): Calculate the user score based on likes and posts. Args: likes (int): Total number of likes received. posts (int): Total number of posts written. Returns: float: The calculated score, rounded to two decimal places. If posts is zero, returns 0.00. if posts == 0: return 0.00 return round(likes / posts, 2)"},{"question":"def average_marks_by_age(students): Given a list of dictionaries representing students, this function returns a dictionary where the keys are ages and the values are the average marks of students of that age. :param students: List[Dict[str, Union[str, List[int], int]]] :return: Dict[int, float] from tests import test_average_marks_by_age, test_empty_students_list, test_all_students_same_age, test_single_student, test_marks_with_different_lengths test_average_marks_by_age() test_empty_students_list() test_all_students_same_age() test_single_student() test_marks_with_different_lengths()","solution":"def average_marks_by_age(students): Given a list of dictionaries representing students, this function returns a dictionary where the keys are ages and the values are the average marks of students of that age. :param students: List[Dict[str, Union[str, List[int], int]]] :return: Dict[int, float] from collections import defaultdict age_marks_dict = defaultdict(list) for student in students: age = student['age'] marks = student['marks'] age_marks_dict[age].extend(marks) average_marks = {} for age, marks in age_marks_dict.items(): average_marks[age] = round(sum(marks) / len(marks), 2) return average_marks"},{"question":"def find_longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive numbers in the array. :param arr: List of integers :return: Length of the longest consecutive subsequence >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> find_longest_consecutive_subsequence([9, 1, 4, 7, 3, -1, 0, 5, 8, -1, 6]) 7 >>> find_longest_consecutive_subsequence([1, 2, 2, 3, 4, 4, 5]) 5 >>> find_longest_consecutive_subsequence([-1, -2, 0, 1, 2]) 5 # Your code here","solution":"def find_longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive numbers in the array. :param arr: List of integers :return: Length of the longest consecutive subsequence if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def reverseVowels(s: str) -> str: Reverses only the vowels in the string s, leaving other characters in place. >>> reverseVowels(\\"hello\\") 'holle' >>> reverseVowels(\\"leetcode\\") 'leotcede' >>> reverseVowels(\\"aA\\") 'Aa' >>> reverseVowels(\\"racecar\\") 'racecar'","solution":"def reverseVowels(s: str) -> str: Reverses only the vowels in the string s, leaving other characters in place. vowels = set('aeiouAEIOU') s = list(s) i, j = 0, len(s) - 1 while i < j: if s[i] not in vowels: i += 1 elif s[j] not in vowels: j -= 1 else: s[i], s[j] = s[j], s[i] i += 1 j -= 1 return ''.join(s)"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths for a robot to navigate from the top-left to the bottom-right corner of an m x n grid. >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths for a robot to navigate from the top-left to the bottom-right corner of an m x n grid. # Create a 2D list (m x n) with 1 as default values dp = [[1] * n for _ in range(m)] # Iterate over the grid, starting from cell (1, 1) to calculate number of unique paths for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The value at the bottom-right corner of the grid return dp[m-1][n-1]"},{"question":"class Player: A class to represent a player in a text adventure game who can collect treasures. Methods ------- collect_treasure(location: str, treasure: str): Collects the treasure from the specified location. treasure_count() -> int: Returns the total number of unique treasures collected by the player. Examples -------- >>> p = Player() >>> p.collect_treasure(\\"cave\\", \\"gem\\") >>> p.collect_treasure(\\"forest\\", \\"gold\\") >>> p.collect_treasure(\\"cave\\", \\"gold\\") >>> print(p.treasure_count()) 2 def __init__(self): pass def collect_treasure(self, location: str, treasure: str): pass def treasure_count(self) -> int: pass def unique_treasures(locations: List[str]) -> int: Count the number of unique treasures from a list of location_treasure strings. Parameters ---------- locations : List[str] A list of strings where each string is in the format \\"location_treasure\\". Returns ------- int The count of unique treasures ignoring their locations. Examples -------- >>> unique_treasures([\\"cave_gem\\", \\"forest_gold\\", \\"cave_gold\\", \\"forest_gold\\", \\"lake_pearl\\"]) 3 pass","solution":"class Player: def __init__(self): self.treasures = {} def collect_treasure(self, location, treasure): location = location.lower() treasure = treasure.lower() if location not in self.treasures: self.treasures[location] = set() if treasure not in self.treasures[location]: self.treasures[location].add(treasure) def treasure_count(self): all_treasures = set() for treasures in self.treasures.values(): all_treasures.update(treasures) return len(all_treasures) def unique_treasures(locations): unique_treas = set() for loc_treas in locations: _, treasure = loc_treas.lower().split('_') unique_treas.add(treasure) return len(unique_treas)"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome ignoring non-alphanumeric characters and case differences. >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"A1B2 3 2B 1A\\") == True","solution":"def is_palindrome(s): Checks if the given string is a palindrome ignoring non-alphanumeric characters and case differences. Parameters: s (str): Input string Returns: bool: True if the string is a palindrome, False otherwise # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"def longest_equal_subarray(arr: List[int]) -> int: Returns the length of the longest subarray with all elements equal in the given array. >>> longest_equal_subarray([1,1,0,1,1,1]) 3 >>> longest_equal_subarray([2,2,2,3,3,3,3,1,1]) 4 >>> longest_equal_subarray([1,2,3,4,5]) 1","solution":"def longest_equal_subarray(arr): Returns the length of the longest subarray with all elements equal in the given array. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: current_len = 1 if current_len > max_len: max_len = current_len return max_len"},{"question":"def is_valid_email(email: str) -> bool: Validates if the given email matches the following pattern: 1. Contains exactly one '@' character. 2. Has a non-empty local part. 3. Has a domain part with at least one period that does not start or end with a period. :param email: The email address to validate as a string. :return: True if the email is valid, False otherwise. >>> is_valid_email('example@domain.com') True >>> is_valid_email('invalid-email@domain') False >>> is_valid_email('@domain.com') False >>> is_valid_email('example@domain.com.') False >>> is_valid_email('user.name@example-domain.co') True >>> is_valid_email('example@domain..com') False","solution":"import re def is_valid_email(email): Validates if the given email matches the following pattern: 1. Contains exactly one '@' character. 2. Has a non-empty local part. 3. Has a domain part with at least one period that does not start or end with a period. :param email: The email address to validate as a string. :return: True if the email is valid, False otherwise. pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}' if not re.fullmatch(pattern, email): return False local, domain = email.split('@') if local == '' or domain.startswith('.') or domain.endswith('.') or \\"..\\" in domain: return False return True"},{"question":"def is_palindrome(n: int) -> bool: Checks if the given number is a palindrome. Parameters: n (int): The number to check Returns: bool: True if the number is a palindrome, False otherwise Examples: >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(12321) True","solution":"def is_palindrome(n: int) -> bool: Checks if the given number is a palindrome. Parameters: n (int): The number to check Returns: bool: True if the number is a palindrome, False otherwise str_n = str(n) return str_n == str_n[::-1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root, p, q): Finds the lowest common ancestor (LCA) of two given nodes in the BST. :param root: TreeNode, the root of the binary search tree :param p: TreeNode, the first given node :param q: TreeNode, the second given node :return: TreeNode, the lowest common ancestor of nodes p and q pass def test_case_1(): # Construct the tree [6,2,8,0,4,7,9,null,null,3,5] root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) p = root.left # Node with value 2 q = root.right # Node with value 8 assert lowestCommonAncestor(root, p, q).val == 6 def test_case_2(): # Construct the tree [6,2,8,0,4,7,9,null,null,3,5] root = TreeNode(6) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(0) root.left.right = TreeNode(4) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.left.right.left = TreeNode(3) root.left.right.right = TreeNode(5) p = root.left # Node with value 2 q = root.left.right # Node with value 4 assert lowestCommonAncestor(root, p, q).val == 2 def test_case_3(): # Construct a simpler tree [2,1] root = TreeNode(2) root.left = TreeNode(1) p = root # Node with value 2 q = root.left # Node with value 1 assert lowestCommonAncestor(root, p, q).val == 2 def test_case_4(): # Construct the tree [5,2,8,1,3,7,9,null,null,null,null,6] root = TreeNode(5) root.left = TreeNode(2) root.right = TreeNode(8) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(7) root.right.right = TreeNode(9) root.right.left.left = TreeNode(6) p = root.right.left.left # Node with value 6 q = root.right.right # Node with value 9 assert lowestCommonAncestor(root, p, q).val == 8","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root, p, q): Finds the lowest common ancestor (LCA) of two given nodes in the BST. :param root: TreeNode, the root of the binary search tree :param p: TreeNode, the first given node :param q: TreeNode, the second given node :return: TreeNode, the lowest common ancestor of nodes p and q # Traverse the tree current = root while current: # If both nodes p and q are less than the current node, # then LCA lies in the left subtree if p.val < current.val and q.val < current.val: current = current.left # If both nodes p and q are greater than the current node, # then LCA lies in the right subtree elif p.val > current.val and q.val > current.val: current = current.right else: # We have found the split point, i.e., the LCA node return current"},{"question":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the array. Returns: list: The rotated array. >>> rotate([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate([-1, -100, 3, 99], 2) [3, 99, -1, -100]","solution":"def rotate(nums, k): Rotates the array to the right by k steps. Parameters: nums (list): The list of integers to rotate. k (int): The number of steps to rotate the array. Returns: list: The rotated array. n = len(nums) k = k % n # In case k is greater than the length of the array def reverse(lst, start, end): while start < end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1 # Reverse the entire array reverse(nums, 0, n - 1) # Reverse the first k elements reverse(nums, 0, k - 1) # Reverse the rest of the array reverse(nums, k, n - 1) return nums"},{"question":"def count_distinct_characters(s: str) -> int: Returns the number of distinct characters in the string s. >>> count_distinct_characters(\\"hello\\") 4 >>> count_distinct_characters(\\"world\\") 5 >>> count_distinct_characters(\\"aaaa\\") 1 >>> count_distinct_characters(\\"\\") 0 >>> count_distinct_characters(\\"Python\\") 6","solution":"def count_distinct_characters(s): Returns the number of distinct characters in the string s. :param s: The input string. :return: The number of distinct characters. return len(set(s))"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Returns the length of the longest substring that contains only unique characters. >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3 >>> length_of_longest_unique_substring(\\"dvdf\\") 3 >>> length_of_longest_unique_substring(\\"\\") 0 >>> length_of_longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_unique_substring(\\"abc abc abc\\") 4 >>> length_of_longest_unique_substring(\\"abc!@#\\") 6 >>> length_of_longest_unique_substring(\\"aabbcc\\") 2 >>> length_of_longest_unique_substring(\\"aAaAaA\\") 2","solution":"def length_of_longest_unique_substring(s): Returns the length of the longest substring that contains only unique characters. char_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def findPalindromeSubstrings(s: str) -> List[str]: Returns a list of all unique palindrome substrings in the given string 's'. >>> findPalindromeSubstrings(\\"abacdfgdcaba\\") ['a', 'b', 'aba', 'c', 'd', 'f', 'g', 'dc', 'cabac'] >>> findPalindromeSubstrings(\\"a\\") ['a'] >>> findPalindromeSubstrings(\\"ab\\") ['a', 'b'] >>> findPalindromeSubstrings(\\"aa\\") ['a', 'aa'] >>> findPalindromeSubstrings(\\"aba\\") ['a', 'b', 'aba'] >>> findPalindromeSubstrings(\\"abba\\") ['a', 'b', 'bb', 'abba'] >>> findPalindromeSubstrings(\\"abcba\\") ['a', 'b', 'c', 'bcb', 'abcba'] >>> findPalindromeSubstrings(\\"abcdef\\") ['a', 'b', 'c', 'd', 'e', 'f']","solution":"def findPalindromeSubstrings(s): Returns a list of all unique palindrome substrings in the given string 's'. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() for i in range(len(s)): # Expand around center for odd length palindromes l, r = i, i while l >= 0 and r < len(s) and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 # Expand around center for even length palindromes l, r = i, i + 1 while l >= 0 and r < len(s) and s[l] == s[r]: palindromes.add(s[l:r+1]) l -= 1 r += 1 return list(palindromes)"},{"question":"def count_even_sum_pairs(T: int, testcases: List[Tuple[int, List[int]]]) -> List[int]: This function calculates the number of different customer pairs that have an even total amount. Parameters: T (int): The number of test cases. testcases (List[Tuple[int, List[int]]]): A list of tuples, each containing the number of customers and a list of integers representing the amount each customer is willing to spend in that test case. Returns: List[int]: A list containing the number of pairs with an even sum for each test case. Example: >>> count_even_sum_pairs(3, [(4, [2, 4, 6, 7]), (3, [3, 5, 8]), (2, [1, 1])]) [3, 1, 1] from solution import count_even_sum_pairs def test_case_1(): T = 3 testcases = [ (4, [2, 4, 6, 7]), (3, [3, 5, 8]), (2, [1, 1]) ] assert count_even_sum_pairs(T, testcases) == [3, 1, 1] def test_case_2(): T = 1 testcases = [ (5, [1, 2, 3, 4, 5]) ] assert count_even_sum_pairs(T, testcases) == [4] def test_case_3(): T = 2 testcases = [ (6, [1, 3, 5, 7, 9, 11]), (4, [2, 4, 6, 8]) ] assert count_even_sum_pairs(T, testcases) == [15, 6] def test_case_4(): T = 1 testcases = [ (3, [10, 21, 30]) ] assert count_even_sum_pairs(T, testcases) == [1] def test_case_5(): T = 1 testcases = [ (4, [1, 3, 5, 7]) ] assert count_even_sum_pairs(T, testcases) == [6]","solution":"def count_even_sum_pairs(T, testcases): results = [] for i in range(T): N = testcases[i][0] B = testcases[i][1] even_count = sum(1 for b in B if b % 2 == 0) odd_count = N - even_count # Number of ways to choose 2 evens and 2 odds even_pairs = even_count * (even_count - 1) // 2 odd_pairs = odd_count * (odd_count - 1) // 2 results.append(even_pairs + odd_pairs) return results"},{"question":"def max_profit(prices: List[int]) -> int: Calculate the maximum profit from stock prices by buying and selling multiple times. :param prices: List[int], list of stock prices. :return: int, maximum profit possible. Example: >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Calculate the maximum profit from stock prices by buying and selling multiple times. :param prices: List[int], list of stock prices. :return: int, maximum profit possible. if not prices or len(prices) < 2: return 0 max_profit = 0 # Loop through the prices array for i in range(1, len(prices)): # If current price is higher than previous, add the profit if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Determine if two strings are anagrams of each other. Two strings are considered anagrams if they can be composed of the same characters with the same frequency, but arranged differently. Parameters: str1 (str): First string. str2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"Listen\\", \\"Silent\\") False >>> are_anagrams(\\"aabbcc\\", \\"abcabc\\") True >>> are_anagrams(\\"aabbcc\\", \\"abbccc\\") False","solution":"def are_anagrams(str1, str2): Returns True if str1 and str2 are anagrams, else False. # Check if lengths of both strings are equal if len(str1) != len(str2): return False # Count the frequency of each character in both strings char_count1 = {} char_count2 = {} for char in str1: char_count1[char] = char_count1.get(char, 0) + 1 for char in str2: char_count2[char] = char_count2.get(char, 0) + 1 # Compare the frequency dictionaries return char_count1 == char_count2"},{"question":"def kth_largest_palindrome(s: str, k: int) -> str: Determine the k-th largest palindrome substring of the given string s. If no such k-th palindrome exists, return an empty string. Args: s (str): The input string. k (int): The k-th index to find the largest palindrome substring. Returns: str: The k-th largest palindrome substring. Examples: >>> kth_largest_palindrome(\\"abcbaba\\", 3) 'bab' >>> kth_largest_palindrome(\\"abcd\\", 2) 'b' >>> kth_largest_palindrome(\\"level\\", 5) 'v' >>> kth_largest_palindrome(\\"aaa\\", 6) ''","solution":"def kth_largest_palindrome(s: str, k: int) -> str: def is_palindrome(sub): return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) sorted_palindromes = sorted(palindromes, key=lambda x: (-len(x), x)) if k <= len(sorted_palindromes): return sorted_palindromes[k-1] else: return \\"\\""},{"question":"def most_frequent_character(s: str) -> str: Returns the character that appears the most frequently in the string. In case of a tie, return the character that appears first. If the input string is empty, returns None. >>> most_frequent_character(\\"teststring\\") == \\"t\\" >>> most_frequent_character(\\"character\\") == \\"c\\" >>> most_frequent_character(\\"abcabc\\") == \\"a\\" >>> most_frequent_character(\\"a\\") == \\"a\\" >>> most_frequent_character(\\"zzzzzz\\") == \\"z\\" >>> most_frequent_character(\\"\\") == None >>> most_frequent_character(\\"abcdefg\\") == \\"a\\"","solution":"def most_frequent_character(s): Returns the character that appears the most frequently in the string. In case of a tie, return the character that appears first. if not s: return None frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 most_freq_char = s[0] max_count = 0 for char in s: if frequency[char] > max_count: max_count = frequency[char] most_freq_char = char return most_freq_char"},{"question":"def fibonacci(n: int) -> List[int]: Returns a list of n consecutive Fibonacci numbers starting from 0. Parameters: n (int): Number of Fibonacci numbers to generate Returns: List[int]: A list of n consecutive Fibonacci numbers >>> fibonacci(5) == [0, 1, 1, 2, 3] >>> fibonacci(8) == [0, 1, 1, 2, 3, 5, 8, 13] >>> fibonacci(0) == [] >>> fibonacci(1) == [0] >>> fibonacci(2) == [0, 1] >>> fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of n consecutive Fibonacci numbers starting from 0. Parameters: n (int): Number of Fibonacci numbers to generate Returns: List[int]: A list of n consecutive Fibonacci numbers if n <= 0: return [] fib_sequence = [0] * n if n > 1: fib_sequence[1] = 1 for i in range(2, n): fib_sequence[i] = fib_sequence[i - 1] + fib_sequence[i - 2] return fib_sequence"},{"question":"def change_calculator(cents: int) -> int: Determines the minimum number of coins needed to make a given amount of cents using the standard US coin denominations (penny - 1 cent, nickel - 5 cents, dime - 10 cents, and quarter - 25 cents). >>> change_calculator(87) 6 >>> change_calculator(99) 9 >>> change_calculator(2) 2 >>> change_calculator(15) 2 >>> change_calculator(0) 0 >>> change_calculator(1) 1 >>> change_calculator(25) 1 >>> change_calculator(5) 1 >>> change_calculator(10) 1 >>> change_calculator(10000) 400 pass","solution":"def change_calculator(cents): Determines the minimum number of coins needed to make a given amount of cents using the standard US coin denominations (penny, nickel, dime, quarter). coins = [25, 10, 5, 1] count = 0 for coin in coins: count += cents // coin cents %= coin return count"},{"question":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. Example 1: >>> grid = [ ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"0\\"], ... [\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\"] ... ] >>> islandPerimeter(grid) 16 Example 2: >>> grid = [[\\"1\\"]] >>> islandPerimeter(grid) 4 Example 3: >>> grid = [ ... [\\"1\\",\\"0\\"], ... [\\"0\\",\\"0\\"] ... ] >>> islandPerimeter(grid) 4","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == \\"1\\": perimeter += 4 if r > 0 and grid[r-1][c] == \\"1\\": # Check top cell perimeter -= 2 if c > 0 and grid[r][c-1] == \\"1\\": # Check left cell perimeter -= 2 return perimeter"},{"question":"def check_books_arrangement(n: int, thicknesses: List[int]) -> str: This function checks if the arrangement of books meets the criteria of having no more than two consecutive books with the same thickness. Parameters: n (int): the number of books on the shelf thicknesses (list of int): the thickness of each book in increasing order Returns: str: \\"YES\\" if the arrangement meets the criteria, \\"NO\\" otherwise. >>> check_books_arrangement(5, [1, 2, 2, 3, 3]) 'YES' >>> check_books_arrangement(6, [1, 2, 2, 2, 3, 4]) 'NO' >>> check_books_arrangement(4, [5, 5, 5, 10]) 'NO' >>> check_books_arrangement(3, [7, 8, 8]) 'YES'","solution":"def check_books_arrangement(n, thicknesses): This function checks if the arrangement of books meets the criteria of having no more than two consecutive books with the same thickness. Parameters: n (int): the number of books on the shelf thicknesses (list of int): the thickness of each book in increasing order Returns: str: \\"YES\\" if the arrangement meets the criteria, \\"NO\\" otherwise for i in range(2, n): if thicknesses[i] == thicknesses[i - 1] == thicknesses[i - 2]: return \\"NO\\" return \\"YES\\""},{"question":"def remove_vowels(s: str) -> str: Removes all vowels from the string s and returns the resulting string. >>> remove_vowels(\\"hello\\") \\"hll\\" >>> remove_vowels(\\"aeiou\\") \\"\\" >>> remove_vowels(\\"bcdfg\\") \\"bcdfg\\" >>> remove_vowels(\\"beautiful\\") \\"btfl\\" >>> remove_vowels(\\"a\\") \\"\\" >>> remove_vowels(\\"b\\") \\"b\\" >>> remove_vowels(\\"thequickbrownfoxjumpsoverthelazydog\\" * 10) \\"thqckbrwnfxjmpsvrthlzydg\\" * 10","solution":"def remove_vowels(s): Removes all vowels from the string s and returns the resulting string. vowels = 'aeiou' return ''.join([char for char in s if char not in vowels])"},{"question":"from typing import List, Dict def removeExpiredCookies(cookies: List[Dict[str, str]], current_date: str) -> List[Dict[str, str]]: This function takes a list of cookie objects and a current date. It returns a list of cookies that are expired based on the current date. It also prints the total number of cookies to be removed. Args: cookies (List[Dict[str, str]]): List of cookies with type, quantity, and expirationDate keys. current_date (str): The current date in YYYY-MM-DD format. Returns: List[Dict[str, str]]: List of expired cookies. Example: >>> removeExpiredCookies([ ... {\\"type\\": \\"Chocolate Chip\\", \\"quantity\\": 10, \\"expirationDate\\": \\"2023-10-01\\"}, ... {\\"type\\": \\"Oatmeal Raisin\\", \\"quantity\\": 5, \\"expirationDate\\": \\"2023-10-05\\"}, ... {\\"type\\": \\"Peanut Butter\\", \\"quantity\\": 7, \\"expirationDate\\": \\"2023-09-30\\"} ... ], \\"2023-10-02\\") [ {\\"type\\": \\"Chocolate Chip\\", \\"quantity\\": 10, \\"expirationDate\\": \\"2023-10-01\\"}, {\\"type\\": \\"Peanut Butter\\", \\"quantity\\": 7, \\"expirationDate\\": \\"2023-09-30\\"} ] \\"Total cookies to be removed: 17\\"","solution":"from datetime import datetime def removeExpiredCookies(cookies, current_date): This function takes a list of cookie objects and a current date. It returns a list of cookies that are expired based on the current date. It also prints the total number of cookies to be removed. # Convert current_date to a datetime object current_date = datetime.strptime(current_date, \\"%Y-%m-%d\\") expired_cookies = [] total_quantity = 0 for cookie in cookies: expiration_date = datetime.strptime(cookie['expirationDate'], \\"%Y-%m-%d\\") if expiration_date < current_date: expired_cookies.append(cookie) total_quantity += cookie['quantity'] if expired_cookies: print(f\\"Total cookies to be removed: {total_quantity}\\") else: print(\\"No expired cookies today!\\") return expired_cookies"},{"question":"def find_task_order(N: int, M: int, dependencies: List[Tuple[int, int]]) -> None: Determine whether it is possible to complete all tasks given their dependencies. Args: N (int): The number of tasks. M (int): The number of dependencies. dependencies (List[Tuple[int, int]]): A list of tuples representing the dependencies, where (a_i, b_i) means task a_i depends on task b_i. Example: >>> find_task_order(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (6, 3), (4, 6)]) Possible 1 2 3 6 4 5 # Unit Tests def test_example_case(): from io import StringIO import sys input_data = \\"6 6n1 2n2 3n3 4n4 5n6 3n4 6n\\" sys.stdin = StringIO(input_data) find_task_order(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (6, 3), (4, 6)]) sys.stdin = sys.__stdin__ def test_no_dependencies(): from io import StringIO import sys input_data = \\"3 0n\\" sys.stdin = StringIO(input_data) find_task_order(3, 0, []) sys.stdin = sys.__stdin__ def test_impossible_case(): from io import StringIO import sys input_data = \\"3 3n1 2n2 3n3 1n\\" sys.stdin = StringIO(input_data) find_task_order(3, 3, [(1, 2), (2, 3), (3, 1)]) sys.stdin = sys.__stdin__ def test_single_task(): from io import StringIO import sys input_data = \\"1 0n\\" sys.stdin = StringIO(input_data) find_task_order(1, 0, []) sys.stdin = sys.__stdin__","solution":"def find_task_order(N, M, dependencies): from collections import deque, defaultdict # Initialize graph and in-degrees graph = defaultdict(list) in_degree = defaultdict(int) for a, b in dependencies: graph[b].append(a) in_degree[a] += 1 # Queue for all vertices with no incoming edges queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == N: print(\\"Possible\\") print(\\" \\".join(map(str, order))) else: print(\\"Impossible\\") # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) dependencies = [(int(data[i*2+2]), int(data[i*2+1])) for i in range(M)] find_task_order(N, M, dependencies)"},{"question":"def symmetry_type(lst: List[int]) -> int: Takes a list of integers and returns an integer representing the type of symmetry found within the list. Code: 0 - asymmetric 1 - symmetric 2 - rotational symmetry >>> symmetry_type([1, 2, 3, 2, 1]) == 1 >>> symmetry_type([3, 5, 8, 1, 14, 3]) == 0 >>> symmetry_type([1, 2, 3, 1, 2, 3]) == 2 pass","solution":"def symmetry_type(lst): Takes a list of integers and returns an integer representing the type of symmetry found within the list. Code: 0 - asymmetric 1 - symmetric 2 - rotational symmetry if lst == lst[::-1]: return 1 n = len(lst) if n % 2 == 0 and lst[:n//2] == lst[n//2:]: return 2 return 0"},{"question":"def duplicate_encode(word: str) -> str: Converts a string into a new string where each character in the new string is \\"(\\" if that character appears only once in the original string or \\")\\" if that character appears more than once in the original string. Ignores capitalization when determining if a character is a duplicate. Args: word (str): The input string. Returns: str: The encoded string. pass # Unit Test def test_duplicate_encode_single_occurrence(): assert duplicate_encode(\\"din\\") == \\"(((\\" def test_duplicate_encode_mixed_occurrence(): assert duplicate_encode(\\"recede\\") == \\"()()()\\" def test_duplicate_encode_with_case_sensitivity(): assert duplicate_encode(\\"Success\\") == \\")())())\\" def test_duplicate_encode_with_special_characters(): assert duplicate_encode(\\"(( @\\") == \\"))((\\" def test_duplicate_encode_empty_string(): assert duplicate_encode(\\"\\") == \\"\\" def test_duplicate_encode_single_character(): assert duplicate_encode(\\"a\\") == \\"(\\" def test_duplicate_encode_repeated_character(): assert duplicate_encode(\\"aaa\\") == \\")))\\"","solution":"def duplicate_encode(word): Converts a string into a new string where each character in the new string is \\"(\\" if that character appears only once in the original string or \\")\\" if that character appears more than once in the original string. Ignores capitalization when determining if a character is a duplicate. Args: word (str): The input string. Returns: str: The encoded string. # Normalize the word to lower case word = word.lower() # Create a dictionary to count occurrences of each character char_count = {} for char in word: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Create the encoded string based on the counts encoded_string = ''.join(['(' if char_count[char] == 1 else ')' for char in word]) return encoded_string"},{"question":"from typing import List def prime_factors(num: int) -> List[int]: Takes an integer \`num\` as input and returns a list of its prime factors in ascending order. If \`num\` is less than or equal to 1, return an empty list. >>> prime_factors(60) == [2, 3, 5] >>> prime_factors(45) == [3, 5] >>> prime_factors(1) == []","solution":"def prime_factors(num): Returns a list of prime factors of num in ascending order without duplication. If num is less than or equal to 1, returns an empty list. if num <= 1: return [] def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True prime_factors_set = set() factor = 2 while num % factor == 0: prime_factors_set.add(factor) num //= factor factor = 3 while factor * factor <= num: while num % factor == 0: if is_prime(factor): prime_factors_set.add(factor) num //= factor factor += 2 if num > 2 and is_prime(num): prime_factors_set.add(num) return sorted(list(prime_factors_set))"},{"question":"def is_multiple_of_3(binary_str: str) -> str: Determine if the given binary number is a multiple of 3. Args: binary_str (str): A string representing a binary number. Returns: str: \\"Yes\\" if the binary number is a multiple of 3, otherwise \\"No\\". >>> is_multiple_of_3(\\"110\\") \\"Yes\\" >>> is_multiple_of_3(\\"10\\") \\"No\\"","solution":"def is_multiple_of_3(binary_str): Determine if the given binary number is a multiple of 3. Args: binary_str (str): A string representing a binary number. Returns: str: \\"Yes\\" if the binary number is a multiple of 3, otherwise \\"No\\". decimal_num = int(binary_str, 2) if decimal_num % 3 == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def sort_string(s: str) -> str: Sorts the given string such that all letters come before any digits, and within the letters and digits groups, the characters are sorted in ascending order. >>> sort_string(\\"dc1a2b3\\") == \\"abcd123\\" >>> sort_string(\\"c2a1b\\") == \\"abc12\\" >>> sort_string(\\"4z5y6x\\") == \\"xyz456\\"","solution":"def sort_string(s): Sorts the given string such that all letters come before any digits, and within the letters and digits groups, the characters are sorted in ascending order. letters = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return ''.join(letters + digits)"},{"question":"def calculate_score(answers): Calculate the total score based on the special grading system. Parameters: answers (list): List of answers where True is correct, False is incorrect, and None is unanswered. Returns: int: Total score. Examples: >>> calculate_score([True, True, False, None, True]) == 11 >>> calculate_score([False, False, False, False]) == -4 >>> calculate_score([None, None, None]) == 0 >>> calculate_score([]) == 0 from solution import calculate_score def test_calculate_score_mixed_answers(): assert calculate_score([True, True, False, None, True]) == 11 def test_calculate_score_all_incorrect(): assert calculate_score([False, False, False, False]) == -4 def test_calculate_score_all_unanswered(): assert calculate_score([None, None, None]) == 0 def test_calculate_score_empty_list(): assert calculate_score([]) == 0 def test_calculate_score_all_correct(): assert calculate_score([True, True, True, True]) == 16 def test_calculate_score_no_correct(): assert calculate_score([False, None, False, None]) == -2 def test_calculate_score_mixed_with_unanswered(): assert calculate_score([True, False, None, True, None, False]) == 6 def test_calculate_score_only_unanswered(): assert calculate_score([None, None, None, None, None]) == 0","solution":"def calculate_score(answers): Calculate the total score based on the special grading system. Parameters: answers (list): List of answers where True is correct, False is incorrect, and None is unanswered. Returns: int: Total score. score = 0 for answer in answers: if answer is True: score += 4 elif answer is False: score -= 1 # No action needed for None (unanswered questions) return score"},{"question":"def maxProfit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from one transaction, or 0 if no profit can be made. :param prices: List of stock prices :return: int >>> maxProfit([7, 1, 5, 3, 6, 4]) == 5 >>> maxProfit([7, 6, 4, 3, 1]) == 0 return 0 from solution import maxProfit def test_max_profit_example_1(): assert maxProfit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_example_2(): assert maxProfit([7, 6, 4, 3, 1]) == 0 def test_max_profit_all_increasing(): assert maxProfit([1, 2, 3, 4, 5]) == 4 def test_max_profit_all_decreasing(): assert maxProfit([5, 4, 3, 2, 1]) == 0 def test_max_profit_single_day(): assert maxProfit([5]) == 0 # Test if length of prices is less than 2 def test_max_profit_two_days_profit(): assert maxProfit([1, 2]) == 1 def test_max_profit_two_days_no_profit(): assert maxProfit([2, 1]) == 0 def test_max_profit_fluctuating_prices(): assert maxProfit([2, 4, 1, 5, 3, 6]) == 5","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved from one transaction, or 0 if no profit can be made. :param prices: List of stock prices :return: int if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"def path_exists(grid: List[str]) -> bool: Determines if there is a path between 'S' and 'E' in a grid. The grid is represented as a list of strings, where: 'S' is the starting point, 'E' is the ending point, '1' represents passable cells, '0' represents blocked cells. You can move up, down, left, or right from a passable cell. :param grid: List of strings representing the grid. :return: True if there is a path from 'S' to 'E', otherwise False. >>> grid = [ ... \\"S01\\", ... \\"111\\", ... \\"10E\\" ... ] >>> path_exists(grid) True >>> grid = [ ... \\"S01\\", ... \\"100\\", ... \\"10E\\" ... ] >>> path_exists(grid) False >>> grid = [\\"S\\"] >>> path_exists(grid) False >>> grid = [ ... \\"S11\\", ... \\"111\\", ... \\"11E\\" ... ] >>> path_exists(grid) True >>> grid = [ ... \\"S11\\", ... \\"101\\", ... \\"01E\\" ... ] >>> path_exists(grid) True >>> grid = [ ... \\"S110\\", ... \\"1010\\", ... \\"1110\\", ... \\"0E00\\" ... ] >>> path_exists(grid) True >>> grid = [ ... \\"110\\", ... \\"111\\", ... \\"10E\\" ... ] >>> path_exists(grid) False >>> grid = [ ... \\"S10\\", ... \\"111\\", ... \\"100\\" ... ] >>> path_exists(grid) False","solution":"def path_exists(grid): Determines if there is a path between 'S' and 'E' in a grid. :param grid: List of strings representing the grid. :return: True if there is a path from 'S' to 'E', otherwise False. from collections import deque # Find the starting point 'S' rows, cols = len(grid), len(grid[0]) start = None end = None for r in range(rows): for c in range(cols): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'E': end = (r, c) if not start or not end: return False # BFS to find the path from 'S' to 'E' queue = deque([start]) visited = set([start]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: current = queue.popleft() if current == end: return True for dr, dc in directions: nr, nc = current[0] + dr, current[1] + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != '0' and (nr, nc) not in visited: queue.append((nr, nc)) visited.add((nr, nc)) return False"},{"question":"def count_pizza_orders(orders: List[str]) -> Dict[str, int]: Given an array of orders, returns a dictionary with the count of each pizza type ordered. >>> count_pizza_orders([\\"pepperoni\\", \\"margherita\\", \\"pepperoni\\", \\"veggie\\"]) {\\"pepperoni\\": 2, \\"margherita\\": 1, \\"veggie\\": 1} >>> count_pizza_orders([]) {}","solution":"def count_pizza_orders(orders): Given an array of orders, returns a dictionary with the count of each pizza type ordered. pizza_count = {} for order in orders: if order in pizza_count: pizza_count[order] += 1 else: pizza_count[order] = 1 return pizza_count"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression consisting of digits, plus signs (+), minus signs (-), and spaces. Returns the result of the expression. Handles addition and subtraction. >>> evaluate_expression(\\"12 + 5 - 3\\") 14 >>> evaluate_expression(\\"10 + 2 - 7 + 5\\") 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression consisting of digits, plus signs (+), minus signs (-), and spaces. Handles addition and subtraction. tokens = expression.replace(' ', '') total = 0 current_number = 0 sign = 1 for char in tokens: if char.isdigit(): current_number = current_number * 10 + int(char) elif char == '+': total += sign * current_number current_number = 0 sign = 1 elif char == '-': total += sign * current_number current_number = 0 sign = -1 total += sign * current_number return total"},{"question":"def sumAllEvens(lst: List[int]) -> int: Write a function sumAllEvens that takes a list of integers and returns the sum of all even numbers in the list. >>> sumAllEvens([1, 2, 3, 4, 5, 6]) 12 >>> sumAllEvens([7, 8, 10, 11]) 18 >>> sumAllEvens([1, 3, 5]) 0","solution":"def sumAllEvens(lst): Returns the sum of all even numbers in the list. Parameters: lst (list of int): The list of integers to sum up. Returns: int: The sum of all even numbers in the list. return sum(num for num in lst if num % 2 == 0)"},{"question":"from typing import List def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of integers nums. >>> length_of_lis([10, 9, 2, 5, 3]) 2 >>> length_of_lis([0, 8, 4, 12, 2, 50]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([5]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([3, 4, 1, 2, 8, 5, 6]) 4","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the list of integers nums. if not nums: return 0 dp = [] for num in nums: idx = binary_search(dp, num) if idx == len(dp): dp.append(num) else: dp[idx] = num return len(dp) def binary_search(dp, target): Helper function to perform binary search and return the index where target should be inserted. left, right = 0, len(dp) while left < right: mid = (left + right) // 2 if dp[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"def length_of_last_word(s: str) -> int: Returns the length of the last word in the string s. If there is no word in the string, returns 0. >>> length_of_last_word(\\"Hello World\\") == 5 >>> length_of_last_word(\\" \\") == 0 >>> length_of_last_word(\\"Hello World \\") == 5 >>> length_of_last_word(\\" Hello World\\") == 5 >>> length_of_last_word(\\"\\") == 0 >>> length_of_last_word(\\" \\") == 0 >>> length_of_last_word(\\"Hello\\") == 5 >>> length_of_last_word(\\"Hello World\\") == 5","solution":"def length_of_last_word(s): Returns the length of the last word in the string s. If there is no word in the string, returns 0. words = s.split() if not words: return 0 return len(words[-1])"},{"question":"def isValidSerialization(preorder: str) -> bool: Determine if a given preorder string is a valid serialization of a binary tree. >>> isValidSerialization(\\"9,3,4,#,#,1,#,#,2,#,6,#,#\\") True >>> isValidSerialization(\\"1,#\\") False >>> isValidSerialization(\\"9,#,#,1\\") False >>> isValidSerialization(\\"1,#,#\\") True >>> isValidSerialization(\\"#\\") True >>> isValidSerialization(\\"9,3,4,#,#,1,2,#,#,#,5,#,#\\") True >>> isValidSerialization(\\"9,3,#,4,#,#,1,#,#,2,#,6\\") False","solution":"def isValidSerialization(preorder: str) -> bool: Determine if a given preorder string is a valid serialization of a binary tree. # Split the input string by commas into nodes nodes = preorder.split(',') # Initialize a counter for available slots slots = 1 # Iterate through the nodes for node in nodes: # For every node, one slot is taken slots -= 1 # If slots are negative, the serialization is invalid if slots < 0: return False # If the node is not a null pointer, it adds two slots (two children) if node != '#': slots += 2 # All slots should be used up for the serialization to be valid return slots == 0"},{"question":"def is_divisible_by_8(s: str) -> str: Check if any permutation of the string s is divisible by 8. >>> is_divisible_by_8(\\"123\\") \\"YES\\" >>> is_divisible_by_8(\\"1000\\") \\"YES\\" >>> is_divisible_by_8(\\"75\\") \\"NO\\" >>> is_divisible_by_8(\\"8\\") \\"YES\\" >>> is_divisible_by_8(\\"16\\") \\"YES\\" >>> is_divisible_by_8(\\"7\\") \\"NO\\" >>> is_divisible_by_8(\\"888\\") \\"YES\\" >>> is_divisible_by_8(\\"111\\") \\"NO\\" >>> is_divisible_by_8(\\"12345678901234567890\\") \\"YES\\" >>> is_divisible_by_8(\\"111222333444555666777888999000\\") \\"YES\\" >>> is_divisible_by_8(\\"1928374655647382910\\") \\"YES\\" def check_divisibility_by_8(test_cases: List[str]) -> List[str]: For each string in the list, output \\"YES\\" if there exists a permutation of the string that is divisible by 8, otherwise \\"NO\\". >>> check_divisibility_by_8([\\"123\\", \\"1000\\", \\"75\\", \\"8\\", \\"16\\", \\"7\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_divisible_by_8(s): Check if any permutation of the string s is divisible by 8. from itertools import permutations # If the length of the string is less than 3, # we can simply try all permutations directly if len(s) < 3: for perm in permutations(s): if int(''.join(perm)) % 8 == 0: return \\"YES\\" return \\"NO\\" # For strings of length 3 or more # We just need to check if there's any 3-digit combination that is divisible by 8 digits = list(s) for i in range(len(digits)): for j in range(len(digits)): if j != i: for k in range(len(digits)): if k != i and k != j: num = int(digits[i] + digits[j] + digits[k]) if num % 8 == 0: return \\"YES\\" return \\"NO\\" def check_divisibility_by_8(test_cases): results = [] for s in test_cases: results.append(is_divisible_by_8(s)) return results"},{"question":"from typing import List def get_total_volume(sides: List[int]) -> int: Calculate the total volume of all given cubes. :param sides: List of integers, each representing the side length of a cube :return: Total volume of all cubes >>> get_total_volume([1, 2, 3]) 36 >>> get_total_volume([0, 1, 2]) 9 >>> get_total_volume([10, 20, 30]) 37000 pass def test_single_cube(): assert get_total_volume([1]) == 1 assert get_total_volume([2]) == 8 def test_multiple_cubes(): assert get_total_volume([1, 2, 3]) == 36 assert get_total_volume([2, 2, 2]) == 24 def test_zero_length(): assert get_total_volume([]) == 0 def test_varied_lengths(): assert get_total_volume([0, 1, 2]) == 9 assert get_total_volume([10, 20, 30]) == 10**3 + 20**3 + 30**3 def test_large_numbers(): assert get_total_volume([100, 200, 300]) == 100**3 + 200**3 + 300**3 def test_all_zero_lengths(): assert get_total_volume([0, 0, 0]) == 0","solution":"from typing import List def get_total_volume(sides: List[int]) -> int: Calculate the total volume of all given cubes. :param sides: List of integers, each representing the side length of a cube :return: Total volume of all cubes return sum(side ** 3 for side in sides)"},{"question":"def max_children_to_receive_candies(n: int, candies: List[int]) -> int: Given a list of integers representing the number of candies in each bag, determine the maximum number of children that can equally receive candies without any candy left undistributed. :param n: Number of bags :param candies: List of integers denoting candies in each bag :return: Maximum number of children that can equally receive candies >>> max_children_to_receive_candies(5, [10, 20, 30, 40, 50]) 5 >>> max_children_to_receive_candies(4, [5, 5, 5, 5]) 4","solution":"def max_children_to_receive_candies(n, candies): Given a list of integers representing the number of candies in each bag, determine the maximum number of children that can equally receive candies without any candy left undistributed. :param n: Number of bags :param candies: List of integers denoting candies in each bag :return: Maximum number of children that can equally receive candies total_candies = sum(candies) # Find the maximum number of children such that total_candies is divisible by that number max_children = n while total_candies % max_children != 0: max_children -= 1 return max_children"},{"question":"def highestProduct(nums: List[int]) -> int: Returns the highest product that can be obtained by multiplying any three numbers from the input list. >>> highestProduct([1, 2, 3, 4]) == 24 >>> highestProduct([-10, -10, 1, 3, 2]) == 300 >>> highestProduct([0, -1, 3, 100, 70, 50]) == 350000 >>> highestProduct([1, 2]) raises ValueError >>> highestProduct([1, 2, 3]) == 6 pass","solution":"def highestProduct(nums): Returns the highest product that can be obtained by multiplying any three numbers from the input list. if len(nums) < 3: raise ValueError(\\"Input list must have at least 3 numbers\\") nums.sort() # The highest product can be from the top three positive numbers # or from the two most negative numbers and the top positive number return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def find_longest_unique_substring(s: str): Find the length and the longest substring with unique characters. >>> find_longest_unique_substring(\\"abcabcbb\\") (3, \\"abc\\") >>> find_longest_unique_substring(\\"bbbbb\\") (1, \\"b\\") >>> find_longest_unique_substring(\\"pwwkew\\") (3, \\"wke\\") >>> find_longest_unique_substring(\\"\\") (0, \\"\\") >>> find_longest_unique_substring(\\"abcdef\\") (6, \\"abcdef\\") >>> find_longest_unique_substring(\\"a\\") (1, \\"a\\") >>> find_longest_unique_substring(\\"abcabcabc\\") (3, \\"abc\\") >>> find_longest_unique_substring(\\"a!b@c#\\") (6, \\"a!b@c#\\")","solution":"def find_longest_unique_substring(s): Returns the length and the longest substring with unique characters. char_index = {} start = maxLength = 0 longest_substring = \\"\\" for end in range(len(s)): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end if end - start + 1 > maxLength: maxLength = end - start + 1 longest_substring = s[start:end + 1] return maxLength, longest_substring"},{"question":"def min_operations_to_heads(n: int, coins: str) -> int: Calculate the minimum number of operations to make all coins show heads (H). >>> min_operations_to_heads(5, \\"HHHTT\\") == 1 >>> min_operations_to_heads(4, \\"HHHH\\") == 0 >>> min_operations_to_heads(6, \\"TTTTHH\\") == 2 def process_cases(t: int, cases: list) -> list: Process multiple test cases to calculate minimum number of operations for each. >>> process_cases(3, [(5, \\"HHHTT\\"), (4, \\"HHHH\\"), (6, \\"TTTTHH\\")]) == [1, 0, 2] >>> process_cases(2, [(1, \\"H\\"), (1, \\"T\\")]) == [0, 1]","solution":"def min_operations_to_heads(n, coins): Function to calculate minimum number of operations to make all coins show heads (H). coins = list(coins) operations = 0 for i in range(n): if coins[i] == 'T': operations += 1 # Flip all coins from i-th position to the end for j in range(i, n): coins[j] = 'H' if coins[j] == 'T' else 'T' return operations def process_cases(t, cases): results = [] for i in range(t): n, coins = cases[i] results.append(min_operations_to_heads(n, coins)) return results"},{"question":"def max_subarray_product(yield_list): Calculate the maximum product of all possible subarrays after rotation >>> max_subarray_product([5]) 5 >>> max_subarray_product([1, 2]) 2 >>> max_subarray_product([2, 2, 2, 2]) 16 >>> max_subarray_product([1, 2, 3, 4, 5, 6]) 720 >>> max_subarray_product([0, 2, 3, 4]) 24 >>> max_subarray_product([10000, 10000, 10000]) 1000000000000","solution":"def max_subarray_product(yield_list): def max_product_of_subarray(subarray): max_prod = float('-inf') n = len(subarray) for i in range(n): current_prod = 1 for j in range(n): current_prod *= subarray[(i + j) % n] max_prod = max(max_prod, current_prod) return max_prod n = len(yield_list) max_product = float('-inf') for start in range(n): for end in range(start + 1, n + 1): subarray = yield_list[start:end] max_product = max(max_product, max_product_of_subarray(subarray)) return max_product"},{"question":"def arrange_fruits(N: int, F: List[int]) -> Union[List[int], str]: Determine if it is possible to arrange the fruits in the specified pattern, and if so, provide one possible arrangement. >>> arrange_fruits(3, [1, 2, 1]) [2, 1, 2, 3] >>> arrange_fruits(2, [3, 1]) \\"Not possible\\"","solution":"import heapq from collections import Counter def arrange_fruits(N, F): if N == 1: return [1]*F[0] # Create a max-heap with negative counts because heapq in Python is a min-heap by default max_heap = [(-count, i+1) for i, count in enumerate(F)] heapq.heapify(max_heap) result = [] prev_count, prev_fruit = 0, 0 while max_heap: count, fruit = heapq.heappop(max_heap) result.append(fruit) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_fruit)) prev_count = count + 1 # Since count is negative, incrementing reduces its absolute value prev_fruit = fruit if len(result) != sum(F): return \\"Not possible\\" return result"},{"question":"from typing import List def searchRange(nums: List[int], target: int) -> List[int]: You are given a sorted array of integers and a target value. Write a function that finds the starting and ending position of the target value in the array. If the target is not found in the array, return [-1, -1]. >>> searchRange([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> searchRange([5, 7, 7, 8, 8, 10], 6) [-1, -1]","solution":"from typing import List def searchRange(nums: List[int], target: int) -> List[int]: def findLeft(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def findRight(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left, right = findLeft(nums, target), findRight(nums, target) if left <= right and left < len(nums) and nums[left] == target and nums[right] == target: return [left, right] else: return [-1, -1]"},{"question":"def rearrange_kth_word(s: str, k: int) -> str: Rearranges the words in the string such that every k-th word is moved to the beginning of the string. The order of the other words remains the same. Args: s (str): The input string of words. k (int): The position of the word to be moved to the beginning. Returns: str: The rearranged string with the k-th word moved to the beginning. Example: >>> rearrange_kth_word(\\"the quick brown fox jumps over the lazy dog\\", 3) 'brown the quick fox jumps over the lazy dog' >>> rearrange_kth_word(\\"the quick brown fox\\", 1) 'the quick brown fox' >>> rearrange_kth_word(\\"the quick brown fox\\", 2) 'quick the brown fox' import unittest class TestRearrangeKthWord(unittest.TestCase): def test_rearrange_kth_word_basic(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox jumps over the lazy dog\\", 3), \\"brown the quick fox jumps over the lazy dog\\") def test_rearrange_kth_word_starting(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox\\", 1), \\"the quick brown fox\\") def test_rearrange_kth_word_middle(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox\\", 2), \\"quick the brown fox\\") def test_rearrange_kth_word_end(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox\\", 4), \\"fox the quick brown\\") def test_rearrange_kth_word_one_word(self): self.assertEqual(rearrange_kth_word(\\"hello\\", 1), \\"hello\\") def test_rearrange_kth_word_long_string(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox jumps over the lazy dog\\", 9), \\"dog the quick brown fox jumps over the lazy dog\\") def test_rearrange_kth_word_k_zero(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox\\", 0), \\"the quick brown fox\\") def test_rearrange_kth_word_k_out_of_range(self): self.assertEqual(rearrange_kth_word(\\"the quick brown fox\\", 5), \\"the quick brown fox\\") if __name__ == \\"__main__\\": unittest.main()","solution":"def rearrange_kth_word(s: str, k: int) -> str: Rearranges the words in the string such that every k-th word is moved to the beginning of the string. The order of the other words remains the same. Args: s (str): The input string of words. k (int): The position of the word to be moved to the beginning. Returns: str: The rearranged string with the k-th word moved to the beginning. words = s.split() # Getting every k-th word, which in this case is only the single k-th word if k <= 0 or k > len(words): return s kth_word = words.pop(k - 1) return \\" \\".join([kth_word] + words)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (as tuples) from the input list that add up to the target integer. Each pair should be sorted in ascending order, and the entire list of pairs should be sorted lexicographically. >>> find_pairs([1, 2, 3, 4, 3, 2, 1], 4) [(1, 3), (2, 2)] >>> find_pairs([1, 5, 2, -2, 4], 3) [(-2, 5), (1, 2)] >>> find_pairs([0, -1, 2, -3, 1], -2) [(-3, 1)]","solution":"def find_pairs(nums, target): Returns a list of unique pairs (as tuples) that add up to the target. Each pair and the resulting list are sorted in ascending order. num_set = set(nums) pairs_set = set() for num in nums: complement = target - num if complement in num_set: pair = tuple(sorted((num, complement))) if pair[0] != pair[1] or nums.count(pair[0]) > 1: pairs_set.add(pair) return sorted(pairs_set)"},{"question":"def square_elements(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list with each element squared. >>> square_elements([1, 2, 3]) [1, 4, 9] >>> square_elements([0, 2, 4]) [0, 4, 16] >>> square_elements([-1, -2, -3]) [1, 4, 9] >>> square_elements([-1, 2, -3, 4]) [1, 4, 9, 16] >>> square_elements([]) [] >>> square_elements([5]) [25] >>> square_elements([-2]) [4]","solution":"def square_elements(nums): Returns a new list with each element squared. :param nums: List of integers :return: List of integers with each element squared return [x ** 2 for x in nums]"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, 2, 5, -3, 6]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([0, 0, 0, 0]) == 0 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 def process_test_cases(testcases): Processes multiple test cases and returns the results. >>> testcases = [(4, [1, 2, 3, 4]), (5, [-1, 2, 5, -3, 6])] >>> process_test_cases(testcases) == [10, 10] >>> testcases = [(3, [-1, -2, -3]), (4, [4, -1, 2, 1])] >>> process_test_cases(testcases) == [-1, 6]","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_test_cases(testcases): Processes multiple test cases and returns the results. results = [] for case in testcases: N, arr = case result = max_subarray_sum(arr) results.append(result) return results"},{"question":"def max_area(heights): Find the indices of two lines that together, with the x-axis, forms a container such that the container contains the most water. Args: heights (List[int]): An array of non-negative integers representing the heights of vertical lines. Returns: int: The maximum amount of water a container can store. Examples: >>> max_area([1,8,6,2,5,4,8,3,7]) 49 >>> max_area([1,1]) 1 >>> max_area([4,3,2,1,4]) 16 >>> max_area([1,2,1]) 2","solution":"def max_area(heights): Returns the maximum amount of water a container can store given a list of heights. left, right = 0, len(heights) - 1 max_water = 0 while left < right: # Calculate the amount of water the current container can store height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update the maximum water amount if the current container stores more water max_water = max(max_water, current_water) # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def to_uppercase(s: str) -> str: Converts a string to uppercase. >>> to_uppercase(\\"hello\\") 'HELLO' >>> to_uppercase(\\"\\") '' pass def capitalize_each_word(s: str) -> str: Capitalizes the first letter of each word in a string. >>> capitalize_each_word(\\"hello world\\") 'Hello World' >>> capitalize_each_word(\\"\\") '' pass def reverse_words(s: str) -> str: Reverses the order of words in a string. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"\\") '' pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def to_uppercase(s): Converts a string to uppercase. >>> to_uppercase(\\"hello\\") 'HELLO' >>> to_uppercase(\\"\\") '' return s.upper() def capitalize_each_word(s): Capitalizes the first letter of each word in a string. >>> capitalize_each_word(\\"hello world\\") 'Hello World' >>> capitalize_each_word(\\"\\") '' return ' '.join(word.capitalize() for word in s.split()) def reverse_words(s): Reverses the order of words in a string. >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\"\\") '' return ' '.join(s.split()[::-1])"},{"question":"from collections import Counter def most_common_word(words): Returns the most common word in the list of words. If there are multiple words with the highest frequency, returns the lexicographically smallest one. >>> most_common_word(['apple', 'orange', 'banana', 'apple', 'orange', 'apple']) == 'apple' >>> most_common_word(['apple', 'banana', 'apple', 'banana']) 'apple' >>> most_common_word(['apple']) == 'apple' >>> most_common_word(['apple', 'orange', 'banana']) == 'apple' >>> most_common_word(['apple', 'orange', 'orange', 'apple']) == 'apple' >>> most_common_word(['Apple', 'apple', 'apple']) == 'apple'","solution":"from collections import Counter def most_common_word(words): Returns the most common word in the list of words. If there are multiple words with the highest frequency, returns the lexicographically smallest one. word_count = Counter(words) max_frequency = max(word_count.values()) max_words = [word for word, count in word_count.items() if count == max_frequency] return min(max_words)"},{"question":"def findMinDifference(timePoints: List[str]) -> int: Finds the minimum difference in minutes between any two different time points. Example 1: >>> findMinDifference([\\"23:59\\",\\"00:00\\"]) 1 Example 2: >>> findMinDifference([\\"00:00\\",\\"23:59\\",\\"12:30\\",\\"12:31\\"]) 1","solution":"def findMinDifference(timePoints): Find the minimum difference in minutes between any two different time points. :param timePoints: List of strings representing the time in \\"HH:MM\\" format. :return: Minimum difference in minutes. def convertToMinutes(time): Converts a time string \\"HH:MM\\" to total minutes from 00:00. :param time: Time string in \\"HH:MM\\" format. :return: Total minutes. h, m = map(int, time.split(':')) return h * 60 + m minutes = [convertToMinutes(time) for time in timePoints] minutes.sort() min_diff = float('inf') for i in range(1, len(minutes)): min_diff = min(min_diff, minutes[i] - minutes[i - 1]) # Check the difference between the last and the first time point considering the circular nature of the clock min_diff = min(min_diff, 1440 - (minutes[-1] - minutes[0])) return min_diff"},{"question":"import math def findNextPerfectSquare(n: int) -> int: Returns the next perfect square if n is a perfect square, otherwise returns -1. >>> findNextPerfectSquare(16) 25 >>> findNextPerfectSquare(10) -1 >>> findNextPerfectSquare(1) 4 >>> findNextPerfectSquare(0) 1 >>> findNextPerfectSquare(-1) -1","solution":"import math def findNextPerfectSquare(n): Returns the next perfect square if n is a perfect square, otherwise returns -1. if n < 0: return -1 root = int(math.sqrt(n)) if root * root == n: return (root + 1) * (root + 1) else: return -1"},{"question":"def merge_sort(array): Sorts an array in ascending order using the merge sort algorithm. >>> merge_sort([4, 2, 6, 5, 1, 3]) == [1, 2, 3, 4, 5, 6] >>> merge_sort([10, -1, 2, 5, 0, 6, 4, -5]) == [-5, -1, 0, 2, 4, 5, 6, 10] >>> merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]","solution":"def merge_sort(array): Sorts an array in ascending order using the merge sort algorithm. if len(array) <= 1: return array mid = len(array) // 2 left = merge_sort(array[:mid]) right = merge_sort(array[mid:]) return merge(left, right) def merge(left, right): Merges two sorted arrays into one sorted array. result = [] left_index = 0 right_index = 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: result.append(left[left_index]) left_index += 1 else: result.append(right[right_index]) right_index += 1 result.extend(left[left_index:]) result.extend(right[right_index:]) return result"},{"question":"def anagram_words(word1: str, word2: str) -> bool: Checks if two given words are anagrams of each other. Args: word1 (str): First word for comparison. word2 (str): Second word for comparison. Returns: bool: True if the words are anagrams, False otherwise. Examples: >>> anagram_words(\\"binary\\", \\"brainy\\") True >>> anagram_words(\\"listen\\", \\"silent\\") True >>> anagram_words(\\"hello\\", \\"world\\") False >>> anagram_words(\\"triangle\\", \\"integral\\") True >>> anagram_words(\\"apple\\", \\"pabble\\") False pass","solution":"def anagram_words(word1: str, word2: str) -> bool: Checks if two given words are anagrams of each other. Args: word1 (str): First word for comparison. word2 (str): Second word for comparison. Returns: bool: True if the words are anagrams, False otherwise. return sorted(word1) == sorted(word2)"},{"question":"def merge_intervals(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]: Merge a list of intervals and return the merged intervals in sorted order. Each interval in the input list is represented as a tuple (start, end). The output list should have merged intervals in ascending order by their starting points. Args: intervals (list[tuple[int, int]]): List of intervals represented as tuples. Returns: list[tuple[int, int]]: List of merged intervals in sorted order. Examples: >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) [(1, 4), (5, 8)] >>> merge_intervals([(1, 5), (2, 3), (4, 6)]) [(1, 6)] >>> merge_intervals([(1, 10), (2, 6), (8, 10)]) [(1, 10)] >>> merge_intervals([(1, 2), (3, 4), (5, 6)]) [(1, 2), (3, 4), (5, 6)] # Return the list of merged intervals. # Unit tests for validation def test_merge_intervals_simple_overlap(): assert merge_intervals([(1, 3), (2, 4)]) == [(1, 4)] def test_merge_intervals_no_overlap(): assert merge_intervals([(1, 2), (3, 4), (5, 6)]) == [(1, 2), (3, 4), (5, 6)] def test_merge_intervals_complex_overlap(): assert merge_intervals([(1, 5), (2, 3), (4, 6)]) == [(1, 6)] assert merge_intervals([(1, 10), (2, 6), (8, 10)]) == [(1, 10)] def test_merge_intervals_with_continuous_overlap(): assert merge_intervals([(1, 3), (2, 4), (5, 7), (6, 8)]) == [(1, 4), (5, 8)] def test_merge_intervals_with_single_interval(): assert merge_intervals([(1, 2)]) == [(1, 2)] def test_merge_intervals_empty(): assert merge_intervals([]) == [] def test_merge_intervals_end_start_overlap(): assert merge_intervals([(1, 4), (4, 5)]) == [(1, 5)] def test_merge_intervals_large_intervals(): assert merge_intervals([(1, 1000000), (500000, 1000000)]) == [(1, 1000000)]","solution":"def merge_intervals(intervals): Merges a list of intervals and returns the merged intervals in a sorted order. Parameters: intervals (list of tuple): List of intervals represented as tuples (start, end). Returns: list of tuple: List of merged intervals. if not intervals: return [] # Sort intervals by the starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"def evaluate_expression(expression: str) -> float: Evaluate a mathematical expression and return the result. The expression can include non-negative integers, the operators '+', '-', '*', and '/', and parentheses '()'. Division should result in floating-point division. Examples: >>> evaluate_expression(\\"3+2*2\\") # returns 7.0 >>> evaluate_expression(\\" 3/2 \\") # returns 1.5 >>> evaluate_expression(\\"3+5 / 2\\") # returns 5.5 >>> evaluate_expression(\\"(1+(4+5+2)-3)+(6+8)\\") # returns 23.0 >>> evaluate_expression(\\"((2+3)*5)/2\\") # returns 12.5","solution":"def evaluate_expression(expression): def operate(a, b, operator): if operator == '+': return a + b elif operator == '-': return a - b elif operator == '*': return a * b elif operator == '/': return a / b def precedence(operator): if operator in ('+', '-'): return 1 if operator in ('*', '/'): return 2 return 0 def apply_operations(operators, values): right = values.pop() left = values.pop() operator = operators.pop() values.append(operate(left, right, operator)) def evaluate(expression): operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operations(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operations(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operations(operators, values) return values[0] return round(float(evaluate(expression)), 6)"},{"question":"def greeting(hour: int) -> str: Returns a greeting based on the hour of the day. Parameters: hour (int): The current hour in 24-hour format (0-23). Returns: str: The appropriate greeting. >>> greeting(9) 'Good Morning' >>> greeting(14) 'Good Afternoon' >>> greeting(20) 'Good Evening'","solution":"def greeting(hour): Returns a greeting based on the hour of the day. Parameters: hour (int): The current hour in 24-hour format (0-23). Returns: str: The appropriate greeting. if 0 <= hour <= 11: return \\"Good Morning\\" elif 12 <= hour <= 17: return \\"Good Afternoon\\" elif 18 <= hour <= 23: return \\"Good Evening\\" else: raise ValueError(\\"Invalid hour. Hour must be between 0 and 23.\\")"},{"question":"def has_cycle(matrix, n, m): Determine if there is a cycle in the matrix consisting of the same character. >>> has_cycle([[\\"a\\", \\"a\\", \\"a\\", \\"a\\"], [\\"a\\", \\"b\\", \\"b\\", \\"a\\"], [\\"a\\", \\"a\\", \\"a\\", \\"a\\"]], 3, 4) \\"Yes\\" >>> has_cycle([[\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [\\"e\\", \\"f\\", \\"g\\", \\"h\\"], [\\"i\\", \\"j\\", \\"k\\", \\"l\\"]], 3, 4) \\"No\\" from solution import has_cycle def test_has_cycle_with_cycle(): matrix = [ [\\"a\\", \\"a\\", \\"a\\", \\"a\\"], [\\"a\\", \\"b\\", \\"b\\", \\"a\\"], [\\"a\\", \\"a\\", \\"a\\", \\"a\\"] ] assert has_cycle(matrix, 3, 4) == \\"Yes\\" def test_has_cycle_without_cycle(): matrix = [ [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], [\\"e\\", \\"f\\", \\"g\\", \\"h\\"], [\\"i\\", \\"j\\", \\"k\\", \\"l\\"] ] assert has_cycle(matrix, 3, 4) == \\"No\\" def test_has_cycle_small_cycle(): matrix = [ [\\"a\\", \\"a\\"], [\\"a\\", \\"a\\"] ] assert has_cycle(matrix, 2, 2) == \\"Yes\\" def test_has_cycle_single_row_no_cycle(): matrix = [ [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] ] assert has_cycle(matrix, 1, 4) == \\"No\\" def test_has_cycle_single_column_no_cycle(): matrix = [ [\\"a\\"], [\\"b\\"], [\\"c\\"], [\\"d\\"] ] assert has_cycle(matrix, 4, 1) == \\"No\\" def test_has_cycle_single_element(): matrix = [ [\\"a\\"] ] assert has_cycle(matrix, 1, 1) == \\"No\\"","solution":"def has_cycle(matrix, n, m): def dfs(x, y, parent_x, parent_y, char): if visited[x][y]: return True visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx != parent_x or ny != parent_y) and matrix[nx][ny] == char: if dfs(nx, ny, x, y, char): return True return False visited = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): if not visited[i][j]: if dfs(i, j, -1, -1, matrix[i][j]): return \\"Yes\\" return \\"No\\""},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring(\\"abcabcbb\\") 3 >>> longest_substring(\\"bbbbb\\") 1 >>> longest_substring(\\"pwwkew\\") 3 >>> longest_substring(\\"\\") 0 >>> longest_substring(\\"abcdef\\") 6 >>> longest_substring(\\"aaaaa\\") 1 >>> longest_substring(\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 52 >>> longest_substring(\\"a b c a b c\\") 3 >>> longest_substring(\\"abcabcabcabcabc\\") 3","solution":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. start = 0 # starting index of the currently considered substring max_length = 0 # max length of substring found so far used_chars = {} # dictionary to store the most recent index of each character for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, i - start + 1) used_chars[char] = i return max_length"},{"question":"from typing import List, Union def group_consecutives(lst: Union[List[int], str]) -> Union[List[List[int]], str]: Returns the elements of the original list divided into groups of consecutive elements. >>> group_consecutives([3, 4, 5, 10, 11, 12, 20]) [[3, 4, 5], [10, 11, 12], [20]] >>> group_consecutives([1, 2, 3, 5, 6, 8, 9, 10]) [[1, 2, 3], [5, 6], [8, 9, 10]] >>> group_consecutives([100, 200, 300]) [[100], [200], [300]] >>> group_consecutives([4, 'a', 5]) 'Not valid' >>> group_consecutives('4,5,6') 'Not valid' from solution import group_consecutives def test_valid_input(): assert group_consecutives([3, 4, 5, 10, 11, 12, 20]) == [[3, 4, 5], [10, 11, 12], [20]] def test_mixed_consecutives(): assert group_consecutives([1, 2, 3, 5, 6, 8, 9, 10]) == [[1, 2, 3], [5, 6], [8, 9, 10]] def test_non_consecutives(): assert group_consecutives([100, 200, 300]) == [[100], [200], [300]] def test_invalid_input_type(): assert group_consecutives('4, 5, 6') == \\"Not valid\\" def test_invalid_list_elements(): assert group_consecutives([4, 'a', 5]) == \\"Not valid\\" def test_empty_list(): assert group_consecutives([]) == [] def test_single_element_list(): assert group_consecutives([42]) == [[42]]","solution":"def group_consecutives(lst): Returns a new list containing the elements of the original list divided into groups of consecutive elements. Each group is represented as a sublist. Returns \\"Not valid\\" if the input is not a list of integers. if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst): return \\"Not valid\\" if not lst: return [] result = [] current_group = [lst[0]] for i in range(1, len(lst)): if lst[i] == lst[i - 1] + 1: current_group.append(lst[i]) else: result.append(current_group) current_group = [lst[i]] result.append(current_group) return result"},{"question":"def matrixDiagonalSum(matrix: List[List[int]]) -> int: Given a matrix of integers, returns the sum of the elements on the main diagonal. >>> matrixDiagonalSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 >>> matrixDiagonalSum([[10, 20], [30, 40]]) 50 >>> matrixDiagonalSum([[5]]) 5 pass","solution":"def matrixDiagonalSum(matrix): Returns the sum of the elements on the main diagonal of the matrix. return sum(matrix[i][i] for i in range(len(matrix)))"},{"question":"from typing import List def subarraySum(nums: List[int], k: int) -> int: Given an array of integers nums, return the number of consecutive sequences that sum to k. A sequence is defined as a subarray or contiguous part of the array. Args: nums (List[int]): A list of integers. k (int): The target sum. Returns: int: The number of subarrays that sum to k. Example: >>> subarraySum([1, 2, 3], 3) 2 >>> subarraySum([-1, -1, 1], 0) 1 >>> subarraySum([1, 1, 1], 2) 2 pass # Unit Tests def test_example_1(): nums = [1, 2, 3] k = 3 assert subarraySum(nums, k) == 2 def test_example_2(): nums = [-1, -1, 1] k = 0 assert subarraySum(nums, k) == 1 def test_example_3(): nums = [1, 1, 1] k = 2 assert subarraySum(nums, k) == 2 def test_single_element_positive(): nums = [5] k = 5 assert subarraySum(nums, k) == 1 def test_single_element_negative(): nums = [-5] k = -5 assert subarraySum(nums, k) == 1 def test_single_element_no_match(): nums = [5] k = 3 assert subarraySum(nums, k) == 0 def test_large_array(): nums = [1] * 10000 k = 2 assert subarraySum(nums, k) == 9999 def test_no_subarray_found(): nums = [1, 2, 3] k = 7 assert subarraySum(nums, k) == 0","solution":"from typing import List def subarraySum(nums: List[int], k: int) -> int: count = 0 cumulative_sum = 0 cumulative_sum_freq = {0: 1} for num in nums: cumulative_sum += num if cumulative_sum - k in cumulative_sum_freq: count += cumulative_sum_freq[cumulative_sum - k] if cumulative_sum in cumulative_sum_freq: cumulative_sum_freq[cumulative_sum] += 1 else: cumulative_sum_freq[cumulative_sum] = 1 return count"},{"question":"def sort_string(s: str) -> str: Sorts the input string such that all the alphabets come before the numbers, and both the alphabets and numbers are sorted in ascending order within their respective groups. Parameters: s (str): the input string containing a mix of alphabets and numbers. Returns: str: the sorted string. Examples: >>> sort_string(\\"b3a1d2\\") 'abd123' >>> sort_string(\\"4b2a1c3\\") 'abc1234' >>> sort_string(\\"1a1b0\\") 'ab011' >>> sort_string(\\"dcba\\") 'abcd' >>> sort_string(\\"4321\\") '1234' >>> sort_string(\\"\\") '' >>> sort_string(\\"a2\\") 'a2' >>> sort_string(\\"2a\\") 'a2'","solution":"def sort_string(s): Sorts the input string such that all the alphabets come before the numbers, and both the alphabets and numbers are sorted in ascending order within their respective groups. Parameters: s (str): the input string containing a mix of alphabets and numbers. Returns: str: the sorted string. # Separate characters into alphabets and numbers alphabets = sorted([char for char in s if char.isalpha()]) numbers = sorted([char for char in s if char.isdigit()]) # Combine sorted alphabets and numbers into one string return ''.join(alphabets + numbers)"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[List[int]]) -> List[int]: Perform operations on an array and return results of sum queries. Args: n: int - length of the array. q: int - number of queries. arr: List[int] - initial elements of the array. queries: List[List[int]] - list of queries, where each query is: - [1, i, x]: Update the element at index i to value x. - [2, l, r]: Calculate the sum of elements from index l to index r inclusive. Returns: List[int] - results of the sum queries. >>> process_queries(5, 6, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 2, 10], [2, 1, 3], [2, 2, 5], [1, 5, 20], [2, 4, 5]]) [6, 14, 22, 24]","solution":"def process_queries(n, q, arr, queries): result = [] for query in queries: if query[0] == 1: # Update the element at index i to x i, x = query[1] - 1, query[2] arr[i] = x elif query[0] == 2: # Calculate the sum of elements from index l to r l, r = query[1] - 1, query[2] - 1 result.append(sum(arr[l:r + 1])) return result"},{"question":"def examSchedule(capacities, students): Distributes students to examination rooms based on their capacities. Parameters: capacities (list of int): The capacity of each examination room. students (int): The total number of students to be scheduled. Returns: list of list: 2D list where each sublist contains the capacity of next room and the count of students allocated to it. from solution import examSchedule def test_examSchedule_exact_fit(): assert examSchedule([10, 20, 15], 45) == [[10, 10], [20, 20], [15, 15]] def test_examSchedule_extra_students(): assert examSchedule([10, 20, 15], 50) == [[10, 10], [20, 20], [15, 15]] def test_examSchedule_less_students(): assert examSchedule([10, 20, 15], 35) == [[10, 10], [20, 20], [15, 5]] def test_examSchedule_no_students(): assert examSchedule([5, 5, 5], 0) == [[5, 0], [5, 0], [5, 0]] def test_examSchedule_single_room(): assert examSchedule([10], 8) == [[10, 8]] def test_examSchedule_excess_capacity(): assert examSchedule([5, 5, 5], 1) == [[5, 1], [5, 0], [5, 0]]","solution":"def examSchedule(capacities, students): Distributes students to examination rooms based on their capacities. Parameters: capacities (list of int): The capacity of each examination room. students (int): The total number of students to be scheduled. Returns: list of list: 2D list where each sublist contains the capacity of next room and the count of students allocated to it. schedule = [] remaining_students = students for capacity in capacities: allocated_students = min(capacity, remaining_students) schedule.append([capacity, allocated_students]) remaining_students -= allocated_students if remaining_students <= 0: break # If we haven't gone through all capacities, append remaining empty rooms for i in range(len(schedule), len(capacities)): schedule.append([capacities[i], 0]) return schedule"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums: List[int]) -> Optional[TreeNode]: Converts a sorted array to a height balanced binary search tree (BST). >>> inorder_traversal(sortedArrayToBST([-10, -3, 0, 5, 9])) [-10, -3, 0, 5, 9] >>> inorder_traversal(sortedArrayToBST([1])) [1] >>> inorder_traversal(sortedArrayToBST([1, 2])) [1, 2] >>> inorder_traversal(sortedArrayToBST([1, 2, 3])) [1, 2, 3] >>> inorder_traversal(sortedArrayToBST([])) [] def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Helper function to perform inorder traversal of the BST and return the elements in a list. if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Converts a sorted array to a height balanced binary search tree (BST). if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sortedArrayToBST(nums[:mid]) root.right = sortedArrayToBST(nums[mid+1:]) return root"},{"question":"def numDecodings(s: str) -> int: Determine the number of ways to decode a string of digits. :param s: str :return: int Example 1: >>> numDecodings(\\"12\\") 2 Example 2: >>> numDecodings(\\"226\\") 3 Example 3: >>> numDecodings(\\"06\\") 0 Example 4: >>> numDecodings(\\"11106\\") 2","solution":"def numDecodings(s): Determine the number of ways to decode a string of digits. :param s: str :return: int if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) # Base cases dp[0] = 1 # An empty string has one way to be decoded dp[1] = 1 # A single non-zero digit has one way to be decoded # Fill the dp array for i in range(2, n + 1): # Check the single digit if s[i-1] != '0': dp[i] += dp[i-1] # Check the two-digit decipherability if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def update_leaderboard(leaderboard, new_scores): Updates the leaderboard with new scores and returns the updated leaderboard. Args: leaderboard (list of tuples): A list where each tuple contains a player's name and their current score. new_scores (dict): A dictionary where each key is a player's name and the value is the score they earned in the recent game. Returns: list of tuples: The updated leaderboard, sorted in descending order of scores, with ties broken by player names in ascending order. Examples: >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)], {\\"Alice\\": 200}) [(\\"Alice\\", 1700), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)], {\\"Derek\\": 1400}) [(\\"Alice\\", 1500), (\\"Derek\\", 1400), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)], {\\"Alice\\": 200, \\"Charlie\\": 100, \\"Derek\\": 1400}) [(\\"Alice\\", 1700), (\\"Derek\\", 1400), (\\"Bob\\", 1300), (\\"Charlie\\", 1300)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1300)], {\\"Alice\\": 100, \\"Bob\\": 1500}) [(\\"Bob\\", 2800), (\\"Alice\\", 1600)] >>> update_leaderboard([], {\\"Alice\\": 100, \\"Bob\\": 200, \\"Charlie\\": 150}) [(\\"Bob\\", 200), (\\"Charlie\\", 150), (\\"Alice\\", 100)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)], {}) [(\\"Alice\\", 1500), (\\"Bob\\", 1300), (\\"Charlie\\", 1200)]","solution":"def update_leaderboard(leaderboard, new_scores): Updates the leaderboard with new scores and returns the updated leaderboard. Args: leaderboard (list of tuples): A list where each tuple contains a player's name and their current score. new_scores (dict): A dictionary where each key is a player's name and the value is the score they earned in the recent game. Returns: list of tuples: The updated leaderboard, sorted in descending order of scores, with ties broken by player names in ascending order. # Convert leaderboard list to a dictionary for easier updates current_scores = {name: score for name, score in leaderboard} # Update the current scores with new scores for name, score in new_scores.items(): if name in current_scores: current_scores[name] += score else: current_scores[name] = score # Convert the dictionary back to a list of tuples updated_leaderboard = list(current_scores.items()) # Sort the leaderboard first by descending score, then by name for ties updated_leaderboard.sort(key=lambda x: (-x[1], x[0])) return updated_leaderboard"},{"question":"from typing import List, Tuple def minimum_difference_between_containers(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum possible absolute difference between the weights of the two containers for each test case. Args: T: Number of test cases test_cases: List of tuples, each containing the number of items and the list of item weights Returns: List of integers representing the minimum possible absolute difference in weights for each test case. >>> minimum_difference_between_containers(2, [(4, [3, 1, 4, 2]), (3, [2, 5, 6])]) [0, 1] >>> minimum_difference_between_containers(1, [(1, [1000])]) [1000]","solution":"def minimum_difference_between_containers(T, test_cases): Returns the minimum possible absolute difference between the weights of the two containers for each test case. results = [] for n, weights in test_cases: total_weight = sum(weights) dp = [False] * (total_weight + 1) dp[0] = True for weight in weights: for j in range(total_weight - weight, -1, -1): if dp[j]: dp[j + weight] = True min_diff = float('inf') for j in range(total_weight // 2 + 1): if dp[j]: min_diff = min(min_diff, abs(total_weight - 2 * j)) results.append(min_diff) return results"},{"question":"def expand_string(s: str) -> str: Expands the given string \`s\` according to the specified rules. >>> expand_string('3a4b2c') 'aaabbbbcc' >>> expand_string('1a0b3c') 'accc' >>> expand_string('2x3y4z') 'xxyyyzzzz' >>> expand_string('a2b3c') 'abbccc' >>> expand_string('10a2b') 'aaaaaaaaaabb' >>> expand_string('0c0d1e') 'e' >>> expand_string('3a3b3c') 'aaabbbccc' >>> expand_string('a') 'a' >>> expand_string('2a5b10c') 'aabbbbbcccccccccc'","solution":"def expand_string(s): Expands the given string \`s\` according to the specified rules. Args: - s (str): the input string to expand. Returns: - str: the expanded string. # Initialize the result string result = [] i = 0 while i < len(s): if s[i].isdigit(): # Gather any consecutive digits to form a number num = 0 while i < len(s) and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 # The next character must be a letter if i < len(s) and s[i].isalpha(): result.append(s[i] * num) else: # Add the letter as is result.append(s[i]) i += 1 return \\"\\".join(result)"},{"question":"def max_subarray_sum(num_cases: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array A_1, A_2, ..., A_N, find the maximum sum of any subarray of array A. A subarray A[i, j], where 1  i  j  N is a sequence of integers A_i, A_{i+1}, ..., A_j. You have to find the subarray A[i, j] with the maximum possible sum. Parameters: num_cases (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the size of the array and the array elements. Returns: List[int]: A list of integers representing the maximum sum of subarray for each test case. Example: >>> max_subarray_sum(2, [(4, [-2, 1, -3, 4]), (5, [1, 2, 3, 4, 5])]) [4, 15]","solution":"def max_subarray_sum(num_cases, test_cases): results = [] for case in test_cases: N, array = case max_ending_here = max_so_far = array[0] for i in range(1, N): max_ending_here = max(array[i], max_ending_here + array[i]) max_so_far = max(max_so_far, max_ending_here) results.append(max_so_far) return results"},{"question":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the integer that appears only once in a list where all other integers appear exactly three times. >>> find_single_number([2, 2, 3, 2]) 3 >>> find_single_number([0, 1, 0, 1, 0, 1, 99]) 99 # Implement the function here # Unit tests def test_find_single_number_case_one(): assert find_single_number([2, 2, 3, 2]) == 3 def test_find_single_number_case_two(): assert find_single_number([0, 1, 0, 1, 0, 1, 99]) == 99 def test_find_single_number_with_negative_numbers(): assert find_single_number([-1, -1, -1, -2]) == -2 def test_find_single_number_single_element(): assert find_single_number([1]) == 1 def test_find_single_number_with_large_numbers(): assert find_single_number([10**6, 10**6, 10**6, 100]) == 100","solution":"def find_single_number(nums): Finds the integer that appears only once in a list where all other integers appear exactly three times. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"from typing import List def remove_duplicates_and_sort(lst: List[int]) -> List[int]: Remove duplicates from the list and return the remaining elements sorted in ascending order. Args: lst (list): List of integers. Returns: list: Sorted list of integers with duplicates removed. >>> remove_duplicates_and_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 2, 3, 4, 5, 6, 9] >>> remove_duplicates_and_sort([5, 3, 8, 1, 2]) [1, 2, 3, 5, 8] >>> remove_duplicates_and_sort([7, 7, 7, 7, 7]) [7] >>> remove_duplicates_and_sort([]) [] >>> remove_duplicates_and_sort([42]) [42] >>> remove_duplicates_and_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_and_sort([2, -3, -2, 2, 1]) [-3, -2, 1, 2]","solution":"def remove_duplicates_and_sort(lst): Remove duplicates from the list and return the remaining elements sorted in ascending order. Args: lst (list): List of integers. Returns: list: Sorted list of integers with duplicates removed. return sorted(set(lst))"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of non-empty palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aa\\") 3 def count_palindromes_in_test_cases(test_cases: List[str]) -> List[int]: For each test case in test_cases, return the count of non-empty palindromic substrings. >>> count_palindromes_in_test_cases([\\"ababa\\", \\"aaa\\", \\"abc\\", \\"aa\\"]) [9, 6, 3, 3]","solution":"def count_palindromic_substrings(s): Returns the number of non-empty palindromic substrings in the given string s. n = len(s) count = 0 # Function to check palindromes expanding around the center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): expand_around_center(i, i) # odd length palindromes expand_around_center(i, i+1) # even length palindromes return count def count_palindromes_in_test_cases(test_cases): results = [] for s in test_cases: results.append(count_palindromic_substrings(s)) return results"},{"question":"def determine_level(points: int) -> int: Given the accumulated points, return the player's level. >>> determine_level(50) 1 >>> determine_level(450) 4 >>> determine_level(3001) 9 def process_test_cases(test_cases: List[int]) -> List[int]: Given a list of test cases with accumulated points, return a list of player levels. >>> process_test_cases([50, 450, 3001]) [1, 4, 9] >>> process_test_cases([0, 99, 100, 199, 200, 299, 300, 499]) [1, 1, 2, 2, 3, 3, 4, 4] >>> process_test_cases([500, 799, 800, 1299, 1300, 1999, 2000, 2999, 3000, 4999, 5000, 10000000]) [5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10]","solution":"def determine_level(points): Given the accumulated points, return the player's level. if points >= 5000: return 10 elif points >= 3000: return 9 elif points >= 2000: return 8 elif points >= 1300: return 7 elif points >= 800: return 6 elif points >= 500: return 5 elif points >= 300: return 4 elif points >= 200: return 3 elif points >= 100: return 2 else: return 1 def process_test_cases(test_cases): Given a list of test cases with accumulated points, return a list of player levels. results = [] for points in test_cases: results.append(determine_level(points)) return results"},{"question":"from typing import List def find_anagrams(s: str) -> List[str]: Returns all unique anagrams of the string \`s\`, sorted lexicographically. >>> find_anagrams(\\"eat\\") ['aet', 'ate', 'eat', 'eta', 'tae', 'tea'] >>> find_anagrams(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] def test_find_anagrams_with_three_characters(): result = find_anagrams(\\"eat\\") assert result == ['aet', 'ate', 'eat', 'eta', 'tae', 'tea'] def test_find_anagrams_with_all_unique_characters(): result = find_anagrams(\\"abc\\") assert result == ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] def test_find_anagrams_with_repeating_characters(): result = find_anagrams(\\"aab\\") assert result == ['aab', 'aba', 'baa'] def test_find_anagrams_with_single_character(): result = find_anagrams(\\"a\\") assert result == ['a'] def test_find_anagrams_with_two_characters(): result = find_anagrams(\\"ab\\") assert result == ['ab', 'ba'] def test_find_anagrams_with_same_characters(): result = find_anagrams(\\"aaa\\") assert result == ['aaa']","solution":"from itertools import permutations from typing import List def find_anagrams(s: str) -> List[str]: Returns all unique anagrams of the string \`s\`, sorted lexicographically. # Generate all possible permutations of the string \`s\` perm_set = set(permutations(s)) # Convert each tuple to a string anagrams = [''.join(perm) for perm in perm_set] # Sort the list lexicographically anagrams.sort() return anagrams"},{"question":"def sum_of_odd_numbers(test_cases): Given an integer array A of size N, find the sum of all odd numbers in the array. Args: test_cases (List): a list of test cases where even-indexed elements represent the size of the array and odd-indexed elements represent the array itself. Returns: List: a list of integers representing the sum of odd numbers for each test case. Example: >>> sum_of_odd_numbers([4, [1, 2, 3, 4], 5, [10, 21, 32, 43, 54], 3, [7, 8, 5]]) [4, 64, 12]","solution":"def sum_of_odd_numbers(test_cases): results = [] for i in range(0, len(test_cases), 2): n = test_cases[i] array = test_cases[i+1] sum_odds = sum(x for x in array if x % 2 != 0) results.append(sum_odds) return results"},{"question":"def min_shelves_required(genres: List[int], shelf_capacity: int) -> int: Function to calculate the minimum number of shelves required to store all the books. :param genres: List of integers where each integer is the number of books in a genre. :param shelf_capacity: Maximum number of books one shelf can hold. :return: Minimum number of shelves required. >>> min_shelves_required([100, 200, 300], 200) 3 >>> min_shelves_required([50, 50, 50, 50], 100) 2 pass","solution":"def min_shelves_required(genres, shelf_capacity): Function to calculate the minimum number of shelves required to store all the books. :param genres: List of integers where each integer is the number of books in a genre. :param shelf_capacity: Maximum number of books one shelf can hold. :return: Minimum number of shelves required. total_books = sum(genres) # Calculate the minimum number of shelves required shelves_needed = (total_books + shelf_capacity - 1) // shelf_capacity return shelves_needed"},{"question":"def training_battle(guild1, guild2): Compare the abilities of warriors from two guilds in training battles. >>> training_battle( [{\\"name\\": \\"Aragorn\\", \\"strength\\": 85, \\"intelligence\\": 75, \\"agility\\": 80, \\"stamina\\": 90}, {\\"name\\": \\"Legolas\\", \\"strength\\": 70, \\"intelligence\\": 85, \\"agility\\": 95, \\"stamina\\": 75}], [{\\"name\\": \\"Gimli\\", \\"strength\\": 90, \\"intelligence\\": 65, \\"agility\\": 70, \\"stamina\\": 85}, {\\"name\\": \\"Boromir\\", \\"strength\\": 80, \\"intelligence\\": 70, \\"agility\\": 75, \\"stamina\\": 80}] ) {\\"winner\\": \\"guild1\\", \\"guild1_wins\\": 2, \\"guild2_wins\\": 0} >>> training_battle( [{\\"name\\": \\"Warrior1\\", \\"strength\\": 60, \\"intelligence\\": 50, \\"agility\\": 55, \\"stamina\\": 70}], [{\\"name\\": \\"Warrior2\\", \\"strength\\": 100, \\"intelligence\\": 100, \\"agility\\": 100, \\"stamina\\": 100}] ) {\\"winner\\": \\"guild2\\", \\"guild1_wins\\": 0, \\"guild2_wins\\": 1} >>> training_battle( [{\\"name\\": \\"Warrior1\\", \\"strength\\": 60, \\"intelligence\\": 70, \\"agility\\": 80, \\"stamina\\": 90}], [{\\"name\\": \\"Warrior2\\", \\"strength\\": 65, \\"intelligence\\": 85, \\"agility\\": 60, \\"stamina\\": 90}] ) {\\"winner\\": \\"Tie\\", \\"guild1_wins\\": 0, \\"guild2_wins\\": 0} >>> training_battle( [{\\"name\\": \\"Warrior1\\", \\"strength\\": 80, \\"intelligence\\": 70, \\"agility\\": 75, \\"stamina\\": 85}, {\\"name\\": \\"Warrior2\\", \\"strength\\": 60, \\"intelligence\\": 55, \\"agility\\": 60, \\"stamina\\": 70}], [{\\"name\\": \\"Warrior3\\", \\"strength\\": 75, \\"intelligence\\": 75, \\"agility\\": 75, \\"stamina\\": 75}] ) {\\"winner\\": \\"guild1\\", \\"guild1_wins\\": 1, \\"guild2_wins\\": 0}","solution":"def training_battle(guild1, guild2): guild1_wins = 0 guild2_wins = 0 for warrior1, warrior2 in zip(guild1, guild2): guild1_score = warrior1[\\"strength\\"] + warrior1[\\"intelligence\\"] + warrior1[\\"agility\\"] + warrior1[\\"stamina\\"] guild2_score = warrior2[\\"strength\\"] + warrior2[\\"intelligence\\"] + warrior2[\\"agility\\"] + warrior2[\\"stamina\\"] if guild1_score > guild2_score: guild1_wins += 1 elif guild2_score > guild1_score: guild2_wins += 1 if guild1_wins > guild2_wins: winner = \\"guild1\\" elif guild2_wins > guild1_wins: winner = \\"guild2\\" else: winner = \\"Tie\\" return { \\"winner\\": winner, \\"guild1_wins\\": guild1_wins, \\"guild2_wins\\": guild2_wins }"},{"question":"def highest_skill_team(t: int, teams: List[List[int]]) -> int: Returns the highest total skill level among the given teams. Parameters: t (int): Number of teams teams (list of list of int): Skill levels of the teams Returns: int: The total skill level of the team with highest combined skill >>> highest_skill_team(1, [[5, 10, -3]]) == 12 >>> highest_skill_team(3, [[1, 2, 3], [-5, -6], [4, 0, -1, 5]]) == 8 >>> highest_skill_team(2, [[-10, -20], [-5, -5, -5]]) == -15 >>> highest_skill_team(2, [[0, 0, 0], [0, 0, 0, 0]]) == 0 >>> highest_skill_team(3, [[3, -1, 2], [-3, 1, 3], [5, -5, 7]]) == 7 >>> highest_skill_team(4, [[1, 1], [1, 1], [1, 1], [1, 1]]) == 2","solution":"def highest_skill_team(t, teams): Returns the highest total skill level among the given teams. Parameters: t (int): Number of teams teams (list of list of int): Skill levels of the teams Returns: int: The total skill level of the team with highest combined skill max_skill = float('-inf') # Initialize with the lowest possible value for team in teams: total_skill = sum(team) if total_skill > max_skill: max_skill = total_skill return max_skill"},{"question":"def teamRoles(positions, queries): Processes and retrieves information about team members based on roles and member queries. Args: positions (dict): A dictionary where keys are role names and values are lists of team member names. queries (list): A list of tuples representing the queries. Returns: list: A list of lists with the results of the queries. Examples: >>> positions = { ... \\"Developer\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], ... \\"Manager\\": [\\"Eve\\", \\"Bob\\"], ... \\"Tester\\": [\\"Charlie\\", \\"Eve\\"] ... } >>> queries = [ ... (\\"role\\", \\"Developer\\"), ... (\\"role\\", \\"Manager\\"), ... (\\"member\\", \\"Bob\\"), ... (\\"member\\", \\"Alice\\"), ... (\\"role\\", \\"Designer\\") ... ] >>> teamRoles(positions, queries) [['Alice', 'Bob', 'Charlie'], ['Eve', 'Bob'], ['Developer', 'Manager'], ['Developer'], []] # Unit Tests def test_teamRoles(): positions = { \\"Developer\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"Manager\\": [\\"Eve\\", \\"Bob\\"], \\"Tester\\": [\\"Charlie\\", \\"Eve\\"] } queries = [ (\\"role\\", \\"Developer\\"), (\\"role\\", \\"Manager\\"), (\\"member\\", \\"Bob\\"), (\\"member\\", \\"Alice\\"), (\\"role\\", \\"Designer\\") ] # Expected output expected_output = [ [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], [\\"Eve\\", \\"Bob\\"], [\\"Developer\\", \\"Manager\\"], [\\"Developer\\"], [] ] assert teamRoles(positions, queries) == expected_output def test_teamRoles_empty_positions(): positions = {} queries = [ (\\"role\\", \\"Developer\\"), (\\"member\\", \\"Alice\\") ] # Expected output expected_output = [ [], [] ] assert teamRoles(positions, queries) == expected_output def test_teamRoles_single_role_multiple_members(): positions = { \\"Project Manager\\": [\\"John\\", \\"Doe\\", \\"Alice\\"] } queries = [ (\\"role\\", \\"Project Manager\\"), (\\"member\\", \\"Alice\\"), (\\"member\\", \\"John\\"), (\\"member\\", \\"Nonexistent Member\\") ] # Expected output expected_output = [ [\\"John\\", \\"Doe\\", \\"Alice\\"], [\\"Project Manager\\"], [\\"Project Manager\\"], [] ] assert teamRoles(positions, queries) == expected_output def test_teamRoles_member_with_multiple_roles(): positions = { \\"Developer\\": [\\"Alice\\", \\"Charlie\\"], \\"Manager\\": [\\"Charlie\\"], \\"Tester\\": [\\"Charlie\\"] } queries = [ (\\"member\\", \\"Charlie\\"), (\\"role\\", \\"Developer\\"), (\\"role\\", \\"Manager\\") ] # Expected output expected_output = [ [\\"Developer\\", \\"Manager\\", \\"Tester\\"], [\\"Alice\\", \\"Charlie\\"], [\\"Charlie\\"] ] assert teamRoles(positions, queries) == expected_output def test_teamRoles_roles_and_members_not_found(): positions = { \\"Developer\\": [\\"Alice\\"], } queries = [ (\\"role\\", \\"Designer\\"), (\\"member\\", \\"Bob\\") ] # Expected output expected_output = [ [], [] ] assert teamRoles(positions, queries) == expected_output","solution":"def teamRoles(positions, queries): Processes and retrieves information about team members based on roles and member queries. Args: positions (dict): A dictionary where keys are role names and values are lists of team member names. queries (list): A list of tuples representing the queries. Returns: list: A list of lists with the results of the queries. result = [] # Create a reverse dictionary mapping members to roles for quick lookup in member queries member_role_map = {} for role, members in positions.items(): for member in members: if member in member_role_map: member_role_map[member].append(role) else: member_role_map[member] = [role] # Process each query for query in queries: query_type, query_value = query if query_type == \\"role\\": # Return list of members holding the specified role_name result.append(positions.get(query_value, [])) elif query_type == \\"member\\": # Return list of roles assigned to the specified member_name result.append(member_role_map.get(query_value, [])) return result"},{"question":"def print_diamond(N: int): Given a positive integer N, print a diamond pattern of height 2*N - 1 using only arithmetic operations. This function should print a diamond shape with the height of 2*N-1. For example, for N=3, the output should be: * *** ***** *** *","solution":"def print_diamond(N): rows = 2 * N - 1 for i in range(rows): if i < N: # Top half of the diamond including the middle row for j in range(rows): if j >= N - i - 1 and j <= N + i - 1: print('*', end='') else: print(' ', end='') else: # Bottom half of the diamond for j in range(rows): if j >= i - N + 1 and j < rows - (i - N + 1): print('*', end='') else: print(' ', end='') print()"},{"question":"def eval_expression(expression: str, variables: dict) -> float: Evaluate a mathematical expression using variable values provided in a dictionary. Parameters: expression (str): A string containing a valid mathematical expression. variables (dict): A dictionary where the keys are variable names, and the values are their corresponding numeric values. Returns: float: The result of the evaluated expression. Examples: >>> eval_expression(\\"a + b\\", {\\"a\\": 5, \\"b\\": 3}) 8.0 >>> eval_expression(\\"a + b - (c * d) / e\\", {\\"a\\": 5, \\"b\\": 3, \\"c\\": 8, \\"d\\": 2, \\"e\\": 4}) 4.0 >>> eval_expression(\\"a * (b + c) / d\\", {\\"a\\": 6, \\"b\\": 2, \\"c\\": 4, \\"d\\": 3}) 12.0 >>> eval_expression(\\"a + b - c * d / e\\", {\\"a\\": 10, \\"b\\": 5, \\"c\\": 6, \\"d\\": 3, \\"e\\": 2}) 6.0 >>> eval_expression(\\"a / b\\", {\\"a\\": 4, \\"b\\": 0}) ZeroDivisionError","solution":"def eval_expression(expression, variables): Evaluates a mathematical expression using the provided variable values. Parameters: expression (str): A string containing a valid mathematical expression. variables (dict): A dictionary where the keys are variable names, and the values are their corresponding numeric values. Returns: float: The result of the evaluated expression. for var, value in variables.items(): expression = expression.replace(var, str(value)) return eval(expression)"},{"question":"def can_form_arithmetic_progression(arr: List[int]) -> bool: Determines if the elements of the array can be re-arranged to form an arithmetic progression. Parameters: arr (list of int): The array of integers to check. Returns: bool: True if the array can be re-arranged into an arithmetic progression, False otherwise. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 2, 4]) False >>> can_form_arithmetic_progression([1]) True >>> can_form_arithmetic_progression([]) True >>> can_form_arithmetic_progression([7, 7, 7]) True >>> can_form_arithmetic_progression([3, 6, 9, 12, 15]) True >>> can_form_arithmetic_progression([5, 7, 1, 3]) True >>> can_form_arithmetic_progression([1, 3, 5, 9]) False","solution":"def can_form_arithmetic_progression(arr): Determines if the elements of the array can be re-arranged to form an arithmetic progression. Parameters: arr (list of int): The array of integers to check. Returns: bool: True if the array can be re-arranged into an arithmetic progression, False otherwise. if len(arr) <= 1: return True arr.sort() difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != difference: return False return True"},{"question":"import re from collections import defaultdict from typing import Dict def word_count(text: str) -> Dict[str, int]: Returns a dictionary with words as keys and their frequencies as values. >>> word_count(\\"Hello world! Hello everyone.\\") {'hello': 2, 'world': 1, 'everyone': 1} >>> word_count(\\"It's a beautiful day; isn't it?\\") {'it': 2, 's': 1, 'a': 1, 'beautiful': 1, 'day': 1, 'isn': 1, 't': 1} >>> word_count(\\"HELLO hello HeLLo\\") {'hello': 3} >>> word_count(\\"\\") {} >>> word_count(\\"123 456!!! some_words here 123.\\") {'some': 1, 'words': 1, 'here': 1} >>> word_count(\\"hi!@#%^&*()_+-=,./<>?;:'\\"[]{}| hi\\") {'hi': 2} # Implement the function here","solution":"import re from collections import defaultdict def word_count(text): Returns a dictionary with words as keys and their frequencies as values. # Normalize the text to lowercase and use a regular expression to find words text = text.lower() words = re.findall(r'[a-z]+', text) # Initialize a default dictionary to count word frequencies word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"def is_palindrome_permutation(s: str) -> bool: Check if a given string is a permutation of a palindrome. >>> is_palindrome_permutation(\\"Tact Coa\\") True >>> is_palindrome_permutation(\\"Was it a car or a cat I saw\\") True >>> is_palindrome_permutation(\\"This is not a palindrome\\") False >>> is_palindrome_permutation(\\"\\") True >>> is_palindrome_permutation(\\"a\\") True >>> is_palindrome_permutation(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome_permutation(\\"AaBbCcDdEeFff\\") True >>> is_palindrome_permutation(\\"abcdefg\\") False","solution":"def is_palindrome_permutation(s: str) -> bool: # Remove whitespaces and convert to lowercase s = ''.join(filter(str.isalnum, s)).lower() char_count = {} # Count occurrences of each character for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of odd counts odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # A palindrome permutation can have at most one character with an odd count return odd_count <= 1"},{"question":"def product_except_self(nums): Given an array of integers, return a new array such that each element at index \`i\` of the new array is equal to the product of all the values in the original array except the one at index \`i\` without using division and in linear time. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 6, 7]) [42, 35, 30] >>> product_except_self([3, 2]) [2, 3] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] pass def process_test_cases(test_cases): Process a list of test cases and return the results for each case. >>> test_cases = [(4, [1, 2, 3, 4]), (3, [5, 6, 7])] >>> process_test_cases(test_cases) [[24, 12, 8, 6], [42, 35, 30]] pass def main(input_data): Read input data, process the test cases and print results. >>> input_data = \\"2n4n1 2 3 4n3n5 6 7n\\" >>> main(input_data) 24 12 8 6 42 35 30 pass","solution":"def product_except_self(nums): n = len(nums) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [0] * n # Fill left_products array for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Fill right_products array for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Construct result from left_products and right_products for i in range(n): result[i] = left_products[i] * right_products[i] return result def process_test_cases(test_cases): results = [] for case in test_cases: n, arr = case result = product_except_self(arr) results.append(result) return results def main(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] idx = 1 for _ in range(t): n = int(lines[idx]) arr = list(map(int, lines[idx + 1].split())) test_cases.append((n, arr)) idx += 2 results = process_test_cases(test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"from typing import List def permutations(s: str) -> List[str]: Create a function called \`permutations\` that takes in a string \`s\` and returns a list of all possible permutations of the characters in the string. The permutations should be in lexicographic (sorted) order if the input string is sorted. >>> permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> permutations(\\"dog\\") == [\\"dgo\\", \\"dog\\", \\"gdo\\", \\"god\\", \\"odg\\", \\"ogd\\"] >>> permutations(\\"a\\") == [\\"a\\"] >>> permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] >>> permutations(\\"\\") == [\\"\\"] pass","solution":"import itertools def permutations(s): Returns a list of all possible permutations of the characters in the string s, in lexicographic order. return sorted([''.join(p) for p in itertools.permutations(s)])"},{"question":"def group_by_owners(files_dict: dict) -> dict: Groups filenames by their owners. Parameters: files_dict (dict): A dictionary where the keys are filenames and the values are the owners' names. Returns: dict: A dictionary where the keys are the owners' names and the values are lists of filenames owned by them. Examples: >>> group_by_owners({'Input.txt': 'Randy', 'Code.py': 'Stan', 'Output.txt': 'Randy'}) {'Randy': ['Input.txt', 'Output.txt'], 'Stan': ['Code.py']} >>> group_by_owners({'a.txt': 'Anna', 'b.txt': 'Anna', 'c.txt': 'Anna'}) {'Anna': ['a.txt', 'b.txt', 'c.txt']} >>> group_by_owners({'file1': 'Owner1', 'file2': 'Owner2', 'file3': 'Owner1', 'file4': 'Owner3', 'file5': 'Owner2'}) {'Owner1': ['file1', 'file3'], 'Owner2': ['file2', 'file5'], 'Owner3': ['file4']} >>> group_by_owners({}) {} >>> group_by_owners({'fileA': 'Alice', 'fileB': 'Bob', 'fileC': 'Charlie', 'fileD': 'Dana'}) {'Alice': ['fileA'], 'Bob': ['fileB'], 'Charlie': ['fileC'], 'Dana': ['fileD']} >>> group_by_owners({'fileA': 'Alice', 'fileB': 'Bob', 'fileA': 'Charlie'}) {'Charlie': ['fileA'], 'Bob': ['fileB']}","solution":"def group_by_owners(files_dict: dict) -> dict: Groups filenames by their owners. Parameters: files_dict (dict): A dictionary where the keys are filenames and the values are the owners' names. Returns: dict: A dictionary where the keys are the owners' names and the values are lists of filenames owned by them. result = {} for file, owner in files_dict.items(): if owner in result: result[owner].append(file) else: result[owner] = [file] return result"},{"question":"def combine_arrays(arr1, arr2): Combines two lists of integers into a new sorted list without duplicates. >>> combine_arrays([3, 1, 3, 2], [4, 2, 5]) == [1, 2, 3, 4, 5] >>> combine_arrays([1, 2, 3], [3, 4, 5]) == [1, 2, 3, 4, 5] >>> combine_arrays([], [1, 2, 3]) == [1, 2, 3] # Your code here","solution":"def combine_arrays(arr1, arr2): Combines two lists of integers into a new sorted list without duplicates. combined = arr1 + arr2 # Remove duplicates result = [] seen = set() for number in combined: if number not in seen: seen.add(number) result.append(number) # Perform insertion sort on the result list for i in range(1, len(result)): key = result[i] j = i - 1 while j >= 0 and key < result[j]: result[j + 1] = result[j] j -= 1 result[j + 1] = key return result"},{"question":"def unique_paths(R: int, C: int, grid: List[str]) -> int: Determine the number of unique paths from the top-left to the bottom-right corner of the grid. >>> unique_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> unique_paths(3, 3, [\\".#.\\", \\"#\\", \\"..#\\"]) 0","solution":"def unique_paths(R, C, grid): MOD = 1000000007 # dp table with R rows and C columns initialized to 0 dp = [[0] * C for _ in range(R)] # Starting point if grid[0][0] == '.': dp[0][0] = 1 # Fill the dp table for i in range(R): for j in range(C): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[R-1][C-1]"},{"question":"def sum_above_threshold(arr, threshold): Returns the sum of all integers in the array that are strictly greater than the given threshold. >>> sum_above_threshold([1, 2, 3, 4, 5], 3) 9 >>> sum_above_threshold([10, -1, 7, 0], 5) 17 >>> sum_above_threshold([-3, -2, -1, 0], -2) -1","solution":"def sum_above_threshold(arr, threshold): Returns the sum of all integers in the array that are strictly greater than the given threshold. return sum(x for x in arr if x > threshold)"},{"question":"def mergeAndSort(list1, list2): Merges two lists of integers into a single list, removes any duplicates, and sorts the resulting list in ascending order. Args: list1 (list of int): The first list of integers. list2 (list of int): The second list of integers. Returns: list of int: The merged, deduplicated, and sorted list.","solution":"def mergeAndSort(list1, list2): Merges two lists of integers into a single list, removes any duplicates, and sorts the resulting list in ascending order. Args: list1 (list of int): The first list of integers. list2 (list of int): The second list of integers. Returns: list of int: The merged, deduplicated, and sorted list. merged_list = list(set(list1 + list2)) merged_list.sort() return merged_list"},{"question":"from typing import List def can_form_palindrome(numbers: List[int]) -> bool: Determines whether it is possible to rearrange the list to form a palindrome. Examples: >>> can_form_palindrome([1, 2, 3, 2, 1]) True >>> can_form_palindrome([1, 2, 3, 4, 5]) False","solution":"from collections import Counter def can_form_palindrome(numbers): Determines whether it is possible to rearrange the list to form a palindrome. Parameters: numbers (list): A list of integers. Returns: bool: True if it is possible to rearrange the list to form a palindrome, otherwise False. count = Counter(numbers) odd_count = sum(1 for frequency in count.values() if frequency % 2 != 0) # A palindrome can have at most one character with an odd frequency return odd_count <= 1"},{"question":"from typing import List def sortByFrequency(arr: List[int]) -> List[int]: Takes a list of integers and returns a new list where the integers are sorted by the frequency of their occurrences. If two integers have the same frequency, they are sorted in ascending order. >>> sortByFrequency([4, 5, 6, 5, 4, 3]) [3, 6, 4, 4, 5, 5] >>> sortByFrequency([1]) [1] >>> sortByFrequency([2, 3, 2, 3, 1, 1]) [1, 1, 2, 2, 3, 3] >>> sortByFrequency([7, 7, 7, 7]) [7, 7, 7, 7] >>> sortByFrequency([9, 8, 7, 8, 7, 7]) [9, 8, 8, 7, 7, 7] >>> sortByFrequency([10, 10, 10, 9, 9, 8]) [8, 9, 9, 10, 10, 10]","solution":"from collections import Counter def sortByFrequency(arr): Takes a list of integers and returns a new list where the integers are sorted by the frequency of their occurrences. If two integers have the same frequency, they are sorted in ascending order. # Count the frequency of each integer in the array frequency = Counter(arr) # Sort the array first by frequency, and then by the integer value sorted_arr = sorted(arr, key=lambda x: (frequency[x], x)) return sorted_arr"},{"question":"def solve(arr: List[int], k: int) -> int: Determines the number of consecutive subarrays that have a sum divisible by k. Parameters: arr (list of int): The array of integers. k (int): The divisor. Returns: int: The number of subarrays with a sum divisible by k. >>> solve([2, 3, 1, 6, 4], 3) 4 >>> solve([1, 2, 4], 5) 0 >>> solve([3, 3, 3], 3) 6 >>> solve([4, 5, 0, -2, -3, 1], 5) 7 >>> solve([-5, -5, 5, 5], 5) 10 >>> solve([1, 2, 3], 0) 0","solution":"def solve(arr, k): Determines the number of consecutive subarrays that have a sum divisible by k. Parameters: arr (list of int): The array of integers. k (int): The divisor. Returns: int: The number of subarrays with a sum divisible by k. if k == 0: return 0 count = 0 prefix_sum = 0 remainder_count = {0: 1} # Initialize with 0 remainder and count 1 for subarray starting from index zero for num in arr: prefix_sum += num remainder = prefix_sum % k if remainder < 0: remainder += k if remainder in remainder_count: count += remainder_count[remainder] remainder_count[remainder] += 1 else: remainder_count[remainder] = 1 return count"},{"question":"def find_first_duplicate_word(s: str) -> str: Returns the first word in the string 's' that has duplicate consecutive characters. If no such word exists, returns an empty string. Examples: >>> find_first_duplicate_word(\\"hello world\\") 'hello' >>> find_first_duplicate_word(\\"this is a test\\") '' >>> find_first_duplicate_word(\\"success is key\\") 'success'","solution":"def find_first_duplicate_word(s): Returns the first word in the string 's' that has duplicate consecutive characters. If no such word exists, returns an empty string. words = s.split() for word in words: for i in range(len(word) - 1): if word[i] == word[i + 1]: return word return \\"\\""},{"question":"from typing import List, Optional def find_majority_element(arr: List[int]) -> Optional[int]: Finds the majority element in the array if it exists, otherwise returns None. A majority element is one that appears more than n / 2 times. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == None >>> find_majority_element([2, 2, 1, 1, 2, 2, 2, 2]) == 2 def test_majority_element_exists(): assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert find_majority_element([2, 2, 1, 1, 2, 2, 2, 2]) == 2 def test_no_majority_element(): assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == None def test_single_element(): assert find_majority_element([1]) == 1 def test_two_different_elements(): assert find_majority_element([1, 2]) == None def test_all_elements_same(): assert find_majority_element([5, 5, 5, 5, 5]) == 5 def test_multiple_appearances_but_no_majority(): assert find_majority_element([1, 2, 3, 1, 2, 1, 2, 1, 2, 1, 2]) == None def test_empty_list(): assert find_majority_element([]) == None","solution":"from typing import List, Optional def find_majority_element(arr: List[int]) -> Optional[int]: Finds the majority element in the array if it exists, otherwise returns None. A majority element is one that appears more than n / 2 times. count = {} n = len(arr) for num in arr: if num in count: count[num] += 1 else: count[num] = 1 # If at any point, the count of the number exceeds n // 2, return it immediately if count[num] > n // 2: return num return None"},{"question":"def exam_result(score: int) -> str: Returns the result of an exam based on the given score. If the score (integer) is 90 or above, you should return \\"Excellent\\". If the score is between 70 and 89 inclusive, you should return \\"Good\\". If the score is between 50 and 69 inclusive, you should return \\"Pass\\". If the score is below 50, you should return \\"Fail\\". >>> exam_result(90) == \\"Excellent\\" >>> exam_result(75) == \\"Good\\" >>> exam_result(60) == \\"Pass\\" >>> exam_result(30) == \\"Fail\\"","solution":"def exam_result(score): Returns the result of an exam based on the given score. Parameters: score (int): The score obtained in the exam. Returns: str: The result of the exam (\\"Excellent\\", \\"Good\\", \\"Pass\\", \\"Fail\\"). if score >= 90: return \\"Excellent\\" elif score >= 70: return \\"Good\\" elif score >= 50: return \\"Pass\\" else: return \\"Fail\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression in infix notation with +, -, *, / operators. The division (/) is integer division. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5","solution":"def evaluate_expression(expression): Evaluate a mathematical expression in infix notation with +, -, *, / operators. The division (/) is integer division. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b # integer division def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue if tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(expression)"},{"question":"from typing import List def minCoins(coins: List[int], amount: int) -> int: Given a list of integers, where each number represents the nominal value of a coin, determine the minimum number of coins that add up to a given sum. If that amount cannot be made up by any combination of the coins, return -1. >>> minCoins([1, 2, 5], 11) 3 # Explanation: 11 = 5 + 5 + 1 >>> minCoins([2], 3) -1 # Explanation: It's not possible to make up 3 with only coins of 2","solution":"from typing import List def minCoins(coins: List[int], amount: int) -> int: Returns the minimum number of coins required to make up the given amount. If it's not possible to make up the amount, returns -1. # We initialize an array dp with size (amount + 1) with infinity values dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case, 0 coins needed to make amount 0 # Iterate through each coin and update the dp table for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # If dp[amount] is still infinity, it means it's not possible to form the amount return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def final_coordinates(moves: List[str]) -> Tuple[int, int]: Returns the final coordinates after performing all the moves. Parameters: moves (list of str): List of moves where each move is \\"UP\\", \\"DOWN\\", \\"LEFT\\", or \\"RIGHT\\". Returns: tuple: Final coordinates (x, y) on the 2D grid. >>> final_coordinates([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\"]) (0, 1) >>> final_coordinates([\\"RIGHT\\", \\"RIGHT\\", \\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\"]) (1, 1) >>> final_coordinates([\\"LEFT\\"]) (-1, 0)","solution":"def final_coordinates(moves): Returns the final coordinates after performing all the moves. Parameters: moves (list of str): List of moves where each move is \\"UP\\", \\"DOWN\\", \\"LEFT\\", or \\"RIGHT\\". Returns: tuple: Final coordinates (x, y) on the 2D grid. x, y = 0, 0 for move in moves: if move == \\"UP\\": y += 1 elif move == \\"DOWN\\": y -= 1 elif move == \\"LEFT\\": x -= 1 elif move == \\"RIGHT\\": x += 1 return x, y"},{"question":"def three_sum_closest(nums: List[int], target: int) -> int: Determine if there are three integers in nums such that the sum is closest to the target. Return the sum of the three integers. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 1, 1, 0], 100) 3 >>> three_sum_closest([0, 2, 1, -3], 1) 0 >>> three_sum_closest([1, 2, 3, 4], 6) 6 >>> three_sum_closest([1, 1, -1, -1, 3], -1) -1 >>> three_sum_closest([5, 1, 3, 6, 7], 9) 9","solution":"def three_sum_closest(nums, target): nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"def minimum_distance_to_complete_journey(N, S, D, distances): Determines the minimum distance Alex will travel to complete his journey and return to place S, or return -1 if it is not possible within the given constraints. :param N: Number of places. :param S: Starting place (1-based index). :param D: Distance threshold. :param distances: List of distances between consecutive places in the cycle :return: Minimum distance traveled to complete the journey or -1 if not possible. pass # Tests def test_sample_input_1(): assert minimum_distance_to_complete_journey(5, 3, 15, [1, 2, 3, 4, 5]) == 15 def test_sample_input_2(): assert minimum_distance_to_complete_journey(4, 1, 3, [5, 6, 2, 3]) == -1 def test_all_distances_within_threshold(): assert minimum_distance_to_complete_journey(6, 2, 100, [10, 20, 30, 15, 25, 40]) == 140 def test_first_distance_exceeds_threshold(): assert minimum_distance_to_complete_journey(3, 2, 2, [3, 4, 5]) == -1 def test_large_number_of_places(): N = 10**5 distances = [i % 100 + 1 for i in range(N)] assert minimum_distance_to_complete_journey(N, 1, 100, distances) == sum(distances) def test_single_distance_exceeds_threshold_midway(): assert minimum_distance_to_complete_journey(5, 1, 10, [1, 2, 3, 11, 12]) == -1","solution":"def minimum_distance_to_complete_journey(N, S, D, distances): Determines the minimum distance Alex will travel to complete his journey and return to place S, or return -1 if it is not possible within the given constraints. :param N: Number of places. :param S: Starting place (1-based index). :param D: Distance threshold. :param distances: List of distances between consecutive places in the cycle :return: Minimum distance traveled to complete the journey or -1 if not possible. # Convert the starting place from 1-based index to 0-based index start_index = S - 1 # Traverse the cycle in a clockwise direction starting from S total_distance = 0 for i in range(N): current_distance = distances[(start_index + i) % N] if current_distance > D: return -1 total_distance += current_distance return total_distance"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> bool: Returns True if there are two distinct numbers in the array that add up to the target sum, False otherwise. >>> has_pair_with_sum([1, 2, 3, 9], 8) == False >>> has_pair_with_sum([1, 2, 4, 4], 8) == True >>> has_pair_with_sum([2, 7, 11, 15], 9) == True >>> has_pair_with_sum([], 5) == False >>> has_pair_with_sum([5], 5) == False >>> has_pair_with_sum([1, 3, 5, 7, 9], 10) == True >>> has_pair_with_sum([-1, -3, -5, -7, -9], -10) == True >>> has_pair_with_sum([0, 0, 1, -1], 0) == True","solution":"def has_pair_with_sum(arr, target): Returns True if there are two distinct numbers in the array that add up to the target sum, False otherwise. encountered_numbers = set() for number in arr: if target - number in encountered_numbers: return True encountered_numbers.add(number) return False"},{"question":"def most_frequent_rune(n: int, runes: List[str]) -> str: Determine the most frequently occurring magical rune string. If there is a tie, return the lexicographically smallest string among those tied for the most occurrences. >>> most_frequent_rune(1, [\\"a\\"]) == \\"a\\" >>> most_frequent_rune(3, [\\"a\\", \\"b\\", \\"a\\"]) == \\"a\\" >>> most_frequent_rune(4, [\\"a\\", \\"b\\", \\"b\\", \\"a\\"]) == \\"a\\" >>> most_frequent_rune(7, [\\"abc\\", \\"xyz\\", \\"abc\\", \\"ABC\\", \\"def\\", \\"xyz\\", \\"abc\\"]) == \\"abc\\" >>> most_frequent_rune(5, [\\"a\\", \\"b\\", \\"b\\", \\"c\\", \\"c\\"]) == \\"b\\" >>> most_frequent_rune(3, [\\"a\\", \\"A\\", \\"a\\"]) == \\"a\\" >>> most_frequent_rune(5, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) == \\"a\\"","solution":"def most_frequent_rune(n, runes): from collections import Counter rune_count = Counter(runes) max_frequency = max(rune_count.values()) candidates = [rune for rune, count in rune_count.items() if count == max_frequency] return min(candidates)"},{"question":"def dominant_index(nums: List[int]) -> int: Given a non-empty list of unique integers, return the index of the first integer which is larger than all previously seen integers. If there are no such elements, return -1. >>> dominant_index([1, 2, 1, 3, 2]) 1 >>> dominant_index([10, 5, 4, 3, 2]) -1 >>> dominant_index([1, 3, 2, 4, 5]) 1","solution":"def dominant_index(nums): max_so_far = nums[0] for i in range(1, len(nums)): if nums[i] > max_so_far: return i max_so_far = max(max_so_far, nums[i]) return -1"},{"question":"from typing import List def array_intersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of two arrays. The intersection must be an array of unique elements and in ascending order. >>> array_intersection([1, 2, 2, 4, 5], [2, 3, 4]) [2, 4] >>> array_intersection([7, 8, 9], [10, 11, 12]) [] >>> array_intersection([1, 1, 1, 1], [1, 1, 1, 1, 1]) [1] pass def test_common_elements(): assert array_intersection([1, 2, 2, 4, 5], [2, 3, 4]) == [2, 4] def test_no_common_elements(): assert array_intersection([7, 8, 9], [10, 11, 12]) == [] def test_all_elements_same(): assert array_intersection([1, 1, 1, 1], [1, 1, 1, 1, 1]) == [1] def test_mixed_elements_with_duplicates(): assert array_intersection([1, 2, 3, 3, 5], [3, 3, 5, 7, 9]) == [3, 5] def test_one_array_empty(): assert array_intersection([], [1, 2, 3]) == [] assert array_intersection([1, 2, 3], []) == [] def test_with_different_length_arrays(): assert array_intersection([1, 3, 5, 7], [3, 3, 3, 3]) == [3] assert array_intersection([4, 6, 8, 10, 12], [8, 14, 8, 10]) == [8, 10]","solution":"def array_intersection(arr1, arr2): Returns the intersection of two arrays. The intersection must be an array of unique elements and in ascending order. # Convert both arrays to sets to keep only unique elements and intersect them. intersection = set(arr1).intersection(set(arr2)) # Return the sorted list of the intersection set. return sorted(list(intersection))"},{"question":"def find_smallest_missing_positive(arr): Find the smallest positive integer that is missing from the list. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([-1, -2, -3]) 1 >>> find_smallest_missing_positive([1, 2, 3]) 4 >>> find_smallest_missing_positive([1, 1, 2, 2]) 3 >>> find_smallest_missing_positive([]) 1 >>> find_smallest_missing_positive([4, 3, 2, 1]) 5 >>> find_smallest_missing_positive([1, 2, 2, -1, -3]) 3 >>> find_smallest_missing_positive(list(range(1, 1000))) 1000","solution":"def find_smallest_missing_positive(arr): Returns the smallest positive integer that is missing from the list. n = len(arr) # First move all positive numbers to the correct position for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Then, find the first place where the number is not in the right position for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def sort_books(books: List[str]) -> List[str]: Sorts a list of books by their titles while retaining the unique identifier and maintaining the original order of identical titles. Args: books (List[str]): A list of strings where each string represents a book title and its unique identifier separated by a comma. Returns: List[str]: The list of books sorted by title. Examples: >>> sort_books([ ... \\"The Great Gatsby,3416\\", ... \\"To Kill a Mockingbird,5842\\", ... \\"1984,1234\\", ... \\"The Catcher in the Rye,2234\\", ... \\"The Odyssey,9876\\" ... ]) ['1984,1234', 'The Catcher in the Rye,2234', 'The Great Gatsby,3416', 'The Odyssey,9876', 'To Kill a Mockingbird,5842'] >>> sort_books([\\"The Great Gatsby,3416\\"]) ['The Great Gatsby,3416'] >>> sort_books([\\"The Great Gatsby,3416\\", \\"The Great Gatsby,5842\\", \\"1984,1234\\"]) ['1984,1234', 'The Great Gatsby,3416', 'The Great Gatsby,5842']","solution":"from typing import List def sort_books(books: List[str]) -> List[str]: Sorts a list of books by their titles while retaining the unique identifier and maintaining the original order of identical titles. Args: books (List[str]): A list of strings where each string represents a book title and its unique identifier separated by a comma. Returns: List[str]: The list of books sorted by title. return sorted(books, key=lambda x: x.split(',')[0])"},{"question":"from typing import List from collections import deque class AnimalGathering: @staticmethod def MinimumMoves(forestMap: List[List[int]], startPositions: List[int], targetLocation: int) -> int: Calculate the minimum number of moves required for all animals to gather at the target location. Args: forestMap (List[List[int]]): Adjacency matrix representing the forest map. startPositions (List[int]): Starting positions of the animals. targetLocation (int): Desired target location. Returns: int: Minimum number of moves required, or -1 if it's impossible for all animals to gather at the target location. Examples: >>> forestMap = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] >>> startPositions = [0, 2, 3] >>> targetLocation = 1 >>> AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) 1 pass def test_minimum_moves(): forestMap = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] startPositions = [0, 2, 3] targetLocation = 1 assert AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) == 1 def test_no_path_case(): forestMap = [ [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0] ] startPositions = [0, 2, 3] targetLocation = 1 assert AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) == -1 def test_all_animals_already_at_target(): forestMap = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] startPositions = [1, 1, 1] targetLocation = 1 assert AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) == 0 def test_single_animal_case(): forestMap = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] startPositions = [0] targetLocation = 1 assert AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) == 1 def test_large_grid_case(): forestMap = [[0]*5 for _ in range(5)] for i in range(4): forestMap[i][i+1] = 1 forestMap[i+1][i] = 1 startPositions = [0, 2, 4] targetLocation = 4 assert AnimalGathering.MinimumMoves(forestMap, startPositions, targetLocation) == 4","solution":"from collections import deque class AnimalGathering: @staticmethod def MinimumMoves(forestMap, startPositions, targetLocation): def bfs(start, target, forestMap): N = len(forestMap) visited = [False] * N queue = deque([(start, 0)]) visited[start] = True while queue: current, moves = queue.popleft() if current == target: return moves for neighbor in range(N): if forestMap[current][neighbor] == 1 and not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, moves + 1)) return -1 max_moves = 0 for start in startPositions: moves = bfs(start, targetLocation, forestMap) if moves == -1: return -1 max_moves = max(max_moves, moves) return max_moves"},{"question":"def check_recipes_unique_and_allergen_free(chefs: int, allergens: List[str], recipes: List[Tuple[int, ...]]) -> str: Determines if it is possible to assign non-allergic unique ingredient sets to each chef. >>> check_recipes_unique_and_allergen_free(4, [\\"peanut\\", \\"shellfish\\"], [(3, \\"tomato\\", \\"cheese\\", \\"basil\\"), (3, \\"lettuce\\", \\"bacon\\", \\"egg\\"), (2, \\"tomato\\", \\"bacon\\"), (4, \\"bacon\\", \\"egg\\", \\"cheese\\", \\"mushroom\\")]) \\"Possible\\" >>> check_recipes_unique_and_allergen_free(4, [\\"peanut\\", \\"shellfish\\"], [(3, \\"tomato\\", \\"cheese\\", \\"peanut\\"), (3, \\"lettuce\\", \\"bacon\\", \\"egg\\"), (2, \\"tomato\\", \\"bacon\\"), (4, \\"bacon\\", \\"egg\\", \\"cheese\\", \\"mushroom\\")]) \\"Impossible\\" >>> check_recipes_unique_and_allergen_free(4, [\\"peanut\\", \\"shellfish\\"], [(3, \\"tomato\\", \\"cheese\\", \\"basil\\"), (3, \\"tomato\\", \\"cheese\\", \\"basil\\"), (2, \\"tomato\\", \\"bacon\\"), (4, \\"bacon\\", \\"egg\\", \\"cheese\\", \\"mushroom\\")]) \\"Impossible\\" >>> check_recipes_unique_and_allergen_free(3, [], [(3, \\"tomato\\", \\"cheese\\", \\"basil\\"), (3, \\"lettuce\\", \\"bacon\\", \\"egg\\"), (2, \\"tomato\\", \\"bacon\\")]) \\"Possible\\" >>> check_recipes_unique_and_allergen_free(3, [\\"peanut\\"], [(0, ), (3, \\"lettuce\\", \\"bacon\\", \\"egg\\"), (2, \\"tomato\\", \\"bacon\\")]) \\"Possible\\"","solution":"def check_recipes_unique_and_allergen_free(chefs, allergens, recipes): allergen_set = set(allergens) recipe_sets = [] for recipe in recipes: P, ingredients = recipe[0], recipe[1:] ingredient_set = set(ingredients) # Check if any allergen is present in the recipe if not ingredient_set.isdisjoint(allergen_set): return \\"Impossible\\" # Check for uniqueness of ingredient sets if ingredient_set in recipe_sets: return \\"Impossible\\" recipe_sets.append(ingredient_set) return \\"Possible\\""},{"question":"def four_sum_count(arr, target): Finds the number of unique quadruplets in the array that sum to the target. Arguments: arr -- list of integers target -- integer, the target sum Returns: count -- integer, the number of unique quadruplets Examples: >>> four_sum_count([1, 0, -1, 0, -2, 2], 0) 3 >>> four_sum_count([0, 1, 2, 3], 10) 0 >>> four_sum_count([1, 1, 1, 1, 1, 1], 4) 1 >>> four_sum_count([-3, -2, -1, 0, 0, 1, 2, 3], 0) 8 >>> four_sum_count([1, 1, 1, 1, 1, 1, 1, 1], 4) 1","solution":"def four_sum_count(arr, target): Finds the number of unique quadruplets in the array that sum to the target. arr.sort() n = len(arr) quadruplets = set() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: quad_sum = arr[i] + arr[j] + arr[left] + arr[right] if quad_sum == target: quadruplets.add((arr[i], arr[j], arr[left], arr[right])) left += 1 right -= 1 elif quad_sum < target: left += 1 else: right -= 1 return len(quadruplets)"},{"question":"def capitalize_words(s: str) -> str: Capitalizes the first and last character of each word in the string, making all other characters lowercase. Args: s (str): The input string. Returns: str: The processed string with each word's first and last character capitalized. Example: >>> capitalize_words(\\"capitalize each word\\") \\"CapitalizE EacH WorD\\" >>> capitalize_words(\\"HELLO world FROM python\\") \\"HellO WorlD FroM PythoN\\"","solution":"def capitalize_words(s): Capitalizes the first and last character of each word in the string, making all other characters lowercase. Args: s (str): The input string. Returns: str: The processed string with each word's first and last character capitalized. words = s.split() result = [] for word in words: if len(word) > 1: capitalized_word = word[0].upper() + word[1:-1].lower() + word[-1].upper() else: capitalized_word = word.upper() result.append(capitalized_word) return ' '.join(result)"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds all unique pairs in \`nums\` that sum up to \`target\`. Each returned pair is in the format (a, b) where a <= b. Args: nums (List[int]): The list of integers. target (int): The target sum. Returns: List[Tuple[int, int]]: A list of unique pairs that sum up to the target. Examples: >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([-1, 0, 1, 2, -1, -4], 0) [(-1, 1)] >>> find_pairs([1, 2, 3, 4, 5], 10) [] >>> find_pairs([], 10) [] >>> find_pairs([2, 4, 6, 8, 10], 12) [(2, 10), (4, 8)]","solution":"def find_pairs(nums, target): Finds all unique pairs in \`nums\` that sum up to \`target\`. Each returned pair is in the format (a, b) where a <= b. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"import math def calculate_squares(a: int, b: int) -> int: Create a function \`calculate_squares\` that takes two integers \`a\` and \`b\` as inputs and returns the number of perfect squares between \`a\` and \`b\` inclusive. A perfect square is an integer that is the square of another integer. >>> calculate_squares(1, 25) # Perfect squares: 1, 4, 9, 16, 25 5 >>> calculate_squares(27, 35) # No perfect squares between 27 and 35 0 >>> calculate_squares(16, 16) # Only 16 is a perfect square 1 >>> calculate_squares(10, 1) # Invalid range (a > b) 0 >>> calculate_squares(4, 9) # Perfect squares: 4, 9 2 >>> calculate_squares(1, 100) # Perfect squares: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 10","solution":"import math def calculate_squares(a, b): Returns the number of perfect squares between a and b inclusive. if a > b: return 0 start = math.ceil(math.sqrt(a)) end = math.floor(math.sqrt(b)) if start > end: return 0 return end - start + 1"},{"question":"def simple_calculator(expression: str) -> Union[int, float, str]: Takes in a string representing a basic mathematical expression with two operands and one operator, and returns the result of the expression. >>> simple_calculator(\\"5 + 3\\") 8 >>> simple_calculator(\\"10 - 2\\") 8 >>> simple_calculator(\\"4 * 2\\") 8 >>> simple_calculator(\\"16 / 2\\") 8.0 >>> simple_calculator(\\"16 / 0\\") \\"Error: Division by zero\\" >>> simple_calculator(\\"5 / 2\\") 2.5 >>> simple_calculator(\\"1000000 * 1000000\\") 1000000000000 >>> simple_calculator(\\"-4 + 2\\") -2 >>> simple_calculator(\\"-4 - 2\\") -6 >>> simple_calculator(\\"5 - 10\\") -5 >>> simple_calculator(\\"-5 + 10\\") 5 >>> simple_calculator(\\"5 ^ 2\\") \\"Error: Unsupported operator\\"","solution":"def simple_calculator(expression): Takes in a string representing a basic mathematical expression with two operands and one operator, and returns the result of the expression. # Split the expression into operand1, operator, and operand2 operand1, operator, operand2 = expression.split() # Convert operands to integers operand1 = int(operand1) operand2 = int(operand2) if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': if operand2 == 0: return \\"Error: Division by zero\\" else: return operand1 / operand2 else: return \\"Error: Unsupported operator\\""},{"question":"def rearrange(s: str) -> str: Rearranges the input string such that all the digits come before all the letters. The relative order of the digits and the letters is preserved. Parameters: s (str): The input string consisting of digits and lowercase letters. Returns: str: The rearranged string with all digits followed by all letters. Examples: >>> rearrange(\\"a1b2c3\\") \\"123abc\\" >>> rearrange(\\"3z4y5x\\") \\"345zyx\\" >>> rearrange(\\"h1e2l3l4o5\\") \\"12345hello\\"","solution":"def rearrange(s): Rearranges the input string such that all the digits come before all the letters. The relative order of the digits and the letters is preserved. Parameters: s (str): The input string consisting of digits and lowercase letters. Returns: str: The rearranged string with all digits followed by all letters. digits = [] letters = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(digits + letters)"},{"question":"from typing import List def process_matrix_operations(matrix: List[List[int]], operations: List[str]) -> List[List[int]]: Perform a series of operations on a matrix of integers and return the final matrix. An operation can be one of the following: 1. Addition: Takes the form \\"add k\\" where \\"add\\" is a string and \\"k\\" is an integer. This operation adds \\"k\\" to every element. 2. Multiplication: Takes the form \\"mult k\\" where \\"mult\\" is a string and \\"k\\" is an integer. This operation multiplies every element by \\"k\\". 3. Transpose: Takes the form \\"transpose\\". This operation transposes the matrix, converting rows into columns and vice-versa. Args: matrix (List[List[int]]): The initial state of the matrix. operations (List[str]): A list of operations to be performed on the matrix. Returns: List[List[int]]: The final state of the matrix after all operations. Examples: >>> process_matrix_operations([[1, 2, 3], [4, 5, 6]], [\\"add 1\\"]) [[2, 3, 4], [5, 6, 7]] >>> process_matrix_operations([[1, 2, 3], [4, 5, 6]], [\\"mult 2\\"]) [[2, 4, 6], [8, 10, 12]] >>> process_matrix_operations([[1, 2, 3], [4, 5, 6]], [\\"transpose\\"]) [[1, 4], [2, 5], [3, 6]] >>> process_matrix_operations([[1, 2, 3], [4, 5, 6]], [\\"add 1\\", \\"mult 2\\", \\"transpose\\"]) [[4, 10], [6, 12], [8, 14]] >>> process_matrix_operations([[1, 2, 3], [4, 5, 6]], []) [[1, 2, 3], [4, 5, 6]]","solution":"from typing import List def process_matrix_operations(matrix: List[List[int]], operations: List[str]) -> List[List[int]]: for operation in operations: if operation.startswith(\\"add\\"): _, k = operation.split() k = int(k) # Perform addition on each element matrix = [[element + k for element in row] for row in matrix] elif operation.startswith(\\"mult\\"): _, k = operation.split() k = int(k) # Perform multiplication on each element matrix = [[element * k for element in row] for row in matrix] elif operation == \\"transpose\\": # Perform transposition of the matrix matrix = [list(row) for row in zip(*matrix)] return matrix"},{"question":"def nested_sum(lst): Returns the total sum of all integers in the list and any nested lists. >>> nested_sum([1, 2, 3, 4, 5]) == 15 >>> nested_sum([1, [2, 3], 4, 5]) == 15 >>> nested_sum([1, [2, [3, 4], 5], 6]) == 21 >>> nested_sum([1]) == 1 >>> nested_sum([[1]]) == 1 >>> nested_sum([[[1]]]) == 1 >>> nested_sum([1000, [2000, [3000, 4000], 5000], 6000]) == 21000 >>> nested_sum([]) == 0 >>> nested_sum([[]]) == 0 >>> nested_sum([[[[]]]]) == 0","solution":"def nested_sum(lst): Returns the total sum of all integers in the list and any nested lists. total = 0 for element in lst: if isinstance(element, list): total += nested_sum(element) else: total += element return total"},{"question":"class PlateauGrid: def __init__(self, heights): Initializes the PlateauGrid object with the given heights of the plateau grid. Args: heights (List[List[int]]): 2D list representing the heights of the plateau grid. pass def rainDropPath(self, r, c): Returns the path of the rain drop starting from cell (r, c). The path is a list of cells in the order visited by the rain drop. Args: r (int): Row index of the starting cell. c (int): Column index of the starting cell. Returns: List[List[int]]: List of cells in the order visited by the rain drop. Examples: >>> plateau = PlateauGrid([[5, 3, 4, 6], [7, 1, 2, 3], [8, 6, 4, 7]]) >>> plateau.rainDropPath(0, 0) [[0, 0], [0, 1], [1, 1]] >>> plateau = PlateauGrid([[5, 3, 4, 6], [7, 1, 2, 3], [8, 6, 4, 7]]) >>> plateau.rainDropPath(2, 3) [[2, 3], [1, 3], [1, 2], [1, 1]] >>> plateau = PlateauGrid([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) >>> plateau.rainDropPath(0, 0) [[0, 0]] >>> plateau = PlateauGrid([[42]]) >>> plateau.rainDropPath(0, 0) [[0, 0]] pass","solution":"class PlateauGrid: def __init__(self, heights): self.heights = heights self.rows = len(heights) self.cols = len(heights[0]) def rainDropPath(self, r, c): path = [] current_height = self.heights[r][c] path.append([r, c]) while True: next_r, next_c = -1, -1 for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_r, new_c = r + dr, c + dc if 0 <= new_r < self.rows and 0 <= new_c < self.cols and self.heights[new_r][new_c] < current_height: current_height = self.heights[new_r][new_c] next_r, next_c = new_r, new_c if next_r == -1 and next_c == -1: break r, c = next_r, next_c path.append([r, c]) return path"},{"question":"def add_to_inventory(inventory, items): Adds items to the inventory. Updates the quantities of items. >>> inventory = {'apple': 2, 'banana': 3} >>> add_to_inventory(inventory, ['apple', 'orange', 'banana', 'banana']) >>> inventory {'apple': 3, 'banana': 5, 'orange': 1} # Your code here def remove_from_inventory(inventory, item, quantity): Removes a specified quantity of an item from the inventory. >>> inventory = {'apple': 3, 'banana': 5, 'orange': 1} >>> remove_from_inventory(inventory, 'banana', 2) True >>> inventory {'apple': 3, 'banana': 3, 'orange': 1} >>> remove_from_inventory(inventory, 'orange', 2) False >>> inventory {'apple': 3, 'banana': 3, 'orange': 1} # Your code here","solution":"def add_to_inventory(inventory, items): Adds items to the inventory. Updates the quantities of items. :param inventory: dictionary with current inventory where keys are item names and values are quantities :param items: list of items to be added to the inventory for item in items: if item in inventory: inventory[item] += 1 else: inventory[item] = 1 def remove_from_inventory(inventory, item, quantity): Removes a specified quantity of an item from the inventory. :param inventory: dictionary with current inventory where keys are item names and values are quantities :param item: the name of the item to be removed :param quantity: the quantity to remove from the inventory :return: True if the quantity was successfully removed, else False if item in inventory and inventory[item] >= quantity: inventory[item] -= quantity if inventory[item] == 0: del inventory[item] return True return False"},{"question":"from datetime import datetime def days_since_start_of_year(date_str: str) -> int: Returns the number of days that passed since the beginning of the year until the given date. If the input date is invalid, returns None. Args: date_str (str): a string representing the date in \\"YYYY-MM-DD\\" format Returns: int: The number of days since the start of the year, or None if the date is invalid. Examples: >>> days_since_start_of_year(\\"2023-03-15\\") 74 >>> days_since_start_of_year(\\"2021-12-31\\") 365 >>> days_since_start_of_year(\\"2020-02-29\\") 60 >>> days_since_start_of_year(\\"2021-02-29\\") None pass def test_valid_dates(): assert days_since_start_of_year(\\"2023-03-15\\") == 74 assert days_since_start_of_year(\\"2021-12-31\\") == 365 assert days_since_start_of_year(\\"2020-02-29\\") == 60 assert days_since_start_of_year(\\"2023-01-01\\") == 1 def test_invalid_dates(): assert days_since_start_of_year(\\"2021-02-29\\") == None assert days_since_start_of_year(\\"2023-15-03\\") == None assert days_since_start_of_year(\\"2023-03-32\\") == None assert days_since_start_of_year(\\"2021-04-31\\") == None assert days_since_start_of_year(\\"invalid_date\\") == None def test_leap_year(): assert days_since_start_of_year(\\"2020-12-31\\") == 366 # 2020 is a leap year def test_non_leap_year(): assert days_since_start_of_year(\\"2021-12-31\\") == 365 # 2021 is not a leap year","solution":"from datetime import datetime def days_since_start_of_year(date_str): Returns the number of days that passed since the beginning of the year until the given date. Arguments: - date_str: a string representing the date in \\"YYYY-MM-DD\\" format Returns: - The number of days since the start of the year, or None if the date is invalid. try: date = datetime.strptime(date_str, '%Y-%m-%d') start_of_year = datetime(date.year, 1, 1) delta = date - start_of_year return delta.days + 1 except ValueError: return None"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the sum of the largest contiguous subarray. :param arr: List[int] - A list of integers. :return: int - The sum of the largest contiguous subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-3, 1, -8, 12, -3, 10, -8, 1]) 19","solution":"def max_subarray_sum(arr): Returns the sum of the largest contiguous subarray. :param arr: List[int] - A list of integers. :return: int - The sum of the largest contiguous subarray. max_sum = float('-inf') current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, and / with no parentheses. >>> evaluate_expression(\\"3+2\\") 5 >>> evaluate_expression(\\"7-5\\") 2 >>> evaluate_expression(\\"3*2\\") 6 >>> evaluate_expression(\\"8/4\\") 2 >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"3+5-2\\") 6 >>> evaluate_expression(\\"100/25+6\\") 10 >>> evaluate_expression(\\" 3 + 2 * 2 \\") 7 >>> evaluate_expression(\\"0\\") 0 >>> evaluate_expression(\\"10+0\\") 10","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing +, -, *, and / with no parentheses. # Helper function to apply an operator to two numbers def apply_op(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b # Use floor division # Variables to store numbers and operations nums = [] ops = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 nums.append(num) elif expression[i] in \\"+-*/\\": while (ops and ops[-1] in \\"*/\\" and expression[i] in \\"+-\\") or (ops and ops[-1] in \\"*/\\" and expression[i] in \\"*/\\"): num2 = nums.pop() num1 = nums.pop() op = ops.pop() nums.append(apply_op(num1, num2, op)) ops.append(expression[i]) i += 1 else: i += 1 while ops: num2 = nums.pop() num1 = nums.pop() op = ops.pop() nums.append(apply_op(num1, num2, op)) return nums[0]"},{"question":"def minDistance(nums: List[int], k: int) -> int: You are given a list of integers \`nums\` representing the positions of houses along a straight road. A certain number of \`k\` mailboxes can be installed along the road, and each mailbox can serve any house. The goal is to minimize the total travel distance for all houses to their respective nearest mailbox. >>> minDistance([1, 4, 8, 10, 20], 3) 5 >>> minDistance([2, 3, 5, 12, 18], 2) 9 >>> minDistance([1], 1) 0 >>> minDistance([10, 10, 10, 10], 2) 0 >>> minDistance([1, 2, 3, 4, 5], 5) 0 >>> minDistance([1, 100], 1) 99","solution":"def minDistance(nums, k): nums.sort() n = len(nums) dp = [[float('inf')] * (n + 1) for _ in range(k + 1)] dp[0][0] = 0 for i in range(1, k + 1): for j in range(i, n + 1): for t in range(i - 1, j): median_pos = (t + j) // 2 median = nums[median_pos] distance = sum(abs(nums[l] - median) for l in range(t, j)) dp[i][j] = min(dp[i][j], dp[i - 1][t] + distance) return dp[k][n]"},{"question":"from typing import List, Tuple def count_non_decreasing_subarrays(arr: List[int]) -> int: This function returns the number of non-decreasing subarrays in the given array. >>> count_non_decreasing_subarrays([1, 2, 3]) 6 >>> count_non_decreasing_subarrays([4, 3, 2, 1]) 4 >>> count_non_decreasing_subarrays([1, 1, 1, 1]) 10 >>> count_non_decreasing_subarrays([1, 2, 1, 2]) 6 >>> count_non_decreasing_subarrays([5]) 1 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases and returns the results. >>> process_test_cases([(3, [1, 2, 3]), (4, [4, 3, 2, 1])]) [6, 4] >>> process_test_cases([(1, [1])]) [1] >>> process_test_cases([(5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1])]) [15, 5] >>> process_test_cases([(3, [1, 1, 1]), (4, [2, 2, 2, 2]), (3, [3, 2, 1])]) [6, 10, 3]","solution":"def count_non_decreasing_subarrays(arr): This function returns the number of non-decreasing subarrays in the given array. n = len(arr) count = 0 length = 1 for i in range(1, n): if arr[i] >= arr[i-1]: length += 1 else: count += (length * (length + 1)) // 2 length = 1 count += (length * (length + 1)) // 2 return count def process_test_cases(test_cases): This function processes multiple test cases and returns the results. results = [] for case in test_cases: n, arr = case results.append(count_non_decreasing_subarrays(arr)) return results"},{"question":"def atm_withdrawal(balance: int, amount: int, prefers_large: bool) -> tuple: Simulates an ATM withdrawal process. Parameters: balance (int): Current account balance. amount (int): Amount the user wishes to withdraw. prefers_large (bool): Preference for large denominations (True) or small denominations (False). Returns: tuple: (boolean indicating whether withdrawal is possible, dict of denominations given out) >>> atm_withdrawal(135, 70, True) (True, {50: 1, 20: 1}) >>> atm_withdrawal(135, 73, False) (True, {10: 7, 1: 3}) >>> atm_withdrawal(50, 75, True) (False, {}) # Your solution here","solution":"def atm_withdrawal(balance, amount, prefers_large): Simulates an ATM withdrawal process. Parameters: balance (int): Current account balance. amount (int): Amount the user wishes to withdraw. prefers_large (bool): Preference for large denominations (True) or small denominations (False). Returns: tuple: (boolean indicating whether withdrawal is possible, dict of denominations given out) if amount > balance: return False, {} large_denominations = [50, 20] small_denominations = [10, 5, 1] if prefers_large: denominations = large_denominations else: denominations = small_denominations withdrawal = {} remaining_amount = amount for denom in denominations: if remaining_amount >= denom: count = remaining_amount // denom withdrawal[denom] = count remaining_amount -= denom * count if remaining_amount == 0: return True, withdrawal else: return False, {}"},{"question":"def longest_sequence_length(n: int, S: int) -> int: Find the length of the longest sequence of consecutive integers from the set {1, 2, ..., n} such that the sum of the sequence is S. >>> longest_sequence_length(10, 15) == 5 >>> longest_sequence_length(10, 55) == 10 >>> longest_sequence_length(10, 5) == 2 >>> longest_sequence_length(10, 50) == 0 pass def test_longest_sequence_length_example_1(): assert longest_sequence_length(10, 15) == 5 def test_longest_sequence_length_example_2(): assert longest_sequence_length(10, 55) == 10 def test_longest_sequence_length_example_3(): assert longest_sequence_length(10, 5) == 2 def test_longest_sequence_length_example_4(): assert longest_sequence_length(10, 50) == 0 def test_longest_sequence_length_edge_case_1(): assert longest_sequence_length(1, 1) == 1 def test_longest_sequence_length_edge_case_2(): assert longest_sequence_length(10, 1) == 1 def test_longest_sequence_length_large_value(): assert longest_sequence_length(1000000, 500000500000) == 1000000","solution":"def longest_sequence_length(n, S): Find the length of the longest sequence of consecutive integers from the set {1, 2, ..., n} that sums up to S. # Use the sum of arithmetic progression to find the length for length in range(n, 0, -1): total_sum = (length * (length + 1)) // 2 if total_sum > S: continue if (S - total_sum) % length == 0 and (S - total_sum) // length < n: start = (S - total_sum) // length + 1 if start > 0 and (start + length - 1) <= n: return length return 0"},{"question":"from typing import List def daily_temperatures(T: List[int]) -> List[int]: Calculate the number of days to wait until a warmer temperature. :param T: List of daily temperatures :return: List of days to wait for a warmer temperature >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 60, 90]) [1, 1, 0] >>> daily_temperatures([50, 50, 50, 50]) [0, 0, 0, 0] >>> daily_temperatures([60, 50, 40, 30]) [0, 0, 0, 0] >>> daily_temperatures([]) [] >>> daily_temperatures([70]) [0] >>> daily_temperatures([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) [1, 1, 1, 1, 1, 1, 1, 1, 1, 0]","solution":"def daily_temperatures(T): Calculate the number of days to wait until a warmer temperature. :param T: List of daily temperatures :return: List of days to wait for a warmer temperature result = [0] * len(T) stack = [] for i, temp in enumerate(T): while stack and T[stack[-1]] < temp: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"def count_pairs_with_sum(arr: List[int], target_sum: int) -> int: Returns the count of all pairs of unique integers in the array that add up to the target sum. The function has a linear runtime complexity. >>> count_pairs_with_sum([1, 2, 3, 4, 5], 7) 2 >>> count_pairs_with_sum([1, -1, 2, -2, 3], 1) 3","solution":"def count_pairs_with_sum(arr, target_sum): Returns the count of all pairs of unique integers in the array that add up to the target sum. seen = set() pair_count = 0 for num in arr: complement = target_sum - num if complement in seen: pair_count += 1 seen.add(num) return pair_count"},{"question":"def isIsogram(string: str) -> bool: Determines if the provided string is an isogram. An isogram is a word or phrase without a repeating letter, irrespective of case. This function ignores spaces and hyphens. Args: string (str): The string to be checked. Returns: bool: True if the string is an isogram, False otherwise. Examples: >>> isIsogram(\\"Dermatoglyphics\\") True >>> isIsogram(\\"aba\\") False >>> isIsogram(\\"moOse\\") False >>> isIsogram(\\"thumb-screws\\") False >>> isIsogram(\\"six-year-old\\") True","solution":"def isIsogram(string): Determines if the provided string is an isogram. Parameters: string (str): The string to be checked. Returns: bool: True if the string is an isogram, False otherwise. cleaned_string = string.lower().replace(\\" \\", \\"\\").replace(\\"-\\", \\"\\") return len(cleaned_string) == len(set(cleaned_string))"},{"question":"def min_minutes_to_collect_fruits(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the minimum number of minutes required to collect exactly K magical fruits from the trees. Each tree produces a certain number of fruits per minute. We need to find out the minimum time to collect the exact number of fruits required. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List containing the details for each test case. Returns: List[int]: List containing minimum number of minutes required for each test case. >>> min_minutes_to_collect_fruits(2, [(3, 10, [2, 3, 5]), (2, 7, [4, 1])]) [1, 2] >>> min_minutes_to_collect_fruits(1, [(1, 10, [2])]) [5] def test_basic_cases(): assert min_minutes_to_collect_fruits(2, [ (3, 10, [2, 3, 5]), (2, 7, [4, 1]) ]) == [1, 2] def test_single_tree(): assert min_minutes_to_collect_fruits(1, [ (1, 10, [2]) ]) == [5] def test_large_k(): assert min_minutes_to_collect_fruits(1, [ (2, 1000000, [1000, 1000]) ]) == [500] def test_multiple_trees(): assert min_minutes_to_collect_fruits(1, [ (3, 30, [2, 4, 6]) ]) == [3] def test_edge_case_min_fruits(): assert min_minutes_to_collect_fruits(1, [ (3, 1, [1, 1, 1]) ]) == [1] def test_edge_case_one_minute(): assert min_minutes_to_collect_fruits(1, [ (3, 6, [1, 2, 3]) ]) == [1]","solution":"def min_minutes_to_collect_fruits(T, test_cases): results = [] for case in test_cases: N, K, fruits_per_minute = case max_fruits_per_minute = sum(fruits_per_minute) # Maximum fruits that can be collected in 1 minute # If max possible collection per minute is greater than or equal to K, only 1 minute needed if K <= max_fruits_per_minute: results.append(1) continue # Binary search to find the minimum minutes left, right = 1, K // min(fruits_per_minute) + 1 # Right bound can be optimistically reduced while left < right: mid = (left + right) // 2 total_fruits = sum(f * mid for f in fruits_per_minute) if total_fruits >= K: right = mid else: left = mid + 1 results.append(left) return results"},{"question":"def fibonacci_pattern(m: int, n: int) -> List[List[int]]: Generates a two-dimensional array (matrix) where each number is a part of the Fibonacci sequence. >>> fibonacci_pattern(3, 3) [ [0, 1, 1], [2, 3, 5], [8, 13, 21] ] >>> fibonacci_pattern(2, 4) [ [0, 1, 1, 2], [3, 5, 8, 13] ] >>> fibonacci_pattern(4, 4) [ [0, 1, 1, 2], [3, 5, 8, 13], [21, 34, 55, 89], [144, 233, 377, 610] ]","solution":"def fibonacci_pattern(m, n): Generates a two-dimensional array (matrix) where each number is a part of the Fibonacci sequence. Parameters: m (int): number of rows n (int): number of columns Returns: List[List[int]]: A 2D array filled with Fibonacci sequence numbers. # Base case for fibonacci fibonacci_sequence = [0, 1] # Generate enough fibonacci numbers to fill the m x n matrix while len(fibonacci_sequence) < m * n: fibonacci_sequence.append(fibonacci_sequence[-1] + fibonacci_sequence[-2]) # Fill the matrix matrix = [] for i in range(m): row = fibonacci_sequence[i * n : (i + 1) * n] matrix.append(row) return matrix"},{"question":"def count_non_null_elements(arr): Returns the count of non-null elements in the provided array. If the provided array is None, returns 0. >>> count_non_null_elements([1, 2, None, 4, None, 6]) 4 >>> count_non_null_elements(None) 0 >>> count_non_null_elements([1, 2, 3, 4, 5, 6]) 6 >>> count_non_null_elements([None, None, None, None]) 0 >>> count_non_null_elements([]) 0 >>> count_non_null_elements([None, \\"a\\", None, 2, 3.5]) 3","solution":"def count_non_null_elements(arr): Returns the count of non-null elements in the provided array. If the provided array is None, returns 0. if arr is None: return 0 return sum(1 for x in arr if x is not None)"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> int: Removes duplicates from sorted array in-place and returns the length of the array with unique elements. >>> remove_duplicates([1, 1, 2]) 2 >>> remove_duplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4]) 5 >>> remove_duplicates([1, 1, 1]) 1 # start the function definition here","solution":"def remove_duplicates(nums): Removes duplicates from sorted array in-place and returns the length of the array with unique elements. :param nums: List[int], a list of sorted integers :return: int, the new length of the array with unique elements if not nums: return 0 # The index of the last unique element last_unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[last_unique_index]: last_unique_index += 1 nums[last_unique_index] = nums[i] return last_unique_index + 1"},{"question":"def findCommonTuples(lst1, lst2): Takes two lists of tuples and returns a sorted list of tuples that are common between lst1 and lst2. The result is sorted in ascending order based on the string element in the tuple, and then by the integer element. >>> findCommonTuples([(\\"apple\\", 2), (\\"banana\\", 4)], [(\\"banana\\", 4), (\\"apple\\", 2)]) [(\\"apple\\", 2), (\\"banana\\", 4)] >>> findCommonTuples([(\\"apple\\", 2), (\\"banana\\", 4)], [(\\"fig\\", 3), (\\"grape\\", 2)]) []","solution":"def findCommonTuples(lst1, lst2): Takes two lists of tuples and returns a sorted list of tuples present in both lists. Tuples are sorted first by the string and then by the integer. # Convert the lists to sets to find common elements common_tuples = set(lst1).intersection(set(lst2)) # Convert the set back to a list and sort it sorted_common_tuples = sorted(common_tuples, key=lambda x: (x[0], x[1])) return sorted_common_tuples"},{"question":"from typing import List def can_split_into_three_parts_with_equal_sum(arr: List[int]) -> bool: Determine whether it is possible to split the list into three non-empty consecutive parts whose sum is the same. Example: >>> can_split_into_three_parts_with_equal_sum([1, 2, 3, 0, 3]) True >>> can_split_into_three_parts_with_equal_sum([1, 1, 1, 1, 1, 1]) True >>> can_split_into_three_parts_with_equal_sum([1, 2, 3, 4, 5, 6]) False >>> can_split_into_three_parts_with_equal_sum([2, 2, 2, 2, 2, 2]) True >>> can_split_into_three_parts_with_equal_sum([-1, 1, -1, 1, -1, 1, 2, -2]) True >>> can_split_into_three_parts_with_equal_sum([1, -1, 1]) False >>> can_split_into_three_parts_with_equal_sum([3, 3, 3]) True","solution":"def can_split_into_three_parts_with_equal_sum(arr): Returns whether it's possible to split the list into three non-empty consecutive parts with the same sum. total_sum = sum(arr) # If total_sum is not divisible by 3, we can't split into three parts with equal sum if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 parts_found = 0 # Iterate through the array to find parts with the target sum for number in arr: current_sum += number if current_sum == target_sum: parts_found += 1 current_sum = 0 # We need exactly three parts if parts_found == 3: return True return False"},{"question":"from itertools import combinations from typing import List, Any def get_all_subsets(s: List[Any], n: int) -> List[List[Any]]: Generates all possible subsets of a given set s with exactly n elements. Parameters: s (list): A list of unique elements. n (int): The size of the subsets to be generated. Returns: list: A list of lists where each inner list is a subset of s containing exactly n elements. >>> sorted(get_all_subsets([1, 2, 3], 2)) == sorted([[1, 2], [1, 3], [2, 3]]) True >>> get_all_subsets([1], 1) [[1]] >>> get_all_subsets([1], 2) [] >>> get_all_subsets([], 0) [[]] >>> get_all_subsets([], 1) [] >>> sorted(get_all_subsets(['a', 'b', 'c', 'd'], 3)) == sorted([['a', 'b', 'c'], ['a', 'b', 'd'], ['a', 'c', 'd'], ['b', 'c', 'd']]) True >>> sorted(get_all_subsets([1, 2, 3], 3)) == sorted([[1, 2, 3]]) True >>> get_all_subsets([1, 2, 3], 0) [[]]","solution":"from itertools import combinations def get_all_subsets(s, n): Generates all possible subsets of a given set s with exactly n elements. Parameters: s (list): A list of unique elements. n (int): The size of the subsets to be generated. Returns: list: A list of lists where each inner list is a subset of s containing exactly n elements. if n > len(s): return [] return [list(subset) for subset in combinations(s, n)]"},{"question":"def can_form_contiguous_subarray(arr, k): Determine if there exists a subarray of length exactly k whose elements can be rearranged to form a contiguous sequence. Parameters: arr (list): The list of integers. k (int): The required subarray length. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> can_form_contiguous_subarray([4, 3, 2, 6, 5, 7], 3) \\"YES\\" >>> can_form_contiguous_subarray([1, 3, 4, 6, 8], 4) \\"NO\\" >>> can_form_contiguous_subarray([1, 2, 3], 4) \\"NO\\" >>> can_form_contiguous_subarray([5, 5, 5, 5, 5], 2) \\"NO\\" >>> can_form_contiguous_subarray([1, 2], 2) \\"YES\\" >>> can_form_contiguous_subarray(list(range(1, 300001)), 300000) \\"YES\\" >>> can_form_contiguous_subarray([-1, -2, -3, -4, -5], 3) \\"YES\\" >>> can_form_contiguous_subarray([1, -1, 0], 3) \\"YES\\"","solution":"def can_form_contiguous_subarray(arr, k): Determine if there exists a subarray of length exactly k whose elements can be rearranged to form a contiguous sequence. Parameters: arr (list): The list of integers. k (int): The required subarray length. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". n = len(arr) for i in range(n - k + 1): subarray = arr[i:i + k] subarray_sorted = sorted(subarray) # Check if the sorted subarray forms a contiguous sequence is_contiguous = all(subarray_sorted[j] + 1 == subarray_sorted[j + 1] for j in range(k - 1)) if is_contiguous: return \\"YES\\" return \\"NO\\""},{"question":"def productOfDigits(n: int) -> int: Returns the product of the digits of the number n. If n is negative, the absolute value is used. >>> productOfDigits(123) 6 >>> productOfDigits(-456) 120 >>> productOfDigits(0) 0 >>> productOfDigits(7) 7 >>> productOfDigits(-8) 8 >>> productOfDigits(987654321) 362880 >>> productOfDigits(102030) 0 >>> productOfDigits(120305) 0","solution":"def productOfDigits(n): Returns the product of the digits of the number n. If n is negative, the absolute value is used. n = abs(n) if n == 0: return 0 product = 1 while n > 0: digit = n % 10 product *= digit n //= 10 return product"},{"question":"import heapq from typing import List, Tuple def min_travel_time(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> List[int]: Determines the minimum travel time from Island 1 to every other island. If an island is not reachable from Island 1, indicates this with a -1. Args: n (int): Number of islands. m (int): Number of bridges. bridges (List[Tuple[int, int, int]]): List of bridges where each bridge is represented as a tuple (u, v, w) representing a one-way bridge from island u to island v with a time cost of w. Returns: List[int]: List of minimum travel times from Island 1 to each of the islands 2 to N. If some island is not reachable, -1 is returned for that island. >>> min_travel_time(5, 6, [(1, 2, 2), (1, 3, 4), (2, 4, 7), (2, 5, 3), (3, 5, 1), (4, 5, 1)]) [2, 4, 9, 5] >>> min_travel_time(4, 2, [(1, 2, 4), (3, 4, 2)]) [4, -1, -1] >>> min_travel_time(3, 0, []) [-1, -1]","solution":"import heapq def min_travel_time(n, m, bridges): # Construct the graph graph = [[] for _ in range(n + 1)] for u, v, w in bridges: graph[u].append((v, w)) # Initialize the distance array INF = float('inf') distances = [INF] * (n + 1) distances[1] = 0 # Use a priority queue for Dijkstra's algorithm pq = [(0, 1)] # (cost, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > distances[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) # Prepare the result list result = [] for i in range(2, n + 1): if distances[i] == INF: result.append(-1) else: result.append(distances[i]) return result"},{"question":"def findLongestSubstring(s: str) -> int: Write a function called \`findLongestSubstring\` that takes a string and returns the length of the longest substring with all unique characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. Examples: >>> findLongestSubstring(\\"abcabcbb\\") # \\"abc\\" -> 3 >>> findLongestSubstring(\\"bbbbb\\") # \\"b\\" -> 1 >>> findLongestSubstring(\\"pwwkew\\") # \\"wke\\" -> 3 >>> findLongestSubstring(\\"\\") # \\"\\" -> 0 >>> findLongestSubstring(\\"dvdf\\") # \\"vdf\\" -> 3 def test_findLongestSubstring(): assert findLongestSubstring(\\"abcabcbb\\") == 3 # \\"abc\\" assert findLongestSubstring(\\"bbbbb\\") == 1 # \\"b\\" assert findLongestSubstring(\\"pwwkew\\") == 3 # \\"wke\\" assert findLongestSubstring(\\"\\") == 0 # \\"\\" assert findLongestSubstring(\\"dvdf\\") == 3 # \\"vdf\\" assert findLongestSubstring(\\"abccba\\") == 3 # \\"abc\\" or \\"cba\\" assert findLongestSubstring(\\"a\\") == 1 # \\"a\\" assert findLongestSubstring(\\"abcd\\") == 4 # \\"abcd\\" assert findLongestSubstring(\\"aabbccdd\\") == 2 # \\"aa\\", \\"bb\\", \\"cc\\", \\"dd\\" assert findLongestSubstring(\\"!@#%^&*()\\") == 10 # \\"!@#%^&*()\\" assert findLongestSubstring(\\"tmmzuxt\\") == 5 # \\"mzuxt\\"","solution":"def findLongestSubstring(s): Returns the length of the longest substring with all unique characters. start = 0 maxLength = 0 usedChars = {} for i, char in enumerate(s): if char in usedChars and start <= usedChars[char]: start = usedChars[char] + 1 else: maxLength = max(maxLength, i - start + 1) usedChars[char] = i return maxLength"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if a binary tree is height-balanced. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is height-balanced. def get_height(node): if not node: return 0 left_height = get_height(node.left) right_height = get_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return get_height(root) != -1"},{"question":"def max_profit(prices: List[int]) -> int: Given a list of stock prices, calculate the maximum profit that can be made with one buy and one sell transaction. :param prices: List of integers representing the stock prices :return: An integer representing the maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) # Buy on day 2 (price = 1), sell on day 5 (price = 6) 5 >>> max_profit([7, 6, 4, 3, 1]) # No profit can be made in this case 0 >>> max_profit([1, 2, 3, 4, 5]) # Buy on day 1 (price = 1), sell on day 5 (price = 5) 4 >>> max_profit([5]) # Only one price, no transaction possible 0 >>> max_profit([]) # No prices available, no transaction possible 0 # Your implementation here","solution":"def max_profit(prices): Given a list of stock prices, calculate the maximum profit that can be made with one buy and one sell transaction. :param prices: List of integers representing the stock prices :return: An integer representing the maximum profit if not prices: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the given digits can represent. >>> letter_combinations(\\"2\\") [\\"A\\", \\"B\\", \\"C\\"] >>> letter_combinations(\\"23\\") [\\"AD\\", \\"AE\\", \\"AF\\", \\"BD\\", \\"BE\\", \\"BF\\", \\"CD\\", \\"CE\\", \\"CF\\"] >>> letter_combinations(\\"79\\") [\\"PW\\", \\"PX\\", \\"PY\\", \\"PZ\\", \\"QW\\", \\"QX\\", \\"QY\\", \\"QZ\\", \\"RW\\", \\"RX\\", \\"RY\\", \\"RZ\\", \\"SW\\", \\"SX\\", \\"SY\\", \\"SZ\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"234\\") [\\"ADG\\", \\"ADH\\", \\"ADI\\", \\"AEG\\", \\"AEH\\", \\"AEI\\", \\"AFG\\", \\"AFH\\", \\"AFI\\", \\"BDG\\", \\"BDH\\", \\"BDI\\", \\"BEG\\", \\"BEH\\", \\"BEI\\", \\"BFG\\", \\"BFH\\", \\"BFI\\", \\"CDG\\", \\"CDH\\", \\"CDI\\", \\"CEG\\", \\"CEH\\", \\"CEI\\", \\"CFG\\", \\"CFH\\", \\"CFI\\"]","solution":"from itertools import product def letter_combinations(digits): Returns all possible letter combinations that the given digits can represent. if not digits: return [] # Mapping from digits to corresponding letters on a phone keypad digit_to_letters = { '2': 'ABC', '3': 'DEF', '4': 'GHI', '5': 'JKL', '6': 'MNO', '7': 'PQRS', '8': 'TUV', '9': 'WXYZ' } # Create list of letter strings corresponding to each digit in the input letter_groups = [digit_to_letters[digit] for digit in digits] # Generate all combinations using Cartesian product combinations = [''.join(combo) for combo in product(*letter_groups)] return combinations"},{"question":"def find_word_combinations(target: str, word_list: List[str]) -> int: Write a function \`find_word_combinations(target, word_list)\` which takes two arguments: a string \`target\` and a list of strings \`word_list\`. The function should return the number of unique ways to construct the \`target\` string by concatenating words from \`word_list\` (each word can be used multiple times). # Example 1: >>> find_word_combinations(\\"abcdef\\", [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"]) 1 # Example 2: >>> find_word_combinations(\\"purple\\", [\\"purp\\", \\"p\\", \\"ur\\", \\"le\\", \\"purpl\\"]) 2 # Example 3: >>> find_word_combinations(\\"enterapotentpot\\", [\\"a\\", \\"p\\", \\"ent\\", \\"enter\\", \\"ot\\", \\"o\\", \\"t\\"]) 4 The solution can be achieved using dynamic programming or recursion with memoization. # Unit Tests def test_find_word_combinations_example_1(): target = \\"abcdef\\" word_list = [\\"ab\\", \\"abc\\", \\"cd\\", \\"def\\", \\"abcd\\"] assert find_word_combinations(target, word_list) == 1 def test_find_word_combinations_example_2(): target = \\"purple\\" word_list = [\\"purp\\", \\"p\\", \\"ur\\", \\"le\\", \\"purpl\\"] assert find_word_combinations(target, word_list) == 2 def test_find_word_combinations_example_3(): target = \\"enterapotentpot\\" word_list = [\\"a\\", \\"p\\", \\"ent\\", \\"enter\\", \\"ot\\", \\"o\\", \\"t\\"] assert find_word_combinations(target, word_list) == 4 def test_find_word_combinations_empty_target(): target = \\"\\" word_list = [\\"a\\", \\"b\\", \\"c\\"] assert find_word_combinations(target, word_list) == 1 def test_find_word_combinations_no_way_to_construct(): target = \\"hello\\" word_list = [\\"cat\\", \\"dog\\", \\"mouse\\"] assert find_word_combinations(target, word_list) == 0 def test_find_word_combinations_single_word_multiple_times(): target = \\"aaaa\\" word_list = [\\"a\\", \\"aa\\"] assert find_word_combinations(target, word_list) == 5","solution":"def find_word_combinations(target, word_list): cache = {} def helper(sub_target): if sub_target in cache: return cache[sub_target] if sub_target == \\"\\": return 1 total_count = 0 for word in word_list: if sub_target.startswith(word): suffix = sub_target[len(word):] count_for_suffix = helper(suffix) total_count += count_for_suffix cache[sub_target] = total_count return total_count return helper(target)"},{"question":"def distinct_in_subarray(arr, queries): Given an array of integers arr and a list of queries, each query containing two integers l and r, returns the number of distinct integers in the subarray arr[l-1:r]. Parameters: arr (list): The array of integers. queries (list): A list of tuples, where each tuple (l, r) denotes a query for the subarray. Returns: list: A list of integers representing the number of distinct integers in each queried subarray. >>> distinct_in_subarray([1, 2, 1, 2, 3], [(1, 3), (2, 4), (1, 5)]) [2, 2, 3] >>> distinct_in_subarray([1, 2, 3, 4, 5], [(1, 5), (1, 1), (2, 2), (2, 5)]) [5, 1, 1, 4] >>> distinct_in_subarray([5, 5, 5, 5, 5], [(1, 5), (2, 4), (1, 3)]) [1, 1, 1] >>> distinct_in_subarray([], []) [] >>> distinct_in_subarray([1], [(1, 1)]) [1]","solution":"def distinct_in_subarray(arr, queries): Given an array of integers arr and a list of queries, each query containing two integers l and r, returns the number of distinct integers in the subarray arr[l-1:r]. Parameters: arr (list): The array of integers. queries (list): A list of tuples, where each tuple (l, r) denotes a query for the subarray. Returns: list: A list of integers representing the number of distinct integers in each queried subarray. result = [] for l, r in queries: subarray = arr[l-1:r] distinct_count = len(set(subarray)) result.append(distinct_count) return result"},{"question":"def analyze_string(s: str) -> list: Analyzes the given string to count the number of vowels, consonants, and unique letters. Parameters: s (str): input string consisting of lowercase letters Returns: list: [number of vowels, number of consonants, number of unique letters] Examples: >>> analyze_string(\\"hello\\") [2, 3, 4] >>> analyze_string(\\"aabbcc\\") [2, 4, 3]","solution":"def analyze_string(s): Analyzes the given string to count the number of vowels, consonants, and unique letters. Parameters: s (str): input string consisting of lowercase letters Returns: list: [number of vowels, number of consonants, number of unique letters] vowels = set('aeiou') vowel_count = 0 consonant_count = 0 unique_letters = set(s) for char in s: if char in vowels: vowel_count += 1 else: consonant_count += 1 return [vowel_count, consonant_count, len(unique_letters)]"},{"question":"def sum_square_difference(n: int) -> int: Returns the difference between the sum of the squares of the first n natural numbers and the square of their sum. >>> sum_square_difference(1) == 0 >>> sum_square_difference(2) == 4 >>> sum_square_difference(3) == 22 >>> sum_square_difference(10) == 2640 >>> sum_square_difference(100) == 25164150","solution":"def sum_square_difference(n): Returns the difference between the sum of the squares of the first n natural numbers and the square of their sum. sum_of_squares = sum(i**2 for i in range(1, n+1)) square_of_sum = sum(range(1, n+1)) ** 2 return square_of_sum - sum_of_squares"},{"question":"def count_equal_even_odd_subarrays(arr): Given an array of integers \`arr\`, returns the number of contiguous subarrays that have an equal number of even and odd numbers. >>> count_equal_even_odd_subarrays([1, 2, 3, 4]) == 4 >>> count_equal_even_odd_subarrays([1, 1, 1, 1]) == 0 >>> count_equal_even_odd_subarrays([2, 2, 2, 2]) == 0","solution":"def count_equal_even_odd_subarrays(arr): Returns the number of contiguous subarrays that have an equal number of even and odd numbers. count_map = {0: 1} count = 0 current_balance = 0 for num in arr: if num % 2 == 0: current_balance += 1 else: current_balance -= 1 if current_balance in count_map: count += count_map[current_balance] count_map[current_balance] += 1 else: count_map[current_balance] = 1 return count"},{"question":"MOD = 1000000007 def process_queries(n, q, arr, queries): Given an array of integers and a series of operations, process the following three types of queries: 1. \\"ADD x y\\": Add the integer y to each element from the x-th position to the end of the array. 2. \\"MULT x y\\": Multiply each element from the x-th position to the end of the array by the integer y. 3. \\"SUM l r\\": Compute the sum of the elements from the l-th to the r-th position, both inclusive. >>> process_queries(5, 4, [1, 2, 3, 4, 5], [\\"ADD 2 3\\", \\"MULT 3 2\\", \\"SUM 1 5\\", \\"SUM 2 4\\"]) [48, 31] >>> process_queries(3, 2, [1, 2, 3], [\\"ADD 2 1\\", \\"SUM 1 3\\"]) [8] >>> process_queries(4, 2, [1, 2, 3, 4], [\\"ADD 1 2\\", \\"SUM 1 4\\"]) [18] >>> process_queries(4, 2, [1, 2, 3, 4], [\\"MULT 1 2\\", \\"SUM 1 4\\"]) [20] >>> process_queries(2, 1, [1000000000, 1000000000], [\\"SUM 1 2\\"]) [999999993]","solution":"MOD = 1000000007 def process_queries(n, q, arr, queries): results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"ADD\\": x = int(parts[1]) - 1 y = int(parts[2]) for i in range(x, n): arr[i] = (arr[i] + y) % MOD elif command == \\"MULT\\": x = int(parts[1]) - 1 y = int(parts[2]) for i in range(x, n): arr[i] = (arr[i] * y) % MOD elif command == \\"SUM\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 sum_result = sum(arr[l:r+1]) % MOD results.append(sum_result) return results"},{"question":"from typing import List def can_split_batting_order(batting_averages: List[int]) -> bool: Determine if it's possible to split the batting_averages into two subarrays with equal sum. >>> can_split_batting_order([1, 5, 11, 5]) True >>> can_split_batting_order([1, 2, 3, 5]) False pass def test_can_split_batting_order(): assert can_split_batting_order([1, 5, 11, 5]) == True assert can_split_batting_order([1, 2, 3, 5]) == False assert can_split_batting_order([1, 1, 3, 4, 7]) == True assert can_split_batting_order([2, 2, 2, 2, 2, 2]) == True assert can_split_batting_order([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 19]) == False assert can_split_batting_order([100, 100]) == True assert can_split_batting_order([100]) == False assert can_split_batting_order([1, 2, 4, 8, 16, 32, 64, 128]) == False test_can_split_batting_order()","solution":"from typing import List def can_split_batting_order(batting_averages: List[int]) -> bool: total_sum = sum(batting_averages) # If the total sum is odd, it cannot be divided into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for avg in batting_averages: for i in range(target, avg - 1, -1): dp[i] = dp[i] or dp[i - avg] return dp[target]"},{"question":"def translate_message(message: str) -> str: Translates the alien code back into human-readable messages Arguments: message -- str, the alien-coded message Returns: str, the human-readable message Examples: >>> translate_message(\\"XYZODXY\\") 'XYKneel before Zod!XY' >>> translate_message(\\"XYZODZODXY\\") 'XYDouble Zod has come!XY' >>> translate_message(\\"ZODZODXYZOD\\") 'Double Zod has come!XYKneel before Zod!' >>> translate_message(\\"HELLOWORLD\\") 'HELLOWORLD' >>> translate_message(\\"ZODZODXYZZOD\\") 'Double Zod has come!XYZKneel before Zod!' >>> translate_message(\\"HELLOZOD\\") 'HELLOKneel before Zod!' >>> translate_message(\\"HELLOZODZOD\\") 'HELLODouble Zod has come!'","solution":"def translate_message(message): Translates the alien code back into human-readable messages Arguments: message -- str, the alien-coded message Returns: str, the human-readable message translations = { \\"ZOD\\": \\"Kneel before Zod!\\", \\"ZODZOD\\": \\"Double Zod has come!\\" } result = '' i = 0 while i < len(message): if message[i:i+6] == \\"ZODZOD\\": result += translations[\\"ZODZOD\\"] i += 6 elif message[i:i+3] == \\"ZOD\\": result += translations[\\"ZOD\\"] i += 3 else: result += message[i] i += 1 return result"},{"question":"def matrix_submatrix_sum(n: int, m: int, matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Returns the result of submatrix sum for each query. :param n: number of rows in the matrix :param m: number of columns in the matrix :param matrix: 2D list containing the matrix elements :param queries: list of queries where each query is represented by four integers (x1, y1, x2, y2) :return: list of integers representing the sum of elements in submatrices defined by the queries >>> matrix_submatrix_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2), (2, 2, 3, 3)]) [12, 28] >>> matrix_submatrix_sum(2, 2, [[1, 2], [3, 4]], [(1, 1, 2, 2)]) [10]","solution":"def matrix_submatrix_sum(n, m, matrix, queries): Returns the result of submatrix sum for each query. :param n: number of rows in the matrix :param m: number of columns in the matrix :param matrix: 2D list containing the matrix elements :param queries: list of queries where each query is represented by four integers (x1, y1, x2, y2) :return: list of integers representing the sum of elements in submatrices defined by the queries # Initialize prefix sum array prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] # Compute prefix sum for the matrix for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) result = [] # Process each query for (x1, y1, x2, y2) in queries: # Compute the sum for the query using the prefix sum array submatrix_sum = (prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1]) result.append(submatrix_sum) return result"},{"question":"def are_averages_above_threshold(n, marks_subject_a, marks_subject_b, threshold): Check if all students' average marks are greater than the threshold value. Args: n : int : Number of students marks_subject_a : list : Marks obtained in subject A marks_subject_b : list : Marks obtained in subject B threshold : int : Threshold value Returns: bool : True if all students' average marks are greater than the threshold value, otherwise False.","solution":"def are_averages_above_threshold(n, marks_subject_a, marks_subject_b, threshold): Check if all students' average marks are greater than the threshold value. Args: n : int : Number of students marks_subject_a : list : Marks obtained in subject A marks_subject_b : list : Marks obtained in subject B threshold : int : Threshold value Returns: bool : True if all students' average marks are greater than the threshold value, otherwise False. if n != len(marks_subject_a) or n != len(marks_subject_b): raise ValueError(\\"Number of students must match the length of the marks lists\\") for a, b in zip(marks_subject_a, marks_subject_b): average = (a + b) / 2 if average <= threshold: return False return True"},{"question":"def longest_palindrome_substring(s: str) -> (int, str): Returns the length of the longest palindromic substring and the substring itself. >>> longest_palindrome_substring(\\"\\") == (0, \\"\\") >>> longest_palindrome_substring(\\"a\\") == (1, \\"a\\") >>> longest_palindrome_substring(\\"z\\") == (1, \\"z\\") >>> longest_palindrome_substring(\\"abcde\\") == (1, \\"a\\") >>> longest_palindrome_substring(\\"babad\\") == (3, \\"bab\\") or longest_palindrome_substring(\\"babad\\") == (3, \\"aba\\") >>> longest_palindrome_substring(\\"cbbd\\") == (2, \\"bb\\") >>> longest_palindrome_substring(\\"forgeeksskeegfor\\") == (10, \\"geeksskeeg\\") >>> longest_palindrome_substring(\\"aba\\") == (3, \\"aba\\") >>> longest_palindrome_substring(\\"racecar\\") == (7, \\"racecar\\") >>> longest_palindrome_substring(\\"abccba\\") == (6, \\"abccba\\") >>> longest_palindrome_substring(\\"banana\\") == (5, \\"anana\\") >>> longest_palindrome_substring(\\"abcdcbaefg\\") == (7, \\"abcdcba\\") pass","solution":"def longest_palindrome_substring(s): Returns the length of the longest palindromic substring and the substring itself. n = len(s) if n == 0: return 0, \\"\\" longest = 1 start = 0 # Dynamic programming table to store palindrome status dp = [[False] * n for _ in range(n)] # Single-letter palindromes for i in range(n): dp[i][i] = True # Check for 2-letter palindromes for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i longest = 2 # Check for palindromes longer than 2 letters for length in range(3, n + 1): # length of the substring for i in range(n - length + 1): # starting point of the substring j = i + length - 1 # ending point of the substring if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i longest = length return longest, s[start:start + longest]"},{"question":"def middle_element(arr): Returns the middle element of the list if the list length is odd. If the list length is even, returns the average of the two middle elements. Examples: >>> middle_element([1, 3, 5]) 3 >>> middle_element([2, 4, 6, 8]) 5.0 >>> middle_element([7, 9, 11, 13, 15]) 11 >>> middle_element([10, 20]) 15.0","solution":"def middle_element(arr): Returns the middle element of the list if the list length is odd. If the list length is even, returns the average of the two middle elements. n = len(arr) if n % 2 == 1: # If the length of the list is odd, return the middle element return arr[n // 2] else: # If the length of the list is even, return the average of the two middle elements return (arr[n // 2 - 1] + arr[n // 2]) / 2"},{"question":"def shortest_balanced_substring(s: str) -> int: Given a string s consisting only of characters 'a' and 'b', a substring is considered balanced if it contains an equal number of 'a's and 'b's. This function returns the length of the shortest balanced substring in s. If no such substring exists, returns -1. Examples: >>> shortest_balanced_substring(\\"babaa\\") 2 >>> shortest_balanced_substring(\\"bbaa\\") 2 >>> shortest_balanced_substring(\\"aaaa\\") -1 >>> shortest_balanced_substring(\\"babab\\") 2","solution":"def shortest_balanced_substring(s): Returns the length of the shortest balanced substring in s. A balanced substring contains an equal number of 'a's and 'b's. If no such substring exists, returns -1. # Iterate over all possible substring lengths starting from 2 (smallest balanced length) for length in range(2, len(s) + 1): # Iterate over all possible subtrings of current length for start in range(len(s) - length + 1): substring = s[start:start + length] # Check if the substring is balanced if substring.count('a') == substring.count('b'): return length return -1"},{"question":"import collections from typing import List, Tuple def find_most_popular_book(test_cases: List[Tuple[int, List[str]]]) -> List[str]: Finds the most popular book for each test case based on the number of ratings. Parameters: test_cases (list): A list of tuples where each tuple represents a test case. Each tuple contains an integer (number of books) and a list of strings (book names). Returns: list: A list of strings where each string is the most popular book for the corresponding test case. Examples: >>> find_most_popular_book([(5, ['harry_potter', 'twilight', 'harry_potter', 'hunger_games', 'twilight'])]) ['harry_potter'] >>> find_most_popular_book([(4, ['book1', 'book2', 'book1', 'book2'])]) ['book1'] pass def test_find_most_popular_book(): test_cases = [ (5, ['harry_potter', 'twilight', 'harry_potter', 'hunger_games', 'twilight']), (4, ['book1', 'book2', 'book1', 'book2']), (6, ['bookA', 'bookB', 'bookA', 'bookA', 'bookC', 'bookB']), (3, ['unique1', 'unique2', 'unique3']), (2, ['same', 'same']) ] expected_output = [ 'harry_potter', 'book1', 'bookA', 'unique1', 'same' ] assert find_most_popular_book(test_cases) == expected_output def test_find_most_popular_book_with_single_book(): test_cases = [ (1, ['single_book']), ] expected_output = [ 'single_book' ] assert find_most_popular_book(test_cases) == expected_output def test_find_most_popular_book_with_multiple_same_books(): test_cases = [ (10, ['same_book'] * 10), ] expected_output = [ 'same_book' ] assert find_most_popular_book(test_cases) == expected_output","solution":"def find_most_popular_book(test_cases): Finds the most popular book for each test case based on the number of ratings. Parameters: test_cases (list): A list of tuples where each tuple represents a test case. Each tuple contains an integer (number of books) and a list of strings (book names). Returns: list: A list of strings where each string is the most popular book for the corresponding test case. results = [] for num_books, books in test_cases: book_count = {} for i, book in enumerate(books): if book not in book_count: book_count[book] = (1, i) else: book_count[book] = (book_count[book][0] + 1, book_count[book][1]) most_popular = max(book_count.items(), key=lambda x: (x[1][0], -x[1][1])) results.append(most_popular[0]) return results"},{"question":"from typing import List def longest_non_decreasing_subsequence(arr: List[int]) -> List[int]: Find the longest non-decreasing subsequence in a given list of integers. >>> longest_non_decreasing_subsequence([5, 1, 3, 4, 2, 3, 4, 5, 1]) in [[1, 3, 4, 4, 5], [1, 2, 3, 4, 5]] True >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) == [5] True >>> longest_non_decreasing_subsequence([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] True >>> longest_non_decreasing_subsequence([]) == [] True def test_single_element(): assert longest_non_decreasing_subsequence([1]) == [1] def test_strictly_decreasing(): assert longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) == [5] def test_all_elements_equal(): assert longest_non_decreasing_subsequence([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] def test_general_case_1(): result = longest_non_decreasing_subsequence([5, 1, 3, 4, 2, 3, 4, 5, 1]) assert result in [[1, 3, 4, 4, 5], [1, 2, 3, 4, 5]] def test_general_case_2(): result = longest_non_decreasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) assert result in [[10, 22, 33, 50, 60, 80], [10, 21, 33, 50, 60, 80]] def test_empty_list(): assert longest_non_decreasing_subsequence([]) == [] def test_increasing_sequence(): assert longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]","solution":"def longestNonDecreasingSubsequence(arr): if not arr: return [] n = len(arr) dp = [1] * n prev_index = [-1] * n for i in range(1, n): for j in range(i): if arr[i] >= arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev_index[i] = j max_length = max(dp) max_index = dp.index(max_length) result = [] while max_index != -1: result.append(arr[max_index]) max_index = prev_index[max_index] return result[::-1]"},{"question":"def min_steps_to_exit(maze): Determines the minimum number of steps required to reach the bottom-right corner from the top-left corner in a maze. Parameters: maze (list of list of str): 2D grid filled with characters 'O' and 'X'. Returns: int: Minimum number of steps required to reach the bottom-right corner or -1 if it is not possible. Examples: >>> min_steps_to_exit([[\\"O\\", \\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\", \\"O\\"]]) 6 >>> min_steps_to_exit([[\\"O\\", \\"X\\", \\"O\\"], [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"]]) -1 from solution import min_steps_to_exit def test_min_steps_example_1(): maze = [ [\\"O\\", \\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\", \\"X\\"], [\\"X\\", \\"O\\", \\"O\\", \\"O\\"] ] assert min_steps_to_exit(maze) == 6 def test_min_steps_example_2(): maze = [ [\\"O\\", \\"X\\", \\"O\\"], [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"] ] assert min_steps_to_exit(maze) == -1 def test_min_steps_single_cell(): maze = [[\\"O\\"]] assert min_steps_to_exit(maze) == 0 def test_min_steps_blocked_entrance(): maze = [ [\\"X\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"] ] assert min_steps_to_exit(maze) == -1 def test_min_steps_blocked_exit(): maze = [ [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"O\\", \\"X\\"] ] assert min_steps_to_exit(maze) == -1 def test_min_steps_bigger_maze(): maze = [ [\\"O\\", \\"O\\", \\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\", \\"O\\", \\"O\\"] ] assert min_steps_to_exit(maze) == 8","solution":"from collections import deque def min_steps_to_exit(maze): Determines the minimum number of steps required to reach the bottom-right corner from the top-left corner in a maze. if not maze or not maze[0]: return -1 n, m = len(maze), len(maze[0]) if maze[0][0] == 'X' or maze[n-1][m-1] == 'X': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if (r, c) == (n-1, m-1): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and maze[nr][nc] == 'O' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def smallest_window_all_unique_chars(s: str) -> int: Given a string of lowercase letters, find the length of the smallest window that contains all the unique characters of the input string. >>> smallest_window_all_unique_chars(\\"aabcbcdbca\\") 4 >>> smallest_window_all_unique_chars(\\"aaaa\\") 1 >>> smallest_window_all_unique_chars(\\"abcdefg\\") 7 >>> smallest_window_all_unique_chars(\\"abac\\") 3 pass # Tests def test_example(): assert smallest_window_all_unique_chars(\\"aabcbcdbca\\") == 4 def test_single_character(): assert smallest_window_all_unique_chars(\\"aaaa\\") == 1 def test_all_unique_characters(): assert smallest_window_all_unique_chars(\\"abcdefg\\") == 7 def test_repeated_characters(): assert smallest_window_all_unique_chars(\\"abac\\") == 3 def test_large_input(): s = \\"abcdefghijklmnopqrstuvwxyz\\" * 385 + \\"a\\" assert smallest_window_all_unique_chars(s) == 26 def test_edge_case_minimum_length(): assert smallest_window_all_unique_chars(\\"a\\") == 1 def test_edge_case_empty_string(): assert smallest_window_all_unique_chars(\\"\\") == 0","solution":"def smallest_window_all_unique_chars(s): from collections import defaultdict # Get the list of unique characters in the input string unique_chars = set(s) unique_count = len(unique_chars) # Dictionary to store the count of characters in the current window char_count = defaultdict(int) min_len = float('inf') start = 0 start_index = -1 count = 0 for j in range(len(s)): char_count[s[j]] += 1 # If this character's count was 1 after inserting (i.e., it's the first occurrence) if char_count[s[j]] == 1: count += 1 # If the current window contains all characters if count == unique_count: # Minimize the window's size while char_count[s[start]] > 1: if char_count[s[start]] > 1: char_count[s[start]] -= 1 start += 1 # Update the minimum length of the window window_len = j - start + 1 if min_len > window_len: min_len = window_len start_index = start return min_len if start_index != -1 else 0"},{"question":"from typing import List, Tuple def separate_even_odd(numbers: List[int]) -> Tuple[List[int], List[int]]: Separates a list of numbers into even and odd numbers. Args: numbers (List[int]): The input list of integers. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - First list with even numbers. - Second list with odd numbers. Examples: >>> separate_even_odd([10, 21, 32, 43, 54, 65]) ([10, 32, 54], [21, 43, 65]) >>> separate_even_odd([1, 2, 3, 4, 5, 6]) ([2, 4, 6], [1, 3, 5]) pass def test_separate_even_odd_basic(): assert separate_even_odd([10, 21, 32, 43, 54, 65]) == ([10, 32, 54], [21, 43, 65]) def test_separate_even_odd_with_negatives(): assert separate_even_odd([10, -21, 32, -43, 54, -65]) == ([10, 32, 54], [-21, -43, -65]) def test_separate_even_odd_all_even(): assert separate_even_odd([2, 4, 6, 8, 10]) == ([2, 4, 6, 8, 10], []) def test_separate_even_odd_all_odd(): assert separate_even_odd([1, 3, 5, 7, 9]) == ([], [1, 3, 5, 7, 9]) def test_separate_even_odd_mixed(): assert separate_even_odd([1, 2, 3, 4, 5, 6]) == ([2, 4, 6], [1, 3, 5]) def test_separate_even_odd_empty(): assert separate_even_odd([]) == ([], [])","solution":"from typing import List, Tuple def separate_even_odd(numbers: List[int]) -> Tuple[List[int], List[int]]: Separates a list of numbers into even and odd numbers. Args: numbers (List[int]): The input list of integers. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - First list with even numbers. - Second list with odd numbers. evens = [num for num in numbers if num % 2 == 0] odds = [num for num in numbers if num % 2 != 0] return (evens, odds)"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Returns a tuple of indices of the two numbers in the list that add up to the target. If no such pair exists, returns None. >>> find_pair_with_sum([2, 7, 11, 15], 9) # (0, 1) >>> find_pair_with_sum([1, 4, 5, 6, 10], 10) # (1, 3) >>> find_pair_with_sum([0, 1, 2, 3, 4, 5], 8) # (3, 5) >>> find_pair_with_sum([1, 5, 4, 5], 10) # (1, 3) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) # None >>> find_pair_with_sum([1], 1) # None >>> find_pair_with_sum([], 0) # None","solution":"def find_pair_with_sum(nums, target): Returns a tuple of indices of the two numbers in the list that add up to the target. If no such pair exists, returns None. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"from typing import List def rearrange_string(s: str) -> str: Given a string consisting of only the characters 'a', 'b', and 'c', rearrange the characters so that no two identical characters are adjacent to one another. Return the rearranged string. If it is not possible to rearrange the string in such a way, return an empty string. Examples: >>> rearrange_string(\\"aabbc\\") 'abcab' >>> rearrange_string(\\"aaab\\") '' pass # Unit Test def test_rearrange_possible_case(): s = \\"aabbc\\" result = rearrange_string(s) assert len(result) == len(s) for i in range(1, len(result)): assert result[i] != result[i-1] def test_rearrange_impossible_case(): s = \\"aaab\\" result = rearrange_string(s) assert result == \\"\\" def test_rearrange_single_char_case(): s = \\"a\\" result = rearrange_string(s) assert result == \\"a\\" def test_rearrange_two_chars_case(): s = \\"aa\\" result = rearrange_string(s) assert result == \\"\\" def test_rearrange_balanced_case(): s = \\"abcabc\\" result = rearrange_string(s) assert len(result) == len(s) for i in range(1, len(result)): assert result[i] != result[i-1] def test_rearrange_same_chars(): s = \\"ccc\\" result = rearrange_string(s) assert result == \\"\\" def test_rearrange_different_chars(): s = \\"cba\\" result = rearrange_string(s) assert len(result) == len(s) for i in range(1, len(result)): assert result[i] != result[i-1]","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string so that no two adjacent characters are the same. Returns an empty string if not possible. # Count the frequency of each character freq = Counter(s) max_heap = [] # Create a max heap based on character frequency for char, count in freq.items(): heapq.heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char is not None and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 if len(result) != len(s): return \\"\\" else: return \\"\\".join(result)"},{"question":"from typing import List def maxProjects(arr: List[int], K: int, B: int) -> int: Write a function \`maxProjects\` that returns the maximum number of projects you can fund without exceeding the budget B and without funding more than K projects. Args: arr : List[int] : an array of integers representing the cost of a set of projects. K : int : the number of projects you have resources to complete. B : int : the total budget available to fund projects. Returns: int: Maximum number of projects that can be funded within the constraints. Examples: >>> maxProjects([2, 3, 1, 5, 4], 3, 7) 3 >>> maxProjects([10, 2, 5, 8, 3], 2, 10) 2 >>> maxProjects([1, 1, 1, 1], 2, 3) 2 >>> maxProjects([7, 6, 8, 9], 2, 10) 1 pass","solution":"def maxProjects(arr, K, B): Determines the maximum number of projects that can be funded without exceeding the budget B and without funding more than K projects. arr.sort() count = 0 total_cost = 0 for cost in arr: if count < K and total_cost + cost <= B: total_cost += cost count += 1 else: break return count"},{"question":"import heapq from typing import List, Tuple def min_toll(n: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Returns the minimum toll fee to travel from start to end. Parameters: n (int): Number of towns. roads (List[Tuple[int, int, int]]): List of roads where each road is represented as a tuple (u, v, w) with u and v being towns and w being the toll fee. start (int): Starting town. end (int): Destination town. >>> min_toll(4, [(0, 1, 10), (0, 2, 6), (1, 3, 15), (2, 3, 4)], 0, 3) 10 >>> min_toll(5, [(0, 1, 2), (1, 2, 3), (3, 4, 1)], 0, 4) -1 >>> min_toll(3, [(0, 1, 5), (1, 2, 10), (0, 2, 15)], 0, 2) 15 >>> min_toll(6, [(0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (4, 5, 9)], 0, 4) 20 >>> min_toll(3, [(0, 1, 1), (1, 2, 2)], 0, 0) 0 >>> min_toll(3, [(0, 1, 1)], 0, 2) -1","solution":"import heapq def min_toll(n, roads, start, end): Returns the minimum toll fee to travel from start to end. graph = {i: [] for i in range(n)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) min_heap = [(0, start)] # (toll, town) visited = set() min_toll = {i: float('inf') for i in range(n)} min_toll[start] = 0 while min_heap: toll, town = heapq.heappop(min_heap) if town in visited: continue visited.add(town) if town == end: return toll for neighbor, weight in graph[town]: if neighbor not in visited: new_toll = toll + weight if new_toll < min_toll[neighbor]: min_toll[neighbor] = new_toll heapq.heappush(min_heap, (new_toll, neighbor)) return -1"},{"question":"from typing import List, Tuple def best_selling_book(n: int, sales: List[Tuple[str, int]]) -> str: Record book sales and identify the best-selling book. If there is a tie, return the title that comes first lexicographically. >>> best_selling_book(4, [(\\"GreatExpectations\\", 10), (\\"MobyDick\\", 15), (\\"GreatExpectations\\", 5), (\\"WarAndPeace\\", 15)]) 'MobyDick' >> best_selling_book(3, [(\\"BookOne\\", 5), (\\"BookTwo\\", 10), (\\"BookThree\\", 7)]) 'BookTwo' pass def test_single_record(): assert best_selling_book(1, [(\\"BookOne\\", 10)]) == \\"BookOne\\" def test_multiple_records_no_tie(): assert best_selling_book(3, [(\\"BookOne\\", 10), (\\"BookTwo\\", 15), (\\"BookThree\\", 5)]) == \\"BookTwo\\" def test_multiple_records_with_tie(): assert best_selling_book(4, [(\\"BookOne\\", 10), (\\"BookTwo\\", 15), (\\"BookThree\\", 15), (\\"BookFour\\", 5)]) == \\"BookThree\\" def test_same_book_multiple_sales(): assert best_selling_book(3, [(\\"BookOne\\", 10), (\\"BookOne\\", 5), (\\"BookTwo\\", 12)]) == \\"BookOne\\" def test_lexicographical_tie(): assert best_selling_book(4, [(\\"BookA\\", 10), (\\"BookB\\", 10), (\\"BookC\\", 8), (\\"BookD\\", 7)]) == \\"BookA\\"","solution":"def best_selling_book(n, sales): from collections import defaultdict sales_dict = defaultdict(int) for title, copies in sales: sales_dict[title] += copies max_sales = max(sales_dict.values()) best_sellers = [title for title, copies in sales_dict.items() if copies == max_sales] return min(best_sellers)"},{"question":"def max_min_house_market_distance(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determines the maximum of the minimum distances from houses to markets in a grid. Args: T: int - Number of test cases. test_cases: List[Tuple[int, List[str]]] - A list of test cases where each test case is a tuple containing an integer N and a list of N strings representing the grid. Returns: List[int] - A list of integers representing the maximum of the minimum distances from houses to markets for each test case. Example: >>> max_min_house_market_distance(2, [(3, [\\"H..\\", \\"...\\", \\"..M\\"]), (4, [\\"H.M.\\", \\"....\\", \\"M.H.\\", \\"....\\"])]) [2, 1] >>> max_min_house_market_distance(1, [(3, [\\"...\\", \\"...\\", \\"..M\\"])]) [-1]","solution":"def max_min_house_market_distance(T, test_cases): def bfs_multisource(grid, houses): from collections import deque, defaultdict N = len(grid) dx = [1, -1, 0, 0] dy = [0, 0, 1, -1] # Create a distance dictionary for houses initialized to inf distances = defaultdict(lambda: float('inf')) # Prepare the queue with all market positions and mark their distances as 0 queue = deque() for x in range(N): for y in range(N): if grid[x][y] == 'M': queue.append((x, y, 0)) # Conduct a BFS from all market positions simultaneously while queue: cx, cy, current_dist = queue.popleft() for i in range(4): nx, ny = cx + dx[i], cy + dy[i] if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] != 'M': if (nx, ny) not in distances or distances[(nx, ny)] > current_dist + 1: distances[(nx, ny)] = current_dist + 1 queue.append((nx, ny, current_dist + 1)) # Return the minimum distance for each house return [distances[house] for house in houses] results = [] for i in range(T): N = test_cases[i][0] grid = test_cases[i][1] houses = [(x, y) for x in range(N) for y in range(N) if grid[x][y] == 'H'] if not houses: results.append(-1) continue markets = any(grid[x][y] == 'M' for x in range(N) for y in range(N)) if not markets: results.append(-1) continue min_distances = bfs_multisource(grid, houses) results.append(max(min_distances)) return results"},{"question":"def reverse_subarrays(arr: List[int], k: int) -> List[int]: Reverses every sub-array of k elements in the given array. Args: arr : list of int : input array of integers k : int : number of elements to be reversed in each group Returns: list of int : array after reversing each sub-array of k elements from solution import reverse_subarrays def test_reverse_subarrays_example1(): assert reverse_subarrays([1, 2, 3, 4, 5, 6, 7, 8], 3) == [3, 2, 1, 6, 5, 4, 8, 7] def test_reverse_subarrays_example2(): assert reverse_subarrays([1, 2, 3, 4, 5], 2) == [2, 1, 4, 3, 5] def test_reverse_subarrays_example3(): assert reverse_subarrays([1, 2, 3, 4], 4) == [4, 3, 2, 1] def test_reverse_subarrays_single_element(): assert reverse_subarrays([1], 1) == [1] def test_reverse_subarrays_elements_less_than_k(): assert reverse_subarrays([1, 2, 3], 4) == [3, 2, 1] def test_reverse_subarrays_all_elements_same(): assert reverse_subarrays([2, 2, 2, 2], 2) == [2, 2, 2, 2] def test_reverse_subarrays_elements_and_k_equal(): assert reverse_subarrays([1, 2, 3], 3) == [3, 2, 1] def test_reverse_subarrays_large_k(): assert reverse_subarrays([1, 2, 3, 4, 5, 6], 6) == [6, 5, 4, 3, 2, 1]","solution":"def reverse_subarrays(arr, k): Reverses every sub-array of k elements in the given array. Args: arr : list of int : input array of integers k : int : number of elements to be reversed in each group Returns: list of int : array after reversing each sub-array of k elements n = len(arr) result = [] for i in range(0, n, k): sub_array = arr[i:i+k] result.extend(reversed(sub_array)) return result"},{"question":"from typing import List def word_value(lst: List[str]) -> List[int]: Calculate the alphabetic value of each string in the list. Each character's value is determined by its position in the alphabet (a=1, b=2, ..., z=26). Args: lst : list of str : List of strings to calculate values for. Returns: list of int : List of integer values corresponding to each input string. >>> word_value([\\"abc\\"]) == [6] >>> word_value([\\"hello world\\"]) == [124] >>> word_value([\\"abc\\", \\"def\\"]) == [6, 15] >>> word_value([\\"a\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]) == [1, 6, 10, 15] >>> word_value([\\"abcdefghijklmnopqrstuvwxyz\\"]) == [351] >>> word_value([\\"\\"]) == [0] >>> word_value([\\" \\"]) == [0]","solution":"def word_value(lst): Calculate the alphabetic value of each string in the list. Args: lst : list of str : List of strings to calculate values for. Returns: list of int : List of integer values corresponding to each input string. def single_word_value(word): return sum((ord(char) - ord('a') + 1) for char in word if char.isalpha()) return [single_word_value(word) for word in lst]"},{"question":"def reverse_digits(num: int) -> str: Returns the integer num as a reversed string of digits with leading zeros removed. >>> reverse_digits(10500) \\"501\\" >>> reverse_digits(5) \\"5\\" >>> reverse_digits(1234) \\"4321\\" >>> reverse_digits(0) \\"0\\" >>> reverse_digits(1000) \\"1\\"","solution":"def reverse_digits(num): Returns the integer num as a reversed string of digits with leading zeros removed. return str(int(str(num)[::-1]))"},{"question":"from collections import deque def find_minimum_path_length(maze, target): Determine the minimum number of rooms you need to pass through to get from room 0 to the target room. Returns -1 if the target room is unreachable. :param maze: Maze object with methods get_rooms() and get_doors(room_id) :param target: int representing the target room ID :return: int representing the minimum number of rooms to pass through, or -1 if target is unreachable >>> class Maze: ... def __init__(self, connections): ... self.connections = connections ... ... def get_rooms(self): ... return list(self.connections.keys()) ... ... def get_doors(self, room_id): ... return self.connections.get(room_id, []) ... >>> maze = Maze({ ... 0: [1, 2], ... 1: [3], ... 2: [3], ... 3: [4], ... 4: [] ... }) >>> find_minimum_path_length(maze, 4) 3 >>> find_minimum_path_length(maze, 3) 2 >>> find_minimum_path_length(maze, 2) 1 >>> find_minimum_path_length(maze, 5) -1 >>> find_minimum_path_length(maze, 0) 0 >>> maze_with_no_path = Maze({ ... 0: [1, 2], ... 1: [3], ... 2: [], ... 3: [] ... }) >>> find_minimum_path_length(maze_with_no_path, 2) 1 >>> find_minimum_path_length(maze_with_no_path, 3) 2 >>> find_minimum_path_length(maze_with_no_path, 4) -1 >>> maze = Maze({ ... 0: [] ... }) >>> find_minimum_path_length(maze, 0) 0 >>> find_minimum_path_length(maze, 1) -1 >>> maze = Maze({ ... 0: [1], ... 1: [2], ... 3: [4], ... 4: [] ... }) >>> find_minimum_path_length(maze, 2) 2 >>> find_minimum_path_length(maze, 4) -1","solution":"from collections import deque def find_minimum_path_length(maze, target): Returns the minimum number of rooms to pass through to get from room 0 to the target room. Returns -1 if the target room is unreachable. # Initialize the queue for BFS queue = deque([(0, 0)]) # Each element is a tuple (current_room, depth) visited = set() # Run the BFS while queue: current_room, depth = queue.popleft() if current_room == target: return depth if current_room not in visited: visited.add(current_room) for neighbor in maze.get_doors(current_room): queue.append((neighbor, depth + 1)) return -1 # Target room is unreachable"},{"question":"def process_queries(T: int, cases: List[Tuple[int, int, List[int], List[Tuple[int, int, int]]]]) -> List[int]: Process a large number of queries on an array of integers to find the sum of a modified subarray. T - the number of test cases. cases - a list of tuples, each containing a test case description. >>> T = 1 >>> cases = [ >>> (5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 4, -1), (3, 5, 3)]) >>> ] >>> process_queries(T, cases) [12, 6, 21]","solution":"def process_queries(T, cases): results = [] for case in cases: N, M, A, queries = case # Precomputed prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] for query in queries: x, y, w = query # Calculate the sum of the subarray A[x..y] sum_subarray = prefix_sum[y] - prefix_sum[x - 1] # Add w * length of subarray sum_subarray += w * (y - x + 1) results.append(sum_subarray) return results"},{"question":"def is_sorted_ascending(n: int, lst: List[int]) -> str: Checks if the list is sorted in ascending order. >>> is_sorted_ascending(5, [1, 2, 3, 4, 5]) 'Y' >>> is_sorted_ascending(5, [3, 1, 2, 5, 4]) 'N' >>> is_sorted_ascending(1, [10]) 'Y' >>> is_sorted_ascending(4, [-3, -2, -1, 0]) 'Y' >>> is_sorted_ascending(4, [-3, -1, -2, 0]) 'N' >>> is_sorted_ascending(6, [-3, 0, 2, 5, 7, 8]) 'Y' >>> is_sorted_ascending(6, [-3, 0, 2, 5, 7, 6]) 'N'","solution":"def is_sorted_ascending(n, lst): Checks if the list is sorted in ascending order. Parameters: n (int): Number of integers in the list lst (list of int): The list of integers Returns: str: 'Y' if the list is sorted in ascending order, 'N' otherwise for i in range(n-1): if lst[i] > lst[i+1]: return 'N' return 'Y'"},{"question":"def count_ways_to_place_items(n, m, blocked_spots): Returns the number of ways to place two distinct items in a warehouse grid with blocked spots. Parameters: n (int): Number of rows in the warehouse grid. m (int): Number of columns in the warehouse grid. blocked_spots (list of tuples): List of coordinates for blocked spots. Returns: int: Number of ways to place two distinct items in the available spots. pass def calculate_ways_for_test_cases(test_cases): Process multiple test cases to find the number of ways to place two distinct items in various warehouse grids. Parameters: test_cases (list of tuples): List of test cases where each test case includes the number of rows, columns, number of blocked spots, and the list of blocked spot coordinates. Returns: list of int: List of results for each test case indicating the number of ways to place the items. pass def test_count_ways_to_place_items(): # Test case 1 assert count_ways_to_place_items(3, 3, [(2, 2)]) == 56 # Test case 2 assert count_ways_to_place_items(4, 4, [(2, 2), (3, 3)]) == 182 # Test case 3 assert count_ways_to_place_items(2, 2, [(1, 1), (2, 2), (1, 2), (2, 1)]) == 0 # Test case 4 assert count_ways_to_place_items(1, 1, []) == 0 # Test case 5 assert count_ways_to_place_items(4, 4, []) == 240 def test_calculate_ways_for_test_cases(): test_cases = [ (3, 3, 1, [(2, 2)]), (4, 4, 2, [(2, 2), (3, 3)]) ] expected_results = [56, 182] assert calculate_ways_for_test_cases(test_cases) == expected_results","solution":"def count_ways_to_place_items(n, m, blocked_spots): Returns the number of ways to place two distinct items in a warehouse grid with blocked spots. Parameters: n (int): Number of rows in the warehouse grid. m (int): Number of columns in the warehouse grid. blocked_spots (list of tuples): List of coordinates for blocked spots. Returns: int: Number of ways to place two distinct items in the available spots. total_spots = n * m available_spots = total_spots - len(blocked_spots) # If there are less than 2 available spots, it's not possible to place two items if available_spots < 2: return 0 return available_spots * (available_spots - 1) # Function to process multiple test cases def calculate_ways_for_test_cases(test_cases): results = [] for test_case in test_cases: n, m, b, blocked_spots = test_case results.append(count_ways_to_place_items(n, m, blocked_spots)) return results"},{"question":"from typing import List def count_visible_buildings(n: int, heights: List[int]) -> int: Determine the number of buildings visible from the left side. A building is visible if it is strictly taller than all the buildings before it. >>> count_visible_buildings(6, [3, 1, 4, 1, 5, 9]) 4 >>> count_visible_buildings(5, [2, 2, 2, 2, 2]) 1 >>> count_visible_buildings(5, [1, 2, 3, 4, 5]) 5 >>> count_visible_buildings(5, [5, 4, 3, 2, 1]) 1 >>> count_visible_buildings(6, [1, 3, 2, 4, 3, 5]) 4 >>> count_visible_buildings(1, [5]) 1 >>> count_visible_buildings(0, []) 0 >>> count_visible_buildings(4, [1000000000, 999999999, 1000000001, 1000000002]) 3","solution":"def count_visible_buildings(n, heights): if n == 0: return 0 visible_count = 1 max_height = heights[0] for i in range(1, n): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"def total_elevation_gain(N: int, elevations: List[int]) -> int: Returns the total elevation gain of the trail. Args: N : int : The number of elements in the trail. elevations : list of int : The list of elevations in the trail. Returns: int : The total elevation gain. Examples: >>> total_elevation_gain(6, [100, 120, 90, 150, 80, 200]) 200 >>> total_elevation_gain(4, [100, 90, 80, 70]) 0 >>> total_elevation_gain(5, [100, 100, 100, 100, 100]) 0 >>> total_elevation_gain(3, [100, 110, 120]) 20 >>> total_elevation_gain(5, [100, 200, 150, 250, 300]) 250","solution":"def total_elevation_gain(N, elevations): Returns the total elevation gain of the trail. Args: N : int : The number of elements in the trail. elevations : list of int : The list of elevations in the trail. Returns: int : The total elevation gain. total_gain = 0 for i in range(1, N): if elevations[i] > elevations[i - 1]: total_gain += elevations[i] - elevations[i - 1] return total_gain"},{"question":"def factorial(n: int) -> int: Calculate and return the factorial of a given non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(20) 2432902008176640000","solution":"def factorial(n): Returns the factorial of a given non-negative integer n. If n is 0, returns 1 as 0! is defined as 1. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def contains_duplicate(nums: List[int]) -> bool: Determine whether the array contains any duplicates. >>> contains_duplicate([1, 2, 3, 1]) == True >>> contains_duplicate([1, 2, 3, 4]) == False >>> contains_duplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True >>> contains_duplicate([]) == False >>> contains_duplicate([1]) == False >>> contains_duplicate([1, 2, 3, 4, 5]) == False >>> contains_duplicate([1, -1, 2, -2, 3, -3, 1]) == True >>> contains_duplicate([1, 1, 1, 1, 1]) == True >>> contains_duplicate(list(range(1000000)) + [999999]) == True pass","solution":"def contains_duplicate(nums): Returns True if any integer appears at least twice in the array, False otherwise. seen = set() for num in nums: if num in seen: return True seen.add(num) return False"},{"question":"import re def extract_assignments(source_code: str) -> list: Extract all variable assignments from a given piece of Python source code. Args: source_code (str): A string containing Python source code. Returns: list of tuple: A list of tuples containing variable names and their assigned values as strings. >>> extract_assignments(\\"x = 10ny = x + 2nz = 'hello'\\") [('x', '10'), ('y', 'x + 2'), ('z', \\"'hello'\\")] >>> extract_assignments(\\"a = [1, 2, 3]nb = {'key': 'value'}nc = 'single quote inside ''string'' '\\") [('a', '[1, 2, 3]'), ('b', \\"{'key': 'value'}\\"), ('c', \\"'single quote inside ''string'' '\\")]","solution":"import re def extract_assignments(source_code): Extract all variable assignments from a given piece of Python source code. Args: source_code (str): A string containing Python source code. Returns: list of tuple: A list of tuples containing variable names and their assigned values as strings. # Regular expression to capture valid variable assignments assignment_regex = re.compile(r'^s*([a-zA-Z_]w*)s*=s*(.*?)s*(#.*)?', re.MULTILINE) assignments = [] # Split the source code into lines and accumulate lines for multi-line assignments lines = source_code.splitlines() multi_line_context = \\"\\" for line in lines: stripped_line = line.strip() # Continue building multi-line strings if stripped_line.endswith(\\"\\"): multi_line_context += stripped_line[:-1] continue else: multi_line_context += stripped_line match = assignment_regex.match(multi_line_context) if match: # Match contains three groups: variable name, value, and optional comment variable_name = match.group(1) assigned_value = match.group(2) assignments.append((variable_name, assigned_value)) # Reset the multi-line context after processing each full line multi_line_context = \\"\\" return assignments"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. :param s: Input string :return: Longest substring without repeating characters >>> longest_unique_substring(\\"abcabcbb\\") 'abc' >>> longest_unique_substring(\\"bbbbb\\") 'b' >>> longest_unique_substring(\\"pwwkew\\") 'wke' >>> longest_unique_substring(\\"\\") '' >>> longest_unique_substring(\\"a\\") 'a' >>> longest_unique_substring(\\"abcdef\\") 'abcdef' >>> longest_unique_substring(\\"aaabcdef\\") 'abcdef' >>> longest_unique_substring(\\"abcdefgg\\") 'abcdefg' >>> longest_unique_substring(\\"abcdbcbb\\") 'abcd'","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. :param s: Input string :return: Longest substring without repeating characters if not s: return \\"\\" start = 0 maxLength = 0 startMax = 0 seen = {} for end in range(len(s)): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end if end - start + 1 > maxLength: maxLength = end - start + 1 startMax = start return s[startMax:startMax + maxLength]"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> bool: Given a list of integers, determine if it contains a contiguous subarray of size at least 2 that sums to zero. If such a subarray exists, return True. Otherwise, return False. >>> has_zero_sum_subarray([1, 2, -3, 3, -1]) == True >>> has_zero_sum_subarray([1, 2, 3, 4, 5]) == False >>> has_zero_sum_subarray([2, -2, 3]) == True >>> has_zero_sum_subarray([1, 2, -3]) == True >>> has_zero_sum_subarray([0]) == False >>> has_zero_sum_subarray([1]) == False >>> has_zero_sum_subarray([4, 2, -2, 1]) == True >>> has_zero_sum_subarray([-100000, 100000]) == True >>> has_zero_sum_subarray([0, 0, 0, 0]) == True >>> has_zero_sum_subarray([1, 2, 3, 0, -6, 6]) == True","solution":"def has_zero_sum_subarray(arr): Check if there is a contiguous subarray of size at least 2 that sums to zero. if len(arr) < 2: return False prefix_sum = {} current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0 or current_sum in prefix_sum: return True prefix_sum[current_sum] = i return False"},{"question":"def min_transformations(n: int, m: int, matrix: List[List[int]]) -> int: Returns the minimum number of transformations required to make every element of the matrix equal. >>> min_transformations(3, 3, [ ... [1, 2, 1], ... [3, 4, 3], ... [1, 2, 1] ... ]) 2 >>> min_transformations(3, 3, [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) 0 >>> min_transformations(3, 3, [ ... [1, 1, 1], ... [2, 2, 2], ... [1, 1, 1] ... ]) 2 >>> min_transformations(3, 3, [ ... [1, 2, 1], ... [1, 2, 1], ... [1, 2, 1] ... ]) 2 >>> min_transformations(1, 1, [ ... [0] ... ]) 0","solution":"def min_transformations(n, m, matrix): Returns the minimum number of transformations required to make every element of the matrix equal. target = matrix[0][0] for i in range(n): for j in range(m): if matrix[i][j] != target: return 2 return 0"},{"question":"from typing import List def walls_and_gates(matrix: List[List[int]]) -> List[List[int]]: Transform each empty room with the distance to its nearest gate. >>> INF = 2**31 - 1 >>> matrix = [[INF, -1, 0, INF], ... [INF, INF, INF, -1], ... [INF, -1, INF, -1], ... [0, -1, INF, INF]] >>> walls_and_gates(matrix) [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] >>> matrix = [[0, INF], ... [INF, INF], ... [INF, 0]] >>> walls_and_gates(matrix) [[0, 1], [1, 1], [1, 0]] >>> matrix = [[-1, -1, -1], ... [-1, 0, -1], ... [-1, -1, -1]] >>> walls_and_gates(matrix) [[-1, -1, -1], [-1, 0, -1], [-1, -1, -1]] >>> matrix = [] >>> walls_and_gates(matrix) [] >>> matrix = [[INF, INF, INF], ... [INF, 0, INF], ... [INF, INF, INF]] >>> walls_and_gates(matrix) [[2, 1, 2], [1, 0, 1], [2, 1, 2]]","solution":"from collections import deque from typing import List def walls_and_gates(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix INF = 2**31 - 1 m, n = len(matrix), len(matrix[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Add all gates to the queue first for i in range(m): for j in range(n): if matrix[i][j] == 0: queue.append((i, j)) while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and matrix[new_x][new_y] == INF: matrix[new_x][new_y] = matrix[x][y] + 1 queue.append((new_x, new_y)) return matrix"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring('abcabcbb') 3 >>> length_of_longest_substring('bbbbb') 1 >>> length_of_longest_substring('pwwkew') 3 >>> length_of_longest_substring('') 0 >>> length_of_longest_substring('abcde') 5 >>> length_of_longest_substring('dvdf') 3 >>> length_of_longest_substring('abcd' * 1000) 4 >>> length_of_longest_substring('a') 1 >>> length_of_longest_substring('au') 2 >>> length_of_longest_substring('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') 62","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: string :return: integer char_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def find_max_sum_subsequence(arr): Returns the smallest length subsequence with the maximum sum. pass def process_test_cases(t, test_cases): Given multiple test cases, find the smallest length subsequence with the maximum sum for each test case. Args: t : int : number of test cases test_cases : list of tuples : each tuple contains an integer n and a list of integers a Returns: list of tuples : each tuple contains the length of the subsequence and the subsequence itself >>> process_test_cases(2, [(4, [1, 2, 3, 4]), (5, [-1, -2, -3, -4, -5])]) [(2, [4, 3]), (2, [-1, -2])] >>> process_test_cases(1, [(6, [1, 1, 1, 1, 1, 1])]) [(2, [1, 1])] >>> process_test_cases(3, [(3, [3, -1, 2]), (4, [4, 4, 4, 4]), (2, [1, -1])]) [(2, [3, 2]), (2, [4, 4]), (2, [1, -1])] >>> process_test_cases(1, [(5, [-100, -200, -300, -400, -500])]) [(2, [-100, -200])] >>> process_test_cases(1, [(8, [3, 3, 4, 4, 2, 2, 1, 1])]) [(2, [4, 4])] pass","solution":"def find_max_sum_subsequence(arr): Returns the smallest length subsequence with the maximum sum. n = len(arr) # Sort the array in descending order arr.sort(reverse=True) # The first two elements will give us the maximum sum return arr[:2] def process_test_cases(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] subseq = find_max_sum_subsequence(a) results.append((len(subseq), subseq)) return results"},{"question":"def reverse_vowels(s: str) -> str: Reverses the vowels in a string while maintaining the relative order of the consonants. Parameters: s (str): The input string. Returns: str: The string with vowels reversed in order. Examples: >>> reverse_vowels(\\"hello\\") 'holle' >>> reverse_vowels(\\"leetcode\\") 'leotcede' >>> reverse_vowels(\\"aA\\") 'Aa' >>> reverse_vowels(\\"bcdfg\\") 'bcdfg'","solution":"def reverse_vowels(s): Reverses the vowels in a string while maintaining the relative order of the consonants. Parameters: s (str): The input string. Returns: str: The string with vowels reversed in order. vowels = set(\\"aeiouAEIOU\\") s = list(s) left, right = 0, len(s) - 1 while left < right: if s[left] in vowels and s[right] in vowels: s[left], s[right] = s[right], s[left] left += 1 right -= 1 if s[left] not in vowels: left += 1 if s[right] not in vowels: right -= 1 return ''.join(s)"},{"question":"def has_revisited_location(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determine if the suspect revisited any location during his movements for each test case. Args: test_cases: List of tuples containing each test case. Each test case is a tuple where the first element is the number of timestamps, and the second element is a list of tuples containing the coordinates of the suspect. Returns: List of strings, where each string is \\"yes\\" if the suspect revisited any location, otherwise \\"no\\". Example: >>> has_revisited_location([(3, [(1, 2), (3, 4), (1, 2)])]) [\\"yes\\"] >>> has_revisited_location([(4, [(10, 10), (20, 20), (30, 30), (40, 40)])]) [\\"no\\"] >>> has_revisited_location([(5, [(5, 5), (5, 6), (7, 8), (8, 9), (5, 5)])]) [\\"yes\\"] pass def parse_input(input_text: str) -> List[Tuple[int, List[Tuple[int, int]]]]: Parse the input text into a list of test cases. Args: input_text: A string containing the input data. Returns: List of tuples containing each test case. Each test case is a tuple where the first element is the number of timestamps, and the second element is a list of tuples containing the coordinates of the suspect. Example: >>> parse_input(\\"1n3n1 2n3 4n1 2n\\") [(3, [(1, 2), (3, 4), (1, 2)])] pass def format_output(results: List[str]) -> str: Format the results into a single output string. Args: results: List of strings, where each string is \\"yes\\" if the suspect revisited any location, otherwise \\"no\\". Returns: A formatted string of results separated by new lines. Example: >>> format_output([\\"yes\\", \\"no\\", \\"yes\\"]) \\"yesnnonyes\\" pass def process_input_output(input_text: str) -> str: Process the input text and generate the formatted output. Args: input_text: A string containing the input data. Returns: A formatted string of results separated by new lines. Example: >>> process_input_output(\\"1n3n1 2n3 4n1 2n\\") \\"yes\\" pass","solution":"def has_revisited_location(test_cases): results = [] for case in test_cases: M = case[0] coordinates = case[1] visited = set() revisit = \\"no\\" for coordinate in coordinates: if coordinate in visited: revisit = \\"yes\\" break visited.add(coordinate) results.append(revisit) return results def parse_input(input_text): lines = input_text.strip().split('n') Q = int(lines[0]) test_cases = [] index = 1 for _ in range(Q): M = int(lines[index]) coordinates = [] for j in range(1, M + 1): x, y = map(int, lines[index + j].split()) coordinates.append((x, y)) index += M + 1 test_cases.append((M, coordinates)) return test_cases def format_output(results): return \\"n\\".join(results) def process_input_output(input_text): test_cases = parse_input(input_text) results = has_revisited_location(test_cases) return format_output(results)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a string containing a mathematical expression in infix notation and return the result as an integer. The expression can include parentheses to enforce precedence and will only contain non-negative integers and the operators +, -, *, and /. Division should be treated as integer division, rounding down towards zero. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3+5/2\\") == 5 >>> evaluate_expression(\\"(2+3)*(5-2)\\") == 15 >>> evaluate_expression(\\"(2*(3+5))/4\\") == 4 pass # Unit Tests def test_simple_addition(): assert evaluate_expression(\\"3+2\\") == 5 def test_simple_subtraction(): assert evaluate_expression(\\"3-2\\") == 1 def test_simple_multiplication(): assert evaluate_expression(\\"3*2\\") == 6 def test_simple_division(): assert evaluate_expression(\\"6/3\\") == 2 def test_mixed_operations(): assert evaluate_expression(\\"3+2*2\\") == 7 assert evaluate_expression(\\"3+5/2\\") == 5 def test_parentheses_operations(): assert evaluate_expression(\\"(2+3)*(5-2)\\") == 15 assert evaluate_expression(\\"(2*(3+5))/4\\") == 4 def test_complex_expression(): assert evaluate_expression(\\"10 + 2 * 6\\") == 22 assert evaluate_expression(\\"100 * 2 + 12\\") == 212 assert evaluate_expression(\\"100 * ( 2 + 12 )\\") == 1400 assert evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") == 100 def test_expression_with_spaces(): assert evaluate_expression(\\" 3 + 5 / 2 \\") == 5 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*(5-2))\\") == 15 assert evaluate_expression(\\"((2*(3+5))/4)\\") == 4","solution":"def evaluate_expression(expression: str) -> int: def operate(a, b, op): if op == '+': return a + b elif op == '-': return a - b elif op == '*': return a * b elif op == '/': return a // b def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_ops(operators, values): op = operators.pop() right = values.pop() left = values.pop() values.append(operate(left, right, op)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_ops(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_ops(operators, values) operators.append(expression[i]) i += 1 while operators: apply_ops(operators, values) return values[-1]"},{"question":"class ParkingLot: def __init__(self, floors, slots_per_floor): Initializes the object with the given number of floors and the number of slots per floor. pass def parkVehicle(self, vehicleID): Parks the vehicle with given ID in the first available parking slot, starting from the lowest floor. pass def removeVehicle(self, vehicleID): Removes the vehicle with the given ID from the parking lot and returns the slot ID where the vehicle was parked. Returns -1 if the vehicle is not found. pass def getSlotInfo(self, floor, slot): Returns the vehicle ID parked in a given slot on the specified floor, or \\"Empty\\" if the slot is empty. pass # Unit Tests def test_parkVehicle(): P = ParkingLot(2, 3) P.parkVehicle(1) assert P.getSlotInfo(0, 0) == 1 P.parkVehicle(2) assert P.getSlotInfo(0, 1) == 2 P.parkVehicle(3) assert P.getSlotInfo(0, 2) == 3 P.parkVehicle(4) assert P.getSlotInfo(1, 0) == 4 def test_removeVehicle(): P = ParkingLot(2, 3) P.parkVehicle(1) P.parkVehicle(2) P.parkVehicle(3) P.parkVehicle(4) assert P.removeVehicle(2) == '0_1' assert P.getSlotInfo(0, 1) == \\"Empty\\" assert P.removeVehicle(5) == -1 def test_getSlotInfo(): P = ParkingLot(2, 3) P.parkVehicle(1) assert P.getSlotInfo(0, 1) == \\"Empty\\" P.parkVehicle(2) P.parkVehicle(3) assert P.getSlotInfo(0, 2) == 3 P.parkVehicle(4) assert P.getSlotInfo(1, 0) == 4 P.removeVehicle(2) P.parkVehicle(5) assert P.getSlotInfo(0, 1) == 5 def test_integration(): P = ParkingLot(2, 3) P.parkVehicle(1) P.parkVehicle(2) P.parkVehicle(3) P.parkVehicle(4) assert P.removeVehicle(2) == '0_1' P.parkVehicle(5) assert P.getSlotInfo(0, 1) == 5 assert P.removeVehicle(5) == '0_1' assert P.getSlotInfo(0, 1) == \\"Empty\\"","solution":"class ParkingLot: def __init__(self, floors, slots_per_floor): self.floors = floors self.slots_per_floor = slots_per_floor self.parking_lot = [[\\"Empty\\" for _ in range(slots_per_floor)] for _ in range(floors)] self.vehicle_to_slot = {} def parkVehicle(self, vehicleID): for floor in range(self.floors): for slot in range(self.slots_per_floor): if self.parking_lot[floor][slot] == \\"Empty\\": self.parking_lot[floor][slot] = vehicleID self.vehicle_to_slot[vehicleID] = (floor, slot) return def removeVehicle(self, vehicleID): if vehicleID in self.vehicle_to_slot: floor, slot = self.vehicle_to_slot[vehicleID] self.parking_lot[floor][slot] = \\"Empty\\" del self.vehicle_to_slot[vehicleID] return f\\"{floor}_{slot}\\" return -1 def getSlotInfo(self, floor, slot): return self.parking_lot[floor][slot] if 0 <= floor < self.floors and 0 <= slot < self.slots_per_floor else \\"Empty\\""},{"question":"def can_form_rectangle(Q: int, queries: List[Tuple[int, List[int]]]) -> List[str]: Determine if Johny can form a rectangle with the given sticks. >>> can_form_rectangle(1, [(6, [4, 2, 4, 2, 5, 2])]) == [\\"YES\\"] >>> can_form_rectangle(1, [(5, [5, 5, 5, 5, 5])]) == [\\"YES\\"] >>> can_form_rectangle(1, [(6, [3, 4, 5, 6, 7, 8])]) == [\\"NO\\"] >>> can_form_rectangle(3, [(6, [4, 2, 4, 2, 5, 2]), (5, [5, 5, 5, 5, 5]), (6, [3, 4, 5, 6, 7, 8])]) == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_form_rectangle(Q, queries): results = [] for query in queries: M, lengths = query[0], query[1:] length_count = {} # Count the occurrences of each length for length in lengths: if length in length_count: length_count[length] += 1 else: length_count[length] = 1 pairs = 0 # Count pairs of sticks for count in length_count.values(): pairs += count // 2 if pairs >= 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class Library: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str) -> None: Adds a book to the library inventory. If the same ISBN already exists, updates the book's title and author. pass def remove_book(self, isbn: str) -> bool: Removes a book from the library inventory by its ISBN. Returns True if the book was successfully removed, and False if no book with that ISBN exists. pass def get_book(self, isbn: str) -> tuple: Retrieves the title and author of the book by its ISBN. If no book with that ISBN exists, returns (\\"Book not found\\", \\"N/A\\"). pass # Unit tests def test_add_book(): library = Library() library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\") assert library.get_book(\\"978-3-16-148410-0\\") == (\\"The Catcher in the Rye\\", \\"J.D. Salinger\\") def test_add_book_existing_isbn(): library = Library() library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\") library.add_book(\\"978-3-16-148410-0\\", \\"1984\\", \\"George Orwell\\") assert library.get_book(\\"978-3-16-148410-0\\") == (\\"1984\\", \\"George Orwell\\") def test_remove_book(): library = Library() library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\") result = library.remove_book(\\"978-3-16-148410-0\\") assert result == True assert library.get_book(\\"978-3-16-148410-0\\") == (\\"Book not found\\", \\"N/A\\") def test_remove_non_existent_book(): library = Library() result = library.remove_book(\\"978-3-16-148410-0\\") assert result == False def test_get_non_existent_book(): library = Library() assert library.get_book(\\"978-3-16-148410-0\\") == (\\"Book not found\\", \\"N/A\\")","solution":"class Library: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str) -> None: Adds a book to the library inventory. If the same ISBN already exists, it updates the book's title and author. self.inventory[isbn] = {\\"title\\": title, \\"author\\": author} def remove_book(self, isbn: str) -> bool: Removes a book from the library inventory by its ISBN. Returns True if the book was successfully removed, and False if no book with that ISBN exists. if isbn in self.inventory: del self.inventory[isbn] return True return False def get_book(self, isbn: str) -> tuple: Retrieves the title and author of the book by its ISBN. If no book with that ISBN exists, returns (\\"Book not found\\", \\"N/A\\"). if isbn in self.inventory: book = self.inventory[isbn] return (book[\\"title\\"], book[\\"author\\"]) return (\\"Book not found\\", \\"N/A\\")"},{"question":"from typing import List def find_shortest_path(N: int, M: int, A: int, B: int, K: int, edges: List[str]) -> int: Determine the shortest possible time Alex can take to travel from city A to city B without exceeding the budget for tolls. Parameters: N (int): The number of cities. M (int): The number of roads connecting cities. A (int): The starting city. B (int): The destination city. K (int): The maximum budget for tolls. edges (List[str]): List of strings where each string contains four integers u_i, v_i, t_i, l_i representing a road from city u_i to v_i with travel time t_i and toll cost l_i. Returns: int: The shortest travel time from city A to city B within the budget. If it's impossible, returns -1. Example usage: >>> N, M, A, B, K = 5, 6, 1, 5, 10 >>> edges = [ ... \\"1 2 3 2\\", ... \\"2 3 4 5\\", ... \\"2 4 2 1\\", ... \\"4 5 6 2\\", ... \\"3 5 3 8\\", ... \\"1 3 7 10\\" ... ] >>> find_shortest_path(N, M, A, B, K, edges) 11","solution":"import heapq import sys from collections import defaultdict def shortest_path_with_budget(N, M, A, B, K, roads): graph = defaultdict(list) for u, v, t, l in roads: graph[u].append((v, t, l)) graph[v].append((u, t, l)) # Using a tuple (time, current_city, money_spent) for heapq pq = [(0, A, 0)] dist = {(A, 0): 0} while pq: time, u, money_spent = heapq.heappop(pq) if u == B: return time for v, t, l in graph[u]: new_time = time + t new_money_spent = money_spent + l if new_money_spent <= K: if (v, new_money_spent) not in dist or new_time < dist[(v, new_money_spent)]: dist[(v, new_money_spent)] = new_time heapq.heappush(pq, (new_time, v, new_money_spent)) return -1 # Function to use the above for given input def find_shortest_path(N, M, A, B, K, edges): roads = [tuple(map(int, edge.split())) for edge in edges] return shortest_path_with_budget(N, M, A, B, K, roads) # Example usage: N, M, A, B, K = 5, 6, 1, 5, 10 edges = [ \\"1 2 3 2\\", \\"2 3 4 5\\", \\"2 4 2 1\\", \\"4 5 6 2\\", \\"3 5 3 8\\", \\"1 3 7 10\\" ] print(find_shortest_path(N, M, A, B, K, edges)) # Output: 11"},{"question":"from typing import List def longest_unique_substring(s: str) -> int: Given a string containing uppercase and lowercase letters, numbers, and special characters, determine the length of the longest substring that contains only unique characters (no duplicates). >>> longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> longest_unique_substring(\\"\\") == 0 # \\"\\" >>> longest_unique_substring(\\"aabbccddeeff\\") == 2 # \\"ab\\", \\"bc\\", \\"cd\\", etc. >>> longest_unique_substring(\\"abc@123\\") == 7 # \\"abc@123\\" from solution import longest_unique_substring def test_example_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 assert longest_unique_substring(\\"\\") == 0 assert longest_unique_substring(\\"aabbccddeeff\\") == 2 assert longest_unique_substring(\\"abc@123\\") == 7 def test_special_characters(): assert longest_unique_substring(\\"abc!@#abc\\") == 6 assert longest_unique_substring(\\"a!@#%^&*()\\") == 11 def test_numbers(): assert longest_unique_substring(\\"123456781234567\\") == 8 assert longest_unique_substring(\\"111223344\\") == 2 def test_mixed_characters(): assert longest_unique_substring(\\"a1!a1!\\") == 3 def test_single_characters(): assert longest_unique_substring(\\"a\\") == 1 assert longest_unique_substring(\\"1\\") == 1 assert longest_unique_substring(\\"@\\") == 1 def test_long_string(): assert longest_unique_substring(\\"a\\"*10000) == 1 assert longest_unique_substring(\\"ab\\"*5000) == 2","solution":"def longest_unique_substring(s): Given a string s, determine the length of the longest substring that contains only unique characters. if not s: return 0 max_len = 0 start = 0 char_index_map = {} for end, char in enumerate(s): if char in char_index_map: start = max(start, char_index_map[char] + 1) char_index_map[char] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def count_valid_flag_designs(m: int) -> int: Returns the number of valid flag designs with m sections where no two adjacent sections have the same color. >>> count_valid_flag_designs(1) 3 >>> count_valid_flag_designs(2) 6 >>> count_valid_flag_designs(3) 12 pass def process_input(input_data: str) -> List[int]: Processes the input data and returns the result for each test case. >>> process_input(\\"3n1n2n3\\") [3, 6, 12] >>> process_input(\\"2n4n5\\") [24, 48] pass","solution":"def count_valid_flag_designs(m): Returns the number of valid flag designs with m sections where no two adjacent sections have the same color. if m == 1: return 3 elif m == 2: return 6 # dp[i][0] will store the number of valid sequences of length i ending in Red # dp[i][1] will store the number of valid sequences of length i ending in Green # dp[i][2] will store the number of valid sequences of length i ending in Blue dp = [[0, 0, 0] for _ in range(m + 1)] # Base case: For a flag of length 1, there are 3 possibilities (R, G, B) dp[1][0] = dp[1][1] = dp[1][2] = 1 for i in range(2, m + 1): dp[i][0] = dp[i - 1][1] + dp[i - 1][2] dp[i][1] = dp[i - 1][0] + dp[i - 1][2] dp[i][2] = dp[i - 1][0] + dp[i - 1][1] return dp[m][0] + dp[m][1] + dp[m][2] def process_input(input_data): Processes the input data and returns the result for each test case. result = [] input_lines = input_data.strip().split('n') t = int(input_lines[0]) for i in range(1, t + 1): m = int(input_lines[i]) result.append(count_valid_flag_designs(m)) return result"},{"question":"def count_subarrays_with_sum(nums: List[int], k: int) -> int: Count the number of continuous subarrays whose sum is exactly k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Number of continuous subarrays with sum equal to k. >>> count_subarrays_with_sum([1, 2, 3, -2, 2], 5) == 2 >>> count_subarrays_with_sum([1, 1, 1], 2) == 2 >>> count_subarrays_with_sum([1, -1, 0], 0) == 3 >>> count_subarrays_with_sum([1], 0) == 0 >>> count_subarrays_with_sum([-1, -1, 1], 0) == 1 >>> count_subarrays_with_sum([3, 4, 7, 2, -3, 1, 4, 2], 7) == 4 >>> large_nums = [0] * 10**5 >>> count_subarrays_with_sum(large_nums, 0) == (10**5 * (10**5 + 1)) // 2","solution":"def count_subarrays_with_sum(nums, k): Count the number of continuous subarrays whose sum is exactly k. Args: nums (List[int]): List of integers. k (int): Target sum. Returns: int: Number of continuous subarrays with sum equal to k. count = 0 current_sum = 0 sum_dict = {0: 1} # Dictionary to store the prefix sums and their frequencies for num in nums: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def count_days_with_above_average_rainfall(test_cases): Determine the number of days where the amount of rainfall is strictly greater than the average amount. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of days and a list of rainfall amounts. Returns: List[int]: List of integers where each integer represents the count of days with rainfall above average for the corresponding test case. pass def process_input(input_data): Helper function to process the input data string and convert it into a list of test cases. Args: input_data (str): Raw input data as a string. Returns: List[Tuple[int, List[int]]]: Parsed test cases from the input data. pass # Example test cases def test_basic_case_1(): input_data = \\"2n5n22 25 26 24 23n3n10 15 20\\" test_cases = process_input(input_data) assert count_days_with_above_average_rainfall(test_cases) == [2, 1] def test_all_equal_rainfall(): input_data = \\"1n4n10 10 10 10\\" test_cases = process_input(input_data) assert count_days_with_above_average_rainfall(test_cases) == [0] def test_one_day_case(): input_data = \\"1n1n5\\" test_cases = process_input(input_data) assert count_days_with_above_average_rainfall(test_cases) == [0] def test_large_numbers(): input_data = \\"1n4n1000 999 1000 999\\" test_cases = process_input(input_data) assert count_days_with_above_average_rainfall(test_cases) == [2] def test_zero_rainfall(): input_data = \\"1n3n0 0 0\\" test_cases = process_input(input_data) assert count_days_with_above_average_rainfall(test_cases) == [0]","solution":"def count_days_with_above_average_rainfall(test_cases): results = [] for case in test_cases: days, rainfall_amounts = case average_rainfall = sum(rainfall_amounts) / days count = sum(1 for amount in rainfall_amounts if amount > average_rainfall) results.append(count) return results # Helper function to process input def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) rainfall_amounts = list(map(int, input_lines[index + 1].split())) test_cases.append((N, rainfall_amounts)) index += 2 return test_cases"},{"question":"def directory_files(file_paths: List[str]) -> Dict[str, List[str]]: Returns a dictionary where the keys are directory paths and the values are lists of files found in those directories. :param file_paths: List of complete file paths :return: Dictionary with directory paths as keys and file names as values >>> file_paths = [ ... \\"/home/user/documents/file1.txt\\", ... \\"/home/user/documents/file2.txt\\", ... \\"/home/user/music/song1.mp3\\", ... \\"/home/user/music/song2.mp3\\", ... \\"/home/user/music/song3.mp3\\", ... \\"/var/log/system.log\\" ... ] >>> directory_files(file_paths) { \\"/home/user/documents/\\": [\\"file1.txt\\", \\"file2.txt\\"], \\"/home/user/music/\\": [\\"song1.mp3\\", \\"song2.mp3\\", \\"song3.mp3\\"], \\"/var/log/\\": [\\"system.log\\"] }","solution":"def directory_files(file_paths): Returns a dictionary where the keys are directory paths and the values are lists of files found in those directories. :param file_paths: List of complete file paths :return: Dictionary with directory paths as keys and file names as values from collections import defaultdict import os directory_dict = defaultdict(list) for path in file_paths: directory, file = os.path.split(path) directory_dict[directory + '/'].append(file) # Ensuring directory ends with '/' character return dict(directory_dict) # Convert back to regular dict from defaultdict"},{"question":"from typing import List, Dict def frequency_counter(nums: List[int]) -> Dict[int, int]: Takes a list of integers and returns a dictionary representing the frequency count of each distinct integer in the list. >>> frequency_counter([1, 2, 2, 3, 3, 3]) {1: 1, 2: 2, 3: 3} >>> frequency_counter([4, 4, 4, 4]) {4: 4} >>> frequency_counter([]) {} >>> frequency_counter([1]) {1: 1} >>> frequency_counter([5, 5, 6, 6, 6]) {5: 2, 6: 3}","solution":"def frequency_counter(nums): Takes a list of integers and returns a dictionary representing the frequency count of each distinct integer in the list. freq_dict = {} for num in nums: if num in freq_dict: freq_dict[num] += 1 else: freq_dict[num] = 1 return freq_dict"},{"question":"def largest_prime_factor(n: int) -> int: Write a function that takes a positive integer n as an input and returns the largest prime factor of that number. A prime factor is defined as a factor that is a prime number. >>> largest_prime_factor(15) 5 >>> largest_prime_factor(21) 7 >>> largest_prime_factor(1) 1 >>> largest_prime_factor(2) 2 >>> largest_prime_factor(3) 3 >>> largest_prime_factor(4) 2 >>> largest_prime_factor(6) 3 >>> largest_prime_factor(13195) 29 >>> largest_prime_factor(29) 29 # Your code here","solution":"def largest_prime_factor(n): Returns the largest prime factor of a positive integer n. def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True largest_factor = 1 factor = 2 while factor * factor <= n: if n % factor == 0: if is_prime(factor): largest_factor = factor while n % factor == 0: n //= factor factor += 1 if n > 1 and is_prime(n): # if n is prime and greater than 1 largest_factor = n return largest_factor"},{"question":"def minimum_cost(T: int, test_cases: List[str]) -> List[int]: Determine the minimum cost required to completely remove all characters from the string for each test case. Each string S consists of lowercase English letters. Remove all occurrences of any character in a single operation. The cost associated with this operation is the unique ASCII value of the character removed. Args: T (int): The number of test cases. test_cases (List[str]): List of test case strings. Returns: List[int]: List of minimum costs for each test case. Examples: >>> minimum_cost(3, [\\"abc\\", \\"aaa\\", \\"abacaba\\"]) [294, 97, 294]","solution":"def minimum_cost(T, test_cases): result = [] for s in test_cases: unique_characters = set(s) cost = sum(ord(char) for char in unique_characters) result.append(cost) return result"},{"question":"def count_vowels(s: str) -> int: Count the number of vowels (a, e, i, o, u) in a given string, regardless of case. >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"bcdfg\\") == 0 >>> count_vowels(\\"aeiouAEIOU\\") == 10 >>> count_vowels(\\"Hello\\") == 2 >>> count_vowels(\\"WORLD\\") == 1 >>> count_vowels(\\"Python\\") == 1 >>> count_vowels(\\"Beautiful\\") == 5 >>> count_vowels(\\"a\\") == 1 >>> count_vowels(\\"A\\") == 1 >>> count_vowels(\\"b\\") == 0 >>> count_vowels(\\"B\\") == 0","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) present in the string s, regardless of case. vowels = 'aeiouAEIOU' return sum(1 for char in s if char in vowels)"},{"question":"def is_balanced_bracket_string(s: str) -> bool: Determines if the input string s is a Balanced Bracket String. >>> is_balanced_bracket_string(\\"()\\") True >>> is_balanced_bracket_string(\\"([{}])\\") True >>> is_balanced_bracket_string(\\"(]\\") False >>> is_balanced_bracket_string(\\"[(])\\") False >>> is_balanced_bracket_string(\\"[({}])\\") True","solution":"def is_balanced_bracket_string(s): Determines if the input string s is a Balanced Bracket String. bracket_stack = [] bracket_pairs = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_pairs.values(): bracket_stack.append(char) elif char in bracket_pairs: if not bracket_stack or bracket_stack[-1] != bracket_pairs[char]: return False bracket_stack.pop() else: return False return not bracket_stack"},{"question":"def format_names(names: List[str]) -> List[str]: Transforms the list of full names into the format \\"LastName, FirstName\\", removes duplicate names, and sorts the final list alphabetically by the last name. >>> format_names([\\"John Smith\\", \\"Anna Brown\\", \\"John Smith\\", \\"Emily Davis\\"]) [\\"Brown, Anna\\", \\"Davis, Emily\\", \\"Smith, John\\"] >>> format_names([\\"John Smith\\", \\"Anna Brown\\", \\"Johnny Smith\\", \\"Emily Davis\\"]) [\\"Brown, Anna\\", \\"Davis, Emily\\", \\"Smith, John\\", \\"Smith, Johnny\\"]","solution":"def format_names(names): Transforms the list of full names into the format \\"LastName, FirstName\\", removes duplicate names, and sorts the final list alphabetically by the last name. # Convert each name to \\"LastName, FirstName\\" format and use a set to remove duplicates formatted_names = {f\\"{name.split()[1]}, {name.split()[0]}\\" for name in names} # Convert the set back to a list formatted_names = list(formatted_names) # Sort the list alphabetically by the last name formatted_names.sort() return formatted_names"},{"question":"def check_possibility(nums: List[int]) -> bool: Determine if the array could become non-decreasing by modifying at most one element. :param nums: List[int] - The input array of integers. :return: bool - True if the array could become non-decreasing, False otherwise. >>> check_possibility([4, 2, 3]) True >>> check_possibility([4, 2, 1]) False >>> check_possibility([1]) True >>> check_possibility([1, 2, 3, 4, 5]) True >>> check_possibility([3, 4, 2, 3]) False >>> check_possibility([5, 7, 1, 8]) True >>> check_possibility([3, 4, 3, 4, 3]) False >>> check_possibility([2, 1]) True","solution":"def check_possibility(nums): Determine if the array could become non-decreasing by modifying at most one element. :param nums: List[int] - The input array of integers. :return: bool - True if the array could become non-decreasing, False otherwise. count = 0 # To keep track of the modifications for i in range(1, len(nums)): if nums[i] < nums[i - 1]: if count == 1: return False # More than one modification required count += 1 # Determine whether to fix nums[i-1] or nums[i] if i == 1 or nums[i] >= nums[i - 2]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"def final_position(commands: str) -> tuple: Returns the final coordinates of the robot after executing the command string. The robot can move in a 2D grid with the following three commands: - 'U' (up): Moves the robot one step upwards. - 'R' (right): Moves the robot one step to the right. - 'D' (down): Moves the robot one step downwards. The robot's initial position is at the origin (0, 0). :param commands: A string representing the commands ('U', 'R', 'D') :return: A tuple representing the final coordinates (x, y) >>> final_position(\\"UUU\\") (0, 3) >>> final_position(\\"UURRDD\\") (2, 0) >>> final_position(\\"\\") (0, 0) pass # Unit tests def test_final_position_all_up(): assert final_position(\\"UUU\\") == (0, 3) def test_final_position_up_right_down(): assert final_position(\\"UURRDD\\") == (2, 0) def test_final_position_mixed_commands(): assert final_position(\\"URURD\\") == (2, 1) def test_final_position_no_movement(): assert final_position(\\"\\") == (0, 0) def test_final_position_back_to_origin(): assert final_position(\\"UUDD\\") == (0, 0) assert final_position(\\"UDUD\\") == (0, 0) def test_final_position_left_not_allowed(): assert final_position(\\"LLLL\\") == (0, 0) def test_final_position_long_sequence(): assert final_position(\\"UR\\"*5000) == (5000, 5000) assert final_position(\\"U\\" * 10000 + \\"D\\" * 10000) == (0, 0)","solution":"def final_position(commands): Returns the final coordinates of the robot after executing the command string. :param commands: str, a string representing the commands ('U', 'R', 'D') :return: tuple, the final coordinates (x, y) x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'R': x += 1 elif command == 'D': y -= 1 return (x, y)"},{"question":"def find_dominant(lst: List[int]) -> Optional[int]: Returns the dominant integer from the list if it exists, otherwise returns None. A dominant integer is an integer that appears more than half the size of the list. >>> find_dominant([3,3,4,2,4,4,2,4,4]) == 4 >>> find_dominant([3,3,4,2,4,4,2,4]) == None >>> find_dominant([1]) == 1 >>> find_dominant([1, 2, 1, 2, 1, 2, 1]) == 1 >>> find_dominant([1, 2, 3, 1, 2, 3, 1, 2]) == None >>> find_dominant([1000000, 1000000, 1000000, 2000000, 1000000, 3000000, 1000000]) == 1000000","solution":"def find_dominant(lst): Returns the dominant integer from the list if it exists, otherwise returns None. A dominant integer is an integer that appears more than half the size of the list. threshold = len(lst) // 2 count_dict = {} for num in lst: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 if count_dict[num] > threshold: return num return None"},{"question":"def maximize_alice_sum(N: int, A: List[int]) -> int: Determine the maximum possible sum that Alice can achieve if both players play optimally. >>> maximize_alice_sum(4, [1, 2, 9, 4]) 10 >>> maximize_alice_sum(1, [5]) 5 >>> maximize_alice_sum(3, [4, 4, 4]) 8 >>> maximize_alice_sum(4, [1, 2, 3, 4]) 6 >>> maximize_alice_sum(4, [4, 3, 2, 1]) 6","solution":"def maximize_alice_sum(N, A): Determine the maximum possible sum that Alice can achieve if both players play optimally. :param N: int - the number of integers in the array :param A: list of int - the array of integers :return: int - the maximum sum that Alice can achieve dp = [[0] * N for _ in range(N)] for i in range(N): dp[i][i] = A[i] for length in range(2, N + 1): for i in range(N - length + 1): j = i + length - 1 pick_left = A[i] + (sum(A[i+1:j+1]) - dp[i+1][j]) pick_right = A[j] + (sum(A[i:j]) - dp[i][j-1]) dp[i][j] = max(pick_left, pick_right) return dp[0][N-1]"},{"question":"from typing import List, Union def fizz_buzz_transform(numbers: List[int]) -> List[Union[int, str]]: Transforms a list of integers such that: - Elements that are multiples of 3 are replaced with 'Fizz'. - Elements that are multiples of 5 are replaced with 'Buzz'. - Elements that are multiples of both 3 and 5 are replaced with 'FizzBuzz'. Args: numbers (List[int]): The input list of integers. Returns: List[Union[int, str]]: The transformed list where multiples are replaced with corresponding strings. Examples: >>> fizz_buzz_transform([1, 2, 3, 4, 5, 15, 30]) [1, 2, 'Fizz', 4, 'Buzz', 'FizzBuzz', 'FizzBuzz'] >>> fizz_buzz_transform([6, 7, 8, 9, 10]) ['Fizz', 7, 8, 'Fizz', 'Buzz']","solution":"from typing import List, Union def fizz_buzz_transform(numbers: List[int]) -> List[Union[int, str]]: Transforms a list of integers such that: - Elements that are multiples of 3 are replaced with 'Fizz'. - Elements that are multiples of 5 are replaced with 'Buzz'. - Elements that are multiples of both 3 and 5 are replaced with 'FizzBuzz'. Args: numbers (List[int]): The input list of integers. Returns: List[Union[int, str]]: The transformed list where multiples are replaced with corresponding strings. result = [] for number in numbers: if number % 3 == 0 and number % 5 == 0: result.append('FizzBuzz') elif number % 3 == 0: result.append('Fizz') elif number % 5 == 0: result.append('Buzz') else: result.append(number) return result"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups a list of strings into anagrams. :param words: List of strings :return: List of lists where each sublist contains anagrams Examples: >>> group_anagrams([\\"tar\\", \\"rat\\", \\"bats\\", \\"tabs\\", \\"stab\\", \\"cat\\", \\"act\\"]) [['tar', 'rat'], ['bats', 'tabs', 'stab'], ['cat', 'act']] >>> group_anagrams([]) [] >>> group_anagrams([\\"\\"]) [['']] >>> group_anagrams([\\"a\\"]) [['a']] from collections import defaultdict def test_group_anagrams_basic(): result = group_anagrams([\\"tar\\", \\"rat\\", \\"bats\\", \\"tabs\\", \\"stab\\", \\"cat\\", \\"act\\"]) expected = [['tar', 'rat'], ['bats', 'tabs', 'stab'], ['cat', 'act']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_empty_string(): result = group_anagrams([\\"\\"]) expected = [['']] assert result == expected def test_group_anagrams_single_char(): result = group_anagrams([\\"a\\"]) expected = [['a']] assert result == expected def test_group_anagrams_no_input(): result = group_anagrams([]) expected = [] assert result == expected def test_group_anagrams_all_anagrams(): result = group_anagrams([\\"aaa\\", \\"aaa\\"]) expected = [['aaa', 'aaa']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected]) def test_group_anagrams_mixed_size(): result = group_anagrams([\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"batman\\"]) expected = [['bat', 'tab'], ['eat', 'tea'], ['tan', 'nat'], ['batman']] assert sorted([sorted(group) for group in result]) == sorted([sorted(group) for group in expected])","solution":"from collections import defaultdict def group_anagrams(words): Groups a list of strings into anagrams. :param words: List of strings :return: List of lists where each sublist contains anagrams anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def can_play(arrangement: list) -> bool: Determines if the given music arrangement can be played without any notes overlapping. Parameters: arrangement (list): A list of strings representing the note events. Returns: bool: True if no notes overlap, False otherwise. >>> can_play([\\"3 2\\", \\"5 2\\", \\"1 2\\"]) True >>> can_play([\\"1 3\\", \\"2 2\\", \\"4 1\\"]) False >>> can_play([\\"1 1\\", \\"2 1\\", \\"3 2\\", \\"6 1\\"]) True >>> can_play([\\"1 3\\", \\"4 2\\", \\"7 1\\", \\"5 2\\"]) False >>> can_play([\\"3 2\\"]) True pass","solution":"def can_play(arrangement: list) -> bool: Determines if the given music arrangement can be played without any notes overlapping. Parameters: arrangement (list): A list of strings representing the note events. Returns: bool: True if no notes overlap, False otherwise. # Parse the arrangement into a list of tuples (note_time, note_duration) events = [] for note in arrangement: note_time, note_duration = map(int, note.split()) events.append((note_time, note_duration)) # Sort events by the start time events.sort() # Check for overlaps for i in range(1, len(events)): prev_end_time = events[i-1][0] + events[i-1][1] current_start_time = events[i][0] if current_start_time < prev_end_time: return False return True"},{"question":"def smallest_subarray_with_sum(s: int, arr: List[int]) -> int: Returns the length of the smallest contiguous subarray whose sum is greater than or equal to s. If no such subarray exists, return 0. >>> smallest_subarray_with_sum(7, [2, 3, 1, 2, 4, 3]) == 2 >>> smallest_subarray_with_sum(15, [1, 2, 3, 4, 5]) == 5 >>> smallest_subarray_with_sum(100, [1, 2, 3, 4, 5]) == 0","solution":"def smallest_subarray_with_sum(s, arr): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to s. If no such subarray exists, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"def reorderToPalindrome(s: str) -> bool: Checks whether any permutation of the input string s can form a palindrome. The check is case-insensitive. :param s: Input string :return: True if any permutation can form a palindrome, otherwise False from collections import Counter def test_reorder_to_palindrome_even_length_true(): assert reorderToPalindrome(\\"aabb\\") == True def test_reorder_to_palindrome_odd_length_true(): assert reorderToPalindrome(\\"aabbc\\") == True def test_reorder_to_palindrome_single_char(): assert reorderToPalindrome(\\"a\\") == True def test_reorder_to_palindrome_mixed_case(): assert reorderToPalindrome(\\"AabbC\\") == True def test_reorder_to_palindrome_non_palindrome(): assert reorderToPalindrome(\\"abc\\") == False def test_reorder_to_palindrome_all_same_char(): assert reorderToPalindrome(\\"aaa\\") == True def test_reorder_to_palindrome_empty_string(): assert reorderToPalindrome(\\"\\") == True def test_reorder_to_palindrome_special_characters(): assert reorderToPalindrome(\\"aAbBcC\\") == True def test_reorder_to_palindrome_special_case_false(): assert reorderToPalindrome(\\"abcd\\") == False","solution":"def reorderToPalindrome(s): Checks whether any permutation of the input string s can form a palindrome. The check is case-insensitive. :param s: Input string :return: True if any permutation can form a palindrome, otherwise False from collections import Counter # Convert the string to lowercase to make the check case-insensitive s = s.lower() # Count the frequency of each character char_count = Counter(s) # Check the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearranged into a palindrome, # there can be at most one character with an odd frequency. return odd_count <= 1"},{"question":"def is_valid_sentence(sentence: str) -> bool: Determines whether the sequence of words represents a valid sentence. For the sequence to be valid, it should follow these rules: 1. The sequence should not contain any digits. 2. Each word must start with an uppercase letter followed by only lowercase letters. 3. There should be no punctuation marks within or at the end of the words. >>> is_valid_sentence(\\"Hello World This Is A Test\\") True >>> is_valid_sentence(\\"hello World This Is A Test\\") False >>> is_valid_sentence(\\"Hello World This is A Test3\\") False","solution":"def is_valid_sentence(sentence): Returns True if the sentence is valid based on the given rules, otherwise False. # Split the sentence into words words = sentence.split() # Define the criteria for a valid word def is_valid_word(word): return word[0].isupper() and word[1:].islower() if len(word) > 1 else word.isupper() # Check each word in the sentence for word in words: if not is_valid_word(word) or any(char.isdigit() for char in word): return False return True"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([2, 4, 1, 2, 10]) 9","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def sum_even_fibonacci(n: int) -> int: Returns the sum of all even Fibonacci numbers that are less than or equal to n. >>> sum_even_fibonacci(8) --> 10 >>> sum_even_fibonacci(34) --> 44 >>> sum_even_fibonacci(1) --> 0","solution":"def sum_even_fibonacci(n): Returns the sum of all even Fibonacci numbers that are less than or equal to n. a, b = 0, 1 sum_even = 0 while a <= n: if a % 2 == 0: sum_even += a a, b = b, a + b return sum_even"},{"question":"def minimum_subset_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given n items, each represented by an integer value. The objective is to partition these items into two subsets such that the difference between the sums of the subsets is minimized. Return the minimum possible difference. >>> minimum_subset_difference(2, [(4, [1, 6, 11, 5]), (3, [1, 2, 3])]) [1, 0] >>> minimum_subset_difference(1, [(2, [3, 1])]) [2]","solution":"def find_min_subset_sum_difference(arr): Function to find the minimum possible difference between the sums of two subsets. total_sum = sum(arr) n = len(arr) # Initialize a 2D boolean array dp[][] such that dp[i][j] will be # True if there is a subset of elements from the first i elements # of arr[] with a sum equal to j. dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] # There is always a subset with 0 sum, an empty subset for i in range(n + 1): dp[i][0] = True # Fill the partition table in bottom-up manner for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the maximum j such that dp[n][j] # is true where j loops from total_sum//2 to 0 diff = float('inf') for j in range(total_sum // 2, -1, -1): if dp[n][j] == True: diff = total_sum - 2 * j break return diff def minimum_subset_difference(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] results.append(find_min_subset_sum_difference(arr)) return results"},{"question":"def merge_sorted_lists(list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into a single sorted list. Parameters: list1 (list): First sorted list of integers. list2 (list): Second sorted list of integers. Returns: list: A single sorted list containing all the integers from list1 and list2. >>> merge_sorted_lists([1, 5, 7], [2, 3, 6]) [1, 2, 3, 5, 6, 7] >>> merge_sorted_lists([], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] >>> merge_sorted_lists([-5, -3, -1, 0, 3], [-4, -2, 1, 2, 4]) [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4] >>> merge_sorted_lists([1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists([1], [2]) [1, 2] >>> list1 = list(range(1000)) >>> list2 = list(range(1000, 2000)) >>> merge_sorted_lists(list1, list2) list(range(2000))","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1 (list): First sorted list of integers. list2 (list): Second sorted list of integers. Returns: list: A single sorted list containing all the integers from list1 and list2. i, j = 0, 0 merged_list = [] while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def range_compressor(nums: List[int]) -> str: Compress a list of integers into a string representation of ranges. >>> range_compressor([1, 2, 3, 6, 7, 8, 10, 13, 14, 15, 16, 20]) '1-3, 6-8, 10, 13-16, 20' >>> range_compressor([5, 6, 7, 9, 11, 12, 13]) '5-7, 9, 11-13' >>> range_compressor([1, 3, 5, 7]) '1, 3, 5, 7' >>> range_compressor([1, 2, 3, 4, 5]) '1-5' >>> range_compressor([2, 4, 6, 8, 10]) '2, 4, 6, 8, 10' >>> range_compressor([7]) '7' >>> range_compressor([2, 3, 4, 10, 12, 13, 14, 20]) '2-4, 10, 12-14, 20' >>> range_compressor([]) ''","solution":"from typing import List def range_compressor(nums: List[int]) -> str: if not nums: return \\"\\" ranges = [] start = prev = nums[0] for num in nums[1:]: if num == prev + 1: prev = num else: if start == prev: ranges.append(str(start)) else: ranges.append(f\\"{start}-{prev}\\") start = prev = num if start == prev: ranges.append(str(start)) else: ranges.append(f\\"{start}-{prev}\\") return \\", \\".join(ranges)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largest_values_in_tree_rows(root): Determine the largest value in each row of the binary tree. :param root: The root of the binary tree :type root: TreeNode :return: A list of integers containing the largest value in each row :rtype: List[int] pass from solution import TreeNode, largest_values_in_tree_rows def test_largest_values_in_tree_rows(): # Construct the tree root = TreeNode(1) root.left = TreeNode(3) root.right = TreeNode(2) root.left.left = TreeNode(5) root.left.right = TreeNode(3) root.right.right = TreeNode(9) assert largest_values_in_tree_rows(root) == [1, 3, 9] def test_empty_tree(): assert largest_values_in_tree_rows(None) == [] def test_single_node_tree(): root = TreeNode(7) assert largest_values_in_tree_rows(root) == [7] def test_multiple_levels(): # Construct a more complex tree root = TreeNode(4) root.left = TreeNode(9) root.right = TreeNode(2) root.left.left = TreeNode(5) root.left.right = TreeNode(1) root.right.right = TreeNode(7) assert largest_values_in_tree_rows(root) == [4, 9, 7] def test_all_negative_values(): root = TreeNode(-1) root.left = TreeNode(-2) root.right = TreeNode(-3) root.left.left = TreeNode(-4) root.left.right = TreeNode(-5) root.right.right = TreeNode(-6) assert largest_values_in_tree_rows(root) == [-1, -2, -4]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right from collections import deque def largest_values_in_tree_rows(root): Return the largest values in each row of the binary tree. :param root: TreeNode root :return: List[int] largest values in each row if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"from itertools import permutations def lexicographical_permutations(S: str): Given a string S, generates all possible permutations of the string in lexicographical order and prints them. >>> lexicographical_permutations(\\"abc\\") abc acb bac bca cab cba >>> lexicographical_permutations(\\"a\\") a >>> lexicographical_permutations(\\"ba\\") ab ba","solution":"from itertools import permutations def lexicographical_permutations(S): Given a string S, generates all possible permutations of the string in lexicographical order and prints them. perms = permutations(S) sorted_perms = sorted([''.join(p) for p in perms]) for perm in sorted_perms: print(perm)"},{"question":"class CaesarCipher: Caesar Cipher is one of the simplest encryption techniques where each letter in the plaintext is shifted a certain number of places down or up the alphabet. Implement the class \`CaesarCipher\` with the following methods: 1. \`__init__(self, shift: int)\`: Initializes the cipher with a given shift. 2. \`encrypt(self, text: str) -> str\`: Encrypts the \`text\` using the initialized shift. The function should preserve the case of each letter and ignore non-alphabetic characters. 3. \`decrypt(self, text: str) -> str\`: Decrypts the \`text\` using the initialized shift. The function should preserve the case of each letter and ignore non-alphabetic characters. For example, with a shift of 3: - \`a\` becomes \`d\` - \`y\` becomes \`b\` - \`Z\` becomes \`C\` # Constraints * \`shift\` is an integer and can be any value (positive, negative, or zero). * The text can contain: * Uppercase letters (\`A\`-\`Z\`) * Lowercase letters (\`a\`-\`z\`) * Non-alphabetic characters (which should be ignored during both encryption and decryption) * The length of \`text\` will be at most \`10^4\`. # Examples >>> cipher = CaesarCipher(3) >>> cipher.encrypt(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" >>> cipher.decrypt(\\"Khoor, Zruog!\\") == \\"Hello, World!\\" >>> cipher = CaesarCipher(1) >>> cipher.encrypt(\\"Python 3.9!\\") == \\"Qzuipo 3.9!\\" >>> cipher.decrypt(\\"Qzuipo 3.9!\\") == \\"Python 3.9!\\" def __init__(self, shift: int): ... def encrypt(self, text: str) -> str: ... def decrypt(self, text: str) -> str: ... def test_encrypt(): cipher = CaesarCipher(3) assert cipher.encrypt(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" assert cipher.encrypt(\\"a b c!\\") == \\"d e f!\\" def test_decrypt(): cipher = CaesarCipher(3) assert cipher.decrypt(\\"Khoor, Zruog!\\") == \\"Hello, World!\\" assert cipher.decrypt(\\"d e f!\\") == \\"a b c!\\" def test_encrypt_with_wrap_around(): cipher = CaesarCipher(4) assert cipher.encrypt(\\"xyz\\") == \\"bcd\\" assert cipher.encrypt(\\"XYZ\\") == \\"BCD\\" def test_decrypt_with_wrap_around(): cipher = CaesarCipher(4) assert cipher.decrypt(\\"bcd\\") == \\"xyz\\" assert cipher.decrypt(\\"BCD\\") == \\"XYZ\\" def test_encrypt_negative_shift(): cipher = CaesarCipher(-3) assert cipher.encrypt(\\"abc\\") == \\"xyz\\" assert cipher.encrypt(\\"ABC\\") == \\"XYZ\\" def test_decrypt_negative_shift(): cipher = CaesarCipher(-3) assert cipher.decrypt(\\"xyz\\") == \\"abc\\" assert cipher.decrypt(\\"XYZ\\") == \\"ABC\\" def test_encrypt_decrypt_with_non_alpha(): cipher = CaesarCipher(5) encrypted = cipher.encrypt(\\"Hello, World! 123\\") decrypted = cipher.decrypt(encrypted) assert encrypted == \\"Mjqqt, Btwqi! 123\\" assert decrypted == \\"Hello, World! 123\\" def test_zero_shift(): cipher = CaesarCipher(0) assert cipher.encrypt(\\"No change!\\") == \\"No change!\\" assert cipher.decrypt(\\"No change!\\") == \\"No change!\\"","solution":"class CaesarCipher: def __init__(self, shift: int): self.shift = shift def encrypt(self, text: str) -> str: return self._shift_text(text, self.shift) def decrypt(self, text: str) -> str: return self._shift_text(text, -self.shift) def _shift_text(self, text: str, shift: int) -> str: result = [] for char in text: if char.isalpha(): shift_amount = shift % 26 if char.islower(): shifted_char = chr((ord(char) - ord('a') + shift_amount) % 26 + ord('a')) else: shifted_char = chr((ord(char) - ord('A') + shift_amount) % 26 + ord('A')) result.append(shifted_char) else: result.append(char) return ''.join(result)"},{"question":"def can_be_split_into_equal_sum_subsequences(sequence: List[int]) -> bool: Determines if the sequence can be split into two sub-sequences with equal sum. :param sequence: List of integers representing the sequence. :return: Boolean value indicating if the sequence can be split as required. >>> can_be_split_into_equal_sum_subsequences([1, 2, 3, 4, 5, 5]) == True >>> can_be_split_into_equal_sum_subsequences([1, 1, 1]) == False >>> can_be_split_into_equal_sum_subsequences([10]) == False >>> can_be_split_into_equal_sum_subsequences([5, 5]) == True >>> can_be_split_into_equal_sum_subsequences([5, 6]) == False >>> can_be_split_into_equal_sum_subsequences([2, 2, 3, 3, 4, 4, 5, 5]) == True >>> can_be_split_into_equal_sum_subsequences([2, 2, 3, 3, 4, 4, 5, 6]) == False sequence_sum = sum(sequence) # If the sum of sequence is odd, it cannot be split into two equal sum sub-sequences if sequence_sum % 2 != 0: return False target = sequence_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in sequence: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]","solution":"def can_be_split_into_equal_sum_subsequences(sequence): Determines if the sequence can be split into two sub-sequences with equal sum. :param sequence: List of integers representing the sequence. :return: Boolean value indicating if the sequence can be split as required. total_sum = sum(sequence) # If the total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(sequence) # Initialize a DP table where dp[i] will be True if a subset sum of 'i' can be formed with the elements dp = [False] * (target_sum + 1) dp[0] = True # Update the DP table for each number in the sequence for num in sequence: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"def fibonacci_sequence(n: int) -> List[int]: Given a non-negative integer n, return an array of the first n elements of the Fibonacci sequence. >>> fibonacci_sequence(1) == [0] >>> fibonacci_sequence(2) == [0, 1] >>> fibonacci_sequence(5) == [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_sequence(n): Returns an array of the first n Fibonacci numbers. if n == 0: return [] sequence = [0] if n > 1: sequence.append(1) for i in range(2, n): next_number = sequence[i - 1] + sequence[i - 2] sequence.append(next_number) return sequence"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Write a function to find the length of the longest increasing path in a given matrix of integers. The path can move in four possible directions: left, right, up, and down. You can only move to cells that have a strictly increasing value. Return 0 if the matrix is empty. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) == 4 True >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) == 4 True >>> longest_increasing_path([]) == 0 True >>> longest_increasing_path([[42]]) == 1 True >>> longest_increasing_path([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) == 1 True >>> longest_increasing_path([ ... [1, 2, 3], ... [6, 5, 4], ... [7, 8, 9] ... ]) == 9 True","solution":"from typing import List def longest_increasing_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_length = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def schedule_tasks(intervals: List[List[int]]) -> List[List[int]]: Determines if it is possible to schedule all the given tasks without any overlap. :param intervals: List of intervals where each interval is represented as [start, end] :return: A list of non-overlapping intervals if possible, otherwise an empty list. >>> schedule_tasks([[1, 3], [2, 4], [3, 5]]) [] >>> schedule_tasks([[7, 10], [2, 4]]) [[2, 4], [7, 10]] >>> schedule_tasks([[1, 3], [5, 8], [4, 5], [9, 10]]) [[1, 3], [4, 5], [5, 8], [9, 10]]","solution":"def schedule_tasks(intervals): Determines if it is possible to schedule all the given tasks without any overlap. :param intervals: List of intervals where each interval is represented as [start, end] :return: A list of non-overlapping intervals if possible, otherwise an empty list. if not intervals: return [] # Sort intervals by their ending times intervals.sort(key=lambda x: x[1]) result = [] last_end_time = 0 for interval in intervals: if interval[0] >= last_end_time: result.append(interval) last_end_time = interval[1] else: return [] return result"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams together from the input list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: The grouped anagrams, each sublist sorted lexicographically. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] >>> group_anagrams([\\"cat\\", \\"dog\\", \\"god\\", \\"tac\\", \\"act\\", \\"rat\\"]) [['act', 'cat', 'tac'], ['dog', 'god'], ['rat']] def test_group_anagrams_basic(): assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [['ate', 'eat', 'tea'], ['bat'], ['nat', 'tan']] def test_group_anagrams_empty_list(): assert group_anagrams([]) == [] def test_group_anagrams_no_anagrams(): assert group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) == [['abc'], ['def'], ['ghi']] def test_group_anagrams_all_anagrams(): assert group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"]) == [['enlist', 'listen', 'silent']] def test_group_anagrams_mixed_case(): assert group_anagrams([\\"a\\", \\"b\\", \\"a\\", \\"c\\"]) == [['a', 'a'], ['b'], ['c']] def test_group_anagrams_extended(): assert group_anagrams([\\"cat\\", \\"dog\\", \\"god\\", \\"tac\\", \\"act\\", \\"rat\\"]) == [['act', 'cat', 'tac'], ['dog', 'god'], ['rat']]","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams together from the input list of words. Parameters: words (list of str): The list of words to group. Returns: list of list of str: The grouped anagrams, each sublist sorted lexicographically. anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Prepare the final output by sorting each group and then the list of groups. result = [sorted(group) for group in anagrams.values()] result.sort() return result"},{"question":"def min_moves_to_increasing(N: int, A: List[int]) -> int: Determines the minimum number of moves required to make the array strictly increasing by removing the minimum number of elements. Parameters: - N: int, the length of the array - A: list of int, the array of integers Returns: - int, the minimum number of moves required >>> min_moves_to_increasing(5, [3, 2, 1, 4, 5]) 2 >>> min_moves_to_increasing(4, [1, 2, 3, 4]) 0 >>> min_moves_to_increasing(4, [4, 3, 2, 1]) 3","solution":"def min_moves_to_increasing(N, A): Determines the minimum number of moves required to make the array strictly increasing by removing the minimum number of elements. Parameters: - N: int, the length of the array - A: list of int, the array of integers Returns: - int, the minimum number of moves required # Longest Increasing Subsequence (LIS) problem from bisect import bisect_left lis = [] for a in A: pos = bisect_left(lis, a) if pos < len(lis): lis[pos] = a else: lis.append(a) # Minimum moves to make array strictly increasing = N - length of LIS return N - len(lis)"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of strings words and a string pattern, return a list of words[i] that match the given pattern. A word matches the pattern if there exists a permutation of letters p so that after substituting every letter x in the pattern with p(x), we get the desired word. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"ccc\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"aaa\\", \\"bbb\\"], \\"ccc\\") [\\"aaa\\", \\"bbb\\"] >>> find_and_replace_pattern([], \\"abb\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"xyz\\", \\"abz\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"abcd\\", \\"ab\\", \\"xyz\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"aaa\\", \\"bbb\\", \\"abc\\"], \\"aaa\\") [\\"aaa\\", \\"bbb\\"]","solution":"def find_and_replace_pattern(words, pattern): def encode(word): mapping = {} encoded_word = [] next_code = 0 for char in word: if char not in mapping: mapping[char] = str(next_code) next_code += 1 encoded_word.append(mapping[char]) return \\" \\".join(encoded_word) encoded_pattern = encode(pattern) return [word for word in words if encode(word) == encoded_pattern]"},{"question":"def deepClone(obj): Perform a deep clone of an object or an array. The function should handle nested objects and arrays, even when mixed together. The original input must remain unmodified. Parameters: obj (any): The object or array to be cloned. Returns: any: A deep clone of the input object or array. Example: >>> input_obj = { ... 'a': 1, ... 'b': [2, 3, {'c': 4}], ... 'd': {'e': 5, 'f': [6, 7], 'g': {'h': 8}} ... } >>> cloned_obj = deepClone(input_obj) >>> cloned_obj['b'][2]['c'] = 42 >>> cloned_obj['d']['g']['h'] = 99 >>> input_obj {'a': 1, 'b': [2, 3, {'c': 4}], 'd': {'e': 5, 'f': [6, 7], 'g': {'h': 8}}} >>> cloned_obj {'a': 1, 'b': [2, 3, {'c': 42}], 'd': {'e': 5, 'f': [6, 7], 'g': {'h': 99}}} pass from deepClone import deepClone def test_deepClone_basic_dictionary(): input_data = {\\"x\\": 1, \\"y\\": 2} cloned_data = deepClone(input_data) cloned_data[\\"x\\"] = 42 assert input_data == {\\"x\\": 1, \\"y\\": 2} assert cloned_data == {\\"x\\": 42, \\"y\\": 2} def test_deepClone_basic_list(): input_data = [1, 2, 3] cloned_data = deepClone(input_data) cloned_data[0] = 42 assert input_data == [1, 2, 3] assert cloned_data == [42, 2, 3] def test_deepClone_nested_structure(): input_data = {\\"a\\": 1, \\"b\\": [2, {\\"c\\": 3}]} cloned_data = deepClone(input_data) cloned_data[\\"b\\"][1][\\"c\\"] = 42 assert input_data == {\\"a\\": 1, \\"b\\": [2, {\\"c\\": 3}]} assert cloned_data == {\\"a\\": 1, \\"b\\": [2, {\\"c\\": 42}]} def test_deepClone_empty_structure(): input_data = {} cloned_data = deepClone(input_data) assert input_data == {} assert cloned_data == {} input_data = [] cloned_data = deepClone(input_data) assert input_data == [] assert cloned_data == [] def test_deepClone_multilevel_structure(): input_data = {\\"x\\": [1, {\\"y\\": [2, [3]]}], \\"z\\": 4} cloned_data = deepClone(input_data) cloned_data[\\"x\\"][1][\\"y\\"][1][0] = 42 assert input_data == {\\"x\\": [1, {\\"y\\": [2, [3]]}], \\"z\\": 4} assert cloned_data == {\\"x\\": [1, {\\"y\\": [2, [42]]}], \\"z\\": 4} def test_deepClone_mixed_list_and_dict(): input_data = [1, {\\"a\\": 2, \\"b\\": [3, 4], \\"c\\": {\\"d\\": 5}}] cloned_data = deepClone(input_data) cloned_data[1][\\"b\\"][0] = 99 cloned_data[1][\\"c\\"][\\"d\\"] = 100 assert input_data == [1, {\\"a\\": 2, \\"b\\": [3, 4], \\"c\\": {\\"d\\": 5}}] assert cloned_data == [1, {\\"a\\": 2, \\"b\\": [99, 4], \\"c\\": {\\"d\\": 100}}]","solution":"def deepClone(obj): Perform a deep clone of an object or an array. Parameters: obj (any): The object or array to be cloned. Returns: any: A deep clone of the input object or array. if isinstance(obj, dict): return {key: deepClone(value) for key, value in obj.items()} elif isinstance(obj, list): return [deepClone(item) for item in obj] else: return obj"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if the given list can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) == True >>> can_partition([1, 2, 3, 5]) == False # Your code here # Unit tests def test_example_1(): assert can_partition([1, 5, 11, 5]) == True def test_example_2(): assert can_partition([1, 2, 3, 5]) == False def test_single_element(): assert can_partition([1]) == False def test_two_equal_elements(): assert can_partition([2, 2]) == True def test_odd_total_sum(): assert can_partition([1, 2, 4]) == False def test_large_input(): large_input = [1]*100 + [2]*50 assert can_partition(large_input) == True def test_no_partition_possible(): input_data = [1, 1, 1, 1, 1, 10] assert can_partition(input_data) == False","solution":"def can_partition(nums): Determines if the given list can be partitioned into two subsets with equal sum. total_sum = sum(nums) # If the total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def trap_rainwater(heights): Calculate the trapped rainwater given a list of building heights. :param heights: List of non-negative integers representing the heights of the buildings :return: Total amount of trapped water >>> trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rainwater([4,2,0,3,2,5]) 9 >>> trap_rainwater([0,0,0,0]) 0 >>> trap_rainwater([3, 0, 0, 2, 0, 4]) 10","solution":"def trap_rainwater(heights): Calculate the trapped rainwater given a list of building heights. :param heights: List of non-negative integers representing the heights of the buildings :return: Total amount of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"class BookInventory: An online bookstore maintains an inventory system that handles various operations related to book stock management. There will be 5 different types of operations: 1. **ADD Book**: Given a book ID and a quantity, add the quantity to the stock of that book. If the book does not exist, add a new entry for it. 2. **REMOVE Book**: Given a book ID and a quantity, decrease the quantity from the stock of that book. If the remaining quantity falls to zero or below, remove the book from the inventory. 3. **CHECK Stock**: Given a book ID, return the current stock quantity of that book. If the book is not present in inventory, return \\"NOT AVAILABLE\\". 4. **MAX Stock**: Return the book ID with the maximum stock quantity. If there are multiple books with the same maximum quantity, return the smallest ID. 5. **MIN Stock**: Return the book ID with the minimum stock quantity. If there are multiple books with the same minimum quantity, return the smallest ID. >>> inventory = BookInventory() >>> inventory.add_book(1001, 50) >>> inventory.add_book(1002, 75) >>> inventory.check_stock(1001) 50 >>> inventory.remove_book(1002, 50) >>> inventory.check_stock(1002) 25 >>> inventory.max_stock() 1001 >>> inventory.min_stock() 1002 def add_book(self, book_id, quantity): Given a book ID and a quantity, add the quantity to the stock of that book. If the book does not exist, add a new entry for it. pass def remove_book(self, book_id, quantity): Given a book ID and a quantity, decrease the quantity from the stock of that book. If the remaining quantity falls to zero or below, remove the book from the inventory. pass def check_stock(self, book_id): Given a book ID, return the current stock quantity of that book. If the book is not present in inventory, return 'NOT AVAILABLE'. pass def max_stock(self): Return the book ID with the maximum stock quantity. If there are multiple books with the same maximum quantity, return the smallest ID. pass def min_stock(self): Return the book ID with the minimum stock quantity. If there are multiple books with the same minimum quantity, return the smallest ID. pass import pytest def test_add_book(): inventory = BookInventory() inventory.add_book(1001, 50) inventory.add_book(1002, 75) assert inventory.check_stock(1001) == 50 assert inventory.check_stock(1002) == 75 inventory.add_book(1001, 25) assert inventory.check_stock(1001) == 75 def test_remove_book(): inventory = BookInventory() inventory.add_book(1002, 75) inventory.remove_book(1002, 50) assert inventory.check_stock(1002) == 25 inventory.remove_book(1002, 25) assert inventory.check_stock(1002) == \\"NOT AVAILABLE\\" def test_check_stock(): inventory = BookInventory() inventory.add_book(1001, 75) assert inventory.check_stock(1001) == 75 assert inventory.check_stock(1002) == \\"NOT AVAILABLE\\" def test_max_stock(): inventory = BookInventory() inventory.add_book(1001, 50) inventory.add_book(1002, 75) inventory.add_book(1003, 75) assert inventory.max_stock() == 1002 def test_min_stock(): inventory = BookInventory() inventory.add_book(1001, 75) inventory.add_book(1002, 50) inventory.add_book(1003, 50) assert inventory.min_stock() == 1002","solution":"class BookInventory: def __init__(self): self.inventory = {} def add_book(self, book_id, quantity): if book_id in self.inventory: self.inventory[book_id] += quantity else: self.inventory[book_id] = quantity def remove_book(self, book_id, quantity): if book_id in self.inventory: self.inventory[book_id] -= quantity if self.inventory[book_id] <= 0: del self.inventory[book_id] def check_stock(self, book_id): return self.inventory.get(book_id, \\"NOT AVAILABLE\\") def max_stock(self): if not self.inventory: return \\"NOT AVAILABLE\\" max_quantity = max(self.inventory.values()) max_books = [book_id for book_id, quantity in self.inventory.items() if quantity == max_quantity] return min(max_books) def min_stock(self): if not self.inventory: return \\"NOT AVAILABLE\\" min_quantity = min(self.inventory.values()) min_books = [book_id for book_id, quantity in self.inventory.items() if quantity == min_quantity] return min(min_books)"},{"question":"from typing import List def find_anagrams(words_list: List[str]) -> List[List[str]]: Given a list of strings \`words_list\`, group and return the anagrams together. An anagram is a word formed by rearranging the letters of another, such as \\"eat\\", \\"tea\\", and \\"ate\\". The function should return a list of lists, each containing words that are anagrams of each other. The order of the groups and the order of words within each group does not matter. >>> find_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> find_anagrams([\\"\\"]) [[\\"\\"]] >>> find_anagrams([\\"a\\"]) [[\\"a\\"]]","solution":"from typing import List from collections import defaultdict def find_anagrams(words_list: List[str]) -> List[List[str]]: Groups the anagrams together. Args: words_list: List of strings. Returns: List of lists, where each list contains words that are anagrams of each other. anagrams = defaultdict(list) for word in words_list: # Sort the word and use it as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"def merge_lists(lst1, lst2): Merges two sorted lists into one sorted list. Args: lst1: List of sorted integers. lst2: List of sorted integers. Returns: A new list containing all the elements from input lists, sorted in ascending order. pass # Test Cases def test_merge_sorted_lists(): assert merge_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_lists([1, 3, 5], []) == [1, 3, 5] assert merge_lists([], [2, 4, 6]) == [2, 4, 6] assert merge_lists([], []) == [] def test_merge_with_duplicates(): assert merge_lists([1, 2, 3], [2, 2, 4]) == [1, 2, 2, 2, 3, 4] def test_merge_negative_numbers(): assert merge_lists([-3, -1, 0], [-2, 1, 2]) == [-3, -2, -1, 0, 1, 2] def test_merge_single_item_lists(): assert merge_lists([1], [2]) == [1, 2] def test_merge_large_numbers(): assert merge_lists([1000000], [999999, 1000001]) == [999999, 1000000, 1000001]","solution":"def merge_lists(lst1, lst2): Merges two sorted lists into one sorted list. Args: lst1: List of sorted integers. lst2: List of sorted integers. Returns: A new list containing all the elements from input lists, sorted in ascending order. merged_list = [] i = j = 0 while i < len(lst1) and j < len(lst2): if lst1[i] < lst2[j]: merged_list.append(lst1[i]) i += 1 else: merged_list.append(lst2[j]) j += 1 # Append remaining elements of lst1, if any while i < len(lst1): merged_list.append(lst1[i]) i += 1 # Append remaining elements of lst2, if any while j < len(lst2): merged_list.append(lst2[j]) j += 1 return merged_list"},{"question":"def calculate_cashback(total_spending: int, cashback_info: dict) -> float: Calculate the cashback amount based on the spending and cashback tiers. Parameters: total_spending (int): The total amount spent by the customer. cashback_info (dict): A dictionary containing the tier thresholds and cashback percentages. Returns: float: The cashback amount. >>> calculate_cashback(800, { \\"Silver\\": 1000, \\"Gold\\": 5000, \\"BronzeCashback\\": 1, \\"SilverCashback\\": 2, \\"GoldCashback\\": 5 }) 8.0 >>> calculate_cashback(1200, { \\"Silver\\": 1000, \\"Gold\\": 5000, \\"BronzeCashback\\": 1, \\"SilverCashback\\": 2, \\"GoldCashback\\": 5 }) 24.0 >>> calculate_cashback(6000, { \\"Silver\\": 2000, \\"Gold\\": 4000, \\"BronzeCashback\\": 0.5, \\"SilverCashback\\": 1.5, \\"GoldCashback\\": 4 }) 240.0","solution":"def calculate_cashback(total_spending, cashback_info): Calculate the cashback amount based on the spending and cashback tiers. Parameters: total_spending (int): The total amount spent by the customer. cashback_info (dict): A dictionary containing the tier thresholds and cashback percentages. Returns: float: The cashback amount. silver_threshold = cashback_info['Silver'] gold_threshold = cashback_info['Gold'] if total_spending >= gold_threshold: cashback_percentage = cashback_info['GoldCashback'] elif total_spending >= silver_threshold: cashback_percentage = cashback_info['SilverCashback'] else: cashback_percentage = cashback_info['BronzeCashback'] cashback_amount = total_spending * (cashback_percentage / 100.0) return cashback_amount"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def contains(self, key): Checks if the tree contains the key >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(5) >>> bst.insert(15) >>> bst.contains(10) True >>> bst.contains(7) False def getHeight(self): Returns the height of the tree >>> bst = BinarySearchTree() >>> bst.getHeight() -1 >>> bst.insert(10) >>> bst.getHeight() 0 >>> bst.insert(5) >>> bst.insert(15) >>> bst.getHeight() 1","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert_recursive(node.right, key) def contains(self, key): # Checks if the tree contains the key return self._contains_recursive(self.root, key) def _contains_recursive(self, node, key): if node is None: return False if node.val == key: return True elif node.val > key: return self._contains_recursive(node.left, key) else: return self._contains_recursive(node.right, key) def getHeight(self): # Returns the height of the tree return self._getHeight_recursive(self.root) def _getHeight_recursive(self, node): if node is None: return -1 # height of empty tree is -1 else: left_height = self._getHeight_recursive(node.left) right_height = self._getHeight_recursive(node.right) return 1 + max(left_height, right_height)"},{"question":"from typing import List def string_permutations(s: str) -> List[str]: Returns all the unique permutations of the characters in the string sorted in lexicographical order. >>> string_permutations('abc') ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> string_permutations('aab') ['aab', 'aba', 'baa'] pass","solution":"from itertools import permutations def string_permutations(s): Returns all the unique permutations of the characters in the string sorted in lexicographical order. perms = sorted(set(permutations(s))) return [''.join(p) for p in perms]"},{"question":"def min_add_to_make_valid(s: str) -> int: Given a string containing only the characters '(' and ')', determine the minimum number of parentheses needed to be added to make the string valid. A string of parentheses is valid if: - It is the empty string, or - It can be written as AB (A concatenated with B), where A and B are valid strings, or - It can be written as (A), where A is a valid string. Args: s (str): The input string containing only '(' and ')' characters. Returns: int: The minimum number of parentheses to be added to make the string valid. Examples: >>> min_add_to_make_valid(\\"())\\") 1 >>> min_add_to_make_valid(\\"(((\\") 3 >>> min_add_to_make_valid(\\"(())\\") 0 >>> min_add_to_make_valid(\\"())((())\\") 2 pass # Test cases def test_min_add_to_make_valid_case1(): assert min_add_to_make_valid(\\"())\\") == 1 def test_min_add_to_make_valid_case2(): assert min_add_to_make_valid(\\"(((\\") == 3 def test_min_add_to_make_valid_case3(): assert min_add_to_make_valid(\\"(())\\") == 0 def test_min_add_to_make_valid_case4(): assert min_add_to_make_valid(\\"())((())\\") == 2 def test_min_add_to_make_valid_empty_string(): assert min_add_to_make_valid(\\"\\") == 0 def test_min_add_to_make_valid_already_valid(): assert min_add_to_make_valid(\\"()()\\") == 0 def test_min_add_to_make_valid_complex_case(): assert min_add_to_make_valid(\\"((())(())((())\\") == 2","solution":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses to be added to make the string valid. left_needed = 0 right_needed = 0 for char in s: if char == '(': left_needed += 1 elif char == ')': if left_needed > 0: left_needed -= 1 else: right_needed += 1 return left_needed + right_needed"},{"question":"def check_subarray_sum(nums, k): Determine if the array contains a contiguous subarray of length at least 2 that sums up to a multiple of k. Args: nums (List[int]): Array of integers k (int): A positive integer Returns: bool: True if such a subarray exists, False otherwise Examples: >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False","solution":"def check_subarray_sum(nums, k): Determine if the array contains a contiguous subarray of length at least 2 that sums up to a multiple of k. # Dictionary to store remainder and the corresponding index rem_map = {0: -1} current_sum = 0 for i, num in enumerate(nums): current_sum += num rem = current_sum % k if rem in rem_map: if i - rem_map[rem] > 1: return True else: rem_map[rem] = i return False"},{"question":"def smallest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the smallest substring of \`s\` that contains at least \`k\` distinct characters. Args: s (str): A string composed of lowercase alphabets. k (int): A positive integer. Returns: int: Length of the smallest substring that contains at least \`k\` distinct characters, or \`-1\` if no such substring exists. >>> smallest_substring_with_k_distinct(\\"abcba\\", 3) 3 >>> smallest_substring_with_k_distinct(\\"aaabbb\\", 4) -1","solution":"def smallest_substring_with_k_distinct(s, k): if k > len(set(s)): return -1 n = len(s) min_len = n + 1 char_count = {} left = 0 for right in range(n): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) >= k: min_len = min(min_len, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_len if min_len <= n else -1"},{"question":"def sum_prime_factors(n: int) -> int: Returns the sum of the distinct prime factors of n. >>> sum_prime_factors(28) 9 >>> sum_prime_factors(29) 29 >>> sum_prime_factors(1) 0 >>> sum_prime_factors(0) 0 >>> sum_prime_factors(2) 2 >>> sum_prime_factors(4) 2 >>> sum_prime_factors(60) 10 >>> sum_prime_factors(100) 7 >>> sum_prime_factors(13195) 54","solution":"def sum_prime_factors(n: int) -> int: Returns the sum of the distinct prime factors of n. if n <= 1: return 0 prime_factors = set() divisor = 2 while n % divisor == 0: # handle smallest prime factor separately prime_factors.add(divisor) n //= divisor divisor = 3 while n != 1 and divisor * divisor <= n: while n % divisor == 0: prime_factors.add(divisor) n //= divisor divisor += 2 if n > 1: # This means n itself is a prime number prime_factors.add(n) return sum(prime_factors)"},{"question":"def second_largest_distinct(arr: List[int]) -> int: Given an array of integers, returns the second largest distinct element. If the array does not contain at least two distinct elements, return -1. >>> second_largest_distinct([1, 2, 3, 4, 5]) 4 >>> second_largest_distinct([5, 5, 5, 5]) -1 >>> second_largest_distinct([10, 9, 8, 8]) 9 >>> second_largest_distinct([2]) -1 >>> second_largest_distinct([-3, -2, -1, 0]) -1","solution":"def second_largest_distinct(arr): Returns the second largest distinct element in the array. If the array does not contain at least two distinct elements, return -1. distinct_elements = list(set(arr)) # Convert to a set to get distinct elements and then back to list if len(distinct_elements) < 2: return -1 distinct_elements.sort(reverse=True) # Sort the distinct elements in descending order return distinct_elements[1] # Return the second largest element"},{"question":"def two_sum(nums, target): Given a list of integers nums and a target integer target, return the indices of the two numbers that add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: >>> two_sum([2, 7, 11, 15], 9) [0, 1] Example 2: >>> two_sum([3, 2, 4], 6) [1, 2] Example 3: >>> two_sum([3, 3], 6) [0, 1] Args: nums (list): List of integers. target (int): Target integer. Returns: list: Indices of the two numbers that add up to the target. from solution import two_sum def test_example1(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] def test_example2(): assert two_sum([3, 2, 4], 6) == [1, 2] def test_example3(): assert two_sum([3, 3], 6) == [0, 1] def test_large_numbers(): assert two_sum([1000000, 2000000, 3000000, 1000001], 2000001) == [0, 3] def test_negative_numbers(): assert two_sum([-2, 7, 11, -15], -17) == [0, 3] def test_mixed_numbers(): assert two_sum([-1, 1, 2, -2], 0) == [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Given an array of integers nums and an integer target, return all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < nums.length, a, b, c, and d are distinct, and nums[a] + nums[b] + nums[c] + nums[d] == target. >>> sorted(four_sum([1, 0, -1, 0, -2, 2], 0)) == sorted([[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]) True >>> sorted(four_sum([2, 2, 2, 2, 2], 8)) == sorted([[2, 2, 2, 2]]) True >>> four_sum([], 0) [] >>> four_sum([0,0,0,0], 1) [] >>> four_sum([1, 2, 3, 4], 50) [] >>> four_sum([5, 5, 5, 5], 5) [] >>> four_sum([-2, -1, 0, 1, 2], 0) [[-2, -1, 1, 2]] >>> sorted(four_sum([1, 1, 1, 1], 4)) [[1, 1, 1, 1]] >>> sorted(four_sum([1, 2, 3, 4, 5, 6], 10)) [[1, 2, 3, 4]]","solution":"def four_sum(nums, target): Returns unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that they sum up to the target. nums.sort() quadruplets = set() n = len(nums) for i in range(n): for j in range(i + 1, n): left = j + 1 right = n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return [list(quad) for quad in quadruplets]"},{"question":"from typing import List def maximalRectangle(matrix: List[str]) -> int: Given a 2D grid of characters numRows x numCols, find the largest rectangle containing only '1's and return its area. >>> maximalRectangle([\\"10100\\", \\"10111\\", \\"11111\\", \\"10010\\"]) 6 >>> maximalRectangle([\\"1111\\"]) 4 >>> maximalRectangle([\\"1\\", \\"1\\", \\"0\\", \\"1\\"]) 2 >>> maximalRectangle([\\"1\\"]) 1 >>> maximalRectangle([\\"0\\"]) 0 >>> maximalRectangle([\\"01\\", \\"10\\"]) 1 >>> maximalRectangle([]) 0 >>> maximalRectangle([\\"\\"]) 0","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 height = [0] * (len(matrix[0]) + 1) for row in matrix: for i in range(len(matrix[0])): if row[i] == '1': height[i] += 1 else: height[i] = 0 stack = [-1] for i in range(len(height)): while height[i] < height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def parity_array(arr): Returns a new array that contains the parity of each element in the input array. The parity of a number is 0 if it is even, and 1 if it is odd. Args: arr (list): A list of integers. Returns: list: A list of integers where even numbers are replaced with 0 and odd numbers are replaced with 1. >>> parity_array([1, 2, 3, 4, 5]) [1, 0, 1, 0, 1] >>> parity_array([10, 21, 32]) [0, 1, 0]","solution":"def parity_array(arr): Returns a new array that contains the parity of each element in the input array. The parity of a number is 0 if it is even, and 1 if it is odd. Args: arr (list): A list of integers. Returns: list: A list of integers where even numbers are replaced with 0 and odd numbers are replaced with 1. return [0 if x % 2 == 0 else 1 for x in arr]"},{"question":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def merge_trees(tree1: TreeNode, tree2: TreeNode) -> List[int]: Given two balanced binary search trees, return a merged list of all nodes in ascending order. >>> # Constructing tree1 >>> tree1 = TreeNode(2) >>> tree1.left = TreeNode(1) >>> tree1.right = TreeNode(3) >>> # Constructing tree2 >>> tree2 = TreeNode(7) >>> tree2.left = TreeNode(6) >>> tree2.right = TreeNode(8) >>> merge_trees(tree1, tree2) [1, 2, 3, 6, 7, 8] >>> # Constructing tree1 >>> tree1 = TreeNode(4) >>> tree1.left = TreeNode(2) >>> tree1.right = TreeNode(6) >>> tree1.left.left = TreeNode(1) >>> tree1.left.right = TreeNode(3) >>> tree1.right.left = TreeNode(5) >>> tree1.right.right = TreeNode(7) >>> # Constructing tree2 >>> tree2 = TreeNode(10) >>> tree2.left = TreeNode(8) >>> tree2.right = TreeNode(12) >>> tree2.left.left = TreeNode(7) >>> tree2.left.right = TreeNode(9) >>> tree2.right.left = TreeNode(11) >>> tree2.right.right = TreeNode(13) >>> merge_trees(tree1, tree2) [1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13] >>> merge_trees(None, None) [] >>> merge_trees(TreeNode(1), None) [1] >>> merge_trees(None, TreeNode(1)) [1] >>> tree1 = TreeNode(5) >>> tree2 = TreeNode(10) >>> merge_trees(tree1, tree2) [5, 10] >>> # Constructing a left-heavy tree1 >>> tree1 = TreeNode(5) >>> tree1.left = TreeNode(3) >>> tree1.left.left = TreeNode(2) >>> tree1.left.left.left = TreeNode(1) >>> # Constructing a left-heavy tree2 >>> tree2 = TreeNode(15) >>> tree2.left = TreeNode(12) >>> tree2.left.left = TreeNode(10) >>> merge_trees(tree1, tree2) [1, 2, 3, 5, 10, 12, 15]","solution":"from typing import List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def merge_trees(tree1: TreeNode, tree2: TreeNode) -> List[int]: def inorder_traversal(root: TreeNode) -> List[int]: if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) # Get the sorted lists from both trees using in-order traversal list1 = inorder_traversal(tree1) list2 = inorder_traversal(tree2) # Merge the two sorted lists merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def is_valid_anagram(words: List[str], anagram: str) -> bool: Given a list of words and a scrambled version of those words (anagram), determine if the scrambled version is a valid anagram of the concatenation of the words in the list. Args: words (List[str]): A list of words. anagram (str): A scrambled version of the concatenated words. Returns: bool: True if the anagram is valid, otherwise False. >>> is_valid_anagram([\\"listen\\", \\"silent\\"], \\"enlistensilt\\") True >>> is_valid_anagram([\\"hello\\", \\"world\\"], \\"helloworld\\") True >>> is_valid_anagram([\\"rat\\", \\"tar\\"], \\"arttar\\") True >>> is_valid_anagram([\\"anagram\\", \\"test\\"], \\"magtsetanara\\") False >>> is_valid_anagram([\\"a\\"], \\"b\\") False","solution":"from collections import Counter def is_valid_anagram(words, anagram): Given a list of words and a scrambled version of those words (anagram), determine if the scrambled version is a valid anagram of the concatenation of the words in the list. Args: words (List[str]): A list of words. anagram (str): A scrambled version of the concatenated words. Returns: bool: True if the anagram is valid, otherwise False. concatenated_words = ''.join(words) # Check if the lengths of the concatenated words and anagram match if len(concatenated_words) != len(anagram): return False # Check if both have identical character counts return Counter(concatenated_words) == Counter(anagram)"},{"question":"def number_pyramid(n: int) -> str: Generate a pyramid of numbers with n levels. Parameters: n (int): Number of levels for the pyramid Returns: str: The formatted number pyramid as a string >>> number_pyramid(3) ' 1 n 121 n12321' >>> number_pyramid(5) ' 1 n 121 n 12321 n 1234321 n123454321' >>> number_pyramid(0) '' >>> number_pyramid(-1) ''","solution":"def number_pyramid(n): Generate a pyramid of numbers with n levels. Parameters: n (int): Number of levels for the pyramid Returns: str: The formatted number pyramid as a string if n <= 0: return \\"\\" # Create the pyramid string pyramid = [] for i in range(1, n + 1): # Construct the left part of the line (1 to i) left_part = ''.join(str(x) for x in range(1, i + 1)) # Construct the right part of the line (i-1 down to 1) right_part = ''.join(str(x) for x in range(i - 1, 0, -1)) # Combine both parts line = left_part + right_part # Center the line according to the base width pyramid.append(line.center(2 * n - 1)) return 'n'.join(pyramid)"},{"question":"def max_cards(n: int, cards: List[int]) -> int: Returns the maximum number of cards that can be collected in increasing order of their values. Parameters: n (int): The number of cards available. cards (List[int]): A list of integers representing the value of each card in the order they are presented. Returns: int: The maximum number of cards a player can collect in increasing order of their values. Example: >>> max_cards(6, [3, 1, 2, 5, 6, 4]) 4 >>> max_cards(1, [100]) 1 >>> max_cards(5, [1, 2, 3, 4, 5]) 5","solution":"def max_cards(n, cards): Returns the maximum number of cards that can be collected in increasing order of their values. # Initialize the length of longest increasing subsequence (LIS) from bisect import bisect_left lis = [] for card in cards: pos = bisect_left(lis, card) if pos == len(lis): lis.append(card) else: lis[pos] = card return len(lis)"},{"question":"def unique_bird_species_count(n: int, bird_ids: List[int]) -> int: Returns the count of unique bird species based on the list of bird IDs. Parameters: n (int): The number of bird sightings noted down. bird_ids (list): A list of integers representing the IDs of the species of birds spotted. Returns: int: The count of unique bird species. >>> unique_bird_species_count(7, [1, 2, 3, 4, 2, 3, 5]) 5 >>> unique_bird_species_count(5, [1, 2, 3, 4, 5]) 5 >>> unique_bird_species_count(4, [3, 3, 3, 3]) 1 >>> unique_bird_species_count(6, [1, 2, 1, 2, 1, 2]) 2 >>> unique_bird_species_count(10**6, list(range(1, 10**6 + 1))) 1000000","solution":"def unique_bird_species_count(n, bird_ids): Returns the count of unique bird species based on the list of bird IDs. Parameters: n (int): The number of bird sightings noted down. bird_ids (list): A list of integers representing the IDs of the species of birds spotted. Returns: int: The count of unique bird species. return len(set(bird_ids))"},{"question":"def rank_players(test_cases): Determine the ranking of players based on their total points across all matches. Args: test_cases (List[List[Tuple[int, str, int]]]): A list of test cases, where each test case is a list of tuples. Each tuple contains: - match_id (int): Unique identifier for the match. - player_name (str): Name of the player. - points_scored (int): Points scored by the player in the match. Returns: List[Union[int, str]]: The ranking of the players for each test case. The first element is the number of distinct players. Each subsequent element is a string containing the player's rank, player name, and total points scored. >>> rank_players([ ... [(1, \\"alice\\", 10), (1, \\"bob\\", 15), (2, \\"alice\\", 20), ... (2, \\"bob\\", 10), (3, \\"charlie\\", 5), (3, \\"alice\\", 15), ... (3, \\"bob\\", 15)] ... ]) [3, '1 alice 45', '2 bob 40', '3 charlie 5'] >>> rank_players([ ... [(1, \\"alice\\", 30), (1, \\"bob\\", 30), (2, \\"charlie\\", 10), ... (3, \\"alice\\", 20), (3, \\"bob\\", 20), (4, \\"charlie\\", 30)] ... ]) [3, '1 alice 50', '2 bob 50', '3 charlie 40'] >>> rank_players([ ... [(1, \\"alice\\", 20), (1, \\"bob\\", 10)], ... [(2, \\"dave\\", 50), (2, \\"carol\\", 50)] ... ]) [2, '1 alice 20', '2 bob 10', 2, '1 carol 50', '2 dave 50'] >>> rank_players([ ... [] ... ]) [0]","solution":"def rank_players(test_cases): results = [] for case in test_cases: matches = case player_points = {} for match in matches: match_id, player_name, points_scored = match if player_name in player_points: player_points[player_name] += points_scored else: player_points[player_name] = points_scored sorted_players = sorted(player_points.items(), key=lambda x: (-x[1], x[0])) results.append(len(sorted_players)) for i, (player_name, total_points) in enumerate(sorted_players): results.append(f\\"{i+1} {player_name} {total_points}\\") return results"},{"question":"from typing import List def largest_allied_group(R: int, C: int, matrix: List[List[int]]) -> int: Given the number of rows R and columns C, and an R x C matrix where each cell contains a positive integer representing the strength of a particular faction's unit, find the size of the largest group of connected cells belonging to allied factions. >>> R=4 >>> C=4 >>> matrix = [ ... [2, 3, 4, 5], ... [6, 4, 3, 8], ... [6, 9, 2, 7], ... [1, 8, 9, 2] ... ] >>> largest_allied_group(R, C, matrix) 5 >>> R=1 >>> C=1 >>> matrix = [ ... [5] ... ] >>> largest_allied_group(R, C, matrix) 1 >>> R=2 >>> C=2 >>> matrix = [ ... [1, 1], ... [1, 1] ... ] >>> largest_allied_group(R, C, matrix) 1 >>> R=3 >>> C=3 >>> matrix = [ ... [2, 4, 2], ... [6, 8, 6], ... [10, 12, 10] ... ] >>> largest_allied_group(R, C, matrix) 9 >>> R=3 >>> C=3 >>> matrix = [ ... [2, 4, 5], ... [6, 7, 6], ... [8, 9, 10] ... ] >>> largest_allied_group(R, C, matrix) 4 pass # Implement the function here","solution":"from math import gcd from collections import deque def get_neighbors(r, c, R, C): Return valid neighbors (up, down, left, right) for cell (r, c) neighbors = [] if r - 1 >= 0: neighbors.append((r - 1, c)) if r + 1 < R: neighbors.append((r + 1, c)) if c - 1 >= 0: neighbors.append((r, c - 1)) if c + 1 < C: neighbors.append((r, c + 1)) return neighbors def are_allies(a, b): Return whether two cell values are allied. return gcd(a, b) > 1 def bfs(matrix, r, c, visited, R, C): Perform BFS to find the size of the connected component of allies starting from (r, c) queue = deque([(r, c)]) visited[r][c] = True component_size = 0 while queue: cr, cc = queue.popleft() component_size += 1 for nr, nc in get_neighbors(cr, cc, R, C): if not visited[nr][nc] and are_allies(matrix[cr][cc], matrix[nr][nc]): visited[nr][nc] = True queue.append((nr, nc)) return component_size def largest_allied_group(R, C, matrix): visited = [[False for _ in range(C)] for _ in range(R)] largest_size = 0 for r in range(R): for c in range(C): if not visited[r][c]: component_size = bfs(matrix, r, c, visited, R, C) largest_size = max(largest_size, component_size) return largest_size # Example usage: R = 4 C = 4 matrix = [ [2, 3, 4, 5], [6, 4, 3, 8], [6, 9, 2, 7], [1, 8, 9, 2] ] # This should return 5 print(largest_allied_group(R, C, matrix))"},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a string mathematical expression. >>> evaluate_expression(\\"3+5\\") 8 >>> evaluate_expression(\\"10-5\\") 5 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"8/4\\") 2 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"2+3*4-5\\") 9 >>> evaluate_expression(\\"10+2*6\\") 22 >>> evaluate_expression(\\"100 * 2 + 12\\") 212 >>> evaluate_expression(\\"100 * ( 2 + 12 )\\") 1400 >>> evaluate_expression(\\"100 * ( 2 + 12 ) / 14\\") 100 >>> evaluate_expression(\\"2 * ( 5 + 5 * 2 ) / 3 + ( 6 / 2 + 8 )\\") 21","solution":"def evaluate_expression(expr): Evaluates a string mathematical expression. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b # Use integer division as per example outputs def evaluate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return evaluate(list(expr))"},{"question":"from datetime import datetime, timedelta class Activity: def __init__(self, user_id, timestamp): self.user_id = user_id self.timestamp = timestamp def get_active_users(activities, activity_threshold, time_span): Given a list of user activities, return a list of user IDs who have logged more than a specified number of activities within a given time span. >>> activities = [ ... Activity(\\"user1\\", datetime(2023, 10, 1, 12, 0)), ... Activity(\\"user1\\", datetime(2023, 10, 1, 12, 5)), ... Activity(\\"user2\\", datetime(2023, 10, 1, 12, 10)), ... Activity(\\"user1\\", datetime(2023, 10, 1, 12, 15)), ... Activity(\\"user3\\", datetime(2023, 10, 1, 12, 20)), ... Activity(\\"user1\\", datetime(2023, 10, 1, 12, 25)) ... ] >>> time_span = timedelta(minutes=10) >>> get_active_users(activities, 3, time_span) [\\"user1\\"] from solution import get_active_users def test_single_user_threshold_met(): activities = [ Activity(\\"user1\\", datetime(2023, 10, 1, 12, 0)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 5)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 10)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 15)), ] time_span = timedelta(minutes=10) result = get_active_users(activities, 3, time_span) assert result == [\\"user1\\"] def test_single_user_threshold_not_met(): activities = [ Activity(\\"user1\\", datetime(2023, 10, 1, 12, 0)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 5)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 20)), ] time_span = timedelta(minutes=10) result = get_active_users(activities, 3, time_span) assert result == [] def test_multiple_users_mixed_thresholds(): activities = [ Activity(\\"user1\\", datetime(2023, 10, 1, 12, 0)), Activity(\\"user2\\", datetime(2023, 10, 1, 12, 1)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 5)), Activity(\\"user2\\", datetime(2023, 10, 1, 12, 6)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 10)), Activity(\\"user2\\", datetime(2023, 10, 1, 12, 11)), Activity(\\"user3\\", datetime(2023, 10, 1, 12, 20)), Activity(\\"user2\\", datetime(2023, 10, 1, 12, 30)), ] time_span = timedelta(minutes=10) result = get_active_users(activities, 3, time_span) assert result == [\\"user1\\", \\"user2\\"] def test_activities_outside_time_span(): activities = [ Activity(\\"user1\\", datetime(2023, 10, 1, 12, 0)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 5)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 20)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 25)), Activity(\\"user1\\", datetime(2023, 10, 1, 12, 30)), ] time_span = timedelta(minutes=10) result = get_active_users(activities, 3, time_span) assert result == [\\"user1\\"] def test_no_activities(): activities = [] time_span = timedelta(minutes=10) result = get_active_users(activities, 3, time_span) assert result == []","solution":"from datetime import datetime, timedelta from collections import defaultdict, deque class Activity: def __init__(self, user_id, timestamp): self.user_id = user_id self.timestamp = timestamp def get_active_users(activities, activity_threshold, time_span): # Sort activities by timestamp activities.sort(key=lambda x: x.timestamp) # Dictionary to store deque of timestamps for each user user_activities = defaultdict(deque) active_users = set() for activity in activities: user_id = activity.user_id timestamp = activity.timestamp # Add current timestamp to user activity log user_activities[user_id].append(timestamp) # Remove activities outside of the time_span window while user_activities[user_id] and (timestamp - user_activities[user_id][0] > time_span): user_activities[user_id].popleft() # Check if user meets the threshold if len(user_activities[user_id]) >= activity_threshold: active_users.add(user_id) return list(active_users)"},{"question":"def majority_element(nums: List[int]) -> int: Finds and returns the majority element in the list of integers nums. The majority element is the element that appears more than half the time in the list. Assumes that the list always contains a majority element. Parameters: nums (List[int]): List of integers. Returns: int: The majority element. Examples: >>> majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) 2","solution":"def majority_element(nums): Finds and returns the majority element in the list of integers nums. The majority element is the element that appears more than half the time in the list. Assumes that the list always contains a majority element. Args: nums (list of int): List of integers. Returns: int: The majority element. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def min_operations(s: str, t: str) -> int: Determine the minimum number of operations required to transform the string \`s\` into the string \`t\`. The operations allowed are: 1. Insert a character '0' or '1' at any position in the string \`s\`. 2. Delete any single character from the string \`s\`. 3. Swap any two adjacent characters in the string \`s\`. >>> min_operations(\\"010\\", \\"110\\") 1 >>> min_operations(\\"00101\\", \\"101\\") 2 >>> min_operations(\\"10101\\", \\"10101\\") 0","solution":"def min_operations(s, t): m, n = len(s), len(t) # Create a DP table to store results of subproblems dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, the only option is to insert all characters of second string if i == 0: dp[i][j] = j # Insert all characters of t # If second string is empty, the only option is to delete all characters of first string elif j == 0: dp[i][j] = i # Delete all characters of s # If last characters are the same, ignore the last char and recur for the remaining string elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List, Dict, Any class Library: def __init__(self): self.books = [] def add_book(self, book_id: int, title: str, author: str) -> None: Adds a new book to the library. pass def remove_book(self, book_id: int) -> bool: Removes the book with the given book_id from the library. Returns True if the book was successfully removed, False if the book was not found. pass def search_by_author(self, author: str) -> List[Dict[str, Any]]: Returns a list of all books written by a particular author. If no books are found, an empty list is returned. pass def search_by_title(self, keyword: str) -> List[Dict[str, Any]]: Returns a list of all books that have titles containing a given keyword (case insensitive). If no books are found, an empty list is returned. pass def list_books(self) -> List[Dict[str, Any]]: Returns a list of all books currently in the library. pass def test_add_book(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert len(library.books) == 1 assert library.books[0][\\"title\\"] == \\"The Great Gatsby\\" def test_remove_book(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert library.remove_book(1) == True assert len(library.books) == 0 def test_remove_book_not_found(): library = Library() assert library.remove_book(1) == False def test_search_by_author(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") assert library.search_by_author(\\"F. Scott Fitzgerald\\") == [{\\"book_id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"}] assert library.search_by_author(\\"Unknown Author\\") == [] def test_search_by_title(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") assert library.search_by_title(\\"great\\") == [{\\"book_id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"}] assert library.search_by_title(\\"unknown\\") == [] def test_list_books(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") assert library.list_books() == [ {\\"book_id\\": 1, \\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\"}, {\\"book_id\\": 2, \\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\"} ]","solution":"from typing import List, Dict, Any class Library: def __init__(self): self.books = [] def add_book(self, book_id: int, title: str, author: str) -> None: Adds a new book to the library. self.books.append({\\"book_id\\": book_id, \\"title\\": title, \\"author\\": author}) def remove_book(self, book_id: int) -> bool: Removes the book with the given book_id from the library. Returns True if the book was successfully removed, False if the book was not found. for book in self.books: if book[\\"book_id\\"] == book_id: self.books.remove(book) return True return False def search_by_author(self, author: str) -> List[Dict[str, Any]]: Returns a list of all books written by a particular author. If no books are found, an empty list is returned. return [book for book in self.books if book[\\"author\\"].lower() == author.lower()] def search_by_title(self, keyword: str) -> List[Dict[str, Any]]: Returns a list of all books that have titles containing a given keyword (case insensitive). If no books are found, an empty list is returned. return [book for book in self.books if keyword.lower() in book[\\"title\\"].lower()] def list_books(self) -> List[Dict[str, Any]]: Returns a list of all books currently in the library. return self.books"},{"question":"from typing import List def string_permutations(s: str) -> List[str]: Returns a list of all possible permutations of a given string in lexicographical order. >>> string_permutations(\\"ABC\\") [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] >>> string_permutations(\\"AB\\") [\\"AB\\", \\"BA\\"] >>> string_permutations(\\"A\\") [\\"A\\"] >>> string_permutations(\\"\\") [\\"\\"] >>> string_permutations(\\"12\\") [\\"12\\", \\"21\\"] >>> string_permutations(\\".A\\") [\\".A\\", \\"A.\\"] >>> result = string_permutations(\\"ABCDEFGH\\") >>> result[0] \\"ABCDEFGH\\" >>> result[-1] \\"HGFEDCBA\\"","solution":"from itertools import permutations def string_permutations(s): Returns a list of all possible permutations of a given string in lexicographical order. return [''.join(p) for p in sorted(permutations(s))]"},{"question":"def shift_string(s: str) -> str: Write a function that takes a string and returns the string with each character shifted by 3 places in the ASCII table. If shifting a character by 3 places results in a character beyond 'z' or 'Z', wrap around to the beginning of the alphabet. Non-alphabet characters should remain the same. >>> shift_string(\\"abc\\") == \\"def\\" >>> shift_string(\\"xyz\\") == \\"abc\\" >>> shift_string(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" >>> shift_string(\\"AaZz\\") == \\"DdCc\\" pass from solution import shift_string def test_shift_all_lowercase(): assert shift_string(\\"abc\\") == \\"def\\" assert shift_string(\\"xyz\\") == \\"abc\\" def test_shift_all_uppercase(): assert shift_string(\\"ABC\\") == \\"DEF\\" assert shift_string(\\"XYZ\\") == \\"ABC\\" def test_shift_mixed_case(): assert shift_string(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" assert shift_string(\\"AaZz\\") == \\"DdCc\\" def test_shift_with_non_alpha(): assert shift_string(\\"123 !@#\\") == \\"123 !@#\\" def test_shift_single_char(): assert shift_string(\\"a\\") == \\"d\\" assert shift_string(\\"A\\") == \\"D\\" def test_shift_empty_string(): assert shift_string(\\"\\") == \\"\\" def test_shift_with_wrap(): assert shift_string(\\"z\\") == \\"c\\" assert shift_string(\\"Z\\") == \\"C\\"","solution":"def shift_string(s: str) -> str: result = [] for char in s: if 'a' <= char <= 'z': result.append(chr((ord(char) - ord('a') + 3) % 26 + ord('a'))) elif 'A' <= char <= 'Z': result.append(chr((ord(char) - ord('A') + 3) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string possible by moving characters to the beginning or end. >>> lexicographically_smallest_string(\\"cba\\") \\"acb\\" >>> lexicographically_smallest_string(\\"a\\") \\"a\\" >>> lexicographically_smallest_string(\\"abc\\") \\"abc\\" >>> lexicographically_smallest_string(\\"bbbaa\\") \\"abbba\\" >>> lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\") \\"azyxwvutsrqponmlkjihgfedcb\\"","solution":"def lexicographically_smallest_string(s: str) -> str: Returns the lexicographically smallest string possible by moving characters to the beginning or end. # find the lexicographically smallest character in the string min_char = min(s) # find the first occurrence of the smallest character min_index = s.index(min_char) # move the smallest character to the front and return the result return min_char + s[:min_index] + s[min_index + 1:] # Example usage input_str = \\"cba\\" print(lexicographically_smallest_string(input_str)) # Output: \\"acb\\""},{"question":"def sorted_squares(arr): Given a sorted array of integers, both negative and positive, returns a new array containing the squares of each number from the input array sorted in non-decreasing order. >>> sorted_squares([1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] >>> sorted_squares([-5, -4, -3, -2, -1]) [1, 4, 9, 16, 25] >>> sorted_squares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121] >>> sorted_squares([-5, -2, 0, 1, 3]) [0, 1, 4, 9, 25] >>> sorted_squares([5]) [25] >>> sorted_squares([-5]) [25] >>> sorted_squares([-3, -3, 2, 2, 3]) [4, 4, 9, 9, 9]","solution":"def sorted_squares(arr): Given a sorted array of integers, both negative and positive, returns a new array containing the squares of each number from the input array sorted in non-decreasing order. n = len(arr) result = [0] * n left, right = 0, n - 1 position = n - 1 while left <= right: if abs(arr[left]) > abs(arr[right]): result[position] = arr[left] ** 2 left += 1 else: result[position] = arr[right] ** 2 right -= 1 position -= 1 return result"},{"question":"from typing import List, Union def nested_sum(nested_list: List[Union[int, List]]) -> int: Returns the sum of all integers in the nested list structure. >>> nested_sum([1, 2, 3]) 6 >>> nested_sum([1, [2, 3], 4]) 10 >>> nested_sum([[1, 2], [[3], 4], 5]) 15 >>> nested_sum([1, [2, [3, [4]]], 5]) 15","solution":"def nested_sum(nested_list): Returns the sum of all integers in the nested list structure. total = 0 for element in nested_list: if isinstance(element, list): total += nested_sum(element) else: total += element return total"},{"question":"def contains_nearby_duplicate(arr: List[int], k: int) -> bool: Determine if the array contains any duplicates within k distance from each other. >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 1, 2, 3], 2) False >>> contains_nearby_duplicate([99, 99], 2) True >>> contains_nearby_duplicate([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) False","solution":"from typing import List def contains_nearby_duplicate(arr: List[int], k: int) -> bool: Determine if the array contains any duplicates within k distance from each other. seen = {} for i, num in enumerate(arr): if num in seen and i - seen[num] <= k: return True seen[num] = i return False"},{"question":"def max_sum_no_consecutive(arr): Returns the maximum sum of elements in the array where no two elements are consecutive. >>> max_sum_no_consecutive([3, 2, 7, 10]) 13 >>> max_sum_no_consecutive([3, 2, 5, 10, 7]) 15 pass def process_tasks(T, cases): Process multiple test cases to find the maximum sum for each. >>> T = 2 >>> cases = [(4, [3, 2, 7, 10]), (5, [3, 2, 5, 10, 7])] >>> process_tasks(T, cases) [13, 15] pass","solution":"def max_sum_no_consecutive(arr): Returns the maximum sum of elements in the array where no two elements are consecutive. n = len(arr) if n == 0: return 0 if n == 1: return arr[0] incl = arr[0] excl = 0 for i in range(1, n): new_excl = max(incl, excl) incl = excl + arr[i] excl = new_excl return max(incl, excl) def process_tasks(T, cases): results = [] for case in cases: _, array = case results.append(max_sum_no_consecutive(array)) return results"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5 >>> longest_unique_substring(\\"abcdab\\") 4 >>> longest_unique_substring(\\"aab\\") 2","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def knapsack(n, W, items): Given a number of items with their weights and values, and a maximum knapsack weight, this function returns the maximum value that can be accumulated in the knapsack using the 0/1 knapsack approach. Parameters: n (int): Number of items W (int): Maximum weight the knapsack can hold items (list): List of tuples where each tuple contains two integers (weight, value) of an item Returns: int: Maximum value that can be accumulated in the knapsack from solution import knapsack def test_example1(): n = 4 W = 7 items = [(2, 10), (3, 14), (4, 7), (5, 13)] assert knapsack(n, W, items) == 24 def test_example2(): n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 220 def test_single_item(): n = 1 W = 100 items = [(50, 60)] assert knapsack(n, W, items) == 60 def test_multiple_identical_items(): n = 3 W = 50 items = [(10, 60), (10, 60), (10, 60)] assert knapsack(n, W, items) == 180 def test_no_items(): n = 0 W = 50 items = [] assert knapsack(n, W, items) == 0 def test_zero_capacity(): n = 3 W = 0 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 0 def test_items_too_heavy(): n = 3 W = 5 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 0","solution":"def knapsack(n, W, items): Given a number of items with their weights and values, and a maximum knapsack weight, this function returns the maximum value that can be accumulated in the knapsack using the 0/1 knapsack approach. Parameters: n (int): Number of items W (int): Maximum weight the knapsack can hold items (list): List of tuples where each tuple contains two integers (weight, value) of an item Returns: int: Maximum value that can be accumulated in the knapsack # Initialize a DP array to store the maximum values for every possible weight dp = [0] * (W + 1) # Iterate through each item for weight, value in items: # Traverse dp array from right to left for w in range(W, weight - 1, -1): # Update dp array considering the inclusion of the current item dp[w] = max(dp[w], dp[w - weight] + value) return dp[W]"},{"question":"from functools import cmp_to_key from typing import List def largest_number(nums: List[int]) -> str: Given an integer array nums, return the largest number you can form by concatenating its elements. The result should be in string format. >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330'","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(nums): Returns the largest number that can be formed by concatenating the elements of nums. # Convert numbers to strings for comparison str_nums = list(map(str, nums)) # Sort numbers based on custom comparator str_nums.sort(key=cmp_to_key(compare)) # Concatenate sorted numbers result = ''.join(str_nums) # Remove leading zeros return result if result[0] != '0' else '0'"},{"question":"def split_string(s: str, delimiters: set) -> list: Split the input string s into a list of substrings using the provided set of delimiters. The delimiter characters themselves should not appear in the output list. >>> split_string(\\"hello,world:here\\", {',', ':'}) [\\"hello\\", \\"world\\", \\"here\\"] >>> split_string(\\"I love coding! Do you?\\", {' ', '!', '?'}) [\\"I\\", \\"love\\", \\"coding\\", \\"Do\\", \\"you\\"]","solution":"def split_string(s: str, delimiters: set) -> list: import re # Create a regular expression pattern from the delimiters pattern = '|'.join(map(re.escape, delimiters)) # Split the string using the pattern and filter out empty strings return [substring for substring in re.split(pattern, s) if substring]"},{"question":"def sum_of_odd_digits(n: int) -> int: Returns the sum of the odd digits in the input number. >>> sum_of_odd_digits(123456789) 25 >>> sum_of_odd_digits(24680) 0 >>> sum_of_odd_digits(1) 1 >>> sum_of_odd_digits(9) 9 >>> sum_of_odd_digits(4) 0 >>> sum_of_odd_digits(8) 0 >>> sum_of_odd_digits(1357924680) 25 >>> sum_of_odd_digits(1020304050) 9","solution":"def sum_of_odd_digits(n): Returns the sum of the odd digits in the input number. Parameters: n (int): A positive integer. Returns: int: The sum of the odd digits in the number. total = 0 while n > 0: digit = n % 10 if digit % 2 != 0: total += digit n //= 10 return total"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Checks whether two strings are anagrams of each other, ignoring spaces and case sensitivity. >>> are_anagrams(\\"abc\\", \\"CBA\\") == True >>> are_anagrams(\\"a bc\\", \\"cba\\") == True >>> are_anagrams(\\"Listen\\", \\"Silent\\") == True >>> are_anagrams(\\"hello\\", \\"world\\") == False >>> are_anagrams(\\"Astronomer\\", \\"Moon starer\\") == True >>> are_anagrams(None, \\"\\") == True >>> are_anagrams(\\"abc\\", None) == False from solution import are_anagrams def test_anagrams_basic(): assert are_anagrams(\\"abc\\", \\"CBA\\") == True assert are_anagrams(\\"a bc\\", \\"cba\\") == True def test_anagrams_case_insensitivity(): assert are_anagrams(\\"Listen\\", \\"Silent\\") == True def test_anagrams_ignore_spaces(): assert are_anagrams(\\"Astronomer\\", \\"Moon starer\\") == True def test_anagrams_negative_case(): assert are_anagrams(\\"hello\\", \\"world\\") == False def test_anagrams_null_handling(): assert are_anagrams(None, \\"\\") == True assert are_anagrams(\\"abc\\", None) == False def test_anagrams_with_extra_spaces(): assert are_anagrams(\\"abc \\", \\" AB c\\") == True","solution":"def are_anagrams(str1, str2): Checks whether two strings are anagrams of each other, ignoring spaces and case sensitivity. def clean_string(s): if s is None: return \\"\\" return \\"\\".join(sorted(s.replace(\\" \\", \\"\\").upper())) return clean_string(str1) == clean_string(str2)"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"abcdef\\") 6 def test_longest_unique_substring_examples(): assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 assert longest_unique_substring(\\"abcdef\\") == 6 def test_longest_unique_substring_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_longest_unique_substring_single_character(): assert longest_unique_substring(\\"a\\") == 1 def test_longest_unique_substring_repeating_characters(): assert longest_unique_substring(\\"aaaaa\\") == 1 def test_longest_unique_substring_no_repeating_characters(): assert longest_unique_substring(\\"abcd\\") == 4 def test_longest_unique_substring_mixed_characters(): assert longest_unique_substring(\\"abcbdef\\") == 5","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def reverse_words(sentence: str) -> str: This function takes a sentence and reverses the order of its words while maintaining the original spacing. >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" Hello World \\") \\" World Hello \\"","solution":"def reverse_words(sentence): This function takes a sentence and reverses the order of its words while maintaining the original spacing. # Split the sentence by spaces while keeping all spaces words = sentence.split(' ') # Reverse the list of words reversed_words = words[::-1] # Join the reversed list back into a string reversed_sentence = ' '.join(reversed_words) return reversed_sentence"},{"question":"def add_task(task_list, task): Adds a task to the list of tasks. >>> add_task([], \\"Buy groceries\\") ['Buy groceries'] >>> add_task([\\"Buy groceries\\"], \\"Clean house\\") ['Buy groceries', 'Clean house'] def complete_task(task_list, task): Marks a task as complete by removing it from the list if it exists. >>> complete_task([\\"Buy groceries\\", \\"Clean house\\"], \\"Buy groceries\\") ['Clean house'] >>> complete_task([\\"Buy groceries\\"], \\"Do laundry\\") ['Buy groceries'] def remove_task(task_list, task): Removes a task from the task_list if it exists. >>> remove_task([\\"Buy groceries\\", \\"Clean house\\"], \\"Clean house\\") ['Buy groceries'] >>> remove_task([\\"Buy groceries\\"], \\"Do laundry\\") ['Buy groceries']","solution":"def add_task(task_list, task): Adds a task to the list of tasks. >>> add_task([], \\"Buy groceries\\") ['Buy groceries'] >>> add_task([\\"Buy groceries\\"], \\"Clean house\\") ['Buy groceries', 'Clean house'] task_list.append(task) return task_list def complete_task(task_list, task): Marks a task as complete by removing it from the list if it exists. >>> complete_task([\\"Buy groceries\\", \\"Clean house\\"], \\"Buy groceries\\") ['Clean house'] >>> complete_task([\\"Buy groceries\\"], \\"Do laundry\\") ['Buy groceries'] if task in task_list: task_list.remove(task) return task_list def remove_task(task_list, task): Removes a task from the task_list if it exists. >>> remove_task([\\"Buy groceries\\", \\"Clean house\\"], \\"Clean house\\") ['Buy groceries'] >>> remove_task([\\"Buy groceries\\"], \\"Do laundry\\") ['Buy groceries'] if task in task_list: task_list.remove(task) return task_list"},{"question":"from typing import List def minimum_moves_to_target(n: int, m: int, grid: List[str]) -> int: Given a grid of n rows and m columns where each cell is either open ('.') or blocked ('#'), determine the minimum number of moves required to reach the bottom-right cell (n, m) from the top-left cell (1, 1). Return -1 if it is impossible to reach the target. >>> minimum_moves_to_target(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> minimum_moves_to_target(4, 4, [\\"....\\", \\"..\\", \\"..\\", \\"....\\"]) 6 >>> minimum_moves_to_target(3, 3, [\\"..#\\", \\".#.\\", \\"..#\\"]) -1 >>> minimum_moves_to_target(1, 1, [\\".\\"]) 0 >>> minimum_moves_to_target(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> minimum_moves_to_target(2, 2, [\\".#\\", \\"#.\\"]) -1","solution":"from collections import deque def minimum_moves_to_target(n, m, grid): # Directions of movement (right, down, left, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() # If we've reached the bottom-right cell, return the distance if row == n - 1 and col == m - 1: return dist # Explore all 4 possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc # Check if new position is within bounds and not visited if 0 <= new_row < n and 0 <= new_col < m and grid[new_row][new_col] == '.' and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If queue is exhausted and we haven't returned, it's impossible to reach the target return -1"},{"question":"def compress_string(s: str) -> str: Compress the string by converting consecutive repeated characters into character and count. If the compressed string is not smaller, return the original string. >>> compress_string(\\"abcdef\\") == \\"abcdef\\" >>> compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"aa\\") == \\"aa\\" >>> compress_string(\\"aA\\") == \\"aA\\" >>> compress_string(\\"aa11bb22\\") == \\"aa11bb22\\" >>> compress_string(\\"aa!!??\\") == \\"aa!!??\\" # write your code here","solution":"def compress_string(s): Compress the string by converting consecutive repeated characters into character and count. If the compressed string is not smaller, return the original string. if not s: return s compressed = [] count = 1 previous_char = s[0] for char in s[1:]: if char == previous_char: count += 1 else: compressed.append(f\\"{previous_char}{count}\\") previous_char = char count = 1 compressed.append(f\\"{previous_char}{count}\\") compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def split_camel_case(s: str) -> List[str]: Splits a camel case string into individual words in lowercase. >>> split_camel_case(\\"CamelCaseFormat\\") ['camel', 'case', 'format'] >>> split_camel_case(\\"ThisIsATest\\") ['this', 'is', 'a', 'test']","solution":"def split_camel_case(s): Splits a camel case string into individual words in lowercase. Parameters: - s (str): The camel case string. Returns: - list: A list of words in lowercase. import re words = re.findall(r'[A-Z][a-z]*', s) return [word.lower() for word in words]"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Perform level order traversal on a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], a list of lists where each list contains the values of the nodes at each level >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> level_order(root) [[1]] >>> root = None >>> level_order(root) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Perform level order traversal on a binary tree. :param root: TreeNode, the root of the binary tree :return: List[List[int]], a list of lists where each list contains the values of the nodes at each level if not root: return [] result = [] queue = deque([root]) while queue: level = [] level_length = len(queue) for i in range(level_length): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def longest_zigzag(arr: List[int]) -> int: Finds the length of the longest zigzag sequence in the given list. >>> longest_zigzag([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag([1, 2, 3, 4, 5]) 2 >>> longest_zigzag([10]) 1 >>> longest_zigzag([10, 20]) 2 >>> longest_zigzag([10, 5, 10, 5, 10, 5]) 6 >>> longest_zigzag([5, 5, 5, 5, 5]) 1 >>> longest_zigzag([1, 3, 2, 5, 4, 6]) 6 pass","solution":"def longest_zigzag(arr): Finds the length of the longest zigzag sequence in the given list. if len(arr) < 2: return len(arr) up = down = 1 # Start with the first element for both up and down for i in range(1, len(arr)): if arr[i] > arr[i-1]: up = down + 1 elif arr[i] < arr[i-1]: down = up + 1 return max(up, down)"},{"question":"class NestedIterator: def __init__(self, nestedList): Initialize your data structure here. :type nestedList: [List[int]] >>> i = NestedIterator([[1, 1], 2, [1, [1, 2, [3]]]]) >>> result = [] >>> while i.hasNext(): >>> result.append(i.next()) >>> print(result) # Output: [1, 1, 2, 1, 1, 2, 3] def next(self): Return the next integer element in the nested list structure. :rtype: int def hasNext(self): Return True if there are more integers to return, otherwise False. :rtype: bool # Unit tests def test_single_integer(): nestedList = [1] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) assert result == [1] def test_flat_list(): nestedList = [1, 2, 3, 4] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) assert result == [1, 2, 3, 4] def test_nested_lists(): nestedList = [[1, 1], 2, [1, [1, 2, [3]]]] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) assert result == [1, 1, 2, 1, 1, 2, 3] def test_deeply_nested_list(): nestedList = [[1, [2, [3, [4, [5]]]]]] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) assert result == [1, 2, 3, 4, 5] def test_empty_sublist(): nestedList = [1, [], 2, [3, [4, []], 5]] i = NestedIterator(nestedList) result = [] while i.hasNext(): result.append(i.next()) assert result == [1, 2, 3, 4, 5]","solution":"class NestedIterator: def __init__(self, nestedList): self.stack = [] self._flatten(nestedList) def _flatten(self, nestedList): for element in nestedList[::-1]: if isinstance(element, int): self.stack.append(element) else: self._flatten(element) def next(self): return self.stack.pop() def hasNext(self): return len(self.stack) > 0 # Usage example: # nestedList = [[1, 1], 2, [1, [1, 2, [3]]]] # i = NestedIterator(nestedList) # result = [] # while i.hasNext(): # result.append(i.next()) # print(result) # Output: [1, 1, 2, 1, 1, 2, 3]"},{"question":"def format_phone_number(phone_number: str) -> str: Formats a 10-digit phone number string into the format: (XXX) XXX-XXXX Args: phone_number (str): A string containing exactly 10 digits. Returns: str: A formatted phone number. Examples: >>> format_phone_number(\\"1234567890\\") == \\"(123) 456-7890\\" >>> format_phone_number(\\"9876543210\\") == \\"(987) 654-3210\\"","solution":"def format_phone_number(phone_number: str) -> str: Formats a 10-digit phone number string into the format: (XXX) XXX-XXXX Args: phone_number (str): A string containing exactly 10 digits. Returns: str: A formatted phone number. return f\\"({phone_number[:3]}) {phone_number[3:6]}-{phone_number[6:]}\\""},{"question":"def can_be_balanced(t: int, test_cases: List[str]) -> List[str]: Determines if the parentheses in each string can be rearranged to form a valid balanced sequence. Parameters: t (int): Number of test cases test_cases (list of str): List of strings, each containing parentheses and letters Returns: list of str: List of results for each test case, either \\"YES\\" or \\"NO\\" >>> can_be_balanced(3, [\\"a(b)c)d(\\", \\"(abc)def\\", \\"(g(h))i)j(\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> can_be_balanced(1, [\\"(()))(\\"]) [\\"NO\\"] >>> can_be_balanced(2, [\\"abc\\", \\"(((())))\\"]) [\\"YES\\", \\"YES\\"]","solution":"def can_be_balanced(t, test_cases): Determines if the parentheses in each string can be rearranged to form a valid balanced sequence. Parameters: t (int): Number of test cases test_cases (list of str): List of strings, each containing parentheses and letters Returns: list of str: List of results for each test case, either \\"YES\\" or \\"NO\\" results = [] for s in test_cases: open_count = s.count('(') close_count = s.count(')') if open_count != close_count: results.append(\\"NO\\") else: balance = 0 valid = True for ch in s: if ch == '(': balance += 1 elif ch == ')': balance -= 1 if balance < 0: valid = False break if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def word_frequency(s: str) -> dict: Returns a dictionary with the frequency of each word in the input string. >>> word_frequency(\\"Hello world hello\\") {'hello': 2, 'world': 1} >>> word_frequency(\\"One two three four\\") {'one': 1, 'two': 1, 'three': 1, 'four': 1} >>> word_frequency(\\"Python python PYTHON\\") {'python': 3} >>> word_frequency(\\"Single\\") {'single': 1} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"This is a test\\") {'this': 1, 'is': 1, 'a': 1, 'test': 1} >>> text = \\"a long string with many many many words and many words are repeated\\" >>> expected = { ... 'a': 1, 'long': 1, 'string': 1, 'with': 1, 'many': 4, 'words': 2, ... 'and': 1, 'are': 1, 'repeated': 1 ... } >>> word_frequency(text) == expected True","solution":"def word_frequency(s): Returns a dictionary with the frequency of each word in the input string. words = s.lower().split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"def problems_solved_within_limit(T: int, data: List[List[int]]) -> List[int]: Determines the number of problems each participant solved within the time limit. :param T: An integer representing the number of participants. :param data: A list containing sublists for each participant. Each sublist contains [N, L, times] where N is the number of problems attempted, L is the time limit, and times is a list of times taken for each problem. :return: A list of integers where each integer is the number of problems solved within the time limit for each participant. >>> problems_solved_within_limit(2, [ [5, 10, [2, 8, 3, 7, 2]], [3, 15, [5, 12, 8]] ]) [5, 3] >>> problems_solved_within_limit(1, [ [4, 5, [1, 4, 6, 5]] ]) [3]","solution":"def problems_solved_within_limit(T, data): Determines the number of problems each participant solved within the time limit. :param T: An integer representing the number of participants. :param data: A list containing sublists for each participant. Each sublist contains [N, L, times] where N is the number of problems attempted, L is the time limit, and times is a list of times taken for each problem. :return: A list of integers where each integer is the number of problems solved within the time limit for each participant. results = [] for i in range(T): N, L, times = data[i] count = sum(1 for time in times if time <= L) results.append(count) return results"},{"question":"def filter_even_numbers(nums: List[int]) -> List[int]: Returns a new array containing only the even numbers from the original array. >>> filter_even_numbers([]) [] >>> filter_even_numbers([1, 3, 5, 7]) [] >>> filter_even_numbers([2, 4, 6, 8]) [2, 4, 6, 8] >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even_numbers([2]) [2] >>> filter_even_numbers([1]) [] >>> filter_even_numbers([-2, -4, -6]) [-2, -4, -6] >>> filter_even_numbers([-3, -2, 0, 1, 2, 3]) [-2, 0, 2]","solution":"def filter_even_numbers(nums): Returns a new list containing only the even numbers from the input list. return [num for num in nums if num % 2 == 0]"},{"question":"from typing import List def find_prime_numbers(n: int, numbers: List[int]) -> List[int]: Given a list of positive integers, return a list of the integers that are prime numbers. A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself. Args: n : int : the number of elements in the list numbers : List[int] : the list of positive integers Returns: List[int] : a list of prime numbers from the given list Examples: >>> find_prime_numbers(5, [2, 4, 6, 5, 7]) [2, 5, 7] >>> find_prime_numbers(3, [4, 6, 8]) [] pass def test_find_prime_numbers_with_example_data(): assert find_prime_numbers(5, [2, 4, 6, 5, 7]) == [2, 5, 7] assert find_prime_numbers(3, [4, 6, 8]) == [] def test_find_prime_numbers_all_primes(): assert find_prime_numbers(4, [2, 3, 5, 7]) == [2, 3, 5, 7] def test_find_prime_numbers_no_primes(): assert find_prime_numbers(4, [4, 6, 8, 10]) == [] def test_find_prime_numbers_single_element(): assert find_prime_numbers(1, [1]) == [] assert find_prime_numbers(1, [2]) == [2] def test_find_prime_numbers_mixed_numbers(): assert find_prime_numbers(5, [1, 13, 15, 17, 19]) == [13, 17, 19]","solution":"from typing import List def is_prime(num: int) -> bool: Returns True if num is a prime number, otherwise False. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def find_prime_numbers(n: int, numbers: List[int]) -> List[int]: Returns a list of prime numbers from the given list of numbers. return [num for num in numbers if is_prime(num)]"},{"question":"def inventory_management_system(N: int, initial_stock: List[int], M: int, operations: List[List[int]]) -> List[int]: Inventory management system that performs restock, purchase, and query operations. :param N: Number of initial products :param initial_stock: List of initial stock levels :param M: Number of operations to be performed :param operations: List of operations to be performed :return: List of results for each query operation >>> N = 5 >>> initial_stock = [10, 20, 30, 40, 50] >>> M = 6 >>> operations = [ ... [0, 2, 5], ... [1, 3, 10], ... [2, 3], ... [2, 1], ... [1, 5, 60], ... [2, 5] ... ] >>> inventory_management_system(N, initial_stock, M, operations) [20, 10, 0] from typing import List def test_inventory_management_system(): N = 5 initial_stock = [10, 20, 30, 40, 50] M = 6 operations = [ [0, 2, 5], [1, 3, 10], [2, 3], [2, 1], [1, 5, 60], [2, 5] ] expected_output = [20, 10, 0] assert inventory_management_system(N, initial_stock, M, operations) == expected_output # Additional test cases N = 3 initial_stock = [5, 10, 15] M = 4 operations = [ [0, 1, 5], [1, 2, 7], [2, 1], [2, 2] ] expected_output = [10, 3] assert inventory_management_system(N, initial_stock, M, operations) == expected_output N = 2 initial_stock = [1, 2] M = 3 operations = [ [1, 1, 1], [1, 2, 3], [2, 2] ] expected_output = [0] assert inventory_management_system(N, initial_stock, M, operations) == expected_output N = 4 initial_stock = [100, 200, 300, 400] M = 3 operations = [ [2, 4], [0, 4, 100], [2, 4] ] expected_output = [400, 500] assert inventory_management_system(N, initial_stock, M, operations) == expected_output N = 5 initial_stock = [50, 60, 70, 80, 90] M = 5 operations = [ [1, 3, 70], [2, 3], [0, 2, 40], [1, 5, 100], [2, 5] ] expected_output = [0, 0] assert inventory_management_system(N, initial_stock, M, operations) == expected_output","solution":"def inventory_management_system(N, initial_stock, M, operations): Inventory management system that performs restock, purchase, and query operations. :param N: Number of initial products :param initial_stock: List of initial stock levels :param M: Number of operations to be performed :param operations: List of operations to be performed :return: List of results for each query operation # Initialize the stock as per the initial stock levels stock = initial_stock.copy() results = [] for operation in operations: if operation[0] == 0: # Restock operation P, Q = operation[1], operation[2] stock[P - 1] += Q elif operation[0] == 1: # Purchase operation P, Q = operation[1], operation[2] stock[P - 1] = max(stock[P - 1] - Q, 0) elif operation[0] == 2: # Query operation P = operation[1] results.append(stock[P - 1]) return results"},{"question":"from typing import List def formatDate(date: str) -> str: Converts a date from \\"DD/MM/YYYY\\" format to \\"Month Day, Year\\" format. Args: date (str): A string representing a date in \\"DD/MM/YYYY\\" format. Returns: str: The date in \\"Month Day, Year\\" format. Example: >>> formatDate(\\"25/12/2021\\") 'December 25, 2021' >>> formatDate(\\"01/01/2022\\") 'January 1, 2022'","solution":"from datetime import datetime def formatDate(date: str) -> str: Converts a date from \\"DD/MM/YYYY\\" format to \\"Month Day, Year\\" format. Args: date (str): A string representing a date in \\"DD/MM/YYYY\\" format. Returns: str: The date in \\"Month Day, Year\\" format. # Parse the input date string to a datetime object date_obj = datetime.strptime(date, \\"%d/%m/%Y\\") # Convert the datetime object to the required format formatted_date = date_obj.strftime(\\"%B %d, %Y\\").lstrip('0').replace(' 0', ' ') return formatted_date"},{"question":"def rotateAndSum(arr, k): Rotates the array to the right by k steps and returns the sum of the rotated array. >>> rotateAndSum([1, 2, 3, 4, 5], 2) == 15 >>> rotateAndSum([10, 20, 30], 1) == 60 >>> rotateAndSum([], 2) == 0 >>> rotateAndSum([5], 3) == 5 >>> rotateAndSum([1, 2, 3], 0) == 6 >>> rotateAndSum([1, 2, 3, 4], 6) == 10 >>> rotateAndSum([1, 2, 3, 4, 5], -2) == 15","solution":"def rotateAndSum(arr, k): Rotates the array to the right by k steps and returns the sum of the rotated array. if not arr: return 0 k = k % len(arr) # if k is greater than the array length rotated_array = arr[-k:] + arr[:-k] return sum(rotated_array)"},{"question":"def generate_prime_pair_array(m: int) -> List[int]: Generates a prime-pair array of length m where each pair of adjacent elements sum up to a prime number. >>> generate_prime_pair_array(1) [4] >>> generate_prime_pair_array(3) [4, 3, 4] >>> generate_prime_pair_array(5) [4, 3, 4, 3, 4] pass def process_queries(t: int, queries: List[int]) -> List[List[int]]: Processes multiple test cases to generate prime-pair arrays of lengths specified in queries. >>> process_queries(1, [1]) [[4]] >>> process_queries(3, [1, 3, 5]) [[4], [4, 3, 4], [4, 3, 4, 3, 4]] pass","solution":"def generate_prime_pair_array(m): Generates a prime-pair array of length m. # A prime-pair array can be constructed simply by alternating between 4 and 3 # because 4 + 3 = 7, which is prime. array = [] for i in range(m): array.append(4 if i % 2 == 0 else 3) return array def process_queries(t, queries): Processes multiple test cases to generate prime-pair arrays of lengths specified in queries. results = [] for m in queries: results.append(generate_prime_pair_array(m)) return results"},{"question":"def first_non_repeating_character_index(s: str) -> int: Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. >>> first_non_repeating_character_index('leetcode') 0 >>> first_non_repeating_character_index('loveleetcode') 2 >>> first_non_repeating_character_index('aabb') -1 >>> first_non_repeating_character_index('') -1 >>> first_non_repeating_character_index('aaaaa') -1 >>> first_non_repeating_character_index('abcd') 0 >>> first_non_repeating_character_index('aabbccddeeffg') 12 >>> first_non_repeating_character_index('abcabcabdcab') 8 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases, each containing a string, and returns a list with the indices of the first non-repeating character for each string. >>> process_test_cases(['leetcode', 'loveleetcode', 'aabb']) [0, 2, -1] >>> process_test_cases(['abcd', 'abcabcabdcab']) [0, 8] >>> process_test_cases(['', 'aaaaa']) [-1, -1] >>> process_test_cases(['aabbccddeeffg', 'aabbccddeeffgg']) [12, -1]","solution":"def first_non_repeating_character_index(s): Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. from collections import Counter count = Counter(s) for idx, char in enumerate(s): if count[char] == 1: return idx return -1 def process_test_cases(test_cases): Processes a list of test cases, each containing a string, and returns a list with the indices of the first non-repeating character for each string. results = [] for case in test_cases: results.append(first_non_repeating_character_index(case)) return results"},{"question":"from typing import List def find_packet_with_most_unique_routers(packets: List[List[int]]) -> List[int]: Given a list of packets, with each packet represented as an array of router IDs it has passed through, find the packet that has visited the most unique routers. If multiple packets have visited the most unique routers, return the packet that visited those routers in the earliest order. >>> find_packet_with_most_unique_routers([[1, 2, 3], [4, 3, 2], [1, 2, 3, 4, 5], [2, 3]]) == [1, 2, 3, 4, 5] >>> find_packet_with_most_unique_routers([[1, 2, 3], [2, 3, 1], [3, 2, 1]]) == [1, 2, 3] pass","solution":"def find_packet_with_most_unique_routers(packets): max_unique_count = 0 best_packet = [] for packet in packets: unique_routers = set(packet) if len(unique_routers) > max_unique_count: max_unique_count = len(unique_routers) best_packet = packet elif len(unique_routers) == max_unique_count: best_packet = min(best_packet, packet) return best_packet"},{"question":"def minRequiredMaxTime(tasks: List[int], T: int) -> int: Determine the minimum value of maxTime such that all tasks can be completed within the T time slots. >>> minRequiredMaxTime([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 15 >>> minRequiredMaxTime([3, 2, 2, 4, 1, 4], 3) 6 >>> minRequiredMaxTime([1, 2, 3, 1, 1], 4) 3","solution":"def canComplete(tasks, T, maxTime): current_slot_time = 0 slots_used = 1 for task in tasks: if current_slot_time + task <= maxTime: current_slot_time += task else: slots_used += 1 current_slot_time = task if slots_used > T: return False return True def minRequiredMaxTime(tasks, T): left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if canComplete(tasks, T, mid): right = mid else: left = mid + 1 return left"},{"question":"def min_moves_to_make_elements_equal(n: int, array: List[int]) -> int: Returns the minimum number of moves required to make all elements of the array equal. >>> min_moves_to_make_elements_equal(4, [1, 2, 3, 4]) 6 >>> min_moves_to_make_elements_equal(3, [0, 0, 3]) 3 >>> min_moves_to_make_elements_equal(1, [10]) 0 >>> min_moves_to_make_elements_equal(5, [5, 5, 5, 5, 5]) 0 >>> min_moves_to_make_elements_equal(6, [1, 2, 3, 4, 5, 6]) 15 >>> min_moves_to_make_elements_equal(4, [2, 2, 2, 2]) 0 >>> min_moves_to_make_elements_equal(2, [1, 2]) 1 >>> min_moves_to_make_elements_equal(3, [3, 3, 4]) 1 pass","solution":"def min_moves_to_make_elements_equal(n, array): Returns the minimum number of moves required to make all elements of the array equal. min_element = min(array) total_moves = sum(array) - (n * min_element) return total_moves"},{"question":"def fibonacciSum(n): Calculate the sum of all Fibonacci numbers that are less than the given n. Parameters: n (int): The upper bound value. Returns: int/bool: The sum of all Fibonacci numbers that are less than n, or False if n is not a positive integer. >> fibonacciSum(10) # returns 20 (0, 1, 1, 2, 3, 5, 8 -> 0 + 1 + 1 + 2 + 3 + 5 + 8 = 20) >> fibonacciSum(20) # returns 33 (0, 1, 1, 2, 3, 5, 8, 13 -> 0 + 1 + 1 + 2 + 3 + 5 + 8 + 13 = 33) >> fibonacciSum(1) # returns 0 (0 is less than 1 but 1 is not less than 1) >> fibonacciSum(\\"five\\") # returns false >> fibonacciSum(-5) # returns false","solution":"def fibonacciSum(n): Calculate the sum of all Fibonacci numbers that are less than the given n. Parameters: n (int): The upper bound value. Returns: int/bool: The sum of all Fibonacci numbers that are less than n, or False if n is not a positive integer. if not isinstance(n, int) or n <= 0: return False a, b = 0, 1 fib_sum = 0 while a < n: fib_sum += a a, b = b, a + b return fib_sum"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring. >>> longest_balanced_substring(\\"(()))(()\\") 4 >>> longest_balanced_substring(\\")()())\\") 4 >>> longest_balanced_substring(\\"()(())\\") 6 >>> longest_balanced_substring(\\"()\\") 2 >>> longest_balanced_substring(\\")(\\") 0 >>> longest_balanced_substring(\\"((()))\\") 6 >>> longest_balanced_substring(\\"(()(()))()\\") 10 >>> longest_balanced_substring(\\"((((((\\") 0 >>> longest_balanced_substring(\\")))))\\") 0 >>> longest_balanced_substring(\\"\\") 0 >>> longest_balanced_substring(\\"(((\\") 0 >>> longest_balanced_substring(\\")))\\") 0","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring. max_length = 0 stack = [-1] # Initialize stack with a base index for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: stack.append(i) return max_length"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression string that includes only single-digit numbers and addition/subtraction operations. Ignores any whitespace characters. >>> evaluate_expression(\\"1 + 2 - 3 + 4\\") # 4 >>> evaluate_expression(\\"6 - 4 + 3\\") # 5 >>> evaluate_expression(\\"9 + 1 + 1\\") # 11 >>> evaluate_expression(\\" \\") # 0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression string that includes only single-digit numbers and addition/subtraction operations. Ignores any whitespace characters. Args: expression (str): The input string containing the mathematical expression. Returns: int: The result of the evaluated expression. if not expression.strip(): return 0 # Removing any whitespace from the expression expression = expression.replace(\\" \\", \\"\\") # Using eval to directly evaluate the string expression # This is safe here because the problem constraints guarantee a valid input return eval(expression)"},{"question":"from typing import List, Tuple def can_form_strictly_increasing_sequence(n: int, k: int, arr: List[int]) -> str: Check if it is possible to rearrange the elements of the array to form a strictly increasing sequence using at most k swaps. >>> can_form_strictly_increasing_sequence(5, 2, [4, 3, 2, 5, 1]) == \\"Impossible\\" >>> can_form_strictly_increasing_sequence(4, 0, [1, 2, 3, 4]) == \\"Possible\\" >>> can_form_strictly_increasing_sequence(3, 1, [3, 1, 2]) == \\"Possible\\" pass def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Process multiple test cases to check if it's possible to rearrange each array into a strictly increasing sequence with at most k swaps. >>> process_test_cases(3, [(5, 2, [4, 3, 2, 5, 1]), (4, 0, [1, 2, 3, 4]), (3, 1, [3, 1, 2])]) ['Impossible', 'Possible', 'Possible'] pass","solution":"def can_form_strictly_increasing_sequence(n, k, arr): Check if it is possible to rearrange the elements of the array to form a strictly increasing sequence using at most k swaps. swaps_needed = sum(1 for i in range(1, n) if arr[i] < arr[i - 1]) return \\"Possible\\" if swaps_needed <= k else \\"Impossible\\" def process_test_cases(t, test_cases): results = [] for n, k, arr in test_cases: result = can_form_strictly_increasing_sequence(n, k, arr) results.append(result) return results # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() index = 0 t = int(data[index]) index += 1 test_cases = [] for _ in range(t): n = int(data[index]) k = int(data[index + 1]) arr = list(map(int, data[index + 2 : index + 2 + n])) index += 2 + n test_cases.append((n, k, arr)) results = process_test_cases(t, test_cases) for result in results: print(result)"},{"question":"def fibonacci(n: int) -> int: Returns the n-th number in the Fibonacci sequence. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(3) 2 >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the n-th number in the Fibonacci sequence. :param n: non-negative integer representing the position in the Fibonacci sequence. :return: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string as input and returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"def format_numbers(numbers: str) -> str: Formats a string of comma-separated numbers into a human-readable English format. >>> format_numbers(\\"1,2,3,4\\") \\"1, 2, 3 and 4\\" >>> format_numbers(\\"1,2\\") \\"1 and 2\\" >>> format_numbers(\\"1\\") \\"1\\" >>> format_numbers(\\"\\") \\"\\" from solution import format_numbers def test_format_numbers_empty_string(): assert format_numbers(\\"\\") == \\"\\" def test_format_numbers_single_number(): assert format_numbers(\\"1\\") == \\"1\\" def test_format_numbers_two_numbers(): assert format_numbers(\\"1,2\\") == \\"1 and 2\\" assert format_numbers(\\"23,42\\") == \\"23 and 42\\" def test_format_numbers_multiple_numbers(): assert format_numbers(\\"1,2,3\\") == \\"1, 2 and 3\\" assert format_numbers(\\"4,5,6,7\\") == \\"4, 5, 6 and 7\\" assert format_numbers(\\"10,20,30,40,50\\") == \\"10, 20, 30, 40 and 50\\" def test_format_numbers_large_numbers(): assert format_numbers(\\"1000,2000,3000\\") == \\"1000, 2000 and 3000\\"","solution":"def format_numbers(numbers): Formats a string of comma-separated numbers into a human-readable English format. if not numbers: return \\"\\" num_list = numbers.split(',') if len(num_list) == 1: return num_list[0] elif len(num_list) == 2: return ' and '.join(num_list) else: return ', '.join(num_list[:-1]) + ' and ' + num_list[-1]"},{"question":"import re def is_strong_password(password: str) -> bool: Check if the password is strong enough. A strong password must be at least 8 characters long, contain both uppercase and lowercase letters, include at least one digit, and one special character. >>> is_strong_password('Abcdef1!') True >>> is_strong_password('A1!bcdef') True >>> is_strong_password('Abc1!') False >>> is_strong_password('abcdef1!') False >>> is_strong_password('ABCDEF1!') False >>> is_strong_password('ABCdef!') False >>> is_strong_password('Abcdef12') False from solution import is_strong_password def test_strong_password(): assert is_strong_password('Abcdef1!') == True assert is_strong_password('A1!bcdef') == True def test_weak_password_too_short(): assert is_strong_password('Abc1!') == False def test_weak_password_no_uppercase(): assert is_strong_password('abcdef1!') == False def test_weak_password_no_lowercase(): assert is_strong_password('ABCDEF1!') == False def test_weak_password_no_digit(): assert is_strong_password('ABCdef!') == False def test_weak_password_no_special_character(): assert is_strong_password('Abcdef12') == False","solution":"import re def is_strong_password(password): return bool(re.match(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*d)(?=.*[W_]).{8,}', password))"},{"question":"def min_path_sum(matrix: List[List[int]]) -> int: Returns the minimized sum of the values along the path from the top-left to the bottom-right of the matrix. The path can only move in two directions: right and down. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([ ... [5] ... ]) == 5 >>> min_path_sum([ ... [1, 2, 3] ... ]) == 6 >>> min_path_sum([ ... [1], ... [2], ... [3] ... ]) == 6 >>> min_path_sum([ ... [1, 2], ... [3, 4] ... ]) == 7 >>> min_path_sum([ ... [1, 3, 1, 1], ... [1, 5, 1, 1], ... [4, 2, 1, 1], ... [4, 2, 1, 1] ... ]) == 9","solution":"def min_path_sum(matrix): Returns the minimized sum of the values along the path from the top-left to the bottom-right of the matrix. The path can only move in two directions: right and down. n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def longest_equal_subarray_length(nums: List[int]) -> int: Given a list of integers nums, return the length of the longest contiguous subarray such that all the elements in the subarray are equal. >>> longest_equal_subarray_length([1, 1, 0, 2, 2, 2, 3, 3, 4]) == 3 >>> longest_equal_subarray_length([1, 1, 1, 1, 1, 1]) == 6 >>> longest_equal_subarray_length([1, 1, 2, 2, 2, 1, 1, 1]) == 3 >>> longest_equal_subarray_length([1]) == 1 >>> longest_equal_subarray_length([0]) == 1 >>> longest_equal_subarray_length([1] * 10000) == 10000 >>> longest_equal_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 >>> longest_equal_subarray_length([4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7]) == 5","solution":"def longest_equal_subarray_length(nums): Returns the length of the longest contiguous subarray such that all the elements in the subarray are equal. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def water_flow(grid: List[List[int]]) -> int: Returns the number of cells from which water can flow to both the top/left and bottom/right edges. >>> water_flow([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) == 7 >>> water_flow([[1]]) == 1 >>> water_flow([]) == 0 >>> water_flow([[1, 2, 2, 2]]) == 4 >>> water_flow([[1],[2],[2],[2]]) == 4 >>> water_flow([ [10, 9, 8, 7, 6], [11, 10, 9, 8, 7], [12, 11, 10, 9, 8], [13, 12, 11, 10, 9], [14, 13, 12, 11, 10] ]) == 25","solution":"def water_flow(grid): Returns the number of cells from which water can flow to both the top/left and bottom/right edges. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y, ocean_reachable): ocean_reachable.add((x, y)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in ocean_reachable and grid[nx][ny] >= grid[x][y]: dfs(nx, ny, ocean_reachable) top_left_reachable = set() bottom_right_reachable = set() # Flow from top and left edges for i in range(m): dfs(i, 0, top_left_reachable) for j in range(n): dfs(0, j, top_left_reachable) # Flow from bottom and right edges for i in range(m): dfs(i, n - 1, bottom_right_reachable) for j in range(n): dfs(m - 1, j, bottom_right_reachable) # Intersection of reachable from both sources result = top_left_reachable & bottom_right_reachable return len(result)"},{"question":"def max_possible_score(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum possible score Rocky can achieve by selecting exactly M characters from a set of N characters based on their scores in multiple test cases. Args: T: The number of test cases. test_cases: A list where each element is a tuple containing: - A tuple with two integers (N, M) where N is the number of characters and M is the number of characters to select. - A list of integers representing the scores of the characters. Returns: A list of integers where each integer is the maximum possible score for the respective test case. Example: >>> T = 3 >>> test_cases = [ ... [(5, 3), [4, 2, 7, 1, 8]], ... [(4, 2), [1, 5, 3, 6]], ... [(6, 1), [10, 9, 8, 7, 6, 5]] ... ] >>> max_possible_score(T, test_cases) [19, 11, 10]","solution":"def max_possible_score(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] scores = test_cases[i][1] scores.sort(reverse=True) result = sum(scores[:M]) results.append(result) return results # Example usage: # T = 3 # test_cases = [ # [(5, 3), [4, 2, 7, 1, 8]], # [(4, 2), [1, 5, 3, 6]], # [(6, 1), [10, 9, 8, 7, 6, 5]] # ] # print(max_possible_score(T, test_cases)) # Outputs: [19, 11, 10]"},{"question":"def arrange_books(N): Returns the arrangement of books in the required pattern for N books. >>> arrange_books(3) [1, 2, 1] >>> arrange_books(4) [1, 2, 2, 1] >>> arrange_books(5) [1, 2, 3, 2, 1] >>> arrange_books(1) [1] >>> arrange_books(2) [1, 1] >>> arrange_books(6) [1, 2, 3, 3, 2, 1] pass def process_test_cases(M, test_cases): Process and return the results for each test case. >>> process_test_cases(3, [3, 4, 5]) [[1, 2, 1], [1, 2, 2, 1], [1, 2, 3, 2, 1]] >>> process_test_cases(2, [1, 2]) [[1], [1, 1]] >>> process_test_cases(1, [6]) [[1, 2, 3, 3, 2, 1]] pass","solution":"def arrange_books(N): Returns the arrangement of books in the required pattern for N books. books = [] for i in range(1, (N // 2) + 1): books.append(i) if N % 2 != 0: books.append((N // 2) + 1) books.extend(range((N // 2), 0, -1)) return books def process_test_cases(M, test_cases): Process and return the results for each test case. results = [] for N in test_cases: results.append(arrange_books(N)) return results"},{"question":"def filter_and_sort(lst: List[int], threshold: int) -> List[int]: Returns a new list containing only the elements from lst that are greater than threshold, sorted in descending order. :param lst: List of integers :param threshold: Integer threshold :return: List of integers >>> filter_and_sort([12, 15, 10, 20], 10) [20, 15, 12] >>> filter_and_sort([4, 7, 9], 10) [] >>> filter_and_sort([12, 5, 8, 19, 3, 10], 10) [19, 12] >>> filter_and_sort([], 10) [] >>> filter_and_sort([10, 10, 10], 10) [] >>> filter_and_sort([15, 12, 25, 11, 10], 10) [25, 15, 12, 11]","solution":"def filter_and_sort(lst, threshold): Returns a new list containing only the elements from lst that are greater than threshold, sorted in descending order. :param lst: List of integers :param threshold: Integer threshold :return: List of integers return sorted([x for x in lst if x > threshold], reverse=True)"},{"question":"from collections import defaultdict from typing import List def max_points_on_line(points: List[List[int]]) -> int: Returns the maximum number of points that lie on the same straight line. >>> max_points_on_line([[1,1], [2,2], [3,3]]) 3 >>> max_points_on_line([[1,1], [3,2], [5,3], [4,1], [2,3], [1,4]]) 4 def test_example1(): points = [[1, 1], [2, 2], [3, 3]] assert max_points_on_line(points) == 3 def test_example2(): points = [[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]] assert max_points_on_line(points) == 4 def test_single_point(): points = [[0, 0]] assert max_points_on_line(points) == 1 def test_two_points(): points = [[0, 0], [1, 1]] assert max_points_on_line(points) == 2 def test_vertical_points(): points = [[1, 1], [1, 2], [1, 3], [1, 4]] assert max_points_on_line(points) == 4 def test_duplicate_points(): points = [[1, 1], [1, 1], [2, 2], [3, 3]] assert max_points_on_line(points) == 4","solution":"from collections import defaultdict from math import gcd def max_points_on_line(points): Returns the maximum number of points that lie on the same straight line. def max_points_from_point(i): lines = defaultdict(int) duplicates = 1 vertical = 0 result = 0 for j in range(len(points)): if i != j: if points[i] == points[j]: duplicates += 1 elif points[i][0] == points[j][0]: vertical += 1 else: dx = points[j][0] - points[i][0] dy = points[j][1] - points[i][1] g = gcd(dx, dy) slope = (dy // g, dx // g) lines[slope] += 1 result = max(result, lines[slope]) return max(result, vertical) + duplicates n = len(points) if n < 3: return n result = 0 for i in range(n): result = max(result, max_points_from_point(i)) return result"},{"question":"def unique_paths(N: int, M: int, grid: List[List[str]]) -> int: Calculate the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> unique_paths(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6 >>> unique_paths(1, 1, [['.']]) 1 >>> unique_paths(6, 1, [['.'], ['.'], ['.'], ['#'], ['.'], ['.']]) 0 >>> unique_paths(1, 7, [['.', '.', '.', '#', '.', '.', '.']]) 0","solution":"def unique_paths(N, M, grid): Calculate the number of unique paths from the top-left corner to the bottom-right corner in a grid with obstacles. if grid[0][0] == '#' or grid[N-1][M-1] == '#': return 0 # If start or end is blocked, no path is possible. # 2D list for dynamic programming dp = [[0] * M for _ in range(N)] # Starting position dp[0][0] = 1 # Fill the dp table for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 # No path through an obstacle else: if i > 0: dp[i][j] += dp[i-1][j] # Add path from top if j > 0: dp[i][j] += dp[i][j-1] # Add path from left return dp[N-1][M-1]"},{"question":"def elevator(current_floor: int, requests: List[int]) -> List[int]: Simulates the behavior of an elevator in a building to fulfill floor requests in an efficient manner. Parameters: current_floor (int): The floor the elevator is currently situated on. requests (list): A list of integers representing the requested floors. Returns: list: A list representing the order of floors the elevator will visit. >>> elevator(5, [3, 8, 13, 2, 7, 12]) [7, 8, 12, 13, 3, 2] >>> elevator(3, [5, 7, 8]) [5, 7, 8] >>> elevator(10, [9, 5, 2]) [9, 5, 2] >>> elevator(5, [1, 8, 4, 7, 3]) [7, 8, 4, 3, 1] >>> elevator(5, [5, 1, 7]) [7, 1] >>> elevator(5, []) [] >>> elevator(5, [10]) [10] >>> elevator(5, [2]) [2] pass","solution":"def elevator(current_floor, requests): Simulates the behavior of an elevator in a building. Parameters: current_floor (int): The floor the elevator is currently situated on. requests (list): A list of integers representing the requested floors. Returns: list: A list representing the order of floors the elevator will visit. # Separate the requests into two lists: those above the current floor and those below above = sorted([request for request in requests if request > current_floor]) below = sorted([request for request in requests if request < current_floor], reverse=True) # First serve the requests above the current floor, then the ones below return above + below # Example usage: # current_floor = 5 # requests = [3, 8, 13, 2, 7, 12] # output = elevator(current_floor, requests) # print(output) # Should print [7, 8, 12, 13, 3, 2]"},{"question":"from typing import List, Tuple def check_subarray_sum_zero(num_cases: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given an array of integers, determine if there exists a subarray with a sum of zero. Args: num_cases (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer (length of array) and a list of integers. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> check_subarray_sum_zero(2, [(5, [4, 2, -3, 1, 6]), (3, [1, 2, 3])]) [\\"YES\\", \\"NO\\"] >>> check_subarray_sum_zero(1, [(4, [1, 2, -3, 2])]) [\\"YES\\"] def test_check_subarray_sum_zero(): assert check_subarray_sum_zero(2, [(5, [4, 2, -3, 1, 6]), (3, [1, 2, 3])]) == [\\"YES\\", \\"NO\\"] assert check_subarray_sum_zero(1, [(4, [1, 2, -3, 2])]) == [\\"YES\\"] assert check_subarray_sum_zero(1, [(5, [-1, 2, 3, -1, -3])]) == [\\"YES\\"] assert check_subarray_sum_zero(1, [(3, [1, 1, 1])]) == [\\"NO\\"] assert check_subarray_sum_zero(3, [(3, [3, -3, 3]), (3, [4, -1, -3]), (5, [5, -5, 3, 2, -5])]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert check_subarray_sum_zero(1, [(3, [1, -1, 0])]) == [\\"YES\\"] if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def check_subarray_sum_zero(num_cases, test_cases): results = [] for i in range(num_cases): N = test_cases[i][0] array = test_cases[i][1] prefix_sum = set() current_sum = 0 found = False for num in array: current_sum += num if current_sum == 0 or current_sum in prefix_sum: found = True break prefix_sum.add(current_sum) if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculate_final_grade(max_scores: List[int], student_scores: List[int]) -> int: Returns the final grade percentage of a student based on their scores compared to the maximum possible scores. The result is rounded to the nearest whole number. Args: max_scores (List[int]): A list of the maximum scores for each assignment. student_scores (List[int]): A list of the scores obtained by the student. Returns: int: The final grade as a percentage. Examples: >>> calculate_final_grade([20, 30, 50], [15, 24, 40]) 79 >>> calculate_final_grade([10, 10, 10, 10, 10], [9, 8, 10, 7, 10]) 88 >>> calculate_final_grade([100], [50]) 50","solution":"def calculate_final_grade(max_scores, student_scores): Returns the final grade percentage of a student based on their scores compared to the maximum possible scores. The result is rounded to the nearest whole number. total_max_score = sum(max_scores) total_student_score = sum(student_scores) final_grade = (total_student_score / total_max_score) * 100 return round(final_grade)"},{"question":"def length_of_lis(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the given array of integers. Example 1: >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 Example 2: >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 Example 3: >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 Note: - The length of the array will not exceed 2500. - The value of the elements in the array will be in the range [-10^4, 10^4].","solution":"def length_of_lis(nums): Returns the length of the longest increasing subsequence in the given array of integers. if not nums: return 0 # Initialize an array to hold the length of LIS ending at each index lis = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence return max(lis)"},{"question":"def search_books(titles, query): Return a list of book titles that match the search query. The search engine should be case-insensitive and should return all titles that contain the entire search query as a substring. Parameters: - titles (list of str): List of book titles - query (str): Search query Returns: - list of str: List of book titles that contain the query >>> search_books([ \\"Harry Potter and the Sorcerer's Stone\\", \\"A Game of Thrones\\", \\"The Hobbit\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\" ], \\"the\\") [\\"Harry Potter and the Sorcerer's Stone\\", \\"The Hobbit\\", \\"The Great Gatsby\\"] >>> search_books([ \\"Harry Potter and the Sorcerer's Stone\\", \\"A Game of Thrones\\", \\"The Hobbit\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\" ], \\"GREAT\\") [\\"The Great Gatsby\\"] >>> search_books([ \\"Harry Potter and the Sorcerer's Stone\\", \\"A Game of Thrones\\", \\"The Hobbit\\", \\"To Kill a Mockingbird\\", \\"The Great Gatsby\\" ], \\"game\\") [\\"A Game of Thrones\\"]","solution":"def search_books(titles, query): Returns a list of book titles that match the search query. Parameters: - titles (list of str): List of book titles - query (str): Search query Returns: - list of str: List of book titles that contain the query query_lower = query.lower() return [title for title in titles if query_lower in title.lower()]"},{"question":"from typing import List, Tuple def getGridState(m: int, moves: List[Tuple[int, int]]) -> List[List[int]]: Returns the final state of the grid after completing all moves. The grid is an m x m matrix where Alice and Bob take turns placing values. Alice places value 1 and Bob places value 2, starting with Alice. :param m: Size of the grid. :param moves: List of tuples representing the moves. :return: Final state of the grid. >>> getGridState(3, [(0, 0), (0, 1), (1, 1), (2, 2)]) [[1, 2, 0], [0, 1, 0], [0, 0, 2]] >>> getGridState(3, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]]","solution":"from typing import List, Tuple def getGridState(m: int, moves: List[Tuple[int, int]]) -> List[List[int]]: Returns the final state of the grid after completing all moves. :param m: Size of the grid. :param moves: List of tuples representing the moves. :return: Final state of the grid. grid = [[0] * m for _ in range(m)] for i, (x, y) in enumerate(moves): if i % 2 == 0: grid[x][y] = 1 else: grid[x][y] = 2 return grid"},{"question":"def fractionAddition(s: str) -> str: Evaluate and simplify the expression of fractional additions and subtractions. >>> fractionAddition(\\"-1/2+1/2\\") \\"0/1\\" >>> fractionAddition(\\"1/3-1/2\\") \\"-1/6\\" >>> fractionAddition(\\"5/3+1/3\\") \\"2/1\\"","solution":"from fractions import Fraction def fractionAddition(s: str) -> str: Function to evaluate and simplify the fractional arithmetic expression. # Split the string into list of fractions including positive and negative signs fractions = [] i = 0 while i < len(s): if s[i] == '-' or s[i] == '+': sign = s[i] i += 1 else: sign = '+' start = i while i < len(s) and s[i] != '-' and s[i] != '+': i += 1 fractions.append(sign + s[start:i]) # Convert each fraction to a Fraction object and sum them result = sum(Fraction(frac) for frac in fractions) # Return the simplified fraction as a string return f\\"{result.numerator}/{result.denominator}\\""},{"question":"def min_diff_in_subarrays(arr: List[int], k: int) -> int: Returns the minimum difference between the maximum and minimum elements of any subarray of length k. >>> min_diff_in_subarrays([10, 1, 2, 4, 7, 2], 3) 3 >>> min_diff_in_subarrays([5, 3, 10, 1], 1) 0 >>> min_diff_in_subarrays([1, 2, 3, 4, 5], 2) 1 >>> min_diff_in_subarrays([5, 4, 3, 2, 1], 3) 2 >>> min_diff_in_subarrays([1, 2, 3, 4, 5], 5) 4 >>> min_diff_in_subarrays([10], 1) 0 >>> min_diff_in_subarrays([1, 2, 3], 4) -1","solution":"def min_diff_in_subarrays(arr, k): Returns the minimum difference between the maximum and minimum elements of any subarray of length k. if k > len(arr): return -1 # k cannot be greater than the length of the array arr.sort() min_diff = float('inf') for i in range(len(arr) - k + 1): current_diff = arr[i + k - 1] - arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three distinct integers in the array. Returns 0 if the array has fewer than three integers. >>> maximum_product_of_three([1, 2, 3, 4]) 24 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([1, 2]) 0 >>> maximum_product_of_three([-1, -2, -3, -4]) -6 >>> maximum_product_of_three([-10, 10, 5, 4]) 200","solution":"def maximum_product_of_three(nums): Returns the maximum product of any three distinct integers in the array. Returns 0 if the array has fewer than three integers. if len(nums) < 3: return 0 nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def max_adjacent_pairs(animals: List[int]) -> int: Determine the maximum possible number of pairs of adjacent animals that can be of the same species after performing at most one swap operation. >>> max_adjacent_pairs([1, 2, 3, 3, 2, 1]) 3 >>> max_adjacent_pairs([1, 1, 1, 1]) 3 >>> max_adjacent_pairs([1, 2, 3, 4]) 0 >>> max_adjacent_pairs([1, 1]) 1 >>> max_adjacent_pairs([1, 2]) 0 >>> max_adjacent_pairs([1, 1, 1, 2, 2, 2]) 4 >>> max_adjacent_pairs([1, 2, 2, 1, 3, 3]) 3 >>> max_adjacent_pairs([1]) 0 >>> max_adjacent_pairs([1, 1, 2, 2, 3, 3]) 3","solution":"from typing import List def count_adjacent_pairs(animals: List[int]) -> int: count = 0 for i in range(1, len(animals)): if animals[i] == animals[i - 1]: count += 1 return count def max_adjacent_pairs(animals: List[int]) -> int: n = len(animals) if n < 2: return 0 # Calculate current number of adjacent pairs current_pairs = count_adjacent_pairs(animals) max_pairs = current_pairs # Try swapping every pair of different animals and count pairs for i in range(n): for j in range(i + 1, n): if animals[i] != animals[j]: # Swap animals[i] and animals[j] animals[i], animals[j] = animals[j], animals[i] max_pairs = max(max_pairs, count_adjacent_pairs(animals)) # Swap them back to check next pairs animals[i], animals[j] = animals[j], animals[i] return max_pairs"},{"question":"def longest_palindromic_substring_lengths(s: str, queries: List[List[int]]) -> List[int]: Given a string \`s\` and a list of query ranges represented as [start, end) (half-open intervals), implement a function that returns a list of the longest palindromic substring lengths for each query range. A palindromic substring is a substring that reads the same backward as forwards. Example 1: >>> s = \\"babad\\" >>> queries = [[0, 3], [1, 4], [0, 5]] >>> longest_palindromic_substring_lengths(s, queries) [3, 3, 3] Example 2: >>> s = \\"cbbd\\" >>> queries = [[0, 2], [1, 3], [0, 4]] >>> longest_palindromic_substring_lengths(s, queries) [1, 2, 2]","solution":"def longest_palindromic_substring_lengths(s, queries): Returns a list of the lengths of longest palindromic substrings within the specified ranges. def is_palindrome(sub): return sub == sub[::-1] def longest_palindrome_length(sub_s): n = len(sub_s) max_len = 1 for i in range(n): for j in range(i, n): if is_palindrome(sub_s[i:j+1]): max_len = max(max_len, j - i + 1) return max_len result = [] for start, end in queries: substring = s[start:end] result.append(longest_palindrome_length(substring)) return result"},{"question":"class NumArray: NumArray class to preprocess an integer array and provide functionalities of update and sumRange. Methods: def __init__(self, nums: List[int]): Initialize the object with the integer array nums. pass def update(self, index: int, val: int): Update the element at index with val. pass def sumRange(self, left: int, right: int) -> int: Return the sum of elements between indices left and right inclusive. pass >>> numArray = NumArray([1, 3, 5]) >>> numArray.sumRange(0, 2) 9 >>> numArray.update(1, 2) >>> numArray.sumRange(0, 2) 8","solution":"class NumArray: def __init__(self, nums): self.n = len(nums) self.tree = [0] * (self.n + 1) self.nums = nums for i in range(self.n): self._update_tree(i + 1, nums[i]) def _update_tree(self, index, val): while index <= self.n: self.tree[index] += val index += index & -index def _query(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def update(self, index, val): self._update_tree(index + 1, val - self.nums[index]) self.nums[index] = val def sumRange(self, left, right): return self._query(right + 1) - self._query(left)"},{"question":"def find_unique_integer(N: int, integers: List[int]) -> int: Given a list of N integers where each integer occurs exactly twice except for one integer which occurs exactly once, find and return the integer which occurs only once. Parameters: - N: int - the number of integers in the list - integers: list of int - the list of N integers Returns: int - the integer which occurs exactly once >>> find_unique_integer(5, [1, 2, 3, 2, 1]) 3 >>> find_unique_integer(3, [2, 3, 2]) 3 >>> find_unique_integer(7, [4, 5, 6, 5, 4, 6, 7]) 7 >>> find_unique_integer(9, [2, 3, 2, 3, 4, 4, 5, 6, 5]) 6 >>> find_unique_integer(7, [10, 12, 11, 11, 10, 12, 13]) 13","solution":"def find_unique_integer(N, integers): Given a list of N integers where each integer occurs exactly twice except for one integer which occurs exactly once, find and return the integer which occurs only once. Parameters: - N: int - the number of integers in the list - integers: list of int - the list of N integers Returns: int - the integer which occurs exactly once unique_int = 0 for num in integers: unique_int ^= num return unique_int"},{"question":"def findAnagramIndices(s: str, p: str) -> List[int]: Finds the starting indices of anagram substrings of p in s. :param s: The input string to be searched :param p: The anagram pattern :return: A list of starting indices of anagram substrings of p in s >>> findAnagramIndices(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAnagramIndices(\\"abcdefg\\", \\"hij\\") [] >>> findAnagramIndices(\\"anagramtanagram\\", \\"anagram\\") [0, 8]","solution":"from collections import Counter def findAnagramIndices(s, p): Finds the starting indices of anagram substrings of p in s. :param s: The input string to be searched :param p: The anagram pattern :return: A list of starting indices of anagram substrings of p in s ns, np = len(s), len(p) if np > ns: return [] p_count = Counter(p) s_count = Counter(s[:np-1]) indices = [] for i in range(np-1, ns): s_count[s[i]] += 1 if s_count == p_count: indices.append(i - np + 1) s_count[s[i - np + 1]] -= 1 if s_count[s[i - np + 1]] == 0: del s_count[s[i - np + 1]] return indices"},{"question":"[Completion Task in Python] from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime pass def divisors(n: int) -> List[int]: Returns a list of all prime divisors of the given number n. >>> divisors(28) -> [2, 7] >>> divisors(30) -> [2, 3, 5] >>> divisors(17) -> [17] >>> divisors(1) -> [] >>> divisors(77) -> [7, 11] pass","solution":"def is_prime(num): Helper function to check if a number is prime if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def divisors(n): Returns a list of prime divisors of the given number n. prime_divisors = [] for i in range(1, n + 1): if n % i == 0 and is_prime(i): prime_divisors.append(i) return prime_divisors"},{"question":"def first_non_repeating(s: str) -> str: Given a string s consisting of lowercase letters, find and return the first non-repeating character in it. If there is no non-repeating character, return a single space (' '). >>> first_non_repeating(\\"leetcode\\") 'l' >>> first_non_repeating(\\"loveleetcode\\") 'v' >>> first_non_repeating(\\"aabbcc\\") ' ' >>> first_non_repeating(\\"xyzxyz\\") ' ' def test_first_non_repeating_with_non_repeating_chars(): assert first_non_repeating(\\"leetcode\\") == 'l' assert first_non_repeating(\\"loveleetcode\\") == 'v' assert first_non_repeating(\\"abcd\\") == 'a' def test_first_non_repeating_without_non_repeating_chars(): assert first_non_repeating(\\"aabbcc\\") == ' ' assert first_non_repeating(\\"xyzxyz\\") == ' ' def test_first_non_repeating_single_char(): assert first_non_repeating(\\"a\\") == 'a' def test_first_non_repeating_repeated_char(): assert first_non_repeating(\\"aa\\") == ' ' def test_first_non_repeating_mixed_cases(): assert first_non_repeating(\\"aabcdef\\") == 'b' assert first_non_repeating(\\"ababacb\\") == 'c' def test_first_non_repeating_different_length(): assert first_non_repeating(\\"a\\"*10000 + \\"b\\") == 'b' assert first_non_repeating(\\"a\\"*5000 + \\"b\\"*5000 + \\"c\\") == 'c'","solution":"def first_non_repeating(s): Returns the first non-repeating character in the string s. If there is no such character, returns a single space (' '). from collections import OrderedDict char_count = OrderedDict() for char in s: char_count[char] = char_count.get(char, 0) + 1 for char, count in char_count.items(): if count == 1: return char return ' '"},{"question":"from typing import List, Tuple def calculate_subtree_sum(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: Calculate the sum of values in the subtree of a given node in a tree. Args: N (int): The number of nodes in the tree. values (List[int]): The values associated with each node. edges (List[Tuple[int, int]]): The edges connecting the nodes. queries (List[int]): The queries for which to calculate the subtree sums. Returns: List[int]: The sum of values in the subtree for each queried node. Examples: >>> N = 5 >>> Q = 3 >>> values = [10, 5, 12, 6, 9] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> queries = [1, 3, 4] >>> calculate_subtree_sum(N, values, edges, queries) [42, 27, 6] >>> N = 1 >>> Q = 1 >>> values = [7] >>> edges = [] >>> queries = [1] >>> calculate_subtree_sum(N, values, edges, queries) [7]","solution":"from collections import defaultdict def calculate_subtree_sum(N, values, edges, queries): def dfs(node, parent): subtree_sums[node] = values[node - 1] for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) subtree_sums[node] += subtree_sums[neighbor] tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_sums = [0] * (N + 1) dfs(1, -1) result = [] for node in queries: result.append(subtree_sums[node]) return result # Example usage: N = 5 Q = 3 values = [10, 5, 12, 6, 9] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [1, 3, 4] output = calculate_subtree_sum(N, values, edges, queries) print(output) # Output: [42, 27, 6]"},{"question":"from typing import List, Tuple def calculateHeight(edges: List[Tuple[int, int]], root: int) -> int: Determine the height of a tree. The height of a tree is the length of the longest path from the root to any leaf. Args: edges (List[Tuple[int, int]]): List of edges representing the tree, where each edge is a tuple (u, v). root (int): The root node of the tree. Returns: int: The height of the tree. Examples: >>> calculateHeight([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 1) 2 >>> calculateHeight([], 1) 0 >>> calculateHeight([(1, 2), (2, 3), (3, 4), (4, 5)], 1) 4","solution":"from typing import List, Tuple, Dict from collections import defaultdict, deque def calculateHeight(edges: List[Tuple[int, int]], root: int) -> int: # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Breadth-first search (BFS) to calculate the height def bfs_height(root: int) -> int: visited = set() queue = deque([(root, 0)]) # (node, current_height) max_height = 0 while queue: node, height = queue.popleft() if node not in visited: visited.add(node) max_height = max(height, max_height) for neighbor in tree[node]: if neighbor not in visited: queue.append((neighbor, height + 1)) return max_height return bfs_height(root)"},{"question":"def canReduceToEmptyString(s: str) -> bool: Given a string containing only letters \`A\` and \`B\`, check if it is possible to make the string empty by repeatedly performing delete operations on two adjacent letters 'A' and 'B' or 'B' and 'A'. >>> canReduceToEmptyString('AABB') True >>> canReduceToEmptyString('ABAB') True >>> canReduceToEmptyString('AABBA') False","solution":"def canReduceToEmptyString(s: str) -> bool: Checks if it is possible to reduce the string to empty by repeatedly removing 'AB' or 'BA' sequences. stack = [] for char in s: if stack and ((stack[-1] == 'A' and char == 'B') or (stack[-1] == 'B' and char == 'A')): stack.pop() else: stack.append(char) return len(stack) == 0"},{"question":"def run_length_encode(s: str) -> str: Perform run-length encoding on a given string and return the encoded string. If the encoded string is not shorter than the original string, return the original string instead. Args: s (str): The input string to encode. Returns: str: The run-length encoded string or the original string if the encoded string is not shorter. Examples: >>> run_length_encode('aabcccccaaa') 'a2b1c5a3' >>> run_length_encode('abcd') 'abcd' pass from solution import run_length_encode def test_example_1(): assert run_length_encode('aabcccccaaa') == 'a2b1c5a3' def test_example_2(): assert run_length_encode('abcd') == 'abcd' def test_single_character(): assert run_length_encode('a') == 'a' def test_no_repeats(): assert run_length_encode('abcdefgh') == 'abcdefgh' def test_all_identical_characters(): assert run_length_encode('aaaaaaa') == 'a7' def test_mixed_characters(): assert run_length_encode('aaabbbbccaa') == 'a3b4c2a2' def test_encoded_not_shorter(): assert run_length_encode('abc') == 'abc' def test_empty_string(): assert run_length_encode('') == '' def test_large_input(): input_str = 'a' * 100000 result = run_length_encode(input_str) assert result == 'a100000' assert len(result) < len(input_str)","solution":"def run_length_encode(s: str) -> str: n = len(s) if n == 0: return s encoded_str = [] count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: encoded_str.append(s[i - 1] + str(count)) count = 1 encoded_str.append(s[-1] + str(count)) encoded_result = ''.join(encoded_str) return encoded_result if len(encoded_result) < n else s"},{"question":"from typing import List def k_most_frequent_elements(arr: List[int], k: int) -> List[int]: Returns the k most frequent elements in the array. If there are multiple elements with same frequency, returns the smallest elements first. >>> k_most_frequent_elements([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> k_most_frequent_elements([1, 1, 1, 2, 2, 3], 1) [1] >>> k_most_frequent_elements([1, 1, 2, 2, 3, 3], 2) [1, 2] >>> k_most_frequent_elements([1, 2, 3], 2) [1, 2] >>> k_most_frequent_elements([4, 4, 4, 5, 5, 6], 2) [4, 5] >>> k_most_frequent_elements([1, 1, 2], 5) [1, 2] >>> k_most_frequent_elements([], 3) [] >>> k_most_frequent_elements([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> k_most_frequent_elements([1], 1) [1] >>> k_most_frequent_elements([1, 2, 3, 4, 5], 0) [] >>> k_most_frequent_elements([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3) [4, 3, 2]","solution":"from collections import Counter def k_most_frequent_elements(arr, k): Returns the k most frequent elements in the array. If there are multiple elements with same frequency, returns the smallest elements first. if not arr: return [] freq_counter = Counter(arr) sorted_elements = sorted(freq_counter.keys(), key=lambda x: (-freq_counter[x], x)) return sorted_elements[:k]"},{"question":"def find_pair_with_sum(n: int, elements: List[int], x: int) -> Union[Tuple[int, int], None]: Finds two integers in the list that sum up to a given target integer x. Returns the one where the elements have the lowest indices if there are multiple pairs. If no such pair exists, returns \\"None\\". >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 9) (4, 5) >>> find_pair_with_sum(4, [1, 2, 3, 1], 5) (2, 3) >>> find_pair_with_sum(4, [1, 2, 3, 4], 8) None from typing import List, Tuple, Union def test_find_pair_with_sum_example1(): assert find_pair_with_sum(5, [1, 2, 3, 4, 5], 9) == (4, 5) def test_find_pair_with_sum_example2(): assert find_pair_with_sum(4, [1, 2, 3, 1], 5) == (2, 3) def test_find_pair_with_sum_example3(): assert find_pair_with_sum(4, [1, 2, 3, 4], 8) == None def test_find_pair_with_sum_no_pair(): assert find_pair_with_sum(3, [11, 15, 6], 22) == None def test_find_pair_with_sum_first_pair(): assert find_pair_with_sum(6, [2, 7, 11, 15, 3, 3], 6) == (3, 3) def test_find_pair_with_sum_negatives(): assert find_pair_with_sum(5, [-1, -2, -3, -4, 1], -5) == (-2, -3) def test_find_pair_with_sum_mixed(): assert find_pair_with_sum(5, [10, -1, 8, -10, 20], 0) == (10, -10) def test_find_pair_with_sum_large_numbers(): assert find_pair_with_sum(4, [int(1e9), int(-1e9), 2, 3], 0) == (1000000000, -1000000000)","solution":"def find_pair_with_sum(n, elements, x): Finds two integers in the list that sum up to a given target integer x. Returns the one where the elements have the lowest indices if there are multiple pairs. If no such pair exists, returns \\"None\\". seen = {} for index, number in enumerate(elements): complement = x - number if complement in seen: return elements[seen[complement]], number seen[number] = index return None"},{"question":"from collections import deque def shortest_path(n, maze): Analyze a square maze represented by a 2D array and determine the shortest path to navigate from the top-left corner to the bottom-right corner. The maze is composed of walls (represented by 1s) and open spaces (represented by 0s). Find the shortest path from the start point (0, 0) to the finish point (n-1, n-1). You are allowed to move up, down, left, or right, but you cannot move diagonally or through walls. Input: - n: an integer representing the size of the n x n maze, where 2 <= n <= 100 - maze: a 2D list (or array) where each nested list represents a row of the maze, and each element within a nested list is either 0 (open space) or 1 (wall) Output: The function should return an integer representing the number of steps in the shortest path from (0, 0) to (n-1, n-1). If there is no valid path, the function should return -1. Example: n = 5 maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] Output: 8 Explanation: The shortest path is as follows: (0, 0) -> (1, 0) -> (2, 0) -> (2, 1) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3) -> (4, 4), resulting in a total of 8 steps. Test Cases: >>> maze = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> shortest_path(5, maze) 8 >>> maze = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path(2, maze) -1 >>> maze = [ ... [0, 0, 0], ... [1, 1, 0], ... [1, 1, 0] ... ] >>> shortest_path(3, maze) 4 >>> maze = [ ... [0] * 10 for _ in range(10) ... ] >>> shortest_path(10, maze) 18 >>> maze = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> shortest_path(3, maze) -1 >>> maze = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> shortest_path(3, maze) -1","solution":"from collections import deque def shortest_path(n, maze): Returns the shortest path length from the top-left to the bottom-right corner of the maze. If no path exists, returns -1. if maze[0][0] == 1 or maze[n-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == n-1 and c == n-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and maze[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def remove_duplicates(input_list): Returns a new list with all duplicates removed, preserving the original order of elements. :param input_list: List[int] - List of integers that may contain duplicates :return: List[int] - List of integers with duplicates removed >>> remove_duplicates([1, 2, 3, 1, 2, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([5, 5, 5, 5, 5]) == [5] >>> remove_duplicates([]) == [] >>> remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([1, 3, 1, 4, 3, 5, 6, 6]) == [1, 3, 4, 5, 6]","solution":"def remove_duplicates(input_list): Returns a new list with all duplicates removed, preserving the original order of elements. :param input_list: List[int] - List of integers that may contain duplicates :return: List[int] - List of integers with duplicates removed seen = set() result = [] for item in input_list: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def prime_factors(n: int) -> List[int]: Write a function that takes an integer \`n\` and returns a list of all the prime factors of \`n\`. A prime factor is a prime number that divides \`n\` without leaving a remainder. The returned list should be sorted in ascending order. >>> prime_factors(28) # [2, 7] >>> prime_factors(60) # [2, 3, 5] >>> prime_factors(13) # [13] >>> prime_factors(1) # []","solution":"def prime_factors(n): Returns a list of all prime factors of the integer n in ascending order. if n < 2: return [] factors = [] divisor = 2 while n >= 2: if n % divisor == 0: if divisor not in factors: factors.append(divisor) n = n // divisor else: divisor += 1 return factors"},{"question":"def fibonacci_word_length(n: int) -> int: Returns the length of the nth Fibonacci word. >>> fibonacci_word_length(1) == 1 >>> fibonacci_word_length(2) == 1 >>> fibonacci_word_length(3) == 2 >>> fibonacci_word_length(4) == 3 >>> fibonacci_word_length(5) == 5 >>> fibonacci_word_length(6) == 8 >>> fibonacci_word_length(7) == 13 >>> fibonacci_word_length(8) == 21 >>> fibonacci_word_length(9) == 34 >>> fibonacci_word_length(10) == 55 >>> fibonacci_word_length(20) == 6765 >>> fibonacci_word_length(30) == 832040 >>> fibonacci_word_length(40) == 102334155 >>> fibonacci_word_length(50) == 12586269025","solution":"def fibonacci_word_length(n): Returns the length of the nth Fibonacci word. if n == 1 or n == 2: return 1 prev = 1 curr = 1 for _ in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"class FenwickTree: def __init__(self, size: int): Initializes the Fenwick Tree with a given size. pass def update(self, index: int, value: int): Updates the tree by adding the value at the given index. pass def query(self, index: int) -> int: Returns the sum from the start to the given index. pass def range_query(self, left: int, right: int) -> int: Returns the sum of elements in the range from left to right (inclusive). pass def process_queries(array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes a list of queries on the given array. Args: array (List[int]): Array of integers. queries (List[Tuple[int, int, int]]): Queries to process. Returns: List[int]: Results of queries of Type 1. >>> array = [1, 2, 3, 4, 5] >>> queries = [(1, 1, 3), (2, 3, 5), (1, 2, 5), (3, 4, 10)] >>> process_queries(array, queries) [6, 24, 36] pass # Example tests def test_process_queries_type1(): array = [1, 2, 3, 4, 5] queries = [ (1, 1, 3), # Sum from index 1 to 3 should be 1+2+3 = 6 (1, 2, 5) # Sum from index 2 to 5 should be 2+3+4+5 = 14 ] result = process_queries(array, queries) assert result == [6, 14] def test_process_queries_type2(): array = [1, 2, 3, 4, 5] queries = [ (2, 3, 5), # Increment index 1 to 3 by 5: array becomes [6, 7, 8, 4, 5] (1, 1, 3), # Sum from index 1 to 3 should be 6+7+8 = 21 ] result = process_queries(array, queries) assert result == [21] def test_process_queries_type3(): array = [1, 2, 3, 4, 5] queries = [ (3, 4, 10), # Set index 4 to 10: array becomes [1, 2, 3, 10, 5] (1, 1, 5) # Sum from index 1 to 5 should be 1+2+3+10+5 = 21 ] result = process_queries(array, queries) assert result == [21] def test_process_queries_mixed(): array = [1, 2, 3, 4, 5] queries = [ (1, 1, 3), # Sum from index 1 to 3 should be 1+2+3 = 6 (2, 3, 5), # Increment index 1 to 3 by 5: array becomes [6, 7, 8, 4, 5] (1, 2, 5), # Sum from index 2 to 5 should be 7+8+4+5 = 24 (3, 4, 10), # Set index 4 to 10: array becomes [6, 7, 8, 10, 5] (1, 1, 5) # Sum from index 1 to 5 should be 6+7+8+10+5 = 36 ] result = process_queries(array, queries) assert result == [6, 24, 36]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, value): while index <= self.size: self.tree[index] += value index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): return self.query(right) - self.query(left - 1) def process_queries(array, queries): n = len(array) fenwick_tree = FenwickTree(n) # Build the initial Fenwick tree with the given array for i in range(n): fenwick_tree.update(i + 1, array[i]) results = [] for query in queries: type_query = query[0] if type_query == 1: # Sum from l to r l, r = query[1], query[2] results.append(fenwick_tree.range_query(l, r)) elif type_query == 2: # Increment from 1 to x by value x, val = query[1], query[2] for i in range(1, x + 1): fenwick_tree.update(i, val) elif type_query == 3: # Set array index to new_val i, new_val = query[1], query[2] # Update the difference to the Fenwick tree current_val = fenwick_tree.range_query(i, i) diff = new_val - current_val fenwick_tree.update(i, diff) return results"},{"question":"def can_be_valid_bracket_sequence(s: str) -> str: Determine if the string can be converted to a valid balanced bracket sequence. Args: s (str): A string consisting only of '(', ')' and '*'. Returns: str: \\"Yes\\" if the string can be a valid balanced bracket sequence, \\"No\\" otherwise. Examples: >>> can_be_valid_bracket_sequence(\\"(*)\\") \\"Yes\\" >>> can_be_valid_bracket_sequence(\\"(*)*\\") \\"Yes\\" >>> can_be_valid_bracket_sequence(\\")*(\\") \\"No\\"","solution":"def can_be_valid_bracket_sequence(s): min_open = max_open = 0 for char in s: if char == '(': min_open += 1 max_open += 1 elif char == ')': if min_open > 0: min_open -= 1 max_open -= 1 else: # char == '*' if min_open > 0: min_open -= 1 max_open += 1 if max_open < 0: # More closing brackets than open brackets return \\"No\\" if min_open == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing non-negative integers and the operators +, -, *, / (without parentheses), adhering to the standard order of operations (PEMDAS/BODMAS). The division operator should perform integer division. >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"5-3\\") 2 >>> evaluate_expression(\\"4*2\\") 8 >>> evaluate_expression(\\"8/2\\") 4 >>> evaluate_expression(\\"3+5*2-10/2\\") 8 >>> evaluate_expression(\\"10+2*3\\") 16 >>> evaluate_expression(\\"14-3/2\\") 13 >>> evaluate_expression(\\"2*3/2\\") 3 >>> evaluate_expression(\\"18/3*2\\") 12 >>> evaluate_expression(\\"1+2+3\\") 6 # Implement the function here","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing non-negative integers and the operators +, -, *, / (without parentheses), adhering to the standard order of operations (PEMDAS/BODMAS). import re # Helper function to perform basic arithmetic operations between two operands def apply_operator(operands, operator): b = operands.pop() a = operands.pop() if operator == '+': operands.append(a + b) elif operator == '-': operands.append(a - b) elif operator == '*': operands.append(a * b) elif operator == '/': operands.append(a // b) # Regular expression to tokenize the expression into integers and operators tokens = re.findall(r'd+|[+*/-]', expression) # Two stacks to hold the operands and operators operands = [] operators = [] # Operator precedence mapping precedence = {'+': 1, '-': 1, '*': 2, '/': 2} for token in tokens: if token.isdigit(): operands.append(int(token)) else: while (operators and precedence[operators[-1]] >= precedence[token]): apply_operator(operands, operators.pop()) operators.append(token) while operators: apply_operator(operands, operators.pop()) return operands[0]"},{"question":"def smallest_subarray_with_sum(arr: List[int], n: int) -> int: Returns the length of the smallest contiguous subarray for which the sum of its elements is greater than or equal to n. If no such subarray exists, return 0. >>> smallest_subarray_with_sum([2, 1, 5, 2, 3, 2], 7) 2 >>> smallest_subarray_with_sum([2, 1, 5, 2, 8], 7) 1 >>> smallest_subarray_with_sum([3, 4, 1, 1, 6], 8) 3 >>> smallest_subarray_with_sum([1, 2, 3], 10) 0 >>> smallest_subarray_with_sum([10], 5) 1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_sum([5, 1, 4], 5) 1","solution":"def smallest_subarray_with_sum(arr, n): Returns the length of the smallest contiguous subarray for which the sum of its elements is greater than or equal to n. If no such subarray exists, return 0. min_length = float('inf') curr_sum = 0 start = 0 for end in range(len(arr)): curr_sum += arr[end] while curr_sum >= n: min_length = min(min_length, end - start + 1) curr_sum -= arr[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def trap(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped between columns. Parameters: heights (list of int): A list of non-negative integers where each represents the height of a column. Returns: int: Total amount of trapped water. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([5]) 0 >>> trap([2, 2]) 0 >>> trap([3, 0, 3]) 3","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped between columns. Parameters: heights (list of int): A list of non-negative integers where each represents the height of a column. Returns: int: Total amount of trapped water. if not heights: return 0 n = len(heights) # Initialize left_max and right_max arrays left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def convert_to_title(n: int) -> str: Convert a given integer to its corresponding column title as it appears in an Excel sheet. >>> convert_to_title(1) \\"A\\" >>> convert_to_title(28) \\"AB\\" >>> convert_to_title(701) \\"ZY\\" >>> convert_to_title(702) \\"ZZ\\" >>> convert_to_title(703) \\"AAA\\"","solution":"def convert_to_title(n: int) -> str: Convert a given integer to its corresponding column title as it appears in an Excel sheet. result = [] while n > 0: n -= 1 # Adjust so that it fits 0-based index system result.append(chr(n % 26 + ord('A'))) n //= 26 return ''.join(result[::-1])"},{"question":"def valid_bracket_sequences(sequence: str) -> bool: Determine whether a string consists of valid sequences of round brackets, square brackets, and curly braces. The sequence is valid if brackets are closed in the correct order. >>> valid_bracket_sequences(\\"()[]{}\\") True >>> valid_bracket_sequences(\\"{[()()]}\\") True >>> valid_bracket_sequences(\\"{[(])}\\") False >>> valid_bracket_sequences(\\"[{}([{})]\\") False >>> valid_bracket_sequences(\\"a{b[c(d)e]f}g\\") True >>> valid_bracket_sequences(\\"\\") True","solution":"def valid_bracket_sequences(sequence: str) -> bool: Determines whether a string consists of valid sequences of round brackets, square brackets, and curly braces. The sequence is valid if the brackets are closed in the correct order. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if stack == [] or stack.pop() != matching_bracket[char]: return False # Ignore non-bracket characters return stack == []"},{"question":"def find_pairs(input_string: str) -> List[Tuple[str, str]]: Given an input string of words where the words are separated by spaces, return a list containing pairs of the first and last letter of each word. >>> find_pairs(\\"hello world\\") == [('h', 'o'), ('w', 'd')] >>> find_pairs(\\"programming is fun\\") == [('p', 'g'), ('i', 's'), ('f', 'n')] >>> find_pairs(\\"a b c\\") == [('a', 'a'), ('b', 'b'), ('c', 'c')] from typing import List, Tuple def test_find_pairs_single_word(): assert find_pairs(\\"hello\\") == [('h', 'o')] def test_find_pairs_multiple_words(): assert find_pairs(\\"hello world\\") == [('h', 'o'), ('w', 'd')] def test_find_pairs_with_mixed_length_words(): assert find_pairs(\\"programming is fun\\") == [('p', 'g'), ('i', 's'), ('f', 'n')] def test_find_pairs_single_letter_words(): assert find_pairs(\\"a b c\\") == [('a', 'a'), ('b', 'b'), ('c', 'c')] def test_find_pairs_empty_string(): assert find_pairs(\\"\\") == [] def test_find_pairs_words_with_repeated_characters(): assert find_pairs(\\"aaa bbb ccc\\") == [('a', 'a'), ('b', 'b'), ('c', 'c')] def test_find_pairs_words_with_same_start_and_end_letters(): assert find_pairs(\\"radar level rotor\\") == [('r', 'r'), ('l', 'l'), ('r', 'r')]","solution":"def find_pairs(input_string): Returns a list of tuples containing the first and last letter of each word. words = input_string.split() return [(word[0], word[-1]) for word in words]"},{"question":"def join_elements(arr, delimiter): Concatenates the elements of the array using the given delimiter. Parameters: - arr (list): List of strings to be concatenated. - delimiter (str): The delimiter to be used between elements. Returns: - str: A single concatenated string. Examples: >>> join_elements(['Python', 'is', 'fun'], \\" \\") == \\"Python is fun\\" >>> join_elements(['1', '2', '3'], \\"-\\") == \\"1-2-3\\" >>> join_elements(['apple', 'banana', 'cherry'], \\"\\") == \\"applebananacherry\\" >>> join_elements([], \\",\\") == \\"\\"","solution":"def join_elements(arr, delimiter): Concatenates the elements of the array using the given delimiter. Parameters: - arr (list): List of strings to be concatenated. - delimiter (str): The delimiter to be used between elements. Returns: - str: A single concatenated string. return delimiter.join(arr)"},{"question":"from typing import List, Tuple def dijkstra(graph: dict, start: int) -> dict: Returns the shortest distance from start to all other nodes using Dijkstra's algorithm. pass def shortest_travel_time(m: int, n: int, roads: List[Tuple[int, int, int]], K: int, special_landmarks: List[int]) -> int: Determines the shortest travel time required to visit all the given special landmarks starting from any one of them. :param m: number of landmarks :param n: number of roads :param roads: list of tuples with roads information (u, v, t) where 'u' and 'v' are landmarks and 't' is travel time :param K: number of special landmarks :param special_landmarks: list of special landmark IDs :return: the shortest travel time required to visit all special landmarks starting and ending at any one special landmark >>> shortest_travel_time(5, 7, [(1, 2, 3), (1, 3, 1), (1, 4, 6), (2, 3, 1), (2, 5, 2), (3, 5, 5), (4, 5, 2)], 3, [1, 3, 5]) 8 >>> shortest_travel_time(4, 4, [(1, 2, 4), (2, 3, 5), (3, 4, 2), (1, 4, 7)], 2, [1, 3]) 18 >>> shortest_travel_time(4, 4, [(1, 2, 4), (2, 3, 5), (3, 4, 2), (1, 4, 7)], 1, [1]) 0 pass","solution":"import heapq from itertools import permutations def dijkstra(graph, start): Returns the shortest distance from start to all other nodes using Dijkstra's algorithm. min_heap = [(0, start)] # (distance, vertex) distances = {node: float('inf') for node in graph} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances def shortest_travel_time(m, n, roads, K, special_landmarks): graph = {i: [] for i in range(1, m + 1)} for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Compute shortest paths from each special landmark sp_distances = {} for landmark in special_landmarks: sp_distances[landmark] = dijkstra(graph, landmark) # Generate all permutations of visiting special landmarks shortest_time = float('inf') for perm in permutations(special_landmarks): current_time = 0 for i in range(len(perm) - 1): current_time += sp_distances[perm[i]][perm[i+1]] current_time += sp_distances[perm[-1]][perm[0]] # Return to the start shortest_time = min(shortest_time, current_time) return shortest_time"},{"question":"def can_be_password(n: int, s: str) -> str: Determines if the given string \`s\` of length \`n\` can be a valid password. The password must satisfy the following conditions: 1. The password must be of length \`n\` where \`1 <= n <= 10^5\`. 2. The password must contain at least one vowel (\`a\`, \`e\`, \`i\`, \`o\`, \`u\`). 3. The password must contain at least one consonant (all alphabets excluding \`a\`, \`e\`, \`i\`, \`o\`, \`u\`). 4. The password can only contain lowercase alphabets (\`a\` to \`z\`). >>> can_be_password(5, 'hello') 'YES' >>> can_be_password(4, 'abcd') 'YES' >>> can_be_password(6, 'aeiouj') 'YES' >>> can_be_password(3, 'xyz') 'NO' def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases and returns the results as a list of strings. >>> test_cases = [ ... (5, 'hello'), ... (4, 'abcd'), ... (6, 'aeiouj'), ... (3, 'xyz'), ... ] >>> results = process_test_cases(4, test_cases) >>> results ['YES', 'YES', 'YES', 'NO'] from typing import List, Tuple def test_can_be_password(): assert can_be_password(5, 'hello') == \\"YES\\" assert can_be_password(4, 'abcd') == \\"YES\\" assert can_be_password(6, 'aeiouj') == \\"YES\\" assert can_be_password(3, 'xyz') == \\"NO\\" assert can_be_password(7, 'pqrstuv') == \\"YES\\" assert can_be_password(1, 'a') == \\"NO\\" # Only one vowel, no consonants assert can_be_password(1, 'b') == \\"NO\\" # Only one consonant, no vowels assert can_be_password(2, 'ab') == \\"YES\\" assert can_be_password(5, 'xyzae') == \\"YES\\" assert can_be_password(2, 'io') == \\"NO\\" # Only two vowels, no consonants def test_process_test_cases(): test_cases = [ (5, 'hello'), (4, 'abcd'), (6, 'aeiouj'), (3, 'xyz'), ] results = process_test_cases(4, test_cases) assert results == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [ (7, 'pqrstuv'), (1, 'a'), (1, 'b'), (2, 'ab'), (5, 'xyzae'), (2, 'io') ] results = process_test_cases(6, test_cases) assert results == [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] if __name__ == \\"__main__\\": test_can_be_password() test_process_test_cases() print(\\"All tests passed!\\")","solution":"def can_be_password(n, s): Determines if the given string \`s\` of length \`n\` can be a valid password. vowels = set('aeiou') contains_vowel = False contains_consonant = False for char in s: if char in vowels: contains_vowel = True else: contains_consonant = True if contains_vowel and contains_consonant: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list of strings. results = [] for i in range(t): n, s = test_cases[i] result = can_be_password(n, s) results.append(result) return results"},{"question":"def are_anagrams(first: str, second: str) -> bool: Determines whether the second string can be obtained by rearranging the characters of the first string. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pabble\\") False >>> are_anagrams(\\"rat\\", \\"car\\") False >>> are_anagrams(\\"\\", \\"\\") True >>> are_anagrams(\\"a\\", \\"\\") False >>> are_anagrams(\\"ab\\", \\"a\\") False","solution":"def are_anagrams(first, second): Returns True if the second string can be obtained by rearranging the characters of the first string, otherwise returns False. # Both strings must be of the same length to be anagrams if len(first) != len(second): return False # Use a frequency counter to compare character counts in both strings from collections import Counter return Counter(first) == Counter(second)"},{"question":"def find_k_largest_palindromes_in_range(lower_limit: int, upper_limit: int, k: int) -> List[int]: Implement a function \`find_k_largest_palindromes_in_range\` that accepts three arguments: \`lower_limit\`, \`upper_limit\`, and \`k\`. The function should return the \`k\` largest palindromic numbers within the inclusive range from \`lower_limit\` to \`upper_limit\`. A palindromic number is a number that remains the same when its digits are reversed. Example: >>> find_k_largest_palindromes_in_range(10, 200, 5) [191, 181, 171, 161, 151] >>> find_k_largest_palindromes_in_range(100, 500, 3) [494, 484, 474] >>> find_k_largest_palindromes_in_range(50, 60, 2) [55] from solution import find_k_largest_palindromes_in_range def test_find_k_largest_palindromes_in_range_case1(): assert find_k_largest_palindromes_in_range(10, 200, 5) == [191, 181, 171, 161, 151], \\"test case 1 failed\\" def test_find_k_largest_palindromes_in_range_case2(): assert find_k_largest_palindromes_in_range(100, 500, 3) == [494, 484, 474], \\"test case 2 failed\\" def test_find_k_largest_palindromes_in_range_case3(): assert find_k_largest_palindromes_in_range(50, 60, 2) == [55], \\"test case 3 failed\\" def test_find_k_largest_palindromes_in_range_no_k(): assert find_k_largest_palindromes_in_range(1, 9, 3) == [9, 8, 7], \\"test no k failed\\" def test_find_k_largest_palindromes_in_range_less_than_k(): assert find_k_largest_palindromes_in_range(1, 20, 50) == [11, 9, 8, 7, 6, 5, 4, 3, 2, 1], \\"test less than k failed\\"","solution":"def find_k_largest_palindromes_in_range(lower_limit, upper_limit, k): Returns the k largest palindromic numbers within the inclusive range from lower_limit to upper_limit. def is_palindrome(num): return str(num) == str(num)[::-1] palindromes = [num for num in range(upper_limit, lower_limit - 1, -1) if is_palindrome(num)] return palindromes[:k]"},{"question":"def deepest_directory_depth(paths: List[str]) -> int: Returns the depth of the deepest directory from a list of directory paths. >>> deepest_directory_depth([\\"/usr/bin\\", \\"/usr/bin/python\\", \\"/usr/local/bin\\", \\"/home/user/documents/pictures/vacation\\"]) 5 >>> deepest_directory_depth([\\"/usr\\", \\"/bin\\", \\"/etc\\"]) 1 >>> deepest_directory_depth([]) 0 >>> deepest_directory_depth([\\"/a/b/c\\", \\"/d/e/f\\"]) 3 >>> deepest_directory_depth([\\"/a\\", \\"/a/b/c\\", \\"/a/b/c/d/e\\", \\"/f/g/h\\"]) 5 >>> deepest_directory_depth([\\"/\\", \\"/a\\", \\"/b/c\\", \\"/d/e/f/g/h/i\\"]) 6","solution":"def deepest_directory_depth(paths): Returns the depth of the deepest directory from a list of directory paths. :param paths: List of strings representing directory paths :return: An integer representing the depth of the deepest directory max_depth = 0 for path in paths: # Split path by '/' and filter out empty strings (which occur from leading '/') depth = len([dir for dir in path.split('/') if dir]) if depth > max_depth: max_depth = depth return max_depth"},{"question":"import heapq from collections import defaultdict, deque from typing import List, Tuple def find_minimum_time(N: int, M: int, paths: List[Tuple[int, int, int]]) -> int: Determine the minimum time required from the initial station (Vertex 1) to the final station (Vertex N) in a directed acyclic graph (DAG). Args: N : int : the number of workstations M : int : the number of paths paths : List[Tuple[int, int, int]] : a list of tuples where each tuple contains (u, v, w) - u : int : the starting workstation of the path - v : int : the ending workstation of the path - w : int : the time taken to traverse the path Returns: int : the minimum time required from station 1 to station N; if there is no path, return -1 Examples: >>> find_minimum_time(5, 6, [(1, 2, 10), (1, 3, 20), (2, 4, 15), (3, 4, 10), (4, 5, 5), (3, 5, 30)]) 30 >>> find_minimum_time(3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 15)]) 15 >>> find_minimum_time(4, 2, [(1, 2, 10), (3, 4, 20)]) -1","solution":"import heapq from collections import defaultdict, deque def find_minimum_time(N, M, paths): # Create the graph as an adjacency list graph = defaultdict(list) for u, v, w in paths: graph[u].append((v, w)) # Topological sorting using Kahn's algorithm in_degree = [0] * (N + 1) for u in range(1, N + 1): for v, w in graph[u]: in_degree[v] += 1 zero_in_degree_queue = deque([u for u in range(1, N + 1) if in_degree[u] == 0]) topo_order = [] while zero_in_degree_queue: u = zero_in_degree_queue.popleft() topo_order.append(u) for v, w in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: zero_in_degree_queue.append(v) # If there is no valid topological order, it means we cannot sort the graph. if len(topo_order) != N: return -1 # Initialize distances with infinity, except for the first node distances = [float('inf')] * (N + 1) distances[1] = 0 # Process nodes in topological order for u in topo_order: for v, w in graph[u]: if distances[u] != float('inf') and distances[u] + w < distances[v]: distances[v] = distances[u] + w # Return the distance to the final node, or -1 if it's still infinity return distances[N] if distances[N] != float('inf') else -1"},{"question":"def sum_of_differences(arr): Returns the sum of the differences between consecutive integers in the array, provided the integers are sorted in descending order. >>> sum_of_differences([2, 1, 10]) 9 >>> sum_of_differences([5]) 0 >>> sum_of_differences([]) 0 >>> sum_of_differences([10, 2, 1]) 9 >>> sum_of_differences([20, 10, 5, 1]) 19 >>> sum_of_differences([1, 2, 3]) 2 >>> sum_of_differences([3, 2, 1]) 2 >>> sum_of_differences([7, 7, 7, 7]) 0 >>> sum_of_differences([5, 5, 5]) 0 >>> sum_of_differences([42]) 0 >>> sum_of_differences([50, 25]) 25 >>> sum_of_differences([25, 50]) 25 pass def test_sum_of_differences_standard_cases(): assert sum_of_differences([2, 1, 10]) == 9 assert sum_of_differences([5]) == 0 assert sum_of_differences([]) == 0 def test_sum_of_differences_sorted_input(): assert sum_of_differences([10, 2, 1]) == 9 assert sum_of_differences([20, 10, 5, 1]) == 19 def test_sum_of_differences_unsorted_input(): assert sum_of_differences([1, 2, 3]) == 2 assert sum_of_differences([3, 2, 1]) == 2 def test_sum_of_differences_all_equal_elements(): assert sum_of_differences([7, 7, 7, 7]) == 0 assert sum_of_differences([5, 5, 5]) == 0 def test_sum_of_differences_single_element(): assert sum_of_differences([42]) == 0 def test_sum_of_differences_two_elements(): assert sum_of_differences([50, 25]) == 25 assert sum_of_differences([25, 50]) == 25","solution":"def sum_of_differences(arr): Returns the sum of the differences between consecutive integers in the array, provided the integers are sorted in descending order. if len(arr) < 2: return 0 arr.sort(reverse=True) return sum(arr[i] - arr[i+1] for i in range(len(arr) - 1))"},{"question":"def rearrange_string(s: str) -> str: Rearranges the input string such that no two identical characters are adjacent. If it's not possible, returns an empty string. >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"acabab\\", \\"acabba\\", \\"babaca\\", \\"bacaba\\", \\"babcaa\\"] True >>> rearrange_string(\\"aaabb\\") in [\\"ababa\\", \\"abbaa\\", \\"baaba\\"] True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"aaa\\") == \\"\\" True >>> rearrange_string(\\"bbbb\\") == \\"\\" True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"abcacb\\", \\"abcbac\\", \\"acbacb\\"] True >>> rearrange_string(\\"aabbccddeeffgghhiijjkkll\\") != \\"\\" True","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the input string such that no two identical characters are adjacent. If it's not possible, returns an empty string. if not s: return \\"\\" # Counting frequency of each character char_freq = Counter(s) # Max-Heap to store characters by their frequencies max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) result = [] prev_char = None prev_freq = 0 while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"def incremental_pairs(lst: list) -> list: Given a list of integers, returns a list of incremental pairs. Each pair consists of two consecutive integers where the second integer is exactly one greater than the first. >>> incremental_pairs([1, 2, 3, 5, 6, 7, 8]) [[1, 2], [2, 3], [5, 6], [6, 7], [7, 8]] >>> incremental_pairs([10, 11, 13, 14, 16]) [[10, 11], [13, 14]] >>> incremental_pairs([4, 4, 4, 4]) [] >>> incremental_pairs([1, 3, 5, 7]) []","solution":"def incremental_pairs(lst: list) -> list: Given a list of integers, returns a list of incremental pairs. Each pair consists of two consecutive integers where the second integer is exactly one greater than the first. pairs = [] for i in range(len(lst) - 1): if lst[i+1] == lst[i] + 1: pairs.append([lst[i], lst[i+1]]) return pairs"},{"question":"def min_walking_distance(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Given the number of test cases 't' and a list of 'test_cases', where each test case contains: - dims: A tuple (N, M), where N is the number of shelves and M is the number of items. - positions: A list of M integers representing the positions of the items on the shelves. This function returns a list of integers, each representing the minimum walking distance required to collect all M items for the corresponding test case. >>> min_walking_distance(2, [{'dims': (5, 3), 'positions': [1, 3, 5]}, {'dims': (7, 4), 'positions': [2, 4, 6, 7]}]) [4, 5] >>> min_walking_distance(1, [{'dims': (4, 2), 'positions': [1, 4]}]) [3]","solution":"def min_walking_distance(t, test_cases): results = [] for i in range(t): N, M = test_cases[i]['dims'] items = sorted(test_cases[i]['positions']) distance = items[-1] - items[0] results.append(distance) return results"},{"question":"def formatPhoneNumber(number: str) -> str: Formats a string of 10 digits into the format (XXX) XXX-XXXX. Args: number (str): A string containing exactly 10 digits. Returns: str: The formatted phone number. Examples: >>> formatPhoneNumber(\\"1234567890\\") '(123) 456-7890' >>> formatPhoneNumber(\\" 987 654 3210 \\") '(987) 654-3210' def test_formatPhoneNumber_standard(): assert formatPhoneNumber(\\"1234567890\\") == \\"(123) 456-7890\\" def test_formatPhoneNumber_with_spaces(): assert formatPhoneNumber(\\" 987 654 3210 \\") == \\"(987) 654-3210\\" def test_formatPhoneNumber_mixed_spaces(): assert formatPhoneNumber(\\" 123 456 7890 \\") == \\"(123) 456-7890\\" def test_formatPhoneNumber_with_no_spaces(): assert formatPhoneNumber(\\"9876543210\\") == \\"(987) 654-3210\\" def test_formatPhoneNumber_with_tabs(): assert formatPhoneNumber(\\"t123t456t7890t\\") == \\"(123) 456-7890\\" def test_formatPhoneNumber_with_multiple_spaces(): assert formatPhoneNumber(\\"123 456 7890\\") == \\"(123) 456-7890\\"","solution":"def formatPhoneNumber(number): Formats a string of 10 digits into the format (XXX) XXX-XXXX. Args: number (str): A string containing exactly 10 digits. Returns: str: The formatted phone number. # Remove whitespaces from the input string cleaned_number = ''.join(number.split()) # Format the string into (XXX) XXX-XXXX formatted_number = f\\"({cleaned_number[:3]}) {cleaned_number[3:6]}-{cleaned_number[6:]}\\" return formatted_number"},{"question":"def trap_rain_water(height): Given a list of non-negative integers representing the heights of buildings, returns the total amount of rainwater that can be trapped. Args: height (List[int]): A list of non-negative integers representing the heights of buildings. Returns: int: The total amount of rainwater that can be trapped. Examples: >>> trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_rain_water([2,0,2]) 2 >>> trap_rain_water([1,2,3,4,5]) 0","solution":"def trap_rain_water(height): Given a list of non-negative integers representing the heights of buildings, returns the total amount of rainwater that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Write a function that takes an integer \`n\` and returns a list of all prime numbers less than \`n\` using the Sieve of Eratosthenes algorithm without direct list/array manipulation methods. >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(2) [] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]","solution":"def sieve_of_eratosthenes(n): Returns a list of prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] primes = [True] * n primes[0] = primes[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n, p): primes[i] = False p += 1 primes_list = [x for x in range(n) if primes[x]] return primes_list"},{"question":"from typing import List def count_unique_pairs(nums: List[int], target_sum: int) -> int: Returns the number of unique pairs (a, b) in the list such that a + b == target_sum. Each pair should be counted only once, and the order of the integers in the pair does not matter. >>> count_unique_pairs([1, 5, 3, 3, 7, 9, 2], 10) 2 >>> count_unique_pairs([1, 2, 3, 4, 5], 8) 1 >>> count_unique_pairs([2, 2, 2, 2], 4) 1 >>> count_unique_pairs([], 5) 0 >>> count_unique_pairs([1, 2, 3, 4], 10) 0 >>> count_unique_pairs([-1, 1, 2, -2, 3], 1) 2 >>> count_unique_pairs([1, -1, 2, -2, 3, -3, 4, -4], 0) 4","solution":"def count_unique_pairs(nums, target_sum): Returns the number of unique pairs (a, b) in the list such that a + b == target_sum. Each pair should be counted only once, and the order of the integers in the pair does not matter. seen = set() pairs = set() for num in nums: difference = target_sum - num if difference in seen: pairs.add((min(num, difference), max(num, difference))) seen.add(num) return len(pairs)"},{"question":"from typing import List, Tuple def partition_ages(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Partition the ages into the minimal number of groups such that the maximum difference in age within each group is minimized. >>> partition_ages(2, [((5, 2), [8, 12, 16, 6, 10]), ((6, 3), [7, 2, 5, 9, 4, 3])]) [4, 2] >>> partition_ages(1, [((1, 1), [15])]) [0] >>> partition_ages(1, [((4, 2), [10, 10, 10, 10])]) [0] from solution import partition_ages def test_partition_ages_basic(): T = 1 test_cases = [ ((5, 2), [8, 12, 16, 6, 10]), ] assert partition_ages(T, test_cases) == [4] def test_partition_ages_another_case(): T = 1 test_cases = [ ((6, 3), [7, 2, 5, 9, 4, 3]), ] assert partition_ages(T, test_cases) == [2] def test_partition_ages_multiple_cases(): T = 2 test_cases = [ ((5, 2), [8, 12, 16, 6, 10]), ((6, 3), [7, 2, 5, 9, 4, 3]), ] assert partition_ages(T, test_cases) == [4, 2] def test_partition_ages_single_participant(): T = 1 test_cases = [ ((1, 1), [15]), ] assert partition_ages(T, test_cases) == [0] def test_partition_ages_all_same_age(): T = 1 test_cases = [ ((4, 2), [10, 10, 10, 10]), ] assert partition_ages(T, test_cases) == [0]","solution":"def partition_ages(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] ages = sorted(test_cases[i][1]) def can_partition_with_max_diff(max_diff): group_count = 1 min_age = ages[0] for j in range(1, N): if ages[j] - min_age > max_diff: group_count += 1 min_age = ages[j] if group_count > K: return False return True left, right = 0, ages[-1] - ages[0] while left < right: mid = (left + right) // 2 if can_partition_with_max_diff(mid): right = mid else: left = mid + 1 results.append(left) return results # Example usage T = 2 test_cases = [ ((5, 2), [8, 12, 16, 6, 10]), ((6, 3), [7, 2, 5, 9, 4, 3]), ] print(partition_ages(T, test_cases)) # Output: [4, 2]"},{"question":"from typing import List, Tuple from collections import defaultdict import heapq def find_cheapest_price(n: int, flights: List[Tuple[int, int, int]], source: int, destination: int, k: int) -> int: Find the cheapest price for a flight from source to destination with at most k stops. >>> find_cheapest_price(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 1) 200 >>> find_cheapest_price(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 0) 500 >>> find_cheapest_price(3, [[0,1,100],[1,2,100],[0,2,500]], 0, 2, 2) 200 >>> find_cheapest_price(3, [[0,1,100],[1,2,100]], 0, 2, 0) -1","solution":"from collections import defaultdict import heapq def find_cheapest_price(n, flights, source, destination, k): Find the cheapest price for a flight from source to destination with at most k stops. # Create adjacency list for the graph graph = defaultdict(list) for fromCity, toCity, price in flights: graph[fromCity].append((toCity, price)) # Priority queue to store the (cost, current city, remaining stops) heap = [(0, source, k + 1)] while heap: cost, current_city, stops_left = heapq.heappop(heap) if current_city == destination: return cost if stops_left > 0: for neighbor, price in graph[current_city]: heapq.heappush(heap, (cost + price, neighbor, stops_left - 1)) return -1"},{"question":"def smallest_substrings(T: int, test_cases: List[Tuple[str, List[int]]]) -> List[List[str]]: Function to determine the lexicographically smallest substrings. Parameters: T (int): Number of test cases. test_cases (list): List of tuples with each tuple containing a string S and a list of integers representing the queries Q. Returns: list: List of lists containing the results of each query for each test case. results = [] for S, queries in test_cases: result = [] for L in queries: # Implement logic here to find the lexicographically smallest substring of length L result.append(None) # Placeholder for the actual result results.append(result) return results","solution":"def smallest_substrings(T, test_cases): Function to determine the lexicographically smallest substrings. Parameters: T (int): Number of test cases. test_cases (list): List of tuples with each tuple containing a string S and a list of integers representing the queries Q. Returns: list: List of lists containing the results of each query for each test case. results = [] for S, queries in test_cases: result = [] for L in queries: # Initialize smallest substring as a large string. smallest_substr = S[:L] for i in range(1, len(S) - L + 1): current_substr = S[i:i + L] if current_substr < smallest_substr: smallest_substr = current_substr result.append(smallest_substr) results.append(result) return results"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < len(nums) a, b, c, and d are all distinct. nums[a] + nums[b] + nums[c] + nums[d] == target :param List[int] nums: List of integers :param int target: The target sum :return List[List[int]]: List of unique quadruplets >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]]","solution":"def four_sum(nums, target): Returns all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that: 0 <= a, b, c, d < len(nums) a, b, c, and d are all distinct. nums[a] + nums[b] + nums[c] + nums[d] == target :param List[int] nums: List of integers :param int target: The target sum :return List[List[int]]: List of unique quadruplets nums.sort() quadruplets = [] n = len(nums) for i in range(n-3): if i > 0 and nums[i] == nums[i-1]: continue for j in range(i+1, n-2): if j > i+1 and nums[j] == nums[j-1]: continue left, right = j + 1, n - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def min_fuel_needed(grid, N, M): Returns the minimum fuel needed to reach the bottom-right corner of the grid. If it's impossible, returns -1. # Implementation goes here pass def driving_simulation(N, M, F, grid): Calculate the minimum fuel needed for Mark to complete his journey to the bottom-right corner. If he cannot reach the destination with the given fuel, output \\"Impossible\\". >>> driving_simulation(3, 3, 10, [[3, 4, 1], [2, 8, 3], [6, 2, 1]]) 'Impossible' >>> driving_simulation(3, 3, 15, [[3, 4, 1], [2, 8, 3], [6, 2, 1]]) 12 >>> driving_simulation(1, 1, 1, [[1]]) 1 # Implementation goes here pass def test_min_fuel_needed(): grid = [ [3, 4, 1], [2, 8, 3], [6, 2, 1] ] assert min_fuel_needed(grid, 3, 3) == 12 def test_driving_simulation_possible(): grid = [ [3, 4, 1], [2, 8, 3], [6, 2, 1] ] assert driving_simulation(3, 3, 15, grid) == 12 def test_driving_simulation_impossible(): grid = [ [3, 4, 1], [2, 8, 3], [6, 2, 1] ] assert driving_simulation(3, 3, 10, grid) == \\"Impossible\\" def test_driving_simulation_edge_case(): grid = [ [1] ] assert driving_simulation(1, 1, 1, grid) == 1 def test_driving_simulation_large_grid_possible(): grid = [ [1, 1000], [1, 1] ] assert driving_simulation(2, 2, 3, grid) == 3 def test_driving_simulation_large_grid_impossible(): grid = [ [1, 1000], [1, 1] ] assert driving_simulation(2, 2, 2, grid) == \\"Impossible\\"","solution":"def min_fuel_needed(grid, N, M): Returns the minimum fuel needed to reach the bottom-right corner of the grid. If it's impossible, returns -1. dp = [[float('inf')] * M for _ in range(N)] dp[0][0] = grid[0][0] for i in range(N): for j in range(M): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[N-1][M-1] def driving_simulation(N, M, F, grid): min_needed_fuel = min_fuel_needed(grid, N, M) if min_needed_fuel <= F: return min_needed_fuel else: return \\"Impossible\\""},{"question":"def double_positive(nums: List[int]) -> List[int]: Returns a new list with each positive element doubled. Negative elements and zero are included in their original form. Parameters: nums (list): List of integers. Returns: list: List with doubled positive integers and untouched negative integers and zero. # Test cases to validate the solution def test_double_positive_all_positives(): assert double_positive([1, 2, 3]) == [2, 4, 6] def test_double_positive_mixed(): assert double_positive([1, -1, 0, 2]) == [2, -1, 0, 4] def test_double_positive_all_non_positives(): assert double_positive([-5, 0, -3]) == [-5, 0, -3] def test_double_positive_single_element(): assert double_positive([5]) == [10] assert double_positive([-1]) == [-1] assert double_positive([0]) == [0] def test_double_positive_with_large_numbers(): assert double_positive([1000, -2000, 3000]) == [2000, -2000, 6000] def test_double_positive_edge_case(): assert double_positive([-1, 0, 1]) == [-1, 0, 2]","solution":"def double_positive(nums): Returns a new list with each positive element doubled. Negative elements and zero are included in their original form. Parameters: nums (list): List of integers. Returns: list: List with doubled positive integers and untouched negative integers and zero. result = [] for num in nums: if num > 0: result.append(num * 2) else: result.append(num) return result"},{"question":"def common_pattern(seq1, seq2): Finds the longest common sub-sequence (in the same order) between seq1 and seq2. If there are multiple such sub-sequences of the same length, the one that appears first in seq1 is returned. Parameters: - seq1: List of strings representing the first sequence of events. - seq2: List of strings representing the second sequence of events. Returns: - A list of strings representing the longest common sub-sequence. Examples: >>> common_pattern([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"C\\", \\"A\\", \\"B\\", \\"D\\", \\"F\\"]) [\\"A\\", \\"B\\", \\"D\\"] >>> common_pattern([\\"event1\\", \\"event2\\", \\"event3\\"], [\\"event4\\", \\"event5\\"]) [] from solution import common_pattern def test_common_pattern_example_1(): assert common_pattern([\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"], [\\"C\\", \\"A\\", \\"B\\", \\"D\\", \\"F\\"]) == [\\"A\\", \\"B\\", \\"D\\"] def test_common_pattern_example_2(): assert common_pattern([\\"event1\\", \\"event2\\", \\"event3\\"], [\\"event4\\", \\"event5\\"]) == [] def test_common_pattern_single_element_common(): assert common_pattern([\\"A\\"], [\\"A\\"]) == [\\"A\\"] def test_common_pattern_multiple_same_length(): assert common_pattern([\\"A\\", \\"X\\", \\"B\\", \\"X\\", \\"C\\"], [\\"X\\", \\"A\\", \\"X\\", \\"B\\", \\"C\\", \\"D\\"]) == [\\"A\\", \\"X\\", \\"B\\", \\"C\\"] def test_common_pattern_no_common(): assert common_pattern([\\"A\\", \\"B\\", \\"C\\"], [\\"D\\", \\"E\\", \\"F\\"]) == [] def test_common_pattern_subsequence_at_start(): assert common_pattern([\\"A\\", \\"B\\", \\"C\\"], [\\"A\\", \\"D\\", \\"C\\"]) == [\\"A\\", \\"C\\"] def test_common_pattern_subsequence_at_end(): assert common_pattern([\\"X\\", \\"A\\", \\"B\\"], [\\"A\\", \\"B\\", \\"Y\\"]) == [\\"A\\", \\"B\\"]","solution":"def common_pattern(seq1, seq2): Finds the longest common sub-sequence (in the same order) between seq1 and seq2. If there are multiple such sub-sequences of the same length, the one that appears first in seq1 is returned. def lcs_length_matrix(X, Y): m = len(X) n = len(Y) L = [[0] * (n+1) for _ in range(m+1)] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L def trace_back_lcs(L, X, Y): m = len(X) n = len(Y) i = m j = n lcs = [] while i > 0 and j > 0: if X[i-1] == Y[j-1]: lcs.insert(0, X[i-1]) i -= 1 j -= 1 elif L[i-1][j] > L[i][j-1]: i -= 1 else: j -= 1 return lcs L = lcs_length_matrix(seq1, seq2) return trace_back_lcs(L, seq1, seq2)"},{"question":"def can_partition(nums): Determines if the input array can be partitioned into two subarrays with equal sum. Parameters: nums (list of int): The input array of integers. Returns: bool: True if partitioning is possible, otherwise False. Examples: >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([3, 3, 3, 4, 5]) True >>> can_partition([1, 1, 1, 1]) True","solution":"def can_partition(nums): Determines if the input array can be partitioned into two subarrays with equal sum. Parameters: nums (list of int): The input array of integers. Returns: bool: True if partitioning is possible, otherwise False. total = sum(nums) if total % 2 != 0: return False target = total // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def count_possible_L_shapes(grid, M, N): Count possible L-shaped patterns that can be formed by adding flowers in the garden. # Implement the function here def max_flowers_to_add(T, test_cases): Calculate the maximum number of flowers that can be added to form valid L-shaped patterns. Args: - T: The number of test cases - test_cases: A list of tuples where each tuple contains the garden dimensions (MxN) and the grid representing the garden. Returns: - A list of integers where each integer represents the maximum number of flowers that can be added for the corresponding test case. >>> T = 2 >>> test_cases = [ ... ((3, 3), [['1', '0', '0'], ['0', '0', '1'], ['1', '1', '0']]), ... ((4, 4), [['1', '0', '0', '1'], ['0', '0', '0', '0'], ['0', '1', '0', '0'], ['1', '0', '0', '1']]) ... ] >>> max_flowers_to_add(T, test_cases) == [1, 2] # Implement the function here # Example usage: # To run the tests use: # pytest -q test_solution.py def test_count_possible_L_shapes(): grid = [ ['1', '0', '0'], ['0', '0', '1'], ['1', '1', '0'] ] assert count_possible_L_shapes(grid, 3, 3) == 1 grid = [ ['1', '0', '0', '1'], ['0', '0', '0', '0'], ['0', '1', '0', '0'], ['1', '0', '0', '1'] ] assert count_possible_L_shapes(grid, 4, 4) == 2 def test_max_flowers_to_add(): T = 2 test_cases = [ ((3, 3), [['1', '0', '0'], ['0', '0', '1'], ['1', '1', '0']]), ((4, 4), [['1', '0', '0', '1'], ['0', '0', '0', '0'], ['0', '1', '0', '0'], ['1', '0', '0', '1']]) ] assert max_flowers_to_add(T, test_cases) == [1, 2]","solution":"def count_possible_L_shapes(grid, M, N): max_flowers = 0 visited = [[False]*N for _ in range(M)] for i in range(M): for j in range(N): if grid[i][j] == '1': # Check for possible 'L' shapes like '', '', '', '' if j + 1 < N and i + 1 < M: if grid[i][j+1] == '0' and grid[i+1][j] == '0': if not visited[i][j+1] and not visited[i+1][j]: max_flowers += 1 visited[i][j+1] = True visited[i+1][j] = True return max_flowers def max_flowers_to_add(T, test_cases): results = [] for t in range(T): M, N = test_cases[t][0] grid = test_cases[t][1] results.append(count_possible_L_shapes(grid, M, N)) return results # Example Usage: # T = 2 # test_cases = [ # ((3, 3), [['1', '0', '0'], ['0', '0', '1'], ['1', '1', '0']]), # ((4, 4), [['1', '0', '0', '1'], ['0', '0', '0', '0'], ['0', '1', '0', '0'], ['1', '0', '0', '1']]) # ] # print(max_flowers_to_add(T, test_cases))"},{"question":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Write a function that takes a square matrix as input and returns its transpose. A square matrix is an NxN matrix with the same number of rows and columns. The transpose of a matrix is obtained by flipping the matrix over its diagonal, meaning the row and column indices are swapped. For example: Given a matrix M: |1 2 3| |4 5 6| |7 8 9| The transpose of M will be: |1 4 7| |2 5 8| |3 6 9| To find the element at position [i][j] in the transposed matrix, you take the element at position [j][i] in the original matrix. >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([ ... [1, 2], ... [3, 4] ... ]) [[1, 3], [2, 4]] >>> transpose_matrix([ ... [1] ... ]) [[1]] >>> transpose_matrix([]) [] >>> transpose_matrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [4, 8, 12, 16]]","solution":"def transpose_matrix(matrix): Returns the transpose of a square matrix. n = len(matrix) transposed = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): transposed[i][j] = matrix[j][i] return transposed"},{"question":"from typing import List, Tuple def can_finish_courses(courses: List[Tuple[int, int]]) -> bool: Determines whether it is possible to finish all courses given the prerequisites. >>> can_finish_courses([]) True >>> can_finish_courses([(1, 0), (2, 1), (3, 2)]) True >>> can_finish_courses([(1, 0), (0, 1)]) False >>> can_finish_courses([(1, 0), (2, 0), (3, 1), (3, 2)]) True >>> can_finish_courses([(1, 0), (3, 2)]) True >>> can_finish_courses([(1, 0), (0, 1), (2, 3), (3, 2)]) False >>> can_finish_courses([(1, 0), (2, 1), (3, 2), (4, 2), (4, 3)]) True pass","solution":"from typing import List, Tuple def can_finish_courses(courses: List[Tuple[int, int]]) -> bool: from collections import defaultdict, deque # Create the adjacency list for the graph graph = defaultdict(list) indegree = defaultdict(int) for course, prereq in courses: graph[prereq].append(course) indegree[course] += 1 if prereq not in indegree: indegree[prereq] = 0 # Create a queue and add all courses with no prerequisites queue = deque([node for node in indegree if indegree[node] == 0]) count_of_courses_taken = 0 while queue: course = queue.popleft() count_of_courses_taken += 1 for next_course in graph[course]: indegree[next_course] -= 1 if indegree[next_course] == 0: queue.append(next_course) if count_of_courses_taken == len(indegree): return True else: return False"},{"question":"def balance_parentheses(expression: str) -> bool: Write a function balance_parentheses(expression) that takes a string containing only the characters '(', ')', '{', '}', '[' and ']' and returns a boolean indicating whether the parentheses, braces, and brackets in the expression are balanced (i.e., every opening brace has a corresponding closing brace in the correct order). >>> balance_parentheses(\\"(){}[]\\") True >>> balance_parentheses(\\"(]\\") False >>> balance_parentheses(\\"([{}])\\") True >>> balance_parentheses(\\"(((\\") False","solution":"def balance_parentheses(expression): Returns True if the parentheses, braces, and brackets in the expression are balanced, otherwise returns False. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in expression: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False else: # Invalid character return False return stack == []"},{"question":"def simulate_snake_game(commands: List[str]) -> Tuple[int, int]: Simulate the snake game and return the final position after executing all commands. :param commands: List of strings representing the movements ('U', 'D', 'L', 'R') :return: Tuple (x, y) representing the final coordinates of the snake >>> simulate_snake_game(['U', 'U', 'R', 'D', 'L', 'L']) (-1, 1) >>> simulate_snake_game(['R', 'R', 'D', 'D', 'L', 'U']) (1, -1) >>> simulate_snake_game([]) (0, 0)","solution":"def simulate_snake_game(commands): Simulate the snake game and return the final position after executing all commands. :param commands: List of strings representing the movements ('U', 'D', 'L', 'R') :return: Tuple (x, y) representing the final coordinates of the snake x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"def remove_duplicates(s: str) -> str: You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. >>> remove_duplicates(\\"abbaca\\") == \\"ca\\" >>> remove_duplicates(\\"azxxzy\\") == \\"ay\\"","solution":"def remove_duplicates(s: str) -> str: stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"from typing import List, Tuple def top_k_frequent_words(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> None: Create a program that helps track the most frequently occurring words in a series of documents and outputs the top K frequent words in order of their frequency. Parameters: T (int): The number of test cases test_cases (List[Tuple[int, int, List[str]]]): A list of tuples, where each tuple represents a test case containing: - N (int): The number of lines in the document - K (int): The number of top frequent words to output - lines (List[str]): The lines of the document Returns: None: Prints the top K frequent words in order of their frequency. Ties in frequency are broken by lexicographical order. Example Usage: # Example Input T = 2 test_cases = [ (3, 2, [\\"apple orange apple\\", \\"banana apple\\", \\"orange banana orange\\"]), (5, 3, [\\"cat dog\\", \\"cat dog dog\\", \\"fish bird cat\\", \\"fish bird\\", \\"dog bird cat\\"]) ] # Expected Output # apple # orange # # dog # cat # bird","solution":"from collections import Counter import heapq def top_k_frequent_words(T, test_cases): results = [] for i in range(T): N, K, lines = test_cases[i] words = [] for line in lines: words.extend(line.split()) word_count = Counter(words) # This heap stores (-frequency, word) tuples heap = [(-freq, word) for word, freq in word_count.items()] heapq.heapify(heap) top_k = [] for _ in range(K): top_k.append(heapq.heappop(heap)[1]) results.append(' '.join(sorted(top_k))) for result in results: print(result) print() # Parsing and calling the function for the original problem statement def main(): import sys input = sys.stdin.read data = input().splitlines() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N, K = map(int, data[index].split()) lines = data[index+1:index+N+1] test_cases.append((N, K, lines)) index += N + 1 top_k_frequent_words(T, test_cases) if __name__ == \\"__main__\\": main()"},{"question":"import collections from typing import List def is_path_exists(grid: List[List[int]]) -> bool: Checks whether there is a path from the top-left corner to the bottom-right corner in a binary matrix. Args: grid : List[List[int]] A binary matrix (n x n) where each element is 0 or 1. Returns: bool True if such a path exists, False otherwise. Examples: >>> is_path_exists([[0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0]]) True >>> is_path_exists([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) False def test_is_path_exists(): assert is_path_exists([[0, 1, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0]]) == True assert is_path_exists([[1, 1, 1], [1, 0, 1], [1, 1, 1]]) == False assert is_path_exists([[0]]) == True assert is_path_exists([[1]]) == False assert is_path_exists([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == True assert is_path_exists([[0, 1, 0], [1, 1, 0], [0, 0, 0]]) == False assert is_path_exists([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) == True if __name__ == \\"__main__\\": test_is_path_exists()","solution":"from collections import deque def is_path_exists(grid): Checks whether there is a path from the top-left corner to the bottom-right corner in a binary matrix. Args: grid : List[List[int]] A binary matrix (n x n) where each element is 0 or 1. Returns: bool True if such a path exists, False otherwise. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return False directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] queue = deque([(0, 0)]) visited = [[False] * n for _ in range(n)] visited[0][0] = True while queue: x, y = queue.popleft() if x == n-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0: visited[nx][ny] = True queue.append((nx, ny)) return False"},{"question":"def magic_square(matrix: List[List[int]]) -> bool: Determines if a given 3x3 matrix is a magic square. Parameters: matrix: List[List[int]] - A 3x3 matrix represented as a list of lists of integers. Returns: bool - True if the matrix is a magic square, False otherwise. >>> magic_square([[4, 9, 2], [3, 5, 7], [8, 1, 6]]) True >>> magic_square([[4, 9, 2], [3, 5, 8], [8, 1, 6]]) False >>> magic_square([[4, 9, 2], [3, 5, 7], [8, 1, 5]]) False >>> magic_square([[4, 9, 1], [3, 5, 7], [8, 1, 6]]) False >>> magic_square([[2, -1, 4], [-4, 2, 7], [3, 5, -1]]) False >>> magic_square([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) True >>> magic_square([[1, 2], [3, 4]]) False >>> magic_square([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) False >>> magic_square([[1, 2, 3], [4, 5, 6], [7, 8]]) False","solution":"def magic_square(matrix): Determines if a given 3x3 matrix is a magic square. Parameters: matrix: List[List[int]] - A 3x3 matrix represented as a list of lists of integers. Returns: bool - True if the matrix is a magic square, False otherwise. if len(matrix) != 3 or any(len(row) != 3 for row in matrix): return False # Sum of the first diagonal diag_sum1 = sum(matrix[i][i] for i in range(3)) # Sum of the second diagonal diag_sum2 = sum(matrix[i][2 - i] for i in range(3)) if diag_sum1 != diag_sum2: return False # Sum of the first row, which is the target magic constant magic_constant = sum(matrix[0]) # Check rows and columns for i in range(3): if sum(matrix[i]) != magic_constant: return False if sum(matrix[j][i] for j in range(3)) != magic_constant: return False return True"},{"question":"def find_pair_with_sum(n: int, target: int, lst: List[int]) -> str: Checks if there are any two elements in the list that add up to the target number. >>> find_pair_with_sum(5, 8, [1, 2, 3, 7, 5]) == \\"Found\\" >>> find_pair_with_sum(4, 10, [1, 2, 3, 4]) == \\"Not Found\\" >>> find_pair_with_sum(6, 8, [1, 2, 3, 7, 5, 3]) == \\"Found\\" >>> find_pair_with_sum(5, -2, [-1, -2, -3, 1, 2]) == \\"Found\\" >>> find_pair_with_sum(1000, 0, list(range(-500, 500))) == \\"Found\\" >>> find_pair_with_sum(5, 2, [0, 1, -1, 2, 3]) == \\"Found\\" >>> find_pair_with_sum(5, 4, [1, 1, 1, 1, 3]) == \\"Found\\"","solution":"def find_pair_with_sum(n, target, lst): Checks if there are any two elements in the list that add up to the target number. :param n: Number of elements in the list :param target: Target sum :param lst: List of integers :return: \\"Found\\" if there is a pair that sums up to the target, otherwise \\"Not Found\\" seen = set() for num in lst: complement = target - num if complement in seen: return \\"Found\\" seen.add(num) return \\"Not Found\\""},{"question":"def count_divisible_pairs(arr: List[int], k: int) -> int: Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is divisible by k. >>> count_divisible_pairs([1, 2, 3, 4, 5], 3) 4 >>> count_divisible_pairs([1, 3, 2, 4, 6, 9], 5) 5 >>> count_divisible_pairs([0, 0, 0, 0], 1) 6 >>> count_divisible_pairs([1, 2, 4, 7], 10) 0 >>> count_divisible_pairs([10**9, 10**9 - 1, 1], 10**9) 1 >>> count_divisible_pairs([3, 5, 7, 9], 1) 6 >>> count_divisible_pairs([2, 4, 6, 8, 10], 4) 4","solution":"def count_divisible_pairs(arr, k): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] is divisible by k. count = 0 n = len(arr) for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % k == 0: count += 1 return count"},{"question":"from typing import List def count_mountains(elevations: List[int]) -> int: Counts the number of distinct mountains in the list of elevations. >>> count_mountains([2, 3, 5, -1, -2, 4, 1, -3, 2]) 2 >>> count_mountains([1, 2, -2, 2, -2]) 2 >>> count_mountains([3, 2, 1]) 1 >>> count_mountains([1, -1, 1, -1, 1, -1]) 3 >>> count_mountains([0, 0, 1, 2, 0, 0]) 1 >>> count_mountains([0, 2, -2, 0]) 1 >>> count_mountains([-1, -2, -3]) 0 >>> count_mountains([1, 2, 3, 2, 1, 2, 3, 4]) 1 >>> count_mountains([1, 2, 3, -1, -2, 4, 1, -3, 2]) 2 # your code here","solution":"from typing import List def count_mountains(elevations: List[int]) -> int: Counts the number of distinct mountains in the list of elevations. if not elevations: return 0 num_mountains = 0 n = len(elevations) i = 0 while i < n: # Find the starting point of a mountain while i < n and elevations[i] <= 0: i += 1 if i == n: break # Ascending phase while i < n - 1 and elevations[i] < elevations[i+1]: i += 1 # Check if it's a peak we can start counting as a mountain if i < n - 1 and elevations[i] > elevations[i+1]: num_mountains += 1 # Descending phase while i < n - 1 and elevations[i] > elevations[i+1]: i += 1 i += 1 # Move to the next potential start return num_mountains"},{"question":"from collections import Counter def canFormPalindrome(s: str) -> bool: Determines if the string can be rearranged to form a palindrome. :param s: Input string of lowercase characters. :return: True if the string can be rearranged to form a palindrome, else False. >>> canFormPalindrome(\\"carrace\\") True >>> canFormPalindrome(\\"daily\\") False >>> canFormPalindrome(\\"aab\\") True >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"abcba\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"aaa\\") True >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"abccba\\") True >>> canFormPalindrome(\\"abcdef\\") False","solution":"from collections import Counter def canFormPalindrome(s: str) -> bool: Determines if the string can be rearranged to form a palindrome. :param s: Input string of lowercase characters. :return: True if the string can be rearranged to form a palindrome, else False. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def max_flowers(n: int, m: int, garden: List[str]) -> int: Returns the maximum number of flowers that can be placed in the garden such that no two flowers are in the same row or column. Args: n (int): Number of rows in the garden. m (int): Number of columns in the garden. garden (List[str]): The representation of the garden grid, where each string represents a row of cells. 'F' for flower, '.' for empty. Returns: int: The maximum number of flowers that can be placed. Examples: >>> max_flowers(2, 3, [\\"...\\", \\".F.\\"]) 2 >>> max_flowers(4, 4, [\\"....\\", \\"..F.\\", \\"....\\", \\"....\\"]) 4 >>> max_flowers(5, 5, [\\"F....\\", \\"....F\\", \\".....\\", \\".....\\", \\".....\\"]) 5 from typing import List def test_max_flowers_example1(): garden = [ \\"...\\", \\".F.\\" ] assert max_flowers(2, 3, garden) == 2 def test_max_flowers_example2(): garden = [ \\"....\\", \\"..F.\\", \\"....\\", \\"....\\" ] assert max_flowers(4, 4, garden) == 4 def test_max_flowers_example3(): garden = [ \\"F....\\", \\"....F\\", \\".....\\", \\".....\\", \\".....\\" ] assert max_flowers(5, 5, garden) == 5 def test_max_flowers_all_empty(): garden = [ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ] assert max_flowers(4, 4, garden) == 4 def test_max_flowers_single_cell_with_flower(): garden = [\\"F\\"] assert max_flowers(1, 1, garden) == 1 def test_max_flowers_single_empty_cell(): garden = [\\".\\"] assert max_flowers(1, 1, garden) == 1 def test_max_flowers_large_garden(): garden = [\\".\\" * 1000] * 1000 assert max_flowers(1000, 1000, garden) == 1000","solution":"def max_flowers(n, m, garden): Returns the maximum number of flowers that can be placed in the garden such that no two flowers are in the same row or column. row_occupied = set() col_occupied = set() # Mark already occupied rows and columns for r in range(n): for c in range(m): if garden[r][c] == 'F': row_occupied.add(r) col_occupied.add(c) # Maximum flowers is limited by the minimum of available rows and columns max_flowers_placement = min(n - len(row_occupied), m - len(col_occupied)) # Include already placed flowers total_flowers = len(row_occupied) + max_flowers_placement return total_flowers"},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequently occurring character in the string. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. If the input string is empty, returns an empty string. >>> most_frequent_char(\\"\\") == \\"\\" >>> most_frequent_char(\\"a\\") == \\"a\\" >>> most_frequent_char(\\"abacad\\") == \\"a\\" >>> most_frequent_char(\\"aabbbc\\") == \\"b\\" >>> most_frequent_char(\\"abababa\\") == \\"a\\" >>> most_frequent_char(\\"bacbacbac\\") == \\"b\\" >>> most_frequent_char(\\"1234445555\\") == \\"5\\" >>> most_frequent_char(\\"aAbBcCaA\\") == \\"a\\" >>> most_frequent_char(\\"abc1a1a1\\") == \\"a\\"","solution":"def most_frequent_char(s): Returns the most frequently occurring character in the string. If there are multiple characters with the same maximum frequency, returns the character that appears first in the string. If the input string is empty, returns an empty string. if not s: return \\"\\" char_count = {} for index, char in enumerate(s): if char in char_count: char_count[char][0] += 1 else: char_count[char] = [1, index] max_occurrence = -1 result_char = '' for char, (count, index) in char_count.items(): if count > max_occurrence or (count == max_occurrence and index < char_count[result_char][1]): max_occurrence = count result_char = char return result_char"},{"question":"def check_tickets(total_tickets: int, sold_tickets: int, request_tickets: int) -> int: Returns the remaining number of tickets after fulfilling the request if possible, otherwise returns -1. >>> check_tickets(100, 90, 5) 5 >>> check_tickets(50, 45, 10) -1 def test_check_tickets_enough_tickets(): assert check_tickets(100, 90, 5) == 5 def test_check_tickets_not_enough_tickets(): assert check_tickets(50, 45, 10) == -1 def test_check_tickets_exact_amount(): assert check_tickets(30, 25, 5) == 0 def test_check_tickets_no_tickets_sold(): assert check_tickets(20, 0, 10) == 10 def test_check_tickets_no_tickets_requested(): assert check_tickets(20, 15, 0) == 5 def test_check_tickets_all_tickets_sold(): assert check_tickets(40, 40, 5) == -1","solution":"def check_tickets(total_tickets, sold_tickets, request_tickets): Returns the remaining number of tickets after fulfilling the request if possible, otherwise returns -1. if total_tickets - sold_tickets >= request_tickets: return total_tickets - sold_tickets - request_tickets else: return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> is_symmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): def is_mirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) return is_mirror(root, root)"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Write a function that takes a list of integers representing daily temperatures, and returns a new list where each days value is the number of days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, put 0 in that days value in the final list. Examples: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([90, 80, 70, 60]) [0, 0, 0, 0] pass","solution":"def daily_temperatures(temperatures): This function takes a list of daily temperatures and returns a list where each element is the number of days until a warmer temperature. If there is no future day with a warmer temperature, the value is 0. Parameters: temperatures (List[int]): List of integers representing daily temperatures. Returns: List[int]: List where each element is the number of days until a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] # This will store the indices of the temperatures list for i in range(n): # If the current day's temperature is higher than the temperature of the day at the index stored in the stack while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() answer[index] = i - index # Calculate the days to wait for a warmer temperature stack.append(i) # Add the current day's index to the stack return answer"},{"question":"def replace_question_marks(S: str) -> str: Replace all '?' characters in the string such that no adjacent characters are the same. >>> replace_question_marks(\\"a?b\\") \\"aab\\" >>> replace_question_marks(\\"??\\") \\"ab\\" >>> replace_question_marks(\\"a?a?a\\") \\"ababa\\"","solution":"def replace_question_marks(S: str) -> str: n = len(S) S = list(S) for i in range(n): if S[i] == '?': for c in 'abc': if (i > 0 and S[i-1] == c) or (i < n-1 and S[i+1] == c): continue S[i] = c break return \\"\\".join(S)"},{"question":"from typing import List def numIslands(grid: List[List[int]]) -> int: Return the number of distinct islands in the grid. >>> numIslands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"]]) 3 >>> numIslands([ [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], [\\"1\\",\\"0\\",\\"0\\",\\"0\\",\\"0\\"], [\\"0\\",\\"0\\",\\"0\\",\\"0\\",\\"1\\"]]) 2 # your code here","solution":"def numIslands(grid): if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark as visited dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count"},{"question":"def sort_and_unique(int_list: List[int]) -> List[int]: This function receives a list of integers and returns a new list containing those integers in sorted order but with duplicates removed. >>> sort_and_unique([5, 3, 1, 4, 4, 2, 5]) [1, 2, 3, 4, 5] >>> sort_and_unique([-1, -3, -2, -2, -1]) [-3, -2, -1] >>> sort_and_unique([]) [] >>> sort_and_unique([7]) [7] >>> sort_and_unique([3, -1, 2, -3, 3, 2]) [-3, -1, 2, 3]","solution":"def sort_and_unique(int_list): This function receives a list of integers and returns a new list containing those integers in sorted order but with duplicates removed. return sorted(set(int_list))"},{"question":"def factorial(n: int) -> int: Returns the factorial of the non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 >>> factorial(5) 120 >>> factorial(6) 720 >>> factorial(-1) Traceback(most recent call last): ... ValueError: Negative integers do not have factorials.","solution":"def factorial(n): Returns the factorial of the non-negative integer n. if n < 0: raise ValueError(\\"Negative integers do not have factorials.\\") if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result"},{"question":"def is_palindrome(s: str) -> bool: Determines whether a given string is a palindrome. A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). If the input string is None, return False. For example: >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True","solution":"import string def is_palindrome(s): Returns True if the given string is a palindrome, False otherwise. if s is None: return False # Remove punctuation, spaces, and convert to lowercase s = ''.join([char.lower() for char in s if char in string.ascii_letters]) # Check if the string reads the same forward and backward return s == s[::-1]"},{"question":"from typing import List class Solution: def removeDuplicates(self, nums: List[int]) -> int: Remove duplicates from sorted list of integers in-place. Returns the length of the list after removing duplicates. Example 1: >>> nums = [1,1,2] >>> result = Solution().removeDuplicates(nums) >>> result 2 >>> nums[:result] [1, 2] Example 2: >>> nums = [0,0,1,1,1,2,2,3,3,4] >>> result = Solution().removeDuplicates(nums) >>> result 5 >>> nums[:result] [0, 1, 2, 3, 4] :param nums: List[int] - a list of non-negative integers sorted in non-decreasing order :return: int - the length of the list after removing duplicates pass # Unit Tests def test_removeDuplicates_example1(): nums = [1, 1, 2] result = Solution().removeDuplicates(nums) assert result == 2 assert nums[:result] == [1, 2] def test_removeDuplicates_example2(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] result = Solution().removeDuplicates(nums) assert result == 5 assert nums[:result] == [0, 1, 2, 3, 4] def test_removeDuplicates_empty_list(): nums = [] result = Solution().removeDuplicates(nums) assert result == 0 assert nums == [] def test_removeDuplicates_single_element_list(): nums = [1] result = Solution().removeDuplicates(nums) assert result == 1 assert nums == [1] def test_removeDuplicates_no_duplicates(): nums = [1, 2, 3, 4, 5] result = Solution().removeDuplicates(nums) assert result == 5 assert nums[:result] == [1, 2, 3, 4, 5] def test_removeDuplicates_all_duplicates(): nums = [2, 2, 2, 2, 2] result = Solution().removeDuplicates(nums) assert result == 1 assert nums[:result] == [2]","solution":"from typing import List class Solution: def removeDuplicates(self, nums: List[int]) -> int: Remove duplicates from sorted list of integers in-place. Returns the length of the list after removing duplicates. if not nums: return 0 # Initialize the position to place the next unique element place_index = 1 # Iterate through the sorted list starting from the second element for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[place_index] = nums[i] place_index += 1 return place_index"},{"question":"def can_form_special_string(s: str) -> bool: Checks if the given string 's' can be rearranged to form a special string which contains at least one vowel and at least one consonant. >>> can_form_special_string(\\"hello\\") == True >>> can_form_special_string(\\"aeiou\\") == False >>> can_form_special_string(\\"bcdfg\\") == False >>> can_form_special_string(\\"a\\") == False >>> can_form_special_string(\\"b\\") == False >>> can_form_special_string(\\"ba\\") == True >>> can_form_special_string(\\"edcba\\") == True >>> can_form_special_string(\\"aabbcc\\") == True","solution":"def can_form_special_string(s): Checks if the given string 's' can be rearranged to form a special string which contains at least one vowel and at least one consonant. Parameters: s (str): The input string to check. Returns: bool: True if the string can form a special string, False otherwise. vowels = set('aeiou') has_vowel = has_consonant = False for char in s: if char in vowels: has_vowel = True else: has_consonant = True if has_vowel and has_consonant: return True return False"},{"question":"def sort_participants(names: List[str]) -> List[str]: Sorts a list of participant names by last name and first name, case-insensitive. Parameters: names (list): A list of strings, each string containing a first name and a last name. Returns: list: The sorted list of names. >>> sort_participants([\\"John Doe\\", \\"Jane Smith\\", \\"Alice Johnson\\", \\"Emma Doe\\"]) ['Emma Doe', 'John Doe', 'Alice Johnson', 'Jane Smith'] >>> sort_participants([\\"john doe\\", \\"Jane Smith\\", \\"alice Johnson\\", \\"Emma doe\\"]) ['Emma doe', 'john doe', 'alice Johnson', 'Jane Smith'] >>> sort_participants([\\"John Smith\\", \\"Jane Smith\\", \\"Alice Smith\\", \\"Bob Smith\\"]) ['Alice Smith', 'Bob Smith', 'Jane Smith', 'John Smith'] >>> sort_participants([\\"John Doe\\"]) ['John Doe'] >>> sort_participants([]) []","solution":"def sort_participants(names): Sorts a list of participant names by last name and first name, case-insensitive. Parameters: names (list): A list of strings, each string containing a first name and a last name. Returns: list: The sorted list of names. return sorted(names, key=lambda name: (name.split()[1].lower(), name.split()[0].lower()))"},{"question":"def generate_non_repeating_string(k: int) -> str: Generates a string of length k where no substring of length 2 or more repeats. Args: k (int): The length of the desired string. Returns: str: A string of length k with no repeating substrings of length 2 or more. >>> generate_non_repeating_string(1) 'a' >>> generate_non_repeating_string(3) 'abc' >>> generate_non_repeating_string(2) 'ab' >>> generate_non_repeating_string(6) 'abcdef' >>> generate_non_repeating_string(25) 'abcdefghijklmnopqrstuvwxy'","solution":"def generate_non_repeating_string(k): Generates a string of length k where no substring of length 2 or more repeats. Args: k (int): The length of the desired string. Returns: str: A string of length k with no repeating substrings of length 2 or more. if k < 1 or k > 26: return \\"\\" alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" return alphabet[:k]"},{"question":"def final_position(moves: str) -> tuple: Given a sequence of moves, determines the robot's final position on a 2D plane starting from coordinate (0, 0). Parameters: moves (str): A string of characters where each character represents a move. Returns: tuple: The final coordinates (x, y). >>> final_position(\\"UUDDLRLR\\") (0, 0) >>> final_position(\\"UUUURRDD\\") (2, 2)","solution":"def final_position(moves): Given a sequence of moves, determines the robot's final position on a 2D plane starting from coordinate (0, 0). Parameters: moves (str): A string of characters where each character represents a move. Returns: tuple: The final coordinates (x, y). x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x, y"},{"question":"def truck_with_max_distance(n: int, truck_data: List[Tuple[str, int]]) -> str: Returns the identifier of the truck that has traveled the most distance. If there are ties, return the identifier with the smallest value in lexicographical order. Args: n: The number of trucks. truck_data: A list of tuples where each tuple contains an identifier (string) and distance (integer). Returns: The identifier of the truck with the greatest distance traveled. Examples: >>> truck_with_max_distance(3, [(\\"truck1\\", 540), (\\"truck2\\", 700), (\\"truck3\\", 540)]) 'truck2' >>> truck_with_max_distance(3, [(\\"truck1\\", 540), (\\"truck2\\", 540), (\\"truck3\\", 540)]) 'truck1' import pytest from typing import List, Tuple def test_single_truck(): assert truck_with_max_distance(1, [(\\"truck1\\", 100)]) == \\"truck1\\" def test_multiple_trucks_unique_distances(): assert truck_with_max_distance(3, [(\\"truck1\\", 540), (\\"truck2\\", 700), (\\"truck3\\", 600)]) == \\"truck2\\" def test_multiple_trucks_tied_distances(): assert truck_with_max_distance(3, [(\\"truck1\\", 540), (\\"truck2\\", 700), (\\"truck3\\", 540)]) == \\"truck2\\" def test_multiple_trucks_tied_max_distances(): assert truck_with_max_distance(3, [(\\"truck1\\", 700), (\\"truck2\\", 700), (\\"truck3\\", 700)]) == \\"truck1\\" def test_trucks_with_zero_distance(): assert truck_with_max_distance(3, [(\\"truck1\\", 0), (\\"truck2\\", 0), (\\"truck3\\", 0)]) == \\"truck1\\" @pytest.fixture def large_input(): truck_data = [(f\\"truck{i}\\", i) for i in range(50)] return 50, truck_data def test_large_input(large_input): n, truck_data = large_input assert truck_with_max_distance(n, truck_data) == \\"truck49\\"","solution":"def truck_with_max_distance(n, truck_data): Returns the identifier of the truck that has traveled the most distance. If there are ties, return the identifier with the smallest value in lexicographical order. max_distance = -1 max_truck_id = \\"\\" for truck in truck_data: truck_id, distance = truck distance = int(distance) if distance > max_distance or (distance == max_distance and truck_id < max_truck_id): max_distance = distance max_truck_id = truck_id return max_truck_id"},{"question":"def trap(height): Calculate the total amount of rainwater that can be trapped. :param height: List[int] - list of integers representing the heights of the buildings :return: int - total amount of trapped rainwater >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([2, 2, 2, 2, 2]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): Calculate the total amount of rainwater that can be trapped. :param height: List[int] - list of integers representing the heights of the buildings :return: int - total amount of trapped rainwater if not height or len(height) < 3: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill in the left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill in the right max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def count_binary_substrings(binaryString: str) -> int: Returns the number of contiguous substrings in the binary string that have equal number of '0's and '1's. >>> count_binary_substrings(\\"00110011\\") 6 >>> count_binary_substrings(\\"10101\\") 4 >>> count_binary_substrings(\\"0\\") 0 >>> count_binary_substrings(\\"1\\") 0 >>> count_binary_substrings(\\"00000\\") 0 >>> count_binary_substrings(\\"11111\\") 0 >>> count_binary_substrings(\\"010101\\") 5","solution":"def count_binary_substrings(binaryString): Returns the number of contiguous substrings in the binary string that have equal number of '0's and '1's. counts = [] count = 1 # Count consecutive 0's and 1's for i in range(1, len(binaryString)): if binaryString[i] == binaryString[i-1]: count += 1 else: counts.append(count) count = 1 counts.append(count) # Count the substrings result = 0 for i in range(1, len(counts)): result += min(counts[i-1], counts[i]) return result"},{"question":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"hello\\") False","solution":"def is_palindrome(s): Determines if a given string is a palindrome. Ignores spaces, punctuation, and capitalization. :param s: Input string :return: True if the string is a palindrome, False otherwise # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if cleaned string is equal to its reverse return cleaned == cleaned[::-1]"},{"question":"def extract_domain(emails: str) -> list: Extracts unique domain names from a string containing one or more email addresses. >>> extract_domain(\\"Contact me at example@domain.com.\\") ['domain.com'] >>> extract_domain(\\"Emails: first@company.com, second@shop.net, and third@service.org.\\") ['company.com', 'shop.net', 'service.org'] >>> extract_domain(\\"Emails: info@company.com, support@company.com.\\") ['company.com'] >>> extract_domain(\\"Reach out at info@company.com, sales@shop.net. Or support@service.org!\\") ['company.com', 'shop.net', 'service.org'] >>> extract_domain(\\"There are no emails here.\\") [] >>> extract_domain(\\"Get in touch at user@example.com or example@domain.com, admin@domain.org!\\") ['example.com', 'domain.com', 'domain.org']","solution":"import re def extract_domain(emails): Extracts unique domain names from a string containing one or more email addresses. Args: emails (str): A string containing email addresses Returns: List[str]: A list of unique domain names # Use regular expressions to find all occurrences of domains domains = re.findall(r'@w+.w+', emails) # Extract domain names by removing the leading '@' domain_names = set(domain[1:] for domain in domains) # Return unique domain names preserving the input order return list(domain_names)"},{"question":"from typing import List def generate_ip_addresses(s: str) -> List[str]: Generate all possible valid IP addresses from a given string of digits. A valid IP address consists of exactly four integers (each ranging from 0 to 255) separated by periods. The integers cannot have leading zeros. >>> generate_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> generate_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> generate_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> generate_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] from solution import generate_ip_addresses def test_generate_ip_addresses_example_1(): assert generate_ip_addresses(\\"25525511135\\") == [\\"255.255.11.135\\", \\"255.255.111.35\\"] def test_generate_ip_addresses_example_2(): assert generate_ip_addresses(\\"0000\\") == [\\"0.0.0.0\\"] def test_generate_ip_addresses_example_3(): assert generate_ip_addresses(\\"1111\\") == [\\"1.1.1.1\\"] def test_generate_ip_addresses_example_4(): assert generate_ip_addresses(\\"101023\\") == [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] def test_generate_ip_addresses_empty_string(): assert generate_ip_addresses(\\"\\") == [] def test_generate_ip_addresses_too_short(): assert generate_ip_addresses(\\"123\\") == [] def test_generate_ip_addresses_too_long(): assert generate_ip_addresses(\\"1234567890123\\") == [] def test_generate_ip_addresses_no_valid_ips(): assert generate_ip_addresses(\\"999999999999\\") == [] def test_generate_ip_addresses_leading_zeros(): assert generate_ip_addresses(\\"010010\\") == [\\"0.10.0.10\\", \\"0.100.1.0\\"]","solution":"from typing import List def is_valid(segment: str) -> bool: Check if the given string segment is a valid IP address segment. if len(segment) == 0 or len(segment) > 3: return False if segment[0] == '0' and len(segment) > 1: return False if int(segment) > 255: return False return True def generate_ip_addresses(s: str) -> List[str]: Generate all possible valid IP addresses from a given string. n = len(s) if n < 4 or n > 12: return [] valid_ips = [] for i in range(1, min(4, n - 2)): for j in range(i + 1, min(i + 4, n - 1)): for k in range(j + 1, min(j + 4, n)): s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:] if is_valid(s1) and is_valid(s2) and is_valid(s3) and is_valid(s4): valid_ips.append(f\\"{s1}.{s2}.{s3}.{s4}\\") return valid_ips"},{"question":"import numpy as np def split_into_four_subarrays(input_list): Split a given list of 12 integers into 4 equal-sized sub-arrays. Parameters: input_list (list of int): A list of 12 integers. Returns: list of np.ndarray: A list containing the 4 sub-arrays as NumPy arrays. >>> split_into_four_subarrays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) [array([1, 2, 3]), array([4, 5, 6]), array([7, 8, 9]), array([10, 11, 12])] >>> split_into_four_subarrays([-12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1]) [array([-12, -11, -10]), array([-9, -8, -7]), array([-6, -5, -4]), array([-3, -2, -1])]","solution":"import numpy as np def split_into_four_subarrays(input_list): Split a given list of 12 integers into 4 equal-sized sub-arrays. Parameters: input_list (list of int): A list of 12 integers. Returns: list of np.ndarray: A list containing the 4 sub-arrays as NumPy arrays. array = np.array(input_list) sub_arrays = np.split(array, 4) return sub_arrays # Example usage: input_list = list(map(int, \\"1 2 3 4 5 6 7 8 9 10 11 12\\".split())) result = split_into_four_subarrays(input_list) for sub_array in result: print(sub_array)"},{"question":"from typing import List def count_islands_with_forts(grid: List[List[str]]) -> int: Count the number of islands that contain at least one fortress. An island is defined as a region of connected lands (value '1') that includes at least one fortress (value '2'). You can move up, down, left, or right from any land cell. >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"2\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ] >>> count_islands_with_forts(grid) 1 >>> grid = [ ... [\\"0\\", \\"0\\"], ... [\\"0\\", \\"2\\"] ... ] >>> count_islands_with_forts(grid) 1 >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"0\\", \\"2\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"2\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"2\\", \\"1\\"] ... ] >>> count_islands_with_forts(grid) 3 >>> grid = [ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"2\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ] >>> count_islands_with_forts(grid) 1 >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"2\\", \\"2\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ] >>> count_islands_with_forts(grid) 1 >>> grid = [ ... [\\"2\\", \\"0\\"], ... [\\"0\\", \\"2\\"] ... ] >>> count_islands_with_forts(grid) 2 pass","solution":"from typing import List, Tuple def count_islands_with_forts(grid: List[List[str]]) -> int: def dfs(x: int, y: int) -> None: if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return if grid[x][y] == '1' or grid[x][y] == '2': # Mark the land as visited grid[x][y] = '0' # Conduct DFS in 4 directions for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy dfs(nx, ny) m, n = len(grid), len(grid[0]) count = 0 for i in range(m): for j in range(n): if grid[i][j] == '2': # Start a DFS if we find a fortress count += 1 dfs(i, j) return count"},{"question":"def find_kth_largest(nums, k): Find the k-th largest element in an array. Params: - nums (list of int): The array of integers. - k (int): The k-th largest index (1-based). Returns: - int: The k-th largest element in the array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1, 1, 1, 1, 1], 1) 1 >>> find_kth_largest([1, 1, 1, 1, 1], 3) 1 >>> find_kth_largest([7, 4, 6, 3, 9, 1], 3) 6 >>> find_kth_largest([-3, -2, -1, -5, -6, -4], 2) -2 >>> find_kth_largest([10, 20, 15, 5, 25, 30, 12], 7) 5","solution":"def find_kth_largest(nums, k): Find the k-th largest element in an array. Params: - nums (list of int): The array of integers. - k (int): The k-th largest index (1-based). Returns: - int: The k-th largest element in the array. def partition(left, right, pivot_index): pivot_value = nums[pivot_index] # Move pivot to end nums[pivot_index], nums[right] = nums[right], nums[pivot_index] store_index = left # Move all larger elements to the left for i in range(left, right): if nums[i] > pivot_value: nums[store_index], nums[i] = nums[i], nums[store_index] store_index += 1 # Move pivot to its final place nums[right], nums[store_index] = nums[store_index], nums[right] return store_index def quick_select(left, right, k_smallest): if left == right: return nums[left] # Choose a random pivot index pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return nums[k_smallest] elif k_smallest < pivot_index: return quick_select(left, pivot_index - 1, k_smallest) else: return quick_select(pivot_index + 1, right, k_smallest) return quick_select(0, len(nums) - 1, k - 1)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Finds the maximum sum of any contiguous subarray within a given list of integers. >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) 9 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1","solution":"def max_subarray_sum(nums): Finds the maximum sum of any contiguous subarray within a given list of integers. :param nums: List of integers :return: Maximum subarray sum if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def compact_and_filter(sentence: str, length: int) -> str: Takes a string sentence and an integer length, removes words shorter than the given length, and concatenates the remaining words back into a single string. >>> compact_and_filter(\\"The quick brown fox jumps over the lazy dog\\", 4) \\"quick brown jumps over lazy\\" >>> compact_and_filter(\\"Hello world this is a test\\", 3) \\"Hello world this test\\" >>> compact_and_filter(\\"One two three four five\\", 5) \\"three\\"","solution":"def compact_and_filter(sentence, length): Takes a string sentence and an integer length, removes words shorter than the given length, and concatenates the remaining words back into a single string. words = sentence.split() filtered_words = [word for word in words if len(word) >= length] return ' '.join(filtered_words)"},{"question":"def highest_product_of_three(lst: List[int]) -> int: Write a function that accepts a list of integers and returns the highest product of any three distinct integers from the list. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) # Output: 300 (10*6*5) >>> highest_product_of_three([-10, -10, 1, 3, 2]) # Output: 300 (-10*-10*3) if len(lst) < 3: raise ValueError(\\"List should contain at least 3 numbers.\\") lst.sort() return max(lst[0] * lst[1] * lst[-1], lst[-1] * lst[-2] * lst[-3]) from solution import highest_product_of_three def test_highest_product_of_three(): # Positive numbers assert highest_product_of_three([1, 10, 2, 6, 5, 3]) == 300 # Negative and positive numbers assert highest_product_of_three([-10, -10, 1, 3, 2]) == 300 # All positive numbers assert highest_product_of_three([5, 2, 3, 7]) == 105 # All negative numbers assert highest_product_of_three([-1, -2, -3, -4]) == -6 # Combination with zeros assert highest_product_of_three([0, -1, 3, 100]) == 0 assert highest_product_of_three([0, 0, 0]) == 0 assert highest_product_of_three([0, -1, -2, -3]) == 0 # Mixed negatives and positives with zeros assert highest_product_of_three([-10, -10, 5, 2, 0]) == 500 try: test_highest_product_of_three() print(\\"All tests passed!\\") except AssertionError: print(\\"A test failed.\\")","solution":"def highest_product_of_three(lst): Returns the highest product of any three distinct integers from the list. if len(lst) < 3: raise ValueError(\\"List should contain at least 3 numbers.\\") lst.sort() return max(lst[0] * lst[1] * lst[-1], lst[-1] * lst[-2] * lst[-3])"},{"question":"from typing import List def canFinishCourses(n: int, prerequisites: List[List[int]]) -> bool: Determine if it is possible to finish all courses given their prerequisites. Args: n (int): number of courses prerequisites (List[List[int]]): list of prerequisite pairs Returns: bool: True if it is possible to finish all courses, False otherwise Examples: >>> canFinishCourses(2, [[1, 0]]) True >>> canFinishCourses(2, [[1, 0], [0, 1]]) False >>> canFinishCourses(3, []) True","solution":"from typing import List from collections import defaultdict, deque def canFinishCourses(n: int, prerequisites: List[List[int]]) -> bool: Returns whether it is possible to finish all the courses given the prerequisites. # Create an adjacency list for the graph graph = defaultdict(list) # Create an indegree array to count dependencies indegree = [0] * n # Build the graph and fill the indegree array for course, prereq in prerequisites: graph[prereq].append(course) indegree[course] += 1 # Use a queue to perform BFS queue = deque([i for i in range(n) if indegree[i] == 0]) count_of_finished_courses = 0 while queue: current_course = queue.popleft() count_of_finished_courses += 1 for next_course in graph[current_course]: indegree[next_course] -= 1 if indegree[next_course] == 0: queue.append(next_course) return count_of_finished_courses == n"},{"question":"import numpy as np from typing import List, Tuple def sum_and_product(matrix: List[List[int]]) -> Tuple[int, int, np.ndarray, np.ndarray]: Computes the sum and product of all elements in the matrix, the sum along each row and the sum along each column. Parameters: matrix (list of list of int): NxM integer array Returns: tuple: (sum_all, prod_all, sum_rows, sum_columns) >>> sum_and_product([[1, 2], [3, 4]]) == (10, 24, np.array([3, 7]), np.array([4, 6])) >>> sum_and_product([[5]]) == (5, 5, np.array([5]), np.array([5])) >>> sum_and_product([[0, 0], [0, 0]]) == (0, 0, np.array([0, 0]), np.array([0, 0])) >>> sum_and_product([[-1, 2], [3, -4]]) == (0, 24, np.array([1, -1]), np.array([2, -2]))","solution":"import numpy as np def sum_and_product(matrix): Computes the sum and product of all elements in the matrix, the sum along each row and the sum along each column. Parameters: matrix (list of list of int): NxM integer array Returns: tuple: (sum_all, prod_all, sum_rows, sum_columns) np_matrix = np.array(matrix) sum_all = np.sum(np_matrix) prod_all = np.prod(np_matrix) sum_rows = np.sum(np_matrix, axis=1) sum_columns = np.sum(np_matrix, axis=0) return sum_all, prod_all, sum_rows, sum_columns"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the words in the input string can be rearranged to form a palindrome. :param s: A string of words separated by spaces :return: True if a palindrome can be formed, False otherwise >>> can_form_palindrome(\\"race car\\") True >>> can_form_palindrome(\\"not a palindrome\\") False >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"aabbc\\") True >>> can_form_palindrome(\\"aaaa\\") True >>> can_form_palindrome(\\"aba cBa\\") False >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a man a pla n a ca n a l panam a\\") True","solution":"def can_form_palindrome(s: str) -> bool: Determines if the words in the input string can be rearranged to form a palindrome. :param s: A string of words separated by spaces :return: True if a palindrome can be formed, False otherwise from collections import Counter # Remove spaces and create a frequency count of each character s = s.replace(\\" \\", \\"\\") freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd count, we cannot form a palindrome return odd_count <= 1"},{"question":"def sessions_do_not_overlap(sessions): Returns true if there are no overlapping sessions, otherwise false. Parameters: sessions (list): A list of tuples where each tuple represents a session with start and end times in the format \\"HH:MM\\". Returns: bool: True if no sessions overlap, False otherwise. Examples: >>> sessions_do_not_overlap([(\\"09:00\\", \\"10:30\\"), (\\"10:30\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) True >>> sessions_do_not_overlap([(\\"09:00\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) False","solution":"def sessions_do_not_overlap(sessions): Returns true if there are no overlapping sessions, otherwise false. Parameters: sessions (list): A list of tuples where each tuple represents a session with start and end times. Returns: bool: True if no sessions overlap, False otherwise. sorted_sessions = sorted(sessions, key=lambda x: x[0]) # Sort sessions by their start time for i in range(len(sorted_sessions) - 1): end_time = sorted_sessions[i][1] next_start_time = sorted_sessions[i + 1][0] # If the end time of the current session is greater than the start time of the next session if end_time > next_start_time: return False return True"},{"question":"def maximum_product_of_three_numbers(arr: List[int]) -> int: Returns the maximum product of any three numbers from the array. >>> maximum_product_of_three_numbers([-10, -10, 5, 2]) 500 >>> maximum_product_of_three_numbers([1, 2, 3, 4]) 24","solution":"def maximum_product_of_three_numbers(arr): Returns the maximum product of any three numbers from the array. arr.sort() # The maximum product can be either from the three largest numbers # or from two smallest numbers (both could be negative) and the largest number return max(arr[-1] * arr[-2] * arr[-3], arr[0] * arr[1] * arr[-1])"},{"question":"def second_highest_score(scores): Returns the highest score that is lower than the maximum score in the list. If there is no such score, returns -1. >>> second_highest_score([45, 67, 89, 23, 67, 89]) 67 >>> second_highest_score([100, 99, 98, 97]) 99 >>> second_highest_score([5, 5, 5, 5]) -1 >>> second_highest_score([1]) -1 >>> second_highest_score([50, 100, 100, 75, 75, 100]) 75 >>> second_highest_score([10, 20]) 10 >>> second_highest_score([3, 1, 4, 1, 5, 9, 2, 6, 5]) 6 >>> second_highest_score([-5, -1, -3, -2]) -2 >>> second_highest_score([15, 20, 20, 10]) 15 >>> second_highest_score(list(range(1, 20))) 18 >>> second_highest_score(list(range(20, 0, -1))) 19 >>> second_highest_score([5, 3, 5, 2, 5, 4]) 4","solution":"def second_highest_score(scores): Returns the highest score that is lower than the maximum score in the list. If there is no such score, returns -1. if len(scores) < 2: return -1 # Not enough scores to determine the second highest unique_scores = set(scores) # Remove duplicates if len(unique_scores) < 2: return -1 # Not enough unique scores to determine the second highest unique_scores.remove(max(unique_scores)) # Remove the maximum score return max(unique_scores) # Return the highest score in the remaining set"},{"question":"def can_rearrange_without_adjacent_dups(t: int, test_cases: List[str]) -> List[str]: Given a number of test cases and a list of strings, determines if it's possible to rearrange the characters in each string such that no two adjacent characters are the same. If possible, returns \\"YES\\" followed by the rearranged string, otherwise returns \\"NO\\". Args: t (int): The number of test cases. test_cases (List[str]): A list of strings to be tested. Returns: List[str]: A list containing the results for each test case (\\"YES <arrangement>\\" or \\"NO\\"). Example: >>> can_rearrange_without_adjacent_dups(3, [\\"aab\\", \\"aaab\\", \\"aabb\\"]) [\\"YES aba\\", \\"NO\\", \\"YES abab\\"]","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): Returns a possible rearrangement of the string s such that no two adjacent characters are the same. If it's not possible, returns None. count = Counter(s) max_heap = [] for char, freq in count.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 rearranged_s = ''.join(result) if len(rearranged_s) == len(s): return rearranged_s else: return None def can_rearrange_without_adjacent_dups(t, test_cases): results = [] for s in test_cases: rearranged_s = rearrange_string(s) if rearranged_s: results.append(f\\"YES {rearranged_s}\\") else: results.append(\\"NO\\") return results"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target integer. :param nums: List[int] - List of integers :param target: int - Target integer :return: List[int] - Indices of the two numbers adding up to the target >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1, 2, 3, 1000000000, 999999997], 1999999997) [3, 4] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 3, 3, 4], 6) [1, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the array that add up to the target integer. :param nums: List[int] - List of integers :param target: int - Target integer :return: List[int] - Indices of the two numbers adding up to the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index # Example Usage: # result = two_sum([2, 7, 11, 15], 9) # print(result) # Output: [0, 1]"},{"question":"def can_be_expressed_as_sum_of_consecutive(n: int) -> bool: Determine if a positive integer can be expressed as the sum of two or more consecutive positive integers. Args: n (int): A positive integer. Returns: bool: True if n can be expressed as the sum of two or more consecutive positive integers, otherwise False. >>> can_be_expressed_as_sum_of_consecutive(15) True >>> can_be_expressed_as_sum_of_consecutive(21) True >>> can_be_expressed_as_sum_of_consecutive(28) True >>> can_be_expressed_as_sum_of_consecutive(1) False >>> can_be_expressed_as_sum_of_consecutive(2) False >>> can_be_expressed_as_sum_of_consecutive(4) False >>> can_be_expressed_as_sum_of_consecutive(1000000000) True >>> can_be_expressed_as_sum_of_consecutive(3) True >>> can_be_expressed_as_sum_of_consecutive(7) True","solution":"def can_be_expressed_as_sum_of_consecutive(n): Returns True if the positive integer n can be expressed as the sum of two or more consecutive positive integers, otherwise returns False. # A number can be expressed as the sum of two or more consecutive integers # if it cannot be written in the form of a power of 2 (2^k) where k is a non-negative integer. return (n & (n - 1)) != 0"},{"question":"def count_distinct_increasing_subsequences(seq: List[int]) -> int: Determine the number of distinct increasing subsequences in the given sequence of integers. >>> count_distinct_increasing_subsequences([1]) 1 >>> count_distinct_increasing_subsequences([3, 2, 1]) 3 >>> count_distinct_increasing_subsequences([2, 2, 2]) 1 >>> count_distinct_increasing_subsequences([1, 2, 3, 4]) 15 >>> count_distinct_increasing_subsequences([3, 2, 1, 4, 5]) 15 >>> count_distinct_increasing_subsequences(list(range(1, 21))) ...","solution":"def count_distinct_increasing_subsequences(seq): from itertools import combinations def is_increasing(subseq): return all(x < y for x, y in zip(subseq, subseq[1:])) n = len(seq) all_subsequences = set() for i in range(1, n + 1): for subseq in combinations(seq, i): if is_increasing(subseq): all_subsequences.add(subseq) return len(all_subsequences)"},{"question":"def second_largest(numbers: List[int]) -> Union[int, str]: Returns the second largest number in the list. If the list contains less than 2 elements, return \\"List needs at least two elements\\". >>> second_largest([3, 1, 4, 1, 5, 9]) == 5 >>> second_largest([]) == \\"List needs at least two elements\\" >>> second_largest([1]) == \\"List needs at least two elements\\" >>> second_largest([1, 2]) == 1 >>> second_largest([1, 2, 2, 2]) == 1 >>> second_largest([2, 2, 2, 2]) == \\"No second largest element\\" >>> second_largest([-3, -1, -4, -1, -2]) == -2 >>> second_largest([1, -2, 3, -4]) == 1","solution":"def second_largest(numbers): Returns the second largest number in the list. If the list contains less than 2 elements, return \\"List needs at least two elements\\". if len(numbers) < 2: return \\"List needs at least two elements\\" first, second = float('-inf'), float('-inf') for num in numbers: if num > first: first, second = num, first elif num > second and num != first: second = num return second if second != float('-inf') else \\"No second largest element\\""},{"question":"from typing import List def countCharacters(words: List[str], chars: str) -> int: Given an array of strings words and a string chars, find the total length of all strings in words that can be formed using the characters in chars. Parameters: - words (List[str]): List of words to form. - chars (str): String providing characters to form words. Returns: - int: Total length of all strings that can be formed. Examples: >>> countCharacters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> countCharacters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 pass # Unit tests def test_example_1(): assert countCharacters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") == 6 def test_example_2(): assert countCharacters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") == 10 def test_single_word(): assert countCharacters([\\"single\\"], \\"singenicle\\") == 6 assert countCharacters([\\"single\\"], \\"segnic\\") == 0 def test_all_words_formable(): assert countCharacters([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"abcd\\") == 4 def test_no_words_formable(): assert countCharacters([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"xyz\\") == 0 def test_repeated_characters(): assert countCharacters([\\"aaa\\", \\"aa\\", \\"a\\"], \\"aaaa\\") == 6 assert countCharacters([\\"aaaa\\", \\"aa\\", \\"a\\"], \\"aaa\\") == 3","solution":"from collections import Counter def countCharacters(words, chars): Given an array of strings words and a string chars, find the total length of all strings in words that can be formed using the characters in chars. Parameters: - words (List[str]): List of words to form. - chars (str): String providing characters to form words. Returns: - int: Total length of all strings that can be formed. chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"from typing import List def exponential_to_logarithmic(equation1: str, equation2: str) -> str: Convert two exponential equations of the form 'a^x = b' and 'c^y = d' into a single logarithmic equation of the form 'A*log(y) + B*log(x) = C'. Parameters: equation1 (str): The first exponential equation as a string. equation2 (str): The second exponential equation as a string. Returns: str: A logarithmic equation representing the relationship between x and y. >>> exponential_to_logarithmic(\\"2^x = 8\\", \\"3^y = 27\\") '3log(y) + log(x) = 3' >>> exponential_to_logarithmic(\\"5^x = 125\\", \\"2^y = 16\\") 'log(x) + 4log(y) = 6' pass","solution":"import math def exponential_to_logarithmic(equation1, equation2): # Parse the input equations a_str, b_str = equation1.split(\\"^x = \\") c_str, d_str = equation2.split(\\"^y = \\") # Convert string values to integers a = int(a_str) b = int(b_str) c = int(c_str) d = int(d_str) # Calculate the exponents based on the given equations x = math.log(b, a) y = math.log(d, c) # Convert the exponents into integers if they're handle cleanly x = round(x) y = round(y) # A coefficient for log(y) A = y # B coefficient for log(x) B = 1 # C result C = A + 1 return f\\"{A}log(y) + {B}log(x) = {C}\\""},{"question":"def min_edit_distance(str1: str, str2: str) -> int: Returns the minimum number of edits (insertions, deletions, or substitutions) required to transform str1 into str2. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 >>> min_edit_distance(\\"abc\\", \\"abc\\") == 0 >>> min_edit_distance(\\"\\", \\"abc\\") == 3 >>> min_edit_distance(\\"abc\\", \\"\\") == 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") == 5 >>> min_edit_distance(\\"a\\", \\"b\\") == 1 >>> min_edit_distance(\\"a\\", \\"ab\\") == 1 >>> min_edit_distance(\\"ab\\", \\"a\\") == 1","solution":"def min_edit_distance(str1, str2): Returns the minimum number of edits (insertions, deletions, or substitutions) required to transform str1 into str2. m = len(str1) n = len(str2) # Create a dp table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in a bottom up manner for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If str1 is empty, insert all characters of str2 elif j == 0: dp[i][j] = i # If str2 is empty, remove all characters of str1 elif str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1])# Replace return dp[m][n]"},{"question":"def is_palindrome(s: str) -> bool: Check if the given string is a palindrome. Ignore spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Hello, world!\\") False def test_palindrome_word(): assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"Level\\") == True assert is_palindrome(\\"Radar\\") == True def test_palindrome_phrase(): assert is_palindrome(\\"A man a plan a canal Panama\\") == True assert is_palindrome(\\"Was it a car or a cat I saw\\") == True def test_not_palindrome(): assert is_palindrome(\\"Hello, world!\\") == False assert is_palindrome(\\"This is not a palindrome\\") == False def test_single_characters(): assert is_palindrome(\\"A\\") == True assert is_palindrome(\\"z\\") == True def test_mixed_cases(): assert is_palindrome(\\"Able was I ere I saw Elba\\") == True assert is_palindrome(\\"No lemon, no melon\\") == True","solution":"def is_palindrome(s): Check if the given string is a palindrome. Ignore spaces, punctuation, and capitalization. import re # Remove all non-alphanumeric characters and convert to lowercase cleaned_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"from typing import Dict def word_count(s: str) -> Dict[str, int]: Returns the frequency of each word in the input string. Ignores punctuation and converts words to lowercase. >>> word_count(\\"Hello, world! Hello Python world.\\") {'hello': 2, 'world': 2, 'python': 1} >>> word_count(\\"It's the end of the world as we know it, and I feel fine.\\") {'it': 2, 's': 1, 'the': 2, 'end': 1, 'of': 1, 'world': 1, 'as': 1, 'we': 1, 'know': 1, 'and': 1, 'i': 1, 'feel': 1, 'fine': 1} >>> word_count(\\"Apple apple apple\\") {'apple': 3} >>> word_count(\\"\\") {} >>> word_count(\\"Hello world\\") {'hello': 1, 'world': 1}","solution":"import re from collections import Counter def word_count(s): Returns the frequency of each word in the input string. Ignores punctuation and converts words to lowercase. # Use regular expression to find words and convert them to lowercase words = re.findall(r'bw+b', s.lower()) # Use Counter to count the frequency of each word return dict(Counter(words))"},{"question":"def intersection_with_counts(list1, list2): Returns the intersection of two lists, considering the frequency of each element and preserving the order as in the first list. >>> intersection_with_counts([4, 9, 5, 4], [9, 4, 9, 8, 4]) [4, 9, 4] >>> intersection_with_counts([1, 2, 2, 1], [2, 2]) [2, 2] >>> intersection_with_counts([1, 2, 3], [3, 4, 5]) [3]","solution":"def intersection_with_counts(list1, list2): Returns the intersection of two lists, considering the frequency of each element and preserving the order as in the first list. result = [] counts = {} # Count occurrences of elements in list2 for num in list2: if num in counts: counts[num] += 1 else: counts[num] = 1 # Iterate through list1 and collect intersecting elements for num in list1: if num in counts and counts[num] > 0: result.append(num) counts[num] -= 1 return result"},{"question":"def process_instructions(instructions: List[str]) -> List[Tuple[int, int]]: Processes a list of toggle instructions and returns a sorted list of tuples representing the coordinates of all lights that are on. >>> process_instructions(['toggle 0,0']) [(0, 0)] >>> process_instructions(['toggle 0,0', 'toggle 0,0']) [] >>> process_instructions(['toggle 0,0', 'toggle 1,1', 'toggle 0,0']) [(1, 1)] >>> process_instructions(['toggle 0,0', 'toggle 1,1', 'toggle 2,2', 'toggle 1,1', 'toggle 3,3']) [(0, 0), (2, 2), (3, 3)] >>> process_instructions(['toggle -1,-1', 'toggle -2,-2', 'toggle -1,-1']) [(-2, -2)] >>> process_instructions(['toggle 0,0', 'toggle 0,0', 'toggle 0,0', 'toggle 0,0', 'toggle 0,0']) [(0, 0)] >>> process_instructions([f'toggle {i},{i}' for i in range(1000)]) [(i, i) for i in range(1000)]","solution":"def process_instructions(instructions): Processes a list of toggle instructions and returns a sorted list of tuples representing the coordinates of all lights that are on. lights = set() for instruction in instructions: toggle, coord = instruction.split() x, y = map(int, coord.split(',')) if (x, y) in lights: lights.remove((x, y)) else: lights.add((x, y)) return sorted(lights)"},{"question":"def analyze_route(traffic_lights): Analyze the safety and urgency of the route based on the sequence of traffic lights. :param traffic_lights: List of strings where each string is 'green', 'yellow', or 'red' :return: A string indicating the safety and urgency of the route Examples: >>> analyze_route(['green', 'green', 'green']) \\"Safe route, proceed!\\" >>> analyze_route(['green', 'yellow', 'green']) \\"Caution! Be prepared to stop!\\" >>> analyze_route(['green', 'red', 'yellow']) \\"Stop! Dangerous route ahead!\\"","solution":"def analyze_route(traffic_lights): Analyze the safety and urgency of the route based on the sequence of traffic lights. :param traffic_lights: List of strings where each string is 'green', 'yellow', or 'red' :return: A string indicating the safety and urgency of the route if 'red' in traffic_lights: return \\"Stop! Dangerous route ahead!\\" elif 'yellow' in traffic_lights: return \\"Caution! Be prepared to stop!\\" else: return \\"Safe route, proceed!\\""},{"question":"from collections import deque def min_steps(garden: List[List[int]], R: int, C: int) -> int: Find the minimum number of steps to navigate from the top-left corner to the bottom-right corner. >>> min_steps([[0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [1, 0, 0, 0, 0]], 5, 5) 8 >>> min_steps([[0, 1], [0, 0]], 2, 2) 2 >>> min_steps([[0, 1, 0], [1, 1, 0], [0, 1, 0]], 3, 3) -1 >>> min_steps([[0]], 1, 1) 0 >>> min_steps([[1, 1], [1, 1]], 2, 2) -1 >>> min_steps([[0, 0], [0, 0]], 2, 2) 2","solution":"from collections import deque def min_steps(garden, R, C): Find the minimum number of steps to navigate from the top-left corner to the bottom-right corner. Uses BFS to navigate the garden matrix. # Directions: Right, Down, Left, Up. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we reach the bottom-right corner, return the distance. if r == R - 1 and c == C - 1: return dist # Try all possible directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and garden[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If no path is found, return -1 return -1"},{"question":"def removeOuterParentheses(s: str) -> str: Return the string after removing the outermost parentheses of every primitive substring. A primitive substring is a non-empty substring that can be partitioned into multiple balanced pairs of parentheses, but every partition starts with a left parenthesis and ends with a right parenthesis. Examples: >>> removeOuterParentheses(\\"(()())(())\\") \\"()()()\\" >>> removeOuterParentheses(\\"(()())(())(()(()))\\") \\"()()()()(())\\" >>> removeOuterParentheses(\\"()()\\") \\"\\" >>> removeOuterParentheses(\\"((()))\\") \\"(())\\" >>> removeOuterParentheses(\\"((()()))\\") \\"(()())\\"","solution":"def removeOuterParentheses(s): This function removes the outermost parentheses from every primitive substring of s. result = [] open_count = 0 for char in s: if char == '(': if open_count > 0: result.append(char) open_count += 1 else: # char == ')' open_count -= 1 if open_count > 0: result.append(char) return \\"\\".join(result)"},{"question":"def validate_timestamps(timestamps: List[str]) -> List[str]: Given a list of timestamps, validate each one and return the results. Validation rules: - Each timestamp must be exactly 19 characters long. - It must follow the format: YYYY-MM-DD HH:MM:SS - Year (YYYY) must be a 4-digit number that is a leap year. - Month (MM) should be from 01 to 12. - Day (DD) must be valid for the given month and year. - Hour (HH) should be from 00 to 23. - Minute (MM) should be from 00 to 59. - Second (SS) should be from 00 to 59. >>> validate_timestamps([\\"2020-02-29 12:45:59\\", \\"2019-02-29 12:45:59\\"]) [\\"Valid\\", \\"Invalid\\"] >>> validate_timestamps([\\"2020-04-31 12:45:59\\", \\"2020-02-30 12:45:59\\"]) [\\"Invalid\\", \\"Invalid\\"] >>> validate_timestamps([\\"2000-02-29 23:59:59\\", \\"2096-02-29 00:00:00\\"]) [\\"Valid\\", \\"Valid\\"]","solution":"import datetime def is_leap_year(year): Returns True if the given year is a leap year, otherwise False. return (year % 4 == 0) and (year % 100 != 0 or year % 400 == 0) def validate_timestamp(timestamp): Validates the format and values of the given timestamp. if len(timestamp) != 19: return 'Invalid' try: year, month, day = int(timestamp[:4]), int(timestamp[5:7]), int(timestamp[8:10]) hour, minute, second = int(timestamp[11:13]), int(timestamp[14:16]), int(timestamp[17:19]) except ValueError: return 'Invalid' if not is_leap_year(year): if month == 2 and day > 28: return 'Invalid' try: datetime.datetime(year, month, day, hour, minute, second) except ValueError: return 'Invalid' return 'Valid' def validate_timestamps(timestamps): Given a list of timestamps, validate each one and return the results. results = [] for timestamp in timestamps: results.append(validate_timestamp(timestamp)) return results"},{"question":"def does_return_home(start_position: (int, int), moves: str) -> bool: Function to check if a drone returns to its starting position after a series of moves. Args: start_position (tuple of int): A tuple containing the starting (row, column) position of the drone. moves (str): A string representing the sequence of moves made by the drone. Returns: bool: True if the drone returns to its starting position, otherwise False. Examples: >>> does_return_home((0, 0), \\"UDLR\\") True >>> does_return_home((1, 2), \\"UUDDLLRR\\") True >>> does_return_home((2, 3), \\"RRU\\") False","solution":"def does_return_home(start_position, moves): Function to check if a drone returns to its starting position after a series of moves. Args: start_position (tuple of int): A tuple containing the starting (row, column) position of the drone. moves (str): A string representing the sequence of moves made by the drone. Returns: bool: True if the drone returns to its starting position, otherwise False. x, y = start_position for move in moves: if move == 'U': x -= 1 elif move == 'D': x += 1 elif move == 'L': y -= 1 elif move == 'R': y += 1 return (x, y) == start_position"},{"question":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size \`k\`. If \`k\` is larger than the length of the array, returns None. >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([10], 1) 10 >>> max_sum_subarray([1, 2, 3], 5) None >>> max_sum_subarray([1, 2, 3], 3) 6 >>> max_sum_subarray([-1, -2, -3, -4], 2) -3 >>> max_sum_subarray([-1, 4, -2, 3, 5], 3) 6","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any contiguous subarray of size k. If k is larger than the length of the array, returns None. if k > len(arr): return None max_sum = float('-inf') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from collections import Counter def inventory_report(codes: List[str]) -> List[str]: Generate the inventory report from given codes. >>> inventory_report([\\"a3b2c1\\"]) [\\"a3b2c1\\"] >>> inventory_report([\\"xyz9\\"]) [\\"x1y1z9\\"] >>> inventory_report([\\"m5n3p2\\"]) [\\"m5n3p2\\"]","solution":"def inventory_report(codes): import collections result = [] for code in codes: counter = collections.Counter() i = 0 while i < len(code): char = code[i] num = 0 i += 1 while i < len(code) and code[i].isdigit(): num = num * 10 + int(code[i]) i += 1 counter[char] += num sorted_items = sorted(counter.items()) report = ''.join(f\\"{char}{count}\\" for char, count in sorted_items) result.append(report) return result"},{"question":"def largestContiguousSum(nums: List[int]) -> int: Returns the largest sum of a contiguous subarray within the given array. >>> largestContiguousSum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> largestContiguousSum([-3, -2, -1, -4]) -1 >>> largestContiguousSum([1, 2, 3, 4]) 10 >>> largestContiguousSum([0, -3, 5, 6, 3, -1, 0, -6, 3]) 14 >>> largestContiguousSum([5]) 5 >>> largestContiguousSum([]) 0 >>> largestContiguousSum([10**6, -10**7, 10**6, 10**7]) 11000000","solution":"def largestContiguousSum(nums): Returns the largest sum of a contiguous subarray within the given array. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def next_letter(s: str) -> str: Given a string consisting of lowercase letters, replace each letter with the next letter in the alphabet (with 'a' replacing 'z') and return the resulting string. >>> next_letter(\\"abcdz\\") \\"bcdea\\" >>> next_letter(\\"xyz\\") \\"yza\\"","solution":"def next_letter(s: str) -> str: Given a string consisting of lowercase letters, replace each letter with the next letter in the alphabet (with 'a' replacing 'z') and return the resulting string. result = [] for char in s: if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def sumBinary(A: str, B: str) -> str: Returns the sum of two binary numbers A and B as a binary string. >>> sumBinary(\\"101\\", \\"11\\") \\"1000\\" >>> sumBinary(\\"110\\", \\"110\\") \\"1100\\" >>> sumBinary(\\"1\\", \\"1\\") \\"10\\" # Your code here # Unit tests def test_sumBinary(): assert sumBinary(\\"101\\", \\"11\\") == \\"1000\\", \\"Test case 1 failed\\" assert sumBinary(\\"110\\", \\"110\\") == \\"1100\\", \\"Test case 2 failed\\" assert sumBinary(\\"1\\", \\"1\\") == \\"10\\", \\"Test case 3 failed\\" assert sumBinary(\\"0\\", \\"0\\") == \\"0\\", \\"Test case 4 failed\\" assert sumBinary(\\"111\\", \\"111\\") == \\"1110\\", \\"Test case 5 failed\\" assert sumBinary(\\"1001\\", \\"1011\\") == \\"10100\\", \\"Test case 6 failed\\" assert sumBinary(\\"1111\\", \\"1111\\") == \\"11110\\", \\"Test case 7 failed\\" assert sumBinary(\\"10001\\", \\"110\\") == \\"10111\\", \\"Test case 8 failed\\" print(\\"All test cases pass\\") # Run the tests test_sumBinary()","solution":"def sumBinary(A, B): Returns the sum of two binary numbers A and B as a binary string. max_len = max(len(A), len(B)) # Padding the binary strings with leading zeros to make them of equal length A = A.zfill(max_len) B = B.zfill(max_len) carry = 0 result = [] # Perform binary addition from the least significant bit (rightmost) for i in range(max_len - 1, -1, -1): bit_sum = carry bit_sum += 1 if A[i] == '1' else 0 bit_sum += 1 if B[i] == '1' else 0 # Append the current bit to the result result.append('1' if bit_sum % 2 == 1 else '0') # Update the carry carry = 0 if bit_sum < 2 else 1 # If there's a carry left after the final addition, add it to the result if carry != 0: result.append('1') # The result is currently in reverse order result.reverse() return ''.join(result)"},{"question":"def flatten(nested_list): Recursively flattens a nested list. Args: nested_list (list): A nested list of arbitrary depth. Returns: list: A single, flattened list containing all the elements. >>> flatten([1, [2, [3, 4], 5], 6]) [1, 2, 3, 4, 5, 6] >>> flatten([[], [1, [[], [2, 3]]]]) [1, 2, 3]","solution":"def flatten(nested_list): Recursively flattens a nested list. Args: nested_list (list): A nested list of arbitrary depth. Returns: list: A single, flattened list containing all the elements. result = [] for item in nested_list: if isinstance(item, list): result.extend(flatten(item)) else: result.append(item) return result"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. pass def find_twin_primes(numbers: List[int]) -> List[Tuple[int, int]]: Find and return all pairs of twin primes in the given list of numbers. >>> find_twin_primes([3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31)] >>> find_twin_primes([4, 6, 8, 10, 14, 18]) [] pass def process_twin_primes_output(n: int, numbers: List[int]) -> str: Process the input and generate the required output format. >>> process_twin_primes_output(10, [3, 5, 7, 11, 13, 17, 19, 23, 29, 31]) '3 5n5 7n11 13n17 19n29 31' >>> process_twin_primes_output(6, [4, 6, 8, 10, 14, 18]) 'No twin primes' pass","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def find_twin_primes(numbers): Find and return all pairs of twin primes in the given list of numbers. prime_numbers = sorted([num for num in numbers if is_prime(num)]) twin_primes = [] for i in range(len(prime_numbers) - 1): if prime_numbers[i + 1] == prime_numbers[i] + 2: twin_primes.append((prime_numbers[i], prime_numbers[i + 1])) return twin_primes def process_twin_primes_output(n, numbers): Process the input and generate the required output format. twin_primes = find_twin_primes(numbers) if not twin_primes: return \\"No twin primes\\" else: return \\"n\\".join(f\\"{pair[0]} {pair[1]}\\" for pair in twin_primes)"},{"question":"def ATM(commands: List[str]) -> List[int]: Simulates the working of an ATM machine by handling deposit, withdraw, and balance operations. >>> ATM([\\"deposit 100\\", \\"balance\\"]) == [100] >>> ATM([\\"deposit 200\\", \\"deposit 50\\", \\"balance\\"]) == [250] >>> ATM([\\"deposit 100\\", \\"withdraw 50\\", \\"balance\\"]) == [50] >>> ATM([\\"deposit 100\\", \\"withdraw 150\\", \\"balance\\"]) == [100] >>> ATM([\\"deposit 100\\", \\"withdraw 100\\", \\"balance\\"]) == [0] >>> ATM([\\"deposit 100\\", \\"balance\\", \\"withdraw 30\\", \\"balance\\", \\"withdraw 50\\", \\"balance\\", \\"withdraw 100\\", \\"balance\\"]) == [100, 70, 20, 20] >>> ATM([\\"balance\\"]) == [0] >>> ATM([\\"balance\\", \\"deposit 100\\", \\"withdraw 200\\", \\"balance\\", \\"deposit 50\\", \\"balance\\"]) == [0, 100, 150] >>> ATM([\\"balance\\"]) == [0] >>> ATM([\\"balance\\", \\"balance\\", \\"balance\\"]) == [0, 0, 0]","solution":"def ATM(commands): balance = 0 results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"deposit\\": amount = int(parts[1]) balance += amount elif action == \\"withdraw\\": amount = int(parts[1]) if amount <= balance: balance -= amount elif action == \\"balance\\": results.append(balance) return results"},{"question":"def find_palindromes(strings: List[str]) -> List[str]: Returns a list of palindromes from the provided list of strings. >>> find_palindromes(['madam', 'racecar', 'apple', 'level']) ['madam', 'racecar', 'level'] >>> find_palindromes(['Python', 'Hello', 'world']) [] >>> find_palindromes([]) [] pass def test_find_palindromes_with_palindromes(): assert find_palindromes(['madam', 'racecar', 'apple', 'level']) == ['madam', 'racecar', 'level'] def test_find_palindromes_without_palindromes(): assert find_palindromes(['Python', 'Hello', 'world']) == [] def test_find_palindromes_empty_list(): assert find_palindromes([]) == [] def test_find_palindromes_mixed_case(): assert find_palindromes(['Madam', 'Racecar', 'Apple', 'Level']) == ['Madam', 'Racecar', 'Level'] def test_find_palindromes_single_character(): assert find_palindromes(['a', 'b', 'c']) == ['a', 'b', 'c'] def test_find_palindromes_mixed_character(): assert find_palindromes(['aBba', 'Deed', 'Noon', 'hello']) == ['aBba', 'Deed', 'Noon']","solution":"def find_palindromes(strings): Returns a list of palindromes from the provided list of strings. Args: strings (list): The list of strings to be checked for palindromes. Returns: list: A list of palindrome strings. return [s for s in strings if s.lower() == s.lower()[::-1]] # Example usage: # print(find_palindromes(['madam', 'racecar', 'apple', 'level'])) # should return ['madam', 'racecar', 'level'] # print(find_palindromes(['Python', 'Hello', 'world'])) # should return [] # print(find_palindromes([])) # should return []"},{"question":"def solve(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the number of notifications for potential fraudulent activities for multiple test cases. Args: T : int : number of test cases test_cases : List[Tuple[int, int, List[int]]] : list containing tuples of test case parameters Returns: List[int] : list of integers representing the number of notifications for each test case Example: >>> solve(2, [(9, 5, [2, 3, 4, 2, 3, 6, 8, 4, 5]), (5, 2, [1, 2, 3, 4, 5])]) [2, 1]","solution":"from bisect import insort, bisect_left def median(data, d): k = d // 2 if d % 2 == 0: return (data[k-1] + data[k]) / 2 else: return data[k] def count_notifications(exp, d): cnt = 0 trailing = sorted(exp[:d]) for i in range(d, len(exp)): med = median(trailing, d) if exp[i] >= 2 * med: cnt += 1 # Remove the element that's no longer in the trailing period trailing.pop(bisect_left(trailing, exp[i-d])) # Add the new element while maintaining sorted order insort(trailing, exp[i]) return cnt def solve(T, test_cases): results = [] for case in test_cases: n, d, expenditures = case notifications = count_notifications(expenditures, d) results.append(notifications) return results"},{"question":"def is_permutation(s1: str, s2: str) -> bool: Determines if one string is a permutation of the other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. pass # Test cases def test_is_permutation_true(): assert is_permutation(\\"abc\\", \\"cab\\") == True assert is_permutation(\\"123\\", \\"321\\") == True assert is_permutation(\\"\\", \\"\\") == True # edge case: empty strings assert is_permutation(\\"aabbcc\\", \\"bbaacc\\") == True def test_is_permutation_false(): assert is_permutation(\\"abc\\", \\"def\\") == False assert is_permutation(\\"abcd\\", \\"abc\\") == False assert is_permutation(\\"123\\", \\"12\\") == False assert is_permutation(\\"aabbcc\\", \\"aabbc\\") == False def test_is_permutation_different_lengths(): assert is_permutation(\\"abc\\", \\"abcd\\") == False def test_is_permutation_case_sensitive(): assert is_permutation(\\"abc\\", \\"ABC\\") == False","solution":"def is_permutation(s1, s2): Determines if one string is a permutation of the other. Args: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. return sorted(s1) == sorted(s2)"},{"question":"def find_shortest_time(buses, source_stop, destination_stop): Finds the shortest travel time from source_stop to destination_stop using Dijkstra's algorithm. :param buses: List of tuples (start_stop, end_stop, time_interval) :param source_stop: The bus stop from which travel starts :param destination_stop: The bus stop at which travel ends :return: The shortest travel time or -1 if unreachable # Example Test Cases buses = [(\\"A\\", \\"B\\", 4), (\\"B\\", \\"D\\", 1), (\\"A\\", \\"C\\", 2), (\\"C\\", \\"D\\", 7), (\\"D\\", \\"E\\", 3)] assert find_shortest_time(buses, \\"A\\", \\"E\\") == 8 buses = [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 1), (\\"C\\", \\"D\\", 1), (\\"D\\", \\"A\\", 1)] assert find_shortest_time(buses, \\"A\\", \\"D\\") == 3 buses = [(\\"X\\", \\"Y\\", 5), (\\"Y\\", \\"Z\\", 10)] assert find_shortest_time(buses, \\"X\\", \\"A\\") == -1 buses = [(\\"R\\", \\"S\\", 2)] assert find_shortest_time(buses, \\"R\\", \\"S\\") == 2","solution":"import heapq def find_shortest_time(buses, source_stop, destination_stop): Finds the shortest travel time from source_stop to destination_stop using Dijkstra's algorithm. :param buses: List of tuples (start_stop, end_stop, time_interval) :param source_stop: The bus stop from which travel starts :param destination_stop: The bus stop at which travel ends :return: The shortest travel time or -1 if unreachable # Create graph from buses data graph = {} for start, end, time in buses: if start not in graph: graph[start] = [] graph[start].append((end, time)) # Priority queue for Dijkstra's algorithm pq = [(0, source_stop)] shortest_time = {source_stop: 0} while pq: current_time, stop = heapq.heappop(pq) if stop == destination_stop: return current_time for neighbor, travel_time in graph.get(stop, []): time = current_time + travel_time if neighbor not in shortest_time or time < shortest_time[neighbor]: shortest_time[neighbor] = time heapq.heappush(pq, (time, neighbor)) return -1"},{"question":"from typing import List def difference_max_min(nums: List[int]) -> int: Given a list of integers, return the difference between the largest and smallest values in the list. Constraints: 1. The list will contain at least two integers. 2. The integers can be both positive and negative. 3. The list can contain repeated values. >>> difference_max_min([1, 2, 3, 4, 5]) 4 >>> difference_max_min([-1, -2, -3, -4, -5]) 4 >>> difference_max_min([-1, -2, 2, 3, -4, 5]) 9 >>> difference_max_min([2, 2, 2, 2, 2]) 0 >>> difference_max_min([5, 5, 5, 5, -5]) 10 # Your code here","solution":"def difference_max_min(nums): Returns the difference between the largest and smallest values in the list. if len(nums) < 2: raise ValueError(\\"The list should contain at least two integers.\\") min_val = float('inf') max_val = float('-inf') for num in nums: if num < min_val: min_val = num if num > max_val: max_val = num return max_val - min_val"},{"question":"def convert_grayscale_to_ascii(pixels: List[int], width: int, height: int) -> str: Convert a list of pixel values into a string representing the grayscale image using specified symbols for different ranges of pixel values. :param pixels: List of integers representing pixel values :param width: Width of the image grid :param height: Height of the image grid :return: String representation of grayscale image pass # Unit tests from solution import convert_grayscale_to_ascii def test_single_row(): assert convert_grayscale_to_ascii([150, 200, 50, 0, 180, 255, 70, 10, 90], 9, 1) == \\"@ # . . @ # + . +\\" def test_multiple_rows(): assert convert_grayscale_to_ascii([150, 200, 50, 0, 180, 255, 70, 10, 90], 3, 3) == \\"@ # .n. @ #n+ . +\\" def test_all_symbols(): assert convert_grayscale_to_ascii([0, 64, 128, 192], 2, 2) == \\". +n@ #\\" def test_uniform_values(): assert convert_grayscale_to_ascii([255, 255, 255, 255], 2, 2) == \\"# #n# #\\" assert convert_grayscale_to_ascii([0, 0, 0, 0], 2, 2) == \\". .n. .\\" def test_empty_input(): assert convert_grayscale_to_ascii([], 0, 0) == \\"\\"","solution":"def convert_grayscale_to_ascii(pixels, width, height): Convert a list of pixel values into a string representing the grayscale image using specified symbols for different ranges of pixel values. symbol_map = [ (192, '#'), (128, '@'), (64, '+'), (0, '.') ] rows = [] for i in range(height): row = [] for j in range(width): pixel = pixels[i * width + j] for threshold, symbol in symbol_map: if pixel >= threshold: row.append(symbol) break rows.append(\\" \\".join(row)) return \\"n\\".join(rows)"},{"question":"def can_reach_end(nums: List[int], k: int) -> bool: Determine if you can successfully reach the end of the array by jumping from block to block. Parameters: nums (list): An array of integers representing the block heights. k (int): An integer representing the maximum height you can jump. Returns: bool: True if you can reach the last block, otherwise False. >>> can_reach_end([1, 3, 2, 4, 3, 5], 2) True >>> can_reach_end([1, 3, 7, 2, 4, 3], 2) False >>> can_reach_end([1], 2) True >>> can_reach_end([3, 3, 3, 3, 3], 2) True >>> can_reach_end([4, 2, 6, 8, 3], 5) True >>> can_reach_end([4, 2, 7, 9, 3], 3) False >>> can_reach_end([1, 1, 1, 1, 1], 0) True","solution":"def can_reach_end(nums, k): Determine if you can successfully reach the end of the array by jumping from block to block. Parameters: nums (list): An array of integers representing the block heights. k (int): An integer representing the maximum height you can jump. Returns: bool: True if you can reach the last block, otherwise False. for i in range(len(nums) - 1): if abs(nums[i + 1] - nums[i]) > k: return False return True"},{"question":"from typing import List def findMin(nums: List[int]) -> int: This function finds the minimum element in a rotated sorted array. >>> findMin([3,4,5,1,2]) 1 >>> findMin([4,5,6,7,0,1,2]) 0 >>> findMin([11,13,15,17]) 11 >>> findMin([1,2,3,4,5,6,7]) 1 >>> findMin([1]) 1 >>> findMin([2, 1]) 1 >>> findMin([2, 3, 4, 5, 1]) 1 >>> findMin(list(range(1000, 10000)) + list(range(1000))) 0","solution":"def findMin(nums): This function finds the minimum element in a rotated sorted array. Parameters: nums (List[int]): The input rotated sorted array without duplicates. Returns: int: The minimum element in the array. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[right]: left = mid + 1 else: right = mid return nums[left]"},{"question":"def get_mode(numbers: List[int]) -> int: Given a list of integers, return the mode (the number that appears most frequently). If multiple numbers have the same highest frequency, return the smallest number among them. If the list is empty, return None. :param numbers: List[int] - A list of integers :return: int - The mode of the list >>> get_mode([1, 2, 2, 3, 3, 4]) # 2 >>> get_mode([1, 1, 2, 2, 3, 3]) # 1 >>> get_mode([5, 1, 2, 2, 3, 1, 3, 4]) # 1 >>> get_mode([]) # None >>> get_mode([7]) # 7 >>> get_mode([4, 4, 4, 4]) # 4 >>> get_mode([1, 2, 3, 3, 2, 1, 1]) # 1 >>> get_mode([1]*1000 + [2]*1000 + [3]*500) # 1","solution":"def get_mode(numbers): Given a list of integers, return the mode (the number that appears most frequently). :param numbers: List[int] - A list of integers :return: int - The mode of the list from collections import Counter if not numbers: return None count = Counter(numbers) max_frequency = max(count.values()) modes = [num for num, freq in count.items() if freq == max_frequency] return min(modes)"},{"question":"from typing import List def islandCount(matrix: List[List[str]]) -> int: Write a function to count the number of islands in a given matrix. An island is a region of land (represented by '1's) surrounded by water (represented by '0's). The islands are formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the matrix are surrounded by water. >>> matrix = [ ... ['1', '1', '0', '0', '0'], ... ['1', '1', '0', '0', '0'], ... ['0', '0', '1', '0', '0'], ... ['0', '0', '0', '1', '1'] ... ] >>> islandCount(matrix) 3 >>> matrix = [ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ] >>> islandCount(matrix) 0 >>> matrix = [ ... ['0', '0', '0', '0'], ... ['0', '1', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ] >>> islandCount(matrix) 1 >>> matrix = [ ... ['1', '0', '1', '0', '1'], ... ['0', '1', '0', '1', '0'], ... ['1', '0', '1', '0', '1'], ... ['0', '1', '0', '1', '0'], ... ['1', '0', '1', '0', '1'] ... ] >>> islandCount(matrix) 13 >>> matrix = [ ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'] ... ] >>> islandCount(matrix) 1 >>> matrix = [] >>> islandCount(matrix) 0 >>> matrix = [['1', '0', '1', '1', '0']] >>> islandCount(matrix) 2 >>> matrix = [['1'], ['0'], ['1'], ['1'], ['0']] >>> islandCount(matrix) 2","solution":"from typing import List def islandCount(matrix: List[List[str]]) -> int: if not matrix: return 0 m, n = len(matrix), len(matrix[0]) def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] == '0': return matrix[i][j] = '0' # Mark the cell as visited by setting it to '0' # Traverse all 4 possible directions (up, down, left, right) dfs(i-1, j) # up dfs(i+1, j) # down dfs(i, j-1) # left dfs(i, j+1) # right count = 0 for i in range(m): for j in range(n): if matrix[i][j] == '1': count += 1 # Found an island dfs(i, j) return count"},{"question":"def calculate_volumes(num_cases, cases): Calculate the volumes of a square pyramid and a triangular prism for given test cases. >>> calculate_volumes(2, [\\"1.00 3.00 2.00 3.00 4.00\\", \\"2.50 4.50 3.60 2.00 5.00\\"]) [\\"1.000000 24.000000\\", \\"9.375000 36.000000\\"] >>> calculate_volumes(1, [\\"3.00 6.00 1.00 2.00 3.00\\"]) [\\"18.000000 6.000000\\"]","solution":"def calculate_volumes(num_cases, cases): results = [] for case in cases: # Parse input values a1, h1, A2, h2, l2 = map(float, case.split()) # Calculate the volume of the square pyramid volume_pyramid = (1/3) * (a1 ** 2) * h1 # Calculate the volume of the triangular prism volume_prism = A2 * h2 * l2 # Append the result formatted to 6 decimal places results.append(f\\"{volume_pyramid:.6f} {volume_prism:.6f}\\") return results"},{"question":"from typing import List def count_islands(matrix: List[List[int]]) -> int: Returns the number of distinct islands in the given matrix. An island is defined as a group of 1's (land) connected 4-directionally (horizontal or vertical). Example: >>> count_islands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 1, 1]] ... ) 2 >>> count_islands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0]] ... ) 0 >>> count_islands([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]] ... ) 1 >>> count_islands([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]] ... ) 1 >>> count_islands([ ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0]] ... ) 4","solution":"def count_islands(matrix): Returns the number of distinct islands in the given matrix. An island is defined as a group of 1's (land) connected 4-directionally (horizontal or vertical). if not matrix: return 0 rows = len(matrix) cols = len(matrix[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): stack = [(r, c)] while stack: x, y = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] == 1 and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) num_islands = 0 for r in range(rows): for c in range(cols): if matrix[r][c] == 1 and not visited[r][c]: num_islands += 1 visited[r][c] = True dfs(r, c) return num_islands"},{"question":"def largest_rectangle_area(heights): This function takes a list of building heights and computes the largest rectangular area that can be formed. >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 2, 0, 3]) 6 pass def process_test_cases(T, test_cases): This function processes multiple test cases and returns a list of results for each. >>> T = 2 >>> test_cases = [ ... [7, [6, 2, 5, 4, 5, 1, 6]], ... [5, [2, 4, 2, 0, 3]] ... ] >>> process_test_cases(T, test_cases) [12, 6] >>> T = 1 >>> test_cases = [ ... [6, [2, 1, 5, 6, 2, 3]] ... ] >>> process_test_cases(T, test_cases) [10] pass","solution":"def largest_rectangle_area(heights): This function takes a list of building heights and computes the largest rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] results.append(largest_rectangle_area(heights)) return results"},{"question":"def longest_winning_streak(outcomes): Determines the length of the longest winning streak. Parameters: outcomes (list): A list of game outcomes, with 'W' for a win and 'L' for a loss. Returns: int: The length of the longest winning streak. Examples: >>> longest_winning_streak(['W', 'L', 'W', 'W', 'L', 'W', 'W', 'W', 'L']) 3 >>> longest_winning_streak(['L', 'L', 'L', 'L']) 0 >>> longest_winning_streak(['W', 'W', 'W', 'W', 'W', 'W']) 6 >>> longest_winning_streak(['L', 'W', 'L', 'W', 'W', 'L', 'L', 'W', 'W', 'W']) 3 from solution import longest_winning_streak def test_no_wins(): assert longest_winning_streak(['L', 'L', 'L', 'L']) == 0 def test_all_wins(): assert longest_winning_streak(['W', 'W', 'W', 'W', 'W', 'W']) == 6 def test_mix_wins_and_losses(): assert longest_winning_streak(['W', 'L', 'W', 'W', 'L', 'W', 'W', 'W', 'L']) == 3 def test_ends_with_streak(): assert longest_winning_streak(['L', 'W', 'L', 'W', 'W', 'L', 'L', 'W', 'W', 'W']) == 3 def test_single_game_outcomes(): assert longest_winning_streak(['W']) == 1 assert longest_winning_streak(['L']) == 0 def test_alternating_outcomes(): assert longest_winning_streak(['W', 'L', 'W', 'L', 'W', 'L']) == 1 def test_no_outcomes(): assert longest_winning_streak([]) == 0","solution":"def longest_winning_streak(outcomes): Determines the length of the longest winning streak. Parameters: outcomes (list): A list of game outcomes, with 'W' for a win and 'L' for a loss. Returns: int: The length of the longest winning streak. max_streak = 0 current_streak = 0 for outcome in outcomes: if outcome == 'W': current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 0 return max_streak"},{"question":"from typing import List, Tuple def can_reach_exit(N: int, M: int, K: int, edges: List[Tuple[int, int, int]], start: int, exit: int, busy_passages: List[Tuple[int, int]]) -> str: Determine if there exists a path from the starting room to the exit room avoiding the busy narrow passages. Arguments: N -- the number of rooms in the maze M -- the number of passages in the maze K -- the number of busy narrow passages edges -- list of tuples of the form (U, V, T) where U and V are room numbers and T is the type of passage (1 for wide, 2 for narrow) start -- the starting room number exit -- the target exit room number busy_passages -- list of tuples of the form (A, B) indicating the busy narrow passages Returns: \\"YES\\" if there's a path from start to exit avoiding the busy narrow passages, \\"NO\\" otherwise. Example: >>> can_reach_exit(6, 7, 2, [(1, 2, 1), (2, 3, 2), (3, 4, 2), (4, 5, 1), (5, 6, 1), (1, 6, 2), (2, 5, 2)], ... 1, 6, [(2, 3), (4, 5)]) \\"YES\\" >>> can_reach_exit(3, 0, 0, [], 1, 3, []) \\"NO\\" >>> can_reach_exit(2, 1, 0, [(1, 2, 1)], 1, 2, []) \\"YES\\" >>> can_reach_exit(2, 1, 0, [(1, 2, 2)], 1, 2, []) \\"YES\\" >>> can_reach_exit(2, 1, 1, [(1, 2, 2)], 1, 2, [(1, 2)]) \\"NO\\" >>> can_reach_exit(4, 3, 0, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], 1, 4, []) \\"YES\\" >>> can_reach_exit(4, 3, 0, [(1, 2, 2), (2, 3, 2), (3, 4, 2)], 1, 4, []) \\"YES\\" >>> can_reach_exit(4, 3, 1, [(1, 2, 2), (2, 3, 2), (3, 4, 2)], 1, 4, [(2, 3)]) \\"NO\\" >>> can_reach_exit(5, 5, 1, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 2), (2, 5, 2)], 1, 5, [(2, 3)]) \\"YES\\" # Implementation here","solution":"def can_reach_exit(N, M, K, edges, start, exit, busy_passages): import collections # Create graph adjancency list & track narrow passage dict to check busy status graph = collections.defaultdict(list) narrow_passages = set((min(a, b), max(a, b)) for a, b in busy_passages) for u, v, t in edges: if t == 1: # wide passage graph[u].append(v) graph[v].append(u) elif t == 2: # narrow passage if (min(u,v), max(u,v)) not in narrow_passages: graph[u].append(v) graph[v].append(u) # Perform BFS from start to find if there's a path to exit queue = collections.deque([start]) visited = set([start]) while queue: node = queue.popleft() if node == exit: return \\"YES\\" for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return \\"NO\\""},{"question":"def longestPalindromicSubsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string s. >>> longestPalindromicSubsequence(\\"bbbab\\") == 4 >>> longestPalindromicSubsequence(\\"cbbd\\") == 2 >>> longestPalindromicSubsequence(\\"aabcdcb\\") == 5 def test_longest_palindromic_subsequence_example1(): assert longestPalindromicSubsequence(\\"bbbab\\") == 4 def test_longest_palindromic_subsequence_example2(): assert longestPalindromicSubsequence(\\"cbbd\\") == 2 def test_longest_palindromic_subsequence_example3(): assert longestPalindromicSubsequence(\\"aabcdcb\\") == 5 def test_longest_palindromic_subsequence_single_char(): assert longestPalindromicSubsequence(\\"a\\") == 1 def test_longest_palindromic_subsequence_all_different_chars(): assert longestPalindromicSubsequence(\\"abcdef\\") == 1 def test_longest_palindromic_subsequence_longer_palindrome(): assert longestPalindromicSubsequence(\\"bananas\\") == 5 def test_longest_palindromic_subsequence_palindrome_string(): assert longestPalindromicSubsequence(\\"racecar\\") == 7","solution":"def longestPalindromicSubsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string s. n = len(s) # Create a 2D array to store lengths of longest palindromic subsequences. dp = [[0] * n for _ in range(n)] # All sub-strings of length 1 are palindromes of length 1. for i in range(n): dp[i][i] = 1 # Build the table. for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"def longest_uppercase_substring(s): Takes a string composed of uppercase letters and non-alphabet characters and returns the longest substring that contains only uppercase alphabet characters. If the input is not valid, returns \\"Not valid\\". Example usage: >>> longest_uppercase_substring(\\"HelloWORLD%\\") 'WORLD' >>> longest_uppercase_substring(\\"123ABCxyz!UVW78\\") 'ABC' >>> longest_uppercase_substring(\\"123xyz!78\\") 'Not valid' >>> longest_uppercase_substring(\\"\\") 'Not valid'","solution":"def longest_uppercase_substring(s): Takes a string composed of uppercase letters and non-alphabet characters and returns the longest substring that contains only uppercase alphabet characters. If the input is not valid, returns \\"Not valid\\". if not isinstance(s, str) or not s: return \\"Not valid\\" max_substring = \\"\\" current_substring = \\"\\" for char in s: if 'A' <= char <= 'Z': current_substring += char if len(current_substring) > len(max_substring): max_substring = current_substring else: current_substring = \\"\\" return max_substring if max_substring else \\"Not valid\\""},{"question":"def find_two_sum_indices(n: int, array: List[int], target: int) -> Union[Tuple[int, int], int]: Given an array of integers and a target integer, determine if there are two distinct elements in the array that add up to the target. If so, return the indices of those elements. If so, return the indices of those elements. If there are multiple pairs, return any one of them. If no such pair exists, return -1. Args: n (int): Number of elements in the array. array (List[int]): List of integers representing the array. target (int): The target sum. Returns: Union[Tuple[int, int], int]: Tuple of the two indices (1-based) or -1 if no such pair exists. Examples: >>> find_two_sum_indices(4, [2, 7, 11, 15], 9) (1, 2) >>> find_two_sum_indices(5, [1, 2, 3, 4, 5], 10) -1","solution":"def find_two_sum_indices(n, array, target): Finds two distinct indices in the array such that the elements at those indices add up to the target. Args: n (int): Number of elements in the array. array (list of int): List of integers representing the array. target (int): The target sum. Returns: tuple of int or int: Tuple of the two indices (1-based) or -1 if no such pair exists. value_to_index = {} for index, value in enumerate(array): complement = target - value if complement in value_to_index: return value_to_index[complement] + 1, index + 1 value_to_index[value] = index return -1"},{"question":"def findSubsets(nums: list[int]) -> list[list[int]]: Returns all possible subsets of a list of integers. The subsets should be sorted in ascending order and the order of output subsets should be based on the ascending order of their elements. >>> findSubsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> findSubsets([4, 5, 6]) [[], [4], [4, 5], [4, 5, 6], [4, 6], [5], [5, 6], [6]] from solution import findSubsets def test_findSubsets_example_1(): assert findSubsets([1, 2, 3]) == [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] def test_findSubsets_example_2(): assert findSubsets([4, 5, 6]) == [[], [4], [4, 5], [4, 5, 6], [4, 6], [5], [5, 6], [6]] def test_findSubsets_empty(): assert findSubsets([]) == [[]] def test_findSubsets_single_element(): assert findSubsets([1]) == [[], [1]] def test_findSubsets_two_elements(): assert findSubsets([2, 1]) == [[], [1], [1, 2], [2]] def test_findSubsets_with_negative_numbers(): assert findSubsets([-1, 0, 1]) == [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]]","solution":"def findSubsets(nums): Returns all possible subsets of nums sorted in ascending order of elements. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() result = [] backtrack(0, []) return result"},{"question":"def balloons_after_wind(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]: Calculate the final number of balloons each child has after the wind bursts some of them. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): List of tuples for each test case containing: - Number of children. - List of integers representing the initial number of balloons each child had. - List of integers representing the number of burst balloons for each child. Returns: List[List[int]]: List containing final number of balloons each child has left for each test case. pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int], List[int]]]]: Parse the input string into number of test cases and test case details. Args: input_str (str): Input string containing test case details. Returns: Tuple[int, List[Tuple[int, List[int], List[int]]]]: Parsed number of test cases and test case details. pass def format_output(result: List[List[int]]) -> str: Format the result into an output string. Args: result (List[List[int]]): List containing final number of balloons each child has left for each test case. Returns: str: Formatted output string with results for each test case. pass def test_example_1(): input_str = '2n3n5 3 7n2 1 6n4n10 15 8 9n5 6 1 0' T, test_cases = parse_input(input_str) result = balloons_after_wind(T, test_cases) output_str = format_output(result) expected_output = '3 2 1n5 9 7 9' assert output_str == expected_output def test_single_child(): input_str = '1n1n7n3' T, test_cases = parse_input(input_str) result = balloons_after_wind(T, test_cases) output_str = format_output(result) expected_output = '4' assert output_str == expected_output def test_all_balloons_intact(): input_str = '1n3n4 6 8n0 0 0' T, test_cases = parse_input(input_str) result = balloons_after_wind(T, test_cases) output_str = format_output(result) expected_output = '4 6 8' assert output_str == expected_output def test_all_balloons_burst(): input_str = '1n3n4 6 8n4 6 8' T, test_cases = parse_input(input_str) result = balloons_after_wind(T, test_cases) output_str = format_output(result) expected_output = '0 0 0' assert output_str == expected_output def test_large_numbers(): input_str = '1n2n1000000000 999999999n500000000 499999999' T, test_cases = parse_input(input_str) result = balloons_after_wind(T, test_cases) output_str = format_output(result) expected_output = '500000000 500000000' assert output_str == expected_output","solution":"def balloons_after_wind(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] B = test_cases[i][1] B_prime = test_cases[i][2] L = [B[j] - B_prime[j] for j in range(N)] results.append(L) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): N = int(lines[index].strip()) B = list(map(int, lines[index + 1].strip().split())) B_prime = list(map(int, lines[index + 2].strip().split())) test_cases.append((N, B, B_prime)) index += 3 return T, test_cases def format_output(result): output_lines = [] for res in result: output_lines.append(' '.join(map(str, res))) return 'n'.join(output_lines)"},{"question":"def count_exchanges(num_employees: int) -> int: Calculate the number of unique business card exchanges among employees. >>> count_exchanges(0) == 0 >>> count_exchanges(1) == 0 >>> count_exchanges(2) == 1 >>> count_exchanges(3) == 3 >>> count_exchanges(4) == 6 >>> count_exchanges(10) == 45 >>> count_exchanges(100) == 4950 >>> count_exchanges(-5) == 0","solution":"def count_exchanges(num_employees): Calculate the number of unique business card exchanges among employees. The number of unique exchanges of business cards among n employees is given by the combination formula: C(n, 2) = n * (n - 1) / 2 :param num_employees: Number of employees :return: Total number of unique exchanges if num_employees < 2: return 0 # If there are fewer than two employees, no exchanges can occur return num_employees * (num_employees - 1) // 2"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a given N x M matrix 90 degrees clockwise. Args: matrix (list of list of int): The input matrix of size N x M. Returns: list of list of int: The rotated matrix of size M x N. >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a given N x M matrix 90 degrees clockwise. Args: matrix (list of list of int): The input matrix of size N x M. Returns: list of list of int: The rotated matrix of size M x N. n = len(matrix) m = len(matrix[0]) # Create a new matrix with swapped dimensions rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def longest_mountain(arr: List[int]) -> int: Given a list of integers, find the length of the longest \\"mountain\\" subarray. A \\"mountain\\" subarray consists of three or more elements and has the following properties: 1. There exists some index i with 0 < i < len - 1 such that arr[0] < arr[1] < ... < arr[i] 2. and arr[i] > arr[i+1] > ... > arr[len-1]. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0","solution":"def longest_mountain(arr): n = len(arr) if n < 3: return 0 longest = 0 i = 1 while i < n - 1: # Check if arr[i] is a peak if arr[i - 1] < arr[i] > arr[i + 1]: # Find the left bound of the mountain left = i - 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 # Find the right bound of the mountain right = i + 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 # Calculate the length of the mountain current_length = right - left + 1 longest = max(longest, current_length) # Move i to the end of the right bound i = right else: i += 1 return longest"},{"question":"def calculate_average(scores: List[int]) -> int: Returns the average score from the list of scores, rounded to the nearest integer. >>> calculate_average([80, 90, 85, 70]) 81 >>> calculate_average([50, 50, 50, 50]) 50 >>> calculate_average([100, 90, 80, 70]) 85 >>> calculate_average([]) 0 >>> calculate_average([90]) 90 >>> calculate_average([45]) 45 >>> calculate_average([90, 40, 70, 60, 55]) 63 >>> calculate_average([80, 90, 85]) 85 >>> calculate_average([70, 75, 80]) 75","solution":"def calculate_average(scores): Returns the average score from the list of scores, rounded to the nearest integer. if not scores: return 0 # Handling empty list case average = sum(scores) / len(scores) return round(average)"},{"question":"def search(nums, target): Searches for the target value in a rotated sorted array. :param nums: List[int], the rotated sorted array :param target: int, the value to search for :return: int, the index of the target value if found, otherwise -1 Examples: >>> search([4,5,6,7,0,1,2], 0) 4 >>> search([4,5,6,7,0,1,2], 3) -1","solution":"def search(nums, target): Searches for the target value in a rotated sorted array. :param nums: List[int], the rotated sorted array :param target: int, the value to search for :return: int, the index of the target value if found, otherwise -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid if nums[left] <= nums[mid]: # Left part is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def min_cost_segment(N: int, costs: List[int]) -> int: Determines the minimum possible cost Ravi has to pay for fruits from any continuous segment of stalls. Parameters: N (int): Total number of stalls in the market. costs (list of int): List of costs at each stall. Returns: int: The minimum total cost for purchasing fruits from any continuous segment of stalls. >>> min_cost_segment(5, [4, 2, 3, 5, 1]) 1 >>> min_cost_segment(6, [6, 5, 3, 2, 8, 7]) 2 >>> min_cost_segment(1, [3]) 3 >>> min_cost_segment(1, [0]) 0 >>> min_cost_segment(5, [0, 0, 0, 0, 0]) 0 >>> min_cost_segment(3, [1, 2, 3]) 1 >>> min_cost_segment(7, [3, 2, 1, 2, 3, 5, 1]) 1 >>> min_cost_segment(4, [1, 2, -5, 1, 2]) -5 >>> min_cost_segment(5, [0, -1, -3, -4, 0]) -8 >>> min_cost_segment(10, [4, 2, 3, 5, 1, 6, 9, 3, 8, 1]) 1","solution":"def min_cost_segment(N, costs): Determines the minimum possible cost Ravi has to pay for fruits from any continuous segment of stalls. Parameters: N (int): Total number of stalls in the market. costs (list of int): List of costs at each stall. Returns: int: The minimum total cost for purchasing fruits from any continuous segment of stalls. min_cost = float('inf') current_sum = 0 for cost in costs: current_sum += cost if current_sum < min_cost: min_cost = current_sum if current_sum > 0: current_sum = 0 return min_cost"},{"question":"from typing import List def find_unique_element(N: int, A: List[int]) -> int: Given a positive integer N and an array A of size N containing integers where every element appears exactly twice, except for one element which appears exactly once, find and return the element that appears exactly once. >>> find_unique_element(7, [4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_element(9, [7, 9, 1, 8, 7, 9, 8, 6, 6]) 1 >>> find_unique_element(1, [42]) 42 >>> find_unique_element(5, [14, 21, 14, 21, 13]) 13 >>> find_unique_element(3, [1000000000, 999999999, 1000000000]) 999999999","solution":"def find_unique_element(N, A): Return the element that appears exactly once in array A where every other element appears exactly twice. unique_element = 0 for element in A: unique_element ^= element return unique_element"},{"question":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring(\\"abcabcbb\\") == 3 # \\"abc\\" >>> longest_substring(\\"bbbbb\\") == 1 # \\"b\\" >>> longest_substring(\\"pwwkew\\") == 3 # \\"wke\\" >>> longest_substring(\\"\\") == 0","solution":"def longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_set = set() l = 0 longest = 0 for r in range(len(s)): while s[r] in char_set: char_set.remove(s[l]) l += 1 char_set.add(s[r]) longest = max(longest, r - l + 1) return longest"},{"question":"def sort_samples_by_priority(samples_string: str) -> list: Sort the sample identifiers in descending order based on the number of data points. If two samples have the same number of data points, they should be sorted in ascending order based on their identifiers. Args: samples_string (str): A space-separated string of sample identifiers. Returns: list: A list of sorted sample identifiers. Examples: >>> sort_samples_by_priority('sample1_5 sample2_10 sample3_3 sample4_10 sample5_7') ['sample2_10', 'sample4_10', 'sample5_7', 'sample1_5', 'sample3_3'] >>> sort_samples_by_priority('sampleA_2 sampleB_4 sampleC_3 sampleD_4 sampleE_1') ['sampleB_4', 'sampleD_4', 'sampleC_3', 'sampleA_2', 'sampleE_1'] from solution import sort_samples_by_priority def test_sort_samples_normal_case(): assert sort_samples_by_priority('sample1_5 sample2_10 sample3_3 sample4_10 sample5_7') == [ 'sample2_10', 'sample4_10', 'sample5_7', 'sample1_5', 'sample3_3' ] def test_sort_samples_with_single_element(): assert sort_samples_by_priority('sample1_5') == ['sample1_5'] def test_sort_samples_with_duplicate_priorities(): assert sort_samples_by_priority('sampleB_4 sampleA_2 sampleD_4 sampleC_3 sampleE_1') == [ 'sampleB_4', 'sampleD_4', 'sampleC_3', 'sampleA_2', 'sampleE_1' ] def test_sort_samples_with_all_same_priorities(): assert sort_samples_by_priority('sampleA_5 sampleB_5 sampleC_5') == [ 'sampleA_5', 'sampleB_5', 'sampleC_5' ] def test_sort_samples_with_empty_string(): assert sort_samples_by_priority('') == [] def test_sort_samples_with_various_formats(): assert sort_samples_by_priority('sample9_100 sample8_90 sample0_1000 sampleA_50 sampleB_90 sampleC_90 sampleD_50') == [ 'sample0_1000', 'sample9_100', 'sample8_90', 'sampleB_90', 'sampleC_90', 'sampleA_50', 'sampleD_50' ]","solution":"def sort_samples_by_priority(samples_string): # Split the input string into individual samples samples = samples_string.split() # Define key function for sorting def sort_key(sample): # Split the sample identifier to get the number of data points identifier, data_points = sample.rsplit('_', 1) # Convert data points to integer for sorting data_points = int(data_points) # Return a tuple (negative data points, identifier) for sorting return (-data_points, identifier) # Sort samples using the defined key function sorted_samples = sorted(samples, key=sort_key) return sorted_samples"},{"question":"def valid_braces(string: str) -> bool: Determines if the input string of braces is valid. The function returns True if every opening brace has a corresponding closing brace in the correct order, otherwise it returns False. >>> valid_braces(\\"(){}[]\\") True >>> valid_braces(\\"([{}])\\") True >>> valid_braces(\\"(}\\") False >>> valid_braces(\\"[(])\\") False >>> valid_braces(\\"\\") True","solution":"def valid_braces(string): Determines if the input string of braces is valid. :param string: A string containing only characters '()', '{}', '[]' :return: True if the string is valid, False otherwise # Dictionary to map open braces to their corresponding closing braces brace_map = {'(': ')', '{': '}', '[': ']'} # Stack to keep track of open braces stack = [] for char in string: if char in brace_map: # If it's an opening brace stack.append(char) else: # If it's a closing brace if not stack or brace_map[stack.pop()] != char: return False return not stack # Return True if stack is empty (all braces matched)"},{"question":"def max_difference(lst: List[int]) -> int: Returns the maximum difference between any two elements in the list such that the larger element comes after the smaller one. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([7, 9, 5, 6, 3, 2]) 2 >>> max_difference([1, 2, 90, 10, 110]) 109 >>> max_difference([4, 3, 2, 1]) -1 from typing import List def test_example_cases(): assert max_difference([2, 3, 10, 6, 4, 8, 1]) == 8 # 10 - 2 assert max_difference([7, 9, 5, 6, 3, 2]) == 2 # 9 - 7 assert max_difference([1, 2, 90, 10, 110]) == 109 # 110 - 1 assert max_difference([4, 3, 2, 1]) == -1 # No larger element comes after a smaller one def test_more_cases(): assert max_difference([10, 12, 3, 1, 25, 18]) == 24 # 25 - 1 assert max_difference([15, 7, 6, 20, 10]) == 14 # 20 - 6 def test_edge_cases(): assert max_difference([5]) == -1 # Single element assert max_difference([]) == -1 # Empty list assert max_difference([1, 1, 1, 1]) == -1 # All elements are the same assert max_difference([1, 5]) == 4 # Only two elements assert max_difference([5, 1]) == -1 # Only two elements, no larger after smaller def test_large_differences(): assert max_difference([1, 100, 1000, 10, 10000]) == 9999 # 10000 - 1 assert max_difference([1000, 100, 10, 1, 10000]) == 9999 # 10000 - 1","solution":"def max_difference(lst): Returns the maximum difference between any two elements such that the larger element comes after the smaller one in the list. if len(lst) < 2: return -1 min_element = lst[0] max_diff = -1 for i in range(1, len(lst)): if lst[i] > min_element: max_diff = max(max_diff, lst[i] - min_element) min_element = min(min_element, lst[i]) return max_diff"},{"question":"[Completion Task in Python] def evaluateExpression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators '+', '-', '*', '/'. The expression should be evaluated based on the following rules: 1. The operators '*', and '/' have higher precedence than '+' and '-'. 2. The operators of equal precedence are evaluated from left to right. 3. It is guaranteed that the given expression is always valid. 4. Division between two integers should truncate toward zero. >>> evaluateExpression(\\"3+2*2\\") 7 >>> evaluateExpression(\\" 3/2 \\") 1 >>> evaluateExpression(\\" 3+5 / 2 \\") 5","solution":"def evaluateExpression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and the operators '+', '-', '*', '/'. # Remove whitespace from the expression expression = expression.replace(\\" \\", \\"\\") stack = [] num = 0 sign = \\"+\\" i = 0 while i < len(expression): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if sign == \\"+\\": stack.append(num) elif sign == \\"-\\": stack.append(-num) elif sign == \\"*\\": stack.append(stack.pop() * num) elif sign == \\"/\\": stack.append(int(stack.pop() / num)) sign = char num = 0 i += 1 return sum(stack)"},{"question":"def find_largest_divisible_subset(lst: List[int]) -> List[int]: Given a list of integers, identify the largest subset where all pairs (i, j) of integers in the subset satisfy the condition i % j == 0 or j % i == 0. >>> find_largest_divisible_subset([3, 5, 10, 20, 21]) [5, 10, 20] >>> find_largest_divisible_subset([1, 2, 3]) [1, 2]","solution":"def find_largest_divisible_subset(lst): if not lst: return [] lst.sort() dp = [[num] for num in lst] for i in range(len(lst)): for j in range(i): if lst[i] % lst[j] == 0: if len(dp[i]) < len(dp[j]) + 1: dp[i] = dp[j] + [lst[i]] return max(dp, key=len)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse nodes of a linked list \`k\` at a time and return the modified list. Example: >>> # Helper function to convert list to linked list >>> def list_to_linked_list(lst): ... dummy = ListNode(0) ... curr = dummy ... for val in lst: ... curr.next = ListNode(val) ... curr = curr.next ... return dummy.next ... >>> # Helper function to convert linked list to list >>> def linked_list_to_list(node): ... result = [] ... while node: ... result.append(node.val) ... node = node.next ... return result ... >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> k = 2 >>> result = reverseKGroup(head, k) >>> linked_list_to_list(result) [2, 1, 4, 3, 5] >>> head = list_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> k = 3 >>> result = reverseKGroup(head, k) >>> linked_list_to_list(result) [3, 2, 1, 6, 5, 4, 9, 8, 7]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverse_linked_list(start, end): prev, curr = None, start while curr != end: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev count = 0 ptr = head # First, check the list length while ptr: count += 1 ptr = ptr.next dummy = ListNode(0) dummy.next = head prev = dummy while count >= k: curr = prev.next next_prev = curr # Move curr to the end of the k group for _ in range(k): if curr: curr = curr.next # Reverse the k-group reversed_head = reverse_linked_list(prev.next, curr) next_prev.next = curr prev.next = reversed_head prev = next_prev count -= k return dummy.next"},{"question":"def merge_sentences(sentences: List[str]) -> str: Joins a list of sentences into a single paragraph ensuring proper grammar rules. >>> merge_sentences([\\"hello world\\"]) \\"Hello world.\\" >>> merge_sentences([\\"hello world\\", \\"this is a test.\\", \\"have a good day!\\"]) \\"Hello world. This is a test. Have a good day!\\" >>> merge_sentences([\\"Once upon a time\\", \\"there was a princess\\", \\"and she lived happily ever after\\"]) \\"Once upon a time. There was a princess. And she lived happily ever after.\\" >>> merge_sentences([]) \\"\\" >>> merge_sentences([\\"\\", \\" \\", \\"hello\\", \\"world\\"]) \\"Hello. World.\\" >>> merge_sentences([\\"What time is it\\", \\"It's 5 o'clock\\", \\"Really\\"]) \\"What time is it. It's 5 o'clock. Really.\\"","solution":"def merge_sentences(sentences): Joins a list of sentences into a single paragraph ensuring proper grammar rules. if not sentences: return \\"\\" merged_sentences = [] for i, sentence in enumerate(sentences): sentence = sentence.strip() if not sentence: continue if i == 0: sentence = sentence.capitalize() else: sentence = sentence[0].upper() + sentence[1:] if sentence[-1] not in '.!?': sentence += '.' merged_sentences.append(sentence) return ' '.join(merged_sentences)"},{"question":"def count_vowels_and_consonants(input_string: str) -> tuple: Returns the number of vowels and consonants in the given string. The function should be case-insensitive and should not count non-alphabetical characters. Parameters: input_string (str): The string to be analyzed Returns: tuple: A tuple containing two integers: number of vowels and number of consonants. Example: >>> count_vowels_and_consonants(\\"Hello, World!\\") (3, 7) >>> count_vowels_and_consonants(\\"AEIOU\\") (5, 0) >>> count_vowels_and_consonants(\\"bcdfg\\") (0, 5) >>> count_vowels_and_consonants(\\"\\") (0, 0) >>> count_vowels_and_consonants(\\"12345\\") (0, 0) >>> count_vowels_and_consonants(\\"a1, b2.\\") (1, 1) >>> count_vowels_and_consonants(\\"Rhythm\\") (0, 6) >>> count_vowels_and_consonants(\\"HeLLo, WoRLd!\\") (3, 7) >>> count_vowels_and_consonants(\\"abcDEF\\") (2, 4)","solution":"def count_vowels_and_consonants(input_string): Returns the number of vowels and consonants in the given string. Case-insensitive and ignores non-alphabetical characters. Parameters: input_string (str): The string to be analyzed Returns: tuple: A tuple containing two integers: number of vowels and number of consonants. vowels = set(\\"aeiouAEIOU\\") num_vowels = 0 num_consonants = 0 for char in input_string: if char.isalpha(): if char in vowels: num_vowels += 1 else: num_consonants += 1 return (num_vowels, num_consonants)"},{"question":"def max_score(nums: List[int], k: int) -> int: Returns the maximum score Alice can achieve if both players play optimally. >>> max_score([1,2,3,4,5,6,1], 3) 12 >>> max_score([2,2,2], 2) 4 >>> max_score([9,7,7,9,7,7,9], 7) 55 >>> max_score([1,1000,1], 1) 1 >>> max_score([1,2,100,2,1], 2) 3","solution":"def max_score(nums, k): Returns the maximum score Alice can achieve if both players play optimally. n = len(nums) total_score = sum(nums[:k]) max_score = total_score for i in range(1, k + 1): total_score += nums[-i] - nums[k - i] max_score = max(max_score, total_score) return max_score"},{"question":"def longest_subarray_with_sum_zero(arr: List[int]) -> int: Given an array of integers, returns the length of the longest contiguous subarray that has a sum equal to 0. If no such subarray exists, returns -1. >>> longest_subarray_with_sum_zero([1, -1, 3, 2, -2, -3, 4, -4]) 8 >>> longest_subarray_with_sum_zero([1, 2, 3, 4, 5]) -1 >>> longest_subarray_with_sum_zero([0, 0, 0, 0, 0]) 5 >>> longest_subarray_with_sum_zero([3, 4, -7, 1, 2, -6, 3, 1, 1]) 7 >>> longest_subarray_with_sum_zero([0]) 1 >>> longest_subarray_with_sum_zero([5]) -1","solution":"def longest_subarray_with_sum_zero(arr): Returns the length of the longest contiguous subarray with sum equal to 0. If no such subarray exists, returns -1. sum_index_dict = {} max_length = 0 current_sum = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == 0: max_length = i + 1 if current_sum in sum_index_dict: max_length = max(max_length, i - sum_index_dict[current_sum]) else: sum_index_dict[current_sum] = i return max_length if max_length > 0 else -1"},{"question":"from typing import List def coin_change(coins: List[int], amount: int) -> int: Returns the minimum number of coins needed to match the given amount. If it is not possible to match the amount, returns -1. pass def test_coin_change_example1(): coins = [1, 2, 5] amount = 11 assert coin_change(coins, amount) == 3 # 11 = 5 + 5 + 1 def test_coin_change_example2(): coins = [2] amount = 3 assert coin_change(coins, amount) == -1 # Cannot make 3 with only 2s def test_coin_change_zero_amount(): coins = [1, 2, 5] amount = 0 assert coin_change(coins, amount) == 0 # 0 amount requires 0 coins def test_coin_change_single_coin(): coins = [2] amount = 4 assert coin_change(coins, amount) == 2 # 4 = 2 + 2 def test_coin_change_multiple_coins(): coins = [1, 3, 4] amount = 6 assert coin_change(coins, amount) == 2 # 6 = 3 + 3 def test_coin_change_impossible_amount(): coins = [3, 7] amount = 5 assert coin_change(coins, amount) == -1 # Cannot make 5 with 3 and 7","solution":"def coin_change(coins, amount): Returns the minimum number of coins needed to match the given amount. If it is not possible to match the amount, returns -1. # Initialize a list to store the minimum coins needed for each amount from 0 to \`amount\` dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 # Loop through each coin and update the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def widget_counter(widgets: List[Dict[str, int]]) -> List[Dict[str, int]]: Develop a \\"Widget Counter\\" function. The function will take a list of widgets with their respective quantities and return a summary of the total counts for each type of widget. >>> widget_counter([ ... {\\"name\\": \\"widgetA\\", \\"quantity\\": 2}, ... {\\"name\\": \\"widgetB\\", \\"quantity\\": 4}, ... {\\"name\\": \\"widgetA\\", \\"quantity\\": 3} ... ]) [{\\"name\\": \\"widgetA\\", \\"quantity\\": 5}, {\\"name\\": \\"widgetB\\", \\"quantity\\": 4}] >>> widget_counter([]) [] >>> widget_counter([{\\"name\\": \\"widgetA\\", \\"quantity\\": 1}]) [{\\"name\\": \\"widgetA\\", \\"quantity\\": 1}] >>> widget_counter([ ... {\\"name\\": \\"widgetA\\", \\"quantity\\": 1}, ... {\\"name\\": \\"widgetB\\", \\"quantity\\": 1}, ... {\\"name\\": \\"widgetC\\", \\"quantity\\": 1} ... ]) [{\\"name\\": \\"widgetA\\", \\"quantity\\": 1}, {\\"name\\": \\"widgetB\\", \\"quantity\\": 1}, {\\"name\\": \\"widgetC\\", \\"quantity\\": 1}] >>> widget_counter([ ... {\\"name\\": \\"widgetA\\", \\"quantity\\": 1000000}, ... {\\"name\\": \\"widgetA\\", \\"quantity\\": 2000000} ... ]) [{\\"name\\": \\"widgetA\\", \\"quantity\\": 3000000}]","solution":"def widget_counter(widgets): widget_summary = {} for widget in widgets: name = widget['name'] quantity = widget['quantity'] if name in widget_summary: widget_summary[name] += quantity else: widget_summary[name] = quantity return [{\\"name\\": name, \\"quantity\\": quantity} for name, quantity in widget_summary.items()]"},{"question":"def first_greater_than_previous(nums: list[int]) -> int: Returns the index of the first element that is greater than all previous elements in the list. If no such element exists, return -1. Examples: >>> first_greater_than_previous([1, 3, 2, 4, 5]) 1 >>> first_greater_than_previous([10, 5, 2, 2, 1]) -1 >>> first_greater_than_previous([3, 1, 4, 1, 5, 9]) 2 >>> first_greater_than_previous([]) -1 >>> first_greater_than_previous([10]) -1 >>> first_greater_than_previous([5, 5, 5, 5, 5]) -1 >>> first_greater_than_previous([9, 8, 7, 6, 5]) -1 >>> first_greater_than_previous([1, 2, 3, 4, 5]) 1 # Your code here","solution":"def first_greater_than_previous(nums): Returns the index of the first element that is greater than all previous elements in the list. If no such element exists, return -1. if not nums: return -1 max_so_far = nums[0] for i in range(1, len(nums)): if nums[i] > max_so_far: return i max_so_far = max(max_so_far, nums[i]) return -1"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. total_sum = sum(nums) # If total sum is odd, it can't be partitioned into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # DP approach to check if a subset with sum target_sum exists dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum]"},{"question":"def min_flips_to_heads(coins: List[int]) -> int: Return the minimum number of series of consecutive coins flips required to make all coins show heads (1). >>> min_flips_to_heads([1, 0, 1, 1, 0]) 2 >>> min_flips_to_heads([0, 0, 0]) 1 >>> min_flips_to_heads([1, 1, 1]) 0 >>> min_flips_to_heads([1, 0, 1, 0, 1, 0]) 3","solution":"def min_flips_to_heads(coins): Return the minimum number of series of consecutive coins flips required to make all coins show heads (1). n = len(coins) # If n is 0, no flips are needed if n == 0: return 0 # Initialize the number of flips flips = 0 # Iterate through the coins for i in range(n): # If we find a '0' (tail) and it is the start of a series of tails, # we need one flip to turn all the following tails in this series to heads if coins[i] == 0 and (i == 0 or coins[i - 1] == 1): flips += 1 return flips"},{"question":"def correct_message(message: str, n: int, corrections: List[Tuple[str, str]]) -> str: Correct the given message based on the provided list of corrections. Parameters: - message (str): The original message containing potential misspellings. - n (int): The number of misspelled words and their corrections. - corrections (list of tuples): Each tuple contains a misspelled word and its correction. Returns: - str: The corrected message. >>> correct_message(\\"beautiful bwetaflu\\", 1, [(\\"bwetaflu\\", \\"beautiful\\")]) == \\"beautiful beautiful\\" >>> correct_message(\\"hte mssage is corect\\", 3, [(\\"hte\\", \\"the\\"), (\\"mssage\\", \\"message\\"), (\\"corect\\", \\"correct\\")]) == \\"the message is correct\\" >>> correct_message(\\"this message does not need correction\\", 0, []) == \\"this message does not need correction\\" >>> correct_message(\\"thsi is a tset\\", 1, [(\\"thsi\\", \\"this\\")]) == \\"this is a tset\\" >>> correct_message(\\"hte is ht wron\\", 2, [(\\"hte\\", \\"the\\"), (\\"ht\\", \\"it\\")]) == \\"the is it wron\\"","solution":"def correct_message(message, n, corrections): Correct the given message based on the provided list of corrections. Parameters: - message (str): The original message containing potential misspellings. - n (int): The number of misspelled words and their corrections. - corrections (list of tuples): Each tuple contains a misspelled word and its correction. Returns: - str: The corrected message. corrections_dict = dict(corrections) words = message.split() corrected_words = [corrections_dict.get(word, word) for word in words] return ' '.join(corrected_words) # Sample Input message = \\"beautiful bwetaflu\\" n = 1 corrections = [(\\"bwetaflu\\", \\"beautiful\\")] # Sample Output print(correct_message(message, n, corrections)) # Output: \\"beautiful beautiful\\""},{"question":"def can_form_palindrome(s: str) -> bool: Return True if the string can be rearranged to form a palindrome, and False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True","solution":"from collections import Counter def can_form_palindrome(s): Return True if the string can be rearranged to form a palindrome, and False otherwise. # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # If more than one character has an odd frequency, it cannot be rearranged to a palindrome return odd_count <= 1"},{"question":"def text_editor(operations): Processes a series of text editing operations and returns the results of the substring queries. Args: operations (list of str): List of operations to process. Returns: list of str: Results of the 'substring' queries. >>> text_editor([\\"append a\\", \\"append b\\", \\"append c\\", \\"substring 1 3\\", \\"delete\\", \\"substring 1 2\\"]) ['abc', 'ab']","solution":"def text_editor(operations): Processes a series of text editing operations and returns the results of the substring queries. Args: operations (list of str): List of operations to process. Returns: list of str: Results of the 'substring' queries. current_text = [] results = [] for operation in operations: if operation.startswith('append'): _, char = operation.split() current_text.append(char) elif operation == 'delete': if current_text: current_text.pop() elif operation.startswith('substring'): _, i, j = operation.split() i, j = int(i), int(j) results.append(''.join(current_text[i-1:j])) return results"},{"question":"def customSort(s: str) -> str: Sorts the input string such that lowercase letters come first, then uppercase letters, then digits, and then special characters, maintaining their internal order from the original string. Examples: >>> customSort(\\"aB3cD1\\") \\"acBD31\\" >>> customSort(\\"5aBc@1D\\") \\"acBD51@\\"","solution":"def customSort(s): Sorts the input string such that lowercase letters come first, then uppercase letters, then digits, and then special characters, maintaining their internal order from the original string. lowercase = ''.join([char for char in s if char.islower()]) uppercase = ''.join([char for char in s if char.isupper()]) digits = ''.join([char for char in s if char.isdigit()]) special_chars = ''.join([char for char in s if not char.isalnum()]) return lowercase + uppercase + digits + special_chars"},{"question":"def palindrome_check(s: str) -> bool: Determines whether the string s is a palindrome, ignoring non-alphabetic characters and case. Parameters: s (str): input string Returns: bool: True if s is a palindrome, False otherwise >>> palindrome_check(\\"A man, a plan, a canal, Panama\\") True >>> palindrome_check(\\"race a car\\") False >>> palindrome_check(\\"No lemon, no melon\\") True","solution":"def palindrome_check(s): Determines whether the string s is a palindrome, ignoring non-alphabetic characters and case. Parameters: s (str): input string Returns: bool: True if s is a palindrome, False otherwise filtered_s = ''.join(char.lower() for char in s if char.isalpha()) return filtered_s == filtered_s[::-1]"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a non-negative integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(3) 6 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(20) 2432902008176640000 >>> factorial(30) 265252859812191058636308480000000","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def prime_factors_count(n: int) -> int: Returns the count of prime factors (including their multiplicities) of a given integer n. >>> prime_factors_count(18) 3 >>> prime_factors_count(60) 4 >>> prime_factors_count(29) 1 >>> prime_factors_count(1) 0 >>> prime_factors_count(0) 0 >>> prime_factors_count(-30) 0","solution":"def prime_factors_count(n): Returns the count of prime factors (including their multiplicities) of a given integer n. if n <= 1: return 0 count = 0 factor = 2 while factor * factor <= n: while (n % factor) == 0: count += 1 n //= factor factor += 1 if n > 1: count += 1 return count"},{"question":"def longestPalindrome(strings): Find the longest palindrome in the given list of strings. If there are multiple palindromes with the same length, return the first one that appears. If there are no palindromes, return an empty string. >>> longestPalindrome([\\"racecar\\", \\"Step on no pets\\", \\"banana\\", \\"A man a plan a canal Panama\\", \\"apple\\"]) \\"A man a plan a canal Panama\\" >>> longestPalindrome([\\"apple\\", \\"banana\\"]) \\"\\"","solution":"def longestPalindrome(strings): def is_palindrome(s): s = ''.join(filter(str.isalnum, s)).lower() return s == s[::-1] longest = \\"\\" for s in strings: if is_palindrome(s) and len(''.join(filter(str.isalnum, s))) > len(''.join(filter(str.isalnum, longest))): longest = s return longest"},{"question":"def number_spiral_diagonals(n: int) -> int: Generate a number spiral of size n and find the sum of the numbers on the diagonals. >>> number_spiral_diagonals(1) 1 >>> number_spiral_diagonals(3) 25 >>> number_spiral_diagonals(5) 101 >>> number_spiral_diagonals(7) 261 >>> number_spiral_diagonals(9) 537","solution":"def number_spiral_diagonals(n: int) -> int: if n == 1: return 1 total_sum = 1 current_number = 1 for layer in range(1, (n // 2) + 1): step_size = layer * 2 for i in range(4): current_number += step_size total_sum += current_number return total_sum"},{"question":"from typing import List def first_non_repeating_character(s: str) -> str: Returns the first non-repeating character in the string s. If there is no non-repeating character, returns 'None'. >>> first_non_repeating_character(\\"leetcode\\") == \\"l\\" >>> first_non_repeating_character(\\"loveleetcode\\") == \\"v\\" >>> first_non_repeating_character(\\"aabbcc\\") == \\"None\\" pass def solve(test_cases: List[str]) -> List[str]: Given a list of test cases, returns a list of results for each test case. Each result is the first non-repeating character of the corresponding test case string, or 'None' if there is no non-repeating character. >>> solve([\\"leetcode\\", \\"loveleetcode\\", \\"aabbcc\\"]) == [\\"l\\", \\"v\\", \\"None\\"] >>> solve([\\"abacabad\\", \\"xyz\\", \\"aabbccddeeffg\\"]) == [\\"c\\", \\"x\\", \\"g\\"] >>> solve([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"]) == [\\"a\\", \\"None\\", \\"None\\", \\"None\\"] pass","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string s. If there is no non-repeating character, returns \\"None\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \\"None\\" def solve(test_cases): results = [] for s in test_cases: results.append(first_non_repeating_character(s)) return results"},{"question":"def sum_is_even_or_odd(arr: List[int]) -> str: Determines if the sum of the elements of the array is even or odd. Parameters: arr (list): List of integers. Returns: str: \\"even\\" if the sum is even, \\"odd\\" if the sum is odd. >>> sum_is_even_or_odd([1, 2, 3, 4]) 'even' >>> sum_is_even_or_odd([1, 1, 1]) 'odd' >>> sum_is_even_or_odd([0, -1, -5]) 'even' >>> sum_is_even_or_odd([]) 'even'","solution":"def sum_is_even_or_odd(arr): Determines if the sum of the elements of the array is even or odd. Parameters: arr (list): List of integers. Returns: str: \\"even\\" if the sum is even, \\"odd\\" if the sum is odd. total_sum = sum(arr) if total_sum % 2 == 0: return \\"even\\" else: return \\"odd\\""},{"question":"import re def is_palindrome(s: str) -> bool: Check whether the given string is a palindrome. Ignore case, spaces, and punctuation when evaluating the string. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"level\\") == True >>> is_palindrome(\\"palindrome\\") == False","solution":"import re def is_palindrome(s: str) -> bool: Check whether the given string is a palindrome. Ignore case, spaces, and punctuation when evaluating the string. cleaned_string = re.sub(r'[^A-Za-z0-9]', '', s).lower() return cleaned_string == cleaned_string[::-1]"},{"question":"def find_unique_numbers(numbers: List[int]) -> List[int]: Returns a sorted list of unique numbers from the input list. Args: numbers: A list of integers. Returns: A sorted list of unique integers. pass # Unit tests def test_find_unique_numbers_with_duplicates(): assert find_unique_numbers([3, 1, 2, 3, 4, 1]) == [1, 2, 3, 4] assert find_unique_numbers([7, 8, 5, 5, 3, 7, 9, 2]) == [2, 3, 5, 7, 8, 9] assert find_unique_numbers([10, 20, 20, 10, 30]) == [10, 20, 30] def test_find_unique_numbers_no_duplicates(): assert find_unique_numbers([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_find_unique_numbers_empty_list(): assert find_unique_numbers([]) == [] def test_find_unique_numbers_single_element(): assert find_unique_numbers([1]) == [1] assert find_unique_numbers([100]) == [100] def test_find_unique_numbers_all_identical(): assert find_unique_numbers([1, 1, 1, 1]) == [1] assert find_unique_numbers([5, 5, 5, 5, 5]) == [5]","solution":"def find_unique_numbers(numbers): Returns a sorted list of unique numbers from the input list. Args: numbers: A list of integers. Returns: A sorted list of unique integers. return sorted(set(numbers))"},{"question":"def is_rotated_version(s1: str, s2: str) -> bool: Returns a boolean indicating whether the second string is a rotated version of the first string. A rotated version means that you can take some letters from the beginning of the string and move them to the end without changing the order of the remaining letters. >>> is_rotated_version(\\"abcde\\", \\"deabc\\") True >>> is_rotated_version(\\"abcde\\", \\"cdeab\\") True >>> is_rotated_version(\\"abcde\\", \\"abced\\") False >>> is_rotated_version(\\"abcde\\", \\"abcde\\") True >>> is_rotated_version(\\"abcde\\", \\"edcba\\") False # Test cases def test_is_rotated_version_with_rotation(): assert is_rotated_version(\\"abcde\\", \\"deabc\\") == True assert is_rotated_version(\\"abcde\\", \\"cdeab\\") == True assert is_rotated_version(\\"abcd\\", \\"dabc\\") == True def test_is_rotated_version_without_rotation(): assert is_rotated_version(\\"abcde\\", \\"abced\\") == False assert is_rotated_version(\\"abcde\\", \\"edcba\\") == False assert is_rotated_version(\\"abc\\", \\"acb\\") == False def test_is_rotated_version_same_strings(): assert is_rotated_version(\\"abcde\\", \\"abcde\\") == True assert is_rotated_version(\\"a\\", \\"a\\") == True def test_is_rotated_version_different_lengths(): assert is_rotated_version(\\"abcde\\", \\"abcd\\") == False assert is_rotated_version(\\"abc\\", \\"ab\\") == False","solution":"def is_rotated_version(s1, s2): Returns True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False concatenated = s1 + s1 return s2 in concatenated"},{"question":"def distribute_time(tasks: int, total_time: int) -> list: Distributes the total_time as evenly as possible across the given number of tasks in order to minimize the maximum difference between time spent on any two tasks. >>> distribute_time(3, 10) [3, 3, 4] >>> distribute_time(5, 15) [3, 3, 3, 3, 3] >>> distribute_time(4, 11) [2, 3, 3, 3] pass def test_distribute_time_exact_division(): assert distribute_time(5, 10) == [2, 2, 2, 2, 2] def test_distribute_time_one_extra_unit(): assert distribute_time(3, 10) == [4, 3, 3] or distribute_time(3, 10) == [3, 4, 3] or distribute_time(3, 10) == [3, 3, 4] def test_distribute_time_no_remainder(): assert distribute_time(4, 8) == [2, 2, 2, 2] def test_distribute_time_with_remainder(): assert distribute_time(4, 11) == [3, 3, 3, 2] or distribute_time(4, 11) == [2, 3, 3, 3] or distribute_time(4, 11) == [3, 2, 3, 3] or distribute_time(4, 11) == [3, 3, 2, 3] def test_distribute_time_large_tasks(): assert distribute_time(1, 1000000000) == [1000000000] def test_distribute_time_small_tasks_large_total_time(): assert distribute_time(2, 1000000000) == [500000000, 500000000] assert distribute_time(2, 1000000001) == [500000001, 500000000] or distribute_time(2, 1000000001) == [500000000, 500000001]","solution":"def distribute_time(tasks: int, total_time: int) -> list: Distributes the total_time as evenly as possible across the given number of tasks in order to minimize the maximum difference between time spent on any two tasks. base_time = total_time // tasks extra_time = total_time % tasks # create a list with base_time for each task distribution = [base_time] * tasks # distribute the extra_time among the first 'extra_time' tasks for i in range(extra_time): distribution[i] += 1 return distribution"},{"question":"def min_swaps_to_convert(A: str, B: str) -> int: Determine the minimum number of operations required to convert A to B. >>> min_swaps_to_convert(\\"abcde\\", \\"edcba\\") 2 >>> min_swaps_to_convert(\\"aabb\\", \\"bbaa\\") 2 >>> min_swaps_to_convert(\\"abc\\", \\"def\\") -1 >>> min_swaps_to_convert(\\"abcd\\", \\"abcd\\") 0 >>> min_swaps_to_convert(\\"abab\\", \\"baba\\") 2 pass def solve(test_cases: List[Tuple[int, str, str]]) -> List[int]: Given multiple test cases, determine the minimum number of operations for each case. >>> solve([(5, \\"abcde\\", \\"edcba\\"), (4, \\"aabb\\", \\"bbaa\\"), (3, \\"abc\\", \\"def\\")]) [2, 2, -1] >>> solve([(4, \\"abcd\\", \\"abcd\\"), (4, \\"abab\\", \\"baba\\")]) [0, 2] pass","solution":"def min_swaps_to_convert(A, B): if sorted(A) != sorted(B): return -1 mismatched_indices = [] for i in range(len(A)): if A[i] != B[i]: mismatched_indices.append(i) mismatched_pairs = [] for i in mismatched_indices: for j in mismatched_indices: if i != j and A[j] == B[i] and A[i] == B[j]: mismatched_pairs.append((i, j)) mismatched_indices.remove(i) mismatched_indices.remove(j) break return len(mismatched_pairs) def solve(test_cases): results = [] for N, A, B in test_cases: results.append(min_swaps_to_convert(A, B)) return results"},{"question":"def reverse_words(message): Reverses each word in the input string message. :param message: str, the input message string :return: str, the message with each word reversed or an error message for invalid input >>> reverse_words(\\"Hello World\\") 'olleH dlroW' >>> reverse_words(\\"Coding is fun\\") 'gnidoC si nuf' >>> reverse_words(123) 'Input is not a string' >>> reverse_words([1, 2, 3]) 'Input is not a string' >>> reverse_words(\\"\\") '' # Your implementation here # Unit tests def test_reverse_words_normal_case(): assert reverse_words(\\"Hello World\\") == \\"olleH dlroW\\" assert reverse_words(\\"Coding is fun\\") == \\"gnidoC si nuf\\" def test_reverse_words_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_reverse_words_non_string_input(): assert reverse_words(123) == \\"Input is not a string\\" assert reverse_words([1, 2, 3]) == \\"Input is not a string\\" assert reverse_words({}) == \\"Input is not a string\\" def test_reverse_words_single_word(): assert reverse_words(\\"Python\\") == \\"nohtyP\\" def test_reverse_words_spacing_issues(): assert reverse_words(\\" Hello World \\") == \\" olleH dlroW \\"","solution":"def reverse_words(message): Reverses each word in the input string message. :param message: str, the input message string :return: str, the message with each word reversed or an error message for invalid input if not isinstance(message, str): return \\"Input is not a string\\" if message == \\"\\": return \\"\\" # Split the message into words words = message.split(\\" \\") # Reverse each word manually reversed_words = [] for word in words: reversed_word = \\"\\" for char in word: reversed_word = char + reversed_word reversed_words.append(reversed_word) # Join the reversed words back into a single string return \\" \\".join(reversed_words)"},{"question":"from typing import List, Tuple def partition_and_find_min_max_sum(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Partition the array into k contiguous subarrays such that the maximum sum of any subarray is minimized. >>> T = 2 >>> test_cases = [((7, 3), [7, 2, 5, 10, 8]), ((5, 2), [1, 2, 3, 4, 5])] >>> partition_and_find_min_max_sum(T, test_cases) == [14, 9] results = [] for i in range(T): N, k = test_cases[i][0] A = test_cases[i][1] # You need to write the necessary code to find the minimum possible value # of the maximum sum of the subarrays after partitioning. return results def test_single_case(): T = 1 test_cases = [ [(7, 3), [7, 2, 5, 10, 8]], ] assert partition_and_find_min_max_sum(T, test_cases) == [14] def test_multiple_cases(): T = 2 test_cases = [ [(7, 3), [7, 2, 5, 10, 8]], [(5, 2), [1, 2, 3, 4, 5]], ] assert partition_and_find_min_max_sum(T, test_cases) == [14, 9] def test_single_element(): T = 1 test_cases = [ [(1, 1), [5]], ] assert partition_and_find_min_max_sum(T, test_cases) == [5] def test_all_elements_equal(): T = 1 test_cases = [ [(4, 2), [2, 2, 2, 2]], ] assert partition_and_find_min_max_sum(T, test_cases) == [4] def test_k_equals_n(): T = 1 test_cases = [ [(4, 4), [1, 1, 1, 1]], ] assert partition_and_find_min_max_sum(T, test_cases) == [1]","solution":"def can_partition(nums, max_sum, k): subarray_sum, subarray_count = 0, 1 for num in nums: if subarray_sum + num > max_sum: subarray_sum = num subarray_count += 1 if subarray_count > k: return False else: subarray_sum += num return True def min_max_subarray_sum(nums, k): left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(nums, mid, k): right = mid else: left = mid + 1 return left def partition_and_find_min_max_sum(T, test_cases): results = [] for i in range(T): N, k = test_cases[i][0] A = test_cases[i][1] results.append(min_max_subarray_sum(A, k)) return results"},{"question":"from collections import OrderedDict class LRUCache: Design a class \`LRUCache\` (Least Recently Used) that supports two operations: 1. get(int key) -> int: Returns the value of the key if the key exists in the cache, otherwise returns -1. 2. put(int key, int value) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. Implement the LRUCache class: - LRUCache(int capacity): Initialize the LRUCache with positive size capacity. - int get(int key): Returns the value of the key if the key exists, otherwise returns -1. - void put(int key, int value): Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. Example: >>> lruCache = LRUCache(2) >>> lruCache.put(1, 1) >>> lruCache.get(1) 1 >>> lruCache.put(3, 3) >>> lruCache.get(1) -1 def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass def test_lru_cache(): lruCache = LRUCache(2) lruCache.put(1, 1) assert lruCache.get(1) == 1 lruCache.put(2, 2) assert lruCache.get(2) == 2 lruCache.put(3, 3) assert lruCache.get(1) == -1 assert lruCache.get(3) == 3 def test_lru_cache_single_item_capacity(): lruCache = LRUCache(1) lruCache.put(2, 2) assert lruCache.get(2) == 2 lruCache.put(3, 3) assert lruCache.get(2) == -1 assert lruCache.get(3) == 3 def test_lru_cache_update_item(): lruCache = LRUCache(2) lruCache.put(1, 1) assert lruCache.get(1) == 1 lruCache.put(1, 10) assert lruCache.get(1) == 10 lruCache.put(2, 2) assert lruCache.get(2) == 2 assert lruCache.get(1) == 10","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) # Make this key most recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove least recently used element"},{"question":"def triangle_type(a, b, c): Determine the type of triangle based on the lengths of its sides. >>> triangle_type(3, 3, 3) 'Equilateral' >>> triangle_type(3, 3, 2) 'Isosceles' >>> triangle_type(3, 4, 5) 'Scalene' >>> triangle_type(1, 2, 3) 'Not a triangle'","solution":"def triangle_type(a, b, c): Determines the type of triangle based on the lengths of its sides. # Check if the sides can form a triangle if a + b <= c or a + c <= b or b + c <= a: return \\"Not a triangle\\" if a == b == c: return \\"Equilateral\\" elif a == b or b == c or a == c: return \\"Isosceles\\" else: return \\"Scalene\\""},{"question":"from typing import List class SlidingWindowMax: def __init__(self, nums: List[int], k: int): Initializes the object with the integer array \`nums\` and the sliding window size \`k\`. def maxSlidingWindow(self) -> List[int]: Returns an array representing the maximum values in each sliding window of size \`k\`. >>> swm = SlidingWindowMax([1,3,-1,-3,5,3,6,7], 3) >>> swm.maxSlidingWindow() [3, 3, 5, 5, 6, 7] >>> swm = SlidingWindowMax([1,2,3,4,5], 1) >>> swm.maxSlidingWindow() [1,2,3,4,5] from collections import deque def test_max_sliding_window_example1(): swm = SlidingWindowMax([1,3,-1,-3,5,3,6,7], 3) assert swm.maxSlidingWindow() == [3,3,5,5,6,7] def test_max_sliding_window_size_1(): swm = SlidingWindowMax([1,2,3,4,5], 1) assert swm.maxSlidingWindow() == [1,2,3,4,5] def test_max_sliding_window_entire_array(): swm = SlidingWindowMax([1,3,1,2], 4) assert swm.maxSlidingWindow() == [3] def test_max_sliding_window_with_negative_numbers(): swm = SlidingWindowMax([-1,-3,-1,-3,-5,-3,-6,-7], 3) assert swm.maxSlidingWindow() == [-1,-1,-1,-3,-3,-3] def test_max_sliding_window_all_identical_elements(): swm = SlidingWindowMax([5,5,5,5,5], 3) assert swm.maxSlidingWindow() == [5,5,5]","solution":"from collections import deque class SlidingWindowMax: def __init__(self, nums, k): self.nums = nums self.k = k def maxSlidingWindow(self): deq = deque() result = [] for i in range(len(self.nums)): # Remove elements not within the sliding window if deq and deq[0] < i - self.k + 1: deq.popleft() # Remove elements smaller than the current element from the deque while deq and self.nums[deq[-1]] < self.nums[i]: deq.pop() deq.append(i) # Collect the maximum element of the current window if i >= self.k - 1: result.append(self.nums[deq[0]]) return result"},{"question":"def min_substrings_to_get_all_chars(n: int, s: str) -> int: Returns the minimum number of non-empty substrings needed to obtain all distinct characters from the string. >>> min_substrings_to_get_all_chars(7, \\"abcbbac\\") 3 >>> min_substrings_to_get_all_chars(5, \\"aaaaa\\") 1","solution":"def min_substrings_to_get_all_chars(n, s): Returns the minimum number of substrings needed to obtain all distinct characters from the string s. distinct_characters = set(s) return len(distinct_characters)"},{"question":"def max_beauty_score(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: For each test case, compute and return the maximum possible beauty score by selecting a contiguous subsequence of gemstones with at least 1 and at most K elements. >>> max_beauty_score(1, [((6, 3), [4, -1, 2, -1, 6, -5])]) [7] >>> max_beauty_score(2, [((6, 3), [4, -1, 2, -1, 6, -5]), ((5, 2), [1, 2, 3, -2, 4])]) [7, 5] >>> max_beauty_score(1, [((1, 1), [10])]) [10] >>> max_beauty_score(1, [((4, 2), [-1, -2, -3, -4])]) [-1] >>> max_beauty_score(1, [((1, 1), [-100000])]) [-100000] >>> max_beauty_score(1, [((5, 3), [-1, 100, 200, -200, 50])]) [300] >>> max_beauty_score(1, [((5, 5), [1, 2, 3, 4, 5])]) [15]","solution":"def max_beauty_score(T, test_cases): For each test case, compute and return the maximum possible beauty score by selecting a contiguous subsequence of gemstones with at least 1 and at most K elements. results = [] for t in range(T): N, K = test_cases[t][0] beauty_scores = test_cases[t][1] max_score = float('-inf') for k in range(1, K + 1): current_sum = sum(beauty_scores[:k]) max_score = max(max_score, current_sum) for i in range(k, N): current_sum = current_sum + beauty_scores[i] - beauty_scores[i - k] max_score = max(max_score, current_sum) results.append(max_score) return results"},{"question":"def count_frequency(input_string: str) -> dict: Returns a dictionary where the keys are the unique characters from the input string and the values are the number of times each character appears in the input string. >>> count_frequency(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> count_frequency(\\"aabCcc\\") {'a': 2, 'b': 1, 'C': 1, 'c': 2} >>> count_frequency(\\"\\") {} >>> count_frequency(\\"aaaaa\\") {'a': 5} >>> count_frequency(\\"!@#!@\\") {'!': 2, '@': 2, '#': 1, '': 1} >>> count_frequency(\\"112233\\") {'1': 2, '2': 2, '3': 2} >>> count_frequency(\\"AaBbCc123\\") {'A': 1, 'a': 1, 'B': 1, 'b': 1, 'C': 1, 'c': 1, '1': 1, '2': 1, '3': 1}","solution":"def count_frequency(input_string): Returns a dictionary where the keys are the unique characters from the input string and the values are the number of times each character appears in the input string. frequency_dict = {} for char in input_string: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"def sort_string(s: str) -> str: Returns a string sorted such that all the digits come before the letters while maintaining the relative order of digits and letters as they appeared in the input string. >>> sort_string('a1b2c3') '123abc' >>> sort_string('1a2bc3') '123abc' >>> sort_string('abc') 'abc' >>> sort_string('123') '123' >>> sort_string('') '' >>> sort_string('123abc') '123abc' >>> sort_string('abc123') '123abc'","solution":"def sort_string(s): Returns a string sorted such that all the digits come before the letters while maintaining the relative order of digits and letters as they appeared in the input string. digits = ''.join([char for char in s if char.isdigit()]) letters = ''.join([char for char in s if char.isalpha()]) return digits + letters"},{"question":"from typing import List, Tuple def min_swaps_to_sort(books: List[int]) -> int: This function takes a list 'books' representing the current order of the books and returns the minimum number of swaps required to sort the books in ascending order of their indices. >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 3, 4, 2]) 2 >>> min_swaps_to_sort([1, 2, 3, 4]) 0 >>> min_swaps_to_sort([2, 1, 4, 3]) 2 >>> min_swaps_to_sort([5, 4, 3, 2, 1]) 2 def min_swaps_from_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function takes a list of test cases and returns a list with the minimum number of swaps for each test case. Each test case is represented as a tuple (N, books), where 'N' is the number of books and 'books' is the list of books. >>> min_swaps_from_cases([ ... (4, [4, 3, 2, 1]), ... (4, [1, 3, 4, 2]) ... ]) [2, 2] >>> min_swaps_from_cases([ ... (5, [5, 4, 3, 2, 1]), ... (3, [3, 1, 2]) ... ]) [2, 2] >>> min_swaps_from_cases([ ... (4, [1, 2, 3, 4]), ... (2, [2, 1]) ... ]) [0, 1] >>> min_swaps_from_cases([(5, [5, 1, 3, 2, 4])]) [3]","solution":"def min_swaps_to_sort(books): This function takes a list 'books' representing the current order of the books and returns the minimum number of swaps required to sort the books in ascending order of their indices. n = len(books) visited = [False] * n swaps = 0 # Pair each book value with its index and sort based on the book value book_positions = sorted([(book, i) for i, book in enumerate(books)]) for i in range(n): if visited[i] or book_positions[i][1] == i: # either already visited or already in the correct position continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = book_positions[x][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps def min_swaps_from_cases(test_cases): This function takes a list of test cases and returns a list with the minimum number of swaps for each test case. Each test case is represented as a tuple (N, books), where 'N' is the number of books and 'books' is the list of books. results = [] for N, books in test_cases: results.append(min_swaps_to_sort(books)) return results"},{"question":"def can_find_sum_subsequence(nums: List[int], queries: List[Tuple[int, int]]) -> List[str]: For a given list of integers and a series of queries, determine if there exists a subsequence such that the sum of its elements falls within the given range [l, r]. >>> can_find_sum_subsequence([1, 2, 3, 4, 5], [(6, 10), (15, 20), (1, 5)]) [\\"Yes\\", \\"Yes\\", \\"Yes\\"] >>> can_find_sum_subsequence([1, 2, 3], [(10, 15), (1, 3)]) [\\"No\\", \\"Yes\\"]","solution":"def can_find_sum_subsequence(nums, queries): total_sum = sum(nums) min_sum = min(nums) results = [] for l, r in queries: if l <= total_sum and r >= min_sum: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"import pytest def generate_parenthesis(n: int) -> List[str]: Generate all balanced parenthesis strings of length 2*n. :param n: Number of pairs of parentheses :type n: int :return: List of balanced parenthesis strings :rtype: List[str] pass def test_generate_parenthesis_n_1(): result = generate_parenthesis(1) expected = [\\"()\\"] assert sorted(result) == sorted(expected) def test_generate_parenthesis_n_2(): result = generate_parenthesis(2) expected = [\\"(())\\", \\"()()\\"] assert sorted(result) == sorted(expected) def test_generate_parenthesis_n_3(): result = generate_parenthesis(3) expected = [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] assert sorted(result) == sorted(expected) def test_generate_parenthesis_n_4(): result = generate_parenthesis(4) expected = [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"] assert sorted(result) == sorted(expected) if __name__ == \\"__main__\\": pytest.main()","solution":"def generate_parenthesis(n): Function to generate all balanced parenthesis strings of length 2*n. :param n: Number of pairs of parentheses :type n: int :return: List of balanced parenthesis strings :rtype: List[str] def backtrack(partial_solution, open_count, close_count): if len(partial_solution) == 2 * n: result.append(partial_solution) return if open_count < n: backtrack(partial_solution + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(partial_solution + \\")\\", open_count, close_count + 1) result = [] backtrack(\\"\\", 0, 0) return result"},{"question":"def isPalindromePermutation(s: str) -> bool: Determines if a given string is a permutation of a palindrome. >>> isPalindromePermutation(\\"Tact Coa\\") True # \\"taco cat\\" / \\"atco cta\\" >>> isPalindromePermutation(\\"Hello\\") False >>> isPalindromePermutation(\\"A man a plan a canal Panama\\") True # \\"amanaplanacanalpanama\\" is a palindrome >>> isPalindromePermutation(\\"racecar\\") True # \\"racecar\\" is already a palindrome >>> isPalindromePermutation(\\"never odd or even\\") True # \\"neveroddoreven\\" is a palindrome >>> isPalindromePermutation(\\"no lemon no melon\\") True # \\"nolemonnomelon\\" is a palindrome >>> isPalindromePermutation(\\"not a palindrome\\") False >>> isPalindromePermutation(\\"\\") True # empty string is considered a valid palindrome >>> isPalindromePermutation(\\"a\\") True # a single character is a palindrome >>> isPalindromePermutation(\\"ab\\") False # \\"ab\\" can't become a palindrome","solution":"def isPalindromePermutation(s: str) -> bool: from collections import Counter # normalize the string: remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # count the frequency of each character char_count = Counter(s) # count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # for the string to be a permutation of a palindrome, it can have at most one character with an odd frequency return odd_count <= 1"},{"question":"def second_largest(nums: List[int]) -> int: Given a list of integers, find the second largest number in the list. If the list contains less than two unique numbers, return None. >>> second_largest([10, 5, 20, 20, 4]) '10' >>> second_largest([3, 3, 3]) 'None' >>> second_largest([8]) 'None' from solution import second_largest def test_second_largest_regular_case(): assert second_largest([10, 5, 20, 20, 4]) == 10 def test_second_largest_all_same(): assert second_largest([3, 3, 3]) == None def test_second_largest_single_element(): assert second_largest([8]) == None def test_second_largest_two_unique_elements(): assert second_largest([1, 2]) == 1 def test_second_largest_negative_numbers(): assert second_largest([-1, -2, -3, -4]) == -2 def test_second_largest_mixed_numbers(): assert second_largest([-1, 0, 1, 2, 3, 3]) == 2 def test_second_largest_large_list(): num_list = list(range(1000)) assert second_largest(num_list) == 998 def test_second_largest_duplicates_of_second_largest(): assert second_largest([10, 10, 10, 9]) == 9","solution":"def second_largest(nums): Finds the second largest unique number in the list. Returns None if the list contains less than two unique numbers. unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def second_highest_price(n: int, prices: List[int]) -> int: Determine the second highest price from a list of integers representing the prices of items. >>> second_highest_price(5, [100, 200, 300, 400, 500]) 400 >>> second_highest_price(6, [100, 200, 200, 300, 400, 400]) 300 >>> second_highest_price(4, [100, 100, 100, 100]) None >>> second_highest_price(2, [200, 100]) 100 >>> second_highest_price(7, [50, 150, 100, 550, 250, 200, 75]) 250 >>> second_highest_price(2, [1000, 500]) 500 >>> second_highest_price(5, [1000, 900, 800, 700, 600]) 900 >>> second_highest_price(3, [300, 200, 100]) 200","solution":"def second_highest_price(n, prices): Returns the second highest price from a list of prices. unique_prices = list(set(prices)) # Remove duplicates unique_prices.sort(reverse=True) # Sort in descending order if len(unique_prices) < 2: return None # If there are less than 2 unique prices return unique_prices[1] # Return the second highest price"},{"question":"def max_happiness(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Returns a list of maximum sums of happiness values that can be achieved by visiting up to K consecutive cities for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - N (int): Number of cities - K (int): Maximum number of consecutive cities that can be visited - H (list of int): List of happiness values of the cities Returns: list: Maximum sums of happiness values for each test case >>> max_happiness(3, [(5, 2, [1, 2, 3, 4, 5]), (4, 3, [10, 20, 30, 40]), (6, 4, [1, 100, 1, 2, 3, 4])]) [9, 90, 106] >>> max_happiness(1, [(1, 1, [10])]) [10] >>> max_happiness(1, [(5, 2, [5, 5, 5, 5, 5])]) [10] >>> max_happiness(1, [(3, 3, [5, 10, 15])]) [30] >>> max_happiness(1, [(4, 2, [1000, 999, 1000, 999])]) [1999] >>> max_happiness(1, [(1, 1, [1])]) [1] >>> max_happiness(1, [(5, 3, [1, 2, 1000, 2, 1])]) [1004] >>> max_happiness(1, [(6, 4, [5, 5, 100, 100, 5, 5])]) [210]","solution":"def max_happiness(T, test_cases): Returns a list of maximum sums of happiness values that can be achieved by visiting up to K consecutive cities for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains: - N (int): Number of cities - K (int): Maximum number of consecutive cities that can be visited - H (list of int): List of happiness values of the cities Returns: list: Maximum sums of happiness values for each test case results = [] for t in range(T): N, K, H = test_cases[t] max_sum = 0 for i in range(N): current_sum = 0 for j in range(i, min(i + K, N)): current_sum += H[j] max_sum = max(max_sum, current_sum) results.append(max_sum) return results"},{"question":"def longest_subarray_sum(nums: List[int], target: int) -> int: Find the length of the longest contiguous subarray that sums up to the given target sum. >>> longest_subarray_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_sum([-2, -1, 2, 1], 1) 2","solution":"def longest_subarray_sum(nums, target): Find the length of the longest contiguous subarray that sums up to the target sum. sum_map = {0: -1} # Dictionary to store the first occurrence of a cumulative sum. max_length = 0 cum_sum = 0 for i in range(len(nums)): cum_sum += nums[i] if (cum_sum - target) in sum_map: max_length = max(max_length, i - sum_map[cum_sum - target]) if cum_sum not in sum_map: sum_map[cum_sum] = i return max_length"},{"question":"from typing import List, Tuple def min_number_of_semesters(n: int, m: int, prerequisites: List[Tuple[int, int]]) -> int: Find the minimum number of semesters required to complete all the courses, or return -1 if it is not possible due to cyclic dependencies. Parameters: n (int): the total number of courses. m (int): the number of prerequisites. prerequisites (List[Tuple[int, int]]): a list of tuples representing the prerequisites. Returns: int: the minimum number of semesters required to complete all the courses, or -1 if unable due to cyclic dependencies. >>> min_number_of_semesters(4, 3, [(1, 2), (2, 3), (3, 4)]) 4 >>> min_number_of_semesters(5, 4, [(1, 2), (1, 3), (2, 4), (3, 4)]) 3 >>> min_number_of_semesters(3, 3, [(1, 2), (2, 3), (3, 1)]) -1 >>> min_number_of_semesters(5, 0, []) 1 >>> min_number_of_semesters(1, 0, []) 1 >>> min_number_of_semesters(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) -1","solution":"from collections import deque, defaultdict def min_number_of_semesters(n, m, prerequisites): # Build the graph graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in prerequisites: graph[a].append(b) in_degree[b] += 1 # Start with all courses that have no prerequisites queue = deque() for course in range(1, n + 1): if in_degree[course] == 0: queue.append(course) semesters = 0 completed_courses = 0 # Topological sort using BFS while queue: semesters += 1 for _ in range(len(queue)): # Process all nodes at the current level (i.e., in the current semester) course = queue.popleft() completed_courses += 1 for next_course in graph[course]: in_degree[next_course] -= 1 if in_degree[next_course] == 0: queue.append(next_course) if completed_courses == n: return semesters else: return -1"},{"question":"def complement_dna(dna_sequence: str) -> str: Returns the complementary DNA sequence for a given DNA sequence. Parameters: dna_sequence (str): A string representing a DNA sequence containing 'A', 'T', 'C', 'G'. Returns: str: A string representing the complementary DNA sequence. >>> complement_dna('ATCG') 'TAGC' >>> complement_dna('GATTACA') 'CTAATGT'","solution":"def complement_dna(dna_sequence): Returns the complementary DNA sequence for a given DNA sequence. Parameters: dna_sequence (str): A string representing a DNA sequence containing 'A', 'T', 'C', 'G'. Returns: str: A string representing the complementary DNA sequence. complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} return ''.join(complement[base] for base in dna_sequence)"},{"question":"def find_words_that_can_be_typed(words: List[str], keyboard: str) -> List[str]: Returns the list of words that can be typed using letters from only one row of the keyboard. :param words: List of words. :param keyboard: String representing the keyboard layout. >>> find_words_that_can_be_typed([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"Alaska\\", \\"Dad\\"] >>> find_words_that_can_be_typed([\\"Hello\\", \\"Dad\\", \\"Peace\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"Dad\\"] >>> find_words_that_can_be_typed([\\"typable\\", \\"row\\", \\"tank\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"row\\"] >>> find_words_that_can_be_typed([\\"no\\", \\"words\\", \\"here\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [] >>> find_words_that_can_be_typed([\\"type\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"type\\"] >>> find_words_that_can_be_typed([], \\"qwertyuiopasdfghjklzxcvbnm\\") [] >>> find_words_that_can_be_typed([\\"qwerty\\", \\"asdf\\", \\"zxcv\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"qwerty\\", \\"asdf\\", \\"zxcv\\"] >>> find_words_that_can_be_typed([\\"Hello\\", \\"DAD\\", \\"Peace\\"], \\"qwertyuiopasdfghjklzxcvbnm\\") [\\"DAD\\"]","solution":"def find_words_that_can_be_typed(words, keyboard): Returns the list of words that can be typed using letters from only one row of the keyboard. :param words: List of words. :param keyboard: String representing the keyboard layout. rows = [ set(keyboard[:10]), # top row: qwertyuiop set(keyboard[10:19]), # middle row: asdfghjkl set(keyboard[19:]) # bottom row: zxcvbnm ] def can_be_typed_in_one_row(word): lower_word = word.lower() for row in rows: if all(ch in row for ch in lower_word): return True return False return [word for word in words if can_be_typed_in_one_row(word)]"},{"question":"def merge_sorted_arrays(array1, array2): Merges two sorted arrays into one sorted array. Parameters: array1 (list): First sorted array. array2 (list): Second sorted array. Returns: list: Merged and sorted array. Examples: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 2, 4], [1, 3, 5, 7, 9]) [0, 1, 2, 3, 4, 5, 7, 9] >>> merge_sorted_arrays([10], [5, 7, 12]) [5, 7, 10, 12] pass","solution":"def merge_sorted_arrays(array1, array2): Merges two sorted arrays into one sorted array. Parameters: array1 (list): First sorted array. array2 (list): Second sorted array. Returns: list: Merged and sorted array. merged_array = [] i = j = 0 while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 # Append remaining elements of array1 if any while i < len(array1): merged_array.append(array1[i]) i += 1 # Append remaining elements of array2 if any while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"from typing import List def num_islands(grid: List[List[str]]) -> int: Determines the number of distinct islands in a given 2D grid. An island is formed by connecting adjacent lands horizontally or vertically. Diagonal adjacency does not count. Args: grid (List[List[str]]): A 2D grid where \\"1\\" represents land and \\"0\\" represents water. Returns: int: The number of distinct islands in the grid. Examples: >>> num_islands([ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ]) 3 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1 >>> num_islands([ ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> num_islands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1","solution":"from typing import List def num_islands(grid: List[List[str]]) -> int: def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == \\"0\\": return grid[i][j] = \\"0\\" # Mark the land as visited by sinking it to water dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) if not grid or not grid[0]: return 0 num_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \\"1\\": num_islands += 1 dfs(grid, i, j) return num_islands"},{"question":"def main_diagonal_character(matrix: List[List[str]]) -> str: Determines if all characters along the main diagonal of the given n x n matrix are the same. If they are, returns the common character, otherwise returns \\"NO\\". :param matrix: A list of lists of characters representing the matrix. :return: The common character or \\"NO\\".","solution":"def main_diagonal_character(matrix): Determines if all characters along the main diagonal of the given n x n matrix are the same. If they are, returns the common character, otherwise returns \\"NO\\". :param matrix: A list of lists of characters representing the matrix. :return: The common character or \\"NO\\". n = len(matrix) diagonal_char = matrix[0][0] for i in range(1, n): if matrix[i][i] != diagonal_char: return \\"NO\\" return diagonal_char"},{"question":"from typing import List def minimum_spanning_tree(graph: List[List[int]]) -> int: Return the total weight of the minimum spanning tree (MST) of a given undirected, weighted graph represented as an adjacency matrix. If the graph is disconnected, return float('inf'). >>> graph = [ ... [0, 2, 0, 6, 0], ... [2, 0, 3, 8, 5], ... [0, 3, 0, 0, 7], ... [6, 8, 0, 0, 9], ... [0, 5, 7, 9, 0] ... ] >>> minimum_spanning_tree(graph) 16 >>> graph = [ ... [0, 4, 3, 0], ... [4, 0, 1, 2], ... [3, 1, 0, 5], ... [0, 2, 5, 0] ... ] >>> minimum_spanning_tree(graph) 6 >>> graph = [ ... [0, 2, 0], ... [2, 0, 0], ... [0, 0, 0] ... ] >>> minimum_spanning_tree(graph) float('inf') >>> graph = [ ... [0, 0], ... [0, 0] ... ] >>> minimum_spanning_tree(graph) float('inf') pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"import heapq def minimum_spanning_tree(graph): Returns the total weight of the minimum spanning tree (MST) of a given undirected, weighted graph using Prim's algorithm. if not graph or not graph[0]: return 0 num_nodes = len(graph) visited = [False] * num_nodes min_heap = [(0, 0)] # (cost, vertex) mst_weight = 0 while min_heap: weight, vertex = heapq.heappop(min_heap) if visited[vertex]: continue visited[vertex] = True mst_weight += weight for adj_vertex, edge_weight in enumerate(graph[vertex]): if edge_weight > 0 and not visited[adj_vertex]: heapq.heappush(min_heap, (edge_weight, adj_vertex)) # Check if all nodes were visited (meaning the graph was connected) if all(visited): return mst_weight else: return float('inf') # Graph is disconnected # Example usage: graph = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0] ] print(minimum_spanning_tree(graph)) # Output: 16"},{"question":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence in the given list of heights. >>> longest_increasing_subsequence([4, 2, 5, 3, 7, 6, 8]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence([3, 4, 1, 2, 3, 1, 5, 2]) 4 >>> longest_increasing_subsequence([10, 20, 10, 30, 20, 50, 40, 60]) 5 >>> longest_increasing_subsequence([2, 2, 2, 2, 2]) 1 # Your code here","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence in the given list of heights. if not heights: return 0 # Initialize the array to store the length of longest subsequence at each position dp = [1] * len(heights) # Calculate the longest increasing subsequence ending at each position for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in the dp array return max(dp)"},{"question":"def find_pairs_with_target_sum(numbers: List[int], target: int) -> List[List[int]]: Finds all unique pairs in the list \`numbers\` that sum up to \`target\`. Parameters: numbers (list of int): List of integers. target (int): The target sum. Returns: list of list of int: List of pairs [A, B] such that A + B = target. >>> find_pairs_with_target_sum([1, 2, 3, 4, 5, 6], 7) [[1, 6], [2, 5], [3, 4]] >>> find_pairs_with_target_sum([1, 2, 3], 10) [] >>> find_pairs_with_target_sum([-1, 0, 1, 2, -2, 3, -3], 0) [[-3, 3], [-2, 2], [-1, 1]] >>> find_pairs_with_target_sum([1, 2, 3, -3, -2, -1], -5) [[-3, -2]] >>> find_pairs_with_target_sum([1], 2) [] >>> find_pairs_with_target_sum([1, 1, 2, 2, 3, 3], 4) [[1, 3]]","solution":"def find_pairs_with_target_sum(numbers, target): Finds all unique pairs in the list \`numbers\` that sum up to \`target\`. Parameters: numbers (list of int): List of integers. target (int): The target sum. Returns: list of list of int: List of pairs [A, B] such that A + B = target. pairs = [] numbers_set = set(numbers) for num in numbers: complement = target - num if complement in numbers_set and complement != num: pair = sorted([num, complement]) if pair not in pairs: pairs.append(pair) return sorted(pairs)"},{"question":"def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2 to 9 inclusive, return all possible letter combinations that the number could represent. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"456\\") [\\"gjm\\", \\"gjn\\", \\"gjo\\", \\"gkm\\", \\"gkn\\", \\"gko\\", \\"glm\\", \\"gln\\", \\"glo\\", \\"hjm\\", \\"hjn\\", \\"hjo\\", \\"hkm\\", \\"hkn\\", \\"hko\\", \\"hlm\\", \\"hln\\", \\"hlo\\", \\"ijm\\", \\"ijn\\", \\"ijo\\", \\"ikm\\", \\"ikn\\", \\"iko\\", \\"ilm\\", \\"iln\\", \\"ilo\\"]","solution":"def letter_combinations(digits): Given a string containing digits from 2 to 9 inclusive, return all possible letter combinations that the number could represent. if not digits: return [] digit_to_letters = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def findPeakElement(arr: List[int]) -> int: Find an index of any peak element in the array. A peak element is an element that is greater than its neighbors. :param arr: List[int] - the input array :return: int - index of any one peak element >>> findPeakElement([1, 2, 3, 1]) 2 >>> findPeakElement([1, 2, 3, 4, 5]) 4 pass","solution":"def findPeakElement(arr): Find an index of any peak element in the array. A peak element is an element that is greater than its neighbors. :param arr: List[int] - the input array :return: int - index of any one peak element n = len(arr) # If the array has only one element, return it as the peak element if n == 1: return 0 # Check for peak at the first element if arr[0] >= arr[1]: return 0 # Check for peak at the last element if arr[n-1] >= arr[n-2]: return n-1 # Check for peak in the middle elements for i in range(1, n-1): if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]: return i"},{"question":"from typing import List def min_subarray_len(arr: List[int], target: int) -> int: Given an array of integers \`arr\` and an integer \`target\`, find the length of the shortest subarray that sums to the target. If no such subarray exists, return -1. A subarray is a contiguous part of an array. The sum of the subarray should exactly equal the target. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 from solution import min_subarray_len def test_example_1(): arr = [2, 3, 1, 2, 4, 3] target = 7 assert min_subarray_len(arr, target) == 2 def test_example_2(): arr = [1, 1, 1, 1, 1, 1, 1, 1] target = 11 assert min_subarray_len(arr, target) == -1 def test_single_element_equal_to_target(): arr = [7] target = 7 assert min_subarray_len(arr, target) == 1 def test_single_element_not_equal_to_target(): arr = [5] target = 7 assert min_subarray_len(arr, target) == -1 def test_all_elements_sum_to_target(): arr = [1, 2, 3, 4] target = 10 assert min_subarray_len(arr, target) == 4 def test_partial_subarray_sum_to_target(): arr = [1, 4, 4] target = 8 assert min_subarray_len(arr, target) == 2 def test_large_array(): arr = [1] * 100000 + [5] target = 5 assert min_subarray_len(arr, target) == 1","solution":"def min_subarray_len(arr, target): Returns the length of the shortest subarray that sums to target. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def nth_prime(n: int) -> int: Returns the nth prime number. >>> nth_prime(1) 2 >>> nth_prime(6) 13 >>> nth_prime(10) 29 >>> nth_prime(100) 541 pass def test_nth_prime_first(): assert nth_prime(1) == 2 def test_nth_prime_sixth(): assert nth_prime(6) == 13 def test_nth_prime_tenth(): assert nth_prime(10) == 29 def test_nth_prime_with_invalid_input(): try: nth_prime(0) except ValueError as e: assert str(e) == \\"n must be a positive integer.\\" else: assert False, \\"Expected ValueError\\" def test_nth_prime_large(): assert nth_prime(100) == 541","solution":"def nth_prime(n): Returns the nth prime number. if n < 1: raise ValueError(\\"n must be a positive integer.\\") primes = [] num = 2 # The first prime number while len(primes) < n: is_prime = all(num % p != 0 for p in primes) if is_prime: primes.append(num) num += 1 return primes[n-1]"},{"question":"def count_words_in_sentences(sentences: List[str]) -> List[int]: Given a list of sentences, returns a list of word counts for each sentence. >>> count_words_in_sentences([\\"Hello World\\"]) [2] >>> count_words_in_sentences([ \\"Hello World\\", \\"Programming is fun\\", \\"Count the number of words\\" ]) [2, 3, 5]","solution":"def count_words_in_sentences(sentences): Given a list of sentences, returns a list of word counts for each sentence. return [len(sentence.split()) for sentence in sentences]"},{"question":"def minimumSwapsToSort(arr): Returns the minimum number of swaps required to sort the array in ascending order. >>> minimumSwapsToSort([4, 3, 1, 2]) 3 >>> minimumSwapsToSort([1, 2, 3, 4, 5]) 0 >>> minimumSwapsToSort([5, 4, 3, 2, 1]) 2 >>> minimumSwapsToSort([2, 3, 4, 1, 5]) 3 >>> minimumSwapsToSort([1]) 0 >>> minimumSwapsToSort([]) 0 >>> minimumSwapsToSort([2, 3, 2, 1, 3]) 2 >>> minimumSwapsToSort([100, 90, 80, 70, 60]) 2","solution":"def minimumSwapsToSort(arr): Returns the minimum number of swaps required to sort the array in ascending order. n = len(arr) arrpos = [*enumerate(arr)] arrpos.sort(key=lambda it: it[1]) visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][0] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def check_row_or_column(grid: List[List[int]]) -> str: Check if there exists a row or column in a given NxN grid such that all elements in that row or column are the same. >>> check_row_or_column([[1, 1, 1], [2, 3, 4], [5, 6, 7]]) \\"Yes\\" >>> check_row_or_column([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) \\"No\\" def main(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[str]: Check each test case to determine if there exists a row or column in the grid with all elements the same. Args: T : int : Number of test cases test_cases : List[Tuple[int, List[List[int]]]] : List of test cases where each test case is a tuple (N, grid) Returns: List[str] : List of results (\\"Yes\\" or \\"No\\") for each test case Example: >>> main(2, [(3, [[1, 1, 1], [2, 3, 4], [5, 6, 7]]), (4, [[2, 2, 2, 2], [3, 4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14]])]) [\\"Yes\\", \\"Yes\\"] from typing import List, Tuple","solution":"def check_row_or_column(grid): n = len(grid) # Check rows for row in grid: if all(val == row[0] for val in row): return \\"Yes\\" # Check columns for col in range(n): if all(grid[row][col] == grid[0][col] for row in range(n)): return \\"Yes\\" return \\"No\\" def main(T, test_cases): results = [] for test_case in test_cases: N, grid = test_case results.append(check_row_or_column(grid)) return results"},{"question":"def create_beautiful_string(n: int, k: int, c: str) -> str: Returns the lexographically smallest string of length n with exactly k occurrences of the character 'c'. >>> create_beautiful_string(5, 2, 'a') 'aabbb' >>> create_beautiful_string(7, 3, 'b') 'bbbaaaa' >>> create_beautiful_string(4, 4, 'c') 'cccc' >>> create_beautiful_string(6, 0, 'd') 'aaaaaa' >>> create_beautiful_string(6, 1, 'e') 'eaaaaa' def process_test_cases(T: int, test_cases: List[Tuple[int, int, str]]) -> List[str]: Processes multiple test cases to generate the required strings. >>> process_test_cases(2, [(5, 2, 'a'), (7, 3, 'b')]) ['aabbb', 'bbbaaaa'] >>> process_test_cases(2, [(4, 4, 'c'), (6, 0, 'd')]) ['cccc', 'aaaaaa']","solution":"def create_beautiful_string(n, k, c): Returns the lexographically smallest string of length n with exactly k occurrences of the character 'c'. other_char = 'a' if c != 'a' else 'b' return c * k + other_char * (n - k) def process_test_cases(T, test_cases): results = [] for case in test_cases: n, k, c = case result = create_beautiful_string(n, k, c) results.append(result) return results"},{"question":"from itertools import product def cartesian_product(A, B): Compute the Cartesian product of lists A and B. Parameters: A (list): List of integers. B (list): List of integers. Returns: list: List of tuples representing the Cartesian product of A and B. >>> cartesian_product([1, 2], [3, 4]) [(1, 3), (1, 4), (2, 3), (2, 4)] >>> cartesian_product([1, 2, 3], [4, 5]) [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)] >>> cartesian_product([1], [1]) [(1, 1)] >>> cartesian_product([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) [(1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (3, 6), (3, 7), (3, 8), (3, 9), (3, 10), (4, 6), (4, 7), (4, 8), (4, 9), (4, 10), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10)] >>> cartesian_product([], []) [] pass","solution":"from itertools import product def cartesian_product(A, B): Compute the Cartesian product of lists A and B. Parameters: A (list): List of integers. B (list): List of integers. Returns: list: List of tuples representing the Cartesian product of A and B. return list(product(A, B))"},{"question":"def highest_product_of_three(arr): Finds the highest product of any three numbers from an input list of integers. >>> highest_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> highest_product_of_three([-10, -10, 1, 3, 2]) 300 >>> highest_product_of_three([1, 2, 3, 4, 5]) 60 >>> highest_product_of_three([-10, -20, -1, -2, -3]) -6 >>> highest_product_of_three([-10, -10, 5, 2, 8]) 800 >>> highest_product_of_three([1, 2, 3]) 6 >>> highest_product_of_three([-1, -2, -3]) -6","solution":"def highest_product_of_three(arr): Returns the highest product of any three numbers in the list arr. if len(arr) < 3: raise ValueError(\\"Input list must contain at least three integers\\") # Initialize variables for tracking the highest and lowest values highest = max(arr[0], arr[1]) lowest = min(arr[0], arr[1]) highest_product_of_2 = arr[0] * arr[1] lowest_product_of_2 = arr[0] * arr[1] # Initial product of the first three values highest_product_of_3 = arr[0] * arr[1] * arr[2] # Iterate through the array starting from the third element for i in range(2, len(arr)): current = arr[i] # Compute new potential highest product of three highest_product_of_3 = max(highest_product_of_3, current * highest_product_of_2, current * lowest_product_of_2) # Update the products of two highest_product_of_2 = max(highest_product_of_2, current * highest, current * lowest) lowest_product_of_2 = min(lowest_product_of_2, current * highest, current * lowest) # Update highest and lowest values highest = max(highest, current) lowest = min(lowest, current) return highest_product_of_3"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. >>> flatten_dict({\\"key\\": \\"value\\"}) == {\\"key\\": \\"value\\"} >>> flatten_dict({\\"key\\": {\\"deeper\\": {\\"more\\": {\\"enough\\": \\"value\\"}}}}) == {\\"key.deeper.more.enough\\": \\"value\\"} >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) == {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3} >>> flatten_dict({}) == {} >>> flatten_dict({\\"a\\": {\\"b\\": \\"c\\"}}) == {\\"a.b\\": \\"c\\"} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": \\"f\\"}}}}}) == {\\"a.b.c.d.e\\": \\"f\\"}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def merge_sorted_arrays(arr1, arr2, arr3): Merge three sorted arrays of distinct integers into a single sorted array without duplicates. >>> merge_sorted_arrays([1, 2, 4], [1, 3, 5], [2, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 1], [3, 4], [5, 6]) [0, 1, 3, 4, 5, 6] >>> merge_sorted_arrays([-5, -3, 0], [0, 2, 7], [-1, 1, 5]) [-5, -3, -1, 0, 1, 2, 5, 7]","solution":"def merge_sorted_arrays(arr1, arr2, arr3): Takes three sorted arrays and merges them into one sorted array without duplicates. merged_set = set(arr1 + arr2 + arr3) merged_list = list(merged_set) merged_list.sort() return merged_list"},{"question":"def organize_books(book_list): Organizes books by genre and height. Parameters: book_list (list): A list of tuples where each tuple contains a genre (string) and a height (integer). Returns: dict: A dictionary where keys are genres and values are lists of sorted heights. >>> organize_books([(\\"fantasy\\", 25), (\\"mystery\\", 30), (\\"fantasy\\", 20), (\\"mystery\\", 25), (\\"sci-fi\\", 28)]) {\\"fantasy\\": [20, 25], \\"mystery\\": [25, 30], \\"sci-fi\\": [28]} >>> organize_books([(\\"romance\\", 22)]) {\\"romance\\": [22]} >>> organize_books([]) {}","solution":"def organize_books(book_list): Organizes books by genre and height. Parameters: book_list (list): A list of tuples where each tuple contains a genre (string) and a height (integer). Returns: dict: A dictionary where keys are genres and values are lists of sorted heights. from collections import defaultdict genre_dict = defaultdict(list) for genre, height in book_list: genre_dict[genre].append(height) for genre in genre_dict: genre_dict[genre].sort() return dict(genre_dict)"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Write a function that takes a list of integers and returns the largest possible integer that can be made by concatenating their string representations together. If the list is empty, return an empty string. >>> largest_number([10, 2]) '210' >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([0, 0]) '0' >>> largest_number([]) ''","solution":"from functools import cmp_to_key def largest_number(nums): if not nums: return \\"\\" def compare(a, b): return (a + b > b + a) - (a + b < b + a) nums = list(map(str, nums)) nums.sort(key=cmp_to_key(compare), reverse=True) result = ''.join(nums) return '0' if result[0] == '0' else result"},{"question":"from typing import List def maxSubArrayLen(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray that sums to k. >>> maxSubArrayLen([1, -1, 5, -2, 3], 3) --> 4 >>> maxSubArrayLen([-2, -1, 2, 1], 1) --> 2 >>> maxSubArrayLen([1, 2, 3], 6) --> 3 >>> maxSubArrayLen([1, 0, -1], -1) --> 2 >>> maxSubArrayLen([1, 2, 3], 7) --> 0 def test_example_cases(): assert maxSubArrayLen([1, -1, 5, -2, 3], 3) == 4 assert maxSubArrayLen([-2, -1, 2, 1], 1) == 2 assert maxSubArrayLen([1, 2, 3], 6) == 3 assert maxSubArrayLen([1, 0, -1], -1) == 2 assert maxSubArrayLen([1, 2, 3], 7) == 0 def test_edge_cases(): assert maxSubArrayLen([3], 3) == 1 assert maxSubArrayLen([3], 0) == 0 assert maxSubArrayLen([-1, -2, -3], -5) == 2 assert maxSubArrayLen([1, 2, 3], 100) == 0 assert maxSubArrayLen([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 100) == 0 def test_long_array(): assert maxSubArrayLen([1] * 100000, 50000) == 50000 assert maxSubArrayLen([1] * 50000 + [-1] * 50000, 0) == 100000 def test_mixed_elements(): assert maxSubArrayLen([1, 4, 20, 3, 10, 5], 33) == 3 assert maxSubArrayLen([10, 2, -2, -20, 10], -10) == 4 assert maxSubArrayLen([-10, 0, 2, -2, -20, 10], 20) == 0 def test_tricky_cases(): assert maxSubArrayLen([], 0) == 0 assert maxSubArrayLen([1, -1], 0) == 2 assert maxSubArrayLen([1, 1, 1, -1, -1, -1, 1], 1) == 7","solution":"from typing import List def maxSubArrayLen(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray that sums to k. cum_sum_to_index = {0: -1} # cumulative sum mapped to index cum_sum = 0 max_len = 0 for i, num in enumerate(nums): cum_sum += num if (cum_sum - k) in cum_sum_to_index: max_len = max(max_len, i - cum_sum_to_index[cum_sum - k]) if cum_sum not in cum_sum_to_index: cum_sum_to_index[cum_sum] = i return max_len"},{"question":"def max_pairs(n1: int, n2: int, p: int) -> int: Returns the maximum number of pairs Alex can form. >>> max_pairs(3, 4, 1) 3 >>> max_pairs(5, 5, 2) 5 >>> max_pairs(7, 8, 3) 7 def process_queries(queries: List[Tuple[int, int, int]]) -> List[int]: Processes a list of queries and returns the results. >>> process_queries([(3, 4, 1), (5, 5, 2), (7, 8, 3)]) [3, 5, 7] >>> process_queries([(10, 15, 4), (1, 1, 1), (100, 200, 100)]) [10, 1, 100]","solution":"def max_pairs(n1, n2, p): Returns the maximum number of pairs Alex can form. return min(n1, n2) def process_queries(queries): results = [] for n1, n2, p in queries: results.append(max_pairs(n1, n2, p)) return results"},{"question":"from typing import List def plant_collection(operations: List[str]) -> List[int]: A botanist is cataloging a collection of plants and wants to store some information in a database. Each plant has a unique ID and belongs to a certain species. The botanist needs to know how many unique species there are in the collection at any given time. >>> plant_collection([\\"ADD 1 rose\\", \\"ADD 2 orchid\\", \\"COUNT\\", \\"ADD 3 orchid\\", \\"REMOVE 1\\", \\"COUNT\\", \\"ADD 4 tulip\\", \\"COUNT\\"]) [2, 1, 2] >>> plant_collection([\\"ADD 1 rose\\", \\"ADD 2 orchid\\", \\"ADD 3 tulip\\", \\"COUNT\\"]) [3] >>> plant_collection([\\"ADD 1 rose\\", \\"REMOVE 1\\", \\"COUNT\\"]) [0] >>> plant_collection([\\"ADD 1 rose\\", \\"ADD 2 rose\\", \\"COUNT\\", \\"REMOVE 1\\", \\"COUNT\\", \\"REMOVE 2\\", \\"COUNT\\"]) [1, 1, 0] >>> plant_collection([\\"ADD 1 rose\\", \\"ADD 2 orchid\\", \\"ADD 3 rose\\", \\"REMOVE 1\\", \\"COUNT\\", \\"REMOVE 3\\", \\"COUNT\\"]) [2, 1]","solution":"def plant_collection(operations): plants = {} species_count = {} result = [] for op in operations: parts = op.split() command = parts[0] if command == \\"ADD\\": id = int(parts[1]) species = parts[2] if id not in plants: plants[id] = species if species in species_count: species_count[species] += 1 else: species_count[species] = 1 elif command == \\"REMOVE\\": id = int(parts[1]) if id in plants: species = plants[id] plants.pop(id) if species_count[species] == 1: del species_count[species] else: species_count[species] -= 1 elif command == \\"COUNT\\": result.append(len(species_count)) return result"},{"question":"def max_square_plots(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Help Farmer John determine how many KxK square plots he can create within an NxM barnyard. Args: T: Integer, the number of test cases. test_cases: List of tuples, each containing three integers N, M and K for each test case. Returns: A list of integers, each representing the maximum number of KxK square plots for each test case. >>> max_square_plots(3, [(6, 6, 2), (15, 20, 5), (8, 9, 3)]) [9, 12, 6] >>> max_square_plots(1, [(5, 5, 6)]) [0] >>> max_square_plots(2, [(10, 10, 2), (12, 15, 3)]) [25, 20] >>> max_square_plots(1, [(1, 1, 1)]) [1] >>> max_square_plots(1, [(1000000, 1000000, 1)]) [1000000000000] >>> max_square_plots(1, [(1, 1, 2)]) [0] >>> max_square_plots(1, [(1000000, 1000000, 1000000)]) [1] >>> max_square_plots(1, [(1000000, 999999, 1000000)]) [0]","solution":"def max_square_plots(T, test_cases): Returns a list of the maximum number of KxK square plots that can fit within the NxM barnyard. results = [] for i in range(T): N, M, K = test_cases[i] if K > N or K > M: results.append(0) else: max_plots = (N // K) * (M // K) results.append(max_plots) return results"},{"question":"from typing import List def four_sum(nums: List[int], target: int) -> List[List[int]]: Find all unique quadruplets in the list which give the sum of the target. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4], 100) [] >>> four_sum([1, 0, -1, 0, -2, 2, 2, -1], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, -1, 0, 2], [-1, 0, 0, 1]] >>> four_sum([5, 5, 5, 5], 10) [] >>> four_sum([1, 1, 1, 1, 1, 1, 1], 4) [[1, 1, 1, 1]]","solution":"def four_sum(nums, target): Returns a list of lists containing all unique quadruplets that sum up to the target. nums.sort() quadruplets = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: summed = nums[i] + nums[j] + nums[left] + nums[right] if summed == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif summed < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def single_number(nums): Returns the element that appears only once in an array where every other element appears thrice. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([-2, -2, -3, -2]) -3 >>> single_number([1, -1, 1, -1, 1, -1, 5]) 5 >>> single_number([3, 3, 3, 7, 7, 7, 4]) 4 >>> single_number([4]) 4","solution":"def single_number(nums): Returns the element that appears only once in an array where every other element appears thrice. ones, twos = 0, 0 for num in nums: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def max_subarray(arr: List[int]) -> int: Write a function called \`max_subarray\` that takes a list of integers as its parameter. The goal is to find the contiguous subarray within the given list which has the largest sum, and return this sum. Examples: >>> max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray([1]) 1 >>> max_subarray([1, 2, 3, 4, 5]) 15 >>> max_subarray([-1, -2, -3, -4, -5]) -1 pass","solution":"def max_subarray(arr): Returns the sum of the contiguous subarray with the largest sum. :param arr: List[int], list of integers :return: int, maximum sum of the contiguous subarray max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def reverse_words_order(sentence: str) -> str: Takes a string as input and reverses the order of words while keeping the order of the characters within each word the same. Parameters: sentence (str): The input string. Returns: str: The transformed string. >>> reverse_words_order(\\"code is fun\\") \\"fun is code\\" >>> reverse_words_order(\\"hello world\\") \\"world hello\\" >>> reverse_words_order(\\"I love programming\\") \\"programming love I\\" >>> reverse_words_order(\\"a b c d\\") \\"d c b a\\" >>> reverse_words_order(\\"one\\") \\"one\\" >>> reverse_words_order(\\"\\") \\"\\" >>> reverse_words_order(\\" code is fun \\") \\"fun is code\\" >>> reverse_words_order(\\" hello world\\") \\"world hello\\" >>> reverse_words_order(\\"a b c\\") \\"c b a\\"","solution":"def reverse_words_order(sentence): Takes a string as input and reverses the order of words while keeping the order of the characters within each word the same. Parameters: sentence (str): The input string. Returns: str: The transformed string. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"from typing import List def extract_usernames(emails: List[str]) -> List[str]: Extract the usernames from a list of email addresses. A valid email address consists of a username (containing only lowercase letters and digits), the @ symbol, and a domain name. >>> extract_usernames(['alice@example.com', 'john123@domain.com', 'a1b2c3@service.net']) ['alice', 'john123', 'a1b2c3'] >>> extract_usernames(['Alice@Example.com', 'john_doe@domain.com', '@noservice.org', 'user@name@domain.com']) [] >>> extract_usernames(['alice@example.com', 'john123@domain.com', 'Alice@Example.com', '@noservice.org', 'user@name@domain.com']) ['alice', 'john123'] >>> extract_usernames([]) [] >>> extract_usernames(['valid1@example.com']) ['valid1'] >>> extract_usernames(['Invalid@Email.com']) []","solution":"import re def extract_usernames(emails): usernames = [] email_regex = re.compile(r'^[a-z0-9]+@[a-zA-Z0-9-.]+.[a-zA-Z]{2,}') for email in emails: if email_regex.match(email): username = email.split('@')[0] usernames.append(username) return usernames"},{"question":"def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent on a traditional T9 telephone keypad. >>> letter_combinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letter_combinations(\\"764\\") [\\"pmg\\", \\"pmh\\", \\"pmi\\", \\"png\\", \\"pnh\\", \\"pni\\", \\"pog\\", \\"poh\\", \\"poi\\", \\"qmg\\", \\"qmh\\", \\"qmi\\", \\"qng\\", \\"qnh\\", \\"qni\\", \\"qog\\", \\"qoh\\", \\"qoi\\", \\"rmg\\", \\"rmh\\", \\"rmi\\", \\"rng\\", \\"rnh\\", \\"rni\\", \\"rog\\", \\"roh\\", \\"roi\\", \\"smg\\", \\"smh\\", \\"smi\\", \\"sng\\", \\"snh\\", \\"sni\\", \\"sog\\", \\"soh\\", \\"soi\\"]","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent on a traditional T9 telephone keypad. if not digits: return [] phone_mapping = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(combination, next_digits): if len(next_digits) == 0: output.append(combination) else: for letter in phone_mapping[next_digits[0]]: backtrack(combination + letter, next_digits[1:]) output = [] backtrack(\\"\\", digits) return output"},{"question":"def is_acceptable_word_ladder(s: str) -> bool: Determine if a comma-separated list of words forms an acceptable word ladder where each word is exactly one character different from the previous word. :param s: A string of comma-separated words :return: True if the list forms an acceptable word ladder, False otherwise >>> is_acceptable_word_ladder(\\"cat,bat,bet,bed\\") True >>> is_acceptable_word_ladder(\\"cat,bat,bet,bed,be\\") False >>> is_acceptable_word_ladder(\\"cat,bat,b1t,bed\\") False >>> is_acceptable_word_ladder(\\"dog,log,cog,zog,mog,dog\\") True >>> is_acceptable_word_ladder(\\"dog,log,cog\\") True","solution":"def is_acceptable_word_ladder(s): Determine if a comma-separated list of words forms an acceptable word ladder where each word is exactly one character different from the previous word. :param s: A string of comma-separated words :return: True if the list forms an acceptable word ladder, False otherwise words = s.split(',') # Check all words are alphabetic and of the same length if not all(word.isalpha() and len(word) == len(words[0]) for word in words): return False def one_char_diff(word1, word2): Helper function: Check if two words differ by exactly one character. return sum(c1 != c2 for c1, c2 in zip(word1, word2)) == 1 # Check if each word is exactly one character different from the previous one return all(one_char_diff(words[i], words[i+1]) for i in range(len(words) - 1))"},{"question":"def calculate_dosage(weight: int) -> float: Calculate the dosage based on the patient's weight using a rate of 2.5 mg/kg. >>> calculate_dosage(70) 175.0 >>> calculate_dosage(45) 112.5 >>> calculate_dosage(85) 212.5 def get_dosages(weights: List[int]) -> List[float]: Given a list of weights, returns a list of dosages. >>> get_dosages([70, 45, 85]) [175.0, 112.5, 212.5] >>> get_dosages([1, 200]) [2.5, 500.0]","solution":"def calculate_dosage(weight): Calculate the dosage based on the patient's weight using a rate of 2.5 mg/kg. dosage = weight * 2.5 return dosage def get_dosages(weights): Given a list of weights, returns a list of dosages. dosages = [calculate_dosage(weight) for weight in weights] return dosages"},{"question":"def reverse_words(sentence: str) -> str: This function takes a string containing words separated by spaces and returns a new string where each word is replaced by its reverse. >>> reverse_words(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_words(\\"coding assessments are fun\\") \\"gnidoc stnemssessa era nuf\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"a bc def\\") \\"a cb fed\\" >>> reverse_words(\\"a b c d\\") \\"a b c d\\"","solution":"def reverse_words(sentence): This function takes a string containing words separated by spaces and returns a new string where each word is replaced by its reverse. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list representing the number of days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, the answer is 0 for that day. Examples: >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 30, 30, 30, 30]) == [0, 0, 0, 0, 0] >>> daily_temperatures([50, 50, 50, 50]) == [0, 0, 0, 0] >>> daily_temperatures([70]) == [0] >>> daily_temperatures([70, 80, 70, 60, 90]) == [1, 3, 2, 1, 0] >>> daily_temperatures([100, 90, 80, 70]) == [0, 0, 0, 0]","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list representing the number of days you would have to wait until a warmer temperature. If there is no future day with a warmer temperature, the answer is 0 for that day. n = len(temperatures) res = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() res[prev_index] = i - prev_index stack.append(i) return res"},{"question":"class Matrix: Represents a matrix which can be initialized with a two-dimensional list. Methods: - __init__(self, data): Initializes the matrix with the provided data. - shape(self): Returns the number of rows and columns of the matrix as a tuple (rows, columns). - transpose(self): Returns a new matrix which is the transpose of the original matrix. def __init__(self, data): Initializes the matrix with the provided data. :param data: A two-dimensional list representing the matrix. def shape(self): Returns the number of rows and columns of the matrix as a tuple (rows, columns). :return: A tuple containing the number of rows and columns. def transpose(self): Returns a new matrix which is the transpose of the original matrix. :return: A Matrix object which is the transpose of the original matrix. # Unit tests def test_matrix_initialization(): data = [[1, 2, 3], [4, 5, 6]] m = Matrix(data) assert m._data == data def test_matrix_invalid_initialization(): try: Matrix([[1, 2, 3], [4, 5]]) except ValueError as e: assert str(e) == \\"All rows must have the same length\\" def test_matrix_shape(): m = Matrix([[1, 2, 3], [4, 5, 6]]) assert m.shape() == (2, 3) m = Matrix([[1]]) assert m.shape() == (1, 1) m = Matrix([[1,2,3],[4,5,6],[7,8,9]]) assert m.shape() == (3, 3) def test_matrix_transpose(): m = Matrix([[1, 2, 3], [4, 5, 6]]) t = m.transpose() assert t._data == [[1, 4], [2, 5], [3, 6]] m = Matrix([[1]]) t = m.transpose() assert t._data == [[1]] m = Matrix([[]]) t = m.transpose() assert t._data == [] def test_matrix_transpose_shape(): m = Matrix([[1, 2, 3], [4, 5, 6]]) t = m.transpose() assert t.shape() == (3, 2)","solution":"class Matrix: def __init__(self, data): Initializes the matrix with the provided data. :param data: A two-dimensional list representing the matrix. if not all(len(row) == len(data[0]) for row in data): raise ValueError(\\"All rows must have the same length\\") self._data = data def shape(self): Returns the number of rows and columns of the matrix as a tuple (rows, columns). :return: A tuple containing the number of rows and columns. rows = len(self._data) columns = len(self._data[0]) if rows > 0 else 0 return (rows, columns) def transpose(self): Returns a new matrix which is the transpose of the original matrix. :return: A Matrix object which is the transpose of the original matrix. transposed_data = list(zip(*self._data)) return Matrix([list(row) for row in transposed_data])"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Find the sum of the maximum subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([7]) 7 >>> max_subarray_sum([-7]) -7 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([1] * 100000) 100000 >>> max_subarray_sum([0, 0, 0, 0, 0]) 0 >>> max_subarray_sum([3, -2, 5, -1]) 6 # Your code here","solution":"def max_subarray_sum(arr): Finds the sum of the maximum subarray using Kadane's Algorithm. max_so_far = arr[0] max_ending_here = arr[0] for i in range(1, len(arr)): max_ending_here = max(arr[i], max_ending_here + arr[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def has_cycle(graph): Determine if an undirected graph contains a cycle. >>> has_cycle({0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2]}) True >>> has_cycle({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}) False","solution":"def has_cycle(graph): def dfs(node, parent, visited): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node, visited): return True elif parent is not None and neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, None, visited): return True return False"},{"question":"def swipe_left(grid: List[List[int]]) -> List[List[int]]: Simulates sliding blocks on a 2D grid to the left. Each block is represented by a positive integer, and empty spaces are represented by 0s. When a swipe left action occurs, all non-zero blocks move to the leftmost positions of their respective rows, maintaining their original order, and empty spaces shift to the right. Parameters: grid (List[List[int]]): 2D grid containing integers Returns: List[List[int]]: Transformed 2D grid with non-zero values moved to the left >>> swipe_left([ ... [2, 0, 2, 4], ... [0, 4, 0, 4], ... [2, 2, 2, 0], ... [0, 0, 0, 2] ... ]) [ [2, 2, 4, 0], [4, 4, 0, 0], [2, 2, 2, 0], [2, 0, 0, 0] ] >>> swipe_left([[]]) [[]] >>> swipe_left([[0, 1, 0, 2, 0]]) [[1, 2, 0, 0, 0]] >>> swipe_left([[0, 0, 0, 0], ... [0, 0, 0, 0]]) [[0, 0, 0, 0], [0, 0, 0, 0]] >>> swipe_left([[1, 2, 3, 4], ... [5, 6, 7, 8]]) [[1, 2, 3, 4], [5, 6, 7, 8]] >>> swipe_left([[0, 6, 0, 7], ... [8, 0, 0, 9]]) [[6, 7, 0, 0], [8, 9, 0, 0]]","solution":"def swipe_left(grid): Simulates sliding blocks on a 2D grid to the left. Parameters: grid (List[List[int]]): 2D grid containing integers Returns: List[List[int]]: Transformed 2D grid with non-zero values moved to the left for row in grid: # Filter out non-zero values and count of zeros non_zeros = [num for num in row if num != 0] zeros = [0] * (len(row) - len(non_zeros)) # Update row in the grid row[:] = non_zeros + zeros return grid"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> bool: Determines if the array can be partitioned into k non-empty subsets with equal sum. Args: nums: list of integers k: integer representing the number of subsets Returns: bool: True if partitioning is possible, False otherwise Example: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False","solution":"def can_partition_k_subsets(nums, k): Determines if the array can be partitioned into k non-empty subsets with equal sum. Args: nums: list of integers k: integer representing the number of subsets Returns: bool: True if partitioning is possible, False otherwise total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) if nums[0] > target: return False def search(groups): if not nums: return True num = nums.pop() for i in range(k): if groups[i] + num <= target: groups[i] += num if search(groups): return True groups[i] -= num if groups[i] == 0: break nums.append(num) return False return search([0] * k)"},{"question":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise in place. >>> matrix1 = [ >>> [1, 2], >>> [3, 4] >>> ] >>> rotate_matrix(matrix1) >>> matrix1 == [ >>> [3, 1], >>> [4, 2] >>> ] >>> matrix2 = [ >>> [5, 1, 9, 11], >>> [2, 4, 8, 10], >>> [13, 3, 6, 7], >>> [15, 14, 12, 16] >>> ] >>> rotate_matrix(matrix2) >>> matrix2 == [ >>> [15, 13, 2, 5], >>> [14, 3, 4, 1], >>> [12, 6, 8, 9], >>> [16, 7, 10, 11] >>> ]","solution":"def rotate_matrix(matrix): Rotates a given NxN matrix 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"def has_pair_with_sum(arr, target): Determines if there are two distinct numbers in the array that add up to the target value. >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([5, 3, 6, 1], 10) False >>> has_pair_with_sum([10, 2, 5, 3], 15) True >>> has_pair_with_sum([], 5) False","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct numbers in the array that add up to the target value. seen_numbers = set() for number in arr: if target - number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"def sum_of_digits(s: str) -> int: Returns the sum of all the digits in the string s, ignoring any non-digit characters. >>> sum_of_digits(\\"123abc\\") 6 >>> sum_of_digits(\\"4d5e6\\") 15 >>> sum_of_digits(\\"abc\\") 0 >>> sum_of_digits(\\"12.34\\") 10","solution":"def sum_of_digits(s): Returns the sum of all the digits in the string s, ignoring any non-digit characters. return sum(int(char) for char in s if char.isdigit())"},{"question":"def arrange_sections(n: int, sections: List[int]) -> List[int]: Arrange the sections based on the number of books in descending order. If two sections have the same number of books, their relative order should be the same as the original. :param n: int, the number of sections :param sections: list of int, the number of books in each section :return: list of int, the sections arranged as per the described rule >>> arrange_sections(5, [3, 8, 8, 6, 2]) == [8, 8, 6, 3, 2] >>> arrange_sections(4, [1, 1, 1, 1]) == [1, 1, 1, 1]","solution":"def arrange_sections(n, sections): Arrange the sections based on the number of books in descending order. If two sections have the same number of books, their relative order should be the same as the original. :param n: int, the number of sections :param sections: list of int, the number of books in each section :return: list of int, the sections arranged as per the described rule # Pair each element with its index and sort based on the number of books and index indexed_sections = list(enumerate(sections)) indexed_sections.sort(key=lambda x: (-x[1], x[0])) # Extract the sorted sections sorted_sections = [sections[i] for i, _ in indexed_sections] return sorted_sections"},{"question":"def find_min_new_roads(n: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of new roads needed to make the network fully connected. Parameters: n (int): Number of cities roads (list): List of tuples representing existing roads (city a, city b) Returns: int: Minimum number of new roads needed Examples: >>> find_min_new_roads(4, [(1, 2), (3, 4)]) 1 >>> find_min_new_roads(3, [(1, 2)]) 1 >>> find_min_new_roads(5, []) 4","solution":"def find_min_new_roads(n, roads): Determine the minimum number of new roads needed to make the network fully connected. Parameters: n (int): Number of cities roads (list): List of tuples representing existing roads (city a, city b) Returns: int: Minimum number of new roads needed from collections import defaultdict, deque # Creating an adjacency list for the graph graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: city = queue.popleft() for neighbor in graph[city]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Counting the number of connected components num_connected_components = 0 for city in range(1, n + 1): if not visited[city]: bfs(city) num_connected_components += 1 # The minimum number of new roads needed is (num of connected components - 1) return num_connected_components - 1"},{"question":"def find_closest_slot(slots, car): Finds the closest free slot for a car that wants to park. Parameters: slots (list of int): a list where 0 indicates a free slot and 1 indicates an occupied slot. car (int): the index where the car arrives and wants to park. Returns: int: the index of the closest free slot, or -1 if no free slot is available. pass # Test cases assert find_closest_slot([0, 1, 0, 1, 0], 2) == 2 assert find_closest_slot([1, 1, 1, 0, 1], 1) == 3 assert find_closest_slot([1, 1, 1, 1, 1], 0) == -1 assert find_closest_slot([0, 1, 0, 1, 0], 4) == 4 assert find_closest_slot([0, 0, 0, 0, 0], 2) == 2 assert find_closest_slot([0, 1, 0, 0, 1], 1) == 0 assert find_closest_slot([1, 1, 0, 1, 0, 0, 1], 4) == 4 assert find_closest_slot([0, 0, 0, 1, 0, 0], 3) == 2","solution":"def find_closest_slot(slots, car): Finds the closest free slot for a car that wants to park. Parameters: slots (list of int): a list where 0 indicates a free slot and 1 indicates an occupied slot. car (int): the index where the car arrives and wants to park. Returns: int: the index of the closest free slot, or -1 if no free slot is available. min_distance = float('inf') closest_index = -1 for i in range(len(slots)): if slots[i] == 0: distance = abs(i - car) if distance < min_distance or (distance == min_distance and i < closest_index): min_distance = distance closest_index = i return closest_index"},{"question":"def can_be_strictly_increasing_by_removing_one_element(n, arr): Determine whether it is possible to make the array strictly increasing by removing exactly one element. >>> can_be_strictly_increasing_by_removing_one_element(5, [1, 2, 10, 5, 7]) \\"YES\\" >>> can_be_strictly_increasing_by_removing_one_element(3, [1, 2, 3]) \\"YES\\" >>> can_be_strictly_increasing_by_removing_one_element(4, [4, 1, 2, 3]) \\"YES\\" >>> can_be_strictly_increasing_by_removing_one_element(4, [4, 2, 1, 3]) \\"NO\\" >>> can_be_strictly_increasing_by_removing_one_element(5, [1, 2, 3, 5, 4]) \\"YES\\" >>> can_be_strictly_increasing_by_removing_one_element(2, [2, 1]) \\"YES\\"","solution":"def can_be_strictly_increasing_by_removing_one_element(n, arr): Returns \\"YES\\" if it is possible to make the array strictly increasing by removing exactly one element. Otherwise, returns \\"NO\\". def is_strictly_increasing(subarr): for i in range(len(subarr) - 1): if subarr[i] >= subarr[i + 1]: return False return True # Find the first place where the array breaks the strictly increasing rule for i in range(n - 1): if arr[i] >= arr[i + 1]: # Check both options: removing current element or next element if is_strictly_increasing(arr[:i] + arr[i + 1:]) or is_strictly_increasing(arr[:i + 1] + arr[i + 2:]): return \\"YES\\" else: return \\"NO\\" return \\"YES\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(can_be_strictly_increasing_by_removing_one_element(N, A))"},{"question":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_end_of_word = False class WordDictionary: Data structure that supports adding words and searching with wildcard characters. def __init__(self): Initialize the object. def addWord(self, word: str) -> None: Adds a word to the data structure. def search(self, word: str) -> bool: Returns True if there is any string in the data structure that matches the word, or False otherwise. A word may contain dots '.' where dots can be matched with any letter. # Example Usage: # word_dict = WordDictionary() # word_dict.addWord(\\"bad\\") # word_dict.addWord(\\"dad\\") # word_dict.addWord(\\"mad\\") # assert word_dict.search(\\"pad\\") == False # assert word_dict.search(\\"bad\\") == True # assert word_dict.search(\\".ad\\") == True # assert word_dict.search(\\"b..\\") == True","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def addWord(self, word: str) -> None: current = self.root for char in word: current = current.children[char] current.is_end_of_word = True def search(self, word: str) -> bool: return self._search_helper(word, 0, self.root) def _search_helper(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == '.': for child in node.children.values(): if self._search_helper(word, index + 1, child): return True return False elif char in node.children: return self._search_helper(word, index + 1, node.children[char]) else: return False"},{"question":"def char_count(s: str) -> dict: Returns a dictionary where the keys are the unique characters in the string, and the values are their respective counts. >>> char_count('hello') {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> char_count('apple') {'a': 1, 'p': 2, 'l': 1, 'e': 1}","solution":"def char_count(s): Returns a dictionary with the count of each unique character in the input string s. count_dict = {} for char in s: if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"def find_in_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: Searches for the target value in a 2D matrix. Args: matrix (List[List[int]]): A 2D list of integers where each row and column is sorted in ascending order. target (int): An integer value to search in the matrix. Returns: Tuple[int, int]: A tuple (row, column) representing the position of the target in the matrix. If not found, returns (-1, -1). pass from typing import List, Tuple # Unit Tests def test_find_target_present(): matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] assert find_in_matrix(matrix, 5) == (1, 1) assert find_in_matrix(matrix, 10) == (3, 0) assert find_in_matrix(matrix, 17) == (3, 3) assert find_in_matrix(matrix, 1) == (0, 0) def test_find_target_not_present(): matrix = [ [1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17] ] assert find_in_matrix(matrix, 0) == (-1, -1) assert find_in_matrix(matrix, 18) == (-1, -1) def test_empty_matrix(): matrix = [] assert find_in_matrix(matrix, 1) == (-1, -1) def test_single_element_matrix(): matrix = [[5]] assert find_in_matrix(matrix, 5) == (0, 0) assert find_in_matrix(matrix, 0) == (-1, -1) def test_large_matrix(): matrix = [[i + j*10 for i in range(10)] for j in range(10)] assert find_in_matrix(matrix, 55) == (5, 5) assert find_in_matrix(matrix, 0) == (0, 0) assert find_in_matrix(matrix, 99) == (9, 9)","solution":"def find_in_matrix(matrix, target): Searches for the target value in a 2D matrix. Args: matrix (List[List[int]]): A 2D list of integers where each row and column is sorted in ascending order. target (int): An integer value to search in the matrix. Returns: Tuple[int, int]: A tuple (row, column) representing the position of the target in the matrix. If not found, returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) num_rows = len(matrix) num_cols = len(matrix[0]) row = 0 col = num_cols - 1 while row < num_rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def steps_to_one(s: int) -> int: Returns the number of steps to reach 1 starting from s based on the described game rules. >>> steps_to_one(12) == 9 >>> steps_to_one(19) == 20 >>> steps_to_one(27) == 111 >>> steps_to_one(1) == 0 >>> steps_to_one(2) == 1 >>> steps_to_one(3) == 7 pass def process_test_cases(test_cases: List[int]) -> List[int]: Takes a list of integers and returns a list of steps required for each integer to reach 1. >>> process_test_cases([12, 19, 27]) == [9, 20, 111] >>> process_test_cases([1, 2, 3]) == [0, 1, 7] >>> process_test_cases([5, 7, 9]) == [5, 16, 19] pass","solution":"def steps_to_one(s): Returns the number of steps to reach 1 starting from s based on the described game rules. steps = 0 while s != 1: if s % 2 == 0: s //= 2 else: s = s * 3 + 1 steps += 1 return steps def process_test_cases(test_cases): Takes a list of integers and returns a list of steps required for each integer to reach 1. results = [] for s in test_cases: results.append(steps_to_one(s)) return results"},{"question":"def can_be_balanced(weights): Determines if a collection of weights can be split into two groups with equal sum. # Implementation here def process_test_cases(test_cases): Processes multiple test cases to determine if each set of weights can be balanced. results = [] for weights in test_cases: result = can_be_balanced(weights) results.append(\\"YES\\" if result else \\"NO\\") return results def perfect_balance(input_data): Reads input data for multiple test cases and processes them to determine the balance results. lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append(weights) index += 2 return process_test_cases(test_cases)","solution":"def can_be_balanced(weights): Determines if a collection of weights can be split into two groups with equal sum. total_sum = sum(weights) # If total sum is odd, it can't be split into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 n = len(weights) # Using dynamic programming to determine if there is a subset with sum equal to target dp = [False] * (target + 1) dp[0] = True # Base case: a subset sum of 0 is always possible for weight in weights: for j in range(target, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] return dp[target] def process_test_cases(test_cases): results = [] for weights in test_cases: if can_be_balanced(weights): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to read input and process the test cases def perfect_balance(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append(weights) index += 2 return process_test_cases(test_cases)"},{"question":"def calculate_total_distance(distances: List[int]) -> int: Calculate the total distance Santa and his reindeer can travel as a team before the first reindeer needs to rest. :param distances: A list of integers representing the maximum distances each reindeer can travel before needing a rest. The list contains between 2 and 10 integers. Each distance value is between 50 and 300. :return: The total distance traveled by the group before the first reindeer needs to rest. Examples: >>> calculate_total_distance([100, 150, 200, 120]) 100 >>> calculate_total_distance([250, 300, 225, 275]) 225","solution":"def calculate_total_distance(distances): Returns the total distance Santa and his reindeer can travel as a team before the first reindeer needs to rest. return min(distances)"},{"question":"def maxDifference(arr): Returns the maximum difference between two elements in the list where the smaller element comes before the larger element. >>> maxDifference([2, 3, 10, 2, 4, 8, 1]) 8 >>> maxDifference([7, 9, 5, 6, 3, 2]) 2 >>> maxDifference([10, 20, 30, 40]) 30 >>> maxDifference([40, 30, 20, 10]) -1","solution":"def maxDifference(arr): Returns the maximum difference between two elements in the list where the smaller element comes before the larger element. if len(arr) < 2: return -1 max_diff = -1 min_element = arr[0] for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def is_valid_sudoku(board: List[List[str]]) -> bool: Check whether the given 9x9 Sudoku board is valid. A Sudoku board is valid if: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine 3x3 sub-boxes must contain the digits 1-9 without repetition. The board can contain empty cells, represented by the '.' character. A valid Sudoku board (partially filled) does not necessarily have to be solvable. Example: >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(board) True >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\"5\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(board) False","solution":"def is_valid_sudoku(board): def is_valid_unit(unit): Helper function to check if a unit (row/column/sub-box) is valid unit = [x for x in unit if x != '.'] return len(unit) == len(set(unit)) # Check rows for row in board: if not is_valid_unit(row): return False # Check columns for col in range(9): if not is_valid_unit([board[row][col] for row in range(9)]): return False # Check 3x3 sub-boxes for box_row in range(0, 9, 3): for box_col in range(0, 9, 3): sub_box = [ board[r][c] for r in range(box_row, box_row + 3) for c in range(box_col, box_col + 3) ] if not is_valid_unit(sub_box): return False return True"},{"question":"def second_largest(arr: List[int]) -> Optional[int]: Returns the second largest number in the array. If there is no second largest number, return None. >>> second_largest([12, 35, 1, 10, 34, 1]) == 34 >>> second_largest([10, 5, 10]) == 5 >>> second_largest([4, 4, 4]) == None >>> second_largest([1]) == None >>> second_largest([1, 2, 3, 4, 5]) == 4 >>> second_largest([-1, -2, -3, -4, -5]) == -2 >>> second_largest([2, 2, 3, 3, 4, 4, 5, 5]) == 4 >>> second_largest([1, 2, 2, 2, 2]) == 1 >>> second_largest([5, 5, 4, 3, 3]) == 4 >>> second_largest([100, 1000]) == 100","solution":"def second_largest(arr): Returns the second largest number in the array. If there is no second largest number, return None. if len(arr) < 2: return None first = second = float('-inf') for num in arr: if num > first: first, second = num, first elif first > num > second: second = num return second if second != float('-inf') else None"},{"question":"from typing import List, Tuple def can_words_be_rearranged_to_form_each_other(T: int, test_cases: List[Tuple[int, List[str], List[str]]]) -> List[str]: Determines whether a given word can be transformed into another word by rearranging its letters. It also checks if both original and rearranged words are present in a list of valid words. Args: T: The number of test cases. test_cases: A list of tuples where each tuple consists of: - an integer M denoting the number of words in the list of valid words, - a list of M space-separated words representing the list of valid words, - a list containing two words \`word1\` and \`word2\`. Returns: A list of strings \\"YES\\" or \\"NO\\" for each test case. >>> can_words_be_rearranged_to_form_each_other(2, [(4, [\\"listen\\", \\"silent\\", \\"apple\\", \\"ball\\"], [\\"listen\\", \\"silent\\"]), (3, [\\"train\\", \\"rain\\", \\"cat\\"], [\\"train\\", \\"rain\\"])]) [\\"YES\\", \\"NO\\"] >>> can_words_be_rearranged_to_form_each_other(1, [(5, [\\"alice\\", \\"cider\\", \\"dicer\\", \\"dried\\", \\"redic\\"], [\\"cider\\", \\"redci\\"])]) [\\"NO\\"]","solution":"def can_words_be_rearranged_to_form_each_other(T, test_cases): results = [] for i in range(T): M = test_cases[i][0] word_list = test_cases[i][1] word1, word2 = test_cases[i][2] if word1 in word_list and word2 in word_list and sorted(word1) == sorted(word2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def kth_smallest(arr, k): Returns the k-th smallest element in an unsorted array. :param arr: List[int] - The input list of integers. :param k: int - The k-th smallest element to find. :return: int - The k-th smallest element. >>> kth_smallest([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest([1], 1) 1 >>> kth_smallest([1, 2, 3, 4, 5], 2) 2 >>> kth_smallest([5, 4, 3, 2, 1], 4) 4 >>> kth_smallest([1, 2, 2, 3, 3], 4) 3 >>> kth_smallest([9, 8, 7, 6, 5, 4, 3, 2, 1], 9) 9 # Your code here","solution":"import heapq def kth_smallest(arr, k): Returns the k-th smallest element in an unsorted array using a min-heap. :param arr: List[int] - The input list of integers. :param k: int - The k-th smallest element to find. :return: int - The k-th smallest element. # Convert the list into a heap in-place heapq.heapify(arr) # Extract the smallest element k-1 times for _ in range(k-1): heapq.heappop(arr) # The next element is the k-th smallest return heapq.heappop(arr)"},{"question":"def balanced_parentheses(s: str) -> bool: Check if the parentheses in the input string are balanced. >>> balanced_parentheses(\\"abc(de)f\\") True >>> balanced_parentheses(\\"a(b)c)d(\\") False >>> balanced_parentheses(\\"((happy)days)\\") True >>> balanced_parentheses(\\"noparentheses\\") True >>> balanced_parentheses(\\"()()()\\") True >>> balanced_parentheses(\\"(()\\") False >>> balanced_parentheses(\\"\\") True","solution":"def balanced_parentheses(s): Checks if the parentheses in the input string are balanced. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def is_special_word(word: str) -> bool: Determine if a word in the special language is special. A word is considered special if its score (mean of the values of the letters) is an integer. >>> is_special_word(\\"abc\\") True >>> is_special_word(\\"accc\\") False >>> is_special_word(\\"abac\\") False","solution":"def is_special_word(word: str) -> bool: Determine if a word in the special language is special. A word is considered special if its score (mean of the values of the letters) is an integer. # Define a mapping for the letter values value_map = {'a': 1, 'b': 2, 'c': 3} # Calculate the total sum of the values of the letters in the word total_sum = sum(value_map[char] for char in word) # Calculate the number of letters in the word word_length = len(word) # The score should be an integer return total_sum % word_length == 0"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Add two numbers represented by linked lists in reverse order and return the result as a linked list. >>> l1 = list_to_linkedlist([2, 4, 3]) >>> l2 = list_to_linkedlist([5, 6, 4]) >>> result = add_two_numbers(l1, l2) >>> linkedlist_to_list(result) [7, 0, 8] >>> l1 = list_to_linkedlist([0]) >>> l2 = list_to_linkedlist([7, 3, 2]) >>> result = add_two_numbers(l1, l2) >>> linkedlist_to_list(result) [7, 3, 2] def list_to_linkedlist(lst): Convert a list to a linked list. >>> linkedlist_to_list(list_to_linkedlist([2, 4, 3])) [2, 4, 3] def linkedlist_to_list(node): Convert a linked list to a list. >>> linkedlist_to_list(list_to_linkedlist([2, 4, 3])) [2, 4, 3] def sum_linkedlists_linkedlist_format(t, test_cases): Sum two numbers represented by linked lists for multiple test cases and return the results as a list of lists. >>> sum_linkedlists_linkedlist_format(2, [([2, 4, 3], [5, 6, 4]), ([0], [7, 3, 2])]) [[7, 0, 8], [7, 3, 2]]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 carry, out = divmod(val1 + val2 + carry, 10) current.next = ListNode(out) current = current.next l1 = l1.next if l1 else None l2 = l2.next if l2 else None return dummy.next def list_to_linkedlist(lst): dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linkedlist_to_list(node): result = [] while node: result.append(node.val) node = node.next return result def sum_linkedlists_linkedlist_format(t, test_cases): results = [] for case in test_cases: l1_vals, l2_vals = case l1 = list_to_linkedlist(l1_vals) l2 = list_to_linkedlist(l2_vals) result = add_two_numbers(l1, l2) result_list = linkedlist_to_list(result) results.append(result_list) return results"},{"question":"from typing import List def square_non_negative(numbers: List[int]) -> List[int]: Takes a list of numbers as input and returns a new list with each element squared, excluding the elements that are negative. If the input list is empty, the function returns an empty list. >>> square_non_negative([1, 2, -3, 4, -5]) [1, 4, 16] >>> square_non_negative([-1, -2, -3]) [] >>> square_non_negative([]) [] pass def test_all_positive_numbers(): assert square_non_negative([1, 2, 3, 4, 5]) == [1, 4, 9, 16, 25] def test_mixed_numbers(): assert square_non_negative([1, -2, 3, -4, 5]) == [1, 9, 25] def test_all_negative_numbers(): assert square_non_negative([-1, -2, -3, -4, -5]) == [] def test_empty_list(): assert square_non_negative([]) == [] def test_zero_and_positive_numbers(): assert square_non_negative([0, 2, 3]) == [0, 4, 9] def test_single_negative_number(): assert square_non_negative([-3]) == [] def test_single_positive_number(): assert square_non_negative([3]) == [9] def test_single_zero(): assert square_non_negative([0]) == [0]","solution":"def square_non_negative(numbers): Takes a list of numbers as input and returns a new list with each element squared, excluding the elements that are negative. If the input list is empty, the function returns an empty list. return [x ** 2 for x in numbers if x >= 0]"},{"question":"def delivery_min_distance(N, C, K): Calculates the minimum distance for each city as the starting point for delivery route. Parameters: N (int): The number of cities along the delivery route. C (int): The travel cost between two directly connected cities. K (int): The number of delivery cities. Returns: list of tuple: Each tuple contains starting city and the minimum travel distance. pass # Test cases def test_case_1(): assert delivery_min_distance(5, 3, 2) == [(1, 30), (2, 30), (3, 30), (4, 30), (5, 30)] def test_case_2(): assert delivery_min_distance(4, 1, 1) == [(1, 8), (2, 8), (3, 8), (4, 8)] def test_case_3(): assert delivery_min_distance(3, 2, 3) == [(1, 12), (2, 12), (3, 12)] def test_case_4(): assert delivery_min_distance(6, 5, 3) == [(1, 60), (2, 60), (3, 60), (4, 60), (5, 60), (6, 60)] def test_case_5(): assert delivery_min_distance(2, 10, 1) == [(1, 40), (2, 40)]","solution":"def delivery_min_distance(N, C, K): Calculates the minimum distance for each city as the starting point for delivery route. Parameters: N (int): The number of cities along the delivery route. C (int): The travel cost between two directly connected cities. K (int): The number of delivery cities. Returns: list of tuple: Each tuple contains starting city and the minimum travel distance. total_distance = C * N * 2 results = [] for i in range(1, N + 1): results.append((i, total_distance)) return results"},{"question":"from typing import List from collections import Counter def min_deletions_to_make_anagrams(S1: str, S2: str) -> int: Determine the minimum number of deletions required to make the two strings anagrams of each other. >>> min_deletions_to_make_anagrams(\\"cde\\", \\"abc\\") 4 >>> min_deletions_to_make_anagrams(\\"anagram\\", \\"anagram\\") 0 >>> min_deletions_to_make_anagrams(\\"a\\", \\"b\\") 2 >>> min_deletions_to_make_anagrams(\\"abc\\", \\"\\") 3 >>> min_deletions_to_make_anagrams(\\"\\", \\"def\\") 3 >>> min_deletions_to_make_anagrams(\\"aabbcc\\", \\"abccdd\\") 4 >>> min_deletions_to_make_anagrams(\\"a\\"*1000 + \\"b\\"*1000, \\"b\\"*1000 + \\"c\\"*1000) 2000","solution":"from collections import Counter def min_deletions_to_make_anagrams(S1, S2): Determine the minimum number of deletions required to make the two strings anagrams of each other. # Count the frequency of each character in both strings count1 = Counter(S1) count2 = Counter(S2) # Calculate the number of deletions needed deletions = 0 # For characters present in the first string (S1) for char in count1: if char in count2: deletions += abs(count1[char] - count2[char]) else: deletions += count1[char] # For characters present in the second string (S2) but not in the first string (S1) for char in count2: if char not in count1: deletions += count2[char] return deletions"},{"question":"def is_cyclic_shift(A: str, B: str) -> str: Determines if B is a cyclic shift of A. >>> is_cyclic_shift(\\"abcde\\", \\"deabc\\") == \\"YES\\" >>> is_cyclic_shift(\\"abcdef\\", \\"defabc\\") == \\"YES\\" >>> is_cyclic_shift(\\"a\\", \\"a\\") == \\"YES\\" >>> is_cyclic_shift(\\"abc\\", \\"acb\\") == \\"NO\\" >>> is_cyclic_shift(\\"abc\\", \\"abcd\\") == \\"NO\\" pass def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases for checking cyclic shift. >>> test_cases = [(\\"abcde\\", \\"deabc\\"), (\\"abcdef\\", \\"defabc\\"), (\\"a\\", \\"a\\"), (\\"abc\\", \\"acb\\"), (\\"abc\\", \\"abcd\\")] >>> process_test_cases(5, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_cyclic_shift(A, B): Determines if B is a cyclic shift of A. if len(A) != len(B): return \\"NO\\" combined = A + A if B in combined: return \\"YES\\" else: return \\"NO\\" def process_test_cases(T, test_cases): results = [] for A, B in test_cases: results.append(is_cyclic_shift(A, B)) return results"},{"question":"def is_symmetric(mosaic: List[str]) -> str: Check if the N x N mosaic grid is symmetric about both its vertical and horizontal axes. >>> is_symmetric([ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ]) \\"Symmetric\\" >>> is_symmetric([ ... \\"..#.\\", ... \\"#..#\\", ... \\"#..#\\", ... \\"..#.\\" ... ]) \\"Not symmetric\\"","solution":"def is_symmetric(mosaic): n = len(mosaic) for i in range(n): for j in range(n): if mosaic[i][j] != mosaic[n-1-i][j] or mosaic[i][j] != mosaic[i][n-1-j]: return \\"Not symmetric\\" return \\"Symmetric\\" # Example usage # mosaic = [ # \\".#.\\", # \\"#\\", # \\".#.\\" # ] # print(is_symmetric(mosaic)) # Symmetric"},{"question":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the original list. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([4, 5, 1, 8, 2]) [80, 64, 320, 40, 160] >>> product_except_self([5]) [1] >>> product_except_self([3, 4]) [4, 3] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([]) []","solution":"def product_except_self(nums): Returns a list where each element is the product of all other elements in the original list. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"def find_unsorted_subarray(nums): Returns the smallest window (subarray) that needs to be sorted so that the entire array becomes sorted. If the array is already sorted, returns an empty array. Example: >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) [6, 4, 8, 10, 9] >>> find_unsorted_subarray([1, 2, 3, 4, 5]) []","solution":"def find_unsorted_subarray(nums): Returns the smallest window (subarray) that needs to be sorted so that the entire array becomes sorted. If the array is already sorted, returns an empty array. n = len(nums) start, end = -1, -1 # Initializing the sorted array to detect the inequality positions. sorted_nums = sorted(nums) for i in range(n): if nums[i] != sorted_nums[i]: if start == -1: start = i end = i if start == -1: # This means the array is already sorted return [] return nums[start:end+1]"},{"question":"def word_collage(words): Arrange the words into a square grid where the first column forms the first word, the second column forms the second word, and so on. Returns an empty string if input is invalid. Args: words: List of words of equal length. Returns: A string representing the arranged grid, or an empty string if input is invalid. pass # Test cases print(word_collage([\\"ball\\", \\"area\\", \\"lead\\", \\"lady\\"])) # Output: # ball # area # lead # lady print(word_collage([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"])) # Output: # abcd # efgh # ijkl # mnop print(word_collage([\\"xyz\\", \\"abc\\", \\"def\\"])) # Output: # \\"\\"","solution":"def word_collage(words): Arrange the words into a square grid where the first column forms the first word, the second column forms the second word, and so on. Args: words: List of words of equal length. Returns: A string representing the arranged grid, or an empty string if input is invalid. if not words: return \\"\\" word_len = len(words[0]) for word in words: if len(word) != word_len: return \\"\\" # Create a grid as a list of strings grid = \\"n\\".join(words) return grid"},{"question":"from typing import List def is_hourglass(matrix: List[List[int]]) -> bool: Determines if a given square matrix of integers is an hourglass matrix. A matrix is called \\"hourglass\\" if all its elements are in non-decreasing order both from left to right, and from top to bottom. Args: matrix (List[List[int]]): A square matrix of integers. Returns: bool: True if the matrix is an hourglass matrix, False otherwise. Examples: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> is_hourglass(matrix1) True >>> matrix2 = [ ... [1, 3, 2], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> is_hourglass(matrix2) False >>> matrix3 = [ ... [1, 2], ... [2, 3] ... ] >>> is_hourglass(matrix3) True >>> matrix4 = [ ... [1] ... ] >>> is_hourglass(matrix4) True","solution":"from typing import List def is_hourglass(matrix: List[List[int]]) -> bool: Determines if a given square matrix of integers is an hourglass matrix. n = len(matrix) for i in range(n): for j in range(n): if i > 0 and matrix[i][j] < matrix[i-1][j]: return False if j > 0 and matrix[i][j] < matrix[i][j-1]: return False return True"},{"question":"def numeric_filter(arr): Filters an array of strings and returns only valid numbers. Args: arr (list of str): The input array of strings. Returns: list of str: The filtered array containing only valid numbers. >>> numeric_filter([\\"123\\", \\"abc\\", \\"4.56\\", \\"78.9.0\\", \\"5e2\\", \\"NaN\\", \\"Infinity\\", \\"2\\"]) [\\"123\\", \\"4.56\\", \\"5e2\\", \\"2\\"] >>> numeric_filter([\\"1e3\\", \\"5E2\\", \\"1.23E-4\\"]) [\\"1e3\\", \\"5E2\\", \\"1.23E-4\\"] >>> numeric_filter([\\"0\\", \\"0.0\\", \\"-0\\", \\"+0\\"]) [\\"0\\", \\"0.0\\", \\"-0\\", \\"+0\\"] >>> numeric_filter([\\"-123\\", \\"+456\\", \\".789\\", \\"-.456\\", \\"0.001\\"]) [\\"-123\\", \\"+456\\", \\".789\\", \\"-.456\\", \\"0.001\\"]","solution":"def numeric_filter(arr): Filters an array of strings and returns only valid numbers. Args: arr (list of str): The input array of strings. Returns: list of str: The filtered array containing only valid numbers. filtered_list = [] for item in arr: try: # Attempt to convert the string to a float num = float(item) # If conversion is successful, check for non-standard floats like NaN and Infinity if not (str(num).lower() == 'nan' or str(num).lower() == 'inf' or str(num).lower() == '-inf'): filtered_list.append(item) except ValueError: # Skip the item if it cannot be converted to a float continue return filtered_list"},{"question":"import base64 def decode_base64(encoded_str): Decode a Base64 encoded string and return the original text. Args: encoded_str (str): A Base64 encoded string. Returns: str: The decoded original text. Examples: >>> decode_base64('aGVsbG8gd29ybGQ=') 'hello world' >>> decode_base64('VGhpcyBpcyBhIHRlc3Qgc3RyaW5n') 'This is a test string' >>> decode_base64('U3BlY2lhbCEhICEh') 'Special!! !!' >>> decode_base64('MTIzNDU2Nzg5MA==') '1234567890' >>> decode_base64('') ''","solution":"import base64 def decode_base64(encoded_str): Decode a Base64 encoded string and return the original text. Args: encoded_str (str): A Base64 encoded string. Returns: str: The decoded original text. decoded_bytes = base64.b64decode(encoded_str) return decoded_bytes.decode('utf-8')"},{"question":"from typing import List from collections import deque def min_steps_to_target(N: int, M: int, Sx: int, Sy: int, Tx: int, Ty: int, grid: List[str]) -> int: Determine the minimum number of steps required for the character to reach the target position or return -1 if it is impossible. >>> min_steps_to_target(5, 5, 0, 0, 4, 4, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]) 8 >>> min_steps_to_target(3, 3, 0, 0, 2, 2, [\\"..#\\", \\".#.\\", \\"...\\"]) 4 >>> min_steps_to_target(3, 3, 0, 0, 2, 2, [\\"..#\\", \\"#\\", \\"...\\"]) -1 >>> min_steps_to_target(1, 1, 0, 0, 0, 0, [\\".\\"]) 0 >>> min_steps_to_target(5, 5, 0, 0, 4, 4, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]) 8 def solve_game(T: int, test_cases: List[tuple]) -> List[int]: Solve multiple test cases for the minimum steps to reach the target position. >>> solve_game(2, [ (5, 5, 0, 0, 4, 4, [\\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\"]), (3, 3, 0, 0, 2, 2, [\\"..#\\", \\".#.\\", \\"...\\"]) ]) [8, 4] def test_min_steps_to_target_case1(): N = 5 M = 5 Sx = 0 Sy = 0 Tx = 4 Ty = 4 grid = [ \\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\" ] result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) assert result == 8 def test_min_steps_to_target_case2(): N = 3 M = 3 Sx = 0 Sy = 0 Tx = 2 Ty = 2 grid = [ \\"..#\\", \\".#.\\", \\"...\\" ] result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) assert result == 4 def test_unreachable_target(): N = 3 M = 3 Sx = 0 Sy = 0 Tx = 2 Ty = 2 grid = [ \\"..#\\", \\"#\\", \\"...\\" ] result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) assert result == -1 def test_large_grid(): N = 1000 M = 1000 Sx = 0 Sy = 0 Tx = 999 Ty = 999 grid = [['.'] * 1000 for _ in range(1000)] # Add a few obstacles grid[500][500] = '#' result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) assert result == 1998 def test_trivial_case(): N = 1 M = 1 Sx = 0 Sy = 0 Tx = 0 Ty = 0 grid = [ \\".\\" ] result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) assert result == 0","solution":"from collections import deque def min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS setup queue = deque([(Sx, Sy)]) visited = [[False] * M for _ in range(N)] visited[Sx][Sy] = True steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (Tx, Ty): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) steps += 1 return -1 def solve_game(T, test_cases): results = [] for case in test_cases: N, M, Sx, Sy, Tx, Ty, grid = case result = min_steps_to_target(N, M, Sx, Sy, Tx, Ty, grid) results.append(result) return results # Example test cases input example_test_cases = [ ( 5, 5, 0, 0, 4, 4, [ \\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\" ] ), ( 3, 3, 0, 0, 2, 2, [ \\"..#\\", \\".#.\\", \\"...\\" ] ), ] # Running example test cases T = 2 results = solve_game(T, example_test_cases) for res in results: print(res)"},{"question":"def is_beautiful_sequence_possible(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if a sequence can be rearranged to form a beautiful sequence. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains the integer N and the list of integers. Returns: list: List of strings, \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case.","solution":"def is_beautiful_sequence_possible(T, test_cases): Determine if a sequence can be rearranged to form a beautiful sequence. Parameters: T (int): Number of test cases. test_cases (list): List of tuples, where each tuple contains the integer N and the list of integers. Returns: list: List of strings, \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. results = [] for i in range(T): N, sequence = test_cases[i] count_map = {} for num in sequence: if num in count_map: count_map[num] += 1 else: count_map[num] = 1 max_occurrences = max(count_map.values()) if max_occurrences <= (N + 1) // 2: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False max_divisor = int(num ** 0.5) + 1 for divisor in range(3, max_divisor, 2): if num % divisor == 0: return False return True def prime_positions_are_primes(arr): Check if the numbers at prime positions are prime numbers. >>> prime_positions_are_primes([2, 3, 5, 7, 11, 13]) == \\"YES\\" >>> prime_positions_are_primes([4, 6, 8, 12, 18, 22]) == \\"NO\\"","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False max_divisor = int(num ** 0.5) + 1 for divisor in range(3, max_divisor, 2): if num % divisor == 0: return False return True def prime_positions_are_primes(arr): n = len(arr) for pos in range(2, n + 1): # positions start from 1, so position at index 1 is at pos=2 if is_prime(pos): if not is_prime(arr[pos - 1]): return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for t in test_cases: n, arr = t results.append(prime_positions_are_primes(arr)) return results # function to parse input and produce output def main(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) test_cases.append((n, arr)) index += 2 results = process_test_cases(test_cases) return \\"n\\".join(results)"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None def has_cycle(head): Detects whether a cycle is present in a linked list. Parameters: head (Node): The head node of the linked list. Returns: bool: True if a cycle is present, False otherwise. >>> head = Node(1) >>> second = Node(2) >>> head.next = second >>> assert not has_cycle(head) >>> head = Node(1) >>> second = Node(2) >>> head.next = second >>> second.next = head >>> assert has_cycle(head)","solution":"class Node: def __init__(self, data): self.data = data self.next = None def has_cycle(head): Detects whether a cycle is present in a linked list. Parameters: head (Node): The head node of the linked list. Returns: bool: True if a cycle is present, False otherwise. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"def divide_marbles(T: int, test_cases: List[int]) -> List[Tuple[int, int]]: Returns the number of marbles Jill and Jack end up with for each test case. >>> divide_marbles(3, [10, 15, 7]) [(5, 5), (8, 7), (4, 3)] >>> divide_marbles(1, [0]) [(0, 0)] >>> divide_marbles(2, [1, 2]) [(1, 0), (1, 1)] >>> divide_marbles(4, [11, 12, 999999999, 1000000000]) [(6, 5), (6, 6), (500000000, 499999999), (500000000, 500000000)]","solution":"def divide_marbles(T, test_cases): Returns the number of marbles Jill and Jack end up with for each test case. results = [] for N in test_cases: jill_marbles = (N + 1) // 2 jack_marbles = N // 2 results.append((jill_marbles, jack_marbles)) return results"},{"question":"def is_network_possible(c: int, s: int, connections: List[int]) -> str: Determines if it's possible to create a network following the given rules. Args: c (int): Number of computer rooms. s (int): Number of storage rooms. connections (list of int): Storage room indexes each computer room is connected to. Returns: str: \\"YES\\" if it's possible to create the network, otherwise \\"NO\\". >>> is_network_possible(3, 2, [1, 2, 1]) \\"YES\\" >>> is_network_possible(4, 3, [1, 2, 1, 3]) \\"YES\\" >>> is_network_possible(2, 1, [1, 1]) \\"YES\\" >>> is_network_possible(3, 2, [1, 1, 1]) \\"NO\\"","solution":"def is_network_possible(c, s, connections): Determines if it's possible to create a network following the given rules. Args: c (int): Number of computer rooms. s (int): Number of storage rooms. connections (list of int): Storage room indexes each computer room is connected to. Returns: str: \\"YES\\" if it's possible to create the network, otherwise \\"NO\\". from collections import defaultdict # Create a graph using adjacency list storage_to_computer = defaultdict(list) for i in range(c): storage_to_computer[connections[i]].append(i) # Check if every computer room can be reached by traversing connections visited = set() stack = [connections[0]] while stack: current_storage = stack.pop() if current_storage not in visited: visited.add(current_storage) for computer_room in storage_to_computer[current_storage]: # Add storage rooms connected from each computer for storage in connections: stack.append(storage) # If all computer rooms can be reached, we should have added all to visited if len(visited) == s: return \\"YES\\" else: return \\"NO\\""},{"question":"def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the list to the right by k steps. Arguments: nums -- a list of integers k -- a non-negative integer representing the number of steps >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3]","solution":"def rotate_list(nums, k): Rotates the list to the right by k steps. Arguments: nums -- a list of integers k -- a non-negative integer representing the number of steps if not nums or k == 0: return nums n = len(nums) k = k % n # handle cases where k is greater than the length of the list return nums[-k:] + nums[:-k]"},{"question":"def find_overall_winner(m: int, p: int, race_results: List[List[int]]) -> int: Mallory is organizing a series of bike races in her town. She wants to announce the winners at the end of the day. There are m races in total. Each race has p participants, and the order in which participants finish the race is recorded. Mallory needs a program that helps her determine the overall winner across all races based on their rankings in each race. The overall winner is the participant who has the lowest total ranking score. The ranking score for a participant is the sum of their position in each race (1st place = 1 point, 2nd place = 2 points, and so on). If two or more participants have the same ranking score, the participant who had the highest individual finishing position in any race should be considered the winner. If this condition cannot break the tie, Mallory can simply choose any of the tied participants as the winner. Args: m (int): the number of races. p (int): the number of participants in each race. race_results (List[List[int]]): Finishing order of the participants in each race. Returns: int: The participant number of the overall winner. Example: >>> find_overall_winner(3, 3, [[1, 2, 3], [2, 1, 3], [3, 2, 1]]) 2 >>> find_overall_winner(2, 4, [[2, 1, 3, 4], [1, 3, 2, 4]]) 1","solution":"def find_overall_winner(m, p, race_results): scores = [0] * p highest_positions = [float('inf')] * p for race in race_results: for i, participant in enumerate(race): scores[participant - 1] += (i + 1) highest_positions[participant - 1] = min(highest_positions[participant - 1], i + 1) min_score = min(scores) candidates = [i + 1 for i, score in enumerate(scores) if score == min_score] if len(candidates) == 1: return candidates[0] else: best_candidate = min(candidates, key=lambda x: highest_positions[x - 1]) return best_candidate"},{"question":"from typing import Dict, List, Tuple def find_overlapping_employees(schedules: Dict[str, Dict[str, Tuple[int, int]]]) -> List[Tuple[str, str]]: Finds and returns a list of pairs of employees who share at least one overlapping work hour on any day of the week. :param schedules: A dictionary containing the work schedules of employees, where each key is an employee's name and the value is another dictionary with days of the week as keys and tuples representing start and end times in a 24-hour format. :return: A list of tuples, where each tuple contains two names of employees who have at least one overlapping work hour. Example: >>> schedules = { 'Alice': {'Mon': (9, 17), 'Tue': (9, 17)}, 'Bob': {'Mon': (10, 18), 'Tue': (19, 21)} } >>> find_overlapping_employees(schedules) [('Alice', 'Bob')] Test cases: >>> schedules = { 'Alice': {'Mon': (9, 17), 'Tue': (9, 17)}, 'Bob': {'Mon': (10, 18), 'Tue': (19, 21)} } >>> find_overlapping_employees(schedules) == [('Alice', 'Bob')] >>> schedules = { 'Alice': {'Mon': (9, 17), 'Tue': (9, 17)}, 'Bob': {'Mon': (17, 20), 'Tue': (19, 21)}, 'Charlie': {'Mon': (9, 17), 'Tue': (9, 17)} } >>> find_overlapping_employees(schedules) == [('Alice', 'Charlie')]","solution":"from itertools import combinations def find_overlapping_employees(schedules): def is_overlap(t1, t2): Helper function to check if two time periods overlap return max(t1[0], t2[0]) < min(t1[1], t2[1]) overlapping_pairs = set() # Generate all pairs of employees for emp1, emp2 in combinations(schedules.keys(), 2): for day in schedules[emp1]: if is_overlap(schedules[emp1][day], schedules[emp2][day]): # Add tuple in sorted order to ensure alphabetical order of names overlapping_pairs.add(tuple(sorted((emp1, emp2)))) break return list(overlapping_pairs)"},{"question":"from typing import List def count_unique_integers(lst: List[int]) -> int: Write a function that receives a list of integers and returns the count of unique integers in the list. For example: >>> count_unique_integers([1, 2, 3, 4, 5]) 5 >>> count_unique_integers([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 4 >>> count_unique_integers([7, 7, 7, 7, 7, 7, 7, 7, 7]) 1 >>> count_unique_integers([]) 0 >>> count_unique_integers([42]) 1","solution":"def count_unique_integers(lst): Returns the count of unique integers in the list. return len(set(lst))"},{"question":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(s): Convert a Roman numeral to an integer. :param s: A string representing the Roman numeral. :return: An integer equivalent of the Roman numeral. roman_to_value = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for ch in reversed(s): value = roman_to_value[ch] if value >= prev_value: total += value else: total -= value prev_value = value return total"},{"question":"def generate_spiral_matrix(n: int) -> [[int]]: Generate an n x n matrix containing integers from 1 to n^2 in spiral order, starting from the top-left corner and moving towards the center in a clockwise direction. :param n: an integer representing the size of the n x n matrix :return: a 2D list representing the n x n matrix filled in spiral order >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] import pytest from solution import generate_spiral_matrix def test_generate_spiral_matrix_1x1(): assert generate_spiral_matrix(1) == [[1]] def test_generate_spiral_matrix_2x2(): assert generate_spiral_matrix(2) == [[1, 2], [4, 3]] def test_generate_spiral_matrix_3x3(): assert generate_spiral_matrix(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]] def test_generate_spiral_matrix_4x4(): assert generate_spiral_matrix(4) == [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] def test_generate_spiral_matrix_5x5(): assert generate_spiral_matrix(5) == [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generate an n x n matrix containing integers from 1 to n^2 in spiral order. matrix = [[0] * n for _ in range(n)] number = 1 top, bottom, left, right = 0, n - 1, 0, n - 1 while number <= n * n: for i in range(left, right + 1): matrix[top][i] = number number += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = number number += 1 right -= 1 for i in range(right, left - 1, -1): matrix[bottom][i] = number number += 1 bottom -= 1 for i in range(bottom, top - 1, -1): matrix[i][left] = number number += 1 left += 1 return matrix"},{"question":"def trap(height: List[int]) -> int: Given an array of heights representing the heights of columns where the width of each column is 1, returns the maximum amount of water that can be trapped between the columns after raining. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([3, 3, 3, 3]) 0 >>> trap([]) 0 >>> trap([0,1]) 0 >>> trap([2, 0, 2]) 2 >>> trap([4, 1, 3, 1, 4]) 7","solution":"def trap(height): Given an array height representing the heights of columns where the width of each column is 1, returns the maximum amount of water that can be trapped between the columns after raining. n = len(height) if n == 0: return 0 left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def count_paths(h: int, w: int, blocked: List[List[bool]]) -> int: Returns the number of distinct paths from the top-left to the bottom-right cell in a grid. Only right or down moves are allowed, and some cells may be blocked. Args: h: The height of the grid. w: The width of the grid. blocked: A 2D boolean array where blocked[i][j] is True if the cell (i, j) is blocked, False otherwise. Returns: An integer representing the number of distinct paths from the top-left to the bottom-right cell. Example: >>> count_paths(3, 3, [ ... [False, False, False], ... [False, True, False], ... [False, False, False] ... ]) 2 >>> count_paths(2, 2, [ ... [False, True], ... [False, False] ... ]) 1","solution":"def count_paths(h, w, blocked): Returns the number of distinct paths from the top-left to the bottom-right cell in a grid. Only right or down moves are allowed, and some cells may be blocked. if blocked[0][0] or blocked[h-1][w-1]: return 0 # Create a 2D dp array dp = [[0 for _ in range(w)] for _ in range(h)] # Initialize the starting position dp[0][0] = 1 # Fill the dp array for i in range(h): for j in range(w): if not blocked[i][j]: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[h-1][w-1]"},{"question":"def reverse_groups(s: str, delimiter: str) -> str: Implement a function that reverses the words in a given string, but only within specified groups. Groups are separated by a delimiter. The delimiter itself does not change its position. Args: s (str): The input string containing words separated by the delimiter. delimiter (str): The character that separates the groups in the string. Returns: str: The modified string with words reversed within each group. Examples: >>> reverse_groups(\\"hello world|this is fun\\", \\"|\\") 'world hello|fun is this' >>> reverse_groups(\\"abc def ghi|jkl mno pqr\\", \\"|\\") 'ghi def abc|pqr mno jkl'","solution":"def reverse_groups(s: str, delimiter: str) -> str: Reverses the words within each group of a string separated by a given delimiter. Args: s (str): The input string containing words separated by the delimiter. delimiter (str): The character that separates the groups in the string. Returns: str: The modified string with words reversed within each group. if not s: return s groups = s.split(delimiter) # Reverse the words within each group reversed_groups = [] for group in groups: words = group.split() reversed_group = ' '.join(reversed(words)) reversed_groups.append(reversed_group) # Join the reversed groups with the delimiter result = delimiter.join(reversed_groups) return result"},{"question":"def first_unique(s: str) -> str: Returns the first unique character in the string s. If there is no unique character, return None. >>> first_unique(\\"adbca\\") == 'd' >>> first_unique(\\"aabb\\") == None >>> first_unique(\\"abc\\") == 'a' >>> first_unique(\\"\\") == None >>> first_unique(\\"a\\") == 'a' >>> first_unique(\\"abcabcda\\") == 'd'","solution":"def first_unique(s): Returns the first unique character in the string s. If there is no unique character, return None. char_count = {} # Count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char return None"},{"question":"def duplicate_encode(word: str) -> str: Encodes a string such that each character in the new string is '(' if that character appears only once in the original string, or ')' if that character appears more than once in the original string. The function ignores the case of the characters. >>> duplicate_encode(\\"din\\") == \\"(((\\" >>> duplicate_encode(\\"recede\\") == \\"()()()\\" >>> duplicate_encode(\\"Success\\") == \\")())())\\" >>> duplicate_encode(\\"(( @\\") == \\"))((\\"","solution":"def duplicate_encode(word): Encodes a string such that each character in the new string is '(' if that character appears only once in the original string, or ')' if that character appears more than once in the original string. The function ignores the case of the characters. word = word.lower() return ''.join(['(' if word.count(ch) == 1 else ')' for ch in word])"},{"question":"def percentage_correct_guesses(correctNumber: int, guesses: list[int]) -> int: Given a list of guesses and a correct number, returns the percentage of correct guesses rounded to the nearest integer. Args: correctNumber (int): The correct guessed number. guesses (list of int): A list of guesses made by participants. Returns: int: Percentage of correct guesses rounded to the nearest integer. >>> percentage_correct_guesses(42, []) == 0 >>> percentage_correct_guesses(42, [42, 42, 42]) == 100 >>> percentage_correct_guesses(42, [10, 20, 30]) == 0 >>> percentage_correct_guesses(42, [10, 42, 57, 42, 99]) == 40 >>> percentage_correct_guesses(50, [50]) == 100 >>> percentage_correct_guesses(75, [21]) == 0","solution":"def percentage_correct_guesses(correctNumber, guesses): Returns the percentage of correct guesses rounded to the nearest integer. Args: correctNumber (int): The correct guessed number. guesses (list of int): A list of guesses made by participants. Returns: int: Percentage of correct guesses rounded to the nearest integer. if not guesses: return 0 # If there are no guesses, return 0%. num_correct = sum(1 for guess in guesses if guess == correctNumber) percentage_correct = (num_correct / len(guesses)) * 100 return round(percentage_correct)"},{"question":"def generate_sequence(start: int, n: int) -> list: Returns an array of \`n\` consecutive numbers starting from \`start\`. >>> generate_sequence(5, 5) [5, 6, 7, 8, 9] >>> generate_sequence(-3, 3) [-3, -2, -1] >>> generate_sequence(0, 4) [0, 1, 2, 3] >>> generate_sequence(10, 1) [10] >>> generate_sequence(100, 5) [100, 101, 102, 103, 104] >>> generate_sequence(-10, 3) [-10, -9, -8]","solution":"def generate_sequence(start, n): Returns an array of \`n\` consecutive numbers starting from \`start\`. return [start + i for i in range(n)]"},{"question":"def count_tiling_ways(W: int, H: int, T: int) -> int: A rectangular pool W units wide and H units high contains n square tiles each of width T. Each tile fully fits within the pool. The function returns the number of different ways there are to completely tile the pool using the tiles. The tiles can be rotated if necessary. >>> count_tiling_ways(6, 4, 2) 1 >>> count_tiling_ways(5, 5, 1) 1 >>> count_tiling_ways(10, 10, 2) 1 >>> count_tiling_ways(10, 9, 2) 0 >>> count_tiling_ways(1, 1, 1) 1 >>> count_tiling_ways(1000000000, 1000000000, 1) 1","solution":"def count_tiling_ways(W, H, T): # Check if the pool can be tiled perfectly by width and height if W % T != 0 or H % T != 0: return 0 width_tiles = W // T height_tiles = H // T # There is only one way to tile the pool, regardless of the arrangement return 1"},{"question":"def expand_ranges(ranges: str) -> list: Expands a string containing ranges and individual numbers into a list of all specified numbers. >>> expand_ranges('1-3') == [1, 2, 3] >>> expand_ranges('7-10') == [7, 8, 9, 10] >>> expand_ranges('1-3,5') == [1, 2, 3, 5] >>> expand_ranges('10-13,15-17,20') == [10, 11, 12, 13, 15, 16, 17, 20] >>> expand_ranges('1,3,5-7') == [1, 3, 5, 6, 7]","solution":"def expand_ranges(ranges): Expands a string containing ranges and individual numbers into a list of all specified numbers. Parameters: ranges (str): A string containing comma-separated ranges or individual numbers (e.g., '1-3,5'). Returns: list: A list of integers expanded from the input ranges. result = [] parts = ranges.split(',') for part in parts: if '-' in part: start, end = part.split('-') result.extend(range(int(start), int(end) + 1)) else: result.append(int(part)) return result"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(arr: List[int]) -> int: Determine the length of the longest increasing subsequence in the given list of integers. Parameters: arr (List[int]): A list of integers representing the heights of the trees. Returns: int: The length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([5, 8, 3, 7, 9, 1, 2, 3]) 4 pass def max_increasing_trees(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of trees that can form a strictly increasing sequence of heights for each test case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing an integer N and a list of integers representing the heights of the trees. Returns: List[int]: A list of integers representing the maximum sequence lengths for each test case. >>> test_cases = [(5, [3, 10, 2, 1, 20]), (8, [5, 8, 3, 7, 9, 1, 2, 3])] >>> max_increasing_trees(test_cases) [3, 4] pass def test_single_case(): test_cases = [ (5, [3, 10, 2, 1, 20]) ] expected = [3] assert max_increasing_trees(test_cases) == expected def test_multiple_cases(): test_cases = [ (5, [3, 10, 2, 1, 20]), (8, [5, 8, 3, 7, 9, 1, 2, 3]) ] expected = [3, 4] assert max_increasing_trees(test_cases) == expected def test_monotonically_decreasing(): test_cases = [ (5, [5, 4, 3, 2, 1]) ] expected = [1] assert max_increasing_trees(test_cases) == expected def test_all_same_height(): test_cases = [ (5, [1, 1, 1, 1, 1]) ] expected = [1] assert max_increasing_trees(test_cases) == expected def test_single_tree(): test_cases = [ (1, [10]) ] expected = [1] assert max_increasing_trees(test_cases) == expected def test_empty(): test_cases = [ (0, []) ] expected = [0] assert max_increasing_trees(test_cases) == expected","solution":"def longest_increasing_subsequence(arr): if not arr: return 0 # Initialize the list for the dynamic programming dp = [1] * len(arr) # Fill dp array for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence return max(dp) def max_increasing_trees(test_cases): results = [] for case in test_cases: N, heights = case results.append(longest_increasing_subsequence(heights)) return results"},{"question":"def longest_vowel_substring_length(s: str) -> int: Returns the length of the longest substring consisting of only vowels. >>> longest_vowel_substring_length(\\"aeiou\\") 5 >>> longest_vowel_substring_length(\\"leetcode\\") 2 >>> longest_vowel_substring_length(\\"beautifulday\\") 3 >>> longest_vowel_substring_length(\\"bcdfg\\") 0 >>> longest_vowel_substring_length(\\"a\\") 1 >>> longest_vowel_substring_length(\\"b\\") 0 >>> longest_vowel_substring_length(\\"\\") 0 >>> longest_vowel_substring_length(\\"ababab\\") 1","solution":"def longest_vowel_substring_length(s): Returns the length of the longest substring consisting of only vowels. vowels = {'a', 'e', 'i', 'o', 'u'} max_length = 0 current_length = 0 for char in s: if char in vowels: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def create_greeting_cards(n: int, friends_words: List[str]) -> List[str]: Generates greeting card messages for each friend by sorting their favorite words alphabetically and removing duplicates. Args: n (int): Number of friends. friends_words (list of str): List of comma-separated favorite words for each friend. Returns: list of str: Greeting card messages for each friend. >>> create_greeting_cards(3, [\\"apple,banana,apple,kiwi,banana\\", \\"grape,kiwi,mango\\", \\"apple,orange,banana,banana,kiwi\\"]) ['apple,banana,kiwi', 'grape,kiwi,mango', 'apple,banana,kiwi,orange'] >>> create_greeting_cards(1, [\\"\\"]) [\\"\\"] >>> create_greeting_cards(2, [\\"apple\\", \\"banana\\"]) ['apple', 'banana'] >>> create_greeting_cards(1, [\\"apple,apple,apple,apple\\"]) ['apple'] >>> create_greeting_cards(2, [\\"apple,kiwi,banana,apple\\", \\"mango,grape\\"]) ['apple,banana,kiwi', 'grape,mango'] >>> create_greeting_cards(1, [\\"apple,banana,kiwi,apple,banana,kiwi,apple,kiwi\\"]) ['apple,banana,kiwi']","solution":"def create_greeting_cards(n, friends_words): Generates greeting card messages for each friend by sorting their favorite words alphabetically and removing duplicates. Args: n (int): Number of friends. friends_words (list of str): List of comma-separated favorite words for each friend. Returns: list of str: Greeting card messages for each friend. greeting_cards = [] for words in friends_words: unique_words = sorted(set(words.split(','))) greeting_cards.append(','.join(unique_words)) return greeting_cards"},{"question":"def is_strictly_increasing(sequence): Determines if the sequence of numbers is strictly increasing, where each subsequent number is greater than the previous one. If the array is empty, None, or only contains one element, return False. Args: sequence (list): The list of integers to check. Returns: bool: True if the sequence is strictly increasing, False otherwise. Examples: >>> is_strictly_increasing([1, 3, 5, 7, 9]) True >>> is_strictly_increasing([2, 2, 4, 6, 8]) False from solution import is_strictly_increasing def test_increasing_sequence(): assert is_strictly_increasing([1, 3, 5, 7, 9]) == True def test_equal_elements(): assert is_strictly_increasing([2, 2, 4, 6, 8]) == False def test_decreasing_sequence(): assert is_strictly_increasing([10, 5, 2, 8, 9]) == False def test_single_element(): assert is_strictly_increasing([5]) == False def test_empty_sequence(): assert is_strictly_increasing([]) == False def test_none_sequence(): assert is_strictly_increasing(None) == False def test_mixed_sequence(): assert is_strictly_increasing([1, 2, 2, 3, 4]) == False def test_increasing_with_negative_numbers(): assert is_strictly_increasing([-3, -2, -1, 0, 1]) == True def test_edge_cases(): assert is_strictly_increasing([0, 1]) == True assert is_strictly_increasing([0, 0]) == False assert is_strictly_increasing([100, 200, 300]) == True","solution":"def is_strictly_increasing(sequence): Determines if the sequence of numbers is strictly increasing, where each subsequent number is greater than the previous one. If the array is empty, None, or only contains one element, return False. Args: sequence (list): The list of integers to check. Returns: bool: True if the sequence is strictly increasing, False otherwise. if sequence is None or len(sequence) <= 1: return False for i in range(1, len(sequence)): if sequence[i] <= sequence[i - 1]: return False return True"},{"question":"def generate_spell_word(alphabet: str, target_word: str) -> bool: Determines if the target spell word can be formed by the given sequence of characters. Parameters: alphabet (string): The string containing the alphabet characters. target_word (string): The string of the target word to generate. Returns: boolean: True if the target word can be generated, False otherwise. >>> generate_spell_word('bcadappqz', 'cap') True >>> generate_spell_word('bcadappqz', 'zap') True >>> generate_spell_word('bcadappqz', 'zapz') False >>> generate_spell_word('bcadappqz', 'Cat') False >>> generate_spell_word('bcadappqz', '') True >>> generate_spell_word('', 'a') False >>> generate_spell_word('a', 'aa') False >>> generate_spell_word('bcadappqz', 'apppqzba') False >>> generate_spell_word('bcadap', 'capz') False","solution":"def generate_spell_word(alphabet, target_word): Determines if the target spell word can be formed by the given sequence of characters. Parameters: alphabet (string): The string containing the alphabet characters. target_word (string): The string of the target word to generate. Returns: boolean: True if the target word can be generated, False otherwise. from collections import Counter alphabet_count = Counter(alphabet) target_count = Counter(target_word) for char in target_count: if target_count[char] > alphabet_count.get(char, 0): return False return True"},{"question":"def max_area_of_island(grid: List[List[int]]) -> int: Given a 2D grid of integers representing a map where 1 represents land and 0 represents water, the grid is fully surrounded by water and is rectangular in shape. An island is formed by connecting adjacent lands horizontally or vertically. You need to write a function that returns the maximum area of an island in the grid. The area of an island is the number of land cells in it. >>> max_area_of_island([[0,0,1,0],[0,1,1,0],[0,0,0,0]]) 3 >>> max_area_of_island([[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]) 4 >>> max_area_of_island([[1,0],[0,1]]) 1","solution":"def max_area_of_island(grid): Returns the maximum area of an island in the given grid. An island is defined as a group of adjacent lands (1s). if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return 0 visited[r][c] = True area = 1 # Current cell # Explore all 4 directions area += dfs(r + 1, c) area += dfs(r - 1, c) area += dfs(r, c + 1) area += dfs(r, c - 1) return area max_area = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"def filter_and_sort_names(names: list, length_threshold: int) -> list: Filters the names with length greater than or equal to length_threshold and sorts them alphabetically. Parameters: names (list): List of strings representing names. length_threshold (int): The length threshold for filtering names. Returns: list: Sorted list of names filtered by the length_threshold. >>> filter_and_sort_names([\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"], 4) ['Alice', 'Charlie', 'David'] >>> filter_and_sort_names([\\"Zara\\", \\"Ann\\", \\"Elizabeth\\", \\"Tom\\"], 5) ['Elizabeth']","solution":"def filter_and_sort_names(names, length_threshold): Filters the names with length greater than or equal to length_threshold and sorts them alphabetically. Parameters: names (list): List of strings representing names. length_threshold (int): The length threshold for filtering names. Returns: list: Sorted list of names filtered by the length_threshold. filtered_names = [name for name in names if len(name) >= length_threshold] return sorted(filtered_names)"},{"question":"from typing import List def maxCoins(matrix: List[List[int]]) -> int: Given a matrix of integers, where each cell in the matrix contains a certain number of coins, find the maximum number of coins you can collect by following a path from the top-left corner to the bottom-right corner of the matrix. You can only move to the right or down in the path. >>> maxCoins([ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ]) 12 >>> maxCoins([ [7] ]) 7 >>> maxCoins([ [5, 3, 2, 1] ]) 11 >>> maxCoins([ [2], [5], [1], [3] ]) 11 >>> maxCoins([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) 29 >>> maxCoins([ [1, 0, 0, 1], [0, 2, 0, 0], [1, 0, 3, 1] ]) 7","solution":"def maxCoins(matrix): rows = len(matrix) cols = len(matrix[0]) # Create a 2D DP array dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the DP array for i in range(1, rows): for j in range(1, cols): dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[rows-1][cols-1]"},{"question":"def list_primes(n: int) -> list: Given a positive integer \`n\`, return an array of all prime numbers less than \`n\`. Prime numbers are greater than 1 and have no positive divisors other than 1 and themselves. >>> list_primes(10) # [2, 3, 5, 7] >>> list_primes(20) # [2, 3, 5, 7, 11, 13, 17, 19] >>> list_primes(5) # [2, 3]","solution":"def list_primes(n): Returns a list of all prime numbers less than n. Parameters: - n (int): The upper limit (exclusive) for prime numbers. Returns: - list: A list of prime numbers less than n. if n <= 2: return [] is_prime = [True] * n is_prime[0], is_prime[1] = False, False for start in range(2, int(n ** 0.5) + 1): if is_prime[start]: for multiple in range(start*start, n, start): is_prime[multiple] = False return [num for num in range(n) if is_prime[num]]"},{"question":"def count_subarrays(N: int, H: int, heights: List[int]) -> int: Count the total number of contiguous subarrays where the height of every tree in the subarray is less than or equal to H. >>> count_subarrays(5, 3, [1, 2, 3, 4, 5]) 6 >>> count_subarrays(4, 2, [3, 1, 2, 4]) 3 from typing import List import doctest doctest.testmod() def test_case_1(): assert count_subarrays(5, 3, [1, 2, 3, 4, 5]) == 6 def test_case_2(): assert count_subarrays(4, 2, [3, 1, 2, 4]) == 3 def test_case_3(): assert count_subarrays(3, 1, [1, 1, 1]) == 6 def test_case_4(): assert count_subarrays(6, 3, [4, 5, 6, 1, 2, 3]) == 6 def test_case_5(): assert count_subarrays(7, 5, [1, 2, 3, 4, 5, 6, 7]) == 15","solution":"def count_subarrays(N, H, heights): count = 0 subarray_length = 0 for height in heights: if height <= H: subarray_length += 1 else: count += (subarray_length * (subarray_length + 1)) // 2 subarray_length = 0 # Add the count for the last subarray if it ends with heights less than or equal to H count += (subarray_length * (subarray_length + 1)) // 2 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_reversed_integer(head: ListNode) -> int: Given a linked list, where each node contains a single digit from 0 to 9, return the linked list as an integer in reversed order. >>> linked_list_to_reversed_integer(build_linked_list([1, 2, 3])) 321 >>> linked_list_to_reversed_integer(build_linked_list([0, 1, 0])) 10 >>> linked_list_to_reversed_integer(build_linked_list([7])) 7 >>> linked_list_to_reversed_integer(build_linked_list([5, 6, 2, 9])) 9265 >>> linked_list_to_reversed_integer(build_linked_list([9, 8, 7, 6, 5, 4, 3, 2, 1])) 123456789 def build_linked_list(values): Helper function to build a linked list from a list of values. if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_reversed_integer(head: ListNode) -> int: This function takes the head of a linked list and returns the integer representing the linked list in reversed order. current = head num_str = \\"\\" # Traverse the linked list while current: num_str = str(current.val) + num_str current = current.next return int(num_str)"},{"question":"def find_peak_sum(test_cases): Given an array of N integers, define the \\"peak\\" of the array as the sum of all elements that are greater than both of their immediate neighbors. The first and last elements are not considered peaks. Return the sum of peaks for each test case. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the array size and the array elements. Returns: List[int]: List of sums of peaks for each test case. >>> find_peak_sum([(5, [1, 3, 2, 5, 4])]) [8] >>> find_peak_sum([(4, [4, 3, 2, 1])]) [0] >>> find_peak_sum([(5, [1, 2, 3, 2, 1])]) [3] def process_input(input_data): Process the input to utilize find_peak_sum function properly. Args: input_data (str): A single string input containing multiple lines of test case data. Returns: List[int]: Output for each test case in the input. Example use: input_data = \\"\\"\\"3 5 1 3 2 5 4 4 4 3 2 1 5 1 2 3 2 1\\"\\"\\" print(process_input(input_data)) # Expected output: [8, 0, 3] # Example Test Cases def test_find_peak_sum_case1(): assert find_peak_sum([(5, [1, 3, 2, 5, 4])]) == [8] def test_find_peak_sum_case2(): assert find_peak_sum([(4, [4, 3, 2, 1])]) == [0] def test_find_peak_sum_case3(): assert find_peak_sum([(5, [1, 2, 3, 2, 1])]) == [3] def test_find_peak_sum_no_peaks(): assert find_peak_sum([(6, [1, 2, 2, 2, 2, 1])]) == [0] def test_find_peak_sum_multiple_peaks(): assert find_peak_sum([(7, [1, 3, 1, 5, 1, 7, 1])]) == [15] def test_find_peak_sum_large_input(): assert find_peak_sum([(10, [1, 2, 3, 4, 5, 6, 5, 4, 3, 2])]) == [6] def test_find_peak_sum_multiple_cases(): assert find_peak_sum([ (5, [1, 3, 2, 5, 4]), (4, [4, 3, 2, 1]), (5, [1, 2, 3, 2, 1]) ]) == [8, 0, 3]","solution":"def find_peak_sum(test_cases): results = [] for case in test_cases: N, arr = case peak_sum = 0 for i in range(1, N - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peak_sum += arr[i] results.append(peak_sum) return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return find_peak_sum(test_cases) # Example use: input_data = 3 5 1 3 2 5 4 4 4 3 2 1 5 1 2 3 2 1 print(process_input(input_data)) # Expected output: [8, 0, 3]"},{"question":"from datetime import datetime from typing import List class DiaryEntries: def __init__(self): self.entries = [] def addEntry(self, entry: str, date: str, time: int) -> None: Adds an entry with the given date and time. def getEntriesByTimeRange(self, startDate: str, startTime: int, endDate: str, endTime: int) -> List[str]: Returns a list of entries between the specified start and end date/times. def test_addEntry(): diaryEntries = DiaryEntries() diaryEntries.addEntry(\\"Went jogging\\", \\"2023-04-01\\", 730) assert len(diaryEntries.entries) == 1 assert diaryEntries.entries[0][1] == \\"Went jogging\\" diaryEntries.addEntry(\\"Had breakfast\\", \\"2023-04-01\\", 800) assert len(diaryEntries.entries) == 2 assert diaryEntries.entries[1][1] == \\"Had breakfast\\" def test_getEntriesByTimeRange(): diaryEntries = DiaryEntries() diaryEntries.addEntry(\\"Went jogging\\", \\"2023-04-01\\", 730) diaryEntries.addEntry(\\"Had breakfast\\", \\"2023-04-01\\", 800) diaryEntries.addEntry(\\"Read a book\\", \\"2023-04-02\\", 900) result = diaryEntries.getEntriesByTimeRange(\\"2023-04-01\\", 700, \\"2023-04-01\\", 900) assert result == [\\"Went jogging\\", \\"Had breakfast\\"] result = diaryEntries.getEntriesByTimeRange(\\"2023-04-01\\", 700, \\"2023-04-02\\", 1000) assert result == [\\"Went jogging\\", \\"Had breakfast\\", \\"Read a book\\"] result = diaryEntries.getEntriesByTimeRange(\\"2023-04-01\\", 800, \\"2023-04-02\\", 1000) assert result == [\\"Had breakfast\\", \\"Read a book\\"]","solution":"from datetime import datetime class DiaryEntries: def __init__(self): self.entries = [] def addEntry(self, entry, date, time): Adds an entry with the given date and time. datetime_obj = datetime.strptime(f\\"{date} {time:04d}\\", '%Y-%m-%d %H%M') self.entries.append((datetime_obj, entry)) # Sort entries on the fly to keep them in chronological order self.entries.sort() def getEntriesByTimeRange(self, startDate, startTime, endDate, endTime): Returns a list of entries between the specified start and end date/times. start_datetime = datetime.strptime(f\\"{startDate} {startTime:04d}\\", '%Y-%m-%d %H%M') end_datetime = datetime.strptime(f\\"{endDate} {endTime:04d}\\", '%Y-%m-%d %H%M') result = [] for entry in self.entries: if start_datetime <= entry[0] <= end_datetime: result.append(entry[1]) return result"},{"question":"def find_missing_element(arr1, arr2): Returns the missing element from arr2 which is present in arr1. Parameters: arr1 (List[int]): The original array with all elements. arr2 (List[int]): The shuffled array with one element missing. Returns: int: The missing element. Examples: >>> find_missing_element([1, 2, 3], [3, 1]) 2 >>> find_missing_element([5, 6, 7, 8], [8, 5, 7]) 6","solution":"def find_missing_element(arr1, arr2): Returns the missing element from arr2 which is present in arr1. Parameters: arr1 (List[int]): The original array with all elements. arr2 (List[int]): The shuffled array with one element missing. Returns: int: The missing element. return sum(arr1) - sum(arr2)"},{"question":"def calculate_moving_average(sales, window_size): Calculate the moving average for each product over the specified window size. :param sales: Dictionary where keys are product names and values are lists of daily sales amounts. :param window_size: Integer representing the number of days over which to calculate the moving average. :return: Dictionary where keys are product names and values are lists of moving averages (rounded to 2 decimal places). >>> sales = {'ProductA': [10, 20, 30, 40, 50], 'ProductB': [5, 15, 25, 35, 45]} >>> window_size = 3 >>> calculate_moving_average(sales, window_size) {'ProductA': [20.00, 30.00, 40.00], 'ProductB': [15.00, 25.00, 35.00]} >>> sales = {'ProductA': [10, 20, 30], 'ProductB': [5, 10, 15]} >>> window_size = 1 >>> calculate_moving_average(sales, window_size) {'ProductA': [10.00, 20.00, 30.00], 'ProductB': [5.00, 10.00, 15.00]} >>> sales = {'ProductA': [10, 20, 30, 40, 50], 'ProductB': [5, 15, 25, 35, 45]} >>> window_size = 5 >>> calculate_moving_average(sales, window_size) {'ProductA': [30.00], 'ProductB': [25.00]} >>> sales = {'ProductA': [], 'ProductB': []} >>> window_size = 3 >>> calculate_moving_average(sales, window_size) {'ProductA': [], 'ProductB': []} >>> sales = {'ProductA': [10, 20, 30], 'ProductB': [5, 10]} >>> window_size = 4 >>> calculate_moving_average(sales, window_size) {'ProductA': [], 'ProductB': []}","solution":"def calculate_moving_average(sales, window_size): Calculate the moving average for each product over the specified window size. :param sales: Dictionary where keys are product names and values are lists of daily sales amounts. :param window_size: Integer representing the number of days over which to calculate the moving average. :return: Dictionary where keys are product names and values are lists of moving averages (rounded to 2 decimal places). moving_averages = {} for product, daily_sales in sales.items(): product_moving_averages = [] for i in range(len(daily_sales) - window_size + 1): window = daily_sales[i : i + window_size] average = sum(window) / window_size product_moving_averages.append(round(average, 2)) moving_averages[product] = product_moving_averages return moving_averages"},{"question":"def max_non_overlapping_routes(n, routes): Returns the maximum number of non-overlapping train routes with at least a 15-minute buffer. Parameters: n (int): The number of suggested routes. routes (list of tuples): A list of tuples where each tuple contains (S_i, E_i, T_i). - S_i is the start time in minutes from midnight. - E_i is the end time in minutes from midnight. - T_i is the total travel time in minutes. Returns: int: The maximum number of non-overlapping routes that can be scheduled with the required buffer. from solution import max_non_overlapping_routes def test_sample_case(): routes = [(60, 120, 60), (180, 240, 60), (150, 210, 60), (330, 390, 60), (300, 360, 60)] assert max_non_overlapping_routes(5, routes) == 3 def test_no_routes(): routes = [] assert max_non_overlapping_routes(0, routes) == 0 def test_all_overlapping_routes(): routes = [(0, 60, 60), (30, 90, 60), (15, 75, 60)] assert max_non_overlapping_routes(3, routes) == 1 def test_all_non_overlapping_routes(): routes = [(0, 50, 50), (65, 115, 50), (130, 180, 50), (195, 245, 50)] assert max_non_overlapping_routes(4, routes) == 4 def test_minimal_buffer_case(): routes = [(0, 60, 60), (75, 135, 60), (150, 210, 60)] assert max_non_overlapping_routes(3, routes) == 3","solution":"def max_non_overlapping_routes(n, routes): Returns the maximum number of non-overlapping train routes with at least a 15-minute buffer. Parameters: n (int): The number of suggested routes. routes (list of tuples): A list of tuples where each tuple contains (S_i, E_i, T_i). - S_i is the start time in minutes from midnight. - E_i is the end time in minutes from midnight. - T_i is the total travel time in minutes. Returns: int: The maximum number of non-overlapping routes that can be scheduled with the required buffer. # Sort the routes by their end times routes.sort(key=lambda x: x[1]) count = 0 last_end_time = -15 # Initializing with -15 so the first route can be selected without issues for start, end, _ in routes: if start >= last_end_time + 15: count += 1 last_end_time = end return count"},{"question":"from typing import List def topKFrequent(words: List[str], k: int) -> List[str]: Given an array of strings words and an integer k, return the k most frequent strings. >>> topKFrequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) [\\"i\\", \\"love\\"] >>> topKFrequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) [\\"the\\", \\"is\\", \\"sunny\\", \\"day\\"] >>> topKFrequent([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], 3) [\\"a\\", \\"b\\", \\"c\\"] >>> topKFrequent([\\"i\\", \\"love\\", \\"i\\", \\"love\\", \\"coding\\", \\"coding\\"], 2) [\\"coding\\", \\"i\\"] >>> topKFrequent([\\"hello\\"], 1) [\\"hello\\"] >>> topKFrequent([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\"], 2) [\\"a\\", \\"b\\"]","solution":"from collections import Counter def topKFrequent(words, k): Returns the k most frequent strings from the list words. If two words have the same frequency, the lexicographically smaller string comes first. # Count the frequency of each word count = Counter(words) # Sort the words by frequency and then lexicographically sorted_words = sorted(count.keys(), key=lambda word: (-count[word], word)) # Return the top k words return sorted_words[:k]"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Function to find the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"a\\") == 1 >>> longest_palindromic_subsequence(\\"ab\\") == 1 >>> longest_palindromic_subsequence(\\"aa\\") == 2 >>> longest_palindromic_subsequence(\\"racecar\\") == 7 >>> longest_palindromic_subsequence(\\"bbbab\\") == 4 >>> longest_palindromic_subsequence(\\"abcdef\\") == 1 >>> longest_palindromic_subsequence(\\"agbdba\\") == 5 >>> longest_palindromic_subsequence(\\"aaaa\\") == 4","solution":"def longest_palindromic_subsequence(s: str) -> int: Function to find the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def length_of_longest_substring(s: str) -> int: Find the length of the longest substring without repeating characters in a given string. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"abcbde\\") 4 >>> length_of_longest_substring(\\"tmmzuxt\\") 5","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is a prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(11) True def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(131) True >>> is_palindrome(1) True >>> is_palindrome(1234321) True def smallest_palindromic_prime(n: int) -> int: Return the smallest palindromic prime greater than or equal to n. >>> smallest_palindromic_prime(31) 101 >>> smallest_palindromic_prime(10) 11 >>> smallest_palindromic_prime(130) 131 >>> smallest_palindromic_prime(100) 101 >>> smallest_palindromic_prime(1) 2 >>> smallest_palindromic_prime(2) 2 >>> smallest_palindromic_prime(1000000) 1003001","solution":"def is_prime(num): Check if a number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_palindrome(num): Check if a number is a palindrome. return str(num) == str(num)[::-1] def smallest_palindromic_prime(n): Return the smallest palindromic prime greater than or equal to n. while True: if is_palindrome(n) and is_prime(n): return n n += 1"},{"question":"def is_balanced(s: str) -> str: Determines if the given string of parentheses is balanced. >>> is_balanced(\\"{[()]}\\") 'YES' >>> is_balanced(\\"{[(])}\\") 'NO' >>> is_balanced(\\"{{[[(())]]}}\\") 'YES' pass def check_balanced_parentheses(test_cases: List[str]) -> List[str]: For each testcase, output \\"YES\\" if the string is balanced, otherwise \\"NO\\". >>> check_balanced_parentheses([\\"{[()]}\\", \\"{[(])}\\", \\"{{[[(())]]}}\\"]) ['YES', 'NO', 'YES'] >>> check_balanced_parentheses([\\"()\\", \\"())\\"]) ['YES', 'NO'] pass","solution":"def is_balanced(s): Determines if the given string of parentheses is balanced. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def check_balanced_parentheses(test_cases): results = [] for s in test_cases: results.append(is_balanced(s)) return results"},{"question":"def largest_multiple_of_3(digits: str) -> str: You are given a string of digits (with no spaces) representing a large number and your task is to find the largest multiple of 3 that can be formed by removing zero or more digits from this number. If it's not possible to form such a multiple, return \`-1\`. Args: digits (str): A string of digits. Returns: str: The largest multiple of 3 that can be formed, or \`-1\`. Example: >>> largest_multiple_of_3(\\"8409371625\\") \\"9876543210\\" >>> largest_multiple_of_3(\\"102\\") \\"210\\" >>> largest_multiple_of_3(\\"123456\\") \\"654321\\" >>> largest_multiple_of_3(\\"222\\") \\"222\\" >>> largest_multiple_of_3(\\"1\\") \\"-1\\"","solution":"def largest_multiple_of_3(digits: str) -> str: from collections import Counter digit_count = Counter(digits) digits_sum = sum(int(d) for d in digits) mod = digits_sum % 3 if mod != 0: remainder_digits = [[], [], []] for digit in digits: remainder_digits[int(digit) % 3].append(digit) if mod == 1: if remainder_digits[1]: digit_to_remove = remainder_digits[1][0] digit_count[digit_to_remove] -= 1 else: if len(remainder_digits[2]) >= 2: digit_to_remove_1, digit_to_remove_2 = remainder_digits[2][:2] digit_count[digit_to_remove_1] -= 1 digit_count[digit_to_remove_2] -= 1 else: return \\"-1\\" elif mod == 2: if remainder_digits[2]: digit_to_remove = remainder_digits[2][0] digit_count[digit_to_remove] -= 1 else: if len(remainder_digits[1]) >= 2: digit_to_remove_1, digit_to_remove_2 = remainder_digits[1][:2] digit_count[digit_to_remove_1] -= 1 digit_count[digit_to_remove_2] -= 1 else: return \\"-1\\" result_digits = [] for digit in '9876543210': result_digits.extend([digit] * digit_count[digit]) if result_digits and result_digits[0] != '0': return ''.join(result_digits) elif result_digits: return \\"0\\" return \\"-1\\""},{"question":"def process_operations(n, m, operations): Alex has \`n\` containers, initially empty. He can perform \`m\` operations, each of one of these two types: 1. Fill all containers from index \`u\` to index \`v\` with \`k\` units of water. 2. Query the total amount of water in container \`p\` after the operations. Parameters: n (int): The number of containers. m (int): The number of operations. operations (list): A list of tuples representing the operations. Returns: list: A list containing the results of the query operations. Example: >>> process_operations(5, 4, [('Q', 2), ('A', 1, 3, 10), ('Q', 2), ('A', 2, 5, 5), ('Q', 4)]) [0, 10, 5] from solution import process_operations def test_example(): operations = [ ('Q', 2), ('A', 1, 3, 10), ('Q', 2), ('A', 2, 5, 5), ('Q', 4) ] result = process_operations(5, 4, operations) assert result == [0, 10, 5] def test_fill_entire_range(): operations = [ ('A', 1, 5, 10), ('Q', 1), ('Q', 2), ('Q', 3), ('Q', 4), ('Q', 5) ] result = process_operations(5, 6, operations) assert result == [10, 10, 10, 10, 10] def test_no_operations(): operations = [] result = process_operations(5, 0, operations) assert result == [] def test_complex_case(): operations = [ ('A', 1, 3, 10), ('A', 2, 5, 20), ('Q', 1), ('Q', 2), ('Q', 3), ('Q', 4), ('Q', 5) ] result = process_operations(5, 7, operations) assert result == [10, 30, 30, 20, 20] def test_one_container(): operations = [ ('A', 1, 1, 15), ('Q', 1) ] result = process_operations(1, 2, operations) assert result == [15]","solution":"def process_operations(n, m, operations): containers = [0] * (n + 1) results = [] for operation in operations: if operation[0] == 'A': _, u, v, k = operation containers[u - 1] += k if v < n: containers[v] -= k elif operation[0] == 'Q': _, p = operation total_water = 0 for i in range(p): total_water += containers[i] results.append(total_water) return results"},{"question":"def min_execution_time(test_cases): Determine the minimum execution time that is greater than or equal to M for each team. Parameters: test_cases (List[Tuple[int, int, List[int]]]): A list of test cases, where each test case is a tuple containing: - N (int): the number of tasks. - M (int): the minimum required execution time. - task_times (List[int]): a list of integers representing the execution times of each task. Returns: List[int]: A list of integers representing the minimum total execution time for each test case or -1 if it's not possible to reach the threshold. >>> min_execution_time([(5, 12, [1, 2, 3, 4, 5]), (4, 15, [8, 3, 5, 7])]) [12, 15] >>> min_execution_time([(3, 7, [2, 2, 2])]) [-1] >>> min_execution_time([(6, 10, [1, 1, 1, 1, 1, 10])]) [10] >>> min_execution_time([(3, 3, [1, 1, 1])]) [3] >>> min_execution_time([(3, 4, [2, 4, 6])]) [4] >>> min_execution_time([(5, 20, [3, 6, 9, 12, 15]), (4, 10, [1, 2, 2, 5]), (2, 5, [5, 3])]) [21, 10, 5] def process_input_output(raw_data): Parse input data, process each test case, and return the results. def parse_input(raw_data): Parse raw input data and return a list of test cases.","solution":"def min_execution_time(test_cases): from itertools import combinations results = [] for N, M, task_times in test_cases: possible_sums = set() for i in range(1, N + 1): for comb in combinations(task_times, i): total_time = sum(comb) if total_time >= M: possible_sums.add(total_time) if possible_sums: results.append(min(possible_sums)) else: results.append(-1) return results # Helper function to parse input data def parse_input(raw_data): lines = raw_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, M = map(int, lines[index].split()) task_times = list(map(int, lines[index + 1].split())) test_cases.append((N, M, task_times)) index += 2 return test_cases # Main function to process raw input and produce output def process_input_output(raw_data): test_cases = parse_input(raw_data) results = min_execution_time(test_cases) return 'n'.join(map(str, results))"},{"question":"from typing import List def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the top k most frequent words from the list \`words\`. If two words have the same frequency, the word with the higher alphabetical order comes first. >>> top_k_frequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) ['i', 'love'] >>> top_k_frequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) ['the', 'is', 'sunny', 'day'] >>> top_k_frequent([\\"a\\", \\"aa\\", \\"aaa\\"], 2) ['a', 'aa'] pass","solution":"from collections import Counter import heapq def top_k_frequent(words, k): Returns the top k most frequent words from the list \`words\`. If two words have the same frequency, the word with the higher alphabetical order comes first. count = Counter(words) heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) result = [] for _ in range(k): result.append(heapq.heappop(heap)[1]) return result"},{"question":"def longest_contiguous_subarray(arr): Function to find the length of the longest contiguous subarray where there is at most one pair of elements such that the second element is greater than the first one. >>> longest_contiguous_subarray([1, 3, 5, 4, 2]) 4 >>> longest_contiguous_subarray([2, 2, 2, 2]) 4 pass def test_no_increasing_pairs(): assert longest_contiguous_subarray([2, 2, 2, 2]) == 4 def test_single_increasing_pair(): assert longest_contiguous_subarray([1, 3, 5, 4, 2]) == 4 def test_multiple_increasing_pairs(): assert longest_contiguous_subarray([1, 2, 3, 1, 2, 3]) == 3 def test_all_elements_increasing(): assert longest_contiguous_subarray([1, 2, 3, 4, 5]) == 2 def test_empty_array(): assert longest_contiguous_subarray([]) == 0 def test_single_element(): assert longest_contiguous_subarray([1]) == 1 def test_two_elements_increasing(): assert longest_contiguous_subarray([1, 2]) == 2 def test_two_elements_decreasing(): assert longest_contiguous_subarray([2, 1]) == 2","solution":"def longest_contiguous_subarray(arr): Function to find the length of the longest contiguous subarray where there is at most one pair of elements such that the second element is greater than the first one. max_length = 0 start = 0 n = len(arr) while start < n: count_increasing_pairs = 0 end = start while end < n - 1: if arr[end] < arr[end + 1]: if count_increasing_pairs == 0: count_increasing_pairs += 1 else: break end += 1 max_length = max(max_length, end - start + 1) start += 1 return max_length"},{"question":"def collatz_sequence_length(n: int) -> int: Returns the length of the Collatz sequence starting from n. >>> collatz_sequence_length(1) 1 >>> collatz_sequence_length(6) 9 >>> collatz_sequence_length(19) 21 >>> collatz_sequence_length(27) 112 >>> collatz_sequence_length(837799) 525 >>> collatz_sequence_length(10) 7 >>> collatz_sequence_length(2) 2 >>> collatz_sequence_length(1000000) 153","solution":"def collatz_sequence_length(n: int) -> int: Returns the length of the Collatz sequence starting from n. length = 1 # Start with 1 because we count the starting number itself while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, return a list such that each element at index \`i\` from the original list is substituted by the product of all other elements present in the list except the element at \`i\`. Constraints: - You should complete this in O(N) time complexity. - Do not use division in your solution. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, -3, 3]) [-9, 9, -3, 3] >>> product_except_self([5, 6, 2, 3]) [36, 30, 90, 60]","solution":"def product_except_self(nums): Given a list of integers, returns a list where each element is the product of all elements in the original list except the one at the same index. n = len(nums) result = [1] * n # Step 1: Compute left products left_product = 1 for i in range(n): result[i] = left_product left_product *= nums[i] # Step 2: Compute right products and final result right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def sortNamesAndAges(s: str) -> str: Given a string containing comma-separated values of names and ages, sort the values first by names lexicographically and then by ages numerically. :param s: str - input string containing names and ages :return: str - sorted string >>> sortNamesAndAges(\\"Alice,30;Bob,25;Charlie,20\\") == \\"Alice,30;Bob,25;Charlie,20\\" >>> sortNamesAndAges(\\"Jane,45;Jake,30;Jake,25;Mike,35\\") == \\"Jake,25;Jake,30;Jane,45;Mike,35\\" >>> sortNamesAndAges(\\"Zack,30;Zack,25;Zack,20\\") == \\"Zack,20;Zack,25;Zack,30\\" >>> sortNamesAndAges(\\"Charlie,20;Bob,25;Alice,30\\") == \\"Alice,30;Bob,25;Charlie,20\\" >>> sortNamesAndAges(\\"Eve,40\\") == \\"Eve,40\\" >>> sortNamesAndAges(\\"Tom,50;Jerry,70;Jerry,60;Tom,40\\") == \\"Jerry,60;Jerry,70;Tom,40;Tom,50\\"","solution":"def sortNamesAndAges(s): Given a string containing comma-separated values of names and ages, sort the values first by names lexicographically and then by ages numerically. :param s: str - input string containing names and ages :return: str - sorted string entries = s.split(';') parsed_entries = [(entry.split(',')[0], int(entry.split(',')[1])) for entry in entries] sorted_entries = sorted(parsed_entries, key=lambda x: (x[0], x[1])) sorted_entries_str = [f\\"{name},{age}\\" for name, age in sorted_entries] return ';'.join(sorted_entries_str)"},{"question":"class Animal: def __init__(self, species: str, age: int, weight: int): Initialize an Animal instance. :param species: str, the species of the animal :param age: int, the age of the animal :param weight: int, the weight of the animal in kilograms self.species = species self.age = age self.weight = weight def eat(self, food_weight: int): Increase the weight of the animal by the given food weight. :param food_weight: int, the amount of food weight to be added to the animal's weight pass def birthday(self): Increase the age of the animal by 1. pass class WildlifePreserve: def __init__(self, name: str): Initialize a WildlifePreserve instance. :param name: str, the name of the wildlife preserve self.name = name self.animals = [] def add_animal(self, animal: Animal): Add an animal to the preserve. :param animal: Animal, an instance of the Animal class pass def feed_animals(self, food_weight: int): Feed each animal in the preserve, increasing their weight by the given food weight. :param food_weight: int, the amount of food weight to feed each animal pass # Example usage: if __name__ == \\"__main__\\": # Creating the wildlife preserve preserve = WildlifePreserve(\\"Sunny Reserve\\") # Creating animal instances lion = Animal(\\"Lion\\", 5, 190) elephant = Animal(\\"Elephant\\", 10, 5000) giraffe = Animal(\\"Giraffe\\", 7, 800) # Adding animals to the preserve preserve.add_animal(lion) preserve.add_animal(elephant) preserve.add_animal(giraffe) # Feeding all animals in the preserve preserve.feed_animals(10) # Printing out details of the animals after feeding for animal in preserve.animals: print(f\\"{animal.species} - Age: {animal.age}, Weight: {animal.weight}\\")","solution":"class Animal: def __init__(self, species, age, weight): Initialize an Animal instance. :param species: str, the species of the animal :param age: int, the age of the animal :param weight: int, the weight of the animal in kilograms self.species = species self.age = age self.weight = weight def eat(self, food_weight): Increase the weight of the animal by the given food weight. :param food_weight: int, the amount of food weight to be added to the animal's weight self.weight += food_weight def birthday(self): Increase the age of the animal by 1. self.age += 1 class WildlifePreserve: def __init__(self, name): Initialize a WildlifePreserve instance. :param name: str, the name of the wildlife preserve self.name = name self.animals = [] def add_animal(self, animal): Add an animal to the preserve. :param animal: Animal, an instance of the Animal class self.animals.append(animal) def feed_animals(self, food_weight): Feed each animal in the preserve, increasing their weight by the given food weight. :param food_weight: int, the amount of food weight to feed each animal for animal in self.animals: animal.eat(food_weight)"},{"question":"from typing import List def letter_combinations(digits: str) -> List[str]: Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the digits could represent based on the classic telephone keypad. >>> sorted(letter_combinations(\\"23\\")) ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> letter_combinations(\\"\\") [] >>> sorted(letter_combinations(\\"2\\")) ['a', 'b', 'c'] >>> sorted(letter_combinations(\\"234\\")) ['adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi'] >>> sorted(letter_combinations(\\"79\\")) ['pw', 'px', 'py', 'pz', 'qw', 'qx', 'qy', 'qz', 'rw', 'rx', 'ry', 'rz', 'sw', 'sx', 'sy', 'sz']","solution":"def letter_combinations(digits): Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the digits could represent based on the classic telephone keypad. if not digits: return [] phone_map = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(combination, next_digits): if not next_digits: combinations.append(combination) else: for letter in phone_map[next_digits[0]]: backtrack(combination + letter, next_digits[1:]) combinations = [] backtrack(\\"\\", digits) return combinations"},{"question":"def rename_images(T: int, test_cases: list) -> list: Rename images based on pixel intensity values and their counts. Parameters: T (int): Number of test cases. test_cases (list): A list where each element is a tuple containing an integer N (number of intensity values) and a list of N integers representing the intensity values. Returns: list: A list of strings where each string is the concatenated representation of intensity values and their counts in non-decreasing order of counts and increasing order of intensity values. Example: >>> rename_images(2, [(5, [0, 0, 1, 2, 2]), (8, [5, 5, 5, 255, 255, 255, 255, 255])]) ['I0x2I1x1I2x2', 'I5x3I255x5'] >>> rename_images(1, [(4, [3, 3, 3, 3])]) ['I3x4'] # Your code here from solution import rename_images def test_rename_images_sample_input(): T = 2 test_cases = [ (5, [0, 0, 1, 2, 2]), (8, [5, 5, 5, 255, 255, 255, 255, 255]) ] expected_output = ['I0x2I1x1I2x2', 'I5x3I255x5'] assert rename_images(T, test_cases) == expected_output def test_single_intensity_multiple_occurrences(): T = 1 test_cases = [ (4, [3, 3, 3, 3]) ] expected_output = ['I3x4'] assert rename_images(T, test_cases) == expected_output def test_all_different_intensities(): T = 1 test_cases = [ (4, [0, 1, 2, 3]) ] expected_output = ['I0x1I1x1I2x1I3x1'] assert rename_images(T, test_cases) == expected_output def test_spread_intensities(): T = 1 test_cases = [ (7, [0, 50, 100, 150, 200, 255, 255]) ] expected_output = ['I0x1I50x1I100x1I150x1I200x1I255x2'] assert rename_images(T, test_cases) == expected_output def test_large_input(): import random T = 1 case = [100000, [random.randint(0, 255) for _ in range(100000)]] assert len(rename_images(T, [case])) == 1 # Just checking if the function runs and returns something","solution":"def rename_images(T: int, test_cases: list) -> list: results = [] for case in test_cases: N = case[0] intensities = case[1] # Counting occurrences of each intensity value intensity_count = {} for intensity in intensities: if intensity in intensity_count: intensity_count[intensity] += 1 else: intensity_count[intensity] = 1 # Sorting and forming the result string sorted_intensity_count = sorted(intensity_count.items()) result = ''.join([f'I{intensity}x{count}' for intensity, count in sorted_intensity_count]) results.append(result) return results"},{"question":"def fibonacci_stars(n: int) -> list: Write a function that takes an integer n and returns a list where each element is a string that represents one of the first n Fibonacci numbers. Each Fibonacci string should have a length equal to the number of digits in the Fibonacci number, and should contain only the character '*'. The order of the Fibonacci numbers should be preserved in the output list. >>> fibonacci_stars(5) [\\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"*\\"] >>> fibonacci_stars(7) [\\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"**\\"] >>> fibonacci_stars(10) [\\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"*\\", \\"**\\", \\"**\\", \\"**\\", \\"**\\"]","solution":"def fibonacci_stars(n): Returns a list of strings where each string represents one of the first n Fibonacci numbers using '*' characters. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: list of str: A list of strings representing the first n Fibonacci numbers with the length equal to the number of digits in the number. if n <= 0: return [] # Generate the first n Fibonacci numbers fibs = [1, 1] for i in range(2, n): fibs.append(fibs[-1] + fibs[-2]) # Convert Fibonacci numbers to the desired string format result = [] for num in fibs[:n]: result.append('*' * len(str(num))) return result"},{"question":"from typing import List, Dict, Union def compress_image(image: List[str]) -> List[Dict[str, Union[str, int]]]: Implement a function to perform image compression using Run-Length Encoding (RLE). The input to your function will be a string representation of a binary image, where '1' represents a black pixel and '0' represents a white pixel. The image will be provided as a list of strings, where each string represents one row of the image. Your function should compress the image using RLE, such that consecutive sequences of the same pixel value are represented by a single instance of that value followed by the count of occurrences. The output should be a list of dictionaries, each dictionary representing the RLE compressed version of a row. Example: >>> compress_image([ ... \\"111000\\", ... \\"110011\\", ... \\"001111\\", ... \\"000000\\" ... ]) [ [{'1': 3}, {'0': 3}], [{'1': 2}, {'0': 2}, {'1': 2}], [{'0': 2}, {'1': 4}], [{'0': 6}] ] def test_compress_image_basic(): image = [ \\"111000\\", \\"110011\\", \\"001111\\", \\"000000\\" ] expected = [ [{'1': 3}, {'0': 3}], [{'1': 2}, {'0': 2}, {'1': 2}], [{'0': 2}, {'1': 4}], [{'0': 6}] ] assert compress_image(image) == expected def test_compress_image_single_row(): image = [\\"1111100000\\"] expected = [ [{'1': 5}, {'0': 5}] ] assert compress_image(image) == expected def test_compress_image_all_zeros(): image = [\\"0000\\", \\"0000\\"] expected = [ [{'0': 4}], [{'0': 4}] ] assert compress_image(image) == expected def test_compress_image_all_ones(): image = [\\"1111\\", \\"1111\\"] expected = [ [{'1': 4}], [{'1': 4}] ] assert compress_image(image) == expected def test_compress_image_mixed(): image = [\\"101010\\", \\"010101\\"] expected = [ [{'1': 1}, {'0': 1}, {'1': 1}, {'0': 1}, {'1': 1}, {'0': 1}], [{'0': 1}, {'1': 1}, {'0': 1}, {'1': 1}, {'0': 1}, {'1': 1}] ] assert compress_image(image) == expected","solution":"from typing import List, Dict, Union def compress_image(image: List[str]) -> List[Dict[str, Union[str, int]]]: result = [] for row in image: compressed_row = [] current_char = row[0] current_count = 1 for char in row[1:]: if char == current_char: current_count += 1 else: compressed_row.append({current_char: current_count}) current_char = char current_count = 1 compressed_row.append({current_char: current_count}) result.append(compressed_row) return result"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left to the bottom-right of an m x n grid. Examples: >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(3, 3) 6 >>> unique_paths(1, 1) 1 >>> unique_paths(1, 100) 1 >>> unique_paths(100, 1) 1 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left to the bottom-right of an m x n grid. dp = [[1] * n for _ in range(m)] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def employee_of_the_month(scores: dict[str, int]) -> str: Returns the name of the employee with the highest performance score. In case of a tie, returns the name that comes first in alphabetical order. Args: scores (dict): A dictionary with employee names as keys and their performance scores as values. Returns: str: The name of the employee with the highest performance score. Examples: >>> scores = {'Alice': 88, 'Bob': 95, 'Charlie': 95, 'Diana': 80} >>> employee_of_the_month(scores) 'Bob' >>> scores = {'Alice': 88, 'Bob': 88, 'Charlie': 88} >>> employee_of_the_month(scores) 'Alice'","solution":"def employee_of_the_month(scores: dict[str, int]) -> str: Returns the name of the employee with the highest performance score. In case of a tie, returns the name that comes first in alphabetical order. # Find the maximum score max_score = max(scores.values()) # Filter out the employees who have this maximum score top_candidates = [name for name, score in scores.items() if score == max_score] # Return the alphabetically first name among top candidates return min(top_candidates)"},{"question":"def hotelPicker(hotelsStayed: List[str], hotelsRecommended: List[str]) -> str: Returns the name of a recommended hotel that Lucy hasn't stayed at before. If all recommended hotels have been stayed at, returns 'No new hotels available!'. >>> hotelPicker([\\"Hilton\\", \\"Marriott\\", \\"Sheraton\\"], [\\"Marriott\\", \\"Westin\\", \\"Hilton\\", \\"Radisson\\"]) 'Westin' >>> hotelPicker([\\"Hilton\\", \\"Marriott\\", \\"Sheraton\\"], [\\"Marriott\\", \\"Hilton\\", \\"Sheraton\\"]) 'No new hotels available!'","solution":"def hotelPicker(hotelsStayed, hotelsRecommended): Returns the name of a recommended hotel that Lucy hasn't stayed at before. If all recommended hotels have been stayed at, returns 'No new hotels available!'. for hotel in hotelsRecommended: if hotel not in hotelsStayed: return hotel return 'No new hotels available!'"},{"question":"def restocking_alert(inventory, threshold): Returns a list of product names that require restocking. A product requires restocking if its quantity is less than or equal to the threshold value. Parameters: inventory (dict): A dictionary where keys are product names (strings) and values are quantities (integers). threshold (int): The threshold quantity for restocking. Returns: list: A list of product names that require restocking, in alphabetical order. pass # Unit Tests def test_restocking_alert_no_restocking_needed(): inventory = {\\"pencils\\": 12, \\"notebooks\\": 10, \\"erasers\\": 6, \\"markers\\": 7, \\"paper_clips\\": 8} threshold = 5 assert restocking_alert(inventory, threshold) == [] def test_restocking_alert_some_restocking_needed(): inventory = {\\"pencils\\": 4, \\"notebooks\\": 5, \\"erasers\\": 6, \\"markers\\": 1, \\"paper_clips\\": 2} threshold = 5 assert restocking_alert(inventory, threshold) == [\\"markers\\", \\"notebooks\\", \\"paper_clips\\", \\"pencils\\"] def test_restocking_alert_all_restocking_needed(): inventory = {\\"pencils\\": 2, \\"notebooks\\": 1, \\"erasers\\": 3, \\"markers\\": 2, \\"paper_clips\\": 1} threshold = 5 assert restocking_alert(inventory, threshold) == [\\"erasers\\", \\"markers\\", \\"notebooks\\", \\"paper_clips\\", \\"pencils\\"] def test_restocking_alert_empty_inventory(): inventory = {} threshold = 5 assert restocking_alert(inventory, threshold) == [] def test_restocking_alert_threshold_zero(): inventory = {\\"pencils\\": 0, \\"notebooks\\": 0, \\"erasers\\": 3, \\"markers\\": 4, \\"paper_clips\\": 0} threshold = 0 assert restocking_alert(inventory, threshold) == [\\"notebooks\\", \\"paper_clips\\", \\"pencils\\"]","solution":"def restocking_alert(inventory, threshold): Returns a list of product names that require restocking. A product requires restocking if its quantity is less than or equal to the threshold value. Parameters: inventory (dict): A dictionary where keys are product names (strings) and values are quantities (integers). threshold (int): The threshold quantity for restocking. Returns: list: A list of product names that require restocking, in alphabetical order. # Filter products that need restocking and sort them alphabetically return sorted([product for product in inventory if inventory[product] <= threshold])"},{"question":"from typing import List, Tuple def is_path_with_weight(N: int, M: int, edges: List[Tuple[int, int, int]], K: int) -> str: Determine if there is a path from node 1 to node N in which the sum of the weights is equal to a given integer K. Parameters: N (int): Number of nodes in the graph M (int): Number of edges in the graph edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w) K (int): The target sum for the path's length Returns: str: \\"YES\\" if there exists a path with total weight equal to K, otherwise \\"NO\\" Examples: >>> is_path_with_weight(4, 4, [(1, 2, 100), (2, 3, 200), (3, 4, 300), (1, 3, 400)], 600) \\"YES\\" >>> is_path_with_weight(3, 3, [(1, 2, 100), (2, 3, 200), (1, 3, 500)], 300) \\"YES\\" >>> is_path_with_weight(4, 4, [(1, 2, 100), (2, 3, 200), (3, 4, 300), (1, 3, 400)], 100) \\"NO\\" >>> is_path_with_weight(5, 3, [(1, 2, 100), (2, 3, 200), (4, 5, 50)], 300) \\"NO\\" >>> is_path_with_weight(2, 1, [(1, 2, 100)], 100) \\"YES\\" pass","solution":"from collections import defaultdict, deque def is_path_with_weight(N, M, edges, K): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) def bfs(): queue = deque([(1, 0)]) # (node, current_sum) visited = {1: {0}} while queue: node, current_sum = queue.popleft() for neighbor, weight in graph[node]: new_sum = current_sum + weight if new_sum == K and neighbor == N: return 'YES' if new_sum < K and (neighbor not in visited or new_sum not in visited[neighbor]): if neighbor not in visited: visited[neighbor] = set() visited[neighbor].add(new_sum) queue.append((neighbor, new_sum)) return 'NO' return bfs()"},{"question":"def sort_books_by_thickness(test_cases): This function receives a list of test cases where each test case contains a list of book thicknesses. It returns a sorted list of thicknesses for each test case. def process_input(input_string): Process the input string to create the list of test cases. def format_output(results): Format the sorted thickness lists into the required output string format. def main(input_string): Given an input string representing multiple test cases, process the input, sort the books by thickness for each test case, and format the output. from your_module import main, process_input, format_output, sort_books_by_thickness def test_process_input(): input_string = \\"2n5n10 3 5 8 1n3n4 4 2\\" expected_output = [[10, 3, 5, 8, 1], [4, 4, 2]] assert process_input(input_string) == expected_output def test_format_output(): sorted_books = [[1, 3, 5, 8, 10], [2, 4, 4]] expected_output = \\"1 3 5 8 10n2 4 4\\" assert format_output(sorted_books) == expected_output def test_sort_books_by_thickness(): test_cases = [[10, 3, 5, 8, 1], [4, 4, 2]] expected_output = [[1, 3, 5, 8, 10], [2, 4, 4]] assert sort_books_by_thickness(test_cases) == expected_output def test_main(): input_string = \\"2n5n10 3 5 8 1n3n4 4 2\\" expected_output = \\"1 3 5 8 10n2 4 4\\" assert main(input_string) == expected_output","solution":"def sort_books_by_thickness(test_cases): This function receives a list of test cases where each test case contains a list of book thicknesses. It returns a sorted list of thicknesses for each test case. result = [] for case in test_cases: sorted_case = sorted(case) result.append(sorted_case) return result def process_input(input_string): Process the input string to create the list of test cases. lines = input_string.strip().split('n') num_cases = int(lines[0]) cases = [] index = 1 for _ in range(num_cases): n = int(lines[index]) thicknesses = list(map(int, lines[index + 1].split())) cases.append(thicknesses) index += 2 return cases def format_output(results): Format the sorted thickness lists into the required output string format. output_lines = [' '.join(map(str, res)) for res in results] return 'n'.join(output_lines) def main(input_string): test_cases = process_input(input_string) sorted_books = sort_books_by_thickness(test_cases) return format_output(sorted_books)"},{"question":"def uniquePaths(grid: List[List[int]]) -> int: Given a grid of size m x n with obstacles, determine the total number of unique paths for a robot from the top-left corner to the bottom-right corner. The grid contains obstacles marked by '1' and free spaces marked by '0'. The robot can only move either down or right at any point in time. >>> uniquePaths([[0, 0, 0],[0, 1, 0],[0, 0, 0]]) == 2 >>> uniquePaths([[0, 0, 0],[0, 0, 0],[0, 0, 0]]) == 6 >>> uniquePaths([[1, 0, 0],[0, 0, 0],[0, 0, 0]]) == 0 >>> uniquePaths([[0, 0, 0],[0, 0, 0],[0, 0, 1]]) == 0 >>> uniquePaths([[0]]) == 1 >>> uniquePaths([[0, 1],[1, 0]]) == 0 >>> uniquePaths([[0, 0, 1],[1, 0, 0],[0, 0, 0]]) == 2","solution":"def uniquePaths(grid): Function to calculate the number of unique paths in a grid with obstacles. The robot starts at the top-left corner and must reach the bottom-right corner, moving only down or right. m = len(grid) n = len(grid[0]) # If the starting point or the ending point is an obstacle, no paths are possible if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a DP table to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def make_palindrome(s: str) -> str: Remove the minimum number of characters to make the string a palindrome. The resulting palindrome does not need to be the longest possible one; any valid palindrome will suffice. :param s: A string consisting of lowercase alphabetic characters. :return: A palindrome derived from s by removing the minimum number of characters. >>> make_palindrome(\\"abca\\") in [\\"aca\\", \\"aba\\"] True >>> make_palindrome(\\"racecarx\\") \\"racecar\\" >>> make_palindrome(\\"a\\") == \\"a\\"","solution":"def make_palindrome(s): Remove the minimum number of characters to make the string a palindrome. The resulting palindrome does not need to be the longest possible one; any valid palindrome will suffice. :param s: A string consisting of lowercase alphabetic characters. :return: A palindrome derived from s by removing the minimum number of characters. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s for i in range(len(s)): temp = s[:i] + s[i+1:] if is_palindrome(temp): return temp # If no palindrome found by removing just one character, return the first character return s[0] if s else \\"\\""},{"question":"def segregate_even_odd(nums): Reorder the array so that all even numbers come before all odd numbers. :param nums: List[int] - input array of integers :return: List[int] - reordered array with even numbers first, odd numbers follow >>> segregate_even_odd([3, 1, 2, 4]) in [[4, 2, 1, 3], [2, 4, 1, 3], [4, 2, 3, 1], [2, 4, 3, 1]] True >>> segregate_even_odd([0]) [0] >>> segregate_even_odd([2, 4, 6, 8]) [2, 4, 6, 8] >>> segregate_even_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> segregate_even_odd([2, 3, 4, 1, 6]) in [[2, 6, 4, 1, 3], [4, 6, 2, 1, 3], [6, 2, 4, 1, 3], [2, 4, 6, 1, 3]] True >>> segregate_even_odd([1, 2, 3, 4, 5, 6, 7, 8]) in [[8, 2, 6, 4, 5, 3, 7, 1], [2, 4, 6, 8, 7, 5, 3, 1], [8, 6, 4, 2, 1, 3, 5, 7]] True >>> segregate_even_odd([]) [] >>> segregate_even_odd([3]) [3] >>> segregate_even_odd([2]) [2]","solution":"def segregate_even_odd(nums): Reorder the array so that all even numbers come before all odd numbers. :param nums: List[int] - input array of integers :return: List[int] - reordered array with even numbers first, odd numbers follow left = 0 right = len(nums) - 1 while left < right: # Increment left index until we find an odd number while left < right and nums[left] % 2 == 0: left += 1 # Decrement right index until we find an even number while left < right and nums[right] % 2 != 0: right -= 1 # Swap the two numbers if left < right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 return nums"},{"question":"def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a list of unique elements that are present in both list1 and list2. The elements are returned in the order they appear in list1. >>> common_elements([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) [4, 5] >>> common_elements([], []) [] >>> common_elements([], [1, 2, 3]) [] >>> common_elements([1, 2, 3], []) [] >>> common_elements([1, 2, 3], [4, 5, 6]) [] >>> common_elements([1, 2, 3, 4, 5], [4, 4, 5, 5, 6, 7, 8]) [4, 5] >>> common_elements([1, 2, 2, 3, 4, 5, 5], [4, 5, 6, 6, 7, 8]) [4, 5] >>> common_elements([1, 2, 2, 3, 4, 4, 5], [4, 4, 5, 5, 6, 7, 8]) [4, 5]","solution":"def common_elements(list1, list2): Returns a list of unique elements that are present in both list1 and list2. The elements are returned in the order they appear in list1. set_list2 = set(list2) result = [] seen = set() for elem in list1: if elem in set_list2 and elem not in seen: result.append(elem) seen.add(elem) return result"},{"question":"def rotate_string(s: str, k: int) -> str: Rotate the string \`s\` to the right by \`k\` characters. >>> rotate_string(\\"abcdef\\", 2) \\"efabcd\\" >>> rotate_string(\\"helloworld\\", 15) \\"worldhello\\"","solution":"def rotate_string(s, k): Rotate the string \`s\` to the right by \`k\` characters. n = len(s) k = k % n # To handle cases where k >= n return s[-k:] + s[:-k]"},{"question":"from typing import List class SocialMediaComments: def __init__(self, postId: str): Initializes an object for managing comments for a post identified by postId. pass def addComment(self, commentId: str, parentId: str, content: str) -> None: Adds a comment with commentId and content. If parentId is null, the comment is a top-level comment. Otherwise, the comment is a reply to the comment identified by parentId. Args: commentId (str): The unique identifier for the comment. parentId (str): The unique identifier for the parent comment to which this comment is a reply. content (str): The content of the comment. pass def deleteComment(self, commentId: str) -> None: Marks the comment with commentId as deleted. Args: commentId (str): The unique identifier for the comment. pass def getComments(self) -> List[str]: Returns a list of all visible comments for the post in a flattened structure, preserving the hierarchical relationships. Returns: List[str]: Flattened list of comments, omitting deleted comments. pass if __name__ == \\"__main__\\": # Example usage post = SocialMediaComments(\\"post1\\") post.addComment(\\"c1\\", None, \\"This is the first comment.\\") post.addComment(\\"c2\\", None, \\"This is another top-level comment.\\") post.addComment(\\"c3\\", \\"c1\\", \\"This is a reply to the first comment.\\") post.addComment(\\"c4\\", \\"c3\\", \\"This is a nested reply.\\") print(post.getComments()) post.deleteComment(\\"c3\\") print(post.getComments())","solution":"from typing import List class Comment: def __init__(self, commentId: str, content: str): self.commentId = commentId self.content = content self.replies = [] self.isDeleted = False class SocialMediaComments: def __init__(self, postId: str): self.postId = postId self.comments = {} self.topLevelComments = [] def addComment(self, commentId: str, parentId: str, content: str) -> None: newComment = Comment(commentId, content) self.comments[commentId] = newComment if parentId is None: self.topLevelComments.append(newComment) else: if parentId in self.comments: self.comments[parentId].replies.append(newComment) def deleteComment(self, commentId: str) -> None: if commentId in self.comments: self.comments[commentId].isDeleted = True def getComments(self) -> List[str]: result = [] def traverseComments(comment): if not comment.isDeleted: result.append(f\\"{comment.commentId}: {comment.content}\\") for reply in comment.replies: traverseComments(reply) for comment in self.topLevelComments: traverseComments(comment) return result"},{"question":"def sort_negatives_before_positives(lst: List[int]) -> List[int]: Takes a list of integers and returns the list sorted in ascending order. All negative numbers should appear before any positive numbers without changing the relative order of negative and positive numbers. >>> sort_negatives_before_positives([3, -2, -1, 5, -4, 7, 8, -6]) == [-2, -1, -4, -6, 3, 5, 7, 8] >>> sort_negatives_before_positives([4, -3, 2, -1, 0, -5, 7]) == [-3, -1, -5, 4, 2, 0, 7] >>> sort_negatives_before_positives([]) == [] >>> sort_negatives_before_positives([1, 2, 3, 4]) == [1, 2, 3, 4] >>> sort_negatives_before_positives([-4, -3, -2, -1]) == [-4, -3, -2, -1] >>> sort_negatives_before_positives([-1, -4, -3, 2, 0, 3]) == [-1, -4, -3, 2, 0, 3] # Your code here","solution":"def sort_negatives_before_positives(lst): Returns a list sorted in ascending order with all negative numbers appearing before any positive numbers without changing the relative order of negative and positive numbers. negatives = [x for x in lst if x < 0] non_negatives = [x for x in lst if x >= 0] return negatives + non_negatives"},{"question":"def format_duration(seconds: int) -> str: Convert a duration given in seconds into a human-readable string format in years, days, hours, minutes, and seconds. >>> format_duration(62) --> \\"1 minute and 2 seconds\\" >>> format_duration(3662) --> \\"1 hour, 1 minute and 2 seconds\\"","solution":"def format_duration(seconds): if seconds == 0: return \\"now\\" years, seconds = divmod(seconds, 365 * 24 * 60 * 60) days, seconds = divmod(seconds, 24 * 60 * 60) hours, seconds = divmod(seconds, 60 * 60) minutes, seconds = divmod(seconds, 60) time_parts = [] if years > 0: time_parts.append(f\\"{years} year\\" + (\\"s\\" if years != 1 else \\"\\")) if days > 0: time_parts.append(f\\"{days} day\\" + (\\"s\\" if days != 1 else \\"\\")) if hours > 0: time_parts.append(f\\"{hours} hour\\" + (\\"s\\" if hours != 1 else \\"\\")) if minutes > 0: time_parts.append(f\\"{minutes} minute\\" + (\\"s\\" if minutes != 1 else \\"\\")) if seconds > 0: time_parts.append(f\\"{seconds} second\\" + (\\"s\\" if seconds != 1 else \\"\\")) if len(time_parts) == 1: return time_parts[0] return \\", \\".join(time_parts[:-1]) + \\" and \\" + time_parts[-1]"},{"question":"def is_path_exist(N: int, M: int, grid: List[str]) -> str: Determine whether there exists a path from the start point (0, 0) to the treasure (N-1, M-1) on a grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): Grid representing the city where '.' is an empty cell and '#' is an obstacle. Returns: str: \\"YES\\" if there is a path from the start point to the treasure, otherwise \\"NO\\". Example: >>> is_path_exist(5, 5, [\\".....\\", \\"..#..\\", \\".#...\\", \\"..#..\\", \\".....\\"]) \\"YES\\" >>> is_path_exist(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) \\"NO\\"","solution":"def is_path_exist(N, M, grid): from collections import deque if grid[0][0] == '#' or grid[N-1][M-1] == '#': return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = [[False] * M for _ in range(N)] visited[0][0] = True while queue: x, y = queue.popleft() if x == N-1 and y == M-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def will_robots_collide(x1, y1, vx1, vy1, x2, y2, vx2, vy2, t): Determines if two robots will collide at a specific time t. Args: x1, y1: Initial position of the first robot. vx1, vy1: Velocity of the first robot along the X and Y axes per time unit. x2, y2: Initial position of the second robot. vx2, vy2: Velocity of the second robot along the X and Y axes per time unit. t: The specific time. Returns: True if the robots will collide at time t, False otherwise. >>> will_robots_collide(0, 0, 1, 1, 10, 10, -1, -1, 1) False >>> will_robots_collide(0, 0, 2, 3, 1, 1, 3, 2, 0) False >>> will_robots_collide(0, 0, 1, 1, 0, 0, -1, -1, 0) True >>> will_robots_collide(5, 5, 0, 0, 5, 5, 0, 0, 0) True >>> will_robots_collide(0, 0, 1, 1, 1, 1, 0, 0, 1) True >>> will_robots_collide(0, 0, 1, 0, 10, 0, 0, 0, 10) True >>> will_robots_collide(2, 3, 2, 1, 4, 4, 0, 0, 1) True >>> will_robots_collide(0, 0, 0, 0, 10, 10, 1, 1, 1) False >>> will_robots_collide(0, 0, 0, 0, 0, 0, 0, 0, 10) True","solution":"def will_robots_collide(x1, y1, vx1, vy1, x2, y2, vx2, vy2, t): Determines if two robots will collide at a specific time t. Args: x1, y1: Initial position of the first robot. vx1, vy1: Velocity of the first robot along the X and Y axes per time unit. x2, y2: Initial position of the second robot. vx2, vy2: Velocity of the second robot along the X and Y axes per time unit. t: The specific time. Returns: True if the robots will collide at time t, False otherwise. # Calculate the position of the first robot at time t position1_x = x1 + vx1 * t position1_y = y1 + vy1 * t # Calculate the position of the second robot at time t position2_x = x2 + vx2 * t position2_y = y2 + vy2 * t # Check if both robots occupy the same position at time t return position1_x == position2_x and position1_y == position2_y"},{"question":"class FlightBookings: A class to manage seat bookings for an airline with a matrix seats representing the seats in a plane. Attributes: seats (list of list of int): A 2D list representing the seat availability. Methods: bookSeat(row, col): Books the seat at the specified row and col. releaseSeat(row, col): Releases the previously booked seat at the specified row and col. getSeatStatus(row, col): Returns the current status of the seat at the specified row and col. def __init__(self, seats): Initializes the FlightBookings object with a 2D list representing seats. def bookSeat(self, row, col): Books the seat at the specified row and col. Sets the seat value to 1. def releaseSeat(self, row, col): Releases the previously booked seat at the specified row and col. Sets the seat value to 0. def getSeatStatus(self, row, col): Returns the current status of the seat at the specified row and col. # Example usage: # seats = [[0, 0, 0], [0, 1, 0], [1, 0, 0]] # flightBookings = FlightBookings(seats) # flightBookings.getSeatStatus(1, 1) # return 1 # flightBookings.bookSeat(0, 0) # flightBookings.getSeatStatus(0, 0) # return 1 # flightBookings.releaseSeat(1, 1) # flightBookings.getSeatStatus(1, 1) # return 0","solution":"class FlightBookings: def __init__(self, seats): Initializes the FlightBookings object with a 2D list representing seats. self.seats = seats def bookSeat(self, row, col): Books the seat at the specified row and col. Sets the seat value to 1. self.seats[row][col] = 1 def releaseSeat(self, row, col): Releases the previously booked seat at the specified row and col. Sets the seat value to 0. self.seats[row][col] = 0 def getSeatStatus(self, row, col): Returns the current status of the seat at the specified row and col. return self.seats[row][col]"},{"question":"def evaluate_students_performance(students: List[Dict[str, Any]]) -> Dict[str, Tuple[float, str]]: Evaluate the performance of students in a coding class. Each student is represented by a dictionary containing their name and a dictionary of their scores across assessments. Args: students (List[Dict[str, Any]]): List of students with their scores. Returns: Dict[str, Tuple[float, str]]: A dictionary where each key is a student's name and the value is a tuple containing their average score and a phrase indicating whether they are the highest-scoring student or not. Example: >>> students = [ {'name': 'Alice', 'scores': {'Quiz 1': 85, 'Quiz 2': 90, 'Quiz 3': 80, 'Assignment 1': 75, 'Assignment 2': 70, 'Midterm': 88, 'Project': 95, 'Final Exam': 92}}, {'name': 'Bob', 'scores': {'Quiz 1': 78, 'Quiz 2': 85, 'Quiz 3': 88, 'Assignment 1': 80, 'Assignment 2': 78, 'Midterm': 82, 'Project': 87, 'Final Exam': 85}}, {'name': 'Charlie', 'scores': {'Quiz 1': 90, 'Quiz 2': 92, 'Quiz 3': 85, 'Assignment 1': 80, 'Assignment 2': 72, 'Midterm': 85, 'Project': 90, 'Final Exam': 88}} ] >>> evaluate_students_performance(students) { 'Alice': (84.38, 'Not the highest-scoring student'), 'Bob': (82.88, 'Not the highest-scoring student'), 'Charlie': (85.25, 'Highest-scoring student') }","solution":"def evaluate_students_performance(students): results = {} highest_avg = float('-inf') for student in students: name = student['name'] scores = student['scores'] avg_score = round(sum(scores.values()) / len(scores), 2) results[name] = (avg_score, 'Not the highest-scoring student') if avg_score > highest_avg: highest_avg = avg_score # Check if any student matches the highest average for student in students: if results[student['name']][0] == highest_avg: results[student['name']] = (highest_avg, 'Highest-scoring student') return results"},{"question":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 into a single array sorted in non-decreasing order. The final result is stored in nums1. >>> nums1 = [1,2,3,0,0,0] >>> nums2 = [2,5,6] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 2, 2, 3, 5, 6] >>> nums1 = [1] >>> nums2 = [] >>> merge(nums1, 1, nums2, 0) >>> nums1 [1] >>> nums1 = [0] >>> nums2 = [1] >>> merge(nums1, 0, nums2, 1) >>> nums1 [1] >>> nums1 = [4,5,6,0,0,0] >>> nums2 = [1,2,3] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 2, 3, 4, 5, 6] >>> nums1 = [2,2,3,0,0,0] >>> nums2 = [1,1,1] >>> merge(nums1, 3, nums2, 3) >>> nums1 [1, 1, 1, 2, 2, 3] >>> nums1 = [1,2,4,5,6,0] >>> nums2 = [3] >>> merge(nums1, 5, nums2, 1) >>> nums1 [1, 2, 3, 4, 5, 6]","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays nums1 and nums2 into a single array sorted in non-decreasing order. The final result is stored in nums1. # Start from the end of both arrays i, j, k = m - 1, n - 1, m + n - 1 while i >= 0 and j >= 0: if nums1[i] > nums2[j]: nums1[k] = nums1[i] i -= 1 else: nums1[k] = nums2[j] j -= 1 k -= 1 # Copy the remaining elements from nums2 if any while j >= 0: nums1[k] = nums2[j] j -= 1 k -= 1"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given an array of integers, find a pair of numbers that when added together, equals a specific target number. If such a pair exists, return the indices of the two numbers. If no such pair exists, return an empty list. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3], 6) [] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([1000000, 500000, -1500000], -1000000) [1, 2]","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"from itertools import permutations def tsp_brute_force(n: int, distances: List[List[int]]) -> int: Solves the Traveling Salesman Problem using brute force. Parameters: n (int): Number of cities distances (list of list of int): 2D list representing distances between cities Returns: int: Length of the shortest route that visits each city exactly once and returns to the starting city. >>> tsp_brute_force(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> tsp_brute_force(3, [[0, 29, 20], [29, 0, 15], [20, 15, 0]]) 64 def test_tsp_case1(): n = 4 distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp_brute_force(n, distances) == 80 def test_tsp_case2(): n = 3 distances = [ [0, 29, 20], [29, 0, 15], [20, 15, 0] ] assert tsp_brute_force(n, distances) == 64 def test_tsp_min_case(): n = 2 distances = [ [0, 5], [5, 0] ] assert tsp_brute_force(n, distances) == 10 def test_tsp_large_distances(): n = 3 distances = [ [0, 1000, 2000], [1000, 0, 1500], [2000, 1500, 0] ] assert tsp_brute_force(n, distances) == 4500 def test_tsp_equal_distances(): n = 3 distances = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ] assert tsp_brute_force(n, distances) == 3","solution":"from itertools import permutations def tsp_brute_force(n, distances): Solves the Traveling Salesman Problem using brute force. Parameters: n (int): Number of cities distances (list of list of int): 2D list representing distances between cities Returns: int: Length of the shortest route that visits each city exactly once and returns to the starting city. # Generate all permutations of cities (excluding the starting city) city_indices = list(range(n)) min_route_length = float('inf') # Iterate over all possible permutations of cities for perm in permutations(city_indices[1:]): current_route_length = 0 last_city = 0 # Calculate the cost of the route starting from the 0th city for city in perm: current_route_length += distances[last_city][city] last_city = city # Add the cost to return to the starting city current_route_length += distances[last_city][0] # Update the shortest route length if current is shorter min_route_length = min(min_route_length, current_route_length) return min_route_length"},{"question":"def find_heatwave_days(temperatures): Identifies all the days that are considered heatwave days from the given list of temperatures. Parameters: temperatures (list): A list of integers representing daily temperatures. Returns: list: An array of integers representing the indices of all heatwave days. Example: >>> find_heatwave_days([30, 35, 28, 40, 38, 36, 25, 45, 30]) [1, 3, 7] >>> find_heatwave_days([20, 25, 30, 28, 27, 22]) [2]","solution":"def find_heatwave_days(temperatures): Identifies all the days that are considered heatwave days from the given list of temperatures. Parameters: temperatures (list): A list of integers representing daily temperatures. Returns: list: An array of integers representing the indices of all heatwave days. heatwave_days = [] for i in range(1, len(temperatures) - 1): if temperatures[i] > temperatures[i - 1] and temperatures[i] > temperatures[i + 1]: heatwave_days.append(i) return heatwave_days"},{"question":"def is_zigzag(lst: list[int]) -> bool: Determines if a list of integers is a \\"zigzag\\" list. A list is considered a \\"zigzag\\" if each element is either strictly greater than or strictly less than its preceding element. Args: lst (list of int): The input list of integers. Returns: bool: True if the list is a \\"zigzag\\" list, else False. >>> is_zigzag([1, 3, 2, 4, 3]) True >>> is_zigzag([1, 2, 3, 4]) False >>> is_zigzag([10, 5, 10, 5, 10]) True >>> is_zigzag([1]) True >>> is_zigzag([]) True","solution":"def is_zigzag(lst): Determines if a list of integers is a \\"zigzag\\" list. A list is a \\"zigzag\\" list if each element is either strictly greater than or strictly less than its preceding element. Parameters: lst (list of int): The input list of integers. Returns: bool: True if the list is a \\"zigzag\\" list, else False. n = len(lst) if n < 2: return True # Trivially true for lists with fewer than two elements for i in range(1, n - 1): if not ((lst[i-1] < lst[i] > lst[i+1]) or (lst[i-1] > lst[i] < lst[i+1])): return False # Found a non-zigzag pattern return True"},{"question":"def longest_subarray(nums: List[int], target: int, k: int) -> int: Find the length of the longest subarray that contains at most k occurrences of integers that are exactly equal to target. >>> longest_subarray([1, 2, 3, 4, 2, 2, 3, 4, 1], 2, 2) == 7 >>> longest_subarray([1, 1, 1, 1, 1], 1, 3) == 3 >>> longest_subarray([1, 2, 3, 4, 5], 3, 1) == 5","solution":"def longest_subarray(nums, target, k): Finds the length of the longest subarray with at most k occurrences of target. left = 0 max_length = 0 count = 0 for right in range(len(nums)): if nums[right] == target: count += 1 while count > k: if nums[left] == target: count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def find_longest_subsequence(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the list nums. >>> find_longest_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> find_longest_subsequence([]) 0 >>> find_longest_subsequence([1]) 1 >>> find_longest_subsequence([5, 4, 3, 2, 1]) 1 >>> find_longest_subsequence([1, 2, 3, 4, 5]) 5 >>> find_longest_subsequence([1, 3, 2]) 2 >>> find_longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 # your code here pass","solution":"def find_longest_subsequence(nums): Returns the length of the longest increasing subsequence in the list nums. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def canFormPalindrome(s: str) -> bool: Checks if it's possible to rearrange the characters of a given string to form a palindrome. Arguments: s -- a non-empty string of lowercase and/or uppercase alphabetic characters Returns: bool -- True if it is possible to rearrange the characters to form a palindrome, False otherwise. Examples: >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"Aba\\") True","solution":"def canFormPalindrome(s): Checks if the characters of the given string can be rearranged to form a palindrome. from collections import Counter # Normalize to lower case as the problem is case-insensitive s = s.lower() # Count the frequency of each character char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, at most one character can have an odd frequency return odd_count <= 1"},{"question":"def primeFactorization(n: int) -> str: Returns the prime factorization of the given integer n in the format \\"p1^e1 * p2^e2 * ... * pk^ek\\". >>> primeFactorization(60) '2^2 * 3 * 5' >>> primeFactorization(100) '2^2 * 5^2' >>> primeFactorization(13) '13' >>> primeFactorization(1) '1'","solution":"def primeFactorization(n): Returns the prime factorization of the given integer n in the format \\"p1^e1 * p2^e2 * ... * pk^ek\\". if n == 1: return \\"1\\" factors = {} divisor = 2 while n > 1: while n % divisor == 0: if divisor in factors: factors[divisor] += 1 else: factors[divisor] = 1 n //= divisor divisor += 1 prime_factors = [] for prime in sorted(factors): exponent = factors[prime] if exponent == 1: prime_factors.append(f\\"{prime}\\") else: prime_factors.append(f\\"{prime}^{exponent}\\") return \\" * \\".join(prime_factors)"},{"question":"def largest_subgrid(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Find the largest sub-grid in each test case where all integers are the same. >>> largest_subgrid(2, [((4, 4), [ [1, 1, 2, 2], [1, 1, 2, 2], [3, 3, 2, 2], [3, 3, 2, 2], ]), ((3, 2), [ [1, 1], [1, 1], [1, 1], ])]) [8, 6] >>> largest_subgrid(1, [((1, 1), [ [1], ])]) [1] >>> largest_subgrid(1, [((1, 3), [ [1, 1, 1], ])]) [3] >>> largest_subgrid(1, [((3, 1), [ [1], [1], [1], ])]) [3] >>> largest_subgrid(1, [((4, 4), [ [1, 1, 1, 2], [1, 2, 2, 2], [1, 1, 1, 2], [1, 1, 1, 1], ])]) [6] from typing import List, Tuple def test_largest_subgrid(): test_cases = [ ((4, 4), [ [1, 1, 2, 2], [1, 1, 2, 2], [3, 3, 2, 2], [3, 3, 2, 2], ]), ((3, 2), [ [1, 1], [1, 1], [1, 1], ]), ] results = largest_subgrid(2, test_cases) expected = [8, 6] assert results == expected, f\\"Expected {expected}, but got {results}\\" test_largest_subgrid() def test_largest_subgrid_single_cell(): test_cases = [ ((1, 1), [ [1], ]), ] results = largest_subgrid(1, test_cases) expected = [1] assert results == expected, f\\"Expected {expected}, but got {results}\\" test_largest_subgrid_single_cell() def test_largest_subgrid_single_row(): test_cases = [ ((1, 3), [ [1, 1, 1], ]), ] results = largest_subgrid(1, test_cases) expected = [3] assert results == expected, f\\"Expected {expected}, but got {results}\\" test_largest_subgrid_single_row() def test_largest_subgrid_single_column(): test_cases = [ ((3, 1), [ [1], [1], [1], ]), ] results = largest_subgrid(1, test_cases) expected = [3] assert results == expected, f\\"Expected {expected}, but got {results}\\" test_largest_subgrid_single_column() def test_largest_subgrid_mixed_values(): test_cases = [ ((4, 4), [ [1, 1, 1, 2], [1, 2, 2, 2], [1, 1, 1, 2], [1, 1, 1, 1], ]), ] results = largest_subgrid(1, test_cases) expected = [6] assert results == expected, f\\"Expected {expected}, but got {results}\\" test_largest_subgrid_mixed_values()","solution":"def largest_subgrid(t, test_cases): def largest_subgrid_size(grid, n, m): max_size = 0 for i in range(n): for j in range(m): value = grid[i][j] width = m for row in range(i, n): if grid[row][j] != value: break for col in range(j, width): if grid[row][col] != value: width = col break max_size = max(max_size, (row - i + 1) * (width - j)) return max_size results = [] for case in test_cases: n, m = case[0] grid = case[1] results.append(largest_subgrid_size(grid, n, m)) return results"},{"question":"import bisect def update_gemstone_collection(K: int, initial_codes: List[int], T: int, trades: List[Tuple[int, int]]) -> List[int]: Process the series of trades and return the final sorted sequence of gemstone codes in the collection. :param K: Number of gemstones in initial collection :param initial_codes: Initial sorted sequence of gemstone codes :param T: Number of trades recorded :param trades: List of trades recorded as tuples (traded_away, new_gemstone) :return: Final sorted sequence of gemstone codes in collection Example: >>> update_gemstone_collection(5, [1, 4, 5, 7, 9], 3, [(4, 6), (1, 2), (7, 8)]) [2, 5, 6, 8, 9] >>> update_gemstone_collection(5, [1, 4, 5, 7, 9], 0, []) [1, 4, 5, 7, 9] >>> update_gemstone_collection(5, [1, 4, 5, 7, 9], 1, [(5, 6)]) [1, 4, 6, 7, 9] >>> update_gemstone_collection(7, [2, 3, 5, 8, 10, 12, 15], 4, [(10, 11), (2, 1), (8, 9), (15, 14)]) [1, 3, 5, 9, 11, 12, 14] >>> update_gemstone_collection(5, [2, 4, 6, 8, 10], 3, [(6, 11), (2, 5), (8, 7)]) [4, 5, 7, 10, 11]","solution":"import bisect def update_gemstone_collection(K, initial_codes, T, trades): This function processes the series of trades and returns the final sorted sequence of gemstone codes in the collection. # Convert the initial codes list to a mutable list collection = initial_codes[:] for trade in trades: traded_away, new_gemstone = trade # Removing the traded away gemstone index_to_remove = bisect.bisect_left(collection, traded_away) collection.pop(index_to_remove) # Adding the new gemstone in the correct position bisect.insort(collection, new_gemstone) return collection"},{"question":"from typing import List def min_cost_to_climb(cost: List[int]) -> int: Calculate the minimum cost to climb a staircase. You are given an array \`cost\` where \`cost[i]\` is the cost of the \`i\`-th step on a staircase. Once you pay the cost at a step, you can either climb one or two steps. You need to minimize the total cost to reach the top of the floor, and you can either start from the first step or the second step. >>> min_cost_to_climb([10, 15, 20]) 15 >>> min_cost_to_climb([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) 6","solution":"from typing import List def min_cost_to_climb(cost: List[int]) -> int: n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] dp = [0] * n dp[0] = cost[0] dp[1] = cost[1] for i in range(2, n): dp[i] = cost[i] + min(dp[i-1], dp[i-2]) return min(dp[-1], dp[-2])"},{"question":"def group_words_by_length(words: List[str]) -> Dict[int, List[str]]: Groups words by their length and sorts each group alphabetically. >>> group_words_by_length([\\"apple\\", \\"bat\\", \\"car\\", \\"apples\\", \\"banana\\", \\"ate\\"]) { 3: [\\"ate\\", \\"bat\\", \\"car\\"], 5: [\\"apple\\"], 6: [\\"apples\\", \\"banana\\"]} >>> group_words_by_length([]) {} >>> group_words_by_length([\\"unique\\"]) { 6: [\\"unique\\"]} >>> group_words_by_length([\\"test\\", \\"words\\", \\"for\\", \\"unit\\", \\"test\\", \\"cases\\"]) { 3: [\\"for\\"], 4: [\\"test\\", \\"test\\", \\"unit\\"], 5: [\\"cases\\", \\"words\\"]} >>> group_words_by_length([\\"repeat\\", \\"repeat\\", \\"repeat\\"]) { 6: [\\"repeat\\", \\"repeat\\", \\"repeat\\"]}","solution":"def group_words_by_length(words): Groups words by their length and sorts each group alphabetically. Args: words (list of str): List of words to be grouped. Returns: dict: A dictionary where keys are word lengths and values are lists of words of that length. from collections import defaultdict result = defaultdict(list) for word in words: result[len(word)].append(word) # Sorting the words in each list for length in result: result[length].sort() return dict(result) # Convert defaultdict to dict before returning."},{"question":"def find_longest_slowdown_sequences(T: int, test_cases: List[Tuple[List[int], List[int]]]) -> List[int]: Analyze the performance of a web server to identify the longest subsequence of consecutive requests where each request took at least L milliseconds. Parameters: T (int): The number of test cases. test_cases (List[Tuple[List[int], List[int]]]): A list containing test case information. Each test case is represented as a tuple where: - The first element is a list containing two integers [N, L]. - N: The number of requests - L: The minimum response time threshold in milliseconds. - The second element is a list of N integers representing response times. Returns: List[int]: A list of integers representing the length of the longest subsequence of consecutive requests where each request took at least L milliseconds for each test case. Examples: >>> find_longest_slowdown_sequences(2, [[[5, 100], [80, 150, 200, 90, 100]], [[4, 200], [250, 190, 300, 400]]]) [2, 2] >>> find_longest_slowdown_sequences(1, [[[5, 500], [100, 200, 300, 400, 450]]]) [0] >>> find_longest_slowdown_sequences(1, [[[5, 100], [200, 300, 400, 500, 600]]]) [5] >>> find_longest_slowdown_sequences(1, [[[6, 300], [100, 350, 200, 400, 250, 500]]]) [1] >>> find_longest_slowdown_sequences(1, [[[1, 100], [150]]]) [1] >>> find_longest_slowdown_sequences(1, [[[100000, 999999999], [999999999] * 100000]]) [100000]","solution":"def find_longest_slowdown_sequences(T, test_cases): results = [] for i in range(T): N, L = test_cases[i][0] response_times = test_cases[i][1] max_length = 0 current_length = 0 for response in response_times: if response >= L: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 results.append(max_length) return results"},{"question":"def custom_sort(tuples_list, keys): Sorts a list of tuples based on the values at the indices specified in keys. :param tuples_list: List of tuples to be sorted. :param keys: List of indices that indicate the order of sorting. :return: A new list of tuples sorted based on the specified keys. pass # Implement the custom sort logic # Example: # Sample Input tuples_list = [(1, 4, 3), (2, 3, 5), (2, 4, 1), (3, 1, 2)] keys = [2, 0, 1] # Expected Output print(custom_sort(tuples_list, keys)) # Output: [(2, 4, 1), (3, 1, 2), (1, 4, 3), (2, 3, 5)] from solution import custom_sort def test_custom_sort_example(): tuples_list = [(1, 4, 3), (2, 3, 5), (2, 4, 1), (3, 1, 2)] keys = [2, 0, 1] assert custom_sort(tuples_list, keys) == [(2, 4, 1), (3, 1, 2), (1, 4, 3), (2, 3, 5)] def test_custom_sort_different_keys(): tuples_list = [(1, 4, 3), (2, 3, 5), (2, 4, 1), (3, 1, 2)] keys = [0, 1, 2] assert custom_sort(tuples_list, keys) == [(1, 4, 3), (2, 3, 5), (2, 4, 1), (3, 1, 2)] def test_custom_sort_same_elements_different_order(): tuples_list = [(2, 1, 3), (2, 1, 2), (2, 1, 1), (2, 1, 4)] keys = [2, 1, 0] assert custom_sort(tuples_list, keys) == [(2, 1, 1), (2, 1, 2), (2, 1, 3), (2, 1, 4)] def test_custom_sort_all_keys_same(): tuples_list = [(2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2)] keys = [0, 1, 2] assert custom_sort(tuples_list, keys) == [(2, 2, 2), (2, 2, 2), (2, 2, 2), (2, 2, 2)] def test_custom_sort_mixed_keys(): tuples_list = [(9, 4, 8), (2, 6, 1), (7, 3, 5), (4, 0, 2)] keys = [1, 2, 0] assert custom_sort(tuples_list, keys) == [(4, 0, 2), (7, 3, 5), (9, 4, 8), (2, 6, 1)]","solution":"def custom_sort(tuples_list, keys): Sorts a list of tuples based on the values at the indices specified in keys. :param tuples_list: List of tuples to be sorted. :param keys: List of indices that indicate the order of sorting. :return: A new list of tuples sorted based on the specified keys. return sorted(tuples_list, key=lambda x: (x[keys[0]], x[keys[1]], x[keys[2]]))"},{"question":"class ControlSystem: def __init__(self): Initialize the elevator control system starting from the ground floor (floor 0). self.current = 0 self.requests = [] def request(self, floor: int): Register a request for the elevator to move to a specific floor. Args: floor (int): The floor number to move to. >>> elevator = ControlSystem() >>> elevator.request(3) >>> elevator.request(1) pass def step(self): Move the elevator one floor towards the next requested destination. >>> elevator = ControlSystem() >>> elevator.request(3) >>> elevator.step() >>> elevator.current_floor() 1 pass def current_floor(self) -> int: Return the current floor that the elevator is on. Returns: int: The current floor number. >>> elevator = ControlSystem() >>> elevator.current_floor() 0 pass # Unit tests to validate the functionality def test_initial_floor(): elevator = ControlSystem() assert elevator.current_floor() == 0 def test_single_request(): elevator = ControlSystem() elevator.request(2) elevator.step() assert elevator.current_floor() == 1 elevator.step() assert elevator.current_floor() == 2 def test_multiple_requests(): elevator = ControlSystem() elevator.request(3) elevator.request(1) elevator.step() assert elevator.current_floor() == 1 elevator.step() assert elevator.current_floor() == 2 elevator.step() assert elevator.current_floor() == 3 def test_duplicate_requests(): elevator = ControlSystem() elevator.request(3) elevator.request(3) elevator.step() assert elevator.current_floor() == 1 elevator.step() assert elevator.current_floor() == 2 elevator.step() assert elevator.current_floor() == 3 assert elevator.requests == [] def test_moving_up_and_down(): elevator = ControlSystem() elevator.request(3) elevator.request(1) elevator.step() elevator.step() elevator.step() elevator.request(0) elevator.step() elevator.step() elevator.step() assert elevator.current_floor() == 0 def test_no_duplicate_addition(): elevator = ControlSystem() elevator.request(2) elevator.request(2) elevator.step() assert elevator.current_floor() == 1 elevator.step() assert elevator.current_floor() == 2 assert elevator.requests == [] def test_navigate_floors(): elevator = ControlSystem() elevator.request(5) elevator.request(2) elevator.request(8) while elevator.requests: elevator.step() assert elevator.current_floor() == 8","solution":"class ControlSystem: def __init__(self): self.current = 0 self.requests = [] def request(self, floor): if floor not in self.requests: self.requests.append(floor) def step(self): if self.requests: destination = self.requests[0] if self.current < destination: self.current += 1 elif self.current > destination: self.current -= 1 if self.current == destination: self.requests.pop(0) def current_floor(self): return self.current"},{"question":"from typing import List def calculate_water_trapped(heights: List[int]) -> int: Calculate the total amount of water that can be trapped between bars represented by heights. >>> calculate_water_trapped([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> calculate_water_trapped([4,2,0,3,2,5]) == 9 >>> calculate_water_trapped([1,1,1,1,1,1]) == 0 >>> calculate_water_trapped([4,2,0,3,2,5]) == 9 >>> calculate_water_trapped([1,0,1]) == 1 >>> calculate_water_trapped([]) == 0 >>> calculate_water_trapped([0]) == 0 >>> calculate_water_trapped([1,0,1,3,0,1,2,0,2]) == 10 >>> calculate_water_trapped([2,0,2]) == 2","solution":"from typing import List def calculate_water_trapped(heights: List[int]) -> int: if not heights or len(heights) < 3: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i - 1], heights[i]) right_max[-1] = heights[-1] for i in range(len(heights) - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(len(heights)): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def sum_of_evens(n: int) -> int: Computes the sum of all even numbers from 1 to n (inclusive). Parameters: n (int): The upper bound of the range, inclusive. Returns: int: The sum of all even numbers from 1 to n. >>> sum_of_evens(10) 30 >>> sum_of_evens(1) 0 >>> sum_of_evens(2) 2 >>> sum_of_evens(5) 6 >>> sum_of_evens(100000) 2500050000","solution":"def sum_of_evens(n): Computes the sum of all even numbers from 1 to n (inclusive). Parameters: n (int): The upper bound of the range, inclusive. Returns: int: The sum of all even numbers from 1 to n. return sum(i for i in range(2, n+1, 2))"},{"question":"def transform_items(input_string: str) -> str: Takes a string containing a list of items separated by commas and returns a new string where each item is replaced by its respective length if its a word, or by itself if its a number. Preserve the order and the commas in the output. If an item is a single character word or number, return it unchanged. >>> transform_items(\\"apple,12,grape,4,banana,56,kiwi,a,3\\") \\"5,12,5,4,6,56,4,a,3\\" >>> transform_items(\\"dog,42,fish,876,cat\\") \\"3,42,4,876,3\\"","solution":"def transform_items(input_string): def transform_item(item): if item.isdigit() or len(item) == 1: return item return str(len(item)) items = input_string.split(',') transformed_items = [transform_item(item) for item in items] return ','.join(transformed_items)"},{"question":"def analyze_sentiment(text: str) -> str: Determines if the sentiment of the given text is positive or negative. Parameters: text (str): The text string to analyze. Returns: str: \\"Positive\\" if the sentiment is positive, \\"Negative\\" if the sentiment is negative. >>> analyze_sentiment(\\"this is a fantastically good day\\") \\"Positive\\" >>> analyze_sentiment(\\"this is a horrible and terrible experience\\") \\"Negative\\"","solution":"def analyze_sentiment(text: str) -> str: Determines if the sentiment of the given text is positive or negative. Parameters: text (str): The text string to analyze. Returns: str: \\"Positive\\" if the sentiment is positive, \\"Negative\\" if the sentiment is negative. positive_words = {\\"good\\", \\"happy\\", \\"excellent\\", \\"fantastic\\", \\"great\\"} negative_words = {\\"bad\\", \\"sad\\", \\"horrible\\", \\"terrible\\", \\"poor\\"} positive_count = sum(1 for word in text.split() if word in positive_words) negative_count = sum(1 for word in text.split() if word in negative_words) if positive_count > negative_count: return \\"Positive\\" else: return \\"Negative\\""},{"question":"def is_palindrome(s: str) -> bool: Determines whether a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False","solution":"def is_palindrome(s): Determines whether a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. # Filter and convert the string to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list with its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the input string. If there is no non-repeating character, returns an empty string. >>> first_non_repeating_char(\\"swiss\\") == \\"w\\" >>> first_non_repeating_char(\\"teeter\\") == \\"r\\" >>> first_non_repeating_char(\\"aabb\\") == \\"\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"a\\") == \\"a\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"aabbcc\\") == \\"\\" >>> first_non_repeating_char(\\"\\") == \\"\\" >>> first_non_repeating_char(\\"abacabad\\") == \\"c\\" >>> first_non_repeating_char(\\"abcdefggfedcba\\") == \\"\\"","solution":"def first_non_repeating_char(input_str: str) -> str: Returns the first non-repeating character in the input string. If there is no non-repeating character, returns an empty string. from collections import Counter # Count the frequency of each character in the input string char_count = Counter(input_str) # Iterate over the input string to find the first non-repeating character for char in input_str: if char_count[char] == 1: return char # If no non-repeating character is found, return an empty string return \\"\\""},{"question":"def longest_substring_with_k_repeats(s: str, k: int) -> int: Determine the length of the longest substring in the given string where each character appears at least \`k\` times. >>> longest_substring_with_k_repeats(\\"aaabb\\", 3) 3 >>> longest_substring_with_k_repeats(\\"ababbc\\", 2) 5 >>> longest_substring_with_k_repeats(\\"abcdef\\", 2) 0 >>> longest_substring_with_k_repeats(\\"aaabbbbcc\\", 2) 9 >>> longest_substring_with_k_repeats(\\"aabbcc\\", 3) 0 >>> longest_substring_with_k_repeats(\\"aaabbbcccddd\\", 3) 12","solution":"def longest_substring_with_k_repeats(s, k): def helper(s, k): if len(s) < k: return 0 char_count = {char: s.count(char) for char in set(s)} for mid in range(len(s)): if char_count[s[mid]] < k: left_part = helper(s[:mid], k) right_part = helper(s[mid+1:], k) return max(left_part, right_part) return len(s) return helper(s, k)"},{"question":"def longest_palindromic_substring(s: str) -> str: Write a function that takes a string s and returns the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") in ['a', 'c'] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"banana\\") 'anana' >>> longest_palindromic_substring(\\"abcd\\") in ['a', 'b', 'c', 'd'] True","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. n = len(s) if n <= 1: return s start = 0 max_length = 1 # Single character palindromes # Helper function to expand around the center def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Check for odd length palindrome left1, right1 = expand_around_center(i, i) # Check for even length palindrome left2, right2 = expand_around_center(i, i + 1) if right1 - left1 + 1 > max_length: start = left1 max_length = right1 - left1 + 1 if right2 - left2 + 1 > max_length: start = left2 max_length = right2 - left2 + 1 return s[start:start + max_length]"},{"question":"def search(nums: List[int], target: int) -> int: Searches for target in a rotated sorted array nums. Returns the index of target if found, otherwise -1. >>> search([4,5,6,7,0,1,2], 0) 4 >>> search([4,5,6,7,0,1,2], 3) -1 >>> search([], 1) -1 >>> search([1], 1) 0 >>> search([1], 2) -1 >>> search([6,7,8,1,2,3,4,5], 8) 2 >>> search([7,8,9,1,2,3,4,5,6], 7) 0 >>> search([7,8,9,1,2,3,4,5,6], 6) 8","solution":"def search(nums, target): Searches for target in a rotated sorted array nums. Returns the index of target if found, otherwise -1. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Check the left portion if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # Check the right portion else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def min_cost_to_collect_coins(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Determine the minimum expenditure required to collect all coins from the first to the last district. >>> min_cost_to_collect_coins(3, [(5, [5, 3, 7, 1, 4], [2, 5, 3, 4]), (4, [1, 3, 2, 4], [10, 3, 1]), (3, [10, 20, 30], [15, 15])]) == [14, 14, 30] >>> min_cost_to_collect_coins(1, [(1, [10], [])]) == [0] >>> min_cost_to_collect_coins(1, [(3, [5, 5, 5], [])]) == [0] >>> min_cost_to_collect_coins(1, [(5, [10, 20, 30, 40, 50], [1, 1, 1, 1])]) == [4] >>> min_cost_to_collect_coins(2, [(3, [2, 3, 4], [3, 1]), (4, [1, 1, 1, 1], [2, 3, 4])]) == [4, 9] pass","solution":"def min_cost_to_collect_coins(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] coins = test_cases[i][1] cost = test_cases[i][2] if len(test_cases[i]) > 2 else [] total_cost = sum(cost) if cost else 0 results.append(total_cost) return results # Example Usage t = 3 test_cases = [ (5, [5, 3, 7, 1, 4], [2, 5, 3, 4]), (4, [1, 3, 2, 4], [10, 3, 1]), (3, [10, 20, 30], [15, 15]) ] print(min_cost_to_collect_coins(t, test_cases)) # Output: [14, 14, 30]"},{"question":"def max_palindromic_substring(s: str) -> str: Returns the longest palindromic substring within the given string s. If there are multiple palindromic substrings of the same maximum length, the function returns the first one found. >>> max_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> max_palindromic_substring(\\"cbbd\\") 'bb' >>> max_palindromic_substring(\\"a\\") 'a' >>> max_palindromic_substring(\\"ac\\") 'a' >>> max_palindromic_substring(\\"racecar\\") 'racecar' >>> max_palindromic_substring(\\"aaaabaaa\\") 'aaabaaa' >>> max_palindromic_substring(\\"abcdefedcba\\") 'abcdefedcba' >>> max_palindromic_substring(\\"abcdefgh\\") 'a' pass","solution":"def max_palindromic_substring(s: str) -> str: Returns the longest palindromic substring within the given string s. If there are multiple palindromic substrings of the same maximum length, the function returns the first one found. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] max_palindrome = \\"\\" for i in range(len(s)): # Odd length palindromes palindrome1 = expand_around_center(s, i, i) # Even length palindromes palindrome2 = expand_around_center(s, i, i + 1) # Update max_palindrome if a longer one is found if len(palindrome1) > len(max_palindrome): max_palindrome = palindrome1 if len(palindrome2) > len(max_palindrome): max_palindrome = palindrome2 return max_palindrome"},{"question":"def paint_canvas(n: int, m: int, operations: List[Tuple[str, int, int]]) -> List[str]: This function takes the length of the canvas, the number of operations, and a list of operations. Each operation is a tuple containing a color and a range of indices to be painted that color. It returns the final color of each index on the canvas. >>> paint_canvas(5, 3, [(\\"red\\", 1, 3), (\\"blue\\", 2, 4), (\\"green\\", 0, 2)]) == [\\"green\\", \\"green\\", \\"green\\", \\"blue\\", \\"blue\\"] >>> paint_canvas(10, 2, [(\\"yellow\\", 1, 5), (\\"black\\", 4, 8)]) == [\\"white\\", \\"yellow\\", \\"yellow\\", \\"yellow\\", \\"black\\", \\"black\\", \\"black\\", \\"black\\", \\"black\\", \\"white\\"] pass def test_paint_canvas_example_1(): n = 5 m = 3 operations = [(\\"red\\", 1, 3), (\\"blue\\", 2, 4), (\\"green\\", 0, 2)] assert paint_canvas(n, m, operations) == [\\"green\\", \\"green\\", \\"green\\", \\"blue\\", \\"blue\\"] def test_paint_canvas_example_2(): n = 10 m = 2 operations = [(\\"yellow\\", 1, 5), (\\"black\\", 4, 8)] assert paint_canvas(n, m, operations) == [\\"white\\", \\"yellow\\", \\"yellow\\", \\"yellow\\", \\"black\\", \\"black\\", \\"black\\", \\"black\\", \\"black\\", \\"white\\"] def test_paint_canvas_no_operations(): n = 10 m = 0 operations = [] assert paint_canvas(n, m, operations) == [\\"white\\"] * 10 def test_paint_canvas_single_operation(): n = 7 m = 1 operations = [(\\"red\\", 0, 6)] assert paint_canvas(n, m, operations) == [\\"red\\"] * 7 def test_paint_canvas_overlapping_operations(): n = 6 m = 3 operations = [(\\"red\\", 1, 4), (\\"blue\\", 2, 5), (\\"green\\", 3, 3)] assert paint_canvas(n, m, operations) == [\\"white\\", \\"red\\", \\"blue\\", \\"green\\", \\"blue\\", \\"blue\\"] def test_paint_canvas_edge_operation(): n = 5 m = 2 operations = [(\\"black\\", 0, 0), (\\"white\\", 4, 4)] assert paint_canvas(n, m, operations) == [\\"black\\", \\"white\\", \\"white\\", \\"white\\", \\"white\\"]","solution":"from typing import List, Tuple def paint_canvas(n: int, m: int, operations: List[Tuple[str, int, int]]) -> List[str]: This function takes the length of the canvas, the number of operations, and a list of operations. Each operation is a tuple containing a color and a range of indices to be painted that color. It returns the final color of each index on the canvas. # Initialize the canvas with all white colors canvas = [\\"white\\"] * n # Apply each operation in order for color, start_index, end_index in operations: for i in range(start_index, end_index + 1): canvas[i] = color return canvas"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Return the number of subarrays whose sum equals k. >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2","solution":"def subarray_sum(nums, k): count = 0 current_sum = 0 prefix_sums = {0: 1} # This is where we store the cumulative sums for num in nums: current_sum += num # If (current_sum - k) is in prefix_sums, that means there exists # a subarray that sums up to k if current_sum - k in prefix_sums: count += prefix_sums[current_sum - k] # Store current_sum in the prefix_sums and increment its count if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"from collections import Counter class BookCollection: def __init__(self): self.collection = Counter() def add_year(self, year): Add a publication year to the collection. pass def remove_year(self, year): Remove a single occurrence of the publication year from the collection. pass def query_range(self, start, end): Count the number of books in the collection within the given range [start, end]. pass def process_queries(queries): Process a list of queries and return the results for the queries of type '?'. >>> process_queries([\\"+ 2001\\", \\"+ 1995\\", \\"? 1990 2005\\", \\"+ 2010\\", \\"- 1995\\", \\"? 1990 2005\\", \\"+ 2020\\", \\"? 2000 2020\\", \\"- 2020\\", \\"? 2000 2020\\"]) [2, 1, 3, 2] >>> process_queries([\\"+ 1800\\", \\"+ 1800\\", \\"+ 1900\\", \\"- 1800\\", \\"? 1700 1850\\"]) [1] pass","solution":"from collections import Counter class BookCollection: def __init__(self): self.collection = Counter() def add_year(self, year): self.collection[year] += 1 def remove_year(self, year): if self.collection[year] > 0: self.collection[year] -= 1 if self.collection[year] == 0: del self.collection[year] def query_range(self, start, end): count = 0 for year in self.collection: if start <= year <= end: count += self.collection[year] return count def process_queries(queries): book_collection = BookCollection() results = [] for query in queries: if query.startswith('+'): _, year = query.split() book_collection.add_year(int(year)) elif query.startswith('-'): _, year = query.split() book_collection.remove_year(int(year)) elif query.startswith('?'): _, start, end = query.split() results.append(book_collection.query_range(int(start), int(end))) return results"},{"question":"def can_be_balanced(N: int, M: int, bracket_string: str) -> str: Determine if the bracket sequence can be balanced with at most M swap operations. >>> can_be_balanced(4, 1, \\"(())\\") \\"YES\\" >>> can_be_balanced(4, 1, \\"(()(\\") \\"NO\\" >>> can_be_balanced(0, 0, \\"\\") \\"YES\\" >>> can_be_balanced(6, 2, \\"())(()\\") \\"YES\\" >>> can_be_balanced(4, 1, \\"((((\\") \\"NO\\" >>> can_be_balanced(4, 0, \\"()()\\") \\"YES\\" >>> can_be_balanced(4, 1, \\")(\\") \\"NO\\" >>> can_be_balanced(4, 1, \\"())\\") \\"NO\\"","solution":"def can_be_balanced(N, M, bracket_string): Determine if the bracket sequence can be balanced with at most M swap operations. open_brackets = bracket_string.count('(') close_brackets = bracket_string.count(')') if open_brackets != close_brackets: return \\"NO\\" balance = 0 swaps_needed = 0 for char in bracket_string: if char == '(': balance += 1 else: balance -= 1 if balance < 0: swaps_needed += 1 balance += 2 return \\"YES\\" if swaps_needed <= M else \\"NO\\""},{"question":"from typing import List, Tuple def can_form_straight_flush(deck: List[Tuple[int, str]]) -> str: Checks if any subset of 5 cards in the given deck can form a straight flush. >>> can_form_straight_flush([(3, \\"Hearts\\"), (4, \\"Hearts\\"), (5, \\"Hearts\\"), (6, \\"Hearts\\"), (7, \\"Hearts\\"), (9, \\"Diamonds\\"), (12, \\"Spades\\")]) \\"Straight Flush Found!\\" >>> can_form_straight_flush([(3, \\"Hearts\\"), (4, \\"Hearts\\"), (5, \\"Diamonds\\"), (6, \\"Hearts\\"), (7, \\"Hearts\\"), (9, \\"Diamonds\\"), (12, \\"Spades\\")]) \\"No Straight Flush\\"","solution":"from collections import defaultdict from typing import List, Tuple def can_form_straight_flush(deck: List[Tuple[int, str]]) -> str: # Organize cards by suit suits = defaultdict(list) for value, suit in deck: suits[suit].append(value) # Check each suit for possible straight flush for cards in suits.values(): cards.sort() if has_straight(cards): return \\"Straight Flush Found!\\" return \\"No Straight Flush\\" def has_straight(cards: List[int]) -> bool: n = len(cards) for i in range(n - 4): if cards[i + 4] - cards[i] == 4: return True return False"},{"question":"from typing import List def longest_consecutive_sequence(nums: List[int]) -> int: Write a function that takes an unsorted array of integers and finds the length of the longest consecutive elements sequence. Your function should have a linear runtime complexity. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([-1, -2, -3, 0, 1, 2, 3]) 7 >>> longest_consecutive_sequence([1, 2, 2, 3, 1, 4]) 4 >>> longest_consecutive_sequence(list(range(10000))) 10000","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: # only check for the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def spread_frequency(text: str) -> List[Tuple[str, int]]: Calculate the frequency of each character in a given string and return a list of tuples sorted by frequency in descending order. In case of a tie, sort by alphabetical order. >>> spread_frequency(\\"apple pie\\") [('p', 3), ('e', 2), (' ', 1), ('a', 1), ('i', 1), ('l', 1)] >>> spread_frequency(\\"abcd\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1)] pass","solution":"def spread_frequency(text): from collections import Counter # Calculate the character frequencies frequency = Counter(text) # Create a sorted list of tuples sorted_frequency = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) return sorted_frequency"},{"question":"def compare_arrays(arr1, arr2): Write a function \`compare_arrays(arr1, arr2)\` that compares two arrays of integers. The function should return \`True\` if each element in the first array is the square root of an element in the second array and vice versa. Otherwise, it should return \`False\`. >>> compare_arrays([2, 3, 4], [4, 9, 16]) == True >>> compare_arrays([2, 3, 5], [4, 9, 25, 36]) == False >>> compare_arrays([2, 3, 4], [4, 9, 15]) == False >>> compare_arrays([], []) == False >>> compare_arrays([2], [4]) == True >>> compare_arrays([2], [5]) == False >>> compare_arrays([2, 2, 3], [4, 4, 9]) == True >>> compare_arrays([-2, -3], [4, 9]) == True >>> compare_arrays([2, -3], [4, 9]) == True","solution":"def compare_arrays(arr1, arr2): Returns True if each element in arr1 is the square root of an element in arr2 and vice versa. Otherwise, returns False. # Check if both arrays are not empty and have the same length if not arr1 or not arr2 or len(arr1) != len(arr2): return False # Create a dictionary to count occurrences of each element in arr1^2 and arr2 count_arr1_squared = {} count_arr2 = {} # Count occurrences of each element in arr1 squared for num in arr1: squared_value = num * num if squared_value in count_arr1_squared: count_arr1_squared[squared_value] += 1 else: count_arr1_squared[squared_value] = 1 # Count occurrences of each element in arr2 for num in arr2: if num in count_arr2: count_arr2[num] += 1 else: count_arr2[num] = 1 # Compare both counts return count_arr1_squared == count_arr2"},{"question":"def max_possible_value_after_operations(test_cases): This function takes a list of test cases, performs the required operation to maximize the selected number in the sequence and returns the maximum possible value in each test case. :param test_cases: List of tuples, where each tuple contains the size of the sequence and the sequence itself. :return: List of integers representing the maximum possible value for each test case. pass # Example usage: test_cases = [ (3, [1, 2, 3]), (4, [1, 1, 1, 1]) ] print(max_possible_value_after_operations(test_cases)) # Expected: [6, 4] def test_max_possible_value_after_operations_case1(): test_cases = [(3, [1, 2, 3])] assert max_possible_value_after_operations(test_cases) == [6] def test_max_possible_value_after_operations_case2(): test_cases = [(4, [1, 1, 1, 1])] assert max_possible_value_after_operations(test_cases) == [4] def test_max_possible_value_after_operations_multiple_cases(): test_cases = [ (3, [1, 2, 3]), (4, [1, 1, 1, 1]) ] assert max_possible_value_after_operations(test_cases) == [6, 4] def test_max_possible_value_with_large_numbers(): test_cases = [(3, [1000000000, 1000000000, 1000000000])] assert max_possible_value_after_operations(test_cases) == [3000000000] def test_max_possible_value_with_varied_sequences(): test_cases = [ (5, [2, 4, 6, 8, 10]), (2, [3, 9]), ] assert max_possible_value_after_operations(test_cases) == [30, 12]","solution":"def max_possible_value_after_operations(test_cases): This function takes a list of test cases, performs the required operation to maximize the selected number in the sequence and returns the maximum possible value in each test case. :param test_cases: List of tuples, where each tuple contains the size of the sequence and the sequence itself. :return: List of integers representing the maximum possible value for each test case. results = [] for size, sequence in test_cases: total_sum = sum(sequence) results.append(total_sum) return results"},{"question":"def min_operations(nums: List[int], k: int) -> int: Returns the minimum number of operations required to make all elements of the array equal by either incrementing or decrementing the elements by 1. >>> min_operations([1, 2, 3], 1) 2 >>> min_operations([1, 10, 2, 9], 2) 4 >>> min_operations([5, 6, 8, 8, 5], 0) 0","solution":"def min_operations(nums, k): Returns the minimum number of operations required to make all elements of the array nums equal by either incrementing or decrementing the elements by 1. Parameters: nums (list): List of integers k (int): Not used based on given example and problem statement Returns: int: Minimum number of operations nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def most_frequent_strike(intersections: List[Tuple[int, int]]) -> Tuple[int, int]: Returns the most frequently struck intersection in the city grid. If there is a tie, return the intersection with the smallest x-coordinate, and if still tied, return the one with the smallest y-coordinate. If the input list is empty, return None. :param intersections: List[Tuple[int, int]] :return: Tuple[int, int] or None Examples: >>> most_frequent_strike([(1, 2), (2, 3), (1, 2), (3, 4), (1, 2), (2, 3)]) (1, 2) >>> most_frequent_strike([(3, 4), (1, 2), (2, 3)]) (1, 2) >>> most_frequent_strike([]) None # Your code here from solution import most_frequent_strike def test_most_frequent_strike_basic_cases(): assert most_frequent_strike([(1, 2), (2, 3), (1, 2), (3, 4), (1, 2), (2, 3)]) == (1, 2) assert most_frequent_strike([(3, 4), (1, 2), (2, 3)]) == (1, 2) assert most_frequent_strike([]) == None def test_most_frequent_strike_tie_cases(): assert most_frequent_strike([(1, 1), (1, 2), (1, 1), (1, 2)]) == (1, 1) assert most_frequent_strike([(0, 0), (1, 1), (0, 0), (1, 1), (1, 1)]) == (1, 1) assert most_frequent_strike([(2, 2), (2, 3), (2, 2), (2, 3)]) == (2, 2) def test_most_frequent_strike_single_element(): assert most_frequent_strike([(1, 1)]) == (1, 1) assert most_frequent_strike([(0, 0)]) == (0, 0) def test_most_frequent_strike_large_input(): large_input = [(i, i % 10) for i in range(10000)] assert most_frequent_strike(large_input) == (0, 0)","solution":"def most_frequent_strike(intersections): Returns the most frequently struck intersection in the city grid. If there is a tie, return the intersection with the smallest x-coordinate, and if still tied, return the one with the smallest y-coordinate. If the input list is empty, return None. :param intersections: List[Tuple[int, int]] :return: Tuple[int, int] or None if not intersections: return None from collections import defaultdict strike_counts = defaultdict(int) # Count each intersection strike for intersection in intersections: strike_counts[intersection] += 1 # Find the most frequent intersection most_frequent = None max_count = 0 for intersection, count in strike_counts.items(): if count > max_count or ( count == max_count and (most_frequent is None or intersection < most_frequent) ): most_frequent = intersection max_count = count return most_frequent"},{"question":"def analyze_migration_pattern(c: List[List[int]]) -> str: Analyze the bird's movement and return the predicted migratory route pattern. Parameters: c (List[List[int]]): A 2D array representing the bird's movement in the sky over a series of days. Returns: str: The predicted migratory route pattern: \\"steady\\", \\"rise\\", \\"fall\\", or \\"no specific pattern\\". Examples: >>> analyze_migration_pattern([ ... [100, 100, 100], ... [150, 150, 150], ... [200, 200, 200] ... ]) == \\"steady\\" >>> analyze_migration_pattern([ ... [50, 100, 150], ... [75, 125, 175], ... [100, 150, 200] ... ]) == \\"rise\\" >>> analyze_migration_pattern([ ... [300, 200, 100], ... [400, 300, 200], ... [500, 400, 300] ... ]) == \\"fall\\" >>> analyze_migration_pattern([ ... [120, 100, 130], ... [150, 175, 160], ... [200, 180, 210] ... ]) == \\"no specific pattern\\" pass","solution":"def analyze_migration_pattern(c): if not c or not c[0]: return \\"no specific pattern\\" steady = True rise = True fall = True for day in c: for i in range(1, len(day)): if day[i] != day[i-1]: steady = False if day[i] <= day[i-1]: rise = False if day[i] >= day[i-1]: fall = False if steady: return \\"steady\\" if rise: return \\"rise\\" if fall: return \\"fall\\" return \\"no specific pattern\\""},{"question":"def find_middle(words: List[str]) -> str: Returns the middle word(s) from the list of words. If the list has an odd number of words, returns the middle word. If the list has an even number of words, returns the two middle words concatenated with a space. >>> find_middle([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\"]) == \\"three\\" >>> find_middle([\\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\"]) == \\"three four\\" >>> find_middle([\\"first\\", \\"second\\", \\"third\\", \\"fourth\\", \\"fifth\\"]) == \\"third\\" >>> find_middle([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"]) == \\"d\\" >>> find_middle([\\"this\\", \\"is\\", \\"an\\", \\"example\\"]) == \\"is an\\"","solution":"def find_middle(words): Returns the middle word(s) from the list of words. If the list has an odd number of words, returns the middle word. If the list has an even number of words, returns the two middle words concatenated with a space. n = len(words) mid = n // 2 if n % 2 == 0: # Even number of words return words[mid - 1] + \\" \\" + words[mid] else: # Odd number of words return words[mid]"},{"question":"from math import gcd from functools import reduce from typing import List def gcd_array(arr: List[int]) -> int: Returns the greatest common divisor (GCD) of an array of integers. If the array is empty, returns 0. If there is only one element, returns that element. >>> gcd_array([24, 36, 48]) 12 >>> gcd_array([7, 5, 13]) 1 >>> gcd_array([20, 40, 60, 80]) 20 >>> gcd_array([]) 0 >>> gcd_array([7]) 7 def test_gcd_array(): assert gcd_array([24, 36, 48]) == 12 assert gcd_array([7, 5, 13]) == 1 assert gcd_array([20, 40, 60, 80]) == 20 assert gcd_array([]) == 0 assert gcd_array([7]) == 7 assert gcd_array([100, 200, 400]) == 100 assert gcd_array([2, 4, 6, 8, 10]) == 2 assert gcd_array([3, 6, 9, 12, 15]) == 3 assert gcd_array([11, 13, 17, 19]) == 1 assert gcd_array([1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]) == 1 # Run the test function test_gcd_array()","solution":"from math import gcd from functools import reduce def gcd_array(arr): Returns the greatest common divisor (GCD) of an array of integers. if not arr: return 0 return reduce(gcd, arr) # Examples for testing print(gcd_array([24, 36, 48])) # Output: 12 print(gcd_array([7, 5, 13])) # Output: 1 print(gcd_array([20, 40, 60, 80])) # Output: 20 print(gcd_array([])) # Output: 0 print(gcd_array([7])) # Output: 7"},{"question":"def unique_paths(m: int, n: int) -> int: Given a grid of size m x n, find the number of unique paths from the top-left corner to the bottom-right corner. You can only move either down or right at any point in time. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. # Create a 2D list with all elements set to 1, which represents the number of ways to reach each cell dp = [[1] * n for _ in range(m)] # Iterate over the cells of the grid starting from (1, 1) for i in range(1, m): for j in range(1, n): # The current cell's value is the sum of the cell above it and the cell to the left of it dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner of the dp array contains the number of unique paths return dp[m - 1][n - 1]"},{"question":"def number_to_words(num: int) -> str: Converts a given non-negative integer (less than or equal to 1,000,000) into its English words representation. >>> number_to_words(123) \\"one hundred twenty-three\\" >>> number_to_words(0) \\"zero\\" >>> number_to_words(1000000) \\"one million\\"","solution":"def number_to_words(num): Converts a given non-negative integer (less than or equal to 1,000,000) into its English words representation. if num == 0: return \\"zero\\" # Maps for units, tens, teens, and thousands under_20 = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'] tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'] thousands = ['hundred', 'thousand', 'million'] def words(n): if n < 20: return under_20[n] elif n < 100: return tens[n // 10] + ('' if n % 10 == 0 else ' ' + under_20[n % 10]) elif n < 1000: return under_20[n // 100] + ' hundred' + ('' if n % 100 == 0 else ' ' + words(n % 100)) elif n < 1000000: return words(n // 1000) + ' thousand' + ('' if n % 1000 == 0 else ' ' + words(n % 1000)) else: return 'one million' return words(num)"},{"question":"def minRefuelStops(target: int, startEnergy: int, stations: List[Tuple[int, int]]) -> int: Calculate the minimum number of refueling stops required to reach the target. >>> minRefuelStops(10, 10, []) 0 >>> minRefuelStops(50, 5, [[10,20], [20,5], [30,20]]) -1 >>> minRefuelStops(50, 10, [[10,40], [20,10], [40,10]]) 1 >>> minRefuelStops(100, 10, [[10,60], [20,30], [30,30], [60,40]]) 2 >>> minRefuelStops(100, 1, [[10,100], [20,100], [30,100], [40,100], [50,100]]) -1 >>> minRefuelStops(200, 50, [[50,50], [100,50], [150,50], [180,50], [190,50]]) 3 >>> minRefuelStops(1, 0, []) -1 pass","solution":"import heapq def minRefuelStops(target, startEnergy, stations): Calculate the minimum number of refueling stops required to reach the target. max_heap = [] # max-heap to keep track of the largest fuel available at stations we've passed current_distance = startEnergy num_refuels = 0 i = 0 while current_distance < target: # Add all reachable stations to the max_heap while i < len(stations) and stations[i][0] <= current_distance: heapq.heappush(max_heap, -stations[i][1]) i += 1 # If no stations are reachable and we haven't reached the target if not max_heap: return -1 # Refuel with the largest fuel from max_heap current_distance += -heapq.heappop(max_heap) num_refuels += 1 return num_refuels"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers, addition (+), multiplication (*), and parentheses. Follows standard operator precedence: parentheses first, multiplication second, and addition last. Example: >>> evaluate_expression(\\"4 + 3 * 3\\") 13 >>> evaluate_expression(\\"2 * (5 + 3)\\") 16 >>> evaluate_expression(\\"10 + (2 + 3) * 2\\") 20","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers, addition (+), multiplication (*), and parentheses. Follows standard operator precedence: parentheses first, multiplication second, and addition last. try: result = eval(expression) return result except (SyntaxError, NameError): raise ValueError(\\"Invalid expression\\")"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in a list of integers. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([0, -1, 1, 2, -2, 3, -3]) 7","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in an array. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def longest_unique_path(grid: List[List[str]]) -> int: Identify the longest path in a given grid where the path must form a sequence of unique letters. You can move to adjacent cells (horizontally or vertically, not diagonally). Args: grid: A 2D list of characters representing the grid (1 <= len(grid), len(grid[0]) <= 20). Returns: An integer representing the length of the longest path of unique letters. Examples: >>> grid1 = [ ... ['A', 'B', 'C'], ... ['D', 'E', 'F'], ... ['G', 'H', 'I'] ... ] >>> longest_unique_path(grid1) 9 >>> grid2 = [ ... ['A', 'B', 'A'], ... ['C', 'D', 'C'] ... ] >>> longest_unique_path(grid2) 4 >>> grid3 = [ ... ['A', 'B'], ... ['C', 'C'] ... ] >>> longest_unique_path(grid3) 3","solution":"from typing import List, Set def longest_unique_path(grid: List[List[str]]) -> int: def dfs(x: int, y: int, visited: Set[str]) -> int: if not (0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] not in visited): return len(visited) visited.add(grid[x][y]) max_length = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: max_length = max(max_length, dfs(x + dx, y + dy, visited)) visited.remove(grid[x][y]) return max_length max_path = 0 for i in range(len(grid)): for j in range(len(grid[0])): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"def merge_min_lexicographical(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[List[int]]: Merge two sequences minimally lexicographically, maintaining their relative order. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases. Each test case is a tuple containing: - N (int): Length of the first sequence. - M (int): Length of the second sequence. - P (List[int]): First sequence of integers. - Q (List[int]): Second sequence of integers. Returns: List[List[int]]: Merged sequences for each test case. Example: >>> T = 2 >>> test_cases = [(3, 3, [1, 3, 5], [2, 4, 6]), (4, 2, [2, 5, 6, 8], [3, 7])] >>> merge_min_lexicographical(T, test_cases) [[1, 2, 3, 4, 5, 6], [2, 3, 5, 6, 7, 8]] Test cases: from solution import merge_min_lexicographical def test_merge_min_lexicographical_case1(): T = 2 test_cases = [ (3, 3, [1, 3, 5], [2, 4, 6]), (4, 2, [2, 5, 6, 8], [3, 7]) ] result = merge_min_lexicographical(T, test_cases) expected = [ [1, 2, 3, 4, 5, 6], [2, 3, 5, 6, 7, 8] ] assert result == expected def test_merge_min_lexicographical_all_P(): T = 1 test_cases = [ (4, 0, [1, 2, 3, 4], []) ] result = merge_min_lexicographical(T, test_cases) expected = [ [1, 2, 3, 4] ] assert result == expected def test_merge_min_lexicographical_all_Q(): T = 1 test_cases = [ (0, 3, [], [5, 6, 7]) ] result = merge_min_lexicographical(T, test_cases) expected = [ [5, 6, 7] ] assert result == expected def test_merge_min_lexicographical_mixed_case(): T = 1 test_cases = [ (3, 3, [1, 2, 3], [1, 2, 3]) ] result = merge_min_lexicographical(T, test_cases) expected = [ [1, 1, 2, 2, 3, 3] ] assert result == expected","solution":"def merge_min_lexicographical(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][:2] P = test_cases[i][2] Q = test_cases[i][3] merged = [] i, j = 0, 0 while i < N and j < M: if P[i] < Q[j]: merged.append(P[i]) i += 1 else: merged.append(Q[j]) j += 1 while i < N: merged.append(P[i]) i += 1 while j < M: merged.append(Q[j]) j += 1 results.append(merged) return results"},{"question":"def multiply_strings(num1: str, num2: str) -> str: Returns the product of two non-negative integers num1 and num2 represented as strings. >>> multiply_strings(\\"2\\", \\"3\\") \\"6\\" >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\" >>> multiply_strings(\\"0\\", \\"982\\") \\"0\\" >>> multiply_strings(\\"123456789\\", \\"987654321\\") \\"121932631112635269\\" >>> multiply_strings(\\"100\\", \\"1000\\") \\"100000\\"","solution":"def multiply_strings(num1: str, num2: str) -> str: Returns the product of two non-negative integers num1 and num2 represented as strings. # Edge case for multiplication by zero if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize an array to store the result of each digit multiplication result = [0] * (len(num1) + len(num2)) # Multiply each digit and add the result to the result array for i in range(len(num1)-1, -1, -1): for j in range(len(num2)-1, -1, -1): product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0')) p1 = i + j p2 = i + j + 1 total = product + result[p2] result[p2] = total % 10 result[p1] += total // 10 # Convert result array to string result_str = ''.join(map(str, result)) # Remove leading zeros return result_str.lstrip('0')"},{"question":"def decode_message(encoded_message): Decodes a given encoded message of number-letter pairs. Args: encoded_message (str): The encoded message. Returns: str: The decoded message. def process_multiple_cases(cases): Processes multiple encoded messages and decodes them. Args: cases (list of str): List of encoded messages. Returns: list of str: List of decoded messages. from solution import decode_message, process_multiple_cases def test_decode_message_single_pair(): assert decode_message(\\"3a\\") == \\"aaa\\" def test_decode_message_multiple_pairs(): assert decode_message(\\"3a2b\\") == \\"aaabb\\" assert decode_message(\\"5c1d\\") == \\"cccccd\\" assert decode_message(\\"2x3y4z\\") == \\"xxyyyzzzz\\" def test_decode_message_with_large_numbers(): assert decode_message(\\"10a3b\\") == \\"aaaaaaaaaabbb\\" def test_process_multiple_cases(): cases = [ \\"3a2b\\", \\"5c1d\\", \\"2x3y4z\\" ] expected = [ \\"aaabb\\", \\"cccccd\\", \\"xxyyyzzzz\\" ] assert process_multiple_cases(cases) == expected def test_process_empty_cases(): assert process_multiple_cases([]) == [] def test_decode_message_single_character(): assert decode_message(\\"1a\\") == \\"a\\" assert decode_message(\\"2a\\") == \\"aa\\" def test_decode_message_mixture(): assert decode_message(\\"1a10z\\") == \\"azzzzzzzzzz\\" assert decode_message(\\"2b3c4d\\") == \\"bbcccdddd\\"","solution":"def decode_message(encoded_message): Decodes a given encoded message of number-letter pairs. Args: encoded_message (str): The encoded message. Returns: str: The decoded message. decoded_message = \\"\\" i = 0 while i < len(encoded_message): # Find number part num_str = \\"\\" while i < len(encoded_message) and encoded_message[i].isdigit(): num_str += encoded_message[i] i += 1 # Convert number part to integer number = int(num_str) # Add the corresponding letters to the decoded_message if i < len(encoded_message) and encoded_message[i].isalpha(): decoded_message += encoded_message[i] * number i += 1 return decoded_message def process_multiple_cases(cases): Processes multiple encoded messages and decodes them. Args: cases (list of str): List of encoded messages. Returns: list of str: List of decoded messages. return [decode_message(case) for case in cases]"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA: ListNode, headB: ListNode) -> ListNode: Find the node at which the intersection of two singly linked lists begins. Return the intersecting node or None if there is no intersection. >>> a1 = ListNode(4) >>> a2 = ListNode(1) >>> common = ListNode(8) >>> a3 = ListNode(4) >>> a4 = ListNode(5) >>> a1.next = a2 >>> a2.next = common >>> common.next = a3 >>> a3.next = a4 >>> b1 = ListNode(5) >>> b2 = ListNode(6) >>> b3 = ListNode(1) >>> b1.next = b2 >>> b2.next = b3 >>> b3.next = common >>> getIntersectionNode(a1, b1) == common True >>> a1 = ListNode(2) >>> a2 = ListNode(6) >>> a3 = ListNode(4) >>> a1.next = a2 >>> a2.next = a3 >>> b1 = ListNode(1) >>> b2 = ListNode(5) >>> b1.next = b2 >>> getIntersectionNode(a1, b1) == None True","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA, headB): Find the node at which the intersection of two singly linked lists begins. Return the intersecting node or None if there is no intersection. # Initialize two pointers ptrA, ptrB = headA, headB # Traverse both lists, switching to the other list upon reaching the end of one while ptrA is not ptrB: # If one pointer reaches the end, switch it to the start of the other list ptrA = ptrA.next if ptrA else headB ptrB = ptrB.next if ptrB else headA # When the pointers meet, either both are None or both are at the intersection node return ptrA"},{"question":"def can_alice_guarantee_palindrome(s: str) -> str: Determines if Alice can guarantee that the string will become a palindrome, regardless of how Bob plays. Parameters: s (str): The input string. Returns: str: \\"YES\\" if Alice can guarantee a palindrome, \\"NO\\" otherwise. # Testing the function def test_single_character(): assert can_alice_guarantee_palindrome(\\"a\\") == \\"YES\\" assert can_alice_guarantee_palindrome(\\"z\\") == \\"YES\\" def test_palindromic_string(): assert can_alice_guarantee_palindrome(\\"racecar\\") == \\"YES\\" assert can_alice_guarantee_palindrome(\\"madam\\") == \\"YES\\" def test_near_palindromic_string(): assert can_alice_guarantee_palindrome(\\"abca\\") == \\"YES\\" def test_non_palindromic_string(): assert can_alice_guarantee_palindrome(\\"abcd\\") == \\"NO\\" assert can_alice_guarantee_palindrome(\\"abcdef\\") == \\"NO\\" def test_one_mismatch(): assert can_alice_guarantee_palindrome(\\"abccba\\") == \\"YES\\" assert can_alice_guarantee_palindrome(\\"abbcxba\\") == \\"YES\\" def test_multiple_mismatches(): assert can_alice_guarantee_palindrome(\\"abzcxby\\") == \\"NO\\"","solution":"def can_alice_guarantee_palindrome(s): Determines if Alice can guarantee that the string will become a palindrome, regardless of how Bob plays. Parameters: s (str): The input string. Returns: str: \\"YES\\" if Alice can guarantee a palindrome, \\"NO\\" otherwise. n = len(s) mismatches = sum(1 for i in range(n // 2) if s[i] != s[n - i - 1]) # Alice can guarantee a palindrome if there is at most one mismatch return \\"YES\\" if mismatches <= 1 else \\"NO\\""},{"question":"from typing import List, Dict def calculate_gpa(students: List[Dict]) -> Dict[int, float]: Calculates the GPA (Grade Point Average) for each student in the provided database. :param students: A list of dictionaries, where each dictionary contains: - student_id (int): Unique ID of the student - name (str): Name of the student - courses (List[Dict]): A list of dictionaries, each containing: - course_id (int): Unique ID of the course - grade (float): Numeric grade in the course :return: A dictionary where the key is the student_id and the value is the GPA of the student. Examples: >>> students = [ ... {\\"student_id\\": 1, \\"name\\": \\"Alice\\", \\"courses\\": [{\\"course_id\\": 101, \\"grade\\": 3.5}, {\\"course_id\\": 102, \\"grade\\": 4.0}]}, ... {\\"student_id\\": 2, \\"name\\": \\"Bob\\", \\"courses\\": [{\\"course_id\\": 101, \\"grade\\": 2.5}, {\\"course_id\\": 103, \\"grade\\": 3.0}]} ... ] >>> calculate_gpa(students) {1: 3.75, 2: 2.75} >>> students = [ ... {\\"student_id\\": 1, \\"name\\": \\"Alice\\", \\"courses\\": [{\\"course_id\\": 101, \\"grade\\": 3.7}, {\\"course_id\\": 102, \\"grade\\": 3.9}, {\\"course_id\\": 103, \\"grade\\": 4.0}]}, ... {\\"student_id\\": 2, \\"name\\": \\"Bob\\", \\"courses\\": [{\\"course_id\\": 101, \\"grade\\": 2.0}, {\\"course_id\\": 102, \\"grade\\": 3.0}, {\\"course_id\\": 103, \\"grade\\": 2.6}]} ... ] >>> calculate_gpa(students) {1: 3.8666666666666667, 2: 2.533333333333333}","solution":"from typing import List, Dict def calculate_gpa(students: List[Dict]) -> Dict[int, float]: Calculates the GPA for each student. :param students: A list of dictionaries, each containing student information. :return: A dictionary where the key is the student_id and the value is the GPA of the student. gpa_dict = {} for student in students: student_id = student[\\"student_id\\"] courses = student[\\"courses\\"] total_grade = sum(course[\\"grade\\"] for course in courses) gpa = total_grade / len(courses) if courses else 0 gpa_dict[student_id] = gpa return gpa_dict"},{"question":"def floyd_warshall(n, edges): Implement the Floyd-Warshall algorithm to find the shortest paths between all pairs of cities. Args: n (int): Number of cities. edges (List[Tuple[int, int, int]]): List of tuples representing the roads, where each tuple contains three integers (u, v, w) denoting a road between city u and city v with length w. Returns: List[List[int]]: An n x n matrix where the entry at row i and column j represents the shortest distance between city i and city j. If there's no possible route between two cities, the distance is -1. def shortest_path_multiple_cases(t, cases): Process multiple test cases to find the shortest paths between all pairs of cities for each case. Args: t (int): Number of test cases. cases (List[Tuple[int, int, List[Tuple[int, int, int]]]]): List of test cases where each test case is represented as a tuple containing: - Number of cities (n) - Number of roads (m) - List of roads (edges), where each road is represented as a tuple (u, v, w) Returns: List[List[List[int]]]: Results for each test case where each result is an n x n matrix. from typing import List, Tuple def test_case_1(): t = 2 cases = [ (4, 4, [(1, 2, 4), (2, 3, 1), (3, 4, 2), (1, 3, 7)]), (3, 3, [(1, 2, 5), (2, 3, 3), (1, 3, 10)]) ] expected = [ [ [0, 4, 5, 7], [4, 0, 1, 3], [5, 1, 0, 2], [7, 3, 2, 0] ], [ [0, 5, 8], [5, 0, 3], [8, 3, 0] ] ] result = shortest_path_multiple_cases(t, cases) assert result == expected def test_case_2(): t = 1 cases = [ (2, 1, [(1, 2, 1)]) ] expected = [ [ [0, 1], [1, 0] ] ] result = shortest_path_multiple_cases(t, cases) assert result == expected def test_case_3(): t = 1 cases = [ (5, 0, []) ] expected = [ [ [0, -1, -1, -1, -1], [-1, 0, -1, -1, -1], [-1, -1, 0, -1, -1], [-1, -1, -1, 0, -1], [-1, -1, -1, -1, 0] ] ] result = shortest_path_multiple_cases(t, cases) assert result == expected def test_case_4(): t = 1 cases = [ (3, 2, [(1, 2, 2), (2, 3, 4)]) ] expected = [ [ [0, 2, 6], [2, 0, 4], [6, 4, 0] ] ] result = shortest_path_multiple_cases(t, cases) assert result == expected","solution":"def floyd_warshall(n, edges): INF = float('inf') dist = [[INF] * n for _ in range(n)] # Initialize distances based on edges for u, v, w in edges: dist[u-1][v-1] = w dist[v-1][u-1] = w # Distance to self is 0 for i in range(n): dist[i][i] = 0 # Floyd Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] # Replace INF with -1 to indicate no path exists for i in range(n): for j in range(n): if dist[i][j] == INF: dist[i][j] = -1 return dist def shortest_path_multiple_cases(t, cases): results = [] for n, m, edges in cases: results.append(floyd_warshall(n, edges)) return results"},{"question":"def maximum_product_of_two_distinct_elements(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers. Your task is to find the maximum product of two distinct elements in the array. -----Input:----- - First-line will contain T, the number of test cases. Then the test cases follow. - Each test case contains two lines of input. The first line contains a single integer N representing the number of elements in the array. - The second line contains N space-separated integers that represent the elements of the array. -----Output:----- For each test case, output a single line containing the maximum product of two distinct elements in the array. -----Constraints----- - 1 <= T <= 100 - 2 <= N <= 1000 - -10^3 <= A[i] <= 10^3 -----Sample Input:----- 2 4 1 2 3 4 5 -10 -20 5 7 8 -----Sample Output:----- 12 200 >>> T = 2 >>> test_cases = [ ... (4, [1, 2, 3, 4]), ... (5, [-10, -20, 5, 7, 8]) ... ] >>> maximum_product_of_two_distinct_elements(T, test_cases) [12, 200]","solution":"def maximum_product_of_two_distinct_elements(T, test_cases): results = [] for case in test_cases: N, array = case max1, max2 = float('-inf'), float('-inf') min1, min2 = float('inf'), float('inf') for num in array: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num if num < min1: min2 = min1 min1 = num elif num < min2: min2 = num max_product = max(max1 * max2, min1 * min2) results.append(max_product) return results"},{"question":"def largest_contiguous_sequence_of_digits(s: str) -> str: Returns the largest contiguous sequence of digits found in the input string. >>> largest_contiguous_sequence_of_digits(\\"abc123xyz4567def\\") \\"4567\\" >>> largest_contiguous_sequence_of_digits(\\"abc1xyz2ef\\") \\"1\\" >>> largest_contiguous_sequence_of_digits(\\"123abc456\\") \\"123\\" >>> largest_contiguous_sequence_of_digits(\\"abc123xyz4567\\") \\"4567\\" >>> largest_contiguous_sequence_of_digits(\\"\\") \\"\\" >>> largest_contiguous_sequence_of_digits(\\"abcdefg\\") \\"\\" >>> largest_contiguous_sequence_of_digits(\\"1234567890\\") \\"1234567890\\" >>> largest_contiguous_sequence_of_digits(\\"123xyz456\\") \\"123\\" >>> largest_contiguous_sequence_of_digits(\\"a12bcd345efgh6789ij0\\") \\"6789\\"","solution":"def largest_contiguous_sequence_of_digits(s): Returns the largest contiguous sequence of digits found in the input string. Parameters: s (str): Input string containing alphanumeric characters. Returns: str: Largest contiguous sequence of digits in the input string. max_sequence = \\"\\" current_sequence = \\"\\" for char in s: if char.isdigit(): current_sequence += char if len(current_sequence) > len(max_sequence): max_sequence = current_sequence else: current_sequence = \\"\\" return max_sequence"},{"question":"def find_min_spanning_tree(roads): Function to find the total minimal length of the roads required to connect all buildings using Kruskal's algorithm. If buildings cannot be connected, return None. >>> roads = [ ... (\\"House\\", \\"Library\\", 7), ... (\\"House\\", \\"Market\\", 4), ... (\\"Library\\", \\"Market\\", 2), ... (\\"Library\\", \\"Farm\\", 6), ... (\\"Market\\", \\"Farm\\", 3) ... ] >>> find_min_spanning_tree(roads) 9 >>> roads = [ ... (\\"House\\", \\"Library\\", 7), ... (\\"Library\\", \\"Farm\\", 6), ... (\\"Market\\", \\"Shop\\", 3) ... ] >>> find_min_spanning_tree(roads) None >>> roads = [] >>> find_min_spanning_tree(roads) None >>> roads = [ ... (\\"House\\", \\"Library\\", 7) ... ] >>> find_min_spanning_tree(roads) 7 >>> roads = [ ... (\\"A\\", \\"B\\", 1), ... (\\"B\\", \\"C\\", 2), ... (\\"C\\", \\"D\\", 3), ... (\\"D\\", \\"A\\", 4), ... (\\"A\\", \\"C\\", 5), ... (\\"B\\", \\"D\\", 6) ... ] >>> find_min_spanning_tree(roads) 6 >>> roads = [ ... (\\"A\\", \\"B\\", 1), ... (\\"A\\", \\"C\\", 1), ... (\\"B\\", \\"C\\", 1) ... ] >>> find_min_spanning_tree(roads) 2","solution":"def find_min_spanning_tree(roads): Function to find the total minimal length of the roads required to connect all buildings using Kruskal's algorithm. If buildings cannot be connected, return None. # Kruskal's algorithm is used here to find the MST # Firstly, we need to sort the roads based on their length sorted_roads = sorted(roads, key=lambda x: x[2]) # Creating a helper function to find the root of a node in a disjoint set def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Function to perform union of two sets def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 # Initialize variables parent = {} rank = {} mst_weight = 0 num_edges = 0 buildings = set() for road in roads: buildings.add(road[0]) buildings.add(road[1]) # Create disjoint sets for each building for building in buildings: parent[building] = building rank[building] = 0 edges = 0 for road in sorted_roads: building1, building2, length = road x = find(parent, building1) y = find(parent, building2) # If including this road doesn't cause a cycle, include it in the result if x != y: mst_weight += length union(parent, rank, x, y) edges += 1 # Stop if we have enough edges for MST if edges == len(buildings) - 1: break # Check if MST includes all the buildings if edges != len(buildings) - 1: return None return mst_weight"},{"question":"def convert_to_roman(n: int) -> str: Convert a given positive integer into its corresponding Roman numeral representation. >>> convert_to_roman(1) \\"I\\" >>> convert_to_roman(3) \\"III\\" >>> convert_to_roman(4) \\"IV\\" >>> convert_to_roman(5) \\"V\\" >>> convert_to_roman(9) \\"IX\\" >>> convert_to_roman(10) \\"X\\" >>> convert_to_roman(12) \\"XII\\" >>> convert_to_roman(27) \\"XXVII\\" >>> convert_to_roman(40) \\"XL\\" >>> convert_to_roman(90) \\"XC\\" >>> convert_to_roman(100) \\"C\\" >>> convert_to_roman(234) \\"CCXXXIV\\" >>> convert_to_roman(345) \\"CCCXLV\\" >>> convert_to_roman(400) \\"CD\\" >>> convert_to_roman(900) \\"CM\\" >>> convert_to_roman(1000) \\"M\\" >>> convert_to_roman(1987) \\"MCMLXXXVII\\" >>> convert_to_roman(2021) \\"MMXXI\\" >>> convert_to_roman(3999) \\"MMMCMXCIX\\" >>> convert_to_roman(499) \\"CDXCIX\\" >>> convert_to_roman(999) \\"CMXCIX\\" >>> convert_to_roman(1444) \\"MCDXLIV\\"","solution":"def convert_to_roman(n): Converts a given integer to its corresponding Roman numeral representation. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while n > 0: for _ in range(n // val[i]): roman_num += syms[i] n -= val[i] i += 1 return roman_num"},{"question":"def calculate_repair_cost(time_taken: float, hourly_rate: float) -> float: Returns the total cost for a single repair task. >>> calculate_repair_cost(2, 50) 100.0 >>> calculate_repair_cost(1.5, 75) 112.5 >>> calculate_repair_cost(0, 40) 0.0 >>> calculate_repair_cost(3, 0) 0.0 def calculate_total_repair(tasks: list) -> dict: Returns the total time and total cost for a list of repair tasks. If total time exceeds 8 hours, returns \\"Overwork Detected\\". >>> calculate_total_repair([(2, 50), (3, 40)]) {'total_time': 5, 'total_cost': 220.0} >>> calculate_total_repair([(1, 30), (0.5, 20)]) {'total_time': 1.5, 'total_cost': 40.0} >>> calculate_total_repair([(4, 30), (5, 20)]) \\"Overwork Detected\\" >>> calculate_total_repair([(1, 50), (2, 50), (4, 50), (1.5, 50)]) \\"Overwork Detected\\" >>> calculate_total_repair([(8, 25)]) {'total_time': 8, 'total_cost': 200.0} >>> calculate_total_repair([]) {'total_time': 0, 'total_cost': 0}","solution":"def calculate_repair_cost(time_taken, hourly_rate): Returns the total cost for a single repair task. Parameters: time_taken (float): Time taken for the repair task in hours. hourly_rate (float): Hourly rate charged in dollars. Returns: float: Total cost for the repair task. return time_taken * hourly_rate def calculate_total_repair(tasks): Returns the total time and total cost for a list of repair tasks. Parameters: tasks (list): List of tuples, each containing time taken and hourly rate for a repair task (time_taken, hourly_rate). Returns: dict: Contains 'total_time' and 'total_cost'. If total time exceeds 8 hours, returns \\"Overwork Detected\\". total_time = sum(task[0] for task in tasks) total_cost = sum(task[0] * task[1] for task in tasks) if total_time > 8: return \\"Overwork Detected\\" return {'total_time': total_time, 'total_cost': total_cost}"},{"question":"def trap_water(heights): Computes how much water it is able to trap after raining. Parameters: heights (list): A list of non-negative integers representing the heights of the bars. Returns: int: The total units of trapped water. from solution import trap_water def test_trap_water_example_1(): heights = [0,1,0,2,1,0,1,3,2,1,2,1] assert trap_water(heights) == 6 def test_trap_water_example_2(): heights = [4,2,0,3,2,5] assert trap_water(heights) == 9 def test_trap_water_no_bars(): heights = [] assert trap_water(heights) == 0 def test_trap_water_single_bar(): heights = [4] assert trap_water(heights) == 0 def test_trap_water_same_height_bars(): heights = [1, 1, 1, 1] assert trap_water(heights) == 0 def test_trap_water_decreasing_bars(): heights = [5, 4, 3, 2, 1] assert trap_water(heights) == 0 def test_trap_water_increasing_bars(): heights = [1, 2, 3, 4, 5] assert trap_water(heights) == 0 def test_trap_water_middle_peak(): heights = [0, 2, 4, 2, 0] assert trap_water(heights) == 0 def test_trap_water_multipeaks(): heights = [3, 1, 2, 1, 3] assert trap_water(heights) == 5","solution":"def trap_water(heights): Computes how much water it is able to trap after raining. Parameters: heights (list): A list of non-negative integers representing the heights of the bars. Returns: int: The total units of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root: TreeNode) -> int: Returns the maximum depth of a binary tree. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> maxDepth(root) 3 >>> maxDepth(None) 0 from solution import TreeNode, maxDepth def test_max_depth_empty_tree(): assert maxDepth(None) == 0 def test_max_depth_single_node(): root = TreeNode(1) assert maxDepth(root) == 1 def test_max_depth_two_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert maxDepth(root) == 2 def test_max_depth_three_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) assert maxDepth(root) == 3 def test_max_depth_unbalanced_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert maxDepth(root) == 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def maxDepth(root): Returns the maximum depth of a binary tree. if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def rearrange_string(s: str) -> str: Returns a new string with characters in even positions followed by all the characters in odd positions based on 0-based indexing. >>> rearrange_string(\\"abcdef\\") \\"acebdf\\" >>> rearrange_string(\\"a\\") \\"a\\" >>> rearrange_string(\\"ab\\") \\"ab\\" >>> rearrange_string(\\"abcde\\") \\"acebd\\" >>> rearrange_string(\\"abcdefgh\\") \\"acegbdfh\\" >>> rearrange_string(\\"aaaa\\") \\"aaaa\\" >>> input_str = \\"a\\" * 1000 >>> rearrange_string(input_str) \\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\" >>> input_str = \\"ab\\" * 500 >>> rearrange_string(input_str) \\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...","solution":"def rearrange_string(s): Returns a new string with characters in even positions followed by all the characters in odd positions based on 0-based indexing. even_chars = s[0::2] odd_chars = s[1::2] return even_chars + odd_chars"},{"question":"def check_diagonal_grid(r: int, c: int, grid: List[str]) -> str: Check whether the grid follows Alan's diagonal structure. Args: r: number of rows c: number of columns grid: grid, a list of strings Returns: \\"YES\\" if the grid follows the diagonal structure, otherwise \\"NO\\" >>> check_diagonal_grid(5, 5, [\\"#....\\", \\".#...\\", \\"..#..\\", \\"...#.\\", \\"....#\\"]) \\"YES\\" >>> check_diagonal_grid(3, 3, [\\"#..\\", \\"...\\", \\"..#\\"]) \\"NO\\" >>> check_diagonal_grid(4, 4, [\\"#...\\", \\".#..\\", \\"..#.\\", \\"...#\\"]) \\"YES\\" >>> check_diagonal_grid(4, 5, [\\"#.....\\", \\".#....\\", \\"..#...\\", \\"...#..\\"]) \\"NO\\" >>> check_diagonal_grid(4, 4, [\\"#...\\", \\"#.\\", \\"..#.\\", \\"...#\\"]) \\"NO\\"","solution":"def check_diagonal_grid(r, c, grid): Check whether the grid follows Alan's diagonal structure. Args: r: number of rows c: number of columns grid: grid, a list of strings Returns: \\"YES\\" if the grid follows the diagonal structure, otherwise \\"NO\\" if r != c: return \\"NO\\" for i in range(r): for j in range(c): if i == j: if grid[i][j] != '#': return \\"NO\\" else: if grid[i][j] != '.': return \\"NO\\" return \\"YES\\""},{"question":"def is_valid_identifier(identifier: str) -> bool: Determine if a given string is a valid identifier in a programming language considering given constraints. Constraints: - An identifier can only contain alphanumeric characters (a-z, A-Z, 0-9) and underscores (_). - An identifier must start with a letter (a-z, A-Z) or an underscore (_). - An identifier cannot be a reserved keyword in the programming language. Reserved keywords: [\\"if\\", \\"else\\", \\"while\\", \\"for\\", \\"return\\"] Examples: >>> is_valid_identifier(\\"variable1\\") == True >>> is_valid_identifier(\\"2variable\\") == False >>> is_valid_identifier(\\"if\\") == False >>> is_valid_identifier(\\"_underscore\\") == True","solution":"def is_valid_identifier(identifier: str) -> bool: Determine if a given string is a valid identifier in a programming language considering given constraints. reserved_keywords = [\\"if\\", \\"else\\", \\"while\\", \\"for\\", \\"return\\"] if not identifier: return False if identifier in reserved_keywords: return False if not (identifier[0].isalpha() or identifier[0] == '_'): return False for char in identifier: if not (char.isalnum() or char == '_'): return False return True"},{"question":"def unique_digits_count(a: int, b: int) -> int: Returns the number of unique digits in the product of a and b. >>> unique_digits_count(12, 34) 3 >>> unique_digits_count(5, 25) 3 >>> unique_digits_count(0, 100) 1 >>> unique_digits_count(12345, 1) 5 >>> unique_digits_count(10, 10) 2 >>> unique_digits_count(7, 7) 2 >>> unique_digits_count(0, 0) 1 >>> unique_digits_count(9999, 9999) 4","solution":"def unique_digits_count(a, b): Returns the number of unique digits in the product of a and b. product = a * b unique_digits = set(str(product)) return len(unique_digits)"},{"question":"def sumArrayExceptSelf(arr: List[int]) -> List[int]: Write a function that accepts an array of integers and returns an array where each element is the sum of the other elements except the element at the current index. You may not use division in your solution. >>> sumArrayExceptSelf([1, 2, 3, 4]) [9, 8, 7, 6] >>> sumArrayExceptSelf([5, 10, 15]) [25, 20, 15] >>> sumArrayExceptSelf([7, 0, 3]) [3, 10, 7] >>> sumArrayExceptSelf([10]) [0] >>> sumArrayExceptSelf([0, 0, 0]) [0, 0, 0] >>> sumArrayExceptSelf([2, 2, 2]) [4, 4, 4] >>> sumArrayExceptSelf([1, 1, 1, 1, 1]) [4, 4, 4, 4, 4] >>> sumArrayExceptSelf([0]) [0] >>> sumArrayExceptSelf([999, 1]) [1, 999] >>> sumArrayExceptSelf([1000000, 1000000, 1000000]) [2000000, 2000000, 2000000]","solution":"def sumArrayExceptSelf(arr): Returns a new array where each element is the sum of all other elements except the one at the current index. total_sum = sum(arr) result = [total_sum - x for x in arr] return result"},{"question":"def calculate_total_cost(prices: dict, orders: list) -> float: Calculates the total cost of all orders. Parameters: prices (dict): A dictionary with items and their respective prices. orders (list): A list of tuples containing the item name and the quantity ordered. Returns: float: The total cost of all orders. >>> prices = {\\"apple\\": 2.5, \\"banana\\": 1.0, \\"orange\\": 1.75} >>> orders = [(\\"apple\\", 3), (\\"banana\\", 1), (\\"orange\\", 2)] >>> calculate_total_cost(prices, orders) 12.0 >>> prices = {\\"apple\\": 2.5, \\"banana\\": 1.0, \\"orange\\": 1.75} >>> orders = [] >>> calculate_total_cost(prices, orders) 0.0 >>> prices = {} >>> orders = [(\\"apple\\", 3), (\\"banana\\", 1), (\\"orange\\", 2)] >>> calculate_total_cost(prices, orders) 0.0 >>> prices = {\\"apple\\": 2.5, \\"orange\\": 1.75} >>> orders = [(\\"apple\\", 3), (\\"banana\\", 1), (\\"orange\\", 2)] >>> calculate_total_cost(prices, orders) 11.0 >>> prices = {\\"apple\\": 2.5, \\"banana\\": 1.0, \\"orange\\": 1.75} >>> orders = [(\\"apple\\", 0), (\\"banana\\", 0), (\\"orange\\", 0)] >>> calculate_total_cost(prices, orders) 0.0","solution":"def calculate_total_cost(prices, orders): Calculates the total cost of all orders. Parameters: prices (dict): A dictionary with items and their respective prices. orders (list): A list of tuples containing the item name and the quantity ordered. Returns: float: The total cost of all orders. total_cost = 0 for item, quantity in orders: if item in prices: total_cost += prices[item] * quantity return total_cost"},{"question":"def find_odd_occurrence(arr): Returns the integer that appears an odd number of times in the list. If no integer appears an odd number of times, return None. Examples: >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([4, 5, 5, 4, 4]) 4 >>> find_odd_occurrence([2, 2, 2, 2]) None","solution":"def find_odd_occurrence(arr): Returns the integer that appears an odd number of times in the list. If no integer appears an odd number of times, return None. count_dict = {} for num in arr: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 for num, count in count_dict.items(): if count % 2 != 0: return num return None"},{"question":"def robot_path_possible(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Determine if there is a path for the robot to reach its goal. Parameters: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of test cases, where each test case is a tuple containing the number of rows, number of columns, and the grid itself. Returns: List[str]: List of results for each test case, either \\"YES\\" if a path exists, or \\"NO\\" if it does not. >>> t = 3 >>> test_cases = [ ... (3, 4, [\\"....\\", \\".R..\\", \\"....\\"]), ... (2, 2, [\\".R\\", \\".R\\"]), ... (4, 4, [\\".R..\\", \\"..R.\\", \\"R...\\", \\"....\\"]), ... ] >>> robot_path_possible(t, test_cases) ['YES', 'NO', 'YES'] >>> t = 1 >>> test_cases = [ ... (3, 4, [\\"R...\\", \\".R..\\", \\"....\\"]), ... ] >>> robot_path_possible(t, test_cases) ['NO'] >>> t = 2 >>> test_cases = [ ... (1, 1, [\\".\\"]), ... (1, 1, [\\"R\\"]) ... ] >>> robot_path_possible(t, test_cases) ['YES', 'NO']","solution":"def robot_path_possible(t, test_cases): def is_path_possible(grid, m, n): if grid[0][0] == 'R' or grid[m-1][n-1] == 'R': return False dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 'R': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] != 0 results = [] for case in test_cases: m, n, grid = case results.append(\\"YES\\" if is_path_possible(grid, m, n) else \\"NO\\") return results"},{"question":"def rearrange_array(arr): Rearrange the array such that no two adjacent elements are equal. If such a rearrangement is possible, return any valid rearrangement. Otherwise, return an empty array. >>> rearrange_array([1, 1, 1, 2, 2, 3]) [1, 2, 1, 3, 1, 2] >>> rearrange_array([1, 1, 1]) [] >>> rearrange_array([1]) [1] >>> rearrange_array([1, 2]) [1, 2] from collections import Counter import heapq def test_rearrange_possible(): arr = [1, 1, 1, 2, 2, 3] result = rearrange_array(arr) assert len(result) == len(arr) assert all(result[i] != result[i+1] for i in range(len(result) - 1)) def test_rearrange_not_possible(): arr = [1, 1, 1] result = rearrange_array(arr) assert result == [] def test_rearrange_single_element(): arr = [1] result = rearrange_array(arr) assert result == [1] def test_rearrange_two_different_elements(): arr = [1, 2] result = rearrange_array(arr) assert result in [[1, 2], [2, 1]] def test_rearrange_large_number_elements(): arr = [1]*50000 + [2]*50000 result = rearrange_array(arr) assert len(result) == len(arr) assert all(result[i] != result[i+1] for i in range(len(result) - 1))","solution":"def rearrange_array(arr): from collections import Counter import heapq # Count frequency of each element freq = Counter(arr) # Create a max-heap based on frequencies (-frequency due to min-heap properties) max_heap = [] for num, count in freq.items(): heapq.heappush(max_heap, (-count, num)) result = [] prev_count, prev_num = 0, None while max_heap: count, num = heapq.heappop(max_heap) # pop the most frequent element result.append(num) if prev_count < 0: # push the previous element back to the heap if it has remaining count heapq.heappush(max_heap, (prev_count, prev_num)) count += 1 # decrease the count since we've used one occurrence of \`num\` prev_count, prev_num = count, num if len(result) != len(arr): return [] return result"},{"question":"def second_largest(nums): Returns the second largest number in the list of integers nums. If all numbers are the same, it returns the number itself. pass # Read input def main(): n = int(input().strip()) nums = list(map(int, input().strip().split())) print(second_largest(nums))","solution":"def second_largest(nums): Returns the second largest number in the list of integers nums. If all numbers are the same, it returns the number itself. # Convert to set to remove duplicates and then sort the list. unique_nums = list(set(nums)) unique_nums.sort(reverse=True) # If there is only one unique number, return it if len(unique_nums) == 1: return unique_nums[0] # Return the second largest number return unique_nums[1] # Read input def main(): n = int(input().strip()) nums = list(map(int, input().strip().split())) print(second_largest(nums))"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the letters of a given string can form a palindrome. We ignore non-alphanumeric characters and consider the string case-insensitively. >>> can_form_palindrome(\\"Tact Coa\\") == True >>> can_form_palindrome(\\"Able was I ere I saw Elba\\") == True >>> can_form_palindrome(\\"Hello\\") == False >>> can_form_palindrome(\\"racecar\\") == True >>> can_form_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> can_form_palindrome(\\"abc\\") == False >>> can_form_palindrome(\\"123321\\") == True","solution":"def can_form_palindrome(s): Determines if any permutation of the letters of a given string can form a palindrome. We ignore non-alphanumeric characters and consider the string case-insensitively. from collections import Counter # Clean the string: remove spaces and convert to lowercase clean_s = ''.join(char.lower() for char in s if char.isalnum()) # Count the frequency of each character char_count = Counter(clean_s) # A string can form a palindrome if it has at most one character with an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def remove_element(nums: List[int], target: int) -> int: Removes all occurrences of 'target' in the array 'nums' in-place and returns the new length of the array. :param nums: List[int], The input list of integers :param target: int, The target integer to remove from the list :return: int, The new length of the list after removal of the target Examples: >>> nums = [3, 2, 2, 3] >>> remove_element(nums, 3) 2 >>> sorted(nums[:length]) == sorted([2, 2]) >>> nums = [0, 1, 2, 2, 3, 0, 4, 2] >>> remove_element(nums, 2) 5 >>> sorted(nums[:length]) == sorted([0, 1, 3, 0, 4])","solution":"def remove_element(nums, target): Removes all occurrences of 'target' in the array 'nums' in-place and returns the new length of the array. :param nums: List[int], The input list of integers :param target: int, The target integer to remove from the list :return: int, The new length of the list after removal of the target k = 0 # Pointer for the position of the next valid element for i in range(len(nums)): if nums[i] != target: nums[k] = nums[i] k += 1 return k"},{"question":"def maxBracketDepth(s: str) -> int: Returns the maximum depth of nested brackets of different types: {}, [], (). If the brackets are unbalanced, returns -1. >>> maxBracketDepth(\\"a(b[c{d}e]f)g\\") 3 >>> maxBracketDepth(\\"a()b{}c[]\\") 1 >>> maxBracketDepth(\\"([a+b]*c){d+e}\\") 2 >>> maxBracketDepth(\\"a(b[c)d]e\\") -1 >>> maxBracketDepth(\\"abcde\\") 0 >>> maxBracketDepth(\\"\\") 0 >>> maxBracketDepth(\\"a{b(c[d]e)f}g\\") 3 >>> maxBracketDepth(\\"{a[b(c)d]e}\\") 3","solution":"def maxBracketDepth(s): Returns the maximum depth of nested brackets of different types: {}, [], (). If the brackets are unbalanced, returns -1. stack = [] max_depth = 0 current_depth = 0 brackets = {')': '(', '}': '{', ']': '['} for char in s: if char in \\"({[\\": stack.append(char) current_depth += 1 max_depth = max(max_depth, current_depth) elif char in \\")}]\\": if not stack or stack[-1] != brackets[char]: return -1 stack.pop() current_depth -= 1 return -1 if stack else max_depth"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the order of the parentheses in the string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. The string only contains the characters '(', ')', '{', '}', '[' and ']'. Examples: >>> is_valid_parentheses(\\"()[]{}\\") == True >>> is_valid_parentheses(\\"([)]\\") == False >>> is_valid_parentheses(\\"{[]}\\") == True from solution import is_valid_parentheses def test_valid_parentheses(): assert is_valid_parentheses(\\"()[]{}\\") == True assert is_valid_parentheses(\\"{[()]}\\") == True assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"([])\\") == True def test_invalid_parentheses(): assert is_valid_parentheses(\\"(]\\") == False assert is_valid_parentheses(\\"([)]\\") == False assert is_valid_parentheses(\\"{[}\\") == False assert is_valid_parentheses(\\"[(])\\") == False def test_empty_string(): assert is_valid_parentheses(\\"\\") == True def test_single_type_parentheses(): assert is_valid_parentheses(\\"(\\") == False assert is_valid_parentheses(\\")\\") == False assert is_valid_parentheses(\\"[]\\") == True def test_multiple_balanced_parentheses(): assert is_valid_parentheses(\\"(){}[{}]\\") == True assert is_valid_parentheses(\\"({}[])\\") == True def test_complex_cases(): assert is_valid_parentheses(\\"{[(())[]]}\\") == True assert is_valid_parentheses(\\"{{{{[[[[(((([]))))]]]]}}}}\\") == True","solution":"def is_valid_parentheses(s): Determine if the order of the parentheses in the string is valid. :param s: String containing the characters '(', ')', '{', '}', '[' and ']' :return: True if the string is valid, False otherwise stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def replace_spaces_with_hyphens(sentence: str) -> str: Replaces all spaces in the sentence with hyphens. >>> replace_spaces_with_hyphens(\\"hello world\\") 'hello-world' >>> replace_spaces_with_hyphens(\\"hello world this is python\\") 'hello-world-this-is-python' >>> replace_spaces_with_hyphens(\\"helloworld\\") 'helloworld' >>> replace_spaces_with_hyphens(\\" hello world \\") '-hello-world-' >>> replace_spaces_with_hyphens(\\" \\") '-----'","solution":"def replace_spaces_with_hyphens(sentence): Replaces all spaces in the sentence with hyphens. return sentence.replace(' ', '-')"},{"question":"from typing import List def find_missing_numbers(sequence: List[int]) -> List[int]: Finds the missing numbers in an arithmetic sequence. >>> find_missing_numbers([1, 2, 4, 5, 7]) [3, 6] >>> find_missing_numbers([10, 15, 20, 25, 35]) [30] >>> find_missing_numbers([-1, 1, 2, 3, 5]) [0, 4] def test_find_missing_numbers_basic(): assert find_missing_numbers([1, 2, 4, 5, 7]) == [3, 6] def test_find_missing_numbers_single_missing(): assert find_missing_numbers([10, 15, 20, 25, 35]) == [30] def test_find_missing_numbers_with_negatives(): assert find_missing_numbers([-1, 1, 2, 3, 5]) == [0, 4] def test_find_missing_numbers_no_missing(): assert find_missing_numbers([1, 3, 5, 7]) == [] def test_find_missing_numbers_large_difference(): assert find_missing_numbers([100, 110, 120, 140]) == [130] def test_find_missing_numbers_all_negatives(): assert find_missing_numbers([-10, -5, 0, 5]) == [] def test_find_missing_numbers_multiple_missing(): assert find_missing_numbers([2, 8, 20, 26]) == [14] def test_find_missing_number_sequence_start_and_end(): assert find_missing_numbers([-10, -5, 0, 10]) == [5]","solution":"def find_missing_numbers(sequence): Finds the missing numbers in the arithmetic sequence. # Calculate the common difference of the sequence common_difference = min(sequence[i] - sequence[i - 1] for i in range(1, len(sequence))) # Initialize the list for missing numbers missing_numbers = [] # Generate the full sequence based on the first element and common difference full_sequence = list(range(sequence[0], sequence[-1] + common_difference, common_difference)) # Find the missing numbers by checking if elements from full sequence are in the given sequence for num in full_sequence: if num not in sequence: missing_numbers.append(num) return missing_numbers"},{"question":"def longest_word(words: list) -> tuple: Returns the longest word in the list along with its length. If multiple words have the same length, the first one is returned. If the list is empty, returns an empty string and 0. >>> longest_word([\\"apple\\", \\"banana\\", \\"kiwi\\", \\"strawberry\\", \\"blueberry\\"]) ('strawberry', 10) >>> longest_word([\\"dog\\", \\"cat\\", \\"elephant\\", \\"tiger\\"]) ('elephant', 8) >>> longest_word([]) ('', 0) >>> longest_word([\\"elephant\\"]) ('elephant', 8) >>> longest_word([\\"bat\\", \\"cat\\", \\"hat\\"]) ('bat', 3) >>> longest_word([\\"at\\", \\"bat\\", \\"tear\\"]) ('tear', 4) >>> longest_word([\\"bear\\", \\"gear\\", \\"xray\\", \\"kiwi\\"]) ('bear', 4)","solution":"def longest_word(words: list) -> tuple: Returns the longest word in the list along with its length. If multiple words have the same length, the first one is returned. If the list is empty, returns an empty string and 0. if not words: return (\\"\\", 0) longest = max(words, key=len) return (longest, len(longest))"},{"question":"def convert_to_title(n: int) -> str: Convert a non-negative integer to its corresponding column title as it appears in Excel. Args: n (int): a non-negative integer Returns: str: corresponding column title Examples: >>> convert_to_title(1) 'A' >>> convert_to_title(28) 'AB' >>> convert_to_title(701) 'ZY'","solution":"def convert_to_title(n): Convert a non-negative integer to its corresponding column title as it appears in Excel. Args: n (int): a non-negative integer Returns: str: corresponding column title result = [] while n > 0: n -= 1 # Adjust for 0-based indexing result.append(chr(n % 26 + ord('A'))) n //= 26 return ''.join(result[::-1])"},{"question":"def aliquot_sum(n: int) -> int: Returns the aliquot sum of a positive integer n. The aliquot sum is the sum of all its proper divisors, excluding the number itself. >>> aliquot_sum(12) == 16 True >>> aliquot_sum(7) == 1 True >>> aliquot_sum(28) == 28 True >>> aliquot_sum(1) == 0 True >>> aliquot_sum(13) == 1 True >>> aliquot_sum(4) == 3 True >>> aliquot_sum(20) == 22 True","solution":"def aliquot_sum(n): Returns the aliquot sum of a positive integer n. The aliquot sum is the sum of all its proper divisors, excluding the number itself. if n <= 1: return 0 divisors = [] for i in range(1, n): if n % i == 0: divisors.append(i) return sum(divisors)"},{"question":"def max_non_overlapping_meetings(test_cases): Return the maximum number of non-overlapping meetings that can be scheduled for each test case. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases where each test case is represented by a tuple containing the number of meetings and a list of meeting requests (start, end) times. Returns: List[int]: A list of integers representing the maximum number of non-overlapping meetings for each test case. >>> max_non_overlapping_meetings([(3, [(1, 2), (2, 3), (3, 4)]), (4, [(1, 3), (2, 4), (3, 5), (7, 8)])]) [3, 3] pass def parse_input(input_str): Parse the input string to get the list of test cases. Args: input_str (str): The input string representing the test cases. Returns: List[Tuple[int, List[Tuple[int, int]]]]: A list of test cases where each test case is represented by a tuple containing the number of meetings and a list of meeting requests (start, end) times. >>> parse_input(\\"2n3n1 2n2 3n3 4n4n1 3n2 4n3 5n7 8n\\") [(3, [(1, 2), (2, 3), (3, 4)]), (4, [(1, 3), (2, 4), (3, 5), (7, 8)])] pass # Unit Tests def test_example_1(): input_str = \\"2n3n1 2n2 3n3 4n4n1 3n2 4n3 5n7 8n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [3, 3] def test_single_meeting(): input_str = \\"1n1n0 5n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [1] def test_all_meetings_overlap(): input_str = \\"1n3n1 4n2 5n3 6n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [1] def test_no_meeting(): input_str = \\"1n0n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [0] def test_alternate_meetings(): input_str = \\"1n4n1 2n2 3n3 4n4 5n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [4] def test_large_number_of_meetings(): input_str = \\"1n5n1 10n2 3n3 4n4 5n5 6n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [4] def test_complex_case(): input_str = \\"1n6n1 3n2 4n3 5n5 7n6 8n8 10n\\" test_cases = parse_input(input_str) assert max_non_overlapping_meetings(test_cases) == [4]","solution":"def max_non_overlapping_meetings(test_cases): results = [] for case in test_cases: N, meetings = case # Sort meetings by their end time meetings.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) current_line = 1 test_cases = [] for _ in range(T): N = int(lines[current_line]) current_line += 1 meetings = [] for _ in range(N): S, E = map(int, lines[current_line].split()) meetings.append((S, E)) current_line += 1 test_cases.append((N, meetings)) return test_cases"},{"question":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in an unsorted array. Example 1: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 Example 2: >>> longest_consecutive([0, -1, -2, 2, 3, 1]) 6 Additional Test Cases: >>> longest_consecutive([]) 0 >>> longest_consecutive([10]) 1 >>> longest_consecutive([10, 5, 100]) 1 >>> longest_consecutive([3, 2, 1, 4]) 4 >>> longest_consecutive([1, 2, 2, 3, 4]) 4 >>> longest_consecutive([10, 20, -10, 5, 6, 7, 8]) 4 pass","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in an unsorted array. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"from typing import List def findLHS(nums: List[int]) -> int: Given an array of integers nums, a harmonious array is an array where the difference between its maximum value and its minimum value is exactly 1. Your task is to find the longest harmonious subsequence in nums. The subsequence must be a subset of the array and does not need to be contiguous. Return the length of the longest harmonious subsequence in nums. If no such subsequence exists, return 0. >>> findLHS([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> findLHS([1, 2, 3, 4]) 2 >>> findLHS([1, 1, 1, 1]) 0 Unit Test: from solution import findLHS def test_example1(): assert findLHS([1,3,2,2,5,2,3,7]) == 5 def test_example2(): assert findLHS([1,2,3,4]) == 2 def test_example3(): assert findLHS([1,1,1,1]) == 0 def test_mixed_large_range(): assert findLHS([1,2,2,1,3,3,3,2]) == 6 def test_no_harmonious_subsequence(): assert findLHS([10,20,30,40,50]) == 0 def test_all_same_element(): assert findLHS([5, 5, 5, 5, 5]) == 0 def test_negative_and_positive_elements(): assert findLHS([-1, -2, -1, -2, 0, 1, 1, 2]) == 4","solution":"from collections import Counter def findLHS(nums): Returns the length of the longest harmonious subsequence. A harmonious array is one where the difference between the maximum and minimum value is exactly 1. count = Counter(nums) longest = 0 for num in count: if num + 1 in count: longest = max(longest, count[num] + count[num + 1]) return longest"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring of a given string that contains no repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"au\\") 2","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List, Tuple def plant_trees(n: int, m: int, streets: List[int], restricted_pairs: List[Tuple[int, int]]) -> List[int]: Determine if there exists a way to assign tree types to the streets such that no two adjacent streets have trees from the restricted pairs. If it's possible, return one valid assignment as a list of \`n\` integers. If multiple valid assignments exist, return any one of them. If not possible, return an empty list. Args: n (int): The number of streets. m (int): The number of tree types. streets (List[int]): The list of street connections. restricted_pairs (List[Tuple[int, int]]): The list of restricted tree type pairs. Returns: List[int]: A valid list of tree type assignments if possible, otherwise an empty list. Examples: >>> plant_trees(6, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3)]) [1, 3, 1, 3, 1, 3] >>> plant_trees(4, 2, [1, 2, 3], [(1, 2)]) [] pass","solution":"def plant_trees(n, m, streets, restricted_pairs): adjacency_list = {i: set(range(1, m + 1)) for i in range(n)} for t1, t2 in restricted_pairs: if t2 in adjacency_list[0]: adjacency_list[0].remove(t2) if t1 in adjacency_list[1]: adjacency_list[1].remove(t1) def is_valid(assignment): for i in range(n-1): if (assignment[i], assignment[i+1]) in restricted_pairs or (assignment[i+1], assignment[i]) in restricted_pairs: return False return True def backtrack(assignment): if len(assignment) == n: return is_valid(assignment) idx = len(assignment) for tree in adjacency_list[idx]: assignment.append(tree) if backtrack(assignment): return assignment assignment.pop() return False assignment = [] result = backtrack(assignment) if result: return assignment else: return []"},{"question":"def process_hotel_operations(T: int, operations: List[str]) -> List[int]: Simulate the process of customer check-in at a hotel and track occupied rooms. Args: T : int : number of operations operations : List[str] : list of operations in the form of \\"check-in X\\" or \\"check-out X\\" Returns: List[int] : list of currently occupied room numbers in ascending order >>> process_hotel_operations(6, [\\"check-in 101\\", \\"check-in 102\\", \\"check-out 101\\", \\"check-in 103\\", \\"check-out 104\\", \\"check-in 102\\"]) [102, 103] >>> process_hotel_operations(3, [\\"check-in 1\\", \\"check-in 2\\", \\"check-in 3\\"]) [1, 2, 3] >>> process_hotel_operations(5, [\\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\"]) [100] from solution import process_hotel_operations def test_sample_case(): T = 6 operations = [ \\"check-in 101\\", \\"check-in 102\\", \\"check-out 101\\", \\"check-in 103\\", \\"check-out 104\\", \\"check-in 102\\" ] assert process_hotel_operations(T, operations) == [102, 103] def test_all_check_in(): T = 3 operations = [ \\"check-in 1\\", \\"check-in 2\\", \\"check-in 3\\" ] assert process_hotel_operations(T, operations) == [1, 2, 3] def test_multiple_check_in_same_room(): T = 5 operations = [ \\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\", \\"check-in 100\\" ] assert process_hotel_operations(T, operations) == [100] def test_check_out_non_existent_room(): T = 4 operations = [ \\"check-in 50\\", \\"check-in 60\\", \\"check-out 100\\", \\"check-out 110\\" ] assert process_hotel_operations(T, operations) == [50, 60] def test_all_operations(): T = 10 operations = [ \\"check-in 45\\", \\"check-in 56\\", \\"check-in 45\\", \\"check-out 56\\", \\"check-in 78\\", \\"check-out 45\\", \\"check-in 56\\", \\"check-out 56\\", \\"check-in 90\\", \\"check-out 100\\" ] assert process_hotel_operations(T, operations) == [78, 90]","solution":"def process_hotel_operations(T, operations): occupied_rooms = set() result = [] for operation in operations: op, room = operation.split() room = int(room) if op == \\"check-in\\": if room not in occupied_rooms: occupied_rooms.add(room) elif op == \\"check-out\\": if room in occupied_rooms: occupied_rooms.remove(room) result = sorted(occupied_rooms) return result"},{"question":"from typing import List def max_product_subarray(nums: List[int]) -> int: Find the maximum product subarray in an array of integers. The function should return the maximum product that can be achieved from a continuous subarray (containing at least one number). :param nums: List of integers :return: Maximum product of a subarray >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 pass # Unit tests def test_example_1(): assert max_product_subarray([2, 3, -2, 4]) == 6 def test_example_2(): assert max_product_subarray([-2, 0, -1]) == 0 def test_all_positive(): assert max_product_subarray([1, 2, 3, 4]) == 24 def test_all_negative(): assert max_product_subarray([-1, -2, -3, -4]) == 24 def test_mix_numbers(): assert max_product_subarray([2, 3, -2, 4, -1]) == 48 def test_single_element(): assert max_product_subarray([0]) == 0 assert max_product_subarray([-5]) == -5 assert max_product_subarray([7]) == 7 def test_empty_array(): assert max_product_subarray([]) == 0 def test_array_with_zero_and_negatives(): assert max_product_subarray([0, -1, -2, -3, 0, -4, -5]) == 20","solution":"def max_product_subarray(nums): Find the maximum product subarray. :param nums: List of integers :return: Maximum product of a subarray if not nums: return 0 max_product = current_max = current_min = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"def min_operations(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of operations needed to paint the wall according to the desired color sequence. >>> min_operations(3, [((5, 3), [2, 1, 2, 3, 1]), ((6, 4), [1, 1, 2, 3, 4, 4]), ((1, 5), [5])]) [5, 4, 1] >>> min_operations(2, [((5, 3), [1, 1, 1, 1, 1]), ((6, 2), [2, 2, 2, 2, 2, 2])]) [1, 1] # Test cases for the completion task def test_min_operations_case1(): t = 3 test_cases = [ ((5, 3), [2, 1, 2, 3, 1]), ((6, 4), [1, 1, 2, 3, 4, 4]), ((1, 5), [5]) ] expected = [5, 4, 1] assert min_operations(t, test_cases) == expected def test_min_operations_all_same_color(): t = 2 test_cases = [ ((5, 3), [1, 1, 1, 1, 1]), ((6, 2), [2, 2, 2, 2, 2, 2]) ] expected = [1, 1] assert min_operations(t, test_cases) == expected def test_min_operations_alternating_colors(): t = 1 test_cases = [ ((4, 2), [1, 2, 1, 2]) ] expected = [4] assert min_operations(t, test_cases) == expected def test_min_operations_largest_case(): t = 1 test_cases = [ ((10**5, 2), [1 if i % 2 == 0 else 2 for i in range(10**5)]) ] expected = [10**5] assert min_operations(t, test_cases) == expected","solution":"def min_operations(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] colors = test_cases[i][1] operations = 1 for j in range(1, n): if colors[j] != colors[j - 1]: operations += 1 results.append(operations) return results"},{"question":"def find_anagrams(s: str, dictionary: List[str]) -> List[str]: Returns a list of unique anagrams of the string s found in the dictionary of words. >>> find_anagrams(\\"listen\\", [\\"enlists\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"silnet\\"]) [\\"inlets\\", \\"silnet\\"] >>> find_anagrams(\\"evil\\", [\\"vile\\", \\"veil\\", \\"live\\", \\"vill\\", \\"elvi\\"]) [\\"elvi\\", \\"live\\", \\"veil\\", \\"vile\\"] >>> find_anagrams(\\"apple\\", [\\"papel\\", \\"lapel\\", \\"pepla\\", \\"appears\\"]) [\\"papel\\", \\"pepla\\"] >>> find_anagrams(\\"cat\\", [\\"dog\\", \\"bird\\", \\"fish\\"]) [] >>> find_anagrams(\\"\\", [\\"\\", \\"a\\", \\"b\\"]) [\\"\\"] >>> find_anagrams(\\"a\\", [\\"a\\", \\"b\\", \\"c\\"]) [\\"a\\"] >>> find_anagrams(\\"aab\\", [\\"baa\\", \\"aba\\", \\"aab\\", \\"abb\\", \\"bba\\"]) [\\"aab\\", \\"aba\\", \\"baa\\"] >>> find_anagrams(\\"abc\\", [\\"CBA\\", \\"bca\\", \\"CAB\\", \\"AbC\\"]) [\\"bca\\"]","solution":"def find_anagrams(s, dictionary): Returns a list of unique anagrams of the string s found in the dictionary of words. sorted_s = \\"\\".join(sorted(s)) anagrams = [word for word in dictionary if \\"\\".join(sorted(word)) == sorted_s] return sorted(anagrams)"},{"question":"def library_usage(log: List[str]) -> Tuple[str, str]: Determine the most and least popular books based on their checkout frequencies over a year. >>> library_usage([\\"5\\", \\"abc123 15\\", \\"xyz456 9\\", \\"def789 15\\", \\"lmn234 0\\", \\"pqr567 9\\"]) (\\"abc123\\", \\"lmn234\\") >>> library_usage([\\"3\\", \\"book1 5\\", \\"book2 5\\", \\"book3 5\\"]) (\\"book1\\", \\"book1\\") >>> library_usage([\\"4\\", \\"book1 5\\", \\"book2 10\\", \\"book3 5\\", \\"book4 10\\"]) (\\"book2\\", \\"book1\\") >>> library_usage([\\"1\\", \\"solo1 100\\"]) (\\"solo1\\", \\"solo1\\") >>> library_usage([\\"3\\", \\"b1 0\\", \\"b2 0\\", \\"b3 0\\"]) (\\"None\\", \\"None\\") >>> library_usage([\\"2\\", \\"book1 2\\", \\"book2 2\\"]) (\\"book1\\", \\"book1\\")","solution":"def library_usage(log): n = int(log[0]) books = [tuple(log[i + 1].split()) for i in range(n)] books = [(book_id, int(checkouts)) for book_id, checkouts in books] if all(checkouts == 0 for book_id, checkouts in books): return \\"None\\", \\"None\\" most_popular = min((book for book in books if book[1] == max(books, key=lambda x: x[1])[1]), key=lambda x: x[0]) least_popular = min((book for book in books if book[1] == min(books, key=lambda x: x[1])[1]), key=lambda x: x[0]) return most_popular[0], least_popular[0]"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string consisting of lowercase letters and returns the length of the longest substring without repeating characters. Args: s (str): The input string Returns: int: The length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Args: s (str): The input string consisting of lowercase letters. Returns: int: The length of the longest substring without repeating characters. n = len(s) char_set = set() left = 0 longest = 0 for right in range(n): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) longest = max(longest, right - left + 1) return longest"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"oxcpqrsvwf\\", \\"shmtulqrypy\\") 2 >>> longest_common_subsequence(\\"abcdgh\\", \\"aedfhr\\") 3","solution":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) # Create a (m+1) x (n+1) matrix initialized to 0 dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp matrix from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def sumStrings(a: str, b: str) -> str: Returns the sum of two non-negative integers represented as strings. The input strings will not contain any leading zeros except the number '0' itself. >>> sumStrings(\\"123\\", \\"456\\") == \\"579\\" >>> sumStrings(\\"0\\", \\"0\\") == \\"0\\" >>> sumStrings(\\"1200\\", \\"345\\") == \\"1545\\"","solution":"def sumStrings(a, b): Returns the sum of two non-negative integers represented as strings. max_len = max(len(a), len(b)) # Pad the shorter string with zeros on the left a = a.zfill(max_len) b = b.zfill(max_len) carry = 0 result = [] # Add digits from right to left for i in range(max_len - 1, -1, -1): digit_sum = int(a[i]) + int(b[i]) + carry carry = digit_sum // 10 result.append(str(digit_sum % 10)) # If there's a carry left at the end, add it to the result if carry: result.append(str(carry)) # The result list contains the digits in reverse order result.reverse() return ''.join(result)"},{"question":"def fizzbuzz(start: int, end: int) -> List[str]: Simulates the game of \\"FizzBuzz\\" for a given range of numbers. Returns a list of strings with the following conditions: - For numbers divisible by both 3 and 5, append \\"FizzBuzz\\". - For numbers divisible by only 3, append \\"Fizz\\". - For numbers divisible by only 5, append \\"Buzz\\". - For numbers not divisible by either 3 or 5, append the number itself as a string. >>> fizzbuzz(1, 15) ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz'] >>> fizzbuzz(3, 3) ['Fizz'] >>> fizzbuzz(5, 5) ['Buzz'] >>> fizzbuzz(15, 15) ['FizzBuzz'] >>> fizzbuzz(7, 7) ['7'] >>> fizzbuzz(-5, 5) ['Buzz', '-4', 'Fizz', '-2', '-1', 'FizzBuzz', '1', '2', 'Fizz', '4', 'Buzz'] >>> fizzbuzz(3, 9) ['Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz'] >>> fizzbuzz(5, 10) ['Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz']","solution":"def fizzbuzz(start, end): Returns a list of strings representing the FizzBuzz game results from start to end (inclusive). result = [] for num in range(start, end + 1): if num % 3 == 0 and num % 5 == 0: result.append(\\"FizzBuzz\\") elif num % 3 == 0: result.append(\\"Fizz\\") elif num % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(num)) return result"},{"question":"from typing import List, Dict def max_code_words(T: int, test_cases: List[Dict]) -> List[int]: Determines the maximum number of valid code words that can be formed from the encrypted message using the provided dictionary of code words. Parameters: T (int): The number of test cases. test_cases (List[Dict]): A list of dictionaries, where each dictionary contains: - 'M': An integer representing the number of valid code words in the dictionary. - 'code_words': A list of strings representing the valid code words. - 'message': A string representing the encrypted message. Returns: List[int]: A list of integers where each integer represents the maximum number of valid code words that can be formed for each test case. Example: >>> max_code_words(2, [{'M': 3, 'code_words': ['apple', 'pear', 'pie'], 'message': 'apwpelearpi'}, {'M': 2, 'code_words': ['rock', 'star'], 'message': 'roctkstarrckor'}]) [2, 3] pass def test_max_code_words(): test_cases = [ {'M': 3, 'code_words': ['apple', 'pear', 'pie'], 'message': 'apwpelearpi'}, {'M': 2, 'code_words': ['rock', 'star'], 'message': 'roctkstarrckor'} ] assert max_code_words(2, test_cases) == [2, 3] test_cases = [ {'M': 3, 'code_words': ['apple', 'banana', 'orange'], 'message': 'aabbovrnana'}, {'M': 2, 'code_words': ['hi', 'hello'], 'message': 'hellohellohello'} ] assert max_code_words(2, test_cases) == [1, 3] test_cases = [ {'M': 1, 'code_words': ['a'], 'message': 'aaaaa'}, {'M': 1, 'code_words': ['z'], 'message': 'yyy'} ] assert max_code_words(2, test_cases) == [5, 0] test_cases = [ {'M': 3, 'code_words': ['abc', 'def', 'ghi'], 'message': 'abcdefghii'}, {'M': 3, 'code_words': ['dog', 'cat', 'fish'], 'message': 'catfish'} ] assert max_code_words(2, test_cases) == [3, 2] test_cases = [ {'M': 2, 'code_words': ['foo', 'bar'], 'message': 'bazfoo'} ] assert max_code_words(1, test_cases) == [1]","solution":"from collections import Counter def max_code_words(T, test_cases): results = [] for case in test_cases: M, code_words, message = case['M'], case['code_words'], case['message'] word_count = 0 # Create a frequency dict for the message message_counter = Counter(message) for word in code_words: word_counter = Counter(word) min_count = float('inf') # Compute the max number of this word we can make from the message for char in word_counter: if char in message_counter: min_count = min(min_count, message_counter[char] // word_counter[char]) else: min_count = 0 break word_count += min_count # Update message_counter by removing used counts for char in word_counter: message_counter[char] -= word_counter[char] * min_count results.append(word_count) return results"},{"question":"def max_profit(prices): Calculate the maximum profit with unlimited transactions. :param prices: List of stock prices on consecutive days. :return: Maximum profit achievable. pass def calculate_max_profits(test_cases): Calculate the maximum profit for multiple test cases. :param test_cases: List of tuples, where each tuple contains the count of days and a list of stock prices. :return: List of maximum profits for each test case. pass # Unit test examples def test_max_profit_basic(): assert max_profit([7, 1, 5, 3, 6, 4]) == 7 assert max_profit([1, 2, 3, 4]) == 3 assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_edge_cases(): assert max_profit([]) == 0 assert max_profit([5]) == 0 assert max_profit([1, 1, 1, 1]) == 0 def test_calculate_max_profits(): test_cases = [ (6, [7, 1, 5, 3, 6, 4]), (4, [1, 2, 3, 4]), (5, [7, 6, 4, 3, 1]) ] assert calculate_max_profits(test_cases) == [7, 3, 0] test_cases = [ (3, [3, 2, 6]), (2, [1, 5]) ] assert calculate_max_profits(test_cases) == [4, 4]","solution":"def max_profit(prices): Calculate the maximum profit with unlimited transactions. :param prices: List of stock prices on consecutive days. :return: Maximum profit achievable. if not prices or len(prices) < 2: return 0 profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: profit += prices[i] - prices[i - 1] return profit def calculate_max_profits(test_cases): results = [] for case in test_cases: n, prices = case results.append(max_profit(prices)) return results"},{"question":"def first_larger_than_prev(arr: List[int]) -> int: Returns the index of the first element that is larger than its preceding element. If no such element exists, returns -1. >>> first_larger_than_prev([1, 2, 3, 4, 5]) == 1 >>> first_larger_than_prev([5, 1, 4, 2, 3]) == 2 >>> first_larger_than_prev([7, 8, 7, 8, 7]) == 1 >>> first_larger_than_prev([7, 5, 3, 1]) == -1 >>> first_larger_than_prev([2]) == -1 >>> first_larger_than_prev([1, 1, 1, 1]) == -1 >>> first_larger_than_prev([1, 2, 1, 2]) == 1 >>> first_larger_than_prev([5, 10, 5, 10]) == 1 >>> first_larger_than_prev([0, 0, 0, 1]) == 3","solution":"def first_larger_than_prev(arr): Returns the index of the first element that is larger than its preceding element. If no such element exists, returns -1. for i in range(1, len(arr)): if arr[i] > arr[i - 1]: return i return -1"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes required to make the string a palindrome. >>> min_changes_to_palindrome(\\"abb\\") == 1 >>> min_changes_to_palindrome(\\"abcd\\") == 2 >>> min_changes_to_palindrome(\\"race\\") == 2 >>> min_changes_to_palindrome(\\"a\\") == 0 >>> min_changes_to_palindrome(\\"aa\\") == 0 >>> min_changes_to_palindrome(\\"ab\\") == 1 >>> min_changes_to_palindrome(\\"abcba\\") == 0 >>> min_changes_to_palindrome(\\"abcdba\\") == 1 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Returns a list of the minimum number of character changes required to make the strings in test_cases palindromes. >>> process_test_cases(3, [\\"abb\\", \\"abcd\\", \\"race\\"]) == [1, 2, 2] >>> process_test_cases(2, [\\"a\\", \\"ab\\"]) == [0, 1] >>> process_test_cases(4, [\\"abcba\\", \\"abcdba\\", \\"abccba\\", \\"abacaba\\"]) == [0, 1, 0, 0] pass","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes required to make the string a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes def process_test_cases(T, test_cases): results = [] for i in range(T): results.append(min_changes_to_palindrome(test_cases[i])) return results"},{"question":"def longest_subsequence_with_diff_two(nums: List[int]) -> int: Given an integer array nums, return the length of the longest strictly increasing subsequence of the integers in that array where the difference between consecutive integers is exactly 2. If there is no such subsequence in the array, return 0. Example 1: >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] >>> longest_subsequence_with_diff_two(nums) 5 Example 2: >>> nums = [5, 1, 3, 9, 7] >>> longest_subsequence_with_diff_two(nums) 2 Constraints: 1 <= nums.length <= 10^4 -10^4 <= nums[i] <= 10^4 from solution import longest_subsequence_with_diff_two def test_example_1(): nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10] assert longest_subsequence_with_diff_two(nums) == 5 def test_example_2(): nums = [5, 1, 3, 9, 7] assert longest_subsequence_with_diff_two(nums) == 2 def test_no_subsequence(): nums = [1, 1, 1, 1] assert longest_subsequence_with_diff_two(nums) == 1 def test_all_identical_numbers(): nums = [2, 2, 2, 2, 2] assert longest_subsequence_with_diff_two(nums) == 1 def test_single_element(): nums = [10] assert longest_subsequence_with_diff_two(nums) == 1 def test_empty_input(): nums = [] assert longest_subsequence_with_diff_two(nums) == 0 def test_large_gap(): nums = [1, 5, 9, 13] assert longest_subsequence_with_diff_two(nums) == 1 def test_mixed_sequence(): nums = [1, 3, 5, 10, 12, 14] assert longest_subsequence_with_diff_two(nums) == 3","solution":"def longest_subsequence_with_diff_two(nums): Returns the length of the longest strictly increasing subsequence in nums where the difference between consecutive integers is exactly 2. if not nums: return 0 # A dictionary to store the max length of subsequence ending with a specific number. subseq_lengths = {} for num in nums: if num - 2 in subseq_lengths: subseq_lengths[num] = subseq_lengths[num - 2] + 1 else: subseq_lengths[num] = 1 # Return the maximum length found return max(subseq_lengths.values())"}]`),C={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},D={class:"card-container"},z={key:0,class:"empty-state"},j=["disabled"],E={key:0},I={key:1};function P(n,e,l,m,i,a){const f=p("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")},"  ")):u("",!0)]),t("div",D,[(s(!0),r(y,null,w(a.displayedPoems,(o,h)=>(s(),v(f,{key:h,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",z,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",I,"Loading...")):(s(),r("span",E,"See more"))],8,j)):u("",!0)])}const M=_(C,[["render",P],["__scopeId","data-v-e32b6a66"]]),G=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/63.md","filePath":"grok/63.md"}'),B={name:"grok/63.md"},Y=Object.assign(B,{setup(n){return(e,l)=>(s(),r("div",null,[x(M)]))}});export{G as __pageData,Y as default};
