import{_ as c,o as s,c as i,a as t,m,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(n,e,u,_,r,a){return s(),i("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const S=c(q,[["render",R],["__scopeId","data-v-440f139c"]]),A=JSON.parse(`[{"question":"from typing import List def shortest_path_in_grid(grids: List[List[List[int]]]) -> List[int]: Determine the length of the shortest path from the top-left corner to the bottom-right corner of each grid. Only cells with a value of 0 are traversable, and you can only move right, left, up, or down. >>> parse_input(\\"1n3 3n0 0 1n0 1 0n0 0 0n\\") [[[0, 0, 1], [0, 1, 0], [0, 0, 0]]] >>> shortest_path_in_grid([[[0, 0, 1], [0, 1, 0], [0, 0, 0]]]) [4] pass def parse_input(data: str) -> List[List[List[int]]]: Parse the input data and return a list of grids. >>> parse_input(\\"1n3 3n0 0 1n0 1 0n0 0 0n\\") [[[0, 0, 1], [0, 1, 0], [0, 0, 0]]] pass def main(input_data: str): grids = parse_input(input_data) results = shortest_path_in_grid(grids) for result in results: print(result)","solution":"from collections import deque def shortest_path_in_grid(grids): def bfs(grid): n, m = len(grid), len(grid[0]) if grid[0][0] != 0 or grid[n-1][m-1] != 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] q = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while q: x, y, dist = q.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) q.append((nx, ny, dist + 1)) return -1 results = [] for grid in grids: results.append(bfs(grid)) return results def parse_input(data): lines = data.split('n') index = 0 test_cases = [] T = int(lines[index].strip()) index += 1 for _ in range(T): N, M = map(int, lines[index].strip().split()) index += 1 grid = [] for _ in range(N): grid.append(list(map(int, lines[index].strip().split()))) index += 1 test_cases.append(grid) return test_cases def main(input_data): grids = parse_input(input_data) results = shortest_path_in_grid(grids) for result in results: print(result)"},{"question":"def longest_common_palindromic_subsequence(seq1, seq2) -> int: Returns the length of the Longest Common Palindromic Subsequence (LCPS) of the given two sequences. >>> longest_common_palindromic_subsequence([1, 2, 3, 4], [3, 2, 1, 3]) == 3 >>> longest_common_palindromic_subsequence([1, 2, 3], [4, 5, 6]) == 0 >>> longest_common_palindromic_subsequence([1, 2, 3, 4, 3], [3, 4, 3, 2, 1]) == 5","solution":"def lcs(X, Y): Helper function to find the length of Longest Common Subsequence (LCS) of sequences X and Y. n = len(X) m = len(Y) L = [[0] * (m + 1) for i in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[n][m] def longest_common_palindromic_subsequence(seq1, seq2): Returns the length of the Longest Common Palindromic Subsequence (LCPS) of the given two sequences. seq2_reversed = seq2[::-1] return lcs(seq1, seq2_reversed)"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. def prime_factors(n: int) -> List[int]: Helper function to get the prime factors of a number. def sum_of_digits(n: int) -> int: Helper function to sum the digits of a number. def smith_number(n: int) -> str: Return \\"Smith !!\\" if the number is a Smith number, otherwise \\"Not !!\\". >>> smith_number(22) 'Smith !!' >>> smith_number(13) 'Not !!'","solution":"def is_prime(n): Helper function to check if a number is prime. if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def prime_factors(n): Helper function to get the prime factors of a number. i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def sum_of_digits(n): Helper function to sum the digits of a number. return sum(int(digit) for digit in str(n)) def smith_number(n): Return \\"Smith !!\\" if the number is a Smith number, otherwise \\"Not !!\\". if is_prime(n): return \\"Not !!\\" prime_fact = prime_factors(n) sum_n = sum_of_digits(n) sum_factors = sum(sum_of_digits(factor) for factor in prime_fact) if sum_n == sum_factors: return \\"Smith !!\\" else: return \\"Not !!\\""},{"question":"def can_cat_catch_mouse(n, m, k, s, t, edges): Determine if the cat can catch the mouse in an undirected unweighted graph. Args: n : int : number of nodes m : int : number of edges k : int : time interval for the mouse's movement s : int : starting node of the cat t : int : starting node of the mouse edges : List[Tuple[int, int]] : list of edges in the graph Returns: str : \\"Yes\\" if the cat can catch the mouse, \\"No\\" otherwise Examples: >>> can_cat_catch_mouse(6, 7, 2, 1, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (2, 4), (2, 5)]) 'Yes' >>> can_cat_catch_mouse(4, 4, 1, 1, 4, [(1, 2), (2, 3), (3, 4), (2, 4)]) 'No' >>> can_cat_catch_mouse(5, 5, 0, 3, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) 'Yes' >>> can_cat_catch_mouse(3, 2, 1, 1, 3, [(1, 2), (2, 3)]) 'No' >>> can_cat_catch_mouse(3, 3, 0, 1, 3, [(1, 2), (2, 3), (1, 3)]) 'Yes'","solution":"from collections import deque def can_cat_catch_mouse(n, m, k, s, t, edges): def bfs(start): distances = [-1] * (n + 1) queue = deque([start]) distances[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + 1 queue.append(neighbor) return distances graph = [[] for _ in range(n + 1)] for u, v in edges: graph[u].append(v) graph[v].append(u) cat_distances = bfs(s) mouse_distances = bfs(t) time_to_catch = cat_distances[t] if time_to_catch == -1: return \\"No\\" if k == 0: return \\"Yes\\" mouse_time = time_to_catch / k if mouse_time.is_integer(): return \\"No\\" return \\"Yes\\""},{"question":"def find_k_for_sum_x(n: int, x: int) -> int: Determines if x can be written as the sum of the first k primes for some k. If possible, finds the smallest possible k such that the sum of the first k prime numbers equals x. >>> find_k_for_sum_x(20, 17) == 4 >>> find_k_for_sum_x(100, 41) == 6 >>> find_k_for_sum_x(50, 30) == -1","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_k_for_sum_x(n, x): primes = [] i = 2 while sum(primes) <= n: if is_prime(i): primes.append(i) if sum(primes) == x: return len(primes) i += 1 return -1"},{"question":"from typing import List, Tuple def check_discount_eligibility(test_cases: List[Tuple[int, int, int, int]]) -> List[str]: Determine if customers are eligible for a discount based on their total spending and number of purchases. >>> check_discount_eligibility([(500, 10, 600, 11), (1000, 5, 800, 10), (300, 2, 400, 2), (750, 8, 750, 7)]) ['YES', 'NO', 'YES', 'NO'] >>> check_discount_eligibility([(700, 3, 700, 3), (1500, 5, 1600, 6)]) ['YES', 'YES'] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, int, int]]]: Parse the input string to extract the number of test cases and their respective parameters. >>> parse_input('4n500 10 600 11n1000 5 800 10n300 2 400 2n750 8 750 7') (4, [(500, 10, 600, 11), (1000, 5, 800, 10), (300, 2, 400, 2), (750, 8, 750, 7)]) >>> parse_input('2n700 3 700 3n1500 5 1600 6') (2, [(700, 3, 700, 3), (1500, 5, 1600, 6)]) pass def main(input_string: str): Main function to handle input and output for checking discount eligibility. pass","solution":"def check_discount_eligibility(test_cases): results = [] for case in test_cases: P, Q, S, R = case if S >= P and R >= Q: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] for line in lines[1:]: P, Q, S, R = map(int, line.split()) test_cases.append((P, Q, S, R)) return T, test_cases def main(input_string): T, test_cases = parse_input(input_string) results = check_discount_eligibility(test_cases) for result in results: print(result)"},{"question":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: Given an array of integers and a target number, find all unique combinations in the array where the integers sum up to the target number. Each number in the array may be used multiple times in the combination. Args: candidates : List[int] - List of integers, each integer is positive and sorted in non-descending order. target : int - Target integer. Returns: List[List[int]] - List of unique combinations that add up to the target integer. Example: >>> combination_sum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] pass def test_combination_sum_example(): assert combination_sum([2, 3, 5], 8) == [ [2, 2, 2, 2], [2, 3, 3], [3, 5] ] def test_combination_sum_single_element(): assert combination_sum([2], 4) == [ [2, 2] ] def test_combination_sum_no_combination(): assert combination_sum([3, 7], 5) == [] def test_combination_sum_larger_numbers(): assert combination_sum([2, 3, 6, 7], 7) == [ [2, 2, 3], [7] ] def test_combination_sum_multiple_elements(): assert combination_sum([2, 3, 5], 10) == [ [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 3, 5], [5, 5] ]","solution":"def combination_sum(candidates, target): res = [] def backtrack(remain, comb, start): if remain == 0: res.append(list(comb)) return if remain < 0: return for i in range(start, len(candidates)): comb.append(candidates[i]) backtrack(remain - candidates[i], comb, i) comb.pop() candidates.sort() backtrack(target, [], 0) return res"},{"question":"def longest_palindrome_substring_length(s: str) -> int: Returns the length of the longest palindrome substring that can be formed by re-ordering the characters of the given string. Args: s (str): input string consisting of lowercase English letters. Returns: int: length of the longest palindromic substring. Examples: >>> longest_palindrome_substring_length(\\"abcb\\") 3 >>> longest_palindrome_substring_length(\\"aabbcc\\") 6 >>> longest_palindrome_substring_length(\\"abcde\\") 1","solution":"def longest_palindrome_substring_length(s): Returns the length of the longest palindrome substring that can be formed by re-ordering the characters of the given string. Args: s (str): input string consisting of lowercase English letters. Returns: int: length of the longest palindromic substring. from collections import Counter char_count = Counter(s) length = 0 odd_count_found = False for count in char_count.values(): # Add the even count part (if the count is odd, it means odd-1 is even) length += count // 2 * 2 # Check if there is any odd count if count % 2 == 1: odd_count_found = True # Add one if there's at least one odd count to allow one central character if odd_count_found: length += 1 return length"},{"question":"def minimize_sum_of_maximums(nums: List[int], k: int) -> int: You are given an integer array nums consisting of n elements, and an integer k. You are tasked with creating a partition of the array into k non-empty contiguous subarrays such that the sum of the maximum of each subarray is minimized. A contiguous subarray is a subarray where the elements are consecutive elements from the original array. Return the minimized sum of the maximum values from each subarray. >>> minimize_sum_of_maximums([1, 3, 2, 5, 8, 7, 4], 3) 8 >>> minimize_sum_of_maximums([10, 1, 2, 7, 4, 9], 2) 10 >>> minimize_sum_of_maximums([3, 2, 1, 6, 4, 5], 4) 6 >>> minimize_sum_of_maximums([5], 1) 5 >>> minimize_sum_of_maximums([2, 2, 2, 2], 2) 2 >>> minimize_sum_of_maximums([1, 2, 3, 4, 5], 5) 5","solution":"def minimize_sum_of_maximums(nums, k): import math def can_partition(mid): partitions = 1 current_max = -math.inf for num in nums: current_max = max(current_max, num) if current_max > mid: partitions += 1 current_max = num if partitions > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"def format_phone_number(phone_number: str) -> str: Ensures consistency in formatting phone numbers in a standardized format: \\"(XXX) XXX-XXXX\\". The input string can have various delimiters, spaces, or no delimiters at all but will always contain exactly 10 digits. Parameters: phone_number (str): A string containing exactly 10 digits and various possible delimiters. Returns: str: The phone number formatted as \\"(XXX) XXX-XXXX\\". >>> format_phone_number(\\"1234567890\\") \\"(123) 456-7890\\" >>> format_phone_number(\\"123-456-7890\\") \\"(123) 456-7890\\" >>> format_phone_number(\\"123 456 7890\\") \\"(123) 456-7890\\" >>> format_phone_number(\\"123-456 7890\\") \\"(123) 456-7890\\" >>> format_phone_number(\\"(123)456-7890\\") \\"(123) 456-7890\\" >>> format_phone_number(\\"123.a456*b7890-\\") \\"(123) 456-7890\\"","solution":"def format_phone_number(phone_number): Formats a phone number string to the \\"(XXX) XXX-XXXX\\" format. Parameters: phone_number (str): A string containing exactly 10 digits and various possible delimiters. Returns: str: The phone number formatted as \\"(XXX) XXX-XXXX\\". # Remove all non-digit characters from the input string digits = ''.join(filter(str.isdigit, phone_number)) # Ensure there are exactly 10 digits if len(digits) != 10: raise ValueError(\\"Phone number must contain exactly 10 digits\\") # Format the digits into the standard phone number format formatted_number = f\\"({digits[:3]}) {digits[3:6]}-{digits[6:]}\\" return formatted_number"},{"question":"def missing_marbles(R1, B1, G1, Y1, R2, B2, G2, Y2): Returns the number of missing marbles of each color. Parameters: R1, B1, G1, Y1 (int): original counts of red, blue, green, and yellow marbles R2, B2, G2, Y2 (int): current counts of red, blue, green, and yellow marbles Returns: tuple: number of red, blue, green, and yellow marbles that are missing >>> missing_marbles(5, 7, 8, 6, 3, 6, 7, 4) (2, 1, 1, 2) >>> missing_marbles(10, 10, 10, 10, 10, 10, 10, 10) (0, 0, 0, 0) >>> missing_marbles(0, 0, 0, 0, 0, 0, 0, 0) (0, 0, 0, 0) >>> missing_marbles(1000000, 500000, 300000, 100000, 500000, 300000, 100000, 50000) (500000, 200000, 200000, 50000) >>> missing_marbles(1, 2, 3, 4, 0, 2, 3, 4) (1, 0,0, 0) >>> missing_marbles(1, 2, 3, 4, 1, 1, 3, 3) (0, 1, 0, 1)","solution":"def missing_marbles(R1, B1, G1, Y1, R2, B2, G2, Y2): Returns the number of missing marbles of each color. Parameters: R1, B1, G1, Y1 (int): original counts of red, blue, green, and yellow marbles R2, B2, G2, Y2 (int): current counts of red, blue, green, and yellow marbles Returns: tuple: number of red, blue, green, and yellow marbles that are missing missing_red = R1 - R2 missing_blue = B1 - B2 missing_green = G1 - G2 missing_yellow = Y1 - Y2 return (missing_red, missing_blue, missing_green, missing_yellow)"},{"question":"from typing import List, Tuple def max_sum_root_to_leaf(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum sum of values from root node to any leaf node. >>> max_sum_root_to_leaf(5, [3, 2, 1, 10, 4], [(1, 2), (1, 3), (2, 4), (2, 5)]) == 15 >>> max_sum_root_to_leaf(3, [1, 4, 5], [(1, 2), (1, 3)]) == 6 >>> max_sum_root_to_leaf(1, [5], []) == 5","solution":"def max_sum_root_to_leaf(n, values, edges): from collections import defaultdict, deque # Create adjacency list for the tree tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Use BFS to find the maximum sum path from root to leaf queue = deque([(1, values[0])]) # Start from root node (index 1) with its value max_sum = 0 while queue: node, current_sum = queue.popleft() is_leaf = True for neighbor in tree[node]: if values[neighbor - 1] != -1: # If this node has not been visited is_leaf = False queue.append((neighbor, current_sum + values[neighbor - 1])) if is_leaf: max_sum = max(max_sum, current_sum) values[node - 1] = -1 # Mark this node as visited (by setting its value to -1) return max_sum"},{"question":"def count_palindromic_subsequences(seq: List[int]) -> int: Counts the number of contiguous palindromic subsequences in the given sequence. :param seq: List[int] - A list of integers representing the sequence. :return: int - The count of palindromic subsequences. >>> count_palindromic_subsequences([1]) 1 >>> count_palindromic_subsequences([1, 1]) 3 >>> count_palindromic_subsequences([1, 2]) 2 >>> count_palindromic_subsequences([1, 2, 3, 2, 1]) 7 >>> count_palindromic_subsequences([1, 1, 1, 1]) 10 >>> count_palindromic_subsequences([1, 2, 3, 4, 5]) 5 >>> count_palindromic_subsequences([1, 2, 1, 2, 1]) 9","solution":"def count_palindromic_subsequences(seq): Counts the number of contiguous palindromic subsequences in the given sequence. :param seq: List[int] - A list of integers representing the sequence. :return: int - The count of palindromic subsequences. n = len(seq) dp = [[False] * n for _ in range(n)] count = 0 for i in range(n): dp[i][i] = True count += 1 for length in range(2, n + 1): for start in range(n - length + 1): end = start + length - 1 if seq[start] == seq[end]: if length == 2 or dp[start + 1][end - 1]: dp[start][end] = True count += 1 return count"},{"question":"def simplify_skyline(buildings): Simplify the skyline silhouette by merging overlapping buildings while maintaining the highest height at any given x-coordinate. :param buildings: A list of tuples (left, right, height) representing the buildings. :return: A list of tuples (left, right, height) representing the simplified silhouette. pass def process_skyline_input(input_string): Processes the input string to read the buildings and return the simplified skyline silhouette. :param input_string: The input string with the building outlines in the specified format. :return: A list of tuples (left, right, height) representing the simplified skyline silhouette. >>> process_skyline_input(\\"3n1 3 4n2 5 3n6 8 5\\") [(1, 5, 4), (6, 8, 5)] >>> process_skyline_input(\\"4n1 2 1n2 4 2n3 5 3n5 6 1\\") [(1, 6, 3)] >>> process_skyline_input(\\"0\\") [] >>> process_skyline_input(\\"2n1 3 4n4 6 3\\") [(1, 3, 4), (4, 6, 3)] >>> process_skyline_input(\\"2n1 5 4n2 4 5\\") [(1, 5, 5)] pass","solution":"def simplify_skyline(buildings): This function simplifies the skyline silhouette by merging overlapping buildings while maintaining the highest height at any given x-coordinate. :param buildings: A list of tuples (left, right, height) representing the buildings. :return: A list of tuples (left, right, height) representing the simplified silhouette. if not buildings: return [] # Sort buildings by their left coordinate first, and if equal by their right coordinate buildings.sort() result = [] current_left, current_right, current_height = buildings[0] for left, right, height in buildings[1:]: if left <= current_right: # Overlapping if right > current_right: # Update current_right to the max of current right or new right current_right = right # Update current_height to the max height between overlapping buildings if height > current_height: current_height = height else: # No overlap result.append((current_left, current_right, current_height)) current_left, current_right, current_height = left, right, height result.append((current_left, current_right, current_height)) return result def process_skyline_input(input_string): This function processes the input string to read the buildings and return the simplified skyline silhouette. :param input_string: The input string with the building outlines in the specified format. :return: A list of tuples (left, right, height) representing the simplified skyline silhouette. lines = input_string.strip().split(\\"n\\") N = int(lines[0]) buildings = [] for i in range(1, N + 1): l, r, h = map(int, lines[i].split()) buildings.append((l, r, h)) return simplify_skyline(buildings)"},{"question":"def countDistinctSortedSubstrings(S: str) -> int: Returns the number of distinct substrings that can be formed by rearranging the characters of each substring in lexicographical order. >>> countDistinctSortedSubstrings(\\"abc\\") 6 >>> countDistinctSortedSubstrings(\\"aaa\\") 3 >>> countDistinctSortedSubstrings(\\"a\\") 1 >>> countDistinctSortedSubstrings(\\"aa\\") 2 >>> countDistinctSortedSubstrings(\\"ab\\") 3 >>> countDistinctSortedSubstrings(\\"abcd\\") 10 >>> countDistinctSortedSubstrings(\\"aab\\") 5","solution":"def countDistinctSortedSubstrings(S): Returns the number of distinct substrings that can be formed by rearranging the characters of each substring in lexicographical order. substrings = set() for start in range(len(S)): for end in range(start + 1, len(S) + 1): substring = S[start:end] sorted_substring = ''.join(sorted(substring)) substrings.add(sorted_substring) return len(substrings)"},{"question":"def max_different_colors(n, flowers): Determines the maximum number of different colors in the bouquet if Megan can only pick one flower of each type. Parameters: n (int): The number of flowers. flowers (list of tuples): Each tuple contains two strings representing the type and color of a flower. Returns: int: The maximum number of different colors in the bouquet. pass # Example test cases def test_max_different_colors(): # Example test case provided in the problem statement n = 5 flowers = [(\\"rose\\", \\"red\\"), (\\"rose\\", \\"yellow\\"), (\\"lily\\", \\"white\\"), (\\"lily\\", \\"pink\\"), (\\"tulip\\", \\"purple\\")] assert max_different_colors(n, flowers) == 3 # Test case with all flowers of same type but different colors n = 4 flowers = [(\\"rose\\", \\"red\\"), (\\"rose\\", \\"yellow\\"), (\\"rose\\", \\"white\\"), (\\"rose\\", \\"pink\\")] assert max_different_colors(n, flowers) == 1 # Test case with all flowers of different types n = 4 flowers = [(\\"rose\\", \\"red\\"), (\\"lily\\", \\"yellow\\"), (\\"tulip\\", \\"white\\"), (\\"daisy\\", \\"pink\\")] assert max_different_colors(n, flowers) == 4 # Edge case with minimum input n = 1 flowers = [(\\"rose\\", \\"red\\")] assert max_different_colors(n, flowers) == 1 # Test case with some same types and different colors n = 6 flowers = [(\\"rose\\", \\"red\\"), (\\"rose\\", \\"yellow\\"), (\\"lily\\", \\"white\\"), (\\"lily\\", \\"pink\\"), (\\"tulip\\", \\"purple\\"), (\\"daisy\\", \\"blue\\")] assert max_different_colors(n, flowers) == 4","solution":"def max_different_colors(n, flowers): Determines the maximum number of different colors in the bouquet if Megan can only pick one flower of each type. Parameters: n (int): The number of flowers. flowers (list of tuples): Each tuple contains two strings representing the type and color of a flower. Returns: int: The maximum number of different colors in the bouquet. flower_dict = {} for flower_type, flower_color in flowers: if flower_type not in flower_dict: flower_dict[flower_type] = flower_color return len(flower_dict)"},{"question":"def min_stops_to_destination(N: int, distances: List[int], fuels: List[int], D: int, F: int) -> int: Returns the minimum number of stops needed to reach the destination. >>> min_stops_to_destination(4, [10, 20, 30, 40], [10, 20, 5, 30], 50, 20) == 2 >>> min_stops_to_destination(3, [15, 25, 35], [5, 10, 10], 60, 30) == -1","solution":"import heapq def min_stops_to_destination(N, distances, fuels, D, F): Returns the minimum number of stops needed to reach the destination. if F >= D: return 0 max_heap = [] stops = 0 current_pos = 0 current_fuel = F for i in range(N): next_pos = distances[i] fuel_at_station = fuels[i] while current_fuel < next_pos - current_pos: if not max_heap: return -1 current_fuel += -heapq.heappop(max_heap) stops += 1 current_fuel -= (next_pos - current_pos) current_pos = next_pos heapq.heappush(max_heap, -fuel_at_station) while current_fuel < D - current_pos: if not max_heap: return -1 current_fuel += -heapq.heappop(max_heap) stops += 1 return stops"},{"question":"def generateSequence(N): Generates the sequence S of length N where S[i] is 0 for multiples of 3, 1 for numbers that leave a remainder of 1 when divided by 3, and 2 for numbers that leave a remainder of 2 when divided by 3. >>> generateSequence(5) [0, 1, 2, 0, 1] >>> generateSequence(10) [0, 1, 2, 0, 1, 2, 0, 1, 2, 0] >>> generateSequence(1) [0] >>> generateSequence(2) [0, 1] >>> generateSequence(3) [0, 1, 2] >>> generateSequence(10**6)[::3] == [0] * ((10**6 + 2) // 3) True","solution":"def generateSequence(N): Generates the sequence S of length N where S[i] is 0 for multiples of 3, 1 for numbers that leave a remainder of 1 when divided by 3, and 2 for numbers that leave a remainder of 2 when divided by 3. return [i % 3 for i in range(N)]"},{"question":"def largest_square_with_same_letters(grid: List[str], n: int) -> int: Returns the side length of the largest square subgrid where all the letters are the same. >>> largest_square_with_same_letters([ \\"aaaa\\", \\"aabb\\", \\"aabb\\", \\"aabb\\" ], 4) 2 >>> largest_square_with_same_letters([ \\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\", \\"uvwxy\\" ], 5) 1 >>> largest_square_with_same_letters([\\"a\\"], 1) 1 >>> largest_square_with_same_letters([ \\"aaa\\", \\"aaa\\", \\"aaa\\" ], 3) 3 >>> largest_square_with_same_letters([ \\"aabb\\", \\"aabb\\", \\"cccc\\", \\"dddd\\" ], 4) 2","solution":"def largest_square_with_same_letters(grid, n): Returns the side length of the largest square subgrid where all the letters are the same. if n == 1: return 1 dp = [[0] * n for _ in range(n)] max_len = 1 for i in range(n): dp[i][0] = 1 dp[0][i] = 1 for i in range(1, n): for j in range(1, n): if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_len = max(max_len, dp[i][j]) else: dp[i][j] = 1 return max_len"},{"question":"def days_until_warmer(temperatures): Given a list of temperatures, returns a list of integers where each integer represents the number of days you would have to wait until a warmer temperature. If no such day exists, return 0 for that day. >>> days_until_warmer([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> days_until_warmer([70, 68, 72, 76, 73, 75]) [2, 1, 1, 0, 1, 0] >>> days_until_warmer([60, 60, 60, 60]) [0, 0, 0, 0] >>> days_until_warmer([70]) [0] >>> days_until_warmer([70, 71, 72, 73]) [1, 1, 1, 0] >>> days_until_warmer([73, 72, 71, 70]) [0, 0, 0, 0] >>> days_until_warmer([70, 70, 70, 70]) [0, 0, 0, 0]","solution":"def days_until_warmer(temperatures): Given a list of temperatures, returns a list of integers where each integer represents the number of days you would have to wait until a warmer temperature. If no such day exists, return 0 for that day. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def findLongestSubstring(S: str) -> int: Returns the length of the longest substring without repeating characters. Args: S (str): input string Returns: int: length of the longest substring without repeating characters Examples: >>> findLongestSubstring(\\"abcabcbb\\") 3 >>> findLongestSubstring(\\"bbbbb\\") 1 >>> findLongestSubstring(\\"pwwkew\\") 3 pass from solution import findLongestSubstring def test_example_1(): assert findLongestSubstring(\\"abcabcbb\\") == 3 def test_example_2(): assert findLongestSubstring(\\"bbbbb\\") == 1 def test_example_3(): assert findLongestSubstring(\\"pwwkew\\") == 3 def test_empty_string(): assert findLongestSubstring(\\"\\") == 0 def test_single_character(): assert findLongestSubstring(\\"a\\") == 1 def test_all_unique_characters(): assert findLongestSubstring(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_some_repeating_characters(): assert findLongestSubstring(\\"aababcabcdabcde\\") == 5 def test_no_repeating_characters(): assert findLongestSubstring(\\"abcdefg\\") == 7","solution":"def findLongestSubstring(S): Returns the length of the longest substring without repeating characters. char_index = {} longest = 0 start = 0 for end, char in enumerate(S): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s, determine the length of the longest substring that contains only unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abccba\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index_map = {} longest_length = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest_length = max(longest_length, end - start + 1) return longest_length"},{"question":"def count_multiples_of_k(N: int, K: int, A: List[int]) -> int: Counts how many multiples of K are present in the list A of length N. Args: - N (int): The number of elements in A. - K (int): The integer to find multiples of. - A (List[int]): A list of integers. Returns: - int: The count of multiples of K in the list A. Examples: >>> count_multiples_of_k(5, 2, [4, 3, 5, 2, 6]) 3 >>> count_multiples_of_k(4, 3, [9, 7, 12, 18]) 3 >>> count_multiples_of_k(5, 2, [1, 3, 5, 7, 9]) 0 >>> count_multiples_of_k(4, 1, [7, 14, 21, 28]) 4 >>> count_multiples_of_k(6, 5, [5, 10, 20, 25, 30, 35]) 6","solution":"def count_multiples_of_k(N, K, A): Counts how many multiples of K are present in the list A of length N. Args: - N (int): The number of elements in A. - K (int): The integer to find multiples of. - A (List[int]): A list of integers. Returns: - int: The count of multiples of K in the list A. return sum(1 for x in A if x % K == 0)"},{"question":"def find_unique_sets(n: int, pairs: List[Tuple[int, int]]) -> int: Determine the number of unique sets of paired devices. >>> find_unique_sets(3, [(1, 2), (3, 4), (2, 3)]) 1 >>> find_unique_sets(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) 4","solution":"def find_unique_sets(n, pairs): parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for a, b in pairs: if a not in parent: parent[a] = a if b not in parent: parent[b] = b union(a, b) unique_roots = {find(x) for x in parent} return len(unique_roots) # Example usage n = 3 pairs = [(1, 2), (3, 4), (2, 3)] print(find_unique_sets(n, pairs)) # Output: 1"},{"question":"def findMajorityElements(arr): Returns a list of elements that appear more than n/3 times in the array. Examples: >>> findMajorityElements([3, 2, 3]) [3] >>> findMajorityElements([1, 1, 1, 3, 3, 2, 2, 2]) [1, 2]","solution":"def findMajorityElements(arr): Returns a list of elements that appear more than n/3 times in the array. if not arr: return [] # Initialize candidate variables and counters candidate1, candidate2, count1, count2 = None, None, 0, 0 for num in arr: if candidate1 == num: count1 += 1 elif candidate2 == num: count2 += 1 elif count1 == 0: candidate1, count1 = num, 1 elif count2 == 0: candidate2, count2 = num, 1 else: count1 -= 1 count2 -= 1 # Verify candidates count1, count2 = 0, 0 for num in arr: if num == candidate1: count1 += 1 elif num == candidate2: count2 += 1 n = len(arr) result = [] if count1 > n // 3: result.append(candidate1) if count2 > n // 3: result.append(candidate2) return result"},{"question":"class MyQueue: def __init__(self): Initialize your data structure here. pass def enqueue(self, x): Insert an element x into the queue. pass def dequeue(self): Remove the element at the front of the queue and return it. pass def peek(self): Return the element at the front of the queue without removing it. pass def is_empty(self): Return True if the queue is empty, otherwise return False. pass # Unit Test: def test_empty_queue(): q = MyQueue() assert q.is_empty() == True def test_enqueue(): q = MyQueue() q.enqueue(1) assert q.is_empty() == False q.enqueue(2) assert q.peek() == 1 def test_dequeue(): q = MyQueue() q.enqueue(3) q.enqueue(4) assert q.dequeue() == 3 assert q.dequeue() == 4 assert q.is_empty() == True def test_peek(): q = MyQueue() q.enqueue(5) q.enqueue(6) assert q.peek() == 5 q.dequeue() assert q.peek() == 6 def test_mixed_operations(): q = MyQueue() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 assert q.peek() == 2 assert q.is_empty() == False assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.is_empty() == True","solution":"class MyQueue: def __init__(self): self.stack_in = [] self.stack_out = [] def enqueue(self, x): Insert an element x into the queue. self.stack_in.append(x) def dequeue(self): Remove the element at the front of the queue and return it. if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out.pop() def peek(self): Return the element at the front of the queue without removing it. if not self.stack_out: while self.stack_in: self.stack_out.append(self.stack_in.pop()) return self.stack_out[-1] def is_empty(self): Return True if the queue is empty, otherwise return False. return not self.stack_in and not self.stack_out"},{"question":"class ToDoList: def __init__(self): Initialize an empty To-Do list. pass def add_task(self, task: str): Adds a task to the list. Duplicate tasks should be ignored. >>> todo = ToDoList() >>> todo.add_task(\\"Buy groceries\\") >>> todo.add_task(\\"Buy groceries\\") # No duplicate >>> todo.get_tasks() == [\\"Buy groceries\\"] pass def remove_task(self, task: str): Removes a task from the list. If the task does not exist, raise a ValueError with the message \\"Task not found\\". >>> todo = ToDoList() >>> todo.add_task(\\"Buy groceries\\") >>> todo.remove_task(\\"Buy groceries\\") >>> todo.get_tasks() == [] >>> todo.remove_task(\\"Buy groceries\\") # Raises ValueError pass def get_tasks(self): Returns a list of all tasks in the order they were added. >>> todo = ToDoList() >>> todo.add_task(\\"Buy groceries\\") >>> todo.add_task(\\"Clean the house\\") >>> todo.get_tasks() == [\\"Buy groceries\\", \\"Clean the house\\"] pass","solution":"class ToDoList: def __init__(self): self.tasks = [] def add_task(self, task: str): Adds a task to the list. Duplicate tasks should be ignored. if len(self.tasks) >= 100: raise IndexError(\\"Task list is full\\") if task not in self.tasks: self.tasks.append(task) def remove_task(self, task: str): Removes a task from the list. If the task does not exist, raise a ValueError with the message \\"Task not found\\". try: self.tasks.remove(task) except ValueError: raise ValueError(\\"Task not found\\") def get_tasks(self) -> list: Returns a list of all tasks in the order they were added. return self.tasks"},{"question":"def assign_grades(students): Assign grades to students based on the average of their marks in three subjects. Parameters: students (list): A list of dictionaries where each dictionary contains a student's name and their marks in mathematics, science, and literature. Returns: list: A new list of dictionaries where each dictionary contains the student's name and their grade. Example: >>> input_data = [ ... {'name': 'Alice', 'math': 85, 'science': 90, 'literature': 88}, ... {'name': 'Bob', 'math': 78, 'science': 74, 'literature': 80}, ... {'name': 'Charlie', 'math': 65, 'science': 60, 'literature': 58}, ... ] >>> assign_grades(input_data) [ {'name': 'Alice', 'grade': 'B'}, {'name': 'Bob', 'grade': 'C'}, {'name': 'Charlie', 'grade': 'D'} ]","solution":"def assign_grades(students): Assign grades to students based on the average of their marks in three subjects. Parameters: students (list): A list of dictionaries where each dictionary contains a student's name and their marks in mathematics, science, and literature. Returns: list: A new list of dictionaries where each dictionary contains the student's name and their grade. def calculate_grade(avg): if avg >= 90: return 'A' elif 80 <= avg < 90: return 'B' elif 70 <= avg < 80: return 'C' elif 60 <= avg < 70: return 'D' else: return 'F' result = [] for student in students: avg = (student['math'] + student['science'] + student['literature']) / 3 grade = calculate_grade(avg) result.append({'name': student['name'], 'grade': grade}) return result"},{"question":"def find_single_element(nums): Finds the single element in an array where every other element appears twice and one element appears exactly once. Args: nums: List[int] - an array of integers Returns: int - the single element Example: >>> find_single_element([2, 1, 4, 5, 2, 4, 1]) 5 >>> find_single_element([9, 2, 4, 6, 2, 4, 6]) 9 >>> find_single_element([1, 2, 3, 1, 2, 3, 5]) 5 >>> find_single_element([-1, -1, -2, -2, 5]) 5 >>> find_single_element([7, 7, 7]) 7","solution":"def find_single_element(nums): Finds the single element in an array where every other element appears twice. Args: nums: List[int] - an array of integers Returns: int - the single element single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"def reverse_each_word(s: str) -> str: Reverse each word in the string while maintaining the original order of the words. >>> reverse_each_word(\\"code assessment task\\") == \\"edoc tnemssessa ksat\\" >>> reverse_each_word(\\"reverse each word\\") == \\"esrever hcae drow\\" >>> reverse_each_word(\\"challenge\\") == \\"egnellahc\\" >>> reverse_each_word(\\" leading and trailing \\") == \\" gnidael dna gniliart \\" >>> reverse_each_word(\\"multiple spaces\\") == \\"elpitlum secaps\\" >>> reverse_each_word(\\"\\") == \\"\\" >>> reverse_each_word(\\"a b c\\") == \\"a b c\\"","solution":"def reverse_each_word(s): Reverse each word in the string while maintaining the original order of the words. Parameters: s (str): The input string containing words separated by spaces. Returns: str: A new string where each word from the original string is reversed. words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def qualified_for_bonus(years_of_service: List[int], k: int) -> List[int]: Returns the indices of employees who qualify for the bonus. >>> qualified_for_bonus([2, 4, 1, 3], 5) [] >>> qualified_for_bonus([3, 7, 1, 8, 2], 6) [1, 3] >>> qualified_for_bonus([10, 10, 10], 10) [0, 1, 2]","solution":"def qualified_for_bonus(years_of_service, k): Returns the indices of employees who qualify for the bonus. Parameters: years_of_service (list of int): The years of service of each employee. k (int): The minimum number of years required to qualify for the bonus. Returns: list of int: The indices of employees who qualify for the bonus. qualifying_indices = [i for i, years in enumerate(years_of_service) if years >= k] return qualifying_indices"},{"question":"def does_rectangle_contain_origin(test_cases): Determine if the origin (0, 0) is inside or on the boundary of the given rectangles. Args: test_cases: List[Tuple[int, int, int, int]] - A list of tuples where each tuple contains four integers representing the coordinates of a rectangle. Returns: List[str] - A list where each element is 'YES' if the origin is inside or on the boundary of the corresponding rectangle, otherwise 'NO'. Example: >>> does_rectangle_contain_origin([(-1, -1, 1, 1), (2, 2, 4, 4), (0, -3, 3, 3)]) ['YES', 'NO', 'YES'] results = []","solution":"def does_rectangle_contain_origin(test_cases): results = [] for x1, y1, x2, y2 in test_cases: if min(x1, x2) <= 0 <= max(x1, x2) and min(y1, y2) <= 0 <= max(y1, y2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def total_apples_collected(N: int, apples: List[int]) -> int: Calculate the total number of apples collected from the orchard. Args: N (int): The number of trees in the orchard. apples (list of int): A list representing the number of apples each tree produces. Returns: int: The total number of apples collected. Examples: >>> total_apples_collected(5, [10, 20, 15, 25, 30]) 100 >>> total_apples_collected(3, [5, 10, 15]) 30 >>> total_apples_collected(1, [50]) 50 >>> total_apples_collected(4, [1, 1, 1, 1]) 4 >>> total_apples_collected(6, [12, 14, 16, 18, 20, 22]) 102","solution":"def total_apples_collected(N, apples): Calculate the total number of apples collected from the orchard. Args: N (int): The number of trees in the orchard. apples (list of int): A list representing the number of apples each tree produces. Returns: int: The total number of apples collected. return sum(apples) # Example usage: # N = 5 # apples = [10, 20, 15, 25, 30] # print(total_apples_collected(N, apples)) # Output: 100"},{"question":"def caesar_cipher_decode(encoded_message: str, shift: int) -> str: Decodes a given encoded string using the Caesar cipher technique. Parameters: encoded_message (str): The encoded message to be decoded. shift (int): The number of positions each letter in the plaintext was shifted. Returns: str: The original message before it was encoded. >>> caesar_cipher_decode(\\"D\\", 3) \\"A\\" >>> caesar_cipher_decode(\\"KHOOR\\", 3) \\"HELLO\\" >>> caesar_cipher_decode(\\"CDEF\\", 2) \\"ABCD\\" >>> caesar_cipher_decode(\\"ZAB\\", 1) \\"YZA\\" >>> caesar_cipher_decode(\\"LIPPS\\", 4) \\"HELLO\\" >>> caesar_cipher_decode(\\"HELLO\\", 0) \\"HELLO\\" >>> caesar_cipher_decode(\\"A\\", 26) \\"A\\" >>> caesar_cipher_decode(\\"HELLO\\", 26) \\"HELLO\\"","solution":"def caesar_cipher_decode(encoded_message, shift): Decodes a given encoded string using the Caesar cipher technique. Parameters: encoded_message (str): The encoded message to be decoded. shift (int): The number of positions each letter in the plaintext was shifted. Returns: str: The original message before it was encoded. decoded_message = [] for char in encoded_message: # Calculate the original position in the alphabet original_position = (ord(char) - ord('A') - shift) % 26 original_char = chr(original_position + ord('A')) decoded_message.append(original_char) return ''.join(decoded_message)"},{"question":"from typing import List def max_sum_of_k_items_within_budget(n: int, K: int, B: int, prices: List[int]) -> int: Determines the maximum sum of prices of any combination of exactly K items that does not exceed the budget B. >>> max_sum_of_k_items_within_budget(5, 3, 100, [20, 30, 50, 10, 40]) 100 >>> max_sum_of_k_items_within_budget(4, 2, 60, [25, 35, 45, 55]) 60 >>> max_sum_of_k_items_within_budget(3, 1, 10, [15, 20, 30]) 0 from solution import max_sum_of_k_items_within_budget def test_example_1(): assert max_sum_of_k_items_within_budget(5, 3, 100, [20, 30, 50, 10, 40]) == 100 def test_example_2(): assert max_sum_of_k_items_within_budget(4, 2, 60, [25, 35, 45, 55]) == 60 def test_example_3(): assert max_sum_of_k_items_within_budget(3, 1, 10, [15, 20, 30]) == 0 def test_case_no_combination(): assert max_sum_of_k_items_within_budget(4, 2, 30, [31, 32, 33, 34]) == 0 def test_case_all_items_exceed_budget(): assert max_sum_of_k_items_within_budget(3, 3, 70, [40, 40, 40]) == 0 def test_case_optimal_combination(): assert max_sum_of_k_items_within_budget(6, 4, 100, [25, 25, 25, 25, 10, 10]) == 100 def test_case_single_item_within_budget(): assert max_sum_of_k_items_within_budget(5, 1, 30, [10, 20, 5, 15, 25]) == 25 def test_case_large_number_of_items(): assert max_sum_of_k_items_within_budget(50, 5, 250, [i for i in range(1, 51)]) == 240","solution":"from itertools import combinations def max_sum_of_k_items_within_budget(n, K, B, prices): Determines the maximum sum of prices of any combination of exactly K items that does not exceed the budget B. max_sum = 0 for combo in combinations(prices, K): combo_sum = sum(combo) if combo_sum <= B: max_sum = max(max_sum, combo_sum) return max_sum"},{"question":"def encodeString(s: str) -> str: Encodes the input string by replacing each character with a pair of elements: the number of consecutive occurrences of the character followed by the character itself. >>> encodeString(\\"aaBBccAA\\") '2a2B2c2A' >>> encodeString(\\"aAAAaaBb\\") '1a3A2a1B1b' >>> encodeString(\\"abc\\") '1a1b1c' >>> encodeString(\\"aaa\\") '3a' >>> encodeString(\\"BBB\\") '3B' >>> encodeString(\\"\\") '' >>> encodeString(\\"aa!BB@\\") '2a1!2B1@' # Write your code here.","solution":"def encodeString(s): Encodes the input string by replacing each character with a pair of elements: the number of consecutive occurrences of the character followed by the character itself. :param s: Input string :type s: str :return: Encoded string :rtype: str if not s: return \\"\\" encoded_string = \\"\\" i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 encoded_string += str(count) + s[i] i += 1 return encoded_string"},{"question":"def sort_employee_ids(test_cases): Organize employee ID badges based on their floor levels in ascending order. Each employee ID badge details which floor they work on, and all employee IDs on the same floor should be grouped and sorted. Overall order between floors should be maintained. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test case tuples containing the number of employees and their respective floor levels as a list of tuples. Returns: List[List[int]]: List of lists containing the sorted employee IDs for each test case. Example: >>> test_cases = [ (3, [(101, 2), (102, 1), (103, 2)]), (4, [(201, 1), (202, 2), (203, 1), (204, 2)]) ] >>> sort_employee_ids(test_cases) [[102, 101, 103], [201, 203, 202, 204]]","solution":"def sort_employee_ids(test_cases): results = [] for case in test_cases: N, employees = case # Group employees by floor floor_groups = {} for emp_id, floor in employees: if floor not in floor_groups: floor_groups[floor] = [] floor_groups[floor].append(emp_id) # Sort the groups and each group individually sorted_floors = sorted(floor_groups.keys()) sorted_ids = [] for floor in sorted_floors: sorted_ids.extend(sorted(floor_groups[floor])) results.append(sorted_ids) return results # Example usage: test_cases = [ (3, [(101, 2), (102, 1), (103, 2)]), (4, [(201, 1), (202, 2), (203, 1), (204, 2)]) ] print(sort_employee_ids(test_cases)) # Expected Output: # [ # [102, 101, 103], # [201, 203, 202, 204] # ]"},{"question":"def assign_cows(n: int, m: int, cow_durations: List[int], intervals: List[Tuple[int, int]]) -> int: Determine the maximum number of cows that can be assigned to protect the intervals, ensuring no interval is left unprotected. >>> assign_cows(4, 3, [5, 10, 6, 8], [(0,3), (4,7), (5,10)]) 3 >>> assign_cows(3, 2, [1, 2, 3], [(0,5), (10,15)]) 0","solution":"def assign_cows(n, m, cow_durations, intervals): # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) # Sort cow durations cow_durations.sort() count = 0 # Count of cows assigned used = [False] * n # Array to check if a cow is already used for start, end in intervals: for i in range(n): if not used[i] and cow_durations[i] >= (end - start): used[i] = True count += 1 break # Move to the next interval return count"},{"question":"from typing import List, Tuple def minimum_additional_connections(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Identify the minimum number of additional connections required to make the graph connected. >>> minimum_additional_connections(1, 0, []) 0 >>> minimum_additional_connections(2, 0, []) 1 >>> minimum_additional_connections(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> minimum_additional_connections(4, 2, [(1, 2), (3, 4)]) 1 >>> minimum_additional_connections(6, 3, [(1, 2), (3, 4), (4, 5)]) 2 >>> minimum_additional_connections(5, 0, []) 4","solution":"def minimum_additional_connections(n, m, connections): from collections import defaultdict, deque if m == 0: return n - 1 # No connections, we need to connect all nodes graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) components = 0 for server in range(1, n + 1): if not visited[server]: bfs(server) components += 1 return components - 1"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The N x N matrix to rotate. Returns: List[List[int]]: The rotated matrix. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise. N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N-1-i] = matrix[i][j] return rotated_matrix def solve_input(input_data): lines = input_data.strip().split('n') index = 0 T = int(lines[index]) index += 1 results = [] for _ in range(T): N = int(lines[index]) index += 1 matrix = [] for _ in range(N): row = list(map(int, lines[index].strip().split())) index += 1 matrix.append(row) rotated_matrix = rotate_matrix_90_clockwise(matrix) results.append(rotated_matrix) return results def format_output(results): output_lines = [] for matrix in results: output_lines.append('n'.join(' '.join(map(str, row)) for row in matrix)) return 'n'.join(output_lines) def rotate_matrices(input_data): results = solve_input(input_data) return format_output(results) # Example usage: input_data = 2 3 1 2 3 4 5 6 7 8 9 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 output = rotate_matrices(input_data) print(output)"},{"question":"from typing import List def find_three_sum_triplets(test_cases: List[List[int]]) -> List[str]: Find all unique triplets in the list which gives the sum of zero. Each triplet should be represented as an integer array [num1, num2, num3] where num1 <= num2 <= num3. >>> test_cases = [[-1, 0, 1, 2, -1, -4], [1, -1, -1]] >>> find_three_sum_triplets(test_cases) ['-1 -1 2n-1 0 1', 'No Triplets Found'] # Add your implementation here","solution":"def find_three_sum_triplets(test_cases): def three_sum(nums): nums.sort() n = len(nums) triplets = [] for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets results = [] for test_case in test_cases: triplets = three_sum(test_case) if not triplets: results.append(\\"No Triplets Found\\") else: results.append('n'.join(' '.join(map(str, triplet)) for triplet in triplets)) return results"},{"question":"def longest_lexicographic_palindrome(s: str) -> str: Find the longest palindrome substring in the given string that is also lexicographically smallest among those with the same length. Args: s (str): Input string of lowercase English letters. Returns: str: The required palindrome. Examples: >>> longest_lexicographic_palindrome(\\"abacdfgdcaba\\") 'aba' >>> longest_lexicographic_palindrome(\\"aabbaa\\") 'aabbaa' >>> longest_lexicographic_palindrome(\\"abcd\\") 'a'","solution":"def longest_lexicographic_palindrome(s): def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] max_palindrome = s[0] for i in range(len(s)): palindrome_odd = expand_around_center(i, i) palindrome_even = expand_around_center(i, i + 1) if len(palindrome_odd) > len(max_palindrome) or (len(palindrome_odd) == len(max_palindrome) and palindrome_odd < max_palindrome): max_palindrome = palindrome_odd if len(palindrome_even) > len(max_palindrome) or (len(palindrome_even) == len(max_palindrome) and palindrome_even < max_palindrome): max_palindrome = palindrome_even return max_palindrome"},{"question":"def num_unique_bsts(n): Returns the number of unique binary search trees that can be formed with n nodes. >>> num_unique_bsts(3) 5 >>> num_unique_bsts(4) 14","solution":"def num_unique_bsts(n): Returns the number of unique binary search trees that can be formed with n nodes. # Dynamic Programming table to store the number of unique BSTs with i nodes dp = [0] * (n + 1) # Base cases dp[0] = 1 # Empty tree dp[1] = 1 # Tree with one node # Fill the dp array for nodes in range(2, n + 1): for root in range(1, nodes + 1): left_trees = dp[root - 1] # number of unique BSTs in the left subtree right_trees = dp[nodes - root] # number of unique BSTs in the right subtree dp[nodes] += left_trees * right_trees return dp[n]"},{"question":"def maxPoints(t, m, k, reg, spec, u, v): Calculate the total number of Regular and Special tasks Nina should perform to achieve the maximum score within the given time. >>> maxPoints(100, 3, 6, 5, 3, 15, 30) [0, 3] >>> maxPoints(90, 4, 7, 6, 4, 20, 25) [2, 2]","solution":"def maxPoints(t, m, k, reg, spec, u, v): max_points = 0 max_reg_tasks = 0 max_spec_tasks = 0 # Try to maximize by trying all possible combinations for r in range(reg + 1): for s in range(spec + 1): total_time = r * u + s * v if total_time <= t: points = r * m + s * k if points > max_points: max_points = points max_reg_tasks = r max_spec_tasks = s return [max_reg_tasks, max_spec_tasks]"},{"question":"def print_cakes_triangle(T, test_cases): Prepare a visually appealing triangular arrangement of cakes for multiple test cases. Parameters: T (int): Number of test cases. test_cases (List[int]): List containing the number of cakes for each test case. Returns: List[str]: Each string represents a triangular arrangement of cakes for a test case. >>> T = 1 >>> test_cases = [3] >>> print_cakes_triangle(T, test_cases) ['CnC CnC C C'] results = [] for N in test_cases: count = 0 result = [] for i in range(1, N+1): row = \\" \\".join([\\"C\\"] * i) result.append(row) count += 1 if count == N: break results.append(\\"n\\".join(result)) return results def format_output(results): Format the output of the triangular arrangement of cakes. Parameters: results (List[str]): The list of results to be formatted. Returns: str: A single formatted string suitable for display. >>> results = ['CnC C', 'CnC CnC C CnC C C C', 'CnC CnC C CnC C C CnC C C C CnC C C C C C'] >>> format_output(results) 'CnC CnnCnC CnC C CnC C C CnnCnC CnC C CnC C C CnC C C C CnC C C C C C' return \\"nn\\".join(results)","solution":"def print_cakes_triangle(T, test_cases): results = [] for N in test_cases: count = 0 result = [] for i in range(1, N+1): row = \\" \\".join([\\"C\\"] * i) result.append(row) count += 1 if count == N: break results.append(\\"n\\".join(result)) return results def format_output(results): return \\"nn\\".join(results) # Example usage: if __name__ == \\"__main__\\": T = 3 test_cases = [2, 4, 6] results = print_cakes_triangle(T, test_cases) output = format_output(results) print(output)"},{"question":"def is_balanced(s: str) -> str: Determines if the brackets in the string are balanced. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or stack.pop() != bracket_map[char]: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def bracket_balance(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each has balanced brackets. >>> bracket_balance(5, [\\"([])\\", \\"([)]\\", \\"{{[[(())]]}}\\", \\"[]\\", \\"[{()}()]\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> bracket_balance(1, [\\"([{}])\\"]) == [\\"YES\\"] >>> bracket_balance(1, [\\"[(){}]\\"]) == [\\"YES\\"] >>> bracket_balance(1, [\\"[{]}\\"]) == [\\"NO\\"] >>> bracket_balance(3, [\\"((\\", \\"()\\", \\"[[]]\\"]) == [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def is_balanced(s): Determines if the brackets in the string are balanced. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or stack.pop() != bracket_map[char]: return \\"NO\\" return \\"YES\\" if stack == [] else \\"NO\\" def bracket_balance(T, test_cases): Processes multiple test cases to determine if each has balanced brackets. results = [] for test in test_cases: results.append(is_balanced(test)) return results"},{"question":"def can_split_into_increasing_subarrays(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if a sequence of distinct integers can be split into three contiguous strictly increasing subarrays for each test case. Args: t (int): Number of test cases. cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing the number of elements in the sequence and the sequence itself. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> can_split_into_increasing_subarrays(3, [(5, [1, 2, 3, 4, 5]), (7, [1, 3, 2, 5, 6, 7, 4]), (4, [1, 3, 2, 4])]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> can_split_into_increasing_subarrays(1, [(6, [1, 2, 2, 3, 4, 5])]) [\\"NO\\"] def test_can_split_into_increasing_subarrays(): cases = [ (5, [1, 2, 3, 4, 5]), (7, [1, 3, 2, 5, 6, 7, 4]), (4, [1, 3, 2, 4]), (9, [1, 2, 1, 3, 4, 2, 5, 6, 7]) ] expected = [\\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert can_split_into_increasing_subarrays(4, cases) == expected def test_case_with_minimum_length(): cases = [ (3, [1, 2, 3]) ] expected = [\\"NO\\"] assert can_split_into_increasing_subarrays(1, cases) == expected def test_case_with_non_strictly_increasing_sequence(): cases = [ (6, [1, 2, 2, 3, 4, 5]) ] expected = [\\"NO\\"] assert can_split_into_increasing_subarrays(1, cases) == expected def test_case_with_exactly_two_peaks(): cases = [ (7, [1, 3, 2, 4, 3, 5, 4]) ] expected = [\\"YES\\"] assert can_split_into_increasing_subarrays(1, cases) == expected # Running pytest if __name__ == '__main__': import pytest pytest.main()","solution":"def can_split_into_increasing_subarrays(t, cases): results = [] for i in range(t): n = cases[i][0] heights = cases[i][1] if n < 3: results.append(\\"NO\\") continue peak_count = 0 peak_position = [] # Find peaks in the array for j in range(1, n - 1): if heights[j - 1] < heights[j] > heights[j + 1]: peak_count += 1 peak_position.append(j) if peak_count < 2: results.append(\\"NO\\") else: peak_a = peak_position[0] peak_b = peak_position[1] if peak_a >= 1 and peak_b <= n - 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to read input and call the solution function def solve(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 cases = [] for _ in range(t): n = int(data[index]) heights = list(map(int, data[index + 1: index + n + 1])) cases.append((n, heights)) index += n + 1 results = can_split_into_increasing_subarrays(t, cases) for result in results: print(result)"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, streets: List[Tuple[int, int, int]], s: int, t: int) -> int: Finds the shortest path between intersections s and t using Dijkstra's algorithm. :param n: Number of intersections :param m: Number of streets :param streets: List of tuples (u, v, w) representing streets between intersections u and v with length w :param s: Source intersection :param t: Target intersection :return: Length of the shortest path from s to t, or -1 if no such path exists >>> shortest_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 2)], 1, 5) 6 >>> shortest_path(4, 2, [(1, 2, 1), (3, 4, 2)], 1, 4) -1","solution":"import heapq def shortest_path(n, m, streets, s, t): Finds the shortest path between intersections s and t using Dijkstra's algorithm. :param n: Number of intersections :param m: Number of streets :param streets: List of tuples (u, v, w) representing streets between intersections u and v with length w :param s: Source intersection :param t: Target intersection :return: Length of the shortest path from s to t, or -1 if no such path exists graph = {i: [] for i in range(1, n+1)} for u, v, w in streets: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm pq = [(0, s)] # (distance, node) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[t] if distances[t] != float('inf') else -1"},{"question":"from typing import List def count_warehouses(M: int, inventories: List[int]) -> None: Print number of warehouses with inventory greater than zero after each step. Args: M : int : number of warehouses inventories : List[int] : list of inventory quantities in each warehouse >>> count_warehouses(5, [7, 8, 3, 4, 6]) 5 4 3 1 0 >>> count_warehouses(1, [10]) 1 0 >>> count_warehouses(4, [1, 3, 3, 6]) 4 3 0 >>> count_warehouses(5, [5, 5, 5, 5, 5]) 5 0 >>> count_warehouses(3, [0, 0, 0]) 0","solution":"def count_warehouses(M, inventories): Print number of warehouses with inventory greater than zero after each step. inventories = sorted(inventories) while any(inventory > 0 for inventory in inventories): median = inventories[M // 2] if M % 2 != 0 else inventories[M // 2 - 1] for i in range(M): inventories[i] -= median inventories = [inventory for inventory in inventories if inventory > 0] M = len(inventories) print(M)"},{"question":"def min_robots(n: int, W: int, weights: List[int]) -> int: Determines the minimum number of robots required to carry all the packages. Returns -1 if it is not possible within the given constraints. Parameters: n (int): The number of packages. W (int): Maximum weight capacity of each robot. weights (list of int): Weights of the packages. Returns: int: Minimum number of robots required or -1 if not possible. >>> min_robots(5, 15, [5, 10, 15, 5, 5]) 3 >>> min_robots(4, 20, [9, 9, 9, 9]) 2 >>> min_robots(3, 10, [11, 9, 5]) -1 >>> min_robots(6, 10, [2, 3, 5, 6, 4, 2]) 3 from solution import min_robots def test_example1(): assert min_robots(5, 15, [5, 10, 15, 5, 5]) == 3 def test_example2(): assert min_robots(4, 20, [9, 9, 9, 9]) == 2 def test_example3(): assert min_robots(3, 10, [11, 9, 5]) == -1 def test_example4(): assert min_robots(6, 10, [2, 3, 5, 6, 4, 2]) == 3 def test_single_package(): assert min_robots(1, 10, [10]) == 1 assert min_robots(1, 10, [11]) == -1 def test_all_exact_fit(): assert min_robots(3, 5, [5, 5, 5]) == 3 def test_multiple_small_packages(): assert min_robots(6, 10, [1, 1, 1, 1, 1, 1]) == 1 def test_varied_weights(): assert min_robots(5, 10, [8, 2, 3, 7, 5]) == 3","solution":"def min_robots(n, W, weights): Determines the minimum number of robots required to carry all the packages. Returns -1 if it is not possible within the given constraints. Parameters: n (int): The number of packages. W (int): Maximum weight capacity of each robot. weights (list of int): Weights of the packages. Returns: int: Minimum number of robots required or -1 if not possible. if any(weight > W for weight in weights): return -1 weights.sort(reverse=True) robots_used = 0 while weights: robots_used += 1 remaining_capacity = W i = 0 while i < len(weights): if weights[i] <= remaining_capacity: remaining_capacity -= weights[i] weights.pop(i) else: i += 1 return robots_used"},{"question":"def to_acronym(s: str) -> str: Given a string 's', returns an acronym composed of the first letters of each word. >>> to_acronym(\\"Hello World\\") 'HW' >>> to_acronym(\\"Portable Network Graphics\\") 'PNG' >>> to_acronym(\\"hello World\\") 'HW' >>> to_acronym(\\"Portable network Graphics\\") 'PNG' >>> to_acronym(\\" Portable Network Graphics \\") 'PNG' >>> to_acronym(\\"\\") ''","solution":"def to_acronym(s): Given a string 's', returns an acronym composed of the first letters of each word. return ''.join(word[0].upper() for word in s.split())"},{"question":"def rearrange_books(identifiers): Determines if the given book identifiers can be rearranged such that no two adjacent identifiers are both even or both odd. Returns \\"YES\\" and a valid rearrangement if possible, or \\"NO\\" if not possible. :param identifiers: List of integers representing book identifiers. :return: Tuple containing \\"YES\\" or \\"NO\\" and the rearranged list (if applicable). >>> rearrange_books([3, 8, 5, 12, 7]) (\\"YES\\", [8, 7, 12, 5, 3]) >>> rearrange_books([1, 2, 3]) (\\"YES\\", [1, 2, 3]) >>> rearrange_books([2, 4, 6]) (\\"NO\\", [])","solution":"def rearrange_books(identifiers): Determines if the given book identifiers can be rearranged such that no two adjacent identifiers are both even or both odd. Returns \\"YES\\" and a valid rearrangement if possible, or \\"NO\\" if not possible. :param identifiers: List of integers representing book identifiers. :return: Tuple containing \\"YES\\" or \\"NO\\" and the rearranged list (if applicable). evens = [x for x in identifiers if x % 2 == 0] odds = [x for x in identifiers if x % 2 == 1] # If the difference between the number of even and odd numbers is more than 1, # then it is impossible to rearrange them as required. if abs(len(evens) - len(odds)) > 1: return \\"NO\\", [] result = [] even_index, odd_index = 0, 0 if len(evens) > len(odds): result.append(evens[even_index]) even_index += 1 else: result.append(odds[odd_index]) odd_index += 1 while even_index < len(evens) and odd_index < len(odds): if result[-1] % 2 == 0: result.append(odds[odd_index]) odd_index += 1 else: result.append(evens[even_index]) even_index += 1 # Append remaining items while even_index < len(evens): result.append(evens[even_index]) even_index += 1 while odd_index < len(odds): result.append(odds[odd_index]) odd_index += 1 return \\"YES\\", result"},{"question":"def apply_discounts(n: int, prices: List[int]) -> List[int]: Applies a 20% discount to every second price in the list and rounds to the nearest integer. Parameters: n (int): The number of different flower types. prices (list): The original prices of each flower type. Returns: list: The final prices after applying the discount and rounding. >>> apply_discounts(5, [100, 200, 300, 400, 500]) [100, 160, 300, 320, 500] >>> apply_discounts(3, [150, 275, 900]) [150, 220, 900]","solution":"def apply_discounts(n, prices): Applies a 20% discount to every second price in the list and rounds to the nearest integer. Parameters: n (int): The number of different flower types. prices (list): The original prices of each flower type. Returns: list: The final prices after applying the discount and rounding. final_prices = [] for i in range(n): price = prices[i] if (i + 1) % 2 == 0: # Every 2nd price needs the discount discounted_price = price * 0.8 final_price = round(discounted_price) else: final_price = price final_prices.append(final_price) return final_prices # Example usage: # n = 5 # prices = [100, 200, 300, 400, 500] # print(apply_discounts(n, prices)) # Output should be [100, 160, 300, 320, 500]"},{"question":"def first_digit_to_appear(n: int) -> int: Returns the first digit (0-9) that appears in the sequence of powers of n, starting with n^1. >>> first_digit_to_appear(3) 3 >>> first_digit_to_appear(10) 1 >>> first_digit_to_appear(5) 5 >>> first_digit_to_appear(2) 2 >>> first_digit_to_appear(999) 9","solution":"def first_digit_to_appear(n: int) -> int: Returns the first digit (0-9) that appears in the sequence of powers of n, starting with n^1. observed_digits = set() power = 1 while True: current_number = str(n ** power) for digit_char in current_number: digit = int(digit_char) if digit not in observed_digits: return digit power += 1"},{"question":"from typing import List def distinct_prime_factors(arr: List[int]) -> int: Returns the number of distinct prime factors of the product of the array elements. Args: arr: List of integers. Returns: An integer, the number of distinct prime factors. Examples: >>> distinct_prime_factors([2, 4, 8]) 1 >>> distinct_prime_factors([3, 5, 10]) 3 pass def process_cases(input_data: str) -> List[int]: Processes multiple test cases and returns the results. Args: input_data: A string containing multiple test cases. Returns: A list of integers, each representing the number of distinct prime factors for the respective test case. Examples: >>> process_cases(\\"2n3n2 4 8n3n3 5 10\\") [1, 3] >>> process_cases(\\"1n5n2 3 5 7 11\\") [5] pass","solution":"def distinct_prime_factors(arr): Returns the number of distinct prime factors of the product of the array elements. def prime_factors(n): Returns the set of prime factors of a given number n. factors = set() # Test for number 2 while n % 2 == 0: factors.add(2) n //= 2 # Test for odd numbers from 3 to sqrt(n) for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.add(i) n //= i if n > 2: factors.add(n) return factors total_factors = set() for num in arr: total_factors.update(prime_factors(num)) return len(total_factors) def process_cases(input_data): Processes multiple test cases and returns the results. results = [] input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 for _ in range(T): N = int(input_lines[index]) arr = list(map(int, input_lines[index + 1].split())) results.append(distinct_prime_factors(arr)) index += 2 return results"},{"question":"def isWave(arr, n): Determine if the array arr is a wave. :param arr: List[int] - an array of integers :param n: int - the length of the array :return: bool - True if the array is a wave, otherwise False >>> isWave([1, 3, 2, 4, 3], 5) True >>> isWave([1, 3, 5, 7], 4) False >>> isWave([5], 1) True >>> isWave([5, 10], 2) True >>> isWave([1, 1, 1, 1], 4) False >>> isWave([1, -1, 1, -1, 1, -1], 6) True >>> isWave([10, 1, 20, 2, 30, 3], 6) True","solution":"def isWave(arr, n): Determine if the array arr is a wave. :param arr: List[int] - an array of integers :param n: int - the length of the array :return: bool - True if the array is a wave, otherwise False if n < 2: return True for i in range(1, n-1): if (arr[i] - arr[i-1]) * (arr[i+1] - arr[i]) >= 0: return False return True"},{"question":"def evaluate_fizzlang(expression): Evaluate a FizzLang expression. >>> evaluate_fizzlang(\\"3+5\\") == 8 >>> evaluate_fizzlang(\\"3*5\\") == 15 >>> evaluate_fizzlang(\\"3+5*2\\") == 13 >>> evaluate_fizzlang(\\"2*3+4\\") == 10 >>> evaluate_fizzlang(\\"2+3*4+5\\") == 19 >>> evaluate_fizzlang(\\"7\\") == 7","solution":"def evaluate_fizzlang(expression): def helper(expr, start, end): num = 0 stack = [] sign = \\"+\\" i = start while i <= end: char = expr[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+*\\" or i == end: if sign == \\"+\\": stack.append(num) elif sign == \\"*\\": stack.append(stack.pop() * num) sign, num = char, 0 i += 1 return sum(stack) return helper(expression, 0, len(expression) - 1)"},{"question":"def can_organize_books(T, test_cases): The city librarian needs your help in organizing their book collection. The collection contains books that are categorized into different genres. Each genre has a set number of shelves specifically allocated to it, and every shelf can hold a specific number of books. Given the details about how many shelves and books per shelf each genre has, determine if all the books of each genre can be properly organized on its allocated shelves without exceeding the shelf capacity for any genre. Args: T: int : The number of test cases. test_cases: List[Tuple[int, List[Tuple[int, int]]]] : The test cases, each containing: - an integer G, the number of genres - a list of G tuples, each containing: - an integer s_i, the number of shelves allocated to the i-th genre - an integer b_i, the number of books in the i-th genre Returns: List[str] : List containing \\"YES\\" or \\"NO\\" for each test case. >>> can_organize_books(3, [(2, [(10, 800), (5, 450)]), (1, [(7, 700)]), (3, [(15, 1500), (20, 1700), (5, 400)])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_organize_books(2, [(2, [(10, 1200), (5, 450)]), (1, [(5, 600)])]) [\\"NO\\", \\"NO\\"] def parse_input(input_data): A helper function to parse input data >>> parse_input(\\"3n2n10 800n5 450n1n7 700n3n15 1500n20 1700n5 400\\") (3, [(2, [(10, 800), (5, 450)]), (1, [(7, 700)]), (3, [(15, 1500), (20, 1700), (5, 400)])])","solution":"def can_organize_books(T, test_cases): results = [] for case in test_cases: G = case[0] genres = case[1] can_organize = True for s, b in genres: if s * 100 < b: can_organize = False break results.append(\\"YES\\" if can_organize else \\"NO\\") return results # Input Parsing Function def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) idx = 1 test_cases = [] for _ in range(T): G = int(input_lines[idx]) genres = [] idx += 1 for _ in range(G): s, b = map(int, input_lines[idx].split()) genres.append((s, b)) idx += 1 test_cases.append((G, genres)) return T, test_cases"},{"question":"def solve_subsequence_anagrams(test_cases): Determine if there exists a contiguous subsequence of s1 that is an anagram of s2. The function takes a list of test cases as input. Each test case is a tuple of two strings (s1, s2). Returns a list of \\"YES\\" or \\"NO\\" for each test case. Args: test_cases (List[Tuple[str, str]]): List of test cases Returns: List[str]: Results of each test case Examples: >>> solve_subsequence_anagrams([(\\"abcdef\\", \\"bca\\"), (\\"aaaaaa\\", \\"aaa\\"), (\\"abcbac\\", \\"bca\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> solve_subsequence_anagrams([(\\"abcdef\\", \\"xyz\\"), (\\"aabbcc\\", \\"abc\\"), (\\"pqrstuv\\", \\"xyz\\")]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def is_anagram_subsequence(s1, s2): from collections import Counter len1, len2 = len(s1), len(s2) if len2 > len1: return \\"NO\\" s2_counter = Counter(s2) window_counter = Counter(s1[:len2]) if window_counter == s2_counter: return \\"YES\\" for i in range(len2, len1): window_counter[s1[i]] += 1 window_counter[s1[i - len2]] -= 1 if window_counter[s1[i - len2]] == 0: del window_counter[s1[i - len2]] if window_counter == s2_counter: return \\"YES\\" return \\"NO\\" def solve_subsequence_anagrams(test_cases): results = [] for s1, s2 in test_cases: results.append(is_anagram_subsequence(s1, s2)) return results"},{"question":"def generate_palindrome(n: int) -> str: Generate a palindrome of length n using only lowercase English letters. If it is impossible to generate such a palindrome of length n, return \\"-1\\". >>> generate_palindrome(1) 'a' >>> generate_palindrome(2) 'aa' >>> generate_palindrome(3) 'aaa' >>> generate_palindrome(4) 'aaaa' >>> generate_palindrome(5) 'aaaaa' >>> generate_palindrome(0) '-1' >>> generate_palindrome(-1) '-1' def process_test_cases(t: int, cases: List[int]) -> List[str]: Process multiple test cases to generate palindromes of given lengths. >>> process_test_cases(5, [3, 4, 2, 1, 5]) ['aaa', 'aaaa', 'aa', 'a', 'aaaaa'] >>> process_test_cases(5, [6, 7, 8, 9, 10]) ['aaaaaa', 'aaaaaaa', 'aaaaaaaa', 'aaaaaaaaa', 'aaaaaaaaaa'] >>> process_test_cases(1, [0]) ['-1'] >>> process_test_cases(1, [-1]) ['-1'] >>> process_test_cases(1, [1]) ['a'] >>> process_test_cases(1, [6]) ['aaaaaa']","solution":"def generate_palindrome(n): if n <= 0: return \\"-1\\" if n == 1: return 'a' if n % 2 == 0: half = 'a' * (n // 2) return half + half[::-1] else: half = 'a' * (n // 2) return half + 'a' + half def process_test_cases(t, cases): results = [] for n in cases: results.append(generate_palindrome(n)) return results"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any non-empty subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23","solution":"def max_subarray_sum(nums): Returns the maximum sum of any non-empty subarray. max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def maxSubArraySum(arr): Finds the maximum sum of any contiguous subarray of the array and returns both the maximum sum and the starting and ending indices of the subarray that provides this maximum sum. Examples: >>> maxSubArraySum([-2,1,-3,4,-1,2,1,-5,4]) {'Maximum Sum': 6, 'Indices': (3, 6)} >>> maxSubArraySum([1]) {'Maximum Sum': 1, 'Indices': (0, 0)} >>> maxSubArraySum([-1, -2, -3, -4]) {'Maximum Sum': -1, 'Indices': (0, 0)} # Your implementation here","solution":"def maxSubArraySum(arr): Finds the maximum sum of any contiguous subarray of the array and returns both the maximum sum and the starting and ending indices of the subarray that provides this maximum sum. max_sum = float('-inf') current_sum = 0 start = 0 end = 0 temporary_start = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temporary_start end = i if current_sum < 0: current_sum = 0 temporary_start = i + 1 return {\\"Maximum Sum\\": max_sum, \\"Indices\\": (start, end)}"},{"question":"def count_unobstructed_views(heights): Determines the number of buildings that have an unobstructed view to the right. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The number of buildings with unobstructed views to the right. >>> count_unobstructed_views([5, 5, 5, 5, 5]) 1 >>> count_unobstructed_views([1, 2, 3, 4, 5]) 1 >>> count_unobstructed_views([5, 4, 3, 2, 1]) 5 >>> count_unobstructed_views([3, 7, 8, 3, 6, 1]) 3 >>> count_unobstructed_views([10]) 1 >>> count_unobstructed_views([10, 2]) 2 >>> count_unobstructed_views([2, 10]) 1","solution":"def count_unobstructed_views(heights): Determines the number of buildings that have an unobstructed view to the right. Parameters: heights (list): A list of integers representing the heights of the buildings. Returns: int: The number of buildings with unobstructed views to the right. count = 0 max_height_to_the_right = 0 # Traverse the list from right to left for height in reversed(heights): if height > max_height_to_the_right: count += 1 max_height_to_the_right = height return count"},{"question":"def count_unique_substrings(s: str) -> int: Returns the count of unique substrings in the given string s. >>> count_unique_substrings(\\"a\\") 1 >>> count_unique_substrings(\\"ab\\") 3 >>> count_unique_substrings(\\"aaa\\") 3 >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"ababa\\") 9","solution":"def count_unique_substrings(s): Returns the count of unique substrings in the given string s. unique_substrings = set() n = len(s) # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def can_flip_one_substring_to_match(S: str, T: str) -> str: Check if binary string S can be transformed to T by flipping exactly one contiguous substring. >>> can_flip_one_substring_to_match(\\"1100\\", \\"0010\\") \\"YES\\" >>> can_flip_one_substring_to_match(\\"1010\\", \\"1010\\") \\"NO\\"","solution":"def can_flip_one_substring_to_match(S, T): Check if binary string S can be transformed to T by flipping exactly one contiguous substring. n = len(S) # If S and T are already the same, we cannot flip exactly one substring to make them equal again. if S == T: return \\"NO\\" # Find the first and last indices where S and T differ. first_diff = -1 last_diff = -1 for i in range(n): if S[i] != T[i]: if first_diff == -1: first_diff = i last_diff = i # Now we need to check if flipping the substring from first_diff to last_diff in S matches T. for i in range(first_diff, last_diff + 1): # If S and T are not complementary in this substring, return NO. if S[i] == T[i]: return \\"NO\\" return \\"YES\\""},{"question":"def compress_string(s: str) -> str: Compresses a string using counts of repeated characters. If the compressed string is not smaller than the original, it returns the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"a\\") 'a' >>> compress_string(\\"\\") '' >>> compress_string(\\"aaaa\\") 'a4' >>> compress_string(\\"aabbbcccc\\") 'a2b3c4' >>> compress_string(\\"aabbccdd\\") 'aabbccdd'","solution":"def compress_string(s): Compresses a string using counts of repeated characters. If the compressed string is not smaller than the original, it returns the original string. :param s: Input string :return: Compressed string or original string if compressed string is not smaller if not s: return s compressed_parts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_parts.append(s[i - 1] + str(count)) count = 1 compressed_parts.append(s[-1] + str(count)) compressed_string = ''.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def calculate_final_scores(N: int, M: int, data: List[List[int]]) -> List[int]: Compute the final scores for a list of participants in a coding competition based on their attempts and the time taken for each problem. N: int - Number of participants M: int - Number of problems data: List[List[int]] - List of attempts and times per participant per problem Returns a list of final scores for each participant. >>> calculate_final_scores(3, 2, [[1, 4, 3, 20], [2, 10, 1, 5], [0, 0, 2, 5]]) [6, 5, 2] >>> calculate_final_scores(1, 3, [[0, 0, 0, 0, 0, 0]]) [0] >>> calculate_final_scores(2, 3, [[1, 2, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0]]) [27, 30] >>> calculate_final_scores(2, 2, [[2, 2, 3, 5], [1, 10, 2, 7]]) [5, 0] >>> calculate_final_scores(1, 1, [[1, 100]]) [0]","solution":"def calculate_final_scores(N, M, data): scores = [] for i in range(N): total_score = 0 for j in range(M): attempts = data[i][2*j] time = data[i][2*j + 1] if attempts == 1: points = 10 elif attempts == 2: points = 7 elif attempts == 3: points = 5 else: points = 0 final_points = max(0, points - time) total_score += final_points scores.append(total_score) return scores"},{"question":"def max_path_sum(n: int, nodes: List[Union[int, None]]) -> int: Calculate the maximum path sum in a given binary tree. Args: n (int): The number of nodes in the binary tree. nodes (List[Union[int, None]]): The values of the nodes in level-order (BFS) traversal of the tree. Returns: int: The maximum path sum. Example: >>> max_path_sum(5, [1, -2, 3, None, -1]) 4 >>> max_path_sum(3, [-10, 9, 20, None, None, 15, 7]) 42 >>> max_path_sum(1, [1]) 1 from typing import List, Union class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes: List[Union[int, None]]) -> TreeNode: Helper function to build a binary tree from a list of node values. if not nodes: return None from collections import deque it = iter(nodes) root = TreeNode(next(it)) queue = deque([root]) while queue: node = queue.popleft() try: left_val = next(it) if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(it) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def test_case_1(): assert max_path_sum(5, [1, -2, 3, None, -1]) == 4 def test_case_2(): assert max_path_sum(3, [-10, 9, 20, None, None, 15, 7]) == 42 def test_case_3(): assert max_path_sum(1, [1]) == 1 def test_case_4(): assert max_path_sum(7, [1, 2, 3, 4, 5, 6, 7]) == 18 def test_case_5(): assert max_path_sum(7, [-3, -2, -1, -4, -5, -6, -7]) == -1 def test_case_6(): assert max_path_sum(0, []) == 0 def test_case_7(): assert max_path_sum(3, [10, 9, -20]) == 19 def test_case_8(): assert max_path_sum(3, [-10, -9, -8]) == -8","solution":"from typing import List, Union class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes: List[Union[int, None]]) -> TreeNode: if not nodes: return None from collections import deque it = iter(nodes) root = TreeNode(next(it)) queue = deque([root]) while queue: node = queue.popleft() try: left_val = next(it) if left_val is not None: node.left = TreeNode(left_val) queue.append(node.left) right_val = next(it) if right_val is not None: node.right = TreeNode(right_val) queue.append(node.right) except StopIteration: break return root def max_path_sum(n: int, nodes: List[Union[int, None]]) -> int: if n == 0: return 0 root = build_tree(nodes) def helper(node): nonlocal max_sum if not node: return 0 left_max = max(helper(node.left), 0) # max path sum on the left right_max = max(helper(node.right), 0) # max path sum on the right current_max_path_sum = node.val + left_max + right_max max_sum = max(max_sum, current_max_path_sum) return node.val + max(left_max, right_max) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def find_robot_final_position(R: int, C: int, grid: List[str], initial_position: Tuple[int, int], commands: str) -> Tuple[int, int]: Simulate the movement of a robot on a rectangular grid. The robot can move up, down, left, or right, and the initial position and a series of commands are provided as inputs. The robot may also encounter obstacles that it cannot cross. Determine the robot's final position after executing all the commands. >>> find_robot_final_position(5, 5, ['.....','..#..','.....','.....','.....'], (2, 2), 'UURRDDLL') (2, 2) >>> find_robot_final_position(4, 4, ['....','..#.', '....','....'], (0, 0), 'DDRRUU') (2, 2)","solution":"def find_robot_final_position(R, C, grid, initial_position, commands): x, y = initial_position for command in commands: if command == 'U': new_x, new_y = x - 1, y elif command == 'D': new_x, new_y = x + 1, y elif command == 'L': new_x, new_y = x, y - 1 elif command == 'R': new_x, new_y = x, y + 1 # Check boundaries and obstacles if 0 <= new_x < R and 0 <= new_y < C and grid[new_x][new_y] != '#': x, y = new_x, new_y else: break # stops moving if an obstacle is encountered or out of bounds return x, y"},{"question":"def contains_simple_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the undirected graph contains a simple cycle. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges where each edge is represented as a tuple (u, v). Returns: str: \\"YES\\" if the graph contains a simple cycle, otherwise \\"NO\\". Examples: >>> contains_simple_cycle(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\" >>> contains_simple_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\"","solution":"def contains_simple_cycle(n, m, edges): from collections import defaultdict # Build the graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # To keep track of visited nodes visited = [False] * (n + 1) def is_cyclic(v, visited, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if is_cyclic(neighbor, visited, v): return True elif parent != neighbor: return True return False for i in range(1, n + 1): if not visited[i]: if is_cyclic(i, visited, -1): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def reorganize_string(s: str) -> str: Reorganize the string such that no two adjacent characters are the same. >>> reorganize_string('aab') 'aba' >>> reorganize_string('aaab') '' >>> reorganize_string('xxxyyyz') # Output can vary, e.g. 'xyxyzyx' True","solution":"from collections import Counter import heapq def reorganize_string(s): # Count frequency of each character char_count = Counter(s) # Create a max heap (negative counts will make it act like a max heap) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) # Result string container result = [] # Previous character to ensure no two adjacent characters are same prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) result.append(char) # Push the previous character back if it has more occurrences if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and decrease count prev_count, prev_char = count + 1, char # Check if we have created a valid reorganized string reorganized_string = ''.join(result) if len(reorganized_string) != len(s): return \\"\\" return reorganized_string"},{"question":"def can_form_palindrome(s: str) -> str: Tina has a string made up of lowercase English letters. She has a special operation where she can select any substring of the string and reverse it in place. Tina wants to check if it's possible to transform her string into a palindrome using zero or more of these operations. A palindrome is a string that reads the same backward as forward. Write a function that takes Tina's string and returns \\"YES\\" if she can transform it into a palindrome using the special reverse operation, otherwise return \\"NO\\". -----Input----- - A single string s consisting of lowercase English letters (1 le |s| le 100,000). -----Output----- - A single string \\"YES\\" if it's possible to transform the string into a palindrome, otherwise \\"NO\\". -----Example----- Input aabb Output YES Input abc Output NO Input racecar Output YES >>> can_form_palindrome(\\"aabb\\") 'YES' >>> can_form_palindrome(\\"abc\\") 'NO' >>> can_form_palindrome(\\"racecar\\") 'YES'","solution":"def can_form_palindrome(s): Returns \\"YES\\" if the string can be transformed into a palindrome using zero or more substring reverse operations, otherwise returns \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_counts = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if it has at most one character with an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def reverse_house_numbers(n: int, house_numbers: List[int]) -> List[int]: Returns the transformed house numbers after Reversal Day. On Reversal Day, each house number transforms into a new house number based on its reverse. If reversing a number results in a leading zero, that zero should be removed. Parameters: n (int): The number of houses. house_numbers (list): A list of n unique positive integers representing house numbers. Returns: list: A list of n integers representing the reversed house numbers. >>> reverse_house_numbers(5, [123, 450, 321, 789, 101]) [321, 54, 123, 987, 101] >>> reverse_house_numbers(3, [9, 90, 900]) [9, 9, 9] >>> reverse_house_numbers(4, [1, 10, 100, 1000]) [1, 1, 1, 1]","solution":"def reverse_house_numbers(n, house_numbers): Returns the transformed house numbers after Reversal Day. Parameters: n (int): The number of houses. house_numbers (list): A list of n unique positive integers representing house numbers. Returns: list: A list of n integers representing the reversed house numbers. reversed_numbers = [] for number in house_numbers: reversed_number = int(str(number)[::-1]) reversed_numbers.append(reversed_number) return reversed_numbers"},{"question":"def cleaning_robot_moves(n: int, m: int, grid: List[str]) -> str: Determines the sequence of moves the robotic vacuum cleaner should take to clean all reachable cells in a 2D grid. The grid is represented as a list of strings where: - '.' represents a cleanable cell - '#' represents a wall - 'S' represents the starting position of the robot The robot must always take the shortest path and prioritize moves in the following order: up, right, down, and left. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The grid represented as a list of strings. Returns: str: A string representing the sequence of moves to clean all reachable cells. >>> cleaning_robot_moves(4, 4, [\\"S...\\", \\".#..\\", \\"..#.\\", \\"....\\"]) 'RRRDDDLLLUURR' >>> cleaning_robot_moves(2, 2, [\\"S#\\", \\"\\"]) '' >>> cleaning_robot_moves(3, 3, [\\"S..\\", \\"...\\", \\"...\\"]) 'RRDDLUURRDD' >>> cleaning_robot_moves(5, 5, [\\"S....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 'RRRRRDDDDDLLLLUURRRRDDDD'","solution":"from collections import deque MOVE_UP = 'U' MOVE_DOWN = 'D' MOVE_LEFT = 'L' MOVE_RIGHT = 'R' DIR_VECTORS = [(0, 1, MOVE_RIGHT), (1, 0, MOVE_DOWN), (0, -1, MOVE_LEFT), (-1, 0, MOVE_UP)] def bfs_cleaning_route(n, m, grid, start): queue = deque([start]) visited = set() visited.add(start) moves = [] paths = {start: \\"\\"} while queue: x, y = queue.popleft() for dx, dy, move in DIR_VECTORS: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny)) paths[(nx, ny)] = paths[(x, y)] + move return \\"\\".join(paths[(i, j)] for i in range(n) for j in range(m) if grid[i][j] == '.' and (i, j) in visited) def cleaning_robot_moves(n, m, grid): start = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) break if start: break return bfs_cleaning_route(n, m, grid, start)"},{"question":"def evaluate(expression: str) -> int: Evaluate the expression of a given string containing a mathematical expression with only non-negative integers and the operators +, -, *, /. Use the integer division for / operator. >>> evaluate(\\"3+5*2\\") == 13 >>> evaluate(\\"10+20/4\\") == 15 >>> evaluate(\\"2*3+4/2\\") == 8 pass # Unit tests def test_evaluate_simple_addition(): assert evaluate(\\"3+5\\") == 8 def test_evaluate_simple_subtraction(): assert evaluate(\\"10-7\\") == 3 def test_evaluate_simple_multiplication(): assert evaluate(\\"4*6\\") == 24 def test_evaluate_simple_division(): assert evaluate(\\"8/2\\") == 4 def test_evaluate_mixed_operations_add_mul(): assert evaluate(\\"3+5*2\\") == 13 def test_evaluate_mixed_operations_add_div(): assert evaluate(\\"10+20/4\\") == 15 def test_evaluate_mixed_operations_mul_add_div(): assert evaluate(\\"2*3+4/2\\") == 8 def test_evaluate_multiple_operations_with_precedence(): assert evaluate(\\"10+2*3-6/3\\") == 14 def test_evaluate_complex_expression(): assert evaluate(\\"5*6-2*3+10/2\\") == 29","solution":"def evaluate(expression): def parse_expression(expression): num_stack = [] op_stack = [] precedence = {'+': 1, '-': 1, '*': 2, '/': 2} i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 num_stack.append(num) i -= 1 elif expression[i] in precedence: while (op_stack and precedence[op_stack[-1]] >= precedence[expression[i]]): apply_operation(num_stack, op_stack) op_stack.append(expression[i]) i += 1 while op_stack: apply_operation(num_stack, op_stack) return num_stack[0] def apply_operation(num_stack, op_stack): if not num_stack or len(num_stack) < 2: return b = num_stack.pop() a = num_stack.pop() op = op_stack.pop() if op == '+': num_stack.append(a + b) elif op == '-': num_stack.append(a - b) elif op == '*': num_stack.append(a * b) elif op == '/': num_stack.append(a // b) return parse_expression(expression)"},{"question":"from typing import List def numSubarrayProductLessThanK(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is less than k. Args: nums: List[int] - the input array of integers k: int - an integer threshold for the product of subarrays Returns: int - the number of contiguous subarrays where the product of all the elements in the subarray is less than k Example: >>> numSubarrayProductLessThanK([10, 5, 2, 6], 100) 8 >>> numSubarrayProductLessThanK([1, 2, 3], 0) 0","solution":"def numSubarrayProductLessThanK(nums, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is less than k. if k <= 1: return 0 prod = 1 left = 0 result = 0 for right in range(len(nums)): prod *= nums[right] while prod >= k: prod //= nums[left] left += 1 result += right - left + 1 return result"},{"question":"from collections import deque def shortest_path_length(maze, M, N): Finds the shortest path length from the top-left corner to the bottom-right corner of the given maze. Returns -1 if no path exists. maze : List of List of str : 2D grid representing the maze M : int : Number of rows in the maze N : int : Number of columns in the maze >>> shortest_path_length([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.']], 3, 3) == 4 True >>> shortest_path_length([ ... ['.', '#', '.'], ... ['#', '#', '#'], ... ['.', '.', '.']], 3, 3) == -1 True >>> shortest_path_length([['.']], 1, 1) == 0 True >>> shortest_path_length([ ... ['.', '.', '.', '.', '.'], ... ['#', '#', '.', '#', '.'], ... ['.', '.', '.', '#', '.'], ... ['.', '#', '#', '#', '.'], ... ['.', '.', '.', '.', '.']], 5, 5) == 8 True >>> shortest_path_length([ ... ['#', '.'], ... ['.', '.']], 2, 2) == -1 True >>> shortest_path_length([ ... ['.', '.'], ... ['.', '#']], 2, 2) == -1 True","solution":"from collections import deque def shortest_path_length(maze, M, N): Finds the shortest path length from the top-left corner to the bottom-right corner of the given maze. Returns -1 if no path exists. maze : List of List of str : 2D grid representing the maze M : int : Number of rows in the maze N : int : Number of columns in the maze if maze[0][0] == '#' or maze[M-1][N-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = [[False] * N for _ in range(M)] visited[0][0] = True distance = [[0] * N for _ in range(M)] while queue: x, y = queue.popleft() if x == M-1 and y == N-1: return distance[x][y] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and not visited[nx][ny] and maze[nx][ny] == '.': queue.append((nx, ny)) visited[nx][ny] = True distance[nx][ny] = distance[x][y] + 1 return -1"},{"question":"def compare_lists(list1, list2): Returns a list of integers that are common in both list1 and list2 without duplicates. Examples: >>> compare_lists([1, 2, 2, 3], [3, 3, 4, 4, 2]) [2, 3] >>> compare_lists([5, 5, 7, 8], [8, 9, 5, 6]) [5, 8] >>> compare_lists([1, 2, 3], [4, 5, 6]) []","solution":"def compare_lists(list1, list2): Returns a list of integers that are common in both list1 and list2 without duplicates. # Convert both lists to sets to remove duplicates and find the intersection set1 = set(list1) set2 = set(list2) intersection = set1.intersection(set2) # Convert the intersection set back to a sorted list and return return list(intersection)"},{"question":"def longest_increasing_hike(heights: List[int]) -> int: Finds the length of the longest sequence of mountain heights where each subsequent height is greater than or equal to the previous height. >>> longest_increasing_hike([1, 2, 2, 3, 5, 4]) == 5 >>> longest_increasing_hike([10, 9, 2, 5, 3]) == 2 >>> longest_increasing_hike([7]) == 1 >>> longest_increasing_hike([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_hike([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_hike([4, 4, 4, 5, 6, 2, 2, 2, 2, 2]) == 5 >>> longest_increasing_hike([3, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 10","solution":"def longest_increasing_hike(heights): Finds the length of the longest sequence of mountain heights where each subsequent height is greater than or equal to the previous height. if not heights: return 0 n = len(heights) dp = [1] * n # dp[i] represents the length of the longest sequence ending at index i for i in range(1, n): if heights[i] >= heights[i - 1]: dp[i] = dp[i - 1] + 1 else: dp[i] = 1 return max(dp)"},{"question":"def find_winner(n, k, array): Determines the winner of the game given the parameters. >>> find_winner(5, 2, [1, 2, 3, 4, 5]) \\"Ben\\" >>> find_winner(6, 3, [1, 2, 3, 4, 5, 6]) \\"Susan\\" # Unit Tests def test_find_winner_case_1(): assert find_winner(5, 2, [1, 2, 3, 4, 5]) == \\"Ben\\" def test_find_winner_case_2(): assert find_winner(6, 3, [1, 2, 3, 4, 5, 6]) == \\"Susan\\" def test_find_winner_case_3(): assert find_winner(7, 4, [1, 2, 3, 4, 5, 6, 7]) == \\"Ben\\" def test_find_winner_case_4(): assert find_winner(10, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == \\"Susan\\" def test_find_winner_case_5(): assert find_winner(9, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"Ben\\"","solution":"def find_winner(n, k, array): Determines the winner of the game given the parameters. if n % k == 0: return \\"Susan\\" else: return \\"Ben\\" Explanation: 1. If the number of elements n in the array is exactly divisible by the number k of elements to be removed in each move, Susan will be able to make the last move and Ben will have no more elements left to remove in his turn. Hence, Susan wins. 2. Otherwise, Ben will always be able to make the last move. Therefore, Ben wins. # Example usage: # print(find_winner(5, 2, [1, 2, 3, 4, 5])) # Ben # print(find_winner(6, 3, [1, 2, 3, 4, 5, 6])) # Susan # print(find_winner(7, 4, [1, 2, 3, 4, 5, 6, 7])) # Ben"},{"question":"def reverse_words_in_string(s: str) -> str: Reverse each word in the input string while preserving the word order. Parameters: s (str): Input string with words separated by spaces. Returns: str: String with each word reversed while keeping the word order. Examples: >>> reverse_words_in_string(\\"hello world\\") 'olleh dlrow' >>> reverse_words_in_string(\\"Coding is fun\\") 'gnidoC si nuf' >>> reverse_words_in_string(\\"Python programming\\") 'nohtyP gnimmargorp'","solution":"def reverse_words_in_string(s): Reverses each word in the input string while preserving the word order. Parameters: s (str): Input string with words separated by spaces. Returns: str: String with each word reversed while keeping the word order. return ' '.join(word[::-1] for word in s.split(' '))"},{"question":"def calculate_delivery_rates(drivers_data): Calculate the delivery rate for each driver. Parameters: drivers_data (list of tuples): Each tuple contains two integers, Di and Hi, representing the number of deliveries and hours worked respectively. Returns: list of floats: The delivery rates for each driver rounded to two decimal places.","solution":"def calculate_delivery_rates(drivers_data): Calculate the delivery rate for each driver. Parameters: drivers_data (list of tuples): Each tuple contains two integers, Di and Hi, representing the number of deliveries and hours worked respectively. Returns: list of floats: The delivery rates for each driver rounded to two decimal places. rates = [] for deliveries, hours in drivers_data: rate = deliveries / hours rates.append(round(rate, 2)) return rates"},{"question":"def find_largest_rectangle_area(input_str: str) -> int: Finds the largest rectangle containing only 1's in a 2D grid from the input string and returns its area. >>> find_largest_rectangle_area(\\"4 4n1 0 1 0n1 0 1 1n1 1 1 1n0 0 1 0\\") 4 >>> find_largest_rectangle_area(\\"1 4n1 1 1 0\\") 3 >>> find_largest_rectangle_area(\\"4 1n1n1n0n1\\") 2 >>> find_largest_rectangle_area(\\"3 3n0 0 0n0 0 0n0 0 0\\") 0 >>> find_largest_rectangle_area(\\"3 3n1 1 1n1 1 1n1 1 1\\") 9 >>> find_largest_rectangle_area(\\"5 6n1 0 1 1 0 1n1 1 1 1 1 1n0 1 0 1 0 1n1 1 1 1 1 0n0 1 1 0 0 1\\") 6 # Parse the input string to get the dimensions and the grid lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) grid = [] for i in range(1, N + 1): grid.append(list(map(int, lines[i].split()))) # Function to find the maximal rectangle in the grid def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 n = len(matrix) m = len(matrix[0]) heights = [0] * (m + 1) for row in matrix: for i in range(m): if row[i] == 0: heights[i] = 0 else: heights[i] += row[i] stack = [-1] for j in range(m + 1): while heights[j] < heights[stack[-1]]: h = heights[stack.pop()] w = j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area return maximalRectangle(grid)","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 n = len(matrix) m = len(matrix[0]) heights = [0] * (m + 1) for row in matrix: for i in range(m): if row[i] == 0: heights[i] = 0 else: heights[i] += row[i] stack = [-1] for j in range(m + 1): while heights[j] < heights[stack[-1]]: h = heights[stack.pop()] w = j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) grid = [] for i in range(1, N + 1): grid.append(list(map(int, lines[i].split()))) return N, M, grid def find_largest_rectangle_area(input_str): N, M, grid = parse_input(input_str) return maximalRectangle(grid) # Example use: # input_str = \\"4 4n1 0 1 0n1 0 1 1n1 1 1 1n0 0 1 0\\" # print(find_largest_rectangle_area(input_str)) # Output: 4"},{"question":"def arrange_characters_by_frequency(s: str) -> str: Arrange characters in the string 's' in decreasing order based on their frequency. Characters with the same frequency should be sorted alphabetically. ------ Sample Input 1 ------ >>> arrange_characters_by_frequency(\\"tree\\") 'eert' ------ Sample Input 2 ------ >>> arrange_characters_by_frequency(\\"cccaaa\\") 'aaaccc' ------ Sample Input 3 ------ >>> arrange_characters_by_frequency(\\"bbbaaaccc\\") 'aaabbbccc'","solution":"from collections import Counter def arrange_characters_by_frequency(s): Arrange characters in string 's' by decreasing frequency. Characters with the same frequency should be sorted alphabetically. if len(s) == 0: return \\"\\" # Count frequency of each character freq = Counter(s) # Create a sorted list of the items in the counter sorted_items = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Build the result string based on sorted items result = ''.join([char * count for char, count in sorted_items]) return result"},{"question":"def count_clusters(N: int, D: int, intersections: List[Tuple[int, int]]) -> int: Count the number of distinct clusters of intersections. Input: - N: the number of intersections (2 ≤ N ≤ 100000) - D: the maximum distance between any two intersections in a cluster (1 ≤ D ≤ 1000) - intersections: a list of tuples (X, Y) representing the coordinates of each intersection (-1000000 ≤ X, Y ≤ 1000000) Output: - An integer representing the number of distinct clusters. Example: >>> count_clusters(5, 2, [(1, 1), (2, 2), (3, 3), (10, 10), (11, 11)]) 2 >>> count_clusters(3, 1, [(0, 0), (2, 2), (4, 4)]) 3","solution":"import math class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def count_clusters(N, D, intersections): uf = UnionFind(N) def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) for i in range(N): for j in range(i + 1, N): if euclidean_distance(intersections[i], intersections[j]) <= D: uf.union(i, j) unique_clusters = len(set(uf.find(i) for i in range(N))) return unique_clusters # Example call to the function based on the provided test input N = 5 D = 2 intersections = [(1, 1), (2, 2), (3, 3), (10, 10), (11, 11)] print(count_clusters(N, D, intersections)) # Output should be 2"},{"question":"def prioritize_animals(test_cases): Returns the sorted order of animal identification numbers for each test case. Args: - test_cases (list of tuples): Each tuple contains the number of identification numbers followed by a list of those numbers. Returns: - list: List of sorted identification numbers for each test case. >>> prioritize_animals([(3, [5, 3, 9]), (4, [1, 4, 7, 3])]) [[3, 5, 9], [1, 3, 4, 7]] >>> prioritize_animals([(5, [5, 3, 3, 9, 5])]) [[3, 3, 5, 5, 9]] >>> prioritize_animals([(1, [42])]) [[42]] >>> prioritize_animals([(3, [1000000000, 999999999, 1])]) [[1, 999999999, 1000000000]]","solution":"def prioritize_animals(test_cases): Returns the sorted order of animal identification numbers for each test case. Args: - test_cases (list of tuples): Each tuple contains the number of identification numbers followed by a list of those numbers. Returns: - list: List of sorted identification numbers for each test case. results = [] for case in test_cases: n, ids = case ids_sorted = sorted(ids) results.append(ids_sorted) return results"},{"question":"def has_palindromic_substring(n: int, k: int, s: str) -> str: Determine if the string s has a palindromic substring of length at least 2 and at most k. Return \\"YES\\" if such a substring exists, otherwise \\"NO\\". >>> has_palindromic_substring(5, 3, 'ababa') \\"YES\\" >>> has_palindromic_substring(6, 2, 'abcdef') \\"NO\\" >>> has_palindromic_substring(4, 4, 'abccba') \\"YES\\" pass def process_inputs(inputs: List[str]) -> List[str]: Takes a list of input strings and processes them to determine if each case has a palindromic substring of specified length. >>> process_inputs([\\"3\\", \\"5 3\\", \\"ababa\\", \\"6 2\\", \\"abcdef\\", \\"4 4\\", \\"abccba\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def has_palindromic_substring(n, k, s): Determine if the string s has a palindromic substring of length at least 2 and at most k. Return \\"YES\\" if such a substring exists, otherwise \\"NO\\". def is_palindrome(sub): return sub == sub[::-1] # Check for palindromes from length 2 to k for l in range(2, k + 1): for i in range(n - l + 1): if is_palindrome(s[i:i + l]): return \\"YES\\" return \\"NO\\" def process_inputs(inputs): results = [] index = 0 T = int(inputs[index]) index += 1 for _ in range(T): N, K = map(int, inputs[index].split()) index += 1 S = inputs[index] index += 1 results.append(has_palindromic_substring(N, K, S)) return results"},{"question":"def longest_subsequence_length(n: int, arr: List[int]) -> int: Returns the length of the longest subsequence such that the absolute difference between any two elements is not more than one. >>> longest_subsequence_length(6, [1, 2, 2, 3, 1, 2]) 5 >>> longest_subsequence_length(5, [4, 6, 5, 3, 3]) 3 >>> longest_subsequence_length(4, [1, 1, 1, 1]) 4 >>> longest_subsequence_length(1, [10]) 1 >>> longest_subsequence_length(3, [10, 20, 30]) 1 >>> longest_subsequence_length(7, [1, 1, 1, 2, 2, 2, 3]) 6","solution":"def longest_subsequence_length(n, arr): Returns the length of the longest subsequence such that the absolute difference between any two elements is not more than one. Parameters: n (int): Number of elements in the list arr (list of int): List of positive integers Returns: int: Length of the longest subsequence from collections import Counter # Count occurrences of each number count = Counter(arr) max_length = 0 # Iterate through the unique numbers in the list for num in count: # Calculate the sum of count of this number and the number+1 current_length = count[num] + count.get(num + 1, 0) max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def find_max_length(arr: List[int]) -> int: Determine the maximum length of a contiguous subarray with an equal number of 0s and 1s. >>> find_max_length([0, 1, 0, 0, 1, 1, 0]) 6 >>> find_max_length([0, 0, 1, 0, 0, 0, 1, 1]) 6 >>> find_max_length([1, 1, 1, 1, 1, 1]) 0 >>> find_max_length([0, 0, 0, 0, 0, 0]) 0 >>> find_max_length([0, 1]) 2 >>> find_max_length([0]) 0 >>> find_max_length([1]) 0 >>> find_max_length([0, 1, 0, 1, 1]) 4 >>> find_max_length([1, 0, 1, 0, 1, 0]) 6 >>> find_max_length([0, 1] * 5000) 10000","solution":"def find_max_length(arr): Returns the maximum length of a contiguous subarray with an equal number of 0s and 1s. count = 0 max_length = 0 hash_map = {0: -1} # Initialize with 0 to handle cases from the start of the array for index, value in enumerate(arr): # Change 0s to -1s to utilize the sum/count approach count += -1 if value == 0 else 1 if count in hash_map: max_length = max(max_length, index - hash_map[count]) else: hash_map[count] = index return max_length"},{"question":"from typing import List def minContainers(products: List[int], maxCapacity: int) -> int: Determine the minimum number of containers required to store all the products without exceeding the maximum weight capacity. >>> minContainers([3, 6, 2, 8, 7], 10) 3 >>> minContainers([5], 10) 1","solution":"def minContainers(products, maxCapacity): # Sort products in descending order products.sort(reverse=True) # List to hold the current weight in each container containers = [] for weight in products: placed = False # Try to place the current product in one of the existing containers for i in range(len(containers)): if containers[i] + weight <= maxCapacity: containers[i] += weight placed = True break # If the product could not be placed in an existing container, add a new container if not placed: containers.append(weight) return len(containers)"},{"question":"def min_shelves_needed(n, figures): Returns the minimum number of shelves required to display all the figures. :param n: int - number of different types of action figures :param figures: list - list containing the number of figures of each type :return: int - minimum number of shelves required >>> min_shelves_needed(3, [2, 3, 1]) == 3 >>> min_shelves_needed(4, [4, 4, 4, 4]) == 4 >>> min_shelves_needed(5, [1, 2, 3, 4, 5]) == 5 >>> min_shelves_needed(1, [10]) == 10 >>> min_shelves_needed(5, [1, 1, 1, 1, 1]) == 1 >>> min_shelves_needed(3, [8, 3, 5]) == 8 >>> min_shelves_needed(4, [100, 200, 300, 400]) == 400","solution":"def min_shelves_needed(n, figures): Returns the minimum number of shelves required to display all the figures. :param n: int - number of different types of action figures :param figures: list - list containing the number of figures of each type :return: int - minimum number of shelves required max_figures_per_type = max(figures) return max_figures_per_type"},{"question":"def sort_arrays(test_cases): Sorts the arrays in non-decreasing order for each test case. Parameters: test_cases (list of lists): List of test cases where each test case contains a list of integers. Returns: list of lists: List of sorted arrays. pass def parse_input(input_str): Parse the input string to extract the number of test cases and the arrays. Parameters: input_str (str): The input string containing number of test cases, followed by integers in each test case. Returns: list of lists: List of extracted arrays from the input string. pass def format_output(sorted_arrays): Formats the sorted arrays for output. Parameters: sorted_arrays (list of lists): List of sorted arrays. Returns: str: Formatted string of sorted arrays for each test case separated by newlines. pass # Unit tests from solution import sort_arrays, parse_input, format_output def test_sort_arrays(): assert sort_arrays([[3, 1, 2, 5, 4], [3, 2, 1]]) == [[1, 2, 3, 4, 5], [1, 2, 3]] def test_parse_input(): input_str = \\"2n5n3 1 2 5 4n3n3 2 1n\\" expected_output = [[3, 1, 2, 5, 4], [3, 2, 1]] assert parse_input(input_str) == expected_output def test_format_output(): sorted_arrays = [[1, 2, 3, 4, 5], [1, 2, 3]] expected_output = \\"1 2 3 4 5n1 2 3\\" assert format_output(sorted_arrays) == expected_output def test_complete_solution(): input_str = \\"2n5n3 1 2 5 4n3n3 2 1n\\" test_cases = parse_input(input_str) sorted_arrays = sort_arrays(test_cases) output_str = format_output(sorted_arrays) assert output_str == \\"1 2 3 4 5n1 2 3\\"","solution":"def sort_arrays(test_cases): Sorts the arrays in non-decreasing order for each test case. Parameters: test_cases (list of lists): List of test cases where each test case contains a list of integers. Returns: list of lists: List of sorted arrays. sorted_arrays = [] for arr in test_cases: sorted_arrays.append(sorted(arr)) return sorted_arrays def parse_input(input_str): Parse the input string to extract the number of test cases and the arrays. Parameters: input_str (str): The input string containing number of test cases, followed by integers in each test case. Returns: list of lists: List of extracted arrays from the input string. lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append(arr) index += 2 return test_cases def format_output(sorted_arrays): Formats the sorted arrays for output. Parameters: sorted_arrays (list of lists): List of sorted arrays. Returns: str: Formatted string of sorted arrays for each test case separated by newlines. return \\"n\\".join(\\" \\".join(map(str, arr)) for arr in sorted_arrays)"},{"question":"def find_reflection_point(x: int, y: int) -> tuple: Given the dimensions of the rectangle, return the coordinates (a, b) such that the point P (a, b) is inside the rectangle and when reflected across both the x-axis and y-axis results in a point Q that also lies inside the rectangle. Parameters: x (int): The length of the rectangle along the x-axis y (int): The height of the rectangle along the y-axis Returns: tuple: Coordinates of the point (a, b) inside the rectangle >>> find_reflection_point(10, 5) (5, 2) >>> find_reflection_point(24, 10) (12, 5) >>> find_reflection_point(1, 1) (0, 0) >>> find_reflection_point(1000000000, 1000000000) (500000000, 500000000) >>> find_reflection_point(100, 1) (50, 0) >>> find_reflection_point(1, 100) (0, 50)","solution":"def find_reflection_point(x, y): Given the dimensions of the rectangle, return the coordinates (a, b) such that the point P (a, b) is inside the rectangle and when reflected across both the x-axis and y-axis results in a point Q that also lies inside the rectangle. Parameters: x (int): The length of the rectangle along the x-axis y (int): The height of the rectangle along the y-axis Returns: tuple: Coordinates of the point (a, b) inside the rectangle a = x // 2 b = y // 2 return (a, b)"},{"question":"from typing import List, Tuple def does_cycle_exist_of_length_k(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> str: Determine whether a cycle of length exactly k exists in the given undirected graph. Args: n (int): The number of vertices in the graph. m (int): The number of edges in the graph. k (int): The length of the cycle to find. edges (List[Tuple[int, int]]): List of edges in the graph. Returns: str: \\"YES\\" if there exists a cycle of length exactly k, otherwise \\"NO\\". Examples: >>> does_cycle_exist_of_length_k(5, 7, 4, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (1, 3)]) 'YES' >>> does_cycle_exist_of_length_k(4, 4, 3, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'NO' from solution import does_cycle_exist_of_length_k def test_example_1(): n, m, k = 5, 7, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (1, 3)] assert does_cycle_exist_of_length_k(n, m, k, edges) == \\"YES\\" def test_example_2(): n, m, k = 4, 4, 3 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert does_cycle_exist_of_length_k(n, m, k, edges) == \\"NO\\" def test_no_edges(): n, m, k = 3, 0, 3 edges = [] assert does_cycle_exist_of_length_k(n, m, k, edges) == \\"NO\\" def test_no_cycle(): n, m, k = 3, 2, 3 edges = [(1, 2), (2, 3)] assert does_cycle_exist_of_length_k(n, m, k, edges) == \\"NO\\" def test_simple_cycle(): n, m, k = 3, 3, 3 edges = [(1, 2), (2, 3), (3, 1)] assert does_cycle_exist_of_length_k(n, m, k, edges) == \\"YES\\"","solution":"from itertools import combinations def does_cycle_exist_of_length_k(n, m, k, edges): from collections import defaultdict # Building the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Helper function to find all cycles of length k starting from each vertex def find_cycles(v, visited, path, target_length): if len(path) == target_length: return path[0] in graph[path[-1]] result = False visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: path.append(neighbor) result = result or find_cycles(neighbor, visited, path, target_length) path.pop() visited[v] = False return result # Check for each vertex if we can find a cycle of length k starting from it for vertex in range(1, n + 1): visited = [False] * (n + 1) if find_cycles(vertex, visited, [vertex], k): return \\"YES\\" return \\"NO\\" # Example Usage: # n, m, k = 5, 7, 4 # edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (1, 3)] # print(does_cycle_exist_of_length_k(n, m, k, edges))"},{"question":"def max_consecutive_open_days(S: str) -> int: Returns the maximum number of consecutive 'O' characters in the string S of length 3. >>> max_consecutive_open_days('COO') == 2 >>> max_consecutive_open_days('OOC') == 2 >>> max_consecutive_open_days('OOO') == 3 >>> max_consecutive_open_days('CCC') == 0 >>> max_consecutive_open_days('COC') == 1","solution":"def max_consecutive_open_days(S): Returns the maximum number of consecutive 'O' characters in the string S of length 3. return max(map(len, S.split('C')))"},{"question":"def sortedWord(word: str) -> str: Returns a string where the characters are sorted in lexicographical order. >>> sortedWord(\\"helloworld\\") \\"dehllloorw\\" >>> sortedWord(\\"python\\") \\"hnopty\\" >>> sortedWord(\\"kata\\") \\"aakt\\"","solution":"def sortedWord(word): Returns a string where the characters are sorted in lexicographical order. return ''.join(sorted(word))"},{"question":"from typing import Any def canFormPalindrome(s: str) -> bool: Determines if a string of lowercase characters can be rearranged to form a palindrome. Args: s (str): a string to check Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False Examples: >>> canFormPalindrome(\\"civic\\") True >>> canFormPalindrome(\\"ivicc\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"aabbccdd\\") True def test_palindrome_permutation(): assert canFormPalindrome(\\"civic\\") == True, \\"Test case civic failed\\" assert canFormPalindrome(\\"ivicc\\") == True, \\"Test case ivicc failed\\" assert canFormPalindrome(\\"hello\\") == False, \\"Test case hello failed\\" assert canFormPalindrome(\\"aabbccdd\\") == True, \\"Test case aabbccdd failed\\" assert canFormPalindrome(\\"racecar\\") == True, \\"Test case racecar failed\\" assert canFormPalindrome(\\"carrace\\") == True, \\"Test case carrace failed\\" assert canFormPalindrome(\\"daily\\") == False, \\"Test case daily failed\\" assert canFormPalindrome(\\"a\\") == True, \\"Test case a failed\\" assert canFormPalindrome(\\"\\") == True, \\"Test case empty string failed\\" assert canFormPalindrome(\\"aabb\\") == True, \\"Test case aabb failed\\"","solution":"def canFormPalindrome(s): Determines if a string can be rearranged to form a palindrome. Args: s (str): a string to check Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False from collections import Counter # Count the frequency of each character char_count = Counter(s) # To form a palindrome, at most one character can have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If odd_count is more than 1, it cannot form a palindrome return odd_count <= 1"},{"question":"def final_coordinates(directions: str) -> tuple: Returns the final coordinates after executing the moves. Parameters: directions (str): A string consisting of characters 'L', 'R', 'U', 'D' Returns: tuple: The final coordinates (x, y) >>> final_coordinates(\\"LLRR\\") (0, 0) >>> final_coordinates(\\"UUDD\\") (0, 0) >>> final_coordinates(\\"LURDLURD\\") (0, 0) >>> final_coordinates(\\"LLLL\\") (-4, 0) >>> final_coordinates(\\"RRRRR\\") (5, 0) >>> final_coordinates(\\"UUUDDD\\") (0, 0) >>> final_coordinates(\\"DDDDUU\\") (0, -2) >>> final_coordinates(\\"LURDLDRU\\") (0, 0) def handle_multiple_cases(T: int, cases: list) -> list: Process multiple test cases and returns their final coordinates. Parameters: T (int): Number of test cases cases (list of str): A list of direction strings Returns: list of tuple: A list containing final coordinates for each test case >>> handle_multiple_cases(3, [\\"LLRR\\", \\"UUDD\\", \\"LURDLURD\\"]) [(0, 0), (0, 0), (0, 0)] >>> handle_multiple_cases(2, [\\"LLLL\\", \\"RRRRR\\"]) [(-4, 0), (5, 0)] >>> handle_multiple_cases(1, [\\"DDDDUU\\"]) [(0, -2)] >>> handle_multiple_cases(4, [\\"L\\", \\"R\\", \\"U\\", \\"D\\"]) [(-1, 0), (1, 0), (0, 1), (0, -1)]","solution":"def final_coordinates(directions): Returns the final coordinates after executing the moves. Parameters: directions (str): A string consisting of characters 'L', 'R', 'U', 'D' Returns: tuple: The final coordinates (x, y) x, y = 0, 0 for move in directions: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return (x, y) def handle_multiple_cases(T, cases): Process multiple test cases and returns their final coordinates. Parameters: T (int): Number of test cases cases (list of str): A list of direction strings Returns: list of tuple: A list containing final coordinates for each test case results = [] for directions in cases: results.append(final_coordinates(directions)) return results"},{"question":"def find_smallest_rectangle(n: int, m: int, grid: List[str]) -> Union[Tuple[int, int, int, int], int]: Find the smallest rectangular area that encompasses all the 'X' in the warehouse grid. Returns the coordinates of the top-left and bottom-right corners of the rectangle in 1-based index. If there are no 'X' items, returns -1. >>> find_smallest_rectangle(3, 4, [ ... \\"....\\", ... \\".X..\\", ... \\"..X.\\" ... ]) (2, 2, 3, 3) >>> find_smallest_rectangle(4, 5, [ ... \\".....\\", ... \\"..X..\\", ... \\"..X..\\", ... \\".....\\" ... ]) (2, 3, 3, 3) >>> find_smallest_rectangle(4, 4, [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ]) -1","solution":"def find_smallest_rectangle(n, m, grid): top, bottom = n, -1 left, right = m, -1 # Scan the grid to find the boundaries of the rectangle that includes all 'X' for i in range(n): for j in range(m): if grid[i][j] == 'X': if i < top: top = i if i > bottom: bottom = i if j < left: left = j if j > right: right = j if top == n: # no 'X' found return -1 # Convert 0-based indices to 1-based. return top + 1, left + 1, bottom + 1, right + 1"},{"question":"def convert_to_title(s: str) -> str: Given a string s representing a positive integer between 1 and 2^31 - 1, return its corresponding column title as it would appear in an Excel sheet. For example: 1 -> A 2 -> B 3 -> C ... 26 -> Z 27 -> AA 28 -> AB ... Example 1: >>> convert_to_title(\\"1\\") \\"A\\" Example 2: >>> convert_to_title(\\"28\\") \\"AB\\" Example 3: >>> convert_to_title(\\"701\\") \\"ZY\\"","solution":"def convert_to_title(s): Converts a string representing a positive integer to a corresponding Excel column title. n = int(s) result = [] while n > 0: n -= 1 result.append(chr(n % 26 + ord('A'))) n //= 26 return ''.join(result[::-1])"},{"question":"def find_max_value(n: int, operations: [(int, int, int)]) -> int: Returns the maximum value in the array after performing the given operations. Parameters: - n: int, the size of the array - operations: a list of tuples (a, b, k) representing the operations Each tuple (a, b, k) means adding k to each element of the array with indexes between a and b (inclusive). Returns: - int, the maximum value in the array after performing all the operations from solution import find_max_value def test_case_1(): assert find_max_value(5, [(1, 2, 100), (2, 5, 100), (3, 4, 100)]) == 200 def test_case_2(): assert find_max_value(10, [(1, 5, 10), (6, 10, 15)]) == 15 def test_case_3(): assert find_max_value(5, [(1, 5, 200), (2, 3, 100)]) == 300 def test_case_4(): assert find_max_value(7, [(1, 2, 50), (3, 5, 20), (4, 6, 30)]) == 50 def test_case_5(): assert find_max_value(3, [(1, 1, 1), (2, 2, 2), (3, 3, 3)]) == 3","solution":"def find_max_value(n, operations): Returns the maximum value in the array after performing the given operations. Parameters: - n: int, the size of the array - operations: a list of tuples (a, b, k) representing the operations Each tuple (a, b, k) means adding k to each element of the array with indexes between a and b (inclusive). Returns: - int, the maximum value in the array after performing all the operations arr = [0] * (n + 1) for a, b, k in operations: arr[a] += k if b + 1 <= n: arr[b + 1] -= k max_value = 0 current_value = 0 for value in arr: current_value += value if current_value > max_value: max_value = current_value return max_value"},{"question":"def max_subarray_sum(n, heights): Function to find the maximum sum of a contiguous subarray. :param n: integer, number of days :param heights: list of integers, height gained by the plant on each day :return: integer, maximum sum of contiguous subarray >>> max_subarray_sum(7, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [7]) 7 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [0, 0, 0, 0, 0]) 0 >>> max_subarray_sum(5, [1, 2, 3, -10, 1]) 6 >>> max_subarray_sum(1000, [i for i in range(1, 1001)]) 500500","solution":"def max_subarray_sum(n, heights): Function to find the maximum sum of a contiguous subarray. :param n: integer, number of days :param heights: list of integers, height gained by the plant on each day :return: integer, maximum sum of contiguous subarray max_current = max_global = heights[0] for i in range(1, n): max_current = max(heights[i], max_current + heights[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def solve_bipartite_problem(test_cases): Determine if a given graph is bipartite. Args: test_cases (list): A list of tuples where each tuple contains: - n (int): Number of vertices in the graph - m (int): Number of edges in the graph - edges (list): List of tuples where each tuple represents an edge (u, v) Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case to indicate if the graph is bipartite. Example: >>> solve_bipartite_problem([ ... (3, 3, [(1, 2), (2, 3), (3, 1)]), ... (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), ... (5, 4, [(1, 2), (3, 4), (2, 3), (4, 5)]) ... ]) ['NO', 'YES', 'YES']","solution":"def is_bipartite_graph(n, edges): from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (n + 1) def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for vertex in range(1, n + 1): if color[vertex] == -1: if not bfs(vertex): return \\"NO\\" return \\"YES\\" def solve_bipartite_problem(test_cases): results = [] for n, m, edges in test_cases: result = is_bipartite_graph(n, edges) results.append(result) return results"},{"question":"def number_of_configurations(N: int, M: int, X: int, Y: int, K: int) -> int: This function calculates the number of configurations possible for planting flowers while respecting the special spot constraint. pass def process_test_cases(test_cases: List[Tuple[int, int, int, int, int]]) -> List[int]: This function processes multiple test cases and returns the results as a list. pass # Unit Tests def test_number_of_configurations(): assert number_of_configurations(3, 3, 2, 2, 3) == 3 ** 9 assert number_of_configurations(2, 2, 1, 2, 4) == 4 ** 4 def test_process_test_cases(): test_cases = [(3, 3, 2, 2, 3), (2, 2, 1, 2, 4)] assert process_test_cases(test_cases) == [3 ** 9, 4 ** 4] def test_additional_cases(): assert number_of_configurations(1, 1, 1, 1, 2) == 2 ** 1 assert number_of_configurations(1, 5, 1, 3, 2) == 2 ** 5 assert number_of_configurations(100, 100, 50, 50, 1) == 1 ** 10000","solution":"def number_of_configurations(N, M, X, Y, K): This function calculates the number of configurations possible for planting flowers while respecting the special spot constraint. total_cells = N * M return K ** total_cells def process_test_cases(test_cases): results = [] for case in test_cases: N, M, X, Y, K = case results.append(number_of_configurations(N, M, X, Y, K)) return results"},{"question":"def process_queries(s: str, T: str, queries: list) -> list: Processes the given queries on string s and alphabet subset T. The function should handle two types of queries: 1. Count the occurrences of characters from subset T in substring s[l:r] inclusive. 2. Replace the character at the v-th position of s with character c. Args: s (str): The input string. T (str): The alphabet subset. queries (list): A list of tuples where each tuple represents a query. Returns: list: A list of results for each 'count' query in order. Example: >>> s = 'abcabcabc' >>> T = 'ab' >>> queries = [(1, 1, 3), (2, 2, 'd'), (1, 1, 3), (2, 5, 'e'), (1, 1, 5)] >>> process_queries(s, T, queries) == [2, 1, 2] def test_process_queries(): # Test case from example s = 'abcabcabc' T = 'ab' queries = [(1, 1, 3), (2, 2, 'd'), (1, 1, 3), (2, 5, 'e'), (1, 1, 5)] expected = [2, 1, 2] assert process_queries(s, T, queries) == expected # Test case with single character string s = 'a' T = 'a' queries = [(1, 1, 1), (2, 1, 'b'), (1, 1, 1)] expected = [1, 0] assert process_queries(s, T, queries) == expected # Test case with no T characters in s s = 'bcdef' T = 'a' queries = [(1, 1, 5), (2, 2, 'a'), (1, 1, 5)] expected = [0, 1] assert process_queries(s, T, queries) == expected # Test case with changes that replace T characters s = 'aaaaaaaaaa' T = 'a' queries = [(1, 1, 10), (2, 1, 'b'), (1, 1, 10)] expected = [10, 9] assert process_queries(s, T, queries) == expected def run_tests(): test_process_queries() print(\\"All tests passed.\\") run_tests()","solution":"def process_queries(s, T, queries): Processes the given queries on string s and alphabet subset T. from collections import Counter # Convert string to list for mutable operations s = list(s) n = len(s) # Precompute counts of T characters in prefix sums prefix_count = [[0] * (n + 1) for _ in range(26)] def char_to_index(c): return ord(c) - ord('a') for i in range(n): for j in range(26): prefix_count[j][i + 1] = prefix_count[j][i] if s[i] in T: prefix_count[char_to_index(s[i])][i + 1] += 1 result = [] for query in queries: query_type = query[0] if query_type == 1: l, r = query[1], query[2] count = 0 for char in T: count += prefix_count[char_to_index(char)][r] - prefix_count[char_to_index(char)][l - 1] result.append(count) elif query_type == 2: v, c = query[1], query[2] v -= 1 if s[v] in T: char_idx = char_to_index(s[v]) for i in range(v, n): prefix_count[char_idx][i + 1] -= 1 s[v] = c if c in T: char_idx = char_to_index(c) for i in range(v, n): prefix_count[char_idx][i + 1] += 1 return result"},{"question":"def max_total_points(N: int, K: int, points: List[int]) -> int: Determines the maximum total points Chef can earn by solving up to K problems. Parameters: N (int): Total number of problems. K (int): Maximum number of problems Chef can solve. points (list): List of integers representing the points for each problem. Returns: int: The maximum total points Chef can earn. >>> max_total_points(7, 3, [4, 8, 15, 16, 23, 42, 8]) 81 >>> max_total_points(5, 5, [10, 20, 30, 40, 50]) 150 >>> max_total_points(1, 1, [100]) 100 >>> max_total_points(5, 1, [10, 50, 20, 30, 40]) 50 >>> max_total_points(4, 4, [1, 2, 3, 4]) 10 >>> max_total_points(6, 2, [5, 5, 5, 5, 5, 5]) 10 >>> max_total_points(7, 0, [7, 8, 9, 10, 5, 6, 4]) 0","solution":"def max_total_points(N, K, points): Determines the maximum total points Chef can earn by solving up to K problems. Parameters: N (int): Total number of problems. K (int): Maximum number of problems Chef can solve. points (list): List of integers representing the points for each problem. Returns: int: The maximum total points Chef can earn. # Sort the points in descending order to get the highest points sorted_points = sorted(points, reverse=True) # Sum the top K points max_points = sum(sorted_points[:K]) return max_points"},{"question":"def min_additions_to_make_palindrome(s: str) -> int: Determine the minimum number of character additions required to make the given string a palindrome. >>> min_additions_to_make_palindrome(\\"ab\\") 1 >>> min_additions_to_make_palindrome(\\"racecar\\") 0 >>> min_additions_to_make_palindrome(\\"abc\\") 2 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases to determine the minimum number of character additions required to make the given strings palindrome. >>> process_test_cases(3, [\\"ab\\", \\"racecar\\", \\"abc\\"]) [1, 0, 2] >>> process_test_cases(4, [\\"a\\", \\"aa\\", \\"aba\\", \\"abb\\"]) [0, 0, 0, 1]","solution":"def min_additions_to_make_palindrome(s): Determine the minimum number of character additions required to make the given string a palindrome. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return 0 for i in range(len(s)): if is_palindrome(s[i:]): return i return len(s) - 1 def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_additions_to_make_palindrome(s)) return results"},{"question":"def find_triplet(arr: List[int], target: int) -> bool: Determines if there are three distinct elements a, b, c in the array such that a + b + c == target. Parameters: arr (list): List of positive integers. target (int): Target sum. Returns: bool: True if such a triplet exists, otherwise False. >>> find_triplet([1, 4, 45, 6, 10, 8], 22) True >>> find_triplet([1, 2, 4, 3, 6], 10) True >>> find_triplet([1, 2, 3, 4, 5], 15) False","solution":"def find_triplet(arr, target): Determines if there are three distinct elements a, b, c in the array such that a + b + c == target. Parameters: arr (list): List of positive integers. target (int): Target sum. Returns: bool: True if such a triplet exists, otherwise False. n = len(arr) arr.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def max_perimeter_of_triangle(n: int, lengths: List[int]) -> int: This function returns the maximum possible perimeter of a triangle that can be formed from the given list of stick lengths. If no such triangle can be formed, it returns -1. :param n: int - number of sticks :param lengths: List[int] - lengths of the sticks :return: int - maximum possible perimeter of a triangle, or -1 if no triangle can be formed >>> max_perimeter_of_triangle(5, [2, 3, 4, 5, 10]) 12 >>> max_perimeter_of_triangle(4, [4, 5, 10, 20]) -1","solution":"def max_perimeter_of_triangle(n, lengths): This function returns the maximum possible perimeter of a triangle that can be formed from the given list of stick lengths. If no such triangle can be formed, it returns -1. :param n: int - number of sticks :param lengths: List[int] - lengths of the sticks :return: int - maximum possible perimeter of a triangle, or -1 if no triangle can be formed lengths.sort(reverse=True) for i in range(n - 2): if lengths[i] < lengths[i + 1] + lengths[i + 2]: return lengths[i] + lengths[i + 1] + lengths[i + 2] return -1"},{"question":"def longest_palindrome(s: str) -> (str, int): Returns the longest palindromic substring in s and its starting index. >>> longest_palindrome(\\"babad\\") ('bab', 0) or ('aba', 1) >>> longest_palindrome(\\"cbbd\\") ('bb', 1) >>> longest_palindrome(\\"racecar\\") ('racecar', 0)","solution":"def longest_palindrome(s: str) -> (str, int): Returns the longest palindromic substring in s and its starting index. if len(s) <= 1: return (s, 0) start, max_length = 0, 1 def expand_around_center(left: int, right: int) -> (int, int): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(len(s)): # Odd length palindromes left1, right1 = expand_around_center(i, i) if right1 - left1 + 1 > max_length: start, max_length = left1, right1 - left1 + 1 # Even length palindromes left2, right2 = expand_around_center(i, i + 1) if right2 - left2 + 1 > max_length: start, max_length = left2, right2 - left2 + 1 return (s[start:start + max_length], start)"},{"question":"from typing import List def max_sum_subsequence(arr: List[int]) -> int: Computes the maximum sum of a subsequence such that no two consecutive integers in the subsequence have the same sign. >>> max_sum_subsequence([1, -2, 3, -4, 5]) 3 >>> max_sum_subsequence([1, -2, -3, 4, -5, 6]) 4 >>> max_sum_subsequence([]) 0 >>> max_sum_subsequence([5]) 5 >>> max_sum_subsequence([-5]) -5 >>> max_sum_subsequence([1, 2, 3]) 1 >>> max_sum_subsequence([-1, -2, -3]) -1 pass def process_test_cases(T: int, test_cases: List[List[int]]) -> List[int]: Processes multiple test cases. Args: - T (int): number of test cases - test_cases (list of lists): a list containing T lists of integers Returns: - list of int: the results for each test case >>> process_test_cases(2, [[1, -2, 3, -4, 5], [1, -2, -3, 4, -5, 6]]) [3, 4] pass","solution":"def max_sum_subsequence(arr): Returns the maximum sum of a subsequence such that no two consecutive integers have the same sign. if not arr: return 0 n = len(arr) max_sum = arr[0] for i in range(1, n): if arr[i] * arr[i-1] < 0: # Check if the current and previous elements have different signs max_sum += arr[i] return max_sum def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(max_sum_subsequence(case)) return results"},{"question":"def smallestNonRepresentableSum(N: int, V: List[int]) -> int: Find the smallest sum of money that cannot be formed using any subset of these coins. >>> smallestNonRepresentableSum(5, [1, 1, 3, 4, 6]) 16 >>> smallestNonRepresentableSum(3, [1, 2, 2]) 6 def test_example1(): assert smallestNonRepresentableSum(5, [1, 1, 3, 4, 6]) == 16 def test_example2(): assert smallestNonRepresentableSum(3, [1, 2, 2]) == 6 def test_single_coin(): assert smallestNonRepresentableSum(1, [1]) == 2 assert smallestNonRepresentableSum(1, [2]) == 1 def test_two_coins(): assert smallestNonRepresentableSum(2, [1, 2]) == 4 assert smallestNonRepresentableSum(2, [1, 3]) == 2 assert smallestNonRepresentableSum(2, [2, 3]) == 1 def test_large_range(): assert smallestNonRepresentableSum(3, [2, 5, 10]) == 1 def test_repeated_coins(): assert smallestNonRepresentableSum(4, [1, 1, 1, 1]) == 5 def test_high_values(): assert smallestNonRepresentableSum(5, [100, 200, 300, 400, 500]) == 1","solution":"def smallestNonRepresentableSum(N, V): V.sort() # Initialize the smallest sum that cannot be represented smallest_sum = 1 for coin in V: if coin > smallest_sum: break smallest_sum += coin return smallest_sum"},{"question":"def shortestPalindrome(s: str) -> str: Returns the shortest palindrome by appending characters to the front of the input string. >>> shortestPalindrome(\\"race\\") \\"ecarace\\" >>> shortestPalindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortestPalindrome(\\"a\\") \\"a\\" >>> shortestPalindrome(\\"aba\\") \\"aba\\" >>> shortestPalindrome(\\"abcd\\") \\"dcbabcd\\"","solution":"def shortestPalindrome(s): Returns the shortest palindrome by appending characters to the front of the input string if not s: return s rev = s[::-1] comb = s + '#' + rev lps = [0] * len(comb) for i in range(1, len(comb)): j = lps[i - 1] while j > 0 and comb[i] != comb[j]: j = lps[j - 1] if comb[i] == comb[j]: lps[i] = j + 1 return rev[:len(s)-lps[-1]] + s"},{"question":"def max_flowers_in_garden(n: int, grid: List[List[int]]) -> int: Determine the maximum number of flowers that can be collected from either one row or one column of the garden. >>> max_flowers_in_garden(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 24 >>> max_flowers_in_garden(2, [ ... [100, 200], ... [300, 400] ... ]) 700 >>> max_flowers_in_garden(1, [ ... [50] ... ]) 50 >>> max_flowers_in_garden(3, [ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) 15 >>> max_flowers_in_garden(4, [ ... [1, 1, 1, 1], ... [2, 2, 2, 2], ... [3, 3, 3, 3], ... [4, 4, 4, 4] ... ]) 16","solution":"def max_flowers_in_garden(n, grid): max_flowers = 0 # Check each row for the maximum flowers possible to collect for row in grid: max_flowers = max(max_flowers, sum(row)) # Check each column for the maximum flowers possible to collect for col in range(n): col_sum = sum(grid[row][col] for row in range(n)) max_flowers = max(max_flowers, col_sum) return max_flowers # Example usage: n = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(max_flowers_in_garden(n, grid)) # Output: 24"},{"question":"def check_toxicity(test_cases): Determine if the total toxicity of detected toxic subsequences exceeds the threshold for each test case. >>> check_toxicity([ >>> { >>> 'main_string': 'aaabbbcccc', >>> 'subsequences': [('aa', 3), ('bb', 4)], >>> 'threshold': 5 >>> }, >>> { >>> 'main_string': 'gggtttcccaa', >>> 'subsequences': [('ggg', 2), ('ttt', 3), ('ccc', 5)], >>> 'threshold': 10 >>> } >>> ]) == [\\"YES\\", \\"NO\\"] >>> check_toxicity([ >>> { >>> 'main_string': 'abcdefgh', >>> 'subsequences': [], >>> 'threshold': 1 >>> } >>> ]) == [\\"NO\\"] >>> check_toxicity([ >>> { >>> 'main_string': 'aaabbbcccc', >>> 'subsequences': [('aa', 3), ('bb', 4)], >>> 'threshold': 50 >>> } >>> ]) == [\\"NO\\"] >>> check_toxicity([ >>> { >>> 'main_string': 'aaabbbcc', >>> 'subsequences': [('aa', 3), ('bb', 4), ('cc', 2)], >>> 'threshold': 1 >>> } >>> ]) == [\\"YES\\"]","solution":"def check_toxicity(test_cases): results = [] for test_case in test_cases: main_string = test_case['main_string'] toxic_subsequences = test_case['subsequences'] threshold = test_case['threshold'] total_toxicity = 0 for subsequence, toxicity in toxic_subsequences: # Count occurrences of the toxic subsequence in the main string count = main_string.count(subsequence) total_toxicity += count * toxicity if total_toxicity > threshold: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_increasing_subsequence(N: int, array: List[int]) -> Tuple[int, List[int]]: Returns the length and the elements of the longest increasing subsequence in the given array. Args: N : int : length of the array array : list of int : input array Returns: length : int : length of the longest increasing subsequence subseq : list of int : the longest increasing subsequence pass # Unit Test from solution import longest_increasing_subsequence def test_sample_input_1(): N = 6 array = [5, 2, 8, 6, 3, 6] length, subseq = longest_increasing_subsequence(N, array) assert length == 3 assert subseq == [2, 3, 6] or subseq == [2, 6, 8] def test_sample_input_2(): N = 5 array = [1, 3, 2, 4, 5] length, subseq = longest_increasing_subsequence(N, array) assert length == 4 assert subseq == [1, 2, 4, 5] or subseq == [1, 3, 4, 5] def test_sample_input_3(): N = 5 array = [9, 8, 7, 6, 5] length, subseq = longest_increasing_subsequence(N, array) assert length == 1 assert subseq == [9] or subseq == [8] or subseq == [7] or subseq == [6] or subseq == [5] def test_single_element_array(): N = 1 array = [42] length, subseq = longest_increasing_subsequence(N, array) assert length == 1 assert subseq == [42] def test_empty_array(): N = 0 array = [] length, subseq = longest_increasing_subsequence(N, array) assert length == 0 assert subseq == []","solution":"def longest_increasing_subsequence(N, array): Returns the length and the elements of the longest increasing subsequence in the given array. Args: N : int : length of the array array : list of int : input array Returns: length : int : length of the longest increasing subsequence subseq : list of int : the longest increasing subsequence if N == 0: return 0, [] dp = [1] * N parent = [-1] * N for i in range(1, N): for j in range(0, i): if array[i] > array[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 parent[i] = j length = max(dp) index = dp.index(length) subseq = [] while index != -1: subseq.append(array[index]) index = parent[index] subseq.reverse() return length, subseq"},{"question":"def longest_increasing_sales_sequence(sales): Returns the start position, end position, and length of the longest sequence of consecutive days with increasing sales. >>> longest_increasing_sales_sequence([3, 4, 5, 1, 2, 3, 4, 1, 2]) == (4, 7, 4) >>> longest_increasing_sales_sequence([1, 2, 3, 4, 5]) == (1, 5, 5) >>> longest_increasing_sales_sequence([5, 4, 3, 2, 1]) == (1, 1, 1) >>> longest_increasing_sales_sequence([1, 2, 1, 2, 1, 2]) == (1, 2, 2) >>> longest_increasing_sales_sequence([1]) == (1, 1, 1) >>> longest_increasing_sales_sequence([]) == (0, 0, 0) >>> longest_increasing_sales_sequence([10, 1, 2, 3, 4]) == (2, 5, 4)","solution":"def longest_increasing_sales_sequence(sales): Returns the start position, end position, and length of the longest sequence of consecutive days with increasing sales. if not sales: return (0, 0, 0) max_len = 1 current_len = 1 start_pos = 1 max_start_pos = 1 for i in range(1, len(sales)): if sales[i] > sales[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_pos = start_pos current_len = 1 start_pos = i + 1 if current_len > max_len: max_len = current_len max_start_pos = start_pos return (max_start_pos, max_start_pos + max_len - 1, max_len)"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Given two strings, determine the length of their longest common subsequence. The longest common subsequence is defined as the longest sequence that can be derived from both strings by removing some characters (without reordering the remaining characters). Args: s1 (str): First string s2 (str): Second string Returns: int: Length of the longest common subsequence Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"a\\") 1 >>> longest_common_subsequence(\\"abcde\\", \\"bdf\\") 2","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence between two given strings. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the string s. >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abcd\\") 4 pass def process_palindromic_substrings(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns a list of counts of distinct palindromic substrings. >>> process_palindromic_substrings([\\"ababa\\", \\"abcd\\", \\"aaa\\"]) [5, 4, 3] >>> process_palindromic_substrings([\\"a\\", \\"b\\", \\"c\\"]) [1, 1, 1] >>> process_palindromic_substrings([\\"ababa\\", \\"a\\", \\"bb\\", \\"xyyx\\"]) [5, 1, 2, 4] pass","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the string s. n = len(s) # Set to store unique palindromic substrings palindromes = set() # Function to add palindromes from the given start and end indices def add_palindromes(left, right): while left >= 0 and right < n and s[left] == s[right]: palindromes.add(s[left:right + 1]) left -= 1 right += 1 # Find all palindromic substrings for i in range(n): # Add all odd length palindromes (single center) add_palindromes(i, i) # Add all even length palindromes (double center) add_palindromes(i, i + 1) return len(palindromes) def process_palindromic_substrings(test_cases): Processes multiple test cases and returns a list of counts of distinct palindromic substrings. results = [] for s in test_cases: results.append(count_distinct_palindromic_substrings(s)) return results"},{"question":"def num_subarrays_with_product_less_than_target(nums, target): Returns the number of non-empty subarrays such that the product of their elements is less than the target. >>> num_subarrays_with_product_less_than_target([10, 5, 2, 6], 100) 8 >>> num_subarrays_with_product_less_than_target([1, 2, 3], 0) 0 from typing import List def num_subarrays_with_product_less_than_target(nums: List[int], target: int) -> int: pass","solution":"def num_subarrays_with_product_less_than_target(nums, target): Returns the number of non-empty subarrays such that the product of their elements is less than the target. if target <= 1: return 0 product = 1 count = 0 left = 0 for right in range(len(nums)): product *= nums[right] while product >= target: product //= nums[left] left += 1 count += right - left + 1 return count"},{"question":"def min_cost_to_sort_candies(N: int, candies: List[int]) -> int: Returns the minimum cost to sort the candies using the given operations. Parameters: N (int): The number of candies. candies (List[int]): A list of integers representing the labels of the candies. Returns: int: The minimum cost required to sort the candies. Examples: >>> min_cost_to_sort_candies(5, [4, 3, 5, 1, 2]) 3 >>> min_cost_to_sort_candies(3, [1, 2, 3]) 0 >>> min_cost_to_sort_candies(2, [2, 1]) 1 >>> min_cost_to_sort_candies(4, [4, 3, 2, 1]) 2 >>> min_cost_to_sort_candies(3, [3, 1, 2]) 2 pass","solution":"def min_cost_to_sort_candies(N, candies): Returns the minimum cost to sort the candies using the given operations. def dfs(arr, cost, visited): Depth-First Search to explore possible states and maintain the minimum cost. if tuple(arr) in visited and visited[tuple(arr)] <= cost: return float('inf') visited[tuple(arr)] = cost if arr == sorted(arr): return cost min_cost = float('inf') for i in range(N): for j in range(i + 1, N): # Perform a swap operation arr[i], arr[j] = arr[j], arr[i] min_cost = min(min_cost, dfs(arr, cost + 1, visited)) arr[i], arr[j] = arr[j], arr[i] # revert the swap # Perform a reverse operation arr[i:j+1] = arr[i:j+1][::-1] min_cost = min(min_cost, dfs(arr, cost + 2, visited)) arr[i:j+1] = arr[i:j+1][::-1] # revert the reverse return min_cost initial_arr = list(candies) visited = {} return dfs(initial_arr, 0, visited) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) candies = list(map(int, data[1:])) print(min_cost_to_sort_candies(N, candies))"},{"question":"def find_unique_numbers(n: int, lst: List[int]) -> Union[int, Tuple[int, int]]: Function to find the unique number or numbers in the given list of integers. Each integer appears twice except for one or two numbers that appear only once. Parameters: n (int): The number of integers in the list. lst (list of int): The list of integers. Returns: int, or tuple of two ints: If one unique number is found, return it. If two unique numbers are found, return them as a tuple in increasing order. Examples: >>> find_unique_numbers(7, [2, 3, 2, 4, 4, 5, 3]) 5 >>> find_unique_numbers(8, [1, 2, 3, 4, 2, 1, 5, 3]) (4, 5)","solution":"def find_unique_numbers(n, lst): Function to find the unique number or numbers in the given list. Parameters: n (int): The number of integers in the list. lst (list of int): The list of integers. Returns: int, or tuple of int: Returns the unique number or numbers in the list. from collections import Counter count = Counter(lst) unique_numbers = [number for number, freq in count.items() if freq == 1] if len(unique_numbers) == 1: return unique_numbers[0] elif len(unique_numbers) == 2: return tuple(sorted(unique_numbers)) else: raise ValueError(\\"The input list does not comply with the problem constraints.\\")"},{"question":"from typing import List, Tuple def find_largest_group_size(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determines the size of the largest group of friends in a social network. >>> find_largest_group_size(5, 3, [(1, 2), (2, 3), (4, 5)]) 3 >>> find_largest_group_size(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 6)]) 6","solution":"def find_largest_group_size(n, m, connections): from collections import defaultdict, deque def bfs(node, visited, adjacency_list): queue = deque([node]) visited[node] = True size = 1 while queue: current = queue.popleft() for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) size += 1 return size adjacency_list = defaultdict(list) for u, v in connections: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) max_group_size = 0 for i in range(1, n + 1): if not visited[i]: group_size = bfs(i, visited, adjacency_list) max_group_size = max(max_group_size, group_size) return max_group_size"},{"question":"from typing import List, Tuple def minimize_difference(scores: List[int]) -> int: Minimize the difference in sum of two teams. >>> minimize_difference([1, 6, 11, 5]) 1 >>> minimize_difference([1, 2, 3, 4, 5, 6]) 1 def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solve the problem for given test cases. >>> solve([(4, [1, 6, 11, 5]), (6, [1, 2, 3, 4, 5, 6])]) [1, 1]","solution":"from itertools import combinations def minimize_difference(scores): total_sum = sum(scores) scores.sort() n = len(scores) half = n // 2 min_diff = float('inf') # Generate all possible combinations of half of the students for teamA in combinations(scores, half): teamA_sum = sum(teamA) teamB_sum = total_sum - teamA_sum diff = abs(teamA_sum - teamB_sum) min_diff = min(min_diff, diff) return min_diff def solve(test_cases): results = [] for test in test_cases: N, scores = test results.append(minimize_difference(scores)) return results"},{"question":"def max_sum(cards: List[int]) -> int: Returns the maximum sum Nathan can achieve if he plays first and everyone plays optimally. Parameters: cards (List[int]): List of integers representing the numbers on the cards. Returns: int: The maximum sum Nathan can achieve. >>> max_sum([1, 2, 9, 4]) 10 >>> max_sum([10]) 10 >>> max_sum([10, 20]) 20 >>> max_sum([1, 2, 3, 4]) 6 >>> max_sum([10, 1, 10, 1]) 20 >>> max_sum([1000000, 1000000, 1000000, 1000000]) 2000000 pass def test_example_case(): assert max_sum([1, 2, 9, 4]) == 10 def test_single_card(): assert max_sum([10]) == 10 def test_two_cards(): assert max_sum([10, 20]) == 20 assert max_sum([20, 10]) == 20 def test_increasing_cards(): assert max_sum([1, 2, 3, 4]) == 6 def test_alternating_cards(): assert max_sum([10, 1, 10, 1]) == 20 def test_large_numbers(): assert max_sum([1000000, 1000000, 1000000, 1000000]) == 2000000","solution":"def max_sum(cards): Returns the maximum sum Nathan can achieve if he plays first and everyone plays optimally. N = len(cards) # dp[i][j] will be the maximum sum Nathan can get if it's his turn to play with the cards in range [i, j] dp = [[0]*N for _ in range(N)] for gap in range(N): for i in range(N - gap): j = i + gap if i == j: dp[i][j] = cards[i] else: # Two choices for Nathan: pick leftmost (cards[i]) or rightmost (cards[j]) # dp[i+1][j] is the outcome if Nathan picks cards[i] # dp[i][j-1] is the outcome if Nathan picks cards[j] pick_i = cards[i] + min(dp[i+2][j] if i+2 <= j else 0, dp[i+1][j-1] if i+1 <= j-1 else 0) pick_j = cards[j] + min(dp[i+1][j-1] if i+1 <= j-1 else 0, dp[i][j-2] if i <= j-2 else 0) dp[i][j] = max(pick_i, pick_j) return dp[0][N-1]"},{"question":"from typing import List, Tuple def longest_increasing_subsequence(n: int, scores: List[int]) -> Tuple[int, List[int]]: Find the longest contiguous subsequence of increasing scores in the given list of scores. Input: - n: An integer representing the number of recorded scores. - scores: A list of n integers representing the scores. Output: - A tuple containing: - An integer representing the length of the longest contiguous subsequence of increasing scores. - A list of integers representing the 1-based indices of the subsequence. Examples: >>> longest_increasing_subsequence(6, [10, 20, 10, 30, 40, 50]) (4, [3, 4, 5, 6]) >>> longest_increasing_subsequence(5, [5, 4, 3, 2, 1]) (1, [1])","solution":"def longest_increasing_subsequence(n, scores): if n == 0: return 0, [] longest_length = 1 current_length = 1 start_idx = 0 end_idx = 0 current_start = 0 for i in range(1, n): if scores[i] > scores[i - 1]: current_length += 1 else: if current_length > longest_length: longest_length = current_length start_idx = current_start end_idx = i - 1 current_start = i current_length = 1 if current_length > longest_length: longest_length = current_length start_idx = current_start end_idx = n - 1 indices = list(range(start_idx + 1, end_idx + 2)) return longest_length, indices # Example usage: n = 6 scores = [10, 20, 10, 30, 40, 50] print(longest_increasing_subsequence(n, scores))"},{"question":"def library_management(n, operations): Simulates the borrowing and returning of books in a library. :param n: int, the number of operations :param operations: list of str, each containing an operation (\\"borrow BookID MemberID\\" or \\"return BookID MemberID\\") :return: list of str, results of each operation >>> library_management(6, [\\"borrow Book1 Member1\\", \\"borrow Book2 Member2\\", \\"borrow Book1 Member3\\", \\"return Book1 Member2\\", \\"borrow Book1 Member1\\", \\"return Book1 Member1\\"]) ['Success', 'Success', 'Already borrowed', 'Wrong member', 'Success', 'Success'] >>> library_management(2, [\\"borrow Book1 Member1\\", \\"borrow Book1 Member2\\"]) ['Success', 'Already borrowed'] >>> library_management(6, [\\"borrow Book1 Member1\\", \\"borrow Book2 Member1\\", \\"borrow Book3 Member1\\", \\"borrow Book4 Member1\\", \\"borrow Book5 Member1\\", \\"borrow Book6 Member1\\"]) ['Success', 'Success', 'Success', 'Success', 'Success', 'Limit reached']","solution":"def library_management(n, operations): Simulates the borrowing and returning of books in a library. :param n: int, the number of operations :param operations: list of str, each containing an operation (\\"borrow BookID MemberID\\" or \\"return BookID MemberID\\") :return: list of str, results of each operation borrowed_books = {} member_books_count = {} results = [] for operation in operations: operation_parts = operation.split() action = operation_parts[0] book_id = operation_parts[1] member_id = operation_parts[2] if action == \\"borrow\\": if book_id in borrowed_books: results.append(\\"Already borrowed\\") elif member_books_count.get(member_id, 0) >= 5: results.append(\\"Limit reached\\") else: borrowed_books[book_id] = member_id member_books_count[member_id] = member_books_count.get(member_id, 0) + 1 results.append(\\"Success\\") elif action == \\"return\\": if book_id not in borrowed_books: results.append(\\"Not borrowed\\") elif borrowed_books[book_id] != member_id: results.append(\\"Wrong member\\") else: member_books_count[member_id] -= 1 del borrowed_books[book_id] results.append(\\"Success\\") return results"},{"question":"def longest_common_suffix(strings: List[str]) -> str: Find the longest common suffix among a list of strings. >>> longest_common_suffix([\\"sprining\\", \\"spreading\\", \\"bringing\\"]) \\"ing\\" >>> longest_common_suffix([\\"apple\\", \\"banana\\", \\"orange\\"]) \\"\\" >>> longest_common_suffix([\\"cat\\", \\"bat\\", \\"rat\\"]) \\"at\\" >>> longest_common_suffix([\\"dog\\", \\"dog\\", \\"dog\\"]) \\"dog\\" >>> longest_common_suffix([\\"elephant\\"]) \\"elephant\\" >>> longest_common_suffix([]) \\"\\" >>> longest_common_suffix([\\"a\\", \\"b\\", \\"c\\"]) \\"\\" >>> longest_common_suffix([\\"interview\\", \\"view\\", \\"overview\\"]) \\"view\\" >>> longest_common_suffix([\\"biking\\", \\"king\\", \\"sing\\"]) \\"ing\\"","solution":"def longest_common_suffix(strings): if not strings: return \\"\\" reversed_strings = [s[::-1] for s in strings] min_length = min(len(s) for s in reversed_strings) common_suffix_reversed = [] for i in range(min_length): current_char = reversed_strings[0][i] if all(s[i] == current_char for s in reversed_strings): common_suffix_reversed.append(current_char) else: break common_suffix_reversed = ''.join(common_suffix_reversed) return common_suffix_reversed[::-1]"},{"question":"def fibonacci_primes(n): '''Return a list of the first n prime Fibonacci numbers >>> fibonacci_primes(0) [] >>> fibonacci_primes(-5) [] >>> fibonacci_primes(1) [2] >>> fibonacci_primes(2) [2, 3] >>> fibonacci_primes(3) [2, 3, 5] >>> fibonacci_primes(4) [2, 3, 5, 13] >>> fibonacci_primes(5) [2, 3, 5, 13, 89] >>> fibonacci_primes(10) [2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437] '''","solution":"def fibonacci_primes(n): Return a list of the first n prime Fibonacci numbers. if n <= 0: return [] def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True fib_primes = [] a, b = 0, 1 while len(fib_primes) < n: if is_prime(b): fib_primes.append(b) a, b = b, a + b return fib_primes"},{"question":"def validate_shelves(input_data: List[str]) -> List[str]: Validate whether a given arrangement of products on shelves is valid. Each test case consists of: - Two integers, \`m\` and \`n\`, representing the dimensions of the grid (number of rows and columns, respectively). - An \`m x n\` matrix of integers, where each integer represents the maximum weight capacity of the corresponding shelf. - An \`m x n\` matrix of integers, where each integer represents the weight of products placed on the corresponding shelf. The input is read until a test case where both \`m\` and \`n\` are zero, which is the termination signal and should not be processed. The function returns a list of strings, \\"VALID\\" if the weight arrangement is valid and \\"INVALID\\" otherwise, for each test case. >>> validate_shelves([ \\"2 3\\", \\"5 10 7\\", \\"8 6 5\\", \\"4 6 7\\", \\"3 3 3\\", \\"0 0\\" ]) [\\"VALID\\"] >>> validate_shelves([ \\"2 3\\", \\"5 10 7\\", \\"8 6 5\\", \\"4 6 7\\", \\"3 11 3\\", \\"0 0\\" ]) [\\"INVALID\\"]","solution":"def validate_shelves(input_data): result = [] index = 0 while True: # Parse dimensions and matrices m, n = map(int, input_data[index].strip().split()) if m == 0 and n == 0: break index += 1 capacity_matrix = [] for _ in range(m): capacity_matrix.append(list(map(int, input_data[index].strip().split()))) index += 1 weight_matrix = [] for _ in range(m): weight_matrix.append(list(map(int, input_data[index].strip().split()))) index += 1 # Validate the arrangement valid = True for i in range(m): for j in range(n): if weight_matrix[i][j] > capacity_matrix[i][j]: valid = False break if not valid: break result.append(\\"VALID\\" if valid else \\"INVALID\\") return result"},{"question":"def min_path_cost(grid: List[List[int]]) -> int: Calculate the minimum cost to travel from the top-left corner to the bottom-right corner of a grid. >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_cost([ ... [1, 2, 3, 4] ... ]) == 10 >>> min_path_cost([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10","solution":"def min_path_cost(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array dp = [[0] * m for _ in range(n)] # Initialize the top-left cell with the grid value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def largest_prime_factor(n: int) -> int: Compute the largest prime factor of a given number. >>> largest_prime_factor(10) 5 >>> largest_prime_factor(15) 5 >>> largest_prime_factor(21) 7 import pytest def test_largest_prime_factor_sample(): assert largest_prime_factor(10) == 5 assert largest_prime_factor(15) == 5 assert largest_prime_factor(21) == 7 def test_largest_prime_factor_edge_cases(): assert largest_prime_factor(2) == 2 assert largest_prime_factor(3) == 3 assert largest_prime_factor(5) == 5 assert largest_prime_factor(8) == 2 assert largest_prime_factor(27) == 3 assert largest_prime_factor(49) == 7 def test_largest_prime_factor_large_numbers(): assert largest_prime_factor(1000000000) == 5 assert largest_prime_factor(67280421310721) == 67280421310721 def test_largest_prime_factor_mixed_factors(): assert largest_prime_factor(100) == 5 assert largest_prime_factor(13195) == 29 pytest.main()","solution":"def largest_prime_factor(n): Returns the largest prime factor of the given number n. def max_prime_factor(number): # Initialize the maximum prime factor variable with the lowest prime number max_prime = -1 # Divide number by 2 until it becomes odd while number % 2 == 0: max_prime = 2 number //= 2 # number must be odd at this point, thus skip even numbers (increment by 2) for i in range(3, int(number**0.5) + 1, 2): while number % i == 0: max_prime = i number //= i # This condition is to handle the case when number is a prime number # greater than 2 if number > 2: max_prime = number return max_prime return max_prime_factor(n)"},{"question":"def hasHamiltonianCycle(N: int, M: int, graph: List[List[int]]) -> bool: Determine if the graph contains a Hamiltonian cycle. :param N: Number of vertices :param M: Number of edges :param graph: List of pairs representing the edges of the graph :return: True if there is a Hamiltonian cycle, False otherwise >>> hasHamiltonianCycle(4, 6, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]) True >>> hasHamiltonianCycle(5, 5, [[0, 1], [0, 2], [1, 3], [1, 4], [3, 4]]) False","solution":"def hasHamiltonianCycle(N, M, graph): Determines if the graph contains a Hamiltonian cycle. :param N: Number of vertices :param M: Number of edges :param graph: List of pairs representing the edges of the graph :return: True if there is a Hamiltonian cycle, False otherwise from collections import defaultdict def isHamCycle(v, visited, path): if len(path) == N: return path[0] in adj[path[-1]] for neighbor in adj[v]: if neighbor not in visited: visited.add(neighbor) path.append(neighbor) if isHamCycle(neighbor, visited, path): return True visited.remove(neighbor) path.pop() return False if M < N: return False adj = defaultdict(set) for u, v in graph: adj[u].add(v) adj[v].add(u) for start in range(N): visited = {start} path = [start] if isHamCycle(start, visited, path): return True return False"},{"question":"def min_moves_to_make_beautiful(s: str) -> int: Given a binary string s, this function calculates the minimum number of moves required to make the string beautiful by changing all occurrences of \\"010\\" to \\"101\\" and vice versa. >>> min_moves_to_make_beautiful(\\"0101010\\") 2 >>> min_moves_to_make_beautiful(\\"1101001\\") 1","solution":"def min_moves_to_make_beautiful(s): Given a binary string s, this function calculates the minimum number of moves required to make the string beautiful by changing all occurrences of \\"010\\" to \\"101\\" and vice versa. # Count occurrences of \\"010\\" in the string count_010 = s.count(\\"010\\") # Each \\"010\\" can be changed to \\"101\\" in one move return count_010"},{"question":"def balance_parentheses(s: str) -> bool: Returns whether the parentheses in the input string are balanced. :param s: input string consisting of '(' and ')' :return: boolean indicating whether the parentheses are balanced >>> balance_parentheses(\\"\\") True >>> balance_parentheses(\\"()\\") True >>> balance_parentheses(\\")(\\") False >>> balance_parentheses(\\"(()\\") False >>> balance_parentheses(\\"(())\\") True >>> balance_parentheses(\\"(\\") False >>> balance_parentheses(\\")\\") False >>> balance_parentheses(\\"()()\\") True >>> balance_parentheses(\\"(()(()))\\") True >>> balance_parentheses(\\"(()()))(\\") False","solution":"def balance_parentheses(s): Returns whether the parentheses in the input string are balanced. :param s: input string consisting of '(' and ')' :return: boolean indicating whether the parentheses are balanced stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def CommonElements(arr1, arr2): Write a function that takes two arrays of integers and returns a new array consisting of the integers that appear in both given arrays. The integers in the resulting array should be unique and sorted in ascending order. >>> CommonElements([1, 2, 2, 3], [2, 3, 4, 5]) [2, 3] >>> CommonElements([7, 8, 9], [10, 11, 7]) [7] >>> CommonElements([1, 1, 1, 1], [1, 1, 1, 1]) [1]","solution":"def CommonElements(arr1, arr2): Returns a sorted array of unique integers that appear in both input arrays. result = list(set(arr1).intersection(arr2)) result.sort() return result"},{"question":"def minimum_travel_time(n: int, m: int, paths: List[Tuple[int, int, int]], s: int, d: int) -> int: Calculate the minimum travel time for a traveler to reach a specific destination from a given start point in a network of teleportation points. Args: n : int : Number of teleportation points m : int : Number of one-way paths paths : List[Tuple[int, int, int]] : List of tuples representing paths (u, v, t) where u -> v with travel time t s : int : Starting teleportation point d : int : Destination teleportation point Returns: int: Minimum travel time to reach destination point d from start point s. If not possible, return -1. Example: >>> minimum_travel_time(5, 6, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 1), (4, 5, 6), (3, 5, 8)], 1, 5) 9 >>> minimum_travel_time(3, 2, [(1, 2, 4), (2, 3, 5)], 3, 1) -1","solution":"import heapq def minimum_travel_time(n, m, paths, s, d): # Create the graph graph = [[] for _ in range(n + 1)] for u, v, t in paths: graph[u].append((v, t)) # Dijkstra's algorithm to find the shortest path def dijkstra(start, end): min_time = [float('inf')] * (n + 1) min_time[start] = 0 priority_queue = [(0, start)] while priority_queue: current_time, u = heapq.heappop(priority_queue) if current_time > min_time[u]: continue for v, travel_time in graph[u]: time = current_time + travel_time if time < min_time[v]: min_time[v] = time heapq.heappush(priority_queue, (time, v)) return min_time[end] result = dijkstra(s, d) return result if result != float('inf') else -1"},{"question":"def final_character_count(n: int, changes: List[Tuple[str, str, int]]) -> int: Determines the final count of characters in the text file. Args: n (int): The number of changes made during the day. changes (list of tuples): Each tuple contains a timestamp (str), a change type (str: 'add' or 'delete'), and the number of characters (int). Returns: int: The total number of characters in the text file at the end of the day, capped at 0. >>> changes = [ ... (\\"08:15:30\\", \\"add\\", 10), ... (\\"08:20:45\\", \\"delete\\", 5), ... (\\"09:10:22\\", \\"add\\", 5), ... (\\"10:00:00\\", \\"delete\\", 20), ... (\\"11:45:00\\", \\"add\\", 30), ... ] >>> final_character_count(5, changes) 0 >>> changes = [ ... (\\"08:00:00\\", \\"add\\", 15), ... (\\"09:00:00\\", \\"add\\", 10), ... (\\"10:00:00\\", \\"add\\", 25), ... (\\"11:00:00\\", \\"delete\\", 10), ... (\\"12:00:00\\", \\"add\\", 10), ... ] >>> final_character_count(5, changes) 50 >>> changes = [ ... (\\"08:00:00\\", \\"add\\", 5), ... (\\"09:00:00\\", \\"delete\\", 6), ... (\\"10:00:00\\", \\"add\\", 25), ... ] >>> final_character_count(3, changes) 0 >>> changes = [ ... (\\"08:00:00\\", \\"add\\", 1), ... (\\"08:00:01\\", \\"delete\\", 1), ... (\\"08:00:02\\", \\"delete\\", 1), ... ] >>> final_character_count(3, changes) 0 >>> changes = [ ... (\\"08:00:00\\", \\"add\\", 50), ... (\\"09:00:00\\", \\"delete\\", 50), ... ] >>> final_character_count(2, changes) 0 >>> changes = [ ... (\\"08:00:00\\", \\"add\\", 10), ... (\\"09:00:00\\", \\"add\\", 5), ... (\\"10:00:00\\", \\"add\\", 20), ... ] >>> final_character_count(3, changes) 35","solution":"def final_character_count(n, changes): Determines the final count of characters in the text file. Args: n (int): The number of changes made during the day. changes (list of tuples): Each tuple contains a timestamp (str), a change type (str: 'add' or 'delete'), and the number of characters (int). Returns: int: The total number of characters in the text file at the end of the day, capped at 0. total_characters = 0 for timestamp, change_type, k in changes: if change_type == 'add': total_characters += k elif change_type == 'delete': total_characters -= k if total_characters <= 0: return 0 return total_characters"},{"question":"def is_magic_square(grid): Determine whether the given grid is a magic square. :param grid: List of lists representing the grid :return: \\"YES\\" if the grid is a magic square, otherwise \\"NO\\" >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) == \\"YES\\" >>> is_magic_square([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == \\"NO\\" >>> is_magic_square([ ... [8, 1, 6], ... [3, 5, 7], ... [4, 9, 2] ... ]) == \\"YES\\" >>> is_magic_square([ ... [8, 1, 6], ... [3, 7, 5], ... [4, 9, 2] ... ]) == \\"NO\\" >>> is_magic_square([ ... [1] ... ]) == \\"YES\\" >>> is_magic_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == \\"YES\\" >>> is_magic_square([]) == \\"NO\\"","solution":"def is_magic_square(grid): Determine whether the given grid is a magic square. :param grid: List of lists representing the grid :return: \\"YES\\" if the grid is a magic square, otherwise \\"NO\\" n = len(grid) if n == 0: return \\"NO\\" # Calculate the target sum from the first row target_sum = sum(grid[0]) # Check sums of all rows for row in grid: if sum(row) != target_sum: return \\"NO\\" # Check sums of all columns for col in range(n): if sum(grid[row][col] for row in range(n)) != target_sum: return \\"NO\\" # Check sum of the main diagonal if sum(grid[i][i] for i in range(n)) != target_sum: return \\"NO\\" # Check sum of the secondary diagonal if sum(grid[i][n - 1 - i] for i in range(n)) != target_sum: return \\"NO\\" return \\"YES\\""},{"question":"def longest_substring_k_distinct(s: str, k: int) -> int: Finds the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The maximum number of distinct characters. Returns: int: The length of the longest substring with at most k distinct characters. Examples: >>> longest_substring_k_distinct(\\"abcbae\\", 2) 3 >>> longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> longest_substring_k_distinct(\\"abacd\\", 3) 4 pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[int]: Processes multiple test cases for finding the length of the longest substring with at most k distinct characters. Parameters: test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string and an integer k. Returns: List[int]: A list of integers where each integer is the result of the longest substring length for the corresponding test case. Examples: >>> process_test_cases([(\\"abcbae\\", 2), (\\"aaaa\\", 1), (\\"abacd\\", 3)]) [3, 4, 4] pass","solution":"def longest_substring_k_distinct(s, k): Finds the length of the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The maximum number of distinct characters. Returns: int: The length of the longest substring with at most k distinct characters. if k == 0: return 0 n = len(s) left = 0 max_len = 0 char_count = {} for right in range(n): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) return max_len def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(longest_substring_k_distinct(s, int(k))) return results"},{"question":"def find_pair(arr, x): Returns indices of a pair of elements in arr that sum up to x. If no such pair exists, returns an empty list. # Add your code here def solve(test_cases): Processes multiple test cases to find pairs of elements summing to target values. # Add your code here # Unit tests def test_find_pair(): assert find_pair([2, 7, 11, 15], 9) == [0, 1] assert find_pair([3, 2, 4], 6) == [1, 2] assert find_pair([3, 7, 1], 10) == [0, 1] assert find_pair([1, 2, 3], 5) == [1, 2] assert find_pair([1, 2, 3], 7) == [] assert find_pair([5, 5, 5], 10) == [0, 1] def test_solve(): test_cases = [ (4, 9, [2, 7, 11, 15]), (3, 6, [3, 2, 4]), (3, 10, [3, 7, 1]) ] expected = [\\"0 1\\", \\"1 2\\", \\"0 1\\"] assert solve(test_cases) == expected test_cases = [ (3, 5, [1, 2, 3]), (3, 7, [1, 2, 3]), (3, 10, [5, 5, 5]) ] expected = [\\"1 2\\", \\"\\", \\"0 1\\"] assert solve(test_cases) == expected","solution":"def find_pair(arr, x): Returns indices of a pair of elements in arr that sum up to x. If no such pair exists, returns an empty list. num_indices = {} for i, num in enumerate(arr): complement = x - num if complement in num_indices: return [num_indices[complement], i] num_indices[num] = i return [] def solve(test_cases): Processes multiple test cases to find pairs of elements summing to target values. results = [] for n, x, arr in test_cases: pair = find_pair(arr, x) if pair: results.append(f\\"{pair[0]} {pair[1]}\\") else: results.append(\\"\\") return results"},{"question":"def min_operations_to_balance(M: int, N: int) -> int: Find the minimum number of operations needed to achieve a balanced distribution of candies. A company wants to distribute M candies among N employees such that the distribution is balanced. A balanced distribution occurs when the absolute difference between the maximum and minimum candies given to any employee does not exceed 1. The company can perform the following operations: - Add one candy. - Remove one candy. - Add one employee. - Remove one employee (if the number of employees is greater than 1). Args: M (int): The number of candies. N (int): The number of employees. Returns: int: The minimum number of operations needed to balance the candies distribution. Examples: >>> min_operations_to_balance(52, 10) 2 >>> min_operations_to_balance(49, 7) 0","solution":"def min_operations_to_balance(M, N): if M < N: # If candies are less than employees, all employees can't get at least one candy. return N - M # M >= N scenario r = M % N return min(r, N - r)"},{"question":"def can_make_elements_equal(arr): Determine if all elements of the array can be made equal by replacing any two numbers with their average (which must be an integer). >>> can_make_elements_equal([1, 3, 2, 4]) 'NO' >>> can_make_elements_equal([6, 10]) 'YES' >>> can_make_elements_equal([5, 5, 5]) 'YES'","solution":"def can_make_elements_equal(arr): Determine if all elements of the array can be made equal by replacing any two numbers with their average (which must be an integer). # All elements must have the same remainder when divided by 2 for num in arr: if num % 2 != arr[0] % 2: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for case in test_cases: result = can_make_elements_equal(case) results.append(result) return results def main(T, test_cases): results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def find_subarray(t, test_cases): You are given an array of n positive integers, where each integer represents the amount of money in a bag. You have to pick consecutive bags in such a way that the sum of the money in those bags is exactly equal to a given value k. If there are multiple such subarrays, you should pick the one with the smallest starting index. If no such subarray exists, output -1. >>> find_subarray(3, [(5, 12, [1, 2, 3, 7, 5]), (5, 15, [1, 2, 3, 4, 5]), (10, 55, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) [(2, 4), (1, 5), (1, 10)] >>> find_subarray(1, [(5, 100, [1, 2, 3, 4, 5])]) [-1]","solution":"def find_subarray(t, test_cases): results = [] for case in test_cases: n, k, array = case current_sum = 0 start = 0 found = False for end in range(n): current_sum += array[end] # Shrink the window as long as the current_sum exceeds k while current_sum > k and start <= end: current_sum -= array[start] start += 1 if current_sum == k: results.append((start + 1, end + 1)) found = True break if not found: results.append(-1) return results def process_input_output(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) k = int(data[index + 1]) array = list(map(int, data[index + 2:index + 2 + n])) test_cases.append((n, k, array)) index += 2 + n results = find_subarray(t, test_cases) for result in results: if result == -1: print(result) else: print(result[0], result[1])"},{"question":"def can_transfer_file(n, m, connections, s, d): Determines if there is a path from the source computer to the destination computer in a network represented as a directed graph. Parameters: n (int): Number of computers. m (int): Number of direct connections. connections (list of tuples): Each tuple contains two integers u and v representing a directed connection from computer u to computer v. s (int): Source computer. d (int): Destination computer. Returns: str: \\"YES\\" if there is a path from the source computer to the destination computer, otherwise \\"NO\\". Examples: >>> can_transfer_file(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)], 1, 4) \\"YES\\" >>> can_transfer_file(3, 2, [(1, 2), (2, 3)], 3, 1) \\"NO\\" from solution import can_transfer_file def test_example_1(): n = 4 m = 4 connections = [(1, 2), (2, 3), (3, 4), (4, 2)] s = 1 d = 4 assert can_transfer_file(n, m, connections, s, d) == \\"YES\\" def test_example_2(): n = 3 m = 2 connections = [(1, 2), (2, 3)] s = 3 d = 1 assert can_transfer_file(n, m, connections, s, d) == \\"NO\\" def test_no_connection(): n = 5 m = 3 connections = [(1, 2), (2, 3), (4, 5)] s = 1 d = 5 assert can_transfer_file(n, m, connections, s, d) == \\"NO\\" def test_direct_connection(): n = 5 m = 5 connections = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] s = 1 d = 5 assert can_transfer_file(n, m, connections, s, d) == \\"YES\\" def test_same_source_destination(): n = 3 m = 3 connections = [(1, 2), (2, 3), (3, 1)] s = 1 d = 1 assert can_transfer_file(n, m, connections, s, d) == \\"YES\\" def test_multiple_paths(): n = 6 m = 7 connections = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (4, 6), (5, 6)] s = 1 d = 6 assert can_transfer_file(n, m, connections, s, d) == \\"YES\\"","solution":"def can_transfer_file(n, m, connections, s, d): from collections import deque, defaultdict # Create a graph from the connections using adjacency list representation graph = defaultdict(list) for u, v in connections: graph[u].append(v) # Use BFS to check if there is a path from source (s) to destination (d) queue = deque([s]) visited = set() while queue: current = queue.popleft() if current == d: return \\"YES\\" if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return \\"NO\\""},{"question":"def findIntersection(arr1, arr2, n, m): Finds the intersection of two sorted arrays. Args: arr1 (List[int]): The first sorted array. arr2 (List[int]): The second sorted array. n (int): The size of the first array. m (int): The size of the second array. Returns: List[int]: A list containing the intersection of the two arrays. Example: >>> findIntersection([1, 2, 3, 4, 5], [1, 2, 3], 5, 3) [1, 2, 3] >>> findIntersection([2, 2, 3, 4, 5], [1, 1, 2, 3, 4], 5, 5) [2, 3, 4] >>> findIntersection([1, 1, 1, 1, 1], [2, 2, 2, 2, 2], 5, 5) []","solution":"def findIntersection(arr1, arr2, n, m): Finds the intersection of two sorted arrays. Args: arr1 (List[int]): The first sorted array. arr2 (List[int]): The second sorted array. n (int): The size of the first array. m (int): The size of the second array. Returns: List[int]: A list containing the intersection of the two arrays. i, j = 0, 0 intersection = [] while i < n and j < m: if arr1[i] < arr2[j]: i += 1 elif arr1[i] > arr2[j]: j += 1 else: if len(intersection) == 0 or intersection[-1] != arr1[i]: intersection.append(arr1[i]) i += 1 j += 1 return intersection"},{"question":"def max_hay_bales(W, n, weights): Returns the maximum number of hay bales that can be stored in the barn without exceeding the weight limit. :param W: int, the maximum weight limit of the barn :param n: int, the number of hay bales :param weights: list, the weights of the hay bales :return: int, the maximum number of hay bales that can be stored >>> max_hay_bales(50, 5, [10, 20, 30, 40, 50]) 2 >>> max_hay_bales(100, 4, [25, 25, 25, 25]) 4 >>> max_hay_bales(10, 3, [15, 20, 25]) 0 >>> max_hay_bales(10, 1, [5]) 1 >>> max_hay_bales(60, 6, [30, 10, 20, 5, 15, 25]) 4","solution":"def max_hay_bales(W, n, weights): Returns the maximum number of hay bales that can be stored in the barn without exceeding the weight limit. :param W: int, the maximum weight limit of the barn :param n: int, the number of hay bales :param weights: list, the weights of the hay bales :return: int, the maximum number of hay bales that can be stored weights.sort() total_weight = 0 bale_count = 0 for weight in weights: if total_weight + weight <= W: total_weight += weight bale_count += 1 else: break return bale_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: Reverse a given singly linked list and return the head of the reversed list. >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> new_head = reverseList(head) >>> linkedlist_to_list(new_head) [5, 4, 3, 2, 1] >>> head = list_to_linkedlist([7, 9, 2]) >>> new_head = reverseList(head) >>> linkedlist_to_list(new_head) [2, 9, 7] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next # temporarily store the next node current.next = prev # reverse the 'next' pointer prev = current # move \`prev\` one step forward current = next_node # move \`current\` one step forward return prev # \`prev\` will be the new head at the end"},{"question":"class SparseMatrix: Represents a sparse matrix. Methods: setValue(row: int, col: int, value: int) -> None Sets the value at position (row, col) in the matrix. getValue(row: int, col: int) -> int Returns the value at position (row, col) in the matrix. addMatrix(other: 'SparseMatrix') -> None Adds another SparseMatrix to the current matrix. transpose() -> 'SparseMatrix' Returns a new SparseMatrix which is the transpose of the current matrix. Examples: >>> sparse_matrix = SparseMatrix(5, 5) >>> sparse_matrix.setValue(2, 3, 10) >>> sparse_matrix.getValue(2, 3) 10 >>> transposed = sparse_matrix.transpose() >>> transposed.getValue(3, 2) 10 >>> other_matrix = SparseMatrix(5, 5) >>> other_matrix.setValue(3, 2, 5) >>> sparse_matrix.addMatrix(other_matrix) >>> sparse_matrix.getValue(3, 2) 5 def __init__(self, rows: int, cols: int): pass def setValue(self, row: int, col: int, value: int) -> None: pass def getValue(self, row: int, col: int) -> int: pass def addMatrix(self, other: 'SparseMatrix') -> None: pass def transpose(self) -> 'SparseMatrix': pass","solution":"class SparseMatrix: def __init__(self, rows, cols): self.rows = rows self.cols = cols self.values = {} def setValue(self, row, col, value): if value == 0: if (row, col) in self.values: del self.values[(row, col)] else: self.values[(row, col)] = value def getValue(self, row, col): return self.values.get((row, col), 0) def addMatrix(self, other): result = SparseMatrix(self.rows, self.cols) for (row, col), val in self.values.items(): result.setValue(row, col, val) for (row, col), val in other.values.items(): result.setValue(row, col, result.getValue(row, col) + val) self.values = result.values def transpose(self): transposed = SparseMatrix(self.cols, self.rows) for (row, col), val in self.values.items(): transposed.setValue(col, row, val) return transposed"},{"question":"def findSubset(arr: List[int], target: int) -> List[int]: Returns a subset of the array that sums up to the target. If multiple subsets exist, returns any one of them. If no subset exists, returns an empty list. >>> findSubset([1, 2, 3, 7], 6) in [[1, 2, 3], [3, 3]] True >>> findSubset([1, 2, 7, 1, 5], 10) == [2, 7, 1] True >>> findSubset([1, 3, 4, 8], 6) == [] True","solution":"def findSubset(arr, target): Returns a subset of the array that sums up to the target. If multiple subsets exist, returns any one of them. If no subset exists, returns an empty list. n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] subset_dict = [[[] for _ in range(target + 1)] for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True # Zero sum can always be achieved with an empty subset for i in range(1, n + 1): for t in range(1, target + 1): if arr[i - 1] <= t: if dp[i - 1][t] or dp[i - 1][t - arr[i - 1]]: dp[i][t] = True subset_dict[i][t] = subset_dict[i - 1][t - arr[i - 1]] + [arr[i - 1]] if dp[i - 1][t - arr[i - 1]] else subset_dict[i - 1][t] else: dp[i][t] = False else: dp[i][t] = dp[i - 1][t] subset_dict[i][t] = subset_dict[i - 1][t] return subset_dict[n][target] if dp[n][target] else []"},{"question":"def zigzag_grid(n): Function to create an n x n grid filled in a zigzag pattern. pass def format_grid(grid): Format the grid for output with numbers right-justified to 3-digit width. pass def main(): Main function to read inputs and print formatted output for multiple n-values. pass if __name__ == \\"__main__\\": main()","solution":"def zigzag_grid(n): Function to create an n x n grid filled in a zigzag pattern. grid = [[0] * n for _ in range(n)] current_number = 1 for i in range(n): if i % 2 == 0: # Left to Right for j in range(n): grid[i][j] = current_number current_number += 1 else: # Right to Left for j in range(n-1, -1, -1): grid[i][j] = current_number current_number += 1 return grid def format_grid(grid): Format the grid for output with numbers right-justified to 3-digit width. formatted_lines = [] for row in grid: formatted_lines.append(\\" \\".join(f\\"{num:3d}\\" for num in row)) return \\"n\\".join(formatted_lines) def main(): Main function to read inputs and print formatted output for multiple n-values. import sys input = sys.stdin.read data = input().split() inputs = list(map(int, data)) for n in inputs: if n == 0: break grid = zigzag_grid(n) output = format_grid(grid) print(output) print() if __name__ == \\"__main__\\": main()"},{"question":"def process_operations(operations): Processes a list of operations on a string and returns the output of Print operations. :param operations: List of operations to be performed. :return: List of strings resulting from Print operations. >>> process_operations([\\"Append(B)\\", \\"Append(C)\\", \\"Print()\\", \\"Remove()\\", \\"Print()\\", \\"Append(D)\\", \\"Print()\\"]) [\\"ABC\\", \\"AB\\", \\"ABD\\"] >>> process_operations([\\"Append(X)\\", \\"Print()\\"]) [\\"AX\\"] >>> process_operations([\\"Append(B)\\", \\"Append(C)\\", \\"Remove()\\", \\"Remove()\\", \\"Print()\\"]) [\\"A\\"] >>> process_operations([\\"Append(F)\\", \\"Append(O)\\", \\"Remove()\\", \\"Append(X)\\", \\"Print()\\", \\"Remove()\\", \\"Remove()\\", \\"Print()\\"]) [\\"AFX\\", \\"A\\"] >>> process_operations([]) [] >>> process_operations([\\"Print()\\"]) [\\"A\\"] >>> process_operations([\\"Append(Z)\\"]) []","solution":"def process_operations(operations): Processes a list of operations on a string and returns the output of Print operations. :param operations: List of operations to be performed. :return: List of strings resulting from Print operations. result = [] current_string = \\"A\\" for operation in operations: if operation.startswith(\\"Append(\\"): char_to_append = operation[7] # Extracting the character to append current_string += char_to_append elif operation == \\"Remove()\\": current_string = current_string[:-1] elif operation == \\"Print()\\": result.append(current_string) return result"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Write a function that takes a list of integers and a target integer. The function should return all unique pairs of integers from the list that add up to the target. A pair is defined as a tuple of two different numbers such that their sum equals the target. Your function should avoid returning duplicate pairs. Pairs should be returned as a list of tuples sorted in ascending order by the first element of the pair. If there are multiple pairs with the same first element, sort by the second element. >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, -1, 2, -2, 3, -3], 0) [(-3, 3), (-2, 2), (-1, 1)] >>> find_pairs([2, 4, 3, 5, 7, 8, 9], 10) [(2, 8), (3, 7)] >>> find_pairs([0, 1, 2, 3, 4, 5], 5) [(0, 5), (1, 4), (2, 3)] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] pass","solution":"def find_pairs(nums, target): Finds all unique pairs of integers in the given list that add up to the target integer. nums.sort() # Sort the input list for ordered pairs seen = set() pairs = [] for i in range(len(nums)): complement = target - nums[i] if complement in seen: pairs.append((complement, nums[i])) seen.add(nums[i]) # Remove duplicates and sort pairs unique_pairs = list(set(pairs)) unique_pairs.sort() return unique_pairs"},{"question":"def num_paths(n: int, grid: List[str]) -> int: Calculate the number of distinct paths for a robot to move from the top-left to the bottom-right corner of a grid, avoiding obstacles. The result should be modulo 1000000007 (109 + 7). >>> n = 3 >>> grid = [ ... '...', ... '.#.', ... '...' ... ] >>> num_paths(n, grid) 2 >>> n = 2 >>> grid = [ ... '..', ... '..' ... ] >>> num_paths(n, grid) 2 >>> n = 2 >>> grid = [ ... '.#', ... '..' ... ] >>> num_paths(n, grid) 1 >>> n = 2 >>> grid = [ ... '', ... '' ... ] >>> num_paths(n, grid) 0 >>> n = 1 >>> grid = [ ... '.' ... ] >>> num_paths(n, grid) 1 >>> n = 1 >>> grid = [ ... '#' ... ] >>> num_paths(n, grid) 0","solution":"MOD = 1000000007 def num_paths(n, grid): if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][n-1] # Read inputs def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = [] index = 1 for i in range(n): grid.append(data[index + i]) return n, grid"},{"question":"def can_alice_win(grid: List[str]) -> str: Determine if Alice can make sure that the entire grid becomes 'X's by the end of the game. >>> can_alice_win([\\"XOX\\", \\"OXO\\", \\"XOX\\"]) \\"Alice\\" >>> can_alice_win([\\"XXX\\", \\"OXO\\", \\"XOX\\"]) \\"Alice\\" >>> can_alice_win([\\"OOX\\", \\"OXO\\", \\"XOO\\"]) \\"Bob\\" >>> can_alice_win([\\"XXX\\", \\"XXX\\", \\"XXX\\"]) \\"Alice\\" >>> can_alice_win([\\"OOO\\", \\"OOO\\", \\"OOO\\"]) \\"Bob\\"","solution":"def can_alice_win(grid): n = len(grid) x_count = sum(row.count('X') for row in grid) o_count = n * n - x_count return \\"Alice\\" if x_count > o_count else \\"Bob\\""},{"question":"class SumOfNumbers: Design a SumOfNumbers class to support the following methods: 1. add(int num) Adds the number num to the back of the current list of numbers. 2. getSum(int k) Returns the sum of the last k numbers in the current list. You can assume that the current list always has at least k numbers. Example: sumOfNumbers = SumOfNumbers() sumOfNumbers.add(3) # [3] sumOfNumbers.add(0) # [3,0] sumOfNumbers.add(2) # [3,0,2] sumOfNumbers.add(5) # [3,0,2,5] sumOfNumbers.add(4) # [3,0,2,5,4] sumOfNumbers.getSum(2) # -> 9 sumOfNumbers.getSum(3) # -> 11 sumOfNumbers.getSum(4) # -> 14 sumOfNumbers.add(8) # [3,0,2,5,4,8] sumOfNumbers.getSum(2) # -> 12 def __init__(self): Initialize your data structure here. def add(self, num: int): Adds the number num to the back of the current list of numbers. def getSum(self, k: int) -> int: Returns the sum of the last k numbers in the current list.","solution":"class SumOfNumbers: def __init__(self): Initialize your data structure here. self.numbers = [] def add(self, num: int): Adds the number num to the back of the current list of numbers. self.numbers.append(num) def getSum(self, k: int) -> int: Returns the sum of the last k numbers in the current list. return sum(self.numbers[-k:])"},{"question":"def lexicographically_smallest_string(T: int, test_cases: List[Tuple[int, str]]) -> List[str]: Find the lexicographically smallest string Chef can achieve by applying the swap operation any (possibly zero) number of times. Args: T: Number of test cases. test_cases: A list of tuples where each tuple contains an integer N (number of characters in the string) and a string of length N. Returns: A list of lexicographically smallest strings for each test case. >>> lexicographically_smallest_string(3, [(3, 'cba'), (5, 'geeks'), (4, 'dcba')]) ['abc', 'eegks', 'abcd']","solution":"def lexicographically_smallest_string(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] S = test_cases[i][1] sorted_string = ''.join(sorted(S)) results.append(sorted_string) return results"},{"question":"def is_palindrome(number: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(454) True >>> is_palindrome(567) False >>> is_palindrome(898) True >>> is_palindrome(0) True def count_palindromic_plates(n: int, plates: List[int]) -> int: Count the number of palindromic license plates. Args: n: The number of license plates. plates: List of integers representing the license plates. Returns: Integer count of palindromic license plates. >>> count_palindromic_plates(5, [121, 123, 454, 567, 898]) 3 >>> count_palindromic_plates(3, [1111, 222, 3333]) 3 >>> count_palindromic_plates(4, [101, 202, 303, 404]) 4 >>> count_palindromic_plates(4, [112, 1221, 13531, 1001]) 3 >>> count_palindromic_plates(1, [12321]) 1 >>> count_palindromic_plates(3, [10, 20, 30]) 0","solution":"def is_palindrome(number): Check if a number is a palindrome. str_num = str(number) return str_num == str_num[::-1] def count_palindromic_plates(n, plates): Count the number of palindromic license plates. Args: n: The number of license plates. plates: List of integers representing the license plates. Returns: Integer count of palindromic license plates. return sum(1 for plate in plates if is_palindrome(plate))"},{"question":"def frequency_sort(s: str) -> str: Given a string \`s\` of lowercase alphabets, rearrange the string such that the characters are sorted by their frequency in descending order. If two characters have the same frequency, sort them alphabetically in ascending order. >>> frequency_sort(\\"tree\\") in [\\"eert\\", \\"eetr\\"] True >>> frequency_sort(\\"cccaaa\\") == \\"aaaccc\\" True >>> frequency_sort(\\"aabbbcc\\") == \\"bbbaacc\\" True","solution":"from collections import Counter def frequency_sort(s: str) -> str: Returns a string where characters are sorted by their frequency in descending order. If two characters have the same frequency, they should appear in alphabetical order. # Count the frequency of each character in the string frequency = Counter(s) # Sort characters first by frequency (in descending order), then by character (in ascending order) sorted_characters = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) # Construct the resultant string based on the sorted characters result = ''.join(char * count for char, count in sorted_characters) return result"},{"question":"def is_arithmetic_progression(sequence): Determines if the sequence is an arithmetic progression. Returns the common difference if it is, otherwise returns \\"NO\\". >>> is_arithmetic_progression([4, 2, 4, 6, 8]) 2 >>> is_arithmetic_progression([5, 3, 7, 11, 15, 20]) \\"NO\\" >>> is_arithmetic_progression([3, 5, 10, 15]) 5 >>> is_arithmetic_progression([2, 1, 3]) 2 >>> is_arithmetic_progression([6, 1, 1, 1, 1, 1, 1]) 0 pass def process_input(input_line): Processes the input line and returns the result for whether it forms an arithmetic progression. >>> process_input(\\"4 2 4 6 8\\") 2 >>> process_input(\\"5 3 7 11 15 20\\") \\"NO\\" >>> process_input(\\"3 5 10 15\\") 5 >>> process_input(\\"2 1 3\\") 2 >>> process_input(\\"6 1 1 1 1 1 1\\") 0 pass","solution":"def is_arithmetic_progression(sequence): Determines if the sequence is an arithmetic progression. Returns the common difference if it is, otherwise returns \\"NO\\". n = sequence[0] a = sequence[1:] # Check the common difference in the first two elements common_diff = a[1] - a[0] for i in range(2, n): if a[i] - a[i - 1] != common_diff: return \\"NO\\" return common_diff def process_input(input_line): Processes the input line and returns the result for whether it forms an arithmetic progression. sequence = list(map(int, input_line.split())) return is_arithmetic_progression(sequence)"},{"question":"from typing import List, Tuple def max_distinct_markets(n: int, m: int, d: int, tracks: List[Tuple[int, int]], market_days: List[str]) -> int: The function calculates the maximum number of distinct markets visited starting a trip in the first city on the first day of the week. Args: n (int): number of cities. m (int): number of railway tracks. d (int): number of days in a week. tracks (List[Tuple[int, int]]): list of tuples representing the two-way railway tracks. market_days (List[str]): each string represents market days schedule of respective city. Returns: int: maximum number of distinct markets. Examples: >>> max_distinct_markets(5, 5, 7, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5)], [\\"1010101\\", \\"0101010\\", \\"1110000\\", \\"0001111\\", \\"1000001\\"]) 4 >>> max_distinct_markets(4, 3, 5, [(1, 2), (1, 3), (2, 4)], [\\"11111\\", \\"11100\\", \\"00011\\", \\"00111\\"]) 3 from solution import max_distinct_markets def test_example_1(): n = 5 m = 5 d = 7 tracks = [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5)] market_days = [ \\"1010101\\", \\"0101010\\", \\"1110000\\", \\"0001111\\", \\"1000001\\", ] assert max_distinct_markets(n, m, d, tracks, market_days) == 4 def test_example_2(): n = 4 m = 3 d = 5 tracks = [(1, 2), (1, 3), (2, 4)] market_days = [ \\"11111\\", \\"11100\\", \\"00011\\", \\"00111\\", ] assert max_distinct_markets(n, m, d, tracks, market_days) == 3 def test_single_city(): n = 1 m = 0 d = 5 tracks = [] market_days = [\\"11111\\"] assert max_distinct_markets(n, m, d, tracks, market_days) == 1 def test_multiple_cities_no_tracks(): n = 3 m = 0 d = 7 tracks = [] market_days = [\\"1111111\\", \\"0000000\\", \\"1111111\\"] assert max_distinct_markets(n, m, d, tracks, market_days) == 1 def test_cities_with_no_markets(): n = 3 m = 3 d = 7 tracks = [(1, 2), (2, 3), (3, 1)] market_days = [\\"0000000\\", \\"0000000\\", \\"0000000\\"] assert max_distinct_markets(n, m, d, tracks, market_days) == 0","solution":"from collections import deque def max_distinct_markets(n, m, d, tracks, market_days): adj = [[] for _ in range(n + 1)] for u, v in tracks: adj[u].append(v) adj[v].append(u) def bfs(start_city): # Queue will have tuples of (current_city, day, visited_markets) q = deque([(start_city, 0, set())]) max_markets = 0 visited = set([(start_city, 0)]) while q: city, day, visited_markets = q.popleft() new_visited_markets = visited_markets.copy() if market_days[city - 1][day] == '1': new_visited_markets.add(city) max_markets = max(max_markets, len(new_visited_markets)) for neighbor in adj[city]: new_day = (day + 1) % d state = (neighbor, new_day) if state not in visited: visited.add(state) q.append((neighbor, new_day, new_visited_markets)) return max_markets return bfs(1)"},{"question":"def min_operations_to_cut_all_grass(n: int, grid: List[List[int]]) -> int: Determine the minimum number of operations needed to cut all the grass to height zero in an n x n grid. Args: n (int): The size of the grid. grid (List[List[int]]): The n x n grid representing the field where each cell contains the height of the grass. Returns: int: The minimum number of operations required to cut all the grass to height zero. Example: >>> min_operations_to_cut_all_grass(3, [[2, 5, 4], [3, 0, 1], [6, 4, 2]]) 3 >>> min_operations_to_cut_all_grass(2, [[1, 3], [4, 2]]) 2 >>> min_operations_to_cut_all_grass(4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 4 >>> min_operations_to_cut_all_grass(1, [[5]]) 1 >>> min_operations_to_cut_all_grass(1000, [[1000] * 1000] * 1000) 1000","solution":"def min_operations_to_cut_all_grass(n, grid): # The minimum number of operations needed would either be n rows or n columns, # as choosing to cut rows versus columns does not change the final zeroed grid. return n"},{"question":"def inventory_management(operations): Simulate an inventory management system for a warehouse. The function takes a list of operations and returns the results of 'check' operations. >>> inventory_management([ \\"receive 10 apples\\", \\"receive 5 bananas\\", \\"dispatch 2 apples\\", \\"check apples\\", \\"check bananas\\", \\"check oranges\\", \\"dispatch 3 bananas\\", \\"check bananas\\" ]) [8, 5, 0, 2] >>> inventory_management([ \\"receive 5 apples\\", \\"dispatch 10 apples\\", \\"check apples\\" ]) [5] >>> inventory_management([ \\"receive 10 oranges\\", \\"dispatch 5 oranges\\", \\"dispatch 10 oranges\\", \\"check oranges\\" ]) [5] >>> inventory_management([ \\"check mangoes\\", \\"receive 2 mangoes\\", \\"check mangoes\\" ]) [0, 2] >>> inventory_management([ \\"receive 3 apples\\", \\"receive 4 apples\\", \\"check apples\\" ]) [7]","solution":"def inventory_management(operations): inventory = {} results = [] for operation in operations: op, *args = operation.split() if op == \\"receive\\": k, x = int(args[0]), args[1] if x in inventory: inventory[x] += k else: inventory[x] = k elif op == \\"dispatch\\": k, x = int(args[0]), args[1] if x in inventory and inventory[x] >= k: inventory[x] -= k elif op == \\"check\\": x = args[0] results.append(inventory.get(x, 0)) return results"},{"question":"import math def smallestMultiple(N: int) -> int: Finds the smallest positive integer that is divisible by every number from 1 to N. Args: N (int): The upper bound number. Returns: int: The smallest positive integer divisible by all numbers from 1 to N. Example: >>> smallestMultiple(4) 12 >>> smallestMultiple(6) 60","solution":"import math def smallestMultiple(N): Finds the smallest positive integer that is divisible by every number from 1 to N. def lcm(a, b): return abs(a * b) // math.gcd(a, b) result = 1 for i in range(1, N + 1): result = lcm(result, i) return result"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Computes the minimum path sum from the top-left corner to the bottom-right corner. Parameters: grid (list of list of int): 2D list representing the grid. Returns: int: Minimum sum along the path. Examples: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3 pass","solution":"def min_path_sum(grid): Computes the minimum path sum from the top-left corner to the bottom-right corner. Parameters: grid (list of list of int): 2D list representing the grid. Returns: int: Minimum sum along the path. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # DP table to store minimum path sum until each cell dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def get_primes_up_to_100() -> List[int]: Generate a list of prime numbers up to 100 >>> get_primes_up_to_100() [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] def maximize_beauty(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Modify the array such that the total beauty is maximized. >>> maximize_beauty(2, [(5, [22, 33, 15, 49, 58]), (3, [10, 15, 21])]) [[2, 3, 5, 7, 11], [2, 3, 5]] >>> maximize_beauty(1, [(1, [10])]) [[2]]","solution":"def get_primes_up_to_100(): Function to generate a list of prime numbers up to 100 sieve = [True] * 101 sieve[0] = sieve[1] = False for start in range(2, int(101**0.5) + 1): if sieve[start]: for multiple in range(start*start, 101, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime] def maximize_beauty(T, test_cases): Function to maximize the total beauty of the array primes = get_primes_up_to_100() results = [] for case in test_cases: N = case[0] # Take the first N primes result = primes[:N] results.append(result) return results"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Write a function that takes two strings as input and returns a boolean indicating whether one string is a permutation of the other. A permutation is a rearrangement of characters. For example, \\"abc\\" and \\"cab\\" are permutations of each other, while \\"abc\\" and \\"abcd\\" are not. >>> are_permutations(\\"abc\\", \\"cab\\") True >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"hello\\", \\"bello\\") False >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"Hello\\", \\"hello\\") False >>> are_permutations(\\"Abc\\", \\"abc\\") False","solution":"def are_permutations(str1, str2): Returns True if str1 is a permutation of str2, False otherwise. if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"def determine_parity_balance(numbers): Determine whether the parity of the number of even numbers in the array is the same as the parity of the number of odd numbers in the array. Parameters: numbers (list of int): The list of integers to check. Returns: str: \\"Balanced\\" if the parity of the number of even numbers is the same as the parity of the number of odd numbers, otherwise \\"Unbalanced\\". pass from determine_parity_balance import determine_parity_balance def test_balanced_parity(): assert determine_parity_balance([3, 5, 7, 10]) == \\"Balanced\\" def test_unbalanced_parity(): assert determine_parity_balance([4, 2, 4, 5]) == \\"Balanced\\" def test_all_even(): assert determine_parity_balance([2, 4, 6, 8]) == \\"Balanced\\" def test_all_odd(): assert determine_parity_balance([1, 3, 5, 7]) == \\"Balanced\\" def test_mixed_numbers(): assert determine_parity_balance([1, 2, 3, 4]) == \\"Balanced\\" def test_another_mixed_numbers(): assert determine_parity_balance([1, 2, 3, 4, 5]) == \\"Unbalanced\\" def test_no_numbers(): assert determine_parity_balance([]) == \\"Balanced\\"","solution":"def determine_parity_balance(numbers): Determine whether the parity of the number of even numbers in the array is the same as the parity of the number of odd numbers in the array. Parameters: numbers (list of int): The list of integers to check. Returns: str: \\"Balanced\\" if the parity of the number of even numbers is the same as the parity of the number of odd numbers, otherwise \\"Unbalanced\\". even_count = sum(1 for x in numbers if x % 2 == 0) odd_count = len(numbers) - even_count if even_count % 2 == odd_count % 2: return \\"Balanced\\" else: return \\"Unbalanced\\""},{"question":"def min_changes_to_palindrome(S: str, N: int) -> int: Returns the minimum number of changes required to make string S a palindrome using exactly N operations. If it is not possible to make the string a palindrome using N operations, returns -1. >>> min_changes_to_palindrome(\\"abc\\", 2) == 1 >>> min_changes_to_palindrome(\\"racecar\\", 1) == 0 >>> min_changes_to_palindrome(\\"abcd\\", 2) == 2 >>> min_changes_to_palindrome(\\"abcd\\", 1) == -1 >>> min_changes_to_palindrome(\\"a\\", 0) == 0 def process_test_cases(T: int, test_cases: List[Tuple[str, int]]) -> List[int]: Processes multiple test cases for min_changes_to_palindrome function. Returns a list of results for each test case. >>> process_test_cases(2, [(\\"abc\\", 2), (\\"racecar\\", 1)]) == [1, 0] >>> process_test_cases(3, [(\\"abcd\\", 2), (\\"ab\\", 1), (\\"aaa\\", 0)]) == [2, 1, 0]","solution":"def min_changes_to_palindrome(S, N): Returns the minimum number of changes required to make string S a palindrome using exactly N operations. length = len(S) changes_needed = 0 # Calculate the number of changes needed to make the string palindrome for i in range(length // 2): if S[i] != S[length - i - 1]: changes_needed += 1 # If changes needed is less than or equal to N, it means we can make the string palindrome # but if changes needed is more than N, it means we are unable to make the string palindrome if changes_needed <= N: return changes_needed else: return -1 def process_test_cases(T, test_cases): result = [] for i in range(T): S, N = test_cases[i] result.append(min_changes_to_palindrome(S, N)) return result"},{"question":"def min_lunar_coins(n: int) -> int: Returns the minimum number of Lunar Coins needed to make the amount n. >>> min_lunar_coins(6) 2 >>> min_lunar_coins(15) 4 >>> min_lunar_coins(1) 1 >>> min_lunar_coins(8) 1 >>> min_lunar_coins(1023) 10 >>> min_lunar_coins(12345) 6","solution":"def min_lunar_coins(n): Returns the minimum number of Lunar Coins needed to make the amount n. # The number of 1s in the binary representation of n gives the minimum number of Lunar Coins needed. return bin(n).count('1')"},{"question":"def aggregate_ingredients(recipes): Aggregates the quantities of ingredients needed from a list of recipes. Args: recipes (list of dict): List of recipes where each recipe is represented by a dictionary with ingredient names as keys and quantities as values. Returns: dict: A dictionary with ingredient names as keys and the total quantity needed as values. >>> aggregate_ingredients([ ... {\\"flour\\": 200, \\"sugar\\": 100, \\"eggs\\": 2}, ... {\\"flour\\": 150, \\"sugar\\": 100, \\"butter\\": 50}, ... {\\"milk\\": 200, \\"sugar\\": 50, \\"eggs\\": 1} ... ]) {'flour': 350, 'sugar': 250, 'eggs': 3, 'butter': 50, 'milk': 200} >>> aggregate_ingredients([ ... {\\"flour\\": 200, \\"sugar\\": 100, \\"eggs\\": 2} ... ]) {'flour': 200, 'sugar': 100, 'eggs': 2} >>> aggregate_ingredients([]) {} >>> aggregate_ingredients([ ... {\\"flour\\": 200}, ... {\\"sugar\\": 100}, ... {\\"eggs\\": 3} ... ]) {'flour': 200, 'sugar': 100, 'eggs': 3} >>> aggregate_ingredients([ ... {\\"flour\\": 200, \\"sugar\\": 0, \\"eggs\\": 2}, ... {\\"flour\\": 150, \\"sugar\\": 0, \\"butter\\": 50}, ... {\\"milk\\": 200, \\"sugar\\": 0, \\"eggs\\": 1} ... ]) {'flour': 350, 'sugar': 0, 'eggs': 3, 'butter': 50, 'milk': 200}","solution":"def aggregate_ingredients(recipes): Aggregates the quantities of ingredients needed from a list of recipes. Args: recipes (list of dict): List of recipes where each recipe is represented by a dictionary with ingredient names as keys and quantities as values. Returns: dict: A dictionary with ingredient names as keys and the total quantity needed as values. ingredient_totals = {} for recipe in recipes: for ingredient, quantity in recipe.items(): if ingredient in ingredient_totals: ingredient_totals[ingredient] += quantity else: ingredient_totals[ingredient] = quantity return ingredient_totals"},{"question":"from typing import List, Tuple, Union def find_special_subsequence(n: int, m: int, array: List[int]) -> Union[Tuple[str, List[int]], Tuple[str]]: Finds any special subsequence whose sum is divisible by m. Arguments: n -- The number of elements in the array. m -- The integer by which the subsequence sum should be divisible. array -- The list of integers. Returns: A tuple where the first element is \\"YES\\" and the second element is a list of indices of the elements in the special subsequence, or a tuple with \\"NO\\" if no such subsequence exists. Examples: >>> find_special_subsequence(5, 3, [1, 2, 3, 4, 5]) (\\"YES\\", [1, 2]) >>> find_special_subsequence(4, 5, [1, 1, 1, 1]) (\\"NO\\",) >>> find_special_subsequence(3, 2, [2, 4, 6]) (\\"YES\\", [1]) >>> find_special_subsequence(1, 3, [3]) (\\"YES\\", [1]) >>> find_special_subsequence(1, 4, [3]) (\\"NO\\",) >>> find_special_subsequence(3, 5, [-1, -1, -1]) (\\"NO\\",) pass","solution":"def find_special_subsequence(n, m, array): Finds any special subsequence whose sum is divisible by m. for i in range(1, 1 << n): subsequence = [] subsequence_sum = 0 for j in range(n): if i & (1 << j): subsequence.append(j+1) subsequence_sum += array[j] if subsequence_sum % m == 0: return (\\"YES\\", subsequence) return (\\"NO\\",)"},{"question":"def visible_trees_from_left(n, heights): Determine the number of trees that can be seen from the left side and their heights. Parameters: n (int): the number of trees heights (list): a list of integers representing the heights of the trees Returns: tuple: (count of visible trees, list of visible tree heights) Example: >>> visible_trees_from_left(5, [2, 5, 3, 4, 1]) (2, [2, 5]) >>> visible_trees_from_left(3, [1, 2, 1]) (2, [1, 2])","solution":"def visible_trees_from_left(n, heights): Returns the number of visible trees and their heights from the left side. Parameters: n (int): the number of trees heights (list): a list of integers representing the heights of the trees Returns: tuple: (count of visible trees, list of visible tree heights) if not heights or n == 0: return (0, []) visible_trees = [] max_height = 0 for height in heights: if height > max_height: visible_trees.append(height) max_height = height return (len(visible_trees), visible_trees) # Example usage: # n = 5 # heights = [2, 5, 3, 4, 1] # print(visible_trees_from_left(n, heights)) # Output: (2, [2, 5])"},{"question":"def calculate_tallest_plant_heights(T: int, test_cases: List[List[int]]) -> List[List[int]]: Calculate the height of the tallest plant at the end of each given day specified in the input. Parameters: T (int): Number of test cases test_cases (List[List[int]]): List of test case information Each test case consists of: - Number of plants (N) - Initial heights of the plants (list of N integers) - Growth rates of the plants (list of N integers) - Number of days to calculate the tallest plant's height for (D) - Specific days (list of D integers) Returns: List[List[int]]: For each test case, list of heights of the tallest plant at the end of corresponding days. Example: >>> calculate_tallest_plant_heights(2, [ ... [3, [5, 10, 3], [1, 2, 2], 2, [1, 3]], ... [2, [20, 30], [4, 2], 2, [5, 10]] ... ]) [[12, 16], [40, 60]] def test_calculate_tallest_plant_heights(): T = 2 test_cases = [ [3, [5, 10, 3], [1, 2, 2], 2, [1, 3]], [2, [20, 30], [4, 2], 2, [5, 10]] ] expected_output = [ [12, 16], [40, 60] ] assert calculate_tallest_plant_heights(T, test_cases) == expected_output def test_calculate_tallest_plant_heights_zero_days(): T = 1 test_cases = [ [3, [5, 10, 3], [1, 2, 2], 1, [0]], ] expected_output = [ [10] ] assert calculate_tallest_plant_heights(T, test_cases) == expected_output def test_calculate_tallest_plant_heights_single_plant(): T = 1 test_cases = [ [1, [5], [2], 3, [0, 1, 2]], ] expected_output = [ [5, 7, 9] ] assert calculate_tallest_plant_heights(T, test_cases) == expected_output def test_calculate_tallest_plant_heights_all_plants_same(): T = 1 test_cases = [ [2, [5, 5], [1, 1], 2, [1, 2]], ] expected_output = [ [6, 7] ] assert calculate_tallest_plant_heights(T, test_cases) == expected_output","solution":"def calculate_tallest_plant_heights(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] initial_heights = test_cases[i][1] growth_rates = test_cases[i][2] D = test_cases[i][3] days = test_cases[i][4] tallest_per_day = [] for day in days: heights_on_day = [initial + rate * day for initial, rate in zip(initial_heights, growth_rates)] tallest = max(heights_on_day) tallest_per_day.append(tallest) results.append(tallest_per_day) return results"},{"question":"def maximize_absolute_difference(t, cases): Reorder the list of integers for each test case to maximize the sum of absolute differences between consecutive elements. Args: t : int : number of test cases cases : list of tuples : each tuple contains an integer n and a list of n distinct integers Returns: list of lists : reordered lists of integers that maximize the sum of absolute differences Example: >>> t = 2 >>> cases = [(5, [1, 5, 3, 2, 4]), (3, [-1, 0, 1])] >>> maximize_absolute_difference(t, cases) [[5, 1, 4, 2, 3], [1, -1, 0]]","solution":"def maximize_absolute_difference(t, cases): results = [] for i in range(t): n = cases[i][0] arr = cases[i][1] arr.sort() left = 0 right = n - 1 result = [] while left <= right: if right != left: result.append(arr[right]) result.append(arr[left]) else: result.append(arr[left]) left += 1 right -= 1 results.append(result) return results # Example of how to call the function for your input cases t = 2 cases = [ (5, [1, 5, 3, 2, 4]), (3, [-1, 0, 1]) ] print(maximize_absolute_difference(t, cases))"},{"question":"def shortest_subsequence_length(n, m, color_sequence, color_set): Determine the shortest sub-sequence that includes all the colors in the given set at least once. >>> shortest_subsequence_length(10, 3, [1, 2, 3, 4, 2, 3, 1, 2, 2, 3], [1, 2, 3]) == 3 >>> shortest_subsequence_length(5, 2, [1, 2, 2, 2, 1], [1, 2]) == 2 >>> shortest_subsequence_length(6, 3, [1, 2, 4, 4, 2, 3], [1, 2, 3]) == 6 >>> shortest_subsequence_length(6, 3, [1, 2, 4, 4, 2, 3], [3, 2, 1]) == 6 >>> shortest_subsequence_length(7, 3, [1, 2, 1, 1, 2, 3, 3], [1, 2, 3]) == 3 >>> shortest_subsequence_length(6, 2, [1, 1, 1, 1, 1, 1], [1, 2]) == -1 >>> shortest_subsequence_length(1, 1, [1], [1]) == 1 >>> shortest_subsequence_length(5, 2, [1, 1, 1, 1, 2], [1, 2]) == 2","solution":"def shortest_subsequence_length(n, m, color_sequence, color_set): from collections import defaultdict, Counter # Convert color_set to a set for O(1) lookups required_colors = set(color_set) required_count = Counter(color_set) window_count = defaultdict(int) start = 0 shortest_length = float('inf') formed = 0 # Function to check if current window fulfills the requirement def fulfills_requirements(): for color in required_colors: if window_count[color] < required_count[color]: return False return True # Sliding window for end in range(n): color = color_sequence[end] window_count[color] += 1 # Check if current window satisfies the requirement while fulfills_requirements() and start <= end: current_length = end - start + 1 if current_length < shortest_length: shortest_length = current_length # Slide the window to the right window_count[color_sequence[start]] -= 1 start += 1 return shortest_length if shortest_length != float('inf') else -1"},{"question":"def calculate_resistance(resistors, connection_type): Calculates the equivalent resistance of a combination of resistors in series or parallel. :param resistors: List of float, the resistance values of the resistors. :param connection_type: str, 'series' or 'parallel', the type of connection. :return: float, the equivalent resistance. >>> calculate_resistance([2, 3, 4], 'series') == 9 >>> calculate_resistance([2, 3, 4], 'parallel') == 0.923","solution":"def calculate_resistance(resistors, connection_type): Calculates the equivalent resistance of a combination of resistors in series or parallel. :param resistors: List of float, the resistance values of the resistors. :param connection_type: str, 'series' or 'parallel', the type of connection. :return: float, the equivalent resistance. if connection_type == 'series': return sum(resistors) elif connection_type == 'parallel': reciprocal_sum = sum(1.0 / r for r in resistors) return round(1.0 / reciprocal_sum, 3) else: raise ValueError(\\"Invalid connection type. Use 'series' or 'parallel'.\\")"},{"question":"def find_target_range(nums: List[int], target: int) -> List[int]: Find the starting and ending position of a given target value in a sorted list of integers. If the target is not found, return [-1, -1]. >>> find_target_range([5,7,7,8,8,10], 8) [3, 4] >>> find_target_range([5,7,7,8,8,10], 6) [-1, -1] >>> find_target_range([1,2,3,4,4,4,5,6], 4) [3, 5] >>> find_target_range([], 8) [-1, -1] # Implement the function here using binary search # Unit tests def test_find_target_range(): assert find_target_range([5,7,7,8,8,10], 8) == [3, 4] assert find_target_range([5,7,7,8,8,10], 6) == [-1, -1] assert find_target_range([1,2,3,4,4,4,5,6], 4) == [3, 5] assert find_target_range([], 8) == [-1, -1] assert find_target_range([1,2,2,2,3,4,5], 2) == [1, 3] assert find_target_range([1, 3, 3, 5, 5, 5, 7], 5) == [3, 5] assert find_target_range([1,2,3,4,5,6,7], 7) == [6, 6] assert find_target_range([1,2,3,4,5,6], 1) == [0, 0] assert find_target_range([1,2,3,4,5,6], 10) == [-1, -1] assert find_target_range([2,2,2,2], 2) == [0, 3] if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def find_target_range(nums, target): def find_leftmost(): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_rightmost(): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = find_leftmost() right_idx = find_rightmost() if left_idx <= right_idx and left_idx < len(nums) and nums[left_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"def is_beautiful_sequence(n: int, sequence: List[int]) -> str: Determines if the given sequence of numbers is beautiful. A sequence is beautiful if it contains at least one pair of integers (a, b) such that their product is a perfect square. Args: n: int - the length of the sequence sequence: list of int - the sequence of integers Returns: str - \\"Yes\\" if the sequence is beautiful, otherwise \\"No\\" >>> is_beautiful_sequence(5, [1, 2, 3, 4, 5]) \\"Yes\\" >>> is_beautiful_sequence(3, [2, 6, 3]) \\"No\\"","solution":"import math def is_beautiful_sequence(n, sequence): Determines if the given sequence of numbers is beautiful. A sequence is beautiful if it contains at least one pair of integers (a, b) such that their product is a perfect square. Args: n: int - the length of the sequence sequence: list of int - the sequence of integers Returns: str - \\"Yes\\" if the sequence is beautiful, otherwise \\"No\\" def is_perfect_square(x): return int(math.isqrt(x)) ** 2 == x seen = set() for num in sequence: for factor in range(1, int(math.isqrt(num)) + 1): if num % factor == 0: seen.add(factor) seen.add(num // factor) pair_product = factor * (num // factor) if is_perfect_square(pair_product): return \\"Yes\\" return \\"No\\""},{"question":"def cumulativeSum(array): Given an array of integers, return a new array where each element at index i of the new array is the sum of the previous i elements of the original array. Example 1: >>> cumulativeSum([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] Example 2: >>> cumulativeSum([10, 20, 30]) [10, 30, 60] Example 3: >>> cumulativeSum([5]) [5] Example 4: >>> cumulativeSum([]) [] Example 5: >>> cumulativeSum([3, -2, 7, 10, -3]) [3, 1, 8, 18, 15] Example 6: >>> cumulativeSum([-1, -2, -3, -4, -5]) [-1, -3, -6, -10, -15] Example 7: >>> cumulativeSum([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] Example 8: >>> cumulativeSum([1000000, 2000000, 3000000]) [1000000, 3000000, 6000000]","solution":"def cumulativeSum(array): Returns a new array where each element is the sum of the previous elements. if not array: return [] result = [array[0]] for i in range(1, len(array)): result.append(result[-1] + array[i]) return result"},{"question":"def min_moves_to_collect_coins(t: int, test_cases: List[Dict[str, Any]]) -> List[int]: Calculate the minimum number of moves required to collect all the coins from each grid in the given test cases. t: The number of test cases test_cases: A list of test case dictionaries, where each dictionary contains: - m: The number of rows in the grid - n: The number of columns in the grid - grid: A 2D list representing the number of coins in each cell of the grid Returns a list of integers, each indicating the minimum number of moves required for the corresponding test case. >>> min_moves_to_collect_coins(1, [{'m': 2, 'n': 3, 'grid': [[0, 1, 2], [3, 0, 4]]}]) [4] >>> min_moves_to_collect_coins(1, [{'m': 3, 'n': 2, 'grid': [[1, 0], [0, 3], [2, 2]]}]) [4]","solution":"def min_moves_to_collect_coins(t, test_cases): results = [] for case in test_cases: m, n, grid = case['m'], case['n'], case['grid'] moves = 0 for row in grid: for cell in row: if cell > 0: moves += 1 results.append(moves) return results"},{"question":"def can_rearrange(N, B): Determine if it is possible to rearrange the elements of array B to form an array C such that: for all 1 ≤ i < N, either C[i] is divisible by C[i-1] or C[i-1] is divisible by C[i]. >>> can_rearrange(3, [3, 6, 9]) (\\"YES\\", [3, 6, 9]) >>> can_rearrange(4, [4, 2, 1, 8]) (\\"YES\\", [1, 2, 4, 8]) >>> can_rearrange(2, [5, 10]) (\\"YES\\", [5, 10]) >>> can_rearrange(3, [7, 13, 19]) (\\"NO\\", []) pass def process_test_cases(T, test_cases): Process multiple test cases and return the results in the specified format. >>> process_test_cases(3, [(3, [3, 6, 9]), (4, [4, 2, 1, 8]), (2, [5, 10])]) [ \\"YESn3 6 9\\", \\"YESn1 2 4 8\\", \\"YESn5 10\\" ] >>> process_test_cases(2, [(4, [15, 30, 45, 90]), (3, [7, 13, 19])]) [ \\"YESn15 30 45 90\\", \\"NO\\" ] pass","solution":"def can_rearrange(N, B): Determine if it is possible to rearrange the elements of array B to form an array C such that: for all 1 ≤ i < N, either C[i] is divisible by C[i-1] or C[i-1] is divisible by C[i]. # First, sorting the array B.sort() # As for all x, y in sorted B, either x % y == 0 or y % x == 0, it is enough to # try and print the sorted array as the solution. return \\"YES\\", B def process_test_cases(T, test_cases): results = [] for i in range(T): N, B = test_cases[i] rearrangement_status, rearranged_array = can_rearrange(N, B) if rearrangement_status == \\"YES\\": results.append(f\\"YESn{' '.join(map(str, rearranged_array))}\\") else: results.append(\\"NO\\") return results"},{"question":"def can_form_arithmetic_progression(arr: List[int]) -> bool: Determines if an array can be rearranged to form an arithmetic progression. >>> can_form_arithmetic_progression([3, 5, 1]) True >>> can_form_arithmetic_progression([1, 4, 2, 3]) True >>> can_form_arithmetic_progression([1, 2, 4, 7]) False def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases and determines if the arrays can be rearranged to form an arithmetic progression. >>> process_test_cases([(3, [3, 5, 1]), (4, [1, 4, 2, 3]), (4, [1, 2, 4, 7])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases([(2, [1, 2]), (3, [-1, -3, -5]), (4, [5, 5, 5, 5])]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_arithmetic_progression(arr): Determines if an array can be rearranged to form an arithmetic progression. n = len(arr) if n == 2: return True arr.sort() diff = arr[1] - arr[0] for i in range(2, n): if arr[i] - arr[i-1] != diff: return False return True def process_test_cases(test_cases): Processes multiple test cases and determines if the arrays can be rearranged to form an arithmetic progression. results = [] for case in test_cases: n, arr = case if can_form_arithmetic_progression(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_subset_sum(n: int, S: int, arr: List[int]) -> Union[List[int], int]: Returns a subset of arr that sums up to S, or -1 if no such subset exists. >>> find_subset_sum(5, 9, [3, 34, 4, 12, 5]) in ([4, 5], [5, 4]) True >>> find_subset_sum(4, 11, [1, 2, 3, 5, 8]) in ([3, 8], [8, 3]) True >>> find_subset_sum(3, 10, [1, 2, 5]) -1 >>> find_subset_sum(1, 1, [1]) [1] >>> find_subset_sum(1, 2, [1]) -1 >>> find_subset_sum(4, 10, [2, 3, 1, 4]) in ([2, 3, 1, 4],) True >>> find_subset_sum(5, 10000, [10000, 2000, 3000, 4000, 5000]) [10000] >>> find_subset_sum(5, 15000, [10000, 2000, 3000, 4000, 5000]) in ([10000, 5000], [5000, 10000]) True","solution":"def find_subset_sum(n, S, arr): Returns a subset of arr that sums up to S, or -1 if no such subset exists. from itertools import combinations # Try all possible subsets for r in range(1, n+1): # r ranges from 1 to n (length of combinations) for combo in combinations(arr, r): if sum(combo) == S: return list(combo) return -1"},{"question":"from typing import List, Tuple def generate_shuffle_sequence(M: int, G: int, B: int) -> List[int]: Generates a valid shuffle sequence for the playlist given the constraints. Parameters: M (int): Number of songs. G (int): \\"within G songs\\" constraint. B (int): \\"after more than B songs\\" constraint. Returns: list: A valid shuffle sequence of song IDs. pass def shuffle_playlist(test_cases: List[Tuple[int, int, int]]) -> List[List[int]]: Generates shuffle sequences for multiple test cases. Parameters: test_cases (list): List of (M, G, B) tuples representing each test case. Returns: list: List of shuffle sequences. pass # Example usage: # sequences = shuffle_playlist([(5, 2, 3), (7, 3, 4), (3, 1, 2)]) # for seq in sequences: # print(\\" \\".join(map(str, seq)))","solution":"import random def generate_shuffle_sequence(M, G, B): Generates a valid shuffle sequence for the playlist given the constraints. Parameters: M (int): Number of songs. G (int): \\"within G songs\\" constraint. B (int): \\"after more than B songs\\" constraint. Returns: list: A valid shuffle sequence of song IDs. # Create a list of song IDs songs = list(range(1, M + 1)) # Shuffle using Fisher-Yates algorithm def fisher_yates_shuffle(array): for i in range(len(array) - 1, 0, -1): j = random.randint(0, i) array[i], array[j] = array[j], array[i] return array while True: shuffled = fisher_yates_shuffle(songs.copy()) valid = True for i in range(M): for j in range(i + 1, M): distance = j - i # Ensure the constraints if shuffled[j] == shuffled[i] and (distance <= G or distance > B): valid = False break if not valid: break if valid: return shuffled def shuffle_playlist(test_cases): Generates shuffle sequences for multiple test cases. Parameters: test_cases (list): List of (M, G, B) tuples representing each test case. Returns: list: List of shuffle sequences. sequences = [] for M, G, B in test_cases: sequence = generate_shuffle_sequence(M, G, B) sequences.append(sequence) return sequences def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): M = int(data[index]) G = int(data[index + 1]) B = int(data[index + 2]) test_cases.append((M, G, B)) index += 3 sequences = shuffle_playlist(test_cases) for seq in sequences: print(\\" \\".join(map(str, seq))) if __name__ == \\"__main__\\": main()"},{"question":"def most_penalized_player(penalties: List[List[str]]) -> Tuple[str, int]: Given a list of penalties in the format [player_name, violation_time, violation_code], this function returns the name of the player with the most penalties and the total number of penalties committed by that player. Parameters: penalties (list of lists): List of penalty records in format [player_name, violation_time, violation_code] Returns: tuple: (player_name, total_penalties) >>> most_penalized_player([[\\"Alice\\", \\"00:23\\", \\"F01\\"], [\\"Bob\\", \\"00:45\\", \\"E12\\"], [\\"Alice\\", \\"01:10\\", \\"F02\\"], [\\"Charlie\\", \\"02:30\\", \\"G03\\"], [\\"Bob\\", \\"03:50\\", \\"E12\\"], [\\"Alice\\", \\"04:20\\", \\"H05\\"]]) (\\"Alice\\", 3) >>> most_penalized_player([[\\"Alice\\", \\"00:23\\", \\"F01\\"]]) (\\"Alice\\", 1)","solution":"def most_penalized_player(penalties): Given a list of penalties in the format [player_name, violation_time, violation_code], this function returns the name of the player with the most penalties and the total number of penalties committed by that player. Parameters: penalties (list of lists): List of penalty records in format [player_name, violation_time, violation_code] Returns: tuple: (player_name, total_penalties) from collections import Counter # Extract only the player names from the penalties player_names = [penalty[0] for penalty in penalties] # Count the occurrences of each player name player_count = Counter(player_names) # Identify the player with the maximum penalties most_penalized = player_count.most_common(1)[0] return most_penalized"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Given a list of tasks represented as tuples of (start_time, end_time), return the maximum number of non-overlapping tasks that can be completed. >>> max_non_overlapping_tasks([(1, 4), (2, 6), (5, 7)]) == 2 >>> max_non_overlapping_tasks([(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_tasks([(1, 3), (2, 4), (3, 5)]) == 2","solution":"def max_non_overlapping_tasks(tasks): Given a list of tasks represented as tuples of (start_time, end_time), return the maximum number of non-overlapping tasks that can be completed. Parameters: tasks (list): A list of tuples where each tuple represents (start_time, end_time) Returns: int: The maximum number of non-overlapping tasks. if not tasks: return 0 # Sort the tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize variables max_tasks = 0 last_end_time = 0 # Iterate through the sorted tasks for start_time, end_time in tasks: if start_time >= last_end_time: # If the current task starts after or when the last selected task ends max_tasks += 1 last_end_time = end_time return max_tasks"},{"question":"from typing import List def length_of_longest_increasing_subsequence(sequence: List[int]) -> int: Returns the length of the longest increasing subsequence in the given sequence. >>> length_of_longest_increasing_subsequence([10, 22, 9, 33, 21, 50]) == 4 >>> length_of_longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 pass def process_input(input_data: str) -> List[int]: Processes the input data and finds the length of the longest increasing subsequence in each dataset. >>> process_input(\\"6n10 22 9 33 21 50n5n3 10 2 1 20n0\\") == [4, 3] >>> process_input(\\"0\\") == [] pass def test_length_of_longest_increasing_subsequence(): assert length_of_longest_increasing_subsequence([10, 22, 9, 33, 21, 50]) == 4 assert length_of_longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 assert length_of_longest_increasing_subsequence([10, 9, 8, 7, 6]) == 1 assert length_of_longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 assert length_of_longest_increasing_subsequence([]) == 0 def test_process_input(): assert process_input(\\"6n10 22 9 33 21 50n5n3 10 2 1 20n0\\") == [4, 3] assert process_input(\\"0\\") == [] assert process_input(\\"1n7n0\\") == [1] assert process_input(\\"3n1 1 1n0\\") == [1] assert process_input(\\"4n3 4 2 5n0\\") == [3]","solution":"def length_of_longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence in the given sequence. if not sequence: return 0 n = len(sequence) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis) def process_input(input_data): input_lines = input_data.strip().split(\\"n\\") result = [] i = 0 while i < len(input_lines): n = int(input_lines[i]) if n == 0: break i += 1 sequence = list(map(int, input_lines[i].split())) i += 1 result.append(length_of_longest_increasing_subsequence(sequence)) return result"},{"question":"def valid_ip_address(N: str) -> List[str]: Generate a list of all possible valid IP addresses that can be formed from the given integer by splitting it into four octets. >>> valid_ip_address(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> valid_ip_address(\\"1111\\") [\\"1.1.1.1\\"] >>> valid_ip_address(\\"0000\\") [\\"0.0.0.0\\"] >>> valid_ip_address(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> valid_ip_address(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] >>> valid_ip_address(\\"256256256256\\") [] >>> valid_ip_address(\\"123456789123\\") []","solution":"def valid_ip_address(N): Returns a list of all possible valid IP addresses that can be formed from the given integer N. n = len(N) if n < 4 or n > 12: return [] def is_valid(part): return len(part) == 1 or (part[0] != '0' and 0 <= int(part) <= 255) ip_addresses = [] # Split input N into four parts and check the validity of each part for i in range(1, min(4, n - 2)): for j in range(i + 1, min(i + 4, n - 1)): for k in range(j + 1, min(j + 4, n)): part1, part2, part3, part4 = N[:i], N[i:j], N[j:k], N[k:] if is_valid(part1) and is_valid(part2) and is_valid(part3) and is_valid(part4): ip_addresses.append(f'{part1}.{part2}.{part3}.{part4}') ip_addresses.sort() return ip_addresses"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Given a matrix of characters and a word, determine if the word exists in the matrix. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> board = [ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ] >>> word = \\"ABCCED\\" >>> exist(board, word) True >>> word = \\"SEE\\" >>> exist(board, word) True >>> word = \\"ABCB\\" >>> exist(board, word) False","solution":"def exist(board, word): def dfs(board, word, i, j, word_index): # Base cases if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False # Mark the cell as visited by changing the character (avoid revisit) temp = board[i][j] board[i][j] = '' # Explore neighbors in the order: up, down, left, right found = dfs(board, word, i-1, j, word_index+1) or dfs(board, word, i+1, j, word_index+1) or dfs(board, word, i, j-1, word_index+1) or dfs(board, word, i, j+1, word_index+1) # Restore the cell's value (backtrack) board[i][j] = temp return found for row in range(len(board)): for col in range(len(board[0])): if dfs(board, word, row, col, 0): return True return False"},{"question":"MOD = 1000000007 def good_permutations(n: int) -> int: Determines the number of good permutations as per the given conditions. A permutation is good if for every i (1 ≤ i ≤ n), when you perform a bitwise AND operation on all elements from the start of the permutation up to the ith element, the result is non-decreasing. Output the number modulo 1000000007 (10^9 + 7). >>> good_permutations(1) 1 >>> good_permutations(2) 2 >>> good_permutations(3) 0","solution":"MOD = 1000000007 def good_permutations(n): ''' Determines the number of good permutations as per the given conditions. ''' # For n = 1 or n = 2, all permutations are good if n == 1: return 1 if n == 2: return 2 # For n > 2, no good permutation exists return 0"},{"question":"def max_directory_depth(directory_names: List[str]) -> int: Returns the maximum depth of any directory structure in the input list. Parameters: directory_names (list of str): List of directory names containing nested subdirectories represented by dots ('.'). Returns: int: The maximum directory depth. >>> max_directory_depth([\\"home.username.documents\\", \\"home.username.pictures.vacation\\", \\"home.music\\", \\"var.log\\"]) 4 >>> max_directory_depth([\\"a.b.c\\", \\"d.e\\", \\"f\\"]) 3 >>> max_directory_depth([\\"aaa\\", \\"bbb.ccc.ddd.eee\\"]) 4 >>> max_directory_depth([\\"a.b.c.d.e\\"]) 5 >>> max_directory_depth([\\"a\\", \\"b\\", \\"c\\"]) 1 >>> max_directory_depth([\\"a.b\\", \\"long.directory.structures.are.fun\\", \\"only.one\\"]) 5 >>> max_directory_depth([\\"a.b.c\\", \\"x.y.z\\", \\"1.2.3\\"]) 3 >>> max_directory_depth([\\"a.\\" * 199 + \\"a\\"] * 100) 200","solution":"def max_directory_depth(directory_names): Returns the maximum depth of any directory structure in the input list. Parameters: directory_names (list of str): List of directory names containing nested subdirectories represented by dots ('.'). Returns: int: The maximum directory depth. max_depth = 0 for name in directory_names: # Calculate the depth of the current directory depth = name.count('.') + 1 # Update the maximum depth if the current depth is greater max_depth = max(max_depth, depth) return max_depth"},{"question":"def has_pair_with_sum(nums, target): Checks if there are any two distinct numbers in the list that add up to the target sum. :param nums: List of integers. :param target: Target sum. :return: Boolean value indicating whether such a pair exists. Examples: >>> has_pair_with_sum([3, 4, 7, 1, 12], 10) True >>> has_pair_with_sum([1, 2, 3, 9], 5) True >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([5], 5) False >>> has_pair_with_sum([1, 1, 1, 1], 2) True >>> has_pair_with_sum([1, 3, 3, 2], 6) True >>> has_pair_with_sum([2, 4, 3, 5, 7], 10) True >>> has_pair_with_sum([-3, 4, 3, 90], 0) True >>> has_pair_with_sum([-1, -2, -3, 4], 2) True pass def test_has_pair_with_sum_exists(): assert has_pair_with_sum([3, 4, 7, 1, 12], 10) == True assert has_pair_with_sum([1, 2, 3, 9], 5) == True def test_has_pair_with_sum_not_exists(): assert has_pair_with_sum([1, 2, 3, 9], 8) == False assert has_pair_with_sum([1, 2, 4, 4], 7) == False def test_has_pair_with_sum_empty_list(): assert has_pair_with_sum([], 5) == False def test_has_pair_with_sum_single_element(): assert has_pair_with_sum([5], 5) == False def test_has_pair_with_sum_same_elements(): assert has_pair_with_sum([1, 1, 1, 1], 2) == True def test_has_pair_with_sum_duplicates(): assert has_pair_with_sum([1, 3, 3, 2], 6) == True assert has_pair_with_sum([2, 4, 3, 5, 7], 10) == True def test_has_pair_with_sum_negatives_and_positives(): assert has_pair_with_sum([-3, 4, 3, 90], 0) == True assert has_pair_with_sum([-1, -2, -3, 4], 2) == True","solution":"def has_pair_with_sum(nums, target): Checks if there are any two distinct numbers in the list that add up to the target sum. :param nums: List of integers. :param target: Target sum. :return: Boolean value indicating whether such a pair exists. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"class ShoppingCart: A class representing a Shopping Cart for an e-commerce platform. It supports adding items, removing items, and calculating the total cost. Example: cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"add 2 1 20.0\\") print(cart.process_command(\\"total\\")) # Output: 40.0 cart.process_command(\\"remove 1 1\\") print(cart.process_command(\\"total\\")) # Output: 30.0 Available commands: - \\"add item_id quantity price\\" - \\"remove item_id quantity\\" - \\"total\\" Unit Tests: from solution import ShoppingCart def test_add_items(): cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") assert cart.cart == {'1': {'quantity': 2, 'price': 10.0}} def test_add_additional_quantity(): cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"add 1 3 10.0\\") assert cart.cart == {'1': {'quantity': 5, 'price': 10.0}} def test_remove_existing_item_partial_quantity(): cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"remove 1 1\\") assert cart.cart == {'1': {'quantity': 1, 'price': 10.0}} def test_remove_existing_item_complete_quantity(): cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"remove 1 2\\") assert cart.cart == {} def test_remove_non_existing_item(): cart = ShoppingCart() result = cart.process_command(\\"remove 1 1\\") assert result == \\"Item not found\\" def test_calculate_total(): cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"add 2 1 20.0\\") total = cart.process_command(\\"total\\") assert total == 40.0 def test_invalid_command(): cart = ShoppingCart() result = cart.process_command(\\"invalid_command\\") assert result == \\"Invalid command\\" def __init__(self): # Initialize the cart as an empty dictionary self.cart = {} def process_command(self, command): # Split the command into parts parts = command.split() if parts[0] == \\"add\\": item_id = parts[1] quantity = int(parts[2]) price = float(parts[3]) # TODO: Implement adding item to the cart elif parts[0] == \\"remove\\": item_id = parts[1] quantity = int(parts[2]) # TODO: Implement removing item from the cart elif parts[0] == \\"total\\": # TODO: Implement total cost calculation else: return \\"Invalid command\\"","solution":"class ShoppingCart: def __init__(self): # Initialize the cart as an empty dictionary self.cart = {} def process_command(self, command): # Split the command into parts parts = command.split() if parts[0] == \\"add\\": item_id = parts[1] quantity = int(parts[2]) price = float(parts[3]) if item_id in self.cart: self.cart[item_id]['quantity'] += quantity else: self.cart[item_id] = {'quantity': quantity, 'price': price} elif parts[0] == \\"remove\\": item_id = parts[1] quantity = int(parts[2]) if item_id in self.cart: if self.cart[item_id]['quantity'] > quantity: self.cart[item_id]['quantity'] -= quantity elif self.cart[item_id]['quantity'] == quantity: del self.cart[item_id] else: return \\"Item not found\\" else: return \\"Item not found\\" elif parts[0] == \\"total\\": total_cost = sum(item['quantity'] * item['price'] for item in self.cart.values()) return total_cost else: return \\"Invalid command\\" # Example usage: cart = ShoppingCart() cart.process_command(\\"add 1 2 10.0\\") cart.process_command(\\"add 2 1 20.0\\") print(cart.process_command(\\"total\\")) # Output: 40.0 cart.process_command(\\"remove 1 1\\") print(cart.process_command(\\"total\\")) # Output: 30.0"},{"question":"def can_plant_new_flowers(n: int, m: int, garden: List[str]) -> str: Determine whether it is possible to place new flowers in the garden such that no two flowers are in the same row or column. >>> can_plant_new_flowers(4, 4, [\\".*..\\", \\"....\\", \\"..*.\\", \\"....\\"]) 'YES' >>> can_plant_new_flowers(3, 3, [\\".*.\\", \\".*.\\", \\".*.\\"]) 'NO' >>> can_plant_new_flowers(2, 5, [\\"..*..\\", \\".*...\\"]) 'NO' pass # Omit the solution here, user has to implement it # Unit tests import pytest def test_example_1(): n = 4 m = 4 garden = [ \\".*..\\", \\"....\\", \\"..*.\\", \\"....\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\" def test_example_2(): n = 3 m = 3 garden = [ \\".*.\\", \\".*.\\", \\".*.\\" ] assert can_plant_new_flowers(n, m, garden) == \\"NO\\" def test_example_3(): n = 2 m = 5 garden = [ \\"..*..\\", \\".*...\\" ] assert can_plant_new_flowers(n, m, garden) == \\"NO\\" def test_empty_garden(): n = 2 m = 2 garden = [ \\"..\\", \\"..\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\" def test_full_garden(): n = 2 m = 2 garden = [ \\"**\\", \\"**\\" ] assert can_plant_new_flowers(n, m, garden) == \\"NO\\" def test_one_flower(): n = 1 m = 1 garden = [ \\".\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\" def test_various_sizes(): n = 3 m = 5 garden = [ \\".....\\", \\".*...\\", \\".....\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\" garden = [ \\".....\\", \\"..*..\\", \\".....\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\" garden = [ \\"*....\\", \\".....\\", \\".....\\" ] assert can_plant_new_flowers(n, m, garden) == \\"YES\\"","solution":"def can_plant_new_flowers(n, m, garden): rows_with_flowers = set() cols_with_flowers = set() # Record the rows and columns that already have flowers for i in range(n): for j in range(m): if garden[i][j] == '*': rows_with_flowers.add(i) cols_with_flowers.add(j) # Check if we can plant a new flower such that no two flowers are in the same row or column for i in range(n): for j in range(m): if garden[i][j] == '.' and i not in rows_with_flowers and j not in cols_with_flowers: return \\"YES\\" return \\"NO\\""},{"question":"def max_stack_height(N: int, weights: List[int]) -> int: Determine the maximum height of the stack where each box can be placed on top of another according to the given rule. Parameters: N (int): The number of boxes. weights (List[int]): The weight of each box. Returns: int: The maximum height of the stack. # Sorting the weights to help determine the stacking order weights.sort() # Initialize the maximum height max_height = 1 # Iterate through sorted weights to calculate the max height for i in range(1, N): if weights[i - 1] <= weights[i]: max_height += 1 return max_height # Test cases def test_max_stack_height_sample1(): assert max_stack_height(6, [4, 3, 1, 2, 5, 6]) == 4 def test_max_stack_height_sample2(): assert max_stack_height(5, [5, 4, 3, 2, 1]) == 5 def test_max_stack_height_single_box(): assert max_stack_height(1, [100]) == 1 def test_max_stack_height_equal_weights(): assert max_stack_height(4, [2, 2, 2, 2]) == 4 def test_max_stack_height_alternating_weights(): assert max_stack_height(6, [1, 3, 2, 4, 3, 5]) == 6 def test_max_stack_height_large_input(): weights = list(range(1, 100001)) assert max_stack_height(100000, weights) == 100000","solution":"def max_stack_height(N, weights): Determine the maximum height of the stack where each box can be placed on top of another according to the given rule. Parameters: N (int): The number of boxes. weights (List[int]): The weight of each box. Returns: int: The maximum height of the stack. # Sort weights in non-decreasing order weights.sort() # Initialize the stack height max_height = 1 # Traverse through the sorted weights for i in range(1, N): if weights[i - 1] <= weights[i]: max_height += 1 return max_height"},{"question":"def identify_flower_cells(M, N, garden, flower_type): Identifies all cells (i, j) in the garden where the specified flower type is planted. Parameters: M (int): The number of rows in the garden. N (int): The number of columns in the garden. garden (list of list of str): The garden grid where each cell contains a flower type or '-'. flower_type (str): The type of flower to search for. Returns: list of tuple: List of coordinates (i, j) where the specified flower is planted. Returns an empty list if no such flower is found. >>> garden = [['R', '-', 'Y', 'B', 'G'], ['G', 'R', 'G', 'B', '-'], ['Y', '-', 'B', 'G', 'R'], ['-', 'B', '-', '-', 'Y']] >>> flower_type = 'G' >>> M, N = 4, 5 >>> identify_flower_cells(M, N, garden, flower_type) [(0, 4), (1, 0), (1, 2), (2, 3)] >>> garden = [['R', '-', 'Y', 'B', 'G'], ['G', 'R', 'G', 'B', '-'], ['Y', '-', 'B', 'G', 'R'], ['-', 'B', '-', '-', 'Y']] >>> flower_type = 'X' >>> M, N = 4, 5 >>> identify_flower_cells(M, N, garden, flower_type) 'Not Found'","solution":"def identify_flower_cells(M, N, garden, flower_type): Identifies all cells (i, j) in the garden where the specified flower type is planted. Parameters: M (int): The number of rows in the garden. N (int): The number of columns in the garden. garden (list of list of str): The garden grid where each cell contains a flower type or '-'. flower_type (str): The type of flower to search for. Returns: list of tuple: List of coordinates (i, j) where the specified flower is planted. Returns an empty list if no such flower is found. result = [] for i in range(M): for j in range(N): if garden[i][j] == flower_type: result.append((i, j)) if not result: return \\"Not Found\\" return result # Example Input: 4 5 [['R', '-', 'Y', 'B', 'G'], ['G', 'R', 'G', 'B', '-'], ['Y', '-', 'B', 'G', 'R'], ['-', 'B', '-', '-', 'Y']] 'G' # Expected Output: [(2, 0), (3, 2)]"},{"question":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, only moving right or down at each step. >>> uniquePaths(3, 7) 28 >>> uniquePaths(3, 2) 3 >>> uniquePaths(7, 3) 28 >>> uniquePaths(3, 3) 6","solution":"def uniquePaths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, only moving right or down at each step. # Create a 2D list to store the number of unique paths to each cell. dp = [[0] * n for _ in range(m)] # The number of ways to reach any cell in the first row or first column is 1 for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # For each cell, the number of paths is the sum of the number of paths # to the cell directly above and to the cell directly to the left. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def min_removals_to_avoid_overlap(projects: List[Tuple[int, int]]) -> int: Given a list of project intervals, return the minimum number of projects to remove to ensure no two projects overlap. >>> min_removals_to_avoid_overlap([(1, 3), (2, 5), (4, 6), (7, 8)]) == 1 >>> min_removals_to_avoid_overlap([(1, 2), (2, 3), (3, 4)]) == 0","solution":"def min_removals_to_avoid_overlap(projects): Given a list of project intervals, return the minimum number of projects to remove to ensure no two projects overlap. # Sort projects by their end date projects.sort(key=lambda x: x[1]) # Initialize variables end_time = -1 count = 0 for s, e in projects: # If the start time of the current project is less than or equal to # the end time of the previous project, increment the removal counter if s < end_time: count += 1 else: # Update the end_time to the current end time end_time = e return count"},{"question":"def minimize_performance_difference(n: int, m: int, tasks: List[int]) -> int: Given the number of employees n, the number of tasks m, and a list of task completion times, assign tasks to employees such that the difference in total performance is minimized. Args: n: int - the number of employees m: int - the number of tasks tasks: List[int] - the completion time of each task Returns: int - the minimized difference in total performance between the highest and lowest performing employees Examples: >>> minimize_performance_difference(3, 7, [1, 2, 3, 4, 5, 6, 7]) 1 >>> minimize_performance_difference(2, 5, [8, 4, 6, 2, 5]) 1","solution":"def minimize_performance_difference(n, m, tasks): Given the number of employees n, the number of tasks m, and a list of task completion times, assign tasks to employees such that the difference in total performance is minimized. tasks.sort(reverse=True) performance = [0] * n for task in tasks: performance[performance.index(min(performance))] += task return max(performance) - min(performance)"},{"question":"def min_cost_to_remove_all(matrix): Calculate the minimum cost to remove all elements from the matrix by either removing rows or columns. The minimum cost is determined by examining the smallest element in the matrix, since removing the row/column containing the smallest element first leads to the smallest accumulation of costs. Args: matrix (list of list of int): The matrix of non-negative integers. Returns: int: The minimum cost to remove all elements. >>> min_cost_to_remove_all([[3, 2], [4, 1]]) 1 >>> min_cost_to_remove_all([[2, 1, 5], [3, 4, 2], [1, 3, 6]]) 1","solution":"def min_cost_to_remove_all(matrix): Calculate the minimum cost to remove all elements from the matrix by either removing rows or columns. The minimum cost is determined by examining the smallest element in the matrix, since removing the row/column containing the smallest element first leads to the smallest accumulation of costs. Args: matrix (list of list of int): The matrix of non-negative integers. Returns: int: The minimum cost to remove all elements. min_element = min(min(row) for row in matrix) return min_element"},{"question":"def count_unique_substrings_with_k_distinct_characters(S: str, K: int) -> int: Returns the number of unique substrings with exactly K distinct characters in string S. >>> count_unique_substrings_with_k_distinct_characters(\\"abcabc\\", 2) 5 >>> count_unique_substrings_with_k_distinct_characters(\\"aaa\\", 1) 6 def process_input(test_cases: List[Tuple[str, int]]) -> List[int]: Processes a list of test cases and returns the list of results for the number of unique substrings with exactly K distinct characters. >>> process_input([(\\"abcabc\\", 2)]) [5] >>> process_input([(\\"abcabc\\", 2), (\\"aaa\\", 1)]) [5, 6]","solution":"def count_unique_substrings_with_k_distinct_characters(S, K): Returns the number of unique substrings with exactly K distinct characters in string S. import collections def at_most_k_distinct(s, k): \\"Helper function to count the number of substrings with at most K distinct characters.\\" count = collections.Counter() left = 0 total = 0 for right in range(len(s)): count[s[right]] += 1 while len(count) > k: count[s[left]] -= 1 if count[s[left]] == 0: del count[s[left]] left += 1 total += right - left + 1 return total total_k = at_most_k_distinct(S, K) total_k_minus_1 = at_most_k_distinct(S, K - 1) return total_k - total_k_minus_1 def process_input(test_cases): results = [] for S, K in test_cases: results.append(count_unique_substrings_with_k_distinct_characters(S, K)) return results"},{"question":"def countPowerOutage(n: int, edges: List[List[int]], faulty: int) -> int: Determine the number of substations that will lose power including the faulty one. >>> countPowerOutage(6, [[1, 2], [1, 3], [3, 4], [4, 5], [5, 6]], 3) 4 >>> countPowerOutage(4, [], 2) 1 >>> countPowerOutage(2, [[1, 2]], 1) 2 >>> countPowerOutage(5, [[1, 2], [2, 3], [3, 4], [4, 5]], 2) 4 >>> countPowerOutage(5, [[1, 2], [1, 3], [2, 4], [3, 4], [4, 5]], 1) 5 >>> countPowerOutage(7, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]], 2) 3 >>> countPowerOutage(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]], 6) 1","solution":"def countPowerOutage(n, edges, faulty): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for a, b in edges: graph[a].append(b) # Perform BFS to count all reachable nodes from the faulty substation to_visit = deque([faulty]) visited = set([faulty]) while to_visit: current = to_visit.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) to_visit.append(neighbor) return len(visited)"},{"question":"def find_root_value(n: int, leaf_values: List[int]) -> int: Reconstructs the Super Binary Tree and finds the value of the root node from the given leaf values. :param n: Number of leaf nodes (power of 2) :param leaf_values: List containing the values of the leaf nodes :return: Root value of the reconstructed Super Binary Tree Example: >>> find_root_value(4, [2, 3, 5, 8]) 18 >>> find_root_value(2, [7, 8]) 15","solution":"def find_root_value(n, leaf_values): Reconstructs the Super Binary Tree and finds the value of the root node from the given leaf values. :param n: Number of leaf nodes (power of 2) :param leaf_values: List containing the values of the leaf nodes :return: Root value of the reconstructed Super Binary Tree while len(leaf_values) > 1: leaf_values = [leaf_values[i] + leaf_values[i + 1] for i in range(0, len(leaf_values), 2)] return leaf_values[0]"},{"question":"from typing import List, Tuple import math def closest_pair(points: List[Tuple[int, int]]) -> float: Write a function \`closest_pair(points)\` that takes a list of tuples \`points\`, where each tuple consists of two integers representing the coordinates of a point on a 2D plane. The function should return the Euclidean distance between the closest pair of points. >>> closest_pair([(0, 0), (1, 1), (4, 5), (13, 14)]) 1.414214 pass","solution":"from typing import List, Tuple import math def closest_pair(points: List[Tuple[int, int]]) -> float: def calculate_distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def closest_pair_recursive(sorted_x_points, sorted_y_points): n = len(sorted_x_points) if n <= 3: min_dist = float('inf') for i in range(n): for j in range(i + 1, n): min_dist = min(min_dist, calculate_distance(sorted_x_points[i], sorted_x_points[j])) return min_dist mid = n // 2 midpoint = sorted_x_points[mid][0] left_sorted_x = sorted_x_points[:mid] right_sorted_x = sorted_x_points[mid:] left_sorted_y = list(filter(lambda p: p[0] <= midpoint, sorted_y_points)) right_sorted_y = list(filter(lambda p: p[0] > midpoint, sorted_y_points)) min_dist_left = closest_pair_recursive(left_sorted_x, left_sorted_y) min_dist_right = closest_pair_recursive(right_sorted_x, right_sorted_y) min_dist = min(min_dist_left, min_dist_right) strip = [p for p in sorted_y_points if abs(p[0] - midpoint) < min_dist] for i in range(len(strip)): for j in range(i + 1, min(i + 7, len(strip))): min_dist = min(min_dist, calculate_distance(strip[i], strip[j])) return min_dist sorted_x_points = sorted(points, key=lambda x: x[0]) sorted_y_points = sorted(points, key=lambda y: y[1]) return round(closest_pair_recursive(sorted_x_points, sorted_y_points), 6)"},{"question":"def is_valid_name(name: str) -> str: Returns \\"VALID\\" if the name has letters in alphabetical order, otherwise \\"INVALID\\". >>> is_valid_name(\\"abc\\") 'VALID' >>> is_valid_name(\\"cba\\") 'INVALID' >>> is_valid_name(\\"ace\\") 'VALID' def check_names(names: List[str]) -> List[str]: Given a list of names, returns a list of results if each name is valid or not. >>> check_names([\\"abc\\", \\"cba\\", \\"ace\\"]) ['VALID', 'INVALID', 'VALID']","solution":"def is_valid_name(name): Returns \\"VALID\\" if the name has letters in alphabetical order, otherwise \\"INVALID\\". return \\"VALID\\" if name == ''.join(sorted(name)) else \\"INVALID\\" def check_names(names): Given a list of names, returns a list of results if each name is valid or not. return [is_valid_name(name) for name in names]"},{"question":"def total_subscribers(web_dev_weekly, data_science_monthly): Returns the total number of unique students who have subscribed to at least one of the newspapers. :param web_dev_weekly: A list of student roll numbers who subscribed to Web Dev Weekly :param data_science_monthly: A list of student roll numbers who subscribed to Data Science Monthly :return: An integer representing the total number of unique subscribers","solution":"def total_subscribers(web_dev_weekly, data_science_monthly): Returns the total number of unique students who have subscribed to at least one of the newspapers. :param web_dev_weekly: A list of student roll numbers who subscribed to Web Dev Weekly :param data_science_monthly: A list of student roll numbers who subscribed to Data Science Monthly :return: An integer representing the total number of unique subscribers set_web_dev_weekly = set(web_dev_weekly) set_data_science_monthly = set(data_science_monthly) unique_subscribers = set_web_dev_weekly.union(set_data_science_monthly) return len(unique_subscribers)"},{"question":"from typing import List def lexicographically_smallest_string(t: int, strings: List[str]) -> List[str]: Function to find the lexicographically smallest string possible after at most one operation for each input string. Parameters: t (int): Number of test cases. strings (list of str): List containing the strings for each test case. Returns: list of str: List of resulting strings after performing the operation. pass # Unit tests import pytest def test_lexicographically_smallest_string_base_cases(): assert lexicographically_smallest_string(3, [\\"cba\\", \\"acb\\", \\"abc\\"]) == [\\"ba\\", \\"ab\\", \\"ab\\"] def test_lexicographically_smallest_string_single_char(): assert lexicographically_smallest_string(1, [\\"a\\"]) == [\\"\\"] def test_lexicographically_smallest_string_all_same_chars(): assert lexicographically_smallest_string(2, [\\"aaa\\", \\"bbb\\"]) == [\\"aa\\", \\"bb\\"] def test_lexicographically_smallest_string_different_lengths(): assert lexicographically_smallest_string(2, [\\"abcd\\", \\"xyz\\"]) == [\\"abc\\", \\"xy\\"] def test_lexicographically_smallest_string_edge_case(): assert lexicographically_smallest_string(1, [\\"zbcdef\\"]) == [\\"bcdef\\"]","solution":"def lexicographically_smallest_string(t, strings): Function to find the lexicographically smallest string possible after at most one operation for each input string. Parameters: t (int): Number of test cases. strings (list of str): List containing the strings for each test case. Returns: list of str: List of resulting strings after performing the operation. results = [] for s in strings: smallest = min(s[:i] + s[i+1:] for i in range(len(s))) results.append(smallest) return results"},{"question":"from typing import List, Tuple def process_inventory(n: int, q: int, initial_stock: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process inventory operations and return the final stock levels of items. Parameters: n (int): Number of different types of items. q (int): Number of operations. initial_stock (List[int]): Initial stock levels of the items. operations (List[Tuple[int, int, int]]): List of operations to be performed on the inventory. Returns: List[int]: Final stock levels of the items after processing all the operations. Example: >>> process_inventory(5, 3, [10, 20, 30, 40, 50], [(1, 1, 5), (2, 3, 15), (2, 5, 55)]) [15, 20, 15, 40, 0] >>> process_inventory(4, 2, [7, 15, 22, 9], [(1, 2, 5), (2, 1, 8)]) [0, 20, 22, 9]","solution":"def process_inventory(n, q, initial_stock, operations): stock = initial_stock[:] for op in operations: t, x, y = op if t == 1: stock[x - 1] += y elif t == 2: stock[x - 1] = max(0, stock[x - 1] - y) return stock"},{"question":"def minOperations(n: int, nums: List[int]) -> int: Given an integer array nums of length n, determine the minimum number of operations required to make all the elements in the array equal. An operation is defined as picking any two numbers from nums and replacing them with their sum. Args: n (int): The length of the array. nums (List[int]): The list of integer elements. Returns: int: The minimum number of operations required to make all elements in the array equal. >>> minOperations(4, [1, 2, 3, 4]) 3 >>> minOperations(5, [5, 7, 12, 8, 9]) 4 >>> minOperations(1, [10]) 0 >>> minOperations(4, [1000, 2000, 3000, 4000]) 3 >>> minOperations(6, [10, 10, 10, 10, 10, 10]) 5 >>> minOperations(2, [5, 10]) 1","solution":"def minOperations(n, nums): Returns the minimum number of operations required to make all elements in the array nums equal. # The minimum number of operations to make all elements equal # is equal to n-1 where n is the length of the array. return n - 1"},{"question":"def rank_students(arr, N): Sorts students based on their total score, and if total scores are the same, use the student names for comparison. Args: arr (list of lists): List of students where each student is represented as [name, subj1, subj2, subj3] N (int): Number of students Returns: list of tuples: Sorted list of tuples in form (name, total_score) pass # Your implementation here # Example Tests def test_rank_students_case1(): arr = [[\\"Alice\\", 85, 90, 80], [\\"Bob\\", 80, 95, 85], [\\"Charlie\\", 90, 80, 85]] expected = [(\\"Bob\\", 260), (\\"Alice\\", 255), (\\"Charlie\\", 255)] assert rank_students(arr, 3) == expected def test_rank_students_case2(): arr = [[\\"David\\", 70, 75, 80], [\\"Eve\\", 60, 85, 80]] expected = [(\\"David\\", 225), (\\"Eve\\", 225)] assert rank_students(arr, 2) == expected def test_rank_students_case3(): arr = [[\\"Alice\\", 85, 90, 80], [\\"Bob\\", 80, 95, 85], [\\"Charlie\\", 90, 80, 85], [\\"Bob\\", 90, 85, 85]] expected = [(\\"Bob\\", 260), (\\"Bob\\", 260), (\\"Alice\\", 255), (\\"Charlie\\", 255)] assert rank_students(arr, 4) == expected def test_rank_students_solo_student(): arr = [[\\"Alice\\", 85, 90, 80]] expected = [(\\"Alice\\", 255)] assert rank_students(arr, 1) == expected def test_rank_students_all_zero_scores(): arr = [[\\"Alice\\", 0, 0, 0], [\\"Bob\\", 0, 0, 0]] expected = [(\\"Alice\\", 0), (\\"Bob\\", 0)] assert rank_students(arr, 2) == expected","solution":"def rank_students(arr, N): Sorts students based on their total score, and if total scores are the same, use the student names for comparison. Args: arr (list of lists): List of students where each student is represented as [name, subj1, subj2, subj3] N (int): Number of students Returns: list of tuples: Sorted list of tuples in form (name, total_score) # Calculate total scores for each student for student in arr: student.append(sum(student[1:4])) # Sort students by Total score in descending order and by Name in ascending order arr.sort(key=lambda x: (-x[4], x[0])) # Extract sorted results in desired format sorted_students = [(student[0], student[4]) for student in arr] return sorted_students"},{"question":"def replace_numbers_with_squares(strings: List[str], numbers: List[int]) -> List[str]: Replaces all instances of each number in strings with the square of the number. >>> replace_numbers_with_squares([\\"hello1world\\"], [1]) [\\"hello1world\\"] >>> replace_numbers_with_squares([\\"test2case3\\"], [2, 3]) [\\"test4case9\\"] >>> replace_numbers_with_squares([\\"a1b2c3d4\\"], [1, 4]) [\\"a1b2c3d16\\"] >>> replace_numbers_with_squares([\\"hello\\", \\"world\\"], [1, 2, 3]) [\\"hello\\", \\"world\\"] >>> replace_numbers_with_squares([\\"zero0test\\"], [0]) [\\"zero0test\\"] >>> replace_numbers_with_squares([\\"123\\"], [1, 2, 3]) [\\"149\\"]","solution":"def replace_numbers_with_squares(strings, numbers): Replaces all instances of each number in strings with the square of the number. Parameters: strings (list of str): The list of strings to process. numbers (list of int): The list of distinct numbers whose squares will replace their occurrences in the provided strings. Returns: list of str: The modified strings. # Create a dictionary for quick lookup of the squared values square_map = {str(num): str(num ** 2) for num in numbers} # Replace numbers with their squares in each string result = [] for s in strings: for num_str, num_square in square_map.items(): s = s.replace(num_str, num_square) result.append(s) return result"},{"question":"def min_coins(n: int, denominations: List[int], target: int) -> int: Calculate the minimum number of coins required to make the target amount. Parameters: n: int - the number of available coin denominations denominations: list of int - the values of the n denominations target: int - the target amount in cents Returns: int - the minimum number of coins required to make the target amount, or -1 if it is not possible to make the target amount pass def test_min_coins_example_1(): assert min_coins(3, [1, 2, 5], 11) == 3 def test_min_coins_example_2(): assert min_coins(2, [5, 10], 3) == -1 def test_min_coins_single_coin(): assert min_coins(1, [1], 10) == 10 def test_min_coins_exactly_possible(): assert min_coins(2, [2, 5], 7) == 2 # 5 + 2 def test_min_coins_not_possible(): assert min_coins(2, [4, 5], 7) == -1 def test_min_coins_large_target(): assert min_coins(3, [1, 50, 100], 200) == 2 # 100 + 100 def test_min_coins_no_denominations(): assert min_coins(1, [], 5) == -1","solution":"def min_coins(n, denominations, target): Calculate the minimum number of coins required to make the target amount. Parameters: n: int - the number of available coin denominations denominations: list of int - the values of the n denominations target: int - the target amount in cents Returns: int - the minimum number of coins required to make the target amount, or -1 if it is not possible to make the target amount # Create a list to store min number of coins for each amount from 0 to target dp = [float('inf')] * (target + 1) # Base case: no coins are needed to make 0 amount dp[0] = 0 # Determine the minimum number of coins required for each amount for amount in range(1, target + 1): for coin in denominations: if coin <= amount: dp[amount] = min(dp[amount], dp[amount - coin] + 1) # If dp[target] is still infinity, it means the target amount cannot be made with given denominations return dp[target] if dp[target] != float('inf') else -1"},{"question":"def can_complete_walks(T: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[str]: Determine if the senior citizens' walking group can complete their walks without exceeding their energy thresholds on any day. >>> test_case_1() >>> test_minimal_input() >>> test_maximal_energy() >>> test_exceeding_threshold() >>> test_all_thresholds_met()","solution":"def can_complete_walks(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] energy_required = test_cases[i][1] energy_thresholds = test_cases[i][2] max_energy_required = max(energy_required) if all(threshold >= max_energy_required for threshold in energy_thresholds): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def knapsack(n, W, items): Given the number of items n, the capacity of the knapsack W, and a list of tuples where each tuple contains (weight, value), this function returns the maximum value that can be achieved within the given constraints. Args: n (int): Number of items. W (int): Capacity of the knapsack. items (list of tuple): List of tuples where each tuple contains (weight, value). Returns: int: The maximum value that can be achieved. Examples: >>> knapsack(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack(2, 5, [(3, 20), (2, 15)]) 35 from solution import knapsack def test_knapsack_example1(): n = 4 W = 10 items = [(5, 10), (4, 40), (6, 30), (3, 50)] assert knapsack(n, W, items) == 90 def test_knapsack_example2(): n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 220 def test_knapsack_example3(): n = 2 W = 5 items = [(3, 20), (2, 15)] assert knapsack(n, W, items) == 35 def test_knapsack_single_item(): n = 1 W = 10 items = [(5, 50)] assert knapsack(n, W, items) == 50 def test_knapsack_no_items(): n = 0 W = 10 items = [] assert knapsack(n, W, items) == 0 def test_knapsack_capacity_zero(): n = 3 W = 0 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 0 def test_knapsack_items_exceed_capacity(): n = 3 W = 5 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 0","solution":"def knapsack(n, W, items): Given the number of items n, the capacity of the knapsack W, and a list of tuples where each tuple contains (weight, value), this function returns the maximum value that can be achieved within the given constraints. dp = [0] * (W + 1) for i in range(n): weight, value = items[i] # Traverse the dp array backwards to ensure we do not use an item more than once for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W]"},{"question":"from typing import List, Tuple def manage_borrowing(b: int, s: int, r: int, books_info: List[Tuple[int, int]], students_info: List[Tuple[int, int]], requests_info: List[Tuple[int, int, int]]) -> List[str]: Determine the borrowing schedule for a set of book borrowing requests. Args: b: Number of books. s: Number of students. r: Number of borrowing requests. books_info: List of tuples containing book identifier and number of copies available. students_info: List of tuples containing student identifier and priority level. requests_info: List of tuples containing timestamp, student identifier, and book identifier. Returns: List of strings representing the status of each borrowing request in chronological order. pass # implementation goes here def test_manage_borrowing(): books_info = [(1, 2), (2, 1)] students_info = [(1, 10), (2, 5), (3, 20)] requests_info = [(1, 2, 1), (2, 1, 2), (3, 1, 2), (4, 3, 1), (5, 2, 1)] result = manage_borrowing(2, 3, 5, books_info, students_info, requests_info) assert result == [\\"borrowed\\", \\"borrowed\\", \\"waitlisted\\", \\"borrowed\\", \\"waitlisted\\"] def test_manage_borrowing_invalid_requests(): books_info = [(1, 1), (2, 2)] students_info = [(1, 10), (2, 5)] requests_info = [(1, 3, 1), (2, 1, 3)] result = manage_borrowing(2, 2, 2, books_info, students_info, requests_info) assert result == [\\"invalid request\\", \\"invalid request\\"] def test_manage_borrowing_all_waitlisted(): books_info = [(1, 1)] students_info = [(1, 10), (2, 5)] requests_info = [(1, 1, 1), (2, 2, 1)] result = manage_borrowing(1, 2, 2, books_info, students_info, requests_info) assert result == [\\"borrowed\\", \\"waitlisted\\"] def test_manage_borrowing_with_priorities(): books_info = [(1, 1)] students_info = [(1, 10), (2, 5), (3, 20)] requests_info = [(1, 1, 1), (2, 2, 1), (3, 3, 1)] result = manage_borrowing(1, 3, 3, books_info, students_info, requests_info) assert result == [\\"borrowed\\", \\"waitlisted\\", \\"waitlisted\\"]","solution":"from collections import defaultdict, deque def manage_borrowing(b, s, r, books_info, students_info, requests_info): books = {} students = {} # Populate books data for id_b, c in books_info: books[id_b] = {'copies': c, 'waitlist': deque()} # Populate students data for id_s, priority in students_info: students[id_s] = priority borrowings = {} result = [] for t, id_s, id_b in requests_info: if id_b not in books or id_s not in students: result.append(\\"invalid request\\") continue priority = students[id_s] # If book is available, borrow it if books[id_b]['copies'] > 0: books[id_b]['copies'] -= 1 borrowings[(t, id_s, id_b)] = priority result.append(\\"borrowed\\") else: books[id_b]['waitlist'].append((priority, t, id_s, id_b)) result.append(\\"waitlisted\\") return result"},{"question":"def determine_winner(scorers, names): Determines the winner(s) of the dessert competition. Parameters: scorers (list of list of int): A list of N lists, each containing 12 integers representing weekly scores. names (list of str): A list of N names corresponding to the participants. Returns: str: The name(s) of the winner(s), separated by spaces if there are ties. >>> determine_winner([[7, 8, 9, 4, 5, 6, 9, 8, 4, 5, 7, 6], [5, 6, 8, 9, 7, 6, 7, 8, 9, 4, 6, 8], [8, 9, 7, 4, 6, 5, 8, 9, 6, 7, 5, 4]], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) == \\"Bob\\" >>> determine_winner([[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9]], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) == \\"Alice Bob\\" >>> determine_winner([[7, 8, 9, 6, 5, 4, 9, 9, 8, 7, 6, 5], [8, 9, 9, 6, 7, 5, 8, 7, 9, 6, 7, 8]], [\\"Diane\\", \\"Edward\\"]) == \\"Edward\\" >>> determine_winner([[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]], [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) == \\"Alice Bob Charlie\\" >>> determine_winner([[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 10, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 1]], [\\"Alice\\", \\"Bob\\"]) == \\"Alice\\"","solution":"def determine_winner(scorers, names): Determines the winner(s) of the dessert competition. Parameters: scorers (list of list of int): A list of N lists, each containing 12 integers representing weekly scores. names (list of str): A list of N names corresponding to the participants. Returns: str: The name(s) of the winner(s), separated by spaces if there are ties. # Compute the total score for each participant total_scores = [sum(scores) for scores in scorers] # Determine the highest score max_score = max(total_scores) # Find all participants with the highest score winners = [names[i] for i, score in enumerate(total_scores) if score == max_score] # Return names of winners as a single string return \\" \\".join(winners)"},{"question":"def minimize_sweetness_differences(cakes: List[List[int]]) -> List[int]: Help Maria arrange the layers of each cake such that the sum of the absolute differences of sweetness between all consecutive layers is minimized. Args: cakes: A list of cakes, where each cake is represented as a list of integers. Each sublist contains the number of layers followed by the sweetness factors of the layers. Returns: A list of integers where each integer is the minimized total sweetness difference for the corresponding cake. Examples: >>> minimize_sweetness_differences([[3, 1, 5, 3], [2, 8, 2], [4, 10, 1, 4, 9]]) [4, 6, 9] >>> minimize_sweetness_differences([[1, 5], [2, 2, 8], [3, 5, 1, 3]]) [0, 6, 4]","solution":"def minimize_sweetness_differences(cakes): results = [] for cake in cakes: mi = cake[0] layers = sorted(cake[1:]) total_diff = 0 for i in range(len(layers) - 1): total_diff += abs(layers[i] - layers[i + 1]) results.append(total_diff) return results"},{"question":"from typing import List def uniquePermutations(S: str) -> List[str]: Returns a list of all unique permutations of the given string in lexicographical order. >>> uniquePermutations(\\"ABC\\") [\\"ABC\\", \\"ACB\\", \\"BAC\\", \\"BCA\\", \\"CAB\\", \\"CBA\\"] >>> uniquePermutations(\\"AAB\\") [\\"AAB\\", \\"ABA\\", \\"BAA\\"] pass","solution":"from itertools import permutations def uniquePermutations(S): Returns a list of all unique permutations of the given string in lexicographical order. perms = set(permutations(S)) unique_perms = sorted([''.join(p) for p in perms]) return unique_perms"},{"question":"def canFormPalindrome(s: str) -> bool: Check if the string can form a valid palindrome by removing exactly one character. >>> canFormPalindrome(\\"abca\\") True >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"abc\\") False","solution":"def canFormPalindrome(s: str) -> bool: def isPalindromeRange(i, j): while i < j: if s[i] != s[j]: return False i, j = i + 1, j - 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return isPalindromeRange(left + 1, right) or isPalindromeRange(left, right - 1) left, right = left + 1, right - 1 return True"},{"question":"def count_primes_and_max_gap(X: int, Y: int) -> (int, int): Count the number of prime numbers between X and Y, and find the maximum prime gap in this range. >>> count_primes_and_max_gap(10, 30) (6, 6) >>> count_primes_and_max_gap(14, 16) (0, 0) >>> count_primes_and_max_gap(14, 17) (1, 0) >>> count_primes_and_max_gap(17, 19) (2, 2) >>> count_primes_and_max_gap(2, 100) (25, 8)","solution":"def count_primes_and_max_gap(X, Y): def is_prime(n): if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True primes = [num for num in range(X, Y + 1) if is_prime(num)] if len(primes) < 2: return len(primes), 0 max_gap = max(primes[i + 1] - primes[i] for i in range(len(primes) - 1)) return len(primes), max_gap"},{"question":"def kidsWithCandies(nums, extraCandies): Determine whether giving extraCandies to each child would allow them to have the greatest number of candies among all the children. :param nums: List of integers representing the number of candies each child has. :param extraCandies: Integer representing the extra candies. :return: List of boolean values. >>> kidsWithCandies([2, 3, 5, 1, 3], 3) [True, True, True, False, True] >>> kidsWithCandies([4, 2, 1, 1, 2], 1) [True, False, False, False, False] >>> kidsWithCandies([12, 1, 12], 10) [True, False, True] >>> kidsWithCandies([1, 2, 3, 4, 5], 10) [True, True, True, True, True] >>> kidsWithCandies([1, 1, 1, 1], 0) [True, True, True, True] >>> kidsWithCandies([1, 2, 3, 4, 5], 0) [False, False, False, False, True]","solution":"def kidsWithCandies(nums, extraCandies): Determine whether giving extraCandies to each child would allow them to have the greatest number of candies among all the children. :param nums: List of integers representing the number of candies each child has. :param extraCandies: Integer representing the extra candies. :return: List of boolean values. max_candies = max(nums) result = [(candies + extraCandies) >= max_candies for candies in nums] return result"},{"question":"from typing import List, Tuple def mergeTimeSlots(slots: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping time slots in the provided list of time slots (slots). Args: slots (List[Tuple[int, int]]): List of tuples representing start and end times of time slots in 24-hour format. Returns: List[Tuple[int, int]]: List of merged time slots sorted by start times. Examples: >>> mergeTimeSlots([(9, 11), (13, 16), (10, 12), (15, 18)]) [(9, 12), (13, 18)] >>> mergeTimeSlots([(10, 11), (12, 13)]) [(10, 11), (12, 13)]","solution":"from typing import List, Tuple def mergeTimeSlots(slots: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not slots: return [] # Sort the slots by starting time slots.sort(key=lambda x: x[0]) merged = [] # Start with the first time slot current_start, current_end = slots[0] for start, end in slots[1:]: # If the current slot overlaps with the previous, merge them if start <= current_end: current_end = max(current_end, end) else: # Otherwise, add the previous slot to merged and start a new one merged.append((current_start, current_end)) current_start, current_end = start, end # Add the last slot merged.append((current_start, current_end)) return merged"},{"question":"def replace_words(s: str, d: dict) -> str: Replace each word in string 's' that matches a key in dictionary 'd' with its corresponding definition. >>> replace_words(\\"I love programming because it is fun and challenging\\", {\\"love\\": \\"enjoy greatly\\", \\"programming\\": \\"the act of writing computer programs\\", \\"fun\\": \\"enjoyment or amusement\\"}) \\"I enjoy greatly the act of writing computer programs because it is enjoyment or amusement and challenging\\" >>> replace_words(\\"Learning to code is an excellent skill\\", {\\"Learning\\": \\"Acquiring knowledge\\", \\"code\\": \\"write computer programs\\", \\"excellent\\": \\"outstanding\\"}) \\"Acquiring knowledge to write computer programs is an outstanding skill\\" >>> replace_words(\\"Walking is a good exercise\\", {\\"running\\": \\"moving fast on foot\\", \\"jumping\\": \\"leaping into the air\\"}) \\"Walking is a good exercise\\" >>> replace_words(\\"fast jump\\", {\\"fast\\": \\"quickly\\", \\"jump\\": \\"leap into the air\\"}) \\"quickly leap into the air\\" >>> replace_words(\\"\\", {\\"empty\\": \\"nothing\\"}) \\"\\"","solution":"def replace_words(s, d): Replace each word in string 's' that matches a key in dictionary 'd' with its corresponding definition. words = s.split() for i, word in enumerate(words): if word in d: words[i] = d[word] return \\" \\".join(words)"},{"question":"from typing import List, Tuple def safe_cracking(): Helps Limak to find the correct 4-digit combination of a safe lock within 15 queries. - Each guess is a 4-digit integer. - After each guess, receives two integers \`a\` and \`b\`: - \`a\`: Number of digits in the correct position. - \`b\`: Number of correct digits but in wrong positions. Examples: Input: 0 2 1 1 2 0 Output: 4321 1234 1245 pass def is_valid_guess(guess: str, combination: str, a: int, b: int) -> bool: Checks if a guess conforms to the given response a and b. >>> is_valid_guess('1234', '1243', 2, 2) True >>> is_valid_guess('1234', '5678', 0, 0) True >>> is_valid_guess('1234', '4321', 0, 4) True >>> is_valid_guess('1234', '1234', 4, 0) True >>> is_valid_guess('1234', '5671', 0, 1) True >>> is_valid_guess('1234', '5678', 1, 0) False >>> is_valid_guess('1234', '5678', 0, 1) False >>> is_valid_guess('1234', '1235', 4, 0) False >>> is_valid_guess('1234', '1123', 4, 0) False pass","solution":"import itertools # The main function which tries to guess the combination def safe_cracking(): possible_combinations = [str(x).zfill(4) for x in range(1000, 10000)] queries = 15 for _ in range(queries): guess = possible_combinations.pop(0) print(guess) a, b = map(int, input().split()) if a == 4: return possible_combinations = [ combination for combination in possible_combinations if is_valid_guess(guess, combination, a, b) ] def is_valid_guess(guess, combination, a, b): correct_pos = sum(g == c for g, c in zip(guess, combination)) correct_digit = sum(min(guess.count(d), combination.count(d)) for d in set(guess)) - correct_pos return correct_pos == a and correct_digit == b"},{"question":"def check_double_pattern(n, sequence): Returns 'Yes' if each number in the sequence (except the first one) is the double of the previous number, otherwise 'No' >>> check_double_pattern(4, [2, 4, 8, 16]) == 'Yes' >>> check_double_pattern(5, [3, 6, 12, 24, 50]) == 'No'","solution":"def check_double_pattern(n, sequence): Returns 'Yes' if each number in the sequence (except the first one) is the double of the previous number, otherwise 'No' for i in range(1, n): if sequence[i] != 2 * sequence[i-1]: return 'No' return 'Yes'"},{"question":"def max_sum_subarray_of_length_k(N, K, arr): Finds the maximum possible sum of a subarray of length K. Parameters: N (int): Length of the array. K (int): Length of the subarray. arr (List[int]): List of integers. Returns: int: The maximum possible sum of a subarray of length K. >>> max_sum_subarray_of_length_k(6, 3, [1, 2, 3, 4, 5, 6]) 15 >>> max_sum_subarray_of_length_k(5, 2, [3, 2, 5, 1, 6]) 7 >>> max_sum_subarray_of_length_k(7, 4, [1, -1, 5, 7, -2, 3, -4]) 13 >>> max_sum_subarray_of_length_k(8, 3, [2, 1, 4, 5, 6, 1, -1, 3]) 15 >>> max_sum_subarray_of_length_k(4, 2, [-1, -2, -3, -4]) -3 from solution import max_sum_subarray_of_length_k def test_max_sum_subarray_of_length_k(): assert max_sum_subarray_of_length_k(6, 3, [1, 2, 3, 4, 5, 6]) == 15 assert max_sum_subarray_of_length_k(5, 2, [3, 2, 5, 1, 6]) == 7 assert max_sum_subarray_of_length_k(7, 4, [1, -1, 5, 7, -2, 3, -4]) == 13 assert max_sum_subarray_of_length_k(8, 3, [2, 1, 4, 5, 6, 1, -1, 3]) == 15 assert max_sum_subarray_of_length_k(4, 2, [-1, -2, -3, -4]) == -3 def test_max_sum_subarray_of_length_k_edge_cases(): assert max_sum_subarray_of_length_k(1, 1, [5]) == 5 assert max_sum_subarray_of_length_k(2, 1, [7, -3]) == 7 assert max_sum_subarray_of_length_k(3, 1, [10, 20, 30]) == 30 assert max_sum_subarray_of_length_k(3, 3, [1, 2, 3]) == 6 def test_max_sum_subarray_of_length_k_large_elements(): assert max_sum_subarray_of_length_k(5, 3, [1000000000, -1000000000, 1000000000, -1000000000, 1000000000]) == 1000000000","solution":"def max_sum_subarray_of_length_k(N, K, arr): Finds the maximum possible sum of a subarray of length K. current_sum = sum(arr[:K]) max_sum = current_sum for i in range(K, N): current_sum = current_sum + arr[i] - arr[i - K] max_sum = max(max_sum, current_sum) return max_sum if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) K = int(data[1]) arr = list(map(int, data[2:])) print(max_sum_subarray_of_length_k(N, K, arr))"},{"question":"def findPairWithSum(arr: List[int], target: int) -> Tuple[int, int]: You are given an array of integers and a target integer. Write a function findPairWithSum(arr, target) that returns a tuple of two integers from the array whose sum is equal to the target value. If there are multiple such pairs, return any one of them. If no such pair exists, return an empty tuple. >>> findPairWithSum([2, 7, 11, 15], 9) (2, 7) >>> findPairWithSum([1, 4, 5, 6, 8], 7) (1, 6) >>> findPairWithSum([1, 2, 3, 4, 5], 10) ()","solution":"def findPairWithSum(arr, target): Returns a tuple of two integers from the array whose sum is equal to the target value. If no such pair exists, return an empty tuple. seen = {} for number in arr: complement = target - number if complement in seen: return (complement, number) seen[number] = True return ()"},{"question":"def min_days_for_workshops(n: int, workshops: List[Tuple[int, int]]) -> int: Determine the minimum number of days required to conduct all the workshops without any overlap. Parameters: n (int): Number of workshops. workshops (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, t and d, where t is the starting time slot of the workshop and d is its duration. Returns: int: The minimum number of days required to host all the workshops without overlap. Examples: >>> min_days_for_workshops(3, [(1, 4), (2, 3), (4, 1)]) 2 >>> min_days_for_workshops(2, [(1, 3), (3, 2)]) 1 from typing import List, Tuple def test_case_1(): n = 3 workshops = [(1, 4), (2, 3), (4, 1)] assert min_days_for_workshops(n, workshops) == 2 def test_case_2(): n = 2 workshops = [(1, 3), (3, 2)] assert min_days_for_workshops(n, workshops) == 1 def test_case_3(): n = 1 workshops = [(1, 1)] assert min_days_for_workshops(n, workshops) == 1 def test_case_4(): n = 4 workshops = [(1, 2), (3, 3), (6, 1), (5, 1)] assert min_days_for_workshops(n, workshops) == 1 def test_case_5(): n = 5 workshops = [(1, 4), (2, 1), (5, 3), (6, 2), (10, 1)] assert min_days_for_workshops(n, workshops) == 2","solution":"def min_days_for_workshops(n, workshops): # Sort workshops by their starting time workshops.sort(key=lambda x: x[0]) days = [] for t, d in workshops: placed = False # Check each day if we can place the current workshop without overlap for day in days: if day[-1] <= t: day.append(t + d - 1) placed = True break if not placed: # If it can't be placed in existing days, we need a new day days.append([t + d - 1]) return len(days)"},{"question":"from typing import List def find_first_above_average(numbers: List[int]) -> int: Given a list of integers, returns the first integer that is greater than the average of the entire list. If no such integer exists, returns -1. >>> find_first_above_average([1, 2, 3, 4, 5]) 4 >>> find_first_above_average([10, 10, 10, 10]) -1 >>> find_first_above_average([1, 3, 2, 6, 4, 5]) 6 >>> find_first_above_average([]) -1","solution":"from typing import List def find_first_above_average(numbers: List[int]) -> int: Returns the first integer in the list that is greater than the average of the list. If no such integer exists, returns -1. if not numbers: return -1 average = sum(numbers) / len(numbers) for number in numbers: if number > average: return number return -1"},{"question":"import math def total_time_to_complete_marathon(lengths, speeds): Given the lengths of each part of the marathon and the corresponding speeds of each friend, determine the total time it will take for each friend to complete the entire marathon, rounded up to the nearest whole number. Parameters: lengths (list): List of integers representing the lengths of each part of the marathon. speeds (list): List of integers representing the speeds of each friend in each part of the marathon. Returns: list: List of integers where each integer represents the total time in hours rounded up to the nearest whole number it took each friend to complete the marathon. Example: >>> total_time_to_complete_marathon([3, 6, 9], [1, 2, 3]) [3, 3, 3] >>> total_time_to_complete_marathon([10, 20, 30], [5, 5, 5]) [2, 4, 6] >>> total_time_to_complete_marathon([10, 15, 25], [5, 3, 10]) [2, 5, 3] >>> total_time_to_complete_marathon([1000, 800, 1200], [100, 200, 300]) [10, 4, 4]","solution":"import math def total_time_to_complete_marathon(lengths, speeds): Given the lengths of each part of the marathon and the corresponding speeds of each friend, determine the total time it will take for each friend to complete the entire marathon, rounded up to the nearest whole number. Parameters: lengths (list): List of integers representing the lengths of each part of the marathon. speeds (list): List of integers representing the speeds of each friend in each part of the marathon. Returns: list: List of integers where each integer represents the total time in hours rounded up to the nearest whole number it took each friend to complete the marathon. n = len(lengths) # number of parts in the marathon total_time = [] for i in range(n): time = lengths[i] / speeds[i] total_time.append(math.ceil(time)) return total_time"},{"question":"def can_deliver_all_items(n: int, warehouse_item_pairs: List[Tuple[int, int]], m: int, delivery_orders: List[int]) -> str: Determine if it's possible to deliver all items while visiting each warehouse at most once. >>> can_deliver_all_items(3, [(1, 2), (2, 3), (3, 4)], 4, [2, 3, 4, 2]) 'No' >>> can_deliver_all_items(3, [(1, 2), (2, 3), (4, 5)], 3, [2, 3, 5]) 'Yes' >>> can_deliver_all_items(2, [(1, 2), (2, 3)], 3, [2, 3, 2]) 'No' >>> can_deliver_all_items(1, [(1, 1)], 1, [1]) 'Yes' >>> can_deliver_all_items(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 5, [1, 2, 3, 4, 5]) 'Yes' >>> can_deliver_all_items(4, [(1, 2), (1, 3), (2, 4), (3, 5)], 4, [2, 3, 4, 5]) 'No'","solution":"def can_deliver_all_items(n, warehouse_item_pairs, m, delivery_orders): warehouse_visit_count = {} item_to_warehouse = {item: warehouse for warehouse, item in warehouse_item_pairs} for item in delivery_orders: warehouse = item_to_warehouse[item] if warehouse in warehouse_visit_count: return \\"No\\" warehouse_visit_count[warehouse] = True return \\"Yes\\""},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_circular_linked_list(head): Function to check if a linked list is circular. :param head: ListNode, the head of the linked list :return: True if the linked list is circular, False otherwise # Write your solution here pass # Helper function to create linked list from list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head def check_circular_linked_lists(test_cases): results = [] for n, values in test_cases: head = create_linked_list(values) if n > 0: current = head while current.next: current = current.next # If the last node points to the first node if current.val == head.val: # Assuming circular means last node points to first node current.next = head if is_circular_linked_list(head): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def test_is_circular_linked_list(): # Test case 1: Non-circular list head = create_linked_list([1, 2, 3, 4, 5]) assert not is_circular_linked_list(head), \\"Error in test case 1: Non-circular list\\" # Test case 2: Circular list head = create_linked_list([7, 8, 9]) current = head while current.next is not None: current = current.next current.next = head # making it circular assert is_circular_linked_list(head), \\"Error in test case 2: Circular list\\" # Test case 3: Empty list head = create_linked_list([]) assert not is_circular_linked_list(head), \\"Error in test case 3: Empty list\\" # Test case 4: Single node circular list head = create_linked_list([1]) head.next = head # making it circular assert is_circular_linked_list(head), \\"Error in test case 4: Single node circular list\\" # Test case 5: Single node non-circular list head = create_linked_list([1]) assert not is_circular_linked_list(head), \\"Error in test case 5: Single node non-circular list\\" def test_check_circular_linked_lists(): test_cases = [ (5, [1, 2, 3, 4, 5]), (3, [7, 8, 9]), (4, [10, 20, 30, 40]) ] expected_results = [\\"NO\\", \\"NO\\", \\"NO\\"] assert check_circular_linked_lists(test_cases) == expected_results, \\"Error in test_check_circular_linked_lists\\" test_cases = [ (1, [1]), (1, [2]) ] expected_results = [\\"YES\\", \\"YES\\"] # Assumed that a single node would be circular by definition. assert check_circular_linked_lists(test_cases) == expected_results, \\"Error in single node test cases\\"","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def is_circular_linked_list(head): Function to check if a linked list is circular. :param head: ListNode, the head of the linked list :return: True if the linked list is circular, False otherwise if not head: return False slow_ptr = head fast_ptr = head # Using Floyd's Tortoise and Hare algorithm to detect cycle while fast_ptr is not None and fast_ptr.next is not None: slow_ptr = slow_ptr.next fast_ptr = fast_ptr.next.next if slow_ptr == fast_ptr: return True return False # Helper function to create linked list from list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for val in values[1:]: current.next = ListNode(val) current = current.next return head def check_circular_linked_lists(test_cases): results = [] for n, values in test_cases: head = create_linked_list(values) if n > 0: current = head while current.next: current = current.next # If the last node points to the first node if current.val == head.val: # Assuming circular means last node points to first node current.next = head if is_circular_linked_list(head): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maxFruits(stalls: List[int]) -> int: This function returns the maximum number of consecutive stalls one can visit buying at most two different types of fruits. :param stalls: List[int] A list of integers where each integer represents a type of fruit. :return: int The maximum number of consecutive stalls with at most two types of fruits. >>> maxFruits([1, 2, 1, 2, 3, 2, 2, 1]) 4 >>> maxFruits([1, 1, 1, 1, 1]) 5 >>> maxFruits([1, 2, 1, 2, 2, 2, 1, 1, 1]) 9 >>> maxFruits([1, 2, 3, 2, 2]) 4 >>> maxFruits([1, 2] * 50000) 100000 >>> maxFruits([]) 0 from solution import maxFruits def test_example(): assert maxFruits([1, 2, 1, 2, 3, 2, 2, 1]) == 4 def test_all_same_fruit(): assert maxFruits([1, 1, 1, 1, 1]) == 5 def test_two_fruit_types(): assert maxFruits([1, 2, 1, 2, 2, 2, 1, 1, 1]) == 9 def test_three_fruit_types(): assert maxFruits([1, 2, 3, 2, 2]) == 4 def test_max_length_boundary(): assert maxFruits([1, 2] * 50000) == 100000 def test_empty_list(): assert maxFruits([]) == 0 def test_one_stall(): assert maxFruits([1]) == 1 def test_large_input(): stalls = [1] * 99999 + [2] assert maxFruits(stalls) == 100000","solution":"def maxFruits(stalls): This function returns the maximum number of consecutive stalls one can visit buying at most two different types of fruits. :param stalls: List[int] A list of integers where each integer represents a type of fruit. :return: int The maximum number of consecutive stalls with at most two types of fruits. from collections import defaultdict max_length = 0 left = 0 fruit_counter = defaultdict(int) for right in range(len(stalls)): fruit_counter[stalls[right]] += 1 while len(fruit_counter) > 2: fruit_counter[stalls[left]] -= 1 if fruit_counter[stalls[left]] == 0: del fruit_counter[stalls[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_traversable(heights: list) -> bool: Check if it is possible to traverse from the first pillar to the last pillar without ever stepping down to a lower pillar. Parameters: heights (list): A list of integers representing the heights of the pillars. Returns: bool: True if it is possible to traverse without stepping down, False otherwise. >>> is_traversable([1, 2, 2, 3]) True >>> is_traversable([3, 2, 5, 6]) False >>> is_traversable([1, 3, 3, 5, 5, 5, 7]) True >>> is_traversable([1]) True >>> is_traversable([1, 2, 3, 4, 5]) True >>> is_traversable([5, 5, 5, 5, 5]) True >>> is_traversable([5, 4, 3, 2, 1]) False >>> is_traversable([1, 2, 3, 1, 5]) False >>> is_traversable([1000000000, 1000000000, 1000000001]) True","solution":"def is_traversable(heights): Check if it is possible to traverse from the first pillar to the last pillar without ever stepping down to a lower pillar. Parameters: heights (list): A list of integers representing the heights of the pillars. Returns: bool: True if it is possible to traverse without stepping down, False otherwise. n = len(heights) for i in range(1, n): if heights[i] < heights[i - 1]: return False return True"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in the list that add up to the target. If no such indices exist, returns an empty list. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4], 8) []","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. If no such indices exist, returns an empty list. indices_map = {} for i, num in enumerate(nums): complement = target - num if complement in indices_map: return [indices_map[complement], i] indices_map[num] = i return []"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within arr. The function should take a list of integers (arr) as input and return a single integer, which is the maximum sum of any contiguous subarray within the list. Example: >>> max_subarray_sum([8, -19, 5, -4, 20]) 21 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 pass from solution import max_subarray_sum def test_single_element(): assert max_subarray_sum([1]) == 1 assert max_subarray_sum([-1]) == -1 def test_all_positive_elements(): assert max_subarray_sum([1, 2, 3, 4]) == 10 def test_all_negative_elements(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_mixed_elements(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([8, -19, 5, -4, 20]) == 21 def test_large_elements(): assert max_subarray_sum([100000, -1, 100000]) == 199999 assert max_subarray_sum([-100000, 100000, -100000]) == 100000","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within arr. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def can_transform_to_palindrome(s: str, k: int) -> str: Determine if the given string can be transformed into a palindrome by changing at most K characters. >>> can_transform_to_palindrome(\\"abca\\", 1) \\"YES\\" >>> can_transform_to_palindrome(\\"abcd\\", 1) \\"NO\\" >>> can_transform_to_palindrome(\\"abcde\\", 2) \\"YES\\" pass def process_test_cases(t: int, test_cases: List[Tuple[str, int]]) -> List[str]: Process multiple test cases to determine if each string can be transformed into a palindrome. >>> process_test_cases(3, [(\\"abca\\", 1), (\\"abcd\\", 1), (\\"abcde\\", 2)]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass from solution import can_transform_to_palindrome, process_test_cases def test_can_transform_to_palindrome(): assert can_transform_to_palindrome(\\"abca\\", 1) == \\"YES\\" assert can_transform_to_palindrome(\\"abcd\\", 1) == \\"NO\\" assert can_transform_to_palindrome(\\"abcde\\", 2) == \\"YES\\" assert can_transform_to_palindrome(\\"ab\\", 1) == \\"YES\\" assert can_transform_to_palindrome(\\"a\\", 0) == \\"YES\\" assert can_transform_to_palindrome(\\"racecar\\", 0) == \\"YES\\" assert can_transform_to_palindrome(\\"racecar\\", 1) == \\"YES\\" assert can_transform_to_palindrome(\\"abcdefgh\\", 4) == \\"YES\\" assert can_transform_to_palindrome(\\"abcdefgh\\", 3) == \\"NO\\" def test_process_test_cases(): test_cases = [ (\\"abca\\", 1), (\\"abcd\\", 1), (\\"abcde\\", 2) ] assert process_test_cases(3, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases = [ (\\"racecar\\", 0), (\\"racecar\\", 1), (\\"abcd\\", 2), (\\"abcdefgh\\", 3) ] assert process_test_cases(4, test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_transform_to_palindrome(s, k): # Calculate number of changes needed to make the string a palindrome mismatch_count = 0 n = len(s) for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 # Check if the mismatches can be covered within k changes if mismatch_count <= k: return \\"YES\\" else: return \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): s, k = test_cases[i] k = int(k) result = can_transform_to_palindrome(s, k) results.append(result) return results"},{"question":"def min_height_difference(n: int, heights: List[int]) -> int: Returns the minimum possible difference between the height of the tallest block and the shortest block after performing any number of operations. :param n: int - number of blocks :param heights: list of int - initial heights of the blocks :return: int - min possible height difference >>> min_height_difference(1, [5]) 0 >>> min_height_difference(5, [4, 7, 2, 8, 5]) 0 >>> min_height_difference(3, [1, 3, 5]) 0 >>> min_height_difference(4, [5, 5, 5, 5]) 0 >>> min_height_difference(6, [10, 7, 12, 23, 6, 15]) 0 >>> min_height_difference(6, [7, 7, 7, 7, 7, 7]) 0","solution":"def min_height_difference(n, heights): Returns the minimum possible difference between the height of the tallest block and the shortest block after performing any number of operations. :param n: int - number of blocks :param heights: list of int - initial heights of the blocks :return: int - min possible height difference # As you can always increase any block, the minimum difference is achieved by making all blocks # equal to the height of the tallest block return 0"},{"question":"def filter_primes(input_list): Returns a new list containing only the prime numbers from the original list. >>> filter_primes([2, 3, 5, 7, 11]) == [2, 3, 5, 7, 11] >>> filter_primes([4, 6, 8, 9, 10]) == [] >>> filter_primes([2, 3, 4, 5, 10, 13, 15]) == [2, 3, 5, 13] >>> filter_primes([]) == [] >>> filter_primes([-3, -2, -1, 0, 1]) == [] >>> filter_primes([29, 31, 37, 41, 43, 47, 48, 49, 50, 100]) == [29, 31, 37, 41, 43, 47]","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def filter_primes(input_list): Returns a new list containing only the prime numbers from the original list. return [num for num in input_list if is_prime(num)]"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform level-order traversal on a binary tree and return the values of the nodes level by level. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]]","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level = [] next_queue = [] for node in queue: level.append(node.val) if node.left: next_queue.append(node.left) if node.right: next_queue.append(node.right) result.append(level) queue = next_queue return result"},{"question":"def can_make_all_values_equal(N: int, M: int, A: List[List[int]]) -> str: Determine if it is possible to make all values in the grid equal. Args: N: int : number of rows in grid M: int : number of columns in grid A: list of list of int : grid representing the heights of cells Returns: str : \\"Yes\\" if it possible to make all values equal, otherwise \\"No\\" >>> can_make_all_values_equal(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == \\"Yes\\" >>> can_make_all_values_equal(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == \\"Yes\\"","solution":"def can_make_all_values_equal(N, M, A): Function to determine if it is possible to make all grid values equal. Args: N: int : number of rows in grid M: int : number of columns in grid A: list of list of int : grid representing the heights of cells Returns: str : \\"Yes\\" if it possible to make all values equal, otherwise \\"No\\" max_height = max(max(row) for row in A) return \\"Yes\\" # Example usage N = 3 M = 3 A = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(can_make_all_values_equal(N, M, A)) # Output: Yes"},{"question":"class FileSystem: def __init__(self): self.directories = {} def create(self, directory_name): Create a directory with the given name. pass def add(self, filename, directory_name): Add a file with the given name to the specified directory. pass def move(self, src_directory, dest_directory): Move the contents of the source directory to the destination directory. pass def count(self, directory_name): Print the total number of files in the specified directory, including all its subdirectories. pass def execute(self, commands): Execute a list of commands to manipulate the file system. for command in commands: parts = command.split() if parts[0] == \\"CREATE\\": self.create(parts[1]) elif parts[0] == \\"ADD\\": self.add(parts[1], parts[2]) elif parts[0] == \\"MOVE\\": self.move(parts[1], parts[2]) elif parts[0] == \\"COUNT\\": print(self.count(parts[1])) # Unit tests import io import pytest from contextlib import redirect_stdout def test_fs_simple(): fs = FileSystem() commands = [ \\"CREATE root\\", \\"ADD file1 root\\", \\"CREATE sub\\", \\"MOVE root sub\\", \\"COUNT sub\\", \\"ADD file2 sub\\", ] f = io.StringIO() with redirect_stdout(f): fs.execute(commands) output = f.getvalue().strip().split() assert output == [\\"1\\"] def test_fs_add_file_to_non_existent_directory(): fs = FileSystem() commands = [ \\"CREATE root\\", \\"ADD file1 sub\\", # Should not add as sub doesn't exist \\"COUNT root\\", ] f = io.StringIO() with redirect_stdout(f): fs.execute(commands) output = f.getvalue().strip().split() assert output == [\\"0\\"] def test_fs_count_files_in_multi_level_subdirs(): fs = FileSystem() commands = [ \\"CREATE root\\", \\"ADD file1 root\\", \\"CREATE sub1\\", \\"MOVE root sub1\\", \\"CREATE sub2\\", \\"MOVE sub1 sub2\\", \\"COUNT sub2\\", ] f = io.StringIO() with redirect_stdout(f): fs.execute(commands) output = f.getvalue().strip().split() assert output == [\\"1\\"] def test_fs_count_files_with_multiple_files(): fs = FileSystem() commands = [ \\"CREATE root\\", \\"ADD file1 root\\", \\"ADD file2 root\\", \\"COUNT root\\", ] f = io.StringIO() with redirect_stdout(f): fs.execute(commands) output = f.getvalue().strip().split() assert output == [\\"2\\"] def test_fs_move_and_count(): fs = FileSystem() commands = [ \\"CREATE root\\", \\"ADD file1 root\\", \\"CREATE sub\\", \\"ADD file2 sub\\", \\"MOVE root sub\\", \\"COUNT sub\\", ] f = io.StringIO() with redirect_stdout(f): fs.execute(commands) output = f.getvalue().strip().split() assert output == [\\"2\\"]","solution":"class FileSystem: def __init__(self): self.directories = {} def create(self, directory_name): if directory_name not in self.directories: self.directories[directory_name] = {\\"files\\": set(), \\"subdirs\\": {}} def add(self, filename, directory_name): if directory_name in self.directories: self.directories[directory_name][\\"files\\"].add(filename) def move(self, src_directory, dest_directory): if src_directory in self.directories and dest_directory in self.directories: dest_subdirs = self.directories[dest_directory][\\"subdirs\\"] if src_directory in dest_subdirs: raise Exception(f\\"Cyclic move detected: {src_directory} to {dest_directory}\\") else: dest_files = self.directories[dest_directory][\\"files\\"] src_files = self.directories[src_directory][\\"files\\"] dest_files.update(src_files) dest_subdirs[src_directory] = self.directories[src_directory] del self.directories[src_directory] def count(self, directory_name): def count_files(directory): files = set(directory[\\"files\\"]) for subdir in directory[\\"subdirs\\"].values(): files.update(count_files(subdir)) return files if directory_name in self.directories: return len(count_files(self.directories[directory_name])) return 0 def execute(self, commands): for command in commands: parts = command.split() if parts[0] == \\"CREATE\\": self.create(parts[1]) elif parts[0] == \\"ADD\\": self.add(parts[1], parts[2]) elif parts[0] == \\"MOVE\\": self.move(parts[1], parts[2]) elif parts[0] == \\"COUNT\\": print(self.count(parts[1])) # Example usage: # fs = FileSystem() # commands = [ # \\"CREATE root\\", # \\"ADD file1 root\\", # \\"CREATE sub\\", # \\"MOVE root sub\\", # \\"COUNT sub\\", # \\"ADD file2 sub\\" # ] # fs.execute(commands)"},{"question":"def smallest_lexicographical_string(s: str) -> str: Determine the smallest possible lexicographical string that can be obtained by removing exactly one character from s. >>> smallest_lexicographical_string(\\"abab\\") \\"aab\\" >>> smallest_lexicographical_string(\\"abc\\") \\"ab\\" >>> smallest_lexicographical_string(\\"a\\") \\"\\"","solution":"def smallest_lexicographical_string(s): # Length of the input string n = len(s) # Initialize the smallest string by removing the last character smallest_str = s[:-1] # Iterate through the string to check lexicographical order by removing one character at a time for i in range(n): new_str = s[:i] + s[i+1:] if new_str < smallest_str: smallest_str = new_str return smallest_str # Example usage # print(smallest_lexicographical_string(\\"abab\\")) # Output should be \\"aab\\" # print(smallest_lexicographical_string(\\"abc\\")) # Output should be \\"ab\\" # print(smallest_lexicographical_string(\\"a\\")) # Output should be \\"\\""},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome, ignoring non-alphanumeric characters and case. >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"random\\") False >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"Able , was I saw eLba\\") True >>> is_palindrome(\\"@!!@\\") True >>> is_palindrome(\\"!@#12321@#!\\") True","solution":"def is_palindrome(s): Checks if the given string is a palindrome, ignoring non-alphanumeric characters and case. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list is equal to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def split_array_min_max_sum(nums: List[int], k: int) -> int: Determine the minimum possible value of the maximum sum among the k subarrays after splitting the array. >>> split_array_min_max_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_min_max_sum([10], 1) 10 >>> split_array_min_max_sum([5, 5, 5, 5, 5], 3) 10 >>> split_array_min_max_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 15 >>> split_array_min_max_sum([1, 2, 3, 4, 5], 1) 15 >>> split_array_min_max_sum([1000000000, 1000000000, 1000000000], 2) 2000000000 >>> split_array_min_max_sum([1, 1, 1, 1, 1], 5) 1","solution":"def split_array_min_max_sum(nums, k): def can_split(nums, k, max_sum): current_sum = 0 subarrays = 1 for num in nums: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def restock_shoes(n, list1, m, list2): Determine which shoe models need to be restocked based on the difference in quantities between the two lists. Parameters: n (int): Size of the first list list1 (list): List of tuples where each tuple represents a shoe model and its quantity. m (int): Size of the second list list2 (list): List of tuples where each tuple represents a shoe model and its quantity. Returns: list of tuples: Shoe models and their deficit quantities in ascending order of shoe model IDs. from collections import defaultdict inventory_1 = defaultdict(int) inventory_2 = defaultdict(int) # Fill defaultdicts with respective lists for i in range(n): model, quantity = list1[i] inventory_1[model] += quantity for j in range(m): model, quantity = list2[j] inventory_2[model] += quantity # Combine all keys all_models = set(inventory_1.keys()).union(set(inventory_2.keys())) result = [] for model in sorted(all_models): if model in inventory_1 and model in inventory_2: if inventory_1[model] != inventory_2[model]: result.append((model, abs(inventory_1[model] - inventory_2[model]))) elif model in inventory_1: result.append((model, inventory_1[model])) else: result.append((model, inventory_2[model])) return result from solution import restock_shoes def test_example_case(): assert restock_shoes(5, [(101, 10), (102, 5), (103, 20), (104, 15), (105, 8)], 6, [(101, 5), (103, 25), (106, 10), (105, 10), (107, 3), (108, 7)]) == [ (101, 5), (102, 5), (103, 5), (104, 15), (105, 2), (106, 10), (107, 3), (108, 7) ] def test_no_restock_needed(): assert restock_shoes(3, [(101, 10), (102, 20), (103, 15)], 3, [(101, 10), (102, 20), (103, 15)]) == [] def test_all_models_need_restock(): assert restock_shoes(2, [(101, 10), (102, 20)], 2, [(103, 30), (104, 40)]) == [ (101, 10), (102, 20), (103, 30), (104, 40) ] def test_some_models_common(): assert restock_shoes(3, [(101, 10), (102, 20), (103, 15)], 2, [(101, 5), (104, 25)]) == [ (101, 5), (102, 20), (103, 15), (104, 25) ] def test_identical_models_different_quantities(): assert restock_shoes(1, [(101, 10)], 1, [(101, 7)]) == [ (101, 3) ]","solution":"def restock_shoes(n, list1, m, list2): Determine which shoe models need to be restocked based on the difference in quantities between the two lists. Parameters: n (int): Size of the first list list1 (list): List of tuples where each tuple represents a shoe model and its quantity. m (int): Size of the second list list2 (list): List of tuples where each tuple represents a shoe model and its quantity. Returns: list of tuples: Shoe models and their deficit quantities in ascending order of shoe model IDs. from collections import defaultdict inventory_1 = defaultdict(int) inventory_2 = defaultdict(int) # Fill defaultdicts with respective lists for i in range(n): model, quantity = list1[i] inventory_1[model] += quantity for j in range(m): model, quantity = list2[j] inventory_2[model] += quantity # Combine all keys all_models = set(inventory_1.keys()).union(set(inventory_2.keys())) result = [] for model in sorted(all_models): if model in inventory_1 and model in inventory_2: if inventory_1[model] != inventory_2[model]: result.append((model, abs(inventory_1[model] - inventory_2[model]))) elif model in inventory_1: result.append((model, inventory_1[model])) else: result.append((model, inventory_2[model])) return result"},{"question":"def knapsack(items: List[Tuple[int, int]], weight_limit: int) -> int: Write a function to maximize the number of items Suzuki can carry without exceeding a given weight limit, aiming to maximize the total value of the items. Args: items (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the weight and value of an item. weight_limit (int): An integer representing the weight limit. Returns: int: The maximum total value that Suzuki can carry without exceeding the weight limit. Examples: >>> knapsack([(2, 3), (3, 4), (4, 5), (5, 8)], 5) 8 >>> knapsack([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 5) 5","solution":"def knapsack(items, weight_limit): # Number of items n = len(items) # Initialize a table to store the maximum value for each weight limit dp = [[0 for w in range(weight_limit + 1)] for i in range(n + 1)] # Build the table in a bottom-up manner for i in range(1, n + 1): for w in range(weight_limit + 1): weight, value = items[i - 1] if weight <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight] + value) else: dp[i][w] = dp[i-1][w] return dp[n][weight_limit]"},{"question":"def get_winner(test_cases): Determine the winner of a coding competition with multiple rounds across various participants. Args: test_cases (List[Tuple[int, int, List[List[int]]]]): A list where each element is a tuple containing the number of participants, the number of rounds, and scores of each participant across all rounds. Returns: List[int]: A list of zero-based indices of the winning participants for each test case. >>> get_winner([(3, 3, [[10, 20, 30], [15, 25, 35], [20, 25, 30]]), (2, 4, [[5, 10, 15, 20], [10, 20, 30, 40]])]) [1, 1] pass def process_input(raw_input): Process raw input string to extract the number of test cases and their corresponding details. Args: raw_input (str): Multiline string representing the number of test cases, and for each test case, the number of participants, the number of rounds, and the scores of each participant in each round. Returns: List[Tuple[int, int, List[List[int]]]]: Processed data in a structured format. >>> process_input('2n3 3n10 20 30n15 25 35n20 25 30n2 4n5 10 15 20n10 20 30 40') [(3, 3, [[10, 20, 30], [15, 25, 35], [20, 25, 30]]), (2, 4, [[5, 10, 15, 20], [10, 20, 30, 40]])] pass def main(raw_input): Main function to process input and output the result. Args: raw_input (str): Raw input string. pass","solution":"def get_winner(test_cases): winners = [] for case in test_cases: N, R, scores = case max_total_score = -1 max_total_score_index = -1 max_recent_round_score = -1 for i in range(N): total_score = sum(scores[i]) recent_round_score = scores[i][-1] if (total_score > max_total_score) or (total_score == max_total_score and recent_round_score > max_recent_round_score): max_total_score = total_score max_total_score_index = i max_recent_round_score = recent_round_score winners.append(max_total_score_index) return winners # Read input def process_input(raw_input): lines = raw_input.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, R = map(int, lines[index].split()) index += 1 scores = [] for _ in range(N): scores.append(list(map(int, lines[index].split()))) index += 1 test_cases.append((N, R, scores)) return test_cases def main(raw_input): test_cases = process_input(raw_input) winners = get_winner(test_cases) print(\\"n\\".join(map(str, winners))) raw_input = 2 3 3 10 20 30 15 25 35 20 25 30 2 4 5 10 15 20 10 20 30 40 main(raw_input.strip())"},{"question":"from typing import List def largest_unique_number(nums: List[int]) -> int: Given an integer array nums, return the largest integer that only occurs once. If no integer occurs once, return -1. >>> largest_unique_number([5, 3, 9, 3, 5, 7, 1]) == 9 >>> largest_unique_number([8, 8, 8, 8, 8]) == -1 >>> largest_unique_number([1, 2, 3, 4, 5]) == 5 pass # implement the logic here def test_largest_unique_number(): assert largest_unique_number([5, 3, 9, 3, 5, 7, 1]) == 9 assert largest_unique_number([8, 8, 8, 8, 8]) == -1 assert largest_unique_number([1, 2, 3, 4, 5]) == 5 assert largest_unique_number([1, 1, 2, 2, 3, 3]) == -1 assert largest_unique_number([-1, -2, -3, -1, -2, -3, 0]) == 0 assert largest_unique_number([2, 2, 2, 3, 3, 3, 4, 4, 4, 1]) == 1 assert largest_unique_number([]) == -1 assert largest_unique_number([-10, -20, -30, -10, -20]) == -30 assert largest_unique_number([-1, -1, -2, -2, -3, -3, -4]) == -4 assert largest_unique_number([0, 0, 1]) == 1 assert largest_unique_number([7]) == 7","solution":"def largest_unique_number(nums): Returns the largest integer that only occurs once in the array. If no integer occurs once, returns -1. from collections import Counter # Count occurrences of each number num_counts = Counter(nums) # Find unique numbers unique_numbers = [num for num, count in num_counts.items() if count == 1] if unique_numbers: return max(unique_numbers) else: return -1"},{"question":"class CinemaReservationSystem: def __init__(self): Initialize the CinemaReservationSystem, which maintains the reserved seats and the available seats, along with an efficient way to get the next available seat. pass def reserve(self, x: int): Reserve a seat with seat number x. Args: x (int): The seat number to be reserved. pass def cancel(self, x: int): Cancel the reservation for a seat with seat number x. Args: x (int): The seat number to cancel the reservation for. pass def next(self) -> int: Find the next available seat with the smallest seat number. Returns: int: The next available seat number. pass def available(self, x: int) -> str: Check if a specific seat is available. Args: x (int): The seat number to check availability for. Returns: str: \\"YES\\" if the seat is available, otherwise \\"NO\\". pass def handle_queries(queries: List[str]) -> List[Union[int, str]]: Handle a list of queries related to the cinema reservation system. Args: queries (List[str]): A list of queries to handle. Returns: List[Union[int, str]]: The results of the queries. pass def test_reserve(): system = CinemaReservationSystem() system.reserve(1) assert system.available(1) == \\"NO\\" system.reserve(2) assert system.available(2) == \\"NO\\" def test_cancel(): system = CinemaReservationSystem() system.reserve(1) assert system.available(1) == \\"NO\\" system.cancel(1) assert system.available(1) == \\"YES\\" def test_next(): system = CinemaReservationSystem() system.reserve(1) system.reserve(2) assert system.next() == 3 system.cancel(1) assert system.next() == 1 def test_handle_queries(): queries = [\\"RESERVE 3\\", \\"RESERVE 1\\", \\"AVAILABLE 2\\", \\"CANCEL 3\\", \\"NEXT\\", \\"AVAILABLE 1\\"] results = handle_queries(queries) expected = [\\"YES\\", 2, \\"NO\\"] assert results == expected def test_large_series_of_operations(): system = CinemaReservationSystem() for i in range(1, 50001): system.reserve(i) assert system.available(i) == \\"NO\\" assert system.next() == 50001 for i in range(1, 100001, 2): system.cancel(i) assert system.next() == 1 def test_edge_cases(): system = CinemaReservationSystem() assert system.next() == 1 for i in range(1, 100001): system.reserve(i) assert system.next() == 100001 for i in range(1, 100001): assert system.available(i) == \\"NO\\" for i in range(1, 100001): system.cancel(i) assert system.next() == 1 for i in range(1, 100001): assert system.available(i) == \\"YES\\"","solution":"class CinemaReservationSystem: def __init__(self): self.reserved_seats = set() self.total_seats = 10**5 self.available_seats = set(range(1, self.total_seats + 1)) self.next_seat = 1 def reserve(self, x): if x in self.available_seats: self.available_seats.remove(x) self.reserved_seats.add(x) while self.next_seat in self.reserved_seats: self.next_seat += 1 def cancel(self, x): if x in self.reserved_seats: self.reserved_seats.remove(x) self.available_seats.add(x) if x < self.next_seat: self.next_seat = x def next(self): return self.next_seat def available(self, x): return \\"YES\\" if x in self.available_seats else \\"NO\\" def handle_queries(queries): system = CinemaReservationSystem() results = [] for query in queries: parts = query.split() if parts[0] == \\"RESERVE\\": system.reserve(int(parts[1])) elif parts[0] == \\"CANCEL\\": system.cancel(int(parts[1])) elif parts[0] == \\"NEXT\\": results.append(system.next()) elif parts[0] == \\"AVAILABLE\\": results.append(system.available(int(parts[1]))) return results"},{"question":"class ReviewManager: def __init__(self, initial_scores): Initialize the ReviewManager with initial scores. >>> rm = ReviewManager([1, 2, 3]) >>> rm.scores == [1, 2, 3] True pass def add_review(self, s): Add a new review with score s to the dataset. >>> rm = ReviewManager([1, 2, 3]) >>> rm.add_review(4) >>> rm.scores == [1, 2, 3, 4] True pass def update_review(self, idx, s): Update the review at index idx to have the new score s. >>> rm = ReviewManager([1, 2, 3]) >>> rm.update_review(1, 5) >>> rm.scores == [1, 5, 3] True pass def delete_review(self, idx): Delete the review at index idx from the dataset. >>> rm = ReviewManager([1, 2, 3]) >>> rm.delete_review(1) >>> rm.scores == [1, 3] True pass def average_score(self): Calculate and return the average score of all reviews in the dataset. >>> rm = ReviewManager([1, 2, 3, 4, 5]) >>> rm.average_score() 3.0 pass def count_reviews_with_score(self, s): Return the count of reviews that have the exact score s. >>> rm = ReviewManager([1, 2, 3, 4, 5]) >>> rm.count_reviews_with_score(5) 1 pass","solution":"class ReviewManager: def __init__(self, initial_scores): self.scores = initial_scores def add_review(self, s): self.scores.append(s) def update_review(self, idx, s): if 0 <= idx < len(self.scores): self.scores[idx] = s def delete_review(self, idx): if 0 <= idx < len(self.scores): self.scores.pop(idx) def average_score(self): if not self.scores: return 0.0 return round(sum(self.scores) / len(self.scores), 2) def count_reviews_with_score(self, s): return self.scores.count(s)"},{"question":"def can_schedule_deliveries(test_cases): Determines if it's possible to schedule all deliveries without overlapping. Args: test_cases (List[List[Tuple[int, int]]]): A list of test cases, where each test case is a list of tuples representing delivery requests with start and end times. Returns: List[str]: A list of strings \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. >>> can_schedule_deliveries([[(1, 4), (2, 5), (5, 8)], [(2, 3), (1, 2), (3, 4), (4, 5)]]) ['IMPOSSIBLE', 'POSSIBLE'] def parse_input(input_str): Parses the input string and returns the test cases. Args: input_str (str): Input string in the specified format. Returns: List[List[Tuple[int, int]]]: A list of test cases. >>> parse_input(\\"2n3n1 4n2 5n5 8n4n2 3n1 2n3 4n4 5\\") [[(1, 4), (2, 5), (5, 8)], [(2, 3), (1, 2), (3, 4), (4, 5)]] def process_input_output(input_str): Processes the input string and produces the output string. Args: input_str (str): Input string in the specified format. Returns: str: Output string indicating if deliveries can be scheduled for each test case. >>> process_input_output(\\"2n3n1 4n2 5n5 8n4n2 3n1 2n3 4n4 5\\") 'IMPOSSIBLEnPOSSIBLE'","solution":"def can_schedule_deliveries(test_cases): results = [] for deliveries in test_cases: sorted_deliveries = sorted(deliveries, key=lambda x: x[1]) end_time = 0 possible = True for start, end in sorted_deliveries: if start < end_time: possible = False break end_time = end results.append(\\"POSSIBLE\\" if possible else \\"IMPOSSIBLE\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) deliveries = [] for i in range(1, N+1): start, end = map(int, lines[index + i].split()) deliveries.append((start, end)) test_cases.append(deliveries) index += N + 1 return test_cases # To use the function, we can provide input in the specified format and it will give the desired output. def process_input_output(input_str): test_cases = parse_input(input_str) results = can_schedule_deliveries(test_cases) return \\"n\\".join(results)"},{"question":"def most_likely_winner(n: int, skill_levels: List[int]) -> int: Determines the most likely winner of the tournament given the skill levels of n players. Parameters: n (int): The number of players. skill_levels (list): A list of integers representing the skill levels of the players. Returns: int: The 1-based index of the player most likely to win the tournament. Examples: >>> most_likely_winner(4, [5, 9, 3, 2]) 2 >>> most_likely_winner(6, [10, 20, 30, 40, 50, 60]) 6","solution":"def most_likely_winner(n, skill_levels): Determines the most likely winner of the tournament. Parameters: n (int): The number of players. skill_levels (list): A list of integers representing the skill levels of the players. Returns: int: The 1-based index of the player most likely to win the tournament. max_skill_level = -1 max_index = -1 for i in range(n): if skill_levels[i] > max_skill_level: max_skill_level = skill_levels[i] max_index = i return max_index + 1 # return 1-based index"},{"question":"def subsequence_sum_k(n: int, k: int, array: List[int]) -> str: Determines if there exists a subsequence within \`array\` that sums up to \`k\`. >>> subsequence_sum_k(5, 9, [2, 3, 1, 2, 8]) \\"Yes\\" >>> subsequence_sum_k(4, 15, [1, 2, 4, 5]) \\"No\\" >>> subsequence_sum_k(3, 0, [10, 20, 30]) \\"Yes\\" >>> subsequence_sum_k(4, 3, [1, -1, 2, -2]) \\"Yes\\" >>> subsequence_sum_k(3, -3, [-1, -2, -3]) \\"Yes\\" >>> subsequence_sum_k(1, 100, [100]) \\"Yes\\" >>> subsequence_sum_k(1, 101, [100]) \\"No\\"","solution":"def subsequence_sum_k(n, k, array): Determines if there exists a subsequence within \`array\` that sums up to \`k\`. :param n: Length of the array :param k: The target sum :param array: List of integers :return: \\"Yes\\" if such subsequence exists, \\"No\\" otherwise # To store previous possible sums possible_sums = {0} # Iterate through each number in the array for num in array: new_sums = set() for current_sum in possible_sums: new_sum = current_sum + num new_sums.add(new_sum) possible_sums.update(new_sums) # Early exit if target sum k is found if k in possible_sums: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List, Tuple def process_tree(n: int, edges: List[Tuple[int, int]], operations: List[Tuple[int, ...]]) -> List[int]: Process a tree with given operations and return results of queries. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of the edges in the tree. operations (List[Tuple[int, ...]]): A list of operations to be performed on the tree. Returns: List[int]: A list containing the results of query operations. Example: >>> process_tree(5, [(1, 2), (1, 3), (2, 4), (2, 5)], [(1, 2, 10), (2, 4), (1, 1, 5), (2, 3)]) [10, 5] >>> process_tree(1, [], [(2, 1), (1, 1, 10), (2, 1)]) [0, 10] pass def test_process_tree_example(): n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] operations = [ (1, 2, 10), (2, 4), (1, 1, 5), (2, 3) ] assert process_tree(n, edges, operations) == [10, 5] def test_process_tree_single_node(): n = 1 edges = [] operations = [ (2, 1), (1, 1, 10), (2, 1) ] assert process_tree(n, edges, operations) == [0, 10] def test_process_tree_linear_tree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] operations = [ (1, 1, 10), (2, 4), (1, 2, 5), (2, 3), (2, 4) ] assert process_tree(n, edges, operations) == [10, 15, 15] def test_process_tree_binary_tree(): n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] operations = [ (1, 2, 10), (1, 3, 5), (2, 5), (2, 6), (1, 1, 3), (2, 4), (2, 7) ] assert process_tree(n, edges, operations) == [10, 5, 13, 8] import pytest if __name__ == '__main__': pytest.main()","solution":"from collections import defaultdict import sys sys.setrecursionlimit(200000) def dfs(node, parent, adj, start, end, timer, flat_tree): timer[0] += 1 start[node] = timer[0] flat_tree[timer[0]] = node for neighbor in adj[node]: if neighbor != parent: dfs(neighbor, node, adj, start, end, timer, flat_tree) end[node] = timer[0] def process_tree(n, edges, operations): adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) start = [0] * (n + 1) end = [0] * (n + 1) flat_tree = [0] * (n + 1) timer = [0] dfs(1, -1, adj, start, end, timer, flat_tree) bit = [0] * (n + 2) def add(bit, idx, val): while idx <= n: bit[idx] += val idx += idx & -idx def sum(bit, idx): result = 0 while idx > 0: result += bit[idx] idx -= idx & -idx return result result = [] for operation in operations: if operation[0] == 1: _, u, x = operation add(bit, start[u], x) add(bit, end[u] + 1, -x) elif operation[0] == 2: _, v = operation result.append(sum(bit, start[v])) return result"},{"question":"def has_increasing_subsequence_length_3(N: int, sequence: List[int]) -> str: Determines if there exists a subsequence of length 3 that is strictly increasing. >>> has_increasing_subsequence_length_3(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> has_increasing_subsequence_length_3(4, [5, 4, 3, 2]) \\"NO\\" >>> has_increasing_subsequence_length_3(6, [5, 1, 6, 2, 4, 3]) \\"YES\\"","solution":"def has_increasing_subsequence_length_3(N, sequence): Determines if there exists a subsequence of length 3 that is strictly increasing. Args: N (int): The number of elements in the sequence. sequence (list of int): The sequence of distinct integers. Returns: str: \\"YES\\" if there exists a strictly increasing subsequence of length 3, otherwise \\"NO\\". if N < 3: return \\"NO\\" first = float('inf') second = float('inf') for num in sequence: if num <= first: first = num elif num <= second: second = num else: return \\"YES\\" return \\"NO\\""},{"question":"def create_array(n): Given an integer n, determine if it's possible to create an array of length n where each element is an integer from 1 to n (inclusive) and the sum of the array equals the product of the array. If it is possible, return one such array; otherwise, return -1. >>> create_array(1) [1] >>> create_array(3) [1, 2, 1] >>> create_array(5) [1, 2, 3, 6, 3] >>> create_array(2) -1 pass def process_input(T, test_cases): Process the input, apply the create_array function, and return the results. >>> process_input(3, [1, 3, 5]) [[1], [1, 2, 1], [1, 2, 3, 6, 3]] >>> process_input(2, [2, 4]) [-1, -1] >>> process_input(1, [1]) [[1]] >>> process_input(4, [1, 2, 3, 5]) [[1], -1, [1, 2, 1], [1, 2, 3, 6, 3]] pass","solution":"def create_array(n): Given an integer n, determine if it's possible to create an array of length n where each element is an integer from 1 to n (inclusive) and the sum of the array equals the product of the array. If it is possible, return one such array; otherwise, return -1. if n == 1: return [1] elif n == 3: return [1, 2, 1] elif n == 5: return [1, 2, 3, 6, 3] else: return -1 def process_input(T, test_cases): results = [] for n in test_cases: results.append(create_array(n)) return results"},{"question":"def number_to_excel_column(n: int) -> str: Converts a given integer to its corresponding Excel column title. Args: n: int - the integer to be converted Returns: str - the Excel column title Examples: >>> number_to_excel_column(1) 'A' >>> number_to_excel_column(28) 'AB' >>> number_to_excel_column(701) 'ZY'","solution":"def number_to_excel_column(n): Converts a given integer to its corresponding Excel column title. Args: n: int - the integer to be converted Returns: string - the Excel column title result = '' while n > 0: n -= 1 result = chr(n % 26 + 65) + result n //= 26 return result"},{"question":"def isValidPassword(password: str) -> bool: Checks if a given password adheres to the predefined rules. >>> isValidPassword(\\"Abcdefg1\\") True >>> isValidPassword(\\"Ab1234567\\") True >>> isValidPassword(\\"Abcdef1\\") False >>> isValidPassword(\\"abcdefg1\\") False >>> isValidPassword(\\"ABC1DEFG\\") False >>> isValidPassword(\\"Abcdefg123456789*\\") False >>> isValidPassword(\\"AbcPassword1\\") False >>> isValidPassword(\\"mysecurePassword123\\") False >>> isValidPassword(\\"PaSsWoRdstring123\\") False","solution":"def isValidPassword(password: str) -> bool: Checks if the given password is valid based on predefined rules. :param password: string representing the password to be checked :return: boolean indicating whether the password is valid if len(password) < 8: return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) if not (has_upper and has_lower and has_digit): return False special_chars = set('!@#%^&*()') if any(c in special_chars for c in password): return False if 'password' in password.lower(): return False return True"},{"question":"def can_fulfill_requests(n, requested, stock): Determines if all requests for crates can be fulfilled with available stock. Parameters: n (int): Number of different items requested by all stations. requested (list): A list where each element represents crates needed for the ith item. stock (list): A list where each element represents crates in stock for the ith item. Returns: str: \\"Yes\\" if all requests can be fulfilled from stock, otherwise \\"No\\". pass # Example test cases if __name__ == \\"__main__\\": # Test case 1 assert can_fulfill_requests(3, [5, 10, 7], [6, 10, 8]) == \\"Yes\\" # Test case 2 assert can_fulfill_requests(4, [3, 6, 10, 1], [2, 6, 9, 1]) == \\"No\\" # Test case 3 assert can_fulfill_requests(2, [1, 1], [1, 2]) == \\"Yes\\" # Additional test cases assert can_fulfill_requests(3, [1, 2, 3], [0, 0, 0]) == \\"No\\" assert can_fulfill_requests(5, [3, 8, 6, 7, 5], [3, 8, 5, 7, 6]) == \\"No\\" assert can_fulfill_requests(3, [1000000000, 999999999, 888888888], [1000000000, 999999999, 888888889]) == \\"Yes\\" assert can_fulfill_requests(1, [1], [1]) == \\"Yes\\"","solution":"def can_fulfill_requests(n, requested, stock): Determines if all requests for crates can be fulfilled with available stock. Parameters: n (int): Number of different items requested by all stations. requested (list): A list where each element represents crates needed for the ith item. stock (list): A list where each element represents crates in stock for the ith item. Returns: str: \\"Yes\\" if all requests can be fulfilled from stock, otherwise \\"No\\". for i in range(n): if requested[i] > stock[i]: return \\"No\\" return \\"Yes\\""},{"question":"def check_moisture_levels(sections, readings, min_threshold, max_threshold, data): Check if all sections have readings within the acceptable moisture range. Args: sections (int): Number of sections. readings (int): Number of readings per section. min_threshold (int): Minimum acceptable moisture level. max_threshold (int): Maximum acceptable moisture level. data (list of list of int): Moisture readings for each section. Returns: str: \\"STABLE\\" if all sections are within the acceptable range, \\"UNSTABLE\\" otherwise. >>> check_moisture_levels(3, 4, 10, 50, [ ... [12, 48, 30, 25], ... [10, 20, 25, 45], ... [11, 9, 30, 40] ... ]) 'UNSTABLE' >>> check_moisture_levels(3, 4, 10, 50, [ ... [12, 48, 30, 25], ... [10, 20, 25, 45], ... [11, 30, 30, 40] ... ]) 'STABLE' >>> check_moisture_levels(2, 3, 10, 50, [ ... [10, 20, 30], ... [10, 40, 50] ... ]) 'STABLE' >>> check_moisture_levels(2, 3, 10, 50, [ ... [12, 50, 30], ... [10, 40, 50] ... ]) 'STABLE' >>> check_moisture_levels(2, 3, 10, 50, [ ... [5, 100, 30], ... [1, 200, 2] ... ]) 'UNSTABLE'","solution":"def check_moisture_levels(sections, readings, min_threshold, max_threshold, data): Check if all sections have readings within the acceptable moisture range. Args: sections (int): Number of sections. readings (int): Number of readings per section. min_threshold (int): Minimum acceptable moisture level. max_threshold (int): Maximum acceptable moisture level. data (list of list of int): Moisture readings for each section. Returns: str: \\"STABLE\\" if all sections are within the acceptable range, \\"UNSTABLE\\" otherwise. for section in data: for reading in section: if reading < min_threshold or reading > max_threshold: return \\"UNSTABLE\\" return \\"STABLE\\""},{"question":"def is_perfect_number(n): Checks if a number is a perfect number. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False def next_perfect_number(n): Returns the smallest perfect number greater than n. >>> next_perfect_number(5) 6 >>> next_perfect_number(27) 28 >>> next_perfect_number(500) 8128 >>> next_perfect_number(-10) 6 >>> next_perfect_number(10**18) \\"Not found\\"","solution":"def is_perfect_number(n): Checks if a number is a perfect number. if n < 2: return False sum_divisors = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: sum_divisors += i if i != n // i: sum_divisors += n // i return sum_divisors == n def next_perfect_number(n): Returns the smallest perfect number greater than n. if n >= 10**18: return \\"Not found\\" # List of known perfect numbers up to the computational feasible limit perfect_numbers = [6, 28, 496, 8128, 33550336, 8589869056, 137438691328, 2305843008139952128] for p in perfect_numbers: if p > n: return p return \\"Not found\\""},{"question":"def minimum_total_removals(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum total number of products to remove to make all containers empty. >>> minimum_total_removals(1, [(3, [4, 6, 3])]) == [9] def process_input(input_lines: List[str]) -> Tuple[int, List[Tuple[int, List[int]]]]: Process input lines into T and cases >>> input_lines = [ ... \\"1\\", ... \\"3\\", ... \\"4\\", ... \\"6\\", ... \\"3\\", ... ] >>> process_input(input_lines) == (1, [(3, [4, 6, 3])]) def process_output(output_values: List[int]) -> str: Process the output values into formatted string >>> process_output([13]) == \\"13\\" def test_minimum_total_removals(): # Test case 1 T = 1 cases = [(3, [4, 6, 3])] assert minimum_total_removals(T, cases) == [13] # Test case 2 T = 2 cases = [(1, [10]), (2, [7, 8])] assert minimum_total_removals(T, cases) == [10, 15] # Test case 3 T = 1 cases = [(5, [5, 5, 5, 5, 5])] assert minimum_total_removals(T, cases) == [25] # Test case 4 T = 1 cases = [(4, [1, 2, 3, 4])] assert minimum_total_removals(T, cases) == [10] # Test case 5 T = 3 cases = [(1, [1]), (2, [2, 2]), (3, [3, 3, 3])] assert minimum_total_removals(T, cases) == [1, 4, 9] def test_process_input(): input_lines = [ \\"1\\", \\"3\\", \\"4\\", \\"6\\", \\"3\\" ] T, cases = process_input(input_lines) assert T == 1 assert cases == [(3, [4, 6, 3])] def test_process_output(): output_values = [13] results = process_output(output_values) assert results == \\"13\\" if __name__ == \\"__main__\\": test_minimum_total_removals() test_process_input() test_process_output() print(\\"All tests passed!\\")","solution":"from math import ceil def minimum_total_removals(T, cases): results = [] for case in cases: n, products = case total_removals = 0 for p in products: total_removals += p results.append(total_removals) return results def process_input(input_lines): iterator = iter(input_lines) T = int(next(iterator)) cases = [] for _ in range(T): n = int(next(iterator)) products = [int(next(iterator)) for _ in range(n)] cases.append((n, products)) return T, cases def process_output(output_values): return 'n'.join(map(str, output_values)) # Unit tests run when this file is executed if __name__ == \\"__main__\\": import sys input = sys.stdin.read input_lines = input().strip().split('n') T, cases = process_input(input_lines) results = minimum_total_removals(T, cases) output = process_output(results) print(output)"},{"question":"from typing import List def most_frequent_elements(arr: List[int]) -> List[int]: Identify the most frequent elements in the array and return them sorted in ascending order. >>> most_frequent_elements([1, 2, 2, 3, 3]) == [2, 3] >>> most_frequent_elements([3, 1, 4, 1, 5, 9]) == [1] >>> most_frequent_elements([1]) == [1] >>> most_frequent_elements([5, 2, 9, 1, 5, 1, 5, 5, 3, 2]) == [5] >>> most_frequent_elements([]) == [] >>> most_frequent_elements([4, 4, 4, 4]) == [4] >>> most_frequent_elements([5, 1, 1, 3, 5, 3]) == [1, 3, 5] >>> most_frequent_elements([1000000000, 1, 1000000000, 2, 2, 3, 3, 3]) == [3] >>> most_frequent_elements([7, 8, 8, 3, 3, 7, 9, 3]) == [3] >>> most_frequent_elements([-1, 2, -1, 2]) == [-1, 2]","solution":"from collections import Counter def most_frequent_elements(arr): Returns a list of the most frequent elements in ascending order. if not arr: return [] # Count the frequency of each element in the list freq = Counter(arr) # Find the maximum frequency max_freq = max(freq.values()) # Get all elements with the maximum frequency most_freq_elements = [key for key, value in freq.items() if value == max_freq] # Return the sorted list of the most frequent elements return sorted(most_freq_elements)"},{"question":"class GeographicalZones: def __init__(self): self.rectangles = [] def add(self, x1, y1, x2, y2): Adds a new rectangular zone defined by bottom-left (x1, y1) and top-right (x2, y2) corners. pass def contains(self, x, y): Checks if a point (x, y) lies inside any of the existing rectangular zones. >>> geo_zones = GeographicalZones() >>> geo_zones.add(1, 1, 4, 4) >>> geo_zones.contains(3, 3) 'YES' >>> geo_zones.contains(5, 5) 'NO' pass def minimal(self): Finds the smallest rectangular zone that contains all existing rectangular zones. >>> geo_zones = GeographicalZones() >>> geo_zones.add(1, 1, 4, 4) >>> geo_zones.add(2, 2, 6, 5) >>> geo_zones.minimal() (1, 1, 6, 5) pass def process_operations(m, operations): Processes a sequence of operations on rectangular zones. >>> process_operations(6, [ ... \\"add 1 1 4 4\\", ... \\"add 2 2 6 5\\", ... \\"contains 3 3\\", ... \\"contains 6 6\\", ... \\"minimal\\", ... \\"add 7 3 8 4\\"]) ['YES', 'NO', '1 1 6 5'] >>> process_operations(1, [\\"minimal\\"]) [] pass","solution":"class GeographicalZones: def __init__(self): self.rectangles = [] def add(self, x1, y1, x2, y2): self.rectangles.append((x1, y1, x2, y2)) def contains(self, x, y): for (x1, y1, x2, y2) in self.rectangles: if x1 <= x <= x2 and y1 <= y <= y2: return \\"YES\\" return \\"NO\\" def minimal(self): if not self.rectangles: return None min_x1 = min(rect[0] for rect in self.rectangles) min_y1 = min(rect[1] for rect in self.rectangles) max_x2 = max(rect[2] for rect in self.rectangles) max_y2 = max(rect[3] for rect in self.rectangles) return (min_x1, min_y1, max_x2, max_y2) def process_operations(m, operations): geo_zones = GeographicalZones() results = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"add\\": x1, y1, x2, y2 = map(int, parts[1:]) geo_zones.add(x1, y1, x2, y2) elif cmd == \\"contains\\": x, y = map(int, parts[1:]) results.append(geo_zones.contains(x, y)) elif cmd == \\"minimal\\": result = geo_zones.minimal() if result: results.append(\\" \\".join(map(str, result))) return results"},{"question":"def is_valid_date(T: str) -> str: Check if the given string T follows the date format \\"DD-MM-YYYY\\" used in the Kingdom of Xyzzy. >>> is_valid_date(\\"12-05-2021\\") Yes >>> is_valid_date(\\"12-13-2021\\") No","solution":"def is_valid_date(T): Check if the given string T follows the date format \\"DD-MM-YYYY\\" used in the Kingdom of Xyzzy. # Validate overall length and hyphen positions if len(T) != 10 or T[2] != '-' or T[5] != '-': return \\"No\\" # Extract and validate day, month, and year day = T[0:2] month = T[3:5] year = T[6:10] if not (day.isdigit() and month.isdigit() and year.isdigit()): return \\"No\\" day = int(day) month = int(month) year = int(year) if not (1 <= day <= 31): return \\"No\\" if not (1 <= month <= 12): return \\"No\\" if year <= 0: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_in_bst(root: TreeNode, L: int, R: int) -> List[int]: Find all elements in the BST that fall within a given range [L, R] (inclusive). The elements should be returned in ascending order. Examples: >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(12) >>> root.right.right = TreeNode(18) >>> range_in_bst(root, 7, 15) [7, 10, 12, 15] >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(7) >>> root.right.right = TreeNode(18) >>> range_in_bst(root, 6, 10) [7, 10]","solution":"from typing import List # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def range_in_bst(root: TreeNode, L: int, R: int) -> List[int]: def in_order_traversal(node): if node is None: return if node.val >= L: yield from in_order_traversal(node.left) if L <= node.val <= R: yield node.val if node.val <= R: yield from in_order_traversal(node.right) return list(in_order_traversal(root))"},{"question":"def max_gold_collected(test_cases): Determine the maximum gold that can be collected from a sequence of contiguous regions in a circular arrangement for multiple test cases. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases where each test case is a tuple containing an integer M (number of regions) and a list of integers representing the gold production of each region. Returns: List[int]: A list of integers representing the maximum gold collected for each test case. Example: >>> max_gold_collected([(5, [1, 5, 1, 3, 2]), (3, [2, 3, 5])]) [12, 10] >>> max_gold_collected([(1, [7])]) [7]","solution":"def max_circular_subarray_sum(arr): def kadane(arr): max_end_here = arr[0] max_so_far = arr[0] for x in arr[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far max_kadane = kadane(arr) if max_kadane < 0: return max_kadane max_wrap = 0 for i in range(len(arr)): max_wrap += arr[i] arr[i] = -arr[i] max_wrap += kadane(arr) return max(max_wrap, max_kadane) def max_gold_collected(test_cases): results = [] for test in test_cases: M, gold = test results.append(max_circular_subarray_sum(gold)) return results"},{"question":"def calculate_average_marks(students_marks): Processes a list of strings where each string contains a student's name followed by their marks in different subjects separated by spaces. Returns a list of the students names along with their average marks, sorted in descending order of the average marks. If two students have the same average marks, they should be sorted alphabetically by their names. :param students_marks: List of strings :return: List of strings with the student's name and their average marks from solution import calculate_average_marks def test_calculate_average_marks_example(): students_marks = [ \\"Alice 91 85 74\\", \\"Bob 88 76 92\\", \\"Charlie 70 60\\", \\"David 88 88 88\\" ] expected = [ \\"David 88.0\\", \\"Bob 85.3\\", \\"Alice 83.3\\", \\"Charlie 65.0\\" ] assert calculate_average_marks(students_marks) == expected def test_calculate_average_marks_single_student(): students_marks = [\\"Eve 100 90 95\\"] expected = [\\"Eve 95.0\\"] assert calculate_average_marks(students_marks) == expected def test_calculate_average_marks_same_average_marks(): students_marks = [ \\"Zara 80 90\\", \\"Adam 85 85\\" ] expected = [ \\"Adam 85.0\\", \\"Zara 85.0\\" ] assert calculate_average_marks(students_marks) == expected def test_calculate_average_marks_mixed_marks(): students_marks = [ \\"Tom 60 70\\", \\"Harry 70 60\\", \\"Sally 90 95 100\\" ] expected = [ \\"Sally 95.0\\", \\"Harry 65.0\\", \\"Tom 65.0\\" ] assert calculate_average_marks(students_marks) == expected def test_calculate_average_marks_multiple_students(): students_marks = [ \\"Kate 80 85 90\\", \\"John 75 70 80\\", \\"Doe 100 95\\" ] expected = [ \\"Doe 97.5\\", \\"Kate 85.0\\", \\"John 75.0\\" ] assert calculate_average_marks(students_marks) == expected def test_calculate_average_marks_empty_list(): students_marks = [] expected = [] assert calculate_average_marks(students_marks) == expected","solution":"def calculate_average_marks(students_marks): Processes a list of strings where each string contains a student's name followed by their marks in different subjects separated by spaces. Returns a list of the students names along with their average marks, sorted in descending order of the average marks. If two students have the same average marks, they should be sorted alphabetically by their names. :param students_marks: List of strings :return: List of strings with the student's name and their average marks student_averages = [] for entry in students_marks: parts = entry.split() name = parts[0] marks = list(map(int, parts[1:])) average = sum(marks) / len(marks) student_averages.append((name, average)) # Sort primarily by average marks (descending) and secondarily by name (ascending) student_averages.sort(key=lambda x: (-x[1], x[0])) result = [f\\"{name} {average:.1f}\\" for name, average in student_averages] return result"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any subarray of the given array. >>> max_subarray_sum([-1, 2, 3, -4]) == 5 >>> max_subarray_sum([-2, -3, 4, -1, -2]) == 4 >>> max_subarray_sum([3, -2, 5]) == 6 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-2, -3, -1, -5]) == -1 def max_subarray_sums(test_cases): Processes multiple test cases to find the maximum sum of any subarray for each test case. >>> test_cases = [ ... [-1, 2, 3, -4], ... [-2, -3, 4, -1, -2], ... [3, -2, 5] ... ] >>> max_subarray_sums(test_cases) == [5, 4, 6]","solution":"def max_subarray_sum(arr): Returns the maximum sum of any subarray of the given array. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def max_subarray_sums(test_cases): Processes multiple test cases to find the maximum sum of any subarray for each test case. results = [] for test_case in test_cases: results.append(max_subarray_sum(test_case)) return results"},{"question":"def get_final_position(n: int, commands: List[str]) -> Tuple[int, int]: Calculate the final position of the robot on a 2D plane given a number of commands. Args: n (int): the number of commands commands (list of str): the commands to move the robot Returns: tuple: the final position (x, y) of the robot Examples: >>> get_final_position(5, [\\"U 3\\", \\"D 2\\", \\"L 1\\", \\"R 4\\", \\"D 3\\"]) (3, -2) >>> get_final_position(3, [\\"U 5\\", \\"L 5\\", \\"D 5\\"]) (-5, 0)","solution":"def get_final_position(n, commands): Calculate the final position of the robot on a 2D plane given a number of commands. Args: n (int): the number of commands commands (list of str): the commands to move the robot Returns: tuple: the final position (x, y) of the robot x, y = 0, 0 for command in commands: direction, steps = command.split() steps = int(steps) if direction == \\"U\\": y += steps elif direction == \\"D\\": y -= steps elif direction == \\"L\\": x -= steps elif direction == \\"R\\": x += steps return (x, y)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): Builds a tree from a list of node tuples where each tuple contains (val, left, right) if not nodes: return None tree_nodes = [None] * (len(nodes) + 1) for i, (val, left, right) in enumerate(nodes, 1): if tree_nodes[i] is None: tree_nodes[i] = TreeNode(val) else: tree_nodes[i].val = val if left != -1: if tree_nodes[left] is None: tree_nodes[left] = TreeNode() tree_nodes[i].left = tree_nodes[left] if right != -1: if tree_nodes[right] is None: tree_nodes[right] = TreeNode() tree_nodes[i].right = tree_nodes[right] return tree_nodes[1] def max_path_sum(root): Returns the maximum path sum from root to any leaf node in the binary tree. if not root: return float('-inf') if not root.left and not root.right: return root.val left_sum = max_path_sum(root.left) right_sum = max_path_sum(root.right) return root.val + max(left_sum, right_sum) def solve(test_cases): For each test case, constructs the binary tree and finds the maximum path sum. results = [] for nodes in test_cases: root = build_tree(nodes) results.append(max_path_sum(root)) return results # Unit Tests import pytest def test_single_node_tree(): assert solve([[(3, -1, -1)]]) == [3] def test_simple_tree(): assert solve([[(1, 2, 3), (2, -1, -1), (3, -1, -1)]]) == [4] def test_complex_tree(): nodes = [(5, 2, 3), (3, -1, -1), (4, 4, 5), (-10, -1, -1), (20, -1, -1)] assert solve([nodes]) == [9] def test_multiple_trees(): test_cases = [ [(5, 2, 3), (3, -1, -1), (4, 4, 5), (-10, -1, -1), (20, -1, -1)], [(1, 2, -1), (2, -1, -1)], [(10, 2, 3), (5, -1, -1), (15, -1, -1)] ] assert solve(test_cases) == [9, 3, 25] def test_negative_values(): nodes = [(-1, 2, 3), (-2, -1, -1), (-3, -1, -1)] assert solve([nodes]) == [-3]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nodes): if not nodes: return None tree_nodes = [None] * (len(nodes) + 1) for i, (val, left, right) in enumerate(nodes, 1): if tree_nodes[i] is None: tree_nodes[i] = TreeNode(val) else: tree_nodes[i].val = val if left != -1: if tree_nodes[left] is None: tree_nodes[left] = TreeNode() tree_nodes[i].left = tree_nodes[left] if right != -1: if tree_nodes[right] is None: tree_nodes[right] = TreeNode() tree_nodes[i].right = tree_nodes[right] return tree_nodes[1] def max_path_sum(root): if not root: return float('-inf') if not root.left and not root.right: return root.val left_sum = max_path_sum(root.left) right_sum = max_path_sum(root.right) return root.val + max(left_sum, right_sum) def solve(test_cases): results = [] for nodes in test_cases: root = build_tree(nodes) results.append(max_path_sum(root)) return results"},{"question":"def process_grid_operations(N, M, Q, operations): Apply a series of operations on a 2D grid and return the results of 'max' commands. Parameters: - N: int, number of rows in the grid - M: int, number of columns in the grid - Q: int, number of operations - operations: List of operations to be applied Returns: - List of integers representing the results of 'max' commands. >>> N = 2 >>> M = 3 >>> Q = 5 >>> operations = [ [\\"row\\", \\"1\\", \\"4\\"], [\\"col\\", \\"2\\", \\"2\\"], [\\"max\\"], [\\"row\\", \\"2\\", \\"3\\"], [\\"max\\"] ] >>> process_grid_operations(N, M, Q, operations) [6, 6] >>> N = 3 >>> M = 3 >>> Q = 2 >>> operations = [ [\\"row\\", \\"1\\", \\"1\\"], [\\"max\\"] ] >>> process_grid_operations(N, M, Q, operations) [1] >>> N = 3 >>> M = 3 >>> Q = 2 >>> operations = [ [\\"col\\", \\"2\\", \\"5\\"], [\\"max\\"] ] >>> process_grid_operations(N, M, Q, operations) [5] >>> N = 2 >>> M = 2 >>> Q = 6 >>> operations = [ [\\"row\\", \\"1\\", \\"2\\"], [\\"max\\"], [\\"col\\", \\"2\\", \\"3\\"], [\\"max\\"], [\\"row\\", \\"2\\", \\"1\\"], [\\"max\\"] ] >>> process_grid_operations(N, M, Q, operations) [2, 5, 5] >>> N = 3 >>> M = 3 >>> Q = 3 >>> operations = [ [\\"row\\", \\"1\\", \\"1000000000\\"], [\\"row\\", \\"2\\", \\"1000000000\\"], [\\"max\\"] ] >>> process_grid_operations(N, M, Q, operations) [1000000000]","solution":"def process_grid_operations(N, M, Q, operations): grid = [[0] * M for _ in range(N)] results = [] for op in operations: if op[0] == 'row': x, y = int(op[1]) - 1, int(op[2]) for col in range(M): grid[x][col] += y elif op[0] == 'col': x, y = int(op[1]) - 1, int(op[2]) for row in range(N): grid[row][x] += y elif op[0] == 'max': max_value = max(max(row) for row in grid) results.append(max_value) return results"},{"question":"def can_form_word(word, strings): Determine if a given word can be formed using characters from a provided set of random strings. Each random string in the set can be used more than once to create the given word. Args: word (str): The word to form. strings (List[str]): The list of random strings. Returns: str: \\"YES\\" if the word can be formed with the provided strings, otherwise \\"NO\\". Examples: >>> can_form_word(\\"apple\\", [\\"ap\\", \\"p\\", \\"ple\\"]) \\"YES\\" >>> can_form_word(\\"banana\\", [\\"an\\", \\"ban\\"]) \\"NO\\" >>> can_form_word(\\"hello\\", [\\"hel\\", \\"lo\\"]) \\"YES\\" pass def decode_inputs(T, cases): Process multiple test cases to determine if each word can be formed using the provided random strings. Args: T (int): The number of test cases. cases (List[List[str]]): A list of test cases, where each test case is a list containing the word, the number of strings, and the strings themselves. Returns: List[str]: A list of results, \\"YES\\" or \\"NO\\" for each test case. Test Cases: >>> decode_inputs(1, [[\\"apple\\", \\"3\\", \\"ap\\", \\"p\\", \\"ple\\"]]) [\\"YES\\"] >>> decode_inputs(1, [[\\"banana\\", \\"2\\", \\"an\\", \\"ban\\"]]) [\\"NO\\"] >>> decode_inputs(3, [[\\"apple\\", \\"3\\", \\"ap\\", \\"p\\", \\"ple\\"], [\\"banana\\", \\"2\\", \\"an\\", \\"ban\\"], [\\"hello\\", \\"2\\", \\"hel\\", \\"lo\\"]]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> decode_inputs(1, [[\\"hello\\", \\"2\\", \\"\\", \\"hello\\"]]) [\\"YES\\"] >>> decode_inputs(1, [[\\"hello\\", \\"3\\", \\"h\\", \\"el\\", \\"o\\"]]) [\\"NO\\"] pass","solution":"def can_form_word(word, strings): from collections import Counter word_counter = Counter(word) total_chars = Counter() for s in strings: total_chars.update(Counter(s)) for char in word_counter: if word_counter[char] > total_chars[char]: return \\"NO\\" return \\"YES\\" def decode_inputs(T, cases): results = [] for case in cases: W = case[0] N = int(case[1]) strings = case[2:] results.append(can_form_word(W, strings)) return results"},{"question":"def number_of_distinct_substrings(S: str, K: int) -> int: Returns the number of distinct substrings of length K in the string S. >>> number_of_distinct_substrings(\\"abcabc\\", 3) 3 >>> number_of_distinct_substrings(\\"aaaaaa\\", 2) 1","solution":"def number_of_distinct_substrings(S, K): Returns the number of distinct substrings of length K in the string S. substrings = set() for i in range(len(S) - K + 1): substrings.add(S[i:i+K]) return len(substrings) def process_test_cases(test_cases): results = [] for S, K in test_cases: results.append(number_of_distinct_substrings(S, int(K))) return results # Example usage: # test_cases = [(\\"abcabc\\", 3), (\\"aaaaaa\\", 2)] # print(process_test_cases(test_cases)) # Output: [3, 1]"},{"question":"def maximize_points(test_cases): Compute the maximum points that can be earned from multiple test cases with the constraint to skip at least one task. Args: test_cases (List[List[int]]): A list of test cases, each representing points earned by completing tasks. Returns: List[int]: A list of integers where each integer is the maximum points that can be earned for the corresponding test case. Example: >>> maximize_points([[1, 2, 3, 4], [0, 1, 0, 2, 5]]) [9, 8] >>> maximize_points([[10, 0], [0, 0]]) [10, 0] def test_maximize_points(): assert maximize_points([[1, 2, 3, 4], [0, 1, 0, 2, 5]]) == [9, 8] assert maximize_points([[10, 0], [0, 0]]) == [10, 0] assert maximize_points([[5, 5, 5, 5, 5], [1, 2, 3]]) == [20, 5] assert maximize_points([[100, 200, 300], [50, 0, 100, 50]]) == [500, 200] assert maximize_points([[0, 0, 10, 20], [10, 10]]) == [30, 10] assert maximize_points([[1, 0, 1], [2, 3, 4, 5, 6]]) == [2, 18] test_maximize_points()","solution":"def maximize_points(test_cases): results = [] for points in test_cases: if len(points) == 2: results.append(max(points)) else: total_points = sum(points) max_points = total_points - min(points) results.append(max_points) return results"},{"question":"def hasPairWithSum(nums: List[int], target: int) -> bool: Determines if there exists a pair of distinct integers in the list such that their sum equals the target. >>> hasPairWithSum([2, 7, 11, 15], 9) True >>> hasPairWithSum([1, 2, 3, 4], 8) False >>> hasPairWithSum([3, 2, 4], 6) True","solution":"def hasPairWithSum(nums, target): Determines if there exists a pair of distinct integers in the list such that their sum equals the target. Args: nums (List[int]): List of integers. target (int): The target integer sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"from typing import List, Tuple def longest_increasing_chain(heights: List[int]) -> int: Function to return the length of the longest strictly increasing subsequence. >>> longest_increasing_chain([3, 10, 2, 1, 20]) 3 >>> longest_increasing_chain([50, 3, 10, 7, 40, 80]) 4 pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to process multiple test cases and return the lengths of the longest strictly increasing subsequences. >>> process_test_cases(2, [(5, [3, 10, 2, 1, 20]), (6, [50, 3, 10, 7, 40, 80])]) [3, 4] pass","solution":"def longest_increasing_chain(heights): Function to return the length of the longest strictly increasing subsequence. if not heights: return 0 dp = [1] * len(heights) for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(T, test_cases): results = [] for i in range(T): N, heights = test_cases[i] results.append(longest_increasing_chain(heights)) return results"},{"question":"def larry_benefit(workshops): Determine if Larry will benefit from a series of workshops based on given criteria. Each workshop is represented by \`[a, p, b, q, c, r]\` where: - \`a\`: minimum participation time required (minutes) - \`p\`: actual participation time (minutes) - \`b\`: minimum actionable advice required (pieces) - \`q\`: actual actionable advice received (pieces) - \`c\`: maximum allowable time for Q&A (minutes) - \`r\`: actual time Q&A ended beyond the schedule (minutes) >>> larry_benefit([[60, 90, 15, 20, 5, 3]]) == [\\"YES\\"] >>> larry_benefit([[120, 100, 10, 12, 10, 15]]) == [\\"NO\\"] >>> larry_benefit([[45, 120, 20, 25, 8, 7]]) == [\\"YES\\"] >>> larry_benefit([[60, 90, 15, 20, 5, 3], [120, 100, 10, 12, 10, 15], [45, 120, 20, 25, 8, 7]]) == [\\"YES\\", \\"NO\\", \\"YES\\"] >>> larry_benefit([[30, 30, 5, 5, 0, 0]]) == [\\"YES\\"] >>> larry_benefit([[240, 240, 50, 50, 15, 15]]) == [\\"YES\\"] >>> larry_benefit([[60, 59, 15, 20, 5, 3]]) == [\\"NO\\"] >>> larry_benefit([[60, 90, 15, 14, 5, 3]]) == [\\"NO\\"] >>> larry_benefit([[60, 90, 15, 20, 5, 6]]) == [\\"NO\\"]","solution":"def larry_benefit(workshops): result = [] for workshop in workshops: a, p, b, q, c, r = workshop if p >= a and q >= b and r <= c: result.append(\\"YES\\") else: result.append(\\"NO\\") return result # Sample use workshops = [ [60, 90, 15, 20, 5, 3], [120, 100, 10, 12, 10, 15], [45, 120, 20, 25, 8, 7] ] print(larry_benefit(workshops)) # Expected: ['YES', 'NO', 'YES']"},{"question":"def max_sum_with_min_length(arr, k): Given an array of integers \`arr\` and an integer \`k\`, find the maximum sum of any contiguous subarray with a length of at least \`k\`. >>> max_sum_with_min_length([1, -2, 3, 4, -5, 6], 2) 8 >>> max_sum_with_min_length([-1, -2, -3, -4, -5, -6, -7, -8], 3) -6 >>> max_sum_with_min_length([10, -5, 3, -1, 8, -2, 4, 7, -11, -6], 5) 24","solution":"def max_sum_with_min_length(arr, k): n = len(arr) # Compute the sum of first \`k\` elements current_sum = sum(arr[:k]) max_sum = current_sum # Array to keep track of maximum sum subarray that ends at each index max_subarray_sum_end = [0] * n max_subarray_sum_end[k-1] = current_sum # Iterate from k to n to find maximum sums for subarrays of at least length k for i in range(k, n): current_sum += arr[i] current_sum -= arr[i-k] max_subarray_sum_end[i] = max(max_subarray_sum_end[i-1] + arr[i], current_sum) max_sum = max(max_sum, max_subarray_sum_end[i]) return max_sum"},{"question":"def smallest_permutation_by_cyclic_shift(n: int, arr: List[int]) -> List[int]: Given an integer array of length n, find the smallest permutation of the array that can be obtained by performing one or more cyclic shifts. >>> smallest_permutation_by_cyclic_shift(4, [3, 1, 2, 4]) [1, 2, 4, 3] >>> smallest_permutation_by_cyclic_shift(5, [5, 4, 3, 2, 1]) [1, 5, 4, 3, 2]","solution":"def smallest_permutation_by_cyclic_shift(n, arr): min_perm = arr for i in range(n): arr = arr[1:] + arr[:1] if arr < min_perm: min_perm = arr return min_perm"},{"question":"def count_long_strings(strings: List[str]) -> dict: Returns a dictionary containing the counts of strings with more than three characters (ignoring case). >>> count_long_strings([\\"Apple\\", \\"BANANA\\", \\"apple\\", \\"Dog\\", \\"Cat\\", \\"elephant\\"]) {\\"apple\\": 2, \\"banana\\": 1, \\"elephant\\": 1} >>> count_long_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"dog\\", \\"cat\\", \\"elephant\\"]) {\\"apple\\": 2, \\"banana\\": 1, \\"elephant\\": 1} >>> count_long_strings([\\"APPLE\\", \\"BANANA\\", \\"DOG\\", \\"CAT\\", \\"ELEPHANT\\"]) {\\"apple\\": 1, \\"banana\\": 1, \\"elephant\\": 1} >>> count_long_strings([\\"a\\", \\"abcd\\", \\"abcde\\", \\"abcd\\", \\"ABCD\\"]) {\\"abcd\\": 3, \\"abcde\\": 1} >>> count_long_strings([\\"a\\", \\"ab\\", \\"abc\\"]) {} >>> count_long_strings([]) {}","solution":"def count_long_strings(strings): Returns a dictionary containing the counts of strings with more than three characters (ignoring case). count_dict = {} for string in strings: lower_string = string.lower() if len(lower_string) > 3: if lower_string in count_dict: count_dict[lower_string] += 1 else: count_dict[lower_string] = 1 return count_dict"},{"question":"from typing import List, Dict def find_event_order(events: List[Dict[str, List[str]]]) -> List[str]: Given a list of events with their prerequisites, find an order in which the events can be completed. If it is impossible to complete all events, return an empty list. Args: events (List[Dict[str, List[str]]]): A list of events, where each event is represented as a dictionary with an 'id' and 'prerequisites'. Returns: List[str]: A list of event ids in the order they should be completed. Example: >>> events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": [\\"event2\\", \\"event3\\"]}, {\\"id\\": \\"event2\\", \\"prerequisites\\": [\\"event4\\"]}, {\\"id\\": \\"event3\\", \\"prerequisites\\": []}, {\\"id\\": \\"event4\\", \\"prerequisites\\": []} ] >>> find_event_order(events) [\\"event4\\", \\"event2\\", \\"event3\\", \\"event1\\"] Example: >>> events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": [\\"event2\\"]}, {\\"id\\": \\"event2\\", \\"prerequisites\\": [\\"event3\\"]}, {\\"id\\": \\"event3\\", \\"prerequisites\\": [\\"event1\\"]} ] >>> find_event_order(events) [] # (Write your code here.) Unit Test: from solution import find_event_order def test_no_prerequisites(): events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": []}, {\\"id\\": \\"event2\\", \\"prerequisites\\": []} ] assert find_event_order(events) == [\\"event1\\", \\"event2\\"] or find_event_order(events) == [\\"event2\\", \\"event1\\"] def test_simple_chain(): events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": [\\"event2\\"]}, {\\"id\\": \\"event2\\", \\"prerequisites\\": []} ] assert find_event_order(events) == [\\"event2\\", \\"event1\\"] def test_complex_dependency(): events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": [\\"event2\\", \\"event3\\"]}, {\\"id\\": \\"event2\\", \\"prerequisites\\": [\\"event4\\"]}, {\\"id\\": \\"event3\\", \\"prerequisites\\": []}, {\\"id\\": \\"event4\\", \\"prerequisites\\": []} ] result = find_event_order(events) assert result == [\\"event4\\", \\"event2\\", \\"event3\\", \\"event1\\"] or result == [\\"event3\\", \\"event4\\", \\"event2\\", \\"event1\\"] def test_cycle(): events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": [\\"event2\\"]}, {\\"id\\": \\"event2\\", \\"prerequisites\\": [\\"event3\\"]}, {\\"id\\": \\"event3\\", \\"prerequisites\\": [\\"event1\\"]} ] assert find_event_order(events) == [] def test_disconnected_events(): events = [ {\\"id\\": \\"event1\\", \\"prerequisites\\": []}, {\\"id\\": \\"event2\\", \\"prerequisites\\": []}, {\\"id\\": \\"event3\\", \\"prerequisites\\": [\\"event4\\"]}, {\\"id\\": \\"event4\\", \\"prerequisites\\": []} ] result = find_event_order(events) assert \\"event3\\" in result and \\"event4\\" in result assert result.index(\\"event4\\") < result.index(\\"event3\\") result.remove(\\"event3\\") result.remove(\\"event4\\") assert result == [\\"event1\\", \\"event2\\"] or result == [\\"event2\\", \\"event1\\"]","solution":"def find_event_order(events): from collections import defaultdict, deque event_map = {event['id']: event['prerequisites'] for event in events} indegree = {event['id']: 0 for event in events} # Calculate the indegree (number of prerequisites) for each event for event in events: for prereq in event['prerequisites']: indegree[event['id']] += 1 # Initialize queue with events having no prerequisites queue = deque([event_id for event_id, degree in indegree.items() if degree == 0]) order = [] while queue: current_event = queue.popleft() order.append(current_event) for event in events: if current_event in event['prerequisites']: indegree[event['id']] -= 1 if indegree[event['id']] == 0: queue.append(event['id']) if len(order) == len(events): return order else: return []"},{"question":"def detect_cycle_in_directed_graph(n, edges): Detects if there is a cycle in a directed graph. Params: n - the number of nodes edges - list of tuples (u, v) representing the directed edges Returns: \\"YES\\" if there is at least one cycle in the graph, otherwise \\"NO\\" pass def process_test_cases(test_cases): Processes multiple test cases to determine if each directed graph contains a cycle. Params: test_cases - list of tuples, where each tuple contains: n - number of nodes m - number of edges edges - list of tuples (u, v) representing the directed edges Returns: list of strings, each being \\"YES\\" or \\"NO\\" for the corresponding test case pass # Unit Tests def test_sample_input(): test_cases = [ (4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]), (3, 2, [(1,2), (2,3)]) ] assert process_test_cases(test_cases) == [\\"YES\\", \\"NO\\"] def test_no_edges(): test_cases = [ (3, 0, []) ] assert process_test_cases(test_cases) == [\\"NO\\"] def test_self_loop(): test_cases = [ (3, 1, [(1, 1)]) ] assert process_test_cases(test_cases) == [\\"YES\\"] def test_multiple_cycles(): test_cases = [ (5, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) ] assert process_test_cases(test_cases) == [\\"YES\\"] def test_disconnected_components(): test_cases = [ (6, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) ] assert process_test_cases(test_cases) == [\\"YES\\"] def test_large_input_no_cycle(): test_cases = [ (10, 9, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]) ] assert process_test_cases(test_cases) == [\\"NO\\"] def test_large_input_with_cycle(): test_cases = [ (10, 10, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 1)]) ] assert process_test_cases(test_cases) == [\\"YES\\"]","solution":"from collections import defaultdict, deque def detect_cycle_in_directed_graph(n, edges): def has_cycle(v): if visited[v] == 1: return True if visited[v] == 2: return False visited[v] = 1 for neighbor in graph[v]: if has_cycle(neighbor): return True visited[v] = 2 return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [0] * (n + 1) for node in range(1, n + 1): if visited[node] == 0: if has_cycle(node): return \\"YES\\" return \\"NO\\" def process_test_cases(test_cases): results = [] for n, m, edges in test_cases: result = detect_cycle_in_directed_graph(n, edges) results.append(result) return results"},{"question":"from typing import Dict, List, Union def merge_groups(groups: List[Union[Dict[str, List[str]], Dict[str, List[Union[Dict[str, List[str]], List[str]]]]]]) -> Dict[str, List[str]]: Merges a list of groups into a single group with unique capabilities. Each group can be either a Simple Group, which contains a unique set of capabilities, or a Compound Group, which consists of nested groups (either Simple or Compound). The function ensures no duplicate capabilities within the final merged group. The input list can contain up to 1000 groups, and capabilities are alphanumeric strings of up to 20 characters in length. Example: >>> groups = [ >>> { \\"Simple\\": [\\"read\\", \\"write\\"] }, >>> { \\"Compound\\": [ >>> { \\"Simple\\": [\\"execute\\"] }, >>> { \\"Compound\\": [ >>> { \\"Simple\\": [\\"delete\\", \\"write\\"] }, >>> { \\"Simple\\": [\\"read\\", \\"upload\\"] } >>> ] } >>> ] } >>> ] >>> merge_groups(groups) {\\"Simple\\": [\\"delete\\", \\"execute\\", \\"read\\", \\"upload\\", \\"write\\"]} # Your implementation here # Unit Tests def test_merge_groups_example(): groups = [ { \\"Simple\\": [\\"read\\", \\"write\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"execute\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"delete\\", \\"write\\"] }, { \\"Simple\\": [\\"read\\", \\"upload\\"] } ] } ] } ] expected_output = {\\"Simple\\": [\\"delete\\", \\"execute\\", \\"read\\", \\"upload\\", \\"write\\"]} assert merge_groups(groups) == expected_output def test_merge_groups_single_simple_group(): groups = [ { \\"Simple\\": [\\"view\\", \\"edit\\"] } ] expected_output = {\\"Simple\\": [\\"edit\\", \\"view\\"]} assert merge_groups(groups) == expected_output def test_merge_groups_no_groups(): groups = [] expected_output = {\\"Simple\\": []} assert merge_groups(groups) == expected_output def test_merge_groups_duplicate_capabilities(): groups = [ { \\"Simple\\": [\\"add\\", \\"remove\\"] }, { \\"Simple\\": [\\"add\\", \\"update\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"remove\\"] }, { \\"Simple\\": [\\"delete\\", \\"update\\"] } ] } ] expected_output = {\\"Simple\\": [\\"add\\", \\"delete\\", \\"remove\\", \\"update\\"]} assert merge_groups(groups) == expected_output def test_merge_groups_deeply_nested_structure(): groups = [ { \\"Simple\\": [\\"alpha\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"beta\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"gamma\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"delta\\"] }, { \\"Simple\\": [\\"gamma\\", \\"epsilon\\"] } ] } ] } ] } ] expected_output = {\\"Simple\\": [\\"alpha\\", \\"beta\\", \\"delta\\", \\"epsilon\\", \\"gamma\\"]} assert merge_groups(groups) == expected_output","solution":"from typing import Dict, List, Union def merge_groups(groups: List[Union[Dict[str, List[str]], Dict[str, List[Union[Dict[str, List[str]], List[str]]]]]]) -> Dict[str, List[str]]: def get_capabilities(group): capabilities = set() if \\"Simple\\" in group: capabilities.update(group[\\"Simple\\"]) elif \\"Compound\\" in group: for sub_group in group[\\"Compound\\"]: capabilities.update(get_capabilities(sub_group)) return capabilities all_capabilities = set() for group in groups: all_capabilities.update(get_capabilities(group)) return {\\"Simple\\": sorted(all_capabilities)} # Example usage: groups = [ { \\"Simple\\": [\\"read\\", \\"write\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"execute\\"] }, { \\"Compound\\": [ { \\"Simple\\": [\\"delete\\", \\"write\\"] }, { \\"Simple\\": [\\"read\\", \\"upload\\"] } ] } ] } ] merged_group = merge_groups(groups) print(merged_group) # Expected Output: { \\"Simple\\": [\\"delete\\", \\"execute\\", \\"read\\", \\"upload\\", \\"write\\"] }"},{"question":"import math import sys def determine_product(n: int) -> None: Determine the product of all elements in a 1-based array of n integers, where each integer is either -1, 0, or 1 by performing queries. Args: n (int): Number of elements in the array. Interaction: To query for the value at the index \`i\`, print \`? i\` (1 ≤ i ≤ n). When you deduce the product, print \`!\` followed by the product and finish your program. Example: >>> determine_product(4) ? 1 1 ? 2 0 ! 0 >>> determine_product(3) ? 1 -1 ? 2 1 ? 3 1 ! -1 # Implement the determine_product function","solution":"import math import sys def determine_product(n): zero_found = False product = 1 max_queries = int(2 * math.sqrt(n)) for i in range(1, n + 1): if max_queries <= 0: break print(f'? {i}') sys.stdout.flush() value = int(input().strip()) if value == 0: zero_found = True break product *= value max_queries -= 1 if zero_found: result = 0 else: result = product print(f'! {result}') sys.stdout.flush() # Example Usage: # determine_product(4)"},{"question":"def max_contiguous_subarray_sum(calories): Determine the contiguous subarray within an array of integers that has the maximum sum. Args: calories (List[int]): Array of integers representing calorie intake over a number of days. Returns: int: The maximum sum of the contiguous subarray. Examples: >>> max_contiguous_subarray_sum([1, -2, 3, 10, -4]) 13 >>> max_contiguous_subarray_sum([-3, 4, -1, 2, 1, -5, 4]) 6 from solution import max_contiguous_subarray_sum def test_single_positive_element(): assert max_contiguous_subarray_sum([5]) == 5 def test_single_negative_element(): assert max_contiguous_subarray_sum([-5]) == -5 def test_all_positive_numbers(): assert max_contiguous_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_all_negative_numbers(): assert max_contiguous_subarray_sum([-1, -2, -3, -4, -5]) == -1 def test_mixed_sign_numbers(): assert max_contiguous_subarray_sum([1, -2, 3, 10, -4]) == 13 def test_larger_array_with_mixed_sign_numbers(): assert max_contiguous_subarray_sum([-3, 4, -1, 2, 1, -5, 4]) == 6 def test_array_with_zeroes(): assert max_contiguous_subarray_sum([0, -3, 5, -1, 0, 3]) == 7 def test_array_with_single_element_being_part_of_maximum_sum(): assert max_contiguous_subarray_sum([1, 2, 3, -2, -1, 4, 2, -1, 5, -6]) == 13 def test_empty_array(): try: max_contiguous_subarray_sum([]) assert False, \\"Exception not raised for empty input\\" except IndexError: assert True def test_large_input(): assert max_contiguous_subarray_sum(list(range(-1000, 1000))) == sum(range(0, 1000))","solution":"def max_contiguous_subarray_sum(calories): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. max_sum = current_sum = calories[0] for calorie in calories[1:]: current_sum = max(calorie, current_sum + calorie) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_smallest_period_length(N, S): Determines the length of the smallest substring that can be repeated to form the entire string S of length N. >>> find_smallest_period_length(6, \\"ababab\\") 2 >>> find_smallest_period_length(9, \\"abcabcabc\\") 3 >>> find_smallest_period_length(4, \\"abcd\\") 4 def process_test_cases(test_cases): Processes multiple test cases. >>> process_test_cases([(6, \\"ababab\\"), (9, \\"abcabcabc\\"), (4, \\"abcd\\")]) [2, 3, 4] >>> process_test_cases([(1, \\"a\\"), (5, \\"aaaaa\\"), (3, \\"aba\\")]) [1, 1, 3] >>> process_test_cases([(8, \\"abcdabcd\\"), (6, \\"xyzxyz\\"), (7, \\"abcdefg\\")]) [4, 3, 7]","solution":"def find_smallest_period_length(N, S): Determines the length of the smallest substring that can be repeated to form the entire string S of length N. for length in range(1, N + 1): if N % length == 0: substring = S[:length] if substring * (N // length) == S: return length return N def process_test_cases(test_cases): Processes multiple test cases. results = [] for N, S in test_cases: results.append(find_smallest_period_length(N, S)) return results"},{"question":"def singlePeakNumbers(X): Given a positive integer X, return the single peak numbers in the range from 1 to X. A single peak number has exactly one local peak in its binary representation. >>> singlePeakNumbers(5) [2, 4] >>> singlePeakNumbers(10) [2, 4, 8] from solution import singlePeakNumbers def test_single_peak_numbers_example_cases(): assert singlePeakNumbers(5) == [2, 4] assert singlePeakNumbers(10) == [2, 4, 8] def test_single_peak_numbers_additional_cases(): assert singlePeakNumbers(1) == [] assert singlePeakNumbers(15) == [2, 4, 8] assert singlePeakNumbers(20) == [2, 4, 8, 16] def test_single_peak_numbers_edge_cases(): assert singlePeakNumbers(0) == [] assert singlePeakNumbers(2) == [2] assert singlePeakNumbers(16) == [2, 4, 8, 16] assert singlePeakNumbers(31) == [2, 4, 8, 16]","solution":"def singlePeakNumbers(X): Returns a list of single peak numbers from 1 to X. A single peak number has exactly one '1' bit immediately surrounded by '0' bits. def is_single_peak(num): binary_representation = bin(num)[2:] return binary_representation.count('1') == 1 and binary_representation.endswith('0') result = [] for i in range(1, X + 1): if is_single_peak(i): result.append(i) return result"},{"question":"from collections import Counter def min_deletions_to_make_anagrams(s1: str, s2: str) -> int: Given a string s1 and s2, determines the minimum number of characters that need to be deleted from both strings to make them anagrams of each other. Returns the number of deletions required. :param s1: string :param s2: string :return: int >>> min_deletions_to_make_anagrams(\\"abc\\", \\"cde\\") 4 >>> min_deletions_to_make_anagrams(\\"aabbcc\\", \\"bbaacc\\") 0 pass def test_example_1(): assert min_deletions_to_make_anagrams(\\"abc\\", \\"cde\\") == 4 def test_example_2(): assert min_deletions_to_make_anagrams(\\"aabbcc\\", \\"bbaacc\\") == 0 def test_example_3(): assert min_deletions_to_make_anagrams(\\"hello\\", \\"billion\\") == 6 def test_example_4(): assert min_deletions_to_make_anagrams(\\"abcdef\\", \\"fghijk\\") == 10 def test_case_same_characters(): assert min_deletions_to_make_anagrams(\\"aaaa\\", \\"aaaa\\") == 0 def test_case_disjoint_strings(): assert min_deletions_to_make_anagrams(\\"abc\\", \\"def\\") == 6 def test_case_single_char_diff(): assert min_deletions_to_make_anagrams(\\"a\\", \\"b\\") == 2 def test_case_large_input(): s1 = \\"a\\" * 1000 s2 = \\"b\\" * 1000 assert min_deletions_to_make_anagrams(s1, s2) == 2000","solution":"from collections import Counter def min_deletions_to_make_anagrams(s1, s2): This function returns the minimum number of deletions required to make two strings anagrams of each other. :param s1: string :param s2: string :return: int counter1 = Counter(s1) counter2 = Counter(s2) # find characters that are in s1 but not in s2 and vice versa unique_to_s1 = counter1 - counter2 unique_to_s2 = counter2 - counter1 return sum(unique_to_s1.values()) + sum(unique_to_s2.values())"},{"question":"from typing import List def number_of_paths(grid: List[str]) -> int: Determine the number of possible distinct paths from the top-left to the bottom-right of the grid, given that ships can only move right or down and that 'X' represents obstacles while 'O' represents navigable water. Args: grid: List of strings representing the grid where 'O' is navigable and 'X' is an obstacle. Returns: The number of distinct paths from the top-left to the bottom-right cell. >>> number_of_paths([\\"OOO\\", \\"OXO\\", \\"OOO\\"]) 2 >>> number_of_paths([\\"OX\\", \\"OO\\"]) 1 >>> number_of_paths([\\"OX\\", \\"XO\\"]) 0","solution":"def number_of_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 'X' or grid[n-1][m-1] == 'X': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 'O': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def path_exists(N, obstacles): Determine whether there exists a path from the top-left corner (1, 1) to the bottom-right corner (N, N) on a grid with obstacles. :param N: int - The size of the grid (N x N) :param obstacles: set - Set of tuples representing coordinates of obstacles :return: bool - True if there exists a path, otherwise False pass def find_paths(test_cases): Determine the paths for multiple test cases. :param test_cases: List of tuples, where each tuple contains the grid size, number of obstacles, and list of obstacle coordinates. :return: List of strings - \\"YES\\" or \\"NO\\" for each test case, indicating whether a path exists. pass # Unit Tests def test_path_exists(): test_cases = [ (5, [(3, 3), (3, 4), (4, 3)], 'YES'), (5, [(5, 5)], 'NO'), (2, [], 'YES'), (2, [(1, 2), (2, 1)], 'NO'), (3, [(2, 2)], 'YES'), (3, [(1, 1)], 'NO'), ] for N, obstacles, expected in test_cases: result = \\"YES\\" if path_exists(N, set(obstacles)) else \\"NO\\" assert result == expected, f\\"Failed for N={N}, obstacles={obstacles}.\\" def test_find_paths(): test_cases = [ ([(5, 3, [(3, 3), (3, 4), (4, 3)]), (5, 1, [(5, 5)])], [\\"YES\\", \\"NO\\"]), ([(2, 0, []), (2, 2, [(1, 2), (2, 1)])], [\\"YES\\", \\"NO\\"]), ] for inputs, expected in test_cases: assert find_paths(inputs) == expected, f\\"Failed for inputs={inputs}.\\"","solution":"def path_exists(N, obstacles): from collections import deque if (1, 1) in obstacles or (N, N) in obstacles: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = set() queue = deque([(1, 1)]) visited.add((1, 1)) while queue: x, y = queue.popleft() if (x, y) == (N, N): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 1 <= nx <= N and 1 <= ny <= N and (nx, ny) not in obstacles and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False def find_paths(test_cases): results = [] for N, P, obstacles in test_cases: if path_exists(N, set(obstacles)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def processOperations(N, operations): Processes a series of 'ADD' and 'MULTIPLY' operations on an array of size N. :param N: int - Size of the array, elements A[i] initialized from 1 to N. :param operations: List[Tuple[str, int, int]] - The operations to be performed. :return: List[int] - The array after all operations are performed.","solution":"def processOperations(N, operations): Processes a series of 'ADD' and 'MULTIPLY' operations on an array of size N. :param N: int - Size of the array, elements A[i] initialized from 1 to N. :param operations: List[Tuple[str, int, int]] - The operations to be performed. :return: List[int] - The array after all operations are performed. # Initialize the array A with values from 1 to N A = list(range(1, N + 1)) # Iterate through the list of operations for operation in operations: op, X, Y = operation if op == 'ADD': A[X - 1] += Y elif op == 'MULTIPLY': A[X - 1] *= Y # Return the final array A after performing all operations return A"},{"question":"def robot_movement(commands): Simulates the movement of a robot in a 2D grid starting at the origin (0, 0). Parameters: commands (list of str): A list of commands instructing the robot to move in the grid. Returns: tuple: The final coordinates of the robot after executing all the given commands. Examples: >>> robot_movement([\\"UP\\", \\"UP\\", \\"LEFT\\", \\"DOWN\\", \\"RIGHT\\"]) (1, 1) >>> robot_movement([\\"LEFT\\", \\"LEFT\\", \\"UP\\", \\"UP\\"]) (-2, 2) >>> robot_movement([]) (0, 0)","solution":"def robot_movement(commands): Simulates the movement of a robot in a 2D grid starting at the origin (0, 0). Parameters: commands (list of str): A list of commands instructing the robot to move in the grid. Returns: tuple: The final coordinates of the robot after executing all the given commands. x, y = 0, 0 for command in commands: if command == \\"UP\\": y += 1 elif command == \\"DOWN\\": y -= 1 elif command == \\"LEFT\\": x -= 1 elif command == \\"RIGHT\\": x += 1 return (x, y)"},{"question":"def find_manager_at_level(n, reports, e, k): Function to determine the manager at a given level above a specified employee. :param n: Number of employees :param reports: List of tuples where each tuple (u, v) means employee v reports directly to employee u :param e: Specified employee :param k: Levels above the specified employee :return: The ID of the manager at the level k above the employee e or -1 if there is no such manager >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 5, 2) 1 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 4, 1) 2 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 7, 2) 1 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 6, 3) -1 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 3, 1) 1 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 2, 0) 2 >>> find_manager_at_level(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 1, 1) -1","solution":"def find_manager_at_level(n, reports, e, k): Function to determine the manager at a given level above a specified employee. :param n: Number of employees :param reports: List of tuples where each tuple (u, v) means employee v reports directly to employee u :param e: Specified employee :param k: Levels above the specified employee :return: The ID of the manager at the level k above the employee e or -1 if there is no such manager # Build the tree structure managers = {} for report in reports: u, v = report managers[v] = u current_employee = e while k > 0 and current_employee in managers: current_employee = managers[current_employee] k -= 1 return current_employee if k == 0 else -1 # Example usage: n = 7 reports = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] e = 5 k = 2 print(find_manager_at_level(n, reports, e, k)) # Output should be: 1"},{"question":"def num_unique_islands(n: int, m: int, grid: List[List[str]]) -> int: Determine the number of unique islands in the grid. >>> num_unique_islands(5, 5, [ ... ['.', '*', '.', '.', '.'], ... ['.', '*', '.', '*', '.'], ... ['.', '.', '*', '.', '.'], ... ['*', '.', '*', '*', '.'], ... ['.', '*', '.', '.', '*'] ... ]) 4 >>> num_unique_islands(3, 3, [ ... ['*', '*', '*'], ... ['*', '.', '*'], ... ['*', '*', '*'] ... ]) 1 >>> num_unique_islands(4, 4, [ ... ['.', '.', '*', '.'], ... ['.', '*', '.', '*'], ... ['*', '.', '*', '.'], ... ['.', '*', '.', '.'] ... ]) 6 >>> num_unique_islands(4, 4, [ ... ['*', '*', '*', '*'], ... ['*', '*', '*', '*'], ... ['*', '*', '*', '*'], ... ['*', '*', '*', '*'] ... ]) 0 >>> num_unique_islands(3, 3, [ ... ['.', '.', '.'], ... ['.', '.', '.'], ... ['.', '.', '.'] ... ]) 1 pass","solution":"def num_unique_islands(n, m, grid): def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.': stack.append((ni, nj)) grid[ni][nj] = '#' # Mark visited island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': dfs(i, j) island_count += 1 return island_count"},{"question":"def calculate_bonus(employees_scores: dict) -> dict: Calculate the bonus for each employee based on their project scores. The bonus is calculated as follows: - For each project score that is >= 90, the employee gets a bonus of 100. - For each project score that is between 80 and 89 (inclusive), the employee gets a bonus of 50. - For each project score that is between 70 and 79 (inclusive), the employee gets a bonus of 20. - Project scores below 70 do not contribute to the bonus. Parameters: employees_scores (dict): A dictionary where the keys are employee names, and the values are lists of their scores from different projects. Returns: dict: A dictionary where the keys are employee names, and the values are their bonuses based on the project scores. pass from calculate_bonus import calculate_bonus def test_calculate_bonus_example(): input_data = { \\"Alice\\": [92, 85, 78, 88, 99], \\"Bob\\": [60, 70, 80, 90], \\"Charlie\\": [100, 60, 75, 85, 90] } expected_output = { \\"Alice\\": 320, \\"Bob\\": 170, \\"Charlie\\": 270 } assert calculate_bonus(input_data) == expected_output def test_calculate_bonus_all_high_scores(): input_data = { \\"Alice\\": [90, 91, 92, 93], # All scores >= 90 \\"Bob\\": [88, 89, 90, 91], # Mix of scores \\"Charlie\\": [100, 100, 100] # All perfect scores } expected_output = { \\"Alice\\": 400, # 4 * 100 \\"Bob\\": 300, # 2 * 50 + 2 * 100 \\"Charlie\\": 300 # 3 * 100 } assert calculate_bonus(input_data) == expected_output def test_calculate_bonus_no_contributing_scores(): input_data = { \\"Alice\\": [60, 65, 69], \\"Bob\\": [0, 59, 68] } expected_output = { \\"Alice\\": 0, # All scores < 70 \\"Bob\\": 0 # All scores < 70 } assert calculate_bonus(input_data) == expected_output def test_calculate_bonus_varied_scores(): input_data = { \\"Alice\\": [100, 80, 70, 60], \\"Bob\\": [90, 85, 75, 65] } expected_output = { \\"Alice\\": 170, # 100 + 50 + 20 + 0 \\"Bob\\": 170 # 100 + 50 + 20 + 0 } assert calculate_bonus(input_data) == expected_output def test_calculate_bonus_single_employee(): input_data = { \\"Alice\\": [72, 83] } expected_output = { \\"Alice\\": 70 # 20 + 50 } assert calculate_bonus(input_data) == expected_output def test_calculate_bonus_single_project_score(): input_data = { \\"Alice\\": [72], \\"Bob\\": [90] } expected_output = { \\"Alice\\": 20, \\"Bob\\": 100 } assert calculate_bonus(input_data) == expected_output","solution":"def calculate_bonus(employees_scores): Calculate the bonus for each employee based on their project scores. Args: - employees_scores (dict): A dictionary where the keys are employee names and the values are lists of their scores from different projects. Returns: dict: A dictionary where the keys are employee names and the values are their bonuses. bonuses = {} for employee, scores in employees_scores.items(): bonus = 0 for score in scores: if score >= 90: bonus += 100 elif 80 <= score <= 89: bonus += 50 elif 70 <= score <= 79: bonus += 20 bonuses[employee] = bonus return bonuses"},{"question":"def get_nth_term(n): Returns the Nth term of the sequence defined as follows: - The first two terms are 1 and 2 - Each subsequent term is the sum of the previous two terms Args: n (int): The position of the term to be found. Returns: int: The Nth term of the sequence. Examples: >>> get_nth_term(1) 1 >>> get_nth_term(2) 2 >>> get_nth_term(5) 8 pass def solve_sequence(T, cases): Solves the sequence problem for multiple test cases. Args: T (int): The number of test cases. cases (List[int]): A list of integers representing the positions of the terms. Returns: List[int]: A list of the Nth terms for each test case. Examples: >>> solve_sequence(3, [1, 2, 5]) [1, 2, 8] >>> solve_sequence(2, [3, 6]) [3, 13] pass","solution":"def get_nth_term(n): Returns the Nth term of the sequence defined as follows: - The first two terms are 1 and 2 - Each subsequent term is the sum of the previous two terms # Handle base cases if n == 1: return 1 elif n == 2: return 2 # Initialize the first two terms a, b = 1, 2 # Calculate subsequent terms up to the nth term for _ in range(3, n + 1): a, b = b, a + b return b def solve_sequence(T, cases): results = [] for n in cases: results.append(get_nth_term(n)) return results"},{"question":"def can_visit_all_intersections(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Determine whether all intersections can be visited starting from the first intersection. Args: n (int): Number of intersections. m (int): Number of directed roads. roads (List[Tuple[int, int]]): List of directed roads as tuples. Returns: str: \\"YES\\" if it is possible to visit all intersections starting from the first intersection, otherwise \\"NO\\". Examples: >>> can_visit_all_intersections(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> can_visit_all_intersections(4, 2, [(1, 2), (3, 4)]) 'NO' pass # Unit tests def test_sample_input_1(): assert can_visit_all_intersections(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" def test_sample_input_2(): assert can_visit_all_intersections(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" def test_all_nodes_are_connected(): assert can_visit_all_intersections(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" def test_disconnected_graph(): assert can_visit_all_intersections(4, 2, [(1, 2), (2, 3)]) == \\"NO\\" def test_min_case_1_node(): assert can_visit_all_intersections(1, 0, []) == \\"YES\\" def test_min_case_2_nodes(): assert can_visit_all_intersections(2, 1, [(1, 2)]) == \\"NO\\" def test_max_case(): n = 10**5 m = 2 * 10**5 roads = [(i, i+1) for i in range(1, n)] + [(i, i) for i in range(1, m-n+1)] assert can_visit_all_intersections(n, m, roads) == \\"NO\\"","solution":"def can_visit_all_intersections(n, m, roads): from collections import defaultdict, deque def bfs(start, graph): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbour in graph[node]: if neighbour not in visited: queue.append(neighbour) return visited # Create a graph graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in roads: graph[u].append(v) reverse_graph[v].append(u) # Traverse from node 1 visited_from_start = bfs(1, graph) # If not all nodes are visited, return NO if len(visited_from_start) != n: return \\"NO\\" # Traverse the reverse graph from node 1 visited_in_reverse_graph = bfs(1, reverse_graph) # If not all nodes are visited in reverse graph, return NO if len(visited_in_reverse_graph) != n: return \\"NO\\" return \\"YES\\""},{"question":"def minutes_to_arrange_artists(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Alex is organizing a line of artists for a photo shoot. The artists belong to two different genres: Singers and Dancers. He wants all Singers to stand to the left side and all Dancers to stand to the right side of the line. Initially, the positions of the artists are given by N binary integers, where 0 represents a Dancer and 1 represents a Singer. In each minute, if a Singer finds a Dancer standing immediately to their left, they can swap positions. Alex needs to know the total time required to arrange the line such that all Singers are on the left and all Dancers are on the right. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of artists and their initial arrangement. Returns: List[int]: A list of integers where each integer represents the time required for a respective test case. >>> T, test_cases = parse_input(\\"2n6n1 0 1 0 1 0n4n1 0 1 0\\") >>> minutes_to_arrange_artists(T, test_cases) [3, 2] >>> T, test_cases = parse_input(\\"1n1n1\\") >>> minutes_to_arrange_artists(T, test_cases) [0] >>> T, test_cases = parse_input(\\"1n3n1 1 1\\") >>> minutes_to_arrange_artists(T, test_cases) [0] >>> T, test_cases = parse_input(\\"1n3n0 0 0\\") >>> minutes_to_arrange_artists(T, test_cases) [0] >>> T, test_cases = parse_input(\\"1n10n1 0 1 0 1 0 1 0 1 0\\") >>> minutes_to_arrange_artists(T, test_cases) [5] >>> T, test_cases = parse_input(\\"1n5n1 0 1 0 1\\") >>> minutes_to_arrange_artists(T, test_cases) [2] def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parses the input string to extract the number of test cases and the arrangements. Parameters: input_str (str): The input string containing test cases. Returns: Tuple[int, List[Tuple[int, List[int]]]]: The number of test cases and a list of arrangements. >>> parse_input(\\"2n6n1 0 1 0 1 0n4n1 0 1 0\\") (2, [(6, [1, 0, 1, 0, 1, 0]), (4, [1, 0, 1, 0])])","solution":"def minutes_to_arrange_artists(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arrangement = test_cases[i][1] time = 0 while True: swaps = 0 for j in range(N-1): if arrangement[j] == 1 and arrangement[j+1] == 0: arrangement[j], arrangement[j+1] = arrangement[j+1], arrangement[j] swaps += 1 if swaps == 0: break time += 1 results.append(time) return results # Function to parse input easily, this is not part of the main solution def parse_input(input_str): input_list = input_str.split('n') T = int(input_list[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_list[index]) arrangement = list(map(int, input_list[index + 1].split())) test_cases.append((N, arrangement)) index += 2 return T, test_cases"},{"question":"def award_participants(n: int, times: List[str]) -> List[str]: Distribute awards to participants based on their running times. >>> award_participants(7, [\\"02:45:30\\", \\"03:30:10\\", \\"02:10:20\\", \\"01:22:30\\", \\"02:50:10\\", \\"01:45:50\\", \\"03:10:00\\"]) [\\"01:22:30 Gold\\", \\"01:45:50 Gold\\", \\"02:10:20 Gold\\", \\"02:45:30 Silver\\", \\"02:50:10 Silver\\", \\"03:10:00 Bronze\\", \\"03:30:10 Bronze\\"] >>> award_participants(2, [\\"01:55:00\\", \\"02:40:20\\"]) [] >>> award_participants(9, [\\"05:20:30\\", \\"04:50:00\\", \\"06:15:30\\", \\"05:00:00\\", \\"05:10:00\\", \\"06:25:00\\", \\"04:40:30\\", \\"05:30:20\\", \\"04:55:55\\"]) [\\"04:40:30 Gold\\", \\"04:50:00 Gold\\", \\"04:55:55 Gold\\", \\"05:00:00 Silver\\", \\"05:10:00 Silver\\", \\"05:20:30 Bronze\\", \\"05:30:20 Bronze\\", \\"06:15:30 Bronze\\", \\"06:25:00 Bronze\\"]","solution":"def award_participants(n, times): if n < 3: return [] times.sort() # sort times in ascending order awards = ['Gold'] * 3 + ['Silver'] * 2 + ['Bronze'] * 5 results = [] for i in range(min(n, 10)): results.append(f\\"{times[i]} {awards[i]}\\") return results"},{"question":"def find_top_performers(N: int, M: int, round1_ids: List[int], round2_ids: List[int], K: int) -> List[int]: Returns a list of participant ids who are in the top K positions in both rounds in ascending order. If no such participants exist, return an empty list. >>> find_top_performers(5, 7, [1, 2, 3, 4, 5], [3, 1, 2, 6, 7, 8, 9], 3) [1, 2, 3] >>> find_top_performers(4, 4, [1, 2, 3, 4], [5, 6, 7, 8], 2) [\\"None\\"]","solution":"def find_top_performers(N, M, round1_ids, round2_ids, K): Returns a list of participant ids who are in the top K positions in both rounds in ascending order. If no such participants exist, return an empty list. # Top K participants in both rounds top_k_round1 = set(round1_ids[:K]) top_k_round2 = set(round2_ids[:K]) # Intersection of top K participants in both rounds top_performers = sorted(list(top_k_round1 & top_k_round2)) if top_performers: return top_performers else: return [\\"None\\"]"},{"question":"from typing import List def frequency_sort(n: int, arr: List[int]) -> List[int]: Sorts the elements in non-decreasing order based on the frequency of each element. If two elements have the same frequency, they should be sorted according to their value in non-decreasing order. Args: n: int : Number of elements in the array arr: List[int] : List containing the elements of the array Returns: List[int] : Sorted list based on the frequency of each element Examples: >>> frequency_sort(6, [4, 5, 6, 5, 4, 3]) [3, 6, 4, 4, 5, 5] >>> frequency_sort(5, [9, 9, 9, 6, 6]) [6, 6, 9, 9, 9] # Your code here import pytest def test_example_1(): n = 6 arr = [4, 5, 6, 5, 4, 3] assert frequency_sort(n, arr) == [3, 6, 4, 4, 5, 5] def test_example_2(): n = 5 arr = [9, 9, 9, 6, 6] assert frequency_sort(n, arr) == [6, 6, 9, 9, 9] def test_single_element(): n = 1 arr = [1] assert frequency_sort(n, arr) == [1] def test_all_same_element(): n = 4 arr = [4, 4, 4, 4] assert frequency_sort(n, arr) == [4, 4, 4, 4] def test_different_frequencies(): n = 7 arr = [5, 5, 3, 3, 1, 1, 1] assert frequency_sort(n, arr) == [3, 3, 5, 5, 1, 1, 1] def test_multiple_frequencies(): n = 8 arr = [4, 4, 4, 3, 3, 2, 2, 1] assert frequency_sort(n, arr) == [1, 2, 2, 3, 3, 4, 4, 4] if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import Counter def frequency_sort(n, arr): Sorts the elements in non-decreasing order based on the frequency of each element. If two elements have the same frequency, they should be sorted according to their value in non-decreasing order. Args: n: int : Number of elements in the array arr: List[int] : List containing the elements of the array Returns: List[int] : Sorted list based on the frequency of each element freq = Counter(arr) sorted_arr = sorted(arr, key=lambda x: (freq[x], x)) return sorted_arr # Example usage: # n = 6 # arr = [4, 5, 6, 5, 4, 3] # print(frequency_sort(n, arr)) # Output: [3, 6, 4, 4, 5, 5]"},{"question":"from collections import defaultdict def find_critical_points(N, M, edges): Determine the number of Critical Connection Points (CCPs) in the graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): Each tuple contains two integers U and V representing a directed edge from node U to node V Returns: int: Number of Critical Connection Points in the graph >>> find_critical_points(6, 7, [(1, 2), (2, 3), (3, 1), (1, 4), (4, 5), (5, 6), (6, 4)]) 2 >>> find_critical_points(1, 0, []) 0 >>> find_critical_points(5, 0, []) 0 >>> find_critical_points(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 3 >>> find_critical_points(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 0 # Your implementation here def test_find_critical_points(): edges = [(1, 2), (2, 3), (3, 1), (1, 4), (4, 5), (5, 6), (6, 4)] assert find_critical_points(6, 7, edges) == 2 def test_find_critical_points_single_node(): edges = [] assert find_critical_points(1, 0, edges) == 0 def test_find_critical_points_no_edges(): edges = [] assert find_critical_points(5, 0, edges) == 0 def test_find_critical_points_line_graph(): edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert find_critical_points(5, 4, edges) == 3 def test_find_critical_points_complete_graph(): edges = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert find_critical_points(4, 6, edges) == 0","solution":"from collections import defaultdict def find_critical_points(N, M, edges): def dfs(node, discovery_time, low_time, parent, visited): visited[node] = True discovery_time[node] = low_time[node] = find_critical_points.time find_critical_points.time += 1 children_count = 0 for neighbor in graph[node]: if not visited[neighbor]: parent[neighbor] = node children_count += 1 dfs(neighbor, discovery_time, low_time, parent, visited) low_time[node] = min(low_time[node], low_time[neighbor]) if parent[node] is None and children_count > 1: critical_points.add(node) if parent[node] is not None and low_time[neighbor] >= discovery_time[node]: critical_points.add(node) elif neighbor != parent[node]: low_time[node] = min(low_time[node], discovery_time[neighbor]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * (N + 1) low_time = [-1] * (N + 1) parent = [None] * (N + 1) visited = [False] * (N + 1) critical_points = set() find_critical_points.time = 0 # Initialize static variable for i in range(1, N + 1): if not visited[i]: dfs(i, discovery_time, low_time, parent, visited) return len(critical_points) # Input Reading import sys input = sys.stdin.read def main(): data = input().split() N = int(data[0]) M = int(data[1]) edges = [] for i in range(M): u = int(data[2 + 2 * i]) v = int(data[3 + 2 * i]) edges.append((u, v)) result = find_critical_points(N, M, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def max_product(arr: List[int]) -> int: Write a function that takes an array of integers and returns the maximum product that can be obtained by multiplying two distinct elements from the array. >>> max_product([1, 2, 3, 4]) 12 >>> max_product([-10, -20, 5, 6]) 200 >>> max_product([0, 2, 3, -2]) 6 pass Unit Tests: from solution import max_product def test_max_product(): assert max_product([1, 2, 3, 4]) == 12 assert max_product([-10, -20, 5, 6]) == 200 assert max_product([0, 2, 3, -2]) == 6 assert max_product([1, 2]) == 2 assert max_product([-1, -2]) == 2 assert max_product([-1, 2]) == -2 assert max_product([i for i in range(1, 1001)]) == 999000 assert max_product([0, -1, 10]) == 0","solution":"def max_product(arr): Returns the maximum product that can be obtained by multiplying two distinct elements from the array. if len(arr) < 2: raise ValueError(\\"The array should contain at least two elements.\\") arr.sort() product1 = arr[-1] * arr[-2] product2 = arr[0] * arr[1] return max(product1, product2)"},{"question":"def can_achieve_communication(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine if the village can achieve a state where any two houses can communicate directly or indirectly by only removing some connections. >>> can_achieve_communication(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (1, 4)]) \\"YES\\" >>> can_achieve_communication(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> can_achieve_communication(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> can_achieve_communication(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"YES\\" >>> can_achieve_communication(3, 2, [(1, 2), (2, 3)]) \\"YES\\" >>> can_achieve_communication(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> can_achieve_communication(1, 0, []) \\"YES\\" >>> can_achieve_communication(2, 1, [(1, 2)]) \\"YES\\" >>> can_achieve_communication(2, 0, []) \\"NO\\" pass","solution":"def can_achieve_communication(n, m, connections): from collections import defaultdict, deque def is_connected(graph): visited = [False] * (n + 1) queue = deque([1]) visited[1] = True count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) count += 1 return count == n # Create adjacency list representation of the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Check if the graph is already connected if is_connected(graph): return \\"YES\\" # Check if we can make the graph connected by removing some edges # If we can create or identify a spanning tree # This involves checking if the graph has at least n-1 edges for it to be possible to be connected if m >= n - 1: return \\"YES\\" return \\"NO\\" # Example usage n = 5 m = 6 connections = [ (1, 2), (2, 3), (3, 4), (4, 5), (1, 3), (1, 4) ] print(can_achieve_communication(n, m, connections)) # Output: YES"},{"question":"def parse_batches(input_str: str) -> List[Dict[str, Union[List[Tuple[int, int]], int]]]: Parse the input string into a structured list of batches. Args: input_str (str): The input string describing batches and operations. Returns: List[Dict[str, Union[List[Tuple[int, int]], int]]]: A list of dictionaries where each dictionary represents a batch. pass def max_value(batches: List[Dict[str, Union[List[Tuple[int, int]], int]]]) -> List[str]: Determine the maximum sum of the values of operations that can be completed within the time limit for each batch. Args: batches (List[Dict[str, Union[List[Tuple[int, int]], int]]]): A list of batches where each batch is a dictionary containing operations and Tmax. Returns: List[str]: Results for each batch in the specified output format. pass if __name__ == \\"__main__\\": input_str = 1 3 3 10 2 15 1 30 4 batches = parse_batches(input_str) results = max_value(batches) for result in results: print(result) from solution import max_value, parse_batches def test_single_batch(): input_str = 1 3 3 10 2 15 1 30 4 batches = parse_batches(input_str) results = max_value(batches) expected = [\\"For Batch #1:n45\\"] assert results == expected def test_multiple_batches(): input_str = 2 3 3 10 2 15 1 30 4 2 1 5 2 7 2 batches = parse_batches(input_str) results = max_value(batches) expected = [\\"For Batch #1:n45\\", \\"For Batch #2:n7\\"] assert results == expected def test_no_operations(): input_str = 1 0 10 batches = parse_batches(input_str) results = max_value(batches) expected = [\\"For Batch #1:n0\\"] assert results == expected def test_maximal_operation_time_limit(): input_str = 1 1 1 100 1 batches = parse_batches(input_str) results = max_value(batches) expected = [\\"For Batch #1:n100\\"] assert results == expected","solution":"def max_value(batches): results = [] for batch_num, batch in enumerate(batches, 1): operations = batch['operations'] Tmax = batch['Tmax'] # Using dynamic programming approach for 0/1 knapsack problem dp = [0] * (Tmax + 1) for T, V in operations: for time in range(Tmax, T - 1, -1): dp[time] = max(dp[time], dp[time - T] + V) max_value_sum = max(dp) result_str = f\\"For Batch #{batch_num}:n{max_value_sum}\\" results.append(result_str) return results # Sample input processing function def parse_batches(input_str): lines = input_str.strip().split('n') batches_count = int(lines[0]) index = 1 batches = [] for _ in range(batches_count): M = int(lines[index]) operations = [] for i in range(index + 1, index + 1 + M): T, V = map(int, lines[i].split()) operations.append((T, V)) Tmax = int(lines[index + 1 + M]) batch = { 'operations': operations, 'Tmax': Tmax } batches.append(batch) index = index + 2 + M return batches # Input transformation and function call if __name__ == \\"__main__\\": input_str = 1 3 3 10 2 15 1 30 4 batches = parse_batches(input_str) results = max_value(batches) for result in results: print(result)"},{"question":"def extract_element(query: str, nested_list_str: str): Extracts a specific element from a nested list based on a query index path. >>> extract_element(\\"1.0\\", \\"[[1, 2, 3], [4, [5, 6]], [7, 8, 9]]\\") 4 >>> extract_element(\\"2.1.1\\", \\"[[1, 2, 3], [4, [5, 6]], [7, [8, 9, [10]]]]\\") 9 >>> extract_element(\\"2.2\\", \\"[[1, 2], [3, 4]]\\") 'no such element' >>> extract_element(\\"1.1\\", \\"[10, [20, 30], 40, [50, 60]]\\") 30","solution":"def extract_element(query, nested_list_str): def parse_nested_list(s): Parses a string formatted nested list into an actual nested list. return eval(s.replace('n', '')) def access_element(nested_list, index_path): Accesses the element in the nested list based on the index path. current_element = nested_list for index in index_path: if isinstance(current_element, list) and 0 <= index < len(current_element): current_element = current_element[index] else: return \\"no such element\\" return current_element index_path = list(map(int, query.split('.'))) nested_list = parse_nested_list(nested_list_str) result = access_element(nested_list, index_path) if isinstance(result, list): return \\"list\\" return result"},{"question":"from typing import List, Tuple def can_reach(N: int, M: int, blocked_roads: List[int], A: int, B: int, roads: List[Tuple[int, int]]) -> str: Determine whether it is still possible to reach every location from any starting point, even if some roads are blocked. >>> can_reach(5, 6, [1, 3], 1, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (4, 2)]) \\"YES\\" >>> can_reach(6, 6, [2, 4, 6], 2, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) \\"NO\\" def process_input(input_str: str) -> List[str]: Process the input data and returns a list of results for each dataset. >>> process_input(''' 5 6 1 3 1 5 1 2 2 3 3 4 4 5 5 1 4 2 0 0 ''') [\\"YES\\"] >>> process_input(''' 6 6 2 4 6 2 5 1 2 2 3 3 4 4 5 5 6 6 1 0 0 ''') [\\"NO\\"]","solution":"import sys from collections import defaultdict, deque def can_reach(N, M, blocked_roads, A, B, roads): graph = defaultdict(list) blocked_set = set(blocked_roads) for i in range(1, M + 1): if i not in blocked_set: s, t = roads[i-1] graph[s].append(t) graph[t].append(s) visited = [False] * (N + 1) queue = deque([A]) visited[A] = True while queue: node = queue.popleft() if node == B: return \\"YES\\" for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"NO\\" def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") idx = 0 results = [] while idx < len(input_lines): N, M = map(int, input_lines[idx].split()) if N == 0 and M == 0: break idx += 1 blocked_roads = list(map(int, input_lines[idx].split())) idx += 1 A, B = map(int, input_lines[idx].split()) idx += 1 roads = [] for _ in range(M): si, ti = map(int, input_lines[idx].split()) roads.append((si, ti)) idx += 1 result = can_reach(N, M, blocked_roads, A, B, roads) results.append(result) return results def main(): input_str = sys.stdin.read() results = process_input(input_str) for result in results: print(result) # Uncomment below line to run as script # if __name__ == \\"__main__\\": # main()"},{"question":"def longest_arithmetic_subsequence(arr: List[int]) -> int: Given an array of positive integers, determine the length of the longest subsequence where the difference between consecutive elements is the same. A subsequence is derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Parameters: arr (List[int]): List of positive integers. Returns: int: Length of the longest arithmetic subsequence. Examples: >>> longest_arithmetic_subsequence([3, 6, 9, 12]) 4 >>> longest_arithmetic_subsequence([9, 4, 7, 2, 10]) 3 >>> longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8]) 4 from typing import List def test_longest_arithmetic_subsequence(): assert longest_arithmetic_subsequence([3, 6, 9, 12]) == 4 assert longest_arithmetic_subsequence([9, 4, 7, 2, 10]) == 3 assert longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8]) == 4 assert longest_arithmetic_subsequence([1]) == 1 assert longest_arithmetic_subsequence([0, 0, 0, 0]) == 4 assert longest_arithmetic_subsequence([1, 3, 5, 7, 9, 11]) == 6 assert longest_arithmetic_subsequence([1, 2, 4, 7, 11, 16]) == 3 def test_edge_cases(): assert longest_arithmetic_subsequence([]) == 0 assert longest_arithmetic_subsequence([10000]) == 1","solution":"from typing import List def longest_arithmetic_subsequence(arr: List[int]) -> int: if len(arr) <= 1: return len(arr) # Dictionary to store lengths of arithmetic subsequences with common differences for each index dp = [{} for _ in range(len(arr))] max_length = 1 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def max_balanced_subarray_length(n: int, binary_sequence: str) -> int: Identify the maximum length of a contiguous subarray that is balanced in terms of 1s and 0s. :param n: int, the length of the binary sequence :param binary_sequence: str, the binary sequence of length n :return: int, the maximum length of a balanced contiguous subarray >>> max_balanced_subarray_length(8, \\"11011010\\") 6 >>> max_balanced_subarray_length(10, \\"1010101010\\") 10","solution":"def max_balanced_subarray_length(n, binary_sequence): Returns the maximum length of a balanced contiguous subarray in the binary sequence. :param n: int, the length of the binary sequence :param binary_sequence: str, the binary sequence of length n :return: int, the maximum length of a balanced contiguous subarray # Dictionary to store the first occurrence of each prefix sum prefix_sum_indices = {0: -1} max_length = 0 current_sum = 0 for i in range(n): if binary_sequence[i] == '1': current_sum += 1 else: current_sum -= 1 if current_sum in prefix_sum_indices: max_length = max(max_length, i - prefix_sum_indices[current_sum]) else: prefix_sum_indices[current_sum] = i return max_length"},{"question":"def get_forest_states(n, k, q, forest_states, queries): Returns the forest configuration for each query. Parameters: n (int): The side length of the forest. k (int): The number of previous states recorded. q (int): The number of queries. forest_states (list of list of str): List containing 'k' forest states, each state is a list of 'n' strings. queries (list of int): List containing 'q' queries, each query is an integer d representing the day in the past. Returns: list of list of str: List of forest configurations for each query. Examples: >>> n, k, q = 3, 2, 2 >>> forest_states = [[\\"#\\", \\"#.#\\", \\"#\\"], [\\".\\", \\"#\\", \\"#\\"]] >>> queries = [1, 2] >>> get_forest_states(n, k, q, forest_states, queries) [['#', '#.#', '#'], ['.', '#', '#']] >>> n, k, q = 2, 1, 1 >>> forest_states = [[\\".#\\", \\"\\"]] >>> queries = [1] >>> get_forest_states(n, k, q, forest_states, queries) [['.#', '']] >>> n, k, q = 4, 3, 3 >>> forest_states = [[\\"\\", \\"....\\", \\"\\", \\"....\\"], [\\"#..#\\", \\"\\", \\"#..#\\", \\"\\"], [\\"....\\", \\"\\", \\"....\\", \\"\\"]] >>> queries = [1, 3, 2] >>> get_forest_states(n, k, q, forest_states, queries) [['', '....', '', '....'], ['....', '', '....', ''], ['#..#', '', '#..#', '']]","solution":"def get_forest_states(n, k, q, forest_states, queries): Returns the forest configuration for each query. Parameters: n (int): The side length of the forest. k (int): The number of previous states recorded. q (int): The number of queries. forest_states (list of list of str): List containing 'k' forest states, each state is a list of 'n' strings. queries (list of int): List containing 'q' queries, each query is an integer d representing the day in the past. Returns: list of list of str: List of forest configurations for each query. results = [] for query in queries: results.append(forest_states[query - 1]) return results"},{"question":"def unique_emails(emails): Returns a list of unique email addresses, preserving the original order. >>> unique_emails([\\"alice@example.com\\", \\"bob@example.net\\", \\"alice@example.com\\", \\"carol@example.org\\", \\"bob@example.net\\"]) [\\"alice@example.com\\", \\"bob@example.net\\", \\"carol@example.org\\"]","solution":"def unique_emails(emails): Returns a list of unique email addresses, preserving the original order. seen = set() unique_list = [] for email in emails: if email not in seen: seen.add(email) unique_list.append(email) return unique_list"},{"question":"def build_prefix_sum(heights, N): Builds a prefix sum matrix for the given heights matrix. Args: heights (List[List[int]]): A 2D list representing the heights of buildings. N (int): The side length of the grid. Returns: List[List[int]]: A 2D list representing the prefix sum matrix. pass def get_building_view_score(prefix_sum, r1, c1, r2, c2): Computes the building view score for a specified sub-grid. Args: prefix_sum (List[List[int]]): A 2D list representing the prefix sum matrix. r1 (int): The starting row index of the sub-grid. c1 (int): The starting column index of the sub-grid. r2 (int): The ending row index of the sub-grid. c2 (int): The ending column index of the sub-grid. Returns: int: The building view score for the specified sub-grid. pass def compute_building_view_scores(N, Q, heights, queries): Computes the building view scores for multiple sub-grids. Args: N (int): The side length of the grid. Q (int): The number of queries. heights (List[List[int]]): A 2D list representing the heights of buildings. queries (List[Tuple[int, int, int, int]]): A list of tuples representing the queries, where each tuple contains four integers, r1, c1, r2, c2. Returns: List[int]: A list of integers representing the building view scores for each query. Examples: >>> N = 3 >>> heights = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (2, 2, 3, 3) ... ] >>> compute_building_view_scores(N, 2, heights, queries) [12, 28] pass","solution":"def build_prefix_sum(heights, N): prefix_sum = [[0] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, N + 1): prefix_sum[i][j] = ( heights[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] ) return prefix_sum def get_building_view_score(prefix_sum, r1, c1, r2, c2): return ( prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1] ) def compute_building_view_scores(N, Q, heights, queries): prefix_sum = build_prefix_sum(heights, N) results = [] for q in range(Q): r1, c1, r2, c2 = queries[q] score = get_building_view_score(prefix_sum, r1, c1, r2, c2) results.append(score) return results"},{"question":"def is_playlist_feasible(f: int, s: int) -> str: Checks if it's possible to create a playlist with given number of fast-paced (f) and slow-paced (s) songs following the rules: - No more than 3 fast-paced songs should appear consecutively. - After each set of 3 fast-paced songs, there must be at least 1 slow-paced song before another fast-paced song. >>> is_playlist_feasible(7, 3) \\"YES\\" >>> is_playlist_feasible(6, 1) \\"YES\\" >>> is_playlist_feasible(4, 0) \\"NO\\" >>> is_playlist_feasible(10, 3) \\"YES\\" >>> is_playlist_feasible(8, 1) \\"NO\\" >>> is_playlist_feasible(0, 0) \\"YES\\" >>> is_playlist_feasible(3, 0) \\"YES\\" >>> is_playlist_feasible(1, 0) \\"YES\\" >>> is_playlist_feasible(4, 1) \\"YES\\" >>> is_playlist_feasible(0, 1) \\"YES\\"","solution":"def is_playlist_feasible(f, s): Checks if it's possible to create a playlist with given number of fast-paced (f) and slow-paced (s) songs following the rules: - No more than 3 fast-paced songs should appear consecutively. - After each set of 3 fast-paced songs, there must be at least 1 slow-paced song before another fast-paced song. # Calculate the minimum number of slow-paced songs required required_slow_paced = (f - 1) // 3 if s >= required_slow_paced: return \\"YES\\" else: return \\"NO\\""},{"question":"def total_prime_factors(n): Returns the total number of prime factors of n, including repetitions. >>> total_prime_factors(12) 3 >>> total_prime_factors(13) 1 >>> total_prime_factors(100) 4 >>> total_prime_factors(1) 0 >>> total_prime_factors(32) 5 >>> total_prime_factors(29) 1","solution":"def total_prime_factors(n): Returns the total number of prime factors of n, including repetitions. count = 0 # Check for number of 2s in n while n % 2 == 0: count += 1 n //= 2 # Check for other primes from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: count += 1 n //= factor factor += 2 # If remaining n is a prime number greater than 2 if n > 2: count += 1 return count"},{"question":"def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> Union[int, str]: Determine the shortest path for a robot to travel from a starting point to a delivery point on a grid. Parameters: grid (List[List[int]]): A 2D list representing the grid of city streets (1 for passable, 0 for impassable). start (Tuple[int, int]): A tuple representing the starting coordinates (sx, sy). end (Tuple[int, int]): A tuple representing the ending coordinates (dx, dy). Returns: Union[int, str]: The length of the shortest path as an integer, or \\"No path\\" if no valid path exists. >>> grid = [ ... [1, 1, 1, 0, 1], ... [1, 0, 1, 1, 1], ... [1, 0, 0, 1, 1], ... [1, 1, 1, 0, 1], ... [1, 1, 1, 1, 1] ... ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(grid, start, end) 8 >>> grid = [ ... [1, 1, 0, 1], ... [1, 0, 1, 1], ... [0, 1, 1, 1], ... [1, 1, 1, 0] ... ] >>> start = (0, 0) >>> end = (3, 3) >>> shortest_path(grid, start, end) 'No path'","solution":"from collections import deque def shortest_path(grid, start, end): m, n = len(grid), len(grid[0]) sx, sy = start dx, dy = end directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) while queue: x, y, distance = queue.popleft() if (x, y) == (dx, dy): return distance for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return \\"No path\\" def solve_rds_cases(): import sys input = sys.stdin.read data = input().split() index = 0 case_number = 1 while True: m = int(data[index]) n = int(data[index + 1]) if m == 0 and n == 0: break index += 2 grid = [] for _ in range(m): grid.append(list(map(int, data[index:index + n]))) index += n sx, sy = map(int, data[index:index + 2]) dx, dy = map(int, data[index + 2:index + 4]) index += 4 result = shortest_path(grid, (sx, sy), (dx, dy)) print(f\\"{case_number} {result}\\") case_number += 1"},{"question":"from collections import defaultdict, deque def bfs(graph, source, sink, parent): Helper function for BFS traversal in Edmonds-Karp algorithm # <Implement the BFS traversal here> pass def edmonds_karp(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum flow in a given directed network graph using the Edmonds-Karp algorithm. Args: n : int : the number of vertices in the graph. edges : List[Tuple[int, int, int]] : the edges in the graph, represented as tuples (u, v, c), where u and v are vertices and c is the capacity. Returns: int : the maximum flow from source vertex 1 to sink vertex n. Examples: >>> edges = [(1, 2, 100), (1, 3, 100), (2, 3, 1), (2, 4, 100), (3, 4, 100)] >>> edmonds_karp(4, edges) 200 >>> edges = [(1, 2, 100), (2, 3, 100)] >>> edmonds_karp(4, edges) 0 # <Implement the Edmonds-Karp algorithm here> pass def test_edmonds_karp(): edges = [ (1, 2, 100), (1, 3, 100), (2, 3, 1), (2, 4, 100), (3, 4, 100) ] assert edmonds_karp(4, edges) == 200 def test_no_path(): edges = [ (1, 2, 100), (2, 3, 100) ] assert edmonds_karp(4, edges) == 0 def test_single_path(): edges = [ (1, 2, 100), (2, 3, 50), (3, 4, 75) ] assert edmonds_karp(4, edges) == 50 def test_bidirectional_edges(): edges = [ (1, 2, 100), (2, 1, 50), (2, 3, 100), (3, 2, 50), (3, 4, 100), (4, 3, 50) ] assert edmonds_karp(4, edges) == 100 def test_disconnected_graph(): edges = [ (1, 2, 10), (1, 3, 10), (4, 5, 10) ] assert edmonds_karp(5, edges) == 0","solution":"from collections import deque, defaultdict def bfs(graph, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v, capacity in graph[u].items(): if v not in visited and capacity > 0: queue.append(v) visited.add(v) parent[v] = u if v == sink: return True return False def edmonds_karp(n, edges): graph = defaultdict(lambda: defaultdict(int)) for u, v, c in edges: graph[u][v] += c source, sink = 1, n parent = [0] * (n + 1) max_flow = 0 while bfs(graph, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"def determine_last_paint(grid): Determines which color was used last on a 10x10 grid. Args: grid: a list of lists containing 'R', 'G', and '.' characters, where each list represents a row. Returns: 'R' if a red stripe was painted last, 'G' if a green stripe was painted last. def process_test_cases(test_cases): Processes multiple test cases. Args: test_cases: a list of test cases, each test case being a 10x10 grid of 'R', 'G', and '.' characters. Returns: A list of results for each test case. import pytest def test_determine_last_paint_case1(): grid = [ \\"..........\\", \\".G........\\", \\".G........\\", \\"RRRRRRRRRR\\", \\"..........\\", \\".G........\\", \\".G........\\", \\".G........\\", \\".G........\\", \\".G........\\" ] assert determine_last_paint(grid) == 'R' def test_determine_last_paint_case2(): grid = [ \\"..........GR\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"RRRRRRRRRR\\", \\"RRRRRRRRRR\\", \\"..........\\" ] assert determine_last_paint(grid) == 'R' def test_determine_last_paint_case3(): grid = [ \\"RR.GRR.GGR\\", \\".G......G.\\", \\"RRRRRRRRRR\\", \\".G......G.\\", \\".G......G.\\", \\".G......G.\\", \\"RRRRRRRRRR\\", \\".G......G.\\", \\".G......G.\\", \\"..........\\" ] assert determine_last_paint(grid) == 'G' def test_determine_last_paint_case4(): grid = [ \\"..........\\", \\"..........\\", \\"RRRRRRRRRR\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"RGR.GGGR..\\", \\"..........\\" ] assert determine_last_paint(grid) == 'R' def test_process_test_cases(): test_cases = [ [ \\"..........\\", \\".G........\\", \\".G........\\", \\"RRRRRRRRRR\\", \\"..........\\", \\".G........\\", \\".G........\\", \\".G........\\", \\".G........\\", \\".G........\\" ], [ \\"..........GR\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"G..........R\\", \\"RRRRRRRRRR\\", \\"RRRRRRRRRR\\", \\"..........\\" ], [ \\"RR.GRR.GGR\\", \\".G......G.\\", \\"RRRRRRRRRR\\", \\".G......G.\\", \\".G......G.\\", \\".G......G.\\", \\"RRRRRRRRRR\\", \\".G......G.\\", \\".G......G.\\", \\"..........\\" ], [ \\"..........\\", \\"..........\\", \\"RRRRRRRRRR\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"RGR.GGGR..\\", \\"..........\\" ] ] expected_results = ['R', 'R', 'G', 'R'] assert process_test_cases(test_cases) == expected_results","solution":"def determine_last_paint(grid): Determines which color was used last on a 10x10 grid. Args: grid: a list of lists containing 'R', 'G', and '.' characters, where each list represents a row. Returns: 'R' if a red stripe was painted last, 'G' if a green stripe was painted last. last_red_row = -1 last_green_col = -1 for r in range(10): if 'R' in grid[r]: last_red_row = r for c in range(10): for r in range(10): if grid[r][c] == 'G': last_green_col = c break if last_red_row == -1: return 'G' if last_green_col == -1: return 'R' # Check if the last painted red row was after the last green column painted return 'R' if last_red_row > last_green_col else 'G' def process_test_cases(test_cases): Processes multiple test cases. Args: test_cases: a list of test cases, each test case being a 10x10 grid of 'R', 'G', and '.' characters. Returns: A list of results for each test case. results = [] for grid in test_cases: results.append(determine_last_paint(grid)) return results"},{"question":"def can_move(piece: str, start: str, target: str) -> str: Determine if a chess piece can make a valid move from a given starting position to a given target position on a standard 8x8 chessboard. The input positions are provided in the standard chess notation (A1, H8, etc.), and the types of chess pieces are \\"King\\", \\"Queen\\", \\"Rook\\", \\"Bishop\\", \\"Knight\\", and \\"Pawn\\". Args: piece (str): The type of the chess piece. start (str): The starting position in standard chess notation. target (str): The target position in standard chess notation. Returns: str: \\"YES\\" if the move is valid, otherwise \\"NO\\". >>> can_move(\\"King\\", \\"E2\\", \\"E3\\") \\"YES\\" >>> can_move(\\"King\\", \\"E2\\", \\"E4\\") \\"NO\\" >>> can_move(\\"Queen\\", \\"D1\\", \\"H5\\") \\"YES\\" >>> can_move(\\"Rook\\", \\"A1\\", \\"A8\\") \\"YES\\" >>> can_move(\\"Bishop\\", \\"C1\\", \\"H6\\") \\"YES\\" >>> can_move(\\"Knight\\", \\"B1\\", \\"C3\\") \\"YES\\" >>> can_move(\\"Pawn\\", \\"E2\\", \\"E3\\") \\"YES\\"","solution":"def can_move(piece, start, target): files = 'ABCDEFGH' ranks = '12345678' start_file = files.index(start[0]) start_rank = ranks.index(start[1]) target_file = files.index(target[0]) target_rank = ranks.index(target[1]) file_diff = abs(target_file - start_file) rank_diff = abs(target_rank - start_rank) if piece == \\"King\\": if file_diff <= 1 and rank_diff <= 1: return \\"YES\\" elif piece == \\"Queen\\": if (file_diff == rank_diff) or (file_diff == 0) or (rank_diff == 0): return \\"YES\\" elif piece == \\"Rook\\": if (file_diff == 0) or (rank_diff == 0): return \\"YES\\" elif piece == \\"Bishop\\": if file_diff == rank_diff: return \\"YES\\" elif piece == \\"Knight\\": if (file_diff == 2 and rank_diff == 1) or (file_diff == 1 and rank_diff == 2): return \\"YES\\" elif piece == \\"Pawn\\": if file_diff == 0 and rank_diff == 1 and target_rank > start_rank: return \\"YES\\" if start_rank == 1 and file_diff == 0 and rank_diff == 2 and target_rank > start_rank: return \\"YES\\" return \\"NO\\""},{"question":"def tsp_minimum_distance(n: int, dist: List[List[int]]) -> int: Determine the minimum total distance Mr. Smith needs to travel to visit each city exactly once and return to the starting city. Args: n : int : Number of cities dist : List[List[int]] : n x n matrix representing the distances between each pair of cities Returns: int : The minimum total distance of the trip Examples: >>> tsp_minimum_distance(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 >>> tsp_minimum_distance(3, [ ... [0, 10, 15], ... [10, 0, 20], ... [15, 20, 0] ... ]) 45 >>> tsp_minimum_distance(2, [ ... [0, 5], ... [5, 0] ... ]) 10","solution":"def tsp_minimum_distance(n, dist): from itertools import permutations # Initialize minimum distance to a large number min_distance = float('inf') # Generate all possible permutations of node visits for perm in permutations(range(1, n)): current_distance = 0 current_path = [0] + list(perm) + [0] # Calculate the distance of the current path for i in range(len(current_path) - 1): current_distance += dist[current_path[i]][current_path[i + 1]] # Update minimum distance if current path has a lower distance if current_distance < min_distance: min_distance = current_distance return min_distance"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Find the maximum sum of any subarray of the given array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([-2, -3, -1, -4]) -1 >>> max_subarray_sum([5, -2, 3, -1, 2, -4, 3]) 7 >>> max_subarray_sum([0, 0, 0, 0]) 0 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Find the maximum sum of any subarray of the given array. :param arr: List[int] - List of integers :return: int - Maximum possible sum of any subarray if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def can_transform_to_special_sequence(n: int, array: List[int]) -> str: Determines if the array can be transformed into a special sequence where elements alternately increase and decrease. Parameters: n (int): The size of the array. array (List[int]): The array of integers. Returns: str: \\"YES\\" if it can be transformed, \\"NO\\" otherwise. >>> can_transform_to_special_sequence(5, [1, 3, 5, 2, 4]) \\"YES\\" >>> can_transform_to_special_sequence(4, [4, 5, 5, 6]) \\"NO\\" pass def solve(input_lines: List[str]) -> List[str]: Processes multiple test cases and returns results for each one. Parameters: input_lines (List[str]): List of strings, where each string is a line from the input. Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\") >>> solve([\\"2\\", \\"5\\", \\"1 3 5 2 4\\", \\"4\\", \\"4 5 5 6\\"]) [\\"YES\\", \\"NO\\"] pass","solution":"def can_transform_to_special_sequence(n, array): Determines if the array can be transformed into a special sequence where elements alternately increase and decrease. Parameters: n (int): The size of the array. array (List[int]): The array of integers. Returns: str: \\"YES\\" if it can be transformed, \\"NO\\" otherwise. array.sort() for i in range(1, n): if array[i] == array[i - 1]: return \\"NO\\" return \\"YES\\" def solve(input_lines): Processes multiple test cases and returns results for each one. Parameters: input_lines (List[str]): List of strings, where each string is a line from the input. Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\") output = [] index = 0 T = int(input_lines[index]) index += 1 for _ in range(T): n = int(input_lines[index]) index += 1 array = list(map(int, input_lines[index].split())) index += 1 result = can_transform_to_special_sequence(n, array) output.append(result) return output"},{"question":"def filter_products(catalog, min_price, max_price): Filters the products in the catalog based on the given price range. Args: catalog (list of dict): List of product dictionaries, where each dictionary contains 'name' and 'price'. min_price (int): The minimum price of the range. max_price (int): The maximum price of the range. Returns: list of dict: A list of product dictionaries whose prices fall within the given range. Examples: >>> catalog = [ {\\"name\\": \\"Laptop\\", \\"price\\": 1000}, {\\"name\\": \\"Smartphone\\", \\"price\\": 500}, {\\"name\\": \\"Tablet\\", \\"price\\": 300}, {\\"name\\": \\"Headphones\\", \\"price\\": 100} ] >>> min_price = 200 >>> max_price = 800 >>> filter_products(catalog, min_price, max_price) [{\\"name\\": \\"Smartphone\\", \\"price\\": 500}, {\\"name\\": \\"Tablet\\", \\"price\\": 300}] >>> catalog = [ {\\"name\\": \\"Shirt\\", \\"price\\": 20}, {\\"name\\": \\"Jeans\\", \\"price\\": 40}, {\\"name\\": \\"Jacket\\", \\"price\\": 60}, {\\"name\\": \\"Shoes\\", \\"price\\": 80} ] >>> min_price = 30 >>> max_price = 70 >>> filter_products(catalog, min_price, max_price) [{\\"name\\": \\"Jeans\\", \\"price\\": 40}, {\\"name\\": \\"Jacket\\", \\"price\\": 60}] >>> catalog = [] >>> min_price = 50 >>> max_price = 100 >>> filter_products(catalog, min_price, max_price) []","solution":"def filter_products(catalog, min_price, max_price): Filters the products in the catalog based on the given price range. Args: catalog (list of dict): List of product dictionaries, where each dictionary contains 'name' and 'price'. min_price (int): The minimum price of the range. max_price (int): The maximum price of the range. Returns: list of dict: A list of product dictionaries whose prices fall within the given range. return [product for product in catalog if min_price <= product['price'] <= max_price]"},{"question":"def sum_of_digits_in_sentences(sentences): Given a list of sentences where each sentence consists of multiple words, this function extracts and sums all the digits from every word in the sentences and returns a list where each element is the sum of the digits for the corresponding word in the input list. :param sentences: List of sentences, each sentence is a string. :return: List of integers representing the sum of digits in each word. >>> sum_of_digits_in_sentences([\\"abc123xyz\\"]) == [6] >>> sum_of_digits_in_sentences([\\"76hello89\\"]) == [30] >>> sum_of_digits_in_sentences([\\"python3.8\\"]) == [11] >>> sum_of_digits_in_sentences([\\"beta2gamma9\\"]) == [11] >>> sum_of_digits_in_sentences([\\"abc123xyz\\", \\"76hello89\\", \\"python3.8\\", \\"beta2gamma9\\"]) == [6, 30, 11, 11] >>> sum_of_digits_in_sentences([\\"abc\\", \\"def\\", \\"ghi\\"]) == [0, 0, 0] >>> sum_of_digits_in_sentences([\\"abcdefgh\\", \\"ijklmnopqrstuvwxyz\\"]) == [0, 0] >>> sum_of_digits_in_sentences([\\"\\"]) == [0]","solution":"def sum_of_digits_in_sentences(sentences): Given a list of sentences where each sentence consists of multiple words, this function extracts and sums all the digits from every word in the sentences and returns a list where each element is the sum of the digits for the corresponding word in the input list. :param sentences: List of sentences, each sentence is a string. :return: List of integers representing the sum of digits in each word. result = [] for sentence in sentences: word_sum = 0 for ch in sentence: if ch.isdigit(): word_sum += int(ch) result.append(word_sum) return result"},{"question":"def process_operations(n, q, sequence, operations): Perform a series of operations on a sequence of integers. Args: n: An integer, the length of the sequence (1 <= n <= 10^5). q: An integer, the number of operations (1 <= q <= 10^5). sequence: A list of n integers (1 <= sequence[i] <= 10^9). operations: A list of q tuples representing the operations. Each operation is one of the following: - (1, index, value): Set sequence[index] to value. - (2, left, right): Compute the sum of sequence[left] to sequence[right] (both inclusive). Returns: A list of results for the range sum queries. Example: >>> n = 5 >>> q = 4 >>> sequence = [1, 2, 3, 4, 5] >>> operations = [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 0, 4)] >>> process_operations(n, q, sequence, operations) [9, 16, 22] pass # Unit Tests def test_process_operations(): n = 5 q = 4 sequence = [1, 2, 3, 4, 5] operations = [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 0, 4)] assert process_operations(n, q, sequence, operations) == [9, 16, 22] def test_process_operations_single_update(): n = 3 q = 2 sequence = [1, 1, 1] operations = [(2, 0, 2), (1, 1, 5)] assert process_operations(n, q, sequence, operations) == [3] def test_process_operations_multiple_queries(): n = 4 q = 5 sequence = [2, 4, 6, 8] operations = [(2, 0, 1), (2, 1, 3), (1, 2, 10), (2, 0, 3), (2, 2, 2)] assert process_operations(n, q, sequence, operations) == [6, 18, 24, 10] def test_process_operations_large_sequence(): n = 1000 q = 2 sequence = list(range(1, 1001)) operations = [(2, 0, 999), (1, 500, 0)] result = process_operations(n, q, sequence, operations) assert result[0] == sum(range(1, 1001)) expected_sum = sum(range(1, 501)) + sum(range(501, 1001)) assert process_operations(n, 3, sequence, operations + [(2, 0, 999)])[-1] == expected_sum - 501 + 0 # Run tests test_process_operations() test_process_operations_single_update() test_process_operations_multiple_queries() test_process_operations_large_sequence()","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize segment tree self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update leaf node pos += self.n self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_sum(self, left, right): left += self.n right += self.n + 1 sum_ = 0 while left < right: if left % 2: sum_ += self.tree[left] left += 1 if right % 2: right -= 1 sum_ += self.tree[right] left //= 2 right //= 2 return sum_ def process_operations(n, q, sequence, operations): seg_tree = SegmentTree(sequence) result = [] for op in operations: if op[0] == 1: # Update operation _, index, value = op seg_tree.update(index, value) elif op[0] == 2: # Range sum query _, left, right = op sum_range = seg_tree.range_sum(left, right) result.append(sum_range) return result"},{"question":"def unique_sorted_box_ids(test_cases): Given multiple test cases, each containing a list of box IDs, return the sorted list of unique IDs for each case. >>> unique_sorted_box_ids([(5, [3, 3, 1, 2, 2])]) == [\\"1 2 3\\"] >>> unique_sorted_box_ids([(5, [3, 3, 1, 2, 2]), (4, [4, 4, 4, 4])]) == [\\"1 2 3\\", \\"4\\"] pass def process_input(input_text): Process the input text and converts it into the format expected by unique_sorted_box_ids. >>> process_input(\\"2n5n3 3 1 2 2n4n4 4 4 4\\") == [(5, [3, 3, 1, 2, 2]), (4, [4, 4, 4, 4])] pass def format_results(results): Format the results from unique_sorted_box_ids for output. >>> format_results([\\"1 2 3\\", \\"4\\"]) == \\"1 2 3n4\\" pass from solution import unique_sorted_box_ids, process_input, format_results def test_unique_sorted_box_ids_single_case(): test_cases = [(5, [3, 3, 1, 2, 2])] result = unique_sorted_box_ids(test_cases) assert result == [\\"1 2 3\\"] def test_unique_sorted_box_ids_multiple_cases(): test_cases = [(5, [3, 3, 1, 2, 2]), (4, [4, 4, 4, 4])] result = unique_sorted_box_ids(test_cases) assert result == [\\"1 2 3\\", \\"4\\"] def test_process_input(): input_text = \\"2n5n3 3 1 2 2n4n4 4 4 4\\" test_cases = process_input(input_text) assert test_cases == [(5, [3, 3, 1, 2, 2]), (4, [4, 4, 4, 4])] def test_format_results(): results = [\\"1 2 3\\", \\"4\\"] formatted = format_results(results) assert formatted == \\"1 2 3n4\\" def test_end_to_end(): input_text = \\"2n5n3 3 1 2 2n4n4 4 4 4\\" expected_output = \\"1 2 3n4\\" test_cases = process_input(input_text) results = unique_sorted_box_ids(test_cases) formatted_output = format_results(results) assert formatted_output == expected_output","solution":"def unique_sorted_box_ids(test_cases): Given multiple test cases, each containing a list of box IDs, return the sorted list of unique IDs for each case. results = [] for case in test_cases: n, ids = case unique_ids = sorted(set(ids)) results.append(' '.join(map(str, unique_ids))) return results def process_input(input_text): Process the input text and converts it into the format expected by unique_sorted_box_ids. lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): N = int(lines[line_index]) ids = list(map(int, lines[line_index + 1].strip().split())) test_cases.append((N, ids)) line_index += 2 return test_cases def format_results(results): Format the results from unique_sorted_box_ids for output. return 'n'.join(results)"},{"question":"def calculate_total_expenditure(customers: int) -> List[str]: Calculate the total amount each customer has spent on their orders. Args: customers: The number of customers. Returns: A list of strings where each string is in the format \\"Customer i: total_amount\\" where i is the number of the customer (starting from 1) and total_amount is the sum of price * quantity for all items in all orders of the customer. >>> calculate_total_expenditure(2) 3 2 101 100 2 102 150 1 1 103 200 3 4 104 300 1 105 400 2 106 500 1 2 2 201 120 1 202 130 2 3 203 140 3 204 150 1 205 160 1 [\\"Customer 1: 2850\\", \\"Customer 2: 1210\\"] pass from solution import calculate_total_expenditure def test_single_customer_single_order(): input_data = \\"1n1n2n101 50 2n102 70 1n\\" expected_output = [\\"Customer 1: 170\\"] assert run_test(input_data) == expected_output def test_multiple_orders(): input_data = \\"1n2n1n101 100 1n2n102 150 2n103 100 1n\\" expected_output = [\\"Customer 1: 500\\"] assert run_test(input_data) == expected_output def test_multiple_customers(): input_data = \\"2n1n2n101 100 2n102 150 1n2n1n103 200 3n1n104 100 1n\\" expected_output = [\\"Customer 1: 350\\", \\"Customer 2: 700\\"] assert run_test(input_data) == expected_output def run_test(input_string): import sys from io import StringIO input_data = StringIO(input_string) sys.stdin = input_data n = int(input().strip()) return calculate_total_expenditure(n)","solution":"def calculate_total_expenditure(customers): results = [] for i in range(customers): total_amount = 0 orders = int(input().strip()) for _ in range(orders): items = int(input().strip()) for _ in range(items): item_id, price, quantity = map(int, input().strip().split()) total_amount += price * quantity results.append(f\\"Customer {i + 1}: {total_amount}\\") return results # Example usage: if __name__ == \\"__main__\\": import sys from io import StringIO input_data = StringIO(2 3 2 101 100 2 102 150 1 1 103 200 3 4 104 300 1 105 400 2 106 500 1 2 2 201 120 1 202 130 2 3 203 140 3 204 150 1 205 160 1 ) sys.stdin = input_data n = int(input().strip()) results = calculate_total_expenditure(n) for result in results: print(result)"},{"question":"def concatenate_and_length(s: str, n: int): Concatenates the string s with itself n times and returns the concatenated string and its length. >>> concatenate_and_length(\\"xyz\\", 4) (\\"xyzxyzxyzxyz\\", 12) >>> concatenate_and_length(\\"abc\\", 1) (\\"abc\\", 3) >>> concatenate_and_length(\\"\\", 5) (\\"\\", 0) >>> concatenate_and_length(\\"abc\\", 0) (\\"\\", 0) >>> concatenate_and_length(\\"a\\", 1000) (\\"a\\" * 1000, 1000)","solution":"def concatenate_and_length(s, n): Concatenates the string s with itself n times and returns the concatenated string and its length. concatenated_string = s * n length_of_concatenated_string = len(concatenated_string) return concatenated_string, length_of_concatenated_string"},{"question":"def do_rectangles_overlap(rectangles): Given the coordinates of two rectangles, determine if they overlap. Each rectangle is defined by its bottom-left and top-right corners. Args: rectangles : list of tuples Each tuple contains 8 integers in the format (x1, y1, x2, y2, x3, y3, x4, y4) where (x1, y1) and (x2, y2) are the coordinates of the first rectangle's bottom-left and top-right corners, and (x3, y3) and (x4, y4) are the coordinates of the second rectangle's bottom-left and top-right corners. Returns: list of int For each input query, returns 1 if the two rectangles overlap, otherwise 0. Example: >>> do_rectangles_overlap([(0, 0, 2, 2, 1, 1, 3, 3)]) [1] >>> do_rectangles_overlap([(0, 0, 1, 1, 2, 2, 3, 3)]) [0]","solution":"def do_rectangles_overlap(rectangles): Given the coordinates of two rectangles, determine if they overlap. Each rectangle is defined by its bottom-left and top-right corners. Args: rectangles : list of tuples Each tuple contains 8 integers in the format (x1, y1, x2, y2, x3, y3, x4, y4) where (x1, y1) and (x2, y2) are the coordinates of the first rectangle's bottom-left and top-right corners, and (x3, y3) and (x4, y4) are the coordinates of the second rectangle's bottom-left and top-right corners. Returns: list of int For each rectangle provided in input, returns 1 if they overlap, otherwise 0. result = [] for rect in rectangles: x1, y1, x2, y2, x3, y3, x4, y4 = rect if x1 >= x4 or x3 >= x2 or y1 >= y4 or y3 >= y2: result.append(0) else: result.append(1) return result"},{"question":"def right_angled_area(a, b, c): Determines if the triangle with sides a, b, and c is right-angled, and if so, returns its area. If not, returns a message indicating that it is not a right-angled triangle. >>> right_angled_area(3, 4, 5) 6.0 >>> right_angled_area(6, 8, 10) 24.0 >>> right_angled_area(3, 5, 7) \\"Not a right-angled triangle\\"","solution":"def right_angled_area(a, b, c): Determines if the triangle with sides a, b, and c is right-angled, and if so, returns its area. If not, returns a message indicating that it is not a right-angled triangle. sides = sorted([a, b, c]) if sides[0]**2 + sides[1]**2 == sides[2]**2: # If right-angled, calculate area return 0.5 * sides[0] * sides[1] else: return \\"Not a right-angled triangle\\""},{"question":"def factorial(N: int) -> int: Compute the factorial of N. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(20) 2432902008176640000","solution":"def factorial(N): Calculate the factorial of an integer N. if N == 0 or N == 1: return 1 result = 1 for i in range(2, N+1): result *= i return result"},{"question":"def max_points(n, k, points): Returns the maximum points that can be earned by attempting exactly k contiguous problems out of n total problems. >>> max_points(5, 3, [1, 2, 3, -4, 5]) 6 >>> max_points(6, 2, [-1, -2, 3, 4, -10, 2]) 7","solution":"def max_points(n, k, points): Returns the maximum points that can be earned by attempting exactly k contiguous problems out of n total problems. if k == n: return sum(points) max_sum = float('-inf') current_sum = sum(points[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum += points[i] - points[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def generate_pattern(n: int) -> list: Generates a grid with layers of concentric rectangles formed by asterisks. Parameters: n (int): An odd integer representing the size of the grid (n x n). Returns: list: A list of strings, where each string represents a row of the grid. >>> generate_pattern(5) ['*****', '* *', '* * *', '* *', '*****'] >>> generate_pattern(7) ['*******', '* *', '* *** *', '* * * *', '* *** *', '* *', '*******'] >>> generate_pattern(9) ['*********', '* *', '* ***** *', '* * * *', '* * * * *', '* * * *', '* ***** *', '* *', '*********']","solution":"def generate_pattern(n: int) -> list: Generates a grid with layers of concentric rectangles formed by asterisks. Parameters: n (int): An odd integer representing the size of the grid (n x n). Returns: list: A list of strings, where each string represents a row of the grid. pattern = [[' ' for _ in range(n)] for _ in range(n)] for layer in range(0, n // 2 + 1, 2): for i in range(layer, n - layer): pattern[layer][i] = '*' pattern[n - layer - 1][i] = '*' pattern[i][layer] = '*' pattern[i][n - layer - 1] = '*' return [''.join(row) for row in pattern]"},{"question":"def min_enclosures(test_cases): Determine the minimum number of enclosures needed to accommodate all species while meeting their space and compatibility requirements. Args: - test_cases (List[Dict]): A list of dictionaries, each containing: - 'S' (int): The number of species. - 'space_reqs' (List[int]): A list of space requirements for each species. - 'compatibility_matrix' (List[List[int]]): A matrix indicating compatibility between species. Returns: - List[int]: A list of integers representing the minimum number of enclosures required for each test case. # Write your code here def read_input(input_string): Parse the input string into a list of test cases. Args: - input_string (str): The input string containing the number of test cases and their details. Returns: - List[Dict]: A list of dictionaries representing the test cases. # Write your code here def format_output(results): Format the results into a printable string. Args: - results (List[int]): A list of integers representing the minimum number of enclosures required. Returns: - str: A formatted string of results. # Write your code here # Unit Tests import pytest def test_simple_case(): input_string = \\"1n3n100 200 300n1 1 0n1 1 1n0 1 1\\" test_cases = read_input(input_string) result = min_enclosures(test_cases) expected = [2] assert result == expected assert format_output(result) == \\"2\\" def test_another_case(): input_string = \\"1n3n150 150 150n1 0 1n0 1 1n1 1 1\\" test_cases = read_input(input_string) result = min_enclosures(test_cases) expected = [2] assert result == expected assert format_output(result) == \\"2\\" def test_multiple_cases(): input_string = \\"2n3n100 200 300n1 1 0n1 1 1n0 1 1n3n150 150 150n1 0 1n0 1 1n1 1 1\\" test_cases = read_input(input_string) result = min_enclosures(test_cases) expected = [2, 2] assert result == expected assert format_output(result) == \\"2n2\\" def test_all_compatible(): input_string = \\"1n4n100 200 300 400n1 1 1 1n1 1 1 1n1 1 1 1n1 1 1 1\\" test_cases = read_input(input_string) result = min_enclosures(test_cases) expected = [1] assert result == expected assert format_output(result) == \\"1\\" def test_no_compatible(): input_string = \\"1n3n100 200 300n1 0 0n0 1 0n0 0 1\\" test_cases = read_input(input_string) result = min_enclosures(test_cases) expected = [3] assert result == expected assert format_output(result) == \\"3\\"","solution":"def min_enclosures(test_cases): from itertools import combinations results = [] for case in test_cases: S = case['S'] space_reqs = case['space_reqs'] compatibility_matrix = case['compatibility_matrix'] # To keep track of which species are already assigned assigned = set() enclosures = [] for i in range(S): if i not in assigned: assigned.add(i) current_enclosure = [i] for j in range(i+1, S): if j not in assigned and all(compatibility_matrix[j][k] == 1 for k in current_enclosure): assigned.add(j) current_enclosure.append(j) enclosures.append(current_enclosure) results.append(len(enclosures)) return results def read_input(input_string): data = input_string.strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): S = int(data[index]) index += 1 space_reqs = list(map(int, data[index:index+S])) index += S compatibility_matrix = [] for i in range(S): row = list(map(int, data[index:index+S])) index += S compatibility_matrix.append(row) test_cases.append({ 'S': S, 'space_reqs': space_reqs, 'compatibility_matrix': compatibility_matrix }) return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def min_jumps(nums: List[int]) -> int: Returns the minimum number of jumps to reach the last element of the array. >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([2, 3, 0, 1, 4, 2]) 3 >>> min_jumps([1, 2, 3]) 2 >>> min_jumps([1, 1, 1, 1]) 3 >>> min_jumps([10, 1, 1, 1, 10]) 1 >>> min_jumps([1]) 0","solution":"def min_jumps(nums): Returns the minimum number of jumps to reach the last element of the array. if len(nums) <= 1: return 0 jumps = 0 current_end = 0 farthest = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(nums) - 1: break return jumps"},{"question":"def sum_of_squares(n): Calculate the sum of the squares of the first n natural numbers. :param n: int, the number of first natural numbers :return: the sum of the squares of the first n natural numbers Example: >>> sum_of_squares(1) 1 >>> sum_of_squares(2) 5 >>> sum_of_squares(3) 14 >>> sum_of_squares(1000000000) 333333333833333333500000000","solution":"def sum_of_squares(n): Returns the sum of the squares of the first n natural numbers using the mathematical formula. Formula: n * (n + 1) * (2n + 1) / 6 return n * (n + 1) * (2 * n + 1) // 6"},{"question":"def min_hours_to_complete_assignments(due_dates, completion_times): Determine the minimum total number of hours required to complete all assignments without overlapping. Args: due_dates (List[int]): List of due dates for each assignment in days. completion_times (List[int]): List of time required to complete each assignment in hours. Returns: int: The minimum total number of hours required to complete all assignments. Examples: >>> min_hours_to_complete_assignments([2, 4, 6], [2, 3, 1]) 6 >>> min_hours_to_complete_assignments([1, 2, 4], [3, 2, 1]) 6 pass # The unit tests for validating the implementation def test_case_1(): due_dates = [2, 4, 6] completion_times = [2, 3, 1] assert min_hours_to_complete_assignments(due_dates, completion_times) == 6 def test_case_2(): due_dates = [1, 2, 4] completion_times = [3, 2, 1] assert min_hours_to_complete_assignments(due_dates, completion_times) == 6 def test_case_3(): due_dates = [3, 2, 4] completion_times = [1, 2, 2] assert min_hours_to_complete_assignments(due_dates, completion_times) == 5 def test_case_4(): due_dates = [5, 2, 1] completion_times = [2, 2, 1] assert min_hours_to_complete_assignments(due_dates, completion_times) == 5 def test_case_5(): due_dates = [10, 5, 8] completion_times = [5, 3, 2] assert min_hours_to_complete_assignments(due_dates, completion_times) == 10","solution":"def min_hours_to_complete_assignments(due_dates, completion_times): Returns the minimum total number of hours required to complete all assignments without overlapping. # Combine and sort assignments by due date assignments = sorted(zip(due_dates, completion_times)) total_hours = 0 max_day = 0 for due_date, completion_time in assignments: if max_day < due_date: max_day = due_date work_start_day = max_day - (completion_time - 1) total_hours += completion_time max_day = work_start_day - 1 return total_hours"},{"question":"def maximize_flowers(T: int, cases: List[Tuple[int, int]]) -> List[str]: Jack wants to maximize the number of flowers he can get from a packet of either roses or tulips. Jack can buy two types of plants from the shop: roses and tulips. Each rose plant can produce P flowers. Each tulip plant can produce Q flowers. One packet of roses contains 3 plants, while one packet of tulips contains 4 plants. Jack can only buy one packet of either roses or tulips, and wants to maximize the number of flowers he can get. Print Roses if the packet of roses produces more flowers, Tulips if the packet of tulips produces more flowers, and Either if they produce the same number of flowers. ------ Input Format ------ - The first line of input will contain a single integer T, denoting the number of test cases. - Each test case consists of one line of input, containing two space-separated integers P and Q — the number of flowers each rose plant and tulip plant can produce, respectively. ------ Output Format ------ For each test case, output on a new line the answer: - Roses if the packet of roses produces more flowers. - Tulips if the packet of tulips produces more flowers. - Either if they produce the same number of flowers. You may print each character of the output in either uppercase or lowercase, i.e, Tulips, TULIPS, TuLiPs and tULIps will all be treated as equivalent. >>> maximize_flowers(3, [(2, 2), (3, 1), (4, 3)]) [\\"Tulips\\", \\"Roses\\", \\"Either\\"] >>> maximize_flowers(2, [(1, 2), (2, 1)]) [\\"Tulips\\", \\"Roses\\"]","solution":"def maximize_flowers(T, cases): results = [] for P, Q in cases: roses_flowers = P * 3 tulips_flowers = Q * 4 if roses_flowers > tulips_flowers: results.append(\\"Roses\\") elif tulips_flowers > roses_flowers: results.append(\\"Tulips\\") else: results.append(\\"Either\\") return results"},{"question":"def max_crop_yield(matrix): This function calculates the maximum sum of crop yields in any rectangular sub-field. >>> max_crop_yield([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) == 29 >>> max_crop_yield([]) == 0 >>> max_crop_yield([[-1]]) == -1 >>> max_crop_yield([ ... [-1, -2], ... [-3, -4] ... ]) == -1 >>> max_crop_yield([ ... [6, -5, -7, 4, -4], ... [-9, 3, -6, 5, 2], ... [-10, 4, 7, -6, 3], ... [-8, 9, -3, 3, -7] ... ]) == 17 >>> max_crop_yield([ ... [1, 1], ... [1, 1] ... ]) == 4","solution":"def max_crop_yield(matrix): This function calculates the maximum sum of crop yields in any rectangular sub-field. from sys import maxsize def kadane(arr): Helper function to run Kadane's algorithm on an array max_sum = -maxsize current_sum = 0 for num in arr: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum if not matrix or not matrix[0]: return 0 N = len(matrix) M = len(matrix[0]) max_sum = -maxsize for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"def longest_non_decreasing_segments(test_cases): Find the length of the longest continuous segment where the running distance doesn't decrease for each test case. >>> main('2n6n5 3 4 8 6 7n5n1 2 3 4 5') '3n5' >>> main('1n10n1 2 2 3 3 3 4 4 4 4') '10' >>> main('1n5n5 4 3 2 1') '1' >>> main('1n4n1 1 2 2') '4' >>> main('2n7n1 2 1 2 1 2 1n3n2 2 2') '2n3' pass def parse_input(input_str): pass def main(input_str): pass","solution":"def longest_non_decreasing_segments(test_cases): results = [] for case in test_cases: n, distances = case max_length = 1 current_length = 1 for i in range(1, n): if distances[i] >= distances[i - 1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 if current_length > max_length: max_length = current_length results.append(max_length) return results def parse_input(input_str): lines = input_str.split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) distances = list(map(int, lines[index + 1].split())) test_cases.append((n, distances)) index += 2 return test_cases def main(input_str): test_cases = parse_input(input_str) results = longest_non_decreasing_segments(test_cases) return 'n'.join(map(str, results))"},{"question":"def sumExcludingMinMax(arr, N): Returns the sum of elements excluding the maximum and minimum elements. Parameters: arr (list): List of integers. N (int): Size of the array. Returns: int: Sum of elements excluding the maximum and minimum elements. Examples: >>> sumExcludingMinMax([3, 1, 2, 5, 4], 5) 9 >>> sumExcludingMinMax([1, 2, 4, 3], 4) 5 >>> sumExcludingMinMax([-1, -2, -3, -4], 4) -5 >>> sumExcludingMinMax([10, -10, 0, 50, 20], 5) 30","solution":"def sumExcludingMinMax(arr, N): Returns the sum of elements excluding the maximum and minimum elements. Parameters: arr (list): List of integers. N (int): Size of the array. Returns: int: Sum of elements excluding the maximum and minimum elements. if N <= 2: return 0 # Not enough elements to exclude both min and max min_val = min(arr) max_val = max(arr) return sum(x for x in arr if x != min_val and x != max_val)"},{"question":"def determine_ranks(N: int, participants: List[Tuple[str, int]], Q: int, queries: List[str]) -> List[int]: Determine the ranks of specific participants based on their scores. Parameters: N (int): Number of participants. participants (list of tuples): List containing tuples with ID and score. Q (int): Number of queries. queries (list): List of participant IDs for the queries. Returns: list: Ranks of the queried participant IDs. pass def test_example_case(): N = 5 participants = [ (\\"alice\\", 95), (\\"bob\\", 100), (\\"charlie\\", 90), (\\"diana\\", 95), (\\"elena\\", 105) ] Q = 3 queries = [\\"alice\\", \\"charlie\\", \\"diana\\"] expected_output = [3, 5, 3] assert determine_ranks(N, participants, Q, queries) == expected_output def test_all_same_scores(): N = 5 participants = [ (\\"alice\\", 50), (\\"bob\\", 50), (\\"charlie\\", 50), (\\"diana\\", 50), (\\"elena\\", 50) ] Q = 5 queries = [\\"alice\\", \\"bob\\", \\"charlie\\", \\"diana\\", \\"elena\\"] expected_output = [1, 1, 1, 1, 1] assert determine_ranks(N, participants, Q, queries) == expected_output def test_unique_scores(): N = 4 participants = [ (\\"a\\", 10), (\\"b\\", 20), (\\"c\\", 30), (\\"d\\", 40) ] Q = 4 queries = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] expected_output = [4, 3, 2, 1] assert determine_ranks(N, participants, Q, queries) == expected_output def test_multiple_queries_for_same_participant(): N = 3 participants = [ (\\"a\\", 10), (\\"b\\", 20), (\\"c\\", 30) ] Q = 3 queries = [\\"a\\", \\"a\\", \\"a\\"] expected_output = [3, 3, 3] assert determine_ranks(N, participants, Q, queries) == expected_output def test_descending_scores(): N = 3 participants = [ (\\"a\\", 90), (\\"b\\", 80), (\\"c\\", 70) ] Q = 3 queries = [\\"a\\", \\"b\\", \\"c\\"] expected_output = [1, 2, 3] assert determine_ranks(N, participants, Q, queries) == expected_output","solution":"def determine_ranks(N, participants, Q, queries): Determine the ranks of specific participants based on their scores. Parameters: N (int): Number of participants. participants (list of tuples): List containing tuples with ID and score. Q (int): Number of queries. queries (list): List of participant IDs for the queries. Returns: list: Ranks of the queried participant IDs. # Create a sorted list of participants sorted by score (desc) and ID (asc) sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) # Create dictionary to store ranks rank_dict = {} current_rank = 1 prev_score = None for idx, (participant_id, score) in enumerate(sorted_participants): if prev_score is None or prev_score != score: current_rank = idx + 1 rank_dict[participant_id] = current_rank prev_score = score # Find ranks for each query result = [rank_dict[query] for query in queries] return result # Function to parse input and call 'determine_ranks' def leaderboard(input_data): lines = input_data.strip().split(\\"n\\") N, Q = map(int, lines[0].split()) participants = [tuple(line.split()) for line in lines[1:N+1]] participants = [(p[0], int(p[1])) for p in participants] queries = [line for line in lines[N+1:N+1+Q]] return determine_ranks(N, participants, Q, queries)"},{"question":"from typing import List, Tuple def matrix_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]: Returns the sum of the main diagonal and secondary diagonal of a square matrix. Parameters: matrix (List[List[int]]): A square matrix (list of lists) with integers Returns: Tuple[int, int]: A tuple containing two integers: the sum of the main diagonal and the sum of the secondary diagonal >>> matrix_diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == (15, 15) >>> matrix_diagonal_sum([[1]]) == (1, 1) >>> matrix_diagonal_sum([[1, 2], [3, 4]]) == (5, 5) >>> matrix_diagonal_sum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == (34, 34) >>> matrix_diagonal_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == (-15, -15)","solution":"from typing import List, Tuple def matrix_diagonal_sum(matrix: List[List[int]]) -> Tuple[int, int]: Returns the sum of the main diagonal and secondary diagonal of a square matrix. Parameters: matrix (List[List[int]]): A square matrix (list of lists) with integers Returns: Tuple[int, int]: A tuple containing two integers: the sum of the main diagonal and the sum of the secondary diagonal n = len(matrix) main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return (main_diagonal_sum, secondary_diagonal_sum)"},{"question":"def can_form_palindrome(s: str) -> str: Determine if any permutation of the string can form a palindrome. Args: s (str): Input string. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". Examples: >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determine if any permutation of the string can form a palindrome. Args: s (str): Input string. Returns: str: \\"YES\\" if any permutation can form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def remove_duplicates(registration_numbers): Returns a list of registration numbers with duplicates removed, preserving the original order. >>> remove_duplicates([10, 22, 10, 33, 22, 44, 55, 10]) [10, 22, 33, 44, 55] >>> remove_duplicates([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([7, 7, 7, 7, 7]) [7] >>> remove_duplicates([]) [] >>> remove_duplicates([5, 1, 2, 5, 3, 1, 4, 2]) [5, 1, 2, 3, 4] >>> remove_duplicates([10, 20, 30, 40, 50]) [10, 20, 30, 40, 50]","solution":"def remove_duplicates(registration_numbers): Returns a list of registration numbers with duplicates removed, preserving the original order. seen = set() unique_numbers = [] for number in registration_numbers: if number not in seen: unique_numbers.append(number) seen.add(number) return unique_numbers"},{"question":"def list_employees(employee: dict) -> list: This function accepts the root employee object and returns a list of employee information. The employee information is sorted in ascending order based on the \`id\`. >>> employee = { \\"id\\": 3, \\"name\\": \\"Dave\\", \\"subordinates\\": [ { \\"id\\": 1, \\"name\\": \\"Alice\\", \\"subordinates\\": [] }, { \\"id\\": 2, \\"name\\": \\"Bob\\", \\"subordinates\\": [ { \\"id\\": 4, \\"name\\": \\"Carol\\", \\"subordinates\\": [] } ] } ] } >>> result = list_employees(employee) >>> result [{'id': 1, 'name': 'Alice'}, {'id': 2, 'name': 'Bob'}, {'id': 3, 'name': 'Dave'}, {'id': 4, 'name': 'Carol'}]","solution":"def list_employees(employee: dict) -> list: def traverse(employee, result): result.append({\\"id\\": employee[\\"id\\"], \\"name\\": employee[\\"name\\"]}) for subordinate in employee[\\"subordinates\\"]: traverse(subordinate, result) result = [] traverse(employee, result) result.sort(key=lambda x: x[\\"id\\"]) return result"},{"question":"import math def min_g(T, test_cases): Calculate the minimum value of the equation g(x) = a * cos(x) + b * sin(x) over the range -pi <= x <= pi for T test cases. >>> min_g(2, [(3, 4), (-5, 2)]) [-5.0, -math.sqrt(29)] def format_output(results): Format the output to 6 decimal places for each result in the results list. >>> format_output([-5.0, -math.sqrt(29)]) [\\"-5.000000\\", \\"-5.385165\\"] from solution import min_g, format_output def test_min_g_single_case(): T = 1 test_cases = [(3, 4)] results = min_g(T, test_cases) assert results == [-5.0] def test_format_output_single_case(): results = [-5.0] formatted_results = format_output(results) assert formatted_results == [\\"-5.000000\\"] def test_min_g_multiple_cases(): T = 2 test_cases = [(3, 4), (-5, 2)] results = min_g(T, test_cases) assert results == [-5.0, -math.sqrt(29)] def test_format_output_multiple_cases(): results = [-5.0, -math.sqrt(29)] formatted_results = format_output(results) assert formatted_results == [\\"-5.000000\\", \\"-5.385165\\"] def test_min_g_large_values(): T = 2 test_cases = [(100, 100), (-100, -100)] results = min_g(T, test_cases) assert results == [-math.sqrt(20000), -math.sqrt(20000)] def test_format_output_large_values(): results = [-math.sqrt(20000), -math.sqrt(20000)] formatted_results = format_output(results) assert formatted_results == [\\"-141.421356\\", \\"-141.421356\\"]","solution":"import math def min_g(T, test_cases): results = [] for i in range(T): a, b = test_cases[i] minimum_value = -math.sqrt(a**2 + b**2) results.append(minimum_value) return results def format_output(results): return [f\\"{res:.6f}\\" for res in results]"},{"question":"def canFormPalindrome(s: str) -> bool: Determines if the characters of string s can be rearranged to form a palindrome. >>> canFormPalindrome(\\"carrace\\") True >>> canFormPalindrome(\\"hello\\") False >>> canFormPalindrome(\\"aabb\\") True >>> canFormPalindrome(\\"abc\\") False","solution":"def canFormPalindrome(s): Determines if the characters of string s can be rearranged to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: bool: True if it is possible to rearrange the characters of s to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"from typing import List class RangeQueryArray: def __init__(self, arr: List[int]): Initialize the array with given values and build necessary data structures for range queries and updates. def update(self, i: int, v: int) -> None: Update the value at index i to v in the array. def query_sum(self, i: int, j: int) -> int: Calculate the sum of the elements in the subarray from index i to j, inclusive. def query_max(self, i: int, j: int) -> int: Find the maximum value in the subarray from index i to j, inclusive. # Unit Tests def test_query_sum() -> None: array = RangeQueryArray([1, 2, 3, 4, 5]) assert array.query_sum(1, 3) == 9 def test_query_max() -> None: array = RangeQueryArray([1, 2, 3, 4, 5]) assert array.query_max(0, 2) == 3 def test_update_query_sum() -> None: array = RangeQueryArray([1, 2, 3, 4, 5]) array.update(2, 10) assert array.query_sum(1, 3) == 16 def test_update_query_max() -> None: array = RangeQueryArray([1, 2, 3, 4, 5]) array.update(2, 10) assert array.query_max(1, 4) == 10","solution":"class RangeQueryArray: def __init__(self, arr): self.arr = arr self.n = len(arr) self.prefix_sum = self.build_prefix_sum() self.segment_tree = self.build_segment_tree() def build_prefix_sum(self): prefix_sum = [0] * self.n prefix_sum[0] = self.arr[0] for i in range(1, self.n): prefix_sum[i] = prefix_sum[i-1] + self.arr[i] return prefix_sum def build_segment_tree(self): segment_tree = [0] * (2 * self.n) # initializing the leaves of the segment tree for i in range(self.n): segment_tree[self.n + i] = self.arr[i] # building the segment tree by calculating parents for i in range(self.n - 1, 0, -1): segment_tree[i] = max(segment_tree[2 * i], segment_tree[2 * i + 1]) return segment_tree def update(self, i, v): self.arr[i] = v # Update prefix sum if i == 0: self.prefix_sum[i] = v else: self.prefix_sum[i] = self.prefix_sum[i-1] + v for j in range(i + 1, self.n): self.prefix_sum[j] = self.prefix_sum[j-1] + self.arr[j] # Update in segment tree pos = i + self.n self.segment_tree[pos] = v while pos > 1: pos //= 2 self.segment_tree[pos] = max(self.segment_tree[2 * pos], self.segment_tree[2 * pos + 1]) def query_sum(self, i, j): if i == 0: return self.prefix_sum[j] return self.prefix_sum[j] - self.prefix_sum[i-1] def query_max(self, i, j): l = i + self.n r = j + self.n + 1 max_val = float('-inf') while l < r: if l % 2 == 1: max_val = max(max_val, self.segment_tree[l]) l += 1 if r % 2 == 1: r -= 1 max_val = max(max_val, self.segment_tree[r]) l //= 2 r //= 2 return max_val"},{"question":"def can_reorder_to_alternate_parity(n: int, sequence: List[int]) -> str: Determines if the given sequence can be reordered such that no two adjacent elements have the same parity. >>> can_reorder_to_alternate_parity(5, [1, 2, 3, 4, 5]) == \\"Yes\\" >>> can_reorder_to_alternate_parity(4, [2, 4, 6, 8]) == \\"No\\" # Unit Tests from solution import can_reorder_to_alternate_parity def test_example_1(): assert can_reorder_to_alternate_parity(5, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_example_2(): assert can_reorder_to_alternate_parity(4, [2, 4, 6, 8]) == \\"No\\" def test_single_element(): assert can_reorder_to_alternate_parity(1, [1]) == \\"Yes\\" assert can_reorder_to_alternate_parity(1, [2]) == \\"Yes\\" def test_balanced_parity(): assert can_reorder_to_alternate_parity(6, [1, 2, 3, 4, 5, 6]) == \\"Yes\\" def test_unbalanced_parity(): assert can_reorder_to_alternate_parity(6, [1, 1, 2, 3, 5, 7]) == \\"No\\" def test_large_balanced_even_odd(): seq = [i for i in range(1, 100001)] + [i for i in range(100001, 200001)] assert can_reorder_to_alternate_parity(200000, seq) == \\"Yes\\" def test_large_unbalanced_even_odd(): seq = [i for i in range(1, 150001)] + [2*i for i in range(1, 50001)] assert can_reorder_to_alternate_parity(200000, seq) == \\"No\\" def test_all_odd_elements(): seq = [i for i in range(1, 201, 2)] assert can_reorder_to_alternate_parity(100, seq) == \\"No\\" def test_all_even_elements(): seq = [i for i in range(2, 202, 2)] assert can_reorder_to_alternate_parity(100, seq) == \\"No\\"","solution":"def can_reorder_to_alternate_parity(n, sequence): Determines if the given sequence can be reordered such that no two adjacent elements have the same parity. odd_count = sum(1 for x in sequence if x % 2 != 0) even_count = n - odd_count # Check if the difference between counts is at most one if abs(odd_count - even_count) <= 1: return \\"Yes\\" else: return \\"No\\" # Example Usage: # sequence = [1, 2, 3, 4, 5] # n = len(sequence) # print(can_reorder_to_alternate_parity(n, sequence)) # Output: \\"Yes\\""},{"question":"def findPairWithTargetSum(prices: List[int], target: int) -> List[int]: Finds two distinct indices in prices where the prices at those indices sum up to the target value. :param prices: List of integers representing the prices of items in a store. :param target: Integer representing the target combined price. :return: List of two integers representing the indices of the items. >>> findPairWithTargetSum([2, 7, 11, 15], 9) [0, 1] >>> findPairWithTargetSum([3, 2, 4], 6) [1, 2] >>> findPairWithTargetSum([3, 3], 6) [0, 1]","solution":"def findPairWithTargetSum(prices, target): Finds two distinct indices in prices where the prices at those indices sum up to the target value. :param prices: List of integers representing the prices of items in a store. :param target: Integer representing the target combined price. :return: List of two integers representing the indices of the items. seen = {} for i, price in enumerate(prices): complement = target - price if complement in seen: return [seen[complement], i] seen[price] = i return []"},{"question":"def rotate_matrix(matrix): Rotates the given square matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the square matrix. Returns: list of list of int: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]]","solution":"def rotate_matrix(matrix): Rotates the given square matrix 90 degrees clockwise. Args: matrix (list of list of int): A 2D list representing the square matrix. Returns: list of list of int: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def trap(height): This function calculates the total amount of water that can be trapped after raining given the heights of buildings. :param height: List[int] - List of non-negative integers representing the heights of buildings. :return: int - Total amount of water trapped. Example: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([3,0,0,2,0,4]) 10 >>> trap([2,0,2]) 2","solution":"def trap(height): This function calculates the total amount of water that can be trapped after raining given the heights of buildings. :param height: List[int] - List of non-negative integers representing the heights of buildings. :return: int - Total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array. left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array. right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped. for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def process_commands(commands): Process a series of commands to simulate the processing of orders in a warehouse. Args: commands (List[str]): List of commands to process. Returns: dict: Dictionary with total number of units ordered for each item. Example: >>> process_commands([ \\"stock A 100\\", \\"order A 50\\", \\"order A 75\\", \\"restock A 30\\", \\"order A 50\\", \\"order B 10\\", \\"stock B 100\\", \\"order B 20\\", \\"end\\" ]) {'A': 175, 'B': 30} pass def format_output(total_ordered): Format the output for total ordered units for each item. Args: total_ordered (dict): Dictionary with total number of units ordered for each item. Returns: List[str]: Formatted output list of strings. Example: >>> format_output({'A': 175, 'B': 30}) [\\"A 175\\", \\"B 30\\"] pass from solution import process_commands, format_output def test_process_commands_case1(): commands = [ \\"stock A 100\\", \\"order A 50\\", \\"order A 75\\", \\"restock A 30\\", \\"order A 50\\", \\"order B 10\\", \\"stock B 100\\", \\"order B 20\\", \\"end\\" ] expected_output = [\\"A 175\\", \\"B 30\\"] total_ordered = process_commands(commands) assert format_output(total_ordered) == expected_output def test_process_commands_case2(): commands = [ \\"stock C 50\\", \\"order C 10\\", \\"order C 5\\", \\"stock C 20\\", \\"order C 30\\", \\"order D 100\\", \\"restock C 10\\", \\"order C 10\\", \\"end\\" ] expected_output = [\\"C 55\\", \\"D 100\\"] total_ordered = process_commands(commands) assert format_output(total_ordered) == expected_output def test_process_commands_case3(): commands = [ \\"order A 50\\", \\"stock A 20\\", \\"order A 30\\", \\"stock B 20\\", \\"order B 10\\", \\"restock A 10\\", \\"order A 20\\", \\"end\\" ] expected_output = [\\"A 100\\", \\"B 10\\"] total_ordered = process_commands(commands) assert format_output(total_ordered) == expected_output def test_process_commands_case4(): commands = [ \\"stock X 100\\", \\"order X 98\\", \\"order X 10\\", \\"restock X 5\\", \\"order X 7\\", \\"end\\" ] expected_output = [\\"X 115\\"] total_ordered = process_commands(commands) assert format_output(total_ordered) == expected_output def test_process_commands_case5(): commands = [ \\"order Z 50\\", \\"stock Z 10\\", \\"order Z 30\\", \\"order Z 40\\", \\"end\\" ] expected_output = [\\"Z 120\\"] total_ordered = process_commands(commands) assert format_output(total_ordered) == expected_output","solution":"def process_commands(commands): stock = {} total_ordered = {} for command in commands: if command == \\"end\\": break parts = command.split() action, item, quantity = parts[0], parts[1], int(parts[2]) if action == \\"stock\\": if item not in stock: stock[item] = 0 stock[item] += quantity elif action == \\"order\\": if item not in total_ordered: total_ordered[item] = 0 if item not in stock: stock[item] = 0 fulfillable_quantity = min(stock[item], quantity) stock[item] -= fulfillable_quantity total_ordered[item] += quantity elif action == \\"restock\\": if item not in stock: stock[item] = 0 stock[item] += quantity return total_ordered def format_output(total_ordered): result = [] for item, ordered_quantity in sorted(total_ordered.items()): result.append(f\\"{item} {ordered_quantity}\\") return result"},{"question":"def strictly_increasing_numbers(n: int): Given an integer n, prints all n-digit numbers in ascending order where each digit is strictly less than the digit to its right and all digits are unique. def generate_numbers(start, length, current): if length == 0: print(current) return for i in range(start, 10): generate_numbers(i + 1, length - 1, current * 10 + i) generate_numbers(1, n, 0) # Unit Test from solution import strictly_increasing_numbers def test_strictly_increasing_numbers_1_digit(capsys): strictly_increasing_numbers(1) captured = capsys.readouterr() assert captured.out == \\"1n2n3n4n5n6n7n8n9n\\" def test_strictly_increasing_numbers_2_digits(capsys): strictly_increasing_numbers(2) captured = capsys.readouterr() assert captured.out == (\\"12n13n14n15n16n17n18n19n\\" \\"23n24n25n26n27n28n29n\\" \\"34n35n36n37n38n39n\\" \\"45n46n47n48n49n\\" \\"56n57n58n59n\\" \\"67n68n69n\\" \\"78n79n\\" \\"89n\\") def test_strictly_increasing_numbers_3_digits(capsys): strictly_increasing_numbers(3) captured = capsys.readouterr() assert captured.out.startswith(\\"123n124n125n126n127n128n129n\\") assert \\"678n679n689n789n\\" in captured.out","solution":"def strictly_increasing_numbers(n): Given an integer n, prints all n-digit numbers in ascending order where each digit is strictly less than the digit to its right and all digits are unique. def generate_numbers(start, length, current): if length == 0: print(current) return for i in range(start, 10): generate_numbers(i + 1, length - 1, current * 10 + i) generate_numbers(1, n, 0) # Example usage: # strictly_increasing_numbers(3)"},{"question":"def compare_product_to_z(x: int, y: int, z: int) -> str: Compares the product of x and y to z. If the product of x and y is greater than z, prints \\"Product is Greater\\". Otherwise, prints \\"Product is Not Greater\\". >>> compare_product_to_z(2, 5, 8) 'Product is Greater' >>> compare_product_to_z(2, 5, 10) 'Product is Not Greater' >>> compare_product_to_z(10, 10, 99) 'Product is Greater' >>> compare_product_to_z(2, 5, 20) 'Product is Not Greater'","solution":"def compare_product_to_z(x, y, z): Compares the product of x and y to z. If the product of x and y is greater than z, prints \\"Product is Greater\\". Otherwise, prints \\"Product is Not Greater\\". if x * y > z: return \\"Product is Greater\\" else: return \\"Product is Not Greater\\" # Example usage # x, y, z = map(int, input().split()) # print(compare_product_to_z(x, y, z))"},{"question":"def moveValueToEnd(arr, val): Move all instances of val to the end of the array in-place while preserving the order of the other elements. Parameters: arr (list): List of integers. val (int): The value to move to the end. For example, >>> arr = [3, 1, 2, 3, 4, 3] >>> moveValueToEnd(arr, 3) >>> arr [1, 2, 4, 3, 3, 3] >>> arr = [1, 2, 3, 4, 2] >>> moveValueToEnd(arr, 2) >>> arr [1, 3, 4, 2, 2] >>> arr = [0, 1, 0, 3, 0] >>> moveValueToEnd(arr, 0) >>> arr [1, 3, 0, 0, 0]","solution":"def moveValueToEnd(arr, val): Move all instances of val to the end of the array in-place while preserving the order of the other elements. Parameters: arr (list): List of integers. val (int): The value to move to the end. n = len(arr) write_pos = 0 # Move all elements that are not \`val\` to the front. for i in range(n): if arr[i] != val: arr[write_pos] = arr[i] write_pos += 1 # Fill the remaining positions with \`val\`. for i in range(write_pos, n): arr[i] = val"},{"question":"from typing import List def areMatricesEqual(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Determines whether two matrices are equal. Two matrices are equal if they have the same dimensions and all corresponding elements are equal. >>> areMatricesEqual([[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]) True >>> areMatricesEqual([[1, 2], [3, 4]], [[1, 2, 3], [4, 5, 6]]) False >>> areMatricesEqual([[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [7, 8, 9]]) False >>> areMatricesEqual([[1]], [[1]]) True >>> areMatricesEqual([[1]], [[2]]) False >>> areMatricesEqual([], []) True >>> areMatricesEqual([[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5]]) False","solution":"from typing import List def areMatricesEqual(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Determines whether two matrices are equal. Two matrices are equal if they have the same dimensions and all corresponding elements are equal. # Check if the number of rows are equal if len(matrix1) != len(matrix2): return False # Check if the number of columns in each row are equal for row1, row2 in zip(matrix1, matrix2): if len(row1) != len(row2): return False # Check if all corresponding elements are equal for row1, row2 in zip(matrix1, matrix2): for elem1, elem2 in zip(row1, row2): if elem1 != elem2: return False return True"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence within a given string. Parameters: s (str): The input string. Returns: int: The length of the longest palindromic subsequence. >>> longest_palindromic_subsequence(\\"abacaba\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"a\\") 1","solution":"def longest_palindromic_subsequence(s): Calculate the length of the longest palindromic subsequence in the given string. Parameters: s (str): The input string. Returns: int: The length of the longest palindromic subsequence. n = len(s) # Create a 2D array to store the subsequence lengths dp = [[0 for _ in range(n)] for _ in range(n)] # A single character is always a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of the longest palindromic subsequence is in dp[0][n-1] return dp[0][n - 1]"},{"question":"def count_set_bits(x): Count the number of set bits (1s) in the binary representation of an integer. >>> count_set_bits(0) == 0 >>> count_set_bits(1) == 1 >>> count_set_bits(7) == 3 >>> count_set_bits(12) == 2 pass def min_operations_to_zero(arr): Returns the minimum number of operations required to reduce all elements in the list to 0. >>> min_operations_to_zero([5, 7, 12]) == 7 # 5(2) + 7(3) + 12(2) = 7 >>> min_operations_to_zero([8, 4, 2, 1]) == 4 # Each number has 1 set bit >>> min_operations_to_zero([1, 6]) == 3 # 1(1) + 6(2) = 3 pass def solve(test_cases): Process multiple test cases and return results for each case. >>> test_cases = [(3, [5, 7, 12]), (4, [8, 4, 2, 1]), (2, [1, 6])] >>> solve(test_cases) == [7, 4, 3] pass","solution":"def count_set_bits(x): Count the number of set bits (1s) in the binary representation of an integer. return bin(x).count('1') def min_operations_to_zero(arr): Returns the minimum number of operations required to reduce all elements in the list to 0. operations = 0 for num in arr: operations += count_set_bits(num) return operations def solve(test_cases): Process multiple test cases and return results for each case. results = [] for test_case in test_cases: N, arr = test_case results.append(min_operations_to_zero(arr)) return results"},{"question":"from typing import List, Tuple def compute_checksum(data_sets: List[Tuple[int, int, List[int]]]) -> List[int]: Computes the checksum for a list of given data sets. Each data set is a tuple containing the length of array N, the modulo value M, and the array A of integers. Parameters: data_sets (list): A list of tuples where each tuple contains N, M, and an array A Returns: list: A list containing the checksum for each data set # Your code here # Unit tests def test_single_dataset(): data_sets = [(5, 3, [1, 2, 3, 4, 5])] assert compute_checksum(data_sets) == [0] def test_multiple_datasets(): data_sets = [ (5, 3, [1, 2, 3, 4, 5]), (4, 5, [7, 8, 9, 6]) ] assert compute_checksum(data_sets) == [0, 0] def test_large_values(): data_sets = [ (3, 10, [1000, 1000, 1000]), (1000, 1000, [1] * 1000) ] assert compute_checksum(data_sets) == [0, 0] def test_empty_datasets(): data_sets = [] assert compute_checksum(data_sets) == [] def test_zero_termination(): data_sets = [ (5, 3, [1, 2, 3, 4, 5]), (4, 5, [7, 8, 9, 6]), (0, 0, []) ] assert compute_checksum(data_sets) == [0, 0]","solution":"def compute_checksum(data_sets): Computes the checksum for a list of given data sets. Parameters: data_sets (list): A list of tuples where each tuple contains N, M, and an array A Returns: list: A list containing the checksum for each data set results = [] for data in data_sets: N, M, A = data if N == 0 and M == 0: break checksum = sum(A) % M results.append(checksum) return results"},{"question":"def findMissingInteger(arr, x): Returns the minimum positive integer greater than x that is missing from the array arr. If all integers greater than x are present in the array, returns -1. >>> findMissingInteger([1, 3, 6, 4, 1, 2], 3) 5 >>> findMissingInteger([1, 2, 3], 0) 4 >>> findMissingInteger([7, 8, 9, 11, 12], 7) 10 >>> findMissingInteger([1, 2, 3, 4, 5], 2) 6 >>> findMissingInteger([1, 2, 3], 4) -1 >>> findMissingInteger([1000000, 999999, 1000001, 1000003, 1000002], 999998) 1000004 >>> findMissingInteger([1, 3, 6, 4, 1, 2], 0) 5","solution":"def findMissingInteger(arr, x): Returns the minimum positive integer greater than x that is missing from the array arr. If all integers greater than x are present in the array, returns -1. lookup = set(arr) missing = x + 1 while missing in lookup: missing += 1 return missing if any(num > x for num in arr) else -1"},{"question":"def count_paths(n: int, m: int, traps: List[Tuple[int, int]]) -> int: Count the number of possible paths Masha can take to reach the bottom-right corner of the grid without stepping on any traps. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :param traps: List of tuples representing the positions of traps in the grid. :return: The number of possible paths modulo 1000000007. MOD = 1000000007 # Initialize the grid with False meaning no trap grid = [[False] * m for _ in range(n)] # Place the traps on the grid for x, y in traps: grid[x - 1][y - 1] = True # Initialize the dp array dp = [[0] * m for _ in range(n)] # Starting point if not grid[0][0]: dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j]: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] def count_paths_from_input_string(input_string: str) -> int: Parse the input string and calculate the number of possible paths. :param input_string: Input string containing the grid dimensions and trap positions. :return: The number of possible paths modulo 1000000007. >>> input_string = \\"3 3n1n2 2\\" >>> count_paths_from_input_string(input_string) 2 >>> input_string = \\"3 3n0\\" >>> count_paths_from_input_string(input_string) 6 lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) k = int(lines[1]) traps = [tuple(map(int, line.split())) for line in lines[2:2+k]] return count_paths(n, m, traps)","solution":"def count_paths(n, m, traps): MOD = 1000000007 # Initialize the grid with False meaning no trap grid = [[False] * m for _ in range(n)] # Place the traps on the grid for x, y in traps: grid[x - 1][y - 1] = True # Initialize the dp array dp = [[0] * m for _ in range(n)] # Starting point if not grid[0][0]: dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j]: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] def count_paths_from_input_string(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) k = int(lines[1]) traps = [tuple(map(int, line.split())) for line in lines[2:2+k]] return count_paths(n, m, traps)"},{"question":"def find_two_sum_indices(arr, target): Returns the indices of the two numbers that add up to the target. If no such numbers exist, returns [-1, -1]. >>> find_two_sum_indices([2, 7, 11, 15], 9) [0, 1] >>> find_two_sum_indices([3, 2, 4], 6) [1, 2] >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) [-1, -1] >>> find_two_sum_indices([-1, -2, -3, -4, -5], -8) [2, 4] >>> find_two_sum_indices([0, 4, 3, 0], 0) [0, 3] >>> find_two_sum_indices([5, 75, 25], 100) [1, 2] >>> find_two_sum_indices([1, 1, 1, 1, 1], 2) [0, 1]","solution":"def find_two_sum_indices(arr, target): Returns the indices of the two numbers that add up to the target. If no such numbers exist, returns [-1, -1]. num_to_index = {} for index, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return [-1, -1]"},{"question":"from typing import List def rearrange_even_odd(nums: List[int]) -> List[int]: Rearranges the list so that all even numbers appear before the odd numbers while maintaining their relative order. >>> rearrange_even_odd([4, 3, 2, 1, 5, 6, 7]) [4, 2, 6, 3, 1, 5, 7] >>> rearrange_even_odd([1, 3, 5, 7]) [1, 3, 5, 7] >>> rearrange_even_odd([2, 4, 6, 8]) [2, 4, 6, 8]","solution":"from typing import List def rearrange_even_odd(nums: List[int]) -> List[int]: Rearranges the list so that all even numbers appear before the odd numbers while maintaining their relative order. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def find_maximum_length(N: int, K: int, S: str) -> int: Sammy the squirrel found a string S of length N and wants to break it into exactly K contiguous substrings such that the maximum length of these substrings is minimized. Can you help Sammy determine the maximum length after the optimal division? Input: - N: the length of the string S - K: the number of substrings - S: the string Output: - The minimum possible value for the maximum length of the K substrings. Constraints: - 1 ≤ N ≤ 10^5 - 1 ≤ K ≤ N >>> find_maximum_length(10, 3, \\"abcdefghij\\") 4 >>> find_maximum_length(5, 1, \\"abcde\\") 5 >>> find_maximum_length(1, 1, \\"a\\") 1 >>> find_maximum_length(6, 3, \\"abcdef\\") 2 >>> find_maximum_length(5, 3, \\"aaaaa\\") 2 >>> find_maximum_length(5, 5, \\"abcde\\") 1 pass","solution":"def find_maximum_length(N, K, S): def can_divide_with_length(max_length): count, current_length = 1, 0 for char in S: if current_length + 1 > max_length: count += 1 current_length = 0 current_length += 1 if count > K: return False return True left, right = 1, N while left < right: mid = (left + right) // 2 if can_divide_with_length(mid): right = mid else: left = mid + 1 return left"},{"question":"def min_shelves(n, W, widths): Determines the minimum number of shelves required to store all the books. Parameters: n (int): The number of books. W (int): The width capacity of each shelf. widths (list of int): A list containing the width of each book. Returns: int: The minimum number of shelves required. >>> min_shelves(5, 10, [6, 3, 5, 2, 7]) 3 >>> min_shelves(4, 15, [4, 5, 6]) 1 >>> min_shelves(3, 2, [2, 2, 2]) 3 >>> min_shelves(4, 10, [9, 2, 3, 5]) 2 >>> min_shelves(4, 10, [5, 5, 5, 5]) 2","solution":"def min_shelves(n, W, widths): Determines the minimum number of shelves required to store all the books. Parameters: n (int): The number of books. W (int): The width capacity of each shelf. widths (list of int): A list containing the width of each book. Returns: int: The minimum number of shelves required. shelves = 0 current_shelf_width = 0 for width in widths: if current_shelf_width + width <= W: current_shelf_width += width else: shelves += 1 current_shelf_width = width # We need to count the last shelf if there are widths added to it if current_shelf_width > 0: shelves += 1 return shelves"},{"question":"def balanced_strings_count(s: str) -> int: Returns the number of balanced strings that can be formed from the input string. A balanced string is defined as one that has the same number of 'L' characters as 'R' characters. Parameters: s (str): A string consisting of the characters 'L' and 'R'. Returns: int: The number of balanced strings in the input string. Examples: >>> balanced_strings_count(\\"RLRRLLRLRL\\") 4 >>> balanced_strings_count(\\"RLLLLRRRLR\\") 3 >>> balanced_strings_count(\\"LLLLRRRR\\") 1 >>> balanced_strings_count(\\"RLRRRLLRLL\\") 2 >>> balanced_strings_count(\\"\\") 0 >>> balanced_strings_count(\\"RLRLRLRLRLRL\\") 6 >>> balanced_strings_count(\\"LLLLLLLLRRRRRRRR\\") 1 >>> balanced_strings_count(\\"LLLLLLLL\\") 0 >>> balanced_strings_count(\\"RRRRRRRR\\") 0 from solution import balanced_strings_count def test_balanced_strings_count_example_1(): assert balanced_strings_count(\\"RLRRLLRLRL\\") == 4 def test_balanced_strings_count_example_2(): assert balanced_strings_count(\\"RLLLLRRRLR\\") == 3 def test_balanced_strings_count_example_3(): assert balanced_strings_count(\\"LLLLRRRR\\") == 1 def test_balanced_strings_count_example_4(): assert balanced_strings_count(\\"RLRRRLLRLL\\") == 2 def test_balanced_strings_count_empty_string(): assert balanced_strings_count(\\"\\") == 0 def test_balanced_strings_count_no_balanced_string(): assert balanced_strings_count(\\"RLRLRLRLRLRL\\") == 6 assert balanced_strings_count(\\"LLLLLLLLRRRRRRRR\\") == 1 def test_balanced_strings_count_all_same_characters(): assert balanced_strings_count(\\"LLLLLLLL\\") == 0 assert balanced_strings_count(\\"RRRRRRRR\\") == 0","solution":"def balanced_strings_count(s): Returns the number of balanced strings that can be formed from the input string. Parameters: s (str): A string consisting of the characters 'L' and 'R'. Returns: int: The number of balanced strings in the input string. count = 0 balanced_count = 0 for char in s: if char == 'L': count += 1 else: count -= 1 if count == 0: balanced_count += 1 return balanced_count"},{"question":"from typing import List, Tuple def find_minimum_days(t: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of days required to complete all tasks given the dependencies between them. Each test case consists of two parts: - The first tuple (n, m) contains two integers representing the number of tasks and the number of dependencies respectively. - The second list contains tuples (a, b) indicating that task a must be completed before task b. Example: >>> find_minimum_days(3, [((3, 2), [(1, 2), (2, 3)]), ((4, 3), [(1, 2), (2, 3), (3, 4)]), ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 2)])]) [3, 4, -1] >>> find_minimum_days(1, [((3, 0), [])]) [1] >>> find_minimum_days(1, [((1, 0), [])]) [1] >>> find_minimum_days(2, [((3, 3), [(1, 2), (2, 3), (3, 1)]), ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)])]) [-1, -1] >>> find_minimum_days(1, [((6, 4), [(1, 2), (2, 3), (4, 5), (5, 6)])]) [3]","solution":"from collections import deque, defaultdict def find_minimum_days(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] edges = test_cases[i][1] # Create graph and in-degree array graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in edges: graph[a].append(b) in_degree[b] += 1 # Topological sort using Kahn's algorithm queue = deque() for j in range(1, n + 1): if in_degree[j] == 0: queue.append(j) count = 0 completed_tasks = 0 while queue: size = len(queue) for _ in range(size): task = queue.popleft() completed_tasks += 1 for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) count += 1 if completed_tasks == n: results.append(count) else: results.append(-1) return results"},{"question":"import random import string from typing import List def generate_passwords(n: int) -> List[str]: Generate \`n\` secure passwords that meet the specified criteria. Each password: - Contains at least one uppercase letter. - Contains at least one lowercase letter. - Contains at least one digit. - Contains at least one special character from the set: !@#%^&*()-+ - Is at least 8 characters long. - Is unique. >>> len(generate_passwords(5)) 5 >>> all(len(password)>=8 for password in generate_passwords(5)) True pass # Example usage: # passwords = generate_passwords(3) # for password in passwords: # print(password)","solution":"import random import string def generate_passwords(n): def is_secure(password): has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(c in \\"!@#%^&*()-+\\" for c in password) return has_upper and has_lower and has_digit and has_special and len(password) >= 8 passwords = set() while len(passwords) < n: password = ''.join(random.choices(string.ascii_letters + string.digits + \\"!@#%^&*()-+\\", k=12)) if is_secure(password): passwords.add(password) password_list = list(passwords) for password in password_list: print(password) return password_list"},{"question":"def unique_substrings(S: str) -> int: Returns the number of unique substrings in the given string S. >>> unique_substrings('abc') 6 >>> unique_substrings('aaa') 3 pass # Unit tests def test_unique_substrings_example_1(): assert unique_substrings('abc') == 6 def test_unique_substrings_example_2(): assert unique_substrings('aaa') == 3 def test_unique_substrings_single_character(): assert unique_substrings('a') == 1 assert unique_substrings('b') == 1 def test_unique_substrings_repeated_characters(): assert unique_substrings('abab') == 7 assert unique_substrings('aaaa') == 4 def test_unique_substrings_mixed_characters(): assert unique_substrings('abcd') == 10 assert unique_substrings('abca') == 9 def test_unique_substrings_large_case(): S = 'a' * 1000 assert unique_substrings(S) == 1000","solution":"def unique_substrings(S): Returns the number of unique substrings in the given string S. unique_subs = set() for i in range(len(S)): for j in range(i + 1, len(S) + 1): unique_subs.add(S[i:j]) return len(unique_subs)"},{"question":"def find_winner(N: int, participants: list) -> int: Determines the participant with the highest average score. Args: N (int): Number of participants. participants (list of tuples): Each tuple contains a participant's ID and a list of their scores. Returns: int: ID of the participant with the highest average score. Examples: >>> find_winner(3, [(101, 88, 92, 100), (102, 90, 85, 92), (103, 95, 94, 93)]) 103 >>> find_winner(2, [(101, 100, 100, 100), (102, 100, 100, 100)]) 101 from solution import find_winner def test_example_case(): participants = [ (101, 88, 92, 100), (102, 90, 85, 92), (103, 95, 94, 93) ] assert find_winner(3, participants) == 103 def test_tie_case(): participants = [ (101, 88, 92, 100), (102, 100, 92, 88), (103, 94, 94, 90) ] assert find_winner(3, participants) == 101 def test_single_participant(): participants = [ (101, 100, 100, 100) ] assert find_winner(1, participants) == 101 def test_lowest_id_wins_tiebreaker(): participants = [ (200, 90, 90, 90), (100, 90, 90, 90) ] assert find_winner(2, participants) == 100 def test_maximum_scores(): participants = [ (101, 100, 100, 100), (102, 95, 100, 100), (103, 99, 99, 100) ] assert find_winner(3, participants) == 101","solution":"def find_winner(N, participants): Determines the participant with the highest average score. Args: N (int): Number of participants. participants (list of tuples): Each tuple contains a participant's ID and a list of their scores. Returns: int: ID of the participant with the highest average score. max_avg_score = -1 winner_id = float('inf') for participant in participants: participant_id, *scores = participant avg_score = sum(scores) / len(scores) if (avg_score > max_avg_score) or (avg_score == max_avg_score and participant_id < winner_id): max_avg_score = avg_score winner_id = participant_id return winner_id"},{"question":"def sort_digits(s: str) -> str: Returns a new string with all the digits sorted in non-decreasing order at the beginning, and the letters in their original order at the end of the string. Non-alphanumeric characters are ignored. Args: s (str): input string containing a mix of letters and digits. Returns: str: processed string with sorted digits and original order letters. Examples: >>> sort_digits(\\"a1c3b2\\") '123acb' >>> sort_digits(\\"5z6y@\\") '56zy'","solution":"def sort_digits(s): Returns a new string with all the digits sorted in non-decreasing order at the beginning, and the letters in their original order at the end of the string. Non-alphanumeric characters are ignored. Args: s (str): input string containing a mix of letters and digits. Returns: str: processed string with sorted digits and original order letters. digits = sorted(filter(str.isdigit, s)) letters = filter(str.isalpha, s) return ''.join(digits) + ''.join(letters)"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"carrace\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def validate_schedule(T, test_cases): Validate if the feeding schedule for each test case is regular based on the provided interval K. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - K (int): The interval in hours at which animals need to be fed. - feeding_times (list of int): Times (in hours since the start of the day) at which the animals were fed. Returns: list of str: For each test case, \\"YES\\" if the schedule is regular, otherwise \\"NO\\". # Implement the function here # Example usage and test cases if __name__ == \\"__main__\\": T = 1 test_cases = [(4, [0, 4, 8, 12, 16])] result = validate_schedule(T, test_cases) print(result) # Output should be [\\"YES\\"] T = 1 test_cases = [(2, [0, 2, 4, 7, 10])] result = validate_schedule(T, test_cases) print(result) # Output should be [\\"NO\\"] T = 1 test_cases = [(3, [0, 3, 6])] result = validate_schedule(T, test_cases) print(result) # Output should be [\\"YES\\"] T = 1 test_cases = [(1, [0])] result = validate_schedule(T, test_cases) print(result) # Output should be [\\"YES\\"] T = 3 test_cases = [ (4, [0, 4, 8, 12, 16]), (2, [0, 2, 4, 7, 10]), (3, [0, 3, 6]) ] result = validate_schedule(T, test_cases) print(result) # Output should be [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def validate_schedule(T, test_cases): Validate if the feeding schedule for each test case is regular based on the provided interval K. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - K (int): The interval in hours at which animals need to be fed. - feeding_times (list of int): Times (in hours since the start of the day) at which the animals were fed. Returns: list of str: For each test case, \\"YES\\" if the schedule is regular, otherwise \\"NO\\". results = [] for i in range(T): K, feeding_times = test_cases[i] n = len(feeding_times) is_regular = True for j in range(1, n): if feeding_times[j] - feeding_times[j - 1] != K: is_regular = False break if is_regular: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_kth_tallest(N: int, Q: int, heights: List[int], queries: List[Tuple[int, int, int]]) -> List[Union[int, str]]: Given a number of plants and queries, find the height of the Kth tallest plant within the specified range. For each query, output the height of the Kth tallest plant in the range from L to R, inclusively. If such a Kth tallest plant does not exist, return \\"Out of range\\". >>> N, Q = 7, 3 >>> heights = [10, 20, 15, 25, 30, 5, 40] >>> queries = [(2, 5, 2), (1, 7, 3), (3, 6, 5)] >>> find_kth_tallest(N, Q, heights, queries) [25, 25, \\"Out of range\\"] >>> N, Q = 1, 1 >>> heights = [10] >>> queries = [(1, 1, 1)] >>> find_kth_tallest(N, Q, heights, queries) [10] >>> N, Q = 5, 4 >>> heights = [10, 23, 17, 31, 13] >>> queries = [(1, 5, 3), (2, 4, 1), (1, 3, 2), (1, 2, 3)] >>> find_kth_tallest(N, Q, heights, queries) [17, 31, 17, \\"Out of range\\"] >>> N, Q = 6, 2 >>> heights = [7, 6, 5, 8, 9, 4] >>> queries = [(1, 3, 4), (2, 6, 6)] >>> find_kth_tallest(N, Q, heights, queries) [\\"Out of range\\", \\"Out of range\\"]","solution":"def find_kth_tallest(N, Q, heights, queries): results = [] for query in queries: L, R, K = query if K > (R - L + 1): results.append(\\"Out of range\\") else: sublist = heights[L-1:R] sublist.sort(reverse=True) results.append(sublist[K-1]) return results"},{"question":"def minimizedMaxProcessingLoad(servers: int, files: List[int]) -> int: Distribute the files across the servers in a manner that minimizes the maximum processing load on any server. >>> minimizedMaxProcessingLoad(3, [10, 20, 30, 40, 50]) 60 >>> minimizedMaxProcessingLoad(1, [10, 20, 30, 40, 50]) 150 >>> minimizedMaxProcessingLoad(3, [10, 10, 10, 10, 10]) 20","solution":"def canDistributeLoad(load, servers, files): count = 0 current_load = 0 for file in files: if current_load + file <= load: current_load += file else: count += 1 current_load = file if current_load > load: return False return count < servers def minimizedMaxProcessingLoad(servers, files): low = max(files) high = sum(files) while low < high: mid = (low + high) // 2 if canDistributeLoad(mid, servers, files): high = mid else: low = mid + 1 return low # Example usage: def main(): S = 3 F = 5 processing_powers = [10, 20, 30, 40, 50] result = minimizedMaxProcessingLoad(S, processing_powers) print(result) # Expected output: 60"},{"question":"def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Given a list of test cases with integers N and M, find the smallest prime number greater than N and add it to the sum of the digits of M. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers N and M. Returns: List[int]: A list of results, where each result is the sum of the smallest prime number greater than N and the sum of the digits of M. Examples: >>> solve([(10, 123)]) [17] >>> solve([(17, 456)]) [34]","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def next_prime(n): if n <= 1: return 2 prime = n + 1 while not is_prime(prime): prime += 1 return prime def sum_of_digits(m): return sum(int(digit) for digit in str(m)) def solve(test_cases): results = [] for n, m in test_cases: prime = next_prime(n) digits_sum = sum_of_digits(m) results.append(prime + digits_sum) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Write a function that takes a string as input and returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aAaA\\") 2 >>> length_of_longest_substring(\\"abc1231\\") 6 >>> length_of_longest_substring(\\"!@#%^&*()_+\\") 12 >>> length_of_longest_substring(\\"a\\" * 1000) 1 >>> length_of_longest_substring(\\"\\") 0 from solution import length_of_longest_substring def test_single_character_string(): assert length_of_longest_substring('a') == 1 def test_all_unique_characters(): assert length_of_longest_substring('abcdefg') == 7 def test_repeating_characters_at_start(): assert length_of_longest_substring('abcabcbb') == 3 def test_repeating_characters_in_middle(): assert length_of_longest_substring('bbbbb') == 1 def test_repeating_characters_at_end(): assert length_of_longest_substring('pwwkew') == 3 def test_mixed_case_characters(): assert length_of_longest_substring('aAaA') == 2 def test_alphanumeric_characters(): assert length_of_longest_substring('abc1231') == 6 def test_special_characters(): assert length_of_longest_substring('!@#%^&*()_+') == 12 def test_long_string(): assert length_of_longest_substring('a' * 1000) == 1 def test_empty_string(): assert length_of_longest_substring('') == 0","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) char_index_map = {} longest = start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"def generate_pascals_triangle_row(n: int) -> List[int]: Generate the nth row of Pascal's triangle. Args: n (int): Index of the row to generate (0-based). Returns: List[int]: The nth row of Pascal's triangle. Examples: >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1]","solution":"def generate_pascals_triangle_row(n): Generate the nth row of Pascal's triangle. Args: n (int): Index of the row to generate (0-based). Returns: List[int]: The nth row of Pascal's triangle. if n == 0: return [1] row = [1] for k in range(1, n + 1): row.append(row[k - 1] * (n - k + 1) // k) return row"},{"question":"def max_points(n: int, T: int, times: List[int], points: List[int]) -> int: Determine the maximum points Polycarp can achieve within the given time limit. Args: n (int): The number of problems. T (int): The total hours Polycarp has. times (List[int]): List of integers where each integer represents the time needed to solve a problem. points (List[int]): List of integers where each integer represents the points awarded for solving a problem. Returns: int: The maximum points Polycarp can achieve. Examples: >>> max_points(4, 5, [1, 2, 3, 2], [10, 20, 30, 25]) 55 >>> max_points(3, 5, [4, 4, 2], [10, 15, 20]) 20 >>> max_points(5, 10, [1, 2, 3, 4, 5], [100, 200, 300, 400, 500]) 1000","solution":"def max_points(n, T, times, points): # Initialize a DP array where dp[i] will store the maximum number of points # achievable with exactly i hours dp = [0] * (T + 1) # Iterate over each problem for i in range(n): # Iterate over possible total times in reverse to avoid overcounting for t in range(T, times[i] - 1, -1): dp[t] = max(dp[t], dp[t - times[i]] + points[i]) return max(dp)"},{"question":"def max_paired_books_sets(N, M, K, book_ids): Returns the maximum number of complete book-cover pairs Alice can keep given the set size constraint. >>> max_paired_books_sets(5, 3, 2, [1, 2, 3]) 2 >>> max_paired_books_sets(4, 1, 4, [4]) 0 >>> max_paired_books_sets(6, 5, 3, [1, 2, 3, 4, 6]) 3 def process_input_output(test_cases): Processes multiple test cases and returns the results. >>> process_input_output([(5, 3, 2, [1, 2, 3]), (4, 1, 4, [4]), (6, 5, 3, [1, 2, 3, 4, 6])]) [2, 0, 3] >>> process_input_output([(10, 10, 5, list(range(1, 11))), (20, 15, 4, list(range(1, 16)))]) [10, 12]","solution":"def max_paired_books_sets(N, M, K, book_ids): Returns the maximum number of complete book-cover pairs Alice can keep given the set size constraint. # Number of pairs that can be formed num_pairs = min(N, M) # Number of pairs that can be grouped in sets of size K max_sets = num_pairs // K return max_sets * K def process_input_output(test_cases): Processes multiple test cases and returns the results. results = [] for case in test_cases: N, M, K, book_ids = case result = max_paired_books_sets(N, M, K, book_ids) results.append(result) return results"},{"question":"def is_product_of_distinct_integers(n: int) -> str: Determine if n can be represented as the product of two or more distinct integers greater than 1. >>> is_product_of_distinct_integers(6) #=> \\"YES\\" >>> is_product_of_distinct_integers(30) #=> \\"YES\\" >>> is_product_of_distinct_integers(10) #=> \\"YES\\" >>> is_product_of_distinct_integers(7) #=> \\"NO\\" >>> is_product_of_distinct_integers(1) #=> \\"NO\\" pass def process_test_cases(test_cases: List[int]) -> List[str]: Process a list of test cases and return respective results. >>> process_test_cases([6, 30, 10, 7, 1]) #=> [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> process_test_cases([49, 2, 18, 19]) #=> [\\"NO\\", \\"NO\\", \\"YES\\", \\"NO\\"] pass","solution":"def is_product_of_distinct_integers(n): Determine if n can be represented as the product of two or more distinct integers greater than 1. if n < 2: return \\"NO\\" divisors = set() for i in range(2, int(n ** 0.5) + 1): while n % i == 0: divisors.add(i) n //= i if n == 1 or len(divisors) > 1: break # If n > 1 then it must be a prime number greater than sqrt(n) and should be added if n > 1: divisors.add(n) return \\"YES\\" if len(divisors) > 1 else \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for n in test_cases: results.append(is_product_of_distinct_integers(n)) return results"},{"question":"def load_balancer(n, m, requests): Simulate the load balancing algorithm. Parameters: n (int): Number of servers m (int): Number of requests requests (list): List of incoming requests Returns: List[int]: Final counter values for each server >>> load_balancer(3, 5, [2, 3, 1, 5, 2]) [4, 3, 6] >>> load_balancer(1, 1, [5]) [5] >>> load_balancer(3, 3, [3, 3, 3]) [3, 3, 3] >>> load_balancer(2, 5, [2, 2, 2, 2, 2]) [6, 4] >>> load_balancer(4, 6, [2, 1, 3, 2, 1, 4]) [6, 2, 3, 2]","solution":"def load_balancer(n, m, requests): Simulate the load balancing algorithm. Parameters: n (int): Number of servers m (int): Number of requests requests (list): List of incoming requests Returns: List[int]: Final counter values for each server # Initialize server counters server_counters = [0] * n # Process each request for r in requests: # Find the server with the minimum counter value min_index = 0 for i in range(1, n): if server_counters[i] < server_counters[min_index]: min_index = i # Assign the request to the chosen server server_counters[min_index] += r return server_counters"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate a given n x n 2D matrix by 90 degrees clockwise. Args: matrix: A list of lists of integers representing an n x n matrix. Returns: A list of lists of integers representing the rotated matrix. Example: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] def test_rotate_matrix_3x3(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_2x2(): input_matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_1x1(): input_matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_4x4(): input_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_empty(): input_matrix = [] expected_output = [] assert rotate_matrix(input_matrix) == expected_output","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n 2D matrix by 90 degrees clockwise. Args: matrix: A list of lists of integers representing an n x n matrix. Returns: A list of lists of integers representing the rotated matrix. n = len(matrix) # Create a new matrix of the same size rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated"},{"question":"def reverse_words(input_string: str) -> str: Reverses the words in the input string and joins them with a single space. >>> reverse_words(\\" Hello world this is a test \\") == \\"test a is this world Hello\\" >>> reverse_words(\\" Hello \\") == \\"Hello\\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" a b c d \\") == \\"d c b a\\" >>> reverse_words(\\" \\") == \\"\\" >>> reverse_words(\\"Hello world\\") == \\"world Hello\\" >>> reverse_words(\\" 123 456 789 \\") == \\"789 456 123\\" >>> reverse_words(\\" !@# %^ &*() \\") == \\"&*() %^ !@#\\"","solution":"def reverse_words(input_string): Reverses the words in the input string and joins them with a single space. Parameters: input_string (str): The input string with words separated by multiple spaces. Returns: str: The words in reverse order separated by a single space. words = input_string.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"def caesarCipher(text: str, shift: int) -> str: Encrypts the text using Caesar Cipher with the given shift value. >>> caesarCipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" >>> caesarCipher(\\"abcXYZ\\", 2) == \\"cdeZAB\\" >>> caesarCipher(\\"The quick brown fox jumps over the lazy dog\\", 5) == \\"Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\\" >>> caesarCipher(\\"Khoor, Zruog!\\", -3) == \\"Hello, World!\\" >>> caesarCipher(\\"cdeZAB\\", -2) == \\"abcXYZ\\" >>> caesarCipher(\\"Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\\", -5) == \\"The quick brown fox jumps over the lazy dog\\" >>> caesarCipher(\\"Hello, World!\\", 0) == \\"Hello, World!\\" >>> caesarCipher(\\"abcXYZ\\", 0) == \\"abcXYZ\\" >>> caesarCipher(\\"xyz\\", 3) == \\"abc\\" >>> caesarCipher(\\"XYZ\\", 3) == \\"ABC\\" >>> caesarCipher(\\"123 !@#\\", 5) == \\"123 !@#\\" >>> caesarCipher(\\"Test123!\\", 4) == \\"Xiwx123!\\" >>> caesarCipher(\\"A.B,C-D_E\\", 1) == \\"B.C,D-E_F\\"","solution":"def caesarCipher(text, shift): Encrypts the text using Caesar Cipher with the given shift value. encrypted_text = [] for char in text: if char.isalpha(): # Check if the character is a letter shift_base = ord('A') if char.isupper() else ord('a') new_char = chr((ord(char) - shift_base + shift) % 26 + shift_base) encrypted_text.append(new_char) else: encrypted_text.append(char) return ''.join(encrypted_text)"},{"question":"def find_trending_hashtags(n: int, hashtags: List[int], k: int) -> List[int]: A new social media company is planning to develop a feature to find the trending topics. They define a trending topic as a sequence of hashtags that appear together frequently in user posts. The company uses a sliding window approach to analyze the hashtags. Given a list of integers representing the timestamped hashtag appearances and an integer \`k\` representing the length of the sliding window, they want to determine the most frequent hashtag in each window of size \`k\`. If there are multiple hashtags with the same maximum frequency, the lexicographically smallest hashtag should be chosen. Args: n (int): The number of hashtags that appear in the posts. hashtags (List[int]): A list of integers where each integer represents a hashtag. k (int): The size of the sliding window. Returns: List[int]: A list of integers where each integer is the most frequent hashtag in that window. >>> find_trending_hashtags(10, [3, 3, 1, 2, 2, 2, 1, 3, 3, 3], 3) [3, 1, 2, 2, 2, 2, 3, 3] >>> find_trending_hashtags(7, [1, 1, 2, 2, 3, 3, 3], 4) [1, 2, 2, 3] >>> find_trending_hashtags(5, [5, 4, 4, 4, 4], 2) [4, 4, 4, 4] >>> find_trending_hashtags(5, [1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> find_trending_hashtags(8, [1, 2, 2, 3, 3, 3, 2, 1], 4) [2, 2, 3, 3, 3]","solution":"from collections import Counter def find_trending_hashtags(n, hashtags, k): result = [] current_window_counter = Counter(hashtags[:k]) def most_frequent_hashtag(counter): max_count = max(counter.values()) candidates = [hashtag for hashtag, count in counter.items() if count == max_count] return min(candidates) result.append(most_frequent_hashtag(current_window_counter)) for i in range(k, n): current_window_counter[hashtags[i - k]] -= 1 if current_window_counter[hashtags[i - k]] == 0: del current_window_counter[hashtags[i - k]] current_window_counter[hashtags[i]] += 1 result.append(most_frequent_hashtag(current_window_counter)) return result"},{"question":"import itertools from typing import List def valid_permutations(S: str, dictionary: List[str]) -> List[str]: Returns a list of unique permutations of the string S that are valid dictionary words. Args: S (str): The input string. dictionary (List[str]): List of valid dictionary words. Returns: List[str]: List of unique permutations that are valid dictionary words. >>> valid_permutations(\\"cba\\", [\\"abc\\", \\"acb\\", \\"bac\\", \\"cab\\"]) == [\\"abc\\", \\"acb\\", \\"bac\\", \\"cab\\"] >>> valid_permutations(\\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) == [] >>> valid_permutations(\\"aaa\\", [\\"aaa\\"]) == [\\"aaa\\"] >>> valid_permutations(\\"ab\\", [\\"ab\\", \\"ba\\", \\"abc\\"]) == [\\"ab\\", \\"ba\\"] >>> valid_permutations(\\"abc\\", [\\"abc\\", \\"cab\\", \\"abc\\", \\"bac\\", \\"cab\\"]) == [\\"abc\\", \\"cab\\", \\"bac\\"]","solution":"import itertools def valid_permutations(S, dictionary): Returns a list of unique permutations of the string S that are valid dictionary words. Args: S (str): The input string. dictionary (list): List of valid dictionary words. Returns: list: List of unique permutations that are valid dictionary words. # Create a set of unique permutations of the string S permutations = set(itertools.permutations(S)) # Convert each permutation from tuple back to string and filter those that are in the dictionary valid_words = [\\"\\".join(perm) for perm in permutations if \\"\\".join(perm) in dictionary] return valid_words"},{"question":"def is_Armstrong(n: int) -> int: Checks if the given number is an Armstrong Number. Parameters: n (int): The number to check. Returns: int: 1 if n is an Armstrong Number, otherwise 0. >>> is_Armstrong(153) 1 >>> is_Armstrong(9474) 1 >>> is_Armstrong(1234) 0 >>> is_Armstrong(1) 1 >>> is_Armstrong(370) 1 >>> is_Armstrong(100) 0 >>> is_Armstrong(9926315) 1 >>> is_Armstrong(987654) 0","solution":"def is_Armstrong(n): Checks if the given number is an Armstrong Number. Parameters: n (int): The number to check. Returns: int: 1 if n is an Armstrong Number, otherwise 0. num_str = str(n) num_digits = len(num_str) armstrong_sum = sum(int(digit) ** num_digits for digit in num_str) return 1 if armstrong_sum == n else 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def productOfNodesWithTwoChildren(root): Returns the product of all nodes that have both left and right children. Args: root: TreeNode - the root of the binary tree Returns: int - the product of all nodes that have both left and right children. If no such node exists, return 0. pass # Unit Tests def test_empty_tree(): assert productOfNodesWithTwoChildren(None) == 1 def test_single_node(): root = TreeNode(1) assert productOfNodesWithTwoChildren(root) == 0 def test_no_node_with_both_children(): root = TreeNode(1, TreeNode(2), None) assert productOfNodesWithTwoChildren(root) == 0 def test_tree_with_some_nodes_having_both_children(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert productOfNodesWithTwoChildren(root) == 1 def test_tree_with_multiple_nodes_having_both_children(): root = TreeNode(10, TreeNode(5, TreeNode(4), TreeNode(6, TreeNode(7))), TreeNode(20, TreeNode(15), TreeNode(25))) assert productOfNodesWithTwoChildren(root) == 1000 def test_complex_tree(): root = TreeNode(2, TreeNode(3, TreeNode(5), TreeNode(8)), TreeNode(15, TreeNode(10), TreeNode(20))) assert productOfNodesWithTwoChildren(root) == 90","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def productOfNodesWithTwoChildren(root): Returns the product of all nodes that have both left and right children. if not root: return 1 stack = [root] product = 1 found = False while stack: node = stack.pop() if node.left and node.right: product *= node.val found = True if node.right: stack.append(node.right) if node.left: stack.append(node.left) return product if found else 0"},{"question":"def subarray_sum_exists(n: int, t: int, arr: List[int]) -> str: Checks if there exists at least one subarray with a sum equal to the target number. If such a subarray exists, returns \\"Yes\\". Otherwise, returns \\"No\\". Parameters: n (int): Number of elements in the array t (int): Target sum arr (list): List of integers Returns: str: \\"Yes\\" if subarray with sum t exists, \\"No\\" otherwise >>> subarray_sum_exists(5, 5, [1, 2, 3, 4, 5]) 'Yes' >>> subarray_sum_exists(5, 11, [1, 2, 3, 4, 5]) 'No' >>> subarray_sum_exists(3, 0, [-1, 1, 0]) 'Yes' def test_subarray_sum_exists(): assert subarray_sum_exists(5, 5, [1, 2, 3, 4, 5]) == \\"Yes\\" assert subarray_sum_exists(5, 11, [1, 2, 3, 4, 5]) == \\"No\\" assert subarray_sum_exists(3, 0, [-1, 1, 0]) == \\"Yes\\" assert subarray_sum_exists(4, -3, [-2, 1, -1, -1]) == \\"Yes\\" assert subarray_sum_exists(6, 9, [1, 2, 3, 3, -2, 5]) == \\"Yes\\" assert subarray_sum_exists(3, 10, [3, 3, 3]) == \\"No\\" assert subarray_sum_exists(1, 0, [0]) == \\"Yes\\" assert subarray_sum_exists(1, 1, [1]) == \\"Yes\\" assert subarray_sum_exists(1, 2, [1]) == \\"No\\" def test_edge_cases(): assert subarray_sum_exists(1, -1000, [-100]) == \\"No\\" assert subarray_sum_exists(1, 1000, [100]) == \\"No\\" assert subarray_sum_exists(100, 0, [0] * 100) == \\"Yes\\" assert subarray_sum_exists(100, 10, [1] * 100) == \\"Yes\\" assert subarray_sum_exists(100, -10, [-1] * 100) == \\"Yes\\"","solution":"def subarray_sum_exists(n, t, arr): Checks if there exists at least one subarray with a sum equal to t. If such a subarray exists, returns \\"Yes\\". Otherwise, returns \\"No\\". Parameters: n (int): Number of elements in the array t (int): Target sum arr (list): List of integers Returns: str: \\"Yes\\" if subarray with sum t exists, \\"No\\" otherwise # Using a set to store cumulative sums sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == t or (current_sum - t) in sums: return \\"Yes\\" sums.add(current_sum) return \\"No\\""},{"question":"def min_number_of_plates(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Determine the minimum number of plates required to make up exactly W kilograms. If it is not possible to form exactly W kilograms with the given plates, return -1. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], int]]): A list of test cases, where each test case is represented as a tuple: - The first element is an integer n, the number of different plate weights. - The second element is a list of n integers, the weight of each type of plate. - The third element is an integer W, the total weight to be formed. Returns: List[int]: A list of integers where each integer represents the minimum number of plates required for each test case, or -1 if it is not possible to form the exact weight. Examples: >>> min_number_of_plates(3, [(3, [1, 3, 4], 6), (2, [2, 5], 3), (4, [1, 2, 3, 4], 7)]) [2, -1, 2] >>> min_number_of_plates(1, [(3, [2, 5, 10], 1)]) [-1] >>> min_number_of_plates(1, [(1, [7], 7)]) [1] >>> min_number_of_plates(1, [(5, [5, 10, 20, 50], 10000)]) [200] >>> min_number_of_plates(1, [(3, [1, 2, 3], 6)]) [2] >>> min_number_of_plates(1, [(4, [4, 4, 4, 4], 8)]) [2]","solution":"def min_number_of_plates(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] weights = test_cases[i][1] W = test_cases[i][2] dp = [float('inf')] * (W + 1) dp[0] = 0 for weight in weights: for w in range(weight, W + 1): dp[w] = min(dp[w], dp[w - weight] + 1) results.append(dp[W] if dp[W] != float('inf') else -1) return results"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product that can be obtained from any three integers in the array. >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three([-10, -10, 5, 2]) 500 >>> maximum_product_of_three([-4, -3, -2, -1]) -6 >>> maximum_product_of_three([1000, 100, 10, 1]) 1000000 >>> maximum_product_of_three([1, 2, 3]) 6 >>> maximum_product_of_three([-5, -4, 1, 2, 3, 4]) 80 pass","solution":"def maximum_product_of_three(nums): Returns the maximum product that can be obtained from any three integers in the array. nums.sort() return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])"},{"question":"def max_distance_over_k_days(n: int, k: int, distances: List[int]) -> int: Returns the maximum distance run over any k consecutive days. Parameters: n (int): The number of days. k (int): The number of consecutive days to consider. distances (list): List of distances run each day. Returns: int: The maximum distance run over any k consecutive days. pass if __name__ == \\"__main__\\": import pytest def test_max_distance_basic(): assert max_distance_over_k_days(10, 3, [6, 2, 3, 7, 1, 4, 5, 8, 9, 6]) == 23 assert max_distance_over_k_days(5, 2, [10, 1, 2, 10, 3]) == 13 def test_max_distance_case_all_zeros(): assert max_distance_over_k_days(5, 2, [0, 0, 0, 0, 0]) == 0 def test_max_distance_case_single_day(): assert max_distance_over_k_days(1, 1, [1000]) == 1000 def test_max_distance_case_all_same(): assert max_distance_over_k_days(5, 2, [1, 1, 1, 1, 1]) == 2 def test_max_distance_case_large_k_small_n(): assert max_distance_over_k_days(10, 10, [1,2,3,4,5,6,7,8,9,10]) == 55 def test_max_distance_varied_distances(): assert max_distance_over_k_days(9, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == 24 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_distance_over_k_days(n, k, distances): Returns the maximum distance run over any k consecutive days. Parameters: n (int): The number of days. k (int): The number of consecutive days to consider. distances (list): List of distances run each day. Returns: int: The maximum distance run over any k consecutive days. # Initialize the sum of the first k elements max_sum = current_sum = sum(distances[:k]) # Sliding window approach for i in range(k, n): current_sum += distances[i] - distances[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_subarray_sum(n, difficulty_levels): Returns the maximum sum of difficulty levels within any contiguous segment of cities. :param n: integer, the number of cities :param difficulty_levels: list of integers, difficulty levels of the cities :return: integer, the maximum sum of difficulty levels within any contiguous segment >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [-5, -2, -3, -1, -4]) -1 >>> max_subarray_sum(6, [5, -6, 3, 4, 5, -1]) 12 import unittest class TestMaxSubarraySum(unittest.TestCase): def test_example_case(self): n = 9 difficulty_levels = [-2, 1, -3, 4, -1, 2, 1, -5, 4] self.assertEqual(max_subarray_sum(n, difficulty_levels), 6) def test_single_element_positive(self): n = 1 difficulty_levels = [5] self.assertEqual(max_subarray_sum(n, difficulty_levels), 5) def test_single_element_negative(self): n = 1 difficulty_levels = [-3] self.assertEqual(max_subarray_sum(n, difficulty_levels), -3) def test_alternating_positive_negative(self): n = 5 difficulty_levels = [2, -1, 2, -1, 2] self.assertEqual(max_subarray_sum(n, difficulty_levels), 4) def test_all_negative(self): n = 5 difficulty_levels = [-5, -2, -3, -1, -4] self.assertEqual(max_subarray_sum(n, difficulty_levels), -1) def test_all_positive(self): n = 5 difficulty_levels = [1, 2, 3, 4, 5] self.assertEqual(max_subarray_sum(n, difficulty_levels), 15) def test_large_input(self): n = 100000 difficulty_levels = [i for i in range(1, n + 1)] self.assertEqual(max_subarray_sum(n, difficulty_levels), n * (n + 1) // 2) def test_mixed_values(self): n = 6 difficulty_levels = [5, -6, 3, 4, 5, -1] self.assertEqual(max_subarray_sum(n, difficulty_levels), 12) if __name__ == \\"__main__\\": unittest.main()","solution":"def max_subarray_sum(n, difficulty_levels): Returns the maximum sum of difficulty levels within any contiguous segment of cities. :param n: integer, the number of cities :param difficulty_levels: list of integers, difficulty levels of the cities :return: integer, the maximum sum of difficulty levels within any contiguous segment # Implementing Kadane's Algorithm to find the maximum sum of contiguous subarray max_current = max_global = difficulty_levels[0] for i in range(1, n): max_current = max(difficulty_levels[i], max_current + difficulty_levels[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_moves_to_reach_farm_bottom_right(n: int, m: int, farm: List[str]) -> int: Calculate the minimum number of moves required to get the tractor from the top-left to the bottom-right corner. >>> min_moves_to_reach_farm_bottom_right(5, 6, [\\"#..#.#\\", \\".#.#\\", \\"#...\\", \\"#....#\\", \\"\\"]) -1 >>> min_moves_to_reach_farm_bottom_right(4, 4, [\\"..#.\\", \\"..\\", \\".#..\\", \\"....\\"]) 6 pass # Unit Tests def test_min_moves_example1(): n, m = 5, 6 farm = [ \\"#..#.#\\", \\".#.#\\", \\"#...\\", \\"#....#\\", \\"\\" ] assert min_moves_to_reach_farm_bottom_right(n, m, farm) == -1 def test_min_moves_example2(): n, m = 4, 4 farm = [ \\"..#.\\", \\"..\\", \\".#..\\", \\"....\\" ] assert min_moves_to_reach_farm_bottom_right(n, m, farm) == 6 def test_min_moves_blocked_start(): n, m = 3, 3 farm = [ \\"#..\\", \\"...\\", \\"...\\" ] assert min_moves_to_reach_farm_bottom_right(n, m, farm) == -1 def test_min_moves_blocked_end(): n, m = 3, 3 farm = [ \\"...\\", \\"...\\", \\"..#\\" ] assert min_moves_to_reach_farm_bottom_right(n, m, farm) == -1 def test_min_moves_no_obstacles(): n, m = 2, 2 farm = [ \\"..\\", \\"..\\" ] assert min_moves_to_reach_farm_bottom_right(n, m, farm) == 2","solution":"from collections import deque def min_moves_to_reach_farm_bottom_right(n, m, farm): if farm[0][0] == '#' or farm[n-1][m-1] == '#': return -1 # if start or end is blocked, no path is possible # Direction vectors for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() # If we've reached the bottom-right corner if r == n - 1 and c == m - 1: return dist # Explore all four directions for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and farm[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) # If no path found return -1 return -1 # Example usage if __name__ == \\"__main__\\": n, m = map(int, input().split()) farm = [input().strip() for _ in range(n)] print(min_moves_to_reach_farm_bottom_right(n, m, farm))"},{"question":"def theoricum_value(symbols: str) -> int: Computes the integer value represented by a string of Theoricum symbols. >>> theoricum_value(\\"XVI\\") 16 >>> theoricum_value(\\"XIV\\") 14 >>> theoricum_value(\\"XXI\\") 21 >>> theoricum_value(\\"IV\\") 4 >>> theoricum_value(\\"VI\\") 6 >>> theoricum_value(\\"X\\") 10 >>> theoricum_value(\\"V\\") 5 >>> theoricum_value(\\"I\\") 1 >>> theoricum_value(\\"XXX\\") 30 >>> theoricum_value(\\"XIX\\") 19 >>> theoricum_value(\\"XVIII\\") 18 >>> theoricum_value(\\"XXVII\\") 27","solution":"def theoricum_value(symbols): Computes the integer value represented by a string of Theoricum symbols. Parameters: symbols (str): A string of Theoricum symbols. Returns: int: The integer value of the given Theoricum symbols. # Dictionary to store the values of the symbols symbol_values = {'X': 10, 'V': 5, 'I': 1} total_value = 0 prev_value = 0 for symbol in symbols: curr_value = symbol_values[symbol] total_value += curr_value # If the current symbol value is greater than the previous symbol value, # it means we need to subtract twice the previous symbol value (once # to correct the addition and once more for the subtraction rule) if curr_value > prev_value: total_value -= 2 * prev_value prev_value = curr_value return total_value"},{"question":"from typing import List def most_frequent(nums: List[int]) -> int: Returns the most frequent element in the list. In case of a tie, returns the smallest element among the most frequent elements. >>> most_frequent([1, 3, 2, 3, 2, 1, 1]) 1 >>> most_frequent([4, 4, 5, 5, 2]) 4 >>> most_frequent([-1, -1, 0, 1, 1]) -1 pass","solution":"from collections import Counter def most_frequent(nums): Returns the most frequent element in the list. In case of a tie, returns the smallest element among the most frequent elements. if not nums: raise ValueError(\\"List should contain at least one element\\") count = Counter(nums) most_common = count.most_common() max_frequency = most_common[0][1] # Filter out elements that appear the maximum number of times candidates = [num for num, freq in most_common if freq == max_frequency] return min(candidates)"},{"question":"class Grid: def __init__(self, n, m, grid): Initialize the grid and prepare prefix sums for efficient range queries. :param n: Number of rows :param m: Number of columns :param grid: Initial values of the grid as a 2D list self.n = n self.m = m self.grid = grid self.prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] self._build_prefix_sum() def _build_prefix_sum(self): Build prefix sum array for the grid. for i in range(1, self.n + 1): for j in range(1, self.m + 1): self.prefix_sum[i][j] = self.grid[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1] def update_value(self, x, y, val): Update the value at position (x, y) to val. Adjust prefix sum accordingly. :param x: Row index (1-based) :param y: Column index (1-based) :param val: New value to be set at (x, y) original_val = self.grid[x-1][y-1] self.grid[x-1][y-1] = val diff = val - original_val for i in range(x, self.n + 1): for j in range(y, self.m + 1): self.prefix_sum[i][j] += diff def get_subgrid_sum(self, x1, y1, x2, y2): Get the sum of all values in the subgrid that spans from (x1, y1) to (x2, y2), inclusive. :param x1: Starting row index (1-based) :param y1: Starting column index (1-based) :param x2: Ending row index (1-based) :param y2: Ending column index (1-based) :return: Sum of the values in the specified subgrid return (self.prefix_sum[x2][y2] - self.prefix_sum[x1-1][y2] - self.prefix_sum[x2][y1-1] + self.prefix_sum[x1-1][y1-1]) # Process the input, build the grid and execute the queries def process_queries(n, m, q, grid_values, queries): Process the given queries on the grid. :param n: Number of rows :param m: Number of columns :param q: Number of queries :param grid_values: Initial values of the grid as a 2D list :param queries: List of queries to be processed :return: List of results for the sum queries results = [] grid = Grid(n, m, grid_values) for query in queries: if query[0] == 1: _, x, y, val = query grid.update_value(x, y, val) elif query[0] == 2: _, x1, y1, x2, y2 = query results.append(grid.get_subgrid_sum(x1, y1, x2, y2)) return results # Sample test cases def test_grid_sum(): n, m, q = 3, 3, 5 grid_values = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ [2, 1, 1, 2, 2], [1, 2, 2, 10], [2, 1, 1, 2, 2], [2, 2, 2, 3, 3], [1, 3, 3, -5], [2, 1, 1, 3, 3] ] expected_output = [12, 17, 33, 36] assert process_queries(n, m, q, grid_values, queries) == expected_output # Run the sample test test_grid_sum()","solution":"class Grid: def __init__(self, n, m, grid): self.n = n self.m = m self.grid = grid self.prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] self._build_prefix_sum() def _build_prefix_sum(self): for i in range(1, self.n + 1): for j in range(1, self.m + 1): self.prefix_sum[i][j] = self.grid[i-1][j-1] + self.prefix_sum[i-1][j] + self.prefix_sum[i][j-1] - self.prefix_sum[i-1][j-1] def update_value(self, x, y, val): original_val = self.grid[x-1][y-1] self.grid[x-1][y-1] = val diff = val - original_val for i in range(x, self.n + 1): for j in range(y, self.m + 1): self.prefix_sum[i][j] += diff def get_subgrid_sum(self, x1, y1, x2, y2): return (self.prefix_sum[x2][y2] - self.prefix_sum[x1-1][y2] - self.prefix_sum[x2][y1-1] + self.prefix_sum[x1-1][y1-1]) # Process input, build the grid and execute the queries def process_queries(n, m, q, grid_values, queries): results = [] grid = Grid(n, m, grid_values) for query in queries: if query[0] == 1: _, x, y, val = query grid.update_value(x, y, val) elif query[0] == 2: _, x1, y1, x2, y2 = query results.append(grid.get_subgrid_sum(x1, y1, x2, y2)) return results"},{"question":"def find_hello_path(N: int, M: int, grid: List[str]) -> str: Determine if there's a path through the matrix that spells out the word \\"HELLO\\". You can start from any cell and move either horizontally, vertically, or diagonally in any of the 8 possible directions. The same cell cannot be used more than once in a single word formation. Args: N (int): The number of rows in the matrix. M (int): The number of columns in the matrix. grid (List[str]): The matrix of characters. Returns: str: \\"YES\\" if there exists at least one path that spells \\"HELLO\\", otherwise \\"NO\\". >>> find_hello_path(3, 4, [\\"HAPE\\", \\"ELLO\\", \\"KXYZ\\"]) 'YES' >>> find_hello_path(3, 3, [\\"HAP\\", \\"ELX\\", \\"XYZ\\"]) 'NO' >>> find_hello_path(5, 5, [\\"HHHHH\\", \\"EEEEE\\", \\"LLLLL\\", \\"LLLLL\\", \\"OOOOO\\"]) 'YES' >>> find_hello_path(5, 5, [\\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\", \\"XXXXX\\"]) 'NO' >>> find_hello_path(1, 5, [\\"HELLO\\"]) 'YES' >>> find_hello_path(5, 1, [\\"H\\", \\"E\\", \\"L\\", \\"L\\", \\"O\\"]) 'YES' >>> find_hello_path(5, 5, [\\"H....\\", \\".E...\\", \\"..L..\\", \\"...L.\\", \\"....O\\"]) 'YES'","solution":"def is_path_for_hello(matrix, N, M): def dfs(x, y, idx): if idx == len(word): return True # Mark the current cell as visited temp = matrix[x][y] matrix[x][y] = None # Define the 8 possible directions directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and matrix[nx][ny] == word[idx]: if dfs(nx, ny, idx + 1): return True # Unmark the cell before returning to allow other paths matrix[x][y] = temp return False word = \\"HELLO\\" for i in range(N): for j in range(M): if matrix[i][j] == word[0]: # Start DFS when we find 'H' if dfs(i, j, 1): return \\"YES\\" return \\"NO\\" # Function to read input and call is_path_for_hello def find_hello_path(N, M, grid): matrix = [list(row) for row in grid] return is_path_for_hello(matrix, N, M) # Example input and function call N, M = 3, 4 grid = [ \\"HAPE\\", \\"ELLO\\", \\"KXYZ\\" ] print(find_hello_path(N, M, grid)) # Output should be \\"YES\\""},{"question":"from typing import List, Tuple def max_active_processes(requests: List[Tuple[int, int]]) -> int: Determine the maximum number of active processes given a list of requests. Parameters: requests (list of tuples): A list of tuples, each containing (timestamp, id), representing a request made at \\"timestamp\\" with unique \\"id\\". Returns: int: The maximum number of active processes at any point in time. >>> max_active_processes([(1, 100), (2, 200), (3, 100), (4, 300), (5, 200)]) 2 >>> max_active_processes([(1, 100), (1, 100), (2, 200)]) 1 def test_single_request(): assert max_active_processes([(0, 1)]) == 1 def test_no_duplicates(): assert max_active_processes([(1, 100), (2, 200), (3, 300)]) == 3 def test_all_duplicates(): assert max_active_processes([(1, 100), (2, 100), (3, 100)]) == 1 def test_some_duplicates(): assert max_active_processes([(1, 100), (2, 200), (3, 100), (4, 300), (5, 200)]) == 2 def test_large_input(): requests = [(i, i) for i in range(1, 100001)] # All unique requests assert max_active_processes(requests) == 100000 requests = [(i % 100, 1) for i in range(100000)] # All duplicate requests assert max_active_processes(requests) == 1","solution":"def max_active_processes(requests): Determine the maximum number of active processes given a list of requests. Parameters: requests (list of tuples): A list of tuples, each containing (timestamp, id), representing a request made at \\"timestamp\\" with unique \\"id\\". Returns: int: The maximum number of active processes at any point in time. active_processes = set() max_active = 0 for timestamp, req_id in requests: if req_id in active_processes: active_processes.remove(req_id) else: active_processes.add(req_id) max_active = max(max_active, len(active_processes)) return max_active # Example usage: requests = [(1, 100), (2, 200), (3, 100), (4, 300), (5, 200)] print(max_active_processes(requests)) # Output should be 2"},{"question":"def weather_updates(city_names, weather_data_entries): Returns weather updates for each city in the city_names list based on the provided weather_data_entries. If no weather data is available for a city, it outputs a corresponding message. >>> city_names = [\\"New York\\", \\"San Francisco\\", \\"Austin\\"] >>> weather_data_entries = [\\"New York:22:Sunny\\", \\"Austin:33:Hot\\", \\"Chicago:15:Cold\\", \\"San Francisco:18:Mild\\", \\"Seattle:10:Windy\\"] >>> weather_updates(city_names, weather_data_entries) [\\"In New York, it is currently 22 degrees and Sunny.\\",\\"In San Francisco, it is currently 18 degrees and Mild.\\",\\"In Austin, it is currently 33 degrees and Hot.\\"] >>> city_names = [\\"Boston\\", \\"Miami\\"] >>> weather_data_entries = [\\"Los Angeles:25:Sunny\\", \\"Houston:30:Hot\\", \\"Chicago:15:Cold\\"] >>> weather_updates(city_names, weather_data_entries) [\\"No weather data available for Boston.\\",\\"No weather data available for Miami.\\"]","solution":"def weather_updates(city_names, weather_data_entries): Returns weather updates for each city in the city_names list based on the provided weather_data_entries. If no weather data is available for a city, it outputs a corresponding message. weather_map = {} for entry in weather_data_entries: city, temperature, condition = entry.split(':') weather_map[city] = (temperature, condition) result = [] for city in city_names: if city in weather_map: temperature, condition = weather_map[city] result.append(f\\"In {city}, it is currently {temperature} degrees and {condition}.\\") else: result.append(f\\"No weather data available for {city}.\\") return result"},{"question":"def find_min_road_length(n, m, roads): Find the minimum total length of roads required to connect all locations. If not possible, return -1. :param n: int, number of locations :param m: int, number of potential roads :param roads: list of tuples (u, v, w) representing roads with their lengths :return: int, minimum total length of roads or -1 if not possible # Your code here import pytest def test_sample_1(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 3) ] assert find_min_road_length(n, m, roads) == 6 def test_sample_2(): n = 4 m = 2 roads = [ (1, 2, 3), (3, 4, 5) ] assert find_min_road_length(n, m, roads) == -1 def test_single_location(): n = 1 m = 0 roads = [] assert find_min_road_length(n, m, roads) == 0 def test_no_roads(): n = 3 m = 0 roads = [] assert find_min_road_length(n, m, roads) == -1 def test_already_connected(): n = 4 m = 4 roads = [ (1, 2, 1), (1, 3, 1), (3, 4, 1), (2, 4, 1) ] assert find_min_road_length(n, m, roads) == 3 def test_disconnected(): n = 5 m = 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), ] assert find_min_road_length(n, m, roads) == 4","solution":"def find_min_road_length(n, m, roads): Find the minimum total length of roads required to connect all locations. If not possible, return -1. :param n: int, number of locations :param m: int, number of potential roads :param roads: list of tuples (u, v, w) representing roads with their lengths :return: int, minimum total length of roads or -1 if not possible if n == 1: # If there's only one location, no roads are needed return 0 parent = list(range(n + 1)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX roads.sort(key=lambda x: x[2]) total_length = 0 edges_used = 0 for u, v, w in roads: if find(u) != find(v): union(u, v) total_length += w edges_used += 1 if edges_used == n - 1: break roots = set(find(x) for x in range(1, n + 1)) if len(roots) == 1: return total_length else: return -1"},{"question":"def has_pair_with_sum(N: int, K: int, A: List[int]) -> str: Determine if there are two distinct indices i and j in the array A such that the sum of A[i] and A[j] is equal to K. >>> has_pair_with_sum(4, 7, [1, 2, 3, 4]) 'YES' >>> has_pair_with_sum(5, 9, [1, 5, 3, 4, 4]) 'YES' >>> has_pair_with_sum(6, 10, [6, 4, 2, 5, -1, 7]) 'YES' >>> has_pair_with_sum(4, 8, [1, 2, 3, 4]) 'NO' >>> has_pair_with_sum(3, 5, [1, 1, 1]) 'NO' >>> has_pair_with_sum(5, 0, [1, 2, 3, 4, 5]) 'NO' >>> has_pair_with_sum(4, 0, [-1, 1, 3, -3]) 'YES' >>> has_pair_with_sum(4, -2, [-1, -1, 2, 3]) 'YES' >>> has_pair_with_sum(3, -5, [-2, -3, 1]) 'YES'","solution":"def has_pair_with_sum(N, K, A): seen = set() for num in A: if K - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def count_unique_calls(input_str: str) -> list: Count the unique phone numbers from the call logs. Args: input_str (str): A multi-line string where: - The first line of each dataset contains an integer n (1 ≤ n ≤ 1000) indicating the number of phone numbers. - The next n lines each contain a single phone number. - Datasets are separated by a line with a single 0. Returns: list: A list of integers where each integer is the count of unique phone numbers in the corresponding dataset. Example: >>> count_unique_calls(\\"4n123-456-7890n987-654-3210n123-456-7890n345-678-9012n5n1234567890n1234567890n000-000-0000n555-555-5555n555-555-5555n0\\") [3, 3]","solution":"def count_unique_calls(input_str): Function to count unique phone numbers from the log. logs = input_str.strip().split('n') result = [] i = 0 while i < len(logs): n = int(logs[i]) if n == 0: break phone_numbers = set() for j in range(i + 1, i + 1 + n): phone_numbers.add(logs[j]) result.append(len(phone_numbers)) i += n + 1 return result"},{"question":"from typing import List def compute_gcd(a: int, b: int) -> int: return math.gcd(a, b) def max_gcd_after_removal(N: int, A: List[int]) -> int: Given a sequence of N positive integers, find the maximum possible GCD after removing exactly one integer. >>> max_gcd_after_removal(5, [12, 15, 18, 24, 30]) 6 >>> max_gcd_after_removal(2, [10, 20]) 20 # Implementation here","solution":"import math from typing import List def compute_gcd(a: int, b: int) -> int: return math.gcd(a, b) def max_gcd_after_removal(N: int, A: List[int]) -> int: if N == 2: return max(A) prefix_gcd = [0] * (N + 1) suffix_gcd = [0] * (N + 1) for i in range(1, N + 1): prefix_gcd[i] = compute_gcd(prefix_gcd[i - 1], A[i - 1]) for j in range(N - 1, -1, -1): suffix_gcd[j] = compute_gcd(suffix_gcd[j + 1], A[j]) max_gcd = 0 for k in range(N): if k == 0: current_gcd = suffix_gcd[1] elif k == N - 1: current_gcd = prefix_gcd[N - 1] else: current_gcd = compute_gcd(prefix_gcd[k], suffix_gcd[k + 1]) max_gcd = max(max_gcd, current_gcd) return max_gcd"},{"question":"def daily_temperatures(temperatures): Given a list of daily temperatures, this function returns a list of numbers where each number represents the number of days to wait until a warmer temperature. If there is no future day with a warmer temperature, the value is 0. >>> daily_temperatures([30, 40, 50, 60, 70, 80, 90, 100]) [1, 1, 1, 1, 1, 1, 1, 0] >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 90, 80, 70, 60, 50, 40, 30]) [0, 0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70, 70, 70, 70, 70]) [0, 0, 0, 0, 0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([30, 40, 50, 60, 50, 40, 30]) [1, 1, 1, 0, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Given a list of daily temperatures, this function returns a list of numbers where each number represents the number of days to wait until a warmer temperature. If there is no future day with a warmer temperature, the value is 0. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: last = stack.pop() answer[last] = i - last stack.append(i) return answer"},{"question":"def get_top_k_books(books: List[Tuple[str, int, int]], queries: List[Tuple[str, int]]) -> List[List[str]]: Given a list of books and queries, returns the top k books based on the specified criteria. Parameters: books (list of tuples): List of tuples where each tuple consists of (title, price, rating). queries (list of tuples): List of queries where each tuple consists of (criteria, k). Returns: list of lists: List of lists where each inner list contains titles of top k books for each query. >>> books = [ ... ('HarryPotter', 300, 95), ... ('LordOfTheRings', 500, 97), ... ('ToKillAMockingbird', 400, 80), ... ('TheGreatGatsby', 150, 85), ... ('WarAndPeace', 450, 99) ... ] >>> queries = [('price', 3)] >>> get_top_k_books(books, queries) [['TheGreatGatsby', 'HarryPotter', 'ToKillAMockingbird']] >>> queries = [('rating', 2)] >>> get_top_k_books(books, queries) [['WarAndPeace', 'LordOfTheRings']]","solution":"def get_top_k_books(books, queries): Given a list of books and queries, returns the top k books based on the specified criteria. Parameters: books (list of tuples): List of tuples where each tuple consists of (title, price, rating). queries (list of tuples): List of queries where each tuple consists of (criteria, k). Returns: list of lists: List of lists where each inner list contains titles of top k books for each query. results = [] for criteria, k in queries: if criteria == 'price': sorted_books = sorted(books, key=lambda x: (x[1], x[0])) elif criteria == 'rating': sorted_books = sorted(books, key=lambda x: (-x[2], x[0])) top_k_books = [book[0] for book in sorted_books[:k]] results.append(top_k_books) return results"},{"question":"def find_unique_element(arr): You are given an array of integers where each element appears twice except for one unique element that appears only once. Your task is to find the element that appears only once. Args: arr (List[int]): An array of integers. Returns: int: The single integer that appears only once in the array. >>> find_unique_element([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_element([9, 2, 2, 9, 7]) 7 pass from solution import find_unique_element def test_single_unique_element(): assert find_unique_element([4, 3, 2, 4, 1, 3, 2]) == 1 assert find_unique_element([9, 2, 2, 9, 7]) == 7 def test_all_elements_same_except_one(): assert find_unique_element([6, 6, 7, 7, 8, 8, 5]) == 5 assert find_unique_element([10, 10, 11, 11, 12, 12, 9]) == 9 def test_single_element(): assert find_unique_element([13]) == 13 def test_large_array(): large_array = [i for i in range(1, 10001)] * 2 + [999999] assert find_unique_element(large_array) == 999999 def test_edge_case_with_minimum_values(): assert find_unique_element([1, 2, 1, 3, 2, 3, 4]) == 4 assert find_unique_element([1, 1, 2, 2, 3, 3, 5]) == 5","solution":"def find_unique_element(arr): unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def can_reach_collection_container(n: int, m: int, pipes: List[Tuple[int, int]], s: int, c: int, collections: Set[int]) -> str: Determine if the liquid starting from a given section can reach any of the collection containers. Args: n (int): The number of sections. m (int): The number of pipes. pipes (List[Tuple[int, int]]): List of directed pipes from section u to section v. s (int): The starting section. c (int): The number of collection containers. collections (Set[int]): Set of sections that are collection containers. Returns: str: \\"YES\\" if the liquid can reach a collection container starting from section \`s\`, otherwise \\"NO\\". >>> can_reach_collection_container(5, 6, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)], 1, 2, {4, 5}) 'YES' >>> can_reach_collection_container(5, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 1, {5}) 'NO'","solution":"def can_reach_collection_container(n, m, pipes, s, c, collections): from collections import deque, defaultdict graph = defaultdict(list) for u, v in pipes: graph[u].append(v) visited = [False] * (n + 1) queue = deque([s]) visited[s] = True while queue: current_section = queue.popleft() if current_section in collections: return \\"YES\\" for neighbor in graph[current_section]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"NO\\""},{"question":"def generate_password(input_string: str) -> str: Generates a secure password based on the given input string according to Zedonia's rules. >>> generate_password(\\"hello\\") \\"olleh\\" >>> generate_password(\\"HELLO\\") \\"hello\\" >>> generate_password(\\"12345\\") \\"15\\" >>> generate_password(\\"aBcDeF\\") \\"AbCdEf\\" >>> generate_password(\\"Hello123\\") \\"INVALID\\"","solution":"def generate_password(input_string): Generates a secure password based on the given input string based on Zedonia's rules. if input_string.islower(): return input_string[::-1] elif input_string.isupper(): return input_string.lower() elif input_string.isdigit(): return str(sum(int(char) for char in input_string)) elif input_string.isalpha(): return input_string.swapcase() else: return \\"INVALID\\""},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, initial_forest: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a series of update and frequency queries on a list representing a forest. Args: n: The number of trees in the forest array. q: The number of queries. initial_forest: List of integers representing the initial tree species in the forest. queries: List of tuples where each is a query in the format: - (1, i, x): Update the tree species at index \`i\` to \`x\`. - (2, l, r): Determine the most frequent tree species in the subarray from index \`l\` to index \`r\`. Returns: List of integers where each element is the result of a frequency query. >>> process_queries(5, 5, [1, 2, 2, 1, 3], [(2, 1, 5), (1, 3, 1), (2, 1, 5), (2, 2, 4), (2, 3, 5)]) [1, 1, 1, 1] >>> process_queries(5, 1, [1, 2, 2, 1, 3], [(1, 5, 2)]) [] >>> process_queries(5, 1, [1, 2, 2, 2, 3], [(2, 1, 5)]) [2] >>> process_queries(5, 1, [1, 1, 1, 1, 1], [(2, 1, 5)]) [1] >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 1, 4), (1, 5, 4), (2, 1, 5)]) [4] # Your code here","solution":"import collections class Forest: def __init__(self, trees): self.trees = trees def update(self, i, x): self.trees[i] = x def query(self, l, r): subarray = self.trees[l:r+1] counter = collections.Counter(subarray) max_freq = max(counter.values()) most_common = [tree for tree, freq in counter.items() if freq == max_freq] return min(most_common) def process_queries(n, q, initial_forest, queries): forest = Forest(initial_forest) results = [] for query in queries: if query[0] == 1: _, i, x = query forest.update(i-1, x) elif query[0] == 2: _, l, r = query result = forest.query(l-1, r-1) results.append(result) return results"},{"question":"def collatz_steps(n: int) -> int: Calculate the number of steps to reduce a number to 1 following the rules: - If the current number is even, the next number is half of the current number. - If the current number is odd and greater than 1, the next number is three times the current number plus 1. - The sequence stops when it reaches 1. :param n: A positive integer :return: The number of steps to reduce n to 1 >>> collatz_steps(1) 0 >>> collatz_steps(2) 1 >>> collatz_steps(3) 7 >>> collatz_steps(4) 2 >>> collatz_steps(5) 5 def total_collatz_steps(T: int, test_cases: List[int]) -> List[int]: For each test case, calculate the total number of steps required for all numbers from 1 to N to reduce to 1 :param T: The number of test cases :param test_cases: A list of integers where each integer N is a test case :return: A list of integers, each representing the total number of steps for the corresponding test case >>> total_collatz_steps(1, [3]) [8] >>> total_collatz_steps(1, [5]) [15] >>> total_collatz_steps(2, [3, 5]) [8, 15] >>> total_collatz_steps(3, [1, 2, 3]) [0, 1, 8]","solution":"def collatz_steps(n): steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = 3 * n + 1 steps += 1 return steps def total_collatz_steps(T, test_cases): results = [] for N in test_cases: total_steps = 0 for i in range(1, N + 1): total_steps += collatz_steps(i) results.append(total_steps) return results"},{"question":"def analyze_profitability(datasets: List[List[str]]) -> List[str]: Analyze the profitability of products and return their IDs in the descending order of profitability. >>> analyze_profitability([['3', 'widget1 10 50 200', 'widget2 15 30 150', 'widget3 20 40 160'], ['2', 'gadget1 12 60 240', 'gadget2 8 50 200']]) ['widget2', 'widget1', 'widget3', '#', 'gadget1', 'gadget2', '#'] pass def process_input(input_str: str) -> List[str]: datasets = [] dataset = [] for line in input_str.strip().splitlines(): if line == '0': if dataset: datasets.append(dataset) break elif line.isdigit(): if dataset: datasets.append(dataset) dataset = [] dataset.append(line) return analyze_profitability(datasets) # Unit Test def test_analyze_profitability(): input_str = 3 widget1 10 50 200 widget2 15 30 150 widget3 20 40 160 2 gadget1 12 60 240 gadget2 8 50 200 0 expected_output = [ 'widget2', 'widget1', 'widget3', '#', 'gadget1', 'gadget2', '#' ] assert process_input(input_str) == expected_output def test_single_product(): input_str = 1 product1 10 100 300 0 expected_output = [ 'product1', '#' ] assert process_input(input_str) == expected_output def test_same_profitability(): input_str = 3 producta 10 100 200 productb 20 200 400 productc 5 50 100 0 expected_output = [ 'producta', 'productb', 'productc', '#' ] assert process_input(input_str) == expected_output def test_multiple_equal_products(): input_str = 4 producta 10 50 100 productb 15 75 150 productc 25 125 250 productz 30 150 300 0 expected_output = [ 'producta', 'productb', 'productc', 'productz', '#' ] assert process_input(input_str) == expected_output def test_empty_dataset(): input_str = 0 expected_output = [] assert process_input(input_str) == expected_output","solution":"def analyze_profitability(datasets): result = [] for dataset in datasets: n = int(dataset[0]) products = dataset[1:] profitability_list = [] for product in products: prod_details = product.split() prod_id = prod_details[0] cost = float(prod_details[2]) price = float(prod_details[3]) profitability = price / cost profitability_list.append((prod_id, profitability)) # Sort first by profitability descending, then by prod_id if equal profitability profitability_list.sort(key=lambda x: (-x[1], x[0])) for prod in profitability_list: result.append(prod[0]) result.append('#') return result # Example usage function def process_input(input_str): datasets = [] dataset = [] for line in input_str.strip().splitlines(): if line == '0': if dataset: datasets.append(dataset) break elif line.isdigit(): if dataset: datasets.append(dataset) dataset = [] dataset.append(line) return analyze_profitability(datasets)"},{"question":"def max_pairs(N: int, H: List[int]) -> int: Find the maximum number of pairs (i, j) such that 1 ≤ i < j ≤ N and H[i] < H[j]. >>> max_pairs(5, [2, 1, 5, 4, 3]) 6 >>> max_pairs(3, [3, 2, 1]) 0 >>> max_pairs(4, [1, 2, 3, 4]) 6 >>> max_pairs(4, [1, 1, 1, 1]) 0 >>> max_pairs(5, [3, 1, 4, 2, 5]) 7","solution":"def max_pairs(N, H): count = 0 for i in range(N): for j in range(i + 1, N): if H[i] < H[j]: count += 1 return count"},{"question":"def schedule_classes(n: int, m: int, schedules: List[Tuple[int, int]]) -> Tuple[str, List[int]]: Determines if it is possible to schedule all classes in the given classrooms without conflicts. Parameters: n (int): Number of classrooms available. m (int): Number of classes. schedules (list of tuples): Each tuple contains start and end time of each class. Returns: tuple: (\\"YES\\" or \\"NO\\", List of assigned classrooms if \\"YES\\", otherwise empty list) pass from typing import List, Tuple def test_schedule_classes_no_conflict(): n = 3 m = 5 schedules = [(1, 4), (2, 5), (6, 8), (3, 7), (8, 10)] assert schedule_classes(n, m, schedules)[0] == \\"YES\\" def test_schedule_classes_with_conflict(): n = 2 m = 4 schedules = [(1, 4), (2, 5), (6, 8), (3, 7)] assert schedule_classes(n, m, schedules)[0] == \\"NO\\" def test_schedule_classes_exact_fit(): n = 2 m = 3 schedules = [(1, 4), (4, 5), (5, 6)] result = schedule_classes(n, m, schedules) assert result[0] == \\"YES\\" assert result[1] == [1, 1, 1] or result[1] == [1, 2, 2] def test_schedule_classes_single_classroom(): n = 1 m = 4 schedules = [(1, 4), (4, 5), (5, 6), (6, 7)] result = schedule_classes(n, m, schedules) assert result[0] == \\"YES\\" assert result[1] == [1, 1, 1, 1] def test_schedule_classes_one_class(): n = 2 m = 1 schedules = [(1, 4)] result = schedule_classes(n, m, schedules) assert result[0] == \\"YES\\" assert result[1] == [1]","solution":"def schedule_classes(n, m, schedules): Determines if it is possible to schedule all classes in the given classrooms without conflicts. Parameters: n (int): Number of classrooms available. m (int): Number of classes. schedules (list of tuples): Each tuple contains start and end time of each class. Returns: tuple: (\\"YES\\" or \\"NO\\", List of assigned classrooms if \\"YES\\", otherwise empty list) schedules = sorted(schedules, key=lambda x: x[0]) # Sort schedules by start times classrooms = [[] for _ in range(n)] # Initialize classrooms with empty schedules assignment = [-1] * m # To record the classroom assignment for each class for i, (start, end) in enumerate(schedules): assigned = False for j in range(n): if not classrooms[j] or classrooms[j][-1][1] <= start: # If the classroom is free to use classrooms[j].append((start, end)) assignment[i] = j + 1 # Assigning to classroom (1-indexed) assigned = True break if not assigned: return (\\"NO\\", []) return (\\"YES\\", assignment) # Example usage if __name__ == \\"__main__\\": n = 3 m = 5 schedules = [(1, 4), (2, 5), (6, 8), (3, 7), (8, 10)] result = schedule_classes(n, m, schedules) print(result[0]) if result[0] == \\"YES\\": for room in result[1]: print(room)"},{"question":"def max_distance(commands: str) -> float: Calculate the maximum distance from the origin after executing a series of commands. :param commands: A string of commands (U, D, L, R) :return: Maximum Euclidean distance from the origin during the execution of the commands >>> max_distance('UUDDLRLR') 2.0 >>> max_distance('UUUUU') 5.0 >>> max_distance('UDLR') 1.0 >>> max_distance('UUUDDDRRR') 3.0 >>> max_distance('U'*50000 + 'D'*50000) 50000.0 >>> max_distance('') 0.0","solution":"def max_distance(commands): Calculate the maximum distance from the origin after executing a series of commands. :param commands: A string of commands (U, D, L, R) :return: Maximum Euclidean distance from the origin during the execution of the commands x, y = 0, 0 # Starting at the origin max_dist = 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 # Calculate the Euclidean distance from the origin current_dist = (x ** 2 + y ** 2) ** 0.5 max_dist = max(max_dist, current_dist) return max_dist"},{"question":"def process_queries(matrix, queries): Given a mxn matrix and a list of queries, where each query can ask for the sum or maximum of a submatrix, this function returns the results of all the queries. >>> matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> queries = [[\\"S\\", \\"1\\", \\"1\\", \\"2\\", \\"2\\"], [\\"M\\", \\"1\\", \\"1\\", \\"3\\", \\"3\\"], [\\"S\\", \\"2\\", \\"2\\", \\"3\\", \\"3\\"], [\\"M\\", \\"1\\", \\"2\\", \\"2\\", \\"3\\"], [\\"S\\", \\"1\\", \\"1\\", \\"3\\", \\"3\\"]] >>> process_queries(matrix, queries) [12, 9, 28, 6, 45] # Implement the function here def test_process_queries(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [[\\"S\\", \\"1\\", \\"1\\", \\"2\\", \\"2\\"], [\\"M\\", \\"1\\", \\"1\\", \\"3\\", \\"3\\"], [\\"S\\", \\"2\\", \\"2\\", \\"3\\", \\"3\\"], [\\"M\\", \\"1\\", \\"2\\", \\"2\\", \\"3\\"], [\\"S\\", \\"1\\", \\"1\\", \\"3\\", \\"3\\"]] assert process_queries(matrix, queries) == [12, 9, 28, 6, 45]","solution":"def process_queries(matrix, queries): def submatrix_sum(x1, y1, x2, y2): return sum(matrix[i][j] for i in range(x1-1, x2) for j in range(y1-1, y2)) def submatrix_max(x1, y1, x2, y2): return max(matrix[i][j] for i in range(x1-1, x2) for j in range(y1-1, y2)) results = [] for query in queries: type_query = query[0] x1, y1, x2, y2 = map(int, query[1:]) if type_query == 'S': results.append(submatrix_sum(x1, y1, x2, y2)) elif type_query == 'M': results.append(submatrix_max(x1, y1, x2, y2)) return results # Function to parse the input and call process_queries def main(input_data): input_lines = input_data.strip().split('n') m, n = map(int, input_lines[0].split()) matrix = [] for i in range(1, m + 1): matrix.append(list(map(int, input_lines[i].split()))) Q = int(input_lines[m + 1]) queries = [input_lines[m + 2 + i].split() for i in range(Q)] results = process_queries(matrix, queries) for result in results: print(result) # Example usage input_data = 3 3 1 2 3 4 5 6 7 8 9 5 S 1 1 2 2 M 1 1 3 3 S 2 2 3 3 M 1 2 2 3 S 1 1 3 3 main(input_data)"},{"question":"def contains_anagram(strings: List[str]) -> bool: Returns True if any two strings in the list are anagrams of each other, otherwise False. >>> contains_anagram([]) False >>> contains_anagram([\\"\\"]) False >>> contains_anagram([\\"listen\\", \\"silent\\"]) True >>> contains_anagram([\\"listen\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gooegl\\"]) True >>> contains_anagram([\\"abc\\", \\"def\\", \\"ghi\\"]) False >>> contains_anagram([\\"aabbcc\\", \\"baccab\\", \\"ccabbac\\", \\"abcabc\\", \\"xy\\"]) True","solution":"def contains_anagram(strings): Returns True if any two strings in the list are anagrams of each other, otherwise False. sorted_strings = [''.join(sorted(s)) for s in strings] return len(sorted_strings) != len(set(sorted_strings))"},{"question":"def can_rearrange(arr): Determines if it's possible to rearrange the array such that no two adjacent integers have a sum that is a multiple of 10. pass def process_test_cases(num_cases, test_cases): results = [] for case in test_cases: results.append(can_rearrange(case)) return results def main(test_input): Processes the input and calls the necessary functions to determine if the rearrangement is possible for each test case. >>> main(\\"2n1 2 3 4 5n10 20 30 40\\") [\\"YES\\", \\"NO\\"] >>> main(\\"1n2 4 6 8\\") [\\"YES\\"] >>> main(\\"2n9 1 8 2n3 7 5 5 5 5 5\\") [\\"YES\\", \\"YES\\"] >>> main(\\"1n1000000000 1000000001 1000000002 1000000003\\") [\\"YES\\"] >>> main(\\"1n55\\") [\\"YES\\"] test_lines = test_input.strip().splitlines() T = int(test_lines[0]) test_cases = [list(map(int, line.split())) for line in test_lines[1:T+1]] return process_test_cases(T, test_cases)","solution":"def can_rearrange(arr): Determines if it's possible to rearrange the array such that no two adjacent integers have a sum that is a multiple of 10. counts = [0] * 10 # To store counts of elements with each possible last digit (0 through 9) for num in arr: counts[num % 10] += 1 # Check for odd and even pattern matching for i in range(10): if counts[i] % 2 != 0: return \\"YES\\" return \\"NO\\" def process_test_cases(num_cases, test_cases): results = [] for case in test_cases: results.append(can_rearrange(case)) return results def main(test_input): test_lines = test_input.strip().splitlines() T = int(test_lines[0]) test_cases = [list(map(int, line.split())) for line in test_lines[1:T+1]] return process_test_cases(T, test_cases)"},{"question":"from typing import List, Tuple def get_led_coordinates(pattern: str) -> Tuple[int, List[Tuple[int, int]]]: This function takes a string pattern and returns a list of tuples where each tuple represents the (row, column) of an LED to be lit. Assumes a single row grid. :param pattern: str, the desired pattern with letters, spaces and asterisks :return: Tuple containing the count of LEDs and a list of tuples representing coordinates of LEDs to be lit >>> get_led_coordinates(\\"Hello*World\\") (10, [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11)]) >>> get_led_coordinates(\\"**T*e s*t**\\") (4, [(1, 3), (1, 5), (1, 7), (1, 9)]) >>> get_led_coordinates(\\"* * * * \\") (0, []) >>> get_led_coordinates(\\"ABCDE\\") (5, [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)])","solution":"def get_led_coordinates(pattern): This function takes a string pattern and returns a list of tuples where each tuple represents the (row, column) of an LED to be lit. Assumes a single row grid. :param pattern: str, the desired pattern with letters, spaces and asterisks :return: List of tuples representing coordinates of LEDs to be lit leds = [] row = 1 # Given the problem context, we are using only one row for column, char in enumerate(pattern, 1): if char.isalpha(): leds.append((row, column)) led_count = len(leds) return led_count, leds"},{"question":"def check_balance(T, test_cases): Given T test cases with two arrays of integers each, determines if they have the same set of unique integers. Parameters: T (int): number of test cases. test_cases (list of tuples): each tuple contains the arrays to be checked. Returns: list of str: \\"BALANCED\\" if both arrays have the same set of unique integers, otherwise \\"UNBALANCED\\". pass def parse_input(input_str): Parses the input string as per the given format. Parameters: input_str (str): input string in specified format. Returns: tuple: T and test_cases structure required for check_balance. pass","solution":"def check_balance(T, test_cases): Given T test cases with two arrays of integers each, determines if they have the same set of unique integers. Parameters: T (int): number of test cases. test_cases (list of tuples): each tuple contains the arrays to be checked. Returns: list of str: \\"BALANCED\\" if both arrays have the same set of unique integers, otherwise \\"UNBALANCED\\". results = [] for case in test_cases: n, array1, m, array2 = case set1 = set(array1) set2 = set(array2) if set1 == set2: results.append(\\"BALANCED\\") else: results.append(\\"UNBALANCED\\") return results def parse_input(input_str): Parses the input string as per the given format. Parameters: input_str (str): input string in specified format. Returns: tuple: T and test_cases structure required for check_balance. lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) array1 = list(map(int, lines[index+1].split())) m = int(lines[index+2]) array2 = list(map(int, lines[index+3].split())) test_cases.append((n, array1, m, array2)) index += 4 return T, test_cases"},{"question":"def remove_duplicates(lst: List[int]) -> List[int]: Removes duplicates from the input list while preserving the order of their first appearance. >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) == [1, 2, 3, 4, 5] >>> remove_duplicates([5, 1, 5, 1, 3, 3, 2]) == [5, 1, 3, 2] >>> remove_duplicates([7, 7, 7, 7, 7, 7]) == [7] >>> remove_duplicates([]) == [] pass","solution":"def remove_duplicates(lst): Removes duplicates from the input list while preserving the order of their first appearance. seen = set() result = [] for number in lst: if number not in seen: seen.add(number) result.append(number) return result"},{"question":"from typing import List, Tuple def shortest_travel_time(N: int, M: int, Capital: int, roads: List[Tuple[int, int, int]]) -> List[int]: Determine the shortest travel time from the Capital to all other cities. If a city cannot be reached from the Capital, return -1 for that city. Args: N : int : The number of cities. M : int : The number of roads. Capital : int : The special city designated as the Capital. roads : List[Tuple[int, int, int]] : Each tuple contains two cities and the travel time between them. Returns: List[int] : The shortest travel time from the Capital to each city, in the order from city 1 to N. Example: >>> N = 4 >>> M = 4 >>> Capital = 1 >>> roads = [(1, 2, 5), (1, 3, 10), (2, 4, 15), (3, 4, 10)] >>> shortest_travel_time(N, M, Capital, roads) [0, 5, 10, 20] >>> N = 4 >>> M = 2 >>> Capital = 1 >>> roads = [(1, 2, 5), (3, 4, 10)] >>> shortest_travel_time(N, M, Capital, roads) [0, 5, -1, -1] pass","solution":"import heapq import sys from collections import defaultdict def shortest_travel_time(N, M, Capital, roads): graph = defaultdict(list) # Creating the graph for u, v, travel_time in roads: graph[u].append((v, travel_time)) graph[v].append((u, travel_time)) # Dijkstra's algorithm heap = [(0, Capital)] distances = {i: float('inf') for i in range(1, N+1)} distances[Capital] = 0 while heap: current_dist, current_city = heapq.heappop(heap) if current_dist > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) result = [] for i in range(1, N+1): if i == Capital: result.append(0) else: result.append(distances[i] if distances[i] != float('inf') else -1) return result"},{"question":"def unique_chars(s): Given a string consisting of digits and lowercase alphabetic characters, remove the consecutively repeated characters and count the number of unique characters left. For each unique character, calculate its frequency in the string, and return the list of unique characters along with their counts in the original order of appearance. Args: s (str): input string of digits and lowercase alphabetic characters. Returns: List[Tuple[str, int]]: list of tuples, each containing a unique character and its frequency in the original string. Examples: >>> unique_chars(\\"aabbccdde\\") [('a', 2), ('b', 2), ('c', 2), ('d', 2), ('e', 1)] >>> unique_chars(\\"11233\\") [('1', 2), ('2', 1), ('3', 2)] >>> unique_chars(\\"abcd\\") [('a', 1), ('b', 1), ('c', 1), ('d', 1)]","solution":"def unique_chars(s): Given a string consisting of digits and lowercase alphabetic characters, remove the consecutively repeated characters and count the number of unique characters left. For each unique character, calculate its frequency in the string, and return the list of unique characters along with their counts in the original order of appearance. Args: s (str): input string of digits and lowercase alphabetic characters. Returns: List[Tuple[str, int]]: list of tuples, each containing a unique character and its frequency in the original string. # Initialize an empty dictionary to keep track of character frequencies char_count = {} # Iterate over each character in the string for i in range(len(s)): curr_char = s[i] if curr_char in char_count: char_count[curr_char] += 1 else: char_count[curr_char] = 1 # Create a list of tuples from the dictionary unique_chars_list = [(char, count) for char, count in char_count.items()] return unique_chars_list"},{"question":"def longestAltSubseq(N: int, S: str) -> int: Given an integer N and a string S of length N consisting of lowercase English alphabets, find the length of the longest subsequence of S such that it can be formed by alternating two distinct characters. Example 1: >>> longestAltSubseq(5, \\"abbab\\") 4 Example 2: >>> longestAltSubseq(7, \\"abcabc\\") 4","solution":"def longestAltSubseq(N, S): Returns the length of the longest subsequence of S that can be formed by alternating two distinct characters. max_length = 0 # Create a set of all characters in the string characters = set(S) # Check pairs of different characters for first_char in characters: for second_char in characters: if first_char != second_char: length = 0 last_char = '' for char in S: if char == first_char or char == second_char: if char != last_char: length += 1 last_char = char max_length = max(max_length, length) return max_length"},{"question":"def decode_message(n, encoded): Takes the number of positions letters are rotated and the encoded message, returns the decoded original message. :param n: int, number of positions each letter has been rotated :param encoded: str, the encoded message consisting of lowercase letters and spaces :return: str, the decoded message >>> decode_message(3, 'def') 'abc' >>> decode_message(1, 'bcd efg') 'abc def' >>> decode_message(1, 'a') 'z' >>> decode_message(0, 'hello world') 'hello world' >>> decode_message(25, 'zab') 'abc' # Your code here def process_test_cases(tc, test_cases): Processes multiple test cases of decoding messages. :param tc: int, number of test cases :param test_cases: list of tuples, where each tuple contains an integer (number of rotations) and an encoded string :return: list of strs, each string being the decoded message for that test case >>> tc = 2 >>> test_cases = [(3, 'def'), (1, 'bcd efg')] >>> process_test_cases(tc, test_cases) ['abc', 'abc def'] # Your code here","solution":"def decode_message(n, encoded): Takes the number of positions letters are rotated and the encoded message, returns the decoded original message. :param n: integer, number of positions each letter has been rotated :param encoded: string, the encoded message consisting of lowercase letters and spaces :return: string, the decoded message decoded = [] for char in encoded: if char == ' ': decoded.append(char) else: decoded_char = chr((ord(char) - ord('a') - n) % 26 + ord('a')) decoded.append(decoded_char) return ''.join(decoded) def process_test_cases(tc, test_cases): Processes multiple test cases of decoding messages. :param tc: integer, number of test cases :param test_cases: list of tuples, where each tuple contains an integer (number of rotations) and an encoded string :return: list of strings, each string being the decoded message for that test case results = [] for n, message in test_cases: results.append(decode_message(n, message)) return results"},{"question":"def minimal_time_to_pass(n: int, g: int, scenarios: List[str]) -> List[int]: Calculate the minimal time for a car to pass through the traffic lights. Arguments: n -- the number of test scenarios g -- the green/red cycle time scenarios -- list of test scenarios in the format ['RG1', 'GG2', 'RR1'] Returns: A list of integers representing the minimum number of seconds required for the car to pass through the traffic lights for each scenario. >>> minimal_time_to_pass(3, 5, ['RG1', 'GG2', 'RR1']) [0, 0, 5] >>> minimal_time_to_pass(2, 10, ['RR2', 'GR1']) [10, 0] >>> minimal_time_to_pass(3, 7, ['GG1', 'GR2', 'RG2']) [0, 0, 0] >>> minimal_time_to_pass(4, 6, ['RR1', 'RR2', 'RG1', 'GR2']) [6, 6, 0, 0] >>> minimal_time_to_pass(2, 1, ['RR1', 'GG1']) [1, 0]","solution":"def minimal_time_to_pass(n, g, scenarios): results = [] for scenario in scenarios: light1 = scenario[0] light2 = scenario[1] start_lane = scenario[2] # If start lane is 1 if start_lane == '1': if light1 == 'G': # Green light in the starting lane results.append(0) elif light2 == 'G': # Red light in the starting lane but green in the other lane results.append(0) else: # Both red results.append(g) # If start lane is 2 elif start_lane == '2': if light2 == 'G': # Green light in the starting lane results.append(0) elif light1 == 'G': # Red light in the starting lane but green in the other lane results.append(0) else: # Both red results.append(g) return results"},{"question":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([[5]]) [[5]] def process_test_cases(test_cases): Processes multiple test cases and returns the rotated matrices. >>> process_test_cases([ ... [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], ... [ ... [1, 2], ... [3, 4] ... ] ... ]) [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [3, 1], [4, 2] ] ]","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated def process_test_cases(test_cases): Processes multiple test cases and returns the rotated matrices. results = [] for matrix in test_cases: rotated = rotate_matrix(matrix) results.append(rotated) return results"},{"question":"def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merge overlapping or contiguous intervals in a list. >>> merge_intervals([(1, 3), (2, 4), (5, 7), (6, 9)]) [(1, 4), (5, 9)] >>> merge_intervals([(10, 20), (30, 40), (15, 25), (27, 35)]) [(10, 25), (27, 40)]","solution":"def merge_intervals(intervals): if not intervals: return [] # First, sort the intervals by their start values intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Overlapping or contiguous intervals current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"def longest_subset_subsequence_length(n: int, sequences: List[str]) -> int: Returns the length of the longest subset subsequence that can be found in all given sequences. >>> longest_subset_subsequence_length(3, [\\"abc\\", \\"abcd\\", \\"abdc\\"]) 3 >>> longest_subset_subsequence_length(2, [\\"geeksforgeeks\\", \\"geeks\\"]) 5 >>> longest_subset_subsequence_length(1, [\\"abc\\"]) 3 >>> longest_subset_subsequence_length(3, [\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> longest_subset_subsequence_length(2, [\\"a\\", \\"b\\"]) 0 >>> longest_subset_subsequence_length(3, [\\"abc\\", \\"aabbcc\\", \\"abccba\\"]) 3 >>> longest_subset_subsequence_length(2, [\\"\\", \\"\\"]) 0","solution":"def longest_subset_subsequence_length(n, sequences): Returns the length of the longest subset subsequence that can be found in all given sequences. from collections import Counter if n == 1: return len(sequences[0]) min_freq_dict = Counter(sequences[0]) for seq in sequences[1:]: current_freq_dict = Counter(seq) for char in min_freq_dict.keys(): min_freq_dict[char] = min(min_freq_dict[char], current_freq_dict.get(char, 0)) result_length = 0 for count in min_freq_dict.values(): result_length += count return result_length"},{"question":"def kruskal_mst(districts: int, rail_lines: List[Tuple[int, int, int]]) -> int: Find the total travel time of the minimum spanning tree of a city. The city consists of distinct districts connected by rail lines with given travel times. Args: districts (int): Number of districts in the city. rail_lines (List[Tuple[int, int, int]]): Each tuple contains two districts and the travel time between them. Returns: int: Total travel time of the minimum spanning tree. Example: >>> kruskal_mst(4, [(1, 2, 10), (2, 3, 15), (3, 4, 4), (4, 1, 6), (1, 3, 5)]) 19 >>> kruskal_mst(3, [(1, 2, 5), (2, 3, 4), (1, 3, 3)]) 7 >>> kruskal_mst(5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 2), (2, 4, 2), (3, 5, 2)]) 4 # Unit tests def test_kruskal_mst(): districts = 4 rail_lines = [ (1, 2, 10), (2, 3, 15), (3, 4, 4), (4, 1, 6), (1, 3, 5) ] assert kruskal_mst(districts, rail_lines) == 19 def test_example_2(): districts = 3 rail_lines = [ (1, 2, 5), (2, 3, 4), (1, 3, 3) ] assert kruskal_mst(districts, rail_lines) == 7 def test_large_case(): districts = 5 rail_lines = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 2), (2, 4, 2), (3, 5, 2) ] assert kruskal_mst(districts, rail_lines) == 4","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(districts, rail_lines): rail_lines.sort(key=lambda x: x[2]) # Sort edges based on weight parent = [] rank = [] for i in range(districts): parent.append(i) rank.append(0) mst_total_weight = 0 mst_edges = 0 for u, v, w in rail_lines: root_u = find(parent, u - 1) root_v = find(parent, v - 1) if root_u != root_v: mst_total_weight += w mst_edges += 1 union(parent, rank, root_u, root_v) if mst_edges == districts - 1: break return mst_total_weight # Function to read input and output the result def calculate_minimum_spanning_tree(): import sys input = sys.stdin.read data = input().split() D = int(data[0]) R = int(data[1]) rail_lines = [] index = 2 for i in range(R): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) rail_lines.append((u, v, w)) index += 3 result = kruskal_mst(D, rail_lines) print(result)"},{"question":"def removeDigit(num: str) -> str: Given a string containing digits from \\"0\\" to \\"9\\", generate the smallest possible integer number (in string format) by removing exactly one digit from the input string. >>> removeDigit(\\"1524\\") \\"124\\" >>> removeDigit(\\"1005\\") \\"005\\" >>> removeDigit(\\"1111\\") \\"111\\" >>> removeDigit(\\"54321\\") \\"4321\\" >>> removeDigit(\\"1234\\") \\"123\\" >>> removeDigit(\\"1030\\") \\"030\\" >>> removeDigit(\\"1203\\") \\"103\\"","solution":"def removeDigit(num): Given a string containing digits from \\"0\\" to \\"9\\", generate the smallest possible integer number (in string format) by removing exactly one digit from the input string. for i in range(len(num) - 1): if num[i] > num[i + 1]: return num[:i] + num[i + 1:] return num[:-1]"},{"question":"def contains_duplicates(nums: List[int]) -> bool: Determines if a given list of integers contains duplicates. Returns \`True\` if there are duplicate values in the list and \`False\` otherwise. Examples: >>> contains_duplicates([1, 2, 3, 4, 5]) == False >>> contains_duplicates([1, 2, 3, 4, 5, 1]) == True >>> contains_duplicates([]) == False >>> contains_duplicates([0, 0, 0, 0, 0, 0]) == True","solution":"def contains_duplicates(nums): Returns True if there are duplicate values in the list and False otherwise. return len(nums) != len(set(nums))"},{"question":"def trap(height): Returns the total amount of rainwater that can be trapped. Args: height: List[int] - A list of non-negative integers representing the amount of rainwater trapped on different days. Returns: int - The total amount of rainwater that can be trapped. Examples: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 def test_trap(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap([4, 2, 0, 3, 2, 5]) == 9 assert trap([3, 0, 0, 2, 0, 4]) == 10 assert trap([1, 2, 3, 4, 5]) == 0 assert trap([5, 4, 3, 2, 1]) == 0 assert trap([]) == 0 assert trap([1]) == 0 assert trap([1, 0, 1]) == 1","solution":"def trap(height): Returns the total amount of rainwater that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the total water trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - height[i] return total_water"},{"question":"from collections import defaultdict, deque def tree_diameter(n, edges): Write a program which reads an undirected tree T = (V, E), and finds the diameter of the tree. The diameter of a tree is defined as the longest path between any two vertices. Constraints: 1 ≤ n ≤ 100 Input: In the first line, an integer n denoting the number of vertices, is given. In the next n-1 lines, pairs of vertices u and v representing an edge between vertex u and vertex v are given. Output: Print a single integer representing the diameter of the tree. Example: >>> tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> tree_diameter(4, [(1, 2), (1, 3), (1, 4)]) 2 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) edges = [] for i in range(1, len(data), 2): u = int(data[i]) v = int(data[i + 1]) edges.append((u, v)) print(tree_diameter(n, edges))","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): def bfs(start): dist = [-1] * (n + 1) dist[start] = 0 q = deque([start]) farthest_node = start max_dist = 0 while q: node = q.popleft() for neighbor in graph[node]: if dist[neighbor] == -1: dist[neighbor] = dist[node] + 1 q.append(neighbor) if dist[neighbor] > max_dist: max_dist = dist[neighbor] farthest_node = neighbor return farthest_node, max_dist # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) start = 1 farthest_node_from_start, _ = bfs(start) _, diameter = bfs(farthest_node_from_start) return diameter # Function to handle input and output def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) edges = [] for i in range(1, len(data), 2): u = int(data[i]) v = int(data[i + 1]) edges.append((u, v)) print(tree_diameter(n, edges))"},{"question":"def minimum_effort_to_cut_trees(n: int, heights: List[int]) -> int: Returns the minimum total effort required to ensure no height repeats more than once in the array. Args: n: An integer representing the number of trees. heights: A list of integers representing the heights of the trees. Returns: An integer representing the minimum total effort required. Example: >>> minimum_effort_to_cut_trees(6, [1, 2, 2, 3, 4, 4]) == 6 >>> minimum_effort_to_cut_trees(1, [5]) == 0 >>> minimum_effort_to_cut_trees(5, [1, 2, 3, 4, 5]) == 0 >>> minimum_effort_to_cut_trees(4, [3, 3, 3, 3]) == 9 >>> minimum_effort_to_cut_trees(6, [1, 1, 2, 2, 3, 3]) == 6 >>> minimum_effort_to_cut_trees(3, [10**9, 10**9, 10**9]) == 2*(10**9) >>> minimum_effort_to_cut_trees(5, [1, 2, 3, 1, 5]) == 1","solution":"def minimum_effort_to_cut_trees(n, heights): Returns the minimum total effort required to ensure no height repeats more than once in the array. from collections import Counter height_counts = Counter(heights) effort = 0 for height, count in height_counts.items(): if count > 1: effort += (count - 1) * height return effort"},{"question":"import math from typing import List def sumOfFactorialDigits(n: int) -> int: Returns the sum of all the digits of n factorial. Args: n (int): The input number. Returns: int: The sum of the digits of n factorial. Examples: >>> sumOfFactorialDigits(5) 3 >>> sumOfFactorialDigits(10) 27 >>> sumOfFactorialDigits(15) 45 >>> sumOfFactorialDigits(20) 54 >>> sumOfFactorialDigits(50) 216 >>> sumOfFactorialDigits(100) 648","solution":"import math def sumOfFactorialDigits(n): Returns the sum of all the digits of n factorial. factorial = math.factorial(n) return sum(int(digit) for digit in str(factorial))"},{"question":"def count_operations_to_turn_off_bulbs(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Find the minimum number of operations needed to make all the bulbs turn off in a given number of test cases. >>> count_operations_to_turn_off_bulbs(3, [(5, '11001'), (4, '0000'), (6, '101010')]) [2, 0, 3] >>> count_operations_to_turn_off_bulbs(1, [(4, '0000')]) [0]","solution":"def count_operations_to_turn_off_bulbs(t, test_cases): results = [] for case in test_cases: n, binary_string = case count = 0 i = 0 while i < n: if binary_string[i] == '1': while i < n and binary_string[i] == '1': i += 1 count += 1 i += 1 results.append(count) return results"},{"question":"def min_steps_to_reach_bottom_right(R: int, C: int, grid: List[str]) -> int: Returns the minimum number of steps to get from the top-left cell to the bottom-right cell of the grid. >>> min_steps_to_reach_bottom_right(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_steps_to_reach_bottom_right(2, 2, [\\"..\\", \\"..\\"]) 2","solution":"from collections import deque def min_steps_to_reach_bottom_right(R, C, grid): Returns the minimum number of steps to get from the top-left cell to the bottom-right cell of the grid. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0, 0)]) # (row, col, steps) visited = [[False] * C for _ in range(R)] visited[0][0] = True while queue: r, c, steps = queue.popleft() if r == R - 1 and c == C - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc] and grid[nr][nc] == '.': visited[nr][nc] = True queue.append((nr, nc, steps + 1)) return -1 # Should not reach here given the constraints if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() R, C = int(data[0]), int(data[1]) grid = [data[i + 2] for i in range(R)] print(min_steps_to_reach_bottom_right(R, C, grid))"},{"question":"from typing import List def smallest_c_balanced_subarray(n: int, c: int, arr: List[int]) -> int: Find the length of the smallest c-balanced subarray. A subarray is called c-balanced if the sum of its elements is equal to c. >>> smallest_c_balanced_subarray(5, 7, [1, 2, 3, 4, 5]) 2 >>> smallest_c_balanced_subarray(4, 10, [-1, 2, 4, 10, -2]) 1 >>> smallest_c_balanced_subarray(3, 100, [1, 2, 3]) -1","solution":"def smallest_c_balanced_subarray(n, c, arr): prefix_sum = {0: -1} current_sum = 0 min_length = float('inf') for i in range(n): current_sum += arr[i] if (current_sum - c) in prefix_sum: min_length = min(min_length, i - prefix_sum[current_sum - c]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return min_length if min_length != float('inf') else -1"},{"question":"from typing import List def longest_divisible_subarray(arr: List[int], k: int) -> int: Write a function that takes a list of integers and returns the length of the longest subarray which has a sum divisible by a given integer \`k\`. >>> longest_divisible_subarray([2, 7, 6, 1, 4, 5], 3) 4 >>> longest_divisible_subarray([5, 10, 15], 5) 3","solution":"from typing import List def longest_divisible_subarray(arr: List[int], k: int) -> int: prefix_sum = 0 remainder_map = {0: -1} max_length = 0 for i in range(len(arr)): prefix_sum += arr[i] remainder = prefix_sum % k if remainder < 0: remainder += k if remainder in remainder_map: subarray_length = i - remainder_map[remainder] max_length = max(max_length, subarray_length) else: remainder_map[remainder] = i return max_length"},{"question":"def buildings_with_sunlight(buildings): Returns the indices of buildings that can see the sunlight. Parameters: buildings (list of int): List of building heights Returns: list of int: Indices of buildings that can see the sunlight. >>> buildings_with_sunlight([3, 1, 4, 2, 5]) [1, 3, 5] >>> buildings_with_sunlight([2, 2, 2, 2, 2]) [1] >>> buildings_with_sunlight([5]) [1] >>> buildings_with_sunlight([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> buildings_with_sunlight([5, 4, 3, 2, 1]) [1] >>> buildings_with_sunlight([4, 1, 3, 2, 5, 3, 6]) [1, 5, 7] # your code here","solution":"def buildings_with_sunlight(buildings): Returns the indices of buildings that can see the sunlight. Parameters: buildings (list of int): List of building heights Returns: list of int: Indices of buildings that can see the sunlight result = [] max_height = 0 for i, height in enumerate(buildings): if height > max_height: result.append(i + 1) # since index starts from 1 max_height = height return result"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome considering only alphanumeric characters and ignoring cases.","solution":"import re def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome considering only alphanumeric characters and ignoring cases. # Use regex to extract only alphanumeric characters and convert to lowercase filtered_chars = re.findall(r'[a-zA-Z0-9]', s.lower()) # Check if the list of characters is the same forwards and backwards return filtered_chars == filtered_chars[::-1]"},{"question":"def all_students_passed(grades: List[List[int]]) -> bool: Given a list of lists containing student grades, return True if all students have an average score of at least 70. >>> all_students_passed([[80, 90, 100], [70, 60, 80], [90, 85, 95]]) True >>> all_students_passed([[80, 90, 100], [70, 60, 80], [65, 55, 45]]) False pass","solution":"def allStudentsPassed(grades): Given a list of lists containing student grades, returns True if all students have an average score of at least 70. for student_grades in grades: if sum(student_grades) / len(student_grades) < 70: return False return True"},{"question":"from typing import List, Tuple def barbarian_game(n: int, q: int, initial_values: List[int], rounds: List[List[int]]) -> List[int]: Tarzan is organizing a game with the barbarians. Implement a sequence of updates and range queries. Args: n (int): Number of barbarians. q (int): Number of rounds. initial_values (List[int]): Initial values assigned to each barbarian. rounds (List[List[int]]): List of rounds, where each round is either an update or a query. Returns: List[int]: Results of the query rounds. Examples: >>> barbarian_game(5, 3, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 3, 10], [2, 1, 3]]) [6, 13] pass def test_barbarian_game(): n = 5 q = 3 initial_values = [1, 2, 3, 4, 5] rounds = [ [2, 1, 3], [1, 3, 10], [2, 1, 3], ] expected_output = [6, 13] assert barbarian_game(n, q, initial_values, rounds) == expected_output def test_single_update_and_query_round(): n = 3 q = 2 initial_values = [5, 3, 10] rounds = [ [2, 2, 3], [1, 3, 5], ] expected_output = [13] assert barbarian_game(n, q, initial_values, rounds) == expected_output def test_only_queries(): n = 4 q = 2 initial_values = [7, 8, 5, 6] rounds = [ [2, 1, 2], [2, 3, 4], ] expected_output = [15, 11] assert barbarian_game(n, q, initial_values, rounds) == expected_output def test_edge_case_minimum_values(): n = 1 q = 1 initial_values = [9] rounds = [ [2, 1, 1], ] expected_output = [9] assert barbarian_game(n, q, initial_values, rounds) == expected_output def test_edge_case_all_updates(): n = 3 q = 2 initial_values = [4, 3, 2] rounds = [ [1, 1, 10], [1, 3, 5], ] expected_output = [] assert barbarian_game(n, q, initial_values, rounds) == expected_output","solution":"class BarbarianGame: def __init__(self, n, initial_values): self.n = n self.values = initial_values self.prefix_sum = [0] * (n + 1) self._build_prefix_sum() def _build_prefix_sum(self): for i in range(1, self.n + 1): self.prefix_sum[i] = self.prefix_sum[i - 1] + self.values[i - 1] def update(self, x, v): diff = v - self.values[x - 1] self.values[x - 1] = v for i in range(x, self.n + 1): self.prefix_sum[i] += diff def query(self, l, r): return self.prefix_sum[r] - self.prefix_sum[l - 1] def barbarian_game(n, q, initial_values, rounds): game = BarbarianGame(n, initial_values) result = [] for round in rounds: if round[0] == 1: _, x, v = round game.update(x, v) elif round[0] == 2: _, l, r = round result.append(game.query(l, r)) return result"},{"question":"def tournament(T: int, cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine the number of complete teams formed and the number of unpaired players. Parameters: T (int): Number of test cases cases (List[Tuple[int, int]]): List of tuples, each containing: - P (int): Total number of players - K (int): Team size Returns: List[Tuple[int, int]]: List of tuples with the number of complete teams and the number of unpaired players for each test case >>> tournament(3, [(10, 2), (15, 3), (8, 4)]) [(5, 0), (5, 0), (2, 0)] >>> tournament(1, [(12, 5)]) [(2, 2)] >>> tournament(2, [(100, 1), (100, 10)]) [(100, 0), (10, 0)] >>> tournament(2, [(50, 7), (22, 5)]) [(7, 1), (4, 2)] >>> tournament(3, [(8, 2), (9, 4), (11, 5)]) [(4, 0), (2, 1), (2, 1)]","solution":"def tournament(T, cases): Function to determine the number of complete teams formed and the number of unpaired players. Params: T (int): Number of test cases cases (list): List of tuples, each containing: - P (int): Total number of players - K (int): Team size Returns: list: List of tuples with the number of complete teams and the number of unpaired players for each test case results = [] for case in cases: P, K = case complete_teams = P // K unpaired_players = P % K results.append((complete_teams, unpaired_players)) return results"},{"question":"def process_test_cases(input_data): Given a number of test cases, for each test case find the maximum height in every subarray of fixed length L. The input_data is a single string containing multiple lines of text. >>> input_data = \\"2n6 3n1 3 5 2 8 7n5 2n4 2 7 3 1n\\" >>> process_test_cases(input_data) [\\"5 5 8 8\\", \\"4 7 7 3\\"] import pytest def test_process_test_cases(): input_data = \\"2n6 3n1 3 5 2 8 7n5 2n4 2 7 3 1n\\" expected_output = [\\"5 5 8 8\\", \\"4 7 7 3\\"] result = process_test_cases(input_data) assert result == expected_output def test_single_case(): input_data = \\"1n4 2n1 2 3 4n\\" expected_output = [\\"2 3 4\\"] result = process_test_cases(input_data) assert result == expected_output def test_full_window(): input_data = \\"1n4 4n2 1 4 3n\\" expected_output = [\\"4\\"] result = process_test_cases(input_data) assert result == expected_output def test_min_values(): input_data = \\"1n5 1n5 5 5 5 5n\\" expected_output = [\\"5 5 5 5 5\\"] result = process_test_cases(input_data) assert result == expected_output def test_decreasing_heights(): input_data = \\"1n6 3n6 5 4 3 2 1n\\" expected_output = [\\"6 5 4 3\\"] result = process_test_cases(input_data) assert result == expected_output def test_varied_heights(): input_data = \\"1n5 3n1 3 5 2 4n\\" expected_output = [\\"5 5 5\\"] result = process_test_cases(input_data) assert result == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque def max_heights_in_subarrays(test_cases): results = [] for case in test_cases: N, L, heights = case deq = deque() max_in_windows = [] for i in range(N): # Maintain the deque to have maximums at the front while deq and deq[0] < i - L + 1: deq.popleft() while deq and heights[deq[-1]] <= heights[i]: deq.pop() deq.append(i) # We start recording max values after the initial L elements if i >= L - 1: max_in_windows.append(heights[deq[0]]) results.append(\\" \\".join(map(str, max_in_windows))) return results def process_test_cases(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, L = map(int, lines[index].split()) heights = list(map(int, lines[index + 1].split())) test_cases.append((N, L, heights)) index += 2 return max_heights_in_subarrays(test_cases)"},{"question":"def largest_empty_square(N: int, M: int, grid: List[str]) -> int: Determine the size of the largest square sub-grid that contains only empty cells. >>> largest_empty_square(5, 6, [ ... \\"101001\\", ... \\"100000\\", ... \\"101011\\", ... \\"100001\\", ... \\"101110\\" ... ]) == 2 >>> largest_empty_square(3, 3, [ ... \\"111\\", ... \\"111\\", ... \\"111\\" ... ]) == 0 >>> largest_empty_square(3, 3, [ ... \\"000\\", ... \\"000\\", ... \\"000\\" ... ]) == 3 >>> largest_empty_square(3, 3, [ ... \\"010\\", ... \\"010\\", ... \\"010\\" ... ]) == 1 >>> largest_empty_square(1, 1, [ ... \\"0\\" ... ]) == 1 >>> largest_empty_square(1, 1, [ ... \\"1\\" ... ]) == 0 >>> largest_empty_square(3, 3, [ ... \\"101\\", ... \\"010\\", ... \\"101\\" ... ]) == 1","solution":"def largest_empty_square(N, M, grid): if N == 0 or M == 0: return 0 # Create a 2D dp array initialized to 0 dp = [[0] * M for _ in range(N)] max_side_length = 0 # Fill the dp array for i in range(N): for j in range(M): if grid[i][j] == '0': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"from typing import List def count_unique_packages(n: int, k: int, toy_labels: List[int]) -> int: Returns the number of unique packages Bogo can create from toy_labels with exactly k unique toys. >>> count_unique_packages(5, 3, [1, 2, 3, 4, 5]) 10 >>> count_unique_packages(4, 2, [1, 2, 2, 3]) 3 >>> count_unique_packages(6, 4, [1, 1, 1, 1, 1, 1]) 0 # Your code here","solution":"from itertools import combinations def count_unique_packages(n, k, toy_labels): Returns the number of unique packages Bogo can create from toy_labels with exactly k unique toys. # Get the unique toy labels unique_toys = set(toy_labels) # If there are fewer unique toys than k, it's impossible to create such a package if len(unique_toys) < k: return 0 # Calculate the number of combinations of unique toys taken k at a time unique_toys_combinations = list(combinations(unique_toys, k)) # Return the total number of unique combinations return len(unique_toys_combinations)"},{"question":"def number_of_distinct_cells(N: int) -> int: Returns the number of distinct cells Alice can reach after exactly N steps. >>> number_of_distinct_cells(1) 9 >>> number_of_distinct_cells(2) 25 >>> number_of_distinct_cells(3) 49","solution":"def number_of_distinct_cells(N): Returns the number of distinct cells Alice can reach after exactly N steps. # The pattern shows that after N steps, Alice can reach a square of side (2N + 1) side_length = 2 * N + 1 return side_length * side_length"},{"question":"def can_alice_jump(m, targets): Determine if Alice can land on all the targets exactly as given in the sequence. :param m: The fixed distance multiple for Alice's jumps :param targets: List of target positions on the number line :return: \\"YES\\" if Alice can land on all the targets, otherwise \\"NO\\" >>> can_alice_jump(2, [2, 4, 6]) \\"YES\\" >>> can_alice_jump(3, [3, 5, 9]) \\"NO\\" >>> can_alice_jump(5, [5, 10, 15, 20]) \\"YES\\" >>> can_alice_jump(4, [8]) \\"YES\\" >>> can_alice_jump(4, [7]) \\"NO\\" >>> can_alice_jump(1000000, [0, 1000000, 2000000]) \\"YES\\" >>> can_alice_jump(10, [0, 10, 1000000000]) \\"YES\\" >>> can_alice_jump(7, [7, 14, 21, 22]) \\"NO\\"","solution":"def can_alice_jump(m, targets): Determine if Alice can land on all the targets exactly as given in the sequence. :param m: The fixed distance multiple for Alice's jumps :param targets: List of target positions on the number line :return: \\"YES\\" if Alice can land on all the targets, otherwise \\"NO\\" for target in targets: if target % m != 0: return \\"NO\\" return \\"YES\\""},{"question":"def find_track_id(n, k, x): Find the ID of the track at position x after k updates. Parameters: n (int): Initial number of tracks k (int): Number of updates (hours) x (int): Position in the collection (1-indexed) Returns: int: Track ID at position x after k updates >>> find_track_id(5, 2, 1) 3 >>> find_track_id(6, 10, 3) 13 >>> find_track_id(4, 4, 2) 6 >>> find_track_id(1000000000, 1000000000, 1000000000) 2000000000 >>> find_track_id(1, 1000000000, 1) 1000000001 >>> find_track_id(1, 1, 1) 2 >>> find_track_id(2, 0, 1) 1 >>> find_track_id(10, 5, 5) 10 >>> find_track_id(5, 3, 1) 4","solution":"def find_track_id(n, k, x): Find the ID of the track at position x after k updates. Parameters: n (int): Initial number of tracks k (int): Number of updates (hours) x (int): Position in the collection (1-indexed) Returns: int: Track ID at position x after k updates return x + k"},{"question":"def max_segment_sum(arr): Returns the maximum possible sum of elements in a valid segment array. Args: arr (list): integer array, where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9 Returns: int: the maximum sum of elements of any valid segment array. Examples: >>> max_segment_sum([1, -2, 3, 4, -1]) 7 >>> max_segment_sum([-1, -2, -3]) -1 >>> max_segment_sum([2, 1, -2, 3]) 4","solution":"def max_segment_sum(arr): Returns the maximum possible sum of elements in a valid segment array. Args: arr (list): integer array, where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9 Returns: int: the maximum sum of elements of any valid segment array. current_max_sum = arr[0] max_sum = arr[0] for i in range(1, len(arr)): current_max_sum = max(arr[i], current_max_sum + arr[i]) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"def rank_students(N: int, M: int, activities: List[List[int]]) -> List[int]: Ranks students based on their total points from all activities. >>> rank_students(4, 3, [[1, 2, 3, 4], [2, 3, 4, 1], [4, 1, 2, 3]]) [2, 1, 4, 3] >>> rank_students(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) [1, 2, 3]","solution":"def rank_students(N, M, activities): Ranks students based on their total points from all activities. Parameters: N (int): Number of students M (int): Number of activities activities (list of lists): Rankings of students in each activity Returns: list: Ranks of students based on their total points points = [0] * N for activity in activities: for student_idx, rank in enumerate(activity): if rank == 1: points[student_idx] += 10 elif rank == 2: points[student_idx] += 5 elif rank == 3: points[student_idx] += 2 sorted_students = sorted(range(N), key=lambda x: -points[x]) ranks = [0] * N for idx, student_idx in enumerate(sorted_students): ranks[student_idx] = idx + 1 return ranks"},{"question":"def calculate_total_duration_and_overlaps(events: List[Tuple[str, int]]) -> Tuple[int, Union[str, List[Tuple[int, int]]]]: Determine the total duration of all sessions and the list of overlapping sessions, if any. - A session is defined by two events: a login and a logout event. - The duration of a session is the difference in time between the logout event and the login event. - Overlapping sessions are those sessions that have any time overlap with each other. Args: events: A list of tuples where each tuple contains a string \\"login\\" or \\"logout\\" and an integer timestamp. Returns: A tuple where the first element is an integer representing the total duration of all sessions, and the second element is either a string \\"no overlap\\" or a list of pairs of indices representing overlapping sessions. >>> calculate_total_duration_and_overlaps([(\\"login\\", 1), (\\"login\\", 3), (\\"logout\\", 5), (\\"logout\\", 6)]) (7, [(1, 2)]) >>> calculate_total_duration_and_overlaps([(\\"login\\", 1), (\\"logout\\", 2), (\\"login\\", 3), (\\"logout\\", 4)]) (2, \\"no overlap\\")","solution":"def calculate_total_duration_and_overlaps(events): sessions = [] stack = [] for i, (event, timestamp) in enumerate(events): if event == \\"login\\": stack.append((i, timestamp)) elif event == \\"logout\\" and stack: login_idx, login_time = stack.pop() sessions.append((login_time, timestamp, login_idx + 1)) if stack: raise ValueError(\\"Unmatched login events\\") # Calculate total duration total_duration = sum(logout - login for login, logout, _ in sessions) # Check for overlapping sessions overlaps = [] sessions.sort() # Sort by login time for i in range(len(sessions)): for j in range(i+1, len(sessions)): if sessions[i][1] > sessions[j][0]: # Logout time of i is greater than login time of j overlaps.append((sessions[i][2], sessions[j][2])) if not overlaps: overlaps = \\"no overlap\\" return total_duration, overlaps"},{"question":"def top_k_most_borrowed_books(records: List[Tuple[int, int, int]], k: int) -> List[Tuple[int, int]]: Determine the top k most borrowed books based on lending records. Args: records (List[Tuple[int, int, int]]): List of tuples containing book_id, borrow_time, and return_time. k (int): The number of top books to display. Returns: List[Tuple[int, int]]: List of tuples containing book_id and borrow count. Example: >>> records = [(101, 1, 5), (102, 2, -1), (101, 6, 10), (103, 3, 8), (102, 11, 15)] >>> k = 3 >>> top_k_most_borrowed_books(records, k) [(101, 2), (102, 2), (103, 1)]","solution":"def top_k_most_borrowed_books(records, k): from collections import defaultdict, Counter # Initialize counter for book borrow counts borrow_counts = Counter() # Count borrows for each book ID for record in records: book_id = record[0] borrow_counts[book_id] += 1 # Create a sorted list of tuples (borrow_count, book_id) sorted_books = sorted( [(count, book_id) for book_id, count in borrow_counts.items()], key=lambda x: (-x[0], x[1]) ) # Create result list of top k entries result = [(book_id, count) for count, book_id in sorted_books[:k]] return result"},{"question":"from typing import List def file_management_system(inputs: List[str]) -> List[str]: Maintains a history of file operations and allows querying the last modification time and if a file has been modified within a given time range. Args: inputs: List[str] - List of commands to be processed. Returns: List[str] - The results of the queries as specified in the prompt. Example: >>> file_management_system([ \\"create file1 1\\", \\"modify file1 3\\", \\"create file2 2\\", \\"modify file1 5\\", \\"modify file2 4\\", \\"last_modified file1\\", \\"last_modified file2\\", \\"last_modified file3\\", \\"modified_within file1 2 4\\", \\"modified_within file2 1 3\\", \\"#\\" ]) [5, 4, \\"File does not exist\\", \\"Yes\\", \\"No\\"] def test_file_management_system(): inputs = [ \\"create file1 1\\", \\"modify file1 3\\", \\"create file2 2\\", \\"modify file1 5\\", \\"modify file2 4\\", \\"last_modified file1\\", \\"last_modified file2\\", \\"last_modified file3\\", \\"modified_within file1 2 4\\", \\"modified_within file2 1 3\\", \\"#\\" ] expected_output = [ 5, 4, \\"File does not exist\\", \\"Yes\\", \\"No\\" ] assert file_management_system(inputs) == expected_output def test_file_with_no_modifications(): inputs = [ \\"create file1 1\\", \\"last_modified file1\\", \\"modified_within file1 0 2\\", \\"#\\" ] expected_output = [ \\"File does not exist\\", \\"No\\" ] assert file_management_system(inputs) == expected_output def test_multiple_files(): inputs = [ \\"create file1 1\\", \\"modify file1 3\\", \\"create file2 2\\", \\"modify file2 4\\", \\"last_modified file1\\", \\"last_modified file2\\", \\"modified_within file1 1 3\\", \\"modified_within file2 3 4\\", \\"#\\" ] expected_output = [ 3, 4, \\"Yes\\", \\"Yes\\" ] assert file_management_system(inputs) == expected_output def test_no_files(): inputs = [ \\"last_modified file1\\", \\"modified_within file1 0 2\\", \\"#\\" ] expected_output = [ \\"File does not exist\\", \\"No\\" ] assert file_management_system(inputs) == expected_output","solution":"def file_management_system(inputs): file_logs = {} def process_command(command): parts = command.split() if parts[0] in [\\"create\\", \\"modify\\"]: action = parts[0] file_name = parts[1] timestamp = int(parts[2]) if file_name not in file_logs: file_logs[file_name] = [] file_logs[file_name].append((action, timestamp)) elif parts[0] == \\"last_modified\\": file_name = parts[1] if file_name not in file_logs: results.append(\\"File does not exist\\") else: last_mod_time = max([log[1] for log in file_logs[file_name] if log[0] == \\"modify\\"], default=\\"File does not exist\\") results.append(last_mod_time) elif parts[0] == \\"modified_within\\": file_name = parts[1] start = int(parts[2]) end = int(parts[3]) if file_name not in file_logs: results.append(\\"No\\") else: modified_within_range = any(start <= log[1] <= end and log[0] == \\"modify\\" for log in file_logs[file_name]) results.append(\\"Yes\\" if modified_within_range else \\"No\\") results = [] for line in inputs: if line.strip() == \\"#\\": break process_command(line.strip()) return results"},{"question":"def has_two_sum(A, k): Determines if there are two distinct indices i and j in the array A such that A[i] + A[j] = k. Args: A (List[int]): The array of integers. k (int): The target integer. Returns: bool: True if such indices exist, False otherwise. Examples: >>> has_two_sum([1, 2, 3, 4, 5], 7) True >>> has_two_sum([1, 2, 3, 4, 5], 10) False","solution":"def has_two_sum(A, k): Determines if there are two distinct indices i and j in the array A such that A[i] + A[j] = k. seen = set() for num in A: if (k - num) in seen: return True seen.add(num) return False"},{"question":"class SmartCookbook: def __init__(self): self.ingredients = {} def add_ingredient(self, name, quantity): Adds an ingredient with the specified quantity. If the ingredient already exists, update its quantity with the new value. def update_quantity(self, name, quantity): Updates the quantity of the specified ingredient by adding the provided quantity. If the ingredient does not exist, add it with the given quantity. def query_quantity(self, name): Returns the quantity of the specified ingredient. If the ingredient does not exist, return \\"ingredient_name does not exist\\". import pytest def test_add_ingredient(): cookbook = SmartCookbook() cookbook.add_ingredient(\\"sugar\\", 500) assert cookbook.query_quantity(\\"sugar\\") == 500 def test_update_quantity(): cookbook = SmartCookbook() cookbook.add_ingredient(\\"salt\\", 300) cookbook.update_quantity(\\"salt\\", 200) assert cookbook.query_quantity(\\"salt\\") == 500 def test_query_nonexistent_ingredient(): cookbook = SmartCookbook() assert cookbook.query_quantity(\\"flour\\") == \\"flour does not exist\\" def test_combined_operations(): cookbook = SmartCookbook() cookbook.add_ingredient(\\"sugar\\", 500) assert cookbook.query_quantity(\\"sugar\\") == 500 # After adding, sugar should be 500 cookbook.update_quantity(\\"salt\\", 300) assert cookbook.query_quantity(\\"salt\\") == 300 # Salt initially added with 300 assert cookbook.query_quantity(\\"flour\\") == \\"flour does not exist\\" # Flour doesn't exist cookbook.update_quantity(\\"sugar\\", 200) assert cookbook.query_quantity(\\"sugar\\") == 700 # Sugar should now be 700 after update def test_add_same_ingredient(): cookbook = SmartCookbook() cookbook.add_ingredient(\\"sugar\\", 500) cookbook.add_ingredient(\\"sugar\\", 600) assert cookbook.query_quantity(\\"sugar\\") == 600 # Should update to the last given quantity def test_update_nonexistent_ingredient(): cookbook = SmartCookbook() cookbook.update_quantity(\\"butter\\", 400) assert cookbook.query_quantity(\\"butter\\") == 400 if __name__ == \\"__main__\\": pytest.main()","solution":"class SmartCookbook: def __init__(self): self.ingredients = {} def add_ingredient(self, name, quantity): Adds an ingredient with the specified quantity. If the ingredient already exists, update its quantity with the new value. self.ingredients[name] = quantity def update_quantity(self, name, quantity): Updates the quantity of the specified ingredient by adding the provided quantity. If the ingredient does not exist, add it with the given quantity. if name in self.ingredients: self.ingredients[name] += quantity else: self.ingredients[name] = quantity def query_quantity(self, name): Returns the quantity of the specified ingredient. if name in self.ingredients: return self.ingredients[name] else: return f\\"{name} does not exist\\""},{"question":"def is_valid_gem_sequence(s): Determines if the sequence of collected gems is valid. Args: s (str): The sequence of collected gems as a string. Returns: str: \\"VALID\\" if the gem sequence is valid, \\"INVALID\\" otherwise. Examples: >>> is_valid_gem_sequence(\\"1122334\\") 'VALID' >>> is_valid_gem_sequence(\\"123124\\") 'INVALID' >>> is_valid_gem_sequence(\\"5\\") 'VALID' >>> is_valid_gem_sequence(\\"987654321\\") 'VALID' >>> is_valid_gem_sequence(\\"121212\\") 'INVALID'","solution":"def is_valid_gem_sequence(s): Determines if the sequence of collected gems is valid. Args: s (str): The sequence of collected gems as a string. Returns: str: \\"VALID\\" if the gem sequence is valid, \\"INVALID\\" otherwise. seen = set() current_char = '' for char in s: if char != current_char: if char in seen: return \\"INVALID\\" seen.add(char) current_char = char return \\"VALID\\""},{"question":"def shared_bill(bill): A group of friends wants to share a meal in a restaurant and then split the bill. Each person will order one or more items from the menu, and the cost of each item is known. If the total bill exceeds 100, they get a 10% discount on the entire bill. Calculate the amount each person has to pay after applying the discount, if applicable. The final amount for each person should be rounded to two decimal places. >>> shared_bill({ ... \\"Alice\\": [30.12, 20.45], ... \\"Bob\\": [25.60, 15.25], ... \\"Charlie\\": [50.00] ... }) {\\"Alice\\": 45.51, \\"Bob\\": 36.77, \\"Charlie\\": 45.00} >>> shared_bill({ ... \\"Alice\\": [35.12], ... \\"Bob\\": [65.99] ... }) {\\"Alice\\": 31.61, \\"Bob\\": 59.39} >>> shared_bill({ ... \\"Alice\\": [10.00], ... \\"Bob\\": [15.00], ... \\"Charlie\\": [20.00] ... }) {\\"Alice\\": 10.00, \\"Bob\\": 15.00, \\"Charlie\\": 20.00} pass def test_shared_bill_case1(): result = shared_bill({ \\"Alice\\": [30.12, 20.45], \\"Bob\\": [25.60, 15.25], \\"Charlie\\": [50.00] }) expected = {\\"Alice\\": 45.51, \\"Bob\\": 36.77, \\"Charlie\\": 45.00} assert result == expected def test_shared_bill_case2(): result = shared_bill({ \\"Alice\\": [35.12], \\"Bob\\": [65.99] }) expected = {\\"Alice\\": 31.61, \\"Bob\\": 59.39} assert result == expected def test_shared_bill_case3(): result = shared_bill({ \\"Alice\\": [10.00], \\"Bob\\": [15.00], \\"Charlie\\": [20.00] }) expected = {\\"Alice\\": 10.00, \\"Bob\\": 15.00, \\"Charlie\\": 20.00} assert result == expected def test_shared_bill_no_discount(): result = shared_bill({ \\"Alice\\": [10.00], \\"Bob\\": [20.00], \\"Charlie\\": [15.00], \\"David\\": [12.50] }) expected = {\\"Alice\\": 10.00, \\"Bob\\": 20.00, \\"Charlie\\": 15.00, \\"David\\": 12.50} assert result == expected def test_shared_bill_exactly_100(): result = shared_bill({ \\"Alice\\": [50.00], \\"Bob\\": [25.00], \\"Charlie\\": [25.00] }) expected = {\\"Alice\\": 50.00, \\"Bob\\": 25.00, \\"Charlie\\": 25.00} assert result == expected","solution":"def shared_bill(bill): Calculate the amount each person has to pay after applying the discount if applicable. total_amount = sum(sum(items) for items in bill.values()) discount = 0.0 if total_amount > 100: discount = total_amount * 0.10 discounted_total = total_amount - discount result = {} for person, items in bill.items(): person_total = sum(items) person_discounted_total = person_total - (person_total / total_amount) * discount result[person] = round(person_discounted_total, 2) return result"},{"question":"def skill_levels(T: int, test_cases: List[str]) -> List[str]: Determines the skill level of participants based on their scores. Parameters: T (int): Number of test cases. test_cases (list): A list containing T elements each being a string of space-separated integers (scores). Returns: list: A list of strings where each string represents the skill levels of corresponding scores. >>> skill_levels(3, [\\"23 47 50\\", \\"60 72 75\\", \\"89 91 100\\"]) [\\"Beginner Beginner Beginner\\", \\"Intermediate Intermediate Intermediate\\", \\"Advanced Advanced Advanced\\"] >>> skill_levels(2, [\\"0 50 51 75\\", \\"35 49 100\\"]) [\\"Beginner Beginner Intermediate Intermediate\\", \\"Beginner Beginner Advanced\\"]","solution":"def skill_levels(T, test_cases): Determines the skill level of participants based on their scores. Parameters: T (int): Number of test cases. test_cases (list): A list containing T elements each being a string of space-separated integers (scores). Returns: list: A list of strings where each string represents the skill levels of corresponding scores. skill_levels = [] for case in test_cases: scores = map(int, case.split()) level_line = [] for score in scores: if 0 <= score <= 50: level_line.append(\\"Beginner\\") elif 51 <= score <= 75: level_line.append(\\"Intermediate\\") elif 76 <= score <= 100: level_line.append(\\"Advanced\\") skill_levels.append(\\" \\".join(level_line)) return skill_levels"},{"question":"def is_palindrome(s): Determines whether the given string 's' is a palindrome by ignoring spaces, punctuation, and capitalization. Args: s (str): Input string to be checked if it is a palindrome. Returns: str: \\"YES\\" if the input string is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> is_palindrome(\\"No 'x' in Nixon\\") \\"YES\\" >>> is_palindrome(\\"random string\\") \\"NO\\" >>> is_palindrome(\\"\\") \\"YES\\" >>> is_palindrome(\\" \\") \\"YES\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"Able , was I saw! eLba\\") \\"YES\\" def process_input(lines): Processes multiple lines of input to determine if each line is a palindrome, excluding the line \\"END\\". Args: lines (list of str): List of input strings. Returns: list of str: List of \\"YES\\" or \\"NO\\" strings for each input line excluding \\"END\\". >>> process_input([\\"A man, a plan, a canal, Panama\\", \\"No 'x' in Nixon\\", \\"random string\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_input([\\"madam\\", \\"12321\\", \\"!@# % ^&*\\", \\"END\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_input([\\"END\\"]) []","solution":"def is_palindrome(s): Determines whether the given string 's' is a palindrome by ignoring spaces, punctuation, and capitalization. Args: s (str): Input string to be checked if it is a palindrome. Returns: str: \\"YES\\" if the input string is a palindrome, \\"NO\\" otherwise. filtered_chars = [char.lower() for char in s if char.isalnum()] return \\"YES\\" if filtered_chars == filtered_chars[::-1] else \\"NO\\" def process_input(lines): Processes multiple lines of input to determine if each line is a palindrome, excluding the line \\"END\\". Args: lines (list of str): List of input strings. Returns: list of str: List of \\"YES\\" or \\"NO\\" strings for each input line excluding \\"END\\". results = [] for line in lines: if line == \\"END\\": break results.append(is_palindrome(line)) return results"},{"question":"def max_problems_solved(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of problems a contestant can solve within the given total time. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing tuples. Each tuple contains: - A tuple with two integers (N, M) where N is the number of problems and M is the total available time. - A list of integers representing the time required to solve each problem. Returns: List[int]: A list containing the maximum number of problems that can be solved for each test case. Example: >>> max_problems_solved(2, [((5, 300), [100, 200, 150, 60, 50]), ((4, 120), [30, 50, 70, 40])]) [4, 3]","solution":"def max_problems_solved(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] problem_times = test_cases[i][1] problem_times.sort() total_time = 0 problem_count = 0 for time in problem_times: if total_time + time <= M: total_time += time problem_count += 1 else: break results.append(problem_count) return results"},{"question":"from typing import List def sort_books_by_thickness(thicknesses: List[int]) -> List[int]: Sorts the given list of book thicknesses in ascending order. :param thicknesses: List of integers where each integer represents the thickness of a book. :return: List of integers representing the sorted thicknesses of the books. >>> sort_books_by_thickness([3, 1, 2, 5, 4]) [1, 2, 3, 4, 5] >>> sort_books_by_thickness([10, 7, 2, 5, 1]) [1, 2, 5, 7, 10] pass","solution":"from typing import List def sort_books_by_thickness(thicknesses: List[int]) -> List[int]: Sorts the given list of book thicknesses in ascending order. :param thicknesses: List of integers where each integer represents the thickness of a book. :return: List of integers representing the sorted thicknesses of the books. return sorted(thicknesses)"},{"question":"def max_non_overlapping_appointments(appointments): Determines the maximum number of appointments that can be scheduled without overlap. >>> max_non_overlapping_appointments([(1, 3), (2, 5), (4, 6), (6, 7), (5, 9)]) 3 >>> max_non_overlapping_appointments([(1, 4), (2, 3), (3, 5)]) 2 >>> max_non_overlapping_appointments([(1, 3), (3, 4), (4, 5)]) 3 >>> max_non_overlapping_appointments([(0, 1)]) 1 >>> max_non_overlapping_appointments([(1, 2)] * 10) 1 >>> max_non_overlapping_appointments([(i, i + 1) for i in range(10000)]) 10000","solution":"def max_non_overlapping_appointments(appointments): Determines the maximum number of non-overlapping appointments. # Sort appointments by end time appointments.sort(key=lambda x: x[1]) last_end_time = -1 max_appointments = 0 for start, end in appointments: if start >= last_end_time: max_appointments += 1 last_end_time = end return max_appointments"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if a string can be rearranged and additional 'a' characters can be added to form a palindrome. Args: s (str): Input string consisting of lowercase English letters. Returns: bool: True if the string can be rearranged and/or added with 'a' to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aac\\") True","solution":"def can_form_palindrome(s): Determines if a string can be rearranged and additional 'a' characters can be added to form a palindrome. Args: s (str): Input string consisting of lowercase English letters. Returns: bool: True if the string can be rearranged and/or added with 'a' to form a palindrome, False otherwise. from collections import Counter freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency. return odd_count <= 1"},{"question":"def joyify_string(s: str) -> str: Replaces occurrences of 'happy' with 'joyful', 'sad' with 'melancholy', and 'excited' with 'thrilled' in the given string. >>> joyify_string(\\"I am very happy and excited today.\\") == \\"I am very joyful and thrilled today.\\" >>> joyify_string(\\"He feels sad when he is not happy.\\") == \\"He feels melancholy when he is not joyful.\\" >>> joyify_string(\\"She was excited to be happy but later felt sad.\\") == \\"She was thrilled to be joyful but later felt melancholy.\\" >>> joyify_string(\\"The sad clown was once very happy.\\") == \\"The melancholy clown was once very joyful.\\" >>> joyify_string(\\"Running makes me excited.\\") == \\"Running makes me thrilled.\\" >>> joyify_string(\\"There is nothing to replace here.\\") == \\"There is nothing to replace here.\\" >>> joyify_string(\\"Regular text with no emotional words.\\") == \\"Regular text with no emotional words.\\" >>> joyify_string(\\"\\") == \\"\\"","solution":"def joyify_string(s): Replaces occurrences of 'happy' with 'joyful', 'sad' with 'melancholy', and 'excited' with 'thrilled' in the given string. Parameters: s (str): Input string to be modified. Returns: str: Modified string with specific words replaced. s = s.replace(\\"happy\\", \\"joyful\\") s = s.replace(\\"sad\\", \\"melancholy\\") s = s.replace(\\"excited\\", \\"thrilled\\") return s"},{"question":"class Scoreboard: The Scoreboard class initializes with an array of scores and efficiently processes multiple range sum queries. >>> sb = Scoreboard([1, 2, 3, 4, 5]) >>> sb.range_sum(0, 2) 6 >>> sb.range_sum(1, 3) 9 >>> sb.range_sum(0, 4) 15 def __init__(self, scores): pass def _compute_prefix_sums(self, scores): pass def range_sum(self, start, end): pass def test_initialization(): scores = [1, 2, 3, 4, 5] sb = Scoreboard(scores) assert sb.scores == scores def test_compute_prefix_sums(): scores = [1, 2, 3, 4, 5] sb = Scoreboard(scores) expected_prefix_sums = [0, 1, 3, 6, 10, 15] assert sb.prefix_sums == expected_prefix_sums def test_single_query(): scores = [1, 2, 3, 4, 5] sb = Scoreboard(scores) assert sb.range_sum(0, 2) == 6 def test_multiple_queries(): scores = [1, 2, 3, 4, 5] sb = Scoreboard(scores) assert sb.range_sum(1, 3) == 9 assert sb.range_sum(0, 4) == 15 def test_edge_cases(): scores = [4, 2, 7, 8, 6] sb = Scoreboard(scores) assert sb.range_sum(0, 0) == 4 assert sb.range_sum(4, 4) == 6 assert sb.range_sum(0, 4) == 27 def test_large_range(): scores = list(range(1, 1001)) # [1, 2, 3, ..., 1000] sb = Scoreboard(scores) assert sb.range_sum(0, 999) == 500500 # sum of first 1000 natural numbers","solution":"class Scoreboard: def __init__(self, scores): self.scores = scores self.prefix_sums = self._compute_prefix_sums(scores) def _compute_prefix_sums(self, scores): prefix_sums = [0] * (len(scores) + 1) for i in range(len(scores)): prefix_sums[i + 1] = prefix_sums[i] + scores[i] return prefix_sums def range_sum(self, start, end): return self.prefix_sums[end + 1] - self.prefix_sums[start] # Example usage # N = 5 # scores = [1, 2, 3, 4, 5] # Q = 3 # queries = [(0, 2), (1, 3), (0, 4)] # Initialization # scoreboard = Scoreboard(scores) # Query results # results = [] # for query in queries: # result = scoreboard.range_sum(query[0], query[1]) # results.append(result) # results should be [6, 9, 15]"},{"question":"def can_connect_villages_within_budget(N: int, M: int, Budget: int, roads: List[Tuple[int, int, int]]) -> str: Determines whether it is possible to interconnect all villages within the given budget. Args: N (int): The number of villages. M (int): The number of roads. Budget (int): The maximum allowable total length for the roads. roads (List[Tuple[int, int, int]]): List of tuples representing a road between villages u and v with length l(u, v). Returns: str: \\"YES\\" if it is possible to interconnect all villages within the given budget, otherwise \\"NO\\". Example: >>> can_connect_villages_within_budget(5, 7, 15, [(1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 2), (3, 4, 5), (3, 5, 6), (4, 5, 1)]) 'YES' >>> can_connect_villages_within_budget(3, 3, 2, [(1, 2, 1), (2, 3, 2), (1, 3, 2)]) 'NO' pass import pytest def test_sample_case(): N = 5 M = 7 Budget = 15 roads = [ (1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 2), (3, 4, 5), (3, 5, 6), (4, 5, 1) ] assert can_connect_villages_within_budget(N, M, Budget, roads) == \\"YES\\" def test_case_not_possible(): N = 3 M = 3 Budget = 2 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 2) ] assert can_connect_villages_within_budget(N, M, Budget, roads) == \\"NO\\" def test_case_exact_budget(): N = 4 M = 5 Budget = 6 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 2), (3, 4, 2) ] assert can_connect_villages_within_budget(N, M, Budget, roads) == \\"YES\\" def test_case_large_budget(): N = 6 M = 9 Budget = 1000 roads = [ (1, 2, 10), (1, 3, 15), (2, 4, 12), (3, 5, 10), (4, 6, 5), (5, 6, 20), (2, 5, 10), (3, 4, 30), (1, 6, 25) ] assert can_connect_villages_within_budget(N, M, Budget, roads) == \\"YES\\" def test_case_single_road(): N = 2 M = 1 Budget = 5 roads = [ (1, 2, 4) ] assert can_connect_villages_within_budget(N, M, Budget, roads) == \\"YES\\" if __name__ == \\"__main__\\": pytest.main()","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def can_connect_villages_within_budget(N, M, Budget, roads): edges = sorted(roads, key=lambda x: x[2]) ds = DisjointSet(N) total_length = 0 for u, v, length in edges: if ds.find(u - 1) != ds.find(v - 1): ds.union(u - 1, v - 1) total_length += length if total_length > Budget: return \\"NO\\" return \\"YES\\" if total_length <= Budget else \\"NO\\""},{"question":"def dijkstra(n, m, s, edges): Finds the single-source shortest paths from node s to all other nodes using Dijkstra's algorithm. Parameters: n (int): number of nodes m (int): number of edges s (int): starting node index edges (list of tuples): list of edges where each edge is represented by a tuple (u, v, w) Returns: list: distances from node s to all other nodes (0-indexed with INF for unreachable nodes) >>> dijkstra(5, 6, 1, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 10), (4, 5, 3)]) [0, 2, 3, 10, 13] >>> dijkstra(4, 3, 1, [(1, 2, 2), (2, 3, 3), (3, 4, 4)]) [0, 2, 5, 9] >>> dijkstra(1, 0, 1, []) [0] >>> dijkstra(1000, 1, 1, [(1, 1000, 1)]) [0, 'INF', 'INF', ... , 1] >>> dijkstra(4, 0, 1, []) [0, 'INF', 'INF', 'INF']","solution":"import heapq def dijkstra(n, m, s, edges): Finds the single-source shortest paths from node s to all other nodes using Dijkstra's algorithm. Parameters: n (int): number of nodes m (int): number of edges s (int): starting node index edges (list of tuples): list of edges where each edge is represented by a tuple (u, v, w) Returns: list: distances from node s to all other nodes (0-indexed with INF for unreachable nodes) graph = [[] for _ in range(n)] for u, v, w in edges: graph[u-1].append((w, v-1)) distances = [float('inf')] * n distances[s-1] = 0 priority_queue = [(0, s-1)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for weight, neighbor in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return ['INF' if dist == float('inf') else dist for dist in distances]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_tree_balanced_from_level_order(level_order: str) -> bool: Determines whether a given binary tree represented in level-order format is balanced. A binary tree is balanced if, for every node, the height of its left and right subtrees differ by at most one. >>> is_tree_balanced_from_level_order(\\"1 2 3 4 5 # #\\") True >>> is_tree_balanced_from_level_order(\\"1 2 3 4 # # 5 6\\") False >>> is_tree_balanced_from_level_order(\\"1\\") True >>> is_tree_balanced_from_level_order(\\"#\\") True >>> is_tree_balanced_from_level_order(\\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\\") True >>> is_tree_balanced_from_level_order(\\"1 2 3 4 # 6 7 # # # # 10 11 # # 12\\") False # Implementation goes here","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_balanced(root): def check(node): if node is None: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced height, balance = check(root) return balance def build_tree(level_order): if not level_order or level_order[0] == \\"#\\": return None it = iter(level_order) root = TreeNode(int(next(it))) queue = [root] try: while queue: node = queue.pop(0) left_val = next(it) if left_val != \\"#\\": node.left = TreeNode(int(left_val)) queue.append(node.left) right_val = next(it) if right_val != \\"#\\": node.right = TreeNode(int(right_val)) queue.append(node.right) except StopIteration: pass return root def is_tree_balanced_from_level_order(level_order): level_order = level_order.split() root = build_tree(level_order) return is_balanced(root)"},{"question":"def find_lowest_total_price(N: int, store1_prices: List[int], store2_prices: List[int]) -> int: This function finds the lowest possible total price for purchasing all the products. Parameters: - N (int): The number of products. - store1_prices (List[int]): A list of integers representing the prices of the products in the first store. - store2_prices (List[int]): A list of integers representing the prices of the products in the second store. Returns: - int: The lowest possible total price. >>> find_lowest_total_price(3, [10, 20, 30], [15, 25, 10]) 40 >>> find_lowest_total_price(4, [5, 8, 7, 3], [6, 4, 8, 6]) 19","solution":"def find_lowest_total_price(N, store1_prices, store2_prices): This function finds the lowest possible total price for purchasing all the products. Parameters: N (int): The number of products. store1_prices (list): A list of integers representing the prices of the products in the first store. store2_prices (list): A list of integers representing the prices of the products in the second store. Returns: int: The lowest possible total price. total_price = 0 for price1, price2 in zip(store1_prices, store2_prices): total_price += min(price1, price2) return total_price"},{"question":"def number_of_ways_to_select_pots(N: int, T: int, capacities: List[int]) -> int: Find the number of unique ways to select pots such that the total capacity is exactly T. >>> number_of_ways_to_select_pots(4, 5, [1, 2, 3, 4]) 2 >>> number_of_ways_to_select_pots(1, 3, [3]) 1 >>> number_of_ways_to_select_pots(1, 5, [3]) 0 >>> number_of_ways_to_select_pots(3, 11, [1, 2, 3]) 0 >>> number_of_ways_to_select_pots(5, 8, [1, 2, 3, 4, 5]) 3 >>> number_of_ways_to_select_pots(5, 10, [2, 3, 7, 8, 10]) 3","solution":"def number_of_ways_to_select_pots(N, T, capacities): def count_ways(index, target): if target == 0: return 1 if target < 0 or index == N: return 0 include = count_ways(index + 1, target - capacities[index]) exclude = count_ways(index + 1, target) return include + exclude return count_ways(0, T)"},{"question":"import numpy as np def reshape_and_transpose(lst, r, c): Converts a list of integers into a 2D numpy array with dimensions r and c if possible. If reshaping is not possible, outputs \\"Invalid\\". If reshaping is possible, it also transposes the reshaped array. >>> reshape_and_transpose([1, 2, 3, 4, 5, 6], 2, 3) [[1 2 3] [4 5 6]] [[1 4] [2 5] [3 6]] >>> reshape_and_transpose([1, 2, 3, 4, 5, 6, 7], 2, 4) Invalid","solution":"import numpy as np def reshape_and_transpose(lst, r, c): Converts a list of integers into a 2D numpy array with dimensions r and c if possible. If reshaping is not possible, outputs \\"Invalid\\". If reshaping is possible, it also transposes the reshaped array. if len(lst) == r * c: np_array = np.array(lst).reshape(r, c) print(np_array) print(np_array.T) else: print(\\"Invalid\\") # Example usage: # reshape_and_transpose([1, 2, 3, 4, 5, 6], 2, 3) # reshape_and_transpose([1, 2, 3, 4, 5, 6, 7], 2, 4)"},{"question":"def find_min_subarray_length(data_points: List[int], queries: List[int]) -> List[int]: Returns the length of the smallest contiguous subarray for each query such that its sum is greater than or equal to the given query sum. If no such subarray exists, returns -1. >>> find_min_subarray_length([1, 2, 3, 4, 5, 6, 7, 8], [15, 20, 5]) [2, 3, 1] >>> find_min_subarray_length([1, 1, 1, 1, 1], [5, 6]) [5, -1] >>> find_min_subarray_length([10, 20, 30, 40, 50], [60, 100, 200]) [2, 3, -1] >>> find_min_subarray_length([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 15, 25, 50]) [1, 3, 5, 10] >>> find_min_subarray_length([1], [1, 2]) [1, -1] >>> find_min_subarray_length([5, 1, 3, 5, 10, 7, 4, 9, 2, 8], [15, 35]) [2, 5]","solution":"def find_min_subarray_length(data_points, queries): Returns the length of the smallest contiguous subarray for each query such that its sum is greater than or equal to the given query sum. If no such subarray exists, returns -1. results = [] for s in queries: min_length = float('inf') left = 0 current_sum = 0 for right in range(len(data_points)): current_sum += data_points[right] while current_sum >= s: min_length = min(min_length, right - left + 1) current_sum -= data_points[left] left += 1 results.append(min_length if min_length != float('inf') else -1) return results"},{"question":"from typing import List, Tuple def is_zigzag(sequence: List[int]) -> bool: Determines if the given sequence is a valid Zig-Zag sequence. A Zig-Zag sequence is an array where each element is either strictly larger than or strictly smaller than both of its neighbors. >>> is_zigzag([1, 3, 2, 4, 3]) True >>> is_zigzag([10, 5, 15, 10, 20, 5]) True >>> is_zigzag([1, 2, 2, 1]) False pass def zigzag_sequence_detector(test_cases: List[Tuple[int, List[int]]]) -> List[str]: For each test case, determines if the sequence is a valid Zig-Zag sequence. Returns a list of \\"YES\\" or \\"NO\\" for each sequence. >>> zigzag_sequence_detector([(5, [1, 3, 2, 4, 3]), (6, [10, 5, 15, 10, 20, 5]), (4, [1, 2, 2, 1])]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def is_zigzag(sequence): Determines if the given sequence is a valid Zig-Zag sequence. A Zig-Zag sequence is an array where each element is either strictly larger than or strictly smaller than both of its neighbors. n = len(sequence) if n <= 1: return True for i in range(1, n - 1): if not ((sequence[i] > sequence[i-1] and sequence[i] > sequence[i+1]) or (sequence[i] < sequence[i-1] and sequence[i] < sequence[i+1])): return False return True def zigzag_sequence_detector(test_cases): results = [] for case in test_cases: N, sequence = case if is_zigzag(sequence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def encode_message(S: str, shifts: List[int]) -> str: Encode the message S by shifting each character according to the shift values in the shifts list. >>> encode_message('abcdef', [1, 2, 3, 4, 5, 6]) 'bdfhjl' >>> encode_message('xyz', [1, 1, 1]) 'yza' def process_test_cases(test_cases: List[Tuple[str, List[int]]]) -> List[str]: Process multiple test cases and return the encoded messages. >>> process_test_cases([('abcdef', [1, 2, 3, 4, 5, 6])]) ['bdfhjl'] >>> process_test_cases([('abcdef', [1, 2, 3, 4, 5, 6]), ('xyz', [1, 1, 1])]) ['bdfhjl', 'yza']","solution":"def encode_message(S, shifts): Encodes the message S by shifting each character according to the shift values in the shifts list. encoded_chars = [] for i, char in enumerate(S): new_char = chr((ord(char) - ord('a') + shifts[i]) % 26 + ord('a')) encoded_chars.append(new_char) return ''.join(encoded_chars) def process_test_cases(test_cases): results = [] for S, shifts in test_cases: results.append(encode_message(S, shifts)) return results"},{"question":"def unobstructed_views(test_cases): Given a list of integers representing heights of buildings, determine how many buildings have an unobstructed view of the sunset. A building has an unobstructed view of the sunset if there is no building to its right with a greater or equal height. >>> unobstructed_views([(5, [3, 7, 8, 3, 6]), (4, [4, 3, 2, 1]), (6, [1, 3, 2, 4, 5, 3])]) [2, 4, 2] pass def parse_input(input_data): Parse the input string to extract the number of test cases and the heights of buildings for each test case. >>> parse_input(\\"3n5n3 7 8 3 6n4n4 3 2 1n6n1 3 2 4 5 3\\") [(5, [3, 7, 8, 3, 6]), (4, [4, 3, 2, 1]), (6, [1, 3, 2, 4, 5, 3])] pass def main(input_data): Main function to read input data, process it and print results. test_cases = parse_input(input_data) results = unobstructed_views(test_cases) for result in results: print(result)","solution":"def unobstructed_views(test_cases): results = [] for case in test_cases: N, heights = case max_height = 0 count = 0 for height in reversed(heights): if height > max_height: count += 1 max_height = height results.append(count) return results def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) heights = list(map(int, lines[index + 1].split())) index += 2 test_cases.append((N, heights)) return test_cases def main(input_data): test_cases = parse_input(input_data) results = unobstructed_views(test_cases) for result in results: print(result)"},{"question":"def threeSum(nums): Given an array of integers \`nums\`, return all unique triplets \`[nums[i], nums[j], nums[k]]\` such that \`i, j, and k\` are different and \`nums[i] + nums[j] + nums[k] == 0\`. Note: The solution set must not contain duplicate triplets. >>> threeSum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> threeSum([]) [] >>> threeSum([0]) []","solution":"def threeSum(nums): Given an array nums, return all unique triplets in the array which gives the sum of zero. nums.sort() res = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: # Skip duplicate values for i continue left, right = i + 1, len(nums) - 1 while left < right: sum_ = nums[i] + nums[left] + nums[right] if sum_ == 0: res.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: # Skip duplicates for left left += 1 while left < right and nums[right] == nums[right - 1]: # Skip duplicates for right right -= 1 left += 1 right -= 1 elif sum_ < 0: left += 1 else: right -= 1 return res"},{"question":"def group_anagrams(filenames): Groups filenames that are anagrams of each other. Parameters: filenames (list of str): List of filenames. Returns: list of list of str: List of lists where each list contains filenames that are anagrams of each other. >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlists\\", \\"google\\", \\"inlets\\", \\"bananas\\"]) [['listen', 'silent', 'inlets'], ['enlists'], ['google'], ['bananas']] >>> group_anagrams([\\"a\\", \\"b\\", \\"c\\"]) [['a'], ['b'], ['c']] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [['abc', 'bca', 'cab']] >>> group_anagrams([\\"bat\\", \\"tab\\", \\"bats\\", \\"stab\\"]) [['bat', 'tab'], ['bats', 'stab']] >>> group_anagrams([\\"a\\", \\"a\\", \\"b\\", \\"b\\", \\"c\\"]) [['a', 'a'], ['b', 'b'], ['c']]","solution":"from collections import defaultdict def group_anagrams(filenames): Groups filenames that are anagrams of each other. Parameters: filenames (list of str): List of filenames. Returns: list of list of str: List of lists where each list contains filenames that are anagrams of each other. anagram_map = defaultdict(list) for filename in filenames: sorted_filename = ''.join(sorted(filename)) anagram_map[sorted_filename].append(filename) return list(anagram_map.values())"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Finds the length of the longest palindromic substring in the given string. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"ac\\") 1 >>> longest_palindromic_substring_length(\\"racecar\\") 7 >>> longest_palindromic_substring_length(\\"banana\\") 5 >>> longest_palindromic_substring_length(\\"abcd\\") 1 >>> longest_palindromic_substring_length(\\"abccba\\") 6 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"aaaa\\") 4","solution":"def longest_palindromic_substring_length(s: str) -> int: Finds the length of the longest palindromic substring in the given string. :param s: Input string consisting of lowercase English letters :return: Length of the longest palindromic substring if not s: return 0 n = len(s) # Table to store results of subproblems dp = [[False] * n for _ in range(n)] maxLength = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True maxLength = 2 # Check for lengths greater than 2 for k in range(3, n+1): # k is length of substring for i in range(n-k+1): j = i + k - 1 # Ending index of the current substring # Check if the current substring is palindrome if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True maxLength = k return maxLength"},{"question":"from typing import List def search(nums: List[int], target: int) -> int: This function searches for a target element in a rotated sorted array. If found, it returns the index of the target, otherwise it returns -1. Args: nums (List[int]): The rotated sorted array. target (int): The target element to search for. Returns: int: The index of the target element if found, otherwise -1. Example: >>> search([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search([4, 5, 6, 7, 0, 1, 2], 3) -1","solution":"from typing import List def search(nums: List[int], target: int) -> int: This function searches for a target element in a rotated sorted array. If found, it returns the index of the target, otherwise it returns -1. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # Determine which half is properly sorted if nums[left] <= nums[mid]: # Left half is sorted if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def find_anagrams(s: str, words: list) -> list: Given a string \`s\` and a list of strings \`words\`, returns the list of anagrams of \`s\` in \`words\`. >>> find_anagrams(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"silent\\"]) [\\"enlist\\", \\"inlets\\", \\"silent\\"] >>> find_anagrams(\\"Listen\\", [\\"Enlist\\", \\"Google\\", \\"Inlets\\", \\"Banana\\", \\"Silent\\"]) [\\"Enlist\\", \\"Inlets\\", \\"Silent\\"] >>> find_anagrams(\\"abc\\", [\\"def\\", \\"ghi\\", \\"jkl\\"]) [] >>> find_anagrams(\\"\\", [\\"\\", \\"a\\", \\"b\\"]) [\\"\\"] >>> find_anagrams(\\"abc\\", []) [] >>> find_anagrams(\\"abc\\", [\\"bca\\", \\"cab\\", \\"abc\\", \\"xyz\\"]) [\\"bca\\", \\"cab\\", \\"abc\\"]","solution":"def find_anagrams(s: str, words: list) -> list: Given a string \`s\` and a list of strings \`words\`, returns the list of anagrams of \`s\` in \`words\`. # Normalize the input string s and sort its characters sorted_s = sorted(s.lower()) anagrams = [] for word in words: if sorted(word.lower()) == sorted_s: anagrams.append(word) return anagrams"},{"question":"def max_subarray_sum(charm_amounts): Returns the maximum sum of charm in a single contiguous subarray. Args: charm_amounts (list of int) : List of charm amounts Returns: int : Maximum sum of charm in a contiguous subarray Examples: >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, 2, 3, -9]) 5 from solution import max_subarray_sum def test_single_element_array(): assert max_subarray_sum([5]) == 5 def test_all_positive_elements(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_array_with_negative_elements(): assert max_subarray_sum([-1, 2, 3, -9]) == 5 def test_mixed_elements(): assert max_subarray_sum([4, -1, 2, 1]) == 6 def test_array_with_all_negative_elements(): assert max_subarray_sum([-3, -1, -4, -2]) == -1 def test_large_input(): # Generating a large input of 100000 elements charm_amounts = [i for i in range(1, 100001)] assert max_subarray_sum(charm_amounts) == (100001 * 100000) // 2","solution":"def max_subarray_sum(charm_amounts): Returns the maximum sum of charm in a single contiguous subarray. Args: charm_amounts (list of int) : List of charm amounts Returns: int : Maximum sum of charm in a contiguous subarray max_sum = current_sum = charm_amounts[0] for charm in charm_amounts[1:]: current_sum = max(charm, current_sum + charm) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def rotateMatrix(matrix: List[List[int]]) -> List[List[int]]: Rotate a matrix 90 degrees clockwise. >>> rotateMatrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotateMatrix([[1]]) [[1]] >>> rotateMatrix([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> rotateMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotateMatrix([[1, 2, 3], [4, 5, 6]]) [[4, 1], [5, 2], [6, 3]]","solution":"from typing import List def rotateMatrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a matrix 90 degrees clockwise. return [list(reversed(col)) for col in zip(*matrix)]"},{"question":"def removeVowels(S: str) -> str: This function removes all vowels from the input string S and returns the resulting string. >>> removeVowels(\\"hello\\") \\"hll\\" >>> removeVowels(\\"programming\\") \\"prgrmmng\\" >>> removeVowels(\\"aeiou\\") \\"\\" >>> removeVowels(\\"bcdfg\\") \\"bcdfg\\" >>> removeVowels(\\"HELLO\\".lower()) \\"hll\\" >>> removeVowels(\\"\\") \\"\\"","solution":"def removeVowels(S): This function removes all vowels from the input string S and returns the resulting string. vowels = {'a', 'e', 'i', 'o', 'u'} result = [] for char in S: if char not in vowels: result.append(char) return ''.join(result)"},{"question":"class FileSystem: def __init__(self): Initialize the file system. pass def mkdir(self, path): Create a directory at the specified path. pass def touch(self, path, content): Create a file at the specified path with the given content. pass def ls(self, path): List all files and directories at the specified path. pass def cat(self, path): Read and return the content of the specified file. pass def write(self, path, content): Write new content to the specified file. pass def rm(self, path): Delete the specified file or directory. pass def process_commands(commands): Process a list of file system commands and return the output for ls and cat commands. >>> commands = [ ... \\"mkdir /home\\", ... \\"mkdir /home/user\\", ... \\"mkdir /home/user/docs\\", ... \\"touch /home/user/docs/file1 Hello\\", ... \\"ls /home/user\\", ... \\"cat /home/user/docs/file1\\", ... \\"write /home/user/docs/file1 World\\", ... \\"cat /home/user/docs/file1\\", ... \\"rm /home/user/docs\\", ... \\"ls /home/user\\" ...] >>> process_commands(commands) ['docs', 'Hello', 'World', '(empty)'] pass","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} def _get_dir(self, path): parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part: current = current[part] return current def mkdir(self, path): parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part not in current: current[part] = {} current = current[part] def touch(self, path, content): *dirs, file = path.strip('/').split('/') dir_path = '/' + '/'.join(dirs) dir_ref = self._get_dir(dir_path) dir_ref[file] = content def ls(self, path): dir_ref = self._get_dir(path) return sorted(dir_ref.keys()) def cat(self, path): *dirs, file = path.strip('/').split('/') dir_path = '/' + '/'.join(dirs) dir_ref = self._get_dir(dir_path) return dir_ref[file] def write(self, path, content): *dirs, file = path.strip('/').split('/') dir_path = '/' + '/'.join(dirs) dir_ref = self._get_dir(dir_path) dir_ref[file] = content def rm(self, path): *dirs, name = path.strip('/').split('/') dir_path = '/' + '/'.join(dirs) dir_ref = self._get_dir(dir_path) del dir_ref[name] def process_commands(commands): fs = FileSystem() output = [] for command in commands: parts = command.split(' ', 2) cmd, path = parts[0], parts[1] if cmd == 'mkdir': fs.mkdir(path) elif cmd == 'touch': content = parts[2] fs.touch(path, content) elif cmd == 'ls': result = fs.ls(path) output.append(' '.join(result) or '(empty)') elif cmd == 'cat': result = fs.cat(path) output.append(result) elif cmd == 'write': content = parts[2] fs.write(path, content) elif cmd == 'rm': fs.rm(path) return output"},{"question":"from typing import List def calendar_reminders(events: List[str], queries: List[str]) -> List[str]: This function accepts a list of calendar events and query times, and for each query, determines if there is any event happening at that exact time. Parameters: events (List[str]): A list of strings where each string is an event in the format \`HH:MM EventDescription\`. queries (List[str]): A list of strings where each string represents a query in the format \`HH:MM\`. Returns: List[str]: A list of strings containing event descriptions for corresponding query times or \\"No event\\" if no event is happening at that time. Examples: >>> calendar_reminders([\\"08:00 Breakfast\\", \\"12:00 Lunch\\", \\"18:30 Dinner\\"], [\\"08:00\\", \\"08:30\\", \\"12:00\\", \\"18:30\\", \\"19:00\\"]) ['Breakfast', 'No event', 'Lunch', 'Dinner', 'No event'] >>> calendar_reminders([\\"09:00 Meeting1\\", \\"09:00 Meeting2\\", \\"14:00 Conference\\"], [\\"09:00\\", \\"14:00\\", \\"15:00\\"]) ['Meeting2', 'Conference', 'No event'] pass def test_calendar_reminders(): events = [ \\"08:00 Breakfast\\", \\"12:00 Lunch\\", \\"18:30 Dinner\\" ] queries = [ \\"08:00\\", \\"08:30\\", \\"12:00\\", \\"18:30\\", \\"19:00\\" ] expected_output = [ \\"Breakfast\\", \\"No event\\", \\"Lunch\\", \\"Dinner\\", \\"No event\\" ] assert calendar_reminders(events, queries) == expected_output def test_calendar_reminders_with_multiple_same_time_events(): events = [ \\"09:00 Meeting1\\", \\"09:00 Meeting2\\", \\"14:00 Conference\\" ] queries = [ \\"09:00\\", \\"14:00\\", \\"15:00\\" ] expected_output = [ \\"Meeting2\\", # Only last occurrence of event at the same time will be considered \\"Conference\\", \\"No event\\" ] assert calendar_reminders(events, queries) == expected_output def test_calendar_reminders_all_no_events(): events = [ \\"10:00 EventA\\", \\"10:30 EventB\\", \\"11:00 EventC\\" ] queries = [ \\"12:00\\", \\"13:00\\", \\"14:00\\" ] expected_output = [ \\"No event\\", \\"No event\\", \\"No event\\" ] assert calendar_reminders(events, queries) == expected_output def test_calendar_reminders_empty_events(): events = [] queries = [ \\"10:00\\", \\"10:30\\", \\"11:00\\" ] expected_output = [ \\"No event\\", \\"No event\\", \\"No event\\" ] assert calendar_reminders(events, queries) == expected_output def test_calendar_reminders_empty_queries(): events = [ \\"09:00 Meeting1\\", \\"14:00 Conference\\" ] queries = [] expected_output = [] assert calendar_reminders(events, queries) == expected_output","solution":"from typing import List def calendar_reminders(events: List[str], queries: List[str]) -> List[str]: event_dict = {} # Build a dictionary for quick lookup of events by time for event in events: time, description = event.split(' ', 1) event_dict[time] = description # Find the event for each query time results = [] for query in queries: if query in event_dict: results.append(event_dict[query]) else: results.append(\\"No event\\") return results"},{"question":"def delivery_cost(route_distance, fuel_efficiency, max_distance, fuel_cost): Calculates the delivery cost for the route. Parameters: route_distance (float): Distance of the route in km. fuel_efficiency (float): Fuel efficiency of the truck in km per litre. max_distance (float): Maximum distance the truck can drive in a day in km. fuel_cost (float): Cost of fuel per litre in currency units. Returns: str or float: \\"impossible\\" if the route distance is greater than the max distance the truck can drive, otherwise the delivery cost rounded to 2 decimal places. >>> delivery_cost(800, 10, 500, 1.5) \\"impossible\\" >>> delivery_cost(200, 10, 500, 1.5) 30.00 pass import pytest def test_delivery_cost_impossible(): assert delivery_cost(800, 10, 500, 1.5) == \\"impossible\\" assert delivery_cost(300, 10, 200, 2.0) == \\"impossible\\" def test_delivery_cost_possible(): assert delivery_cost(200, 10, 500, 1.5) == 30.0 assert delivery_cost(300, 15, 400, 2.0) == 40.0 assert delivery_cost(100, 25, 300, 3.0) == 12.0 def test_delivery_cost_edge_cases(): assert delivery_cost(500, 10, 500, 2.5) == 125.0 assert delivery_cost(0, 10, 500, 3.0) == 0.0 assert delivery_cost(100, 20, 500, 5.50) == 27.5 assert delivery_cost(200, 20, 500, 2) == 20.0","solution":"def delivery_cost(route_distance, fuel_efficiency, max_distance, fuel_cost): Calculates the delivery cost for the route. Parameters: route_distance (float): Distance of the route in km. fuel_efficiency (float): Fuel efficiency of the truck in km per litre. max_distance (float): Maximum distance the truck can drive in a day in km. fuel_cost (float): Cost of fuel per litre in currency units. Returns: str or float: \\"impossible\\" if the route distance is greater than the max distance the truck can drive, otherwise the delivery cost rounded to 2 decimal places. if route_distance > max_distance: return \\"impossible\\" fuel_needed = route_distance / fuel_efficiency delivery_cost = fuel_needed * fuel_cost return round(delivery_cost, 2)"},{"question":"from typing import List def max_path_sum_in_grid(test_cases: List[List[List[int]]]) -> List[int]: Find the maximum sum of numbers collected along any path from the top-left corner to the bottom-right corner of a grid. The path is only allowed to move either to the right or down. Params: ------- test_cases: List of Grids representing test cases. Returns: -------- List of maximum sums for each test case. >>> max_path_sum_in_grid([ [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [1, 2], [1, 1] ] ]) [29, 4] pass def parse_input_string(input_string: str) -> List[List[List[int]]]: Parse the input string and convert it to a list of test case grids. Params: ------- input_string: String containing all inputs. Returns: -------- List of test case grids. >>> parse_input_string(\\"2n3n1 2 3n4 5 6n7 8 9n2n1 2n1 1\\") [ [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], [ [1, 2], [1, 1] ] ] pass def max_path_sum(input_string: str) -> None: Parse the input string, compute maximum path sums for each test case, and print the results. Params: ------- input_string: String containing all inputs. >>> max_path_sum(\\"2n3n1 2 3n4 5 6n7 8 9n2n1 2n1 1\\") \\"29n4n\\" pass","solution":"def max_path_sum_in_grid(test_cases): results = [] for grid in test_cases: n = len(grid) # Create a DP table to store the maximum sums dp = [[0] * n for _ in range(n)] # Initialize the top-left corner of the DP table dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will contain the result results.append(dp[n-1][n-1]) return results def parse_input_string(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) grid = [] for i in range(n): grid.append(list(map(int, input_lines[index + 1 + i].split()))) test_cases.append(grid) index += n + 1 return test_cases def max_path_sum(input_string): test_cases = parse_input_string(input_string) results = max_path_sum_in_grid(test_cases) for result in results: print(result)"},{"question":"def max_consecutive_difference(n: int, times: List[int]) -> int: Returns the maximum difference between the execution times of any two consecutive pieces of code. Parameters: n (int): Number of recorded execution times. times (list of int): List of execution times in milliseconds. Returns: int: Maximum consecutive difference in execution times. >>> max_consecutive_difference(5, [10, 20, 30, 50, 40]) == 20 >>> max_consecutive_difference(4, [5, 5, 5, 5]) == 0 >>> max_consecutive_difference(3, [100, 80, 60]) == 20 >>> max_consecutive_difference(3, [10, 20, 35]) == 15 >>> max_consecutive_difference(4, [999999, 1, 500000, 1000000]) == 999998 >>> max_consecutive_difference(2, [100, 200]) == 100 >>> max_consecutive_difference(5, [1, 1, 1, 1, 1000000]) == 999999 >>> max_consecutive_difference(4, [200, 100, 300, 500]) == 200","solution":"def max_consecutive_difference(n, times): Returns the maximum difference between the execution times of any two consecutive pieces of code. Parameters: n (int): Number of recorded execution times. times (list of int): List of execution times in milliseconds. Returns: int: Maximum consecutive difference in execution times. max_diff = 0 for i in range(1, n): diff = abs(times[i] - times[i - 1]) if diff > max_diff: max_diff = diff return max_diff"},{"question":"def relayRace(times): Determines the winning team and the time they took to complete the race. Parameters: times (list of list of int): A 2D array where times[i][j] represents the time taken by the j-th member of the i-th team to run their leg of the race. Returns: tuple: (index of the winning team, total time they took) pass # Test cases from solution import relayRace def test_relayRace_sample_input_0(): times = [ [10, 15, 20, 10], [12, 14, 18, 10], [11, 16, 17, 9] ] assert relayRace(times) == (2, 53) def test_relayRace_sample_input_1(): times = [ [20, 25, 30], [25, 20, 25] ] assert relayRace(times) == (1, 70) def test_relayRace_minimum_teams(): times = [ [1, 1, 1, 1], [1, 1, 1, 2] ] assert relayRace(times) == (0, 4) def test_relayRace_all_teams_tied(): times = [ [10, 10, 10], [10, 10, 10], [10, 10, 10] ] assert relayRace(times) == (0, 30) def test_relayRace_large_numbers(): times = [ [50, 50, 50], [40, 40, 40], [60, 1, 79], [30, 30, 30], ] assert relayRace(times) == (3, 90) def test_relayRace_single_member_teams(): times = [ [10], [5], [7] ] assert relayRace(times) == (1, 5)","solution":"def relayRace(times): Determines the winning team and the time they took to complete the race. Parameters: times (list of list of int): A 2D array where times[i][j] represents the time taken by the j-th member of the i-th team to run their leg of the race. Returns: tuple: (index of the winning team, total time they took) min_time = float('inf') winning_team = -1 for i in range(len(times)): total_time = sum(times[i]) if total_time < min_time: min_time = total_time winning_team = i return (winning_team, min_time)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Process a list of queries that either modify or query an array. Args: n (int): Number of elements in the array. q (int): Number of queries. array (List[int]): Initial array of integers. queries (List[List[int]]): List of queries to process. Returns: List[int]: Result of all type 2 queries (sum queries). Example: >>> process_queries(6, 4, [1, 2, 3, 4, 5, 6], [[1, 2, 4, 3], [2, 1, 3], [1, 1, 6, 2], [2, 3, 5]]) [12, 21] >>> process_queries(1, 2, [5], [[1, 1, 1, 3], [2, 1, 1]]) [8] >>> process_queries(5, 0, [1, 2, 3, 4, 5], []) [] >>> process_queries(3, 2, [1000000000, 1000000000, 1000000000], [[1, 1, 3, 1000000000], [2, 1, 3]]) [6000000000]","solution":"def process_queries(n, q, array, queries): # This function processes a list of queries and modifies/queries the array accordingly. results = [] for query in queries: if query[0] == 1: # Type 1 query: Add X to the subarray A[L]...A[R] L, R, X = query[1] - 1, query[2] - 1, query[3] for i in range(L, R + 1): array[i] += X elif query[0] == 2: # Type 2 query: Compute the sum of the subarray A[L]...A[R] L, R = query[1] - 1, query[2] - 1 results.append(sum(array[L:R + 1])) return results"},{"question":"def canFormPalindrome(s: str) -> str: Determines if the characters in the given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"POSSIBLE\\" if the string's characters can be rearranged to form a palindrome, otherwise \\"IMPOSSIBLE\\". >>> canFormPalindrome(\\"civic\\") 'POSSIBLE' >>> canFormPalindrome(\\"ivicc\\") 'POSSIBLE' >>> canFormPalindrome(\\"hello\\") 'IMPOSSIBLE'","solution":"def canFormPalindrome(s): Determines if the characters in the given string can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"POSSIBLE\\" if the string's characters can be rearranged to form a palindrome, otherwise \\"IMPOSSIBLE\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"IMPOSSIBLE\\" else: return \\"POSSIBLE\\""},{"question":"from typing import List def find_prime_palindromes(inputs: List[int]) -> List[int]: Function to find the smallest Prime Palindrome Number (PPN) which is greater than or equal to each number in the provided list of inputs. A Prime Palindrome Number (PPN) is a number that: 1. Is a prime number. 2. Is a palindrome. Args: inputs (List[int]): List of integers representing the test cases. Returns: List[int]: List of smallest PPNs for each input number. def is_prime(n: int) -> bool: Helper function to check if a number is prime. pass def is_palindrome(n: int) -> bool: Helper function to check if a number is a palindrome. pass def find_smallest_ppn_greater_equal(N: int) -> int: Finds the smallest PPN greater than or equal to N. pass # Collect results for each input outputs = [] for N in inputs: if N == 0: break outputs.append(find_smallest_ppn_greater_equal(N)) return outputs # Unit tests def test_sample_inputs(): inputs = [31, 45, 90, 0] expected_outputs = [101, 101, 101] assert find_prime_palindromes(inputs) == expected_outputs def test_single_inputs(): inputs = [4, 31, 45, 90] expected_outputs = [5, 101, 101, 101] assert find_prime_palindromes(inputs) == expected_outputs def test_prime_palindrome_close_to_input(): inputs = [11, 101, 131] expected_outputs = [11, 101, 131] assert find_prime_palindromes(inputs) == expected_outputs def test_large_numbers(): inputs = [9999, 1000000, 10000000, 0] expected_outputs = [10301, 1003001] assert find_prime_palindromes(inputs[:2]) == expected_outputs[:2] def test_zero_input(): inputs = [0] expected_outputs = [] assert find_prime_palindromes(inputs) == expected_outputs","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): Helper function to check if a number is a palindrome. return str(n) == str(n)[::-1] def find_smallest_ppn_greater_equal(N): Function to find the smallest Prime Palindrome Number (PPN) which is greater than or equal to a given number N. while True: if is_prime(N) and is_palindrome(N): return N N += 1 def find_prime_palindromes(inputs): Processes a list of inputs to find the smallest PPN greater than or equal to each number in the list. outputs = [] for N in inputs: if N == 0: break outputs.append(find_smallest_ppn_greater_equal(N)) return outputs"},{"question":"def countVowelsAndConsonants(S: str) -> dict: Takes a string S as input and returns a dictionary with the count of vowels and consonants in the string. >>> countVowelsAndConsonants(\\"HelloWorld\\") == {\\"vowels\\": 3, \\"consonants\\": 7} >>> countVowelsAndConsonants(\\"abcDEF123\\") == {\\"vowels\\": 2, \\"consonants\\": 4} from solution import countVowelsAndConsonants def test_all_vowels(): assert countVowelsAndConsonants(\\"AEIOUaeiou\\") == {\\"vowels\\": 10, \\"consonants\\": 0} def test_all_consonants(): assert countVowelsAndConsonants(\\"BCDFghjklMNPQRSTvwxyz\\") == {\\"vowels\\": 0, \\"consonants\\": 21} def test_mixed_characters(): assert countVowelsAndConsonants(\\"HelloWorld\\") == {\\"vowels\\": 3, \\"consonants\\": 7} def test_mixed_characters_with_numbers(): assert countVowelsAndConsonants(\\"abcDEF123\\") == {\\"vowels\\": 2, \\"consonants\\": 4} def test_empty_string(): assert countVowelsAndConsonants(\\"\\") == {\\"vowels\\": 0, \\"consonants\\": 0} def test_no_letters(): assert countVowelsAndConsonants(\\"1234567890\\") == {\\"vowels\\": 0, \\"consonants\\": 0} def test_only_vowels_uppercase(): assert countVowelsAndConsonants(\\"AEIOU\\") == {\\"vowels\\": 5, \\"consonants\\": 0} def test_only_vowels_lowercase(): assert countVowelsAndConsonants(\\"aeiou\\") == {\\"vowels\\": 5, \\"consonants\\": 0} def test_single_character_vowel(): assert countVowelsAndConsonants(\\"E\\") == {\\"vowels\\": 1, \\"consonants\\": 0} def test_single_character_consonant(): assert countVowelsAndConsonants(\\"G\\") == {\\"vowels\\": 0, \\"consonants\\": 1}","solution":"def countVowelsAndConsonants(S): Takes a string S as input and returns a dictionary with the count of vowels and consonants in the string. vowels = \\"aeiouAEIOU\\" vowel_count = 0 consonant_count = 0 for char in S: if char.isalpha(): if char in vowels: vowel_count += 1 else: consonant_count += 1 return {\\"vowels\\": vowel_count, \\"consonants\\": consonant_count}"},{"question":"def highest_number(s: str) -> int: Takes a single string of digits as input and returns the highest possible number that can be formed by rearranging those digits. If the input string is empty or contains non-digit characters, return 0. >>> highest_number('4231') 4321 >>> highest_number('102') 210 >>> highest_number('') 0 >>> highest_number('12a5') 0","solution":"def highest_number(s): Takes a single string of digits as input and returns the highest possible number that can be formed by rearranging those digits. If the input string is empty or contains non-digit characters, return 0. if not s.isdigit(): return 0 return int(''.join(sorted(s, reverse=True)))"},{"question":"from typing import List def trapped_water(heights: List[int]) -> int: Determine the amount of water that would be trapped between the towers when it rains. >>> trapped_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapped_water([4,2,0,3,2,5]) 9","solution":"from typing import List def trapped_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"def can_form_string(s: str, t: str) -> str: Check if you can form the string t by deleting some (possibly none) characters from the string s without rearranging the remaining characters. Args: s (str): The source string. t (str): The target string. Returns: str: \\"YES\\" if you can form the string t from s by deleting some characters, otherwise \\"NO\\". Examples: >>> can_form_string(\\"abcde\\", \\"ace\\") \\"YES\\" >>> can_form_string(\\"abc\\", \\"acb\\") \\"NO\\"","solution":"def can_form_string(s, t): Checks if we can form string t by deleting some characters from string s without rearranging the remaining characters. t_index = 0 t_length = len(t) for char in s: if t_index < t_length and char == t[t_index]: t_index += 1 if t_index == t_length: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List from collections import Counter def find_smallest_palindromic_permutation(s: str) -> str: Given a string, generate the lexicographically smallest permutation which is a valid palindrome. If no such permutation exists, return \\"-1\\". Args: s (str): The input string consisting of lowercase letters. Returns: str: The lexicographically smallest palindromic permutation, or \\"-1\\" if none exist. Examples: >>> find_smallest_palindromic_permutation(\\"aabb\\") \\"abba\\" >>> find_smallest_palindromic_permutation(\\"abc\\") \\"-1\\" >>> find_smallest_palindromic_permutation(\\"aaa\\") \\"aaa\\"","solution":"from collections import Counter def find_smallest_palindromic_permutation(s): count = Counter(s) # Check the number of characters with odd count odd_count = sum(1 for freq in count.values() if freq % 2 != 0) if odd_count > 1: return \\"-1\\" # Construct half of the palindrome half_palindrome = [] middle_char = '' for char, freq in sorted(count.items()): if freq % 2 != 0: middle_char = char half_palindrome.append(char * (freq // 2)) half_str = ''.join(half_palindrome) return half_str + middle_char + half_str[::-1]"},{"question":"def min_operations_to_sort_deck(T, test_cases): Calculate the minimum number of operations required to sort the deck of cards. Args: T: int : number of test cases test_cases: List[Tuple[int, List[int]]] : list of tuple containing number of cards and the initial order of cards for each test case Returns: List[int] : list of integers representing the minimum number of operations required for each test case Example: >>> min_operations_to_sort_deck(2, [(4, [4, 3, 2, 1]), (5, [3, 5, 1, 4, 2])]) [1, 2] >>> min_operations_to_sort_deck(1, [(5, [1, 2, 3, 4, 5])]) [0] from solution import min_operations_to_sort_deck def test_single_reverse(): assert min_operations_to_sort_deck(1, [(4, [4, 3, 2, 1])]) == [1] def test_multiple_reverses(): assert min_operations_to_sort_deck(1, [(5, [3, 5, 1, 4, 2])]) == [2] def test_already_sorted(): assert min_operations_to_sort_deck(1, [(5, [1, 2, 3, 4, 5])]) == [0] def test_single_element(): assert min_operations_to_sort_deck(1, [(1, [10])]) == [0] def test_mixed_cases(): assert min_operations_to_sort_deck(2, [(4, [4, 3, 2, 1]), (5, [3, 5, 1, 4, 2])]) == [1, 2]","solution":"def min_operations_to_sort_deck(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] cards = test_cases[i][1] if cards == sorted(cards): results.append(0) continue reverses_needed = 0 in_decreasing_order = False for j in range(1, N): if cards[j] < cards[j-1]: if not in_decreasing_order: reverses_needed += 1 in_decreasing_order = True else: in_decreasing_order = False results.append(reverses_needed) return results"},{"question":"def minDeletions(s: str) -> int: Returns the minimum number of deletions required so that the remaining string does not contain any consecutive repeated characters. >>> minDeletions(\\"aabbcc\\") 3 >>> minDeletions(\\"abccba\\") 1","solution":"def minDeletions(s): Returns the minimum number of deletions required so that the remaining string does not contain any consecutive repeated characters. deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"def minimum_urns(n: int, m: int, candies: List[int]) -> int: Returns the minimum number of urns to be emptied completely to buy m candies. >>> minimum_urns(4, 10, [3, 5, 2, 8]) 2 >>> minimum_urns(5, 12, [1, 2, 3, 4, 5]) 3","solution":"def minimum_urns(n, m, candies): Returns the minimum number of urns to be emptied completely to buy m candies. # Sort the number of candies in each urn in descending order candies.sort(reverse=True) count = 0 for c in candies: m -= c count += 1 if m <= 0: break return count"},{"question":"def move_robot(n, commands): Simulates the movement of a robot on a 2D plane based on given commands. Args: n (int): Number of commands. commands (str): A string consisting of the characters 'U', 'D', 'L', 'R'. Returns: tuple: The final coordinates of the robot as (x, y).","solution":"def move_robot(n, commands): Simulates the movement of a robot on a 2D plane based on given commands. Args: n (int): Number of commands. commands (str): A string consisting of the characters 'U', 'D', 'L', 'R'. Returns: tuple: The final coordinates of the robot as (x, y). x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y)"},{"question":"def minPathSum(grid: List[List[int]]) -> int: Compute the minimum path sum from the top left to the bottom right of a grid. Parameters: grid (list of list of int): The input 2D grid with non-negative integers. Returns: int: The minimum path sum from the top left to the bottom right corner. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12 from solution import minPathSum def test_example_case_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minPathSum(grid) == 7 def test_example_case_2(): grid = [ [1, 2, 3], [4, 5, 6] ] assert minPathSum(grid) == 12 def test_single_element_grid(): grid = [[5]] assert minPathSum(grid) == 5 def test_single_row_grid(): grid = [[1, 2, 3, 4]] assert minPathSum(grid) == 10 def test_single_column_grid(): grid = [ [1], [2], [3], [4] ] assert minPathSum(grid) == 10 def test_zero_cost_grid(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert minPathSum(grid) == 0 def test_large_grid(): grid = [ [1, 2, 5], [3, 2, 1], [4, 3, 2] ] assert minPathSum(grid) == 8","solution":"def minPathSum(grid): Compute the minimum path sum from top left to bottom right of a grid. Parameters: grid (list of list of int): The input 2D grid with non-negative integers. Returns: int: The minimum path sum from the top left to bottom right corner. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Compute the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def count_even_sum_pairs(N, A): Returns the count of distinct pairs (i, j) such that 1 ≤ i < j ≤ N and the sum of A[i] and A[j] is even. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(4, [2, 4, 6, 8]) 6 >>> count_even_sum_pairs(6, [1, 1, 1, 1, 1, 1]) 15 >>> count_even_sum_pairs(3, [1, 3, 5]) 3","solution":"def count_even_sum_pairs(N, A): Returns the count of distinct pairs (i, j) such that 1 ≤ i < j ≤ N and the sum of A[i] and A[j] is even. count_even = sum(1 for x in A if x % 2 == 0) count_odd = N - count_even # Number of ways to choose 2 even numbers or 2 odd numbers pairs = (count_even * (count_even - 1)) // 2 + (count_odd * (count_odd - 1)) // 2 return pairs"},{"question":"def shortest_palindrome_length(s: str) -> int: Given a string \`s\` consisting of lowercase letters, find the length of the shortest palindrome that can be made by adding characters to the end of \`s\`. >>> shortest_palindrome_length('abac') 5 >>> shortest_palindrome_length('abcd') 7 >>> shortest_palindrome_length('race') 7 >>> shortest_palindrome_length('level') 5 >>> shortest_palindrome_length('aa') 2 >>> shortest_palindrome_length('a') 1","solution":"def shortest_palindrome_length(s): Given a string \`s\`, this function returns the length of the shortest palindrome that can be made by adding characters to the end of \`s\`. if s == s[::-1]: return len(s) for i in range(len(s)-1, -1, -1): if s[:i+1] == s[:i+1][::-1]: return len(s) + (len(s) - (i+1)) return 2 * len(s) - 1"},{"question":"def find_longest_word(sentence): Returns the longest word in a given sentence. If there are multiple words with the same length, returns the first one that appears. >>> find_longest_word(\\"the quick brown fox\\") == \\"quick\\" >>> find_longest_word(\\"jumps over the lazy dog\\") == \\"jumps\\" >>> find_longest_word(\\"a quick movement of the enemy\\") == \\"movement\\" >>> find_longest_word(\\"hello world\\") == \\"hello\\" >>> find_longest_word(\\"longer longest long\\") == \\"longest\\" def longest_words(test_cases): Given a list of test cases, returns a list of longest words for each test case. >>> longest_words([ ... \\"the quick brown fox\\", ... \\"jumps over the lazy dog\\", ... \\"a quick movement of the enemy\\", ... \\"hello world\\", ... \\"longer longest long\\" ... ]) == [\\"quick\\", \\"jumps\\", \\"movement\\", \\"hello\\", \\"longest\\"]","solution":"def find_longest_word(sentence): Returns the longest word in a given sentence. If there are multiple words with the same length, returns the first one that appears. words = sentence.split() longest_word = \\"\\" for word in words: if len(word) > len(longest_word): longest_word = word return longest_word def longest_words(test_cases): Given a list of test cases, returns a list of longest words for each test case. results = [] for sentence in test_cases: results.append(find_longest_word(sentence)) return results"},{"question":"def total_matches(N: int) -> int: Returns the total number of matches played in a tournament where each player plays every other player exactly once. Parameters: N (int): the number of players Returns: int: the total number of matches >>> total_matches(4) 6 >>> total_matches(2) 1 >>> total_matches(100000) 4999950000 >>> total_matches(10) 45 >>> total_matches(50) 1225","solution":"def total_matches(N): Returns the total number of matches played in a tournament where each player plays every other player exactly once. Parameters: N (int): the number of players Returns: int: the total number of matches # Using the combination formula C(n, 2) = n * (n - 1) / 2 return (N * (N - 1)) // 2"},{"question":"def second_largest_unique_value(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Write a program to find the second largest unique value from given list of integers. If there is no such value, return -1. The function takes a list of test cases where each test case is a tuple consisting of an integer N (the number of elements in the list) and a list of N space-separated integers representing the elements of the list. >>> second_largest_unique_value([(5, [4, 2, 1, 3, 2])]) [3] >>> second_largest_unique_value([(4, [2, 2, 2, 2])]) [-1] >>> second_largest_unique_value([(6, [10, 7, 7, 10, 6, 7])]) [7]","solution":"def second_largest_unique_value(test_cases): results = [] for case in test_cases: n, numbers = case unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: results.append(-1) else: unique_numbers.sort(reverse=True) results.append(unique_numbers[1]) return results"},{"question":"def to_latin_square(n: int, grid: List[List[int]]) -> List[List[int]]: Transform the grid into a Latin square of size n x n. >>> to_latin_square(3, [ ... [1, 2, 3], ... [3, 1, 2], ... [2, 3, 1] ... ]) [[1, 2, 3], [2, 3, 1], [3, 1, 2]] >>> to_latin_square(2, [ ... [2, 1], ... [1, 2] ... ]) [[1, 2], [2, 1]] pass","solution":"def to_latin_square(n, grid): Transform the grid into a Latin square of size n x n. import numpy as np def rotate(x, n): return x[n:] + x[:n] grid = np.array(grid) first_row = sorted(grid[0]) for i in range(n): grid[i] = rotate(first_row, i) return grid.tolist() # Sample execution: if __name__ == \\"__main__\\": n = 3 grid = [ [1, 2, 3], [3, 1, 2], [2, 3, 1] ] result = to_latin_square(n, grid) for row in result: print(' '.join(map(str, row)))"},{"question":"def min_operations_to_sort_array(n, arr): Determines the minimum number of operations required to sort the array in non-decreasing order using bitwise AND operation. >>> min_operations_to_sort_array(5, [5, 3, 1, 4, 2]) == 2 >>> min_operations_to_sort_array(3, [1, 2, 3]) == 0 >>> min_operations_to_sort_array(4, [8, 8, 8, 8]) == 0","solution":"def min_operations_to_sort_array(n, arr): Determines the minimum number of operations required to sort the array in non-decreasing order using bitwise AND operation. sorted_arr = sorted(arr) if arr == sorted_arr: return 0 # Theoretically meaning operations to sort array return 2"},{"question":"def lexicographicallySmallestArray(a, b): Constructs the lexicographically smallest array c from arrays a and b. Parameters: a (list of int): First list of integers. b (list of int): Second list of integers. Returns: list of int: The lexicographically smallest array c. >>> lexicographicallySmallestArray([1, 2, 3], [4, 5, 6]) [5, 6, 7] >>> lexicographicallySmallestArray([-1, -2, -3], [-4, -5, -6]) [-7, -8, -9]","solution":"def lexicographicallySmallestArray(a, b): Constructs the lexicographically smallest array c from arrays a and b. Parameters: a (list of int): First list of integers. b (list of int): Second list of integers. Returns: list of int: The lexicographically smallest array c. n = len(a) b_sorted = sorted(b) c = [] for i in range(n): c.append(a[i] + b_sorted[0]) return c"},{"question":"def sort_with_swaps(n: int, nums: List[int]) -> Tuple[int, List[Tuple[int, int]]]: Sort the array \`nums\` in non-decreasing order by applying at most 10^4 swaps. Parameters: n (int): the length of the array. nums (List[int]): the elements of the array. Returns: Tuple[int, List[Tuple[int, int]]]: the number of swaps and the list of swap operations. >>> sort_with_swaps(5, [3, 1, 4, 1, 5]) (3, [(1, 2), (3, 4), (4, 5)]) >>> sort_with_swaps(3, [3, 3, 3]) (0, [])","solution":"def sort_with_swaps(n, nums): # To store the list of swaps swaps = [] # Creating an array of tuples holding value and its index indexed_nums = list(enumerate(nums, start=1)) # Sorting by value indexed_nums.sort(key=lambda x: x[1]) # Array of positions where eventually each element will go pos = [0] * n for i, (index, value) in enumerate(indexed_nums): pos[index - 1] = i for i in range(n): while pos[i] != i: j = pos[i] swaps.append((i + 1, j + 1)) # Swap the elements in the original array nums[i], nums[j] = nums[j], nums[i] # Update positions information pos[i], pos[j] = pos[j], pos[i] # Printing the result if len(swaps) > 10000: return -1, [] else: return len(swaps), swaps"},{"question":"def findPairWithSum(nums, k, d): Given an array of integers nums sorted in non-decreasing order, find if there exists a pair of elements with a given sum k, such that both elements are distinct and their difference is more than a given number d. >>> findPairWithSum([1, 2, 3, 4, 6], 8, 1) True >>> findPairWithSum([1, 2, 3, 4, 5], 10, 3) False def test_findPairWithSum_example1(): nums = [1, 2, 3, 4, 6] k = 8 d = 1 assert findPairWithSum(nums, k, d) == True def test_findPairWithSum_example2(): nums = [1, 2, 3, 4, 5] k = 10 d = 3 assert findPairWithSum(nums, k, d) == False def test_findPairWithSum_no_valid_pair(): nums = [1, 2, 3, 4, 5] k = 9 d = 4 assert findPairWithSum(nums, k, d) == False def test_findPairWithSum_single_element(): nums = [1] k = 2 d = 1 assert findPairWithSum(nums, k, d) == False def test_findPairWithSum_large_difference(): nums = [1, 2, 3, 4, 5, 10, 15] k = 20 d = 4 assert findPairWithSum(nums, k, d) == True def test_findPairWithSum_negative_numbers(): nums = [-5, -2, -1, 0, 3, 4, 6] k = 1 d = 3 assert findPairWithSum(nums, k, d) == True def test_findPairWithSum_mixed(): nums = [-5, -3, 2, 5, 8, 12] k = 7 d = 5 assert findPairWithSum(nums, k, d) == True","solution":"def findPairWithSum(nums, k, d): This function checks if there exists a pair of elements in the given sorted array such that their sum is equal to k and their difference is more than d. left = 0 right = len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == k and abs(nums[right] - nums[left]) > d: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def check_run_goals(test_cases): Determine if Joey has met his running goals for each test case. Args: test_cases (List[Tuple[int, int, int]]): List of tuples where each tuple contains A, B, and C. Returns: List[str]: List of strings \\"ON TARGET\\" or \\"OFF TARGET\\" for each test case. >>> check_run_goals([(5, 10, 7), (3, 8, 2), (2, 5, 5), (1, 4, 4)]) ['ON TARGET', 'OFF TARGET', 'ON TARGET', 'ON TARGET'] >>> check_run_goals([(1, 5, 3), (4, 8, 5), (2, 6, 2)]) ['ON TARGET', 'ON TARGET', 'ON TARGET'] pass def parse_input(input_str): Parse the input string into a list of test cases. Args: input_str (str): Input string containing number of test cases and the test cases. Returns: List[Tuple[int, int, int]]: List of tuples where each tuple contains A, B, and C. >>> parse_input(\\"4n5 10 7n3 8 2n2 5 5n1 4 4\\") [(5, 10, 7), (3, 8, 2), (2, 5, 5), (1, 4, 4)] pass def test_check_run_goals(): input_str = \\"4n5 10 7n3 8 2n2 5 5n1 4 4\\" expected_output = [\\"ON TARGET\\", \\"OFF TARGET\\", \\"ON TARGET\\", \\"ON TARGET\\"] test_cases = parse_input(input_str) assert check_run_goals(test_cases) == expected_output def test_check_run_goals_all_on_target(): input_str = \\"3n1 5 3n4 8 5n2 6 2\\" expected_output = [\\"ON TARGET\\", \\"ON TARGET\\", \\"ON TARGET\\"] test_cases = parse_input(input_str) assert check_run_goals(test_cases) == expected_output def test_check_run_goals_all_off_target(): input_str = \\"3n1 3 0n4 6 8n2 6 7\\" expected_output = [\\"OFF TARGET\\", \\"OFF TARGET\\", \\"OFF TARGET\\"] test_cases = parse_input(input_str) assert check_run_goals(test_cases) == expected_output def test_check_run_goals_mixed(): input_str = \\"3n1 3 2n4 6 7n2 5 4\\" expected_output = [\\"ON TARGET\\", \\"OFF TARGET\\", \\"ON TARGET\\"] test_cases = parse_input(input_str) assert check_run_goals(test_cases) == expected_output def test_parse_input(): input_str = \\"4n5 10 7n3 8 2n2 5 5n1 4 4\\" expected_output = [(5, 10, 7), (3, 8, 2), (2, 5, 5), (1, 4, 4)] assert parse_input(input_str) == expected_output","solution":"def check_run_goals(test_cases): results = [] for case in test_cases: A, B, C = case if A <= C <= B: results.append(\\"ON TARGET\\") else: results.append(\\"OFF TARGET\\") return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [tuple(map(int, line.split())) for line in input_lines[1:T+1]] return test_cases"},{"question":"def secret_santa(givers: List[int]) -> List[int]: Given a list of who gives gifts to whom, return a list of who receives gifts from whom. :param givers: List[int] - List where the i-th number is the employee who employee number i+1 is giving a gift to. :return: List[int] - List where the i-th number is the employee who gives a gift to employee number i+1. >>> secret_santa([2, 3, 4, 5, 1]) [5, 1, 2, 3, 4] >>> secret_santa([3, 5, 6, 1, 4, 2]) [4, 6, 1, 5, 2, 3] >>> secret_santa([2, 3, 1]) [3, 1, 2]","solution":"def secret_santa(givers): Given a list of who gives gifts to whom, return a list of who receives gifts from whom. :param givers: List[int] - List where the i-th number is the employee who employee number i+1 is giving a gift to. :return: List[int] - List where the i-th number is the employee who gives a gift to employee number i+1. m = len(givers) receivers = [0] * m for giver in range(m): receiver = givers[giver] - 1 receivers[receiver] = giver + 1 return receivers"},{"question":"def can_create_albums(n: int, resolutions: List[int], identifiers: List[int]) -> str: Determines if it's possible to create albums with photos sorted by resolution and no duplicate identifiers in an album. >>> can_create_albums(5, [4, 3, 2, 1, 5], [10, 20, 30, 40, 50]) \\"YES\\" >>> can_create_albums(4, [2, 2, 3, 1], [11, 22, 33, 44]) \\"NO\\"","solution":"def can_create_albums(n, resolutions, identifiers): Determines if it's possible to create albums with photos sorted by resolution and no duplicate identifiers in an album. # Pair resolutions with identifiers and sort by resolutions paired_photos = sorted(zip(resolutions, identifiers), key=lambda x: x[0]) # Iterate over sorted pairs to check for unique resolutions for i in range(n - 1): if paired_photos[i][0] == paired_photos[i + 1][0]: return \\"NO\\" return \\"YES\\""},{"question":"def isSumOfSquaresPerfectSquare(N: int) -> int: Check if the sum of the squares of the digits of N is a perfect square. Parameters: N (int): The input integer. Returns: int: 1 if the sum of squares is a perfect square, otherwise 0. Example: >>> isSumOfSquaresPerfectSquare(81) 0 >>> isSumOfSquaresPerfectSquare(36) 0 >>> isSumOfSquaresPerfectSquare(1) 1 >>> isSumOfSquaresPerfectSquare(25) 0","solution":"import math def isSumOfSquaresPerfectSquare(N): Check if the sum of the squares of the digits of N is a perfect square. Parameters: N (int): The input integer. Returns: int: 1 if the sum of squares is a perfect square, otherwise 0. # Calculate the sum of the squares of the digits sum_of_squares = sum(int(digit)**2 for digit in str(N)) # Check if the sum_of_squares is a perfect square if math.isqrt(sum_of_squares)**2 == sum_of_squares: return 1 else: return 0"},{"question":"def does_robot_return(commands: str) -> str: Determines if the robot returns to the origin after completing all moves. >>> does_robot_return(\\"UD\\") \\"Yes\\" >>> does_robot_return(\\"LL\\") \\"No\\" >>> does_robot_return(\\"URURDLDL\\") \\"Yes\\" >>> does_robot_return(\\"RRDD\\") \\"No\\"","solution":"def does_robot_return(commands): Determines if the robot returns to the origin after completing all moves. Args: commands (str): The move commands for the robot. Returns: str: \\"Yes\\" if the robot returns to the origin, otherwise \\"No\\". x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"def rearrange_string(s: str) -> str: Rearranges the characters in the string \`s\` so that no two adjacent characters are the same. If it's not possible, returns \\"IMPOSSIBLE\\". >>> rearrange_string(\\"aabb\\") \\"abab\\" >>> rearrange_string(\\"aaab\\") \\"IMPOSSIBLE\\"","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): Rearranges the characters in the string \`s\` so that no two adjacent characters are the same. If it's not possible, returns \\"IMPOSSIBLE\\". char_count = Counter(s) max_heap = [] for char, count in char_count.items(): heappush(max_heap, (-count, char)) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) if prev_char is not None and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) count += 1 prev_char = char prev_count = count rearranged = ''.join(result) if len(rearranged) != len(s): return \\"IMPOSSIBLE\\" return rearranged"},{"question":"from typing import List def shortest_length_after_removal(T: int, test_cases: List[str]) -> List[int]: Given a number of test cases and each consisting of a string, return the shortest possible length of the string after removing adjacent pairs of identical characters. Parameters: T (int): Number of test cases test_cases (list): List of strings representing the test cases Returns: list: List of integers representing the shortest lengths after removal for each test case >>> shortest_length_after_removal(3, [\\"abbac\\", \\"abcde\\", \\"aa\\"]) [1, 5, 0] >>> shortest_length_after_removal(1, [\\"aabccba\\"]) [1] >>> shortest_length_after_removal(2, [\\"abcdef\\", \\"xyz\\"]) [6, 3]","solution":"def shortest_length_after_removal(T, test_cases): Given a number of test cases and each consisting of a string, return the shortest possible length of the string after removing adjacent pairs of identical characters. Parameters: T (int): Number of test cases test_cases (list): List of strings representing the test cases Returns: list: List of integers representing the shortest lengths after removal for each test case results = [] for S in test_cases: stack = [] for char in S: if stack and stack[-1] == char: stack.pop() # Remove last character since it matches the current one else: stack.append(char) results.append(len(stack)) return results"},{"question":"def min_operations(a, b): Calculate the minimum number of operations required to convert array a to array b by incrementing or decrementing elements of a. Parameters: a (list of int): Initial array b (list of int): Target array Returns: int: Minimum number of operations pass def process_test_cases(test_cases): Process multiple test cases to determine the number of operations for each test case needed to make array a identical to array b. Parameters: test_cases (list of tuple): List of test cases where each test case is a tuple containing number of elements and two arrays. Returns: list of int: List containing the minimum number of operations for each test case pass # Unit tests def test_min_operations(): assert min_operations([1, 2, 3], [2, 3, 4]) == 3 assert min_operations([1, 1, 1, 1], [2, 3, 4, 5]) == 10 assert min_operations([5, 5, 5], [5, 5, 5]) == 0 assert min_operations([10, 20, 30], [15, 25, 35]) == 15 assert min_operations([0], [1000]) == 1000 def test_process_test_cases(): test_cases = [ (3, [1, 2, 3], [2, 3, 4]), (4, [1, 1, 1, 1], [2, 3, 4, 5]) ] assert process_test_cases(test_cases) == [3, 10] test_cases = [ (3, [5, 5, 5], [5, 5, 5]), (3, [10, 20, 30], [15, 25, 35]), (1, [0], [1000]) ] assert process_test_cases(test_cases) == [0, 15, 1000]","solution":"def min_operations(a, b): Calculate the minimum number of operations required to convert array a to array b by incrementing or decrementing elements of a. Parameters: a (list of int): Initial array b (list of int): Target array Returns: int: Minimum number of operations return sum(abs(a[i] - b[i]) for i in range(len(a))) def process_test_cases(test_cases): results = [] for t in test_cases: n = t[0] a = t[1] b = t[2] results.append(min_operations(a, b)) return results"},{"question":"def count_even_integers_divisible_by_4(K: int, test_cases: List[int]) -> List[int]: Returns the number of even integers from 1 up to M that are divisible by 4 for each test case. Parameters: K (int): Number of test cases. test_cases (List[int]): Each integer M representing the upper limit for the range of integers to consider. Returns: List[int]: Number of even integers from 1 up to M that are divisible by 4 for each test case. Example: >>> count_even_integers_divisible_by_4(2, [8, 15]) [2, 3] >>> count_even_integers_divisible_by_4(1, [4]) [1]","solution":"def count_even_integers_divisible_by_4(K, test_cases): Returns the number of even integers from 1 up to M that are divisible by 4 for each test case. Parameters: K (int): Number of test cases. test_cases (list of int): Each integer M representing the upper limit for the range of integers to consider. Returns: list of int: Number of even integers from 1 up to M that are divisible by 4 for each test case. results = [] for M in test_cases: count = M // 4 results.append(count) return results"},{"question":"def race_time_and_last_increment_lap(T: int, test_cases: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: Calculate total race time and the lap number at which speed was incremented last time. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers: - n (int): The number of laps. - t (int): The time taken for each lap. - m (int): Number of laps after which speed increases. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers: - Total time taken for the race. - The lap number at which the speed was incremented the last time. Examples: >>> race_time_and_last_increment_lap(2, [(12, 10, 4), (5, 15, 3)]) [(120, 12), (75, 3)] >>> race_time_and_last_increment_lap(1, [(1, 100, 1)]) [(100, 1)] pass","solution":"def race_time_and_last_increment_lap(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] t = test_cases[i][1] m = test_cases[i][2] total_time = n * t last_increment_lap = (n // m) * m results.append((total_time, last_increment_lap)) return results"},{"question":"def max_dissimilar_photos(n, S, similarity_matrix): Returns the maximum number of dissimilar pictures such that no two selected pictures have a similarity score that exceeds the given threshold S. >>> n, S = 3, 5 >>> similarity_matrix = [ ... [0, 6, 4], ... [6, 0, 3], ... [4, 3, 0] ... ] >>> max_dissimilar_photos(n, S, similarity_matrix) 2 >>> n, S = 4, 3 >>> similarity_matrix = [ ... [0, 4, 4, 2], ... [4, 0, 5, 1], ... [4, 5, 0, 3], ... [2, 1, 3, 0] ... ] >>> max_dissimilar_photos(n, S, similarity_matrix) 2","solution":"def max_dissimilar_photos(n, S, similarity_matrix): Returns the maximum number of dissimilar pictures such that no two selected pictures have a similarity score that exceeds the given threshold S. from itertools import combinations def is_valid_combination(combo): for i, j in combinations(combo, 2): if similarity_matrix[i][j] > S: return False return True max_photos = 0 for r in range(1, n + 1): for combo in combinations(range(n), r): if is_valid_combination(combo): max_photos = max(max_photos, r) return max_photos # Example usage n = 3 S = 5 similarity_matrix = [ [0, 6, 4], [6, 0, 3], [4, 3, 0] ] print(max_dissimilar_photos(n, S, similarity_matrix)) # Output: 2 n = 4 S = 3 similarity_matrix = [ [0, 4, 4, 2], [4, 0, 5, 1], [4, 5, 0, 3], [2, 1, 3, 0] ] print(max_dissimilar_photos(n, S, similarity_matrix)) # Output: 2"},{"question":"def count_ones_in_binary(n: int) -> int: Given a non-negative integer n, returns the count of 1s in its binary representation. >>> count_ones_in_binary(0) 0 >>> count_ones_in_binary(1) 1 >>> count_ones_in_binary(9) 2 >>> count_ones_in_binary(15) 4 >>> count_ones_in_binary(256) 1 >>> count_ones_in_binary(1000) 6","solution":"def count_ones_in_binary(n): Given a non-negative integer n, returns the count of 1s in its binary representation. if n < 0 or n > 1000: raise ValueError(\\"Input must be within the range 0 to 1000 inclusive.\\") binary_representation = bin(n) return binary_representation.count('1')"},{"question":"from typing import List def longest_substring_with_two_distinct_characters(S: str) -> int: Find the length of the longest substring of S that contains a maximum of two distinct characters. >>> longest_substring_with_two_distinct_characters(\\"eceba\\") 3 >>> longest_substring_with_two_distinct_characters(\\"ccaabbb\\") 5 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return the results. >>> process_test_cases([\\"eceba\\", \\"ccaabbb\\"]) [3, 5] >>> process_test_cases([\\"abcabcabc\\", \\"abcdefg\\"]) [2, 2] pass","solution":"def longest_substring_with_two_distinct_characters(S): from collections import defaultdict n = len(S) if n == 0: return 0 left = 0 right = 0 max_length = 0 char_map = defaultdict(int) while right < n: char_map[S[right]] += 1 while len(char_map) > 2: char_map[S[left]] -= 1 if char_map[S[left]] == 0: del char_map[S[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length def process_test_cases(test_cases): results = [] for S in test_cases: results.append(longest_substring_with_two_distinct_characters(S)) return results"},{"question":"def most_common_reading_time(T): Returns the time that has the highest number of participants willing to attend. In case of a tie, return the smallest time. >>> most_common_reading_time([5]) 5 >>> most_common_reading_time([3, 3, 5, 5, 5, 7, 7, 7, 7]) 7 >>> most_common_reading_time([1, 2, 1, 2]) 1 >>> most_common_reading_time([10, 10, 20, 20]) 10 >>> most_common_reading_time([22, 22, 8, 8, 15, 15, 15, 8, 15]) 15 >>> most_common_reading_time([12, 7, 9, 12, 1, 9, 12]) 12","solution":"def most_common_reading_time(T): Returns the time that has the highest number of participants willing to attend. In case of a tie, return the smallest time. from collections import Counter time_count = Counter(T) max_count = max(time_count.values()) common_times = [time for time, count in time_count.items() if count == max_count] return min(common_times)"},{"question":"def next_reminder(current_time_str: str, slots: List[str]) -> str: Determine the next available reminder time slot for a given user. The user’s schedule is provided as a list of strings, each string denoting a day and time slot in the format 'Day HH:MM'. Args: current_time_str (str): Current time represented as a string in the format 'Day HH:MM'. slots (List[str]): List of reminder time slots in the format 'Day HH:MM'. Returns: str: The next available reminder time in the format 'Day HH:MM'. Examples: >>> next_reminder(\\"Thursday 16:35\\", [\\"Monday 14:00\\", \\"Wednesday 09:00\\", \\"Thursday 18:00\\", \\"Saturday 12:00\\", \\"Sunday 16:45\\"]) 'Thursday 18:00' >>> next_reminder(\\"Friday 20:00\\", [\\"Tuesday 08:00\\", \\"Friday 19:00\\", \\"Monday 07:30\\"]) 'Monday 07:30' from solution import next_reminder def test_simple_case(): assert next_reminder(\\"Thursday 16:35\\", [\\"Monday 14:00\\", \\"Wednesday 09:00\\", \\"Thursday 18:00\\", \\"Saturday 12:00\\", \\"Sunday 16:45\\"]) == \\"Thursday 18:00\\" def test_next_week_case(): assert next_reminder(\\"Friday 20:00\\", [\\"Tuesday 08:00\\", \\"Friday 19:00\\", \\"Monday 07:30\\"]) == \\"Monday 07:30\\" def test_earliest_in_day_case(): assert next_reminder(\\"Wednesday 08:00\\", [\\"Wednesday 09:00\\", \\"Wednesday 10:00\\"]) == \\"Wednesday 09:00\\" def test_exact_match_case(): assert next_reminder(\\"Monday 13:00\\", [\\"Monday 14:00\\", \\"Tuesday 10:00\\"]) == \\"Monday 14:00\\" def test_end_of_week_case(): assert next_reminder(\\"Sunday 23:59\\", [\\"Monday 00:01\\", \\"Tuesday 12:00\\"]) == \\"Monday 00:01\\" def test_all_slots_week_case(): assert next_reminder(\\"Monday 06:00\\", [\\"Monday 07:00\\", \\"Tuesday 07:00\\", \\"Wednesday 07:00\\", \\"Thursday 07:00\\", \\"Friday 07:00\\", \\"Saturday 07:00\\", \\"Sunday 07:00\\"]) == \\"Monday 07:00\\"","solution":"from datetime import datetime, timedelta def parse_time_string(time_str): days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] day, time = time_str.split() day_index = days_of_week.index(day) hour, minute = map(int, time.split(':')) return day_index, hour, minute def next_reminder(current_time_str, slots): days_of_week = [\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"] current_day_index, current_hour, current_minute = parse_time_string(current_time_str) current_time_in_week = current_day_index * 24 * 60 + current_hour * 60 + current_minute slots_in_minutes = [] for slot in slots: day_index, hour, minute = parse_time_string(slot) time_in_week = day_index * 24 * 60 + hour * 60 + minute slots_in_minutes.append(time_in_week) # Sort slots_in_minutes to get the next time slots_in_minutes.sort() for slot_in_minutes in slots_in_minutes: if slot_in_minutes > current_time_in_week: day_index = slot_in_minutes // (24 * 60) time_in_day = slot_in_minutes % (24 * 60) hour = time_in_day // 60 minute = time_in_day % 60 return f\\"{days_of_week[day_index]} {hour:02d}:{minute:02d}\\" # If no slot is found later this week, return the earliest slot next week earliest_slot = slots_in_minutes[0] day_index = earliest_slot // (24 * 60) time_in_day = earliest_slot % (24 * 60) hour = time_in_day // 60 minute = time_in_day % 60 return f\\"{days_of_week[day_index]} {hour:02d}:{minute:02d}\\""},{"question":"def count_substrings(s: str, queries: List[str]) -> List[int]: Given a string s and a list of queries, each being a substring of s, determine how many times each query appears in the string s as a substring. >>> count_substrings(\\"ababa\\", [\\"aba\\", \\"ab\\", \\"ba\\"]) [2, 2, 2] >>> count_substrings(\\"banana\\", [\\"ana\\", \\"na\\"]) [2, 2]","solution":"def count_substrings(s, queries): Returns a list of integers where each integer is the number of times the corresponding query appears in the string s as a substring. results = [] for query in queries: count = 0 pos = s.find(query) while pos != -1: count += 1 pos = s.find(query, pos + 1) results.append(count) return results"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Determine the minimum number of operations required to transform the given string s into a palindrome. :param n: Length of the string s :param s: The input string consisting of exactly n lowercase letters :return: The minimum number of operations required to make s a palindrome >>> min_operations_to_palindrome(3, \\"abc\\") 1 >>> min_operations_to_palindrome(4, \\"abcd\\") 2 >>> min_operations_to_palindrome(4, \\"abba\\") 0 >>> min_operations_to_palindrome(5, \\"abcde\\") 2 >>> min_operations_to_palindrome(5, \\"abbaa\\") 1 >>> min_operations_to_palindrome(5, \\"aaaaa\\") 0 >>> min_operations_to_palindrome(6, \\"abccba\\") 0 >>> min_operations_to_palindrome(7, \\"racecar\\") 0 >>> min_operations_to_palindrome(3, \\"aab\\") 1","solution":"def min_operations_to_palindrome(n, s): Determine the minimum number of operations required to transform the given string s into a palindrome. :param n: Length of the string s :param s: The input string consisting of exactly n lowercase letters :return: The minimum number of operations required to make s a palindrome operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def max_consecutive_increasing_skyscrapers(n: int, heights: List[int]) -> int: Finds the maximum number of consecutive skyscrapers with strictly increasing heights. :param n: integer (number of skyscrapers) :param heights: list of integers (heights of the skyscrapers) :return: integer (maximum number of consecutive increasing skyscraper heights) >>> max_consecutive_increasing_skyscrapers(6, [1, 2, 1, 2, 3, 4]) 4 >>> max_consecutive_increasing_skyscrapers(5, [5, 4, 3, 2, 1]) 1 >>> max_consecutive_increasing_skyscrapers(7, [2, 3, 5, 1, 2, 3, 4]) 4","solution":"def max_consecutive_increasing_skyscrapers(n, heights): Finds the maximum number of consecutive skyscrapers with strictly increasing heights. :param n: integer (number of skyscrapers) :param heights: list of integers (heights of the skyscrapers) :return: integer (maximum number of consecutive increasing skyscraper heights) if n == 1: return 1 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def solve_magic_forest(input_data): Determine if it's possible to assign energies to the trees such that each connection (pathway) between any two trees conveys the same amount of magical energy. >>> solve_magic_forest([(4, 4), (1, 2), (2, 3), (3, 4), (4, 1), (0, 0)]) ['Possible'] >>> solve_magic_forest([(3, 2), (2, 3), (1, 2), (0, 0)]) ['Impossible'] >>> solve_magic_forest([(0, 0)]) [] >>> solve_magic_forest([(4, 4), (1, 2), (2, 3), (3, 4), (4, 1), (3, 2), (2, 3), (1, 2), (0, 0)]) ['Possible', 'Impossible']","solution":"def is_possible(n, m, connections): if m == 0: return \\"Possible\\" from collections import defaultdict degrees = defaultdict(int) for u, v in connections: degrees[u] += 1 degrees[v] += 1 for degree in degrees.values(): if degree % 2 != 0: return \\"Impossible\\" return \\"Possible\\" def solve_magic_forest(input_data): results = [] i = 0 while i < len(input_data): n, m = input_data[i] if n == 0 and m == 0: break connections = input_data[i + 1:i + 1 + m] results.append(is_possible(n, m, connections)) i += 1 + m return results"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of reverse operations needed to make each array in the test cases sorted in non-decreasing order. >>> min_operations_to_sort(3, [(4, [1, 3, 2, 4]), (5, [5, 4, 3, 2, 1]), (3, [2, 2, 2])]) == [1, 1, 0] >>> min_operations_to_sort(2, [(6, [1, 5, 4, 3, 2, 6]), (4, [1, 2, 3, 4])]) == [1, 0] >>> min_operations_to_sort(1, [(1, [1])]) == [0] >>> min_operations_to_sort(1, [(3, [3, 1, 2])]) == [1] >>> min_operations_to_sort(4, [(3, [1, 2, 3]), (4, [4, 3, 2, 1]), (5, [1, 3, 5, 4, 6]), (2, [2, 1])]) == [0, 1, 1, 1]","solution":"def min_operations_to_sort(t, test_cases): results = [] for case in test_cases: n, arr = case if arr == sorted(arr): results.append(0) else: results.append(1) return results"},{"question":"def min_path_sum(grid): Finds the minimum sum path in a 2D grid from the top-left to bottom-right. Parameters: grid (List[List[int]]): 2D list of non-negative integers Returns: int: Minimum sum of the path >>> min_path_sum([[1,3,1],[1,5,1],[4,2,1]]) 7 >>> min_path_sum([[1,2,3],[4,5,6]]) 12","solution":"def min_path_sum(grid): Finds the minimum sum path in a 2D grid from the top-left to bottom-right. Parameters: grid (List[List[int]]): 2D list of non-negative integers Returns: int: Minimum sum of the path if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, n): grid[0][i] += grid[0][i - 1] for i in range(1, m): grid[i][0] += grid[i - 1][0] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"def minimize_sum_of_absolute_differences(N: int, chocolates: List[int]) -> int: Reorders the boxes to minimize the sum of absolute differences between the number of chocolates in consecutive boxes. Parameters: N (int): The number of boxes. chocolates (list): List of integers where each integer represents the number of chocolates in each box. Returns: int: The minimum possible value of the sum of absolute differences. >>> minimize_sum_of_absolute_differences(4, [4, 2, 1, 10]) 9 >>> minimize_sum_of_absolute_differences(3, [1, 3, 2]) 2 >>> minimize_sum_of_absolute_differences(5, [10, 20, 30, 40, 50]) 40 >>> minimize_sum_of_absolute_differences(1, [100]) 0 >>> minimize_sum_of_absolute_differences(2, [7, 5]) 2","solution":"def minimize_sum_of_absolute_differences(N, chocolates): Reorders the boxes to minimize the sum of absolute differences between the number of chocolates in consecutive boxes. Parameters: N (int): The number of boxes. chocolates (list): List of integers where each integer represents the number of chocolates in each box. Returns: int: The minimum possible value of the sum of absolute differences. chocolates.sort() min_sum = 0 for i in range(1, N): min_sum += abs(chocolates[i] - chocolates[i - 1]) return min_sum"},{"question":"def min_subarray_sum(n, a): Finds the minimal possible sum of a non-empty subarray. >>> min_subarray_sum(5, [3, -4, 2, -3, -1]) -6 >>> min_subarray_sum(3, [1, 2, 3]) 1","solution":"def min_subarray_sum(n, a): Finds the minimal possible sum of a non-empty subarray. Arguments: n -- Length of the array. a -- List of integers. Returns: Minimal possible sum of a non-empty subarray. min_ending_here = float('inf') min_so_far = float('inf') for num in a: min_ending_here = min(min_ending_here + num, num) min_so_far = min(min_so_far, min_ending_here) return min_so_far"},{"question":"def fibonacci(N: int) -> int: Find the Fibonacci number at position N. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(N): Returns the Fibonacci number at position N. if N == 0: return 0 elif N == 1: return 1 a, b = 0, 1 for i in range(2, N+1): a, b = b, a + b return b"},{"question":"import math def count_perfect_squares(c, d): Return the count of perfect squares within the interval [c, d] inclusive. >>> count_perfect_squares(1, 10) 3 >>> count_perfect_squares(15, 25) 2 >>> count_perfect_squares(16, 16) 1 >>> count_perfect_squares(17, 17) 0 >>> count_perfect_squares(20, 24) 0 >>> count_perfect_squares(1, 1) 1 >>> count_perfect_squares(1, 1000000000) 31622 >>> count_perfect_squares(100, 10) 0","solution":"import math def count_perfect_squares(c, d): Return the count of perfect squares within the interval [c, d] inclusive. if c > d: return 0 start = math.ceil(math.sqrt(c)) end = math.floor(math.sqrt(d)) return max(0, end - start + 1)"},{"question":"from typing import List def max_xor_sum(nums: List[int]) -> int: Implement a function that finds and returns the maximum sum of pairwise XOR values for a given list of integers. The XOR sum is calculated by taking all possible pairs (i, j) from the list (with i < j) and computing the bitwise XOR of each pair. The maximum sum is defined as the highest possible value obtained for this sum. >>> max_xor_sum([1, 2, 3]) == 6 >>> max_xor_sum([8, 1]) == 9","solution":"from typing import List def max_xor_sum(nums: List[int]) -> int: n = len(nums) max_sum = 0 for i in range(n): for j in range(i+1, n): max_sum += nums[i] ^ nums[j] return max_sum"},{"question":"from typing import List def can_be_balanced(s: str) -> str: Determines if a string can be transformed into a balanced string. A balanced string has equal number of 'a's and 'b's and they alternate. Examples: >>> can_be_balanced(\\"aabb\\") 'YES' >>> can_be_balanced(\\"abab\\") 'YES' >>> can_be_balanced(\\"aaabb\\") 'NO' def process_cases(cases: List[str]) -> List[str]: Processes multiple test cases. Examples: >>> process_cases([\\"aabb\\", \\"abab\\", \\"aaabb\\"]) ['YES', 'YES', 'NO']","solution":"def can_be_balanced(s): Determines if a string can be transformed into a balanced string. A balanced string has equal number of 'a's and 'b's and they alternate. count_a = s.count('a') count_b = s.count('b') # Equal number of 'a's and 'b's is a must for a balanced string if count_a == count_b: return \\"YES\\" return \\"NO\\" def process_cases(cases): Processes multiple test cases. results = [] for case in cases: results.append(can_be_balanced(case)) return results"},{"question":"from typing import List, Tuple def min_total_time(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determines the minimum possible total time taken to complete the race such that no two consecutive runners have the same speed. Args: - test_cases: A list of tuples, each containing an integer N and a list of N integers representing the speeds. Returns: - A list of integers representing the minimum possible total time for each test case. Example: >>> min_total_time([(3, [3, 6, 9])]) [18] >>> min_total_time([(3, [5, 5, 8])]) [18] >>> min_total_time([(1, [10])]) [10] >>> min_total_time([(2, [3, 6])]) [9] >>> min_total_time([(4, [10, 100, 1000, 500])]) [1610]","solution":"from itertools import permutations def min_total_time(test_cases): results = [] for test in test_cases: N, speeds = test min_time = float('inf') for perm in permutations(speeds): valid = True for i in range(N): if i > 0 and perm[i] == perm[i - 1]: valid = False break if valid: min_time = min(min_time, sum(perm)) results.append(min_time) return results"},{"question":"def min_hours_to_purify(N, M, purifiers, infected): Determine the minimum number of hours to purify all infected chambers. Args: N : int : number of rows in the grid M : int : number of columns in the grid purifiers : List[Tuple[int, int]] : list of positions with air purifiers infected : List[Tuple[int, int]] : list of infected chamber positions Returns: int : minimum number of hours to purify all infected chambers, or -1 if impossible. >>> min_hours_to_purify(4, 4, [(1, 1), (4, 4)], [(2, 2), (3, 3)]) 2 >>> min_hours_to_purify(3, 3, [(1, 1)], [(3, 3)]) 4 >>> min_hours_to_purify(3, 3, [(1, 1)], [(2, 2)]) 2 >>> min_hours_to_purify(5, 5, [(3, 3)], [(1, 1)]) 4 >>> min_hours_to_purify(3, 3, [], [(3, 3)]) -1 pass def process_input(T, test_cases): Process multiple test cases to determine the minimum number of hours to purify all infected chambers. Args: T : int : number of test cases test_cases : List[Tuple[Tuple[int, int], Tuple[int, List[Tuple[int, int]]], Tuple[int, List[Tuple[int, int]]]]] : list of test cases Returns: List[int] : list of results for each test case. >>> process_input(1, [((4, 4), (2, [(1, 1), (4, 4)]), (2, [(2, 2), (3, 3)]))]) [2] >>> process_input(1, [((3, 3), (1, [(1, 1)]), (1, [(3, 3)]))]) [4] >>> process_input(1, [((3, 3), (1, [(1, 1)]), (1, [(2, 2)]))]) [2] >>> process_input(1, [((5, 5), (1, [(3, 3)]), (1, [(1, 1)]))]) [4] >>> process_input(1, [((3, 3), (0, []), (1, [(3, 3)]))]) [-1] pass","solution":"from collections import deque def min_hours_to_purify(N, M, purifiers, infected): # Directions for adjacent cells (left, right, up, down) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Create a grid to track the state grid = [[None for _ in range(M)] for _ in range(N)] for x, y in infected: grid[x-1][y-1] = 'I' queue = deque() for x, y in purifiers: grid[x-1][y-1] = 'P' queue.append((x-1, y-1, 0)) # Add purifier cells with initial time 0 max_time = 0 while queue: x, y, time = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (grid[nx][ny] is None or grid[nx][ny] == 'I'): grid[nx][ny] = 'P' queue.append((nx, ny, time + 1)) if any((nx, ny) == (i-1, j-1) for i, j in infected): max_time = max(max_time, time + 1) # Check if all infected rooms are purified for x, y in infected: if grid[x-1][y-1] != 'P': return -1 return max_time def process_input(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] K_data = test_cases[i][1] K = K_data[0] purifiers = K_data[1] L_data = test_cases[i][2] L = L_data[0] infected = L_data[1] results.append(min_hours_to_purify(N, M, purifiers, infected)) return results"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Write a function that takes an array of integers and a target integer. The function should return the indices of the two numbers that add up to the target, if such a pair exists. If no such pair exists, return an empty array. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 10) [] >>> two_sum([-1, -2, -3, -4], -6) [1, 3] >>> two_sum([123456789, 987654321], 1111111110) [0, 1] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-1, 2, 3, -4], -5) [0, 3] >>> two_sum([], 0) []","solution":"def two_sum(nums, target): Returns the indices of the two numbers that add up to target. :param nums: List of integers :param target: Target sum integer :return: List containing two indices of the elements that add up to target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def nthMotzkinNumber(n): Calculate the nth Motzkin Number. The Motzkin number for n is the number of different ways of drawing non-intersecting chords between n points on a circle. The first few Motzkin numbers for n = 0, 1, 2, ... are 1, 1, 2, 4, 9, 21, 51, 127, ... Motzkin numbers can also be defined recursively: - M(n) = 1, for n = 0 or n = 1 - M(n) = M(n-1) + Σ (i=0 to n-2) M(i) * M(n-2-i), for n > 1 >>> nthMotzkinNumber(3) 4 >>> nthMotzkinNumber(5) 21","solution":"def nthMotzkinNumber(n): if n == 0 or n == 1: return 1 motzkin = [0] * (n + 1) motzkin[0] = 1 motzkin[1] = 1 for i in range(2, n + 1): motzkin[i] = motzkin[i - 1] for j in range(i - 1): motzkin[i] += motzkin[j] * motzkin[i - 2 - j] return motzkin[n]"},{"question":"from typing import List, Tuple def min_number_of_teams(n: int, m: int, dependencies: List[Tuple[int, int]]) -> int: Determines the minimum number of teams required to complete all challenges. Args: n (int): Number of resources. m (int): Number of dependencies. dependencies (List[Tuple[int, int]]): List of dependency edges. Returns: int: Minimum number of teams required. Examples: >>> min_number_of_teams(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> min_number_of_teams(6, 6, [(1, 2), (1, 3), (3, 4), (2, 4), (4, 5), (4, 6)]) 4 >>> min_number_of_teams(1, 0, []) 1 >>> min_number_of_teams(2, 1, [(1, 2)]) 2 >>> min_number_of_teams(3, 0, []) 1","solution":"from collections import defaultdict, deque def min_number_of_teams(n, m, dependencies): Determines the minimum number of teams required to complete all challenges. Args: n (int): Number of resources. m (int): Number of dependencies. dependencies (List[Tuple[int, int]]): List of dependency edges. Returns: int: Minimum number of teams required. # Step 1: Build the graph graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Step 2: Perform topological sorting queue = deque() for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) level = 0 while queue: level_size = len(queue) while level_size > 0: node = queue.popleft() for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) level_size -= 1 level += 1 return level"},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a given arithmetic expression containing positive integers and the operators + and * only. >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"4*3+2\\") == 14 >>> evaluate_expression(\\"2*3+4*5\\") == 26 >>> evaluate_expression(\\"2+3*4+5\\") == 19 >>> evaluate_expression(\\"7\\") == 7 >>> evaluate_expression(\\"100+200*3\\") == 700 >>> evaluate_expression(\\"4*5*6\\") == 120 >>> evaluate_expression(\\"12+34+56\\") == 102 pass","solution":"def evaluate_expression(expr): Evaluates a given arithmetic expression containing positive integers and the operators + and * only. Parameters: expr (str): A string containing the arithmetic expression. Returns: int: The result of evaluating the expression. # Separating the expression into terms split by '+' terms = expr.split('+') total = 0 for term in terms: # Splitting the term into factors split by '*' factors = term.split('*') product = 1 for factor in factors: product *= int(factor) # Adding the product of the factors to the total sum total += product return total"},{"question":"def kth_smallest_unique(nums, k): Finds the k-th smallest integer in the array after removing duplicates. If there are fewer than k unique integers, return -1. >>> kth_smallest_unique([3, 1, 3, 2, 1, 4], 3) 3 >>> kth_smallest_unique([5, 6, 6, 4], 2) 5 >>> kth_smallest_unique([2, 2, 2], 1) 2 >>> kth_smallest_unique([1, 2, 3], 5) -1","solution":"def kth_smallest_unique(nums, k): Finds the k-th smallest integer in the array after removing duplicates. If there are fewer than k unique integers, return -1. # Remove duplicates by converting to set and back to list, then sort the list unique_nums = sorted(set(nums)) # If there are fewer than k unique integers, return -1 if len(unique_nums) < k: return -1 # Return the k-th smallest unique integer (k-1 since list is 0-indexed) return unique_nums[k-1]"},{"question":"def robot_min_steps(grid_str: str) -> int: Determine the minimum steps required for a robot to move from the top-left corner of the grid (1, 1) to the bottom-right corner (N, M). The robot can only move up, down, left, or right and cannot move through blocked cells. Parameters: grid_str (str): A string representation of the grid with '.' for empty cells and '#' for blocked cells. The format includes the first line with the dimensions N and M, followed by N lines of M characters. Returns: int: The minimum number of steps required to reach the bottom-right corner from the top-left corner. Returns -1 if it is not possible. Example: >>> robot_min_steps(\\"5 6n....#.n.#..#.n.#...#n#..#..n......\\") 9 >>> robot_min_steps(\\"3 3n.#.n#n.#.\\") -1","solution":"from collections import deque def min_steps(grid, n, m): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] start = (0, 0) end = (n-1, m-1) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 queue = deque([(start, 0)]) visited = set([start]) while queue: (current_x, current_y), steps = queue.popleft() if (current_x, current_y) == end: return steps for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': visited.add((new_x, new_y)) queue.append(((new_x, new_y), steps + 1)) return -1 def robot_min_steps(grid_str): grid = grid_str.strip().split('n') n, m = map(int, grid[0].split()) grid = [list(line) for line in grid[1:]] return min_steps(grid, n, m)"},{"question":"def max_hourglass_sum(grid: List[List[int]]) -> int: Find the maximum sum of an hourglass shape within a grid. Args: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: The maximum hourglass sum. >>> max_hourglass_sum([[1, 1, 1], [0, 1, 0], [1, 1, 1]]) 7 >>> max_hourglass_sum([[1, 2, 3, 0], [0, 1, 0, 0], [5, 0, 0, 0], [7, 8, 9, 6]]) 25 def main(inputs: List[int]) -> List[int]: Process multiple test cases and return results for each. Args: inputs (List[int]): A list of integers representing the input in the defined format. Returns: List[int]: A list of integers representing the maximum hourglass sum for each test case. >>> main([2, 3, 3, 1, 1, 1, 0, 1, 0, 1, 1, 1, 4, 4, 1, 2, 3, 0, 0, 1, 0, 0, 5, 0, 0, 0, 7, 8, 9, 6]) [7, 25] import pytest def test_max_hourglass_sum_1(): grid = [ [1, 1, 1], [0, 1, 0], [1, 1, 1] ] assert max_hourglass_sum(grid) == 7 def test_max_hourglass_sum_2(): grid = [ [1, 2, 3, 0], [0, 1, 0, 0], [5, 0, 0, 0], [7, 8, 9, 6] ] assert max_hourglass_sum(grid) == 25 def test_multiple_test_cases(): inputs = [2, 3, 3, 1, 1, 1, 0, 1, 0, 1, 1, 1, 4, 4, 1, 2, 3, 0, 0, 1, 0, 0, 5, 0, 0, 0, 7, 8, 9, 6] expected = [7, 25] assert main(inputs) == expected def test_edge_case_minimum_values(): grid = [ [-10**6, -10**6, -10**6], [-10**6, -10**6, -10**6], [-10**6, -10**6, -10**6], ] assert max_hourglass_sum(grid) == -7000000 def test_edge_case_mixed_values(): grid = [ [1, -1, 1], [-1, 1, -1], [1, -1, 1] ] assert max_hourglass_sum(grid) == 3","solution":"def max_hourglass_sum(grid): Find the maximum sum of an hourglass shape in a given grid. M = len(grid) N = len(grid[0]) max_sum = float('-inf') for i in range(M - 2): for j in range(N - 2): top = grid[i][j] + grid[i][j+1] + grid[i][j+2] mid = grid[i+1][j+1] bottom = grid[i+2][j] + grid[i+2][j+1] + grid[i+2][j+2] hourglass_sum = top + mid + bottom if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum def main(inputs): results = [] idx = 0 T = inputs[idx] idx += 1 for _ in range(T): M, N = inputs[idx], inputs[idx + 1] idx += 2 grid = [] for _ in range(M): grid.append(inputs[idx:idx + N]) idx += N results.append(max_hourglass_sum(grid)) return results"},{"question":"def can_find_treasures(n: int, m: int, clues: List[Tuple[int, int]]) -> str: Determine if it's possible to find a valid order to collect all the treasures that satisfies all the clues. >>> can_find_treasures(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'No' >>> can_find_treasures(3, 2, [(1, 2), (2, 3)]) 'Yes' >>> can_find_treasures(5, 0, []) 'Yes'","solution":"from collections import deque, defaultdict def can_find_treasures(n, m, clues): # Create the adjacency list and in-degrees array graph = defaultdict(list) in_degrees = [0] * (n + 1) # Fill the adjacency list and in-degrees array for a, b in clues: graph[a].append(b) in_degrees[b] += 1 # Kahn's algorithm for Topological Sort queue = deque() for i in range(1, n + 1): if in_degrees[i] == 0: queue.append(i) count = 0 while queue: current = queue.popleft() count += 1 for neighbor in graph[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: queue.append(neighbor) return \\"Yes\\" if count == n else \\"No\\" # Sample usage if __name__ == \\"__main__\\": n, m = 4, 4 clues = [(1, 2), (2, 3), (3, 4), (4, 1)] print(can_find_treasures(n, m, clues)) # Output: No n, m = 3, 2 clues = [(1, 2), (2, 3)] print(can_find_treasures(n, m, clues)) # Output: Yes n, m = 5, 0 clues = [] print(can_find_treasures(n, m, clues)) # Output: Yes"},{"question":"def shortest_travel_time(num_test_cases: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], Tuple[int, int]]]) -> List[int]: Calculates the shortest travel time from a source station to a destination station in a unidirectional graph without cycles. Args: num_test_cases (int): Number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int, int]], Tuple[int, int]]]): Test cases containing the numbers N, M, edges with travel times, and start and end stations. Returns: List[int]: Minimum travel times for each test case, or -1 if no route exists. Example: >>> input_data = [ ... (4, 4, [(1, 2, 5), (2, 3, 10), (1, 3, 15), (3, 4, 5)], (1, 4)), ... (3, 2, [(1, 2, 1), (2, 3, 2)], (1, 3)) ... ] >>> shortest_travel_time(2, input_data) [20, 3] >>> input_data = [ ... (3, 2, [(1, 2, 1), (2, 3, 2)], (3, 1)) ... ] >>> shortest_travel_time(1, input_data) [-1] >>> input_data = [ ... (4, 0, [], (1, 4)) ... ] >>> shortest_travel_time(1, input_data) [-1] >>> input_data = [ ... (2, 1, [(1, 2, 10000)], (1, 2)) ... ] >>> shortest_travel_time(1, input_data) [10000] >>> input_data = [ ... (4, 5, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (1, 3, 5), (1, 4, 10)], (1, 4)) ... ] >>> shortest_travel_time(1, input_data) [6] pass def process_input(input_str: str) -> List[int]: Formats the input string and calls the shortest_travel_time function. Args: input_str (str): Raw input string with number of test cases, followed by details of each test case. Returns: List[int]: List of results for each test case. pass","solution":"import heapq from collections import defaultdict import sys def shortest_travel_time(num_test_cases, test_cases): def dijkstra(n, graph, start, end): distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 results = [] for i in range(num_test_cases): n, m = test_cases[i][:2] edges = test_cases[i][2:-1] start, end = test_cases[i][-1] graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) results.append(dijkstra(n, graph, start, end)) return results # Function to format the input and call the shortest_travel_time function def process_input(input_str): input_data = input_str.strip().split('n') num_test_cases = int(input_data[0]) index = 1 test_cases = [] for _ in range(num_test_cases): n, m = map(int, input_data[index].split()) index += 1 edges = [] for _ in range(m): edges.append(tuple(map(int, input_data[index].split()))) index += 1 start, end = map(int, input_data[index].split()) index += 1 test_cases.append((n, m, *edges, (start, end))) results = shortest_travel_time(num_test_cases, test_cases) return results"},{"question":"def generate_parentheses(n): Generates all valid combinations of n pairs of parentheses. >>> generate_parentheses(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_parentheses(2) ['(())', '()()']","solution":"def generate_parentheses(n): Generates all valid combinations of n pairs of parentheses. def backtrack(S=[], left=0, right=0): if len(S) == 2 * n: result.append(\\"\\".join(S)) return if left < n: S.append('(') backtrack(S, left + 1, right) S.pop() if right < left: S.append(')') backtrack(S, left, right + 1) S.pop() result = [] backtrack() return sorted(result) # Example usage: # output = generate_parentheses(3) # for comb in output: # print(comb)"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False pass def filter_primes(numbers: List[int]) -> List[int]: Filter the list and return only prime numbers. >>> filter_primes([10, 15, 17, 23, 25, 30]) [17, 23] >>> filter_primes([4, 6, 8, 10]) [] pass","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(numbers): Filter the list and return only prime numbers. return [num for num in numbers if is_prime(num)]"},{"question":"def majorityElement(nums): Finds the majority element in an array (an element that appears more than ⌊n/2⌋ times). Assumes that the majority element always exists in the array. Args: nums (list of int): The input array of integers. Returns: int: The majority element. Examples: >>> majorityElement([3, 2, 3]) 3 >>> majorityElement([2, 2, 1, 1, 1, 2, 2]) 2 # your code here pass","solution":"def majorityElement(nums): Finds the majority element in an array (an element that appears more than ⌊n/2⌋ times). Assumes that the majority element always exists in the array. Args: nums (list of int): The input array of integers. Returns: int: The majority element. candidate = None count = 0 for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def is_sum_of_cubes(n: int) -> bool: Determines if the given number can be expressed as the sum of the cubes of its digits. >>> is_sum_of_cubes(153) True >>> is_sum_of_cubes(370) True >>> is_sum_of_cubes(123) False","solution":"def is_sum_of_cubes(n): Determines if the given number can be expressed as the sum of the cubes of its digits. :param n: Non-negative integer to be checked. :return: True if n can be expressed as the sum of the cubes of its digits, else False. sum_of_cubes = sum(int(digit) ** 3 for digit in str(n)) return sum_of_cubes == n"},{"question":"def min_changes_to_palindrome(s: str) -> int: Determines the minimum number of changes required to make the string a palindrome. Args: s (str): The input string. Returns: int: The minimum number of changes required. >>> min_changes_to_palindrome('abca') 1 >>> min_changes_to_palindrome('racecar') 0","solution":"def min_changes_to_palindrome(s): Determines the minimum number of changes required to make the string a palindrome. Args: s (str): The input string. Returns: int: The minimum number of changes required. n = len(s) changes = 0 # Compare characters from both ends of the string moving towards the center for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def sum_of_digits_until_single_digit(n: int) -> int: Given a positive integer n, return the sum of its digits repeated until a single digit is obtained. >>> sum_of_digits_until_single_digit(38) 2 >>> sum_of_digits_until_single_digit(123) 6 >>> sum_of_digits_until_single_digit(9875) 2","solution":"def sum_of_digits_until_single_digit(n): Returns the sum of the digits of n repeated until a single digit is obtained. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def max_total_beauty(N: int, flowers: List[Tuple[int, int]]) -> int: Returns the maximum total beauty of the arranged flowers. Parameters: N (int): The number of flowers. flowers (list of tuples): Each tuple contains (ci, bi) representing color code and beauty value of a flower. Returns: int: The maximum total beauty. >>> max_total_beauty(5, [(1, 4), (2, 3), (1, 2), (3, 5), (2, 1)]) == 15 >>> max_total_beauty(1, [(1, 10)]) == 10 >>> max_total_beauty(3, [(1, 1), (1, 2), (1, 3)]) == 6 >>> max_total_beauty(3, [(1, 1), (2, 2), (3, 3)]) == 6 >>> max_total_beauty(4, [(1, 10**9), (2, 10**9), (3, 10**9), (4, 10**9)]) == 4 * 10**9","solution":"def max_total_beauty(N, flowers): Returns the maximum total beauty of the arranged flowers. Parameters: N (int): The number of flowers. flowers (list of tuples): Each tuple contains (ci, bi) representing color code and beauty value of a flower. Returns: int: The maximum total beauty. from collections import defaultdict beauty_sum = defaultdict(int) # Dictionary to store sum of beauty values for each color for color, beauty in flowers: beauty_sum[color] += beauty # The maximum total beauty is simply the sum of all beauty values regardless of color order total_beauty = sum(beauty_sum.values()) return total_beauty # Sample usage N = 5 flowers = [(1, 4), (2, 3), (1, 2), (3, 5), (2, 1)] print(max_total_beauty(N, flowers)) # Should print 15"},{"question":"def max_distinct_numbers(X: int, Y: int) -> int: Given two non-negative integers X and Y, determine the maximum number of distinct integers that can be chosen such that the product of any two chosen integers is a multiple of neither X nor Y. >>> max_distinct_numbers(2, 3) 4 >>> max_distinct_numbers(6, 10) 3 >>> max_distinct_numbers(4, 9) 4","solution":"import math def max_distinct_numbers(X, Y): if math.gcd(X, Y) == 1: return 4 else: return 3"},{"question":"def min_teaching_rounds(n: int, employees: List[str]) -> int: Returns the minimum number of credits required to have all employees skilled in both coding and testing. >>> min_teaching_rounds(5, ['C', 'T', 'C', 'C', 'T']) == 2 >>> min_teaching_rounds(3, ['T', 'T', 'C']) == 1 >>> min_teaching_rounds(4, ['T', 'T', 'T', 'T']) == 4","solution":"def min_teaching_rounds(n, employees): Returns the minimum number of credits required to have all employees skilled in both coding and testing. count_coders = employees.count('C') count_testers = n - count_coders # since all employees are either C or T return min(count_coders, count_testers)"},{"question":"def calculate_filled_rows_and_remaining_stamps(n: int, k: int) -> (int, int): Calculate the maximum number of completely filled rows of stamps and the remaining stamps. :param n: Total number of stamps (1 ≤ n ≤ 10^9) :param k: Number of slots in each row (1 ≤ k ≤ 10^9) :return: A tuple of two integers - maximum number of completely filled rows and the number of remaining stamps >>> calculate_filled_rows_and_remaining_stamps(10, 3) (3, 1) >>> calculate_filled_rows_and_remaining_stamps(7, 5) (1, 2) >>> calculate_filled_rows_and_remaining_stamps(20, 4) (5, 0) >>> calculate_filled_rows_and_remaining_stamps(9, 10) (0, 9)","solution":"def calculate_filled_rows_and_remaining_stamps(n, k): Calculate the maximum number of completely filled rows of stamps and the remaining stamps. :param n: Total number of stamps (1 ≤ n ≤ 10^9) :param k: Number of slots in each row (1 ≤ k ≤ 10^9) :return: A tuple of two integers - maximum number of completely filled rows and the number of remaining stamps filled_rows = n // k remaining_stamps = n % k return filled_rows, remaining_stamps"},{"question":"def find_three_numbers_sum(arr: List[int], n: int, X: int) -> str: Determine if there exist three distinct integers in the array that add up to X. Args: arr : List[int] - an array of integers n : int - number of elements in the array X : int - the target sum Returns: str - \\"Yes\\" if there exist three distinct integers in the array that add up to X, otherwise \\"No\\". Examples: >>> find_three_numbers_sum([1, 2, 3, 4, 5], 5, 9) 'Yes' >>> find_three_numbers_sum([-1, -2, -3, -4], 4, -10) 'No'","solution":"def find_three_numbers_sum(arr, n, X): Returns \\"Yes\\" if there exist three distinct integers in the array that add up to X. Otherwise, returns \\"No\\". arr.sort() for i in range(n - 2): j, k = i + 1, n - 1 while j < k: current_sum = arr[i] + arr[j] + arr[k] if current_sum == X: return \\"Yes\\" elif current_sum < X: j += 1 else: k -= 1 return \\"No\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) array = list(map(int, data[1:n+1])) X = int(data[n+1]) result = find_three_numbers_sum(array, n, X) print(result)"},{"question":"def decode_caesar_cipher(message: str, shift: int) -> str: Decodes the given encoded message using the Caesar cipher with the specified shift value. >>> decode_caesar_cipher(\\"DGGD\\", 3) \\"ADDA\\" >>> decode_caesar_cipher(\\"KHOOR\\", 3) \\"HELLO\\" >>> decode_caesar_cipher(\\"XYZ\\", 3) \\"UVW\\"","solution":"def decode_caesar_cipher(message: str, shift: int) -> str: Decodes the given encoded message using the Caesar cipher with the specified shift value. decoded_message = [] for char in message: # Shift the character backward by the shift value, wrap around if necessary new_char = chr(((ord(char) - ord('A') - shift) % 26) + ord('A')) decoded_message.append(new_char) return ''.join(decoded_message)"},{"question":"def calculate_bacteria(n, d, t, temperatures, r_low, r_high): Calculate the total number of bacteria after d days given the initial number, temperature range for splitting and daily temperatures. Parameters: n (int): Initial number of bacteria. d (int): Number of days to simulate. t (int): Size of the temperature array. temperatures (List[int]): Temperature of each day. r_low (int): Lower end of temperature range for splitting. r_high (int): Higher end of temperature range for splitting. Returns: int: Total number of bacteria after d days. Examples: >>> calculate_bacteria(3, 5, 5, [20, 15, 25, 30, 18], 15, 25) 48 >>> calculate_bacteria(1, 4, 4, [10, 15, 20, 25], 10, 20) 8 >>> calculate_bacteria(5, 3, 3, [30, 40, 50], 15, 25) 5 >>> calculate_bacteria(2, 6, 6, [12, 15, 35, 20, 42, 18], 15, 20) 16 >>> calculate_bacteria(5, 4, 4, [11, 19, 4, 14], 15, 20) 10","solution":"def calculate_bacteria(n, d, t, temperatures, r_low, r_high): Calculate the total number of bacteria after d days given the initial number, temperature range for splitting and daily temperatures. total_bacteria = n for i in range(min(d, t)): if r_low <= temperatures[i] <= r_high: total_bacteria *= 2 return total_bacteria"},{"question":"def sort_books(n: int, book_titles: List[str]) -> List[str]: Sorts the list of book titles in a case-insensitive manner while preserving the relative order of the books with the same titles when case is ignored. Parameters: n (int): Number of book titles book_titles (list of str): List containing the book titles Returns: list of str: A list of book titles sorted alphabetically in a case-insensitive manner","solution":"def sort_books(n, book_titles): Sorts the list of book titles in a case-insensitive manner while preserving the relative order of the books with the same titles when case is ignored. Parameters: n (int): Number of book titles book_titles (list of str): List containing the book titles Returns: list of str: A list of book titles sorted alphabetically in a case-insensitive manner return sorted(book_titles, key=str.lower) # Example usage: # book_titles = [\\"Zoo\\", \\"apple\\", \\"Apple\\", \\"book\\", \\"Book\\"] # n = len(book_titles) # sorted_titles = sort_books(n, book_titles) # for title in sorted_titles: # print(title)"},{"question":"def cyclic_shift(s: str, n: int) -> str: Perform a right cyclic shift on string s n times. Parameters: s (str): The input string consisting of lowercase letters. n (int): The number of times to perform the right cyclic shift. Returns: str: The resulting string after n right cyclic shifts. Examples: >>> cyclic_shift(\\"hello\\", 1) 'ohell' >>> cyclic_shift(\\"abcd\\", 2) 'cdab' >>> cyclic_shift(\\"xyz\\", 3) 'xyz' >>> cyclic_shift(\\"rotation\\", 4) 'tionrota'","solution":"def cyclic_shift(s: str, n: int) -> str: Perform a right cyclic shift on string s n times. Parameters: s (str): The input string consisting of lowercase letters. n (int): The number of times to perform the right cyclic shift. Returns: str: The resulting string after n right cyclic shifts. if not s: return \\"\\" n = n % len(s) # Calculate effective shifts for cycles larger than string length return s[-n:] + s[:-n]"},{"question":"def sum_of_natural_numbers(N: int) -> int: Given an integer N, return the sum of the first N natural numbers. >>> sum_of_natural_numbers(5) 15 >>> sum_of_natural_numbers(1) 1 >>> sum_of_natural_numbers(1000000) 500000500000 >>> sum_of_natural_numbers(10) 55 >>> sum_of_natural_numbers(100) 5050 >>> sum_of_natural_numbers(1000) 500500 pass","solution":"def sum_of_natural_numbers(N): Returns the sum of the first N natural numbers. return (N * (N + 1)) // 2"},{"question":"def count_distinct_substrings(n: int, s: str) -> int: Calculate the number of distinct substrings of the text after processing the input sequence of characters. Parameters: n : int : length of the sequence of characters s : str : string of length n, consisting of lowercase English letters Returns: int : number of distinct substrings >>> count_distinct_substrings(3, \\"abc\\") 6 >>> count_distinct_substrings(4, \\"aaaa\\") 4","solution":"def count_distinct_substrings(n, s): Returns the number of distinct substrings of the text after processing the input sequence of length n and consisting of lowercase English letters. substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def minimize_max_abs_difference(t: int, test_cases: List[Tuple[int, List[int]]]) -> str: Polycarp wants to rearrange the array such that the absolute difference between any two adjacent elements is minimized. If there are multiple valid arrangements, return the one that is lexicographically smallest. Parameters: t (int): the number of test cases test_cases (List[Tuple[int, List[int]]]): a list of tuples where each tuple contains an integer and a list of integers Returns: str: the rearranged arrays for each test case, separated by new lines Examples: >>> minimize_max_abs_difference(2, [(4, [10, 1, 3, 7]), (3, [4, 2, 5])]) '1 3 7 10n2 4 5' >>> minimize_max_abs_difference(1, [(5, [5, 4, 3, 2, 1])]) '1 2 3 4 5'","solution":"def rearrange_array(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = sorted(test_cases[i][1]) results.append(a) return results def format_results(results): return 'n'.join(' '.join(map(str, result)) for result in results) # Function to execute solution on inputs def minimize_max_abs_difference(t, test_cases): results = rearrange_array(t, test_cases) return format_results(results)"},{"question":"def get_order_statuses(T, log_entries): Determines the current status of each order based on log entries. Args: T (int): Number of log entries log_entries (list of str): List containing log entries with order ID and status Returns: list of str: The current status of each order ID, in the order their ID first appears in the log. >>> get_order_statuses(5, [\\"1 placed\\", \\"1 processed\\", \\"2 placed\\", \\"2 processed\\", \\"1 shipped\\"]) [\\"shipped\\", \\"processed\\"] >>> get_order_statuses(4, [\\"1 placed\\", \\"1 processed\\", \\"1 shipped\\", \\"1 delivered\\"]) [\\"delivered\\"]","solution":"def get_order_statuses(T, log_entries): Determines the current status of each order based on log entries. order_status = {} for entry in log_entries: order_id, status = entry.split() order_id = int(order_id) order_status[order_id] = status ordered_ids = list(dict.fromkeys([int(entry.split()[0]) for entry in log_entries])) return [order_status[order_id] for order_id in ordered_ids]"},{"question":"def total_skyline_area(heights: List[int]) -> int: Calculate the total area covered by the skyline when viewed from the side. Parameters: heights (list of int): List of building heights. Returns: int: Total area covered by the skyline. >>> total_skyline_area([1, 3, 2, 5, 4]) 15 >>> total_skyline_area([5]) 5 >>> total_skyline_area([2, 2, 2, 2, 2]) 10 >>> total_skyline_area([0, 5, 0, 2, 4]) 11 >>> total_skyline_area([100, 200, 300]) 600","solution":"def total_skyline_area(heights): Calculate the total area covered by the skyline when viewed from the side. Parameters: heights (list of int): List of building heights. Returns: int: Total area covered by the skyline. return sum(heights)"},{"question":"class Matrix: Matrix class that supports initialization, addition, multiplication, and transposition operations. Initialization: >>> matrix = Matrix([[1, 2], [3, 4]]) >>> matrix.data [[1, 2], [3, 4]] Addition: >>> matrix1 = Matrix([[1, 2], [3, 4]]) >>> matrix2 = Matrix([[5, 6], [7, 8]]) >>> result = matrix1.add(matrix2) >>> result.data [[6, 8], [10, 12]] Multiplication: >>> matrix1 = Matrix([[1, 2], [3, 4]]) >>> matrix2 = Matrix([[2, 0], [1, 2]]) >>> result = matrix1.multiply(matrix2) >>> result.data [[4, 4], [10, 8]] Transpose: >>> matrix = Matrix([[1, 2], [3, 4]]) >>> matrix.transpose() >>> matrix.data [[1, 3], [2, 4]] def __init__(self, data): Initializes the matrix with a 2D list of numbers. pass def add(self, other): Adds two matrices and returns a new matrix with the result. pass def multiply(self, other): Multiplies two matrices and returns a new matrix with the result. pass def transpose(self): Transposes the matrix (rows become columns and vice versa). pass","solution":"class Matrix: def __init__(self, data): Initializes the matrix with a 2D list of numbers. self.data = data def add(self, other): Adds two matrices and returns a new matrix with the result. rows, cols = len(self.data), len(self.data[0]) result = [[self.data[i][j] + other.data[i][j] for j in range(cols)] for i in range(rows)] return Matrix(result) def multiply(self, other): Multiplies two matrices and returns a new matrix with the result. rows_a, cols_a = len(self.data), len(self.data[0]) rows_b, cols_b = len(other.data), len(other.data[0]) result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += self.data[i][k] * other.data[k][j] return Matrix(result) def transpose(self): Transposes the matrix (rows become columns and vice versa). rows, cols = len(self.data), len(self.data[0]) result = [[self.data[j][i] for j in range(rows)] for i in range(cols)] self.data = result"},{"question":"import math from typing import Tuple def calculate_rounds(teams: int) -> Tuple[int, int]: Given a number of teams, calculate the minimum and maximum number of rounds required to determine the winner in a tournament. Parameters: teams (int): Number of teams participating (always a power of two) Returns: Tuple[int, int]: (min_rounds, max_rounds) >>> calculate_rounds(16) (4, 4) >>> calculate_rounds(1) (0, 0) pass # Test cases def test_calculate_rounds_2_teams(): assert calculate_rounds(2) == (1, 1) def test_calculate_rounds_4_teams(): assert calculate_rounds(4) == (2, 2) def test_calculate_rounds_8_teams(): assert calculate_rounds(8) == (3, 3) def test_calculate_rounds_16_teams(): assert calculate_rounds(16) == (4, 4) def test_calculate_rounds_1_team(): assert calculate_rounds(1) == (0, 0) def test_calculate_rounds_32_teams(): assert calculate_rounds(32) == (5, 5) def test_calculate_rounds_64_teams(): assert calculate_rounds(64) == (6, 6) def test_calculate_rounds_1024_teams(): assert calculate_rounds(1024) == (10, 10)","solution":"import math def calculate_rounds(teams): Given a number of teams, calculate the minimum and maximum number of rounds required to determine the winner in a tournament. Parameters: teams (int): The number of teams participating Returns: min_rounds (int): The minimum number of rounds required max_rounds (int): The maximum number of rounds required (same as min in this case) if teams == 1: return (0, 0) min_rounds = int(math.log2(teams)) # As number of teams is always a power of two, min_rounds is equal to max_rounds max_rounds = min_rounds return (min_rounds, max_rounds)"},{"question":"def count_eligible_employees(n: int, employees: List[Tuple[int, int, int]]) -> int: Determine the number of employees eligible for the pension scheme. An employee is eligible if: 1. Their age is at least 60 years. 2. They have taken less than 15 days of medical leave in the previous year. 3. They have been in service for at least 30 years. Parameters: n (int): The number of employees. employees (List[Tuple[int, int, int]]): A list of n tuples, each tuple contains three integers representing the age, number of medical leave days, and years of service of each employee respectively. Returns: int: The number of employees eligible for the pension scheme. Examples: >>> count_eligible_employees(5, [(62, 12, 31), (58, 10, 35), (70, 14, 29), (65, 20, 32), (60, 5, 40)]) 3 >>> count_eligible_employees(3, [(55, 0, 30), (61, 16, 35), (67, 14, 29)]) 0 >>> count_eligible_employees(4, [(60, 14, 30), (65, 10, 25), (75, 7, 32), (59, 14, 29)]) 2","solution":"def count_eligible_employees(n, employees): This function counts the number of employees eligible for the pension scheme. Parameters: - n: int, the number of employees. - employees: list of tuples, each containing three integers representing the age, number of medical leave days, and years of service of each employee. Returns: - int, the number of employees eligible for the pension scheme. eligible_count = 0 for age, medical_leave, years_of_service in employees: if age >= 60 and medical_leave < 15 and years_of_service >= 30: eligible_count += 1 return eligible_count # Example usage: # n = 5 # employees = [(62, 12, 31), (58, 10, 35), (70, 14, 29), (65, 20, 32), (60, 5, 40)] # print(count_eligible_employees(n, employees))"},{"question":"def calculate_total_points(test_cases): Given the scores of bridges for each test case, determine the total points Rohan has after crossing all n bridges. Args: test_cases (list): A list of tuples, each containing an integer n and a list of n integers representing the scores. Returns: list: A list of integers representing the total points for each test case. Examples: >>> calculate_total_points([(5, [1, 2, 3, 4, 5])]) == [6] >>> calculate_total_points([(4, [-1, -2, -3, -4])]) == [-6] >>> calculate_total_points([(6, [10, 20, 30, 40, 50, 60])]) == [120]","solution":"def calculate_total_points(test_cases): Given the scores of bridges for each test case, determine the total points Rohan has after crossing all n bridges. Args: test_cases (list): A list of tuples, each containing an integer n and a list of n integers representing the scores. Returns: list: A list of integers representing the total points for each test case. results = [] for n, scores in test_cases: total_points = sum(scores[i] for i in range(1, n, 2)) results.append(total_points) return results"},{"question":"from typing import List, Tuple def rectangle_sums(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Generates a matrix of integers and returns the sum of the elements in the specified rectangular area within the matrix. Args: matrix (List[List[int]]): A 2D list of integers where \`matrix[i][j]\` represents the element at row \`i\` and column \`j\`. queries (List[Tuple[int, int, int, int]]): A list of tuples, each containing four integers \`(r1, c1, r2, c2)\` representing the top-left and bottom-right corners of the rectangular sub-matrix. Returns: List[int]: A list of integers where each integer is the sum of the elements in the sub-matrix specified by the corresponding query. Example: >>> rectangle_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(0, 0, 1, 1), (1, 1, 2, 2)]) [12, 28] >>> rectangle_sums([[0, 1, 2], [3, 4, 5], [6, 7, 8]], [(0, 0, 2, 2), (1, 1, 1, 1)]) [36, 4]","solution":"from typing import List, Tuple def rectangle_sums(matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) # Compute the prefix sum matrix prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = matrix[r - 1][c - 1] + prefix_sum[r - 1][c] + prefix_sum[r][c - 1] - prefix_sum[r - 1][c - 1] result = [] for r1, c1, r2, c2 in queries: r1, c1, r2, c2 = r1 + 1, c1 + 1, r2 + 1, c2 + 1 # Convert to 1-based indexing submatrix_sum = (prefix_sum[r2][c2] - prefix_sum[r1 - 1][c2] - prefix_sum[r2][c1 - 1] + prefix_sum[r1 - 1][c1 - 1]) result.append(submatrix_sum) return result"},{"question":"def max_min_product(arr): Given an array of integers \`arr\`, return the product of the maximum and minimum element in the array. >>> max_min_product([3, 5, 1, 9, 2]) 9 >>> max_min_product([-3, 0, 6, -2, 4]) -18 >>> max_min_product([7]) 49 >>> max_min_product([10, 10, 10]) 100","solution":"def max_min_product(arr): Returns the product of the maximum and minimum element in the array. if not arr: # Safety check for empty array, although constraint guarantees at least one element return None max_element = max(arr) min_element = min(arr) return max_element * min_element"},{"question":"def item_collector(items_string): Processes a given string of collected items and stores each item in an array of dictionaries. Parameters: items_string (str): A string containing items details in the format \\"name, type, value,...\\" Returns: list: A list of dictionaries, each containing 'name', 'type', and 'value'. Examples: >>> item_collector(\\"Sword, Weapon, 300, Shield, Armor, 150\\") [{'name': 'Sword', 'type': 'Weapon', 'value': 300}, {'name': 'Shield', 'type': 'Armor', 'value': 150}] >>> item_collector(None) [] >>> item_collector(\\"\\") [] >>> item_collector(\\"Potion, Consumable, 50\\") [{'name': 'Potion', 'type': 'Consumable', 'value': 50}] >>> item_collector(\\" Sword , Weapon , 300 , Shield , Armor , 150 \\") [{'name': 'Sword', 'type': 'Weapon', 'value': 300}, {'name': 'Shield', 'type': 'Armor', 'value': 150}] >>> item_collector(\\"Axe, Weapon, 250, Wand, Magic, 200, Bow, Weapon, 180, Armor, Protection, 150\\") [{'name': 'Axe', 'type': 'Weapon', 'value': 250}, {'name': 'Wand', 'type': 'Magic', 'value': 200}, {'name': 'Bow', 'type': 'Weapon', 'value': 180}, {'name': 'Armor', 'type': 'Protection', 'value': 150}]","solution":"def item_collector(items_string): Processes a given string of collected items and stores each item in an array of dictionaries. Parameters: items_string (str): A string containing items details in the format \\"name, type, value,...\\" Returns: list: A list of dictionaries, each containing 'name', 'type', and 'value'. if not items_string: return [] items_list = items_string.split(',') items = [] for i in range(0, len(items_list), 3): name = items_list[i].strip() type_ = items_list[i+1].strip() value = int(items_list[i+2].strip()) items.append({'name': name, 'type': type_, 'value': value}) return items"},{"question":"def max_fountains_with_overlap(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of fountains that can simultaneously tap water at the same point. >>> max_fountains_with_overlap(3, [(3, [(1, 2), (4, 1), (5, 2)]), (4, [(2, 3), (6, 1), (8, 4), (12, 2)]), (2, [(3, 1), (5, 1)])]) [2, 2, 1]","solution":"def max_fountains_with_overlap(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] fountains = test_cases[i][1] intervals = [(x - r, x + r) for x, r in fountains] points = [] for start, end in intervals: points.append((start, 'start')) points.append((end, 'end')) points.sort() max_overlap = 0 current_overlap = 0 for point, type in points: if type == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) elif type == 'end': current_overlap -= 1 results.append(max_overlap) return results"},{"question":"def find_pairs_with_sum(n: int, arr: List[int], k: int) -> None: Given an array of n unique integers, finds all pairs of elements that sum to a given target value, k. Each pair is printed in ascending order with the smaller integer first. If there are multiple pairs that sum up to the same target value, they are listed in lexicographical order. Example: >>> find_pairs_with_sum(5, [1, 2, 3, 4, 5], 5) 1 4 2 3 >>> find_pairs_with_sum(6, [2, 4, 6, 8, 10, 12], 16) 4 12 6 10","solution":"def find_pairs_with_sum(n, arr, k): Returns all pairs of elements from the array that sum to the given target value k. Each pair is returned in ascending order and all pairs are listed in lexicographical order. pairs = [] s = set(arr) for num in arr: complement = k - num if complement in s and complement > num: pairs.append((num, complement)) pairs.sort() for pair in pairs: print(f\\"{pair[0]} {pair[1]}\\") # Example usage: # find_pairs_with_sum(5, [1, 2, 3, 4, 5], 5)"},{"question":"def minimum_time_to_destination(N: int, v: int, F: int): Determines if it's possible for Marty to reach his destination with the given fuel and calculates the minimum time required to reach there if it's possible. Args: N (int): Distance to destination v (int): Maximum speed per second F (int): Available fuel Returns: float or str: Minimum time required in seconds if possible, otherwise \\"Impossible\\". Examples: >>> minimum_time_to_destination(10, 2, 15) 5.0 >>> minimum_time_to_destination(20, 5, 18) 'Impossible'","solution":"def minimum_time_to_destination(N, v, F): Determines if it's possible for Marty to reach his destination with the given fuel and calculates the minimum time required to reach there if it's possible. Args: N (int): Distance to destination v (int): Maximum speed per second F (int): Available fuel Returns: float or str: Minimum time required in seconds if possible, otherwise \\"Impossible\\". if F < N: return \\"Impossible\\" min_time = N / v return min_time"},{"question":"def max_length_subarray(data_blocks: List[int], threshold: int) -> int: Finds the maximum length of a continuous subarray with sum greater than or equal to the threshold. If no such subarray exists, return 0. :param data_blocks: List of integers representing lengths of data blocks. :param threshold: Integer representing the threshold value. :return: Integer representing the maximum length of the continuous subarray. >>> max_length_subarray([2, 1, 5, 6, 2], 7) 3 >>> max_length_subarray([1, 1, 1], 5) 0","solution":"def max_length_subarray(data_blocks, threshold): Finds the maximum length of a continuous subarray with sum greater than or equal to the threshold. If no such subarray exists, return 0. :param data_blocks: List of integers representing lengths of data blocks. :param threshold: Integer representing the threshold value. :return: Integer representing the maximum length of the continuous subarray. n = len(data_blocks) max_len = 0 current_sum = 0 start = 0 for end in range(n): current_sum += data_blocks[end] while current_sum >= threshold: max_len = max(max_len, end - start + 1) current_sum -= data_blocks[start] start += 1 return max_len"},{"question":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements. >>> max_non_adjacent_sum([10]) 10 >>> max_non_adjacent_sum([2, 4]) 4 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([5, 1, 1, 5]) 10 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([1, 1000000, 1, 1000000]) 2000000","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of non-adjacent elements. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize the two scenarios for DP prev_prev = 0 prev = 0 for num in nums: current = max(prev, prev_prev + num) prev_prev = prev prev = current return prev"},{"question":"def min_leveling_operations(grid): Returns the minimum number of leveling operations required to make the entire plot flat. Args: grid (List[List[int]]): 2D grid representing the height of the terrain. Returns: int: Minimum number of leveling operations required. Examples: >>> min_leveling_operations([[4, 2, 3], [7, 6, 5], [1, 2, 3]]) 14 >>> min_leveling_operations([[1, 2], [2, 3]]) 2 pass def parse_input(input_str): Parse the input string to generate the grid. Args: input_str (str): Input string containing the dimensions and heights of the plot. Returns: List[List[int]]: 2D grid representing the height of the terrain. Examples: >>> parse_input(\\"3 3n4 2 3n7 6 5n1 2 3\\") [[4, 2, 3], [7, 6, 5], [1, 2, 3]] >>> parse_input(\\"2 2n1 2n2 3\\") [[1, 2], [2, 3]] pass","solution":"def min_leveling_operations(grid): Returns the minimum number of leveling operations required to make the entire plot flat. from collections import Counter from statistics import median heights = [] for row in grid: heights.extend(row) median_height = int(median(heights)) operations = sum(abs(h - median_height) for h in heights) return operations def parse_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:n+1]] return grid"},{"question":"def is_valid_bracket_sequence(s: str) -> str: Determine if the provided bracket string is valid. A string of brackets is considered valid if every opening bracket has a corresponding closing bracket and the pairs of brackets are properly nested. Args: s (str): The string containing the bracket sequence. Returns: str: \\"YES\\" if the string is a valid sequence of brackets, otherwise \\"NO\\". Examples: >>> is_valid_bracket_sequence(\\"{[()()]}\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"{[(])}\\") \\"NO\\" >>> is_valid_bracket_sequence(\\"((()))\\") \\"YES\\" >>> is_valid_bracket_sequence(\\"([)]\\") \\"NO\\"","solution":"def is_valid_bracket_sequence(s): Determine if the provided bracket string is valid. A string of brackets is considered valid if every opening bracket has a corresponding closing bracket and the pairs of brackets are properly nested. stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def findPythagoreanTriplet(N: int, arr: list) -> bool: This function checks if there exists a Pythagorean triplet in the given array. A Pythagorean triplet (a, b, c) satisfies a^2 + b^2 = c^2. Parameters: N (int): the number of elements in the array. arr (list of int): the list of distinct integers. Returns: bool: True if there exists a Pythagorean triplet, otherwise False. >>> findPythagoreanTriplet(5, [3, 1, 4, 6, 5]) True >>> findPythagoreanTriplet(3, [1, 2, 3]) False","solution":"def findPythagoreanTriplet(N, arr): This function checks if there exists a Pythagorean triplet in the given array. A Pythagorean triplet (a, b, c) satisfies a^2 + b^2 = c^2. Parameters: N (int): the number of elements in the array. arr (list of int): the list of distinct integers. Returns: bool: True if there exists a Pythagorean triplet, otherwise False. # Step 1: Square each element in the array and store them in a set for quick access squared = set([x ** 2 for x in arr]) # Step 2: Check for each combination of (a, b) if their sum of squares is a square in the set for i in range(N - 1): for j in range(i + 1, N): a2_plus_b2 = arr[i] ** 2 + arr[j] ** 2 if a2_plus_b2 in squared: return True # Step 3: If no such triplet found, return False return False"},{"question":"def is_prime(num: int) -> bool: Check if a number is prime. >>> is_prime(2) == True >>> is_prime(4) == False >>> is_prime(17) == True >>> is_prime(18) == False pass def is_palindrome(num: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(121) == True >>> is_palindrome(123) == False >>> is_palindrome(11) == True >>> is_palindrome(22) == True pass def smallest_prime_palindrome(N: int) -> int: Find the smallest prime palindrome greater than or equal to N. >>> smallest_prime_palindrome(31) == 101 >>> smallest_prime_palindrome(130) == 131 >>> smallest_prime_palindrome(777) == 787 pass def solve(T: int, cases: List[int]) -> List[int]: Solve the problem for given T cases. >>> solve(3, [31, 130, 777]) == [101, 131, 787] >>> solve(2, [1, 2]) == [2, 2] pass","solution":"def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True def is_palindrome(num): return str(num) == str(num)[::-1] def smallest_prime_palindrome(N): while True: if is_palindrome(N) and is_prime(N): return N N += 1 def solve(T, cases): results = [] for N in cases: results.append(smallest_prime_palindrome(N)) return results"},{"question":"from typing import List, Tuple def max_revenue_difference(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum revenue difference between two different months' revenue for each test case, where the revenue from the first month is less than the revenue from the second month. >>> max_revenue_difference([(5, [7, 1, 5, 3, 6])]) == [5] >>> max_revenue_difference([(4, [9, 4, 3, 2])]) == [-1]","solution":"def max_revenue_difference(test_cases): results = [] for case in test_cases: m, revenues = case if m < 2: results.append(-1) continue min_revenue = revenues[0] max_diff = -1 for i in range(1, m): if revenues[i] > min_revenue: max_diff = max(max_diff, revenues[i] - min_revenue) min_revenue = min(min_revenue, revenues[i]) results.append(max_diff) return results"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring within the input string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 def longest_palindromic_substrings(test_cases: List[str]) -> List[int]: Returns a list containing the length of the longest palindromic substring for each string in test_cases. >>> longest_palindromic_substrings([\\"babad\\", \\"cbbd\\"]) [3, 2] >>> longest_palindromic_substrings([\\"a\\", \\"ac\\"]) [1, 1] # Tests def test_longest_palindromic_substring_length(): assert longest_palindromic_substring_length(\\"babad\\") == 3 assert longest_palindromic_substring_length(\\"cbbd\\") == 2 assert longest_palindromic_substring_length(\\"a\\") == 1 assert longest_palindromic_substring_length(\\"ac\\") == 1 assert longest_palindromic_substring_length(\\"racecar\\") == 7 assert longest_palindromic_substring_length(\\"\\") == 0 def test_longest_palindromic_substrings(): assert longest_palindromic_substrings([\\"babad\\", \\"cbbd\\"]) == [3, 2] assert longest_palindromic_substrings([\\"a\\", \\"ac\\"]) == [1, 1] assert longest_palindromic_substrings([\\"racecar\\", \\"\\"]) == [7, 0] assert longest_palindromic_substrings([\\"aaaa\\", \\"baaab\\"]) == [4, 5]","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring within the input string s. n = len(s) if n == 0: return 0 # Create a DP table to store the palindromic status dp = [[False] * n for _ in range(n)] max_length = 1 # Every string with one character is a palindrome for i in range(n): dp[i][i] = True start = 0 # To track the starting index of the longest palindrome # Check for sub-string of length 2. for i in range(n-1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length def longest_palindromic_substrings(test_cases): Returns a list containing the length of the longest palindromic substring for each string in test_cases. results = [] for s in test_cases: results.append(longest_palindromic_substring_length(s)) return results"},{"question":"from typing import List, Tuple def max_non_overlapping_routes(n: int, schedules: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping routes that can be covered by a single driver. >>> max_non_overlapping_routes(5, [(1, 3), (2, 5), (3, 9), (6, 8), (8, 10)]) 3 >>> max_non_overlapping_routes(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4","solution":"def max_non_overlapping_routes(n, schedules): Returns the maximum number of non-overlapping routes. # Sort the schedules by end time schedules.sort(key=lambda x: x[1]) max_routes = 0 current_end_time = -1 for schedule in schedules: start, end = schedule if start >= current_end_time: max_routes += 1 current_end_time = end return max_routes"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing non-negative integers and the operators +, -, and *. >>> evaluate_expression(\\"3+5*2-6\\") 7 >>> evaluate_expression(\\"10*2-5*3+4\\") 9 >>> evaluate_expression(\\"1+2*10-3+4*5\\") 38 def test_case_1(): assert evaluate_expression(\\"3+5*2-6\\") == 7 def test_case_2(): assert evaluate_expression(\\"10*2-5*3+4\\") == 9 def test_case_3(): assert evaluate_expression(\\"1+2*10-3+4*5\\") == 38 def test_case_4(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_case_5(): assert evaluate_expression(\\"2*3+4\\") == 10 def test_case_6(): assert evaluate_expression(\\"10-5*2+3*4\\") == 12 def test_case_7(): assert evaluate_expression(\\"4*5+10-3*2\\") == 24","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and the operators +, -, and *. def apply_op(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == '+': values.append(left + right) elif op == '-': values.append(left - right) elif op == '*': values.append(left * right) i = 0 values = [] operators = [] while i < len(expression): if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 else: if expression[i] == '*': while (operators and operators[-1] == '*'): apply_op(operators, values) operators.append(expression[i]) elif expression[i] in ('+', '-'): while (operators and operators[-1] in ('+', '-', '*')): apply_op(operators, values) operators.append(expression[i]) i += 1 while operators: apply_op(operators, values) return values[0]"},{"question":"def is_tournament_sorted(teams): Check if the list of teams with scores is sorted in descending order based on scores. Args: teams (list of tuples): Each tuple contains a team name (str) and a score (int). Returns: bool: True if the list is sorted in descending order by scores, otherwise False. Example: >>> is_tournament_sorted([(\\"TeamA\\", 3), (\\"TeamB\\", 2), (\\"TeamC\\", 1)]) True >>> is_tournament_sorted([(\\"TeamA\\", 1), (\\"TeamB\\", 2), (\\"TeamC\\", 3)]) False >>> is_tournament_sorted([(\\"TeamA\\", 3), (\\"TeamB\\", 3), (\\"TeamC\\", 3)]) True >>> is_tournament_sorted([]) True >>> is_tournament_sorted([(\\"TeamA\\", 2)]) True","solution":"def is_tournament_sorted(teams): Check if the list of teams with scores is sorted in descending order based on scores. Args: teams (list of tuples): Each tuple contains a team name (str) and a score (int). Returns: bool: True if the list is sorted in descending order by scores, otherwise False. for i in range(len(teams) - 1): if teams[i][1] < teams[i + 1][1]: return False return True"},{"question":"def twoSum(arr, target): Determines if there are two distinct elements in the array such that their sum is equal to the target sum. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: boolean: True if there are two distinct elements that add up to target, False otherwise. >>> twoSum([2, 7, 11, 15], 9) True >>> twoSum([1, 2, 3, 4], 8) False >>> twoSum([-1, 2, 4, 5], 3) True >>> twoSum([3, 1, 3, 5], 6) True >>> twoSum([1, 1, 1, 1], 5) False >>> twoSum([1000, -1000], 0) True # Write your code here","solution":"def twoSum(arr, target): Determines if there are two distinct elements in the array such that their sum is equal to the target sum. Parameters: arr (list of int): The list of integers. target (int): The target sum. Returns: boolean: True if there are two distinct elements that add up to target, False otherwise. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def find_pairs(arr, k): Given an array of integers and a target integer k, find all unique pairs of integers in the array that sum up to the target integer k. >>> find_pairs([2, 7, 11, 15, 1], 9) [(2, 7)] >>> find_pairs([1, 5, 3, 3], 6) [(1, 5), (3, 3)] >>> find_pairs([3, 4, 8], 10) [] # Your implementation here def process_test_cases(test_cases): Given a list of test cases, return a list of results for each test case. Each test case is a pair of (array, target) and the result is the list of unique pairs that sum up to the target. >>> process_test_cases([([2, 7, 11, 15, 1], 9), ([1, 5, 3, 3], 6), ([3, 4, 8], 10)]) [[(2, 7)], [(1, 5), (3, 3)], []] # Your implementation here import unittest class TestSolution(unittest.TestCase): def test_find_pairs_example_1(self): self.assertEqual(find_pairs([2, 7, 11, 15, 1], 9), [(2, 7)]) def test_find_pairs_example_2(self): self.assertEqual(find_pairs([1, 5, 3, 3], 6), [(1, 5), (3, 3)]) def test_find_pairs_example_3(self): self.assertEqual(find_pairs([3, 4, 8], 10), []) def test_process_test_cases(self): test_cases = [ ([2, 7, 11, 15, 1], 9), ([1, 5, 3, 3], 6), ([3, 4, 8], 10) ] self.assertEqual(process_test_cases(test_cases), [ [(2, 7)], [(1, 5), (3, 3)], [] ]) def test_find_pairs_empty_array(self): self.assertEqual(find_pairs([], 5), []) def test_find_pairs_no_pairs(self): self.assertEqual(find_pairs([1, 2, 3, 4, 5], 10), []) def test_find_pairs_multiple_pairs(self): self.assertEqual(find_pairs([1, 2, 3, 4, 4, 5], 6), [(1, 5), (2, 4)]) def test_find_pairs_with_negatives(self): self.assertEqual(find_pairs([-1, -2, -3, 3, 2, 1], 0), [(-3, 3), (-2, 2), (-1, 1)]) if __name__ == \\"__main__\\": unittest.main()","solution":"def find_pairs(arr, k): Given an array of integers and a target integer k, find all unique pairs of integers in the array that sum up to the target integer k. pairs = set() seen = set() for number in arr: complement = k - number if complement in seen: pairs.add((min(number, complement), max(number, complement))) seen.add(number) return sorted(pairs) def process_test_cases(test_cases): results = [] for arr, k in test_cases: pairs = find_pairs(arr, k) results.append(pairs) return results"},{"question":"def total_returned_coins(k: int, coins: List[int]) -> int: Returns the total number of gold coins returned to the treasury by all the knights. Parameters: k (int): The number of knights. coins (list): A list of integers representing the number of gold coins each knight received. Returns: int: Total number of gold coins returned to the treasury. >>> total_returned_coins(3, [4, 10, 6]) == 10 >>> total_returned_coins(4, [8, 8, 8, 8]) == 16 >>> total_returned_coins(2, [1000000, 1000000]) == 1000000 >>> total_returned_coins(1, [2]) == 1 >>> total_returned_coins(5, [2, 4, 6, 8, 10]) == 15 >>> total_returned_coins(1000, [2] * 1000) == 1000","solution":"def total_returned_coins(k, coins): Returns the total number of gold coins returned to the treasury by all the knights. Parameters: k (int): The number of knights. coins (list): A list of integers representing the number of gold coins each knight received. Returns: int: Total number of gold coins returned to the treasury. # Each knight returns half of their coins return sum(coin // 2 for coin in coins)"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. Args: s: A string whose longest substring without repeating characters is to be found. Returns: An integer representing the length of the longest substring without repeating characters. Example: >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"abcdabc\\") 4 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. max_len = 0 start = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_len = max(max_len, i - start + 1) used_chars[char] = i return max_len"},{"question":"def unique_paths(n: int, m: int, grid: List[List[str]]) -> int: Returns the number of unique paths from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid of size n x m. >>> unique_paths(2, 2, [['.', '.'], ['.', '.']]) == 2 >>> unique_paths(2, 2, [['.', '#'], ['.', '.']]) == 1 >>> unique_paths(3, 3, [['.', '.', '#'], ['.', '#', '.'], ['#', '.', '.']]) == 0 pass def test_unique_paths_basic(): assert unique_paths(2, 2, [['.', '.'], ['.', '.']]) == 2 def test_unique_paths_with_block(): assert unique_paths(2, 2, [['.', '#'], ['.', '.']]) == 1 def test_unique_paths_no_path(): assert unique_paths(3, 3, [['.', '.', '#'], ['.', '#', '.'], ['#', '.', '.']]) == 0 def test_unique_paths_larger_grid(): assert unique_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) == 2 def test_unique_paths_single_row(): assert unique_paths(1, 3, [['.', '.', '.']]) == 1 def test_unique_paths_single_column(): assert unique_paths(3, 1, [['.'], ['.'], ['.']]) == 1 def test_unique_paths_all_blocks(): assert unique_paths(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.']]) == 0","solution":"def unique_paths(n, m, grid): Returns the number of unique paths from the top-left corner (1, 1) to the bottom-right corner (n, m) in a grid of size n x m. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 # Initialize a 2D DP array with zeros dp = [[0 for _ in range(m)] for _ in range(n)] # Set the starting point dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '.': # Add paths from the left cell if it's within bounds if j > 0: dp[i][j] += dp[i][j - 1] # Add paths from the top cell if it's within bounds if i > 0: dp[i][j] += dp[i - 1][j] return dp[n - 1][m - 1]"},{"question":"def can_reach_end(n: int, m: int, grid: List[str]) -> str: Determines if the robot can reach (n, m) from (1, 1). Args: n (int): Number of rows. m (int): Number of columns. grid (List[str]): n rows of strings representing the grid. Returns: str: \\"YES\\" if the robot can reach the destination, \\"NO\\" otherwise. Example: >>> can_reach_end(4, 4, [\\"....\\", \\"..\\", \\"..#.\\", \\"....\\"]) \\"YES\\" >>> can_reach_end(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"]) \\"NO\\"","solution":"def can_reach_end(n, m, grid): Determines if the robot can reach (n, m) from (1, 1). Args: n (int): Number of rows. m (int): Number of columns. grid (List[str]): n rows of strings representing the grid. Returns: str: \\"YES\\" if the robot can reach the destination, \\"NO\\" otherwise. from collections import deque # Check boundary conditions for the start and end points if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we have reached the bottom-right cell if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def largest_sum_submatrix(matrix: List[List[int]]) -> int: Find the largest sum of any contiguous submatrix within the given MxN matrix. Args: matrix: List of lists of integers representing the MxN matrix. Returns: The largest sum of any contiguous submatrix. >>> largest_sum_submatrix([[1, -2, 1, 0], [-1, 3, 4, -5], [2, -1, 2, 1], [-3, 4, -2, 1]]) 10 >>> largest_sum_submatrix([[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) 29","solution":"def largest_sum_submatrix(matrix): if not matrix or not matrix[0]: return 0 max_sum = float('-inf') n_rows, n_cols = len(matrix), len(matrix[0]) for left in range(n_cols): temp_row_sum = [0] * n_rows for right in range(left, n_cols): for row in range(n_rows): temp_row_sum[row] += matrix[row][right] # Using Kadane's algorithm to find the maximum sum subarray for each pair of columns current_max = temp_row_sum[0] global_max = temp_row_sum[0] for k in range(1, len(temp_row_sum)): current_max = max(temp_row_sum[k], current_max + temp_row_sum[k]) global_max = max(global_max, current_max) max_sum = max(max_sum, global_max) return max_sum"},{"question":"def min_removals_to_palindrome(s: str) -> int: Calculates the minimum number of characters to be removed to transform the input string into a palindrome. >>> min_removals_to_palindrome(\\"abbaa\\") 1 >>> min_removals_to_palindrome(\\"aabab\\") 2 >>> min_removals_to_palindrome(\\"racecar\\") 0 >>> min_removals_to_palindrome(\\"abc\\") 2 >>> min_removals_to_palindrome(\\"a\\") 0 >>> min_removals_to_palindrome(\\"aa\\") 0 >>> min_removals_to_palindrome(\\"ab\\") 1 >>> min_removals_to_palindrome(\\"aaa\\") 0 >>> min_removals_to_palindrome(\\"aabb\\") 2","solution":"def min_removals_to_palindrome(s): Calculates the minimum number of characters to be removed to transform the input string into a palindrome. n = len(s) # Create a DP table where dp[i][j] represents the minimum number of removals # to make the substring s[i:j+1] a palindrome. dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n + 1): # length of substrings for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"def process_queries(n: int, m: int, initial_roads: List[Tuple[int, int]], q: int, queries: List[Tuple[int, ...]]) -> List[int]: In a kingdom represented by a graph with towns as nodes and roads as edges, process queries to build or destroy roads, and check the number of connected components. >>> process_queries(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 5, [(3,), (2, 2, 3), (3,), (1, 2, 5), (3,)]) [1, 2, 1] >>> process_queries(1, 0, [], 1, [(3,)]) [1] >>> process_queries(4, 0, [], 4, [(3,), (1, 1, 2), (3,), (1, 2, 3)]) [4, 3, 2] >>> process_queries(3, 2, [(1, 2), (2, 3)], 6, [(3,), (2, 1, 2), (3,), (2, 1, 2), (3,), (1, 1, 3), (3,)]) [1, 2, 2, 1] >>> process_queries(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 7, [(3,), (2, 3, 4), (3,), (2, 1, 2), (3,), (1, 1, 6), (3,)]) [1, 2, 3, 2]","solution":"class UnionFind: def __init__(self, n): self.n = n self.parent = list(range(n)) self.rank = [1] * n self.components = n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 self.components -= 1 def connected_components(self): return self.components def process_queries(n, m, initial_roads, q, queries): uf = UnionFind(n) road_set = set() for u, v in initial_roads: uf.union(u - 1, v - 1) road_set.add((u, v)) road_set.add((v, u)) result = [] for query in queries: if query[0] == 1: u, v = query[1], query[2] if (u, v) not in road_set: uf.union(u - 1, v - 1) road_set.add((u, v)) road_set.add((v, u)) elif query[0] == 2: u, v = query[1], query[2] if (u, v) in road_set: road_set.remove((u, v)) road_set.remove((v, u)) # Recompute connected components (expensive but simplifies code) uf = UnionFind(n) for road in road_set: uf.union(road[0] - 1, road[1] - 1) elif query[0] == 3: result.append(uf.connected_components()) return result"},{"question":"def max_subarray_sum(arr, L): Calculate the maximum sum of any subarray of length exactly L. Arguments: arr - List of integers representing the array L - Length of the subarray Returns: The maximum sum of any subarray of length exactly L, or -1 if no such subarray exists. >>> max_subarray_sum([1, 2, 3, 4, 5], 3) 12 >>> max_subarray_sum([-1, -2, 3, 4, -1, 2, 1], 4) 8 >>> max_subarray_sum([1, 2, 3], 4) -1 >>> max_subarray_sum([0, 0, 0, 0, 0], 2) 0 >>> max_subarray_sum([-1, -2, -3, -4], 2) -3 def process_test_cases(T, cases): Process multiple test cases for finding the maximum sum of subarrays. Arguments: T - Number of test cases cases - List of tuples where each tuple contains: (N - Length of the array, L - Length of the subarray, arr - List of integers representing the array) Returns: A list of results for each test case. >>> cases = [(5, 3, [1, 2, 3, 4, 5]), (7, 4, [-1, -2, 3, 4, -1, 2, 1])] >>> process_test_cases(2, cases) [12, 8] >>> cases = [(5, 5, [1, 2, 3, 4, 5]), (7, 7, [-1, -2, 3, 4, -1, 2, 1])] >>> process_test_cases(2, cases) [15, 6] from solution import max_subarray_sum, process_test_cases def test_max_subarray_sum_basic(): assert max_subarray_sum([1, 2, 3, 4, 5], 3) == 12 assert max_subarray_sum([-1, -2, 3, 4, -1, 2, 1], 4) == 8 assert max_subarray_sum([1], 1) == 1 assert max_subarray_sum([1, -2, 3, 4, -5, 6], 2) == 7 def test_max_subarray_sum_edge_cases(): assert max_subarray_sum([1, 2, 3], 4) == -1 assert max_subarray_sum([0, 0, 0, 0, 0], 2) == 0 assert max_subarray_sum([-1, -2, -3, -4], 2) == -3 def test_process_test_cases(): cases = [ (5, 3, [1, 2, 3, 4, 5]), (7, 4, [-1, -2, 3, 4, -1, 2, 1]), ] T = 2 expected_results = [12, 8] assert process_test_cases(T, cases) == expected_results cases = [ (5, 5, [1, 2, 3, 4, 5]), (7, 7, [-1, -2, 3, 4, -1, 2, 1]), ] T = 2 expected_results = [15, 6] assert process_test_cases(T, cases) == expected_results","solution":"def max_subarray_sum(arr, L): n = len(arr) if L > n: return -1 # Calculate the sum of the first subarray of length L max_sum = current_sum = sum(arr[:L]) # Use sliding window approach for the rest of the subarrays for i in range(L, n): current_sum += arr[i] - arr[i - L] if current_sum > max_sum: max_sum = current_sum return max_sum def process_test_cases(T, cases): results = [] for i in range(T): N, L, arr = cases[i] result = max_subarray_sum(arr, L) results.append(result) return results"},{"question":"def longest_concatenated_word(words: List[str]) -> str: Find the longest word in the list that can be constructed by concatenating other words from the list. Each word in the list can be used more than once. If there is a tie, return any one of them. If no such word exists, return an empty string. >>> longest_concatenated_word([\\"cat\\", \\"dog\\", \\"catdog\\"]) == \\"catdog\\" >>> longest_concatenated_word([\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == \\"pineapple\\" >>> longest_concatenated_word([\\"helloworld\\", \\"hello\\", \\"world\\", \\"hi\\"]) == \\"helloworld\\" >>> longest_concatenated_word([\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) in [\\"ab\\", \\"abc\\"]","solution":"def longest_concatenated_word(words): word_set = set(words) max_word = \\"\\" def can_form(word): if word in memo: return memo[word] for i in range(1, len(word)): prefix, suffix = word[:i], word[i:] if prefix in word_set and (suffix in word_set or can_form(suffix)): memo[word] = True return True memo[word] = False return False memo = {} for word in words: if can_form(word): if len(word) > len(max_word): max_word = word return max_word"},{"question":"def is_symmetric_possible(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines if the sequence can be rearranged to be symmetric around a pivot. Args: t (int): The number of test cases. test_cases (list): A list of tuples, each containing: - n (int): The length of the sequence. - pivot (int): The pivot index. - seq (list): The sequence of integers. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. >>> t = 1 >>> test_cases = [(5, 2, [1, 2, 3, 2, 1])] >>> is_symmetric_possible(t, test_cases) ['YES'] >>> t = 2 >>> test_cases = [(6, 3, [1, 2, 3, 4, 3, 2]), (5, 4, [1, 2, 3, 4, 5])] >>> is_symmetric_possible(t, test_cases) ['NO', 'NO']","solution":"def is_symmetric_possible(t, test_cases): Determines if the sequence can be rearranged to be symmetric around a pivot. Args: t (int): The number of test cases. test_cases (list): A list of tuples, each containing: - n (int): The length of the sequence. - pivot (int): The pivot index. - seq (list): The sequence of integers. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for n, pivot, seq in test_cases: left_part = seq[:pivot] right_part = seq[pivot+1:] if sorted(left_part) == sorted(right_part): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example use case if __name__ == \\"__main__\\": t = 3 test_cases = [ (5, 2, [1, 2, 3, 2, 1]), (6, 3, [1, 2, 3, 4, 3, 2]), (5, 4, [1, 2, 3, 4, 5]) ] print(is_symmetric_possible(t, test_cases)) # Output should be ['YES', 'NO', 'NO']"},{"question":"from typing import List def min_steps(grid: List[str]) -> int: Find the minimum number of steps required to move from the top-left corner of the grid to the bottom-right corner. Return -1 if no such path exists. >>> min_steps([\\"..#\\", \\".#.\\", \\"...\\"]) 4 >>> min_steps([\\".#.\\", \\"#\\", \\".#.\\"]) -1 pass def solve_min_steps(t: int, test_cases: List[List]) -> List[int]: Solve the problem for multiple test cases. >>> solve_min_steps(2, [ [3, \\"..#\\", \\".#.\\", \\"...\\"], [3, \\".#.\\", \\"#\\", \\".#.\\"] ]) [4, -1] pass","solution":"from collections import deque def min_steps(grid): N = len(grid) if grid[0][0] == '#' or grid[N-1][N-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == N-1 and c == N-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 def solve_min_steps(t, test_cases): results = [] for i in range(t): N = test_cases[i][0] grid = test_cases[i][1:] results.append(min_steps(grid)) return results"},{"question":"def encrypt(msg, shifts): Encrypt the message using a Caesar cipher with variable shifts. Parameters: msg (str): The plaintext message to be encrypted. shifts (list): The list of shifts corresponding to each character in the message. Returns: str: The encrypted message. pass def decrypt(encrypted_msg, shifts): Decrypt the message using a Caesar cipher with variable shifts. Parameters: encrypted_msg (str): The encrypted message to be decrypted. shifts (list): The list of shifts that were used to encrypt the original message. Returns: str: The decrypted (original) message. pass # Example usage: # encrypted_message = encrypt(\\"hello\\", [1, 2, 3, 4, 5]) # print(encrypted_message) # Output: igopt # decrypted_message = decrypt(encrypted_message, [1, 2, 3, 4, 5]) # print(decrypted_message) # Output: hello","solution":"def encrypt(msg, shifts): Encrypt the message using a Caesar cipher with variable shifts. Parameters: msg (str): The plaintext message to be encrypted. shifts (list): The list of shifts corresponding to each character in the message. Returns: str: The encrypted message. encrypted_message = [] for i, char in enumerate(msg): new_char = chr(((ord(char) - ord('a') + shifts[i]) % 26) + ord('a')) encrypted_message.append(new_char) return ''.join(encrypted_message) def decrypt(encrypted_msg, shifts): Decrypt the message using a Caesar cipher with variable shifts. Parameters: encrypted_msg (str): The encrypted message to be decrypted. shifts (list): The list of shifts that were used to encrypt the original message. Returns: str: The decrypted (original) message. decrypted_message = [] for i, char in enumerate(encrypted_msg): new_char = chr(((ord(char) - ord('a') - shifts[i]) % 26) + ord('a')) decrypted_message.append(new_char) return ''.join(decrypted_message)"},{"question":"def transform_array(n: int, a: List[int]) -> List[int]: Transform an array \`a\` into another array \`b\` such that: 1. Each element in \`b\` is greater than or equal to the corresponding element in \`a\`. 2. The sum of elements in \`b\` is S + k (k being a positive integer, S being the sum of elements in \`a\`). 3. No two adjacent elements in \`b\` are the same. Parameters: n (int): The number of elements in the array. a (List[int]): The input array. Returns: List[int]: The transformed array \`b\`. Example: >>> transform_array(4, [1, 2, 3, 4]) [2, 3, 5, 5] >>> transform_array(3, [5, 6, 7]) [6, 7, 8]","solution":"def transform_array(n, a): Transforms array a into array b such that: 1. Each element in b is greater or equal to the corresponding element in a. 2. The sum of elements in b is S + k (k being a positive integer). 3. No two adjacent elements in b are the same. Parameters: n (int): The number of elements in the array. a (list of int): The input array. Returns: list: The transformed array b. S = sum(a) k = 1 b = [0] * n b[0] = a[0] + 1 for i in range(1, n): b[i] = max(b[i-1] + 1, a[i] + 1) b_sum = sum(b) k = (b_sum - S) return b"},{"question":"def max_balloons_to_burst(heights: List[int]) -> int: Given a list of integers representing balloon heights, calculates the maximum number of balloons that can be burst in a single jump. :param heights: List[int] - list of non-negative integers representing balloon heights. :return: int - maximum number of balloons that can be burst in a single jump. >>> max_balloons_to_burst([3, 3, 3, 3]) 4 >>> max_balloons_to_burst([3, 1, 2, 1, 4, 5, 2, 3]) 8 >>> max_balloons_to_burst([1, 2, 3, 2, 1]) 5 >>> max_balloons_to_burst([5, 4, 3, 2, 1]) 5 >>> max_balloons_to_burst([4, 3, 3, 1, 2, 4, 2]) 7 >>> max_balloons_to_burst([3]) 1 >>> max_balloons_to_burst([1]*100000) 100000 >>> max_balloons_to_burst([]) 0","solution":"def max_balloons_to_burst(heights): Given a list of integers representing balloon heights, calculates the maximum number of balloons that can be burst in a single jump. :param heights: List[int] - list of non-negative integers representing balloon heights. :return: int - maximum number of balloons that can be burst in a single jump. if not heights: return 0 max_height = max(heights) return heights.count(max_height) + sum(height < max_height for height in heights)"},{"question":"def max_profit(data): Returns the maximum profit one can achieve from buying and selling the stock. If no profit is possible, returns 0. pass def test_max_profit_example1(): data = [7,1,5,3,6,4] assert max_profit(data) == 5 def test_max_profit_example2(): data = [7,6,4,3,1] assert max_profit(data) == 0 def test_max_profit_single_element(): data = [5] assert max_profit(data) == 0 def test_max_profit_no_profit(): data = [5, 4, 3, 2, 1] assert max_profit(data) == 0 def test_max_profit_buy_and_sell_same_day(): data = [1, 1, 1, 1, 1] assert max_profit(data) == 0 def test_max_profit_profit_at_end(): data = [2, 4, 1, 7, 5, 9] assert max_profit(data) == 8 def test_max_profit_profit_at_start(): data = [1, 7, 5, 3, 6, 4] assert max_profit(data) == 6 def test_max_profit_empty_data(): data = [] assert max_profit(data) == 0","solution":"def max_profit(data): Returns the maximum profit one can achieve from buying and selling the stock. If no profit is possible, returns 0. if not data or len(data) < 2: return 0 min_price = data[0] max_profit = 0 for price in data[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def largest_square_of_dots(n: int, m: int, grid: List[str]) -> int: Find the largest square of size k x k that can be formed such that all the cells in that square are filled with '.' (dots). >>> largest_square_of_dots(5, 6, [ ... \\"....#.\\", ... \\"....\\", ... \\"....\\", ... \\"....#.\\", ... \\"#.....\\" ... ]) 4 >>> largest_square_of_dots(3, 3, [ ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ]) 0 >>> largest_square_of_dots(4, 4, [ ... \\"....\\", ... \\"..#.\\", ... \\"....\\", ... \\"....\\" ... ]) 4","solution":"def largest_square_of_dots(n, m, grid): # Create a DP table to store the size of the largest square that can be formed ending at (i, j) dp = [[0] * m for _ in range(n)] max_square_size = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_size = max(max_square_size, dp[i][j]) return max_square_size ** 2"},{"question":"def secret_santa(n: int) -> List[Tuple[int, int]]: Generates possible allocation of gift exchanges for secret Santa. Args: n (int): Number of friends Returns: List[Tuple[int, int]]: List containing tuples where each tuple represents the giver and receiver of a gift. >>> secret_santa(3) [(1, 2), (2, 3), (3, 1)] >>> secret_santa(4) [(1, 2), (2, 3), (3, 4), (4, 1)] >>> secret_santa(5) [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]","solution":"def secret_santa(n): Generates possible allocation of gift exchanges for secret Santa. Args: n (int): Number of friends Returns: List[Tuple[int, int]]: List containing tuples where each tuple represents the giver and receiver of a gift. return [(i, (i % n) + 1) for i in range(1, n + 1)]"},{"question":"def final_position(steps): Calculates the final position on the number line after executing all the steps. Args: steps (list of int): The list of steps, positive for forward, negative for backward. Returns: int: The final position on the number line. >>> final_position([3, -2, 4, -1, 2]) 6 >>> final_position([10, -8, 5, -6, 3, -4, 7]) 7 >>> final_position([1, 2, 3, 4, 5]) 15 >>> final_position([-1, -2, -3, -4, -5]) -15 >>> final_position([100, -50, 25, -25, 10, -10]) 50 >>> final_position([]) 0 # Implement the function to calculate the final position","solution":"def final_position(steps): Calculates the final position on the number line after executing all the steps. Args: steps (list of int): The list of steps, positive for forward, negative for backward. Returns: int: The final position on the number line. return sum(steps)"},{"question":"def daily_temperatures(T: List[int]) -> List[int]: Given a list of daily temperatures T, returns a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([90, 80, 70, 60, 50]) == [0, 0, 0, 0, 0] >>> daily_temperatures([50, 55, 60, 65, 70]) == [1, 1, 1, 1, 0] >>> daily_temperatures([70, 70, 70, 70, 70]) == [0, 0, 0, 0, 0] >>> daily_temperatures([70]) == [0]","solution":"def daily_temperatures(T): Given a list of daily temperatures T, returns a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. n = len(T) result = [0] * n stack = [] for i in range(n): while stack and T[i] > T[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def raceTimes(times): Given a 2D array of positive integers where each subarray represents the times for one competitor across all stages, return an array of integers where each element represents the total race time for each competitor. Args: times (list of list of int): 2D array representing the race times of competitors Returns: list of int: Total race time for each competitor Examples: >>> raceTimes([[10, 15, 20], [12, 18, 22], [14, 20, 13]]) [45, 52, 47] >>> raceTimes([[25, 35, 45, 55], [30, 40, 50, 60], [20, 30, 40, 50]]) [160, 180, 140] >>> raceTimes([[8], [10], [15]]) [8, 10, 15]","solution":"def raceTimes(times): Given a 2D array of positive integers where each subarray represents the times for one competitor across all stages, return an array of integers where each element represents the total race time for each competitor. Args: times (list of list of int): 2D array representing the race times of competitors Returns: list of int: Total race time for each competitor return [sum(competitor_times) for competitor_times in times]"},{"question":"def min_changes_to_avoid_repeats(s: str) -> int: Given a string of lowercase alphabets, find the minimum number of characters to change so that no two neighboring characters are the same. >>> min_changes_to_avoid_repeats(\\"aab\\") 1 >>> min_changes_to_avoid_repeats(\\"aaaa\\") 3 >>> min_changes_to_avoid_repeats(\\"abcdefgh\\") 0 >>> min_changes_to_avoid_repeats(\\"abacabadabacaba\\") 0","solution":"def min_changes_to_avoid_repeats(s): This function calculates the minimum number of changes to be made to the string such that no two adjacent characters are the same. changes = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: changes += 1 return changes"},{"question":"def totalHikeDistance(d: int, hikes: List[Tuple[int, List[int]]]) -> List[int]: Calculate the total distance hiked each day given the maximum number of segments and their distances. Parameters: d (int): Number of days. hikes (list of tuple): List where each element is a tuple containing k and the distances for that day. Returns: list of int: The total distance hiked each day. >>> totalHikeDistance(2, [(3, [5, 10, 15]), (2, [7, 14])]) [30, 21] >>> totalHikeDistance(1, [(4, [1, 2, 3, 4])]) [10] >>> totalHikeDistance(1, [(5, [100, 200, 300, 400, 500])]) [1500] >>> totalHikeDistance(2, [(3, [1, 1, 1]), (3, [10, 20, 30])]) [3, 60] >>> totalHikeDistance(1, [(1, [3])]) [3]","solution":"def totalHikeDistance(d, hikes): Calculate total distance hiked for each day given maximum number of segments and their distances. Parameters: d (int): Number of days. hikes (list of tuple): List where each element is a tuple containing k and the distances for that day. Returns: list of int: The total distance hiked each day. result = [] for k, distances in hikes: result.append(sum(distances[:k])) return result # Sample usage: # d = 2 # hikes = [(3, [5, 10, 15]), (2, [7, 14])] # print(totalHikeDistance(d, hikes)) # Output: [30, 21]"},{"question":"def findPrimeFactors(n: int) -> List[int]: Returns a list of prime factors of n in sorted order. If n has no prime factors, return [-1]. >>> findPrimeFactors(28) [2, 7] >>> findPrimeFactors(1) [-1] >>> findPrimeFactors(37) [37]","solution":"def findPrimeFactors(n): Returns a list of prime factors of n in sorted order. If n has no prime factors, return [-1]. if n == 1: return [-1] prime_factors = [] # Check for number of 2s that divide n while n % 2 == 0: if 2 not in prime_factors: prime_factors.append(2) n = n // 2 # n must be odd at this point. So a skip of 2 (i.e i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): # while i divides n, add i and divide n while n % i == 0: if i not in prime_factors: prime_factors.append(i) n = n // i # Condition if n is a prime number greater than 2 if n > 2: prime_factors.append(n) return prime_factors"},{"question":"def unique_paths(grid: List[List[str]]) -> int: Determine the number of unique paths from the top-left corner to the bottom-right corner of grid. A path is valid if it only moves through empty cells and does not pass through any blocked cells. Two paths are considered unique if they differ in the sequence of cells they pass through. >>> unique_paths([['.', '#', '#'], ['.', '.', '#'], ['.', '.', '.']]) 2 >>> unique_paths([['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '.', '#'], ['.', '.', '.', '.']]) 4 >>> unique_paths([['.', '#'], ['#', '.']]) 0 >>> unique_paths([['.']]) 1 >>> unique_paths([['#']]) 0 >>> unique_paths([['.', '#'], ['.', '.']]) 1 >>> unique_paths([['.', '.'], ['.', '.']]) 2","solution":"def unique_paths(grid): n = len(grid) dp = [[0] * n for _ in range(n)] if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1] # Example usage: # grid = [ # ['.', '#', '#'], # ['.', '.', '#'], # ['.', '.', '.'] # ] # print(unique_paths(grid)) # Output: 2"},{"question":"def min_difference_between_subsequences(n: int, calories: List[int]) -> int: Find the minimum possible difference between the sums of the two subsequences. >>> min_difference_between_subsequences(4, [1, 2, 3, 4]) 0 >>> min_difference_between_subsequences(5, [10, 20, 15, 5, 25]) 5","solution":"def min_difference_between_subsequences(n, items): total_sum = sum(items) target = total_sum // 2 dp = [0] * (target + 1) for item in items: for j in range(target, item - 1, -1): dp[j] = max(dp[j], dp[j - item] + item) sum1 = dp[target] sum2 = total_sum - sum1 return abs(sum1 - sum2)"},{"question":"def can_form_string(T: str, m: int, strings: List[Tuple[int, str]]) -> str: Verify if the target string T can be formed by concatenating strings from the list. >>> can_form_string(\\"helloworld\\", 3, [(1, \\"hello\\"), (1, \\"world\\"), (0, \\"er\\")]) == \\"YES\\" >>> can_form_string(\\"codingtest\\", 2, [(1, \\"code\\"), (1, \\"test\\")]) == \\"NO\\"","solution":"def can_form_string(T, m, strings): mandatory = [] optional = [] for c, s in strings: if c == 1: mandatory.append(s) else: optional.append(s) # Look for all mandatory strings in T for s in mandatory: pos = T.find(s) if pos == -1: return \\"NO\\" else: T = T[:pos] + T[pos+len(s):] # Try to match the remaining T using optional strings dp = [False] * (len(T) + 1) dp[0] = True for i in range(len(T)): if dp[i]: for opt in optional: if T.startswith(opt, i): dp[i + len(opt)] = True return \\"YES\\" if dp[len(T)] else \\"NO\\""},{"question":"def count_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph with N nodes and M edges. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int]]): A list of edges, where each edge is represented by a tuple of two integers. Returns: int: The number of connected components in the graph. Examples: >>> count_connected_components(6, 5, [(1, 2), (2, 3), (3, 4), (5, 6)]) 2 >>> count_connected_components(4, 2, [(1, 2), (3, 4)]) 2","solution":"def count_connected_components(n, m, edges): def dfs(node, visited, adjacency_list): stack = [node] while stack: u = stack.pop() for neighbor in adjacency_list[u]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) adjacency_list = {i: [] for i in range(1, n + 1)} for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = {i: False for i in range(1, n + 1)} connected_components = 0 for node in range(1, n + 1): if not visited[node]: visited[node] = True dfs(node, visited, adjacency_list) connected_components += 1 return connected_components # Example usage n, m = 6, 5 edges = [(1, 2), (2, 3), (3, 4), (5, 6)] print(count_connected_components(n, m, edges)) # Output: 2"},{"question":"def min_sum_of_conflicts(n: int, heights: List[int]) -> int: Given an array of integers representing the heights of students standing in a line, the teacher wants to arrange the students in a way that the sum of the conflicts between each student and their next neighbor is minimized. A conflict between two students is defined as the absolute difference in their heights. This function rearranges the students to minimize the sum of conflicts and returns the minimum sum. Parameters: n (int): The number of students heights (list of int): The heights of the students Returns: int: The minimum sum of conflicts >>> min_sum_of_conflicts(5, [1, 5, 3, 2, 4]) 4 >>> min_sum_of_conflicts(4, [4, 2, 1, 3]) 3","solution":"def min_sum_of_conflicts(n, heights): This function returns the minimum sum of conflicts when students are arranged to minimize the absolute differences between the heights of adjacent students. Parameters: n (int): The number of students heights (list of int): The heights of the students Returns: int: The minimum sum of conflicts heights.sort() min_conflict_sum = 0 for i in range(n - 1): min_conflict_sum += abs(heights[i] - heights[i + 1]) return min_conflict_sum"},{"question":"def max_books(n: int, h: int, hours: List[int]) -> int: Returns the maximum number of books that Masha can read completely within her flexible schedule. :param n: Number of books :param h: Total number of flexible hours :param hours: A list of integers where each integer is the number of hours required to read the corresponding book :return: Maximum number of books that can be read completely >>> max_books(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_books(3, 7, [2, 2, 3]) 3 >>> max_books(4, 5, [6, 2, 3, 1]) 2 >>> max_books(3, 0, [2, 2, 3]) 0 >>> max_books(1, 5, [5]) 1 >>> max_books(1, 4, [5]) 0 >>> max_books(4, 10, [2, 2, 3, 3]) 4 >>> max_books(4, 5, [3, 1, 6, 2]) 2 >>> max_books(1000, 10000, [1000 for _ in range(1000)]) 10","solution":"def max_books(n, h, hours): Returns the maximum number of books that Masha can read completely within her flexible schedule. :param n: Number of books :param h: Total number of flexible hours :param hours: A list of integers where each integer is the number of hours required to read the corresponding book :return: Maximum number of books that can be read completely hours.sort() books_read = 0 total_hours = 0 for i in range(n): if total_hours + hours[i] <= h: total_hours += hours[i] books_read += 1 else: break return books_read"},{"question":"def calculate_scores(N, Emma, M, Olivia): Calculate the final scores of both Emma and Olivia. >>> calculate_scores(4, [3, 2, 1, 4], 3, [5, -1, 2]) (6, 6) >>> calculate_scores(5, [10, 20, 30, 40, 50], 3, [5, 15, 25]) (60, 45) >>> calculate_scores(3, [7, 8, 9], 5, [1, 2, 3, 4, 5]) (24, 6) >>> calculate_scores(2, [-1, -2], 2, [3, 4]) (-3, 7) >>> calculate_scores(3, [-1, -2, -3], 3, [-4, -5, -6]) (-6, -15)","solution":"def calculate_scores(N, Emma, M, Olivia): emma_score = 0 olivia_score = 0 min_length = min(N, M) # Both Emma and Olivia draw cards until one deck is empty for i in range(min_length): emma_score += Emma[i] olivia_score += Olivia[i] return emma_score, olivia_score"},{"question":"def computeFactorial(M: int) -> int: Compute the factorial of M without the help of loops. >>> computeFactorial(3) 6 >>> computeFactorial(5) 120 pass import pytest def test_factorial_of_1(): assert computeFactorial(1) == 1 def test_factorial_of_3(): assert computeFactorial(3) == 6 def test_factorial_of_5(): assert computeFactorial(5) == 120 def test_factorial_of_0(): assert computeFactorial(0) == 1 def test_factorial_of_10(): assert computeFactorial(10) == 3628800 def test_factorial_max_input(): assert computeFactorial(15) == 1307674368000","solution":"def computeFactorial(M): Computes the factorial of M without the help of loops. # Base case: factorial of 0 or 1 is 1 if M == 0 or M == 1: return 1 # Recursive case: M * factorial of (M-1) else: return M * computeFactorial(M - 1)"},{"question":"def min_replacements_to_make_increasing(matrix): Replace the minimum number of entries in the matrix such that each row and each column is strictly increasing from left to right and from top to bottom respectively. >>> matrix1 = [ ... [1, 2, 3], ... [4, 2, 6], ... [7, 8, 9] ... ] >>> min_replacements_to_make_increasing(matrix1) 1 >>> matrix2 = [ ... [1, 10, 20, 30], ... [2, 11, 21, 31], ... [3, 12, 22, 32], ... [4, 13, 23, 33] ... ] >>> min_replacements_to_make_increasing(matrix2) 0 >>> matrix3 = [ ... [5, 3], ... [2, 1] ... ] >>> min_replacements_to_make_increasing(matrix3) 3","solution":"def min_replacements_to_make_increasing(matrix): N = len(matrix) M = len(matrix[0]) replacements = 0 def is_valid(x, y, val): if x > 0 and matrix[x-1][y] >= val: return False if y > 0 and matrix[x][y-1] >= val: return False return True for i in range(N): for j in range(M): if (i > 0 and matrix[i][j] <= matrix[i-1][j]) or (j > 0 and matrix[i][j] <= matrix[i][j-1]): valid_val = max(matrix[i-1][j] if i > 0 else -1, matrix[i][j-1] if j > 0 else -1) + 1 matrix[i][j] = valid_val replacements += 1 return replacements # Example usage: matrix1 = [ [1, 2, 3], [4, 2, 6], [7, 8, 9] ] matrix2 = [ [1, 10, 20, 30], [2, 11, 21, 31], [3, 12, 22, 32], [4, 13, 23, 33] ] matrix3 = [ [5, 3], [2, 1] ] print(min_replacements_to_make_increasing(matrix1)) # Output: 1 print(min_replacements_to_make_increasing(matrix2)) # Output: 0 print(min_replacements_to_make_increasing(matrix3)) # Output: 3"},{"question":"def can_form_palindrome(s: str) -> str: Determine whether you can create a palindrome by removing exactly one character from the string \`s\`. >>> can_form_palindrome(\\"abca\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"def valid_palindrome_with_one_removal(s): def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j // 2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing either left character or right character return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True def can_form_palindrome(s): if valid_palindrome_with_one_removal(s): return \\"YES\\" else: return \\"NO\\""},{"question":"def can_split_equally(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Determine whether it's possible to split the bill equally among three friends. Each friend has certain amounts of money represented by the integers X, Y, and Z. Returns \\"YES\\" if it's possible to split the money equally among the three friends, or \\"NO\\" otherwise. >>> can_split_equally(3, [(3, 3, 3), (4, 5, 6), (5, 5, 5)]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_split_equally(1, [(1, 1, 2)]) [\\"NO\\"]","solution":"def can_split_equally(t, test_cases): results = [] for case in test_cases: X, Y, Z = case total = X + Y + Z if total % 3 == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def balanced_roots_tree(N: int, edges: List[Tuple[int, int]]) -> None: Determine if it is possible to rearrange the tree to form a Balanced Roots Tree. If possible, print \\"YES\\" followed by the new parent-child relationships. If not, print \\"NO\\". Args: N : int : The number of nodes in the tree. edges : List[Tuple[int, int]] : List of edges where each edge is represented by a tuple of two integers indicating nodes connected by that edge. Example: >>> balanced_roots_tree(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) YES 1 2 1 3 2 4 2 5 3 6 3 7 >>> balanced_roots_tree(4, [(1, 2), (1, 3), (2, 4)]) NO # Your implementation here","solution":"from collections import defaultdict, deque def build_tree(edges, N): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def is_balanced(tree, node, parent): heights = [] for child in tree[node]: if child != parent: # avoid going back to the parent node heights.append(is_balanced(tree, child, node)) if not heights: return 1 max_height = max(heights) min_height = min(heights) if max_height - min_height > 1: return -1 # unbalanced subtree return max_height + 1 def reorder_tree(tree, N): # Rebuild the tree with BFS ensuring it remains balanced root = 1 # arbitrary root queue = deque([root]) visited = set([root]) parent_child_pairs = [] while queue: node = queue.popleft() for child in tree[node]: if child not in visited: parent_child_pairs.append((node, child)) queue.append(child) visited.add(child) return parent_child_pairs def balanced_roots_tree(N, edges): tree = build_tree(edges, N) height_check = is_balanced(tree, 1, -1) if height_check == -1: print(\\"NO\\") else: new_arrangement = reorder_tree(tree, N) print(\\"YES\\") for parent, child in new_arrangement: print(parent, child) # Example Input N = 7 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7) ] balanced_roots_tree(N, edges)"},{"question":"def min_shelves(boxes: List[int], capacity: int) -> int: Determine the minimum number of shelves needed to store all the boxes without exceeding the capacity of any shelf. Args: boxes : List[int] - a list of integers representing the weight of each box. capacity : int - an integer representing the capacity of each shelf. Returns: int - the minimum number of shelves needed. Examples: >>> min_shelves([4, 8, 1, 4, 2, 1], 10) 3 >>> min_shelves([5, 5, 5], 5) 3 >>> min_shelves([2, 2, 2, 2, 2], 10) 1 >>> min_shelves([], 10) 0 >>> min_shelves([10], 10) 1 >>> min_shelves([7, 2, 5, 10, 8, 4], 15) 3","solution":"def min_shelves(boxes, capacity): Function to determine the minimum number of shelves needed to store all the boxes without exceeding the capacity of any shelf. Args: boxes : List[int] - a list of integers representing the weight of each box. capacity : int - an integer representing the capacity of each shelf. Returns: int - the minimum number of shelves needed. shelves = 0 current_capacity = capacity for box in sorted(boxes, reverse=True): if box <= current_capacity: current_capacity -= box else: shelves += 1 current_capacity = capacity - box if current_capacity < capacity: shelves += 1 return shelves"},{"question":"def min_coins(n: int, coin_values: List[int], target_sum: int) -> int: Given n coin values, determine the minimum number of coins required to make the exact sum m. If it is not possible to make that sum, return -1. >>> min_coins(3, [1, 2, 5], 11) == 3 >>> min_coins(2, [2, 5], 3) == -1 >>> min_coins(4, [1, 3, 4, 5], 7) == 2 >>> min_coins(1, [5], 10) == 2 >>> min_coins(3, [2, 4, 6], 7) == -1 >>> min_coins(5, [1, 2, 2, 1, 5], 11) == 3 >>> min_coins(3, [1, 2, 5], 0) == 0 >>> min_coins(3, [1, 2, 5], 10000) == 2000","solution":"def min_coins(n, coin_values, target_sum): Given n coin values, determine the minimum number of coins required to make the exact sum m. If it is not possible to make that sum, return -1. dp = [float('inf')] * (target_sum + 1) dp[0] = 0 for i in range(1, target_sum + 1): for coin in coin_values: if i >= coin: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[target_sum] if dp[target_sum] != float('inf') else -1 # Example usage: # print(min_coins(3, [1, 2, 5], 11)) # Output: 3 # print(min_coins(2, [2, 5], 3)) # Output: -1 # print(min_coins(4, [1, 3, 4, 5], 7)) # Output: 2"},{"question":"def total_tree_height(N: int, heights: List[int]) -> int: Returns the total height of all trees to be planted in the street. Parameters: N (int): The number of buildings. heights (list): The heights of the buildings. Returns: int: The total height of all trees. >>> total_tree_height(5, [3, 5, 4, 7, 2]) 11 >>> total_tree_height(3, [4, 4, 4]) 0 >>> total_tree_height(4, [1, 2, 3, 4]) 3 >>> total_tree_height(4, [4, 3, 2, 1]) 3 >>> total_tree_height(6, [1, 10, 1, 10, 1, 10]) 45","solution":"def total_tree_height(N, heights): Returns the total height of all trees to be planted in the street. Parameters: N (int): The number of buildings. heights (list): The heights of the buildings. Returns: int: The total height of all trees. total_height = 0 for i in range(1, N): total_height += abs(heights[i] - heights[i - 1]) return total_height"},{"question":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(n, queries): Performs the analysis of the magical portal network with given queries Args: n (int): Number of cities in the kingdom queries (List[str]): List of query strings representing the operations to be performed Returns: List[str]: The results for each \`CONNECTED P A B\` query \`","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def process_queries(n, queries): ds = DisjointSet(n) result = [] for query in queries: op, _, a, b = query.split() a, b = int(a) - 1, int(b) - 1 if op == \\"ADDED\\": ds.union(a, b) elif op == \\"REMOVED\\": # Realistically, removing an edge in the union-find structure is complex and isn't handled here. # It requires more advanced data structures like dynamic connectivity. pass elif op == \\"CONNECTED\\": if ds.find(a) == ds.find(b): result.append(\\"YES\\") else: result.append(\\"NO\\") return result def solve(): import sys input = sys.stdin.read data = input().splitlines() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): N, Q = map(int, data[idx].split()) idx += 1 queries = data[idx:idx + Q] idx += Q results.extend(process_queries(N, queries)) for res in results: print(res)"},{"question":"def longest_digit_substring(s: str) -> (int, int): Finds the longest substring containing only digits and returns its starting index and length. Parameters: s (str): Input string Returns: tuple: starting index and length of the longest substring containing only digits Examples: >>> longest_digit_substring(\\"ab1234xyz123\\") (2, 4) >>> longest_digit_substring(\\"abc98765def32\\") (3, 5) >>> longest_digit_substring(\\"abcdefgh\\") (-1, 0) >>> longest_digit_substring(\\"1234567890\\") (0, 10) >>> longest_digit_substring(\\"a1b\\") (1, 1) >>> longest_digit_substring(\\"1234abc5678\\") (0, 4) >>> longest_digit_substring(\\"abc123\\") (3, 3) >>> longest_digit_substring(\\"123abc\\") (0, 3) >>> longest_digit_substring(\\"a1b2c3\\") (1, 1)","solution":"def longest_digit_substring(s): Finds the longest substring containing only digits. Parameters: s (str): Input string Returns: tuple: starting index and length of the longest substring containing only digits max_len = 0 max_start_idx = -1 current_len = 0 current_start_idx = -1 for i, char in enumerate(s): if char.isdigit(): if current_len == 0: current_start_idx = i current_len += 1 else: if current_len > max_len: max_len = current_len max_start_idx = current_start_idx current_len = 0 if current_len > max_len: max_len = current_len max_start_idx = current_start_idx return max_start_idx, max_len"},{"question":"def rotate_list(lst: List[int], k: int) -> List[int]: Rotates the list lst to the right by k steps. >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([7, 1, 5, 8, 2, 4, 6], 3) [2, 4, 6, 7, 1, 5, 8] >>> rotate_list([1, 2, 3], 0) [1, 2, 3] >>> rotate_list([1], 5) [1] >>> rotate_list([1, 2, 3, 4], 6) [3, 4, 1, 2] >>> rotate_list([2, 4, 6, 8], 2) [6, 8, 2, 4]","solution":"def rotate_list(lst, k): Rotates the list lst to the right by k steps. n = len(lst) k = k % n # handle cases where k > n rotated_lst = lst[-k:] + lst[:-k] return rotated_lst"},{"question":"def rearrange_balls(test_cases): Given a list of test cases with each test case in form of a tuple (N, S), where N is the length of the string S containing 'R' and 'W', rearrange the balls such that all 'R's come before all 'W's while preserving relative order. Args: test_cases (List[Tuple[int, str]]): List of test cases Returns: List[str]: List of rearranged strings >>> rearrange_balls([(5, 'WRRWW')]) ['RRWWW'] >>> rearrange_balls([(4, 'RRWW')]) ['RRWW'] >>> rearrange_balls([(7, 'RWRWRRW')]) ['RRRRWWW'] pass def parse_input(input_data): Parses the input data into test cases. Args: input_data (str): Input data in the format specified Returns: List[Tuple[int, str]]: Parsed list of test cases >>> parse_input(\\"2n3nRRWn4nWRRW\\") [(3, 'RRW'), (4, 'WRRW')] pass","solution":"def rearrange_balls(test_cases): results = [] for N, S in test_cases: reds = [char for char in S if char == 'R'] whites = [char for char in S if char == 'W'] results.append(''.join(reds + whites)) return results def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) S = input_lines[index + 1] test_cases.append((N, S)) index += 2 return test_cases"},{"question":"from typing import List, Tuple def find_max_average(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Finds the highest average grade for each k consecutive students in their grade list. >>> find_max_average(1, [([8, 3], [5, 12, 11, 5, 7, 16, 19, 3])]) [\\"14.00\\"] >>> find_max_average(2, [([8, 3], [5, 12, 11, 5, 7, 16, 19, 3]), ([6, 2], [4, 2, 10, 5, 3, 8])]) [\\"14.00\\", \\"7.50\\"]","solution":"def find_max_average(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] grades = test_cases[i][1] max_sum = current_sum = sum(grades[:k]) for j in range(k, n): current_sum += grades[j] - grades[j - k] max_sum = max(max_sum, current_sum) max_average = max_sum / k results.append(f\\"{max_average:.2f}\\") return results"},{"question":"def longest_factor_chain(N: int, weights: List[int]) -> int: Determine the length of the longest possible factor chain using the given weights. Args: N (int): The number of ingredients. weights (List[int]): The weights of the ingredients. Returns: int: The length of the longest possible factor chain. Example: >>> longest_factor_chain(4, [3, 6, 2, 18]) 3 >>> longest_factor_chain(5, [4, 8, 15, 16, 23]) 3 >>> longest_factor_chain(6, [1, 3, 9, 27, 4, 8]) 4","solution":"def longest_factor_chain(N, weights): weights.sort() dp = [1] * N for i in range(N): for j in range(i): if weights[i] % weights[j] == 0 or weights[j] % weights[i] == 0: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def replace_value_in_grid(n, m, grid, x, y): Replaces all occurrences of x with y in the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid of integers. x (int): The value to find in the grid. y (int): The value to replace x with. Returns: list of list of int: The modified grid.","solution":"def replace_value_in_grid(n, m, grid, x, y): Replaces all occurrences of x with y in the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of list of int): The grid of integers. x (int): The value to find in the grid. y (int): The value to replace x with. Returns: list of list of int: The modified grid. for i in range(n): for j in range(m): if grid[i][j] == x: grid[i][j] = y return grid"},{"question":"def trap_water(buildings): Calculate the total amount of water that can be trapped between the buildings. :param buildings: List[int] - heights of the buildings. :return: int - The total amount of trapped water. >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_water([0, 0, 0, 0]) 0 >>> trap_water([1, 1, 1, 1]) 0 >>> trap_water([3]) 0 >>> trap_water([]) 0 >>> trap_water([2, 1, 2]) 1 >>> trap_water([3, 0, 3]) 3 >>> trap_water([2, 0, 2, 0, 2]) 4","solution":"def trap_water(buildings): Calculate the total amount of water that can be trapped between the buildings. :param buildings: List[int] - heights of the buildings. :return: int - The total amount of trapped water. if not buildings: return 0 n = len(buildings) left_max = [0] * n right_max = [0] * n left_max[0] = buildings[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], buildings[i]) right_max[n - 1] = buildings[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], buildings[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - buildings[i] return trapped_water"},{"question":"def minimize_string_length(s: str) -> int: Returns the minimized length of the string after performing the allowed operations optimally. The input consists of a single line containing a string S (1 ≤ |S| ≤ 1000) — the given string. The output should be a single integer — the length of the string after minimizing it using the allowed operations. >>> minimize_string_length(\\"abacaba\\") 1 >>> minimize_string_length(\\"bbc\\") 1 >>> minimize_string_length(\\"z\\") 1","solution":"def minimize_string_length(s): Returns the minimized length of the string after performing the allowed operations optimally. from collections import Counter counter = Counter(s) return sum(1 for char_count in counter.values() if char_count % 2 != 0)"},{"question":"def count_pairs_with_sum(arr, n, x): Determine the number of unique pairs (i, j) where i < j and arr[i] + arr[j] == x, modulo 10^9 + 7. Args: arr: List[int] - The list of integers. n: int - The length of the array. x: int - The target integer. Returns: int - The count of unique pairs where the sum is equal to x, modulo 10^9 + 7. >>> count_pairs_with_sum([1, 5, 3, 4, 2], 5, 7) 2 >>> count_pairs_with_sum([-1, -2, -3, -4], 4, -3) 1 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 5, 10) 0 >>> count_pairs_with_sum([0, 0, 0, 0], 4, 0) 6 >>> count_pairs_with_sum([1, 4, 2, 5, 3], 5, 8) 1 >>> count_pairs_with_sum([1000000000, -1000000000], 2, 0) 1 >>> count_pairs_with_sum([-1, 1, 2, -2], 4, 0) 2","solution":"def count_pairs_with_sum(arr, n, x): Returns the count of unique pairs (i, j) where i < j and arr[i] + arr[j] == x, modulo 10^9 + 7. MOD = 10**9 + 7 num_dict = {} count = 0 for number in arr: complement = x - number if complement in num_dict: count = (count + num_dict[complement]) % MOD if number in num_dict: num_dict[number] += 1 else: num_dict[number] = 1 return count"},{"question":"def min_operations_to_uniform(S: str) -> int: Given a string S consisting only of 'a', 'b', and 'c', returns the minimum number of operations needed to make all characters the same. >>> min_operations_to_uniform(\\"abc\\") 2 >>> min_operations_to_uniform(\\"aaab\\") 1 >>> min_operations_to_uniform(\\"cccc\\") 0","solution":"def min_operations_to_uniform(S): Given a string S consisting only of 'a', 'b', and 'c', returns the minimum number of operations needed to make all characters the same. a_count = S.count('a') b_count = S.count('b') c_count = S.count('c') total_length = len(S) # To make all characters 'a', change all 'b's and 'c's to 'a' operations_to_a = total_length - a_count # To make all characters 'b', change all 'a's and 'c's to 'b' operations_to_b = total_length - b_count # To make all characters 'c', change all 'a's and 'b's to 'c' operations_to_c = total_length - c_count return min(operations_to_a, operations_to_b, operations_to_c)"},{"question":"def min_distance(n: int, locations: List[int]) -> int: Calculate the minimum distance Polycarp needs to travel to deliver all packages and return to coordinate 0. :param n: int - the number of packages :param locations: list of int - coordinates of the delivery locations :return: int - minimum distance Polycarp needs to travel >>> min_distance(3, [-5, 0, 10]) 30 >>> min_distance(3, [1, -2, 3]) 10 >>> min_distance(2, [-3, 4]) 14 >>> min_distance(5, [0, 0, 0, 0]) 0 >>> min_distance(1, [1000000000]) 2000000000","solution":"def min_distance(n, locations): Calculates the minimum distance Polycarp needs to travel to deliver all packages and return to coordinate 0. :param n: int - the number of packages :param locations: list of int - coordinates of the delivery locations :return: int - minimum distance Polycarp needs to travel if n == 0: return 0 max_left = min(locations) if locations else 0 max_right = max(locations) if locations else 0 return abs(max_left) + abs(max_right) + abs(max_right - max_left)"},{"question":"def min_moves(grid): Calculate the minimum number of moves for a robot to reach the bottom-right cell from the top-left cell in a grid of obstacles. Args: grid (List[List[int]]): A 2D list representing the grid where '0' is an empty cell and '1' is an obstacle. Returns: int: The minimum number of moves needed to reach the bottom-right cell, or -1 if it is not possible. Examples: >>> min_moves([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 4 >>> min_moves([ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) -1","solution":"from collections import deque def min_moves(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() if row == n-1 and col == m-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"from typing import List def findClosestElements(arr: List[int], k: int, x: int) -> List[int]: Returns the k closest integers to x in the array arr. >>> findClosestElements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> findClosestElements([1, 3, 3, 3, 5, 8, 8, 9], 3, 4) [3, 3, 3] pass import heapq def test_case_1(): arr = [1, 2, 3, 4, 5] k = 4 x = 3 result = findClosestElements(arr, k, x) assert result == [1, 2, 3, 4] def test_case_2(): arr = [1, 3, 3, 3, 5, 8, 8, 9] k = 3 x = 4 result = findClosestElements(arr, k, x) assert result == [3, 3, 3] def test_case_3(): arr = [1, 2, 3, 4, 5] k = 4 x = -1 result = findClosestElements(arr, k, x) assert result == [1, 2, 3, 4] def test_case_4(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 5 x = 6 result = findClosestElements(arr, k, x) assert result == [4, 5, 6, 7, 8] def test_case_5(): arr = [10, 20, 30, 40, 50] k = 2 x = 35 result = findClosestElements(arr, k, x) assert result == [30, 40]","solution":"import heapq def findClosestElements(arr, k, x): Returns the k closest integers to x in the array arr. # Using a max-heap to keep track of the closest k elements max_heap = [] for num in arr: # Push the negative of the difference to create a max-heap heapq.heappush(max_heap, (-abs(num - x), -num)) if len(max_heap) > k: heapq.heappop(max_heap) # Extract the elements from the heap and sort them result = [-item[1] for item in max_heap] result.sort() return result"},{"question":"def evaluateExpression(s: str) -> int: Evaluate a given arithmetic expression string and return the result as an integer. The expression contains only non-negative integers, the operators +, -, *, /, and parentheses. The integer division should truncate toward zero. >>> evaluateExpression(\\"3 + (2 - 5) * 6 / 2\\") -6 >>> evaluateExpression(\\"10 / 3\\") 3 >>> evaluateExpression(\\"100 * ( 2 + 12 ) / 14\\") 100","solution":"def evaluateExpression(s): def helper(tokens): stack = [] num = 0 sign = \\"+\\" while len(tokens) > 0: token = tokens.pop(0) if token.isdigit(): num = 10 * num + int(token) if token == '(': num = helper(tokens) if (not token.isdigit() and not token.isspace()) or len(tokens) == 0: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': stack[-1] = int(stack[-1] / num) # Using int() to truncate toward zero sign = token num = 0 if token == ')': break return sum(stack) tokens = list(s) return helper(tokens)"},{"question":"def max_manhattan_distance(commands: str, n: int) -> int: Calculate the maximum Manhattan distance from the starting point (0, 0) after replacing exactly \`n\` commands in the given list of commands with any valid command to maximize the distance. :param commands: String, the original list of commands. :param n: Integer, number of erroneous commands. :return: Integer, the maximum Manhattan distance. >>> max_manhattan_distance(\\"UDLR\\", 1) 2 >>> max_manhattan_distance(\\"UUDDLRLR\\", 2) 4","solution":"def max_manhattan_distance(commands, n): Calculate the maximum Manhattan distance from the starting point (0, 0) after replacing exactly \`n\` commands in the given list of commands with any valid command to maximize the distance. :param commands: String, the original list of commands. :param n: Integer, number of erroneous commands. :return: Integer, the maximum Manhattan distance. # Calculate initial net moves vertical_balance = commands.count('U') - commands.count('D') horizontal_balance = commands.count('R') - commands.count('L') # Calculate the best-case scenario after correcting n moves max_distance = abs(vertical_balance) + abs(horizontal_balance) + 2 * n return max_distance"},{"question":"def count_islands(field, N, M): Returns the number of distinct islands of connected land cells. >>> field = [ ... ['L', 'W', 'W', 'L', 'L'], ... ['L', 'L', 'W', 'W', 'L'], ... ['W', 'W', 'L', 'W', 'W'], ... ['L', 'W', 'L', 'L', 'L'] ... ] >>> count_islands(field, 4, 5) 4 >>> field = [ ... ['W', 'W', 'L'], ... ['W', 'L', 'L'], ... ['L', 'L', 'W'] ... ] >>> count_islands(field, 3, 3) 1","solution":"def count_islands(field, N, M): Returns the number of distinct islands of connected land cells. if not field: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= N or y >= M or field[x][y] == 'W': return field[x][y] = 'W' # mark as visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) islands = 0 for i in range(N): for j in range(M): if field[i][j] == 'L': islands += 1 dfs(i, j) return islands"},{"question":"def lexicographically_smallest_array(arr: List[int], k: int) -> List[int]: Returns the lexicographically smallest array after exactly k reverse operations. Parameters: arr (List[int]): The original array. k (int): The number of reverse operations. Returns: List[int]: The lexicographically smallest array possible after k operations. >>> lexicographically_smallest_array([3, 2, 1, 5, 4], 1) == [1, 2, 3, 5, 4] >>> lexicographically_smallest_array([4, 3, 2, 1], 2) == [1, 2, 3, 4] >>> lexicographically_smallest_array([1, 2, 3, 4], 2) == [1, 2, 3, 4] >>> lexicographically_smallest_array([1, 3, 2, 4, 5], 1) == [1, 3, 2, 4, 5] >>> lexicographically_smallest_array([5, 4, 3, 2, 1], 3) == [1, 2, 3, 4, 5]","solution":"def lexicographically_smallest_array(arr, k): Returns the lexicographically smallest array after exactly k reverse operations. n = len(arr) for _ in range(k): smallest = min(arr) if arr[0] == smallest: break index = arr.index(smallest) arr = arr[:index+1][::-1] + arr[index+1:] return arr"},{"question":"def count_distinct_ranks(TC: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Given the number of test cases and for each test case the number of games, points after each game, and ranks after each game, return the number of distinct ranks achieved till the current game. Args: TC: int: number of test cases test_cases: List[Tuple[int, List[int], List[int]]]: list of tuples, each containing: - an integer representing the number of games - a list of integers representing the points after each game - a list of integers representing the ranks after each game Returns: List[int]: list of integers, where each integer is the number of distinct ranks for each test case. Example: >>> count_distinct_ranks(2, [(5, [100, 200, 300, 400, 500], [1, 2, 2, 3, 3]), (3, [150, 150, 200], [1, 2, 2])]) [3, 2] >>> count_distinct_ranks(1, [(4, [100, 200, 300, 400], [1, 1, 1, 1])]) [1]","solution":"def count_distinct_ranks(TC, test_cases): Returns the number of distinct ranks achieved for each test case. results = [] for i in range(TC): N = test_cases[i][0] ranks = test_cases[i][2] distinct_ranks = len(set(ranks)) results.append(distinct_ranks) return results"},{"question":"def group_elements(lst, n): Write a function 'group_elements' that takes in a list 'lst' and an integer 'n', and returns a list of lists where each sublist contains 'n' elements from the original list, except the final sublist which may contain fewer elements if there are not enough remaining items. >>> group_elements([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> group_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 4) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]] >>> group_elements([1, 2, 3], 5) [[1, 2, 3]] >>> group_elements([1, 2, 3, 4], 1) [[1], [2], [3], [4]] >>> group_elements([], 3) [] >>> group_elements([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], 2) [[\\"a\\", \\"b\\"], [\\"c\\", \\"d\\"], [\\"e\\"]]","solution":"def group_elements(lst, n): Groups elements in the list 'lst' into sublists of 'n' elements each. The final sublist may contain fewer than 'n' elements if there are not enough remaining elements. return [lst[i:i + n] for i in range(0, len(lst), n)]"},{"question":"def three_sum(nums, target): Determine if there are three distinct indices (i, j, k) such that the sum of nums[i], nums[j], and nums[k] equals to target. Params: nums: List[int] - the list of non-negative integers target: int - the target sum value Returns: str: \\"YES\\" if such indices exist, \\"NO\\" otherwise >>> three_sum([1, 2, 3, 4, 5], 9) 'YES' >>> three_sum([1, 2, 3, 4], 10) 'NO' >>> three_sum([1, 4, 45, 6, 10, 8], 22) 'YES'","solution":"def three_sum(nums, target): Determine if there are three distinct indices (i, j, k) such that the sum of nums[i], nums[j], and nums[k] equals to target. Params: nums: List[int] - the list of non-negative integers target: int - the target sum value Returns: str: \\"YES\\" if such indices exist, \\"NO\\" otherwise nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return \\"YES\\" elif current_sum < target: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def is_subsequence(s: str, p: str) -> bool: Determine if \`p\` is a subsequence of \`s\`. Args: s (str): the source string. p (str): the pattern string. Returns: bool: True if p can be found as a subsequence in s, False otherwise. pass # Test cases def test_pattern_in_string(): assert is_subsequence(\\"codereview\\", \\"crew\\") == True def test_pattern_in_string_complex(): assert is_subsequence(\\"codinginterview\\", \\"coin\\") == True def test_pattern_not_in_string(): assert is_subsequence(\\"hello\\", \\"world\\") == False def test_empty_pattern(): assert is_subsequence(\\"anything\\", \\"\\") == True def test_empty_string(): assert is_subsequence(\\"\\", \\"something\\") == False def test_both_empty(): assert is_subsequence(\\"\\", \\"\\") == True def test_large_input_true(): s = \\"a\\" * 100000 p = \\"a\\" * 50000 assert is_subsequence(s, p) == True def test_large_input_false(): s = \\"a\\" * 100000 p = \\"b\\" * 50000 assert is_subsequence(s, p) == False","solution":"def is_subsequence(s: str, p: str) -> bool: Determine if \`p\` is a subsequence of \`s\`. Args: s (str): the source string. p (str): the pattern string. Returns: bool: True if p can be found as a subsequence in s, False otherwise. s_len, p_len = len(s), len(p) si, pi = 0, 0 while si < s_len and pi < p_len: if s[si] == p[pi]: pi += 1 si += 1 return pi == p_len"},{"question":"from typing import List def num_playlists(n: int, k: int, durations: List[int]) -> int: Determine the number of distinct playlists that sum up to exactly k minutes. Args: n : int : the number of songs k : int : the desired total duration of the playlist in minutes durations : List[int] : the duration of each song Returns: int : the number of distinct playlists that sum up to exactly k minutes >>> num_playlists(3, 4, [1, 2, 3]) 4 >>> num_playlists(2, 3, [2, 2]) 0 >>> num_playlists(4, 7, [1, 3, 4, 5]) 6","solution":"def num_playlists(n, k, durations): # Initialize a DP array where dp[i] will store the number of ways to achieve # a total duration of i minutes using the provided song durations. dp = [0] * (k + 1) dp[0] = 1 # There is one way to make a duration of 0 - use no songs # Iterate over each song duration for duration in durations: # Update the dp array for each possible total duration from k to duration # We iterate backwards to ensure that each song can be counted multiple times for current_duration in range(duration, k + 1): dp[current_duration] += dp[current_duration - duration] return dp[k] # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) durations = list(map(int, data[2:2 + n])) print(num_playlists(n, k, durations))"},{"question":"def has_pair_with_sum(arr: List[int], x: int) -> str: Determine if there exist two integers in the array whose sum equals the target integer. Args: arr (List[int]): Array of integers. x (int): Target sum. Returns: str: \\"YES\\" if there exists a pair with sum equals to x, otherwise \\"NO\\". Examples: >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) \\"NO\\"","solution":"def has_pair_with_sum(arr, x): seen = set() for number in arr: if x - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"from typing import List def min_groups(n: int, k: int, scores: List[int]) -> int: Determine the minimum number of groups such that the score differences within each group do not exceed a given threshold. Parameters: n (int): The number of participants. k (int): The maximum allowed score difference within a group. scores (List[int]): The list of unique scores of the participants. Returns: int: The minimum number of groups needed. Examples: >>> min_groups(6, 3, [10, 20, 30, 40, 50, 60]) 6 >>> min_groups(3, 10, [15, 5, 25]) 2 >>> min_groups(4, 5, [1, 2, 3, 8]) 2 >>> min_groups(5, 2, [1, 2, 5, 6, 8]) 3","solution":"def min_groups(n, k, scores): scores.sort() groups = 0 i = 0 while i < n: groups += 1 j = i while j < n and scores[j] - scores[i] <= k: j += 1 i = j return groups"},{"question":"def largest_square_plot(M: int, N: int, field: List[List[int]]) -> int: Determines the side length of the largest square plot that contains only plant cells (1s). >>> largest_square_plot(4, 5, [ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0] ]) 2 >>> largest_square_plot(5, 6, [ [0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0] ]) 3","solution":"def largest_square_plot(M, N, field): Determines the side length of the largest square plot that contains only plant cells (1s). # Create a 2D array dp where dp[i][j] represents the side length of the largest square # whose bottom-right corner is the cell (i, j). dp = [[0] * N for _ in range(M)] max_side = 0 # Iterate over the field to fill the dp table for i in range(M): for j in range(N): if field[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List from collections import Counter def longest_subsequence_length(S: str) -> int: Returns the length of the longest subsequence of S such that every character in the subsequence appears at least twice. >>> longest_subsequence_length(\\"abcabc\\") 6 >>> longest_subsequence_length(\\"aabbcc\\") 6 >>> longest_subsequence_length(\\"abacabadabacaba\\") 14 >>> longest_subsequence_length(\\"a\\"*1000) 1000 >>> longest_subsequence_length(\\"abcdabcdabcdabcd\\") 16","solution":"from collections import Counter def longest_subsequence_length(S): Returns the length of the longest subsequence of S such that every character in the subsequence appears at least twice. # Count the frequency of each character char_count = Counter(S) # Initialize the length of the longest subsequence subseq_length = 0 # Iterate through the character counts for count in char_count.values(): # Add twice the number of complete pairs of each character to the subsequence length subseq_length += (count // 2) * 2 return subseq_length"},{"question":"def min_strokes(n: int) -> int: Returns the minimum number of strokes required to paint an n x n canvas. >>> min_strokes(1) == 1 >>> min_strokes(2) == 2 >>> min_strokes(3) == 3 >>> min_strokes(10) == 10 >>> min_strokes(100) == 100 >>> min_strokes(1000) == 1000","solution":"def min_strokes(n): Returns the minimum number of strokes required to paint an n x n canvas. return n"},{"question":"def reverse_dict_lookup(d, target): Returns a list of keys in dictionary d that have the value target. Parameters: d (dict): A dictionary. target: The value to search for in the dictionary. Returns: list: A list of keys that map to the value target. Examples: >>> reverse_dict_lookup({'a': 1, 'b': 2, 'c': 1}, 1) ['a', 'c'] >>> reverse_dict_lookup({'a': 3, 'b': 2, 'c': 2}, 2) ['b', 'c'] >>> reverse_dict_lookup({'a': 3, 'b': 3, 'c': 3}, 3) ['a', 'b', 'c'] >>> reverse_dict_lookup({'a': 1, 'b': 2, 'c': 1}, 3) [] >>> reverse_dict_lookup({}, 1) [] >>> reverse_dict_lookup({}, 0) [] >>> reverse_dict_lookup({'a': 3}, 3) ['a'] >>> reverse_dict_lookup({'a': 3}, 1) [] >>> reverse_dict_lookup({'a': 1, 'b': 1, 'c': 1}, 1) ['a', 'b', 'c'] >>> reverse_dict_lookup({'a': 1, 'b': 1, 'c': 1}, 2) []","solution":"def reverse_dict_lookup(d, target): Returns a list of keys in dictionary d that have the value target. Parameters: d (dict): A dictionary. target: The value to search for in the dictionary. Returns: list: A list of keys that map to the value target. return [key for key, value in d.items() if value == target]"},{"question":"def rearrange_string(s: str, k: int) -> str: Given a string \`s\` consisting of lowercase alphabetical characters and an integer \`k\`, rearrange the string such that the distance between any two identical characters is at least \`k\`. If it's not possible to rearrange the string, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) != \\"\\" >>> rearrange_string(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string(\\"aaabb\\", 5) == \\"\\" >>> rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\" >>> rearrange_string(\\"aaaa\\", 2) == \\"\\" >>> rearrange_string(\\"abcd\\", 5) == \\"abcd\\"","solution":"from heapq import heappush, heappop from collections import Counter, deque def rearrange_string(s: str, k: int) -> str: if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] queue = deque() while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((char, freq + 1)) if len(queue) >= k: front_char, front_freq = queue.popleft() if front_freq < 0: heappush(max_heap, (front_freq, front_char)) if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"import heapq from typing import List, Tuple def dijkstra(N: int, edges: List[Tuple[int, int, int]], S: int) -> List[str]: Compute the shortest time for a message to be sent from the starting server to all other servers in the network. Parameters: N (int): The number of servers. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple consists of three integers u, v, and w. S (int): The starting server. Returns: List[str]: A list of strings where the ith string represents the shortest time required to send a message from the starting server S to server i. If server i cannot be reached from server S, \\"UNREACHABLE\\" will be returned for that server. Example: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (3, 5, 2)], 1) [\\"0\\", \\"2\\", \\"3\\", \\"6\\", \\"5\\"] >>> dijkstra(4, [(1, 2, 1), (3, 4, 1)], 1) [\\"0\\", \\"1\\", \\"UNREACHABLE\\", \\"UNREACHABLE\\"]","solution":"import heapq def dijkstra(N, edges, S): graph = {i: [] for i in range(1, N+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Since it is an undirected graph distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 priority_queue = [(0, S)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, N+1): if distances[i] == float('inf'): result.append(\\"UNREACHABLE\\") else: result.append(str(distances[i])) return result"},{"question":"from typing import List, Tuple def shortest_paths(n: int, connections: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Find the shortest travel time between nodes in a network for multiple queries. Args: n (int): The number of nodes in the network. connections (List[Tuple[int, int, int]]): Each tuple represents a direct connection between nodes (u, v) with travel time w. queries (List[Tuple[int, int]]): Each tuple represents a query to find the shortest travel time between nodes s and t. Returns: List[int]: The shortest travel times for each query. If there's no path, return -1. Example: >>> shortest_paths(5, [(1, 2, 3), (1, 3, 4), (2, 3, 1), (2, 4, 6), (3, 5, 2), (4, 5, 2)], [(1, 5), (2, 3)]) [6, 1] >>> shortest_paths(4, [(1, 2, 5), (3, 4, 7)], [(1, 3), (2, 4)]) [-1, -1]","solution":"import heapq def dijkstra(graph, start, n): Dijkstra's algorithm to find the shortest path from a start node to all other nodes in the graph. distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_paths(n, connections, queries): Finds the shortest travel time between two nodes for multiple queries using Dijkstra's algorithm. graph = {i: [] for i in range(1, n + 1)} for u, v, w in connections: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for s, t in queries: distances = dijkstra(graph, s, n) results.append(distances[t] if distances[t] != float('inf') else -1) return results"},{"question":"def largest_rectangle_area(coords: List[Tuple[int, int]]) -> int: Returns the largest rectangle area that can be formed by the given coordinates with sides parallel to the axes. >>> largest_rectangle_area([(1, 1), (1, 3), (3, 1), (3, 3)]) 4 >>> largest_rectangle_area([(1, 1), (1, 2), (3, 1), (3, 3), (3, 2), (2, 2)]) 2 >>> largest_rectangle_area([(1, 1), (2, 2), (3, 3)]) 0","solution":"def largest_rectangle_area(coords): Returns the largest rectangle area that can be formed by the given coordinates with sides parallel to the axes. if len(coords) < 4: return 0 coord_set = set(coords) max_area = 0 for i in range(len(coords)): for j in range(i + 1, len(coords)): x1, y1 = coords[i] x2, y2 = coords[j] if x1 != x2 and y1 != y2: if (x1, y2) in coord_set and (x2, y1) in coord_set: area = abs(x2 - x1) * abs(y2 - y1) if area > max_area: max_area = area return max_area"},{"question":"def is_possible(N: int, roads: List[List[int]]) -> str: Determine if there exist two cities in a kingdom such that every other city can be reached by at least one of them directly or indirectly. >>> is_possible(5, [[1, 2], [1, 3], [1, 4], [4, 5]]) 'YES' >>> is_possible(5, [[1, 2], [2, 3], [4, 5]]) 'NO'","solution":"def is_possible(N, roads): from collections import defaultdict # Function to run a Depth First Search (DFS) and count reachability def dfs(node, visited): stack = [node] count = 0 while stack: curr = stack.pop() if not visited[curr]: visited[curr] = True count += 1 for neighbor in adj_list[curr]: if not visited[neighbor]: stack.append(neighbor) return count # Create adjacency list representation of the graph adj_list = defaultdict(list) for a, b in roads: adj_list[a].append(b) adj_list[b].append(a) # Check connectivity from any city for node in range(1, N + 1): visited = [False] * (N + 1) visited[node] = True count = 0 for neighbor in adj_list[node]: if not visited[neighbor]: result = dfs(neighbor, visited) count += result if count == N - 1: return \\"YES\\" return \\"NO\\""},{"question":"def max_sum_subsequence(n, k, array): Returns the maximum sum of a contiguous subsequence of length k. Args: n (int): Number of elements in the array. k (int): Length of the subsequence. array (list of int): The array of integers. Returns: int: The maximum sum of a contiguous subsequence of length k. >>> max_sum_subsequence(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_sum_subsequence(8, 4, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_sum_subsequence(6, 2, [1, 2, 3, 4, 5, 6]) 11 >>> max_sum_subsequence(4, 4, [1, 2, 3, 4]) 10 >>> max_sum_subsequence(3, 1, [-1, -2, -3]) -1 >>> max_sum_subsequence(3, 2, [10**9, -10**9, 10**9]) 0","solution":"def max_sum_subsequence(n, k, array): Returns the maximum sum of a contiguous subsequence of length k. Args: n (int): Number of elements in the array. k (int): Length of the subsequence. array (list of int): The array of integers. Returns: int: The maximum sum of a contiguous subsequence of length k. # Compute the sum of the first k elements max_sum = curr_sum = sum(array[:k]) # Use a sliding window to find the maximum sum of a subsequence of length k for i in range(k, n): curr_sum += array[i] - array[i - k] if curr_sum > max_sum: max_sum = curr_sum return max_sum"},{"question":"def check_alternating_strings(T: int, strings: List[str]) -> List[str]: Given the number of test cases T and a list of strings, determine if the characters in each string alternate (i.e., no two consecutive characters are the same). Args: T: An integer indicating the number of test cases. strings: A list of strings, each representing a test case. Returns: A list of strings, where each element is \\"YES\\" if the corresponding input string's characters alternate, and \\"NO\\" otherwise. Tests: >>> check_alternating_strings(1, [\\"abab\\"]) [\\"YES\\"] >>> check_alternating_strings(1, [\\"aabb\\"]) [\\"NO\\"] >>> check_alternating_strings(3, [\\"abab\\", \\"aabb\\", \\"abcdefg\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_alternating_strings(1, [\\"a\\"]) [\\"YES\\"] >>> check_alternating_strings(1, [\\"aaaa\\"]) [\\"NO\\"] >>> check_alternating_strings(1, [\\"abcdefghij\\"]) [\\"YES\\"] >>> check_alternating_strings(1, [\\"ab\\" * 5000]) [\\"YES\\"] >>> check_alternating_strings(1, [\\"aa\\" * 5000]) [\\"NO\\"]","solution":"def check_alternating_strings(T, strings): def is_alternating(s): Returns 'YES' if the string s has no two consecutive characters that are the same, otherwise 'NO'. for i in range(1, len(s)): if s[i] == s[i - 1]: return \\"NO\\" return \\"YES\\" results = [] for s in strings: results.append(is_alternating(s)) return results"},{"question":"from typing import List def can_distribute_marbles(n: int, capacities: List[int], m: int, weights: List[int]) -> str: Determines if it is possible to distribute all the marbles into the containers without exceeding any container's capacity. Args: n (int): Number of containers. capacities (list of int): List of capacities of the containers. m (int): Number of marbles. weights (list of int): List of weights of the marbles. Returns: str: \\"YES\\" if it is possible to distribute the marbles, otherwise \\"NO\\". Examples: >>> can_distribute_marbles(3, [10, 5, 8], 4, [3, 5, 3, 2]) \\"YES\\" >>> can_distribute_marbles(2, [5, 5], 3, [7, 2, 2]) \\"NO\\"","solution":"def can_distribute_marbles(n, capacities, m, weights): Determines if it is possible to distribute all the marbles into the containers without exceeding any container's capacity. Args: n (int): Number of containers. capacities (list of int): List of capacities of the containers. m (int): Number of marbles. weights (list of int): List of weights of the marbles. Returns: str: \\"YES\\" if it is possible to distribute the marbles, otherwise \\"NO\\". capacities.sort(reverse=True) weights.sort(reverse=True) for weight in weights: placed = False for i in range(n): if capacities[i] >= weight: capacities[i] -= weight placed = True break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"def final_position(commands): Compute the final position of a robot that moves on a grid according to a series of commands. >>> final_position([\\"N5\\", \\"E10\\", \\"S3\\", \\"W2\\"]) (8, 2) >>> final_position([\\"N10\\", \\"E10\\", \\"S5\\", \\"W5\\"]) (5, 5) >>> final_position([\\"N10\\", \\"S10\\", \\"E10\\", \\"W10\\"]) (0, 0) ...","solution":"def final_position(commands): x, y = 0, 0 for command in commands: direction = command[0] steps = int(command[1:]) if direction == \\"N\\": y += steps elif direction == \\"E\\": x += steps elif direction == \\"S\\": y -= steps elif direction == \\"W\\": x -= steps return (x, y)"},{"question":"from typing import List def product_non_zero(lst: List[int]) -> int: Create a function that calculates the product of all the elements in a given list of integers, excluding the zero elements. You are not allowed to use any loop constructs like \`for\` or \`while\` in your solution. You may use recursive functions or higher-order functions like \`map\`, \`filter\`, and \`reduce\` from your language's standard library. If the list does not contain any non-zero elements, return 1 as the product. >>> product_non_zero([1, 2, 3, 4, 0, 5, 0]) 120 >>> product_non_zero([0, 0, 0, 0]) 1 >>> product_non_zero([3, 0, 2, 0, 4]) 24","solution":"from functools import reduce def product_non_zero(lst): Returns the product of all non-zero elements in the list. If the list does not contain any non-zero elements, returns 1. non_zero_elements = filter(lambda x: x != 0, lst) result = reduce(lambda x, y: x * y, non_zero_elements, 1) return result"},{"question":"def maximize_events(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events, each represented as a tuple (start, end). Returns: int: The maximum number of non-overlapping events. pass def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) events = [] index = 1 for i in range(N): start = int(data[index]) end = int(data[index+1]) events.append((start, end)) index += 2 print(maximize_events(events))","solution":"def maximize_events(events): Returns the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events, each represented as a tuple (start, end). Returns: int: The maximum number of non-overlapping events. # Sort events based on their end times events.sort(key=lambda x: x[1]) max_events = 0 current_end_time = 0 for start, end in events: if start >= current_end_time: max_events += 1 current_end_time = end return max_events def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) events = [] index = 1 for i in range(N): start = int(data[index]) end = int(data[index+1]) events.append((start, end)) index += 2 print(maximize_events(events))"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers, returns a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. This implementation does not use the division operation. :param nums: List[int] - The input list of integers :return: List[int] - The output list where each element is the product of all elements in nums except the element at that index >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3, 4]) == [24, 0, 0, 0, 0] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] >>> product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8] >>> product_except_self([]) == [] >>> product_except_self([1]) == [1] >>> product_except_self([10]) == [1] >>> product_except_self([1, 2]) == [2, 1] >>> product_except_self([10, 20]) == [20, 10]","solution":"def product_except_self(nums): Given a list of integers, returns a new list such that each element at index i of the new list is the product of all the numbers in the original array except the one at i. This implementation does not use the division operation. :param nums: List[int] - The input list of integers :return: List[int] - The output list where each element is the product of all elements in nums except the element at that index length = len(nums) # Initialize the result array with 1's result = [1] * length # Calculate products of all elements to the left of each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each index right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def earliest_time_to_finish(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the earliest time at which the last runner will receive the baton. n: int : number of runners intervals: list of tuples : list of (li, ui) intervals indicating the min and max times for passing the baton return: int : earliest time the last runner receives the baton >>> earliest_time_to_finish(3, [(2, 5), (3, 10)]) 5 >>> earliest_time_to_finish(4, [(1, 4), (2, 6), (1, 3)]) 4","solution":"def earliest_time_to_finish(n, intervals): Determines the earliest time at which the last runner will receive the baton. n: int : number of runners intervals: list of tuples : list of (li, ui) intervals indicating the min and max times for passing the baton return: int : earliest time the last runner receives the baton current_time = 0 for li, ui in intervals: # Since the handoff is instantaneous, we can directly add li to the current_time current_time += li # The baton can only be handed off within the limits li and ui # In an optimal scenario we hand off baton after exactly li time units for minimizing the total time # Finally, after the last runner's waiting time, \`current_time\` will hold the earliest time the baton is received return current_time # Input example n = 3 intervals = [(2, 5), (3, 10)] print(earliest_time_to_finish(n, intervals)) # Output: 5 (not 8 as assumed previously) n = 4 intervals = [(1, 4), (2, 6), (1, 3)] print(earliest_time_to_finish(n, intervals)) # Output: 4"},{"question":"def can_plant_flowers(n: int, k: int, m: int, preferences: List[Tuple[str, int]]) -> str: Returns \\"YES\\" if it is possible to plant flowers in all of Alice's n flowerbeds while satisfying her preferences, otherwise return \\"NO\\". >>> can_plant_flowers(10, 2, 2, [(\\"roses\\", 3), (\\"lilies\\", 2)]) 'YES' >>> can_plant_flowers(5, 3, 2, [(\\"tulips\\", 6), (\\"daisies\\", 3)]) 'NO'","solution":"def can_plant_flowers(n, k, m, preferences): Returns \\"YES\\" if it is possible to plant flowers in all of Alice's n flowerbeds while satisfying her preferences, otherwise return \\"NO\\". for flower_type, count in preferences: if count > n: return \\"NO\\" return \\"YES\\""},{"question":"def longest_distinct_subarray(sequence): Given a sequence of integers, find the length of the longest contiguous subarray with all distinct numbers. >>> longest_distinct_subarray([1, 2, 1, 3, 4]) == 4 >>> longest_distinct_subarray([1, 2, 3, 4, 5, 6, 7]) == 7 >>> longest_distinct_subarray([1]) == 1 >>> longest_distinct_subarray([1, 1, 1, 1]) == 1 >>> longest_distinct_subarray([1, 2, 1, 2, 1, 2, 1, 2]) == 2 >>> longest_distinct_subarray([i for i in range(100000)]) == 100000 >>> longest_distinct_subarray([1, 2, 3, 1, 2, 3, 4, 5, 6]) == 6","solution":"def longest_distinct_subarray(sequence): Given a sequence of integers, find the length of the longest contiguous subarray with all distinct numbers. n = len(sequence) if n == 0: return 0 max_len = 0 start = 0 seen = {} for end in range(n): if sequence[end] in seen and seen[sequence[end]] >= start: start = seen[sequence[end]] + 1 seen[sequence[end]] = end max_len = max(max_len, end - start + 1) return max_len # Function to read input and print output def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) sequence = list(map(int, data[1:])) print(longest_distinct_subarray(sequence)) if __name__ == \\"__main__\\": main()"},{"question":"def count_buildings_with_sunset_view(buildings): Returns the number of buildings that have an unobstructed view of the sunset. Parameters: buildings (list): List of integers representing the heights of the buildings. Returns: int: Number of buildings with an unobstructed view of the sunset. >>> count_buildings_with_sunset_view([4, 2, 3, 1, 5]) 2 >>> count_buildings_with_sunset_view([1, 2, 3, 4]) 4 >>> count_buildings_with_sunset_view([5]) 1 >>> count_buildings_with_sunset_view([3, 3, 3, 3]) 1 >>> count_buildings_with_sunset_view([4, 3, 2, 1]) 1 >>> count_buildings_with_sunset_view([1, 3, 2, 4]) 3 >>> count_buildings_with_sunset_view([7, 7]) 1","solution":"def count_buildings_with_sunset_view(buildings): Returns the number of buildings that have an unobstructed view of the sunset. Parameters: buildings (list): List of integers representing the heights of the buildings. Returns: int: Number of buildings with an unobstructed view of the sunset. max_height = 0 count = 0 for height in buildings: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def findItinerary(flights: List[List[str]], start: str) -> List[str]: Returns the lexicographically smallest itinerary that visits all airports exactly once based on the given flights. >>> findItinerary([['JFK', 'KUL'], ['JFK', 'NRT'], ['NRT', 'JFK']], 'JFK') ['JFK', 'NRT', 'JFK', 'KUL'] >>> findItinerary([['MUC', 'LHR'], ['JFK', 'MUC'], ['SFO', 'SJC'], ['LHR', 'SFO']], 'JFK') ['JFK', 'MUC', 'LHR', 'SFO', 'SJC'] >>> findItinerary([['JFK', 'LAX']], 'JFK') ['JFK', 'LAX'] >>> findItinerary([['ATL', 'EWR'], ['ATL', 'SFO'], ['SFO', 'ATL'], ['EWR', 'ATL']], 'ATL') ['ATL', 'EWR', 'ATL', 'SFO', 'ATL'] >>> findItinerary([['A', 'B'], ['A', 'C'], ['B', 'A'], ['C', 'A']], 'A') ['A', 'B', 'A', 'C', 'A'] >>> findItinerary([['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'A'], ['C', 'A'], ['D', 'A']], 'A') ['A', 'B', 'A', 'C', 'A', 'D', 'A']","solution":"from collections import defaultdict import heapq def findItinerary(flights, start): Returns the lexicographically smallest itinerary that visits all airports exactly once based on the given flights. def visit(airport): while destinations[airport]: next_airport = heapq.heappop(destinations[airport]) visit(next_airport) itinerary.append(airport) # Create a dictionary of destinations with min-heaps to ensure lexicographical order destinations = defaultdict(list) for frm, to in flights: heapq.heappush(destinations[frm], to) itinerary = [] visit(start) return itinerary[::-1]"},{"question":"def zigzag_sort(arr: List[int]) -> List[int]: Sorts the array in a Zigzag manner where numbers alternate between increasing and decreasing order. Example: >>> zigzag_sort([3, 1, 4, 5, 2]) [1, 5, 2, 4, 3] >>> zigzag_sort([9, 2, -3, 7, 4, 5]) [-3, 9, 2, 7, 4, 5]","solution":"def zigzag_sort(arr): Returns the Zigzag sorted array. # Sort array in ascending order arr.sort() # Initialize empty result list result = [] # Initialize pointers for the smallest and largest remaining elements left, right = 0, len(arr) - 1 # Alternate between smallest and largest while left <= right: if left == right: result.append(arr[left]) else: result.append(arr[left]) result.append(arr[right]) left += 1 right -= 1 return result"},{"question":"from typing import List def min_distance(s: str, t: str) -> int: Given two strings s and t, return the minimum number of operations required to convert s into t. The allowed operations are inserting a character, deleting a character, or replacing a character. Example 1: >>> min_distance(\\"horse\\", \\"ros\\") 3 Example 2: >>> min_distance(\\"intention\\", \\"execution\\") 5 Note: 1. 0 ≤ s.length, t.length ≤ 1000 2. All strings consist of lowercase English letters only. def test_example1(): assert min_distance(\\"horse\\", \\"ros\\") == 3 def test_example2(): assert min_distance(\\"intention\\", \\"execution\\") == 5 def test_empty_s(): assert min_distance(\\"\\", \\"abc\\") == 3 def test_empty_t(): assert min_distance(\\"abc\\", \\"\\") == 3 def test_both_empty(): assert min_distance(\\"\\", \\"\\") == 0 def test_identical_strings(): assert min_distance(\\"abc\\", \\"abc\\") == 0 def test_one_char_diff(): assert min_distance(\\"a\\", \\"b\\") == 1 def test_insert_operation(): assert min_distance(\\"a\\", \\"ab\\") == 1 def test_delete_operation(): assert min_distance(\\"ab\\", \\"a\\") == 1 def test_complex_case(): assert min_distance(\\"abcdef\\", \\"azced\\") == 3","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s into string t. Operations allowed: insert a character, delete a character, or replace a character. m, n = len(s), len(t) # dp[i][j] will hold the minimum edit distance between s[0:i] and t[0:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Compute the dp array for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # delete dp[i][j - 1], # insert dp[i - 1][j - 1]) # replace return dp[m][n]"},{"question":"def rank_participants(P: int, R: int, rounds_data: List[Tuple[int, List[Tuple[str, int]]]], scores_data: List[Tuple[str, int]]) -> List[Tuple[str, int, int]]: Ranks participants in a coding competition based on their total accumulated points. :param P: Number of participants :param R: Number of rounds :param rounds_data: List containing rounds details with problem identifiers and maximum scores :param scores_data: List containing participants' names and their scores per round :return: A list of tuples containing participant's name, total score, and rank >>> rank_participants(3, 1, [(3, [(\\"P1\\", 100), (\\"P2\\", 200), (\\"P3\\", 300)])], [(\\"Alice\\", 50, 150, -1), (\\"Bob\\", -1, 200, 250), (\\"Charlie\\", 30, 100, 300)]) [('Bob', 450, 1), ('Charlie', 430, 2), ('Alice', 200, 3)] >>> rank_participants(2, 1, [(2, [(\\"P1\\", 100), (\\"P2\\", 100)])], [(\\"Alice\\", 100, 100), (\\"Bob\\", 100, 100)]) [('Alice', 200, 1), ('Bob', 200, 1)] >>> rank_participants(2, 1, [(3, [(\\"P1\\", 100), (\\"P2\\", 100), (\\"P3\\", 100)])], [(\\"Alice\\", 50, -1, 100), (\\"Bob\\", 100, 100, -1)]) [('Bob', 200, 1), ('Alice', 150, 2)]","solution":"def rank_participants(P, R, rounds_data, scores_data): Ranks participants in a coding competition based on their total accumulated points. :param P: Number of participants :param R: Number of rounds :param rounds_data: List containing rounds details with problem identifiers and maximum scores :param scores_data: List containing participants' names and their scores per round :return: A list of tuples containing participant's name, total score, and rank participant_scores = {} for participant in scores_data: name = participant[0] scores = participant[1:] total_score = sum(score for score in scores if score != -1) participant_scores[name] = total_score sorted_scores = sorted(participant_scores.items(), key=lambda x: (-x[1], x[0])) ranked_results = [] current_rank = 1 previous_score = -1 rank_count = 0 for idx, (name, score) in enumerate(sorted_scores): if score != previous_score: current_rank += rank_count rank_count = 1 else: rank_count += 1 ranked_results.append((name, score, current_rank)) previous_score = score return ranked_results"},{"question":"def check_projects(T: int, projects: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if it is possible to complete all tasks for each project without cyclic dependencies. Args: T (int): The number of projects. projects (List[Tuple[int, int, List[Tuple[int, int]]]]): A list of projects, where each project is represented as a tuple containing the number of tasks, the number of dependency pairs, and a list of dependencies (pairs of tasks). Returns: List[str]: A list where each element is \\"Possible\\" if the tasks for the corresponding project can be completed without cyclic dependencies, otherwise \\"Impossible\\". >>> check_projects(2, [(4, 2, [(1, 2), (3, 1)]), (3, 3, [(1, 2), (2, 3), (3, 1)])]) [\\"Possible\\", \\"Impossible\\"] >>> check_projects(1, [(4, 0, [])]) [\\"Possible\\"] >>> check_projects(1, [(1, 0, [])]) [\\"Possible\\"] >>> check_projects(2, [(3, 2, [(1, 2), (2, 3)]), (5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)])]) [\\"Possible\\", \\"Possible\\"] >>> check_projects(2, [(3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [\\"Impossible\\", \\"Impossible\\"] >>> check_projects(4, [(4, 2, [(1, 2), (3, 1)]), (3, 3, [(1, 2), (2, 3), (3, 1)]), (3, 2, [(1, 2), (3, 2)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 3)])]) [\\"Possible\\", \\"Impossible\\", \\"Possible\\", \\"Impossible\\"]","solution":"from collections import defaultdict, deque def is_possible_to_complete_all_tasks(n, dependencies): Returns whether it is possible to complete all tasks without cyclic dependencies. graph = defaultdict(list) in_degree = [0] * (n + 1) for a, b in dependencies: graph[b].append(a) in_degree[a] += 1 q = deque() for i in range(1, n + 1): if in_degree[i] == 0: q.append(i) count = 0 while q: node = q.popleft() count += 1 for neighbour in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: q.append(neighbour) return count == n def check_projects(T, projects): results = [] for n, m, dependencies in projects: if is_possible_to_complete_all_tasks(n, dependencies): results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def max_strawberries(m: int, n: int, X: int, grid: List[List[int]]) -> int: Determine the maximum number of strawberries Masha can collect from a single non-risky row. >>> max_strawberries(3, 4, 10, [[1, 2, 3, 4], [5, 10, 5, 5], [7, 8, 9, 10]]) == 10 >>> max_strawberries(3, 4, 10, [[1, 10, 3, 4], [5, 10, 5, 5], [7, 8, 9, 10]]) == 0 >>> max_strawberries(3, 4, 10, [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 0 >>> max_strawberries(3, 4, 10, [[1, 2, 3, 4], [5, 5, 5, 5], [7, 8, 9, 9]]) == 33 >>> max_strawberries(4, 4, 10, [[1, 2, 3, 3], [5, 10, 5, 5], [10, 8, 0, 0], [7, 7, 7, 7]]) == 28","solution":"def max_strawberries(m, n, X, grid): max_strawberries = 0 for row in grid: if X not in row: # Check if the row is not risky max_strawberries = max(max_strawberries, sum(row)) return max_strawberries"},{"question":"from typing import List def calculate_differences(arr: List[int]) -> List[int]: Given a list of integers, the goal is to create a new list where each element is the difference between the original element and the smallest element to its right. If there are no elements to the right, leave the original element unchanged. >>> calculate_differences([4, 2, 6, 3, 5, 1]) [3, 1, 5, 2, 4, 1] >>> calculate_differences([10]) [10] >>> calculate_differences([5, 2]) [3, 2] >>> calculate_differences([2, 5]) [-3, 5] >>> calculate_differences([4, 2, 2, 3, 1, 1]) [3, 1, 1, 2, 0, 1] >>> calculate_differences([2, 2, 2, 2]) [0, 0, 0, 2] >>> calculate_differences([1, 2, 3, 4, 5]) [-1, -1, -1, -1, 5] >>> calculate_differences([5, 4, 3, 2, 1]) [4, 3, 2, 1, 1]","solution":"from typing import List def calculate_differences(arr: List[int]) -> List[int]: if not arr: return [] n = len(arr) result = [0] * n min_to_right = float('inf') for i in range(n-1, -1, -1): if i == n-1: result[i] = arr[i] else: result[i] = arr[i] - min_to_right min_to_right = min(min_to_right, arr[i]) return result"},{"question":"def evaluateExpression(expression: str) -> int: Evaluates a simple mathematical expression involving non-negative integers and the operators + and -. The expression is a valid string containing numbers, spaces, +, and -. >>> evaluateExpression(\\"3+2-5\\") == 0 >>> evaluateExpression(\\"10 + 2 - 6\\") == 6 >>> evaluateExpression(\\"100 - 20 + 5 - 5\\") == 80","solution":"def evaluateExpression(expression: str) -> int: Evaluates a simple mathematical expression involving non-negative integers and the operators + and -. The expression is a valid string containing numbers, spaces, +, and -. Parameters: expression (str): A valid mathematical expression in string format. Returns: int: The result of evaluating the expression. # Remove all spaces from the expression expression = expression.replace(\\" \\", \\"\\") # Initialize variables to store the current number and result current_number = 0 result = 0 # Keep track of the current operation (start with +) operation = '+' for char in expression: if char.isdigit(): # Build the current number current_number = current_number * 10 + int(char) else: # If we encounter an operator, calculate the result based on the previous operation if operation == '+': result += current_number elif operation == '-': result -= current_number # Update the operation and reset current number operation = char current_number = 0 # Apply the last operation to the last number if operation == '+': result += current_number elif operation == '-': result -= current_number return result"},{"question":"from typing import List, Dict def get_change(amount: int, denominations: List[int]) -> Dict[int, int]: Create a function that identifies the smallest set of coins and bills needed to make a given amount of money. The function should accept two parameters: the target amount of money and a list of available denominations. It should return a dictionary with the count of each denomination used to make up the target amount. If it is impossible to make the exact target amount with the given denominations, return an empty dictionary. >>> get_change(97, [1, 5, 10, 25, 50]) == {50: 1, 25: 1, 10: 2, 1: 2} >>> get_change(365, [1, 5, 10, 20, 50, 100]) == {100: 3, 50: 1, 10: 1, 5: 1} >>> get_change(3, [5, 10, 20]) == {} >>> get_change(0, [1, 5, 10, 25, 50]) == {} >>> get_change(30, [30, 40, 50]) == {30: 1} >>> get_change(7, [1, 3, 4]) == {4: 1, 3: 1} >>> get_change(58, [1, 5, 10, 25, 50]) == {50: 1, 5: 1, 1: 3}","solution":"def get_change(amount, denominations): Finds the smallest set of coins and bills needed to make a given amount of money using the provided denominations. Assumes denominations are sorted in ascending order. Returns a dictionary with the count of each denomination used. denomination_count = {} for den in reversed(denominations): if amount == 0: break count = amount // den if count > 0: denomination_count[den] = count amount -= count * den if amount != 0: return {} return denomination_count"},{"question":"def max_slots_occupied(n: int, m: int, server_slots: List[int], process_slots: List[int]) -> int: Calculate the maximum number of slots occupied with the new processes. >>> max_slots_occupied(5, 3, [4, 6, 2, 7, 5], [3, 2, 1]) 6 >>> max_slots_occupied(3, 3, [0, 0, 0], [1, 2, 3]) 0 >>> max_slots_occupied(5, 0, [1, 2, 3, 4, 5], []) 0 >>> max_slots_occupied(5, 1, [2, 2, 2, 2, 2], [1]) 1 >>> max_slots_occupied(10, 5, [10]*10, [2, 2, 2, 2, 2]) 10 >>> max_slots_occupied(4, 4, [4, 4, 4, 4], [4, 4, 4, 4]) 16 >>> max_slots_occupied(4, 5, [5, 7, 8, 4], [2, 3, 2, 1, 3]) 11","solution":"def max_slots_occupied(n, m, server_slots, process_slots): # Sort the process slots in descending order process_slots.sort(reverse=True) max_occupied = 0 for i in range(n): current_occupied = 0 used_processes = [False] * m for j in range(i, n): for k in range(m): if not used_processes[k] and server_slots[j] >= process_slots[k]: server_slots[j] -= process_slots[k] current_occupied += process_slots[k] used_processes[k] = True max_occupied = max(max_occupied, current_occupied) # Reset server slots server_slots = [server_slots[kk] + sum(process_slots[k] for k in range(m) if used_processes[k]) if ii == i else server_slots[kk] for ii, kk in enumerate(range(len(server_slots)))] return max_occupied"},{"question":"def transformString(s: str) -> str: Given a string containing various characters, produce a new string where each character is replaced by the next character in the English alphabet. If a character is 'z' or 'Z', it should wrap around to 'a' or 'A' respectively. Example 1: >>> transformString(\\"abcdef\\") \\"bcdefg\\" Example 2: >>> transformString(\\"AzBY\\") \\"BaCZ\\"","solution":"def transformString(s): Transforms the input string such that each character is replaced by the next character in the English alphabet. 'z' wraps around to 'a' and 'Z' to 'A'. def next_char(c): if c == 'z': return 'a' elif c == 'Z': return 'A' else: return chr(ord(c) + 1) return ''.join(next_char(c) for c in s)"},{"question":"def findArmstrongNumbers(n: int) -> List[int]: Find all Armstrong numbers less than or equal to n. >>> findArmstrongNumbers(1000) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407] >>> findArmstrongNumbers(100) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","solution":"def findArmstrongNumbers(n): Find all Armstrong numbers up to and including n. def is_armstrong(number): digits = list(map(int, str(number))) power = len(digits) return sum(digit ** power for digit in digits) == number return [num for num in range(n + 1) if is_armstrong(num)]"},{"question":"def min_operations_to_equalize(banks): Given a list of non-negative integers representing the amount of money in each bank, calculate the minimum number of operations required to equalize all banks' amounts. An operation consists of picking any two banks and incrementing the amount of money in one of the banks by 1 and decrementing the amount in the other bank by 1. Args: banks: List[int] - a list of non-negative integers representing the amount of money in each bank Returns: int - the minimum number of operations required to equalize all banks' amounts Examples: >>> min_operations_to_equalize([1, 3, 2, 4]) 2 >>> min_operations_to_equalize([5, 5, 5, 5]) 0 >>> min_operations_to_equalize([7]) 0","solution":"def min_operations_to_equalize(banks): Given a list of non-negative integers representing the amount of money in each bank, calculate the minimum number of operations required to equalize all banks' amounts. An operation consists of picking any two banks and incrementing the amount of money in one of the banks by 1 and decrementing the amount in the other bank by 1. Args: banks: List[int] - a list of non-negative integers representing the amount of money in each bank Returns: int - the minimum number of operations required to equalize all banks' amounts total_money = sum(banks) n = len(banks) mean_value = total_money // n operations = 0 for money in banks: operations += abs(money - mean_value) return operations // 2"},{"question":"def find_odd_occurrence(n: int, arr: List[int]) -> int: Given an array of n integers where each integer appears an even number of times except for one integer which appears an odd number of times, this function returns the integer that appears an odd number of times. >>> find_odd_occurrence(5, [1, 2, 3, 2, 1]) == 3 >>> find_odd_occurrence(7, [4, 5, 4, 5, 4, 5, 4]) == 5 >>> find_odd_occurrence(9, [6, 7, 8, 7, 8, 9, 9, 9, 6]) == 9 >>> find_odd_occurrence(1, [10]) == 10","solution":"def find_odd_occurrence(n, arr): Given an array of n integers where each integer appears an even number of times except for one integer which appears an odd number of times, this function returns the integer that appears an odd number of times. result = 0 for number in arr: result ^= number return result"},{"question":"def most_frequent_element(arr, queries): Returns a list of most frequent elements for each query. Parameters: arr (list): The list of integers. queries (list of tuples): The list of queries where each query is a tuple (L, R). Returns: list: The list containing the most frequent element for each query. Examples: >>> most_frequent_element([1, 2, 2, 3, 1], [(1, 3), (2, 4), (1, 5)]) [2, 2, 1] >>> most_frequent_element([1], [(1, 1)]) [1]","solution":"from collections import defaultdict def most_frequent_element(arr, queries): Returns a list of most frequent elements for each query. Parameters: arr (list): The list of integers. queries (list of tuples): The list of queries where each query is a tuple (L, R). Returns: list: The list containing the most frequent element for each query. results = [] for q in queries: L, R = q subarray = arr[L-1:R] frequency = defaultdict(int) # Count frequencies for num in subarray: frequency[num] += 1 # Find the most frequent element max_frequency = max(frequency.values()) most_frequent = min(key for key, value in frequency.items() if value == max_frequency) results.append(most_frequent) return results"},{"question":"def distribute_candies(N: int) -> List[int]: Distribute candies to children such that each child gets a distinct number of candies and the absolute differences between numbers are minimized. Args: N (int): Number of children Returns: List[int]: List of integers representing the number of candies each child gets >>> distribute_candies(2) [1, 2] >>> distribute_candies(3) [1, 2, 3] >>> distribute_candies(5) [1, 2, 3, 4, 5] >>> distribute_candies(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> distribute_candies(50) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]","solution":"def distribute_candies(N): Distributes candies to children in such a way that each child gets a distinct number of candies and the absolute differences between consecutive distributions are minimized. Args: N (int): Number of children Returns: List[int]: List of integers representing the number of candies each child gets return list(range(1, N + 1)) # Example usage: # print(distribute_candies(5)) # Output: [1, 2, 3, 4, 5]"},{"question":"def arrayModifier(arr: list[int], mode: str) -> list[int]: Modifies the array based on the mode ('odd' or 'even'). - \\"odd\\": Increment each odd integer by 1. - \\"even\\": Decrement each even integer by 1. Parameters: arr (list of int): The input list of integers. mode (str): The mode, either \\"odd\\" or \\"even\\". Returns: list of int: The modified list. Examples: >>> arrayModifier([1, 2, 3, 4, 5], \\"odd\\") [2, 2, 4, 4, 6] >>> arrayModifier([1, 2, 3, 4, 5], \\"even\\") [1, 1, 3, 3, 5]","solution":"def arrayModifier(arr, mode): Modifies the array based on the mode ('odd' or 'even'). - \\"odd\\": Increment each odd integer by 1. - \\"even\\": Decrement each even integer by 1. Parameters: arr (list of int): The input list of integers. mode (str): The mode, either \\"odd\\" or \\"even\\". Returns: list of int: The modified list. if mode == \\"odd\\": return [x + 1 if x % 2 != 0 else x for x in arr] elif mode == \\"even\\": return [x - 1 if x % 2 == 0 else x for x in arr] else: raise ValueError(\\"Mode must be 'odd' or 'even'\\")"},{"question":"def generate_identifiers(submissions): Generate unique identifiers for each submission. The format of the identifier is X-y, where X is the unique username and y is a non-negative integer that increments for each subsequent submission by the same user. >>> generate_identifiers([\\"john\\", \\"jane\\", \\"john\\", \\"jane\\", \\"john\\"]) [\\"john-0\\", \\"jane-0\\", \\"john-1\\", \\"jane-1\\", \\"john-2\\"] >>> generate_identifiers([\\"alice\\", \\"alice\\", \\"alice\\"]) [\\"alice-0\\", \\"alice-1\\", \\"alice-2\\"] >>> generate_identifiers([\\"bob\\", \\"bob\\", \\"alice\\", \\"alice\\", \\"bob\\"]) [\\"bob-0\\", \\"bob-1\\", \\"alice-0\\", \\"alice-1\\", \\"bob-2\\"]","solution":"def generate_identifiers(submissions): counts = {} identifiers = [] for username in submissions: if username not in counts: counts[username] = 0 else: counts[username] += 1 identifier = f\\"{username}-{counts[username]}\\" identifiers.append(identifier) return identifiers"},{"question":"def highest_average_score(T: int, test_cases: List[Tuple[int, List[Tuple[str, int, int, int]]]]) -> List[str]: Given a list of students and their scores in three subjects for multiple test cases, find the average score of each student and identify the highest average score among them. If there are multiple students with the same highest average score, return all of them. >>> highest_average_score(1, [(1, [(\\"Alice\\", 100, 100, 100)])]) [\\"Alice 100.00\\"] >>> highest_average_score(1, [(3, [(\\"Alice\\", 90, 80, 70), (\\"Bob\\", 85, 90, 95), (\\"Charlie\\", 50, 60, 70)])]) [\\"Bob 90.00\\"] >>> highest_average_score(2, [(3, [(\\"Alice\\", 90, 80, 70), (\\"Bob\\", 85, 90, 95), (\\"Charlie\\", 50, 60, 70)]), (2, [(\\"David\\", 100, 90, 80), (\\"Eve\\", 85, 95, 100)])]) [\\"Bob 90.00\\", \\"Eve 93.33\\"] >>> highest_average_score(1, [(3, [(\\"Alice\\", 90, 90, 90), (\\"Bob\\", 90, 90, 90), (\\"Charlie\\", 85, 85, 85)])]) [\\"Alice 90.00\\", \\"Bob 90.00\\"] >>> highest_average_score(1, [(2, [(\\"Alice\\", 0, 0, 0), (\\"Bob\\", 100, 100, 100)])]) [\\"Bob 100.00\\"] >>> highest_average_score(1, [(4, [(\\"Alice\\", 100, 100, 99), (\\"Bob\\", 100, 100, 99), (\\"Charlie\\", 95, 100, 100), (\\"David\\", 99, 100, 100)])]) [\\"Alice 99.67\\", \\"Bob 99.67\\", \\"David 99.67\\"]","solution":"def highest_average_score(T, test_cases): results = [] for i in range(T): N, students = test_cases[i] highest_avg = 0 avg_scores = {} for student in students: name, score1, score2, score3 = student avg_score = (score1 + score2 + score3) / 3.0 avg_scores[name] = avg_score if avg_score > highest_avg: highest_avg = avg_score # Get all students with the highest average score top_students = [name for name, avg in avg_scores.items() if avg == highest_avg] top_students.sort() for student in top_students: results.append(f\\"{student} {highest_avg:.2f}\\") return results"},{"question":"def arithmatica_pairing(N, numbers): Determine if it is possible to pair all numbers such that each number is paired with a number of a different parity (odd with even and vice versa). Parameters: N (int): Number of numbers on the scroll. numbers (list of int): The numbers on the scroll. Returns: str: \\"POSSIBLE\\" if all numbers can be paired accordingly, \\"IMPOSSIBLE\\" otherwise. Examples: >>> arithmatica_pairing(4, [1, 2, 3, 4]) \\"POSSIBLE\\" >>> arithmatica_pairing(3, [1, 2, 3]) \\"IMPOSSIBLE\\"","solution":"def arithmatica_pairing(N, numbers): Determine if it is possible to pair all numbers such that each number is paired with a number of a different parity (odd with even and vice versa). Parameters: N (int): Number of numbers on the scroll. numbers (list of int): The numbers on the scroll. Returns: str: \\"POSSIBLE\\" if all numbers can be paired accordingly, \\"IMPOSSIBLE\\" otherwise. even_count = sum(1 for num in numbers if num % 2 == 0) odd_count = N - even_count if even_count == odd_count: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def is_prime(n: int) -> bool: Helper function to determine if n is a prime number. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(15) False >>> is_prime(17) True def sort_primes_before_non_primes(arr: List[int]) -> List[int]: Sort the array such that prime numbers appear before non-prime numbers while maintaining relative order within the groups. >>> sort_primes_before_non_primes([1, 7, 4, 2, 10, 3]) [7, 2, 3, 1, 4, 10] >>> sort_primes_before_non_primes([10, 9, 8, 7, 6]) [7, 10, 9, 8, 6] >>> sort_primes_before_non_primes([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> sort_primes_before_non_primes([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> sort_primes_before_non_primes([1, 1, 1, 1, 2]) [2, 1, 1, 1, 1] >>> sort_primes_before_non_primes([3, 4, 5, 6, 7, 8, 9, 10]) [3, 5, 7, 4, 6, 8, 9, 10]","solution":"def is_prime(n): Helper function to determine if n is a prime number. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sort_primes_before_non_primes(arr): Sort the array such that prime numbers appear before non-prime numbers while maintaining relative order within the groups. primes = [x for x in arr if is_prime(x)] non_primes = [x for x in arr if not is_prime(x)] return primes + non_primes"},{"question":"from typing import List def reorder_array(nums: List[int]) -> List[int]: Modify the array such that all even numbers come before all odd numbers, maintaining their relative order. >>> reorder_array([1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> reorder_array([4, 3, 2, 1]) [4, 2, 3, 1] >>> reorder_array([0, 1, 2, 3, 4, 5]) [0, 2, 4, 1, 3, 5]","solution":"from typing import List def reorder_array(nums: List[int]) -> List[int]: even_nums = [num for num in nums if num % 2 == 0] odd_nums = [num for num in nums if num % 2 != 0] return even_nums + odd_nums"},{"question":"def count_unique_employees(d: int, days: List[List[int]]) -> int: Returns the number of unique employees that participated over all the days. :param d: Number of days. :param days: List of lists, where each inner list specifies the number of employees for that day followed by their IDs. :return: Integer, the total number of unique employees. >>> count_unique_employees(4, [[3, 1, 2, 3], [4, 2, 4, 5, 6], [5, 7, 8, 9, 10, 1], [2, 10, 11]]) == 11 >>> count_unique_employees(1, [[1, 1]]) == 1 >>> count_unique_employees(3, [[2, 1, 2], [2, 3, 4], [2, 5, 6]]) == 6 >>> count_unique_employees(3, [[2, 1, 2], [2, 1, 2], [2, 1, 2]]) == 2 >>> count_unique_employees(3, [[0], [0], [0]]) == 0 >>> count_unique_employees(1, [[5, 10, 20, 30, 40, 50]]) == 5","solution":"def count_unique_employees(d, days): Returns the number of unique employees that participated over all the days. :param d: Number of days. :param days: List of lists, where each inner list specifies the number of employees for that day followed by their IDs. :return: Integer, the total number of unique employees. unique_employees = set() for day in days: employees = day[1:] unique_employees.update(employees) return len(unique_employees)"},{"question":"def frequency_analyzer(N, words): Analyzes the frequency of each word in the given list and returns a sorted list of words and their frequencies. Words with the same frequency are sorted in ascending lexicographical order. :param N: Number of words :param words: List of words :return: Sorted list of words with their frequencies >>> frequency_analyzer(5, [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\"]) [\\"apple 2\\", \\"banana 2\\", \\"orange 1\\"] >>> frequency_analyzer(1, [\\"hello\\"]) [\\"hello 1\\"] >>> frequency_analyzer(3, [\\"apple\\", \\"banana\\", \\"orange\\"]) [\\"apple 1\\", \\"banana 1\\", \\"orange 1\\"] >>> frequency_analyzer(3, [\\"dog\\", \\"cat\\", \\"bat\\"]) [\\"bat 1\\", \\"cat 1\\", \\"dog 1\\"] >>> frequency_analyzer(4, [\\"dog\\", \\"cat\\", \\"cat\\", \\"bat\\"]) [\\"cat 2\\", \\"bat 1\\", \\"dog 1\\"]","solution":"def frequency_analyzer(N, words): Analyzes the frequency of each word in the given list and returns a sorted list of words and their frequencies. Words with the same frequency are sorted in ascending lexicographical order. :param N: Number of words :param words: List of words :return: Sorted list of words with their frequencies from collections import Counter # Calculating the frequency of each word word_count = Counter(words) # Sorting the words first by frequency and then lexicographically sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Preparing the output format result = [f\\"{word} {count}\\" for word, count in sorted_words] return result"},{"question":"def even_squares(lst: List[int]) -> List[int]: Given a list of integers, return a new list containing the square of each integer, but only include the squares that are even numbers. >>> even_squares([1, 2, 3, 4, 5]) [4, 16] >>> even_squares([-1, -2, -3, -4, -5]) [4, 16] >>> even_squares([0, 3, 6, 9, 12]) [0, 36, 144] >>> even_squares([11, 13, 17, 19]) [] >>> even_squares([2, -4, 6, -8, 10]) [4, 16, 36, 64, 100]","solution":"def even_squares(lst): Returns a list containing the squares of the even integers from the input list. return [x**2 for x in lst if (x**2) % 2 == 0]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findDiameter(root): Given the root of a binary tree, this function returns the diameter of the tree. The diameter is defined as the length of the longest path between any two nodes in the tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The diameter of the binary tree. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> findDiameter(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> findDiameter(root) 2","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def findDiameter(root): Function to return the diameter of the binary tree. def diameter_and_height(node): if not node: return 0, 0 # diameter, height left_diameter, left_height = diameter_and_height(node.left) right_diameter, right_height = diameter_and_height(node.right) current_diameter = left_height + right_height max_diameter = max(current_diameter, left_diameter, right_diameter) current_height = 1 + max(left_height, right_height) return max_diameter, current_height diameter, _ = diameter_and_height(root) return diameter"},{"question":"def check_bonus(sales_target: int, actual_sales: int) -> str: Given the sales target and actual sales achieved, determines if the employee will receive a bonus. Parameters: sales_target (int): The sales target that needs to be achieved or exceeded. actual_sales (int): The actual sales achieved by the employee. Returns: str: \\"BONUS\\" if actual sales are greater than or equal to the sales target, otherwise \\"NO BONUS\\". >>> check_bonus(1500, 1600) 'BONUS' >>> check_bonus(1500, 1200) 'NO BONUS'","solution":"def check_bonus(sales_target, actual_sales): Given the sales target and actual sales achieved, determines if the employee will receive a bonus. Parameters: - sales_target (int): The sales target that needs to be achieved or exceeded. - actual_sales (int): The actual sales achieved by the employee. Returns: - str: \\"BONUS\\" if actual sales are greater than or equal to the sales target, otherwise \\"NO BONUS\\". if actual_sales >= sales_target: return \\"BONUS\\" else: return \\"NO BONUS\\""},{"question":"def maximum_sum_subgrid(grid: List[List[int]]) -> int: Find the maximum sum of any contiguous sub-grid within the grid. >>> maximum_sum_subgrid([ [1, -2, 0], [-3, 4, 2], [1, -1, -2]]) 6 >>> maximum_sum_subgrid([ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]]) 29 pass def max_sum_subgrid(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: For each test case, find the maximum sum of any contiguous sub-grid. >>> max_sum_subgrid(2, [ (3, [ [1, -2, 0], [-3, 4, 2], [1, -1, -2]]), (5, [ [2, 1, -3, -4, 5], [0, 6, 3, 4, 1], [2, -2, -1, 4, -5], [-3, 3, 1, 0, 3], [2, 1, -4, -4, 6]]) ]) [6, 18] pass","solution":"def maximum_sum_subgrid(grid): def max_kadane(nums): max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global N = len(grid) max_sum = float('-inf') for left in range(N): temp = [0] * N for right in range(left, N): for i in range(N): temp[i] += grid[i][right] current_max = max_kadane(temp) if current_max > max_sum: max_sum = current_max return max_sum def max_sum_subgrid(T, test_cases): results = [] for i in range(T): N, grid = test_cases[i] results.append(maximum_sum_subgrid(grid)) return results"},{"question":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Rearranges the list into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it rearranges it into the lowest possible order. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1]","solution":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Rearranges the list into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it rearranges it into the lowest possible order. # Find the first decreasing element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i == -1: # If no such element found, reverse the list nums.reverse() return nums # Find the element just larger than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap them nums[i], nums[j] = nums[j], nums[i] # Reverse the elements from i+1 to end to get the next permutation nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def rank_participants(N: int, participants: List[str]) -> str: Rank participants based on their points and submission time. Parameters: - N: int - Total number of participants - participants: List[str] - List of participant data in the format \\"ParticipantID Points Timestamp\\" Returns: - str - Participant IDs sorted by their ranks from highest to lowest, separated by spaces >>> rank_participants(4, [ ... \\"alice 23 2023-08-17 14:32:20\\", ... \\"bob 26 2023-08-17 14:30:10\\", ... \\"charlie 23 2023-08-17 14:30:09\\", ... \\"diana 25 2023-08-17 14:30:11\\" ... ]) \\"bob diana charlie alice\\" >>> rank_participants(3, [ ... \\"alice 23 2023-08-17 14:32:20\\", ... \\"bob 23 2023-08-17 14:30:10\\", ... \\"charlie 23 2023-08-17 14:30:09\\" ... ]) \\"charlie bob alice\\" >>> rank_participants(3, [ ... \\"alice 0 2023-08-17 14:32:20\\", ... \\"bob 0 2023-08-17 14:30:10\\", ... \\"charlie 0 2023-08-17 14:30:09\\" ... ]) \\"charlie bob alice\\" >>> rank_participants(1, [\\"alice 15 2023-08-17 14:32:20\\"]) \\"alice\\" >>> rank_participants(4, [ ... \\"a1 50 2023-10-17 10:10:10\\", ... \\"a2 75 2023-10-17 10:20:10\\", ... \\"a3 50 2023-10-17 09:10:10\\", ... \\"a4 80 2023-10-17 10:30:10\\" ... ]) \\"a4 a2 a3 a1\\"","solution":"def rank_participants(N, participants): # First, parse the input into a list of tuples parsed_participants = [] for p in participants: parts = p.split() identifier = parts[0] points = int(parts[1]) timestamp = parts[2] + \\" \\" + parts[3] parsed_participants.append((identifier, points, timestamp)) # Sort participants by points (descending) and then by timestamp (ascending) sorted_participants = sorted(parsed_participants, key=lambda x: (-x[1], x[2])) # Extract and return only the identifiers in a single line result = \\" \\".join([p[0] for p in sorted_participants]) return result"},{"question":"def matlab_to_list(matlab_str: str) -> list: Converts a MATLAB-style array initialization string into a nested list. Args: matlab_str (str): A string representing a MATLAB-style array initialization. Returns: list: A nested list representing the array. Examples: >>> matlab_to_list('[1 2 3; 4 5 6; 7 8 9]') [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> matlab_to_list('[10, 20, 30; 40, 50, 60]') [[10, 20, 30], [40, 50, 60]] >>> matlab_to_list('[3 4; 5 6]') [[3, 4], [5, 6]] >>> matlab_to_list('[]') [] >>> matlab_to_list('[1]') [[1]] >>> matlab_to_list('[1 2 3]') [[1, 2, 3]] >>> matlab_to_list('[1, 2, 3]') [[1, 2, 3]] >>> matlab_to_list('[1; 2; 3]') [[1], [2], [3]] >>> matlab_to_list('[3 4; 5, 6]') [[3, 4], [5, 6]] >>> matlab_to_list('[1, 2 3; 4, 5, 6]') [[1, 2, 3], [4, 5, 6]]","solution":"def matlab_to_list(matlab_str): Converts a MATLAB-style array initialization string into a nested list. Args: matlab_str (str): A string representing a MATLAB-style array initialization. Returns: list: A nested list representing the array. # Strip the brackets clean_str = matlab_str.strip('[]') if not clean_str: return [] # Split by semicolon to get rows rows = clean_str.split(';') # Split each row by space to get columns array = [list(map(int, row.replace(',', ' ').split())) for row in rows] return array"},{"question":"import re def is_valid_palindrome(s: str) -> bool: Returns True if the string s is a valid palindrome when ignoring non-alphanumeric characters and case. pass def validate_palindromes(n: int, strings: List[str]) -> List[bool]: Returns a list of boolean values indicating if each string in the input list is a valid palindrome. >>> validate_palindromes(3, [\\"A man, a plan, a canal, Panama!\\", \\"race a car\\", \\"No lemon, no melon\\"]) == [True, False, True] >>> validate_palindromes(2, [\\"Madam In Eden, I'm Adam\\", \\"Was it a car or a cat I saw?\\"]) == [True, True] pass # Unit Tests def test_validate_palindromes_example1(): assert validate_palindromes(3, [\\"A man, a plan, a canal, Panama!\\", \\"race a car\\", \\"No lemon, no melon\\"]) == [True, False, True] def test_validate_palindromes_example2(): assert validate_palindromes(2, [\\"Madam In Eden, I'm Adam\\", \\"Was it a car or a cat I saw?\\"]) == [True, True] def test_validate_palindromes_empty_string(): assert validate_palindromes(1, [\\"\\"]) == [True] def test_validate_palindromes_single_characters(): assert validate_palindromes(3, [\\"a\\", \\"B\\", \\"C\\"]) == [True, True, True] def test_validate_palindromes_mixed_cases(): assert validate_palindromes(2, [\\"Able was I ere I saw Elba\\", \\"Never odd or even\\"]) == [True, True] def test_validate_palindromes_non_palindromes(): assert validate_palindromes(3, [\\"hello\\", \\"world\\", \\"test\\"]) == [False, False, False]","solution":"import re def is_valid_palindrome(s): Returns True if the string s is a valid palindrome when ignoring non-alphanumeric characters and case. # Use regex to filter out non-alphanumeric characters and convert to lowercase filtered_s = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the filtered string is equal to its reverse return filtered_s == filtered_s[::-1] def validate_palindromes(n, strings): Returns a list of boolean values indicating if each string in the input list is a valid palindrome. result = [] for s in strings: result.append(is_valid_palindrome(s)) return result"},{"question":"def check_ingredients(n: int, required: List[int], available: List[int]) -> str: Checks if the available amount of each ingredient is enough for the required amount. >>> check_ingredients(3, [500, 200, 300], [600, 200, 400]) \\"Enough\\" >>> check_ingredients(3, [500, 200, 300], [400, 200, 400]) \\"Not enough\\" >>> check_ingredients(3, [500, 200, 300], [600, 100, 400]) \\"Not enough\\" >>> check_ingredients(3, [500, 200, 300], [500, 200, 300]) \\"Enough\\" >>> check_ingredients(1, [100], [150]) \\"Enough\\" >>> check_ingredients(1, [100], [50]) \\"Not enough\\" >>> check_ingredients(1000, [1]*1000, [1]*1000) \\"Enough\\" >>> check_ingredients(1000, [1]*1000, [1]*999 + [0]) \\"Not enough\\"","solution":"def check_ingredients(n, required, available): Checks if the available amount of each ingredient is enough for the required amount. Parameters: n (int): The number of ingredients. required (list of int): The required amount of each ingredient. available (list of int): The available amount of each ingredient. Returns: str: \\"Enough\\" if all required ingredients are available in sufficient amount, otherwise \\"Not enough\\". for req, avail in zip(required, available): if avail < req: return \\"Not enough\\" return \\"Enough\\""},{"question":"def min_unique_substrings(s: str) -> int: Given a string s, determine the minimum number of contiguous substrings you can split the string into such that each substring contains only unique characters. >>> min_unique_substrings(\\"abac\\") == 2 >>> min_unique_substrings(\\"aaaaaa\\") == 6 >>> min_unique_substrings(\\"a\\") == 1 >>> min_unique_substrings(\\"abcde\\") == 1 >>> min_unique_substrings(\\"abacabad\\") == 4 >>> min_unique_substrings(\\"abcdeabcdef\\") == 2 >>> min_unique_substrings(\\"ababab\\") == 3","solution":"def min_unique_substrings(s): Returns the minimum number of contiguous substrings such that each substring contains only unique characters. substrings = 1 seen_chars = set() for char in s: if char in seen_chars: substrings += 1 seen_chars = set(char) else: seen_chars.add(char) return substrings"},{"question":"def uniqueCharacterCount(s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string \`s\` and a list of queries where each query contains a pair of indices \`(i, j)\`, find the number of unique characters in the substring \`s[i...j]\`. >>> uniqueCharacterCount(\\"abacaba\\", [(0, 3), (1, 4), (2, 6)]) [3, 3, 3] >>> uniqueCharacterCount(\\"abcdef\\", [(0, 5), (1, 4), (2, 3)]) [6, 4, 2]","solution":"def uniqueCharacterCount(s, queries): Returns the count of unique characters in the substring s[i...j] for each given pair of indices (i, j) in queries. result = [] for i, j in queries: substring = s[i:j+1] unique_chars = set(substring) result.append(len(unique_chars)) return result"},{"question":"def solution(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Perform a series of queries on an array. Each query can be one of two types: 1. \\"1 x y\\": Update the element at index x to y. 2. \\"2 x y\\": Find the sum of the elements from index x to index y (inclusive). Args: n (int): Length of the array. q (int): Number of queries. array (List[int]): Array of integers. queries (List[Tuple[int, int, int]]): List of queries. Returns: List[int]: Results of all \\"2 x y\\" queries. Example: >>> solution(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 1, 3), (2, 2, 5), (1, 5, 6)]) [6, 13, 21] pass","solution":"class NumArray: def __init__(self, nums): self.n = len(nums) self.nums = nums self.bit = [0] * (self.n + 1) for i in range(self.n): self.add(i + 1, nums[i]) def add(self, index, value): while index <= self.n: self.bit[index] += value index += index & -index def sum(self, index): result = 0 while index > 0: result += self.bit[index] index -= index & -index return result def update(self, index, value): diff = value - self.nums[index - 1] self.nums[index - 1] = value self.add(index, diff) def range_sum(self, left, right): return self.sum(right) - self.sum(left - 1) def handle_queries(n, q, array, queries): num_array = NumArray(array) results = [] for query in queries: q_type, x, y = query if q_type == 1: num_array.update(x, y) elif q_type == 2: results.append(num_array.range_sum(x, y)) return results def solution(n, q, array, queries): return handle_queries(n, q, array, queries)"},{"question":"def count_segments_with_sum(A, N, M): Returns the number of contiguous subarrays that sum up to M. >>> count_segments_with_sum([1, 2, 3, 2, 1], 5, 5) == 2 >>> count_segments_with_sum([5], 1, 5) == 1 >>> count_segments_with_sum([1], 1, 5) == 0 >>> count_segments_with_sum([1, 1, 1, 1, 1], 5, 5) == 1 >>> count_segments_with_sum([1, 2, 3, -1, 2, 3], 6, 5) == 3 >>> count_segments_with_sum([1, 2, -1, 4], 4, 10) == 0 >>> count_segments_with_sum([-1, -2, -3, -4], 4, -5) == 1 >>> count_segments_with_sum([1, -1, 2, -2, 3, -1, 2], 7, 3) == 4 >>> count_segments_with_sum([1]*100000, 100000, 100) == 99901","solution":"def count_segments_with_sum(A, N, M): Returns the number of contiguous subarrays that sum up to M. count = 0 prefix_sum = 0 prefix_sum_count = {0: 1} for num in A: prefix_sum += num if (prefix_sum - M) in prefix_sum_count: count += prefix_sum_count[prefix_sum - M] if prefix_sum in prefix_sum_count: prefix_sum_count[prefix_sum] += 1 else: prefix_sum_count[prefix_sum] = 1 return count"},{"question":"from typing import List def min_operations_to_balance_string(s: str) -> int: Determine the minimum number of operations required to convert the given string into a balanced string. In one operation, you can pick any character of the string and replace it with any other lowercase letter. Args: s (str): The input string Returns: int: Minimum number of operations pass def balance_strings(t: int, strings: List[str]) -> List[int]: Given the number of test cases and a list of strings, determine the minimum number of operations required for each string to become balanced. Args: t (int): Number of test cases strings (List[str]): List of input strings Returns: List[int]: List of minimum number of operations for each string pass # Unit tests def test_min_operations_to_balance_string(): assert balance_strings(3, [\\"aabb\\", \\"abcde\\", \\"aaabb\\"]) == [2, 4, 2] def test_min_operations_all_same_char(): assert balance_strings(1, [\\"aaaa\\"]) == [0] def test_min_operations_different_lengths(): assert balance_strings(2, [\\"aabc\\", \\"aabbcc\\"]) == [2, 4] def test_min_operations_all_different(): assert balance_strings(1, [\\"abcdefghij\\"]) == [9] def test_min_operations_single_char(): assert balance_strings(1, [\\"a\\"]) == [0]","solution":"from collections import Counter def min_operations_to_balance_string(s): counter = Counter(s) n = len(s) most_common_freq = max(counter.values()) return n - most_common_freq def balance_strings(t, strings): results = [] for s in strings: results.append(min_operations_to_balance_string(s)) return results"},{"question":"def matrix_transformations(matrix, sequence): Perform a series of transformations on a given matrix according to a sequence of commands. The possible commands are: - \\"transpose\\": Transpose the matrix. - \\"rotate_clockwise\\": Rotate 90 degrees clockwise. - \\"rotate_counterclockwise\\": Rotate 90 degrees counterclockwise. - \\"flip_horizontal\\": Flip matrix horizontally. - \\"flip_vertical\\": Flip matrix vertically. >>> matrix_transformations([[1, 2], [3, 4]], [\\"transpose\\", \\"rotate_clockwise\\"]) [[3, 1], [4, 2]] >>> matrix_transformations([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [\\"flip_horizontal\\", \\"flip_vertical\\"]) [[9, 8, 7], [6, 5, 4], [3, 2, 1]] >>> matrix_transformations([[1]], [\\"transpose\\", \\"rotate_clockwise\\", \\"flip_horizontal\\"]) [[1]]","solution":"def transpose(matrix): return [list(row) for row in zip(*matrix)] def rotate_clockwise(matrix): return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): return [list(row) for row in zip(*matrix)][::-1] def flip_horizontal(matrix): return [row[::-1] for row in matrix] def flip_vertical(matrix): return matrix[::-1] def matrix_transformations(matrix, sequence): for command in sequence: if command == \\"transpose\\": matrix = transpose(matrix) elif command == \\"rotate_clockwise\\": matrix = rotate_clockwise(matrix) elif command == \\"rotate_counterclockwise\\": matrix = rotate_counterclockwise(matrix) elif command == \\"flip_horizontal\\": matrix = flip_horizontal(matrix) elif command == \\"flip_vertical\\": matrix = flip_vertical(matrix) return matrix"},{"question":"def find_peak(arr): Finds the peak element of the mountain array and returns its index. :param arr: List[int] - A list of integers representing the mountain array. :return: int - The index of the peak element. >>> find_peak([0, 2, 5, 3, 1]) 2 >>> find_peak([3, 5, 3, 2, 0]) 1 >>> find_peak([0, 2, 3, 5, 4, 1]) 3 >>> find_peak([1, 2, 3, 4, 5, 3, 1]) 4 >>> find_peak([0, 10, 6, 2]) 1 >>> find_peak([0, 5, 10, 15, 13, 9, 3, 1]) 3 >>> find_peak([3, 4, 5, 1]) 2 # Your implementation here","solution":"def find_peak(arr): Finds the peak element of the mountain array and returns its index. :param arr: List[int] - A list of integers representing the mountain array. :return: int - The index of the peak element. left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] < arr[mid + 1]: left = mid + 1 else: right = mid return left"},{"question":"def countTriplets(nums): Returns the number of triplets (i, j, k) such that 0 <= i < j < k < n and nums[i] + nums[j] + nums[k] == 0. >>> countTriplets([-1, 0, 1, 2, -1, -4]) 2 >>> countTriplets([]) 0 >>> countTriplets([0, 0, 0, 0]) 1 >>> countTriplets([1, 2, 3, 4, 5]) 0 >>> countTriplets([-2, -1, 0, 1, 2]) 2 >>> countTriplets([-1, -1, -1, 2, 2, 2]) 1","solution":"def countTriplets(nums): Returns the number of triplets (i, j, k) such that 0 <= i < j < k < n and nums[i] + nums[j] + nums[k] == 0. nums.sort() # Sorting the array n = len(nums) triplet_count = 0 for i in range(n - 2): # Skip the duplicate element for \`i\`. if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplet_count += 1 left += 1 right -= 1 # Skip the duplicate elements for \`left\`. while left < right and nums[left] == nums[left - 1]: left += 1 # Skip the duplicate elements for \`right\`. while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplet_count"},{"question":"def population_size(p: int, h: int) -> int: Calculates the population size after h hours. >>> population_size(10, 3) 80 >>> population_size(2, 10) 2048 >>> population_size(1000000, 1) 2000000 >>> population_size(1, 50) 1125899906842624","solution":"def population_size(p, h): Calculates the population size after h hours. Args: p (int): Initial population size (1 <= p <= 10^6) h (int): Number of hours (0 <= h <= 100) Returns: int: Population size after h hours return p * (2 ** h)"},{"question":"def range_sums(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the sums of elements from index l to r for each query. :param n: The size of the array. :param q: The number of queries. :param array: List of integers representing the array. :param queries: List of tuples where each tuple (l, r) represents the range. :return: List of sums for each query. Example: >>> range_sums(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> range_sums(4, 2, [-1, 2, -3, 4], [(1, 2), (3, 4)]) [1, 1]","solution":"def range_sums(n, q, array, queries): Returns the sums of elements from index l to r for each query. :param n: The size of the array. :param q: The number of queries. :param array: List of integers representing the array. :param queries: List of tuples where each tuple (l, r) represents the range. :return: List of sums for each query. # Precompute prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] result = [] for l, r in queries: result.append(prefix_sums[r] - prefix_sums[l - 1]) return result"},{"question":"def count_unique_spots(n: int, coordinates: List[Tuple[int, int]]) -> int: Returns the count of unique coordinate pairs. Args: n: an integer, the number of coordinate pairs. coordinates: a list of tuples, each containing two integers (x, y). Returns: An integer, the number of unique spots. >>> count_unique_spots(8, [(1, 2), (2, 3), (1, 2), (4, 5), (4, 5), (6, 7), (8, 9), (6, 7)]) 5 >>> count_unique_spots(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 5 >>> count_unique_spots(0, []) 0 >>> count_unique_spots(4, [(1, 1), (1, 1), (1, 1), (1, 1)]) 1 >>> count_unique_spots(6, [(1, 2), (3, 4), (5, 6), (1, 2), (3, 4), (7, 8)]) 4","solution":"def count_unique_spots(n, coordinates): Returns the count of unique coordinate pairs. Args: n: an integer, the number of coordinate pairs. coordinates: a list of tuples, each containing two integers (x, y). Returns: An integer, the number of unique spots. unique_spots = set(coordinates) return len(unique_spots) # Example usage n = 8 coordinates = [(1, 2), (2, 3), (1, 2), (4, 5), (4, 5), (6, 7), (8, 9), (6, 7)] print(count_unique_spots(n, coordinates)) # Output: 5"},{"question":"def max_sum_of_differences(N: int) -> int: Calculate the maximum possible sum of absolute differences for the \\"challenge arrangement\\". >>> max_sum_of_differences(3) 4 >>> max_sum_of_differences(4) 6 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases and returns a list of results for each test case. >>> process_test_cases(2, [3, 4]) [4, 6] >>> process_test_cases(3, [2, 3, 4]) [2, 4, 6] pass","solution":"def max_sum_of_differences(N): if N == 2: return 2 if N == 3: return 4 # For N >= 4, the pattern emerges. return (N - 1) * 2 def process_test_cases(T, test_cases): results = [] for N in test_cases: results.append(max_sum_of_differences(N)) return results"},{"question":"def min_path_sum(matrix): Returns the minimum path sum from the top-left cell to the bottom-right cell of the matrix. You can only move right or down from a cell. def solve_min_path_sum(test_cases): Solve the minimum path sum for each test case provided in test_cases. def parse_input(input_str): Parse the input string to extract test cases. def min_path_sum_driver(input_str): Driver function to parse input, compute minimum path sums, and format the output. def test_parse_input(): input_str = \\"2n2n1 2n3 4n3n1 2 3n4 5 6n7 8 9\\" expected_output = [ [ [1, 2], [3, 4] ], [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ] assert parse_input(input_str) == expected_output def test_min_path_sum(): matrix1 = [ [1, 2], [3, 4] ] assert min_path_sum(matrix1) == 7 matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_path_sum(matrix2) == 21 def test_min_path_sum_driver(): input_str = \\"2n2n1 2n3 4n3n1 2 3n4 5 6n7 8 9\\" expected_output = \\"7n21\\" assert min_path_sum_driver(input_str) == expected_output","solution":"def min_path_sum(matrix): Returns the minimum path sum from the top-left cell to the bottom-right cell of the matrix. You can only move right or down from a cell. n = len(matrix) dp = [[0]*n for _ in range(n)] dp[0][0] = matrix[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] dp[0][i] = dp[0][i-1] + matrix[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1] def solve_min_path_sum(test_cases): results = [] for matrix in test_cases: results.append(min_path_sum(matrix)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) matrix = [] idx += 1 for _ in range(N): matrix.append(list(map(int, lines[idx].split()))) idx += 1 test_cases.append(matrix) return test_cases def min_path_sum_driver(input_str): test_cases = parse_input(input_str) results = solve_min_path_sum(test_cases) return \\"n\\".join(map(str, results))"},{"question":"def smallest_substring_all_distinct_chars(s: str) -> str: Returns the smallest substring which contains all distinct characters present in the given string 's. >>> smallest_substring_all_distinct_chars(\\"aabcbcdbca\\") \\"dbca\\" >>> smallest_substring_all_distinct_chars(\\"a\\") \\"a\\" >>> smallest_substring_all_distinct_chars(\\"abcdef\\") \\"abcdef\\" >>> smallest_substring_all_distinct_chars(\\"abac\\") \\"bac\\" >>> smallest_substring_all_distinct_chars(\\"abcdefghijkl\\") \\"abcdefghijkl\\" >>> smallest_substring_all_distinct_chars(\\"aaaaaa\\") \\"a\\" >>> smallest_substring_all_distinct_chars(\\"abcabcbb\\") \\"abc\\"","solution":"def smallest_substring_all_distinct_chars(s): Returns the smallest substring which contains all distinct characters present in the given string 's'. n = len(s) distinct_chars = set(s) required_char_count = len(distinct_chars) char_frequency = {} min_length = float('inf') min_substring = \\"\\" left = 0 distinct_count = 0 for right in range(n): char = s[right] char_frequency[char] = char_frequency.get(char, 0) + 1 if char_frequency[char] == 1: distinct_count += 1 while distinct_count == required_char_count: current_length = right - left + 1 if current_length < min_length: min_length = current_length min_substring = s[left:right+1] starting_char = s[left] char_frequency[starting_char] -= 1 if char_frequency[starting_char] == 0: distinct_count -= 1 left += 1 return min_substring"},{"question":"from typing import List def get_primes(n: int) -> List[int]: Write a function that takes a positive integer \`n\` and returns a list of all prime numbers less than or equal to \`n\`. Args: n (int): A positive integer Returns: List[int]: A list of prime numbers less than or equal to \`n\`. Example: >>> get_primes(10) [2, 3, 5, 7]","solution":"def get_primes(n): Return a list of all prime numbers less than or equal to n. Args: n (int): A positive integer Returns: List[int]: A list of prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) # Create a boolean array \\"sieve[0..n]\\" and initialize all entries it as true. sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers. p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return [p for p in range(n + 1) if sieve[p]]"},{"question":"def capitalize_first_letter(sentence: str) -> str: Capitalizes the first letter of each word in the given sentence, leaving non-alphabet characters and remaining characters of each word unchanged. >>> capitalize_first_letter(\\"hello world\\") == \\"Hello World\\" >>> capitalize_first_letter(\\"let's code\\") == \\"Let's Code\\" >>> capitalize_first_letter(\\"hello world! let's code.\\") == \\"Hello World! Let's Code.\\" >>> capitalize_first_letter(\\"123easy as1 2,3.\\") == \\"123easy As1 2,3.\\" >>> capitalize_first_letter(\\"4score and 7years ago\\") == \\"4score And 7years Ago\\" >>> capitalize_first_letter(\\"\\") == \\"\\" >>> capitalize_first_letter(\\"hello\\") == \\"Hello\\" >>> capitalize_first_letter(\\"WORLD!\\") == \\"WORLD!\\" >>> capitalize_first_letter(\\"hElLo WoRlD\\") == \\"HElLo WoRlD\\" >>> capitalize_first_letter(\\"LeT's cOdE\\") == \\"LeT's COdE\\"","solution":"def capitalize_first_letter(sentence: str) -> str: Capitalizes the first letter of each word in the given sentence, assuming words are separated by spaces. Numbers and special characters remain unchanged. :param sentence: A string containing the sentence to be transformed. :return: A string with the first letter of each word capitalized. words = sentence.split() capitalized_words = [word[0].upper() + word[1:] if word else \\"\\" for word in words] return ' '.join(capitalized_words)"},{"question":"def valid_palindrome(s: str) -> bool: Check if the input string can be converted to a palindrome by removing at most one character. Examples: >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"abcde\\") False","solution":"def valid_palindrome(s): Check if the input string can be converted to a palindrome by removing at most one character. def is_palindrome_range(i, j): # Check if s[i:j+1] is a palindrome return all(s[k] == s[j-k+i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try skipping either the left or the right character return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def max_complete_tasks(test_cases): Determine the maximum number of non-overlapping tasks that can be completed in a single day for each test case. Input: List of dictionaries. Each dictionary represents a test case with the following keys: - 'n': int, the number of tasks. - 'tasks': List of tuples, each tuple contains two integers representing the start and end time of a task. Output: List of integers, where each integer represents the maximum number of non-overlapping tasks for the corresponding test case. Example: >>> test_cases = [ ... {'n': 3, 'tasks': [(1, 3), (2, 5), (4, 7)]}, ... {'n': 4, 'tasks': [(10, 20), (20, 30), (30, 40), (40, 50)]}, ... {'n': 5, 'tasks': [(100, 200), (150, 250), (200, 300), (250, 350), (300, 400)]} ... ] >>> max_complete_tasks(test_cases) [2, 4, 3]","solution":"def max_complete_tasks(test_cases): results = [] for case in test_cases: n, tasks = case['n'], case['tasks'] # Sort the tasks based on end time tasks.sort(key=lambda x: x[1]) count, end_time = 0, 0 for s, e in tasks: if s >= end_time: count += 1 end_time = e results.append(count) return results"},{"question":"def can_assign_time_slots(k, m, constraints): Determines if it's possible to assign a unique time slot to each contest while adhering to the constraints. Args: k (int): Number of contests. m (int): Number of constraints. constraints (list of tuples): List of constraints, where each tuple (u, v) indicates contest u and contest v cannot be in the same time slot. Returns: str: 'YES' if it is possible to assign a unique time slot to each contest while adhering to the constraints, otherwise 'NO'. >>> can_assign_time_slots(3, 2, [(1, 2), (2, 3)]) 'YES' >>> can_assign_time_slots(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO' >>> can_assign_time_slots(4, 2, [(1, 2), (3, 4)]) 'YES'","solution":"import collections def can_assign_time_slots(k, m, constraints): Determines if it's possible to assign a unique time slot to each contest while adhering to the constraints. Args: k (int): Number of contests. m (int): Number of constraints. constraints (list of tuples): List of constraints, where each tuple (u, v) indicates contest u and contest v cannot be in the same time slot. Returns: str: 'YES' if it is possible to assign a unique time slot to each contest while adhering to the constraints, otherwise 'NO'. graph = collections.defaultdict(list) for u, v in constraints: graph[u].append(v) graph[v].append(u) slot_assignment = [-1] * (k + 1) def bfs(start): queue = collections.deque([start]) slot_assignment[start] = 0 # Assign the first time slot while queue: node = queue.popleft() current_slot = slot_assignment[node] for neighbor in graph[node]: if slot_assignment[neighbor] == -1: slot_assignment[neighbor] = (current_slot + 1) % 3 queue.append(neighbor) elif slot_assignment[neighbor] == current_slot: return False return True for i in range(1, k + 1): if slot_assignment[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"def largest_square_of_flowers(n: int, m: int, garden: List[List[int]]) -> int: Given a garden represented by a grid \`n x m\` where each cell contains a flower (\`1\`) or is empty (\`0\`), computes the side length of the largest square sub-grid that contains only flowers. >>> largest_square_of_flowers(5, 6, [ ... [1, 0, 1, 0, 0, 1], ... [1, 1, 0, 1, 1, 1], ... [1, 1, 1, 1, 0, 0], ... [1, 1, 1, 1, 0, 0], ... [0, 1, 1, 1, 0, 1] ... ]) == 3 >>> largest_square_of_flowers(4, 4, [ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0","solution":"def largest_square_of_flowers(n, m, garden): if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if garden[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"def elevator_simulation(N: int, M: int, requests: List[Tuple[int, int]]) -> List[int]: Simulates the elevator travel sequence to minimize total distance. Args: N (int): Number of floors in the building. M (int): Number of requests. requests (list of tuple): List of tuples where each tuple contains two integers representing the starting and ending floor of each request. Returns: list: The sequence of floors the elevator travels through in the optimal order. >>> elevator_simulation(5, 3, [(1, 3), (4, 5), (2, 1)]) [1, 2, 3, 4, 5] >>> elevator_simulation(6, 2, [(6, 2), (3, 1)]) [1, 2, 3, 6] >>> elevator_simulation(4, 1, [(1, 4)]) [1, 4] >>> elevator_simulation(4, 3, [(1, 2), (1, 3), (1, 4)]) [1, 2, 3, 4] >>> elevator_simulation(10, 2, [(8, 10), (9, 10)]) [8, 9, 10] >>> elevator_simulation(2, 1, [(1, 2)]) [1, 2] pass","solution":"def elevator_simulation(N, M, requests): Simulates the elevator travel sequence to minimize total distance. Args: N (int): Number of floors in the building. M (int): Number of requests. requests (list of tuple): List of tuples where each tuple contains two integers representing the starting and ending floor of each request. Returns: list: The sequence of floors the elevator travels through in the optimal order. from itertools import permutations # A set to accumulate all visited floors all_floors = set() for start, end in requests: all_floors.add(start) all_floors.add(end) # Create a list of all unique floors that need to be visited all_floors = list(all_floors) def total_distance(path): distance = 0 for i in range(1, len(path)): distance += abs(path[i] - path[i - 1]) return distance # Generate all possible permutations of the floors and find the minimal distance path optimal_path = None min_distance = float('inf') for perm in permutations(all_floors): dist = total_distance(perm) if dist < min_distance or (dist == min_distance and perm < optimal_path): min_distance = dist optimal_path = perm return list(optimal_path)"},{"question":"def min_max_completion_time(n, m, orders): Distributes orders among assembly lines to minimize the maximum completion time. Parameters: n (int): Number of assembly lines. m (int): Number of orders. orders (list): List of integers representing time each order takes. Returns: int: Minimum possible maximum completion time. Examples: >>> min_max_completion_time(3, 5, [2, 14, 4, 16, 6]) 16 >>> min_max_completion_time(2, 4, [5, 8, 6, 3]) 11 >>> min_max_completion_time(4, 4, [10, 10, 10, 10]) 10 >>> min_max_completion_time(1, 3, [2, 4, 6]) 12","solution":"def min_max_completion_time(n, m, orders): Distributes orders among assembly lines to minimize the maximum completion time. Parameters: n (int): Number of assembly lines. m (int): Number of orders. orders (list): List of integers representing time each order takes. Returns: int: Minimum possible maximum completion time. # Sort orders in descending order orders.sort(reverse=True) # Maintain an array to keep track of time on each assembly line assembly_lines = [0] * n for order in orders: # Assign order to the assembly line with the minimum current load min_index = assembly_lines.index(min(assembly_lines)) assembly_lines[min_index] += order return max(assembly_lines) # Example usage # n = 3, m = 5, orders = [2, 14, 4, 16, 6] # minimum maximum completion time = 16 print(min_max_completion_time(3, 5, [2, 14, 4, 16, 6]))"},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost to traverse from the top-left to the bottom-right of the grid. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2, 3, 4, 5]]) 15 >>> min_cost_path([[1], [2], [3], [4], [5]]) 15 >>> min_cost_path([[1, 3, 1, 2], [2, 5, 1, 3], [3, 2, 1, 4], [4, 3, 2, 1]]) 10 pass def parse_input(input_string: str) -> List[List[int]]: Parses the input string and returns the grid as a list of lists. >>> parse_input(\\"3 3n1 3 1n1 5 1n4 2 1\\") [[1, 3, 1], [1, 5, 1], [4, 2, 1]] >>> parse_input(\\"1 1n5\\") [[5]] >>> parse_input(\\"1 5n1 2 3 4 5\\") [[1, 2, 3, 4, 5]] >>> parse_input(\\"5 1n1n2n3n4n5\\") [[1], [2], [3], [4], [5]] >>> parse_input(\\"4 4n1 3 1 2n2 5 1 3n3 2 1 4n4 3 2 1\\") [[1, 3, 1, 2], [2, 5, 1, 3], [3, 2, 1, 4], [4, 3, 2, 1]] pass","solution":"def min_cost_path(grid): Returns the minimum cost to traverse from the top-left to the bottom-right of the grid. N = len(grid) M = len(grid[0]) # Initialize the costs matrix with the same dimensions as grid cost = [[0]*M for _ in range(N)] # Base case: starting point is the same as grid[0][0] cost[0][0] = grid[0][0] # Initialize the first row and first column for i in range(1, N): cost[i][0] = cost[i-1][0] + grid[i][0] for j in range(1, M): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill in the rest of the cost matrix for i in range(1, N): for j in range(1, M): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[N-1][M-1] def parse_input(input_string): Parses the input string and returns the grid as a list of lists. lines = input_string.strip().split('n') N, M = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return grid"},{"question":"from collections import defaultdict, deque def find_task_order(N: int, M: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determines a valid task ordering based on dependencies. Args: N: int - number of employees. M: int - number of dependencies. dependencies: List[Tuple[int, int]] - list of dependencies (a, b). Returns: list - a valid ordering of employees if possible, otherwise an empty list. Example: >>> find_task_order(3, 2, [(2, 1), (3, 2)]) [1, 2, 3] >>> find_task_order(3, 3, [(1, 2), (2, 3), (3, 1)]) []","solution":"from collections import defaultdict, deque def find_task_order(N, M, dependencies): Determines a valid task ordering based on dependencies. Args: N: int - number of employees. M: int - number of dependencies. dependencies: List[Tuple[int, int]] - list of dependencies (a, b). Returns: list - a valid ordering of employees if possible, otherwise an empty list. # Create adjacency list and in-degree counter adj_list = defaultdict(list) in_degree = defaultdict(int) for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Initialize queue with employees having no incoming edges queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we have ordered all employees, return the order, otherwise empty list return order if len(order) == N else []"},{"question":"def maxEqualElements(arr: List[int], N: int) -> int: Returns the maximum number of elements that can be made equal by performing increment operations. Parameters: arr (list of int): The input array of integers. N (int): The size of the array. Returns: int: The maximum number of elements that can be made equal. >>> maxEqualElements([1, 2, 2, 5], 4) 3 >>> maxEqualElements([1, 2, 1, 2, 2], 5) 4","solution":"def maxEqualElements(arr, N): Returns the maximum number of elements that can be made equal by performing increment operations. Parameters: arr (list of int): The input array of integers. N (int): The size of the array. Returns: int: The maximum number of elements that can be made equal. # Dictionary to count frequency of each element in the array count = {} for num in arr: if num in count: count[num] += 1 else: count[num] = 1 # Find the maximum frequency from the dictionary max_frequency = max(count.values()) return max_frequency"},{"question":"def count_distinct_substrings(T: int, cases: List[Tuple[str, int]]) -> List[int]: Determine the number of distinct substrings of length K present in the string S for each test case. >>> count_distinct_substrings(3, [(\\"abcd\\", 2), (\\"aaaaa\\", 1), (\\"abcdefg\\", 3)]) [3, 1, 5] >>> count_distinct_substrings(1, [(\\"abcd\\", 0)]) [0] >>> count_distinct_substrings(1, [(\\"\\", 3)]) [0] >>> count_distinct_substrings(1, [(\\"abcde\\", 5)]) [1] >>> count_distinct_substrings(1, [(\\"abcd\\", 5)]) [0]","solution":"def count_distinct_substrings(T, cases): results = [] for case in cases: S, K = case K = int(K) if K == 0: results.append(0) continue substrings = set() for i in range(len(S) - K + 1): substrings.add(S[i:i+K]) results.append(len(substrings)) return results # Sample input # T = 3 # cases = [(\\"abcd\\", 2), (\\"aaaaa\\", 1), (\\"abcdefg\\", 3)] # print(count_distinct_substrings(T, cases))"},{"question":"def max_showcase_count(N: int, values: List[int]) -> int: Determine the maximum number of coins Mario can showcase. Parameters: N (int): The number of coins. values (list of int): The values of the coins. Returns: int: The maximum number of coins that can be showcased. >>> max_showcase_count(5, [1, 2, 3, 4, 5]) 5 >>> max_showcase_count(4, [4, 3, 2, 1]) 1 >>> max_showcase_count(6, [1, 3, 2, 5, 4, 6]) 4 def process_input(input_list: List[str]) -> List[int]: Process the input as required to solve for multiple test cases. Parameters: input_list (list of str): The raw input split by lines. Returns: list of int: A list of results for each test case. >>> input_data = [ ... \\"3\\", ... \\"5\\", ... \\"1 2 3 4 5\\", ... \\"4\\", ... \\"4 3 2 1\\", ... \\"6\\", ... \\"1 3 2 5 4 6\\" ... ] >>> process_input(input_data) [5, 1, 4] >>> input_data2 = [ ... \\"2\\", ... \\"3\\", ... \\"1 1 1\\", ... \\"3\\", ... \\"1 2 1\\" ... ] >>> process_input(input_data2) [1, 2]","solution":"def max_showcase_count(N, values): Determine the maximum number of coins Mario can showcase. Parameters: N (int): The number of coins. values (list of int): The values of the coins. Returns: int: The maximum number of coins that can be showcased. if N == 0: return 0 # The current highest value that has been showcased max_value = values[0] count = 1 # The first coin is always showcased for value in values[1:]: if value > max_value: count += 1 max_value = value return count def process_input(input_list): Process the input as required to solve for multiple test cases. Parameters: input_list (list of str): The raw input split by lines. Returns: list of int: A list of results for each test case. current_line = 0 T = int(input_list[current_line]) current_line += 1 results = [] for _ in range(T): N = int(input_list[current_line]) current_line += 1 values = list(map(int, input_list[current_line].split())) current_line += 1 result = max_showcase_count(N, values) results.append(result) return results"},{"question":"def power_level(number): Computes the power level of a number which is defined as the sum of the squares of its digits. Args: number: A positive integer whose power level is to be calculated. Returns: The power level of the number. Examples: >>> power_level(12) 5 >>> power_level(34) 25 pass def sort_regions_by_power_level(test_cases): Sorts regions by their power levels for a given list of test cases. Each test case is a list of space-separated region numbers. Args: test_cases: List of strings, where each string is a space-separated list of region numbers. Returns: List of strings, where each string contains the region numbers sorted by their power levels. Examples: >>> sort_regions_by_power_level([\\"12 34 56 78\\"]) [\\"12 34 56 78\\"] >>> sort_regions_by_power_level([\\"123 321 213\\"]) [\\"123 213 321\\"] pass","solution":"def power_level(number): Computes the power level of a number which is defined as the sum of the squares of its digits. return sum(int(digit) ** 2 for digit in str(number)) def sort_regions_by_power_level(test_cases): Sorts regions by their power levels for a given list of test cases. Each test case is a list of space-separated region numbers. Args: test_cases: List of strings, where each string is a space-separated list of region numbers. Returns: List of strings, where each string contains the region numbers sorted by their power levels. result = [] for case in test_cases: regions = case.split() sorted_regions = sorted(regions, key=lambda x: (power_level(x), int(x))) result.append(\\" \\".join(sorted_regions)) return result"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> int: Function to remove duplicates such that each element appears at most twice. Modify the input array in-place and return the new length of the array. def process_queries(queries: List[List[int]]) -> List[int]: Function to process multiple queries and return the results. # Unit tests def test_remove_duplicates_example1(): nums = [1, 1, 1, 2, 2, 3] assert remove_duplicates(nums) == 5 assert nums[:5] == [1, 1, 2, 2, 3] def test_remove_duplicates_example2(): nums = [1, 1, 1, 1, 1] assert remove_duplicates(nums) == 2 assert nums[:2] == [1, 1] def test_remove_duplicates_example3(): nums = [0, 0, 1, 1, 1, 2, 3] assert remove_duplicates(nums) == 6 assert nums[:6] == [0, 0, 1, 1, 2, 3] def test_remove_duplicates_empty(): nums = [] assert remove_duplicates(nums) == 0 def test_remove_duplicates_single_element(): nums = [1] assert remove_duplicates(nums) == 1 assert nums[:1] == [1] def test_remove_duplicates_two_elements(): nums = [1, 1] assert remove_duplicates(nums) == 2 assert nums[:2] == [1, 1] def test_process_queries(): queries = [ [6, 1, 1, 1, 2, 2, 3], [5, 1, 1, 1, 1, 1], [7, 0, 0, 1, 1, 1, 2, 3] ] assert process_queries(queries) == [5, 2, 6] queries = [ [6, 1, 1, 1, 1, 1, 1], [4, 1, 1, 2, 2], [5, 0, 0, 0, 0, 0] ] assert process_queries(queries) == [2, 4, 2]","solution":"def remove_duplicates(nums): Function to remove duplicates such that each element appears at most twice. Modify the input array in-place and return the new length of the array. if not nums: return 0 n = len(nums) if n < 3: return n index = 2 for i in range(2, n): if nums[i] != nums[index - 2]: nums[index] = nums[i] index += 1 return index def process_queries(queries): Function to process multiple queries. results = [] for query in queries: n, *nums = query results.append(remove_duplicates(nums)) return results # Example usage: queries = [ [6, 1, 1, 1, 2, 2, 3], [5, 1, 1, 1, 1, 1], [7, 0, 0, 1, 1, 1, 2, 3] ] print(process_queries(queries)) # Output: [5, 2, 6]"},{"question":"from typing import List, Tuple def solve(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of N integers, the task is to find the largest positive integer P such that P is a factor of the sum of the integers in the list and P is also the greatest common divisor (GCD) of a subset of the given list. Args: test_cases: A list of tuples, where each tuple contains an integer N and a list of N integers. Returns: A list of integers representing the value of P for each test case. Example: >>> test_cases = [(4, [4, 8, 12, 16]), (6, [18, 24, 30, 42, 48, 54])] >>> solve(test_cases) [4, 6] pass # Replace this with your implementation. from solution import solve def test_example_cases(): test_cases = [ (4, [4, 8, 12, 16]), (6, [18, 24, 30, 42, 48, 54]), ] expected = [4, 6] assert solve(test_cases) == expected def test_small_numbers(): test_cases = [ (3, [2, 4, 6]), (5, [3, 6, 9, 12, 15]), ] expected = [2, 3] assert solve(test_cases) == expected def test_mixed_numbers(): test_cases = [ (5, [10, 5, 15, 25, 35]), (5, [100, 200, 300, 150, 250]), ] expected = [5, 50] assert solve(test_cases) == expected def test_single_number(): test_cases = [ (1, [7]), ] expected = [7] assert solve(test_cases) == expected def test_largest_possible_p(): test_cases = [ (4, [7, 14, 28, 56]), ] expected = [7] assert solve(test_cases) == expected","solution":"from math import gcd from functools import reduce def find_largest_p(N, arr): Given a list of N integers, this function returns the largest positive integer P such that P is a factor of the sum of the integers in the list and P is also the greatest common divisor (GCD) of a subset of the given list. def gcd_multiple(numbers): return reduce(gcd, numbers) total_sum = sum(arr) max_p = 1 # Initialize max_p to 1, the smallest possible positive integer factor of any sum # Finding the GCD of the entire list first, as any subset's GCD must be a divisor of this overall_gcd = gcd_multiple(arr) # We will check divisors starting from the largest possible down to 1 for p in range(overall_gcd, 0, -1): if total_sum % p == 0: return p def solve(test_cases): results = [] for N, arr in test_cases: results.append(find_largest_p(N, arr)) return results"},{"question":"def maxProfit(time: List[int], profit: List[int], totalHours: int) -> int: Determine the maximum profit that can be obtained by completing a subset of projects within the given time limit. Args: time (List[int]): A list of integers representing the time required for each project. profit (List[int]): A list of integers representing the profit for each project. totalHours (int): An integer representing the total available hours. Returns: int: The maximum profit that can be obtained within the given time limit. Examples: >>> maxProfit([2, 3, 5, 7], [10, 15, 20, 25], 8) 35 >>> maxProfit([1, 2, 3, 4], [10, 40, 50, 70], 5) 90","solution":"def maxProfit(time, profit, totalHours): n = len(time) # DP array - dp[i] will store the maximum profit that can be achieved using i hours dp = [0] * (totalHours + 1) for i in range(n): # Traverse backwards to ensure that each project is only considered once for j in range(totalHours, time[i] - 1, -1): dp[j] = max(dp[j], dp[j - time[i]] + profit[i]) return dp[totalHours]"},{"question":"def is_bipartite(graph): Checks if the given graph (represented as an adjacency matrix) is bipartite. >>> is_bipartite([[0, 1, 1], [1, 0, 0], [1, 0, 0]]) == True >>> is_bipartite([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]) == True >>> is_bipartite([[0, 1], [1, 0]]) == True >>> is_bipartite([[0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 0]]) == False pass def check_bipartite_graphs(datasets): Takes multiple datasets and checks if each corresponds to a bipartite graph. Parameters: datasets (list of list of list): Multiple NxN matrices representing adjacency matrices of graphs. Returns: list: List of results as 'Yes' or 'No' for each dataset. >>> check_bipartite_graphs([[[0, 1, 1], [1, 0, 0], [1, 0, 0]], [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]]) == [\\"Yes\\", \\"Yes\\"] >>> check_bipartite_graphs([[[0, 1], [1, 0]], [[0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 0]]]) == [\\"Yes\\", \\"No\\"] pass","solution":"def is_bipartite(graph): Checks if the given graph (represented as an adjacency matrix) is bipartite. N = len(graph) color = [-1] * N def bfs(start): queue = [start] color[start] = 0 while queue: u = queue.pop(0) for v in range(N): if graph[u][v] == 1: if color[v] == -1: color[v] = 1 - color[u] queue.append(v) elif color[v] == color[u]: return False return True for i in range(N): if color[i] == -1: if not bfs(i): return False return True def check_bipartite_graphs(datasets): Takes multiple datasets and checks if each corresponds to a bipartite graph. Parameters: datasets (list of list of list): Multiple NxN matrices representing adjacency matrices of graphs. Returns: list: List of results as 'Yes' or 'No' for each dataset. results = [] for dataset in datasets: if is_bipartite(dataset): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"class Color: def __init__(self, r: int, g: int, b: int): Initializes a Color instance with red, green, and blue components. :param r: Red component (0-255) :param g: Green component (0-255) :param b: Blue component (0-255) self.r = r self.g = g self.b = b def to_hex(self) -> str: Returns a string representing the color in hexadecimal format. >>> Color(255, 0, 0).to_hex() '#FF0000' >>> Color(0, 255, 0).to_hex() '#00FF00' pass def to_hsl(self) -> (int, float, float): Returns a tuple (h, s, l) representing the color in HSL format. >>> Color(255, 0, 0).to_hsl() (0, 1, 0.5) >>> Color(0, 255, 0).to_hsl() (120, 1, 0.5) pass def darker(self, percentage: float) -> 'Color': Returns a new Color instance that is a darker shade by a given percentage. :param percentage: A float between 0 and 1 where 1 means completely black. >>> Color(255, 0, 0).darker(0.3).to_hex() '#B20000' >>> Color(0, 255, 0).darker(0.5).to_hex() '#007F00' pass","solution":"class Color: def __init__(self, r, g, b): self.r = r self.g = g self.b = b def to_hex(self): Returns the color in hexadecimal format. return f'#{self.r:02X}{self.g:02X}{self.b:02X}' def to_hsl(self): Returns the color in HSL format (Hue, Saturation, Lightness). r, g, b = self.r / 255.0, self.g / 255.0, self.b / 255.0 max_c, min_c = max(r, g, b), min(r, g, b) delta = max_c - min_c l = (max_c + min_c) / 2.0 if delta == 0: h = s = 0 else: s = delta / (2.0 - max_c - min_c) if l > 0.5 else delta / (max_c + min_c) if max_c == r: h = ((g - b) / delta) % 6 elif max_c == g: h = (b - r) / delta + 2 else: h = (r - g) / delta + 4 h *= 60 return (int(h), round(s, 2), round(l, 2)) def darker(self, percentage): Returns a new Color instance that is a darker shade by the given percentage. factor = 1 - percentage new_r = max(min(int(self.r * factor), 255), 0) new_g = max(min(int(self.g * factor), 255), 0) new_b = max(min(int(self.b * factor), 255), 0) return Color(new_r, new_g, new_b)"},{"question":"from collections import defaultdict, deque def can_reach_and_return(N, M, Entrance, Treasure, corridors): Determine if it's possible to reach the treasure room and return to the entrance without getting trapped. >>> can_reach_and_return(4, 4, 1, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YES' >>> can_reach_and_return(4, 3, 1, 4, [(1, 2), (2, 3), (3, 1)]) 'NO'","solution":"from collections import defaultdict, deque def can_reach_and_return(N, M, Entrance, Treasure, corridors): graph = defaultdict(list) for A, B in corridors: graph[A].append(B) graph[B].append(A) def bfs(start, end): visited = [False] * (N + 1) queue = deque([start]) while queue: node = queue.popleft() if node == end: return True if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: queue.append(neighbor) return False if bfs(Entrance, Treasure) and bfs(Treasure, Entrance): return \\"YES\\" else: return \\"NO\\" # Sample input N, M = 4, 4 Entrance, Treasure = 1, 4 corridors = [(1, 2), (2, 3), (3, 4), (4, 1)] # Running the function with sample input print(can_reach_and_return(N, M, Entrance, Treasure, corridors)) # Output should be YES"},{"question":"def double_characters(s: str) -> str: Returns a new string where each character in the input string is repeated once. Parameters: s (str): The input string containing alphabet characters. Returns: str: A new string with each character from the input string repeated once. >>> double_characters(\\"hello\\") 'hheelllloo' >>> double_characters(\\"CODE\\") 'CCOODDEE' >>> double_characters(\\"Code\\") 'CCooddee' >>> double_characters(\\"a\\") 'aa' >>> double_characters(\\"Z\\") 'ZZ' >>> double_characters(\\"aBcDeF\\") 'aaBBccDDeeFF' >>> double_characters(\\"aaa\\") 'aaaaaa' pass","solution":"def double_characters(s: str) -> str: Returns a new string where each character in the input string is repeated once. Parameters: s (str): The input string containing alphabet characters. Returns: str: A new string with each character from the input string repeated once. return ''.join([char * 2 for char in s])"},{"question":"def can_reorder_to_gcd_one(arr: List[int]) -> str: Determines if it is possible to reorder the array such that every adjacent pair of numbers has a GCD of 1. :param arr: A list of positive integers. :return: \\"YES\\" if possible to reorder, \\"NO\\" otherwise. >>> can_reorder_to_gcd_one([14, 3, 2, 5, 9, 6]) 'YES' >>> can_reorder_to_gcd_one([4, 8]) 'NO'","solution":"import math from itertools import permutations def can_reorder_to_gcd_one(arr): Determines if it is possible to reorder the array such that every adjacent pair of numbers has a GCD of 1. :param arr: A list of positive integers. :return: \\"YES\\" if possible to reorder, \\"NO\\" otherwise. n = len(arr) # Try all permutations of the array and check the GCD of adjacent pairs for perm in permutations(arr): if all(math.gcd(perm[i], perm[i+1]) == 1 for i in range(n - 1)): return \\"YES\\" return \\"NO\\""},{"question":"import math def find_treasure_sequence(M: int, distances: List[int]) -> Union[List[int], str]: Given the number of treasures M and list of distances, returns the sequence of distances for treasures that are perfect squares. Parameters: M (int): number of treasures distances (list of int): list of distances at which treasures are located Returns: list: sequence of distances for perfect square treasures or \\"No treasures found\\" if none exist. >>> find_treasure_sequence(7, [1, 4, 8, 9, 15, 16, 25]) [1, 4, 9, 16, 25] >>> find_treasure_sequence(5, [3, 8, 10, 12, 14]) \\"No treasures found\\"","solution":"import math def find_treasure_sequence(M, distances): Given the number of treasures M and list of distances, returns the sequence of distances for treasures that are perfect squares. Parameters: M (int): number of treasures distances (list of int): list of distances at which treasures are located Returns: list: sequence of distances for perfect square treasures perfect_squares = [] for distance in distances: if math.isqrt(distance) ** 2 == distance: perfect_squares.append(distance) if not perfect_squares: return \\"No treasures found\\" return sorted(perfect_squares)"},{"question":"def insertion_sort(arr): Sorts the list arr using the insertion sort algorithm. Parameters: arr (list of int): A list of integers to be sorted. Returns: list of int: The sorted list in ascending order. Example: >>> insertion_sort([29, 10, 14, 37, 13]) [10, 13, 14, 29, 37] >>> insertion_sort([3, 0, 2, 5, -1, 4, 1]) [-1, 0, 1, 2, 3, 4, 5] # Implement the insertion sort algorithm here","solution":"def insertion_sort(arr): Sorts the list arr using the insertion sort algorithm. Parameters: arr (list of int): A list of integers to be sorted. Returns: list of int: The sorted list in ascending order. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"def check_storage_constraints(folder_structure: dict, folder_constraints: dict) -> bool: Check if the folder structure adheres to the given size constraints. Args: folder_structure (dict): A nested dictionary representing the folder structure. folder_constraints (dict): A dictionary representing maximum allowable sizes for folders. Returns: bool: True if all the size constraints are satisfied, False otherwise. Examples: >>> folder_structure_1 = { ... \\"root\\": { ... \\"subfolder1\\": { ... \\"file1.txt\\": 100, ... \\"file2.txt\\": 200 ... }, ... \\"subfolder2\\": { ... \\"subsubfolder1\\": { ... \\"file3.txt\\": 150, ... \\"file4.txt\\": 100 ... }, ... \\"file5.txt\\": 300, ... }, ... \\"file6.txt\\": 400 ... } ... } >>> folder_constraints_1 = { ... \\"root\\": 1200, ... \\"subfolder1\\": 400, ... \\"subfolder2\\": 600, ... \\"subsubfolder1\\": 300 ... } >>> check_storage_constraints(folder_structure_1, folder_constraints_1) True >>> folder_structure_2 = { ... \\"root\\": { ... \\"subfolder1\\": { ... \\"file1.txt\\": 100, ... \\"file2.txt\\": 200 ... }, ... \\"subfolder2\\": { ... \\"subsubfolder1\\": { ... \\"file3.txt\\": 150, ... \\"file4.txt\\": 100 ... }, ... \\"file5.txt\\": 300, ... }, ... \\"file6.txt\\": 400 ... } ... } >>> folder_constraints_2 = { ... \\"root\\": 1000, ... \\"subfolder1\\": 400, ... \\"subfolder2\\": 600, ... \\"subsubfolder1\\": 300 ... } >>> check_storage_constraints(folder_structure_2, folder_constraints_2) False","solution":"def check_storage_constraints(folder_structure: dict, folder_constraints: dict) -> bool: def calculate_folder_size(folder): size = 0 for item, content in folder.items(): if isinstance(content, dict): size += calculate_folder_size(content) else: size += content return size def verify_constraints(folder, folder_name): current_size = calculate_folder_size(folder) if folder_name in folder_constraints and current_size > folder_constraints[folder_name]: return False for subfolder, content in folder.items(): if isinstance(content, dict): if not verify_constraints(content, subfolder): return False return True # We assume the root of the structure is always named \\"root\\" return verify_constraints(folder_structure, \\"root\\")"},{"question":"def process(input_str: str) -> str: Find the shortest path from the top-left corner to the bottom-right corner of the grid for each dataset. Grid dimensions range from 2x2 to 100x100. Each cell can either be empty (.) or blocked (#). Args: input_str (str): The input string containing multiple datasets. Returns: str: The lengths of the shortest paths for each dataset, or \\"No path\\" if no valid path exists. Example: >>> process(\\"2 2n.#n#.n0 0\\") 'No path' >>> process(\\"2 3n..#n#..n0 0\\") '4' pass def test_no_path(): input_data = \\"2 2n.#n#.n0 0\\" expected_output = \\"No path\\" assert process(input_data) == expected_output def test_short_path(): input_data = \\"2 3n..#n#..n0 0\\" expected_output = \\"4\\" assert process(input_data) == expected_output def test_multiple_datasets(): input_data = \\"2 2n.#n#.n2 3n..#n#..n0 0\\" expected_output = \\"No pathn4\\" assert process(input_data) == expected_output def test_simple_case(): input_data = \\"3 3n...n...n...n0 0\\" expected_output = \\"5\\" assert process(input_data) == expected_output def test_blocked_path(): input_data = \\"3 3n.#.n#n.#.n0 0\\" expected_output = \\"No path\\" assert process(input_data) == expected_output","solution":"def shortest_path(grid, n, m): from collections import deque # Directions (right, left, down, up) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, path_length) while queue: r, c, length = queue.popleft() if r == n - 1 and c == m - 1: return length for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == '.': grid[nr][nc] = '#' # mark cell as visited queue.append((nr, nc, length + 1)) return \\"No path\\" def parse_input(input_str): input_lines = input_str.split(\\"n\\") index = 0 result = [] while index < len(input_lines): n, m = map(int, input_lines[index].split()) if n == 0 and m == 0: break grid = [] for i in range(1, n+1): grid.append(list(input_lines[index + i])) result.append((grid, n, m)) index += n + 1 return result def process(input_str): datasets = parse_input(input_str) results = [] for grid, n, m in datasets: results.append(shortest_path(grid, n, m)) return \\"n\\".join(map(str, results)) # Example Usage input_data = \\"2 2n.#n#.n2 3n..#n#..n0 0\\" print(process(input_data)) # Expected output: \\"No pathn4\\""},{"question":"def find_dimensions(N: int) -> tuple[int, int]: Returns the dimensions l and w of the garden such that l * w = N and the absolute difference between l and w is minimized. If there are multiple answers, return the pair where l >= w. >>> find_dimensions(12) (4, 3) >>> find_dimensions(20) (5, 4) >>> find_dimensions(17) (17, 1) # Your code here def solve(test_cases: list[int]) -> list[str]: Returns a list of strings with the dimensions l and w for each test case. >>> solve([12, 20, 17]) [\\"4 3\\", \\"5 4\\", \\"17 1\\"] >>> solve([1, 36, 100]) [\\"1 1\\", \\"6 6\\", \\"10 10\\"] # Your code here","solution":"def find_dimensions(N): Returns the dimensions l and w of the garden such that l * w = N and the absolute difference between l and w is minimized. If there are multiple answers, return the pair where l >= w. import math best_l, best_w = N, 1 for w in range(1, int(math.sqrt(N)) + 1): if N % w == 0: l = N // w if abs(l - w) < abs(best_l - best_w) or (abs(l - w) == abs(best_l - best_w) and l > best_l): best_l, best_w = l, w return best_l, best_w def solve(test_cases): results = [] for N in test_cases: l, w = find_dimensions(N) results.append(f\\"{l} {w}\\") return results"},{"question":"def can_assign_tasks(n, m, tasks, drivers): Determines if it's possible to assign tasks to drivers such that no driver exceeds their maximum working time. Parameters: n (int): Number of tasks. m (int): Number of drivers. tasks (list of int): Time each task takes. drivers (list of int): Maximum working time each driver has. Returns: str: \\"YES\\" if it's possible to assign all tasks under constraints, \\"NO\\" otherwise. Examples: >>> can_assign_tasks(4, 3, [2, 3, 5, 7], [10, 7, 8]) \\"YES\\" >>> can_assign_tasks(5, 2, [3, 2, 4, 1, 5], [5, 5]) \\"NO\\"","solution":"def can_assign_tasks(n, m, tasks, drivers): Determines if it's possible to assign tasks to drivers such that no driver exceeds their maximum working time. Parameters: n (int): Number of tasks. m (int): Number of drivers. tasks (list of int): Time each task takes. drivers (list of int): Maximum working time each driver has. Returns: str: \\"YES\\" if it's possible to assign all tasks under constraints, \\"NO\\" otherwise. tasks.sort(reverse=True) drivers.sort(reverse=True) for task in tasks: for i in range(m): if drivers[i] >= task: drivers[i] -= task break else: return \\"NO\\" return \\"YES\\""},{"question":"def fuel_efficiency(distances, fuel_used): This function calculates the fuel efficiency for each leg of the trip. Arguments: distances -- list of positive integers representing distances traveled in kilometers fuel_used -- list of positive integers representing fuel consumed in liters Returns: A list of floats representing fuel efficiency (distance per liter) for each leg of the trip. If the input lists have different lengths or are empty, returns an empty list. >>> fuel_efficiency([100, 200, 150], [10, 20, 15]) [10.0, 10.0, 10.0] >>> fuel_efficiency([300, 400], [15, 20]) [20.0, 20.0] >>> fuel_efficiency([], []) [] >>> fuel_efficiency([100, 200], [10]) [] >>> fuel_efficiency([100], [0]) []","solution":"def fuel_efficiency(distances, fuel_used): This function calculates the fuel efficiency for each leg of the trip. Arguments: distances -- list of positive integers representing distances traveled in kilometers fuel_used -- list of positive integers representing fuel consumed in liters Returns: A list of floats representing fuel efficiency (distance per liter) for each leg of the trip. If the input lists have different lengths or are empty, returns an empty list. if len(distances) != len(fuel_used) or len(distances) == 0: return [] efficiency = [] for distance, fuel in zip(distances, fuel_used): if fuel == 0: return [] # handle division by zero efficiency.append(distance / fuel) return efficiency"},{"question":"def count_inversions(nums) -> int: Returns the number of inversions in the array nums def solve_inversion_problem(T: int, data: list) -> list: Solves the inversion problem for T test cases Parameters: T (int): Number of test cases data (list): List of tuples, each containing the size and array for the test cases Returns: list: Number of inversions for each test case from solve_inversion_problem import solve_inversion_problem def test_sample_input(): T = 2 data = [(5, [2, 4, 1, 3, 5]), (4, [8, 4, 2, 1])] assert solve_inversion_problem(T, data) == [3, 6] def test_empty_and_single_element_arrays(): T = 2 data = [(0, []), (1, [1])] assert solve_inversion_problem(T, data) == [0, 0] def test_already_sorted_array(): T = 1 data = [(5, [1, 2, 3, 4, 5])] assert solve_inversion_problem(T, data) == [0] def test_reversed_array(): T = 1 data = [(4, [4, 3, 2, 1])] assert solve_inversion_problem(T, data) == [6] def test_large_numbers(): T = 1 data = [(3, [10**9, 10**8, 10**7])] assert solve_inversion_problem(T, data) == [3] def test_repeated_elements(): T = 1 data = [(4, [1, 2, 2, 1])] assert solve_inversion_problem(T, data) == [2]","solution":"def count_inversions(nums): Returns the number of inversions in the array nums if len(nums) < 2: return 0 mid = len(nums) // 2 left = nums[:mid] right = nums[mid:] inversions = count_inversions(left) + count_inversions(right) i = j = k = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: nums[k] = left[i] i += 1 else: nums[k] = right[j] j += 1 inversions += len(left) - i k += 1 while i < len(left): nums[k] = left[i] i += 1 k += 1 while j < len(right): nums[k] = right[j] j += 1 k += 1 return inversions def solve_inversion_problem(T, data): Solves the inversion problem for T test cases Parameters: T (int): Number of test cases data (list): List of tuples, each containing the size and array for the test cases Returns: list: Number of inversions for each test case results = [] for i in range(T): n, nums = data[i] results.append(count_inversions(nums)) return results"},{"question":"def maxIncreasingSubsequenceLength(treeHeights): Returns the maximum number of trees that can be kept such that their heights form a strictly increasing sequence. >>> maxIncreasingSubsequenceLength([3, 4, 2, 1, 10, 6, 7]) 4 >>> maxIncreasingSubsequenceLength([5, 10, 3, 7, 8, 9]) 4 >>> maxIncreasingSubsequenceLength([1, 2, 3, 4, 5]) 5 >>> maxIncreasingSubsequenceLength([5, 4, 3, 2, 1]) 1 >>> maxIncreasingSubsequenceLength([]) 0 >>> maxIncreasingSubsequenceLength([10, 20, 10, 30, 20, 50]) 4 >>> maxIncreasingSubsequenceLength([3, 2, 6, 4, 5, 1]) 3 >>> maxIncreasingSubsequenceLength([1]) 1 >>> maxIncreasingSubsequenceLength([10, 10, 10, 10]) 1","solution":"def maxIncreasingSubsequenceLength(treeHeights): Returns the maximum number of trees that can be kept such that their heights form a strictly increasing sequence. if not treeHeights: return 0 n = len(treeHeights) dp = [1] * n # dp[i] will be the length of the longest increasing subsequence ending at i for i in range(n): for j in range(i): if treeHeights[j] < treeHeights[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_integer_after_deleting_one_character(s: str) -> str: Returns the maximum possible integer value that can be obtained by deleting exactly one character from the string s. If deleting one character cannot form a valid integer, returns the original string. Examples: >>> max_integer_after_deleting_one_character(\\"1234\\") '234' >>> max_integer_after_deleting_one_character(\\"1001\\") '101' >>> max_integer_after_deleting_one_character(\\"9\\") '9' >>> max_integer_after_deleting_one_character(\\"5123\\") '523'","solution":"def max_integer_after_deleting_one_character(s): Returns the maximum possible integer value that can be obtained by deleting exactly one character from the string s. If deleting one character cannot form a valid integer, returns the original string. if len(s) == 1: return s max_value = -1 for i in range(len(s)): new_value = int(s[:i] + s[i+1:]) if new_value > max_value: max_value = new_value return str(max_value)"},{"question":"def perform_operations(n: int, q: int, array: List[int], operations: List[int]) -> List[int]: Performs operations on the list of integers, and returns the sum of the elements after each operation. :param n: Size of the list :param q: Number of operations :param array: List of integers :param operations: List of operations :return: List of sums after each operation >>> perform_operations(5, 2, [1, 2, 3, 4, 5], [2, 3]) [25, 40] >>> perform_operations(1, 3, [10], [1, -2, 5]) [11, 9, 14] >>> perform_operations(4, 3, [1, 2, 3, 4], [0, 0, 0]) [10, 10, 10] >>> perform_operations(3, 2, [3, 3, 3], [-1, -2]) [6, 0] >>> perform_operations(2, 1, [10**6, -10**6], [10**6]) [2000000] pass","solution":"def perform_operations(n, q, array, operations): Performs operations on the list of integers, and returns the sum of the elements after each operation. :param n: Size of the list :param q: Number of operations :param array: List of integers :param operations: List of operations :return: List of sums after each operation # Calculate initial sum of the elements in the list current_sum = sum(array) results = [] for x in operations: # Update the sum after adding x to all elements in the list current_sum += x * n results.append(current_sum) return results"},{"question":"def find_hurdle_to_lower(n: int, k: int, heights: List[int]) -> int: Determine the index of one hurdle she should lower to increase the likelihood of a successful training session. >>> find_hurdle_to_lower(5, 7, [3, 10, 5, 6, 2]) 2 >>> find_hurdle_to_lower(4, 8, [5, 6, 7, 9]) 4 >>> find_hurdle_to_lower(3, 5, [6, 7, 8]) 1 >>> find_hurdle_to_lower(3, 3, [2, 3, 4]) 3 >>> find_hurdle_to_lower(3, 5, [1, 2, 3]) -1 >>> find_hurdle_to_lower(1, 1, [2]) 1 >>> find_hurdle_to_lower(4, 5, [6, 7, 8, 9]) 1","solution":"def find_hurdle_to_lower(n, k, heights): # Iterate through the hurdles to find the first one that the dog can't jump for i in range(n): if heights[i] > k: return i + 1 # If all hurdles are within the dog's jump capacity, no hurdle needs to be lowered return -1 # Example Usage n = 5 k = 7 heights = [3, 10, 5, 6, 2] print(find_hurdle_to_lower(n, k, heights)) # Output: 2"},{"question":"def transposeMatrix(matrix): Returns the transpose of a given 2D list (matrix). Returns False if the input is not a valid 2D list. >>> transposeMatrix([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] >>> transposeMatrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] >>> transposeMatrix([[1, 2, 3]]) == [[1], [2], [3]] >>> transposeMatrix([[1], [2], [3]]) == [[1, 2, 3]] >>> transposeMatrix([1, 2, 3]) == False >>> transposeMatrix([[1, 2, 3], [4, 5]]) == False","solution":"def transposeMatrix(matrix): Returns the transpose of a given 2D list (matrix). Returns False if the input is not a valid 2D list. # Check if input is a 2D list (list of lists) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return False # Check if all the rows have the same length if len(set(len(row) for row in matrix)) != 1: return False # Transpose the matrix transposed_matrix = [] for col in range(len(matrix[0])): transposed_row = [matrix[row][col] for row in range(len(matrix))] transposed_matrix.append(transposed_row) return transposed_matrix"},{"question":"class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with the given capacity. pass def get(self, key: int) -> int: Retrieve an item from the cache. If the key does not exist, return -1. pass def set(self, key: int, value: int) -> None: Add an item to the cache. If the cache is full, remove the least recently used item before adding the new item. pass # Example usage # cache = LRUCache(2) # cache.set(1, 1) # cache.set(2, 2) # print(cache.get(1)) # returns 1 # cache.set(3, 3) # evicts key 2 # print(cache.get(2)) # returns -1 (not found) # cache.set(4, 4) # evicts key 1 # print(cache.get(1)) # returns -1 (not found) # print(cache.get(3)) # returns 3 # print(cache.get(4)) # returns 4 # Unit tests def test_lru_cache_operations(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 cache.set(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.set(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_eviction(): cache = LRUCache(1) cache.set(1, 1) assert cache.get(1) == 1 cache.set(2, 2) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 def test_lru_cache_update(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 cache.set(1, 10) assert cache.get(1) == 10 # value should be updated to 10 def test_lru_cache_access(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 # access key 1 so it becomes recently used # Add a new key, which should evict key 2 (which is the least recently used) cache.set(3, 3) assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(1) == 1 # returns 1 (still in cache) assert cache.get(3) == 3 # returns 3 (just added)","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] # Order of keys to keep track of LRU def get(self, key: int) -> int: if key in self.cache: # Move this key to the end to show that it was recently used self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def set(self, key: int, value: int) -> None: if key in self.cache: # Update the value and move the key to the 'recently used' position self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: # Evict the least recently used key lru_key = self.order.pop(0) del self.cache[lru_key] # Add the new key and value self.cache[key] = value self.order.append(key)"},{"question":"def validate_purchase_records(records): Validate quantities in the purchase records. Args: records (list of str): List of purchase quantities as strings. Returns: list: [valid_count, overflow_count, invalid_count] Examples: >>> validate_purchase_records([\\"250\\", \\"1500\\", \\"-5\\", \\"800\\", \\"xyz\\", \\"734\\"]) [3, 1, 2] >>> validate_purchase_records([\\"1\\", \\"10\\", \\"100\\", \\"500\\", \\"999\\", \\"1000\\"]) [6, 0, 0] >>> validate_purchase_records([\\"1001\\", \\"2000\\", \\"1500\\", \\"9999\\"]) [0, 4, 0] >>> validate_purchase_records([\\"0\\", \\"-1\\", \\"abc\\", \\"\\", \\"1.5\\"]) [0, 0, 5] >>> validate_purchase_records([\\"50\\", \\"2048\\", \\"-10\\", \\"350\\", \\"qwerty\\", \\"88\\", \\"10001\\"]) [3, 2, 2]","solution":"def validate_purchase_records(records): Validate quantities in the purchase records. Args: records (list of str): List of purchase quantities as strings. Returns: list: [valid_count, overflow_count, invalid_count] valid_count = 0 overflow_count = 0 invalid_count = 0 for record in records: try: quantity = int(record) if quantity < 1: invalid_count += 1 elif quantity > 1000: overflow_count += 1 else: valid_count += 1 except ValueError: invalid_count += 1 return [valid_count, overflow_count, invalid_count]"},{"question":"def count_districts(n: int, m: int, grid: List[str]) -> int: Determine the number of districts in the city according to the given grid. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid grid (List[str]): List of strings representing the grid where 'L' is land and 'W' is water Returns: int: The number of districts in the city Examples: >>> count_districts(4, 5, [ ... \\"LWLWW\\", ... \\"LWLWL\\", ... \\"WWWLL\\", ... \\"LWLLW\\" ... ]) 4 >>> count_districts(3, 3, [ ... \\"LLL\\", ... \\"LWL\\", ... \\"LLL\\" ... ]) 1","solution":"def count_districts(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 'W' or visited[x][y]: return visited[x][y] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dx, dy in directions: dfs(x+dx, y+dy) visited = [[False] * m for _ in range(n)] districts = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L' and not visited[i][j]: dfs(i, j) districts += 1 return districts # Example usage: # n = 4 # m = 5 # grid = [ # \\"LWLWW\\", # \\"LWLWL\\", # \\"WWWLL\\", # \\"LWLLW\\" # ] # print(count_districts(n, m, grid)) # Output: 4"},{"question":"def minimize_differences(n: int, stones: List[int]) -> int: Moana is organizing her collection of magic stones, each with a unique magical power index. She arranges them sequentially, but due to a sudden storm, some stones are blown away, leaving gaps in her collection which she marks with a -1. Moana wants to rearrange the stones so that the sum of the differences between the magical power indices of the adjacent stones is minimized. The final arrangement should replace the -1 values optimally. A difference sequence for an arrangement is defined as the sum of the absolute differences of the magical power indices for every two adjacent stones. Examples of such differences are |a2 - a1| + |a3 - a2| + ... + |an - an-1|. Your objective is to help Moana minimize this difference sequence by finding an optimal way to replace the -1 gaps. Args: n: An integer representing the number of stones (2 ≤ n ≤ 1000). stones: A list of integers representing the initial arrangement of the stones, where -1 denotes a gap (0 ≤ aᵢ ≤ 1000 for indices of stones and -1 for gaps). The initial stones’ indices are such that they can form a continuous sequence when gaps are filled appropriately. Returns: An integer representing the minimum possible value of the sum of the differences of the adjacent stones after optimally filling the gaps. Examples: >>> minimize_differences(5, [2, -1, 3, -1, 4]) 2 >>> minimize_differences(4, [1, -1, -1, 4]) 3 >>> minimize_differences(3, [-1, 2, -1]) 0 >>> minimize_differences(6, [10, -1, -1, -1, -1, 20]) 10 >>> minimize_differences(2, [-1, 1000]) 0","solution":"def minimize_differences(n, stones): Returns the minimum possible value of the sum of the differences of the adjacent stones after optimally filling the gaps. def fill_gaps(arr): Helper function to fill the gaps (-1) in the array with optimal values that minimize the sum of absolute differences between adjacent elements. # First find all positions and corresponding stones where -1 is not present positions = [i for i, x in enumerate(arr) if x != -1] # If all positions are originally occupied, return the array as is if len(positions) == len(arr): return arr # Find the minimum value of a valid stone min_stone = min([arr[pos] for pos in positions]) max_stone = max([arr[pos] for pos in positions]) # Fill each -1 based on the minimum and maximum value calculated for i in range(len(arr)): if arr[i] == -1: if i == 0: # if the first element is -1, assign it to the minimum stone arr[i] = min_stone elif i == len(arr) - 1: # if the last element is -1, assign it to the maximum stone arr[i] = max_stone else: # Try to minimize the gap by assigning a value between its neighbors' values left_neighbor = arr[i - 1] right_neighbor = None for j in range(i + 1, len(arr)): if arr[j] != -1: right_neighbor = arr[j] break if right_neighbor is not None: arr[i] = (left_neighbor + right_neighbor) // 2 else: arr[i] = left_neighbor # if no valid neighbor on the right return arr stones = fill_gaps(stones) # Calculate the sum of differences between adjacent stones difference_sum = sum(abs(stones[i] - stones[i - 1]) for i in range(1, n)) return difference_sum"},{"question":"from typing import List def top_trending_hashtags(posts: List[str], N: int) -> List[str]: Returns the top N trending hashtags from the given list of posts. Args: posts (list of str): List of posts with words and hashtags. N (int): Number of top trending hashtags to return. Returns: list of str: List of top N trending hashtags. >>> top_trending_hashtags([\\"#fun #sun #sea\\", \\"I love the #sea and #sun\\", \\"#fun and #entertainment\\", \\"#sea\\"], 2) ['#sea', '#sun'] >>> top_trending_hashtags([\\"#apple #banana #apple\\", \\"Let's eat an #apple\\", \\"#orange #banana\\"], 3) ['#apple', '#banana', '#orange'] return [] def test_example1(): posts = [\\"#fun #sun #sea\\", \\"I love the #sea and #sun\\", \\"#fun and #entertainment\\", \\"#sea\\"] N = 2 assert top_trending_hashtags(posts, N) == ['#sea', '#sun'] def test_example2(): posts = [\\"#apple #banana #apple\\", \\"Let's eat an #apple\\", \\"#orange #banana\\"] N = 3 assert top_trending_hashtags(posts, N) == ['#apple', '#banana', '#orange'] def test_single_post(): posts = [\\"#hello #world\\"] N = 1 assert top_trending_hashtags(posts, N) == ['#hello'] def test_no_hashtags(): posts = [\\"This is a post without hashtags\\"] N = 1 assert top_trending_hashtags(posts, N) == [] def test_all_hashtags_same_frequency(): posts = [\\"#one #two #three\\", \\"#three #one #two\\", \\"#two #three #one\\"] N = 2 assert top_trending_hashtags(posts, N) == ['#one', '#three'] def test_more_hashtags_than_N(): posts = [\\"#apple #banana #citrus\\", \\"#dragon #elephant #frog\\", \\"#grape #hazelnut #ice\\"] N = 5 assert top_trending_hashtags(posts, N) == ['#apple', '#banana', '#citrus', '#dragon', '#elephant']","solution":"from collections import defaultdict def top_trending_hashtags(posts, N): Returns the top N trending hashtags from the given list of posts. Args: posts (list of str): List of posts with words and hashtags. N (int): Number of top trending hashtags to return. Returns: list of str: List of top N trending hashtags. hashtag_count = defaultdict(int) # Count the occurrence of each hashtag for post in posts: words = post.split() for word in words: if word.startswith('#'): hashtag_count[word] += 1 # Sort hashtags by frequency and then lexicographically sorted_hashtags = sorted(hashtag_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top N hashtags result = [hashtag for hashtag, count in sorted_hashtags[:N]] return result"},{"question":"def longest_subarray_length(arr, N, K): Returns the length of the longest subarray with sum less than or equal to K. >>> longest_subarray_length([1, 2, 3, 4, 5], 5, 10) 4 >>> longest_subarray_length([3, 1, 2, 1, 1, 1, 1, 1], 8, 15) 8 >>> longest_subarray_length([], 0, 10) 0 >>> longest_subarray_length([1, 2, 3, 4, 5], 5, 15) 5 >>> longest_subarray_length([3, 1, 2, 1, 1, 1, 1, 1], 8, 5) 5 # Your code here def solve(test_cases): Solves the problem for multiple test cases. # Your code here def process_input(input_data): Processes the input data and returns structured test cases. # Your code here","solution":"def longest_subarray_length(arr, N, K): Returns the length of the longest subarray with sum less than or equal to K. max_len = 0 current_sum = 0 start = 0 for end in range(N): current_sum += arr[end] while current_sum > K: current_sum -= arr[start] start += 1 max_len = max(max_len, end - start + 1) return max_len def solve(test_cases): results = [] for N, K, arr in test_cases: result = longest_subarray_length(arr, N, K) results.append(result) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, K = map(int, lines[index].split()) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, K, arr)) index += 2 return test_cases"},{"question":"def calculate_seating_capacity(test_cases: List[List[int]]) -> List[Tuple[int, int]]: Calculate the total seating capacity for a given set of loops, each with a different number of seats. Parameters: test_cases (List[List[int]]): A list containing multiple test cases. Each test case is a list where the first integer represents the number of loops, followed by integers representing the number of seats in each loop. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two integers. The first integer is the total seating capacity, and the second integer is the number of guests seated in the largest loop. Example: >>> calculate_seating_capacity([ ... [1, 10], ... [2, 4, 6] ... ]) [(10, 10), (10, 6)] >>> calculate_seating_capacity([ ... [3, 5, 10, 7], ... [1, 50] ... ]) [(22, 10), (50, 50)]","solution":"def calculate_seating_capacity(test_cases): results = [] for case in test_cases: loops = case[1:] total_capacity = sum(loops) max_loop = max(loops) results.append((total_capacity, max_loop)) return results"},{"question":"from typing import List def largest_k_divisible(nums: List[int]) -> int: Write a function that takes a list of integers as input and returns the largest integer \`k\` such that all integers in the list are divisible by \`k\` and \`k\` is greater than 1. >>> largest_k_divisible([4, 8, 16, 32]) 4 >>> largest_k_divisible([5, 10, 15, 20]) 5 >>> largest_k_divisible([7, 11, 13, 17]) -1 pass # Unit tests def test_all_multiples(): assert largest_k_divisible([4, 8, 16, 32]) == 4 def test_common_multiple(): assert largest_k_divisible([5, 10, 15, 20]) == 5 def test_no_common_divisor_greater_than_one(): assert largest_k_divisible([7, 11, 13, 17]) == -1 def test_all_prime_numbers(): assert largest_k_divisible([3, 5, 7, 11]) == -1 def test_same_number(): assert largest_k_divisible([8, 8, 8, 8]) == 8 def test_large_numbers(): assert largest_k_divisible([100, 200, 300, 400]) == 100 def test_mixed_numbers(): assert largest_k_divisible([21, 35, 49]) == 7 def test_two_numbers(): assert largest_k_divisible([9, 27]) == 9","solution":"import math from functools import reduce def gcd(a, b): Calculates the greatest common divisor of a and b. while b: a, b = b, a % b return a def gcd_of_list(numbers): Calculates the greatest common divisor (gcd) of a list of numbers. return reduce(gcd, numbers) def largest_k_divisible(nums): Returns the largest integer k greater than 1 such that all integers in nums are divisible by k, or -1 if no such k exists. g = gcd_of_list(nums) if g > 1: return g else: return -1"},{"question":"def process_operations(operations: List[str]) -> List[int]: Manipulate a list of integers based on a list of operations. Each operation can either be adding a number to the list, removing a number from the list, or finding the maximum number in the list. - \`1 x\`: Add integer \`x\` to the list. - \`2 x\`: Remove one occurrence of integer \`x\` from the list. If \`x\` is not present in the list, do nothing. - \`3\`: Find and return the maximum integer in the list. If the list is empty, return -1. Returns a list of results from the '3' operations in the order they were encountered. >>> process_operations([\\"1 3\\", \\"1 5\\", \\"1 -1\\", \\"3\\", \\"2 5\\", \\"3\\"]) [5, 3] >>> process_operations([\\"1 2\\", \\"2 2\\", \\"3\\", \\"1 8\\", \\"1 7\\", \\"3\\", \\"2 9\\"]) [-1, 8] pass","solution":"def process_operations(operations): lst = [] results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"1\\": x = int(parts[1]) lst.append(x) elif command == \\"2\\": x = int(parts[1]) if x in lst: lst.remove(x) elif command == \\"3\\": if lst: results.append(max(lst)) else: results.append(-1) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: This function returns the longest palindromic substring of s. If there are multiple substrings of the same maximum length, it returns the first one. >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abccba\\") == \\"abccba\\" >>> longest_palindromic_substring(\\"abcd\\") == \\"a\\" or longest_palindromic_substring(\\"abcd\\") == \\"b\\" or longest_palindromic_substring(\\"abcd\\") == \\"c\\" or longest_palindromic_substring(\\"abcd\\") == \\"d\\" >>> longest_palindromic_substring(\\"abcdefgfedcba\\") == \\"abcdefgfedcba\\" >>> longest_palindromic_substring(\\"noonracecar\\") == \\"racecar\\" or longest_palindromic_substring(\\"noonracecar\\") == \\"noon\\"","solution":"def longest_palindromic_substring(s): This function returns the longest palindromic substring of s. If there are multiple substrings of the same maximum length, it returns the first one. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 for i in range(n): # Odd length palindromes centered at i low, high = i, i while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 # Even length palindromes centered between i and i + 1 low, high = i, i + 1 while low >= 0 and high < n and s[low] == s[high]: current_length = high - low + 1 if current_length > max_length: start = low max_length = current_length low -= 1 high += 1 return s[start:start + max_length]"},{"question":"borrowed_books = set() def borrow_book(book_id: int) -> str: Marks a book as borrowed. If the book is already borrowed, it should return \\"Book already borrowed\\", otherwise it should return \\"Book borrowed successfully\\". >>> borrow_book(1) \\"Book borrowed successfully\\" >>> borrow_book(1) \\"Book already borrowed\\" pass def return_book(book_id: int) -> str: Marks a book as returned. If the book was not borrowed, it should return \\"Book was not borrowed\\", otherwise it should return \\"Book returned successfully\\". >>> return_book(1) \\"Book was not borrowed\\" >>> borrow_book(1) \\"Book borrowed successfully\\" >>> return_book(1) \\"Book returned successfully\\" pass def currently_borrowed() -> list: Returns a list of all book ids that are currently borrowed, sorted in ascending order. >>> borrow_book(1) \\"Book borrowed successfully\\" >>> borrow_book(2) \\"Book borrowed successfully\\" >>> currently_borrowed() [1, 2] pass","solution":"borrowed_books = set() def borrow_book(book_id: int) -> str: if book_id in borrowed_books: return \\"Book already borrowed\\" borrowed_books.add(book_id) return \\"Book borrowed successfully\\" def return_book(book_id: int) -> str: if book_id not in borrowed_books: return \\"Book was not borrowed\\" borrowed_books.remove(book_id) return \\"Book returned successfully\\" def currently_borrowed() -> list: return sorted(borrowed_books)"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] = target. Parameters: arr (List[int]): A list of integers target (int): The target sum Returns: bool: True if such indices exist, False otherwise. Examples: >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([3, 1, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True pass","solution":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] = target. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def get_longest_star_segment(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the length of the longest contiguous segment of stars for each query in the list of queries. Parameters: s (str): A string representing the galaxy. queries (list of tuples): A list of tuples where each tuple contains two integers (l, r) representing the query range. Returns: list of int: A list of integers representing the answer to each query. Example: >>> get_longest_star_segment(\\"*--**-*-\\", [(1, 4), (3, 7), (1, 8)]) [1, 2, 2] >>> get_longest_star_segment(\\"***--***\\", [(1, 3), (5, 8)]) [3, 3]","solution":"def get_longest_star_segment(s, queries): Returns the length of the longest contiguous segment of stars for each query in the list of queries. Parameters: s (str): A string representing the galaxy. queries (list of tuples): A list of tuples where each tuple contains two integers (l, r) representing the query range. Returns: list of int: A list of integers representing the answer to each query. results = [] for l, r in queries: substring = s[l-1:r] # Obtain the substring based on the query range max_stars = 0 current_stars = 0 for char in substring: if char == '*': current_stars += 1 max_stars = max(max_stars, current_stars) else: current_stars = 0 results.append(max_stars) return results"},{"question":"def can_transform(A: str, B: str) -> str: Determines if it's possible to transform word A into word B using the given spell operation. >>> can_transform(\\"abcde\\", \\"cdeab\\") \\"YES\\" >>> can_transform(\\"abcd\\", \\"bcda\\") \\"YES\\" >>> can_transform(\\"abcdef\\", \\"debcaf\\") \\"NO\\" >>> can_transform(\\"a\\", \\"a\\") \\"YES\\" >>> can_transform(\\"abcdxyz\\", \\"yzabcdx\\") \\"YES\\" >>> can_transform(\\"abcdefg\\", \\"fgabcde\\") \\"YES\\" >>> can_transform(\\"abcdefg\\", \\"gfedcba\\") \\"NO\\" def process_test_cases(T: int, cases: list) -> list: Process multiple test cases to determine if transformation from A to B is possible. >>> process_test_cases(3, [(5, \\"abcde\\", \\"cdeab\\"), (4, \\"abcd\\", \\"bcda\\"), (6, \\"abcdef\\", \\"debcaf\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(1, [(1, \\"a\\", \\"a\\")]) [\\"YES\\"]","solution":"def can_transform(A, B): Determines if it's possible to transform word A into word B using the given spell operation. if len(A) != len(B): return \\"NO\\" if A == B: return \\"YES\\" # Double A and see if B is a substring - this handles all rotations doubled_A = A + A if B in doubled_A: return \\"YES\\" return \\"NO\\" def process_test_cases(T, cases): results = [] for i in range(T): N = cases[i][0] A = cases[i][1] B = cases[i][2] result = can_transform(A, B) results.append(result) return results"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals and return the list of merged intervals in sorted order Args: intervals (List[List[int]]): A list of intervals where each interval is represented as a pair of start and end times [start, end]. Returns: List[List[int]]: The list of merged intervals in sorted order. Example: >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([[1,4],[0,1]]) [[0,4]]","solution":"def merge_intervals(intervals): if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # Overlapping intervals, merge them merged[-1] = [previous[0], max(previous[1], current[1])] else: # Non-overlapping interval, add to the list merged.append(current) return merged"},{"question":"def min_cost_to_convert(a: str, b: str) -> int: Write a function \`min_cost_to_convert(a, b)\` that takes two strings \`a\` and \`b\` as input. The task is to compute the minimum cost required to transform string \`a\` into string \`b\`. You are given the following operations with specified costs: - Insert a character: cost = 1 - Delete a character: cost = 1 - Replace a character: cost = 2 You can perform any of these operations any number of times. >>> min_cost_to_convert(\\"abcdef\\", \\"azced\\") 5 >>> min_cost_to_convert(\\"intention\\", \\"execution\\") 8 >>> min_cost_to_convert(\\"same\\", \\"same\\") 0 >>> min_cost_to_convert(\\"\\", \\"data\\") 4 >>> min_cost_to_convert(\\"algo\\", \\"\\") 4 >>> min_cost_to_convert(\\"\\", \\"\\") 0 >>> min_cost_to_convert(\\"abc\\", \\"xyz\\") 6","solution":"def min_cost_to_convert(a, b): Returns the minimum cost required to transform string \`a\` into string \`b\` using the given operations. n = len(a) m = len(b) # Create a 2D DP array dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)] # Initialize the first row and first column for i in range(n + 1): dp[i][0] = i # Cost of deleting all characters in \`a\` for j in range(m + 1): dp[0][j] = j # Cost of inserting all characters in \`b\` # Fill the DP array for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no cost else: dp[i][j] = min(dp[i - 1][j] + 1, # Delete dp[i][j - 1] + 1, # Insert dp[i - 1][j - 1] + 2) # Replace return dp[n][m]"},{"question":"def robot_returns_to_origin(commands: str) -> bool: Determine if the robot returns to the origin (0, 0) after executing all the commands. Parameters: commands (str): A string containing the movement commands ('U', 'D', 'L', 'R'). Returns: bool: True if the robot returns to the origin, False otherwise. Examples: >>> robot_returns_to_origin(\\"UD\\") True >>> robot_returns_to_origin(\\"LL\\") False >>> robot_returns_to_origin(\\"RRDD\\") False >>> robot_returns_to_origin(\\"LDRRLRUULR\\") False >>> robot_returns_to_origin(\\"URDL\\") True >>> robot_returns_to_origin(\\"\\") True >>> robot_returns_to_origin(\\"UUUDDDRRRLLL\\") True","solution":"def robot_returns_to_origin(commands): Determine if the robot returns to the origin (0, 0) after executing all commands. Parameters: commands (str): A string containing the movement commands ('U', 'D', 'L', 'R'). Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return x == 0 and y == 0"},{"question":"def are_alphabetically_similar(A: str, B: str) -> str: Determines if strings A and B are alphabetically similar. >>> are_alphabetically_similar(\\"abc\\", \\"bca\\") \\"YES\\" >>> are_alphabetically_similar(\\"abc\\", \\"abcd\\") \\"NO\\" >>> are_alphabetically_similar(\\"aabbcc\\", \\"bbaacc\\") \\"YES\\" >>> are_alphabetically_similar(\\"abc\\", \\"abcd\\") \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if strings are alphabetically similar. >>> process_test_cases([(\\"abc\\", \\"bca\\"), (\\"abcd\\", \\"dcba\\"), (\\"aabbcc\\", \\"bbaacc\\"), (\\"abc\\", \\"abcd\\")]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def are_alphabetically_similar(A, B): Determines if strings A and B are alphabetically similar. if len(A) != len(B): return \\"NO\\" return \\"YES\\" if sorted(A) == sorted(B) else \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases to determine if strings are alphabetically similar. :param test_cases: List of tuples, each containing two strings A and B :return: List of results for each test case results = [] for A, B in test_cases: results.append(are_alphabetically_similar(A, B)) return results"},{"question":"from typing import List, Tuple def length_of_longest_substring_with_unique_chars(s: str, l: int, r: int) -> int: Returns the length of the longest substring within s[l-1:r] containing all unique characters. Parameters: s (str): The original string. l (int): Starting index of the query (1-based). r (int): Ending index of the query (1-based). Returns: int: Length of the longest substring with all unique characters in the given range. pass def process_queries(s: str, queries: List[Tuple[int, int]]) -> List[int]: Processes a list of queries to find the length of the longest substring with unique characters in the given ranges. Parameters: s (str): The original string. queries (List[Tuple[int, int]]): A list of (l, r) tuples representing queries. Returns: List[int]: A list of results for each query. pass def test_length_of_longest_substring_with_unique_chars(): assert length_of_longest_substring_with_unique_chars(\\"abcdea\\", 1, 5) == 5 assert length_of_longest_substring_with_unique_chars(\\"abcdea\\", 2, 4) == 3 assert length_of_longest_substring_with_unique_chars(\\"abcdea\\", 1, 6) == 5 assert length_of_longest_substring_with_unique_chars(\\"aaaaa\\", 1, 5) == 1 assert length_of_longest_substring_with_unique_chars(\\"abcdabcd\\", 1, 8) == 4 def test_process_queries(): s = \\"abcdea\\" queries = [(1, 5), (2, 4), (1, 6)] assert process_queries(s, queries) == [5, 3, 5] s = \\"abcdefg\\" queries = [(1, 7), (1, 3), (4, 7)] assert process_queries(s, queries) == [7, 3, 4] s = \\"aaaabbbb\\" queries = [(1, 4), (5, 8), (1, 8)] assert process_queries(s, queries) == [1, 1, 2]","solution":"def length_of_longest_substring_with_unique_chars(s, l, r): Returns the length of the longest substring within s[l-1:r] containing all unique characters. substring = s[l-1:r] used_char_map = {} max_len = 0 start = 0 for i in range(len(substring)): if substring[i] in used_char_map and used_char_map[substring[i]] >= start: start = used_char_map[substring[i]] + 1 used_char_map[substring[i]] = i max_len = max(max_len, i - start + 1) return max_len def process_queries(s, queries): results = [] for l, r in queries: results.append(length_of_longest_substring_with_unique_chars(s, l, r)) return results"},{"question":"def process_operations(operations): Given a list of operations, maintain a list of unique sample IDs and perform the specified operations, returning the size of the list when requested and providing the final sorted list of sample IDs. Parameters: operations (List[str]): A list of strings representing operations. Returns: List[Union[int, List[int]]]: A list containing the sizes of the list after \\"size\\" operations, followed by the final sorted list of sample IDs. Examples: >>> process_operations([\\"insert 10\\", \\"insert 5\\", \\"size\\", \\"insert 15\\", \\"size\\", \\"remove 10\\", \\"size\\"]) [2, 3, 2, [5, 15]] >>> process_operations([\\"insert 10\\", \\"insert 20\\", \\"insert 10\\", \\"remove 5\\", \\"size\\"]) [2, [10, 20]] pass import pytest def test_example_1(): operations = [ \\"insert 10\\", \\"insert 5\\", \\"size\\", \\"insert 15\\", \\"size\\", \\"remove 10\\", \\"size\\" ] expected = [2, 3, 2, [5, 15]] assert process_operations(operations) == expected def test_example_2(): operations = [ \\"insert 10\\", \\"insert 20\\", \\"insert 10\\", # attempting to insert duplicate \\"remove 5\\", # attempting to remove non-existent item \\"size\\" ] expected = [2, [10, 20]] assert process_operations(operations) == expected def test_inserting_and_removing(): operations = [ \\"insert 100\\", \\"insert 200\\", \\"insert 300\\", \\"size\\", \\"remove 100\\", \\"size\\", \\"remove 200\\", \\"remove 300\\", \\"size\\" ] expected = [3, 2, 0, []] assert process_operations(operations) == expected def test_size_with_no_inserts(): operations = [ \\"size\\" ] expected = [0, []] assert process_operations(operations) == expected def test_remove_not_inserted(): operations = [ \\"remove 10\\", \\"remove 20\\", \\"insert 5\\", \\"size\\", \\"remove 5\\", \\"insert 10\\", \\"insert 0\\", \\"size\\" ] expected = [1, 2, [0, 10]] assert process_operations(operations) == expected","solution":"def process_operations(operations): sample_ids = [] result = [] for operation in operations: if operation.startswith(\\"insert\\"): _, x = operation.split() x = int(x) if x not in sample_ids: sample_ids.append(x) elif operation.startswith(\\"remove\\"): _, x = operation.split() x = int(x) if x in sample_ids: sample_ids.remove(x) elif operation == \\"size\\": result.append(len(sample_ids)) sample_ids.sort() result.append(sample_ids) return result"},{"question":"def who_wins(n: int, m: int, grid: List[List[int]]) -> str: Determines the winner if both players play optimally. Parameters: n (int): number of rows m (int): number of columns grid (list of list of int): grid of non-negative integers Returns: str: \\"First\\" if the first player wins, otherwise \\"Second\\" >>> who_wins(1, 1, [[0]]) == \\"Second\\" >>> who_wins(1, 1, [[5]]) == \\"Second\\" >>> who_wins(2, 2, [[1, 2], [3, 4]]) == \\"First\\" >>> who_wins(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == \\"First\\" >>> who_wins(2, 3, [[1, 2, 3], [4, 5, 6]]) == \\"First\\" >>> who_wins(3, 2, [[1, 2], [3, 4], [5, 6]]) == \\"First\\"","solution":"def who_wins(n, m, grid): Determines the winner if both players play optimally. Parameters: n (int): number of rows m (int): number of columns grid (list of list of int): grid of non-negative integers Returns: str: \\"First\\" if the first player wins, otherwise \\"Second\\" if n == 1 and m == 1: return \\"Second\\" else: return \\"First\\""},{"question":"def final_frog_position(W, H, xs, ys, instructions): Determines the final position of the frog after executing a series of teleportation instructions. Returns \\"Out of Bounds\\" if the frog's position goes out of grid bounds. Args: W (int): width of the grid H (int): height of the grid xs (int): starting x position ys (int): starting y position instructions (List[Tuple[str, int]]): list of tuples with direction and distance Returns: str or Tuple[int, int]: final position or \\"Out of Bounds\\" >>> final_frog_position(10, 10, 5, 5, [(\\"N\\", 3), (\\"E\\", 2), (\\"SE\\", 4)]) \\"Out of Bounds\\" >>> final_frog_position(100, 100, 50, 50, [(\\"NW\\", 25), (\\"SE\\", 10)]) (35, 65) >>> final_frog_position(10, 10, 0, 0, [(\\"S\\", 1)]) \\"Out of Bounds\\" >>> final_frog_position(10, 10, 0, 0, [(\\"E\\", 5), (\\"N\\", 5)]) (5, 5) >>> final_frog_position(5, 5, 2, 2, [(\\"NE\\", 1), (\\"SW\\", 1), (\\"E\\", 1)]) (3, 2) def process_input(input_lines): Processes the input lines and returns the final output, representing the final position of frogs. Args: input_lines (List[str]): list of input lines Returns: List[str]: List of output results for each test case >>> process_input([ \\"10 10 5 5\\", \\"3\\", \\"N 3\\", \\"E 2\\", \\"SE 4\\", \\"100 100 50 50\\", \\"2\\", \\"NW 25\\", \\"SE 10\\", \\"0 0 0 0\\" ]) [\\"Out of Bounds\\", \\"35 65\\"]","solution":"def final_frog_position(W, H, xs, ys, instructions): Determines the final position of the frog after executing a series of teleportation instructions. xf, yf = xs, ys direction_mapping = { \\"N\\": (0, 1), \\"S\\": (0, -1), \\"E\\": (1, 0), \\"W\\": (-1, 0), \\"NE\\": (1, 1), \\"NW\\": (-1, 1), \\"SE\\": (1, -1), \\"SW\\": (-1, -1) } for direction, distance in instructions: dx, dy = direction_mapping[direction] xf += dx * distance yf += dy * distance if not (0 <= xf < W and 0 <= yf < H): return \\"Out of Bounds\\" return (xf, yf) def process_input(input_lines): output_lines = [] index = 0 while True: W, H, xs, ys = map(int, input_lines[index].split()) if W == 0 and H == 0 and xs == 0 and ys == 0: break index += 1 n = int(input_lines[index]) instructions = [] for _ in range(n): index += 1 dir, dist = input_lines[index].split() instructions.append((dir, int(dist))) result = final_frog_position(W, H, xs, ys, instructions) output_lines.append(result if result == \\"Out of Bounds\\" else f\\"{result[0]} {result[1]}\\") index += 1 return output_lines"},{"question":"def minSwaps(food: List[int], distribution: List[int]) -> int: Returns the minimum number of swaps required to match each guest with their favorite dish. food: List[int] - Array representing each guest's favorite dish. distribution: List[int] - Array representing the dishes currently available at each table. Returns an integer indicating the minimum number of swaps required. Example: >>> minSwaps([1, 4, 3, 2], [2, 1, 4, 3]) 3 >>> minSwaps([5, 6, 7], [7, 6, 5]) 1","solution":"def minSwaps(food, distribution): Returns the minimum number of swaps required to match each guest with their favorite dish. n = len(food) # Create a mapping from food to its index in distribution pos = {distribution[i]: i for i in range(n)} swaps = 0 for i in range(n): # If the current dish is not the favorite dish of the i-th guest if distribution[i] != food[i]: swaps += 1 # Find the correct position of the desired dish correct_pos = pos[food[i]] # Swap the dishes distribution[i], distribution[correct_pos] = distribution[correct_pos], distribution[i] # Update the positions in the pos map pos[distribution[correct_pos]] = correct_pos pos[distribution[i]] = i return swaps"},{"question":"from typing import List def min_score_difference(M: int, N: int, scores: List[List[int]]) -> int: Calculate the minimum possible difference between the highest and lowest total scores of participants after all rounds. :param M: Number of participants :param N: Number of rounds :param scores: A 2D list of scores where scores[i][j] is the score of the i-th participant in the j-th round :return: Minimum possible difference between highest and lowest total scores >>> min_score_difference(3, 4, [[10, 20, 30, 40], [15, 25, 35, 45], [5, 15, 25, 35]]) == 40 >>> min_score_difference(3, 4, [[10, 10, 10, 10], [10, 10, 10, 10], [10, 10, 10, 10]]) == 0 >>> min_score_difference(2, 5, [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]]) == 0 >>> min_score_difference(1, 3, [[10, 20, 30]]) == 0 >>> min_score_difference(2, 3, [[10, 20, 30], [5, 15, 25]]) == 15 pass # Your code here","solution":"def min_score_difference(M, N, scores): Calculate the minimum possible difference between the highest and lowest total scores of participants after all rounds. :param M: Number of participants :param N: Number of rounds :param scores: A 2D list of scores where scores[i][j] is the score of the i-th participant in the j-th round :return: Minimum possible difference between highest and lowest total scores # Calculate total scores for each participant total_scores = [sum(scores[i]) for i in range(M)] # Find the highest and lowest total scores max_score = max(total_scores) min_score = min(total_scores) # Return the difference between highest and lowest total scores return max_score - min_score # Sample input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) scores = [] index = 2 for _ in range(M): scores.append(list(map(int, data[index:index + N]))) index += N result = min_score_difference(M, N, scores) print(result)"},{"question":"def create_diamond(n: int) -> str: Create a diamond shape string with \\"■\\" and \\"□\\" of size n. Parameters: n (int): The size of the diamond, must be an odd integer >= 3. Returns: str: The formatted diamond shape with each line separated by a 'n'. pass def test_diamond_of_3(): expected = \\"□■□n■■■n□■□\\" assert create_diamond(3) == expected def test_diamond_of_5(): expected = \\"□□■□□n□■■■□n■■■■■n□■■■□n□□■□□\\" assert create_diamond(5) == expected def test_diamond_of_7(): expected = \\"□□□■□□□n□□■■■□□n□■■■■■□n■■■■■■■n□■■■■■□n□□■■■□□n□□□■□□□\\" assert create_diamond(7) == expected def test_diamond_invalid_even(): assert create_diamond(4) == \\"\\" def test_diamond_invalid_less_than_3(): assert create_diamond(1) == \\"\\"","solution":"def create_diamond(n): Create a diamond shape string with \\"■\\" and \\"□\\" of size n. Parameters: n (int): The size of the diamond, must be an odd integer >= 3. Returns: str: The formatted diamond shape with each line separated by a 'n'. if n % 2 == 0 or n < 3: return \\"\\" mid = n // 2 diamond = [] # Create the first half of the diamond for i in range(mid + 1): line = '□' * (mid - i) + '■' * (2 * i + 1) + '□' * (mid - i) diamond.append(line) # Create the second half of the diamond (mirror the first half except the middle) for i in range(mid - 1, -1, -1): line = '□' * (mid - i) + '■' * (2 * i + 1) + '□' * (mid - i) diamond.append(line) return 'n'.join(diamond)"},{"question":"def max_product(n: int, a: List[int]) -> int: Returns the maximum product of any two distinct elements in the array. If there are duplicate elements in the array, returns -1. >>> max_product(5, [5, 1, 2, 3, 4]) 20 >>> max_product(4, [1, 2, 3, 2]) -1 >>> max_product(6, [-5, -4, 2, 3, 4, -1]) 20 >>> max_product(7, [6, 6]) -1 >>> max_product(8, [2, 3, 5, 7, 11, 13]) 143","solution":"def max_product(n, a): Returns the maximum product of any two distinct elements in the array. If there are duplicate elements in the array, returns -1. # Check for duplicates if len(a) != len(set(a)): return -1 # Sort the array a_sorted = sorted(a) # The maximum product of any two distinct elements is either # the product of the two largest elements or # the product of the two smallest elements (if both are negative) return max(a_sorted[-1] * a_sorted[-2], a_sorted[0] * a_sorted[1]) # Example usage # n = 5 # a = [5, 1, 2, 3, 4] # print(max_product(n, a)) # Output: 20"},{"question":"def longest_feeding_sequence(feedings): Returns the longest sequence of consecutive feedings where the same type of food was given to the same animal. >>> longest_feeding_sequence([ ... (1, \\"Rex\\", \\"bones\\"), ... (2, \\"Rex\\", \\"bones\\"), ... (3, \\"Rex\\", \\"meat\\"), ... (4, \\"Rex\\", \\"meat\\"), ... (5, \\"Rex\\", \\"meat\\") ... ]) == 3 >>> longest_feeding_sequence([ ... (1, \\"Bella\\", \\"fish\\"), ... (2, \\"Bella\\", \\"fish\\"), ... (3, \\"Rex\\", \\"bones\\"), ... (4, \\"Rex\\", \\"bones\\"), ... (5, \\"Bella\\", \\"fish\\"), ... (6, \\"Bella\\", \\"fish\\") ... ]) == 2 >>> longest_feeding_sequence([ ... (1, \\"Rex\\", \\"fish\\"), ... (2, \\"Rex\\", \\"bones\\"), ... (3, \\"Rex\\", \\"bones\\"), ... (4, \\"Rex\\", \\"meat\\"), ... (5, \\"Rex\\", \\"meat\\"), ... (6, \\"Rex\\", \\"meat\\"), ... (7, \\"Rex\\", \\"meat\\") ... ]) == 4 >>> longest_feeding_sequence([ ... (1, \\"Rex\\", \\"bones\\"), ... (2, \\"Bella\\", \\"bones\\"), ... (3, \\"Max\\", \\"meat\\") ... ]) == 1 >>> longest_feeding_sequence([ ... (1, \\"Rex\\", \\"bones\\") ... ]) == 1 >>> longest_feeding_sequence([]) == 0 >>> longest_feeding_sequence([ ... (1, \\"Husky\\", \\"chicken\\"), ... (2, \\"Husky\\", \\"meat\\"), ... (3, \\"Husky\\", \\"chicken\\"), ... (4, \\"Husky\\", \\"chicken\\") ... ]) == 2","solution":"def longest_feeding_sequence(feedings): Returns the longest sequence of consecutive feedings where the same type of food was given to the same animal. if not feedings: return 0 max_length = 0 current_length = 1 current_animal_food = (feedings[0][1], feedings[0][2]) for i in range(1, len(feedings)): next_animal_food = (feedings[i][1], feedings[i][2]) if next_animal_food == current_animal_food: current_length += 1 else: if current_length > max_length: max_length = current_length current_animal_food = next_animal_food current_length = 1 # Update max length for the last sequence if current_length > max_length: max_length = current_length return max_length"},{"question":"def filter_even_numbers(numbers: List[int]) -> List[int]: Returns a new list containing only the even integers from the input list. Args: numbers (list): A list of integers. Returns: list: A list of even integers. >>> filter_even_numbers([1, 2, 3, 4, 5]) [2, 4] >>> filter_even_numbers([10, 21, 32, 43, 54]) [10, 32, 54]","solution":"def filter_even_numbers(numbers): Returns a new list containing only the even integers from the input list. Args: numbers (list): A list of integers. Returns: list: A list of even integers. return [num for num in numbers if num % 2 == 0]"},{"question":"def subset_sum_exists(n, T, times): Determines if there exists a non-empty subset of \`times\` where the sum is exactly \`T\`. Params: - n (int): number of levels - T (int): target time limit - times (List[int]): completion times for each level Returns: - str: \\"YES\\" if such a subset exists, otherwise \\"NO\\" pass def puzzle_game(test_cases): Determines if there exists a non-empty subset of levels whose completion times sum up to exactly the target time limit for multiple test cases. Params: - test_cases (List[Tuple[Tuple[int, int], List[int]]]): list of test cases where each test case is represented as a tuple containing a tuple of \`n\` and \`T\` and a list of completion times. Returns: - List[str]: \\"YES\\" for each test case where a subset exists, otherwise \\"NO\\" pass from solution import subset_sum_exists, puzzle_game def test_subset_sum_exists(): # Test case 1 assert subset_sum_exists(4, 10, [1, 2, 3, 4]) == \\"YES\\" # Test case 2 assert subset_sum_exists(3, 5, [2, 2, 3]) == \\"YES\\" # Test case 3 assert subset_sum_exists(5, 15, [5, 5, 5, 5, 5]) == \\"YES\\" # Test case 4 assert subset_sum_exists(4, 11, [1, 2, 3, 4]) == \\"NO\\" def test_puzzle_game(): test_cases = [ ((4, 10), [1, 2, 3, 4]), ((3, 5), [2, 2, 3]), ((5, 15), [5, 5, 5, 5, 5]) ] expected_output = [\\"YES\\", \\"YES\\", \\"YES\\"] assert puzzle_game(test_cases) == expected_output test_cases = [ ((4, 11), [1, 2, 3, 4]), ((2, 20), [10, 9]), ((1, 1), [1]) ] expected_output = [\\"NO\\", \\"NO\\", \\"YES\\"] assert puzzle_game(test_cases) == expected_output","solution":"def subset_sum_exists(n, T, times): Determines if there exists a non-empty subset of \`times\` where the sum is exactly \`T\`. from itertools import combinations for r in range(1, n + 1): for comb in combinations(times, r): if sum(comb) == T: return \\"YES\\" return \\"NO\\" def puzzle_game(test_cases): results = [] for test_case in test_cases: n, T = test_case[0] times = test_case[1] results.append(subset_sum_exists(n, T, times)) return results"},{"question":"from typing import List, Tuple def minimal_cost_to_connect_all_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculates the minimal possible total cost to connect all the cities with King's Network. Parameters: n (int): Number of cities. m (int): Number of roads. roads (List[Tuple[int, int, int]]): A list of roads where each road is represented by a tuple containing two cities and the cost of the road. Returns: int: The minimal cost to connect all the cities. Examples: >>> minimal_cost_to_connect_all_cities(4, 5, [(1, 2, 3), (1, 3, 1), (3, 2, 2), (2, 4, 4), (3, 4, 5)]) 7 >>> minimal_cost_to_connect_all_cities(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) 3","solution":"def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) mst_cost = 0 mst_edges = 0 for edge in edges: u, v, w = edge root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_cost += w union(parent, rank, root_u, root_v) mst_edges += 1 if mst_edges == n - 1: break return mst_cost def minimal_cost_to_connect_all_cities(n, m, roads): edges = [(u-1, v-1, w) for (u, v, w) in roads] return kruskal(n, edges)"},{"question":"def longest_valid_path_length(H: int, W: int, grid: List[str], N: int, dictionary: List[str]) -> int: Find the length of the longest path in the grid that visits each cell at most once and forms a valid word from a given dictionary. >>> longest_valid_path_length(3, 3, [\\"aaa\\", \\"aba\\", \\"aaa\\"], 4, [\\"aaa\\", \\"aba\\", \\"aaaa\\", \\"abaa\\"]) == 4 >>> longest_valid_path_length(2, 2, [\\"ab\\", \\"cd\\"], 2, [\\"efg\\", \\"hij\\"]) == 0 >>> longest_valid_path_length(1, 1, [\\"a\\"], 1, [\\"a\\"]) == 1 >>> longest_valid_path_length(3, 3, [\\"cat\\", \\"dog\\", \\"bat\\"], 4, [\\"cat\\", \\"cog\\", \\"dog\\", \\"bat\\"]) == 3 >>> longest_valid_path_length(3, 3, [\\"xyz\\", \\"xzz\\", \\"xyz\\"], 5, [\\"xyz\\", \\"xzz\\", \\"zzz\\", \\"yxz\\", \\"zyx\\"]) == 3","solution":"def longest_valid_path_length(H, W, grid, N, dictionary): def is_valid(x, y): return 0 <= x < H and 0 <= y < W and not visited[x][y] def dfs(x, y, word): longest = 0 if word in word_set: longest = len(word) # Four possible movements: right, left, down, up for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True longest = max(longest, dfs(nx, ny, word + grid[nx][ny])) visited[nx][ny] = False return longest word_set = set(dictionary) max_length = 0 visited = [[False] * W for _ in range(H)] for i in range(H): for j in range(W): visited[i][j] = True max_length = max(max_length, dfs(i, j, grid[i][j])) visited[i][j] = False return max_length"},{"question":"def rotate_string(s: str, n: int) -> str: Rotates the string \`s\` to the right \`n\` times. If \`n\` is negative, rotates to the left \`abs(n)\` times. >>> rotate_string(\\"hello\\", 2) \\"lohel\\" >>> rotate_string(\\"abcdef\\", -3) \\"defabc\\" pass from solution import rotate_string def test_rotate_right(): assert rotate_string(\\"hello\\", 2) == \\"lohel\\" assert rotate_string(\\"abcdef\\", 3) == \\"defabc\\" def test_rotate_left(): assert rotate_string(\\"hello\\", -2) == \\"llohe\\" assert rotate_string(\\"abcdef\\", -3) == \\"defabc\\" def test_rotate_full(): assert rotate_string(\\"hello\\", 5) == \\"hello\\" assert rotate_string(\\"abcdef\\", 6) == \\"abcdef\\" def test_rotate_more_than_length(): assert rotate_string(\\"hello\\", 7) == \\"lohel\\" assert rotate_string(\\"abcdef\\", 10) == \\"cdefab\\" def test_rotate_negative_more_than_length(): assert rotate_string(\\"hello\\", -7) == \\"llohe\\" assert rotate_string(\\"abcdef\\", -10) == \\"efabcd\\"","solution":"def rotate_string(s, n): Rotates the string s to the right n times. If n is negative, rotates to the left abs(n) times. if not s: return \\"\\" n = n % len(s) # handle n larger than the string length return s[-n:] + s[:-n]"},{"question":"from collections import deque from typing import List def shortest_path(n: int, m: int, grid: List[List[int]]) -> int: Determine if there is a shortest path from the top-left to the bottom-right. >>> shortest_path(5, 5, [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 0, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 8 >>> shortest_path(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) -1 pass import pytest def test_shortest_path_exists(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0] ] assert shortest_path(5, 5, grid) == 8 def test_no_path(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert shortest_path(3, 3, grid) == -1 def test_minimum_grid_no_path(): grid = [[1]] assert shortest_path(1, 1, grid) == -1 def test_minimum_grid_with_path(): grid = [[0]] assert shortest_path(1, 1, grid) == 0 def test_larger_grid_no_path(): grid = [ [0, 1, 0, 0], [1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0] ] assert shortest_path(4, 4, grid) == -1 def test_single_row_path(): grid = [ [0, 0, 0, 0, 0] ] assert shortest_path(1, 5, grid) == 4 def test_single_column_path(): grid = [ [0], [0], [0], [0], [0] ] assert shortest_path(5, 1, grid) == 4","solution":"from collections import deque def shortest_path(n, m, grid): if not grid or grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, column, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def find_pair_with_sum(arr, target_sum): Finds a pair of indices (i, j) in \`arr\` such that the elements at these indices add up to \`target_sum\`. If no such pair exists, returns None. Parameters: arr (list): A list of integers. target_sum (int): The target sum for which a pair needs to be found. Returns: tuple: A tuple with a pair of indices (i, j) or None if no pair exists. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([3, 3, 4, 5], 6) (0, 1) >>> find_pair_with_sum([1000000, 2999, 7000, 5000, 4000000], 1007000) (0, 2) >>> find_pair_with_sum([1], 1) None >>> find_pair_with_sum([0, 0, 0, 0], 0) (0, 1)","solution":"def find_pair_with_sum(arr, target_sum): Finds a pair of indices (i, j) in \`arr\` such that the elements at these indices add up to \`target_sum\`. If no such pair exists, returns None. Parameters: arr (list): A list of integers. target_sum (int): The target sum for which a pair needs to be found. Returns: tuple: A tuple with a pair of indices (i, j) or None if no pair exists. seen = {} for i, num in enumerate(arr): complement = target_sum - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"def diamond(n): Generates a diamond-shaped pattern of asterisks (*) for a given positive odd integer n. If n is not a positive odd integer, returns an empty string. >>> diamond(5) ' *n ***n*****n ***n *' >>> diamond(7) ' *n ***n *****n*******n *****n ***n *' >>> diamond(9) ' *n ***n *****n *******n*********n *******n *****n ***n *' >>> diamond(0) '' >>> diamond(2) '' >>> diamond(13) ' *n ***n *****n *******n *********n ***********n*************n ***********n *********n *******n *****n ***n *'","solution":"def diamond(n): Generates a diamond-shaped pattern of asterisks (*) for a given positive odd integer n. If n is not a positive odd integer, returns an empty string. if not isinstance(n, int) or n < 1 or n % 2 == 0: return \\"\\" lines = [] for i in range(n): stars = '*' * (2 * i + 1) if i <= n // 2 else '*' * (2 * (n - i) - 1) spaces = ' ' * ((n - len(stars)) // 2) lines.append(spaces + stars) return 'n'.join(lines)"},{"question":"def modified_sum(test_cases): Returns the modified sum for each test case where the sum is the total of array elements greater than the given threshold Y. :param test_cases: List of tuples, each containing N, Y and the array A :return: List of modified sums for each test case pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) Y = int(data[index + 1]) A = list(map(int, data[index + 2: index + 2 + N])) test_cases.append((N, Y, A)) index += 2 + N result = modified_sum(test_cases) for r in result: print(r)","solution":"def modified_sum(test_cases): Returns the modified sum for each test case where the sum is the total of array elements greater than the given threshold Y. :param test_cases: List of tuples, each containing N, Y and the array A :return: List of modified sums for each test case results = [] for N, Y, A in test_cases: result = sum(x for x in A if x > Y) results.append(result) return results"},{"question":"def validate_username(username: str) -> str: Validates if the given username meets the required criteria: - Between 6 and 20 characters long - Contains only letters, digits, and underscores - Starts with a letter >>> validate_username(\\"John_Doe123\\") 'Valid' >>> validate_username(\\"123John\\") 'Invalid' >>> validate_username(\\"john\\") 'Invalid' >>> validate_username(\\"JohnDoe_\\") 'Valid' >>> validate_username(\\"_thisUsername1IsWayTooLongToBeValid\\") 'Invalid' >>> validate_username(\\"JohnDoe!\\") 'Invalid' >>> validate_username(\\"John@Doe\\") 'Invalid' >>> validate_username(\\"J12345\\") 'Valid' >>> validate_username(\\"J1234567890123456789\\") 'Valid' >>> validate_username(\\"A1234\\") 'Invalid' >>> validate_username(\\"A12345678901234567890\\") 'Invalid'","solution":"import re def validate_username(username): Validates if the given username meets the required criteria: - Between 6 and 20 characters long - Contains only letters, digits, and underscores - Starts with a letter if re.match(\\"^[A-Za-z][A-Za-z0-9_]{5,19}\\", username): return \\"Valid\\" else: return \\"Invalid\\""},{"question":"MOD = 10**9 + 7 def max_beauty_value_sum(test_cases: List[List[int]]) -> List[int]: Determine the maximum possible sum of beauty values for any non-empty subsequence of the flowers. Args: test_cases: A list where each element is a list of integers representing the beauty values of the flowers in each test case. Returns: A list of integers where each integer represents the maximum beauty value sum for the corresponding test case. >>> max_beauty_value_sum([[1, 2, 3], [4, 5, 6]]) == [6, 15] >>> max_beauty_value_sum([[1000]]) == [1000] >>> max_beauty_value_sum([[1000] * 2000]) == [(1000 * 2000) % (10**9 + 7)] >>> max_beauty_value_sum([]) == [] >>> max_beauty_value_sum([[10**9, 10**9, 10**9]]) == [(3 * 10**9) % (10**9 + 7)] >>> max_beauty_value_sum([[1, 2, 3, 4, 5], [10, 20, 30], [7, 8]]) == [15, 60, 15]","solution":"MOD = 10**9 + 7 def max_beauty_value_sum(test_cases): results = [] for flowers in test_cases: results.append(sum(flowers) % MOD) return results"},{"question":"def process_queries(T, test_cases): You are given an array A of integers and you have to perform specific operations to transform it. Given Q queries, for each query, depending on the type, you should either update an element in the array or find the minimum element in a specified range of the array after updates. >>> T = 1 >>> test_cases = [(5, [1, 3, 5, 7, 9], 5, [\\"MIN 1 3\\", \\"UPDATE 2 6\\", \\"MIN 1 3\\", \\"UPDATE 3 4\\", \\"MIN 1 5\\"])] >>> process_queries(T, test_cases) [1, 1, 1] >>> T = 1 >>> test_cases = [(3, [10, 20, 30], 3, [\\"MIN 1 3\\", \\"UPDATE 2 5\\", \\"MIN 1 3\\"])] >>> process_queries(T, test_cases) [10, 5] >>> T = 2 >>> test_cases = [(4, [1, 2, 3, 4], 2, [\\"MIN 1 4\\", \\"UPDATE 4 0\\"]), (6, [7, 2, 3, 4, 5, 6], 3, [\\"UPDATE 1 9\\", \\"MIN 1 3\\", \\"UPDATE 2 8\\"])] >>> process_queries(T, test_cases) [1, 2]","solution":"def process_queries(T, test_cases): results = [] for i in range(T): N, A, Q, queries = test_cases[i] for query in queries: query_parts = query.split() if query_parts[0] == \\"UPDATE\\": index = int(query_parts[1]) - 1 value = int(query_parts[2]) A[index] = value elif query_parts[0] == \\"MIN\\": start = int(query_parts[1]) - 1 end = int(query_parts[2]) - 1 results.append(min(A[start:end+1])) return results"},{"question":"def check_temperature_safety(n, m, temperatures, L, H): Check if all temperature readings are within the permissible range [L, H]. Parameters: n (int): Number of logged temperature readings. m (int): Permissible range (not used in the logic). temperatures (list): List of temperature readings. L (int): Lower bound of permissible temperature range. H (int): Upper bound of permissible temperature range. Returns: str: \\"Safe\\" if all temperatures are within range [L, H], otherwise \\"Unsafe\\". # Your code here import pytest def test_all_temperatures_within_range(): assert check_temperature_safety(5, 10, [1, 2, 3, 4, 5], -5, 5) == \\"Safe\\" assert check_temperature_safety(3, 15, [-10, 0, 10], -10, 10) == \\"Safe\\" def test_some_temperatures_out_of_range(): assert check_temperature_safety(4, 20, [-15, 5, 25, -10], -10, 15) == \\"Unsafe\\" assert check_temperature_safety(6, 30, [10, 20, 30, 40, 50, 60], 15, 55) == \\"Unsafe\\" def test_all_temperatures_out_of_range(): assert check_temperature_safety(3, 20, [30, 40, 50], -10, 10) == \\"Unsafe\\" assert check_temperature_safety(2, 25, [-20, -30], 0, 10) == \\"Unsafe\\" def test_edge_case_boundaries(): assert check_temperature_safety(4, 15, [-10, 0, 15, 20], -10, 20) == \\"Safe\\" assert check_temperature_safety(3, 20, [20, -10, 15], -10, 20) == \\"Safe\\"","solution":"def check_temperature_safety(n, m, temperatures, L, H): Checks if all temperature readings are within the permissible range [L, H]. Parameters: n (int): Number of logged temperature readings. m (int): Permissible range (not used in the logic). temperatures (list): List of temperature readings. L (int): Lower bound of permissible temperature range. H (int): Upper bound of permissible temperature range. Returns: str: \\"Safe\\" if all temperatures are within range [L, H], otherwise \\"Unsafe\\". for temp in temperatures: if temp < L or temp > H: return \\"Unsafe\\" return \\"Safe\\""},{"question":"def two_sum(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] equals target. Returns a list containing the indices [i, j] if such a pair exists, otherwise returns an empty list. # Write your code here def solve_two_sum_problem(T, test_cases): Solves the problem for T test cases. For each test case, determines whether there exists two distinct indices in the list such that their values add up to the target value. Returns a list of strings, each string representing the result for a single test case. # Write your code here","solution":"def two_sum(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] equals target. Returns a list containing the indices [i, j] if such a pair exists, otherwise returns an empty list. checked = {} for i, num in enumerate(nums): complement = target - num if complement in checked: return [checked[complement], i] checked[num] = i return [] def solve_two_sum_problem(T, test_cases): results = [] for case in test_cases: n, target = case[0] nums = case[1] result = two_sum(nums, target) if result: results.append(f\\"{result[0]} {result[1]}\\") else: results.append(\\"-1\\") return results"},{"question":"def max_happiness(strings): Returns the maximum happiness of any non-empty substring for each string in the list. :param strings: List of strings :return: List of integers representing maximum happiness pass from solution import max_happiness def test_max_happiness_single_string(): assert max_happiness([\\"abc\\"]) == [99] assert max_happiness([\\"bba\\"]) == [98] assert max_happiness([\\"zebra\\"]) == [122] def test_max_happiness_multiple_strings(): assert max_happiness([\\"abc\\", \\"bba\\", \\"zebra\\"]) == [99, 98, 122] def test_max_happiness_edge_cases(): assert max_happiness([\\"a\\"]) == [97] # Single character string assert max_happiness([\\"abcdefghijklmnopqrstuvwxyz\\"]) == [122] # All lowercase alphabet def test_max_happiness_mixed_length_strings(): assert max_happiness([\\"abcdefgh\\", \\"zyx\\", \\"mnopqrstu\\"]) == [104, 122, 117] def test_max_happiness_large_input(): large_string = 'a' * 10**5 assert max_happiness([large_string]) == [97] mixed_large_string = 'a' * 99999 + 'z' assert max_happiness([mixed_large_string]) == [122]","solution":"def max_happiness(strings): Returns the maximum happiness of any non-empty substring for each string in the list. :param strings: List of strings :return: List of integers representing maximum happiness results = [] for s in strings: max_happy = max(ord(char) for char in s) results.append(max_happy) return results"},{"question":"def min_weight_difference(N, weights): Returns the minimum possible difference between the total weight of marbles in two bags. :param N: Number of marbles :param weights: List of weights of the marbles :return: Minimum difference in weight between two bags Examples: >>> min_weight_difference(4, [2, 3, 5, 7]) 1 >>> min_weight_difference(5, [1, 2, 3, 4, 5]) 1","solution":"def min_weight_difference(N, weights): Returns the minimum possible difference between the total weight of marbles in two bags. total_weight = sum(weights) dp = [0] * (total_weight // 2 + 1) for weight in weights: for j in range(total_weight // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return total_weight - 2 * dp[total_weight // 2] # Example Usage # N = 4 # weights = [2, 3, 5, 7] # print(min_weight_difference(N, weights)) # Output: 1 # N = 5 # weights = [1, 2, 3, 4, 5] # print(min_weight_difference(N, weights)) # Output: 1"},{"question":"def count_distinct_letters_in_ranges(s: str, ranges: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct letters in the given ranges of the string s. :param s: A string of uppercase English letters. :param ranges: A list of tuples, each containing two integers representing the start and end of a range. :return: A list of integers representing the number of distinct letters in each range. >>> count_distinct_letters_in_ranges(\\"ABCABCABC\\", [(1, 3), (1, 6), (4, 9)]) [3, 3, 3] >>> count_distinct_letters_in_ranges(\\"ABRACADABRA\\", [(1, 11), (3, 7)]) [5, 4]","solution":"def count_distinct_letters_in_ranges(s, ranges): Returns the number of distinct letters in the given ranges of the string s. :param s: A string of uppercase English letters. :param ranges: A list of tuples, each containing two integers representing the start and end of a range. :return: A list of integers representing the number of distinct letters in each range. results = [] for l, r in ranges: # Subtract 1 from l and r to convert to 0-based index distinct_letters = set(s[l-1:r]) results.append(len(distinct_letters)) return results"},{"question":"def compare(a, b): Custom comparison function to sort the numbers in the desired order. if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 def largest_number(numbers): Arrange numbers to form the largest possible value when concatenated. >>> largest_number([10, 2, 9]) '9210' >>> largest_number([3, 30, 34, 5]) '534330' >>> largest_number([12, 121]) '12121' numbers = list(map(str, numbers)) numbers.sort(key=cmp_to_key(compare)) largest_num = ''.join(numbers) return largest_num if largest_num[0] != '0' else '0' def process_test_cases(T, test_cases): Process multiple test cases to find the largest numbers possible by concatenating given integers. >>> process_test_cases(3, [(3, [10, 2, 9]), (4, [3, 30, 34, 5]), (2, [12, 121])]) ['9210', '534330', '12121'] results = [] for i in range(T): N = test_cases[i][0] numbers = test_cases[i][1] result = largest_number(numbers) results.append(result) return results","solution":"from functools import cmp_to_key def compare(a, b): if a + b > b + a: return -1 elif a + b < b + a: return 1 else: return 0 def largest_number(numbers): numbers = list(map(str, numbers)) numbers.sort(key=cmp_to_key(compare)) largest_num = ''.join(numbers) return largest_num if largest_num[0] != '0' else '0' def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] numbers = test_cases[i][1] result = largest_number(numbers) results.append(result) return results"},{"question":"def findNthElement(n: int) -> int: Write a function that takes a positive integer \`n\` and returns the n-th number in the sequence defined as follows: - The first element is \`1\`. - For every \`n ≥ 2\`, the n-th element is the sum of the digits of the (n-1)-th element. Parameters: n (int): The position in the sequence. Returns: int: The n-th element in the sequence. Examples: >>> findNthElement(5) 1 >>> findNthElement(10) 1 >>> findNthElement(12) 1 >>> findNthElement(2) 1","solution":"def findNthElement(n): Returns the n-th number in the sequence defined as follows: - The first element is \`1\`. - For every \`n ≥ 2\`, the n-th element is the sum of the digits of the (n-1)-th element. Parameters: n (int): The position in the sequence. Returns: int: The n-th element in the sequence. return 1"},{"question":"def unique_elements(arr): Given an array/list of integers, find the unique element(s) in the array and return them in ascending order. An element is unique if it is present only once in the array. The array/list size is at least 4. The array/list's numbers will be a mixture of positive and negative integers. If no unique elements are found, return an empty array/list. >>> unique_elements([1, 2, 3, 2, 1, 4]) [3, 4] >>> unique_elements([0, -1, -1, 0, 2, 3, 4, 4]) [2, 3] >>> unique_elements([5, 5, 5, 5]) [] >>> unique_elements([10, 20, 20, 30, -10, 30, -10, 40]) [10, 40]","solution":"def unique_elements(arr): Returns a sorted list of elements that appear only once in the given array. element_count = {} for elem in arr: if elem in element_count: element_count[elem] += 1 else: element_count[elem] = 1 unique_elems = [elem for elem in element_count if element_count[elem] == 1] unique_elems.sort() return unique_elems"},{"question":"def transform_points(t, test_cases): Transform points on a 2D plane such that all the points have distinct integer x and y coordinates. Args: t : int : Number of test cases test_cases : List[Tuple[int, List[Tuple[int, int]]]] : List containing number of points and their coordinates for each test case Returns: List[List[Tuple[int, int]]] : List of transformed points for each test case >>> transform_points(1, [(3, [(1, 1), (2, 3), (3, 2)])]) [[(1, 1), (3, 2), (5, 0)]] >>> transform_points(2, [(3, [(1, 1), (2, 3), (3, 2)]), (2, [(1, 1), (1000, 1000)])]) [[(1, 1), (3, 2), (5, 0)], [(1, 1), (1001, 999)]] >>> transform_points(1, [(1, [(1, 1)])]) [[(1, 1)]] >>> transform_points(1, [(3, [(999, 999), (1000, 1000), (998, 998)])]) [[(999, 999), (1001, 999), (1000, 996)]]","solution":"def transform_points(t, test_cases): results = [] for case in test_cases: n, points = case transformed_points = [] for i, (x, y) in enumerate(points): d = i # increment d for each point to ensure distinctness x_prime = x + d y_prime = y - d transformed_points.append((x_prime, y_prime)) results.append(transformed_points) return results"},{"question":"def findPairs(nums, target): Find all unique pairs of elements from the array whose sum is equal to the target. Return the pairs in lexicographical order. :param nums: List of integers :param target: Integer target sum :return: List of tuples containing all unique pairs that sum up to the target >>> findPairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> findPairs([3, 1, 2, 3, 1, 2], 4) [(1, 3), (2, 2)]","solution":"def findPairs(nums, target): Find all unique pairs of elements from the array whose sum is equal to the target. Return the pairs in lexicographical order. :param nums: List of integers :param target: Integer target sum :return: List of tuples containing all unique pairs that sum up to the target nums.sort() # Sort the nums to ensure lexicographical order pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(list(pairs))"},{"question":"from typing import List, Tuple def can_divide_teams(test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[str]: Determine if it's possible to divide the students into two equal-sized teams with given conditions for stamina and speed differences. Parameters: test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases where each test case is represented by a tuple containing the number of students in each team, the minimum stamina difference, and the respective lists of stamina and speed of students. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each test case depending on whether it is possible to divide students as required. >>> can_divide_teams([(2, 4, [5, 9, 1, 6], [2, 8, 3, 10]), (3, 7, [8, 15, 12, 6, 9, 18], [5, 14, 7, 20, 10, 13])]) ['YES', 'NO'] pass def parse_input(input_data: str) -> List[Tuple[int, int, List[int], List[int]]]: Parse the input string to extract the list of test cases. Parameters: input_data (str): The input string containing all test cases Returns: List[Tuple[int, int, List[int], List[int]]]: List of test cases extracted from the input string pass def format_output(results: List[str]) -> str: Format the output list of strings into a single output string. Parameters: results (List[str]): List of results for each test case Returns: str: Formatted string for the results of all test cases pass","solution":"def can_divide_teams(test_cases): results = [] for case in test_cases: n, s, stamina, speed = case stamina.sort() speed.sort() valid = True for i in range(n): if not (stamina[i + n] - stamina[i] >= s and speed[i + n] - speed[i] >= s): valid = False break results.append(\\"YES\\" if valid else \\"NO\\") return results def parse_input(input_data): lines = input_data.split('n') t = int(lines[0]) cases = [] index = 1 for _ in range(t): n, s = map(int, lines[index].split()) stamina = list(map(int, lines[index + 1].split())) speed = list(map(int, lines[index + 2].split())) cases.append((n, s, stamina, speed)) index += 3 return cases def format_output(results): return 'n'.join(results) # Example input processing input_data = 2 2 4 5 9 1 6 2 8 3 10 3 7 8 15 12 6 9 18 5 14 7 20 10 13 test_cases = parse_input(input_data) results = can_divide_teams(test_cases) formatted_output = format_output(results) print(formatted_output)"},{"question":"def final_position(cmd: str) -> (int, int): Returns the final position of the robot after executing all commands. Parameters: cmd (str): A string consisting of characters 'U', 'D', 'L', 'R' indicating movements. Returns: tuple: A tuple (x, y) representing the final position of the robot. >>> final_position(\\"UDLR\\") (0, 0) >>> final_position(\\"UUU\\") (0, 3) >>> final_position(\\"DDD\\") (0, -3)","solution":"def final_position(cmd): Returns the final position of the robot after executing all commands. Parameters: cmd (str): A string consisting of characters 'U', 'D', 'L', 'R' indicating movements. Returns: tuple: A tuple (x, y) representing the final position of the robot. x, y = 0, 0 for move in cmd: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x, y def main(): import sys input = sys.stdin.read().strip() result = final_position(input) print(result[0], result[1]) if __name__ == \\"__main__\\": main()"},{"question":"def longestZigzag(sequence: List[int]) -> int: Returns the length of the longest Zigzag Sequence that can be formed from the elements of the array. A Zigzag Sequence is defined as a sequence where the differences between consecutive elements strictly alternate between positive and negative. >>> longestZigzag([1, 7, 4, 9, 2, 5]) 6 >>> longestZigzag([1, 2, 3, 4, 5, 6, 7, 8, 9]) 2 >>> longestZigzag([70, 55, 13, 2, 99, 2, 80, 80, 80, 80, 80, 80, 80, 80, 80]) 5 >>> longestZigzag([]) 0 >>> longestZigzag([5]) 1","solution":"def longestZigzag(sequence): if not sequence: return 0 if len(sequence) == 1: return 1 up = [1] * len(sequence) down = [1] * len(sequence) for i in range(1, len(sequence)): for j in range(i): if sequence[i] > sequence[j]: up[i] = max(up[i], down[j] + 1) elif sequence[i] < sequence[j]: down[i] = max(down[i], up[j] + 1) return max(up[-1], down[-1])"},{"question":"def min_number_of_moves(n: int, m: int, grid: List[str]) -> int: Finds the minimum number of moves required to destroy all asteroids in the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The grid representation with '.' as empty cell and '*' as asteroid. Returns: int: The minimum number of moves required to destroy all asteroids. Examples: >>> min_number_of_moves(4, 5, ['.*...', '....*', '.*...', '.....']) 2 >>> min_number_of_moves(3, 3, ['*..', '..*', '..*']) 2 from solution import min_number_of_moves def test_example_1(): n, m = 4, 5 grid = [ \\".*...\\", \\"....*\\", \\".*...\\", \\".....\\" ] assert min_number_of_moves(n, m, grid) == 2 def test_example_2(): n, m = 3, 3 grid = [ \\"*..\\", \\"..*\\", \\"..*\\" ] assert min_number_of_moves(n, m, grid) == 2 def test_no_asteroids(): n, m = 2, 2 grid = [ \\"..\\", \\"..\\" ] assert min_number_of_moves(n, m, grid) == 0 def test_all_asteroids(): n, m = 3, 3 grid = [ \\"***\\", \\"***\\", \\"***\\" ] assert min_number_of_moves(n, m, grid) == 3 def test_one_asteroid(): n, m = 3, 3 grid = [ \\"...\\", \\".*.\\", \\"...\\" ] assert min_number_of_moves(n, m, grid) == 1","solution":"def min_number_of_moves(n, m, grid): rows_with_asteroids = set() cols_with_asteroids = set() for i in range(n): for j in range(m): if grid[i][j] == '*': rows_with_asteroids.add(i) cols_with_asteroids.add(j) return min(len(rows_with_asteroids), len(cols_with_asteroids))"},{"question":"def fruit_vendor(operations): Handles the series of operations for the automated fruit vendor machine. The function takes a list of operations represented as strings and maintains records of available fruits and their quantities, allowing customers to purchase fruits if they are available in the required quantity. Operations: - Restock a fruit: \\"restock fruit_name quantity\\" - Sell a fruit: \\"sell fruit_name quantity\\" A successful sale operation should print \\"Sold\\" followed by the fruit_name. If the fruit to be sold is not available in the required quantity, it should print \\"Insufficient quantity\\" followed by the fruit_name. Args: operations (List[str]): A list of operations to be performed in sequence. Returns: str: The result of each sale operation on a new line. Example: >>> operations = [ ... \\"restock apple 50\\", ... \\"restock orange 30\\", ... \\"sell apple 25\\", ... \\"sell orange 40\\", ... \\"restock banana 100\\", ... \\"sell banana 35\\", ... \\"restock orange 50\\", ... \\"sell orange 70\\" ... ] >>> print(fruit_vendor(operations)) Sold apple Insufficient quantity orange Sold banana Sold orange def test_fruit_vendor(): operations = [ \\"restock apple 50\\", \\"restock orange 30\\", \\"sell apple 25\\", \\"sell orange 40\\", \\"restock banana 100\\", \\"sell banana 35\\", \\"restock orange 50\\", \\"sell orange 70\\" ] result = fruit_vendor(operations) expected = \\"Sold applenInsufficient quantity orangenSold banananSold orange\\" assert result == expected def test_fruit_vendor_with_insufficient_sell(): operations = [ \\"restock apple 10\\", \\"sell apple 15\\" ] result = fruit_vendor(operations) expected = \\"Insufficient quantity apple\\" assert result == expected def test_fruit_vendor_multiple_operations(): operations = [ \\"restock apple 10\\", \\"restock apple 20\\", \\"sell apple 15\\", \\"restock apple 5\\", \\"sell apple 20\\" ] result = fruit_vendor(operations) expected = \\"Sold applenSold apple\\" assert result == expected def test_fruit_vendor_empty_operations(): operations = [] result = fruit_vendor(operations) expected = \\"\\" assert result == expected def test_fruit_vendor_sell_without_restock(): operations = [ \\"sell apple 5\\", \\"restock apple 10\\", \\"sell apple 5\\", \\"sell apple 5\\" ] result = fruit_vendor(operations) expected = \\"Insufficient quantity applenSold applenSold apple\\" assert result == expected","solution":"def fruit_vendor(operations): inventory = {} results = [] for operation in operations: parts = operation.split() action, fruit_name, quantity = parts[0], parts[1], int(parts[2]) if action == \\"restock\\": if fruit_name in inventory: inventory[fruit_name] += quantity else: inventory[fruit_name] = quantity elif action == \\"sell\\": if fruit_name in inventory and inventory[fruit_name] >= quantity: inventory[fruit_name] -= quantity results.append(f\\"Sold {fruit_name}\\") else: results.append(f\\"Insufficient quantity {fruit_name}\\") return \\"n\\".join(results)"},{"question":"def analyze_rainfall_patterns(T, test_cases): Analyzes the rainfall patterns for T test cases and returns the result for each case. >>> analyze_rainfall_patterns(1, [(10, [1, 2, 3, 4, 5, 4, 3, 2, 1, 0])]) == [10] >>> analyze_rainfall_patterns(1, [(5, [5, 5, 5, 5, 5])]) == [0] >>> analyze_rainfall_patterns(1, [(6, [1, 2, 3, 4, 5, 6])]) == [0] >>> analyze_rainfall_patterns(1, [(6, [6, 5, 4, 3, 2, 1])]) == [0] >>> analyze_rainfall_patterns(2, [(5, [1, 3, 2, 4, 5]), (6, [9, 8, 7, 6, 5, 4])]) == [3, 0] >>> analyze_rainfall_patterns(1, [(15, [1, 3, 5, 4, 6, 2, 7, 9, 8, 10, 6, 4, 11, 13, 12])]) == [4] >>> analyze_rainfall_patterns(1, [(0, [])]) == [0] >>> analyze_rainfall_patterns(1, [(2, [1, 2])]) == [0] >>> analyze_rainfall_patterns(1, [(2, [2, 1])]) == [0]","solution":"def longest_increase_decrease_period(arr): Returns the length of the longest period of strictly increasing followed by strictly decreasing rainfall. if not arr: return 0 n = len(arr) inc = [0] * n dec = [0] * n # Fill increasing sequence lengths inc[0] = 1 for i in range(1, n): if arr[i] > arr[i-1]: inc[i] = inc[i-1] + 1 else: inc[i] = 1 # Fill decreasing sequence lengths dec[n-1] = 1 for i in range(n-2, -1, -1): if arr[i] > arr[i+1]: dec[i] = dec[i+1] + 1 else: dec[i] = 1 # Find the maximum length of increase->decrease period max_len = 0 for i in range(n): if inc[i] > 1 and dec[i] > 1: max_len = max(max_len, inc[i] + dec[i] - 1) return max_len def analyze_rainfall_patterns(T, test_cases): Analyzes the rainfall patterns for T test cases and returns the result for each case. results = [] for i in range(T): N, rainfall = test_cases[i] results.append(longest_increase_decrease_period(rainfall)) return results"},{"question":"import requests from bs4 import BeautifulSoup def extract_book_info(url: str) -> dict: Extracts the book information from the given URL. Args: url (str): URL of the book's web page. Returns: dict: A dictionary containing the title, author, and price of the book. Example: >>> url = \\"http://bookstore.com/book/1234\\" >>> extract_book_info(url) {'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald', 'price': '10.99'} >>> url = \\"http://bookstore.com/book/5678\\" >>> extract_book_info(url) {'title': 'To Kill a Mockingbird', 'author': 'Harper Lee', 'price': '8.99'}","solution":"import requests from bs4 import BeautifulSoup def extract_book_info(url): Extracts the book information from the given URL. Args: url (str): URL of the book's web page. Returns: dict: A dictionary containing the title, author, and price of the book. response = requests.get(url) if response.status_code != 200: return {'title': None, 'author': None, 'price': None} soup = BeautifulSoup(response.content, 'html.parser') title = soup.find('h1', {'class': 'book-title'}) author = soup.find('span', {'class': 'book-author'}) price = soup.find('span', {'class': 'book-price'}) return { 'title': title.get_text(strip=True) if title else None, 'author': author.get_text(strip=True) if author else None, 'price': price.get_text(strip=True) if price else None }"},{"question":"import re def isPalindrome(str: str) -> bool: Returns true if the input string is a palindrome, false otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Args: - str (str): the string to be checked Returns: - bool: true if the string is a palindrome, false otherwise Examples: >>> isPalindrome(\\"racecar\\") True >>> isPalindrome(\\"hello\\") False >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"12321\\") True >>> isPalindrome(\\"This is not a palindrome\\") False","solution":"import re def isPalindrome(str): Returns true if the input string is a palindrome, false otherwise. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). # Removing non-alphanumeric characters and converting to lowercase cleaned_str = re.sub(r'[^A-Za-z0-9]', '', str).lower() # Checking if the cleaned string is the same forwards and backwards return cleaned_str == cleaned_str[::-1]"},{"question":"def max_books_in_series(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of books George can read in any series where the total number of pages is the same. Args: T : int : The number of test cases. test_cases : List[Tuple[int, List[int]]] : A list of tuples where each tuple contains an integer N (number of books) and a list of N integers representing the number of pages in each book. Returns: List[int] : A list of integers where each integer represents the maximum number of books George can read in a series for each test case. Examples: >>> max_books_in_series(2, [(3, [100, 200, 300]), (4, [50, 50, 50, 50])]) [0, 4] >>> max_books_in_series(1, [(5, [10, 10, 10, 10, 10])]) [5]","solution":"from collections import defaultdict def max_books_in_series(T, test_cases): results = [] for i in range(T): N, pages = test_cases[i] page_count = defaultdict(int) for page in pages: page_count[page] += 1 max_series = 0 for count in page_count.values(): if count > 1: max_series = max(max_series, count) results.append(max_series) return results"},{"question":"def can_make_equal_by_reversing_substring(s: str, t: str) -> str: Determine if it is possible to make the string s equal to string t by reversing exactly one continuous substring of s. Args: s (str): The original string. t (str): The target string after reversing one substring. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". >>> can_make_equal_by_reversing_substring(\\"abcdef\\", \\"abcfed\\") 'YES' >>> can_make_equal_by_reversing_substring(\\"abcdef\\", \\"abcfgh\\") 'NO'","solution":"def can_make_equal_by_reversing_substring(s, t): if s == t: return \\"YES\\" n = len(s) diff_indices = [i for i in range(n) if s[i] != t[i]] if not diff_indices or len(diff_indices) == 1: return \\"NO\\" start, end = diff_indices[0], diff_indices[-1] if s[start:end + 1][::-1] == t[start:end + 1]: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: You are given a matrix filled with non-negative integers, where each cell represents the cost of passing through that cell. You are currently positioned at the top-left corner of the matrix and your goal is to reach the bottom-right corner. You can only move either down or right at any point in time. Find the minimum cost path to reach the bottom-right corner of the matrix. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) == 12 >>> minPathSum([]) == 0 >>> minPathSum([[]]) == 0","solution":"def minPathSum(grid): Returns the minimum cost to reach the bottom-right corner from the top-left corner of the grid. :param grid: List[List[int]] - The grid representing the costs. :return: int - The minimum cost path. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row for col in range(1, cols): grid[0][col] += grid[0][col - 1] # Initialize the first column for row in range(1, rows): grid[row][0] += grid[row - 1][0] # Fill up the rest of the grid for row in range(1, rows): for col in range(1, cols): grid[row][col] += min(grid[row - 1][col], grid[row][col - 1]) return grid[rows - 1][cols - 1]"},{"question":"def most_popular_class(registrations): Returns the identifier of the most popular class package. If multiple class packages have the same number of registrations, returns the one that appears first in the list. If the list is empty, returns None. >>> most_popular_class(['A1', 'B2', 'C3', 'A1', 'B2', 'A1', 'C3', 'A1', 'B2']) 'A1' >>> most_popular_class(['B2', 'B2', 'A1', 'A1']) 'B2' >>> most_popular_class(['A1', 'B2', 'A1', 'B2']) 'A1' >>> most_popular_class([]) None >>> most_popular_class(['A1']) 'A1' >>> most_popular_class(['a1', 'A1', 'a1', 'A1', 'A1']) 'A1'","solution":"def most_popular_class(registrations): Returns the identifier of the most popular class package. If multiple class packages have the same number of registrations, returns the one that appears first in the list. If the list is empty, returns None. if not registrations: return None from collections import Counter counts = Counter(registrations) max_count = max(counts.values()) for identifier in registrations: if counts[identifier] == max_count: return identifier"},{"question":"def maxProductSubset(arr, n): Given an integer array of size n, find the maximum product of any subset of its elements excluding the empty subset. :param arr: List[int] - An array of integers :param n: int - Size of the array :return: int - The maximum product of any subset of the array elements >>> maxProductSubset([1, 2, 3], 3) 6 >>> maxProductSubset([-1, -1, -2, 4, 3], 5) 24 >>> maxProductSubset([-1, 0], 2) 0 def test_max_product_all_positive(): assert maxProductSubset([1, 2, 3], 3) == 6 def test_max_product_with_neg_and_pos(): assert maxProductSubset([-1, -1, -2, 4, 3], 5) == 24 def test_max_product_with_zero(): assert maxProductSubset([-1, 0], 2) == 0 def test_max_product_single_element(): assert maxProductSubset([5], 1) == 5 assert maxProductSubset([-5], 1) == -5 def test_max_product_all_negative(): assert maxProductSubset([-1, -2, -3, -4], 4) == 24 def test_max_product_with_zero_in_mix(): assert maxProductSubset([-1, 0, -3, 4], 4) == 12","solution":"def maxProductSubset(arr, n): if n == 1: return arr[0] max_neg = float('-inf') count_neg = count_zero = 0 product = 1 for i in range(n): if arr[i] == 0: count_zero += 1 continue if arr[i] < 0: count_neg += 1 max_neg = max(max_neg, arr[i]) product *= arr[i] if count_zero == n: return 0 if count_neg % 2 != 0: if count_neg == 1 and count_zero > 0 and count_zero + count_neg == n: return 0 product //= max_neg return product"},{"question":"def remove_vowels(input_string: str) -> str: Write a function that takes a string as input and returns the string with all of its vowels removed. For the purposes of this question, \\"vowels\\" are A, E, I, O, U and a, e, i, o, u. The function should return the string unchanged if there are no vowels present. If the input is an empty string or None, the function should return an empty string. Examples: >>> remove_vowels(\\"This is a test!\\") == \\"Ths s tst!\\" >>> remove_vowels(\\"Hello World!\\") == \\"Hll Wrld!\\" >>> remove_vowels(\\"Why?\\") == \\"Why?\\"","solution":"def remove_vowels(input_string): Removes all vowels (a, e, i, o, u, A, E, I, O, U) from the input string. Returns an empty string if the input is None or an empty string. if input_string is None: return \\"\\" vowels = \\"aeiouAEIOU\\" return ''.join([char for char in input_string if char not in vowels])"},{"question":"def chemical_formula(s: str) -> dict: Compute the total number of each type of atom in a given chemical formula. Parameters: s (str): A string representing the chemical formula. Returns: dict: A dictionary where the keys are element symbols and the values are the total count of atoms of that element in the molecule. Examples: >>> chemical_formula(\\"H2O\\") {\\"H\\": 2, \\"O\\": 1} >>> chemical_formula(\\"CH3CH2OH\\") {\\"C\\": 2, \\"H\\": 6, \\"O\\": 1} >>> chemical_formula(\\"Mg(OH)2\\") {\\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2} >>> chemical_formula(\\"K4(ON(SO3)2)2\\") {\\"K\\": 4, \\"O\\": 14, \\"N\\": 2, \\"S\\": 4} # Your code here.","solution":"def chemical_formula(s: str) -> dict: import re from collections import defaultdict, deque def multiply_formula(formula, multiplier): for element in formula: formula[element] *= multiplier return formula def parse_formula(s): stack = deque() current_formula = defaultdict(int) i = 0 n = len(s) while i < n: if s[i] == '(': stack.append(current_formula) current_formula = defaultdict(int) i += 1 elif s[i] == ')': i += 1 num = 0 while i < n and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num = num if num != 0 else 1 current_formula = multiply_formula(current_formula, num) previous_formula = stack.pop() for k, v in current_formula.items(): previous_formula[k] += v current_formula = previous_formula else: element = s[i] i += 1 if i < n and s[i].islower(): element += s[i] i += 1 num = 0 while i < n and s[i].isdigit(): num = num * 10 + int(s[i]) i += 1 num = num if num != 0 else 1 current_formula[element] += num return current_formula return dict(parse_formula(s))"},{"question":"def min_steps_to_target(T: int) -> int: Returns the minimum number of steps to reach target number T starting from 1. from collections import deque def test_reach_one(): assert min_steps_to_target(1) == 0 def test_reach_two(): assert min_steps_to_target(2) == 1 def test_reach_five(): assert min_steps_to_target(5) == 3 def test_reach_ten(): assert min_steps_to_target(10) == 4 def test_reach_twenty(): assert min_steps_to_target(20) == 5 def test_reach_large_number(): assert min_steps_to_target(99999) > 0","solution":"from collections import deque def min_steps_to_target(T): Returns the minimum number of steps to reach target number T starting from 1. if T == 1: return 0 # BFS initialization queue = deque([(1, 0)]) # Starting number with step count visited = set([1]) # Set to keep track of visited numbers while queue: current, steps = queue.popleft() # Generate next numbers using the given operations next_num1 = current + 1 next_num2 = current * 2 # Check if we reached the target if next_num1 == T or next_num2 == T: return steps + 1 # Add to queue if not visited yet if next_num1 not in visited and next_num1 <= T: visited.add(next_num1) queue.append((next_num1, steps + 1)) if next_num2 not in visited and next_num2 <= T: visited.add(next_num2) queue.append((next_num2, steps + 1)) return -1 # Should never reach here as T is guaranteed to be reachable"},{"question":"def max_subarray_sum(n: int, nums: List[int]) -> int: Returns the maximum sum of the contiguous subarray within the given array. :param n: int - number of elements in the array :param nums: list of int - the elements of the array :return: int - the maximum sum of the contiguous subarray >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(1, [-1]) -1 >>> max_subarray_sum(6, [1, 2, 3, 4, -10, 10]) 10","solution":"def max_subarray_sum(n, nums): Returns the maximum sum of the contiguous subarray within the given array. :param n: int - number of elements in the array :param nums: list of int - the elements of the array :return: int - the maximum sum of the contiguous subarray max_current = max_global = nums[0] for i in range(1, n): max_current = max(nums[i], max_current + nums[i]) if max_current > max_global: max_global = max_current return max_global # Example Usage # n = 5 # nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] # print(max_subarray_sum(n, nums)) # Output: 6"},{"question":"def min_aircraft_required(datasets): Calculate the minimum number of aircraft needed to cover all the scheduled flights. >>> min_aircraft_required([[(3, 3), [(480, 600), (610, 720), (300, 360)]], [(3, 4), [(0, 200), (200, 400), (400, 600), (600, 800)]], [(0, 0), []]]) [1, 1] >>> min_aircraft_required([[(2, 3), [(300, 400), (500, 600), (400, 500)]], [(2, 3), [(300, 360), (360, 420), (420, 480)]], [(0, 0), []]]) [1, 1] >>> min_aircraft_required([[(2, 2), [(300, 400), (400, 500)]], [(2, 3), [(300, 400), (400, 500), (900, 1000)]], [(0, 0), []]]) [1, 1]","solution":"def min_aircraft_required(datasets): results = [] for dataset in datasets: N, F = dataset[0] flights = dataset[1] if N == 0 and F == 0: break # Sort flights by departure time flights.sort() # Use a min-heap to keep track of aircraft availability import heapq aircrafts = [] for dep, arr in flights: if aircrafts and aircrafts[0] <= dep: heapq.heappop(aircrafts) # remove the available aircraft heapq.heappush(aircrafts, arr) # add the aircraft with its new availability time results.append(len(aircrafts)) return results"},{"question":"def manage_employees(n: int, records: List[str]) -> List[str]: Manage employees using a hierarchical structure. Args: n (int): The number of employees. records (List[str]): A list of employee records where each record contains employee ID, supervisor ID, number of departments, and department IDs. Returns: List[str]: A list of strings with employee hierarchy and department information. Examples: >>> records = [\\"0 -1 2 HR Finance\\", \\"1 0 1 IT\\", \\"2 0 1 HR\\", \\"3 1 2 IT Marketing\\", \\"4 1 1 Finance\\"] >>> manage_employees(5, records) ['employee 0: supervisor = -1, departments = [HR, Finance], subordinates = [1, 2]', 'employee 1: supervisor = 0, departments = [IT], subordinates = [3, 4]', 'employee 2: supervisor = 0, departments = [HR], subordinates = []', 'employee 3: supervisor = 1, departments = [IT, Marketing], subordinates = []', 'employee 4: supervisor = 1, departments = [Finance], subordinates = []'] >>> records = [\\"3 -1 1 Sales\\", \\"0 3 2 Sales Marketing\\", \\"1 3 1 HR\\", \\"2 0 1 IT\\"] >>> manage_employees(4, records) ['employee 0: supervisor = 3, departments = [Sales, Marketing], subordinates = [2]', 'employee 1: supervisor = 3, departments = [HR], subordinates = []', 'employee 2: supervisor = 0, departments = [IT], subordinates = []', 'employee 3: supervisor = -1, departments = [Sales], subordinates = [0, 1]']","solution":"def manage_employees(n, records): from collections import defaultdict # Dictionary to store employee data employee_data = {} subordinates = defaultdict(list) for record in records: parts = record.split() emp_id = int(parts[0]) supervisor_id = int(parts[1]) num_departments = int(parts[2]) departments = parts[3:3+num_departments] # Storing employee information employee_data[emp_id] = { \\"supervisor\\": supervisor_id, \\"departments\\": departments, \\"subordinates\\": [] } # Adding subordinates to supervisors if supervisor_id != -1: subordinates[supervisor_id].append(emp_id) # Adding subordinates information to employee data for emp_id in subordinates: employee_data[emp_id][\\"subordinates\\"] = sorted(subordinates[emp_id]) # Prepare the result in sorted order of employee IDs result = [] for emp_id in sorted(employee_data): data = employee_data[emp_id] result.append( f'employee {emp_id}: supervisor = {data[\\"supervisor\\"]}, ' f'departments = {data[\\"departments\\"]}, ' f'subordinates = {data[\\"subordinates\\"]}' ) return result"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Implements the Sieve of Eratosthenes algorithm to find all prime numbers less than n. >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(2) == [] >>> sieve_of_eratosthenes(11) == [2, 3, 5, 7] def sum_of_primes_last_four_digits(n: int) -> str: Calculates the sum of all primes less than n and returns the last four digits of the sum. >>> sum_of_primes_last_four_digits(10) == '0017' >>> sum_of_primes_last_four_digits(20) == '0077' >>> sum_of_primes_last_four_digits(2) == '0000' >>> sum_of_primes_last_four_digits(30) == '0129' >>> sum_of_primes_last_four_digits(100) == '1060' >>> sum_of_primes_last_four_digits(1000) == '0127' >>> sum_of_primes_last_four_digits(10000) == '6396'","solution":"def sieve_of_eratosthenes(n): Implements the Sieve of Eratosthenes algorithm to find all prime numbers less than n. is_prime = [True] * n p = 2 while p * p < n: if is_prime[p]: for i in range(p * p, n, p): is_prime[i] = False p += 1 primes = [p for p in range(2, n) if is_prime[p]] return primes def sum_of_primes_last_four_digits(n): Calculates the sum of all primes less than n and returns the last four digits of the sum. primes = sieve_of_eratosthenes(n) prime_sum = sum(primes) return str(prime_sum)[-4:].zfill(4)"},{"question":"def handle_queries(n: int, q: int, values: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Handles the queries related to Alice's book collection. Args: n : int : number of books in the collection q : int : number of queries values : list of int : values of the books queries : list of tuples : list of queries Returns: list of int : list of results for type 2 queries >>> n = 5 >>> q = 5 >>> values = [1, 5, 3, 2, 4] >>> queries = [(2, 1, 5), (1, 1, 5), (2, 1, 3), (2, 4, 5), (1, 3, 4)] >>> handle_queries(n, q, values, queries) [5, 5, 2] >>> n = 3 >>> q = 3 >>> values = [3, 1, 2] >>> queries = [(2, 2, 3), (1, 1, 3), (2, 1, 2)] >>> handle_queries(n, q, values, queries) [2, 2] >>> n = 4 >>> q = 2 >>> values = [10, 20, 30, 40] >>> queries = [(2, 1, 4), (2, 2, 3)] >>> handle_queries(n, q, values, queries) [40, 30] >>> n = 2 >>> q = 1 >>> values = [5, 10] >>> queries = [(2, 1, 2)] >>> handle_queries(n, q, values, queries) [10]","solution":"def handle_queries(n, q, values, queries): Handles the queries related to Alice's book collection. Args: n : int : number of books in the collection q : int : number of queries values : list of int : values of the books queries : list of tuples : list of queries Returns: list of int : list of results for type 2 queries results = [] for query in queries: if query[0] == 1: # Swap the positions of two books _, p1, p2 = query values[p1 - 1], values[p2 - 1] = values[p2 - 1], values[p1 - 1] elif query[0] == 2: # Get the maximum value in a given range _, l, r = query results.append(max(values[l - 1:r])) return results"},{"question":"def find_missing_element(test_cases): For each test case, find the missing element from the first list. Args: test_cases (list of tuples): Each tuple has (N, list1, list2) where list1 is the shorter list (N-1 elements), and list2 is the original list (N elements). Returns: list: A list of the missing elements for each test case. >>> find_missing_element([(5, [1, 2, 3, 4], [1, 2, 3, 4, 5]), (3, [6, 7], [7, 6, 7])]) [5, 7] >>> find_missing_element([(4, [1, 2, 3], [4, 1, 3, 2]), (6, [10, 20, 30, 40, 50], [10, 20, 30, 40, 50, 60])]) [4, 60]","solution":"def find_missing_element(test_cases): For each test case, find the missing element from the first list. Args: test_cases (list of tuples): Each tuple has (N, list1, list2) where list1 is the shorter list (N-1 elements), and list2 is the original list (N elements). Returns: list: A list of the missing elements for each test case. results = [] for N, lst1, lst2 in test_cases: sum_lst1 = sum(lst1) sum_lst2 = sum(lst2) missing_element = sum_lst2 - sum_lst1 results.append(missing_element) return results"},{"question":"def remove_consecutive_duplicates(s: str) -> str: Remove the minimum number of characters from the string so that the remaining string contains no consecutive repeating characters. >>> remove_consecutive_duplicates(\\"aaabbbccc\\") \\"abc\\" >>> remove_consecutive_duplicates(\\"aabbaacc\\") \\"abac\\" >>> remove_consecutive_duplicates(\\"abcd\\") \\"abcd\\"","solution":"def remove_consecutive_duplicates(s): Remove the minimum number of characters from the string so that the remaining string contains no consecutive repeating characters. if not s: return s result = [s[0]] for char in s[1:]: if char != result[-1]: result.append(char) return ''.join(result)"},{"question":"class MovieCollection: Implement a class that handles a collection of movies. - addMovie(title: str, rating: int): Adds a movie with the given title and rating to the collection. If a movie with the same title already exists, update its rating to the new rating. - getRating(title: str) -> int: Returns the rating of the movie with the given title. If the movie does not exist, return -1. - getTopRatedMovie() -> str: Returns the title of the movie with the highest rating. If there are multiple movies with the same highest rating, return the one that was added first. If the collection is empty, return \\"No movies in collection\\". Example: movies = MovieCollection() movies.addMovie(\\"Inception\\", 9) movies.addMovie(\\"Interstellar\\", 8) print(movies.getRating(\\"Inception\\")) # Output: 9 movies.addMovie(\\"The Dark Knight\\", 10) print(movies.getTopRatedMovie()) # Output: \\"The Dark Knight\\" movies.addMovie(\\"Interstellar\\", 11) print(movies.getTopRatedMovie()) # Output: \\"Interstellar\\" print(movies.getRating(\\"Avatar\\")) # Output: -1 def __init__(self): pass def addMovie(self, title: str, rating: int): pass def getRating(self, title: str) -> int: pass def getTopRatedMovie(self) -> str: pass # Unit Tests def test_add_and_get_rating(): movies = MovieCollection() movies.addMovie(\\"Inception\\", 9) movies.addMovie(\\"Interstellar\\", 8) assert movies.getRating(\\"Inception\\") == 9 assert movies.getRating(\\"Interstellar\\") == 8 assert movies.getRating(\\"Nonexistent\\") == -1 def test_update_movie_rating(): movies = MovieCollection() movies.addMovie(\\"Inception\\", 9) movies.addMovie(\\"Inception\\", 10) assert movies.getRating(\\"Inception\\") == 10 def test_get_top_rated_movie(): movies = MovieCollection() assert movies.getTopRatedMovie() == \\"No movies in collection\\" movies.addMovie(\\"Inception\\", 9) assert movies.getTopRatedMovie() == \\"Inception\\" movies.addMovie(\\"Interstellar\\", 10) assert movies.getTopRatedMovie() == \\"Interstellar\\" movies.addMovie(\\"The Dark Knight\\", 10) assert movies.getTopRatedMovie() == \\"Interstellar\\" # Because it was added first def test_initially_empty_collection(): movies = MovieCollection() assert movies.getRating(\\"Inception\\") == -1 assert movies.getTopRatedMovie() == \\"No movies in collection\\"","solution":"class Movie: def __init__(self, title, rating): self.title = title self.rating = rating class MovieCollection: def __init__(self): self.movies = {} self.top_rated_movie = None def addMovie(self, title, rating): if title in self.movies: self.movies[title].rating = rating else: self.movies[title] = Movie(title, rating) if self.top_rated_movie is None or self.top_rated_movie.rating < rating or (self.top_rated_movie.rating == rating and title < self.top_rated_movie.title): self.top_rated_movie = self.movies[title] def getRating(self, title): if title in self.movies: return self.movies[title].rating return -1 def getTopRatedMovie(self): if self.top_rated_movie: return self.top_rated_movie.title return \\"No movies in collection\\""},{"question":"def prioritize_sites(N, severity_levels): This function takes the number of sites N and their respective severity levels, then returns the indices of the sites sorted by descending severity. :param N: Number of disaster sites :param severity_levels: List of severity levels for each site :return: List of indices sorted by severity, descending >>> prioritize_sites(5, [10, 50, 20, 50, 30]) [2, 4, 5, 3, 1] >>> prioritize_sites(4, [10, 10, 10, 10]) [1, 2, 3, 4] >>> prioritize_sites(3, [30, 20, 10]) [1, 2, 3] >>> prioritize_sites(3, [10, 20, 30]) [3, 2, 1] >>> prioritize_sites(6, [5, 50, 25, 75, 25, 50]) [4, 2, 6, 3, 5, 1] >>> prioritize_sites(1, [42]) [1]","solution":"def prioritize_sites(N, severity_levels): This function takes the number of sites N and their respective severity levels, then returns the indices of the sites sorted by descending severity. :param N: Number of disaster sites :param severity_levels: List of severity levels for each site :return: List of indices sorted by severity, descending indexed_severity = list(enumerate(severity_levels, 1)) sorted_sites = sorted(indexed_severity, key=lambda x: (-x[1], x[0])) return [index for index, severity in sorted_sites] # Example Usage N = 5 severity_levels = [10, 50, 20, 50, 30] print(prioritize_sites(N, severity_levels)) # Output: [2, 4, 5, 3, 1]"},{"question":"def max_consecutive_strength(n, strengths, k): Returns the maximum sum of strengths of k consecutive knights. Parameters: n (int): The number of knights. strengths (List[int]): The strength values of the knights. k (int): The number of consecutive knights to choose. Returns: int: The maximum possible sum of strengths of k consecutive knights. Examples: >>> max_consecutive_strength(7, [10, -5, -6, -2, 14, 6, -3], 3) 18 >>> max_consecutive_strength(5, [4, -1, 3, 2, -2], 2) 5 >>> max_consecutive_strength(6, [-2, -3, -1, -5, -4, -6], 1) -1","solution":"def max_consecutive_strength(n, strengths, k): Returns the maximum sum of strengths of k consecutive knights. if k == 0: return 0 strengths_extended = strengths * 2 max_sum = current_sum = sum(strengths_extended[:k]) for i in range(k, n + k): current_sum += strengths_extended[i] - strengths_extended[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_bake_all_cakes(n, baking_times, total_time): Determines whether all cakes can be baked within the available total time. :param n: Number of different types of cakes :param baking_times: List of baking times for each type of cake :param total_time: Total time available to bake the cakes :return: String indicating if the feast is ready or not >>> can_bake_all_cakes(4, [45, 30, 60, 20], 160) \\"Feast is ready!\\" >>> can_bake_all_cakes(3, [50, 50, 50], 120) \\"Time is not enough!\\" from solution import can_bake_all_cakes def test_feast_is_ready(): assert can_bake_all_cakes(4, [45, 30, 60, 20], 160) == \\"Feast is ready!\\" assert can_bake_all_cakes(3, [40, 50, 20], 110) == \\"Feast is ready!\\" def test_time_is_not_enough(): assert can_bake_all_cakes(3, [50, 50, 50], 120) == \\"Time is not enough!\\" assert can_bake_all_cakes(5, [70, 80, 90, 100, 110], 400) == \\"Time is not enough!\\" def test_edge_cases(): assert can_bake_all_cakes(1, [120], 120) == \\"Feast is ready!\\" assert can_bake_all_cakes(100, [1]*100, 100) == \\"Feast is ready!\\" assert can_bake_all_cakes(100, [1]*100, 99) == \\"Time is not enough!\\"","solution":"def can_bake_all_cakes(n, baking_times, total_time): Determines whether all cakes can be baked within the available total time. :param n: Number of different types of cakes :param baking_times: List of baking times for each type of cake :param total_time: Total time available to bake the cakes :return: String indicating if the feast is ready or not total_baking_time = sum(baking_times) if total_baking_time <= total_time: return \\"Feast is ready!\\" else: return \\"Time is not enough!\\" # Example of usage: # n = 4 # baking_times = [45, 30, 60, 20] # total_time = 160 # print(can_bake_all_cakes(n, baking_times, total_time)) # Output: Feast is ready!"},{"question":"def marble_probabilities(N: int, counts: List[int]) -> List[float]: Determines the probability of selecting a marble of each type from a collection. Args: N (int): the number of different types of marbles. counts (list): a list of integers representing the count of each type of marble. Returns: list: a list of probabilities for each type of marble, rounded to 4 decimal places. >>> marble_probabilities(4, [2, 3, 5, 10]) [0.1000, 0.1500, 0.2500, 0.5000] >>> marble_probabilities(3, [1, 1, 1]) [0.3333, 0.3333, 0.3333] # Your code goes here from typing import List def test_case_1(): N = 4 counts = [2, 3, 5, 10] expected = [0.1, 0.15, 0.25, 0.5] result = marble_probabilities(N, counts) assert result == expected def test_case_2(): N = 3 counts = [1, 1, 1] expected = [0.3333, 0.3333, 0.3333] result = marble_probabilities(N, counts) assert result == expected def test_case_3(): N = 2 counts = [1, 3] expected = [0.25, 0.75] result = marble_probabilities(N, counts) assert result == expected def test_case_4(): N = 5 counts = [6, 2, 2, 2, 8] expected = (6/20, 2/20, 2/20, 2/20, 8/20) expected = [round(prob, 4) for prob in expected] result = marble_probabilities(N, counts) assert result == expected def test_case_5(): N = 1 counts = [1000] expected = [1.0] result = marble_probabilities(N, counts) assert result == expected","solution":"def marble_probabilities(N, counts): Returns the probabilities of selecting each type of marble. Args: N (int): the number of different types of marbles. counts (list): a list of integers representing the count of each type of marble. Returns: list: a list of probabilities for each type of marble. total_marbles = sum(counts) probabilities = [count / total_marbles for count in counts] return [round(prob, 4) for prob in probabilities]"},{"question":"def find_minimizing_k(arr: List[int]) -> int: Finds an integer k such that it minimizes the sum of absolute differences between each element in the input array and k. >>> find_minimizing_k([1, 2, 3, 4]) 2 >>> find_minimizing_k([3, 5, 8, 2, 6]) 5 Args: arr: List of integers representing the input array. Returns: An integer k that minimizes the sum of absolute differences. from solution import find_minimizing_k def test_single_element(): assert find_minimizing_k([1]) == 1 assert find_minimizing_k([1000000000]) == 1000000000 def test_even_length_array(): assert find_minimizing_k([1, 2, 3, 4]) == 2 assert find_minimizing_k([5, 2, 4, 3]) == 3 def test_odd_length_array(): assert find_minimizing_k([1, 2, 3]) == 2 assert find_minimizing_k([7, 8, 6, 4, 5]) == 6 def test_identical_elements(): assert find_minimizing_k([3, 3, 3, 3]) == 3 assert find_minimizing_k([7, 7, 7, 7, 7]) == 7 def test_large_array(): array = list(range(1, 1000001)) assert find_minimizing_k(array) == 500000 def test_edgecases(): assert find_minimizing_k([1, 2, 3, 5, 8]) == 3 assert find_minimizing_k([1000000000, 1000000000, 1000000000]) == 1000000000","solution":"def find_minimizing_k(arr): Finds an integer k such that it minimizes the sum of absolute differences between each element in the input array and k. arr.sort() n = len(arr) # median minimizes the sum of absolute differences median = arr[(n-1) // 2] return median"},{"question":"def count_even_sum_pairs(n: int, array: List[int]) -> int: Returns the number of unique pairs (i, j) such that 1 ≤ i < j ≤ n and a_i + a_j is an even number. >>> count_even_sum_pairs(5, [1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs(6, [10, 20, 30, 40, 50, 60]) 15","solution":"def count_even_sum_pairs(n, array): Returns the number of unique pairs (i, j) such that 1 ≤ i < j ≤ n and a_i + a_j is an even number. even_count = 0 odd_count = 0 for num in array: if num % 2 == 0: even_count += 1 else: odd_count += 1 even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"def min_steps(n: int, m: int, blocked: List[Tuple[int, int]]) -> int: Returns the minimum number of steps required to reach (n, m) from (0, 0) while avoiding blocked points. If the destination is unreachable, return -1. Parameters: n : int : x-coordinate of the destination m : int : y-coordinate of the destination blocked : List[Tuple[int, int]] : list of coordinates that are blocked Returns: int : minimum number of steps to reach the destination or -1 if unreachable Example: >>> min_steps(3, 4, [(1, 2), (2, 3)]) 7 >>> min_steps(1, 1, [(1, 1)]) -1","solution":"from collections import deque def min_steps(n, m, blocked): Returns the minimum number of steps required to reach (n, m) from (0, 0) while avoiding blocked points. If the destination is unreachable, returns -1. # Convert blocked points to a set for fast lookup blocked_set = set(map(tuple, blocked)) # Edge case: starting point is blocked if (0, 0) in blocked_set: return -1 # Edge case: destination itself is blocked if (n, m) in blocked_set: return -1 # Use BFS for the shortest path problem on unweighted grid queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # possible moves while queue: x, y, steps = queue.popleft() # If destination is reached if (x, y) == (n, m): return steps # Try all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) not in visited and (nx, ny) not in blocked_set: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 # Destination is unreachable"},{"question":"def smallest_contiguous_subarray_sum(arr: List[int]) -> int: Returns the smallest sum of any contiguous subarray in the list. >>> smallest_contiguous_subarray_sum([3, -4, 2, -8, 5, -1]) == -10 >>> smallest_contiguous_subarray_sum([3, 2, 1, 4, 5]) == 1 >>> smallest_contiguous_subarray_sum([-3, -4, -2, -8, -5, -1]) == -23 >>> smallest_contiguous_subarray_sum([2, -1, 2, -3, 4, -5, 1]) == -5 >>> smallest_contiguous_subarray_sum([100]) == 100 >>> smallest_contiguous_subarray_sum([-100]) == -100 >>> smallest_contiguous_subarray_sum([1, 1, 1, 1, 1, 1]) == 1 >>> smallest_contiguous_subarray_sum([-1, -1, -1, -1, -1]) == -5","solution":"def smallest_contiguous_subarray_sum(arr): Returns the smallest sum of any contiguous subarray in the list. min_current = min_global = arr[0] for num in arr[1:]: min_current = min(num, min_current + num) if min_current < min_global: min_global = min_current return min_global"},{"question":"def min_operations(n: int) -> int: Returns the minimum number of operations required to reduce n to zero by subtracting 1, 2, or 5. >>> min_operations(11) 3 >>> min_operations(5) 1 >>> min_operations(9) 3 def get_min_operations(t: int, cases: List[int]) -> List[int]: Given a number of test cases and a list of integers, returns a list of minimum number of operations for each test case. >>> get_min_operations(3, [11, 5, 9]) [3, 1, 3] >>> get_min_operations(2, [1, 2]) [1, 1] >>> get_min_operations(1, [15]) [3]","solution":"def min_operations(n): Returns the minimum number of operations required to reduce n to zero by subtracting 1, 2, or 5. count = 0 while n > 0: if n >= 5: n -= 5 elif n >= 2: n -= 2 else: n -= 1 count += 1 return count def get_min_operations(t, cases): results = [] for n in cases: results.append(min_operations(n)) return results"},{"question":"def isValidIPv4(s: str) -> bool: Determine if the given string is a valid IPv4 address. >>> isValidIPv4(\\"192.168.1.1\\") True >>> isValidIPv4(\\"192.168.01.1\\") False >>> isValidIPv4(\\"256.256.256.256\\") False >>> isValidIPv4(\\"10.0.0.1\\") True >>> isValidIPv4(\\"0.0.0.0\\") True >>> isValidIPv4(\\"255.255.255.255\\") True >>> isValidIPv4(\\"192.168.1\\") False >>> isValidIPv4(\\"192.168.1.1.1\\") False >>> isValidIPv4(\\"192.168.1.a\\") False >>> isValidIPv4(\\"192.168.1.256\\") False >>> isValidIPv4(\\"192.168.1.01\\") False >>> isValidIPv4(\\"01.0.0.0\\") False >>> isValidIPv4(\\"192.168.001.1\\") False >>> isValidIPv4(\\"\\") False >>> isValidIPv4(\\" \\") False >>> isValidIPv4(\\" \\") False >>> isValidIPv4(\\"192. 168.1.1\\") False >>> isValidIPv4(\\"192.168.1. 1\\") False","solution":"def isValidIPv4(s): Returns True if the string s is a valid IPv4 address, else returns False. parts = s.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit() or (part[0] == '0' and len(part) > 1) or not (0 <= int(part) <= 255): return False return True"},{"question":"def validate_sudoku(grid: list[list[int]]) -> bool: Validates a completed Sudoku grid. Args: grid (list of lists): A 9x9 grid where each element is an integer from 1 to 9. Returns: bool: True if the grid is a valid Sudoku solution, False otherwise. >>> grid1 = [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ] >>> validate_sudoku(grid1) True >>> grid2 = [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 1, 9] # note the last row, it has two 1s ... ] >>> validate_sudoku(grid2) False","solution":"def validate_sudoku(grid): Validates a completed Sudoku grid. Parameters: grid (list of lists): A 9x9 grid of integers. Returns: bool: True if the grid is a valid Sudoku solution, False otherwise. def is_valid_block(block): return sorted(block) == list(range(1, 10)) # Check rows for row in grid: if not is_valid_block(row): return False # Check columns for col in range(9): if not is_valid_block([grid[row][col] for row in range(9)]): return False # Check 3x3 sub-grids for i in range(0, 9, 3): for j in range(0, 9, 3): block = [grid[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_block(block): return False return True"},{"question":"def count_palindromic_partitions(s: str) -> int: Given a string consisting of lowercase English letters, find out the number of ways to partition the string into contiguous substrings such that each substring is a palindrome. The result should be returned modulo 10^9 + 7. >>> count_palindromic_partitions(\\"aab\\") 2 >>> count_palindromic_partitions(\\"aaa\\") 4 >>> count_palindromic_partitions(\\"a\\") 1 >>> count_palindromic_partitions(\\"aa\\") 2 >>> count_palindromic_partitions(\\"ab\\") 1","solution":"MOD = 10**9 + 7 def is_palindrome(s): return s == s[::-1] def count_palindromic_partitions(s): n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i): if is_palindrome(s[j:i]): dp[i] = (dp[i] + dp[j]) % MOD return dp[n]"},{"question":"MOD = 10**9 + 7 def fibonacci(n: int) -> int: Calculate the nth Fibonacci number using Dynamic Programming. The result is returned modulo 10^9 + 7. >>> fibonacci(10) == 55 >>> fibonacci(1) == 0 >>> fibonacci(5) == 3","solution":"MOD = 10**9 + 7 def fibonacci(n): Returns the nth Fibonacci number using Dynamic Programming modulo 10^9 + 7. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(2, n): a, b = b, (a + b) % MOD return b"},{"question":"def evaluateExpression(s: str) -> int: Evaluate a mathematical expression given as a string and return the result as an integer. The expression contains characters '(', ')', '+', '-', '*', '/' and digits '0'-'9'. >>> evaluateExpression(\\"3 + 2*2\\") 7 >>> evaluateExpression(\\"3/2\\") 1 >>> evaluateExpression(\\"3+5 / 2\\") 5 >>> evaluateExpression(\\"(3 + 2) * 2\\") 10 >>> evaluateExpression(\\"((2+3)*2)\\") 10","solution":"def evaluateExpression(s: str) -> int: def operate(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return int(a / b) # Truncate towards zero def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operations(operands, operators): b = operands.pop() a = operands.pop() op = operators.pop() operands.append(operate(a, b, op)) operands = [] operators = [] i = 0 while i < len(s): if s[i] == ' ': i += 1 continue if s[i] in '0123456789': val = 0 while i < len(s) and s[i] in '0123456789': val = val * 10 + int(s[i]) i += 1 operands.append(val) continue if s[i] == '(': operators.append(s[i]) elif s[i] == ')': while operators and operators[-1] != '(': apply_operations(operands, operators) operators.pop() else: while (operators and operators[-1] != '(' and precedence(operators[-1]) >= precedence(s[i])): apply_operations(operands, operators) operators.append(s[i]) i += 1 while operators: apply_operations(operands, operators) return operands[0]"},{"question":"def can_withdraw(M: int, W: int, denominations: List[int]) -> str: Determine if it's possible to withdraw the exact amount W using available denominations. Args: M (int): The amount of money in the ATM. W (int): The amount of money to withdraw. denominations (List[int]): List of available denominations. Returns: str: \\"YES\\" if it's possible to withdraw W, otherwise \\"NO\\". >>> can_withdraw(1000, 500, [100, 200, 300, 400, 500]) 'YES' >>> can_withdraw(1000, 250, [100, 200, 300, 400, 500]) 'NO' >>> can_withdraw(1000, 0, [100, 200, 300, 400, 500]) 'YES' >>> can_withdraw(1000, 300, [100, 200, 300]) 'YES' >>> can_withdraw(1000000000, 1000000, [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000]) 'YES' >>> can_withdraw(1000, 7, [2, 4, 6]) 'NO' >>> can_withdraw(1000, 7, [3, 4, 5]) 'YES' >>> can_withdraw(1000, 5000, [1, 5, 10, 50, 100, 500]) 'NO'","solution":"def can_withdraw(M, W, denominations): Determine if it's possible to withdraw the exact amount W using available denominations. Args: M (int): The amount of money in the ATM. W (int): The amount of money to withdraw. denominations (List[int]): List of available denominations. Returns: str: \\"YES\\" if it's possible to withdraw W, otherwise \\"NO\\". def can_make_amount_with_denominations(W, denominations): # To check if we can make amount W with given denominations using dynamic programming. dp = [False] * (W + 1) dp[0] = True # Base case: 0 amount can be made with 0 denominations for denom in denominations: for i in range(denom, W + 1): if dp[i - denom]: dp[i] = True return dp[W] if W > M: return \\"NO\\" if W == 0: return \\"YES\\" return \\"YES\\" if can_make_amount_with_denominations(W, denominations) else \\"NO\\""},{"question":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given a sorted array of distinct integers and a target value, return a tuple containing the indices of the two numbers such that they add up to the target. >>> find_two_sum([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum([1, 2, 3, 4], 8) () >>> find_two_sum([1, 4, 5, 6], 6) (0, 2) >>> find_two_sum([-3, 1, 2, 4, 6], 3) (0, 4) >>> find_two_sum([10, 20, 30, 40, 50], 70) (1, 4)","solution":"from typing import List, Tuple def find_two_sum(nums: List[int], target: int) -> Tuple[int, int]: Given a sorted array of distinct integers and a target value, return a tuple containing the indices of the two numbers such that they add up to the target. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return (left, right) elif current_sum < target: left += 1 else: right -= 1 return ()"},{"question":"from typing import List def can_reach_last_planet(T: List[int]) -> str: Determine if it is possible to reach the last planet \`N-1\` from the first planet \`0\` using teleporters. >>> can_reach_last_planet([2, 3, 1, 1, 4]) \\"Possible\\" >>> can_reach_last_planet([3, 2, 1, 0, 4]) \\"Impossible\\"","solution":"def can_reach_last_planet(T): N = len(T) max_reach = 0 for i in range(N): if i > max_reach: return \\"Impossible\\" max_reach = max(max_reach, i + T[i]) if max_reach >= N - 1: return \\"Possible\\" return \\"Impossible\\""},{"question":"import math from typing import List, Tuple def calculate_distances(bird_data: List[Tuple[float, float, float, float]]) -> List[float]: Given a list of tuples containing the coordinates for each bird's travel, calculate the straight-line distance traveled by each bird. Args: bird_data (list of tuples): List of tuples where each tuple consists of four floats (x1, y1, x2, y2) Returns: list of floats: List of distances traveled by each bird rounded to 6 decimal places. >>> calculate_distances([(0.0, 0.0, 3.0, 4.0), (-1.0, -1.0, 2.0, 2.0)]) [5.000000, 4.242641] >>> calculate_distances([(1.0, 1.0, 1.0, 1.0)]) [0.000000]","solution":"import math def calculate_distances(bird_data): Given a list of tuples containing the coordinates for each bird's travel, calculate the straight-line distance traveled by each bird. Args: bird_data (list of tuples): List of tuples where each tuple consists of four floats (x1, y1, x2, y2) Returns: list of floats: List of distances traveled by each bird rounded to 6 decimal places. distances = [] for (x1, y1, x2, y2) in bird_data: distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) distances.append(round(distance, 6)) return distances"},{"question":"def fizz_buzz(n: int) -> List[str]: Generates the FizzBuzz sequence from 1 to n. For multiples of 3, the string \\"Fizz\\" is added. For multiples of 5, the string \\"Buzz\\" is added. For multiples of both 3 and 5, the string \\"FizzBuzz\\" is added. Otherwise, the number itself is added as a string. If n is less than 1, returns an empty list. >>> fizz_buzz(1) == [\\"1\\"] >>> fizz_buzz(2) == [\\"1\\", \\"2\\"] >>> fizz_buzz(3) == [\\"1\\", \\"2\\", \\"Fizz\\"] >>> fizz_buzz(5) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\"] >>> fizz_buzz(15) == [\\"1\\", \\"2\\", \\"Fizz\\", \\"4\\", \\"Buzz\\", \\"Fizz\\", \\"7\\", \\"8\\", \\"Fizz\\", \\"Buzz\\", \\"11\\", \\"Fizz\\", \\"13\\", \\"14\\", \\"FizzBuzz\\"] >>> fizz_buzz(0) == [] >>> fizz_buzz(-5) == [] >>> fizz_buzz(30)[-1] == \\"FizzBuzz\\" >>> fizz_buzz(30)[-2] == \\"29\\"","solution":"def fizz_buzz(n): Generates the FizzBuzz sequence from 1 to n. For multiples of 3, the string \\"Fizz\\" is added. For multiples of 5, the string \\"Buzz\\" is added. For multiples of both 3 and 5, the string \\"FizzBuzz\\" is added. Otherwise, the number itself is added as a string. If n is less than 1, returns an empty list. if n < 1: return [] result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"from typing import List def max_number_of_visible_boxes(grid: List[List[int]]) -> int: Determine the maximum number of visible boxes in a grid from any direction. >>> grid = [ ... [1, 0, 4, 2, 3], ... [3, 2, 4, 0, 1], ... [1, 1, 0, 2, 2], ... [0, 2, 4, 3, 0] ... ] >>> max_number_of_visible_boxes(grid) 13 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> max_number_of_visible_boxes(grid) 0 >>> grid = [ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ] >>> max_number_of_visible_boxes(grid) 1 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_number_of_visible_boxes(grid) 3 >>> grid = [ ... [3, 1, 4, 1, 5] ... ] >>> max_number_of_visible_boxes(grid) 4 >>> grid = [ ... [3], ... [1], ... [4], ... [1], ... [5] ... ] >>> max_number_of_visible_boxes(grid) 4","solution":"def max_visible_boxes(grid): M = len(grid) N = len(grid[0]) if M > 0 else 0 max_visible = 0 for row in grid: row_visible = len(set(row)) - (1 if 0 in row else 0) max_visible = max(max_visible, row_visible) for col in range(N): col_visible = len(set(grid[row][col] for row in range(M))) - (1 if 0 in (grid[row][col] for row in range(M)) else 0) max_visible = max(max_visible, col_visible) return max_visible def max_number_of_visible_boxes(grid): M = len(grid) N = len(grid[0]) if M > 0 else 0 max_visible = 0 for row in grid: row_visible = len(set(filter(lambda x: x > 0, row))) max_visible = max(max_visible, row_visible) for col in range(N): col_visible = len(set(grid[row][col] for row in range(M) if grid[row][col] > 0)) max_visible = max(max_visible, col_visible) return max_visible"},{"question":"def max_non_overlapping_jobs(jobs): Determines the maximum number of non-overlapping jobs. >>> max_non_overlapping_jobs([(1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> max_non_overlapping_jobs([(1, 5), (2, 6), (6, 8), (4, 7), (5, 9), (8, 10)]) 3 def process_jobs_input(job_input): Processes input list into a format suitable for the max_non_overlapping_jobs function. >>> process_jobs_input([4, (1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> process_jobs_input([6, (1, 5), (2, 6), (6, 8), (4, 7), (5, 9), (8, 10)]) 3","solution":"def max_non_overlapping_jobs(jobs): Determines the maximum number of non-overlapping jobs. # Sort jobs by their end time jobs.sort(key=lambda job: job[1]) # Initialize count of non-overlapping jobs count = 0 last_end_time = 0 for job in jobs: start, end = job if start >= last_end_time: count += 1 last_end_time = end return count def process_jobs_input(job_input): Processes input list into a format suitable for the max_non_overlapping_jobs function. jobs = [] for i in range(1, len(job_input)): jobs.append(tuple(job_input[i])) return max_non_overlapping_jobs(jobs)"},{"question":"def snack_packs(friends: int) -> str: Return the number of snack packs based on the number of friends attending. >>> snack_packs(1) 'Buy 2 packs of snacks' >>> snack_packs(5) 'Buy 2 packs of snacks' >>> snack_packs(10) 'Buy 4 packs of snacks' >>> snack_packs(20) 'Buy 10 packs of snacks' >>> snack_packs(50) 'Buy 20 packs of snacks'","solution":"def snack_packs(friends): Return the number of snack packs based on the number of friends attending. Parameters: friends (int): The number of friends attending. Returns: str: The number of snack packs to buy. if friends < 10: return \\"Buy 2 packs of snacks\\" elif friends < 20: return \\"Buy 4 packs of snacks\\" elif friends < 50: return \\"Buy 10 packs of snacks\\" else: return \\"Buy 20 packs of snacks\\""},{"question":"def minimize_largest_sum(nums, k): Given an array of integers, partition the array into k contiguous subarrays such that the largest sum among these subarrays is minimized. >>> minimize_largest_sum([7, 2, 5, 10, 8], 2) 18 >>> minimize_largest_sum([1, 2, 3, 4, 5], 3) 6 def process_test_cases(t, test_cases): Process multiple test cases for the minimize_largest_sum function. >>> t = 2 >>> test_cases = [ >>> (5, 2, [7, 2, 5, 10, 8]), >>> (5, 3, [1, 2, 3, 4, 5]) >>> ] >>> process_test_cases(t, test_cases) [18, 6] from solution import minimize_largest_sum, process_test_cases def test_minimize_largest_sum(): assert minimize_largest_sum([7, 2, 5, 10, 8], 2) == 18 assert minimize_largest_sum([1, 2, 3, 4, 5], 3) == 6 assert minimize_largest_sum([1, 4, 4], 3) == 4 assert minimize_largest_sum([10, 20, 30, 40, 50], 4) == 50 assert minimize_largest_sum([10, 20, 30, 40, 50], 1) == 150 def test_process_test_cases(): t = 2 test_cases = [ (5, 2, [7, 2, 5, 10, 8]), (5, 3, [1, 2, 3, 4, 5]) ] results = process_test_cases(t, test_cases) assert results == [18, 6] t = 3 test_cases = [ (3, 3, [1, 4, 4]), (5, 4, [10, 20, 30, 40, 50]), (5, 1, [10, 20, 30, 40, 50]) ] results = process_test_cases(t, test_cases) assert results == [4, 50, 150]","solution":"def minimize_largest_sum(nums, k): def is_valid_partition(max_sum): current_sum = 0 partitions = 1 for num in nums: current_sum += num if current_sum > max_sum: partitions += 1 current_sum = num if partitions > k: return False return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid_partition(mid): right = mid else: left = mid + 1 return left def process_test_cases(t, test_cases): results = [] for case in test_cases: n, k, nums = case result = minimize_largest_sum(nums, k) results.append(result) return results"},{"question":"def find_floor_with_highest_avg_distance(F: int, S: int, sensor_data: List[Tuple[int, int, int]]) -> int: Determine which floor has the highest average distance covered by detected motions. Parameters: F (int): Number of floors. S (int): Number of sensors. sensor_data (list of tuples): Each tuple contains (floor, m, d). - \`floor\` (1 ≤ floor ≤ F) indicates the floor on which the sensor is placed. - \`m\` (1 ≤ m ≤ 100) indicates the number of motion events detected by the sensor. - \`d\` (1 ≤ d ≤ 10000) indicates the total distance covered by these motion events in meters. Returns: int: The floor with the highest average distance covered by motions. If there is a tie, select the floor with the smallest number. >>> F = 3 >>> S = 5 >>> sensor_data = [ >>> (1, 5, 400), >>> (2, 10, 600), >>> (3, 10, 500), >>> (1, 4, 500), >>> (2, 6, 300) >>> ] >>> find_floor_with_highest_avg_distance(F, S, sensor_data) 1 >>> F = 3 >>> S = 3 >>> sensor_data = [ >>> (1, 0, 0), >>> (2, 0, 0), >>> (3, 0, 0) >>> ] >>> find_floor_with_highest_avg_distance(F, S, sensor_data) -1 from typing import List, Tuple # Your code here","solution":"def find_floor_with_highest_avg_distance(F, S, sensor_data): Determine which floor has the highest average distance covered by detected motions. Parameters: F (int): Number of floors. S (int): Number of sensors. sensor_data (list of tuples): Each tuple contains (floor, m, d). Returns: int: The floor with the highest average distance covered by motions. from collections import defaultdict # Dictionary to store sum of distances and number of motion events per floor floor_data = defaultdict(lambda: [0, 0]) for floor, m, d in sensor_data: floor_data[floor][0] += d # sum of distances floor_data[floor][1] += m # sum of motion events # Find the floor with the highest average distance max_avg_distance = -1 best_floor = -1 for floor in range(1, F+1): if floor_data[floor][1] != 0: avg_distance = floor_data[floor][0] / floor_data[floor][1] if avg_distance > max_avg_distance or (avg_distance == max_avg_distance and floor < best_floor): max_avg_distance = avg_distance best_floor = floor return best_floor # Example usage: # F = 3 # S = 5 # sensor_data = [ # (1, 5, 400), # (2, 10, 600), # (3, 10, 500), # (1, 4, 500), # (2, 6, 300) # ] # print(find_floor_with_highest_avg_distance(F, S, sensor_data)) # Output: 1"},{"question":"from typing import Tuple def can_deliver_package(x_sd: int, y_sd: int, r: int, x_p: int, y_p: int) -> str: Determines if the drone can deliver the package. Parameters: x_sd (int): x-coordinate of the drone's starting position y_sd (int): y-coordinate of the drone's starting position r (int): maximum delivery range of the drone x_p (int): x-coordinate of the package's position y_p (int): y-coordinate of the package's position Returns: str: \\"Deliverable\\" if the package is reachable, otherwise \\"Not Deliverable\\" >>> can_deliver_package(0, 0, 5, 3, 4) == \\"Deliverable\\" >>> can_deliver_package(0, 0, 5, 6, 8) == \\"Not Deliverable\\" >>> can_deliver_package(0, 0, 5, 5, 0) == \\"Deliverable\\" >>> can_deliver_package(1, 1, 0, 1, 1) == \\"Deliverable\\" >>> can_deliver_package(-1, -1, 5, -4, -4) == \\"Deliverable\\" >>> can_deliver_package(0, 0, 10000, 10000, 0) == \\"Deliverable\\" >>> can_deliver_package(0, 0, 100, 200, 200) == \\"Not Deliverable\\"","solution":"import math def can_deliver_package(x_sd, y_sd, r, x_p, y_p): Determines if the drone can deliver the package. Parameters: x_sd (int): x-coordinate of the drone's starting position y_sd (int): y-coordinate of the drone's starting position r (int): maximum delivery range of the drone x_p (int): x-coordinate of the package's position y_p (int): y-coordinate of the package's position Returns: str: \\"Deliverable\\" if the package is reachable, otherwise \\"Not Deliverable\\" distance = math.sqrt((x_sd - x_p) ** 2 + (y_sd - y_p) ** 2) if distance <= r: return \\"Deliverable\\" return \\"Not Deliverable\\""},{"question":"def convertTemperature(temp: str, targetUnit: str) -> str: Converts a given temperature from Celsius to Fahrenheit or from Fahrenheit to Celsius. Parameters: temp (str): The temperature to be converted, which includes the numerical value followed by the unit ('C' for Celsius, 'F' for Fahrenheit). targetUnit (str): The target unit to convert to, either 'C' or 'F'. Returns: str: The converted temperature rounded to the nearest whole number, followed by the target unit. >>> convertTemperature(\\"21C\\", \\"F\\") '70F' >>> convertTemperature(\\"70F\\", \\"C\\") '21C' from solution import convertTemperature def test_convert_celsius_to_fahrenheit(): assert convertTemperature(\\"21C\\", \\"F\\") == \\"70F\\" assert convertTemperature(\\"0C\\", \\"F\\") == \\"32F\\" assert convertTemperature(\\"-40C\\", \\"F\\") == \\"-40F\\" def test_convert_fahrenheit_to_celsius(): assert convertTemperature(\\"70F\\", \\"C\\") == \\"21C\\" assert convertTemperature(\\"32F\\", \\"C\\") == \\"0C\\" assert convertTemperature(\\"-40F\\", \\"C\\") == \\"-40C\\" def test_edge_cases(): assert convertTemperature(\\"100C\\", \\"F\\") == \\"212F\\" assert convertTemperature(\\"212F\\", \\"C\\") == \\"100C\\" def test_invalid_cases(): try: convertTemperature(\\"21C\\", \\"C\\") except ValueError as ve: assert str(ve) == \\"Invalid unit conversion combination\\" try: convertTemperature(\\"70F\\", \\"F\\") except ValueError as ve: assert str(ve) == \\"Invalid unit conversion combination\\"","solution":"def convertTemperature(temp, targetUnit): Converts a given temperature from Celsius to Fahrenheit or from Fahrenheit to Celsius. Parameters: temp (str): The temperature to be converted, which includes the numerical value followed by the unit ('C' for Celsius, 'F' for Fahrenheit). targetUnit (str): The target unit to convert to, either 'C' or 'F'. Returns: str: The converted temperature rounded to the nearest whole number, followed by the target unit. value = int(temp[:-1]) unit = temp[-1] if unit == 'C' and targetUnit == 'F': converted_value = round((value * 9/5) + 32) elif unit == 'F' and targetUnit == 'C': converted_value = round((value - 32) * 5/9) else: raise ValueError(\\"Invalid unit conversion combination\\") return f\\"{converted_value}{targetUnit}\\""},{"question":"def has_pair_with_sum(arr, k): Determines if there exists a pair of elements in the array that sum up to k. :param arr: List of integers :param k: Target sum integer :return: \\"YES\\" if a pair exists, \\"NO\\" otherwise pass # Tests def test_pair_exists_in_middle(): assert has_pair_with_sum([2, 7, 11, 15, 3], 9) == \\"YES\\" def test_pair_not_exists(): assert has_pair_with_sum([1, 2, 4, 5], 8) == \\"NO\\" def test_pair_with_negative_numbers(): assert has_pair_with_sum([-1, -2, -3, 4, 5], 2) == \\"YES\\" assert has_pair_with_sum([-1, -2, -3, 4, 5], -4) == \\"YES\\" def test_pair_exists_beginning_end(): assert has_pair_with_sum([5, 0, 0, 0, 3, 2], 7) == \\"YES\\" def test_single_element(): assert has_pair_with_sum([5], 5) == \\"NO\\" def test_two_elements(): assert has_pair_with_sum([3, 5], 8) == \\"YES\\" assert has_pair_with_sum([3, 5], 10) == \\"NO\\" def test_large_values(): assert has_pair_with_sum([10**5, 10**5 - 1], 2 * 10**5 - 1) == \\"YES\\"","solution":"def has_pair_with_sum(arr, k): Determines if there exists a pair of elements in the array that sum up to k. :param arr: List of integers :param k: Target sum integer :return: \\"YES\\" if a pair exists, \\"NO\\" otherwise seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def largest_product(nums): Given a list of integers, this function returns the largest product that can be achieved by multiplying three distinct elements from the array. If the array has less than three elements, return 0. # TODO: Implement this function def process_test_cases(t, test_cases): Process multiple test cases for the largest_product function. # TODO: Implement this function # Example test cases if __name__ == \\"__main__\\": t = 3 test_cases = [ (5, [1, 2, 3, 4, 5]), (3, [7, 3, 1]), (4, [1, 10, 2, 6]) ] results = process_test_cases(t, test_cases) print(results) # Should print: [60, 21, 120]","solution":"def largest_product(nums): Given a list of integers, this function returns the largest product that can be achieved by multiplying three distinct elements from the array. If the array has less than three elements, return 0. n = len(nums) if n < 3: return 0 nums.sort() return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1]) def process_test_cases(t, test_cases): Process multiple test cases for the largest_product function. results = [] for i in range(t): n, nums = test_cases[i] results.append(largest_product(nums)) return results"},{"question":"def min_moves_to_reach_n(N: int, K: int) -> int: Returns the minimum number of moves required for Bob to reach exactly position N. >>> min_moves_to_reach_n(5, 3) 3 >>> min_moves_to_reach_n(20, 1) 20 >>> min_moves_to_reach_n(18, 2) 9 >>> min_moves_to_reach_n(7, 3) 5 >>> min_moves_to_reach_n(1, 2) 2","solution":"def min_moves_to_reach_n(N, K): Returns the minimum number of moves required for Bob to reach exactly position N. Parameters: N (int): target position K (int): steps to move right by K units Returns: int: minimum number of moves to reach N # Initialize a dictionary to store the minimum moves to each position min_moves = {0: 0} # Initialize a queue with the starting position queue = [(0, 0)] while queue: current_position, current_moves = queue.pop(0) # Move left to the current_position-1 left_position = current_position - 1 if left_position not in min_moves or current_moves + 1 < min_moves[left_position]: min_moves[left_position] = current_moves + 1 queue.append((left_position, current_moves + 1)) # Move right to the current_position+K right_position = current_position + K if right_position not in min_moves or current_moves + 1 < min_moves[right_position]: min_moves[right_position] = current_moves + 1 queue.append((right_position, current_moves + 1)) if N in min_moves: break return min_moves[N]"},{"question":"from typing import List def trap_water(arr: List[int]) -> int: You are given an array of integers \`arr\` representing the heights of a series of buildings. The buildings are situated in such a way that they form a skyline with some peaks and valleys. Your task is to determine the total volume of water that can be trapped between the buildings after it rains. The water trapped at any position is determined by the height of the buildings to the left and right of that position. Args: arr (List[int]): A single list of integers where \`1 <= len(arr) <= 10000\` and \`0 <= arr[i] <= 1000\`. Returns: int: An integer representing the total volume of water trapped. Examples: >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9 def test_trap_water(): assert trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 assert trap_water([4,2,0,3,2,5]) == 9 assert trap_water([1,0,1]) == 1 assert trap_water([3,0,2,0,4]) == 7 assert trap_water([0,0,0,0]) == 0 assert trap_water([1,1,1,1]) == 0 def test_trap_water_edge_cases(): assert trap_water([]) == 0 assert trap_water([0]) == 0 assert trap_water([4,1,2]) == 1 assert trap_water([4,1,3]) == 2 assert trap_water([3, 0, 0, 2, 0, 4]) == 10","solution":"def trap_water(arr): if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_max[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], arr[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - arr[i] return total_water"},{"question":"def categorize_plants(data: str) -> str: Processes the input data and returns the results for each test case. Args: data (str): The input data containing multiple test cases. Returns: str: The result for each test case containing counts of flowers, bushes, and trees. Example: >>> input_data = \\"1n3nRose FlowernTulip FlowernOak Tree\\" >>> output = \\"Total Flowers: 2nTotal Bushes: 0nTotal Trees: 1\\" >>> categorize_plants(input_data) == output pass from categorize_plants import categorize_plants def test_single_case(): input_data = \\"1n3nRose FlowernTulip FlowernOak Tree\\" output = \\"Total Flowers: 2nTotal Bushes: 0nTotal Trees: 1\\" assert categorize_plants(input_data) == output def test_multiple_cases(): input_data = \\"2n4nRose FlowernTulip FlowernLavender BushnOak Treen3nSunflower FlowernHibiscus BushnPine Tree\\" output = \\"Total Flowers: 2nTotal Bushes: 1nTotal Trees: 1nTotal Flowers: 1nTotal Bushes: 1nTotal Trees: 1\\" assert categorize_plants(input_data) == output def test_no_plants(): input_data = \\"1n0\\" output = \\"Total Flowers: 0nTotal Bushes: 0nTotal Trees: 0\\" assert categorize_plants(input_data) == output def test_all_flowers(): input_data = \\"1n3nRose FlowernTulip FlowernSunflower Flower\\" output = \\"Total Flowers: 3nTotal Bushes: 0nTotal Trees: 0\\" assert categorize_plants(input_data) == output def test_all_bushes(): input_data = \\"1n3nLavender BushnHibiscus BushnRosemary Bush\\" output = \\"Total Flowers: 0nTotal Bushes: 3nTotal Trees: 0\\" assert categorize_plants(input_data) == output def test_all_trees(): input_data = \\"1n3nOak TreenPine TreenMaple Tree\\" output = \\"Total Flowers: 0nTotal Bushes: 0nTotal Trees: 3\\" assert categorize_plants(input_data) == output","solution":"def count_plants(test_case): Process a single test case and return the formatted string containing the count of flowers, bushes, and trees. lines = test_case.strip().split('n') N = int(lines[0]) flower_count = bush_count = tree_count = 0 for i in range(1, N + 1): plant_name, category = lines[i].rsplit(' ', 1) if category == \\"Flower\\": flower_count += 1 elif category == \\"Bush\\": bush_count += 1 elif category == \\"Tree\\": tree_count += 1 return f\\"Total Flowers: {flower_count}nTotal Bushes: {bush_count}nTotal Trees: {tree_count}\\" def categorize_plants(data): Processes the input data and returns the results for each test case. lines = data.strip().split('n') T = int(lines[0]) result = [] index = 1 for _ in range(T): N = int(lines[index]) test_case = 'n'.join(lines[index:index + N + 1]) result.append(count_plants(test_case)) index += N + 1 return 'n'.join(result)"},{"question":"def matrix_addition(n, m, matrix_a, matrix_b): Perform element-wise addition of two n x m matrices A and B. Parameters: n (int): Number of rows. m (int): Number of columns. matrix_a (list of list of int): Matrix A of size n x m. matrix_b (list of list of int): Matrix B of size n x m. Returns: list of list of int: Resulting matrix C of size n x m where each element c_ij = a_ij + b_ij. def format_matrix(matrix): Format a matrix for printing or output. Parameters: matrix (list of list of int): The matrix to format. Returns: str: Formatted matrix as a string. from solution import matrix_addition, format_matrix def test_matrix_addition(): n, m = 2, 3 matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [-1, -2, -3], [-4, -5, -6] ] expected = [ [0, 0, 0], [0, 0, 0] ] assert matrix_addition(n, m, matrix_a, matrix_b) == expected def test_matrix_addition_single_element(): n, m = 1, 1 matrix_a = [ [1] ] matrix_b = [ [2] ] expected = [ [3] ] assert matrix_addition(n, m, matrix_a, matrix_b) == expected def test_matrix_addition_different_values(): n, m = 2, 2 matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [5, 6], [7, 8] ] expected = [ [6, 8], [10, 12] ] assert matrix_addition(n, m, matrix_a, matrix_b) == expected def test_format_matrix(): matrix = [ [0, 0, 0], [0, 0, 0] ] expected = \\"0 0 0n0 0 0\\" assert format_matrix(matrix) == expected def test_format_matrix_single_element(): matrix = [ [3] ] expected = \\"3\\" assert format_matrix(matrix) == expected","solution":"def matrix_addition(n, m, matrix_a, matrix_b): Perform element-wise addition of two n x m matrices A and B. Parameters: n (int): Number of rows. m (int): Number of columns. matrix_a (list of list of int): Matrix A of size n x m. matrix_b (list of list of int): Matrix B of size n x m. Returns: list of list of int: Resulting matrix C of size n x m where each element c_ij = a_ij + b_ij. matrix_c = [] for i in range(n): row = [] for j in range(m): row.append(matrix_a[i][j] + matrix_b[i][j]) matrix_c.append(row) return matrix_c def format_matrix(matrix): Format a matrix for printing or output. Parameters: matrix (list of list of int): The matrix to format. Returns: str: Formatted matrix as a string. return \\"n\\".join(\\" \\".join(map(str, row)) for row in matrix)"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals. Args: intervals (List[List[int]]): A collection of intervals where each interval is a list of two integers. Returns: List[List[int]]: A collection of merged intervals. Example: >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]]","solution":"def merge_intervals(intervals): Merge all overlapping intervals. Args: intervals (List[List[int]]): A collection of intervals where each interval is a list of two integers. Returns: List[List[int]]: A collection of merged intervals. if not intervals: return [] # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) merged = [] current_start, current_end = intervals[0] for i in range(1, len(intervals)): interval_start, interval_end = intervals[i] if interval_start <= current_end: # There is overlap, merge the intervals current_end = max(current_end, interval_end) else: # No overlap, add the previous interval and update the current interval merged.append([current_start, current_end]) current_start, current_end = intervals[i] # Add the last interval merged.append([current_start, current_end]) return merged"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): Build a binary tree from a given list of nodes in the format: [(node, left_child, right_child), ...] Nodes are given in level order. >>> build_tree([(1, 2, 3), (2, -1, -1), (3, 4, 5), (4, -1, -1), (5, -1, -1)]) TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) def unique_traversal(root): Perform a unique traversal on a binary tree. First visit the left subtree in preorder, then visit the root, then visit the right subtree in inorder. >>> unique_traversal(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))) [2, 1, 4, 3, 5] def process_test_cases(test_cases): Process test cases for the unique traversal of binary trees. >>> process_test_cases([[(1, 2, 3), (2, -1, -1), (3, 4, 5), (4, -1, -1), (5, -1, -1)]]) [[2, 1, 4, 3, 5]] def solution(T, test_cases): Main function to solve the problem for T test cases. >>> solution(1, [[(1, 2, 3), (2, -1, -1), (3, 4, 5), (4, -1, -1), (5, -1, -1)]]) [[2, 1, 4, 3, 5]]","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(nodes): if not nodes: return None node_map = {val: TreeNode(val) for val, _, _ in nodes if val != -1} for parent, left, right in nodes: if parent != -1: if left != -1: node_map[parent].left = node_map[left] if right != -1: node_map[parent].right = node_map[right] return node_map[nodes[0][0]] # root node def unique_traversal(root): def preorder_left(node): if not node: return [] return [node.value] + preorder_left(node.left) def inorder_right(node): if not node: return [] return inorder_right(node.left) + [node.value] + inorder_right(node.right) if not root: return [] left_preorder = preorder_left(root.left) root_value = [root.value] right_inorder = inorder_right(root.right) return left_preorder + root_value + right_inorder def process_test_cases(test_cases): results = [] for case in test_cases: tree = build_tree(case) results.append(unique_traversal(tree)) return results def solution(T, test_cases): return process_test_cases(test_cases)"},{"question":"from collections import defaultdict import sys def process_votes(input_lines): Write a program to simulate a specific type of voting process. In a certain country, in order to avoid ties in elections, they have introduced a special rule in their voting process. If a voter changes their vote, all the previous votes for the previous candidate by this voter are considered void, and only the vote for the new candidate is counted. You are given the records of the votes cast by various voters. Each voter is identified by an ID, and you need to determine the number of votes each candidate gets after considering the special rule. Args: input_lines (List[str]): A list of strings representing the voting records. Each string contains a voter ID and a candidate ID separated by a space. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains a candidate ID and the number of valid votes they received, sorted by candidate IDs in ascending order. Example: >>> input_lines = [ ... \\"1 2\\", ... \\"2 3\\", ... \\"1 4\\", ... \\"3 3\\", ... \\"2 3\\" ... ] >>> process_votes(input_lines) [(2, 0), (3, 2), (4, 1)]","solution":"from collections import defaultdict import sys def process_votes(input_lines): latest_votes = {} votes_count = defaultdict(int) for line in input_lines: voter_id, candidate_id = map(int, line.split()) if voter_id in latest_votes: previous_candidate_id = latest_votes[voter_id] votes_count[previous_candidate_id] -= 1 latest_votes[voter_id] = candidate_id votes_count[candidate_id] += 1 # Ensure sorted output by candidate ID sorted_candidates = sorted(votes_count.items()) result = [(candidate, count) for candidate, count in sorted_candidates] return result if __name__ == \\"__main__\\": input_lines = sys.stdin.read().strip().split('n') results = process_votes(input_lines) for candidate, count in results: print(f\\"{candidate} {count}\\")"},{"question":"class Stack: A class to simulate a basic stack data structure with push, pop, and max operations. The max operation should return the largest element currently in the stack in O(1) time. def __init__(self): Initialize an empty stack and a list to keep track of the max values. def push(self, item: int) -> None: Push an item onto the stack and update the max stack. def pop(self) -> int: Pop an item off the stack and update the max stack. def max(self) -> int: Return the maximum item in the stack.","solution":"class Stack: def __init__(self): Initialize an empty stack and a list to keep track of the max values. self.stack = [] self.max_stack = [] def push(self, item: int) -> None: Push an item onto the stack and update the max stack. self.stack.append(item) if not self.max_stack or item >= self.max_stack[-1]: self.max_stack.append(item) def pop(self) -> int: Pop an item off the stack and update the max stack. if not self.stack: return None popped_item = self.stack.pop() if popped_item == self.max_stack[-1]: self.max_stack.pop() return popped_item def max(self) -> int: Return the maximum item in the stack. if not self.max_stack: return None return self.max_stack[-1]"},{"question":"def can_schedule_meetings(n: int, m: int, requests: List[Tuple[int, int, int]]) -> str: Determine if all meeting requests can be scheduled without conflicts. >>> can_schedule_meetings(3, 5, [(1, 5, 1), (6, 10, 1), (5, 8, 2), (2, 5, 3), (8, 9, 3)]) 'YES' >>> can_schedule_meetings(2, 3, [(1, 4, 1), (2, 3, 1), (4, 5, 2)]) 'NO' from typing import List, Tuple def test_single_engineer_no_conflict(): n = 1 m = 2 requests = [ (1, 3, 1), (4, 6, 1) ] assert can_schedule_meetings(n, m, requests) == \\"YES\\" def test_single_engineer_with_conflict(): n = 1 m = 2 requests = [ (1, 5, 1), (4, 6, 1) ] assert can_schedule_meetings(n, m, requests) == \\"NO\\" def test_multiple_engineers_no_conflict(): n = 3 m = 5 requests = [ (1, 5, 1), (6, 10, 1), (5, 8, 2), (2, 5, 3), (8, 9, 3) ] assert can_schedule_meetings(n, m, requests) == \\"YES\\" def test_multiple_engineers_with_conflict(): n = 2 m = 3 requests = [ (1, 4, 1), (2, 3, 1), (4, 5, 2) ] assert can_schedule_meetings(n, m, requests) == \\"NO\\" def test_no_meetings(): n = 3 m = 0 requests = [] assert can_schedule_meetings(n, m, requests) == \\"YES\\" def test_overlapping_meetings_different_engineers(): n = 2 m = 2 requests = [ (1, 5, 1), (1, 5, 2) ] assert can_schedule_meetings(n, m, requests) == \\"YES\\" def test_multiple_operations(): n = 3 m = 6 requests = [ (1, 4, 1), (4, 7, 1), (2, 5, 2), (5, 8, 2), (3, 6, 3), (6, 9, 3) ] assert can_schedule_meetings(n, m, requests) == \\"YES\\" def test_unordered_meetings(): n = 3 m = 5 requests = [ (5, 8, 2), (1, 5, 1), (6, 10, 1), (8, 9, 3), (2, 5, 3) ] assert can_schedule_meetings(n, m, requests) == \\"YES\\"","solution":"def can_schedule_meetings(n, m, requests): from collections import defaultdict # Dictionary to hold the intervals for each engineer engineer_meetings = defaultdict(list) # Populate the dictionary with requests for start, end, engineer in requests: engineer_meetings[engineer].append((start, end)) # Check for conflicts for each engineer for engineer in engineer_meetings: sorted_meetings = sorted(engineer_meetings[engineer]) for i in range(1, len(sorted_meetings)): # If the start time of the current meeting is less than the end time of the previous, there's a conflict if sorted_meetings[i][0] < sorted_meetings[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def count_replacements_to_single_digit(X): Returns the number of replacements required to reduce the integer X to a single-digit number by summing its digits. pass def process_test_cases(test_cases): Process a list of test cases and return the results. Each test case is an integer X, and the output is the number of replacements required to make X a single-digit number. pass # Unit tests def test_single_digit_no_replacement(): assert count_replacements_to_single_digit(5) == 0 def test_multiple_replacements(): assert count_replacements_to_single_digit(57) == 2 def test_multiple_replacements_large_number(): assert count_replacements_to_single_digit(999) == 2 def test_one_replacement(): assert count_replacements_to_single_digit(45) == 1 def test_process_test_cases(): assert process_test_cases([57, 999, 1234]) == [2, 2, 2] def test_large_number(): assert count_replacements_to_single_digit(1000000) == 1 def test_zero(): assert count_replacements_to_single_digit(0) == 0 def test_process_test_cases_mixed(): assert process_test_cases([1, 10, 57, 1234, 1000000]) == [0, 1, 2, 2, 1]","solution":"def count_replacements_to_single_digit(X): Returns the number of replacements required to reduce the integer X to a single-digit number by summing its digits. replacements = 0 while X >= 10: X = sum(int(digit) for digit in str(X)) replacements += 1 return replacements def process_test_cases(test_cases): Process a list of test cases and return the results. Each test case is an integer X, and the output is the number of replacements required to make X a single-digit number. results = [] for X in test_cases: results.append(count_replacements_to_single_digit(X)) return results"},{"question":"from typing import List def max_sum(matrix: List[List[int]]) -> int: Given an n x n matrix filled with integers, find the maximum sum of any row, column, or diagonal within the matrix. >>> max_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 24 >>> max_sum([ ... [1, 1, 1], ... [10, 10, 10], ... [2, 2, 2] ... ]) 30 >>> max_sum([ ... [1, 10, 1], ... [1, 10, 1], ... [1, 10, 1] ... ]) 30 >>> max_sum([ ... [10, 1, 1], ... [2, 10, 2], ... [3, 3, 10] ... ]) 30 >>> max_sum([ ... [1, 1, 10], ... [2, 10, 2], ... [10, 3, 3] ... ]) 30 >>> max_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) -6","solution":"from typing import List def max_sum(matrix: List[List[int]]) -> int: n = len(matrix) max_sum_result = float('-inf') # Calculate row and column sums for i in range(n): row_sum = sum(matrix[i]) col_sum = sum(matrix[j][i] for j in range(n)) max_sum_result = max(max_sum_result, row_sum, col_sum) # Calculate main diagonal (top-left to bottom-right) main_diagonal_sum = sum(matrix[i][i] for i in range(n)) max_sum_result = max(max_sum_result, main_diagonal_sum) # Calculate anti-diagonal (top-right to bottom-left) anti_diagonal_sum = sum(matrix[i][n-1-i] for i in range(n)) max_sum_result = max(max_sum_result, anti_diagonal_sum) return max_sum_result"},{"question":"def sum_special_elements(matrix, m, n): Returns the sum of all elements in the matrix where the row and column indices are either both even or both odd. >>> sum_special_elements([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 3, 3) == 25 >>> sum_special_elements([ ... [0, 1, 2, 3], ... [4, 5, 6, 7] ... ], 2, 4) == 14 >>> sum_special_elements([ ... [7] ... ], 1, 1) == 7 >>> sum_special_elements([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ], 3, 3) == 0 >>> sum_special_elements([ ... [1000000000, 2, 1000000000], ... [4, 1000000000, 6], ... [1000000000, 8, 1000000000] ... ], 3, 3) == 5000000000","solution":"def sum_special_elements(matrix, m, n): Returns the sum of all elements in the matrix where the row and column indices are either both even or both odd. total_sum = 0 for i in range(m): for j in range(n): if (i % 2 == 0 and j % 2 == 0) or (i % 2 == 1 and j % 2 == 1): total_sum += matrix[i][j] return total_sum"},{"question":"def minModifyCells(grid: List[List[int]]) -> int: Given an m x n integer grid, find the minimum number of cells that need to be modified to identify a path from top-left to bottom-right corner. You can modify at most one cell to make the path exist if it doesn't exist initially. The modified cell can be changed to any integer in the range [0, 1000]. Parameters: grid (List[List[int]]): The m x n grid of integers. Returns: int: The minimum number of cells to be modified, or -1 if no such path exists. >>> minModifyCells([ ... [1, 1, -1], ... [-1, 1, 1], ... [2, 2, 1] ... ]) 0 >>> minModifyCells([ ... [1, 1, -1], ... [-1, -1, 1], ... [2, 2, 1] ... ]) 1 >>> minModifyCells([ ... [-1, -1], ... [-1, -1] ... ]) -1","solution":"def minModifyCells(grid): m, n = len(grid), len(grid[0]) # A helper function to check if a path exists from (0, 0) to (m-1, n-1) without any modifications def check_path(): if grid[0][0] == -1: return False visited = [[False]*n for _ in range(m)] stack = [(0, 0)] visited[0][0] = True while stack: x, y = stack.pop() if x == m-1 and y == n-1: return True for dx, dy in [(1, 0), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != -1 and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) return False # If an initial path exists without any modification if check_path(): return 0 # Try modifying each cell once and check if a path can be created for i in range(m): for j in range(n): if grid[i][j] == -1: # consider only the cells that are blocked grid[i][j] = 0 if check_path(): return 1 grid[i][j] = -1 # backtrack # If no path can be created by modifying at most one cell return -1"},{"question":"def min_sticks_to_form_triangle(N: int, sticks: List[int]) -> int: Returns the minimum number of sticks that need to be added so that any three sticks can form a triangle. >>> min_sticks_to_form_triangle(3, [4, 5, 10]) 1 >>> min_sticks_to_form_triangle(3, [3, 4, 5]) 0 >>> min_sticks_to_form_triangle(1, [7]) 2 >>> min_sticks_to_form_triangle(0, []) 3 >>> min_sticks_to_form_triangle(5, [2, 2, 2, 2, 2]) 0","solution":"def min_sticks_to_form_triangle(N, sticks): Returns the minimum number of sticks that need to be added so that any three sticks can form a triangle. if N >= 3: sticks.sort() if sticks[-1] >= sticks[-2] + sticks[-3]: return 1 return max(0, 3 - N)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list while minimizing memory usage. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. Examples: >>> list_to_linked_list([1, 2, 3, 4, 5]) 1 -> 2 -> 3 -> 4 -> 5 -> None >>> reverse_linked_list(head) 5 -> 4 -> 3 -> 2 -> 1 -> None >>> list_to_linked_list([1]) 1 -> None >>> reverse_linked_list(head) 1 -> None >>> list_to_linked_list([]) None >>> reverse_linked_list(head) None pass def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for item in lst[1:]: current.next = ListNode(item) current = current.next return head def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current: next_temp = current.next # Store next node current.next = prev # Reverse the link prev = current # Move prev to current current = next_temp # Proceed to next node return prev"},{"question":"def sum_acute_angles(angle_str): Write a function that takes a string containing varying angles in degrees (as float values) and outputs the sum of all acute angles. An angle is considered acute if it is greater than 0 degrees and less than 90 degrees. The input string will have each angle separated by a space. Returns the sum of all acute angles (0 < angle < 90) from the given string of angles. >>> sum_acute_angles(\\"30.5 45 90 120.75\\") == 75.5 >>> sum_acute_angles(\\"85 95 15 10\\") == 110 >>> sum_acute_angles(\\"90 180 270\\") == 0","solution":"def sum_acute_angles(angle_str): Returns the sum of all acute angles (0 < angle < 90) from the given string of angles. angles = map(float, angle_str.split()) acute_angles_sum = sum(angle for angle in angles if 0 < angle < 90) return acute_angles_sum"},{"question":"def sort_books(books): Sorts the books first by publication year and then by title lexicographically for books with the same year. Parameters: books (list of tuples): A list of tuples where each tuple contains a year (int) and a title (str). Returns: list: A list of book titles sorted as per the described order. from solution import sort_books def test_sort_books_multiple_entries(): books = [ (1993, \\"TheAlchemist\\"), (2023, \\"DeepLearning\\"), (1993, \\"JurassicPark\\"), (2023, \\"ArtificialIntelligence\\") ] expected = [ \\"JurassicPark\\", \\"TheAlchemist\\", \\"ArtificialIntelligence\\", \\"DeepLearning\\" ] assert sort_books(books) == expected def test_sort_books_same_year_different_titles(): books = [ (2021, \\"Zebra\\"), (2021, \\"Apple\\"), (2021, \\"Mango\\") ] expected = [ \\"Apple\\", \\"Mango\\", \\"Zebra\\" ] assert sort_books(books) == expected def test_sort_books_different_years(): books = [ (2000, \\"BookA\\"), (1999, \\"BookB\\"), (2022, \\"BookC\\"), (2010, \\"BookD\\") ] expected = [ \\"BookB\\", \\"BookA\\", \\"BookD\\", \\"BookC\\" ] assert sort_books(books) == expected def test_sort_books_single_entry(): books = [ (1995, \\"SingleBook\\") ] expected = [ \\"SingleBook\\" ] assert sort_books(books) == expected def test_sort_books_all_same_year_and_title(): books = [ (2023, \\"SameBook\\"), (2023, \\"SameBook\\"), (2023, \\"SameBook\\") ] expected = [ \\"SameBook\\", \\"SameBook\\", \\"SameBook\\" ] assert sort_books(books) == expected","solution":"def sort_books(books): Sorts the books first by publication year and then by title lexicographically for books with the same year. Parameters: books (list of tuples): A list of tuples where each tuple contains a year (int) and a title (str). Returns: list: A list of book titles sorted as per the described order. # Sort books by year, then by title lexicographically sorted_books = sorted(books, key=lambda book: (book[0], book[1])) # Extract and return the titles in sorted order sorted_titles = [title for year, title in sorted_books] return sorted_titles"},{"question":"def symmetric_difference(listA, listB): Returns a list containing the symmetric difference of listA and listB, sorted in ascending order. >>> symmetric_difference([1, 2, 3, 4, 5], [4, 5, 6, 7, 8]) [1, 2, 3, 6, 7, 8] >>> symmetric_difference([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> symmetric_difference([1, 2, 3], [1, 2, 3]) [] >>> symmetric_difference([], [1, 2, 3]) [1, 2, 3] >>> symmetric_difference([1, 1, 2, 2, 3, 3], [3, 4, 4, 5, 5]) [1, 2, 4, 5]","solution":"def symmetric_difference(listA, listB): Returns a list containing the symmetric difference of listA and listB, sorted in ascending order. setA = set(listA) setB = set(listB) sym_diff = list((setA - setB) | (setB - setA)) return sorted(sym_diff)"},{"question":"def process_queries(n, m, tasks, queries): Process a list of queries updating task times or finding the maximum task time. Args: n (int): Number of tasks. m (int): Number of queries. tasks (List[int]): Initial completion times for the tasks. queries (List[List[int]]): List of queries to process. Returns: List[int]: Results for the queries requesting the maximum task time. Example: >>> process_queries(5, 5, [3, 8, 4, 5, 6], [[2], [1, 3, 10], [2], [1, 2, 7], [2]]) [8, 10, 10]","solution":"def process_queries(n, m, tasks, queries): results = [] task_times = tasks[:] for query in queries: if query[0] == 1: # Update task time k, x = query[1], query[2] task_times[k-1] = x elif query[0] == 2: # Find the current maximum completion time current_max = max(task_times) results.append(current_max) return results"},{"question":"def can_escape_dungeon(N, levels, M, moves): Determine if the adventurers can find a path to the exit. Each dataset has the following format: - N: number of levels in the dungeon. - levels: a list of tuples, each containing: - R, C: dimensions of the grid. - grid_lines: list of R strings each of length C representing the grid cells (., #, U, D, S, E). - M: number of moves. - moves: list of tuples containing a direction (U, D, L, R) and a number of steps. The function should return \\"YES\\" if the adventurers can reach the exit, otherwise \\"NO\\". Example: >>> can_escape_dungeon( ... 2, ... [ ... (3, 3, [\\"S..\\", \\".#U\\", \\"..E\\"]), ... (3, 3, [\\"D..\\", \\".#.\\", \\"..E\\"]) ... ], ... 5, ... [(\\"R\\", 2), (\\"D\\", 1), (\\"U\\", 1), (\\"L\\", 2), (\\"R\\", 2)] ... ) \\"YES\\" >>> can_escape_dungeon( ... 3, ... [ ... (5, 5, [\\"S....\\", \\".....\\", \\".....\\", \\".....\\", \\"..U..\\"]), ... (5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\"..D.E\\"]), ... (5, 5, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]), ... ], ... 8, ... [(\\"R\\", 1), (\\"D\\", 4), (\\"R\\", 2), (\\"U\\", 1), (\\"L\\", 2), (\\"R\\", 3), (\\"D\\", 1), (\\"R\\", 1)] ... ) \\"NO\\"","solution":"from collections import deque def parse_input(): dungeons = [] while True: N = int(input()) if N == 0: break levels = [] for _ in range(N): R, C = map(int, input().split()) grid = [input().strip() for _ in range(R)] levels.append((R, C, grid)) M = int(input()) moves = [input().split() for _ in range(M)] for move in moves: move[1] = int(move[1]) dungeons.append((N, levels, M, moves)) return dungeons def find_start_exit(level): start = None exit = None R, C, grid = level for r in range(R): for c in range(C): if grid[r][c] == 'S': start = (r, c) elif grid[r][c] == 'E': exit = (r, c) return start, exit def move_adventurers(start, moves, levels): current_level = 0 current_pos = start for direction, steps in moves: for _ in range(steps): if direction == 'U': # Move Up if current_pos[0] > 0 and levels[current_level][2][current_pos[0] - 1][current_pos[1]] != '#': current_pos = (current_pos[0] - 1, current_pos[1]) elif direction == 'D': # Move Down if current_pos[0] < levels[current_level][0] - 1 and levels[current_level][2][current_pos[0] + 1][current_pos[1]] != '#': current_pos = (current_pos[0] + 1, current_pos[1]) elif direction == 'L': # Move Left if current_pos[1] > 0 and levels[current_level][2][current_pos[0]][current_pos[1] - 1] != '#': current_pos = (current_pos[0], current_pos[1] - 1) elif direction == 'R': # Move Right if current_pos[1] < levels[current_level][1] - 1 and levels[current_level][2][current_pos[0]][current_pos[1] + 1] != '#': current_pos = (current_pos[0], current_pos[1] + 1) # Check that the current position if it is staircase to move levels if levels[current_level][2][current_pos[0]][current_pos[1]] == 'U': if current_level > 0: current_level -= 1 elif levels[current_level][2][current_pos[0]][current_pos[1]] == 'D': if current_level < len(levels) - 1: current_level += 1 # Check if reached the exit if levels[current_level][2][current_pos[0]][current_pos[1]] == 'E': return True return False def can_escape_dungeon(N, levels, M, moves): start, exit = find_start_exit(levels[0]) if not start or not exit: return \\"NO\\" can_escape = move_adventurers(start, moves, levels) return \\"YES\\" if can_escape else \\"NO\\" def main(): dungeons = parse_input() results = [] for N, levels, M, moves in dungeons: result = can_escape_dungeon(N, levels, M, moves) results.append(result) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def count_tshirt_distributions(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Count the number of ways to distribute T-shirts to employees. Args: test_cases: A list of tuples, each containing: - An integer N, the number of employees. - A list of N integers, representing the required T-shirt sizes for each employee. - A list of N integers, representing the available T-shirt sizes in the company. Returns: A list of integers, where each integer represents the number of ways to distribute T-shirts for the corresponding test case. Example: >>> count_tshirt_distributions([(3, [1, 2, 3], [3, 2, 1]), (2, [1, 1], [1, 1])]) [6, 2]","solution":"from itertools import permutations def count_tshirt_distributions(test_cases): results = [] for test in test_cases: N, required, available = test result = 0 for perm in permutations(available): if sorted(perm) == sorted(required): result += 1 results.append(result) return results def parse_input(input_str): lines = input_str.strip().split('n') idx = 0 T = int(lines[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(lines[idx]) idx += 1 required = list(map(int, lines[idx].split())) idx += 1 available = list(map(int, lines[idx].split())) idx += 1 test_cases.append((N, required, available)) return test_cases def main(input_str): test_cases = parse_input(input_str) results = count_tshirt_distributions(test_cases) return \\"n\\".join(map(str, results)) # Example input parsing and processing input_str = 2 3 1 2 3 3 2 1 2 1 1 1 1 print(main(input_str))"},{"question":"def categorize_expenses(expenses, categories): Categorizes the unspecified expenses based on predefined keywords in categories. :param expenses: List of tuples, where each tuple contains (amount, description) :param categories: Dictionary where keys are category names and values are lists of keywords :return: List of tuples of original description and the assigned category >>> categorize_expenses([(150, \\"grocery shopping at Walmart\\"), (200, \\"monthly rent\\"), (50, \\"subway sandwich\\")], {\\"Food\\": [\\"grocery\\", \\"subway\\", \\"restaurant\\"], \\"Housing\\": [\\"rent\\", \\"mortgage\\"]}) [(\\"grocery shopping at Walmart\\", \\"Food\\"), (\\"monthly rent\\", \\"Housing\\"), (\\"subway sandwich\\", \\"Food\\")] >>> categorize_expenses([(300, \\"gym membership\\"), (70, \\"electricity bill\\")], {\\"Utilities\\": [\\"electricity\\", \\"water\\", \\"gas\\"], \\"Health\\": [\\"gym\\"], \\"Other\\": [\\"gaming\\", \\"subscription\\"]}) [(\\"gym membership\\", \\"Health\\"), (\\"electricity bill\\", \\"Utilities\\")]","solution":"def categorize_expenses(expenses, categories): Categorizes the unspecified expenses based on predefined keywords in categories. :param expenses: List of tuples, where each tuple contains (amount, description) :param categories: Dictionary where keys are category names and values are lists of keywords :return: List of tuples of original description and the assigned category categorized_expenses = [] for amount, description in expenses: found_category = \\"Uncategorized\\" for category, keywords in categories.items(): if any(keyword in description for keyword in keywords): found_category = category break categorized_expenses.append((description, found_category)) return categorized_expenses"},{"question":"def most_popular_station(n: int, m: int, tickets: List[Tuple[int, int]]) -> int: Determine the station that is present on the maximum number of tickets. >>> most_popular_station(5, 3, [(1, 3), (2, 4), (1, 5)]) 2 >>> most_popular_station(2, 1, [(1, 2)]) 1","solution":"def most_popular_station(n, m, tickets): station_coverage = [0] * (n + 1) # array to track coverage of each station for a, b in tickets: for i in range(a, b + 1): station_coverage[i] += 1 max_coverage = max(station_coverage) for i in range(1, n + 1): if station_coverage[i] == max_coverage: return i # Example usage n, m = 5, 3 tickets = [(1, 3), (2, 4), (1, 5)] print(most_popular_station(n, m, tickets)) # Output: 2"},{"question":"def is_palindrome(n: int) -> int: Determines if the given number n is a palindrome. Args: n: An integer representing the number to check Returns: 1 if n is a palindrome, 0 otherwise >>> is_palindrome(121) 1 >>> is_palindrome(123) 0","solution":"def is_palindrome(n): Determines if the given number n is a palindrome. Args: n: An integer Returns: 1 if n is a palindrome, 0 otherwise str_n = str(n) return 1 if str_n == str_n[::-1] else 0"},{"question":"from typing import List, Tuple def can_find_three_sum(arr: List[int], k: int) -> str: Determine if there are three distinct elements in the array that sum to k. >>> can_find_three_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> can_find_three_sum([3, 3, 3], 10) \\"NO\\" >>> can_find_three_sum([-1, 2, -3, 4], 0) \\"YES\\" ... def solve(t: int, cases: List[Tuple[int, int, List[int]]]) -> List[str]: Solve multiple test cases for the three sum problem. ... # Unit tests def test_example_case_1(): cases = [ (5, 9, [1, 2, 3, 4, 5]), (3, 10, [3, 3, 3]), (4, 0, [-1, 2, -3, 4]) ] assert solve(3, cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_no_possibility(): cases = [ (3, 100, [1, 2, 3]), (4, 7, [1, 1, 1, 1]) ] assert solve(2, cases) == [\\"NO\\", \\"NO\\"] def test_single_possible_combination(): cases = [ (5, 6, [5, 5, 1, 0, 9]) ] assert solve(1, cases) == [\\"YES\\"] def test_multiple_possible_combinations(): cases = [ (6, 6, [1, 2, 3, 4, 0, -1]) ] assert solve(1, cases) == [\\"YES\\"] def test_negative_values(): cases = [ (5, -6, [-1, -2, -3, -4, -5]) ] assert solve(1, cases) == [\\"YES\\"]","solution":"def can_find_three_sum(arr, k): n = len(arr) arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return \\"YES\\" elif current_sum < k: left += 1 else: right -= 1 return \\"NO\\" def solve(t, cases): results = [] for case in cases: n, k, arr = case results.append(can_find_three_sum(arr, k)) return results"},{"question":"def classify_sentences(positive_keywords, negative_keywords, reviews): Classifies each sentence in the reviews as positive, negative, or neutral based on certain keywords. Args: positive_keywords (List[str]): List of positive keywords. negative_keywords (List[str]): List of negative keywords. reviews (List[List[str]]): List containing reviews with sentences. Returns: List[List[str]]: Nested list containing classification for each sentence. >>> classify_sentences([\\"happy\\", \\"love\\", \\"excellent\\"], [\\"poor\\", \\"bad\\"], [[\\"I love this product.\\", \\"The service was excellent.\\", \\"The delivery was poor.\\"], [\\"This makes me happy.\\", \\"The item is bad.\\"]]) [['positive', 'positive', 'negative'], ['positive', 'negative']] >>> classify_sentences([\\"amazing\\", \\"fantastic\\"], [\\"horrible\\", \\"terrible\\"], [[\\"The movie was fantastic.\\", \\"The food was horrible.\\"], [\\"It was an ordinary day.\\"]]) [['positive', 'negative'], ['neutral']] >>> classify_sentences([\\"good\\"], [\\"bad\\"], [[\\"It is a day.\\"]]) [['neutral']] >>> classify_sentences([\\"great\\"], [\\"awful\\"], [[\\"The performance was great.\\", \\"The weather is awful.\\", \\"The seats were comfortable but nothing more.\\", \\"It's sunny and warm\\"]]) [['positive', 'negative', 'neutral', 'neutral']] >>> classify_sentences([\\"happy\\", \\"love\\"], [\\"bad\\", \\"sad\\"], [[\\"I am happy.\\", \\"This is sad.\\"], [\\"We love to play games.\\", \\"This is a neutral statement.\\"]]) [['positive', 'negative'], ['positive', 'neutral']]","solution":"def classify_sentences(positive_keywords, negative_keywords, reviews): Classifies each sentence in the reviews as positive, negative, or neutral. Args: positive_keywords (List[str]): List of positive keywords. negative_keywords (List[str]): List of negative keywords. reviews (List[List[str]]): List containing reviews with sentences. Returns: List[List[str]]: Nested list containing classification for each sentence. classifications = [] for review in reviews: review_classifications = [] for sentence in review: is_positive = any(word in sentence for word in positive_keywords) is_negative = any(word in sentence for word in negative_keywords) if is_positive: review_classifications.append(\\"positive\\") elif is_negative: review_classifications.append(\\"negative\\") else: review_classifications.append(\\"neutral\\") classifications.append(review_classifications) return classifications"},{"question":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.next = None def connectLevels(root): Given a binary tree, connect nodes that are on the same level from left to right. Each level should be connected as a singly linked list. Example: Input: 1 / 2 3 / / 4 5 6 7 Output: Levels connected as linked lists: Level 1: 1 Level 2: 2 -> 3 Level 3: 4 -> 5 -> 6 -> 7 Example: Input: 10 / 5 20 / 3 30 Output: Levels connected as linked lists: Level 1: 10 Level 2: 5 -> 20 Level 3: 3 -> 30 >>> root = TreeLinkNode(1) >>> root.left = TreeLinkNode(2) >>> root.right = TreeLinkNode(3) >>> root.left.left = TreeLinkNode(4) >>> root.left.right = TreeLinkNode(5) >>> root.right.left = TreeLinkNode(6) >>> root.right.right = TreeLinkNode(7) >>> connectLevels(root) >>> root.left.next == root.right True >>> root.left.left.next == root.left.right True >>> root.left.right.next == root.right.left True from solution import TreeLinkNode, connectLevels def test_connect_levels_1(): root = TreeLinkNode(1) root.left = TreeLinkNode(2) root.right = TreeLinkNode(3) root.left.left = TreeLinkNode(4) root.left.right = TreeLinkNode(5) root.right.left = TreeLinkNode(6) root.right.right = TreeLinkNode(7) connectLevels(root) assert root.next is None assert root.left.next == root.right assert root.right.next is None assert root.left.left.next == root.left.right assert root.left.right.next == root.right.left assert root.right.left.next == root.right.right assert root.right.right.next is None def test_connect_levels_2(): root = TreeLinkNode(10) root.left = TreeLinkNode(5) root.right = TreeLinkNode(20) root.left.left = TreeLinkNode(3) root.right.right = TreeLinkNode(30) connectLevels(root) assert root.next is None assert root.left.next == root.right assert root.right.next is None assert root.left.left.next == root.right.right assert root.right.right.next is None def test_single_node(): root = TreeLinkNode(1) connectLevels(root) assert root.next is None def test_empty_tree(): root = None connectLevels(root) assert root is None","solution":"class TreeLinkNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.next = None def connectLevels(root): if not root: return None # Initialize the current level with the root node current_level = [root] while current_level: next_level = [] for i in range(len(current_level)): if i < len(current_level) - 1: current_level[i].next = current_level[i + 1] if current_level[i].left: next_level.append(current_level[i].left) if current_level[i].right: next_level.append(current_level[i].right) current_level = next_level return root"},{"question":"class User: def __init__(self, user_id, name): Initialize a user with a unique ID and a name. >>> user = User(1, 'Alice') >>> user.user_id 1 >>> user.name 'Alice' self.user_id = user_id self.name = name self.borrowed_books = [] class Book: def __init__(self, isbn, title): Initialize a book with a unique ISBN and a title. >>> book = Book('123456', 'The Great Gatsby') >>> book.isbn '123456' >>> book.title 'The Great Gatsby' self.isbn = isbn self.title = title self.borrowed_by = None class Library: def __init__(self): Initialize the library with dictionaries to store users and books. >>> library = Library() >>> library.users {} >>> library.books {} self.users = {} self.books = {} def add_user(self, user_id, name): Add a new user to the library. >>> library = Library() >>> library.add_user(1, \\"Alice\\") >>> 1 in library.users True >>> library.users[1].name 'Alice' self.users[user_id] = User(user_id, name) def add_book(self, isbn, title): Add a new book to the library. >>> library = Library() >>> library.add_book(\\"123456\\", \\"The Great Gatsby\\") >>> '123456' in library.books True >>> library.books['123456'].title 'The Great Gatsby' self.books[isbn] = Book(isbn, title) def borrow_book(self, user_id, isbn): Allow a user to borrow a book if it's available. >>> library = Library() >>> library.add_user(1, \\"Alice\\") >>> library.add_book(\\"123456\\", \\"The Great Gatsby\\") >>> library.borrow_book(1, \\"123456\\") 'Book borrowed successfully' >>> library.books[\\"123456\\"].borrowed_by 1 user = self.users.get(user_id) book = self.books.get(isbn) if user and book and book.borrowed_by is None: book.borrowed_by = user_id user.borrowed_books.append(isbn) return \\"Book borrowed successfully\\" return \\"Cannot borrow book\\" def return_book(self, user_id, isbn): Allow a user to return a borrowed book. >>> library = Library() >>> library.add_user(1, \\"Alice\\") >>> library.add_book(\\"123456\\", \\"The Great Gatsby\\") >>> library.borrow_book(1, \\"123456\\") >>> library.return_book(1, \\"123456\\") 'Book returned successfully' >>> library.books[\\"123456\\"].borrowed_by is None True user = self.users.get(user_id) book = self.books.get(isbn) if user and book and book.borrowed_by == user_id: book.borrowed_by = None user.borrowed_books.remove(isbn) return \\"Book returned successfully\\" return \\"Cannot return book\\" def book_status(self, isbn): Check the borrowing status of a book. >>> library = Library() >>> library.add_book(\\"123456\\", \\"The Great Gatsby\\") >>> library.book_status(\\"123456\\") 'Book is available' >>> library.add_user(1, \\"Alice\\") >>> library.borrow_book(1, \\"123456\\") >>> library.book_status(\\"123456\\") 'Book is borrowed by user 1' book = self.books.get(isbn) if book and book.borrowed_by: return f\\"Book is borrowed by user {book.borrowed_by}\\" return \\"Book is available\\"","solution":"class User: def __init__(self, user_id, name): self.user_id = user_id self.name = name self.borrowed_books = [] class Book: def __init__(self, isbn, title): self.isbn = isbn self.title = title self.borrowed_by = None class Library: def __init__(self): self.users = {} self.books = {} def add_user(self, user_id, name): self.users[user_id] = User(user_id, name) def add_book(self, isbn, title): self.books[isbn] = Book(isbn, title) def borrow_book(self, user_id, isbn): user = self.users.get(user_id) book = self.books.get(isbn) if user and book and book.borrowed_by is None: book.borrowed_by = user_id user.borrowed_books.append(isbn) return \\"Book borrowed successfully\\" return \\"Cannot borrow book\\" def return_book(self, user_id, isbn): user = self.users.get(user_id) book = self.books.get(isbn) if user and book and book.borrowed_by == user_id: book.borrowed_by = None user.borrowed_books.remove(isbn) return \\"Book returned successfully\\" return \\"Cannot return book\\" def book_status(self, isbn): book = self.books.get(isbn) if book and book.borrowed_by: return f\\"Book is borrowed by user {book.borrowed_by}\\" return \\"Book is available\\" # Example usage library = Library() library.add_user(1, \\"Alice\\") library.add_book(\\"123456\\", \\"The Great Gatsby\\") print(library.borrow_book(1, \\"123456\\")) # Output: \\"Book borrowed successfully\\" print(library.book_status(\\"123456\\")) # Output: \\"Book is borrowed by user 1\\" print(library.return_book(1, \\"123456\\")) # Output: \\"Book returned successfully\\" print(library.book_status(\\"123456\\")) # Output: \\"Book is available\\""},{"question":"from typing import List def smallest_subarray_with_divisible(nums: List[int], d: int) -> int: Finds the size of the smallest subarray that contains at least one element that is divisible by d. If no such subarray exists, returns -1. >>> smallest_subarray_with_divisible([3, 5, 7, 9], 3) 1 >>> smallest_subarray_with_divisible([1, 2, 4, 5], 6) -1 >>> smallest_subarray_with_divisible([2, 4, 6, 8, 10], 5) 1 >>> smallest_subarray_with_divisible([1, 1, 1, 1], 1) 1 >>> smallest_subarray_with_divisible([7, 14, 28, 35], 7) 1 >>> smallest_subarray_with_divisible([11, 13, 17, 19], 2) -1","solution":"def smallest_subarray_with_divisible(nums, d): Finds the size of the smallest subarray that contains at least one element that is divisible by d. If no such subarray exists, returns -1. for index, num in enumerate(nums): if num % d == 0: return 1 return -1"},{"question":"def exists_pair_with_sum(arr, target): Determines if there exist two distinct indices such that the elements at those indices sum up to the target value. >>> exists_pair_with_sum([2, 7, 11, 15], 9) \\"YES\\" >>> exists_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> exists_pair_with_sum([1, 2, 3, 4, 4, 5], 8) \\"YES\\" def evaluate_test_cases(test_cases): Evaluates multiple test cases. >>> evaluate_test_cases([(4, [2, 7, 11, 15], 9),(5, [1, 2, 3, 4, 5], 10), (6, [1, 2, 3, 4, 4, 5], 8)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> evaluate_test_cases([(4, [2, 7, 11, 15], 9), (1, [1], 2)]) [\\"YES\\", \\"NO\\"] def test_exists_pair_with_sum(): assert exists_pair_with_sum([2, 7, 11, 15], 9) == \\"YES\\" assert exists_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"NO\\" assert exists_pair_with_sum([1, 2, 3, 4, 4, 5], 8) == \\"YES\\" assert exists_pair_with_sum([1], 2) == \\"NO\\" # edge case with single element def test_evaluate_test_cases(): test_cases = [ (4, [2, 7, 11, 15], 9), (5, [1, 2, 3, 4, 5], 10), (6, [1, 2, 3, 4, 4, 5], 8) ] assert evaluate_test_cases(test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] test_cases_with_edge_case = [ (4, [2, 7, 11, 15], 9), (5, [1, 2, 3, 4, 5], 10), (6, [1, 2, 3, 4, 4, 5], 8), (1, [1], 2) ] assert evaluate_test_cases(test_cases_with_edge_case) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def test_edge_cases(): assert exists_pair_with_sum([], 10) == \\"NO\\" # Empty array, edge case assert exists_pair_with_sum([5, 5], 10) == \\"YES\\" # Smallest valid array assert exists_pair_with_sum([1, 1, 1, 1, 1, 1], 2) == \\"YES\\" # All elements same assert exists_pair_with_sum([1, 1, 1, 1, 1, 1], 3) == \\"NO\\" # All elements same, target not achievable test_exists_pair_with_sum() test_evaluate_test_cases() test_edge_cases()","solution":"def exists_pair_with_sum(arr, target): Determines if there exist two distinct indices such that the elements at those indices sum up to the target value. seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def evaluate_test_cases(test_cases): Evaluates multiple test cases. result = [] for n, arr, target in test_cases: result.append(exists_pair_with_sum(arr, target)) return result"},{"question":"def next_permutation(s: str) -> str: Given a string s, return the next lexicographical permutation of the string. If such a permutation does not exist, return the smallest permutation. def solve(T, strings): For each string in the list, return the next lexicographical permutation. If such a permutation does not exist, return the smallest permutation. Args: T (int): number of test cases strings (List[str]): list of strings Returns: List[str]: list of resulting permutations for the input strings # Example test cases if __name__ == \\"__main__\\": assert next_permutation(\\"ab\\") == \\"ba\\" assert next_permutation(\\"dcba\\") == \\"abcd\\" assert next_permutation(\\"aabb\\") == \\"abab\\" assert solve(3, [\\"ab\\", \\"dcba\\", \\"aabb\\"]) == [\\"ba\\", \\"abcd\\", \\"abab\\"] assert solve(2, [\\"abc\\", \\"acb\\"]) == [\\"acb\\", \\"bac\\"] print(\\"All tests passed.\\")","solution":"def next_permutation(s: str) -> str: Given a string s, return the next lexicographical permutation of the string. If such a permutation does not exist, return the smallest permutation. s = list(s) n = len(s) # Find the pivot point for i in range(n - 2, -1, -1): if s[i] < s[i + 1]: break else: s.sort() # if no pivot was found, return the smallest permutation return ''.join(s) # Find the rightmost element that is larger than s[i] for j in range(n - 1, i, -1): if s[j] > s[i]: break s[i], s[j] = s[j], s[i] # Swap the pivot with this element s = s[:i+1] + sorted(s[i+1:]) # Reverse the part of the string after the pivot return ''.join(s) def solve(T, strings): result = [] for s in strings: result.append(next_permutation(s)) return result"},{"question":"from typing import List, Tuple def find_closest_pair(nums: List[int], k: int) -> Tuple[int, int]: Find two distinct elements from the list such that their sum is closest to K. If there are multiple pairs with the same difference from K, return the pair with the smallest first value. If there is still a tie, select the pair with the smallest second value. >>> find_closest_pair([1, 2, 3, 4, 5], 10) (4, 5) >>> find_closest_pair([-1, 2, 1, -4], 1) (-1, 2) >>> find_closest_pair([5, 1, 3, 5], 8) (3, 5) pass # Your implementation here def process_test_cases(test_cases: List[Tuple[List[int], int]]) -> List[Tuple[int, int]]: Process a list of test cases to find the closest pair for each case. >>> process_test_cases([([1, 2, 3, 4, 5], 10), ([-1, 2, 1, -4], 1), ([5, 1, 3, 5], 8)]) [(4, 5), (-1, 2), (3, 5)] pass # Your implementation here","solution":"def find_closest_pair(nums, k): nums.sort() left, right = 0, len(nums) - 1 closest_pair = (float('inf'), float('inf')) closest_diff = float('inf') while left < right: current_sum = nums[left] + nums[right] current_diff = abs(current_sum - k) if current_diff < closest_diff or (current_diff == closest_diff and (nums[left], nums[right]) < closest_pair): closest_diff = current_diff closest_pair = (nums[left], nums[right]) if current_sum < k: left += 1 else: right -= 1 return closest_pair def process_test_cases(test_cases): results = [] for nums, k in test_cases: result = find_closest_pair(nums, k) results.append(result) return results"},{"question":"class Node: A Node structure to represent a node in a binary tree. def __init__(self, data): self.data = data self.left = None self.right = None def minDepthSum(root): Finds the sum of all nodes at minimum depth in a binary tree. Examples: >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> minDepthSum(root) 5 >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> minDepthSum(root) 3 from solution import Node, minDepthSum def test_minDepthSum_case1(): # Tree: # 1 # / # 2 3 root = Node(1) root.left = Node(2) root.right = Node(3) assert minDepthSum(root) == 5 def test_minDepthSum_case2(): # Tree: # 1 # / # 2 3 #/ #4 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) assert minDepthSum(root) == 3 def test_minDepthSum_single_node(): # Tree: # 1 root = Node(1) assert minDepthSum(root) == 1 def test_minDepthSum_empty(): assert minDepthSum(None) == 0 def test_minDepthSum_deeper_leaves(): # Tree: # 1 # / # 2 3 # # 4 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) assert minDepthSum(root) == 3 def test_minDepthSum_multiple_levels(): # Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) assert minDepthSum(root) == 3","solution":"class Node: A Node structure to represent a node in a binary tree. def __init__(self, data): self.data = data self.left = None self.right = None def minDepthSum(root): Finds the sum of all nodes at minimum depth in a binary tree. if not root: return 0 from collections import deque # Level order traversal using a queue queue = deque([(root, 1)]) current_level = 0 level_sum = 0 while queue: node, level = queue.popleft() if node.left is None and node.right is None: # If it's the first time reaching this depth, reset the sum if current_level == 0: current_level = level level_sum = node.data # If at the current minimum depth, accumulate the sum elif current_level == level: level_sum += node.data # If a lesser depth than has been seen, we can break early else: break if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return level_sum"},{"question":"def longestIncreasingPath(grid: List[List[int]]) -> int: Compute the length of the longest increasing path in the grid. Each step must move to one of the 4 directly neighboring cells (up, down, left, right), and the value in the next cell must be strictly greater than the value in the current cell. :param grid: List of Lists containing non-negative integers representing the grid. :return: The length of the longest increasing path. >>> longestIncreasingPath([ [9, 9, 4, 3], [6, 6, 8, 5], [1, 1, 1, 2] ]) 4 >>> longestIncreasingPath([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 1 >>> longestIncreasingPath([ [1, 2, 3, 4, 5] ]) 5 >>> longestIncreasingPath([ [1], [2], [3], [4], [5] ]) 5 >>> longestIncreasingPath([ [1, 2], [4, 3] ]) 4 >>> longestIncreasingPath([ [7, 8, 9], [6, 1, 2], [5, 4, 3] ]) 9 >>> longestIncreasingPath([ [42] ]) 1","solution":"def longestIncreasingPath(grid): if not grid: return 0 n, m = len(grid), len(grid[0]) dp = [[-1] * m for _ in range(n)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_path = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > grid[x][y]: max_path = max(max_path, 1 + dfs(nx, ny)) dp[x][y] = max_path return max_path max_length = 0 for i in range(n): for j in range(m): max_length = max(max_length, dfs(i, j)) return max_length"},{"question":"def min_snow_clearing(n, roads): Calculate the minimum amount of snow that needs to be cleared so that the roads form the MST. Parameters: n (int): Number of cities roads (list of tuple): Each tuple contains three integers (u, v, w) representing a road connecting city u and city v with weight w Returns: int: The minimum amount of snow that needs to be cleared >>> min_snow_clearing(4, [(1, 2, 5), (2, 3, 1), (2, 4, 3)]) 9 >>> min_snow_clearing(5, [(1, 2, 4), (1, 3, 2), (3, 4, 8), (3, 5, 3)]) 17","solution":"def min_snow_clearing(n, roads): Calculate the minimum amount of snow that needs to be cleared so that the roads form the MST. Parameters: n (int): Number of cities roads (list of tuple): Each tuple contains three integers (u, v, w) representing a road connecting city u and city v with weight w Returns: int: The minimum amount of snow that needs to be cleared return sum([w for u, v, w in roads]) # Example usage: # roads = [(1, 2, 5), (2, 3, 1), (2, 4, 3)] # print(min_snow_clearing(4, roads)) # Output: 9"},{"question":"from typing import List def minimumDifference(values: List[int]) -> int: Determine the minimum possible difference between the sums of any two subsets formed from a list of item values. >>> minimumDifference([1, 2, 3, 9]) 3 >>> minimumDifference([1, 2, 7, 1, 5]) 0 >>> minimumDifference([3, 1, 4, 2, 2, 1]) 1","solution":"from typing import List def minimumDifference(values: List[int]) -> int: total_sum = sum(values) target = total_sum // 2 n = len(values) # dp[j] will be True if there's a subset with sum j dp = [False] * (target + 1) dp[0] = True for value in values: for j in range(target, value - 1, -1): dp[j] = dp[j] or dp[j - value] # Find the largest j such that dp[j] is True for j in range(target, -1, -1): if dp[j]: best_partition_sum = j break return total_sum - 2 * best_partition_sum"},{"question":"def find_min_in_rotated_sorted_array(arr): Returns the smallest element in a rotated sorted array. Args: arr (List[int]): Rotated sorted array which may include duplicates. Returns: int: The smallest element in the array. Examples: >>> find_min_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) 0 >>> find_min_in_rotated_sorted_array([2, 2, 2, 0, 1]) 0 >>> find_min_in_rotated_sorted_array([1, 1, 1, 1, 1, 1]) 1 >>> find_min_in_rotated_sorted_array([1, 3, 3, 1]) 1 import pytest def test_example_1(): assert find_min_in_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) == 0 def test_example_2(): assert find_min_in_rotated_sorted_array([2, 2, 2, 0, 1]) == 0 def test_example_3(): assert find_min_in_rotated_sorted_array([1, 1, 1, 1, 1, 1]) == 1 def test_example_4(): assert find_min_in_rotated_sorted_array([1, 3, 3, 1]) == 1 def test_single_element(): assert find_min_in_rotated_sorted_array([3]) == 3 def test_all_elements_same(): assert find_min_in_rotated_sorted_array([5, 5, 5, 5, 5]) == 5 def test_rotated_at_end(): assert find_min_in_rotated_sorted_array([9, 9, 9, 1, 9]) == 1","solution":"def find_min_in_rotated_sorted_array(arr): Returns the smallest element in a rotated sorted array. # Initialize the left and right pointers left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[right]: left = mid + 1 elif arr[mid] < arr[right]: right = mid else: # When arr[mid] == arr[right], we can't decide the smallest is in the left half or right half. # So we just decrement right to make the array smaller and narrow down. right -= 1 return arr[left]"},{"question":"def minimum_swaps_to_sort(heights): Returns the minimum number of swaps required to sort the list of book heights in non-decreasing order. Parameters: heights (List[int]): List of integers representing the heights of books. Returns: int: Minimum number of swaps required. >>> minimum_swaps_to_sort([4, 3, 1, 2, 5]) 3 >>> minimum_swaps_to_sort([3, 1, 2]) 2","solution":"def minimum_swaps_to_sort(heights): Returns the minimum number of swaps required to sort the list of book heights in non-decreasing order. n = len(heights) arrpos = [(heights[i], i) for i in range(n)] arrpos.sort() visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"from typing import List def longest_common_prefix(words: List[str]) -> str: Find and return the longest common prefix shared among all the words in the array. If there is no common prefix, return an empty string. Args: words (List[str]): A list of strings where each string represents a word. Returns: str: The longest common prefix. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" def process_test_cases(test_cases: List[List[str]]) -> List[str]: Process each test case and return the longest common prefix for each case. Args: test_cases (List[List[str]]): A list of test cases where each test case is a list of strings. Returns: List[str]: A list of longest common prefixes for each test case. >>> process_test_cases([[\\"flower\\", \\"flow\\", \\"flight\\"], [\\"dog\\", \\"racecar\\", \\"car\\"]]) [\\"fl\\", \\"\\"] >>> process_test_cases([[\\"apple\\", \\"ape\\", \\"april\\"], [\\"class\\", \\"clash\\", \\"clay\\"]]) [\\"ap\\", \\"cla\\"] from solution import longest_common_prefix, process_test_cases def test_longest_common_prefix(): assert longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) == \\"fl\\" assert longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) == \\"\\" assert longest_common_prefix([]) == \\"\\" assert longest_common_prefix([\\"single\\"]) == \\"single\\" assert longest_common_prefix([\\"interview\\", \\"intermediate\\", \\"internal\\"]) == \\"inter\\" assert longest_common_prefix([\\"\\", \\"\\"]) == \\"\\" def test_process_test_cases(): assert process_test_cases([[\\"flower\\", \\"flow\\", \\"flight\\"], [\\"dog\\", \\"racecar\\", \\"car\\"]]) == [\\"fl\\", \\"\\"] assert process_test_cases([[], [\\"a\\", \\"a\\", \\"a\\"]]) == [\\"\\", \\"a\\"] assert process_test_cases([[\\"apple\\", \\"ape\\", \\"april\\"], [\\"class\\", \\"clash\\", \\"clay\\"]]) == [\\"ap\\", \\"cla\\"] assert process_test_cases([[\\"lengthy\\", \\"lengthier\\", \\"lengthiest\\"]]) == [\\"length\\"] assert process_test_cases([[\\"a\\", \\"ab\\", \\"abcd\\"], [\\"abc\\", \\"def\\", \\"ghi\\"]]) == [\\"a\\", \\"\\"]","solution":"def longest_common_prefix(words): if not words: return \\"\\" # Sort the array of words words.sort() # Compare the first and the last word in the sorted array first_word = words[0] last_word = words[-1] common_prefix = \\"\\" for i in range(min(len(first_word), len(last_word))): if first_word[i] == last_word[i]: common_prefix += first_word[i] else: break return common_prefix def process_test_cases(test_cases): results = [] for i in range(len(test_cases)): words = test_cases[i] results.append(longest_common_prefix(words)) return results"},{"question":"def canEscape(grid: List[List[int]]) -> bool: Determines if there's a path from the top-left to the bottom-right corner of the grid. :param grid: List of lists of integers representing the maze grid (0 = open, 1 = blocked) :return: True if there is a path, False otherwise >>> canEscape([ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ]) == True >>> canEscape([ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) == False >>> canEscape([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) == False >>> canEscape([ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) == False >>> canEscape([[0]]) == True >>> canEscape([[1]]) == False >>> canEscape([ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0] ]) == True","solution":"from collections import deque def canEscape(grid): Determines if there's a path from the top-left to the bottom-right corner of the grid. :param grid: List of lists of integers representing the maze grid (0 = open, 1 = blocked) :return: True if there is a path, False otherwise if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return False n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n - 1, m - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"def longest_even_subsequence_length(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the length of the longest subsequence that consists only of even numbers for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list containing t tuples, each with an integer N and a list of N integers. Returns: List[int]: A list containing the length of the longest even subsequence for each test case. >>> longest_even_subsequence_length(2, [(6, [1, 2, 4, 6, 5, 7]), (4, [9, 11, 13, 15])]) [3, 0] >>> longest_even_subsequence_length(1, [(4, [9, 11, 13, 15])]) [0] >>> longest_even_subsequence_length(1, [(4, [2, 4, 6, 8])]) [4] from typing import List, Tuple def test_single_case_with_even_numbers(): assert longest_even_subsequence_length(1, [(6, [1, 2, 4, 6, 5, 7])]) == [3] def test_single_case_with_no_even_numbers(): assert longest_even_subsequence_length(1, [(4, [9, 11, 13, 15])]) == [0] def test_single_case_with_all_even_numbers(): assert longest_even_subsequence_length(1, [(4, [2, 4, 6, 8])]) == [4] def test_single_case_with_some_even_numbers(): assert longest_even_subsequence_length(1, [(8, [1, 2, 4, 3, 6, 8, 10, 1])]) == [3] def test_multiple_cases_mixed(): assert longest_even_subsequence_length(2, [(6, [1, 2, 4, 6, 5, 7]), (4, [9, 11, 13, 15])]) == [3, 0]","solution":"def longest_even_subsequence_length(t, test_cases): results = [] for case in test_cases: N, arr = case max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 results.append(max_length) return results # Example Usage t = 2 test_cases = [ (6, [1, 2, 4, 6, 5, 7]), (4, [9, 11, 13, 15]) ] print(longest_even_subsequence_length(t, test_cases))"},{"question":"def process_village_population(T, cases): Processes the population update of villages and answers queries regarding the updated population. Args: T (int): The number of test cases. cases (list of dict): A list where each dict contains information about a single test case consisting of: - 'N' (int) Total number of villages. - 'populations' (list of int): The initial populations of the villages. - 'updates' (list of tuples): Each tuple contains three integers (L, R, P) representing the range of villages (inclusive) and the number of people to increase in that range. - 'queries' (list of int): A list of indices representing the villages to be queried. Returns: list: A list of updated populations for each query across all test cases. >>> T = 1 >>> cases = [{ ... 'N': 5, ... 'populations': [10, 20, 30, 40, 50], ... 'updates': [(1, 3, 10), (0, 2, 5)], ... 'queries': [0, 2, 4] ... }] >>> process_village_population(T, cases) [15, 45, 50] >>> T = 2 >>> cases = [ ... { ... 'N': 5, ... 'populations': [10, 20, 30, 40, 50], ... 'updates': [(1, 3, 10), (0, 2, 5)], ... 'queries': [0, 2, 4] ... }, ... { ... 'N': 3, ... 'populations': [100, 200, 300], ... 'updates': [(0, 2, 50), (1, 1, 100)], ... 'queries': [0, 1, 2] ... } ... ] >>> process_village_population(T, cases) [15, 45, 50, 150, 350, 350] >>> T = 1 >>> cases = [{ ... 'N': 4, ... 'populations': [5, 10, 15, 20], ... 'updates': [], ... 'queries': [0, 1, 2, 3] ... }] >>> process_village_population(T, cases) [5, 10, 15, 20] >>> T = 1 >>> cases = [{ ... 'N': 0, ... 'populations': [], ... 'updates': [], ... 'queries': [] ... }] >>> process_village_population(T, cases) []","solution":"def process_village_population(T, cases): results = [] for case in cases: N = case['N'] populations = case['populations'] updates = case['updates'] queries = case['queries'] # Apply each update for update in updates: L, R, P = update for i in range(L, R + 1): populations[i] += P # Answer each query for query in queries: results.append(populations[query]) return results"},{"question":"def max_non_overlapping_meetings(meetings): Calculate the maximum number of non-overlapping meetings that can be accommodated in the conference room. Args: meetings (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end times of a meeting. Returns: int: Maximum number of non-overlapping meetings. >>> max_non_overlapping_meetings([(1, 3), (2, 5), (4, 6), (6, 8)]) 3 >>> max_non_overlapping_meetings([(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_meetings([(1, 10), (2, 5), (6, 8), (5, 9)]) 2 >>> max_non_overlapping_meetings([]) 0 >>> max_non_overlapping_meetings([(0, 1)]) 1 def process_input(input_data): Process the input data to handle multiple datasets. Args: input_data (str): A string containing the input data formatted for multiple datasets. Returns: List[int]: A list of results, each representing the maximum number of non-overlapping meetings that can be scheduled for the respective dataset. >>> process_input(\\"4n1 3n2 5n4 6n6 8n0n\\") [3] >>> process_input(\\"3n1 2n2 3n3 4n0n\\") [3] >>> process_input(\\"4n1 10n2 5n6 8n5 9n0n\\") [2] >>> process_input(\\"1n0 1n0n\\") [1] >>> process_input(\\"0n\\") []","solution":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be accommodated. :param meetings: List of tuples containing start and end times of meetings. :return: Integer representing the maximum number of non-overlapping meetings. if not meetings: return 0 # Sort meetings based on their end times meetings.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping meetings count = 0 end_time = 0 # Iterate through the sorted list and check for overlaps for start, end in meetings: if start >= end_time: count += 1 end_time = end return count def process_input(input_data): Process the input data to handle multiple datasets. :param input_data: String containing input data. :return: List of results for each dataset. lines = input_data.strip().split(\\"n\\") index = 0 results = [] while index < len(lines): n = int(lines[index]) if n == 0: break index += 1 meetings = [] for _ in range(n): start, end = map(int, lines[index].split()) meetings.append((start, end)) index += 1 results.append(max_non_overlapping_meetings(meetings)) return results"},{"question":"def char_frequency(s: str) -> dict: Takes a string s and returns a dictionary representing the frequency of each character. The function ignores spaces and is case-insensitive. >>> char_frequency(\\"AaBb\\") == {'a': 2, 'b': 2} >>> char_frequency(\\"Hello World\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_frequency(\\" a B b\\") == {'a': 1, 'b': 2} >>> char_frequency(\\"\\") == {} >>> char_frequency(\\" \\") == {} >>> char_frequency(\\"AaBbCc1234!!\\") == {'a': 2, 'b': 2, 'c': 2, '1': 1, '2': 1, '3': 1, '4': 1, '!': 2}","solution":"def char_frequency(s): Takes a string s and returns a dictionary representing the frequency of each character. The function ignores spaces and is case-insensitive. freq = {} for char in s.lower(): if char != ' ': freq[char] = freq.get(char, 0) + 1 return freq"},{"question":"def can_split_with_equal_sum(arr: List[int]) -> str: Determine if it's possible to split the list into two non-empty parts with equal sums. >>> can_split_with_equal_sum([1, 2, 3, 4, 5]) 'NO' >>> can_split_with_equal_sum([2, 2, 2, 2]) 'YES'","solution":"def can_split_with_equal_sum(arr): total_sum = sum(arr) if total_sum % 2 != 0: return \\"NO\\" target_sum = total_sum // 2 current_sum = 0 for num in arr: current_sum += num if current_sum == target_sum: return \\"YES\\" return \\"NO\\""},{"question":"def process_input(input_lines): Evaluate the efficiency of the encoded transmission system by finding the smallest number in each transmission sequence. Args: input_lines (List[str]): A list of input lines where the first entry is the number of test cases followed by transmission data for each test case. Returns: List[int]: A list of smallest numbers for each test case. >>> process_input([ ... \\"3\\", ... \\"5\\", ... \\"3 1 4 1 5\\", ... \\"4\\", ... \\"10 20 30 40\\", ... \\"6\\", ... \\"-5 3 0 -2 4 1\\" ... ]) [1, 10, -5] >>> process_input([ ... \\"1\\", ... \\"3\\", ... \\"-3 -2 -5\\" ... ]) [-5] >>> process_input([ ... \\"1\\", ... \\"4\\", ... \\"8 12 5 7\\" ... ]) [5] >>> process_input([ ... \\"1\\", ... \\"5\\", ... \\"2 -4 6 -1 3\\" ... ]) [-4]","solution":"def find_smallest_number(test_cases): results = [] for i in range(test_cases): _ = input().strip() # read the length of the sequence but it's not needed sequence = list(map(int, input().strip().split())) smallest_number = min(sequence) results.append(smallest_number) return results def process_input(input_lines): test_cases = int(input_lines[0]) index = 1 results = [] for _ in range(test_cases): l = int(input_lines[index]) # read the length of the sequence but it's not needed sequence = list(map(int, input_lines[index + 1].split())) smallest_number = min(sequence) results.append(smallest_number) index += 2 return results"},{"question":"def find_second_max(nums: List[int]) -> int: Returns the second maximum value in a list of distinct integers. :param nums: List of distinct integers. :return: Second maximum value in the list. >>> find_second_max([1, 2, 3, 4, 5]) 4 >>> find_second_max([10, 20, 30]) 20 if len(nums) < 2: raise ValueError(\\"List must contain at least two elements.\\")","solution":"def find_second_max(nums): Returns the second maximum value in a list of distinct integers. :param nums: List of distinct integers. :return: Second maximum value in the list. if len(nums) < 2: raise ValueError(\\"List must contain at least two elements.\\") first_max = second_max = float('-inf') for num in nums: if num > first_max: second_max = first_max first_max = num elif num > second_max and num != first_max: second_max = num return second_max"},{"question":"def calculate_final_score(operations: List[str]) -> int: Calculates the final score of the player after applying the effects of all tiles. >>> calculate_final_score([\\"+5\\"]) 5 >>> calculate_final_score([\\"+3\\", \\"*2\\", \\"-1\\", \\"/2\\"]) 2","solution":"def calculate_final_score(operations): Calculates the final score of the player after applying the effects of all tiles. :param operations: A list of strings where each string represents an effect on the player's score. :return: The final score as an integer. score = 0 for operation in operations: operator, value = operation[0], int(operation[1:]) if operator == '+': score += value elif operator == '-': score -= value elif operator == '*': score *= value elif operator == '/': score //= value return score"},{"question":"def rotateArray(nums, k): Rotates the elements of the array to the right by k steps. Parameters: nums (List[int]): The original array of integers k (int): The number of steps to rotate the array Returns: List[int]: The array after rotating k steps >>> rotateArray([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotateArray([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotateArray([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 12) [4, 5, 1, 2, 3] >>> rotateArray([1], 1) [1] pass","solution":"def rotateArray(nums, k): Rotates the elements of the array to the right by k steps. Parameters: nums (List[int]): The original array of integers k (int): The number of steps to rotate the array Returns: List[int]: The array after rotating k steps n = len(nums) k = k % n # In case k is larger than the array size return nums[-k:] + nums[:-k]"},{"question":"def min_swaps_to_anagram(N: int, S: str, T: str) -> int: Determine the minimum number of operations required to make two strings S and T anagrams of each other. In one operation, you can swap any two characters in the string S. Args: N (int): The length of the strings. S (str): The first string. T (str): The second string. Returns: int: The minimum number of swap operations needed to make S and T anagrams. If it is not possible, return -1. >>> min_swaps_to_anagram(3, 'abc', 'bca') 2 >>> min_swaps_to_anagram(4, 'abcd', 'bcda') 3 >>> min_swaps_to_anagram(5, 'abcde', 'fghij') -1 def process_test_cases(test_cases: List[Tuple[int, str, str]]) -> List[int]: Process multiple test cases to find the minimum number of swaps needed to make S and T anagrams for each. Args: test_cases (List[Tuple[int, str, str]]): A list of tuples where each tuple contains N, S, and T. Returns: List[int]: A list of results for each test case. >>> process_test_cases([(3, 'abc', 'bca'), (4, 'abcd', 'bcda'), (5, 'abcde', 'fghij')]) [2, 3, -1]","solution":"def min_swaps_to_anagram(N, S, T): Returns the minimum number of operations required to make strings S and T anagrams. If it is not possible, returns -1. from collections import Counter # Step 1: Check if it's possible to make them anagrams by comparing character counts if Counter(S) != Counter(T): return -1 # Transform S to T swaps = 0 s_list = list(S) for i in range(N): if s_list[i] != T[i]: # Find next occurrence of T[i] in the remainder of s_list and swap forward for j in range(i+1, N): if s_list[j] == T[i]: # move s_list[j] to position i while j > i: s_list[j], s_list[j-1] = s_list[j-1], s_list[j] swaps += 1 j -= 1 break return swaps def process_test_cases(test_cases): results = [] for N, S, T in test_cases: results.append(min_swaps_to_anagram(N, S, T)) return results"},{"question":"def total_transfer_fees(test_cases): This function receives a list of test cases where each case represents the depot number N. It returns a list of the total accumulated transfer fees by the time the package reaches each depot N. >>> total_transfer_fees([1]) == [1] >>> total_transfer_fees([2]) == [3] >>> total_transfer_fees([3]) == [6] >>> total_transfer_fees([1, 2, 3]) == [1, 3, 6] >>> total_transfer_fees([1000000]) == [500000500000] >>> total_transfer_fees([1000, 5000, 10000, 1000000]) == [500500, 12502500, 50005000, 500000500000] >>> total_transfer_fees([1] * 10**5) == [1] * 10**5","solution":"def total_transfer_fees(test_cases): This function receives a list of test cases where each case represents the depot number N. It returns a list of the total accumulated transfer fees by the time the package reaches each depot N. results = [] for N in test_cases: # The total transfer fee to reach depot N is the sum of first N natural numbers total_fee = N * (N + 1) // 2 results.append(total_fee) return results"},{"question":"def transform_matrix(M: int, N: int, matrix: List[List[int]]) -> List[List[int]]: Transforms the given matrix according to the specified rules: - Each cell containing an even number remains unchanged. - Each cell containing an odd number is incremented by 1. Parameters: M (int): Number of rows in the matrix. N (int): Number of columns in the matrix. matrix (list of list of int): The matrix elements. Returns: list of list of int: The transformed matrix. >>> transform_matrix(3, 3, [[2, 3, 4], [5, 6, 7], [8, 9, 10]]) [[2, 4, 4], [6, 6, 8], [8, 10, 10]] >>> transform_matrix(2, 2, [[1, 2], [3, 4]]) [[2, 2], [4, 4]] >>> transform_matrix(1, 4, [[11, 22, 33, 44]]) [[12, 22, 34, 44]]","solution":"def transform_matrix(M, N, matrix): Transforms the given matrix according to the specified rules: - Each cell containing an even number remains unchanged. - Each cell containing an odd number is incremented by 1. Parameters: M (int): Number of rows in the matrix. N (int): Number of columns in the matrix. matrix (list of list of int): The matrix elements. Returns: list of list of int: The transformed matrix. transformed_matrix = [] for row in matrix: transformed_row = [] for cell in row: if cell % 2 == 0: transformed_row.append(cell) else: transformed_row.append(cell + 1) transformed_matrix.append(transformed_row) return transformed_matrix # Example usage: # M = 3 # N = 3 # matrix = [ # [2, 3, 4], # [5, 6, 7], # [8, 9, 10] # ] # print(transform_matrix(M, N, matrix))"},{"question":"def can_rearrange_to_meet_range(N, A, L, R): Determine if the array can be rearranged such that the sum of differences between adjacent elements falls within the given range [L, R]. >>> can_rearrange_to_meet_range(5, [3, 1, 4, 1, 5], 5, 9) \\"Possible\\" >>> can_rearrange_to_meet_range(3, [1, 2, 3], 10, 15) \\"Impossible\\"","solution":"def can_rearrange_to_meet_range(N, A, L, R): Determine if the array can be rearranged such that the sum of differences between adjacent elements falls within the given range [L, R]. A.sort() min_sum = sum(abs(A[i] - A[i-1]) for i in range(1, N)) max_sum = sum(abs(A[i] - A[0]) for i in range(1, N)) if L <= max_sum and R >= min_sum: return \\"Possible\\" return \\"Impossible\\""}]`),E={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},P={key:0,class:"empty-state"},D=["disabled"],z={key:0},F={key:1};function I(n,e,u,_,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),i(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",F,"Loading...")):(s(),i("span",z,"See more"))],8,D)):l("",!0)])}const O=c(E,[["render",I],["__scopeId","data-v-0f7fa610"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/41.md","filePath":"library/41.md"}'),M={name:"library/41.md"},G=Object.assign(M,{setup(n){return(e,u)=>(s(),i("div",null,[w(O)]))}});export{B as __pageData,G as default};
